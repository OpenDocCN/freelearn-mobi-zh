<html><head></head><body>
		<div><h1 id="_idParaDest-120"><em class="italic"><a id="_idTextAnchor163"/>Chapter 6</em>: Understanding the Swift Type System</h1>
			<p>The previous chapters have left you with a solid foundation that you can use to build great, adaptive apps on. At this point, it is a good idea to take a step back and look at the code you have written to gain a deeper understanding of Swift and how it works. This section focuses on teaching you more about Swift as a language, regardless of what you intend to build.</p>
			<p>In this chapter, you will learn about Swift's fantastic type system. Swift's type system is one of its most powerful features because it allows developers to express complex and flexible principles safely and predictably.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>Understanding available types in Swift</li>
				<li>Understanding differences in types</li>
				<li>Deciding which type to use</li>
			</ul>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor164"/>Technical requirements </h1>
			<p>For this chapter, you'll need to download Xcode version 11.4 or above from Apple's App Store. </p>
			<p>You'll also need to be running the latest version of macOS (Catalina or above). Simply search for <code>Xcode</code> in the App Store and select and download the latest version. Launch Xcode and follow any additional installation instructions that your system may prompt you with. Once Xcode has fully launched, you're ready to go.</p>
			<p>Download the sample code from the following GitHub link:</p>
			<p><a href="https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition">https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition</a></p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor165"/>Understanding available types in Swift</h1>
			<p>To write great code, you<a id="_idIndexMarker274"/> need to learn what tools are available in your toolbox. This applies to building apps and understanding the features UIKit has to offer, but it also applies to the language you use to write software in. Different languages come with various features, best practices, pros, and cons. The deeper your understanding of the language you work with is, the better the decisions you can make about the code you write. As mentioned before, Swift's type system is one of the features that make Swift such an excellent language for both experts and beginners to develop in.</p>
			<p>Before you dive into the details of Swift's types and how they compare to each other, it's essential that you know what types Swift has to offer. On a high level, you can argue that Swift has two types:</p>
			<ul>
				<li>Reference types</li>
				<li>Value types</li>
			</ul>
			<p>Let's have a closer look at each type to see what they mean, how they work, and ho<a id="_idTextAnchor166"/>w you can use them.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor167"/>Working with reference types</h2>
			<p>The types you <a id="_idIndexMarker275"/>have seen so far in this book were mostly, if not all, reference<a id="_idIndexMarker276"/> types. Two types of objects are classified as reference types:</p>
			<ul>
				<li>Classes</li>
				<li>Closures</li>
			</ul>
			<p>You have seen both of these object types in this book already. For instance, all the <code>UIViewController</code> subclasses you have created are reference types. All the closures that you used as callbacks or to perform animations are also reference types.</p>
			<p>So, what does it mean if something is a reference type, and why should it matter to you? Well, reference types come with behavior that can be both convenient and very frustrating depending on what you are trying to achieve in your code.</p>
			<p>One feature that is unique to reference types and classes is the ability to subclass. The only type that can inherit functionality from another object is a class. This will be covered in more depth when you learn about the differences between types, but it's good to be aware of this information already. Let's examine reference types up close by writing some code in a playground.</p>
			<p>Create a new playground project in Xcode and give it any name you like. Then, add the following code:</p>
			<pre>class Pet {
    var name: String
    
    init(name: String) {
        self.name = name
    }
}
func printName(for pet: Pet) {
    print(pet.name)
}
let cat = Pet(name: "Jesse")
printName(for: cat)</pre>
			<p>Likely, you're not <a id="_idIndexMarker277"/>too excited about this little snippet of code. All it <a id="_idIndexMarker278"/>does is define a new <code>Pet</code> class, make an instance of it, and then pass that instance into <code>printName(for:)</code>. However, this code is extremely well-suited to illustrating what a reference type is.</p>
			<p>When you call <code>printName(for: cat)</code>, you pass a <em class="italic">reference</em> to your <code>cat</code> instance to <code>printName(for:)</code>. This means that it is possible for anybody who gets ahold of this reference to make changes to the object that is referenced. If this sounds confusing, that's okay.</p>
			<p>Add the following code to the playground you have created, and then run it:</p>
			<pre>func printName2(for pet: Pet) {
    print(pet.name)
    pet.name = "Pugwash"
}
let dog = Pet(name: "Astro")
printName2(for: dog)
print(dog.name)</pre>
			<p>What do you notice in the console after running this? </p>
			<p>If you noticed that the dog's name changes from <code>Astro</code> to <code>Pugwash</code>, you have just observed what it means to pass a reference to something around. </p>
			<p>Since <code>printName2(for:)</code> received a reference to your <code>Pet</code> instance, it was able to change its name. If you have programmed in other languages, this might be obvious to you. If not, this might be very surprising.</p>
			<p>One more thing you <a id="_idIndexMarker279"/>should note is that <code>dog</code> was declared as a <a id="_idIndexMarker280"/>constant. Regardless, you were able to change the name of your instance from <code>Astro</code> to <code>Pugwash</code>. </p>
			<p>If you think this is obvious, add the following code to your playground and run it:</p>
			<pre>let point = CGPoint(x: 10, y: 10)
point.x = 10</pre>
			<p>This code is very similar to what you did with the <code>Pet</code> instance. You make a constant instance of a thing, and then you change one of its properties. This time, however, when you try to run your playground, you should see the following error:</p>
			<pre>Cannot assign to property: 'point' is a 'let' constant</pre>
			<p>Even though the code you implemented so far is pretty short, it does a great job of demonstrating reference types. You have currently seen two properties of a reference type in action:</p>
			<ul>
				<li>Anybody that receives an instance of a reference type can mutate it.</li>
				<li>You can change properties on a reference type, even if the property that holds onto the reference type is declared as a constant.</li>
			</ul>
			<p>These two characteristics are typical of reference types. The reason reference types work like this is that a variable or constant that is assigned a reference type <em class="italic">does not contain or own</em> the object. The constant or variable only points to an address in memory where the instance is stored.</p>
			<p>Any time you create an instance of a reference type, it is written to RAM, where it will exist at a particular address. RAM is a special type of memory that is used by computers, such as an iPhone, to temporarily store data that is used by a certain program. </p>
			<p>When you assign an instance of a reference type to a property, the property will have a <strong class="bold">pointer</strong> to the memory address for this instance. Let's have another look at the following line of code:</p>
			<pre>let dog = Pet(name: "Astro")</pre>
			<p>The <code>dog</code> constant now points to a particular address in memory where the <code>Pet</code> instance is stored. You are allowed to change properties on the <code>Pet</code> instance as long as the underlying<a id="_idIndexMarker281"/> memory<a id="_idIndexMarker282"/> address isn't changed. </p>
			<p>In fact, you could theoretically put something entirely different at that memory address, and <code>let dog</code> won't care because it still points to the same address.</p>
			<p>For this same reason, it is possible for <code>printName2(for:)</code> to change a pet's name. Instead of passing it an instance of <code>Pet</code>, you pass it the memory address at which the instance is expected to exist. It's okay for <code>printName2(for:)</code> to make changes to the <code>Pet</code> instance because it doesn't change the underlying address in memory.</p>
			<p>If you tried to assign a new instance to <code>dog</code> by typing the following, you would get an error:</p>
			<pre>dog = Pet(name: "Iro")</pre>
			<p>The reason this would cause an error is that you can't change the memory address <code>dog</code> points to since it's a constant.</p>
			<p>Now that you know what a reference type is and how it works, you might have already concluded<a id="_idIndexMarker283"/> that <code>CGPoint</code> that you saw in the preceding example<a id="_idTextAnchor168"/><a id="_idIndexMarker284"/> must be a value type. Next, let's see what value types are all about.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor169"/>Working with value types</h2>
			<p>In the examples <a id="_idIndexMarker285"/>for references types, you saw the following<a id="_idIndexMarker286"/> snippet of code:</p>
			<pre>let point = CGPoint(x: 10, y: 10)
point.x = 10</pre>
			<p>At first sight, you might expect a value type to be a special kind of class because it looks like this snippet creates an instance of a class called <code>CGPoint</code>. You would be right in your observation, but your conclusion is wrong. <code>CGPoint</code> is not a class at all.</p>
			<p>Classes are inherently reference types, and they can't ever be something else. So, what are value types, then?</p>
			<p>There are two types of objects that are considered to be value types:</p>
			<ul>
				<li>Stucts</li>
				<li>Enums</li>
			</ul>
			<p>These two types are both very different, so let's make sure that you understand the basics of value types first, and then you'll learn what each of these two types is.</p>
			<p>Let's have a look at the <code>Pet</code> example again, but use a struct instead of a class. </p>
			<p>Create a new playground page in Xcode, again naming this anything you like.</p>
			<p>Once created, add the following code:</p>
			<pre>struct Pet {
    var name: String
}
func printName(for pet: Pet) {
    print(pet.name)
    pet.name = "Jesse"
}
let dog = Pet(name: "Astro")
printName(for: dog) 
print(dog.name)</pre>
			<p>You will immediately notice that Xcode complains. </p>
			<p>The error you should see in the console tells you that <code>pet</code> is a <code>let</code> constant and you are not allowed to change its name. You can turn <code>pet</code> into a variable by updating <code>printName</code>, as follows:</p>
			<pre>func printName(for pet: Pet) {
    var pet = pet
    print(pet.name)
    pet.name = "Jesse"
}</pre>
			<p>If you run your <a id="_idIndexMarker287"/>playground now, make sure to look at the console<a id="_idIndexMarker288"/> closely. You'll notice that the pet's name remains unchanged in the second print. </p>
			<p>This demonstrates one of the key features of a value type. Instead of passing a reference to an address in memory around, a copy of the object is passed around. This explains why you aren't allowed to change properties on a value type that is assigned to a constant. </p>
			<p>Changing that property would change the value type's value, and it would, therefore, change the value of the constant. This also means that when you pass <code>dog</code> to <code>printName</code>, you pass a copy of the <code>Pet</code> instance to <code>printName</code>, meaning that any changes made to the instance are local to the <code>printName</code> function and won't be applied to <code>dog</code>, in this case.</p>
			<p>This behavior makes using value types extremely safe because it's tough for other objects or functions to make unwanted changes to a value type. Also, if you define something as a constant, it truly is a constant. Another characteristic of value types is that they're typically very fast and lightweight because they can exist on the stack, while reference types exist <a id="_idIndexMarker289"/>on the heap. You'll learn more about this later <a id="_idIndexMarker290"/>when we compare reference types and value types.</p>
			<p>Now that you have a basic understanding of value types, let's have a look at the specific value types.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor170"/>Understanding structs</h2>
			<p>Structs are similar to<a id="_idIndexMarker291"/> classes in the way you define them. If you look at the <code>Pet</code> class you defined earlier, it might be easy to miss the fact that it's a struct. If you pay close attention, you will notice one big difference, though: you didn't have to write an initializer for the struct! Swift can automatically generate initializers for structs. This is extremely convenient and can save you a lot of typing for larger structs.</p>
			<p>Structs also can't inherit functionality from other objects. This means that structs always have a very flat and transparent set of properties and methods. This allows the compiler to make optimizations to your code that make structs extremely lightweight and fast.</p>
			<p>A struct can, however, conform to protocols. The Swift standard library is full of protocols that define features for many of the built-in types, such as <code>Array</code>, <code>Dictionary</code>, and <code>Collection</code>. Most of these built-in types are implemented as structs that adopt one or more protocols.</p>
			<p>One last thing you need to understand about structs is that they are very strict about whether they can be modified. Consider a struct that looks as follows:</p>
			<pre>struct Car {
    var fuelRemaining: Double
    
    func fillFuelTank() {
        fuelRemaining = 1
    }
}</pre>
			<p>This struct will cause the compiler to throw an error. </p>
			<p>A struct itself is immutable by default, which means you cannot change any of its values. It's up to you to make it explicit to the compiler when a method can mutate or change a struct. You do this by adding the <code>mutating</code> keyword to a function, as follows:</p>
			<pre>mutating func fillFuelTank() {
    fuelRemaining = 1
}</pre>
			<p>When you create a constant instance of <code>Car</code> and call <code>fillFuelTank()</code> on it, the compiler will error again. If you call a mutating function on a <code>let</code> instance, you mutate the instance, meaning<a id="_idIndexMarker292"/> the value of the property would change. Because of this, you can only call mutating functions on variable properties.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor171"/>Understanding enums</h2>
			<p>An enum is a type that <a id="_idIndexMarker293"/>holds a finite set of predefined values. Enums are often used to represent a particular state or result of an operation. The best way to learn what this means is to look at an example of an enum that represents the state of a traffic light:</p>
			<pre>struct TrafficLight {
    var state: TrafficLightState
}
enum TrafficLightState {
    case green
    case yellow
    case red
}</pre>
			<p>This sample shows a <code>TrafficLight</code> struct that has a <code>state</code> property. The type of this property is <code>TrafficLightState</code>, which is an enum. </p>
			<p><code>TrafficLightState</code> defines three possible states for a traffic light. This is very convenient because an enum such as this eliminates the possibility of a bad state because the compiler can now enforce that you never end up with an invalid value.</p>
			<p>Enums can also contain properties and methods, just like structs can. However, an enum can also have an <em class="italic">associated value</em>. This means that each possible case can have a representation in a different type, such as a string. </p>
			<p>If you modify <code>TrafficLightState</code>, as shown here, it will have <code>String</code> for <code>rawValue</code>:</p>
			<pre>enum TrafficLightState: String {
    case green
    case yellow
    case red
}</pre>
			<p>If Swift can infer the raw <a id="_idIndexMarker294"/>value, you don't have to do anything more than add the type of the raw value to the enum's type declaration. In this sample, the raw value for the <code>green</code> enum case will be the <code>green</code> string. This can be convenient if you need to map your enum to a different type – for instance, to set it as a label's text.</p>
			<p>Just like structs, enums cannot inherit functionality from other objects, but they can conform to protocols. You make an enum conform to a protocol with an extension, just like you would do for classes and structs.</p>
			<p>This wraps up the exploration of value types. Now that you know what value types and reference types are, let's explore some of their differences!</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor172"/>Understanding differences in types</h1>
			<p>Being aware of the <a id="_idIndexMarker295"/>available types in Swift – knowing their similarities and, more importantly, their differences – will help you make better decisions about the way you write your code. The preceding segments have listed several properties of value types and reference types. More specifically, you learned a lot about classes, structs, and enums. Closures are also a reference type because they get passed around by their location in memory, rather than their value, but there isn't much else to say about them in this context.</p>
			<p>The most obvious comparison you can make is probably between structs and classes. They look very similar, but they have very different characteristics, as you have already seen. Enums are a special type altogether; they represent a value from a fixed number of possible values but are very similar to structs otherwise.</p>
			<p>The most important difference you need to understand is the general difference between value types<a id="_idIndexMarker296"/> and reference types, and the difference between structs and classes specifically. Let's have a look at value types and reference types first, so you have the general picture. Then, you'll learn about the specific differen<a id="_idTextAnchor173"/>ces between structs and classes.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor174"/>Comparing value types to reference types</h2>
			<p>When comparing<a id="_idIndexMarker297"/> value types to reference types, it is essential<a id="_idIndexMarker298"/> to distinguish between the differences you can see as a developer and the differences that are internal to Swift and the way your app will end up working. Knowing these details will ensure that you can make a well-informed decision that considers all the implications instead of only focusing on memory usage or developer convenience.</p>
			<p>Let's examine the more obvious and visible differences first. <a id="_idTextAnchor175"/>Afterward, you will learn about the memory implications for each type.</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor176"/>Differences in usage</h2>
			<p>Create a new<a id="_idIndexMarker299"/> playground, once again naming it anything you like, and add the following code:</p>
			<pre>protocol PetProtocol {
    var name: String { get }
    var ownerName: String { get set }
    
}
class Animal {
    let name: String
    init(name: String) {
        self.name = name
    }
}
class Pet: Animal, PetProtocol {
    var ownerName: String
    
    init(name: String, ownerName: String) {
        self.ownerName = ownerName
        super.init(name: name)
    }
}</pre>
			<p>This code defines a <code>PetProtocol</code> that requires two properties to exist on all objects that conform to this protocol. The <code>name</code> property is defined as a constant since it only needs it to be<a id="_idIndexMarker300"/> gettable, and <code>ownerName</code> is a variable since it requires both <code>get</code> and <code>set</code>. The code also defines an <code>Animal</code> and <code>Pet</code> class. <code>Pet</code> is a subclass of <code>Animal</code>, and it conforms to <code>PetProtocol</code> because <code>Animal</code> satisfies the <code>name</code> constant requirement and <code>Pet</code> itself satisfies the <code>ownerName</code> variable.</p>
			<p>Try changing the <code>class</code> declarations to <code>struct</code>. Your playground will not compile now because structs cannot inherit from other objects as classes can. This is a limitation that is sometimes frustrating because you can end up with a lot of code duplication. Imagine that, in addition to <code>Pet</code>, you would like to create more types of animals, such as a <code>WildAnimal</code> or <code>SeaCreature</code>. This would be easy to achieve with classes because you can inherit from <code>Animal</code>. This is not possible with structs, so you would implement all these types as structs they would need to duplicate their <code>Animal</code> logic.</p>
			<p>Another difference between value types and reference types is how they act when they are passed <a id="_idIndexMarker301"/>around. Add the following code to your playground:</p>
			<pre>class ImageInformation {
    var name: String
    var width: Int
    var height: Int
    
    init(name: String, width: Int, height: Int) {
        self.name = name
        self.width = width
        self.height = height
    }
}
struct ImageLocation {
    let location: String
    let isRemote: Bool
    var isLoaded: Bool
}
let info = ImageInformation(name: "ImageName", width: 100, height: 100)
let location = ImageLocation(location: "ImageLocation", isRemote: false, isLoaded: false)</pre>
			<p>The declarations for <code>info</code> and <code>location</code> look very similar, but their underlying types are entirely different. Try writing a function that takes both <code>ImageLocation</code> and <code>ImageInformation</code> as an argument. Then, try updating the <code>isLoaded</code> property of <code>location</code> and changing the <code>name</code> property of <code>info</code>. The compiler will complain when you try to set <code>isLoaded</code> because the argument for <code>ImageLocation</code> is <code>let constant</code>. The reason for this was described earlier in the discussion on value types.</p>
			<p>Value types are passed around by value, meaning that changing the property of the argument will change the value altogether. Arguments for a function are always constants. This might not be obvious when you use a reference type, though, because it is perfectly fine to change the <code>name</code> property on <code>ImageInformation</code> inside of a function. This is because you don't pass the entire value around when you pass a reference type to a function; you pass the reference to the memory address around. This means that instead of the value being a constant, the underlying memory address is a constant. This, in turn, means that you can change whatever is in memory as much as you like; you just can't change the address that a constant points to.</p>
			<p>Imagine that you need to drive to somebody's house and they send you the address where they live. This <a id="_idIndexMarker302"/>is what it's like to pass around a reference type. Rather than sending you their entire house, they send you the address for their house. While you are driving to their house, the house can change in many ways. The owner could paint it, or replace the windows or doors, anything. In the end, you will still find the house because you received the address for this house, and, as long as the owner doesn't move to a different address, you will find the correct house.</p>
			<p>If you change this analogy to use value types, the person whose house you're looking for will simply send you a full copy of their house. So, rather than you driving toward their house based on the address, they won't give you an address; they will just send you their whole house. If the owner makes changes to their copy of the house, you won't be able to see them reflected on your copy of the house unless they send you a new copy. This is also true for any modifications you make to your copy of the house.</p>
			<p>You can imagine that in some cases, it can be very efficient to send somebody a copy of something rather than the address. The example of a house might be a bit extreme, but I'm pretty sure that if you order a parcel, you would much rather receive the parcel itself than receiving an address to fetch the parcel. This sort of efficiency is what you will learn about next by comparing how va<a id="_idTextAnchor177"/>lue types and reference types behave in terms of memory allocation.</p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor178"/>Deciding which type to use</h1>
			<p>Choosing the wrong type of object to use in your application can have bad implications for your app on several levels. For instance, your app could suffer from unwanted side effects when a reference type is modified in some unexpected place. Or, you could end up with a lot of duplicated logic if you use a struct instead of a class in certain places. Your app could even suffer in terms of performance when you choose a slow reference type where a value type would have been a better choice.</p>
			<p>You should always evaluate what type of object is best suited for your current use case to make sure your code strikes a balanced trade-off between maintainability and performance.</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor179"/>When should I use a reference type?</h2>
			<p>A great time to use a<a id="_idIndexMarker303"/> reference type is when you are subclassing a built-in class, such as <code>UIViewController</code>. In these cases, there is no point in fighting the system because that would definitely do more harm than good. Another time to use a reference type is when you are creating your own delegate protocols.</p>
			<p>Delegates are best implemented as weak reference types. This means that the object that acts as a delegate is referenced weakly by an object to avoid memory leaks.</p>
			<p>Because value types are passed around by making copies, it does not make sense to have a weak reference to them. In this case, your only choice is to use a reference type.</p>
			<p>You also need a reference type if it doesn't make sense to pass around copies of something. If you think back to the example of driving to somebody's house, it makes a lot more sense to pass around the address of a house than to give everybody full copies of the house. You might consider the house as having an identity. </p>
			<p>This means that each house is <em class="italic">unique</em>; there is only one house with that exact address, and making copies of it makes no sense. If you are working with an object where copying it makes no sense, you likely want to implement it as a reference type, so everybody that receives an instance of that type is looking at the same instance.</p>
			<p>One last reason to choose a reference type is if it can save you a lot of typing by subclassing. A lot of people consider subclassing bad, and you can often avoid it, but sometimes it just makes a lot more sense to work with a class hierarchy. </p>
			<p>The downside is that a lot of subclasses can lead to muddy classes that contain functionality to save typing on a couple of subclasses even though the functionality is not relevant to all <a id="_idIndexMarker304"/>subclasses. But just like many tools, subclassing can be quite convenient when used correctly; it's not inherently bad to use it.</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor180"/>When to use a value type</h2>
			<p>It is often said that<a id="_idIndexMarker305"/> you should always start with a struct and change to a different type when needed. This is great advice for a lot of cases because structs are often fine for most cases. However, structs aren't the only value type, and it's always good to not default to using certain things blindly. </p>
			<p>If you need an object that represents a finite set of possible states or results, such as a network connection state, a traffic light state, or a limited set of valid configuration options for your app, you will likely need an enum. </p>
			<p>Regardless of the value semantics that make value types great, an enum is a great way to avoid typos and represent a state. It's often pretty clear when you should use an enum due to its nature.</p>
			<p>Structs are used for objects that do not have an identity. In other words, it makes sense to pass copies of it around. A good example of this is when you create a struct that can communicate with the network or a database. This struct would have no identity because it's mostly a collection of properties and methods that aren't associated with a single version of the struct.</p>
			<p>A good example of a struct is the <code>CGPoint</code> struct that you read about at the beginning of this section. <code>CGPoint</code> represents a location in a two-dimensional grid. It has no identity, and passing copies of it around makes sense. It only contains two properties, so it doesn't require any inheritance. These features make it a great candidate to be implemented as a value type.</p>
			<p>If you follow the advice of always starting with a struct, try to figure out reasons for your new object to <em class="italic">not</em> be a struct. If you find a good reason to not use a struct, then make it a class. Often, you won't be able to find a good reason to use a class instead of a struct. If this is the case, make your new object a struct; you can always switch to using a class later. It's usually <a id="_idIndexMarker306"/>harder to switch from a class to a struct due to the stricter rules regarding mutability and the lack of subclassing for structs.</p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor181"/>Summary</h1>
			<p>You learned a lot about value types and reference types in this chapter. You learned what each type is and how you can use them. You learned that you can use classes, closures, structs, and enums in Swift and that each of these object types has its own pros and cons.</p>
			<p>After learning about all types, you saw how value types and reference types compare to each other, which has shed some light on the sometimes subtle and sometimes obvious use cases for each type. You learned that structs can't be subclasses, while classes can. You also learned that passing around value types passes around copies of each instance, and passing around reference types does not copy each instance but rather passes around a pointer to the addresses in memory. Then, you learned how each type is held in memory and what this means for the performance of the objects you create.</p>
			<p>Lastly, you read about how to choose between value types and reference types by using several rules of thumb that should make choosing between structs, classes, and enums fairly straightforward without blindly picking one. The next chapter will take your Swift knowledge one step further by showing you how to write ultra-flexible code with Swift's generics.</p>
		</div>
	</body></html>