["```java\n*Reflected color                   =           Light intensity      *       Material color*\n*[R1*R2, G1*G2, B1*B2]                         [R1, G1, B1]                 [R2, G2, B2]*\n```", "```java\n    // Geometry vertex position\n    layout(location=0) in vec4 VertexPosition;\n    uniform mat4 ModelViewProjectionMatrix;  \n\n    // Ambient Light and Material information\n    uniform vec3 MaterialAmbient, LightAmbient;\n\n    // Shared calculated ambient from vertex shader\n    out vec4 FinalColor;\n    void main(){\n       // Calculate the ambient intensity \n       vec3 ambient = MaterialAmbient  * LightAmbient;\n       FinalColor   = vec4(ambient, 1.0);\n       gl_Position  = ModelViewProjectionMatrix*VertexPosition;\n    }\n    ```", "```java\n    precision mediump float;\n    in vec4 FinalColor;\n    layout(location = 0) out vec4 outColor;\n    void main() {\n    outColor = FinalColor; // Apply ambient intensity\n    }\n    ```", "```java\n    void ObjLoader::InitModel(){\n      // Compile AmbientVertex and AmbientFragment shader.\n      Many line skipped here . . . . . \n      // Use the shader program\n      glUseProgram( program->ProgramID ); \n\n      // Query uniforms for light and material \n      MaterialAmbient = GetUniform(program,(\"MaterialAmbient\");\n      LightAmbient    = GetUniform(program,\"LightAmbient\");\n\n      // Set Red colored material \n      if (MaterialAmbient >= 0)\n      { Uniform3f(MaterialAmbient, 1.0f, 0.0f, 0.0f); }\n\n      // Set white light \n      if (LightAmbient >= 0)\n      { glUniform3f(LightAmbient, 1.0f, 1.0f, 1.0f); }\n\n      // Get Model-View-Projection Matrix location\n      MVP = GetUniform(program, \"ModelViewProjectionMatrix\");\n    }\n    ```", "```java\n    layout(location = 0) in vec4  VertexPosition;\n    layout(location = 1) in vec3  Normal;\n\n    uniform mat4 ModelViewProjectionMatrix;\n    uniform mat4 ModelViewMatrix;\n    uniform mat3 NormalMatrix;\n\n    // Diffuse Light and Material information\n    uniform vec3 MaterialDiffuse, LightDiffuse;\n\n    // Position of the light source\n    uniform vec3 LightPosition;\n\n    out vec4 FinalColor; // Output color to frag. shader\n\n    void main(){\n       // Calculate normal, eye coord and light vector\n       vec3 nNormal   = normalize ( NormalMatrix * Normal );\n       vec3 eyeCoord  = vec3 (ModelViewMatrix* VertexPosition);\n       vec3 nLight    = normalize( LightPosition - eyeCoord );\n\n       // Calculate cosine Normal and light vector\n       float cosAngle = max( 0.0, dot( nNormal, nLight ));\n       vec3 diffuse = MaterialDiffuse  * LightDiffuse;\n       FinalColor   = vec4(cosAngle * diffuse, 1);\n       gl_Position = ModelViewProjectionMatrix*VertexPosition;\n    }\n    ```", "```java\n      // ObjLoader::InitModel()\n      . . . . \n      glUseProgram( program->ProgramID );\n\n      // Query Light and Material uniform for ambient comp.\n      MaterialDiffuse  = GetUniform(program, \"MaterialDiffuse\");\n      LightDiffuse     = GetUniform(program, \"LightDiffuse\");\n      LightPosition    = GetUniform(program, \"LightPosition\");\n\n      // Set Red colored diffuse material uniform \n      glm::vec3 color = glm::vec3(1.0, 0.0, 0.0);\n      if (MaterialDiffuse >= 0)\n          { glUniform3f(MaterialDiffuse,1.0, 0.0, 0.0); }\n\n      // Set white diffuse light\n      if (LightDiffuse >= 0)\n          { glUniform3f(LightDiffuse, 1.0f, 1.0f, 1.0f); }\n\n      // Set light position\n      glm::vec3 lightPosition(0.0, 0.0, 5.0);\n      glUniform3fv(LightPosition,1,(float*)&lightPosition);\n    ```", "```java\n       // ObjLoader::Render()   \n       mat3 matrix=*(TransformObj->TransformGetModelViewMatrix());\n       mat3 normalMat = glm::mat3( glm::vec3(matrix[0]),\n                     vec3(matrix[1]), glm::vec3(matrix[2]) );\n       glUniformMatrix3fv(NormalMatrix,1,GL_FALSE,\n                         (float*)&normalMat );\n       glUniformMatrix4fv( MV,1,GL_FALSE,(float*)TransformObj->\n                               TransformGetModelViewMatrix() );\n       glUniformMatrix4fv( MVP,1,GL_FALSE,(float*)TransformObj->\n       TransformGetModelViewProjectionMatrix());\n\n       // Bind with Vertex Array Object and Render\n       glBindVertexArray(OBJ_VAO_Id);    \n       glDrawArrays(GL_TRIANGLES, 0, IndexCount );\n    ```", "```java\nR = reflect( -S, N )\n```", "```java\n    #version 300 es\n    layout(location = 0) in vec4  VertexPosition;\n    layout(location = 1) in vec3  Normal;\n\n    uniform mat4    ModelViewProjectionMatrix, ModelViewMatrix;\n    uniform mat3    NormalMatrix;\n\n    // Specular Light and Material information\n    uniform vec3 MaterialSpecular, LightSpecular,LightPosition;\n       uniform float   ShininessFactor;\n    out vec4        FinalColor;\n\n    void main() \n    {\n          vec3 nNormal = normalize( NormalMatrix * Normal );\n          vec3 eyeCoord= vec3( ModelViewMatrix* VertexPosition );\n          vec3 nLight  = normalize( LightPosition - eyeCoord);\n          vec3 V       = normalize( -eyeCoord);\n          vec3 R       = reflect( -nLight, nNormal );\n\n          float sIntensity=pow(max(0.0,dot(R,V)),ShininessFactor);\n          vec3 specular= MaterialSpecular * LightSpecular;\n          FinalColor   = vec4( sIntensity * specular, 1 );\n\n          gl_Position  = ModelViewProjectionMatrix*VertexPosition;\n    }\n    ```", "```java\n        // ObjLoader::InitModel()\n        . . . . .  \n\n        if (MaterialSpecular >= 0)\n              { glUniform3f(MaterialSpecular, 1.0, 0.5, 0.5); }\n\n        if (LightSpecular >= 0)\n              { glUniform3f(LightSpecular, 1.0, 1.0, 1.0); }\n\n        if (ShininessFactor >= 0)\n              { glUniform1f(ShininessFactor, 40); }\n\n        if (LightPosition >= 0){\n           glm::vec3 lightPosition(0.0, 0.0, 10.0);\n              glUniform3fv(LightPosition,1,&lightPosition);\n        }\n    ```", "```java\n// No change in the global variables\n. . . . . .\nvoid main() \n{\n   vec3 nNormal = normalize( NormalMatrix * Normal );\n   vec3 eyeCoord= vec3( ModelViewMatrix * VertexPosition );\n   vec3 nLight  = normalize( LightPosition - eyeCoord);\n   vec3 V       = normalize( -eyeCoord);\n   vec3 H       = normalize (nLight + V);\n   float sIntensity = 0.0;\n   sIntensity=pow(max(0.0,dot(H,nNormal)),ShininessFactor);\n\n   vec3 specular   = MaterialSpecular * LightSpecular;\n   FinalColor      = vec4( sIntensity * specular, 1 );\n   gl_Position     = ModelViewProjectionMatrix * VertexPosition;\n }\n```", "```java\nsIntensity = pow(max(0.0, dot(H, nNormal)), ShininessFactor)\n```", "```java\n. . . . // global variables, vertex attribute and matrixes.\nvec3 GouraudShading()\n{\n    nNormal   = normalize ( NormalMatrix * Normal );\n    eyeCoord  = vec3 ( ModelViewMatrix * VertexPosition );\n    nLight    = normalize( LightPosition - eyeCoord );\n\n    // Diffuse Intensity\n    cosAngle = max( 0.0, dot( nNormal, nLight ));\n\n    // Specular Intensity\n    V       = normalize( -eyeCoord );\n    R       = reflect( -nLight, nNormal );\n    sIntensity=pow( max(0.0, dot(R, V) ), ShininessFactor);\n\n    // ADS color as result of Material & Light interaction\n    ambient = MaterialAmbient  * LightAmbient;//Ambient light\n    diffuse = MaterialDiffuse  * LightDiffuse;//Diffuse light\n    specular = MaterialSpecular*LightSpecular;//Specular light\n\n    return ambient + (cosAngle*diffuse) + (sIntensity*specular);\n}\n\nvoid main(){\n    FinalColor = vec4(GouraudShading(), 1);\n    gl_Position = ModelViewProjectionMatrix * VertexPosition;\n}\n```", "```java\n    #version 300 es\n    // Vertex information\n    layout(location = 0) in vec4  VertexPosition;\n    layout(location = 1) in vec3  Normal;\n\n    // Model View Project Normal Matrix\n    uniform mat4 ModelViewProjectionMatrix, ModelViewMatrix;\n    uniform mat3 NormalMatrix;\n\n    //Out variable shared with Fragment shader\n    out vec3 normalCoord, eyeCoord;\n\n    void main() {\n      normalCoord = NormalMatrix * Normal;\n      eyeCoord    = vec3(ModelViewMatrix * VertexPosition);\n      gl_Position = ModelViewProjectionMatrix * VertexPosition;\n    }\n    ```", "```java\n    #version 300 es\n    precision mediump float;\n\n    // Material & Light property\n    uniform vec3 MaterialAmbient,MaterialSpecular,MaterialDiffuse; \n    uniform vec3 LightAmbient, LightSpecular, LightDiffuse;\n    uniform float   ShininessFactor;\n\n    uniform vec3 LightPosition;\n\n    in vec3    normalCoord;\n    in vec3    eyeCoord;\n\n    layout(location = 0) out vec4 FinalColor;\n\n    vec3 normalizeNormal, normalizeEyeCoord, normalizeLightVec, V, R, ambient, diffuse, specular;\n    float sIntensity, cosAngle;\n\n    vec3 PhongShading()\n    {\n      normalizeNormal   = normalize(normalCoord);\n      normalizeEyeCoord = normalize(eyeCoord);\n      normalizeLightVec = normalize(LightPosition-eyeCoord);\n\n      // Diffuse Intensity\n      cosAngle = max(0.0,\n                    dot(normalizeNormal,normalizeLightVec));\n\n      // Specular Intensity\n      V = -normalizeEyeCoord; // Viewer's vector\n      R = reflect(-normalizeLightVec, normalizeNormal);\n      sIntensity = pow(max(0.0,dot(R,V)), ShininessFactor);\n\n      ambient    = MaterialAmbient  * LightAmbient;\n      diffuse    = MaterialDiffuse  * LightDiffuse;\n      specular   = MaterialSpecular * LightSpecular;\n\n      return ambient+(cosAngle*diffuse)+(sIntensity*specular);\n    }\n\n    void main() {\n      FinalColor = vec4(PhongShading(), 1.0);\n    }\n    ```", "```java\n    vec3 PhongShading(){\n        normalizeNormal   = normalize( normalCoord );\n        normalizeEyeCoord = normalize( eyeCoord );\n        // Calculate Point Light Direction\n        normalizeLightVec = normalize( LightPosition - eyeCoord );\n        . . . . . .\n        // Calculate ADS Material & Light\n        . . . . . .\n        return ambient+(cosAngle*diffuse)+(sIntensity*specular);\n    }\n    ```", "```java\n    vec3 PhongShading(){\n        normalizeNormal   = normalize( normalCoord );\n        normalizeEyeCoord = normalize( eyeCoord );\n        // Calculate Direction Light Direction\n        normalizeLightVec = normalize( LightPosition );\n        . . . . . .\n        // Calculate ADS Material & Light\n        . . . . . .\n        return ambient+(cosAngle*diffuse)+(sIntensity*specular);\n    }\n    ```", "```java\n    // Many line skipped\n    . . . . . \n    // Light uniform array of 4 elements containing light \n    // position and diffuse color information.\n    uniform vec3    LightPositionArray[4];\n    uniform vec3    LightDiffuseArray[4];\n    uniform float   ShininessFactor;\n\n    vec3 PhongShading( int index )\n    {\n        normalizeNormal   = normalize( normalCoord );\n        normalizeEyeCoord = normalize( eyeCoord );\n        normalizeLightVec = normalize\n        (LightPositionArray[index] - eyeCoord );\n\n        cosAngle = max(0.0,dot(normalizeNormal,normalizeLightVec));\n\n        V = -normalizeEyeCoord; // Viewer's vector\n        R =reflect(-normalizeLightVec,normalizeNormal);//Reflectivity\n        sIntensity = pow( max( 0.0, dot( R, V ) ), ShininessFactor );\n\n        ambient   = MaterialAmbient * LightAmbient;\n        diffuse = MaterialDiffuse * LightDiffuseArray[index];\n        specular  = MaterialSpecular * LightSpecular;\n\n        return ambient+(cosAngle*diffuse)+(sIntensity*specular);\n    }\n\n    void main() {\n       vec4 multipleLightColor = vec4( 0.0 );\n       for (int i=0; i<4; i++){\n          multipleLightColor += vec4(PhongShading(i),1.0);\n       }\n       FinalColor = multipleLightColor;\n    }\n    ```", "```java\n       // Inside ObjLoader::InitModel()\n       // Compile and  use Multiple Light Shade Program\n       glUseProgram( program->ProgramID );\n       // Get Material & Light uniform variables from shaders\n       float lightpositions[12]={{-10.0,0.0,5.0}, {0.0,10.0,5.0}, {10.0,0.0,5.0},{0.0,-10.0,5.0}};\n       glUniform3fv(LightPositionArray,\n       sizeof(lightpositions)/sizeof(float), lightpositions);\n\n       float lightdiffusecolors[12]={{1.0,0.0,0.0}, {0.0,1.0,0.0},{1.0,0.0,0.0}, {0.0,1.0,0.0} };\n       glUniform3fv(LightDiffuseArray, sizeof(lightdiffusecolors)/ \n       sizeof(float), lightdiffusecolors);\n    ```", "```java\nvec3 GouraudShading( bool frontSide ){\n  normalizeNormal   = normalize ( normalCoord );\n  normalizeLightVec = normalize ( LightPosition - eyeCoord );\n if ( frontSide ) // Diffuse Intensity\n { cosAngle=max(0.0, dot(normalizeNormal,normalizeLightVec)); }\n else\n { cosAngle=max(0.0, dot(-normalizeNormal,normalizeLightVec));}\n\n  V = normalize( -eyeCoord );\n  R = reflect(-normalizeLightVec, normalizeNormal);\n  sIntensity = pow(max(0.0,dot(R,V)), ShininessFactor);\n ambient    = MaterialAmbient  * LightAmbient; // Net Ambient\n specular   = MaterialSpecular * LightSpecular;// Net Specular\n if ( frontSide ) // Front and back face net Diffuse color\n { diffuse=MaterialDiffuse*LightDiffuse; }\n else\n { diffuse=MaterialDiffuseBackFace*LightDiffuse; }\n\n  return ambient + (cosAngle*diffuse) + (sIntensity*specular);\n}\n\nvoid main() {\n if (gl_FrontFacing)\n { FinalColor = vec4(GouraudShading(true), 1.0); }\n else\n { FinalColor = vec4(GouraudShading(false), 1.0); }\n}\n```"]