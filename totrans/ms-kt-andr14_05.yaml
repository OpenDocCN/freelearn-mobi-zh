- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Design with Material Design 3
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用材料设计 3 进行设计
- en: Material Design is a design system developed by Google. It helps us create beautiful
    UIs. It provides a set of guidelines and components for us to use as we’re developing
    our Android apps.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 材料设计是由谷歌开发的设计系统。它帮助我们创建美观的用户界面。它为我们提供了一套指南和组件，以便我们在开发安卓应用时使用。
- en: In this chapter, we’ll introduce ourselves to **Material 3**. We will also cover
    the features that Material 3 offers. Lastly, we will learn how to use Material
    3 in our Android apps and some of the components in Material 3.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍**Material 3**。我们还将介绍 Material 3 提供的特性。最后，我们将学习如何在安卓应用中使用 Material
    3 以及 Material 3 中的某些组件。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主要内容：
- en: Material Design 3 and its features
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材料设计 3 及其特性
- en: Using Material Design 3 in our apps
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的应用中使用材料设计 3
- en: Building for large screens and foldables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为大屏幕和可折叠设备构建
- en: Making our app accessible
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使我们的应用易于访问
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the instructions in this chapter, you will need to have Android Studio
    Hedgehog or later ([https://developer.android.com/studio](https://developer.android.com/studio))
    downloaded.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章中的说明，您需要下载 Android Studio Hedgehog 或更高版本([https://developer.android.com/studio](https://developer.android.com/studio))。
- en: You can find the code for this chapter at [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfour](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfour).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfour](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfour)找到本章的代码。
- en: Material Design 3 and its features
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 材料设计 3 及其特性
- en: 'The release of **Material Design 3** (**Material 3**) came with lots of new
    features to help us build UIs for our apps. Here are some of the features of Material
    Design 3:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**Material Design 3**（**材料 3**）的发布带来了许多新特性，帮助我们为应用构建用户界面。以下是 Material Design
    3 的部分特性：'
- en: '**Dynamic color**: This is a color system that sets the color of our apps to
    the color of the user’s wallpaper. The System UI also adapts to this color. This
    enables users to have that personalized feel for their apps. Please note that
    dynamic color only works for Android 12 and above devices.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态颜色**：这是一个将我们应用的颜色设置为用户壁纸颜色的颜色系统。系统界面也会适应这种颜色。这使得用户能够拥有个性化的应用体验。请注意，动态颜色仅适用于
    Android 12 及以上设备。'
- en: '**More components**: Material 3 has a new set of improved components that are
    available for use. Some components have new UIs and others have been added to
    the APIs.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更多组件**：Material 3 提供了一组新的改进组件，可供使用。一些组件有新的用户界面，而其他组件则被添加到 API 中。'
- en: '**Simplified typography**: Material 3 has a much more simplified naming and
    grouping for typography. We have the following types: **display**, **headline**,
    **title**, **body**, and **label**, with each supporting *small*, *medium*, and
    *large* sizes. This makes it easier for us to define styles all across our apps.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化排版**：Material 3 对排版进行了更简化的命名和分组。我们有以下类型：**显示**、**标题**、**标题**、**正文**和**标签**，每种类型都支持**小**、**中**和**大**尺寸。这使得我们更容易在应用中定义样式。'
- en: '**Improved color scheme**: The color scheme has undergone a lot of improvements
    with the addition of more color schemes to fine-grain color customization. It’s
    also way easier for us to support both dark and light color schemes in our apps.
    In addition to that, they created a new tool, Material Theme Builder ([https://m3.material.io/theme-builder](https://m3.material.io/theme-builder)),
    which allows us to generate and export dark and light theme colors for our apps.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改进的色彩方案**：色彩方案通过添加更多色彩方案以实现精细的色彩定制进行了大量改进。它还使我们更容易在应用中支持暗色和亮色方案。此外，他们还创建了一个新工具，Material
    Theme Builder ([https://m3.material.io/theme-builder](https://m3.material.io/theme-builder))，它允许我们为应用生成和导出暗色和亮色主题颜色。'
- en: '**Simplified shapes**: Similar to typography, shapes have also been simplified
    to the following: **Extra Small**, **Small**, **Medium**, **Large**, and **Extra
    Large**. All these shapes come with default values, which we can always override
    to use our own.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化形状**：类似于排版，形状也被简化为以下几种：**超小**、**小**、**中**、**大**和**超大**。所有这些形状都有默认值，我们可以随时覆盖它们以使用自己的值。'
- en: The good news for us is that from Android Studio Hedgehog onward, we have project
    templates that come set up with Material 3, which makes things easier for us.
    Even the project we created in [*Chapter 2*](B19779_02.xhtml#_idTextAnchor031)
    comes with Material 3 set up already.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说，好消息是从 Android Studio Hedgehog 版本开始，我们有了预置了 Material 3 的项目模板，这使得事情变得更容易。甚至我们在
    [*第 2 章*](B19779_02.xhtml#_idTextAnchor031) 中创建的项目也已经预先设置了 Material 3。
- en: Material 3 APIs and their predecessors offer a wide range of components for
    us to use in our apps. In the next subsection, we will be looking at some of the
    common ones.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Material 3 API 及其前身为我们提供了广泛的应用组件。在下一小节中，我们将探讨一些常见的组件。
- en: Material components
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 材料组件
- en: The Material library comes with prebuilt components that we can use to build
    common UI components. Let us look at some of the commonly used components and
    some of the updates they had in Material 3.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Material 库提供了预构建的组件，我们可以使用它们来构建常见的 UI 组件。让我们看看一些常用的组件以及它们在 Material 3 中的更新。
- en: Top app bars
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 顶部应用栏
- en: 'This is a component displayed at the top of the screen. It has a title and
    can also have some actions that are related to the screen the user is on. Some
    of the common actions are the settings icon normally at the top right of the screen.
    In Material 3, we have four types of top app bars: **center-aligned**, **small**,
    **medium**, and **large**, as shown in the following figures.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个显示在屏幕顶部的组件。它有一个标题，还可以包含与用户所在的屏幕相关的某些操作。一些常见的操作是通常位于屏幕右上角的设置图标。在 Material
    3 中，我们有四种类型的顶部应用栏：**居中对齐**、**小**、**中**和**大**，如图所示。
- en: '![Figure 4.1 – Small top app bar](img/B19779_04_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 4.1 – Small top app bar](img/B19779_04_01.jpg)'
- en: Figure 4.1 – Small top app bar
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 4.1 – Small top app bar
- en: '![Figure 4.2 – Center-aligned top app bar](img/B19779_04_02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 4.2 – Center-aligned top app bar](img/B19779_04_02.jpg)'
- en: Figure 4.2 – Center-aligned top app bar
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 4.2 – Center-aligned top app bar
- en: '![Figure 4.3 – Medium top app bar](img/B19779_04_03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 4.3 – Medium top app bar](img/B19779_04_03.jpg)'
- en: Figure 4.3 – Medium top app bar
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 4.3 – Medium top app bar
- en: '![Figure 4.4 – Large top app bar](img/B19779_04_04.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 4.4 – Large top app bar](img/B19779_04_04.jpg)'
- en: Figure 4.4 – Large top app bar
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 4.4 – Large top app bar
- en: As seen in *Figures 4.1* to *4.4*, all the top bars have the same width and
    only differ in height and positioning of the title text.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 4.1* 到 *图 4.4* 所示，所有顶部栏的宽度相同，只是在高度和标题文本的位置上有所不同。
- en: 'Let us look at the sample code for one of these top app bars:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些顶部应用栏之一的示例代码：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we have our custom composable and, inside it, we are using the `CenterAlignedTopBar`
    composable from Material 3 and passing in `Text` to the `title` composable. The
    other three (`LargeTopAppBar`, `MediumTopAppBar`, and `TopAppBar`) are similar;
    the only difference is the composable that you will use. Notice that we have the
    `@OptIn` annotation as these components are still experimental.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有我们的自定义可组合组件，并在其中使用 Material 3 的 `CenterAlignedTopBar` 可组合组件，并将 `Text`
    传递给 `title` 可组合组件。其他三个（`LargeTopAppBar`、`MediumTopAppBar` 和 `TopAppBar`）类似；唯一的区别是你会使用的可组合组件。请注意，我们使用了
    `@OptIn` 注解，因为这些组件仍然是实验性的。
- en: Next, let us look at the `FloatingActionButton` component.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `FloatingActionButton` 组件。
- en: FloatingActionButton
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FloatingActionButton
- en: 'Most apps use the component to represent a call to action that is frequently
    used in the app. For example, create a new chat in a chat app. It is normally
    positioned at the bottom right of the screen or elsewhere, depending on your use
    case. This is how we create the component:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用都使用该组件来表示在应用中经常使用的操作调用。例如，在聊天应用中创建一个新的聊天。它通常位于屏幕的右下角或其他位置，具体取决于你的用例。这就是我们创建组件的方式：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We use the `FloatingActionButton` component from the Material 3 library. We
    have the `onclick` argument on the composable and, inside the `content` lambda,
    we pass in an `Icon` composable that has an *add* icon. The preview should be
    the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用来自 Material 3 库的 `FloatingActionButton` 组件。我们在可组合组件上设置了 `onclick` 参数，并在
    `content` 拉姆达函数内部传递了一个带有 *add* 图标的 `Icon` 可组合组件。预览应该是以下内容：
- en: '![Figure 4.5 – FloatingActionButton](img/B19779_04_05.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 4.5 – FloatingActionButton](img/B19779_04_05.jpg)'
- en: Figure 4.5 – FloatingActionButton
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 4.5 – FloatingActionButton
- en: 'The `FloatingActionButton` component has these sizes: large, normal, and small,
    and you can use whichever fits your purpose.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`FloatingActionButton` 组件有这些尺寸：大、正常和小，你可以使用适合你目的的任意一个。'
- en: 'We have another type of `FloatingActionButton` component known as `ExtendedFloatingActionButton`,
    which looks like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一种名为 `ExtendedFloatingActionButton` 的 `FloatingActionButton` 组件，其外观如下：
- en: '![Figure 4.6 – ExtendedFloatingActionButton](img/B19779_04_06.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6 – 扩展FloatingActionButton](img/B19779_04_06.jpg)'
- en: Figure 4.6 – ExtendedFloatingActionButton
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – 扩展FloatingActionButton
- en: 'As seen in the preceding figure, an `ExtendedFloatingActionButton` component
    allows us to add more items to our FAB. They are wider than the normal `FloatActionButton`
    components. In this case, we have a `Text` composable with the text **New Chat**
    in addition to the icon. You can use it with or without the icon. The implementation
    for this is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，`ExtendedFloatingActionButton`组件允许我们向我们的FAB添加更多项目。它们比正常的`FloatActionButton`组件更宽。在这种情况下，我们有一个带有文本**新聊天**的`Text`可组合组件，以及一个图标。您可以使用或不用图标。此实现的代码如下：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we used the `ExtendedFloatingActionButton` component and still passed
    in the same parameters as before. The only difference is that inside the content,
    we pass in a text since the `content` lambda exposes `RowScope`, which means children
    composables will be arranged in a row.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`ExtendedFloatingActionButton`组件，并且仍然传递了之前相同的参数。唯一的不同之处在于，在内容内部，我们传递了一个文本，因为`content`lambda暴露了`RowScope`，这意味着子可组合组件将按行排列。
- en: Next, let us look at the bottom app bar components.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看底部应用栏组件。
- en: Bottom app bars
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 底部应用栏
- en: The bottom app bar components display navigation items at the bottom of the
    screen. They are normally useful for apps that have three to five primary destinations.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 底部应用栏组件在屏幕底部显示导航项。它们通常对具有三个到五个主要目的地的应用程序非常有用。
- en: 'Let us look at the code for a bottom app bar:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看底部应用栏的代码：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We use the `BottomAppBar` component and, inside the `actions` lambda, we pass
    in three `Icon` composables to represent the items we are supposed to show. This
    is how the preview of the composable will look:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`BottomAppBar`组件，并在`actions`lambda内部传递了三个`Icon`可组合组件来表示我们应该显示的项目。这是可组合组件预览将看起来如下：
- en: '![Figure 4.7 – BottomAppBar](img/B19779_04_07.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7 – BottomAppBar](img/B19779_04_07.jpg)'
- en: Figure 4.7 – BottomAppBar
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – BottomAppBar
- en: In *Figure 4**,7*, we can see we have three icons arranged horizontally.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图4*，7*中，我们可以看到有三个图标水平排列。
- en: 'Additionally, in `BottomAppBar`, we can also provision a `FloatingActionButton`
    component. We are going to use the `FloatingActionButton` component that we used
    early on. The updated component code is as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在`BottomAppBar`中，我们还可以提供`FloatingActionButton`组件。我们将使用我们之前早期使用的`FloatingActionButton`组件。更新的组件代码如下：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding code, we have used the `floatingActionButton` parameter and
    passed in `PacktFloatingActionButton()` that we created earlier. The updated preview
    will be as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了`floatingActionButton`参数，并传递了我们之前创建的`PacktFloatingActionButton()`。更新的预览将如下所示：
- en: '![Figure 4.8 – BottomAppBar with FloatingActionButton](img/B19779_04_08.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图4.8 – 带有FloatingActionButton的BottomAppBar](img/B19779_04_08.jpg)'
- en: Figure 4.8 – BottomAppBar with FloatingActionButton
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 – 带有FloatingActionButton的BottomAppBar
- en: As seen in the preceding figure, our `BottomAppBar` now has a nice `FloatingActionButton`
    to its right. The FAB is automatically positioned for you to the right.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，我们的`BottomAppBar`现在在其右侧有一个不错的`FloatingActionButton`。FAB会自动为您定位到右侧。
- en: We have looked at the different components in isolation, but what happens when
    we want to place them on one screen together? Next, we are going to look at `Scaffold`,
    which is meant for this.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经单独查看过不同的组件，但当我们将它们一起放置在一个屏幕上时会发生什么？接下来，我们将要查看`Scaffold`，它就是为了这个目的而设计的。
- en: Scaffold
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Scaffold
- en: This is a layout provided by Material Design that helps place all components
    on your screen in their desired positions with ease.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个由Material Design提供的布局，它可以帮助您轻松地将所有组件放置在屏幕上所需的位置。
- en: 'Let us look at a sample of `Scaffold` that has a top app bar, a floating action
    button, text center-aligned on the screen, and a bottom navigation bar:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个`Scaffold`的示例，它具有顶部应用栏、浮动操作按钮、屏幕上居中的文本和底部导航栏：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A lot is happening here, so let us break it down:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了很多事情，所以让我们逐一分析：
- en: The **Scaffold** composable is used to create a layout that implements the Material
    Design guidelines. It is a container that contains the top bar, bottom bar, floating
    action button, and the content.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Scaffold**可组合组件用于创建一个实现Material Design指南的布局。它是一个容器，包含顶部栏、底部栏、浮动操作按钮和内容。'
- en: The **topBar** parameter is used to specify the top bar. In this case, we are
    using the **PacktSmallTopAppBar** composable that we created earlier.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**topBar**参数用于指定顶部栏。在这种情况下，我们使用的是我们之前创建的**PacktSmallTopAppBar**可组合组件。'
- en: The **bottomBar** parameter is used to specify the bottom bar. In this case,
    we are using the **PacktBottomNavigationBar** composable.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**bottomBar** 参数用于指定底部栏。在这种情况下，我们使用的是 **PacktBottomNavigationBar** 可组合组件。'
- en: The **floatingActionButton** parameter is used to specify the floating action
    button. In this case, we are using the **PacktFloatingActionButton** composable.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**floatingActionButton** 参数用于指定浮动操作按钮。在这种情况下，我们使用的是 **PacktFloatingActionButton**
    可组合组件。'
- en: The **content** parameter is used to specify the content of the screen. In this
    case, we are using a **Column** composable that contains a **Text** composable.
    The text is centered in the column using the **verticalArrangement** and **horizontalAlignment**
    parameters. Notice that inside **Column**, we are using the **paddingValues**
    parameter to add padding to the column. This is because the **Scaffold** composable
    passes the **padding** values to the **content** parameter.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**content** 参数用于指定屏幕的内容。在这种情况下，我们使用了一个包含 **Text** 可组合组件的 **Column** 可组合组件。文本通过
    **verticalArrangement** 和 **horizontalAlignment** 参数在列中居中。请注意，在 **Column** 中，我们使用
    **paddingValues** 参数为列添加填充。这是因为 **Scaffold** 可组合组件将 **padding** 值传递给了 **content**
    参数。'
- en: 'With our `Scaffold` composable ready, let us see how its preview looks:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Scaffold` 可组合组件已经准备好了，让我们看看它的预览效果：
- en: '![Figure 4.9 – Scaffold](img/B19779_04_09.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.9 – Scaffold](img/B19779_04_09.jpg)'
- en: Figure 4.9 – Scaffold
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – Scaffold
- en: In *Figure 4**.9*, we can see that the `Scaffold` composable has added the top
    bar, bottom bar, and the floating action button to the screen. The components
    are also placed in the correct positions as per the Material Design guidelines.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 4.9* 中，我们可以看到 `Scaffold` 可组合组件已经将顶部栏、底部栏和浮动操作按钮添加到了屏幕上。组件也按照 Material Design
    指南放置在了正确的位置。
- en: We have learned about a bunch of components so far; Material 3 still offers
    more components out of the box for us. We will be using some of these components
    in the upcoming chapters of this book. To view the full list of all the components,
    go to the Material 3 Components website (https://m3.material.io/components) to
    see them and their guidelines.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了许多组件；Material 3 仍然为我们提供了更多开箱即用的组件。我们将在本书的后续章节中使用一些这些组件。要查看所有组件的完整列表，请访问
    Material 3 组件网站（https://m3.material.io/components）以查看它们及其指南。
- en: Now that we understand Material 3 and its features, let us look at how to add
    it to our apps.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Material 3 及其特性，让我们看看如何将其添加到我们的应用中。
- en: Using Material Design in our apps
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的应用中使用 Material Design
- en: 'To take advantage of the Material 3 features that we looked at in the previous
    section, we need to add it to our app. Luckily, with Android Studio Hedgehog,
    we have Material 3 templates. Even the sample apps we have been using already
    use Material 3\. So cool, right? Let us quickly scan the dependencies to understand
    what is happening:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用上一节中查看的 Material 3 特性，我们需要将其添加到我们的应用中。幸运的是，随着 Android Studio Hedgehog 的推出，我们有
    Material 3 模板。甚至我们一直在使用的示例应用也已经使用了 Material 3。真是太酷了，对吧？让我们快速扫描依赖项以了解正在发生的事情：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This dependencies block sets up several for us, including the `compose` dependencies.
    The most important one is the `androidx.compose.material3:material3` dependency.
    This is the dependency that contains the Material 3 components. We are using the
    Compose **Bill of Materials** (**BOM**) to manage our dependencies. This means
    that we do not have to specify the version of each dependency. Instead, we specify
    the version of the BOM, and it will manage the versions of the dependencies for
    us. This is the recommended way of managing dependencies in Compose. That is why
    we have not specified the version of each dependency.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个依赖关系块为我们设置了一些依赖项，包括 `compose` 依赖项。其中最重要的是 `androidx.compose.material3:material3`
    依赖项。这是包含 Material 3 组件的依赖项。我们使用 Compose **物料清单**（**BOM**）来管理我们的依赖项。这意味着我们不需要指定每个依赖项的版本。相反，我们指定
    BOM 的版本，它将为我们管理依赖项的版本。这是在 Compose 中管理依赖项的推荐方式。这就是为什么我们没有指定每个依赖项的版本。
- en: With that, our project is ready to take advantage of the Material 3 features.
    In the next subsection, we will be adding more color schemes to the app.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们的项目已经准备好利用 Material 3 的特性了。在下一小节中，我们将向应用添加更多颜色方案。
- en: Adding Material Design 3 color schemes
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 Material Design 3 颜色方案
- en: As mentioned earlier, Material 3 comes with a lot of fine-grained color schemes
    and introduces **dynamic color**. However, they are not set up with the templates
    that Android Studio generates. We will be setting them up in the next few steps.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Material 3 带有很多精细的颜色方案，并引入了**动态颜色**。然而，它们并不是与 Android Studio 生成的模板一起设置的。我们将在接下来的几个步骤中设置它们。
- en: 'Head over to the `ui/theme` package and open the `Color.kt` file, which has
    the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 转到 `ui/theme` 包，打开 `Color.kt` 文件，其中包含以下代码：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So far, this file only has a few colors defined. These colors do not cover all
    the color tokens provided by Material 3\. We will add more colors as we need them
    in the app.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，此文件只定义了少量颜色。这些颜色并不涵盖 Material 3 提供的所有颜色标记。我们将根据需要在应用程序中添加更多颜色。
- en: 'We will be using the **Material Theme Builder** tool to generate these colors.
    Let us open our browser and go to the Material Theme Builder tool ([https://m3.material.io/theme-builder](https://m3.material.io/theme-builder)).
    We will be presented with the following screen:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**材料主题构建器**工具来生成这些颜色。让我们打开我们的浏览器并转到材料主题构建器工具([https://m3.material.io/theme-builder](https://m3.material.io/theme-builder))。我们将看到以下屏幕：
- en: '![Figure 4.10 – Material Theme Builder tool](img/B19779_04_10.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.10 – 材料主题构建器工具](img/B19779_04_10.jpg)'
- en: Figure 4.10 – Material Theme Builder tool
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – 材料主题构建器工具
- en: 'This tool helps us visualize the color schemes for our apps and shows how different
    components will be themed. It makes it easier for us to customize and produce
    a consistent color scheme for our app. It has two tabs: **Dynamic** and **Custom**.
    In the **Dynamic** tab, we can select one of the preloaded colors or wallpapers
    to see how the color changes. One useful feature is that we can also add your
    own wallpaper and generate the colors based on the wallpaper.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此工具帮助我们可视化应用程序的色彩方案，并显示不同组件的主题化方式。它使我们更容易自定义并生成应用程序的一致色彩方案。它有两个选项卡：**动态**和**自定义**。在**动态**选项卡中，我们可以选择预加载的颜色或壁纸，以查看颜色如何变化。一个有用的功能是，我们还可以添加自己的壁纸，并根据壁纸生成颜色。
- en: 'In the **Custom** tab, we can select a color and the tool generates all the
    complementary colors for us based on the color we select, ensuring a harmonious
    color palette:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在**自定义**选项卡中，我们可以选择一种颜色，工具会根据我们选择的颜色生成所有互补色，确保色彩搭配和谐：
- en: '![Figure 4.11 – Material Theme Builder tool custom color](img/B19779_04_11.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.11 – 材料主题构建器工具自定义颜色](img/B19779_04_11.jpg)'
- en: Figure 4.11 – Material Theme Builder tool custom color
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – 材料主题构建器工具自定义颜色
- en: On the left, we have the **Core colors** section where we can select either
    **Primary**, **Secondary**, **Tertiary**, or **Neutral** colors for our app.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，我们有**核心颜色**部分，我们可以为我们的应用程序选择**主色**、**次色**、**三级色**或**中性色**。
- en: 'We are going to select the **Primary** color option, which opens a **Color**
    **Picker** dialog:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择**主色**选项，这将打开一个**颜色** **选择器**对话框：
- en: '![Figure 4.12 – Color Picker](img/B19779_04_12.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.12 – 颜色选择器](img/B19779_04_12.jpg)'
- en: Figure 4.12 – Color Picker
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 – 颜色选择器
- en: 'As we are changing the primary color, we will be able to see the visual preview
    change to match the color we have. Now we have our primary color ready, we are
    going to export the files so that we can use them in our project:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在更改主色，我们将能够看到视觉预览更改为匹配我们选择的颜色。现在我们已经准备好了主色，我们将导出文件，以便我们可以在项目中使用它们：
- en: '![Figure 4.13 – Export option](img/B19779_04_13.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.13 – 导出选项](img/B19779_04_13.jpg)'
- en: Figure 4.13 – Export option
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – 导出选项
- en: As seen in *Figure 4**.13*, the visual preview has changed to the color we chose.
    Click on the `ui` folder that has a `theme` folder inside containing `Color.kt`
    and `Theme.kt` files.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图 4**.13*所示，视觉预览已更改为我们选择的颜色。点击包含 `Color.kt` 和 `Theme.kt` 文件的 `ui` 文件夹中的 `theme`
    文件夹。
- en: 'Let us open the `Color.kt` file, which contains the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开包含以下代码的 `Color.kt` 文件：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can now see, we have more color additions. Let us copy these colors to
    the `Color.kt` file in our project. Next, let us open the `Theme.kt` from the
    unzipped folder.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如您现在所看到的，我们添加了更多颜色。让我们将这些颜色复制到我们项目中的 `Color.kt` 文件中。接下来，让我们打开解压缩文件夹中的 `Theme.kt`。
- en: 'We will notice it is similar to the `Theme.kt` file but it defines all the
    Material 3 color schemes. Copy the contents of this file and paste them into the
    `Theme.kt` file in our project. We are going to make minor edits to the code to
    make sure we maintain the `ChapterFourTheme` name and dynamic color logic that
    was in our theme. Next, we need to change the `DarkColorScheme` variable values
    to the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会注意到它与`Theme.kt`文件类似，但它定义了所有Material 3颜色方案。将此文件的全部内容复制并粘贴到我们项目中的`Theme.kt`文件中。我们将对代码进行一些小的编辑，以确保我们保持`ChapterFourTheme`名称和动态颜色逻辑。接下来，我们需要将`DarkColorScheme`变量的值更改为以下内容：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding code, we are using the `DarkColorScheme` function to create
    a dark color scheme. We are passing the colors that we generated using the Material
    Theme Builder tool. We will use this color scheme to create a dark theme. The
    dark color scheme variable is defined in a similar manner, and we can copy the
    values from the `Theme.kt` file from the tool and add it there too. Let us now
    look at our theme composable in wholesome:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`DarkColorScheme`函数来创建一个深色主题。我们传递使用Material Theme Builder工具生成的颜色。我们将使用此颜色方案来创建一个深色主题。深色颜色方案变量以类似的方式定义，并且我们可以从工具的`Theme.kt`文件中复制值并添加到那里。现在让我们全面查看我们的主题可组合项：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let us break down the preceding code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解前面的代码：
- en: 'The **ChapterFourTheme** composable is used to create a theme for our app.
    It takes three parameters:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ChapterFourTheme**可组合项用于为我们的应用创建一个主题。它接受三个参数：'
- en: The **darkTheme** parameter is used to specify whether the theme is dark or
    light. By default, we are using the system theme.
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**darkTheme**参数用于指定主题是深色还是浅色。默认情况下，我们使用系统主题。'
- en: The **dynamicColor** parameter is used to specify whether the theme should use
    dynamic colors. By default, we are using dynamic colors.
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dynamicColor**参数用于指定主题是否应使用动态颜色。默认情况下，我们使用动态颜色。'
- en: The **content** parameter is used to specify the content of the theme. In this
    case, we are using the **MaterialTheme** composable to create a theme for our
    app.
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**content**参数用于指定主题的内容。在这种情况下，我们使用**MaterialTheme**可组合项来为我们的应用创建一个主题。'
- en: The **colorScheme** variable is used to specify the color scheme to use. We
    are using a **when** expression to determine the color scheme to use. If the **dynamicColor**
    parameter is **true** and the device is running Android 12 or higher, we are using
    the **dynamicDarkColorScheme** or **dynamicLightColorScheme** function to create
    a dynamic color scheme. When not using dynamic colors, we fall back to the normal
    themes. If the **darkTheme** parameter is **true**, we are using the **DarkColorScheme**
    variable to create a dark color scheme. Otherwise, we are using the **LightColorScheme**
    variable to create a light color scheme.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**colorScheme**变量用于指定要使用的颜色方案。我们使用**when**表达式来确定要使用的颜色方案。如果**dynamicColor**参数为**true**且设备正在运行Android
    12或更高版本，我们将使用**dynamicDarkColorScheme**或**dynamicLightColorScheme**函数来创建一个动态颜色方案。当不使用动态颜色时，我们将回退到正常主题。如果**darkTheme**参数为**true**，我们将使用**DarkColorScheme**变量来创建一个深色主题。否则，我们将使用**LightColorScheme**变量来创建一个浅色主题。'
- en: The **view** variable is used to get the view that is using the theme.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**view**变量用于获取正在使用该主题的视图。'
- en: The **SideEffect** composable is used to execute a side effect. In this case,
    we are using it to set the status bar color and the status bar icons’ color. We
    are using the **WindowCompat** class to get **InsetsController** and set the status
    bar color and the status bar icons’ color. We are using the **colorScheme.primary**
    color to set the status bar color. We are using the **darkTheme** parameter to
    determine whether the status bar icons’ color should be light or dark.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SideEffect**可组合项用于执行副作用。在这种情况下，我们使用它来设置状态栏颜色和状态栏图标颜色。我们使用**WindowCompat**类来获取**InsetsController**并设置状态栏颜色和状态栏图标颜色。我们使用**colorScheme.primary**颜色来设置状态栏颜色。我们使用**darkTheme**参数来确定状态栏图标颜色应该是浅色还是深色。'
- en: The **MaterialTheme** composable is used to create a theme for our app. We are
    using the **colorScheme** parameter to specify the color scheme to use. We are
    using the **typography** variable to specify the typography to use.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MaterialTheme**可组合项用于为我们的应用创建一个主题。我们使用**colorScheme**参数来指定要使用的颜色方案。我们使用**typography**变量来指定要使用的排版。'
- en: 'To be able to see the changes we have made, we need to call `PacktScaffold`,
    which we created earlier inside the `MainActivity.kt` file in the `ChapterFourTheme`
    block:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够看到我们所做的更改，我们需要调用我们之前在`ChapterFourTheme`块中的`MainActivity.kt`文件内创建的`PacktScaffold`，如下所示：
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let us build and run the app. We should be able to see the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建并运行这个应用。我们应该能够看到以下内容：
- en: '![Figure 4.14 – Chapter 4 app](img/B19779_04_14.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图4.14 – 第4章应用](img/B19779_04_14.jpg)'
- en: Figure 4.14 – Chapter 4 app
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14 – 第4章应用
- en: 'Like me, you might be wondering why the app does not have the greenish color
    we set on the Material Theme Builder tool. Remember the dynamic color logic in
    our `ChapterFourTheme` composable? It is responsible for the brownish color we
    see. Look at my wallpaper settings:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我一样，你可能想知道为什么应用没有在Material Theme Builder工具上设置的绿色调。还记得我们`ChapterFourTheme`可组合中的动态颜色逻辑吗？它负责我们看到的那种棕色调。看看我的壁纸设置：
- en: '![Figure 4.15 – Wallpaper settings](img/B19779_04_15.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图4.15 – 壁纸设置](img/B19779_04_15.jpg)'
- en: Figure 4.15 – Wallpaper settings
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15 – 壁纸设置
- en: As seen in *Figure 4**.15*, my wallpaper has a brown color set. This means our
    dynamic color logic is working, and our app can adapt well to my wallpaper settings!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图4.15*所示，我的壁纸设置了棕色。这意味着我们的动态颜色逻辑正在工作，并且我们的应用可以很好地适应我的壁纸设置！
- en: We have seen how to use the Material 3 features in our app. In the next section,
    we will see how we can design UIs that work for large screens and foldables in
    Jetpack Compose.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何在我们的应用中使用Material 3功能。在下一节中，我们将看到如何设计适用于Jetpack Compose中大屏幕和可折叠设备的UI。
- en: Designing UIs for large screens and foldables
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为大屏幕和可折叠设备设计UI
- en: In recent years and with the release of Material 3, there has been an increased
    focus on tablets and foldable devices. As such, we, as developers, must make our
    apps work well on these devices. In this section, we will look at how we can make
    our apps work well on large screens and foldables. We need to ensure our apps
    adapt to the different screen sizes. Making our apps responsive provides a good
    user experience.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，随着Material 3的发布，对平板电脑和可折叠设备的关注有所增加。因此，作为开发者，我们必须确保我们的应用在这些设备上运行良好。在本节中，我们将探讨如何使我们的应用在大屏幕和可折叠设备上运行良好。我们需要确保我们的应用适应不同的屏幕尺寸。使我们的应用具有响应性可以提供良好的用户体验。
- en: 'Material 3 offers **canonical layouts** to serve as guidelines for creating
    UIs for large screens and foldables. These layouts are as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Material 3提供了**规范布局**，作为创建大屏幕和可折叠设备UI的指南。这些布局如下：
- en: '**List-detail view**: Here, we place a list of items on the left and, on the
    right, we show the details of a single item.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表-详情视图**：在这里，我们在左侧放置一个项目列表，在右侧显示单个项目的详细信息。'
- en: '**Feed**: Here, we arrange content elements such as cards in a customizable
    grid, which provides a good view of a large amount of content.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内容流**：在这里，我们将内容元素（如卡片）排列在一个可定制的网格中，这可以很好地展示大量内容。'
- en: '**Supporting pane**: Here, we organize app content into primary and secondary
    display areas. The primary area shows the main content while the secondary area
    shows the supporting content. The primary area occupies most of the screen while
    the secondary area occupies a smaller portion.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**辅助面板**：在这里，我们将应用内容组织成主要和次要显示区域。主要区域显示主要内容，而次要区域显示辅助内容。主要区域占据屏幕的大部分，而次要区域占据较小的一部分。'
- en: For us to show the different layouts, we must know the screen size of the device
    the user is using. Luckily for us, Jetpack Compose provides us with a way to get
    the screen size. We have the Material 3 **WindowSizeClass** to help us determine
    which layout to show in our app.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示不同的布局，我们必须知道用户所使用的设备的屏幕尺寸。幸运的是，Jetpack Compose为我们提供了一种获取屏幕尺寸的方法。我们有了Material
    3的**WindowSizeClass**来帮助我们确定在应用中显示哪个布局。
- en: We are going to learn how to use `WindowSizeClass` next.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要学习如何使用`WindowSizeClass`。
- en: Using WindowSizeClass
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用WindowSizeClass
- en: 'For us to use `WindowSizeClass`, we must add the following dependency to our
    app:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`WindowSizeClass`，我们必须将以下依赖项添加到我们的应用中：
- en: '[PRE12]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is the Material 3 dependency that adds `WindowSizeClass` to our project.
    Notice we are not providing a version for this dependency. This is because we
    are using the Compose BOM to manage our dependencies. The BOM will manage the
    version of this dependency for us.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Material 3依赖项，它将`WindowSizeClass`添加到我们的项目中。请注意，我们没有为这个依赖项提供版本号。这是因为我们正在使用Compose
    BOM来管理我们的依赖项。BOM将为我们管理这个依赖项的版本。
- en: '`WindowSizeClass` classifies the available screen width into three categories:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`WindowSizeClass`将可用的屏幕宽度分为三个类别：'
- en: '**Compact**: This is for devices whose width is less than 600 dp. Commonly,
    these are devices in portrait mode.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**紧凑型**：这是指宽度小于600 dp的设备。通常，这些设备处于纵向模式。'
- en: '**Medium**: This is for devices whose width is between 600 dp and 840 dp. Devices
    such as tablets and foldables in portrait mode fall into this category.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Medium**：这是指宽度在 600 dp 和 840 dp 之间的设备。横屏模式的平板电脑和可折叠设备属于这一类别。'
- en: '**Expanded**: This is for devices whose width is greater than 840 dp. Devices
    such as tablets and foldables in landscape mode, phones in landscape mode, and
    desktops fall into this category.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Expanded**：这是指宽度大于 840 dp 的设备。平板电脑和横屏模式的可折叠设备、横屏模式的手机以及桌面电脑都属于这一类别。'
- en: '`WindowSizeClass` uses `widthSizeClass` to get the width of the screen. In
    addition to `widthSizeClass`, it also has `heightSizeClass` to help us determine
    the height of the screen.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`WindowSizeClass` 使用 `widthSizeClass` 来获取屏幕宽度。除了 `widthSizeClass`，它还有一个 `heightSizeClass`
    来帮助我们确定屏幕的高度。'
- en: 'Let us look at `widthSizeClass` in action:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `widthSizeClass` 的实际应用：
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here is an explanation of what the preceding code is doing:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对前面代码的解释：
- en: The **calculateWindowSizeClass** function is used to calculate **WindowSizeClass**.
    We are passing the activity as the parameter. The function is from the **WindowSizeClass**
    APIs. It has the **widthSizeClass** and **heightSizeClass** properties, which
    we can use to get the width and height of the screen, respectively.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**calculateWindowSizeClass** 函数用于计算 **WindowSizeClass**。我们传递活动作为参数。该函数来自 **WindowSizeClass**
    API。它具有 **widthSizeClass** 和 **heightSizeClass** 属性，我们可以使用它们分别获取屏幕的宽度和高度。'
- en: 'We use **widthSizeClass** to customize our display options:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 **widthSizeClass** 来自定义我们的显示选项：
- en: For the **WindowWidthSizeClass.Compact** case, we are using **BottomNavigation**
    for navigation, and the UI should only show the list of characters
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 **WindowWidthSizeClass.Compact** 的情况，我们使用 **BottomNavigation** 进行导航，并且 UI
    应该只显示角色列表。
- en: For the **WindowWidthSizeClass.Medium** case, we are using **NavigationRail**
    for navigation, and the UI should show the list of characters and the details
    of the selected character
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 **WindowWidthSizeClass.Medium** 的情况，我们使用 **NavigationRail** 进行导航，并且 UI 应该显示角色列表和所选角色的详细信息。
- en: For the **WindowWidthSizeClass.Expanded** case, we are using **NavigationDrawer**
    for navigation. and the UI should show the list of characters and the details
    of the selected character
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 **WindowWidthSizeClass.Expanded** 的情况，我们使用 **NavigationDrawer** 进行导航，并且 UI
    应该显示角色列表和所选角色的详细信息。
- en: We have a default case where we are using **BottomNavigation** for navigation,
    and the UI should only show the list of characters
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个默认情况，其中我们使用 **BottomNavigation** 进行导航，并且 UI 应该只显示角色列表。
- en: At a glance, you can see how we take advantage of `WindowSizeClass` to customize
    our UI and navigation type based on the screen size. This is an immensely powerful
    feature that we can use to make our apps responsive. This makes sure we take advantage
    of the screen size and provide a good user experience.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一眼就能看出我们如何利用 `WindowSizeClass` 来根据屏幕大小自定义我们的 UI 和导航类型。这是一个非常强大的功能，我们可以用它来使我们的
    apps 响应。这确保了我们充分利用屏幕大小并提供良好的用户体验。
- en: The example shown in this section was a simple one. In [*Chapter 7*](B19779_07.xhtml#_idTextAnchor092)
    of this book, we will have a more detailed example where we will use `WindowSizeClass`
    to customize our UI based on the screen size.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中展示的示例很简单。在本书的 **第 7 章**（B19779_07.xhtml#_idTextAnchor092）中，我们将有一个更详细的示例，我们将使用
    `WindowSizeClass` 来根据屏幕大小自定义我们的 UI。
- en: Now that we know how to design and build apps for large screens and foldables,
    let us look at yet another important topic in this chapter, which is accessibility.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何设计和构建适用于大屏幕和可折叠设备的 apps，让我们看看本章的另一个重要主题，即可访问性。
- en: Making our app accessible
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使我们的 app 可访问
- en: 'Making the apps that we develop accessible is extremely important. It ensures
    that our apps can be used by everyone. In this section, we will look at how we
    can make our apps accessible. Jetpack Compose uses **semantics** to make our apps
    accessible. Semantics are used to describe the UI elements in our apps. They are
    used by accessibility services to make our apps accessible. Semantics are also
    used by automated testing tools to test our apps. Some of the best practices for
    making our apps accessible are as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使我们开发的 apps 可访问性非常重要。它确保我们的 apps 可以被每个人使用。在本节中，我们将探讨我们如何使我们的 apps 可访问。Jetpack
    Compose 使用 **语义** 来使我们的 apps 可访问。语义用于描述我们 apps 中的 UI 元素。它们被用于使我们的 apps 可访问的辅助服务。语义也被用于自动化测试工具来测试我们的
    apps。使我们的 apps 可访问的一些最佳实践如下：
- en: We should always ensure that all clickable or touchable elements or those that
    require user interaction are large enough to be easily tapped or clicked. Most
    Material components out of the box have a default size that is large enough to
    be easily tapped or clicked. If we must size by ourselves, we should ensure that
    the size is at least 48 dp by 48 dp.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该始终确保所有可点击或可触摸的元素，或者那些需要用户交互的元素，足够大，以便容易点击或触摸。大多数Material组件默认大小足够大，可以轻松点击或触摸。如果我们必须自行设置大小，我们应该确保大小至少为48
    dp x 48 dp。
- en: 'We should add content descriptions to our composables. Components such as **Icon**
    and **Image** provide this argument to describe visual elements to accessibility
    services. We should always provide a content description for these components.
    The following is an example:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该为我们的可组合组件添加内容描述。例如，**Icon**和**Image**组件提供了这个参数来描述视觉元素给辅助服务。我们应该始终为这些组件提供内容描述。以下是一个例子：
- en: '[PRE14]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can see in the preceding code that we are using the `contentDescription`
    parameter to provide a description for `Icon`. This is a good practice that we
    should always follow.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以从前面的代码中看到，我们正在使用`contentDescription`参数为`Icon`提供描述。这是一个我们应该始终遵循的好习惯。
- en: 'We should label our clickable elements. We can pass a clickable label to the
    clickable modifiers. This enables us to add descriptions to our clickable elements.
    The following is an example:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该为我们的可点击元素添加标签。我们可以将可点击标签传递给可点击修饰符。这使我们能够为我们的可点击元素添加描述。以下是一个例子：
- en: '[PRE15]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding example, we are using the `onClickLabel` parameter to add a
    description to the `Text` composable. This is a good practice that we should always
    follow.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用`onClickLabel`参数为`Text`可组合组件添加描述。这是一个我们应该始终遵循的好习惯。
- en: 'By using semantics, we can also describe headers. Headers are used to describe
    the content that follows them. We can use semantics to add a header to our composables.
    The following is an example:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用语义，我们还可以描述标题。标题用于描述其后的内容。我们可以使用语义为我们的可组合组件添加标题。以下是一个例子：
- en: '[PRE16]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can additionally provide information about the state of our composables.
    For example, we can provide information about the state of a button. We can use
    semantics to provide this information. The following is an example:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以提供有关我们可组合组件状态的信息。例如，我们可以提供有关按钮状态的信息。我们可以使用语义来提供这些信息。以下是一个例子：
- en: '[PRE17]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This helps us inform our users about the state of our composables.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这有助于我们向用户告知我们可组合组件的状态。
- en: 'For some groups of components, we can also use the **mergeDescendants** parameter
    to merge the semantics of the children composables. The following is an example:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于某些组件组，我们也可以使用**mergeDescendants**参数来合并子可组合组件的语义。以下是一个例子：
- en: '[PRE18]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Merging descendants is useful when we want to provide a description for a group
    of composables. In the preceding example, we are using the `mergeDescendants`
    parameter to merge the semantics of the `Text` composables. However, we should
    be careful when using this parameter. We should only use it when we want to provide
    a description for a group of composables. If we use it for a large group of composables,
    it can lead to performance issues and can also be confusing for the users.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们想要为多个可组合组件提供描述时，合并子组件是有用的。在前面的例子中，我们使用`mergeDescendants`参数来合并`Text`可组合组件的语义。然而，在使用此参数时我们应该小心。我们只应该在想要为多个可组合组件提供描述时使用它。如果我们为大量可组合组件使用它，可能会导致性能问题，也可能使用户感到困惑。
- en: To learn more about accessibility in Jetpack Compose, visit the official documentation
    ([https://developer.android.com/jetpack/compose/accessibility](https://developer.android.com/jetpack/compose/accessibility)).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于Jetpack Compose的辅助功能，请访问官方文档([https://developer.android.com/jetpack/compose/accessibility](https://developer.android.com/jetpack/compose/accessibility))。
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced Material 3\. We also covered the features that
    Material 3 offers. We saw how to use Material 3 in our apps. Additionally, we
    covered how to design and develop our apps for large screens and, finally, we
    saw how to make our Jetpack Compose UIs accessible.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Material 3。我们还涵盖了Material 3提供的功能。我们看到了如何在我们的应用中使用Material 3。此外，我们还介绍了如何为大型屏幕设计和开发我们的应用，最后，我们看到了如何使我们的Jetpack
    Compose UI易于访问。
- en: In the next chapter, we will continue building upon the skills that we’ve gained
    from the previous chapters. We will be looking at how to architect our app and
    the different architectures available. We will learn how to use Jetpack libraries
    in our apps and how to tackle dependency injection.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续构建在前几章中获得的技能。我们将探讨如何架构我们的应用程序以及可用的不同架构。我们将学习如何在我们的应用程序中使用 Jetpack
    库以及如何处理依赖注入。
