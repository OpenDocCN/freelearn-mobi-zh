<html><head></head><body><div class="chapter" title="Chapter&#xA0;15.&#xA0;iOS 5 Features"><div class="titlepage"><div><div><h1 class="title"><a id="ch15"/>Chapter 15. iOS 5 Features</h1></div></div></div><p>In this chapter, we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Reproducing the page curl effect</li><li class="listitem" style="list-style-type: disc">Styling views</li><li class="listitem" style="list-style-type: disc">Twitter integration</li><li class="listitem" style="list-style-type: disc">Working with the split keyboard</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec01"/>Introduction</h1></div></div></div><p>The fifth major release of iOS brought over 200 new features. In this chapter, we will work on only a few of them, which mostly have to do with enhanced user experience.<a id="id1045" class="indexterm"/>
</p><p>Specifically, we will create a project that displays content separated into pages, which the user can navigate through like in a normal book, with the help of the newly introduced UIPageViewController class.<a id="id1046" class="indexterm"/>
</p><p>We will then discuss the UIAppearance class, which allows us to style controls included in our application in a more flexible and easy manner. Social sharing could also not be absent in today's devices, so we will create a project that allows the user to use Twitter, using the TWTweetComposeViewController.<a id="id1047" class="indexterm"/>
</p><p>In the last recipe of this chapter, we will work with the new split keyboard feature for the iPad, to learn how we can adjust content according to the position of the virtual keyboard on the screen.</p></div></div>
<div class="section" title="Reproducing the page curl effect"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec02"/>Reproducing the page curl effect</h1></div></div></div><p>In this recipe, we will create an app that displays content like a book, with the help of the<code class="literal"> UIPageViewController</code> class.<a id="id1048" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec01"/>Getting ready</h2></div></div></div><p>Create a new iPhone project in MonoDevelop, and name it<code class="literal"> BookApp</code>. Apart from the<code class="literal"> MainController</code>, add another controller, and name it<code class="literal"> Page</code>. Configure the appearance of the<code class="literal"> Page</code> controller however you like. In the source code for this recipe, it contains a<code class="literal"> UIImageView</code> and a<code class="literal"> UILabel</code>.<a id="id1049" class="indexterm"/>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec02"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"> Enter the following code in the<code class="literal"> MainController</code> class:<div class="informalexample"><pre class="programlisting">private UIPageViewController pageViewController;
private int pageCount = 3;
public override void ViewDidLoad (){
base.ViewDidLoad ();
Page firstPage = new Page(0);
this.pageViewController = new UIPageViewController( UIPageViewControllerTransitionStyle.PageCurl, UIPageViewControllerNavigationOrientation.Horizontal, UIPageViewControllerSpineLocation.Min);
this.pageViewController.SetViewControllers(new UIViewController[] { firstPage }, UIPageViewControllerNavigationDirection.Forward, false, s =&gt; { });
this.pageViewController.GetNextViewController = this.GetNextViewController;
this.pageViewController.GetPreviousViewController = this.GetPreviousViewController;
this.pageViewController.View.Frame = this.View.Bounds;
this.View.AddSubview(this.pageViewController.View);
}
private UIViewController GetNextViewController( UIPageViewController pageController, UIViewController referenceViewController){
Page currentPageController = referenceViewController as Page;
if (currentPageController.PageIndex &gt;= (this.pageCount - 1)){
return null;
} else{
int nextPageIndex = currentPageController.PageIndex + 1;
return new Page(nextPageIndex);
}
}
private UIViewController GetPreviousViewController( UIPageViewController pageController, UIViewController referenceViewController){
Page currentPageController = referenceViewController as Page;
if (currentPageController.PageIndex &lt;= 0){
return null;
} else{
int previousPageIndex = currentPageController.PageIndex - 1;
return new Page(previousPageIndex);
}
}
</pre></div></li><li class="listitem"> Add a property to the<code class="literal"> Page</code> class, and change its constructor, as shown in the following code:<a id="id1050" class="indexterm"/><div class="informalexample"><pre class="programlisting">public Page (int pageIndex) : base ("Page", null){
this.PageIndex = pageIndex;
}
public int PageIndex{
get;
private set;
}
</pre></div></li><li class="listitem"> Finally, configure the content that will be displayed in the<code class="literal"> Page</code>, in the<code class="literal"> ViewDidLoad</code> method:<a id="id1051" class="indexterm"/><div class="informalexample"><pre class="programlisting">this.imageView.Image = UIImage.FromFile(string.Format( "images/{0}.jpg", this.PageIndex + 1));
this.lblPageNum.Text = string.Format("Page {0}", this.PageIndex + 1);
</pre></div></li><li class="listitem"> Compile and run the application on the simulator.</li><li class="listitem"> Click-and-drag on the simulator's screen area to change page. The result should look similar to the following screenshot:</li></ol></div><div class="mediaobject"><img src="graphics/1468EXP_15_01.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec03"/>How it works...</h2></div></div></div><p>The<code class="literal"> UIPageViewController</code> class introduced with iOS 5 was a desired component by many developers. It allows us to navigate through content with the effect of a real book, like in Apple's iBooks application.<a id="id1052" class="indexterm"/>
</p><p>We initialize it with the following line:</p><div class="informalexample"><pre class="programlisting">this.pageViewController = new UIPageViewController( UIPageViewControllerTransitionStyle.PageCurl, UIPageViewControllerNavigationOrientation.Horizontal, UIPageViewControllerSpineLocation.Min);
</pre></div><p>The first parameter of the constructor determines the type of the effect. The only available value right now is<code class="literal"> PageCurl</code>. The second parameter determines the orientation of the effect.<code class="literal"> Horizontal</code> is the value for the effect similar to a book, while<code class="literal"> Vertical</code> is the value for the effect similar to a notebook, where the pages are bound at the top. The third parameter determines the position of the bind of the book.<code class="literal"> Min</code> declares that the bind is on one edge of the screen; in this case, on the left side.</p><p>After initializing the page controller, we need to set its first page by calling its<code class="literal"> SetViewControllers</code> method:<a id="id1053" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">this.pageViewController.SetViewControllers(new UIViewController[] { firstPage }, UIPageViewControllerNavigationDirection.Forward, false, s =&gt; { });
</pre></div><p>Its first parameter is an array of<code class="literal"> UIViewController</code> objects. We can set either one or two controllers for this parameter, depending on the device orientation. For example, if the application supported landscape orientation, we might want to show two pages at the same time. The second parameter basically determines the navigation direction of the included pages.<code class="literal"> Forward</code> means that the next page will be loaded if we swipe from right to left on the screen, while<code class="literal"> Reverse</code> means that the previous page will be loaded for the same swipe. The last parameter is of the delegate type<code class="literal"> UICompletionHandler</code> and represents the handler to be executed after the controllers have been added. In this example, we do not need it, so we just pass an empty lambda.<a id="id1054" class="indexterm"/>
</p><p>Next, we need to provide the data source for the rest of the pages of our "book". Once again, MonoTouch simplifies things for us by providing two very helpful properties for us to use:<code class="literal"> GetNextViewController</code> and<code class="literal"> GetPreviousViewController</code>. These properties merely represent the callback methods we would have to override if we were creating a<code class="literal"> Delegate</code> object for the page controller. Apart from their names, the signatures of these two methods are identical:<a id="id1055" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">UIViewController GetNextViewController(UIPageViewController pageController, UIViewController referenceViewController);
UIViewController GetPreviousViewController(UIPageViewController pageController, UIViewController referenceViewController);
</pre></div><p>The first parameter gives us the page controller, while the second parameter gives us the controller that is currently displayed on screen when the method is called.<a id="id1056" class="indexterm"/>
</p><p>In the implementation of these methods, we simply have to return the controller that should be loaded next, or before the current one. If we do not want the effect to be activated, we just return<code class="literal"> null</code>.</p><p>Last but not least, we set the size of the page controller's view and add it to a superview, so that it will be displayed:</p><div class="informalexample"><pre class="programlisting">this.pageViewController.View.Frame = this.View.Bounds;
this.View.AddSubview(this.pageViewController.View);
</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec04"/>There's more...</h2></div></div></div><p>If we would like our application to support landscape orientation, we would first have to implement the<code class="literal"> ShouldAutoRotateToInterfaceOrientation</code> method in the<code class="literal"> MainController</code> class, returning<code class="literal"> true</code> from it for the orientation we wish to support. Secondly, we would have to provide two view controllers to the<code class="literal"> SetViewControllers</code> method of the<code class="literal"> UIPageViewController</code> class.<a id="id1057" class="indexterm"/>
</p><div class="section" title="Double sided pages"><div class="titlepage"><div><div><h3 class="title"><a id="ch15lvl3sec01"/>Double sided pages</h3></div></div></div><p>As you might have noticed in the screenshot of this recipe, when we turn a page, its content is displayed in reverse on the page's back, like when we see through a page in real books. We have the option of creating double-sided pages by setting the<code class="literal"> UIPageViewController.DoubleSided</code> property to<code class="literal"> true</code>.<a id="id1058" class="indexterm"/>
</p></div></div></div>
<div class="section" title="Styling views"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec03"/>Styling views</h1></div></div></div><p>In this recipe, we will discover how we can easily style buttons across our application.<a id="id1059" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec05"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> StyleButtonsApp</code>. Add the<code class="literal"> MainController</code> and another controller with the name<code class="literal"> ModalController</code>.<a id="id1060" class="indexterm"/>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec06"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"> Add one button on each of the controllers. In the<code class="literal"> MainController</code> class, implement the<code class="literal"> ViewDidLoad</code> method with the following code:<a id="id1061" class="indexterm"/><div class="informalexample"><pre class="programlisting">public override void ViewDidLoad (){
base.ViewDidLoad ();
<span class="strong"><strong>
UIButton.Appearance.BackgroundColor = UIColor.Gray;
UIButton.Appearance.SetTitleColor(UIColor.White, UIControlState.Normal);
</strong></span>

this.buttonPresent.TouchUpInside += delegate(object sender, EventArgs e) {
this.PresentModalViewController(new ModalController(), true);
} ;
}
</pre></div></li><li class="listitem"> Implement the<code class="literal"> ViewDidLoad</code> method of the<code class="literal"> ModalController</code> class, to dismiss it when the button is tapped:<a id="id1062" class="indexterm"/><div class="informalexample"><pre class="programlisting">this.buttonDismiss.TouchUpInside += delegate(object sender, EventArgs e) {
this.DismissModalViewControllerAnimated(true);
} ;
</pre></div></li><li class="listitem"> Compile and run the application on the simulator.</li><li class="listitem"> Tap on the<span class="strong"><strong> Present</strong></span> button to display the modal controller. Note that the buttons of both the<code class="literal"> MainController</code> and<code class="literal"> ModalController</code> have the same background color and text color.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec07"/>How it works...</h2></div></div></div><p>To make all the buttons in our application look the same, we use the<code class="literal"> Appearance</code> static property of the<code class="literal"> UIButton</code> class. This property returns the object that inherits the<code class="literal"> UIAppearance</code> class, which is the class that reflects the Objective-C<code class="literal"> UIAppearance</code> protocol to MonoTouch.<a id="id1063" class="indexterm"/>
</p><p>This way, we have an<code class="literal"> Appearance</code> static property for all views that support it, strongly-typed according to the view we want to style. For the<code class="literal"> UIButton</code>, the<code class="literal"> Appearance</code> property returns a<code class="literal"> UIButtonAppearance</code> object. After we set the values we want in this object, all instances of<code class="literal"> UIButton</code> in the application will share the same styling.<a id="id1064" class="indexterm"/>
</p><p>So, in this example, as shown in the highlighted code, we set the background color and text color we want all of our buttons to have, and the runtime takes care of the rest for us.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec08"/>There's more...</h2></div></div></div><p>Styling our controls globally in our application is a very nice feature, but one might agree that it is a bit limiting. What if we wanted to style specific<code class="literal"> UIButtons</code> in our application, instead of all? Consider the following code:</p><div class="informalexample"><pre class="programlisting">UIButton.UIButtonAppearance buttonStyle = UIButton.AppearanceWhenContainedIn(typeof(ModalController));
buttonStyle.BackgroundColor = UIColor.Red;
</pre></div><p>The<code class="literal"> AppearanceWhenContainedIn</code> method returns the corresponding<code class="literal"> UIAppearance</code> object, in this case<code class="literal"> UIButtonAppearance</code>, and accepts a variable number of parameters of the type<code class="literal"> System.Type</code> (params<code class="literal"> Type[] containers)</code>. This code will style only instances of<code class="literal"> UIButton</code> that are contained in<code class="literal"> ModalController</code> objects only.<a id="id1065" class="indexterm"/>
</p><p>Although the number of parameters of the method is variable, the sequence of<code class="literal"> Type</code> objects that we pass determines its behavior. For example, the following call would apply the styles we set to instances of<code class="literal"> UIButton</code> contained in<code class="literal"> ModalController</code>, only when<code class="literal"> ModalController</code> is contained in<code class="literal"> MainController</code>.<a id="id1066" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">UIButton.AppearanceWhenContainedIn(typeof(MainController), typeof(ModalController));
</pre></div><div class="section" title="Specific properties"><div class="titlepage"><div><div><h3 class="title"><a id="ch15lvl3sec02"/>Specific properties</h3></div></div></div><p>Every class that inherits from<code class="literal"> UIView</code> inherits the<code class="literal"> UIAppearance</code> class. However, not all properties of each class support it. For example, through the<code class="literal"> UIButtonAppearance</code> object, we can set the background color of every<code class="literal"> UIButton</code> in our application, but we cannot set the title.</p></div></div></div>
<div class="section" title="Twitter integration"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec04"/>Twitter integration</h1></div></div></div><p>In this recipe, we will create an application that implements Twitter sharing, to allow the user to send tweets.<a id="id1067" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec09"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> TweetApp</code>. Add the<code class="literal"> MainController</code> to the project.<a id="id1068" class="indexterm"/>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec10"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"> Add a button on the view of<code class="literal"> MainController</code> and the<code class="literal"> MonoTouch.Twitter</code> namespace in the class. Next, enter the following code:<div class="informalexample"><pre class="programlisting">private TWTweetComposeViewController tweetController;
public override void ViewDidLoad (){
base.ViewDidLoad ();
this.buttonTweet.TouchUpInside += delegate(object sender, EventArgs e) {
if (TWTweetComposeViewController.CanSendTweet){
this.tweetController = new TWTweetComposeViewController();
this.tweetController.SetInitialText("Tweet from MonoTouch!");
this.tweetController.AddUrl(NSUrl.FromString( "http://software.tavlikos.com"));
this.tweetController.SetCompletionHandler(delegate( TWTweetComposeViewControllerResult tweetResult) {
if (tweetResult == TWTweetComposeViewControllerResult.Cancelled){
Console.WriteLine("Tweet cancelled!");
} else{
Console.WriteLine("Tweet sent!");
}
this.DismissModalViewControllerAnimated(true);
} );
this.PresentModalViewController(this.tweetController, true);
} else{
Console.WriteLine("Cannot use Twitter on this device!");
}
} ;
}
</pre></div></li><li class="listitem"> Compile and run the application on the simulator. If a Twitter account has not been set on the simulator, it can easily be configured through the<code class="literal"> Settings</code> application.<a id="id1069" class="indexterm"/></li><li class="listitem"> Tap the button to present the Twitter controller. The result should be similar to the following screenshot:</li></ol></div><div class="mediaobject"><img src="graphics/1468EXP_15_02.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec11"/>How it works...</h2></div></div></div><p>iOS provides the<code class="literal"> TWTweetComposeViewController</code> class that provides the sharing functionality. This controller's is the same as the native interface that is used to share a photo from the device album. Just like similar native controllers, we can only set its content before it is presented. We cannot make modifications to it after it has been displayed to the user, and the user is responsible whether to send it or discard it.<a id="id1070" class="indexterm"/>
</p><p>We can determine if the user has configured a Twitter account on the device by reading the<code class="literal"> CanSendTweet</code> static property:<a id="id1071" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">if (TWTweetComposeViewController.CanSendTweet)
</pre></div><p>If we present the controller without an account set on the device, a native alert will be presented, giving the user the option to configure an account before proceeding.</p><p>We then initialize the controller and set the text to be filled, if we wish, with the<code class="literal"> SetInitialText</code> method:<a id="id1072" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">this.tweetController = new TWTweetComposeViewController();
this.tweetController.SetInitialText("Tweet from MonoTouch!");
</pre></div><p>We also have the option of adding URLs or images in the tweet, with the<code class="literal"> AddUrl</code> and<code class="literal"> AddImage</code> methods, respectively.<a id="id1073" class="indexterm"/>
</p><p>In order to get feedback of whether the user has sent or cancelled the tweet, we call the<code class="literal"> SetCompletionHandler</code> method, passing the callback to be called:<a id="id1074" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">this.tweetController.SetCompletionHandler(delegate(TWTweetComposeView ControllerResult tweetResult) {
</pre></div><p>This callback accepts one parameter of the enumeration type<code class="literal"> TWTweetComposeViewControllerResult</code>, and it can contain either of the two values<code class="literal"> Done</code> or<code class="literal"> Cancelled</code>.<a id="id1075" class="indexterm"/>
</p><p>Last but not least, we should dismiss the controller in the callback.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note48"/>Note</h3><p>Manually dismissing the<code class="literal"> TWTweetComposeViewController</code> is not a requirement. If we do not dismiss it manually, however, it has been noticed that although the controller is dismissed when the user tapped on<span class="strong"><strong> Send</strong></span>, it takes two taps on the<span class="strong"><strong> Cancel</strong></span> button to dismiss it.</p></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec12"/>There's more...</h2></div></div></div><p>Apart from sending tweets, the<code class="literal"> MonoTouch.Twitter</code> namespace also wraps the<code class="literal"> TWRequest</code> class that allows us to read Twitter information, such as the user's timeline, through Twitter API URLs. Data received this way are in the form of JSON objects, and it is our responsibility of reading them properly.<a id="id1076" class="indexterm"/>
</p><div class="section" title="Supporting landscape orientation"><div class="titlepage"><div><div><h3 class="title"><a id="ch15lvl3sec03"/>Supporting landscape orientation</h3></div></div></div><p>The<code class="literal"> TWTweetComposeViewController</code> supports landscape orientation. To enable it, we just have to override the<code class="literal"> ShouldAutoRotateToInterfaceOrientation</code> method in the controller that presents it.<a id="id1077" class="indexterm"/>
</p></div></div></div>
<div class="section" title="Working with the split keyboard"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec05"/>Working with the split keyboard</h1></div></div></div><p>In this recipe, we will create an iPad application that is aware of the changes to the positioning of the virtual keyboard, to adjust our content accordingly.<a id="id1078" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec13"/>Getting ready</h2></div></div></div><p>Create a new iPad project in MonoDevelop, and name it<code class="literal"> SplitKeyboardApp</code>. Add the<code class="literal"> MainController</code> to the project.<a id="id1079" class="indexterm"/>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec14"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"> Add a<code class="literal"> UITextField,</code> and position it at the center of<code class="literal"> MainController</code>. Resize the text field so that its width expands across the screen. Add the following code in the<code class="literal"> MainController</code> class:<a id="id1080" class="indexterm"/><div class="informalexample"><pre class="programlisting">private NSObject kbdFrameChangedObserver;
public override void ViewDidLoad (){
base.ViewDidLoad ();
this.kbdFrameChangedObserver = NSNotificationCenter. DefaultCenter.AddObserver(new NSString(" UIKeyboardDidChangeFrameNotification"), this.KeyboardFrameChanged);
}
private void KeyboardFrameChanged(NSNotification ntf){
Console.WriteLine("Keyboard frame changed!");
if (ntf.UserInfo != null){
NSObject frameEndObj = null;
if (ntf.UserInfo.TryGetValue(UIKeyboard.FrameEndUserInfoKey, out frameEndObj)){
RectangleF keyboardFrame = (frameEndObj as NSValue).RectangleFValue;
RectangleF textFieldFrame = this.txtInput.Frame;
if (textFieldFrame.IntersectsWith(keyboardFrame)){
textFieldFrame.Y = keyboardFrame.Y - (textFieldFrame.Height + 40f);
UIView.BeginAnimations("");
this.txtInput.Frame = textFieldFrame;
UIView.CommitAnimations();
}
}
}
}
</pre></div></li><li class="listitem"> Compile and run the application on the simulator.<a id="id1081" class="indexterm"/></li><li class="listitem"> Tap on the text field to show the keyboard. If the keyboard on the iPad simulator has not been previously used, it will default to its normal state, which is at the bottom and merged.<a id="id1082" class="indexterm"/></li><li class="listitem"> Tap-and-drag the<span class="strong"><strong> hide keyboard</strong></span> key at the bottom-right corner to move the keyboard, so that it splits, and leave it over the text field.</li></ol></div><div class="mediaobject"><img src="graphics/1468EXP_15_03.jpg" alt="How to do it..."/></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">Watch the text field animate right above the keyboard. The result should be similar to the following screenshot:</li></ul></div><div class="mediaobject"><img src="graphics/1468EXP_15_04.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec15"/>How it works...</h2></div></div></div><p>To detect the position of the split keyboard, we first need to add an observer for the<code class="literal"> UIKeyboardDidChangeFrameNotification</code> key:<a id="id1083" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">this.kbdFrameChangedObserver = NSNotificationCenter. DefaultCenter.AddObserver(new NSString( "UIKeyboardDidChangeFrameNotification"), this.KeyboardFrameChanged);
</pre></div><p>Inside the<code class="literal"> KeyboardFrameChanged</code> callback, we get the value of the<code class="literal"> FrameEndUserInfoKey</code> key from the<code class="literal"> UserInfo</code> dictionary. This value, returned as an<code class="literal"> NSObject</code>, is actually an<code class="literal"> NSValue</code> object that contains the frame of the keyboard. We read the<code class="literal"> RectangleFValue</code> property from it to get the<code class="literal"> RectangleF</code> object that holds the frame values of the keyboard:<a id="id1084" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">if (ntf.UserInfo.TryGetValue(UIKeyboard.FrameEndUserInfoKey, out frameEndObj)){
RectangleF keyboardFrame = (frameEndObj as NSValue).RectangleFValue;
}
</pre></div><p>The rest of the code moves the text field above the keyboard. Change it as you please!</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec16"/>There's more...</h2></div></div></div><p>The<code class="literal"> UserInfo</code> property of the<code class="literal"> NSNotification</code> class returns an<code class="literal"> NSDictionary</code> object, which contains various information about the keyboard. To enumerate the keys it contains, a simple<code class="literal"> foreach</code> will do:<a id="id1085" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">foreach (NSString eachItem in ntf.UserInfo.Keys){
Console.WriteLine("Key: {0}", eachItem);
}
</pre></div><div class="section" title="Problems moving the keyboard?"><div class="titlepage"><div><div><h3 class="title"><a id="ch15lvl3sec04"/>Problems moving the keyboard?</h3></div></div></div><p>The hide keyboard key presents a small "context menu" when we tap and hold on it. This menu gives us the option of docking and merging (or the opposite) the keyboard. To move the keyboard in the position we want, we have to start dragging as soon as we tap on the key.<a id="id1086" class="indexterm"/>
</p></div></div></div></body></html>