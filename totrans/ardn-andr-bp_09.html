<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Bluetooth Low Energy Mobile Robot</h1></div></div></div><p>In this chapter, we are going to use most of the concepts we have learned throughout the book to control a <a id="id455" class="indexterm"/>mobile robot via an Android app. The robot will have two motors that we can control, and also an ultrasonic sensor in the front so that it can detect obstacles. The robot will also have a BLE chip so that it can receive commands from the Android app.</p><p>The application will have the following basic commands that you will need to control the robot:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Go forward</li><li class="listitem" style="list-style-type: disc">Go backward</li><li class="listitem" style="list-style-type: disc">Turn left</li><li class="listitem" style="list-style-type: disc">Turn right</li><li class="listitem" style="list-style-type: disc">Display the connection status to the robot</li></ul></div><p>The following will be the major takeaways from this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Building a mobile robot based on the Arduino platform</li><li class="listitem" style="list-style-type: disc">Connecting a BLE module to the Arduino robot</li><li class="listitem" style="list-style-type: disc">Building an Android application to control the robot remotely</li></ul></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec37"/>Hardware and software requirements</h1></div></div></div><p>Let's first<a id="id456" class="indexterm"/> see what we need for this project.</p><p>The base of this <a id="id457" class="indexterm"/>project is of course the robot itself. For this project, we used a <a id="id458" class="indexterm"/>DFRobot miniQ two-wheeled robot chassis. It comes with a round robot chassis, two DC motors, two wheels, and some screws and bolts so that you can mount multiple Arduino boards on it. You can basically use any equivalent robot chassis that has two wheels coupled with DC motors and on which you can mount Arduino-compatible boards.</p><p>To control the <a id="id459" class="indexterm"/>robot, we are actually going to use three different Arduino boards. The "brain" of the robot will be a simple Arduino Uno board. On <a id="id460" class="indexterm"/>top of that, we will use a DFRobot motor shield to control the two DC motors of the robot. And on top of these two boards, we will put a prototyping shield so that we can connect different modules to the robot.</p><p>To control the robot remotely, we will again use BLE. To give BLE connectivity to the robot, we used an Adafruit nRF8001 breakout board.</p><p>To give the robot the ability to detect what is in front of it, we added an URM37 ultrasonic sensor to the project. As we will see, this sensor is really easy to interface with Arduino.</p><p>Finally, you will also need some jumper wires to make the different connections between the robot, the sensor, and the Bluetooth module.</p><p>The following is a list of all of the hardware you will need for this project, along with links to these parts on the web:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An <a id="id461" class="indexterm"/>Arduino Uno board (<a class="ulink" href="http://www.dfrobot.com/index.php?route=product/product&amp;search=uno&amp;description=true&amp;product_id=838">http://www.dfrobot.com/index.php?route=product/product&amp;search=uno&amp;description=true&amp;product_id=838</a>)</li><li class="listitem" style="list-style-type: disc">An <a id="id462" class="indexterm"/>Arduino motor shield (<a class="ulink" href="http://www.dfrobot.com/index.php?route=product/product&amp;path=35_39&amp;product_id=59">http://www.dfrobot.com/index.php?route=product/product&amp;path=35_39&amp;product_id=59</a>)</li><li class="listitem" style="list-style-type: disc">An <a id="id463" class="indexterm"/>Arduino prototyping shield (<a class="ulink" href="http://www.dfrobot.com/index.php?route=product/product&amp;product_id=55">http://www.dfrobot.com/index.php?route=product/product&amp;product_id=55</a>)</li><li class="listitem" style="list-style-type: disc">An <a id="id464" class="indexterm"/>nRF8001 breakout board (<a class="ulink" href="https://www.adafruit.com/products/1697">https://www.adafruit.com/products/1697</a>)</li><li class="listitem" style="list-style-type: disc">An <a id="id465" class="indexterm"/>ultrasonic range sensor (<a class="ulink" href="http://www.dfrobot.com/index.php?route=product/product&amp;search=ultrasonic&amp;description=true&amp;page=1&amp;product_id=53">http://www.dfrobot.com/index.php?route=product/product&amp;search=ultrasonic&amp;description=true&amp;page=1&amp;product_id=53</a>)</li><li class="listitem" style="list-style-type: disc">An <a id="id466" class="indexterm"/>ultrasonic sensor mounting kit (<a class="ulink" href="http://www.dfrobot.com/index.php?route=product/product&amp;product_id=322">http://www.dfrobot.com/index.php?route=product/product&amp;product_id=322</a>)</li><li class="listitem" style="list-style-type: disc">A <a id="id467" class="indexterm"/>DFRobot miniQ chassis (<a class="ulink" href="http://www.dfrobot.com/index.php?route=product/product&amp;search=miniq&amp;description=true&amp;product_id=367">http://www.dfrobot.com/index.php?route=product/product&amp;search=miniq&amp;description=true&amp;product_id=367</a>)</li><li class="listitem" style="list-style-type: disc">A <a id="id468" class="indexterm"/>7.4 V battery (<a class="ulink" href="http://www.dfrobot.com/index.php?route=product/product&amp;product_id=489">http://www.dfrobot.com/index.php?route=product/product&amp;product_id=489</a>)</li><li class="listitem" style="list-style-type: disc">Jumper wires <a id="id469" class="indexterm"/>(<a class="ulink" href="https://www.adafruit.com/products/1957">https://www.adafruit.com/products/1957</a>)</li></ul></div><p>On the <a id="id470" class="indexterm"/>software side, you<a id="id471" class="indexterm"/> will of course need the Arduino IDE. You will also need the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A library<a id="id472" class="indexterm"/> for the nRF8001 chip (<a class="ulink" href="https://github.com/adafruit/Adafruit_nRF8001">https://github.com/adafruit/Adafruit_nRF8001</a>)</li><li class="listitem" style="list-style-type: disc">The<a id="id473" class="indexterm"/> aREST library to send commands to the robot (<a class="ulink" href="https://github.com/marcoschwartz/aREST">https://github.com/marcoschwartz/aREST</a>)</li></ul></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec59"/>Configuring the hardware</h2></div></div></div><p>We are <a id="id474" class="indexterm"/>first going to assemble the robot itself, and then see how to connect the Bluetooth module and the ultrasonic sensor. To give you an idea of what you should end up with, the following is a front-view image of the robot when fully assembled:</p><div><img src="img/0389OS_09_01.jpg" alt="Configuring the hardware"/></div><p>The following <a id="id475" class="indexterm"/>image shows the back of the robot when fully assembled:</p><div><img src="img/0389OS_09_02.jpg" alt="Configuring the hardware"/></div><p>The first step is<a id="id476" class="indexterm"/> to assemble the robot chassis. To do so, you can watch the <a id="id477" class="indexterm"/>DFRobot assembly guide at <a class="ulink" href="https://www.youtube.com/watch?v=tKakeyL_8Fg">https://www.youtube.com/watch?v=tKakeyL_8Fg</a>.</p><p>Then, you need to attach the different Arduino boards and shields to the robot. Use the spacers found in the robot chassis kit to mount the Arduino Uno board first. Then put the Arduino motor shield on top of that. At this point, use the screw header terminals to connect the two DC motors to the motor shield. This is how it should look at this point:</p><div><img src="img/0389OS_09_03.jpg" alt="Configuring the hardware"/></div><p>Finally, mount the prototyping shield on top of the motor shield.</p><p>We are now going <a id="id478" class="indexterm"/>to connect the BLE module and the ultrasonic sensor to the Arduino prototyping shield. The following is a schematic diagram showing the connections between the Arduino Uno board (done via the prototyping shield in our case) and the components:</p><div><img src="img/0389OS_09_04.jpg" alt="Configuring the hardware"/></div><p>Now perform the<a id="id479" class="indexterm"/> following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">First, we are now going to connect the BLE module.</li><li class="listitem">Place the module on the prototyping shield.</li><li class="listitem">Connect the power supply of the module as follows: <strong>GND</strong> goes to the prototyping shield's <strong>GND</strong> pin, and <strong>VIN</strong> goes to the prototyping shield's +5V.</li><li class="listitem">After that, you need to connect the different wires responsible for the SPI interface: <strong>SCK</strong> to Arduino pin <strong>13</strong>, <strong>MISO</strong> to Arduino pin <strong>12</strong>, and <strong>MOSI</strong> to Arduino pin <strong>11</strong>.</li><li class="listitem">Then connect the <strong>REQ</strong> pin to Arduino pin <strong>10</strong>.</li><li class="listitem">Finally, connect the <strong>RDY</strong> pin to Arduino pin <strong>2</strong> and the <strong>RST</strong> pin to Arduino pin <strong>9</strong>.</li><li class="listitem">For the URM37 module, connect the <strong>VCC</strong> pin of the module to Arduino +5V, <strong>GND</strong> to <strong>GND</strong>, and the <strong>PWM</strong> pin to the Arduino <strong>A3</strong> pin.<div><div><h3 class="title"><a id="note13"/>Note</h3><p>To review the pin order on the URM37 module, you can check the official <a id="id480" class="indexterm"/>DFRobot documentation at <a class="ulink" href="http://www.dfrobot.com/wiki/index.php?title=URM37_V3.2_Ultrasonic_Sensor_(SKU:SEN0001)">http://www.dfrobot.com/wiki/index.php?title=URM37_V3.2_Ultrasonic_Sensor_(SKU:SEN0001)</a>.</p></div></div><p>The following<a id="id481" class="indexterm"/> is a close-up image of the prototyping shield with the BLE module connected:</p><div><img src="img/0389OS_09_05.jpg" alt="Configuring the hardware"/></div></li><li class="listitem">Finally, connect the 7.4 V battery to the Arduino Uno board power jack. The battery is simply placed below the Arduino Uno board.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec60"/>Testing the robot</h2></div></div></div><p>We are <a id="id482" class="indexterm"/>now going to write a sketch to test the different functionalities of the robot, first without using Bluetooth. As the sketch is quite long, we will look at the code piece by piece. Before you proceed, make sure that the battery is always plugged into the robot. Now perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">The sketch starts by including the aREST library that we will use to control the robot via serial commands:<div><pre class="programlisting">#include &lt;aREST.h&gt;</pre></div></li><li class="listitem">Now we declare which pins the motors are connected to:<div><pre class="programlisting">int speed_motor1 = 6;  
int speed_motor2 = 5;
int direction_motor1 = 7;
int direction_motor2 = 4;</pre></div></li><li class="listitem">We also declare which pin the ultrasonic sensor is connected to:<div><pre class="programlisting">int distance_sensor = A3;</pre></div></li><li class="listitem">Then, we create an instance of the aREST library:<div><pre class="programlisting">aREST rest = aREST();</pre></div></li><li class="listitem">To<a id="id483" class="indexterm"/> store the distance data measured by the ultrasonic sensor, we declare a distance variable:<div><pre class="programlisting">int distance;</pre></div></li><li class="listitem">In the <code class="literal">setup()</code> function of the sketch, we first initialize serial communications that we will use to communicate with the robot for this test:<div><pre class="programlisting">Serial.begin(115200);</pre></div></li><li class="listitem">We also expose the distance variable to the REST API, so we can access it easily:<div><pre class="programlisting">rest.variable("distance",&amp;distance);</pre></div></li><li class="listitem">To control the robot, we are going to declare a whole set of functions that will perform the basic operations: going forward, going backward, turning on itself (left or right), and stopping. We will see the details of these functions in a moment; for now, we just need to expose them to the API:<div><pre class="programlisting">rest.function("forward",forward);
rest.function("backward",backward);
rest.function("left",left);
rest.function("right",right);
rest.function("stop",stop);</pre></div></li><li class="listitem">We also give the robot an ID and a name:<div><pre class="programlisting">rest.set_id("001");
rest.set_name("mobile_robot");</pre></div></li><li class="listitem">In the <code class="literal">loop()</code> function of the sketch, we first measure the distance from the sensor:<div><pre class="programlisting">distance = measure_distance(distance_sensor);</pre></div></li><li class="listitem">We then handle the requests using the aREST library:<div><pre class="programlisting">rest.handle(Serial);  </pre></div></li><li class="listitem">Now, we will look at the functions for controlling the motors. They are all based on a function to control a single motor, where we need to set the motor pins, the speed, and the direction of the motor:<div><pre class="programlisting">void send_motor_command(int speed_pin, int direction_pin, int pwm, boolean dir)
{
  analogWrite(speed_pin, pwm); // Set PWM control, 0 for stop, and 255 for maximum speed
  digitalWrite(direction_pin, dir); // Dir set the rotation direction of the motor (true or false means forward or reverse)
}</pre></div></li><li class="listitem">Based <a id="id484" class="indexterm"/>on this function, we can now define the different functions to move the robot, such as <code class="literal">forward</code>:<div><pre class="programlisting">int forward(String command) {
  
  send_motor_command(speed_motor1,direction_motor1,100,1);
  send_motor_command(speed_motor2,direction_motor2,100,1);
  return 1;
}</pre></div></li><li class="listitem">We also define a <code class="literal">backward</code> function, simply inverting the direction of both motors:<div><pre class="programlisting">int backward(String command) {
  send_motor_command(speed_motor1,direction_motor1,100,0);
  send_motor_command(speed_motor2,direction_motor2,100,0);
  return 1;
}</pre></div></li><li class="listitem">To make the robot turn left, we simply make the motors rotate in opposite directions:<div><pre class="programlisting">int left(String command) {
  send_motor_command(speed_motor1,direction_motor1,75,0);
  send_motor_command(speed_motor2,direction_motor2,75,1);
  return 1;
}</pre></div></li><li class="listitem">We also have a function to stop the robot:<div><pre class="programlisting">int stop(String command) {
  send_motor_command(speed_motor1,direction_motor1,0,1);
  send_motor_command(speed_motor2,direction_motor2,0,1);
  return 1;
}</pre></div></li></ol></div><p>There is also a <a id="id485" class="indexterm"/>function to make the robot turn right, which is not detailed here. Note <a id="id486" class="indexterm"/>that all of the code used in this chapter can be found in the GitHub repository of the book at <a class="ulink" href="https://github.com/marcoschwartz/arduino-android-blueprints">https://github.com/marcoschwartz/arduino-android-blueprints</a>.</p><p>We are now going to test the robot. Before you do anything, ensure that the battery is always plugged into the robot. This will ensure that the motors are not trying to get power from your computer USB port, which could damage it.</p><p>Also place some small support at the bottom of the robot so that the wheels don't touch the ground. This will ensure that you can test all the commands of the robot without the robot moving too far from your computer, as it is still attached via the USB cable.</p><p>Now you can upload the sketch to your Arduino Uno board. Open the serial monitor and type the following:</p><div><pre class="programlisting">
<strong>/forward</strong>
</pre></div><p>This should make both the wheels of the robot turn in the same direction. You can also try the other commands to move the robot to make sure they all work properly. Then, test the ultrasonic distance sensor by typing the following:</p><div><pre class="programlisting">
<strong>/distance</strong>
</pre></div><p>You should get back the distance (in centimeters) in front of the sensor:</p><div><pre class="programlisting">
<strong>{"distance": 24, "id": "001", "name": "mobile_robot", "connected": true}</strong>
</pre></div><p>Try changing the distance by putting your hand in front of the sensor and typing the command again.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec38"/>Writing the Arduino sketch</h1></div></div></div><p>Now that <a id="id487" class="indexterm"/>we have made sure that the robot is <a id="id488" class="indexterm"/>working properly, we can write the final sketch that will receive the commands via Bluetooth. As the sketch shares many similarities with the test sketch, we are only going to see what is added compared to the test sketch. We first need to include more libraries:</p><div><pre class="programlisting">#include &lt;SPI.h&gt;
#include "Adafruit_BLE_UART.h"
#include &lt;aREST.h&gt;</pre></div><p>We also define which pins the BLE module is connected to:</p><div><pre class="programlisting">#define ADAFRUITBLE_REQ 10
#define ADAFRUITBLE_RDY 2     // This should be an interrupt pin, on Uno thats #2 or #3
#define ADAFRUITBLE_RST 9</pre></div><p>We <a id="id489" class="indexterm"/>have to <a id="id490" class="indexterm"/>create an instance of the BLE module:</p><div><pre class="programlisting">Adafruit_BLE_UART BTLEserial = Adafruit_BLE_UART(ADAFRUITBLE_REQ, ADAFRUITBLE_RDY, ADAFRUITBLE_RST);</pre></div><p>In the <code class="literal">setup()</code> function of the sketch, we initialize the BLE chip:</p><div><pre class="programlisting">BTLEserial.begin();</pre></div><p>In the <code class="literal">loop()</code> function, we check the status of the BLE chip and store it in a variable:</p><div><pre class="programlisting">BTLEserial.pollACI();
aci_evt_opcode_t status = BTLEserial.getState();</pre></div><p>If we detect that a device is connected to the chip, we handle the incoming request with the aREST library, which will allow us to use the same commands as before to control the robot:</p><div><pre class="programlisting">if (status == ACI_EVT_CONNECTED) {
  rest.handle(BTLEserial);
}</pre></div><p>You can now upload the code to your Arduino board, again by making sure that the battery is connected to the Arduino Uno board via the power jack. You can now move on to the development of the Android application to control the robot.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec61"/>Setting up the Android app</h2></div></div></div><p>The <a id="id491" class="indexterm"/>Android application that we will be creating will give us the opportunity to control the robot via BLE from the physical Android device. This application will have five <a id="id492" class="indexterm"/>basic controls, that is, <strong>Forward</strong>, <strong>Backward</strong>, <strong>Left</strong>, <strong>Right</strong>, and <strong>Stop</strong>. In addition, it will also show the BLE connection status and there will be a <strong>Refresh</strong> button that will allow us to refresh the Bluetooth callback.</p><p>We will assume that you will have switched on the <code class="literal">Auto-Import</code> function within your preferences. If not, activate it by going to the <strong>Auto-Import</strong> preferences and selecting all the available options. The <strong>Auto-Import</strong> preferences are available on Mac and Windows as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">On a Mac, navigate to <strong>Android Studio</strong> &gt; <strong>Preferences</strong> &gt; <strong>Editor</strong> &gt; <strong>Auto-Import</strong></li><li class="listitem" style="list-style-type: disc">On Windows, navigate to <strong>File</strong> &gt; <strong>Settings</strong> &gt; <strong>Editor</strong> &gt; <strong>Auto-Import</strong></li></ul></div><p>With all the <a id="id493" class="indexterm"/>necessary settings in place, we will start off by creating a new project where we will choose the following within the <strong>New Project</strong> setup walkthrough:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Name</strong>: <code class="literal">Mobile Robot</code></li><li class="listitem" style="list-style-type: disc"><strong>Minimum SDK</strong>: <code class="literal">18</code></li><li class="listitem" style="list-style-type: disc"><strong>Project</strong>: <code class="literal">Blank Activity</code></li><li class="listitem" style="list-style-type: disc"><strong>Activity Name</strong>: <code class="literal">RobotControlAc</code><code class="literal">tivity</code></li><li class="listitem" style="list-style-type: disc"><strong>Domain</strong>: <code class="literal">arduinoandroid.com</code></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec62"/>Laying out the Android user interface and setting permissions</h2></div></div></div><p>In order to <a id="id494" class="indexterm"/>make this project work, we will need to first go over to the Android <code class="literal">Manifest</code> file, which is available at <code class="literal">app</code> &gt; <code class="literal">src</code> &gt; <code class="literal">main</code> &gt; <code class="literal">AndroidManifest.xml</code>.</p><p>Since this <a id="id495" class="indexterm"/>Android application uses BLE to connect the Android physical device to the robot, we will need to add the following permissions to the Android <code class="literal">Manifest</code> file. These permissions will allow the application to connect to the paired Bluetooth devices that have been discovered:</p><div><pre class="programlisting">&lt;uses-permission android:name="android.permission.BLUETOOTH"/&gt;
&lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN"/&gt;</pre></div><p>The next step that we will take is to set up the very basic Android layout file so that we can implement the app's functions and allow the user to activate the voice recognition intent.</p><p>In our project, we will navigate to the main layout file which can be accessed from <code class="literal">app</code> &gt; <code class="literal">src</code> &gt; <code class="literal">res</code> &gt; <code class="literal">layout</code> &gt; <code class="literal">activity_robot_control.xml</code>.</p><p>There are a number of layout formats with the Android user interface design, and in this particular case, we will be using a horizontal linear layout with a vertical linear layout as a child. Keeping these concepts in mind, we will replace the current code with the following lines of code:</p><div><pre class="programlisting">&lt;LinearLayout
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    &gt;

    &lt;Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Connect"
        android:id="@+id/connectBtn"
        android:layout_gravity="center_horizontal"
        /&gt;

    &lt;Button
        style="?android:attr/buttonStyleSmall"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Forward"
        android:id="@+id/fwdBtn"
        android:layout_gravity="center_horizontal"
        /&gt;

    &lt;LinearLayout
        android:orientation="horizontal"
        android:layout_width="fill_parent"
        android:layout_height="57dp"&gt;

        &lt;Button
            style="?android:attr/buttonStyleSmall"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Left"
            android:id="@+id/leftBtn"
            android:layout_weight="1"
            /&gt;

        &lt;Button
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Stop"
            android:id="@+id/stopBtn"
            android:layout_gravity="center_horizontal"
            android:layout_weight="1"
            /&gt;

        &lt;Button
            style="?android:attr/buttonStyleSmall"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Right"
            android:id="@+id/rightBtn"
            android:layout_weight="1"
            /&gt;

    &lt;/LinearLayout&gt;

    &lt;Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Backward"
        android:id="@+id/backwardBtn"         
		android:layout_gravity="center_horizontal"
        /&gt;

    &lt;TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Connection Status View"
        android:id="@+id/connectionStsView"
        android:layout_gravity="center_horizontal"
        /&gt;

&lt;/LinearLayout&gt;</pre></div><p>At this <a id="id496" class="indexterm"/>point, you <a id="id497" class="indexterm"/>should end up with something that looks like the following screenshot. This is based on the LG Nexus 5:</p><div><img src="img/0389OS_09_06.jpg" alt="Laying out the Android user interface and setting permissions"/></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec63"/>Coding the app's internals</h2></div></div></div><p>At this point, we <a id="id498" class="indexterm"/>want to start connecting our freshly designed Android user interface to the main Android code, and we will start doing this by opening the <code class="literal">RobotControlActivity.java</code> file, which is available at <code class="literal">app</code> &gt; <code class="literal">src</code> &gt; <code class="literal">main</code> &gt; <code class="literal">java</code> &gt; <code class="literal">package name</code> &gt; <code class="literal">RobotControlActivity.java</code>.</p><p>We will start off by declaring the user interface element variables together with the main variable, which we could use for logging, as follows:</p><div><pre class="programlisting">//User Interface Elements
    Button fwdBtn;
    Button leftBtn;
    Button rightBtn;
    Button backBtn;
    Button stopBtn;
    Button connectBtn;
    TextView connectionSts;

    //Logging Variables
    private final String LOG_TAG = RobotControlActivity.class.getSimpleName();</pre></div><p>We will <a id="id499" class="indexterm"/>declare all the necessary variables for the <code class="literal">BluetoothCallback</code> variable, where we will primarily declare the UUIDs associated with our specific BLE module, followed by the Bluetooth adapter variables and characteristics:</p><div><pre class="programlisting">    // UUIDs for UAT service and associated characteristics.
    public static UUID UART_UUID = UUID.fromString("6E400001-B5A3-F393-E0A9-E50E24DCCA9E");
    public static UUID TX_UUID = UUID.fromString("6E400002-B5A3-F393-E0A9-E50E24DCCA9E");
    public static UUID RX_UUID = UUID.fromString("6E400003-B5A3-F393-E0A9-E50E24DCCA9E");

    // UUID for the BTLE client characteristic which is necessary for notifications.
    public static UUID CLIENT_UUID = UUID.fromString("00002902-0000-1000-8000-00805f9b34fb");

    // BTLE states
    private BluetoothAdapter adapter;
    private BluetoothGatt gatt;
    private BluetoothGattCharacteristic tx;
    private BluetoothGattCharacteristic rx;</pre></div><p>We will then proceed to the <code class="literal">onCreate()</code> method and connect the different user interface elements to the code:</p><div><pre class="programlisting">        fwdBtn = (Button) findViewById(R.id.fwdBtn);
        leftBtn = (Button) findViewById(R.id.leftBtn);
        rightBtn = (Button) findViewById(R.id.rightBtn);
        backBtn = (Button) findViewById(R.id.backwardBtn);
        stopBtn = (Button) findViewById(R.id.stopBtn);
        connectBtn = (Button) findViewById(R.id.connectBtn);

        connectionSts = (TextView)findViewById(R.id.connectionStsView);</pre></div><p>In this project, we would like to send specific BLE messages to our robot when the user taps on the buttons, and <a id="id500" class="indexterm"/>in this part, we will be adding <code class="literal">onClickListeners</code> to our buttons which we have connected earlier to send the messages that we need to interface with the robot:</p><div><pre class="programlisting">fwdBtn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                String setOutputMessage = "/forward /";
                tx.setValue(setOutputMessage.getBytes(Charset.forName("UTF-8")));
                if (gatt.writeCharacteristic(tx)) {
                    writeConnectionData("Sent: " + setOutputMessage);
                } else {
                    writeConnectionData("Couldn't write TX characteristic!");
                }
            }
        });

        leftBtn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                String setOutputMessage = "/left /";
                tx.setValue(setOutputMessage.getBytes(Charset.forName("UTF-8")));
                if (gatt.writeCharacteristic(tx)) {
                    writeConnectionData("Sent: " + setOutputMessage);
                } else {
                    writeConnectionData("Couldn't write TX characteristic!");
                }
            }
        });

        rightBtn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                String setOutputMessage = "/right /";
                tx.setValue(setOutputMessage.getBytes(Charset.forName("UTF-8")));
                if (gatt.writeCharacteristic(tx)) {
                    writeConnectionData("Sent: " + setOutputMessage);
                } else {
                    writeConnectionData("Couldn't write TX characteristic!");
                }
            }
        });
        backBtn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                String setOutputMessage = "/backward /";
                tx.setValue(setOutputMessage.getBytes(Charset.forName("UTF-8")));
                if (gatt.writeCharacteristic(tx)) {
                    writeConnectionData("Sent: " + setOutputMessage);
                } else {
                    writeConnectionData("Couldn't write TX characteristic!");
                }
            }
        });
        stopBtn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                String setOutputMessage = "/stop /";
                tx.setValue(setOutputMessage.getBytes(Charset.forName("UTF-8")));
                if (gatt.writeCharacteristic(tx)) {
                    writeConnectionData("Sent: " + setOutputMessage);
                } else {
                    writeConnectionData("Couldn't write TX characteristic!");
                }
            }
        });

        connectBtn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {

                restartScan();
            }
        });</pre></div><p>In the next section, we need to declare a new method, which we will name <code class="literal">writeConnectionData</code>. Its main role is writing the status of the Bluetooth callback to the connection status text view:</p><div><pre class="programlisting">private void writeConnectionData(final CharSequence text) {
        Log.e(LOG_TAG, text.toString());
        connectionSts.setText(text.toString());
    }</pre></div><p>The following<a id="id501" class="indexterm"/> code is all the necessary Bluetooth callback which needs to take place in order to establish a connection between the Android physical device and BLE module on the robot:</p><div><pre class="programlisting">private BluetoothGattCallback bluetoothGattCallback = new BluetoothGattCallback() {
        // Called whenever the device connection state changes, i.e. from disconnected to connected.
        @Override
        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {
            super.onConnectionStateChange(gatt, status, newState);
            if (newState == BluetoothGatt.STATE_CONNECTED) {
                writeConnectionData("Connected!");
                // Discover services.
                if (!gatt.discoverServices()) {
                    writeConnectionData("Failed to start discovering services!");
                }
            } else if (newState == BluetoothGatt.STATE_DISCONNECTED) {
                writeConnectionData("Disconnected!");
            } else {
                writeConnectionData("Connection state changed.  New state: " + newState);
            }
        }

        // Called when services have been discovered on the remote device.
        // It seems to be necessary to wait for this discovery to occur before
        // manipulating any services or characteristics.
        public void onServicesDiscovered(BluetoothGatt gatt, int status) {
            super.onServicesDiscovered(gatt, status);
            if (status == BluetoothGatt.GATT_SUCCESS) {
                writeConnectionData("Service discovery completed!");
            } else {
                writeConnectionData("Service discovery failed with status: " + status);
            }
            // Save reference to each characteristic.
            tx = gatt.getService(UART_UUID).getCharacteristic(TX_UUID);
            rx = gatt.getService(UART_UUID).getCharacteristic(RX_UUID);

            // Setup notifications on RX characteristic changes (i.e. data received).
            // First call setCharacteristicNotification to enable notification.
            if (!gatt.setCharacteristicNotification(rx, true)) {
                writeConnectionData("Couldn't set notifications for RX characteristic!");
            }

            // Next update the RX characteristic's client descriptor to enable notifications.
            if (rx.getDescriptor(CLIENT_UUID) != null) {
                BluetoothGattDescriptor desc = rx.getDescriptor(CLIENT_UUID);
                desc.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);
                if (!gatt.writeDescriptor(desc)) {
                    writeConnectionData("Couldn't write RX client descriptor value!");
                }
            } else {
                writeConnectionData("Couldn't get RX client descriptor!");
            }
            areServicesAccessible = true;
        }
    };</pre></div><p>The Android application's life cycle gives us the ability to add methods that can be activated at different <a id="id502" class="indexterm"/>parts of this cycle. The following <code class="literal">onStart()</code> and <code class="literal">onStop()</code>methods, which are invoked on starting and exiting the application respectively, allow us to conserve the device's energy and memory resources:</p><div><pre class="programlisting">protected void onStart() {
        Log.d(LOG_TAG,"onStart has been called");
        super.onStart();
        // / Scan for all BTLE devices.
        // The first one with the UART service will be chosen--see the code in the scanCallback.
        adapter = BluetoothAdapter.getDefaultAdapter();
        startScan();
    }

    //When this Activity isn't visible anymore
    protected void onStop() {
        Log.d(LOG_TAG,"onStop has been called");
        //disconnect and close Bluetooth Connection for better reliability
        if (gatt != null) {
            gatt.disconnect();
            gatt.close();
            gatt = null;
            tx = null;
            rx = null;
        }
        super.onStop();
    }</pre></div><p>In order to <a id="id503" class="indexterm"/>allow the starting, stopping, and restarting of Bluetooth scans, we need to declare methods to do these particular actions, which is the purpose of the following code:</p><div><pre class="programlisting">private void startScan() {
        if (!adapter.isEnabled()) {
            adapter.enable();
        }
        if (!adapter.isDiscovering()) {
            adapter.startDiscovery();
        }
        writeConnectionData("Scanning for devices...");
        adapter.startLeScan(scanCallback);
    }

    private void stopScan() {
        if (adapter.isDiscovering()) {
            adapter.cancelDiscovery();
        }
        writeConnectionData("Stopping scan");
        adapter.stopLeScan(scanCallback);
    }

    private void restartScan() {
        stopScan();
        startScan();
    }</pre></div><p>The most important <a id="id504" class="indexterm"/>part of the Bluetooth callback is to connect to the right BLE device, and the following code helps the user to achieve that:</p><div><pre class="programlisting">private BluetoothAdapter.LeScanCallback scanCallback = new BluetoothAdapter.LeScanCallback() {
        // Called when a device is found.
        @Override
        public void onLeScan(BluetoothDevice bluetoothDevice, int i, byte[] bytes) {
            Log.d(LOG_TAG, bluetoothDevice.getAddress());

            writeConnectionData("Found device: " + bluetoothDevice.getAddress());

            // Check if the device has the UART service.
            if (BluetoothUtils.parseUUIDs(bytes).contains(UART_UUID)) {
                // Found a device, stop the scan.
                adapter.stopLeScan(scanCallback);
                writeConnectionData("Found UART service!");
                // Connect to the device.
                // Control flow will now go to the bluetoothGattCallback functions when BTLE events occur.
                gatt = bluetoothDevice.connectGatt(getApplicationContext(), false, bluetoothGattCallback);
            }
        }
    };</pre></div><p>UUID parsing, unlike in the previous chapters, has been moved to a <code class="literal">utility</code> class in order to refactor the code and make it more readable. In order to create a <code class="literal">utility</code> class, we first need to right-click on our package name and create a new package called <code class="literal">Bluetooth</code>.</p><p>After that, we will right-click on the new package, select <strong>New</strong> &gt; <strong>Java Class</strong>, and name the new class as <code class="literal">BluetoothUtils</code>.</p><p>After the preceding two steps, we will replace the code within the class with the following<a id="id505" class="indexterm"/> code:</p><div><pre class="programlisting">public class BluetoothUtils {

    // Filtering by custom UUID is broken in Android 4.3 and 4.4, see:
    //   http://stackoverflow.com/questions/18019161/startlescan-with-128-bit-uuids-doesnt-work-on-native-android-ble-implementation?noredirect=1#comment27879874_18019161
    // This is a workaround function from the SO thread to manually parse advertisement data.
    public static List&lt;UUID&gt; parseUUIDs(final byte[] advertisedData) {
        List&lt;UUID&gt; uuids = new ArrayList&lt;UUID&gt;();

        int offset = 0;
        while (offset &lt; (advertisedData.length - 2)) {
            int len = advertisedData[offset++];
            if (len == 0)
                break;

            int type = advertisedData[offset++];
            switch (type) {
                case 0x02: // Partial list of 16-bit UUIDs
                case 0x03: // Complete list of 16-bit UUIDs
                    while (len &gt; 1) {
                        int uuid16 = advertisedData[offset++];
                        uuid16 += (advertisedData[offset++] &lt;&lt; 8);
                        len -= 2;
                        uuids.add(UUID.fromString(String.format("%08x-0000-1000-8000-00805f9b34fb", uuid16)));
                    }
                    break;
                case 0x06:// Partial list of 128-bit UUIDs
                case 0x07:// Complete list of 128-bit UUIDs
                    // Loop through the advertised 128-bit UUID's.
                    while (len &gt;= 16) {
                        try {
                            // Wrap the advertised bits and order them.
                            ByteBuffer buffer = ByteBuffer.wrap(advertisedData, offset++, 16).order(ByteOrder.LITTLE_ENDIAN);
                            long mostSignificantBit = buffer.getLong();
                            long leastSignificantBit = buffer.getLong();
                            uuids.add(new UUID(leastSignificantBit,
                                    mostSignificantBit));
                        } catch (IndexOutOfBoundsException e) {
                            // Defensive programming.
                            //Log.e(LOG_TAG, e.toString());
                            continue;
                        } finally {
                            // Move the offset to read the next uuid.
                            offset += 15;
                            len -= 16;
                        }
                    }
                    break;
                default:
                    offset += (len - 1);
                    break;
            }
        }
        return uuids;
    }
}</pre></div><p>At this point, you<a id="id506" class="indexterm"/> could go ahead, build, and run the project on an Android physical device running Android 4.3 with Bluetooth switched on.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec39"/>Enhancing the user interface further</h1></div></div></div><p>Once<a id="id507" class="indexterm"/> we <a id="id508" class="indexterm"/>have managed to finalize our code and assure ourselves that the user interface includes all the basic functionalities required to control the robot, we can proceed to improving our user interface.</p><p>We will improve the user interface with two main actions:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Adding a new app icon</li><li class="listitem" style="list-style-type: disc">Styling the user interface buttons</li></ul></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec64"/>Adding a new app icon</h2></div></div></div><p>First, we <a id="id509" class="indexterm"/>will download the image asset. It's available within the GitHub repository and <a id="id510" class="indexterm"/>also as a public download at <a class="ulink" href="http://bit.ly/mobileroboticon">http://bit.ly/mobileroboticon</a>.</p><p>You should navigate to the project tree, followed by a right-click on <strong>app</strong>.</p><p>When you right-click on <strong>app</strong>, create a new image asset by going to <strong>New</strong> &gt; <strong>Image Asset</strong>.</p><p>You will then be shown an <strong>Asset Studio</strong> pop-up window, which will allow you to choose your very own image file. For optimization purposes, we recommend that you go for a <code class="literal">.png</code> file with a resolution of 144 pixels by 144 pixels. Android Studio automatically does all the resizing and resource creation to adapt your graphic to different screens.</p><p>Once you choose the <code class="literal">ic_launcher</code> image file that we have provided you with, you will be shown a screen with the icon in different sizes. Click on <strong>Next</strong> where you will see the screen with the launcher icons in different sizes.</p><p>This screen warns you that previous files will be overwritten and shows you the image launcher file in a number of different resolutions once again. Click on <strong>Finish.</strong> Then compile the app, launch it on your physical device, and you should see something pleasant in your app tray and in the app's action bar.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec65"/>Styling the user interface buttons</h2></div></div></div><p>The <a id="id511" class="indexterm"/>final steps that we will be taking about are to modify our buttons and add some color to the text.</p><p>There are two steps required while creating the new buttons:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a <code class="literal">Drawable</code> folder with a new XML drawable file known as <code class="literal">button.xml</code>.</li><li class="listitem">Then connect the drawable resource file to the main Android layout file.</li></ol></div><p>Create the <code class="literal">Drawable</code> folder by right-clicking on the <code class="literal">res</code> folder, which is available at <code class="literal">App</code> &gt; <code class="literal">src</code> &gt; <code class="literal">main</code> &gt; <code class="literal">res</code>.</p><p>After creating the <code class="literal">Drawable</code> folder within the <code class="literal">res</code> folder, we need to once again right-click on the new <code class="literal">drawable</code> folder and navigate to <strong>New</strong> &gt; <strong>Drawable Resource File</strong>.</p><p>Name the file <code class="literal">buttonshape</code> and type <code class="literal">shape</code> as the root element, followed by clicking on <strong>OK</strong>.</p><p>Within the <code class="literal">button.xml</code> file, replace the current code with the following:</p><div><pre class="programlisting">&lt;shape &gt;
    &lt;corners
        android:radius="30dp"/&gt;
    &lt;solid
        android:color="#FFFFFF"/&gt;
    &lt;padding
        android:left="10dp"
        android:top="10dp"
        android:right="10dp"
        android:bottom="10dp"/&gt;
    &lt;stroke
        android:width="2dp"
        android:color="#4A90E2"/&gt;
&lt;/shape&gt;</pre></div><p>At this point, the buttons have not been modified yet, so we will go to the robot control activity layout file, which is available at <code class="literal">app</code> &gt; <code class="literal">main</code> &gt; <code class="literal">res</code> &gt; <code class="literal">layout</code> &gt; <code class="literal">activity_robot_control.xml</code>.</p><p>Within this<a id="id512" class="indexterm"/> file, we will also be connecting the changes within the <code class="literal">buttonshape.xml</code> file to the main layout file, and we will be adding <code class="literal">margin</code> to the buttons so that there is enough spacing between the buttons for a presentable layout.</p><p>We will add the following code to all the button elements to give them the <code class="literal">buttonshape</code> styling:</p><div><pre class="programlisting">android:background="@drawable/buttonshape"</pre></div><p>After that, we will add the margins by adding the following code to the <strong>Connect</strong>, <strong>Backward</strong>, and <strong>Forward</strong> buttons:</p><div><pre class="programlisting">android:layout_margin="10dp"</pre></div><p>For the left and right buttons, we will add the following code since they're within a different kind of layout:</p><div><pre class="programlisting">android:layout_marginLeft="10dp"
android:layout_marginRight="10dp"</pre></div><p>At this point, you should have a layout that looks like the following screenshot on Nexus 4, which is more attractive and presentable to the user:</p><div><img src="img/0389OS_09_07.jpg" alt="Styling the user interface buttons"/></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec66"/>How to go further</h2></div></div></div><p>The <a id="id513" class="indexterm"/>Android application can be further enhanced with more refined controls that could quantify the exact angle by which you would like the robot to turn left or right. We can also extract data from the ultrasonic sensor and display it within the Android application to get data about the proximity to obstacles.</p><p>In addition, the <a id="id514" class="indexterm"/>Android application will definitely benefit from the addition of a <strong>Connection</strong> dialog that shows the user all the available BLE devices, and the user can choose the BLE Chip connected to the robot. This will enhance user experience and, at the same time, provide a more stable connection with the robot, especially if you're working in an environment surrounded by other BLE transmitters.</p><p>Last but not least, the reader can also go ahead and do further modifications to the user interface and layout to make the app even more attractive and presentable. Our main recommendation is <a id="id515" class="indexterm"/>to follow the design guidelines available at <a class="ulink" href="http://developer.android.com">http://developer.android.com</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec40"/>Summary</h1></div></div></div><p>In this chapter, we managed to create our very own mobile robot together with a companion Android application that we can use to control our robot.</p><p>We achieved this step by step by setting up an Arduino-enabled robot and coding the companion Android application. It uses the BLE software and hardware of an Android physical device running on Android 4.3 or higher.</p><p>In the final chapter, we will consider a more direct form of user interaction, by measuring our pulse rate using Android, Arduino, and a specific sensor.</p></div></body></html>