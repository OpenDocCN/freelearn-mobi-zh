<html><head></head><body>
        

                            
                    <h1 class="header-title">Accessing the Database</h1>
                
            
            
                
<p>In this chapter, we will learn about the database in the Spring Framework. The database is a collection of data that is stored in the server in an organized way, so that an application can retrieve the data in the way that the user requests. In this chapter, you will learn how to use the database on both the client and server side. In addition to this, we will explore the usage of JDBC, JPA, Hibernate, and MySQL from the server side, and we will look at the room persistence library from the client side.</p>
<p>This chapter covers the following topics:</p>
<ul>
<li style="font-weight: 400">What is a database?</li>
<li style="font-weight: 400">What is a database management system?</li>
<li style="font-weight: 400">Data access in Spring.</li>
<li style="font-weight: 400">Data access with JDBC in Spring.</li>
<li style="font-weight: 400">Creating a sample project using JDBC.</li>
<li style="font-weight: 400">Data access with JPA and Hibernate in Spring.</li>
<li style="font-weight: 400">Creating a sample project using JPA + Hibernate.</li>
<li style="font-weight: 400">What is the room persistence library?</li>
<li style="font-weight: 400">Creating an Android application using the room persistence library.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>We have previously demonstrated how to set up the environment and what tools, software, and IDE are needed in order to develop Spring. To create your project, visit this link: <a href="https://start.spring.io/">https://start.spring.io/</a>. The following options will be available here:</p>
<ul>
<li>Maven project</li>
<li>Language – Kotlin</li>
</ul>
<ul>
<li>Spring Boot version – 2.1.1 (SNAPSHOT)</li>
<li>When you create the project, you need to provide some information, such as—<strong>Group</strong>, <strong>Artifact</strong>, <strong>Name</strong>, <strong>Description</strong>, <strong>Package Name</strong>, <strong>Packaging</strong>, and <strong>Java Version</strong>.</li>
</ul>
<p>We will use MySQL in upcoming projects. Consequently, you need to download the tools for MySQL from <a href="https://dev.mysql.com/downloads/workbench/">https://dev.mysql.com/downloads/workbench/</a> and install it. Please try to configure the MySQL database with the given information to make your project easier:</p>
<pre>Host -- localhost<br/>Port -- 3306<br/>Username -- root<br/>Password -- 12345678</pre>
<p>The source code with an example for this chapter is available on GitHub at the following link: <a href="https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter06">https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter06</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Database</h1>
                
            
            
                
<p>A <strong>database</strong> is a collection of information that is stored in the server in an organized way. A user can fetch and use this data from the server in various systems. In the database, a user can add, delete, update, get, or manage the data. Normally, data is assembled into tables, columns, and rows, making it easier to find relevant data. A computer database contains aggregations of data records or files. A company's data can include their statistics or client information, or it can be top secret documents. A database manager provides the client or the user with the ability to control read and/or write access, analyze the data, and so on. We will now look at various types of database and their uses.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Types of database</h1>
                
            
            
                
<p>Databases are used for a variety of purposes, such as to store personal or company information. There are several databases available on the market, as described in the following sections.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Personal database</h1>
                
            
            
                
<p>A personal database is designed for data stored on a personal computer. This database is small and very easy to manage, and it is normally used by a small group of people or a small organization.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Relational database</h1>
                
            
            
                
<p>The relational database is created on a set of tables that fit into a pre-defined category. These databases are sorted by an arrangement of tables where information gets fit into a pre-characterized class. The table is comprised of rows and columns. The column has a passage for information for an explicit classification. On the other side, rows contain a case for that information characterized by the classification. The relational database has a standard user and application program interface named <strong>Structured Query Language</strong> (<strong>SQL</strong>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Distributed database</h1>
                
            
            
                
<p>A distributed database is stored in multiple physical locations and distributed at various sites of an organization. The sites are connected with the help of communication links, so the user can access the distributed data easily. There are two kinds of distributed database—homogeneous and heterogeneous. In a homogenous distributed database, the physical locations have the same hardware and run in the same OS and database applications. However, in the heterogeneous distributed database, the hardware, OS, or database applications can be found in a different location.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Object-oriented database</h1>
                
            
            
                
<p>In an object-oriented database, items are created by using object-oriented programming such as Java and C++, which are stored in relational databases. But for those items, an object-oriented database is well-suited. An object-oriented database is sorted out around objects as opposed to activities, and information instead of rationale.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">NoSQL database</h1>
                
            
            
                
<p>A NoSQL database is normally used for a large set of distributed data. This database is very effective for big data where an organization analyzes large chunks of unorganized data stored in multiple virtual servers in the cloud.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Graph database</h1>
                
            
            
                
<p>A graph database is a type of NoSQL database that uses graph theory to store, map, and query the relationships of the data. It is a collection of lots of nodes and edges. The nodes represent the entity and the edges represent the connection between nodes. This database is used a lot in social media platforms such as Facebook.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Cloud database</h1>
                
            
            
                
<p>A cloud database is mainly built for a virtualized environment. The virtualized environment can be a hybrid cloud, public cloud, or private cloud. These databases provide various benefits, such as the ability to pay for storage capacity and per-user basis bandwidth. As a software-as-a-server, it provides support to enterprise business applications.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Database management system</h1>
                
            
            
                
<p>A <strong>database management system</strong> (<strong>DBMS</strong>) is system software that is made for creating and managing databases. With the help of the <strong>DBMS</strong>, a user or a developer can create, get, update, and manage data in a systemic way. This system is kind of an interface between a user and a database. It also ensures that data is consistently organized and easily accessible.</p>
<p>Here is a diagram regarding the use of a <strong>DBMS</strong>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/d25e9f1c-fb8a-4046-8422-fa9d3ca02d48.png" style="width:16.25em;height:19.33em;"/></p>
<p>There are three important features of a <strong>DBMS</strong>, and these are the data, the database engine, and the database schema. The data is a collection of information, the database engine allows data to be locked, accessed, and modified, and the database schema defines the logical structure of the database.</p>
<p>The <strong>DBMS</strong> provides a general view of how data can be accessed by multiple users from multiple locations in a controlled manner. It also limits a user's access to user data. The database schema provides the logic of how a user can view the data. The <strong>DBMS</strong> handles all the requests and executes them on the database.</p>
<p>Both logical and physical data independence is offered by the <strong>DBMS</strong>. This means that an application can use APIs to utilize the data from the database. In addition, clients and applications don't need to worry about the locations of the stored data and changes to the physical structure of the data, such as storage and hardware.</p>
<p>Popular database models and their management systems include the following:</p>
<ul>
<li style="font-weight: 400"><strong>Relational database management system</strong> (<strong>RDMS</strong>)</li>
<li style="font-weight: 400">NoSQL DBMS</li>
<li style="font-weight: 400"><strong>In-memory database management system</strong> (<strong>IMDBMS</strong>)</li>
<li style="font-weight: 400"><strong>Columnar database management system</strong> (<strong>CDBMS</strong>)</li>
<li style="font-weight: 400">Cloud-based data management system</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Data access in the Spring</h1>
                
            
            
                
<p>Data access is responsible for authorizing access to data repositories. It helps to distinguish the <em>role</em> ability, like users or administrators in the application. It maintains the data access system, such as insert, retrieve, update, or delete based on the role. In <a href="5bf1668f-e909-4dff-837b-49e441bd0f47.xhtml">Chapter 3</a>, <em>Overview of Spring Framework</em>, we have learned about the architecture of Spring.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Here is a diagram of the Spring architecture, where <strong>Data Access</strong> is one of the layers:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/76a06808-b5d5-4223-957f-a4c24fa9088a.png" style="width:35.75em;height:31.58em;"/> </p>
<p class="CDPAlignLeft CDPAlign">As you can see, <strong>Data Access</strong> is one of the layers of Spring architecture. This part is concerned with data access. <strong>JDBC</strong>, <strong>ORM</strong>, <strong>OXM</strong>, <strong>JMS</strong>, and <strong>Transactions</strong> modules are modules that are used in Spring. We have mentioned the details of this in <a href="5bf1668f-e909-4dff-837b-49e441bd0f47.xhtml"/><a href="5bf1668f-e909-4dff-837b-49e441bd0f47.xhtml">Chapter 3</a>, <em>Overview of Spring Framework</em>, under the Spring architecture topic. In this chapter, we will see the use of <strong>JDBC</strong> and <strong>ORM</strong> (<strong>JPA</strong>, <strong>Hibernate</strong>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Java database connectivity in Spring</h1>
                
            
            
                
<p><strong>Java Database Connectivity</strong> (<strong>JDBC</strong>) is an API specification for connecting and moving data from the frontend to the backend. The classes and interfaces are written in Java. Nowadays, it also supports Kotlin. We will write in Kotlin throughout this chapter. This basically acts as an interface or bridge between the Java-based application and database. JDBC is very similar to the <strong>Open Database Connectivity</strong> (<strong>ODBC</strong>).<strong> </strong>Like ODBC, JDBC enables a JDBC application to access a collection of data. </p>
<p>In the Spring Framework, the JDBC is divided into the following four separate packages:</p>
<ul>
<li><strong>Core</strong>: This is the JDBC's core functionality and <kbd>JdbcTemplate</kbd>, <kbd>SimpleJdbcInsert</kbd>, and <kbd>SimpleJdbcCall</kbd> are the important classes of this core part</li>
<li><strong>DataSource</strong>: This is used to access data sources</li>
<li><strong>Object</strong>: The JDBC can access in an object-oriented manner. As a business object, it executes queries and returns the results</li>
<li><strong>Support</strong>: Support classes work under core and object packages</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a sample project using JDBC</h1>
                
            
            
                
<p>Let's learn JDBC using a project in which we will create REST APIs for users and show the list of user details. In this project, we will use JDBC, MySQL, and Spring Boot.</p>
<p>To create a project, go to this link: <a href="https://start.spring.io">https://start.spring.io</a> and create a Kotlin-based project. Here are the dependencies of JDBC:</p>
<ul>
<li style="font-weight: 400"><strong>JDBC</strong>: this will implement all the features regarding JDBC</li>
<li style="font-weight: 400"><strong>MySQL</strong>: this will implement all the features of MySQL database</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Maven dependencies</h1>
                
            
            
                
<p>If you go to the <kbd>pom.xml</kbd> file, there you can see the dependencies for the JDBC, and we are using MySQL for the data. Here is a piece of code of the <kbd>pom.xml</kbd> file:</p>
<pre><strong>-----<br/>-----<br/>&lt;!-- This is for JDBC use --&gt;<br/>&lt;dependency&gt;<br/>   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>   &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>-----<br/>-----<br/><br/>&lt;!-- This is for use the MySQL --&gt;<br/>&lt;dependency&gt;<br/>   &lt;groupId&gt;mysql&lt;/groupId&gt;<br/>   &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;<br/>   &lt;scope&gt;runtime&lt;/scope&gt;<br/>&lt;/dependency&gt;<br/>-----<br/>-----</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating DataSource</h1>
                
            
            
                
<p>We configure the DataSource and connection pool in the <kbd>application.properties</kbd>. Spring Boot uses the <kbd>spring.datasource</kbd> interface as a prefix to configure DataSource. Our database schema name is <kbd>packtpub_dbtest_schema</kbd>. You can create this on your own and rename it. Here are the details of <kbd>application.properties</kbd>:</p>
<pre># Database Configuration<br/><br/>spring.datasource.url=jdbc:mysql://localhost:3306/packtpub_dbtest_schema<br/>spring.datasource.username=root<br/>spring.datasource.password=12345678</pre>
<p>According to the previous code, <kbd>spring.datasource.url=jdbc:mysql:<br/></kbd><kbd>//localhost:3306/packtpub_dbtest_schema</kbd> means the URL for the database schema called <kbd>packtpub_dbtest_schema</kbd> to access the data in the project. <kbd>spring.datasource.username=root</kbd> means the username of the database is <kbd>root</kbd>, and <kbd>spring.datasource.password=12345678</kbd> means the username of the database is <kbd>12345678</kbd>.</p>
<p>In our system, the MySQL details are as follows:</p>
<pre>Host -- localhost                                    // the host URL<br/>Port -- 3306                                         // the host POST number<br/>Username -- root                                     // the username of the database<br/>Password -- 12345678                                 // the password of the database<br/>Database Name - packtpub_dbtest                      // the Database name<br/>Database Schema Name - packtpub_dbtest_schema        // the Database Schema name</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a table in database</h1>
                
            
            
                
<p>Go to the MySQL Workbench and select the database.</p>
<p class="mce-root"/>
<p>We have included some user details for the <kbd>USERS</kbd> table. You can copy and paste the following code to create a <kbd>USERS</kbd> table and insert some demo data:</p>
<pre>create table users (id int not null auto_increment, name varchar(255), email varchar(255), contact_number varchar(255)<br/>, primary key (id)) engine=MyISAM;<br/>INSERT INTO user (id, name, email, contact_number) values (1, 'Sunnat', 'sunnat629@gmail.com', '1234567890');<br/>INSERT INTO user (id, name, email, contact_number) values (2, 'Chaity', 'chaity123@gmail.com', '9876543210');<br/>INSERT INTO user (id, name, email, contact_number) values (3, 'Mirza', 'mirza123@gmail.com', '1234567800');<br/>INSERT INTO user (id, name, email, contact_number) values (4, 'Hasib', 'hasib123@gmail.com', '1234500800');<br/>INSERT INTO user (id, name, email, contact_number) values (4, 'Jisan', 'jisan123@gmail.com', '1004500800');<br/></pre>
<p>After inserting the user details in the user table, you can see the content in your <kbd>users</kbd> table, as in the following screenshot:  </p>
<p class="CDPAlignCenter CDPAlign"><img src="img/06df5d5d-6d98-4dfd-b94a-a44ed7f00a95.png" style="width:37.75em;height:31.83em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a model</h1>
                
            
            
                
<p>In this project, we will create a REST API to see the list of user details where we can get a username, email ID, and contact number. So let's create a model of a user; the class name is <kbd>UserModel.kt</kbd>.</p>
<p>Here is the code of the model class:</p>
<pre>data class UserModel(val id: Int,<br/>                     val name: String,<br/>                     val email: String,<br/>                     val contact_number: String)</pre>
<p>We have created a class named <kbd>UserModel</kbd>, where we have initialized <kbd>id</kbd>, <kbd>name</kbd>, <kbd>email</kbd>, and <kbd>contact_number</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating row mapper</h1>
                
            
            
                
<p><kbd>RowMapper</kbd> is an interface that is provided by the Spring JDBC. This is used to map a row with a Java object and to fetch data from the database. It uses the <kbd>query()</kbd> function of the <kbd>JdbcTemplate</kbd> class. Let's create a <kbd>RowMapper</kbd> interface named <kbd>UserRowMapper.kt</kbd>.</p>
<p>Here is the code of this interface:</p>
<pre>class UserRowMapper : RowMapper&lt;UserModel&gt; {<br/><br/>    @Throws(SQLException::class)<br/>    override fun mapRow(row: ResultSet, rowNumber: Int): UserModel? {<br/>        return UserModel(row.getInt("id"),<br/>                row.getString("name"),<br/>                row.getString("email"),<br/>                row.getString("contact_number"))<br/>    }<br/>}</pre>
<p>In this code, we extended <kbd>RowMapper&lt;UserModel&gt;</kbd> and overrode the <kbd>mapRow</kbd> where we return the <kbd>UserModel</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating an API interface</h1>
                
            
            
                
<p>To get a REST API response, we need to create an interface where we will mention what we want to do with the data, such as getting the user list, creating a new user, and deleting or updating the user details. Let's create an interface named <kbd>UserInterface.kt</kbd>.</p>
<p>Here is the code of the interface:</p>
<pre>interface UserInterface {<br/>    fun getAllUserList(): List&lt;UserModel&gt;<br/>    fun getUserByID(id: Int): UserModel?<br/>    fun addNewUser(userModel: UserModel)<br/>    fun updateUser(userModel: UserModel)<br/>    fun deleteUser(id: Int)<br/>}</pre>
<p>We have used five functions, which are explained as follows:</p>
<ul>
<li><kbd>getAllUserList()</kbd>: This will return a list of the details of all users</li>
<li><kbd>getUserByID(id: Int)</kbd>: This will return the details of a specific user</li>
<li><kbd>addNewUser(userModel: UserModel)</kbd>: This will add new user details</li>
<li><kbd>updateUser(userModel: UserModel)</kbd>: This will update an existing user's details</li>
<li><kbd>deleteUser(id: Int)</kbd>: This will delete a specific user</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a user repository</h1>
                
            
            
                
<p>We will communicate with the database in this class. This is a repository class and so we annotate this class with <kbd>@Repository</kbd>. Let's create a repository class named <kbd>UserRepository.kt</kbd>, which implements the <kbd>UsersInterface.</kbd></p>
<p>Here is the code of the repository class:</p>
<pre><strong>@Repository</strong><br/>class UserRepository: UsersInterface {<br/><br/>    override fun getAllUserList(): List&lt;UserModel&gt; {<br/>    }<br/><br/>    override fun getUserByID(id: Int): UserModel? {<br/>    }<br/><br/>    override fun addNewUser(userModel: UserModel) {<br/>    }<br/><br/>    override fun updateUser(userModel: UserModel) {<br/>    }<br/><br/>    override fun deleteUser(id: Int) {<br/>    }<br/>}</pre>
<p>We have created a repository class named <kbd>UserRepository</kbd>, where we implement <kbd>UsersInterface</kbd>, and override all the functions of the interface. We use the <kbd>@Repository</kbd> annotation to make it a repository class.</p>
<p class="mce-root">Let's complete this class step by step in the following section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">JdbcTemplate implementation</h1>
                
            
            
                
<p><kbd>JdbcTemplate</kbd> is the heart of the JDBC. This is the center class of JDBC. SQL queries are executed by <kbd>JdbcTemplate</kbd>, which also fetches the results. To use this <kbd>JdbcTemplate</kbd>, we need to autowire the <kbd>JdbcTemplate</kbd> in this repository class. Here is the piece of code of this repository class:</p>
<pre>@Repository<br/>class UserRepository: UserInterface {<br/><br/>    <strong>@Autowired<br/>    private lateinit var jdbcTemplate: JdbcTemplate</strong><br/>    ----<br/>    ----<br/>  }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating HTTP methods for RESTful APIs</h1>
                
            
            
                
<p>For this project, we will create <strong>create, read, update, and delete</strong> (<strong>CRUD</strong>) operations. </p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Create</h1>
                
            
            
                
<p>Find the code snippet pertaining to the create operation, where we will insert the user details:</p>
<pre>override fun addNewUser(userModel: UserModel) {<br/>    val addQuery = "INSERT INTO users (name, email, contact_number) values (?,?,?)"<br/>    jdbcTemplate.update(addQuery,userModel.name,userModel.email,userModel.contact_number)<br/>}</pre>
<p>The <kbd>addQuery = "INSERT INTO users (name, email, contact_number) values (?,?,?)"</kbd> is the query to insert the user in the USER table. </p>
<p>The <kbd>jdbcTemplate.update()</kbd> is the function where we use the query and user details as the parameters to insert in the database.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">READ</h1>
                
            
            
                
<p>Find the code snippet pertaining to the read operation. The following function will return a list of all the user's details:</p>
<pre>override fun getAllUserList(): List&lt;UserModel&gt; {<br/>    val selectAllSql = "SELECT * FROM users"<br/>    return jdbcTemplate.query(selectAllSql, UserRowMapper())<br/>}</pre>
<p><kbd>selectAllSql = "SELECT * FROM users"</kbd> is the query to fetch all the users from user the table. <kbd>jdbcTemplate.query()</kbd> will execute the query and fetch the data.</p>
<p>This following function will get a user's details based on <kbd>id</kbd>:</p>
<pre>override fun getUserByID(id: Int): UserModel? {<br/>    val selectAllSql = "SELECT * FROM users WHERE id = ?"<br/>    return jdbcTemplate.queryForObject(selectAllSql, UserRowMapper(), id)<br/>}</pre>
<p><kbd>selectAllSql = "SELECT * FROM users WHERE id = ?"</kbd> is the query to fetch a user from the user table by using the ID. <kbd>jdbcTemplate.queryForObjec()</kbd> will execute the query and fetch the data.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">UPDATE</h1>
                
            
            
                
<p>Find the code snippet for update operation:</p>
<pre>override fun updateUser(userModel: UserModel) {<br/>    val updateQuery = "UPDATE users SET name=?,email=?, contact_number=? WHERE id=?"<br/>    jdbcTemplate.update(updateQuery, userModel.name, userModel.email, userModel.contact_number, userModel.id)<br/>}</pre>
<p><kbd>updateQuery = "UPDATE users SET name=?,email=?, contact_number=? WHERE id=?"</kbd> is the query to update a user from the user table by using the ID. <kbd>jdbcTemplate.update()</kbd> will execute the query and update the data.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">DELETE</h1>
                
            
            
                
<p>Find the code snippet for delete operation:</p>
<pre>override fun deleteUser(id: Int) {<br/>    val deleteQuery = "DELETE FROM users WHERE id=?"<br/>    jdbcTemplate.update(deleteQuery, id)<br/>}</pre>
<p><kbd>deleteQuery = "DELETE FROM users WHERE id=?"</kbd> is the query to update a user from user table by using the ID. <kbd>jdbcTemplate.update()</kbd> will execute the query and delete the specific data.</p>
<p>With these functions, we have finished our repository class.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating service</h1>
                
            
            
                
<p>After creating the repository class, let's create the service class where we will autowire the repository class using the <kbd>@autowired</kbd> annotation. Let's create a service class named <kbd>UserService.kt</kbd> with the <kbd>@Service</kbd> annotation that implements the <kbd>UserInterface</kbd> and overrides all functions.</p>
<p>Here is the piece of code for the <kbd>UserService.kt</kbd><strong>:</strong></p>
<pre>@Service<br/>class UserService: UsersInterface {<br/>    <br/>    <strong>@Autowired</strong><br/><strong>    private lateinit var userRepository: UserRepository</strong><br/><br/>    ------<br/>    ------<br/>}</pre>
<p>Let's override and modify the functions with the help of <kbd>UserRepository</kbd>. Here is the full code of the <kbd>UserService</kbd> class:</p>
<pre>@Service<br/>class UserService: UsersInterface {<br/>    @Autowired<br/>    private lateinit var userRepository: UserRepository<br/><br/>    override fun getAllUserList(): List&lt;UserModel&gt; {<br/>        return userRepository.getAllUserList()<br/>    }<br/><br/>    override fun getUserByID(id: Int): UserModel? {<br/>        return userRepository.getUserByID(id)<br/>    }<br/><br/>    override fun addNewUser(userModel: UserModel) {<br/>        userRepository.addNewUser(userModel)<br/>    }<br/><br/>    override fun updateUser(userModel: UserModel, id: Int) {<br/>        userRepository.updateUser(userModel, id)<br/>    }<br/><br/>    override fun deleteUser(id: Int) {<br/>        userRepository.deleteUser(id)<br/>    }<br/>}</pre>
<ul>
<li><kbd>getAllUserList()</kbd>: This function will fetch all the users</li>
<li><kbd>getUserByID(id: Int)</kbd>: This function will fetch a user by ID</li>
<li><kbd>addNewUser(userModel: UserModel)</kbd>: This function will insert a new user</li>
<li><kbd>updateUser(userModel: UserModel, id: Int)</kbd>: This function will update a user by ID</li>
<li><kbd>deleteUser(id: Int)</kbd>: This function will delete a user by ID</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating controller</h1>
                
            
            
                
<p>If your model, repository, and service classes are complete, then you are ready to create the controller class, where we will create <kbd>GetMapping</kbd>, <kbd>PostMapping</kbd>, <kbd>PutMapping</kbd>, and <kbd>DeleteMapping</kbd> to create RESTful API URL paths. Let's create a controller class named <kbd>UserController.kt</kbd> using the <kbd>@RestController</kbd> annotation to create the controller class:</p>
<pre>@RestController<br/>class UserController {<br/>    ----<br/>    ----<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Autowired service</h1>
                
            
            
                
<p>Let's autowire the <kbd>UserService</kbd> using the <kbd>@Autowired</kbd> annotation. Here is the piece of code for this <kbd>UserController</kbd> class:</p>
<pre> <strong>@Autowired<br/> private lateinit var userService: UserService</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting the user list</h1>
                
            
            
                
<p>Find the code snippet for the <kbd>getAllUsers()</kbd> operation:</p>
<pre>//    Getting the User List<br/><strong>@GetMapping(path = ["/users"])</strong><br/>fun getAllUsers(): ResponseEntity&lt;List&lt;UserModel&gt;&gt; {<br/>    return ResponseEntity(userService.getAllUserList(),<br/>            HttpStatus.OK)<br/>}</pre>
<p>The <kbd>@GetMapping(path = ["/users"])</kbd> annotation is the URL path of <kbd>/users</kbd> and it is a <kbd>GET</kbd>  request function. Here, we will get a list of the users from the database.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting one user by ID</h1>
                
            
            
                
<p>Find the code snippet for the <kbd>getAllUserByID()</kbd> operation:</p>
<pre>//    Getting one User by ID<br/><strong>@GetMapping(path = ["/user/{id}"])</strong><br/>fun getAllUserByID(<strong>@PathVariable("id") id: Int</strong>): ResponseEntity&lt;UserModel&gt; {<br/>    return ResponseEntity(userService.getUserByID(id),<br/>            HttpStatus.OK)<br/>}</pre>
<p>The <kbd>@GetMapping(path = ["/user/{id}"])</kbd> annotation is the URL path of <kbd>"/user/{id}"</kbd>, and it is a <kbd>GET</kbd> request with a specific ID. Here, we will get the specific user details from the database.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Inserting a new user</h1>
                
            
            
                
<p>Find the code snippet for <kbd>addNewUser()</kbd> operation:</p>
<pre>//    Inserting new User<br/><strong>@PostMapping(path = ["/user/new"])</strong><br/>fun addNewUser(<strong>@RequestBody userModel: UserModel</strong>): String {<br/>    ResponseEntity(userService.addNewUser(userModel), HttpStatus.CREATED)<br/>    return "${userModel.name} has been added to database"<br/>}</pre>
<p>The <kbd>@PostMapping(path = ["/user/new"])</kbd> annotation is the URL path of <kbd>"/user/new"</kbd>, and it is a <kbd>POST</kbd> request. Here, we can insert user details into the database.</p>
<p>Here, <kbd>@RequestBody</kbd> is an annotation of the Spring MVC framework. This is used in a controller to implement object serialization and deserialization. It helps you to avoid boilerplate codes by extracting the logic. The <kbd>@RequestBody</kbd> annotated function returns a value that is bound to the HTTP web response body. Here, the object is <kbd>UserModel</kbd>. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Updating a user</h1>
                
            
            
                
<p>Find the code snippet for <kbd>updateUser()</kbd> operation:</p>
<pre>//    Updating a User<br/><strong>@PutMapping(path = ["/user/{id}"])</strong><br/>fun updateUser(@RequestBody userModel: UserModel, @PathVariable("id") id: Int): ResponseEntity&lt;UserModel&gt; {<br/>    userService.updateUser(userModel, id)<br/>    return ResponseEntity(userModel, HttpStatus.OK)<br/>}</pre>
<p>The <kbd>@PutMapping(path = ["/user/{id}"])</kbd> annotation is the URL path of <kbd>"/user/{id}"</kbd>, and it is a <kbd>PUT</kbd> request with a specific ID. Here, we will update the specific user details in the database.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Deleting a user </h1>
                
            
            
                
<p>Find the code snippet for <kbd>deleteUser()</kbd> operation:</p>
<pre>//    Deleting a User<br/><strong>@DeleteMapping(path = ["/user/{id}"])</strong><br/>fun deleteUser(@PathVariable("id") id: Int): String {<br/>    userService.deleteUser(id)<br/>    return "$id User has been deleted."<br/>}</pre>
<p>The <kbd>@DeleteMapping(path = ["/user/{id}"])</kbd> annotation is the URL path of <kbd>"/user/{id}"</kbd>, and it is a delete request with a specific ID. Here, we will delete the specific user details from the database.</p>
<p class="mce-root">If you finish this controller class, then you are ready to run this application and test the REST API using Insomnia.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing the output</h1>
                
            
            
                
<p>Let's <em>run</em> the project. If the project doesn't experience an error, then you'll be able to see the RUN tab of the IDE, as demonstrated in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/5a54fe0a-7b95-4c30-9c1c-1d0e2a632881.png"/></p>
<p>Now, open the Insomnia app. Let's apply the REST API request in this app.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting the user list</h1>
                
            
            
                
<p>Use this <kbd>GET</kbd> request with this URL: <kbd>http://localhost:8080/users</kbd>, and hit Send. The user details will be fetched from the database and you can see the return JSON value, as the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/71c87cb5-fd73-4546-89b8-355d4bb07264.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting one user by ID</h1>
                
            
            
                
<p>Create a <kbd>GET</kbd> function with this URL: <kbd>http://localhost:8080/user/1</kbd>, and hit Send. The user details will be fetched from the database and you can see the return JSON value of a user whose <kbd>id</kbd> is <kbd>1</kbd>, as in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/636d9fb9-4c4d-4cdd-9943-d39d4ac5596a.png" style="width:54.17em;height:15.17em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Inserting a new user</h1>
                
            
            
                
<p>Create a <kbd>POST</kbd> function with this URL: <kbd>http://localhost:8080/user/new</kbd> a and hit Send. This will insert a user in the database and show the new user details, as in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/3373d7b0-1c14-4c8b-801b-d4c4e6a811e4.png"/></p>
<p>If you use the <kbd>/users</kbd> <kbd>GET</kbd> request URL path, you can check the user list containing the new user: </p>
<p class="CDPAlignCenter CDPAlign"><img src="img/998d9d15-db95-4257-9342-9b940defbb2e.png"/></p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Updating a user</h1>
                
            
            
                
<p>Create an <kbd>UPDATE</kbd> function with this URL: <kbd>http://localhost:8080/user/8</kbd>, and hit Send. It will update the user who has the ID number eight in the database and shows the updated user information, as in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/207e2708-513c-4c16-ac8b-a8be932f2d29.png"/></p>
<p>If you use the <kbd>http://localhost:8080/user/8</kbd> <kbd>GET</kbd> request URL path, you can check the new user with the new details like the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/957a9089-b535-4d62-be91-8a380315a01f.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Deleting a user </h1>
                
            
            
                
<p>Create a <kbd>DELETE</kbd> function with this URL: <kbd>http://localhost:8080/users</kbd>, and hit Send. This will delete the specific user from the database, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c140f020-594e-4845-80ca-b03ae30ccd9e.png"/></p>
<p>If you check all the users, then you will see that there are only seven.</p>
<p>Finally, we have created an application that is using JDBC, and we have also created a REST API. You can check out our GitHub project for the latest update if there is any. I also add a SQL file with the MySQL code. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Java Persistence API</h1>
                
            
            
                
<p>The<strong> </strong><strong>Java Persistence API</strong> (<strong>JPA</strong>) is an approach to <strong>object-relational mapping</strong> (<strong>ORM</strong>). ORM is a system that maps Java objects to databases, tables, and vice-versa. JPA can be used in both Java enterprise and standard edition-based applications. Hibernate, TopLink, EclipseLink, and Apache OpenJPA are the implementations of the JPA. Among these, Hibernate is the most advanced and widely used.</p>
<p>JPA helps the developer to work directly with the objects, and therefore, there is no need to worry about the SQL statements. With the help of the JPA, they can map, store, update, and fetch the data from a relational database to a Java object or vice versa. </p>
<p>JPA metadata is mainly defined by the annotation in a class. However, it also supports XML, which means it can be defined by XML. We will use the annotation to define the JPA metadata throughout this book. Now, we will see the architecture of JPA, and its uses.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Architecture of JPA</h1>
                
            
            
                
<p>The following diagram shows the class-level architecture of JPA:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/23abc5c8-a595-4dc1-9048-2070b34bd557.png" style="width:31.00em;height:29.17em;"/></p>
<p>Let's describe the diagram:</p>
<ul>
<li><kbd>EntityManagerFactory</kbd>: A factory class of <kbd>EntityManager</kbd> that creates and manages multiple <kbd>EntityManager</kbd> instances.</li>
<li><kbd>EntityManager</kbd>: This is an interface that manages the persistence operations on objects.</li>
<li><kbd>Entity</kbd>: This is a persistence object that is stored as records in the database</li>
<li><kbd>EntityTransaction</kbd>: This has a one-to-one relationship with <kbd>EntityManager</kbd>. For each <kbd>EntityManager</kbd>, operations are maintained by the <kbd>EntityTransaction</kbd> class.</li>
<li><kbd>Query</kbd>: This is an interface that is implemented by each JPA vendor to obtain relational objects with the criteria.</li>
<li><kbd>Persistence</kbd>: This is a class. To obtain an <kbd>EntityManagerFactory</kbd> instance, it contains static methods.</li>
</ul>
<p> </p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>If you look at the diagram again, you may notice that there is some relation between the classes and interfaces that belong to the <kbd>javax.presistence</kbd> package:</p>
<ul>
<li class="mce-root">Between <kbd>EntityManagerFactory</kbd> and <kbd>EntityManager</kbd>, there is a one-to-many relationship</li>
<li>Between <kbd>EntityManager</kbd> and <kbd>EntityTransaction</kbd>, there is a one-to-one relationship</li>
<li>Between <kbd>EntityManager</kbd> and <kbd>Query</kbd>, there is a one-to-many relationship</li>
<li>Between <kbd>EntityManager</kbd> and <kbd>Entity</kbd>, there is a one-to-many relationship</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a project using JPA</h1>
                
            
            
                
<p>Let's create a simple project using Spring Boot with JPA, as well as Hibernate and MySQL. We will build a RESTful CRUD API of a user list. </p>
<p>To create a project, go to this link: <a href="https://start.spring.io">https://start.spring.io</a> and create a Kotlin-based project.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Maven dependencies</h1>
                
            
            
                
<p>If you go to the <kbd>pom.xml</kbd> file, you can see the dependencies for the JDBC there. We are using MySQL for the database:</p>
<pre><strong>-----<br/>-----<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/><br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/><br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;com.h2database&lt;/groupId&gt;<br/>    &lt;artifactId&gt;h2&lt;/artifactId&gt;<br/>    &lt;scope&gt;runtime&lt;/scope&gt;<br/>&lt;/dependency&gt;<br/><br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;mysql&lt;/groupId&gt;<br/>    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;<br/>    &lt;scope&gt;runtime&lt;/scope&gt;<br/>&lt;/dependency&gt;<br/>-----<br/>-----</strong></pre>
<p class="mce-root">According to this code, here are the dependencies:</p>
<ul>
<li class="mce-root">Web</li>
<li class="mce-root">JPA</li>
<li class="mce-root">MySQL</li>
<li class="mce-root">H2</li>
</ul>
<p class="mce-root">Here, we have seen a new dependency named <kbd>h2</kbd>. This is one of the well known, in-memory databases. Spring Boot and H2 have a great combination between one another.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the DataSource</h1>
                
            
            
                
<p>We configure the <em>DataSource </em>and <em>connection pool</em> in the <kbd>application.properties</kbd>. Spring boot uses the <kbd>spring.datasource</kbd> interface as a prefix to configure DataSource. Our database schema name is <kbd>cha6_dbtest_schema</kbd>. You can create this on your own and rename it. Here are the details of <kbd>application.properties</kbd>:</p>
<pre>## <strong>Spring DATASOURCE (DataSourceAutoConfiguration &amp; DataSourceProperties)</strong><br/>spring.datasource.url = jdbc:mysql://localhost:3306/cha6_dbtest_schema?useSSL=false<br/>spring.datasource.username = root<br/>spring.datasource.password = 12345678<br/><br/><br/><strong>## Hibernate Properties<br/># The SQL dialect makes Hibernate generate better SQL for the chosen database<br/></strong>spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5Dialect<br/><br/><strong># Hibernate ddl auto (create, create-drop, validate, update)<br/></strong>spring.jpa.hibernate.ddl-auto = update</pre>
<p>In our system, the MySQL details are as follows:</p>
<ul>
<li><kbd>Host -- localhost</kbd></li>
<li><kbd>Port -- 3306</kbd></li>
<li><kbd>Username -- rootPassword -- 12345678</kbd></li>
<li><kbd>Database Name - packtpub_dbtest</kbd></li>
<li><kbd>Database Schema Name - packtpub_dbtest_schema</kbd></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a model</h1>
                
            
            
                
<p>In this project, we will create a REST API to see the list of user details where we can get a username, email ID, and contact number. So let's create a model of a user where the class name is <kbd>UserModel.kt</kbd>.</p>
<p>Here is the code of the model class:</p>
<pre>@Entity<br/>@Table(name="user_jpa")<br/>@EntityListeners(AuditingEntityListener::class)<br/>data class UserModel(<br/>    @Id<br/>    @GeneratedValue(strategy = GenerationType.IDENTITY)<br/>    @Column(name = "id")<br/>    var id: Long = 0,<br/><br/>    @NotBlank<br/>    @Column(name = "name")<br/>    var name: String ?= null,<br/><br/>    @NotBlank<br/>    @Column(name = "email")<br/>    var email: String ?= null,<br/><br/>    @NotBlank<br/>    @Column(name = "contact_number")<br/>    var contact_number: String ?= null<br/>)</pre>
<p>Here, our <kbd>UserModel</kbd> class has the following fields:</p>
<ul>
<li><kbd>id</kbd>: Primary key with auto increment</li>
<li><kbd>name</kbd>:  (NOT NULL field)</li>
<li><kbd>email</kbd>: (NOT NULL field)</li>
<li><kbd>contact_number</kbd>: (NOT NULL field)</li>
</ul>
<p>Unlike JDBC, you don't need to create any table manually in your database. JPA will create a table using the <kbd>UserModel</kbd>. Let's look at how to create a table in our database using this <kbd>UserModel</kbd> object:</p>
<ul>
<li><kbd>@Entity</kbd>: All your domain models must be annotated with this annotation. This annotation is used to mark the class as a persistent Java class.</li>
<li class="mce-root"><kbd>@Table</kbd>: This annotation is used to provide the details of the table. The entity will be mapped by it.</li>
<li class="mce-root"><kbd>@Id</kbd>: This is used to define the primary key.</li>
<li class="mce-root"><kbd>@GeneratedValue</kbd>: This annotation is used to define the primary key generation strategy. In the preceding case, we have declared the primary key as an auto increment field.</li>
<li class="mce-root"><kbd>@NotBlank</kbd>: This is used to verify that the annotated field is not null or empty.</li>
<li class="mce-root"><kbd>@Column</kbd>: This is used to verify the properties of the column that will be mapped to the annotated field.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a user repository</h1>
                
            
            
                
<p>We will communicate with the database in this repository class. This is a <kbd>Repository</kbd> class, and so we annotate it with <kbd>@Repository</kbd>. Let's create a <kbd>Repository</kbd> class named <kbd>UserRepository.kt</kbd>, which extends the <kbd>JpaRepository</kbd>.  By extending <kbd>JpaRepository</kbd>, this interface will get a set of generic CRUD functions to create, update, delete, and fetch the data. </p>
<p>Here is the code of the <kbd>Repository</kbd> class:</p>
<pre>@Repository<br/>interface UserRepository: <strong>JpaRepository&lt;UserModel, Long&gt;</strong></pre>
<p>Here are some functions we will get from this <kbd>JPARepository</kbd>:</p>
<ul>
<li><kbd>List&lt;T&gt; findAll()</kbd>: To fetch all the data</li>
<li class="mce-root"><kbd>List&lt;T&gt; findAll(Sort var1)</kbd> : To fetch all the data in sort</li>
<li class="mce-root"><kbd>List&lt;T&gt; findAllById(Iterable&lt;ID&gt; var1)</kbd>: To fetch data by ID</li>
<li class="mce-root"><kbd>&lt;S extends T&gt; List&lt;S&gt; saveAll(Iterable&lt;S&gt; var1)</kbd>: To insert data using the list of a data</li>
</ul>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating controller</h1>
                
            
            
                
<p>If your model and repository classes are complete, then you are ready to create the controller class where we will create the <kbd>GetMapping</kbd>, <kbd>PostMapping</kbd>, <kbd>PutMapping</kbd>, and <kbd>DeleteMapping</kbd> to create <em>RESTful API URL</em> paths. Let's create a controller class named <kbd>UserController.kt</kbd> using the <kbd>@RestController</kbd> annotation to create the controller class:</p>
<pre><strong>@RestController</strong><br/>class UserController {<br/>    ----<br/>    ----<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Autowired repository</h1>
                
            
            
                
<p class="mce-root">Let's autowire the <kbd>UserRepository</kbd> using the <kbd>@Autowired</kbd> annotation. Here is the piece of code of this class:</p>
<pre>@RestController<br/>class UserController {<br/><br/>    <strong>@Autowired</strong><br/><strong>    private lateinit var userRepository: UserRepository</strong><br/><br/>    ----<br/>    ----<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting the user list</h1>
                
            
            
                
<p>Find the code snippet for <kbd>getAllUsers()</kbd> operation:</p>
<pre>// to get all the users details<br/><strong>    @GetMapping("/users")</strong><br/>    fun getAllUsers(): List&lt;UserModel&gt;{<br/>        return <strong>userRepository.findAll()</strong><br/>    }</pre>
<p>The <kbd>@GetMapping(path = ["/users"])</kbd> annotation means it is used to <kbd>GET</kbd> a request. Here, we will get a list of the users from the database using <kbd>findAll()</kbd> of the <kbd>UserRepository</kbd> interface, which implemented <kbd>JpaRepository</kbd>. Consequently, we don't need to create a <em>custom interface</em>, unlike <em>JDBC</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting one user by ID</h1>
                
            
            
                
<p>Find the code snippet <kbd>getAllUserByID()</kbd> operation as follows:</p>
<pre> // to get one specific user details<br/><strong>    @GetMapping("/user/{id}")</strong><br/>    fun getUser(<strong>@PathVariable(name = "id")</strong> id: Long): UserModel {<br/>        return userRepository<strong>.findById(id).get()</strong><br/>    }</pre>
<p>The <kbd>@GetMapping(path = ["/user/{id}"])</kbd> annotation is the URL path of <kbd>"/user/{id}"</kbd>, and it is a  <kbd>GET</kbd> request with a specific ID. Here, we return <kbd>findById(id).get()</kbd> to get the specific user details from the database.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Inserting new user</h1>
                
            
            
                
<p>Find the code snippet for <kbd>addNewUser()</kbd> operation as follows:</p>
<pre>// to add a user<br/><strong>@PostMapping("/users")</strong><br/>fun addUser(<strong>@Valid @RequestBody userModel: UserModel</strong>): UserModel {<br/>    return userRepository<strong>.save(userModel)</strong><br/>}</pre>
<p>The <kbd>@PostMapping(path = ["/user/"])</kbd>  annotation is the URL path of <kbd>"/user/"</kbd>, and it is a <kbd>POST</kbd> request. Here, we enter the details of a user to insert the user data in the database.</p>
<p>To bind the request body with a method parameter, we are using the <kbd>@RequestBody</kbd> annotation.</p>
<p class="mce-root">The <kbd>@Valid</kbd> annotation makes sure that the request body is valid and not null. </p>
<p>Here, we return <kbd>save(userModel)</kbd> to insert new user details into the database.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Updating a user</h1>
                
            
            
                
<p>Find the code snippet for the <kbd>updateUser()</kbd> operation:</p>
<pre> // to update a user<br/>    <strong>@PutMapping("/user/{id}")</strong><br/>    fun updateUser(<strong>@PathVariable(name = "id")id: Long, @Valid @RequestBody userDetails: UserModel</strong>): UserModel {<br/>        val currentUser: UserModel = userRepository.findById(id).get()<br/><br/>        currentUser.name = userDetails.name<br/>        currentUser.email = userDetails.email<br/>        currentUser.contact_number = userDetails.contact_number<br/><br/>        return <strong>userRepository.save(currentUser)</strong><br/>    }</pre>
<p>The <kbd>@PutMapping("/user/{id}")</kbd> annotation is the URL path of <kbd>"/user/{id}"</kbd>, and it is a <kbd>PUT</kbd> request with a specific ID. Here, we will update the specific user details in the database.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Deleting a user </h1>
                
            
            
                
<p>Find the code snippet for <kbd>deleteUser()</kbd> operation as follows:</p>
<pre>// to delete a user<br/><strong>    @DeleteMapping("/user/{id}")</strong><br/>    fun deleteUser(<strong>@PathVariable(name = "id")id: Long</strong>): ResponseEntity&lt;*&gt;{<br/>        userRepository.delete(userRepository.findById(id).get())<br/>        return ResponseEntity.ok().build&lt;Any&gt;()<br/>    }</pre>
<p>The <kbd>@DeleteMapping("/user/{id}")</kbd> annotation is the URL path of <kbd>"/user/{id}"</kbd> and it is a <kbd>DELETE</kbd> request with a specific ID. Here we will delete the specific user details from the database.</p>
<p class="mce-root">If you finish this controller class, then you are ready to run this application and test the <em>REST API</em> using <em>Insomnia</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Seeing the output</h1>
                
            
            
                
<p>Before running the project, go to the MySQL Workbench app, the <kbd>cha6_dbtest</kbd> table, and <kbd>cha6_dbtest_schema</kbd>. There you will notice that there will be no table named <kbd>user_jpa</kbd>, which was mentioned in the <kbd>UserModel</kbd> class as a table name. </p>
<p>Here is the screenshot of the schema where we have no table:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/188960bb-780e-4a2d-8682-c8b01b212ced.png" style="width:14.83em;height:9.50em;"/></p>
<p>Let's run the application, check the database again, and <em>refresh</em> the schema. Notice that now there is a table as we mentioned in the <kbd>@Table</kbd> annotation of the <kbd>UserModel</kbd>. This has all the columns of that object, including—<kbd>id</kbd>, <kbd>name</kbd>, <kbd>email</kbd>, and <kbd>contact_number</kbd>.</p>
<p>Here is the screenshot of the updated database:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/1218d344-9441-4430-8872-30c29dc0306b.png" style="width:37.92em;height:19.58em;"/></p>
<p>The testing system is the same as the JDBC. Please check this yourself, and if you are confused, then go to the <kbd>Testing the Output of JDBC</kbd> project.</p>
<p>Here is the REST API URL of this project:</p>
<ul>
<li><kbd>GET http://localhost:8080/users</kbd>: To get a list of all users</li>
<li><kbd>GET http://localhost:8080/user/1</kbd>: To get a specific user details</li>
<li><kbd>POST http://localhost:8080/user/new</kbd>: To insert a new user</li>
<li><kbd>PUT http://localhost:8080/user/1</kbd>: To update a specific user details</li>
<li><kbd>DELETE http://localhost:8080/user/2</kbd>: To delete a specific user details</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Database of client-side application</h1>
                
            
            
                
<p>Up to this point, you have learned about databases for the server-side. Now we are going to understand databases for the client-side. The Android application will be our client-side application. The demand for Android is now rapidly increasing, and it has also surpassed the PC-based operating systems. Even nowadays, hardware is also more powerful than a PC or laptop. </p>
<p>The database is the essential part for a smart device, and it is the best way to store and manage the data on a device. This data can be handled in two ways. One way is online based, which means all the data is handled by a server-side or cloud and mobile communicates with them through the network. Without the internet connection, this system is almost useless. The second option is to store all the data in the local database. This means that it can be used offline and is also less dependent on the internet.</p>
<p>There are some criteria for the mobile-based database:</p>
<ul>
<li>Lightweight and fast</li>
<li>Secured</li>
<li>Independent from an online server</li>
<li>Easy to handle using the code</li>
<li>Can be shared publicly or privately</li>
<li>Low power consumption and low memory</li>
</ul>
<p>There are lots of mobile databases available on the market but very few databases have met these criteria. <em>SQLite</em>, <em>Realm</em> DB,<em> </em>and <em>ORMLite</em> are few of them. </p>
<p>We will use the SQLite database throughout this book. However, we are not going to use the raw SQLite. We will instead use a library called <strong>room persistence library</strong>, which is part of the architecture components. IT provides an abstraction layer over the SQLite. This allows database access that is more robust and helps with much less code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Architecture components</h1>
                
            
            
                
<p>The <strong>architecture components</strong> are one of the components of Android Jetpack. This is a guideline for application architecture. This component is built on some libraries to do common tasks in an easier way. With the help of this component, a developer can develop their project, which can be robust, maintainable, and testable.</p>
<p>Today we will create an Android offline application where we will use Android components.</p>
<p>Here is the diagram of this architecture:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/4036109a-4261-42a4-8c4a-827082753e00.png" style="width:18.08em;height:38.67em;"/></p>
<p>The following is a brief description of all the components:</p>
<ul>
<li class="mce-root"><kbd>UI Controller</kbd>: UI components like activities and fragments are under this component.</li>
<li class="mce-root"><kbd>ViewModel</kbd>: This fetches data with the help of model and provides it to the UI.</li>
<li class="mce-root"><kbd>LiveData</kbd>: This class holds the observable data. This is lifecycle-aware, unlike the regular observable.</li>
</ul>
<ul>
<li class="mce-root"><kbd>Repository</kbd>: This manages multiple data sources.</li>
<li class="mce-root"><kbd>Room Database</kbd>: This is a top database layer, which is from the SQLite database.</li>
<li class="mce-root"><kbd>Entity</kbd>: This describes a database table.</li>
<li class="mce-root"><kbd>DAO</kbd>: The full form is <strong>a data access object</strong> (<strong>DAO</strong>). It maps SQL queries.</li>
<li class="mce-root"><kbd>SQLite database</kbd>: Data is stored using this in the device. It is created and maintained by the room.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating an Android app</h1>
                
            
            
                
<p>Let's create a simple Android app that has a database. This will store the details of users (including name, contact number, and email ID) and show these details in a list using <kbd>RecyclerView</kbd>.</p>
<p>First of all, we need to create an app from Android Studio, write down your project, and the company domain. Don't forget to check Include Kotlin support to make it a Kotlin-based application. The following screenshot shows the Create Android Project window:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/5aa17e9c-f14d-4317-8c77-eb74dd4679b4.png" style="width:48.83em;height:31.17em;"/></p>
<p>Now select the minimum API version from the Phone and Tablet option. There is no need to add other options for this project. After clicking Next in the Add an Activity to Mobile, you can select Basic Activity and then, after renaming the <strong>Activity Name</strong> and <strong>layout</strong>, click Finish. After building the project, you will be ready to start creating an Android app.</p>
<p>Here is the screenshot of the Add an Activity to Mobile window and here we select the Basic Activity template like the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/26c14aa1-f124-4f41-9194-6b8143ecb1f0.png" style="width:55.00em;height:39.75em;"/></p>
<p>The final files of this project are shown in the following screenshot, where you can see all the files and resources after finishing this project:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/60d4d013-e5f3-4f79-a3c5-23a86660368c.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Gradle information</h1>
                
            
            
                
<p>Here are the details of my Android Studio's Gradle file:</p>
<pre>buildscript {<br/>   -----<br/>-----<br/>    dependencies {<br/><strong>        classpath 'com.android.tools.build:gradle:3.2.1'</strong><br/><strong>        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:1.3.10"</strong><br/><br/>    }<br/>}<br/>-----<br/>-----</pre>
<p>This file injects the dependencies of the Gradle and Kotlin. In this project, the Gradle version is 3.2.1 and the Kotlin version is 1.3.10</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Gradle dependencies</h1>
                
            
            
                
<p>This Gradle file is for the application. It contains all the dependencies and other Android SDK versions.</p>
<p class="mce-root">Here is the following code in the dependencies block:</p>
<pre>      // Room components<br/>    implementation "android.arch.persistence.room:runtime:$rootProject.roomVersion"<br/>    kapt "android.arch.persistence.room:compiler:$rootProject.roomVersion"<br/>    androidTestImplementation "android.arch.persistence.room:testing:$rootProject.roomVersion"<br/><br/>    // Lifecycle components<br/>    implementation "android.arch.lifecycle:extensions:$rootProject.archLifecycleVersion"<br/>    kapt "android.arch.lifecycle:compiler:$rootProject.archLifecycleVersion"<br/><br/>    // Coroutines<br/>    api "org.jetbrains.kotlinx:kotlinx-coroutines-core:$rootProject.coroutines"<br/>    api "org.jetbrains.kotlinx:kotlinx-coroutines-android:$rootProject.coroutines"</pre>
<p>To enable the coroutines features, add the following code end of the app's <kbd>build.gradle</kbd> file:</p>
<pre>kotlin {<br/>    experimental {<br/><strong>        coroutines "enable"<br/></strong>    }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating entity</h1>
                
            
            
                
<p>Let's create a class of user named <kbd>UserModel.kt</kbd> with the <kbd>@Entity</kbd> annotation so that each user is an entity. All variables columns shouldn't be private and so that <kbd>Room</kbd> will able to instantiate your objects:</p>
<pre>@Entity(tableName = "users")<br/>class Users(): Parcelable {<br/>    @PrimaryKey(autoGenerate = true)<br/>    @NonNull<br/>    @ColumnInfo(name = "userId")<br/>    var userId: Int = 0<br/><br/>    @NonNull<br/>    @ColumnInfo(name = "username")<br/>    lateinit var username: String<br/><br/>    @NonNull<br/>    @ColumnInfo(name = "email")<br/>    lateinit var email: String<br/><br/>    @NonNull<br/>    @ColumnInfo(name = "contactNumber")<br/>    lateinit var contactNumber: String<br/><br/>   @NonNull<br/>    @ColumnInfo(name = "address")<br/>    lateinit var address: String<br/><br/>    constructor(username: String, email: String, contactNumber: String, address: String):this(){<br/>        this.username = username<br/>        this.email = email<br/>        this.contactNumber = contactNumber<br/>        this.address = address<br/>    }<br/><br/>    override fun toString(): String {<br/>        return "Users(username='$username', email='$email', contactNumber='$contactNumber', address='$address')"<br/>    }<br/>}</pre>
<p>Let's see what is in this class:</p>
<ul>
<li><kbd>@Entity(tableName = "users")</kbd>: An entity class represents a table, and our table name is <kbd>users</kbd></li>
<li><kbd>@ColumnInfo(name = "**")</kbd>: This specifies a name in the table</li>
<li><kbd>@PrimaryKey(autoGenerate = true)</kbd>: This means the <kbd>ID</kbd> is our primary key and it will automatically increase the value</li>
<li><kbd>@NonNull</kbd>: This means there will be no null or empty value in the columns</li>
</ul>
<p class="mce-root"/>
<p>To pass this object from one activity to another, we need to convert this class into a <kbd>Parcelable</kbd> class. So let's extend this class. In the traditional way, it will need lots of code like the following:</p>
<pre>@Entity(tableName = "users")<br/>class Users(): Parcelable {<br/>    ----<br/>    ----<br/>    constructor(parcel: Parcel) : this() {<br/>        userId = parcel.readInt()<br/>        username = parcel.readString()!!<br/>        email = parcel.readString()!!<br/>        contactNumber = parcel.readString()!!<br/>        address = parcel.readString()!!<br/>    }<br/>    ----<br/>    ----<br/>    override fun writeToParcel(parcel: Parcel, flags: Int) {<br/>        parcel.writeInt(userId)<br/>        parcel.writeString(username)<br/>        parcel.writeString(email)<br/>        parcel.writeString(contactNumber)<br/>        parcel.writeString(address)<br/>    }<br/><br/>    override fun describeContents(): Int {<br/>        return 0<br/>    }<br/><br/>    companion object CREATOR : Parcelable.Creator&lt;Users&gt; {<br/>        override fun createFromParcel(parcel: Parcel): Users {<br/>            return Users(parcel)<br/>        }<br/><br/> override fun newArray(size: Int): Array&lt;Users?&gt; {<br/>            return arrayOfNulls(size)<br/>        }<br/>    }<br/>}</pre>
<p>So, it's really complex to understand and handle, though we don't need to modify the override functions and constructors. However, if you omit these lines, then, of course, you will be happy, and your code will look nice. To do this, we need to apply the lazy coder's way.</p>
<p>We just need an annotation named <kbd>@Parcelize</kbd> on top of the model class. Here is the full code for this:</p>
<pre><strong>@Parcelize</strong><br/>@Entity(tableName = "users")<br/>class Users(): Parcelable {<br/>    @PrimaryKey(autoGenerate = true)<br/>    @NonNull<br/>    @ColumnInfo(name = "userId")<br/>    var userId: Int = 0<br/><br/>    @NonNull<br/>    @ColumnInfo(name = "username")<br/>    lateinit var username: String<br/><br/>    @NonNull<br/>    @ColumnInfo(name = "email")<br/>    lateinit var email: String<br/><br/>    @NonNull<br/>    @ColumnInfo(name = "contactNumber")<br/>    lateinit var contactNumber: String<br/><br/>   @NonNull<br/>    @ColumnInfo(name = "address")<br/>    lateinit var address: String<br/><br/>    constructor(username: String, email: String, contactNumber: String, address: String):this(){<br/>        this.username = username<br/>        this.email = email<br/>        this.contactNumber = contactNumber<br/>        this.address = address<br/>    }<br/><br/>    override fun toString(): String {<br/>        return "Users(username='$username', email='$email', contactNumber='$contactNumber', address='$address')"<br/>    }<br/>}</pre>
<p>So there is no more extra code. To enable this, you need to add the following code in the <kbd>android</kbd> block of the <kbd>build.gradle (Module: app)</kbd> file:</p>
<pre>android {<br/>    ----<br/>    ----<br/>    androidExtensions {<br/>        experimental = true<br/>    }<br/>}<br/>dependencies {<br/>    ----<br/>    ----<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the DAO</h1>
                
            
            
                
<p>Let's create an interface named <kbd>UserDAO.kt</kbd>, and annotated with <kbd>@DAO</kbd> annotation. This will help <kbd>Room</kbd> to identify the <kbd>DAO</kbd> class. Here is the code for the <kbd>DAO</kbd> interface:</p>
<pre>@Dao<br/>interface UserDAO</pre>
<p>In this interface, we will create functions that will be responsible for inserting, deleting, and getting the user details:</p>
<pre><strong>@Insert</strong><br/>fun addNewUser(users: Users)</pre>
<p>In the preceding code, <kbd>@Insert</kbd> is used to insert a user:</p>
<pre><strong>@Query("DELETE FROM USERS")</strong><br/>fun deleteAllUsers()</pre>
<p>In the previous code, <kbd>@Query("DELETE FROM USERS")</kbd> is used to delete all the users from the <kbd>USERS</kbd> table:</p>
<pre>@Query("SELECT * FROM USERS")<br/>fun getAllUsers():  List&lt;Users&gt;</pre>
<p class="mce-root">In this code, <kbd>@Query("SELECT * FROM USERS")</kbd> is used to get all the users as a list from the <kbd>USERS</kbd> table.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the LiveData class</h1>
                
            
            
                
<p>Data always changes dynamically and so we have to keep it updated and show the latest result to users. For this reason, we need to observe the data. <kbd>LiveData</kbd> is a lifecycle library class that can observe the data and react.</p>
<p class="mce-root"/>
<p>Let's wrap the <kbd>getAllUsers()</kbd> function of <kbd>UserDao.kt</kbd> with the <kbd>LiveData</kbd>:</p>
<pre>@Query("SELECT * FROM USERS")<br/>fun getAllUsers():  LiveData&lt;List&lt;Users&gt;&gt;</pre>
<p>The <kbd>@Query("SELECT * FROM USERS")</kbd> is to get all the information from the <kbd>USERS</kbd> table</p>
<p>So here is the full code of the DAO interface:</p>
<pre>@Dao<br/>interface UserDAO {<br/><br/>    @Insert(onConflict = OnConflictStrategy.REPLACE)<br/>    fun addNewUser(users: Users)<br/><br/>    @Query("DELETE FROM USERS")<br/>    fun deleteAllUsers()<br/><br/>    @Query("SELECT * FROM USERS")<br/>    fun getAllUsers():  LiveData&lt;List&lt;Users&gt;&gt;<br/>}</pre>
<p>In the <kbd>MainActivity</kbd>, we will see how to create an <kbd>Observer</kbd> of the data and override the observer's <kbd>onChanged()</kbd> function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a Room database</h1>
                
            
            
                
<p><kbd>Room</kbd> is not a database but a layer of the <kbd>SQLite</kbd> database. It mainly uses <kbd>DAO</kbd> and the queries to make it easier to fetch the database for the clients. It doesn't use the main thread, but runs asynchronously on a background thread and so the UI performance doesn't fall.</p>
<p class="mce-root">Let's create an abstract class named <kbd>UsersRoomDatabase</kbd> and extend <kbd>RoomDatabase</kbd>. Use the <kbd>@Database</kbd> annotation with an entity of <kbd>Users</kbd> class and add the version number. Lastly, initialize an abstract function of the <kbd>UserDao</kbd> class:</p>
<pre>@Database(entities = [Users::class], version = 1)<br/>abstract class UsersRoomDatabase : RoomDatabase() {<br/>    abstract fun userDAO(): UserDAO<br/>----<br/>----<br/>}</pre>
<p>Let's create a singleton. This will handle multiple instances of the database when it opens at the same time.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Initialize the <kbd>UsersRoomDatabase</kbd> object.</p>
<p>The name of the <kbd>UsersRoomDatabase</kbd> is <kbd>"user_database"</kbd>.</p>
<p>Here is the piece of code for this object:</p>
<pre>// static members<br/>companion object {<br/>    @Volatile<br/>    private var INSTANCE: UsersRoomDatabase? = null<br/><br/>    fun getDatabase(context: Context, scope: CoroutineScope): UsersRoomDatabase {<br/>        val tempInstance = INSTANCE<br/>        if (tempInstance != null) {<br/>            return tempInstance<br/>        }<br/>        synchronized(this) {<br/>            val instance = Room.databaseBuilder(<br/>                context.applicationContext,<br/>                UsersRoomDatabase::class.java,<br/>                "user_database"<br/>            ).addCallback(UserDatabaseCallback(scope))<br/>                .build()<br/>            INSTANCE = instance<br/>            return instance<br/>        }<br/>    }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Populating the database</h1>
                
            
            
                
<p>To store data in the database, we can input some demo data by using the code for the users. The rest of the data will be stored by using the <kbd>NewUserActivity.kt</kbd> class.</p>
<p>For the demo data, we are creating a simple function where we insert two demo user details and it will show after running the app.</p>
<p>To do this, let's create an inner callback named <kbd>UserDatabaseCallback()</kbd> with the <kbd>CoroutineScope</kbd> parameter and extend <kbd>RoomDatabase.Callback()</kbd>. Lastly, we will override the <kbd>onOpen(db: SupportSQLiteDatabase)</kbd> and there we can add two random user objects:</p>
<pre>fun populateDatabase(userDao: UserDAO) {<br/>            userDao.addNewUser(<br/>                Users(<br/>                    "Sunnat", "sunnat629@gmail.com",<br/>                    "1234567890", "Dhaka"<br/>                )<br/>            )<br/>            userDao.addNewUser(<br/>                Users(<br/>                    "Chaity", "chaity123@gmail.com",<br/>                    "54321987", "Dhaka"<br/>                )<br/>            )<br/>        }</pre>
<p>Here we have created the user details using the <kbd>userDao.addNewUser()</kbd>. These user details will show in the listview if we run the application.</p>
<p>Lastly, we need to add the callback to the database and call <kbd>build()</kbd> to finish this callback like this code shows:</p>
<pre>fun getDatabase(context: Context, scope: CoroutineScope): UsersRoomDatabase {<br/>    val tempInstance = INSTANCE<br/>    if (tempInstance != null) {<br/>        return tempInstance<br/>    }<br/>    synchronized(this) {<br/>        val instance = Room.databaseBuilder(<br/>            context.applicationContext,<br/>            UsersRoomDatabase::class.java,<br/>            "user_database"<br/>        ).<strong>addCallback(UserDatabaseCallback(scope))</strong><br/><strong>            .build()</strong><br/>        INSTANCE = instance<br/>        return instance<br/>    }<br/>}<br/><br/><strong>private class </strong><strong>UserDatabaseCallback(</strong><br/><strong> private val scope: CoroutineScope</strong><br/><strong>) : RoomDatabase.Callback()</strong> {<br/><br/> override fun onOpen(db: SupportSQLiteDatabase) {<br/> super.onOpen(db)<br/> INSTANCE?.let { database -&gt;<br/> scope.launch(Dispatchers.IO) {<br/> <strong>populateDatabase(database.userDAO())</strong><br/> }<br/> }<br/> }<br/>----<br/>----<br/>}</pre>
<p>In the preceding code, we created a callback class named <kbd>UserDatabaseCallback</kbd> where we populate the database using the <kbd>DAO</kbd> function named <kbd>userDAO()</kbd>.</p>
<p>Then we add this callback in the <kbd>instance</kbd> of <kbd>getDatabase()</kbd> function using <kbd>addCallback().</kbd></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing the repository</h1>
                
            
            
                
<p>Repository class is the bridge between the <kbd>Room</kbd> database and the <kbd>ViewModel</kbd>. This provides data from multiple data sources and isolates the data layer. </p>
<p>We can separate this repository into two sections; one is DAO, which is mainly used for the local database and to connect the local database with the application. Another section is the network, which is mainly used for handling and communicating between the cloud and application.</p>
<p>Now create a repository class named <kbd>UsersRepository.kt</kbd> and declare <kbd>UserDAO</kbd> as the constructor of this class.</p>
<p>Here is the code of <kbd>UsersRepository.kt</kbd>:</p>
<pre>class UsersRepository(<strong>private val mUserDAO: UserDAO</strong>) {<br/><br/>    val mAllUsers: LiveData&lt;List&lt;Users&gt;&gt; = mUserDAO.getAllUsers()<br/><br/>    <strong>@WorkerThread</strong><br/>    suspend fun <strong>insert(user: Users)</strong>{<br/>        mUserDAO<strong>.addNewUser(user)</strong><br/>    }<br/>}</pre>
<p>Here, we have initialized the user list. Now the <kbd>Room</kbd> will execute all queries. The queries will be done in a different thread.</p>
<p><kbd>LiveData</kbd> will notify the callback function if there are any changes in the database. The <kbd>insert(user: Users)</kbd> is the function that is used to wrap the <kbd>addNewUser()</kbd>. This insert function has to run on a non-UI thread or the application will crash. To avoid this, we need to use <kbd>@WorkerThread</kbd> annotation, which helps to execute this function on a non-UI thread. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the ViewModel</h1>
                
            
            
                
<p>Now create a <kbd>ViewModel</kbd> class named <kbd>MainViewModel.kt</kbd>.</p>
<p>Here is the <kbd>MainViewModel.kt</kbd> class:</p>
<pre>open class MainViewModel<strong>(application: Application) : AndroidViewModel(application)</strong> {<br/>    private val mRepository: UsersRepository<br/>    private val mAllUsers: LiveData&lt;List&lt;Users&gt;&gt;<br/><br/>    private var  parentJob = Job()<br/>    private val coroutineContext: CoroutineContext<br/>        get() = parentJob + Dispatchers.Main<br/><br/>    private val scope = CoroutineScope(coroutineContext)<br/><br/>    init {<br/>        val userDao = UsersRoomDatabase.getDatabase(application, scope).userDAO()<br/>        mRepository = UsersRepository(userDao)<br/>        mAllUsers = mRepository.mAllUsers<br/>    }<br/><br/>    fun getAllUsers(): LiveData&lt;List&lt;Users&gt;&gt;{<br/>        return mAllUsers<br/>    }<br/><br/>    fun insert(users: Users) = scope.launch(Dispatchers.IO){<br/>        mRepository.insert(users)<br/>    }<br/><br/>    override fun onCleared() {<br/>        super.onCleared()<br/>        parentJob.cancel()<br/>    }<br/>}</pre>
<p>This class gets the <kbd>Application</kbd> as a parameter and extends the <kbd>AndroidViewModel</kbd>.</p>
<p>Initialize a private variable of <kbd>WordRepository</kbd> and a <kbd>LiveData</kbd>, which will cache the list of the users. </p>
<p>In the <kbd>init</kbd> block, add a <kbd>UserDAO</kbd> reference from the <kbd>UsersRoomDatabase</kbd>. Initialize the <kbd>mAllUsers</kbd> with the <kbd>mRepository.mAllUsers</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating new activity</h1>
                
            
            
                
<p>Now we need an activity where we will create a function to insert the user details and save into the database. Right-click on the app folder and create Empty Activity named <kbd>NewUserActivity.kt</kbd> like the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a210195e-3448-4fc6-a628-916ba645cdb0.png" style="width:47.92em;height:46.83em;"/></p>
<p>Here is the code of the layout of this class named <kbd>activity_new_user.xml</kbd>. (The entire code can be found at GitHub link):</p>
<pre>----<br/>----<br/>    &lt;EditText<br/>            android:id="@+id/editEmail"<br/>            android:layout_width="match_parent"<br/>            android:layout_height="wrap_content"<br/>            android:hint="@string/hint_email"<br/>            android:inputType="textEmailAddress"<br/>            android:padding="5dp"<br/>            android:textSize="18sp" android:layout_marginTop="8dp"<br/>            app:layout_constraintTop_toBottomOf="@+id/editUsername" app:layout_constraintStart_toStartOf="parent"<br/>            app:layout_constraintEnd_toEndOf="parent"/&gt;<br/><br/>    &lt;EditText<br/>            android:id="@+id/editContactID"<br/>            android:layout_width="match_parent"<br/>            android:layout_height="wrap_content"<br/>            android:hint="@string/hint_contact"<br/>            android:inputType="phone"<br/>            android:padding="5dp"<br/>            android:textSize="18sp" android:layout_marginTop="8dp"<br/>            app:layout_constraintTop_toBottomOf="@+id/editEmail" app:layout_constraintStart_toStartOf="parent"<br/>            app:layout_constraintEnd_toEndOf="parent"<br/>    /&gt;<br/>----<br/>---<br/>    &lt;Button<br/>            android:id="@+id/buttonSave"<br/>            android:layout_width="match_parent"<br/>            android:layout_height="wrap_content"<br/>            android:background="@color/colorPrimary"<br/>            android:text="@string/button_save"<br/>            android:textColor="@android:color/white"<br/>            android:layout_marginBottom="8dp"<br/>            app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintStart_toStartOf="parent"<br/>            app:layout_constraintEnd_toEndOf="parent" android:layout_marginTop="8dp"<br/>            app:layout_constraintTop_toBottomOf="@+id/editAddress" app:layout_constraintVertical_bias="1.0"/&gt;<br/>&lt;/android.support.constraint.ConstraintLayout&gt;<br/></pre>
<p>Here we have added four <kbd>EditText</kbd> where we can input—<kbd>username</kbd>, <kbd>contactNumber</kbd>, <kbd>email</kbd>, <kbd>address</kbd>, and a button named <kbd>buttonSave</kbd> to save this information into the database.</p>
<p>Here is the code of the <kbd>NewUserActivity.kt</kbd> class:</p>
<pre>class NewUserActivity : AppCompatActivity(), View.OnClickListener {<br/><br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        setContentView(R.layout.activity_new_user)<br/>        buttonSave.setOnClickListener(this)<br/>    }<br/><br/>    override fun onClick(view: View?) {<br/>        if (view!!.id == R.id.buttonSave){<br/>            val intent = Intent()<br/>            if (isTextFieldEmpty()){<br/>                Snackbar.make(view, "Empty Field", Snackbar.LENGTH_LONG)<br/>                    .setAction("Action", null).show()<br/>                setResult(Activity.RESULT_CANCELED, intent)<br/>            } else {<br/>                val users = Users(editUsername.text.toString(),<br/>                    editEmail.text.toString(),<br/>                    editContactID.text.toString(),<br/>                    editAddress.text.toString())<br/><br/>                Log.wtf("CRAY", editUsername.text.toString()+" "+<br/>                        editEmail.text.toString()+" "+<br/>                        editContactID.text.toString()+" "+<br/>                        editAddress.text.toString())<br/><br/>                Log.wtf("CRAY", users.toString())<br/>                // If an instance of this Activity already exists, then it will be moved to the front.<br/>                // If an instance does NOT exist, a new instance will be created.<br/>                intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT)<br/>                intent.putExtra(getString(R.string.result_replay), users)<br/>                setResult(Activity.RESULT_OK, intent)<br/>            }<br/>            finish()<br/>        }<br/>    }<br/><br/>    private fun isTextFieldEmpty(): Boolean {<br/>        return TextUtils.isEmpty(editUsername.text) ||<br/>                TextUtils.isEmpty(editEmail.text) ||<br/>                TextUtils.isEmpty(editContactID.text) ||<br/>                TextUtils.isEmpty(editAddress.text)<br/>    }<br/>}</pre>
<p>According to the preceding code:</p>
<ul>
<li>Implement the <kbd>View.OnClickListener</kbd> and override the <kbd>onClick(view: View?)</kbd>.</li>
<li>In the <kbd>onCreate()</kbd>,  <kbd>setOnClickListener()</kbd> for the <kbd>buttonSave</kbd>, and override the <kbd>onClick(view: View?)</kbd> that we want to execute with the button. Lastly, we call an <kbd>Intent</kbd>, which will change the activity from the <strong><kbd>UserModel</kbd></strong> to the <kbd>MainActivity</kbd> class. </li>
<li>The <kbd>isTextFieldEmpty()</kbd> is designed to check whether the <kbd>EditText</kbd> fields are empty or not.</li>
<li>Then we get all the text, make a <kbd>UserObject</kbd>, and pass this <em>Parcelable user object</em> to the <kbd>MainActivity</kbd> using <kbd>intent.putExtra(getString(R.string.result_replay), users)</kbd>.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating custom RecyclerView adapter</h1>
                
            
            
                
<p>To show all the user list, we will use the <kbd>RecyclerView</kbd>. For our project, we need to customize the <kbd>RecyclerView</kbd> adapter in our own way. In this adapter, we mainly pass the user model. This will show the username, email, and contact number. Let's create an adapter named <kbd>UserListAdapter.kt</kbd> and extend <kbd>RecyclerView.Adapter&lt;UserListAdapter.UserViewHolder&gt;()</kbd>. Here is the code for the <kbd>UserListAdapter.kt</kbd>:</p>
<pre>class UserListAdapter internal constructor(context: Context) :<br/>    RecyclerView.Adapter&lt;UserListAdapter.UserViewHolder&gt;() {<br/><br/>    private val mLayoutInflater: LayoutInflater = LayoutInflater.from(context)!!<br/>    private var mUsers: List&lt;Users&gt; = emptyList() // Cached copy of users<br/><br/><br/>    inner class UserViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {<br/>        val rowName: TextView = itemView.name<br/>        val rowEmail: TextView = itemView.email<br/>        val rowContactNumber: TextView = itemView.contactNumber<br/>        val rowAddress: TextView = itemView.contactNumber<br/>    }<br/><br/>    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): UserViewHolder {<br/>        val itemView: View = mLayoutInflater.inflate(R.layout.recyclerview_item, parent, false)<br/>        return UserViewHolder(itemView)<br/>    }<br/><br/>    override fun onBindViewHolder(holder: UserViewHolder, position: Int) {<br/>        holder.rowName.text = mUsers[position].username<br/>        holder.rowEmail.text = mUsers[position].email<br/>        holder.rowContactNumber.text = mUsers[position].contactNumber<br/>        holder.rowAddress.text = mUsers[position].address<br/>    }<br/><br/>    override fun getItemCount(): Int {<br/>        return mUsers.size<br/>    }<br/><br/>    internal fun setNewUser(users: List&lt;Users&gt;) {<br/>        mUsers = users<br/>        notifyDataSetChanged()<br/>    }<br/>}</pre>
<p>According to the code:</p>
<pre>onCreateViewHolder()<br/>onBindViewHolder()<br/>UserViewHolder()</pre>
<p>Here we initialize four attributes of the <kbd>activity_new_user.xml</kbd> in the <kbd>UserViewHolder</kbd> inner class :</p>
<pre>val rowName: TextView = itemView.name<br/>val rowEmail: TextView = itemView.email<br/>val rowContactNumber: TextView = itemView.contactNumber<br/>val rowAddress: TextView = itemView.contactNumber</pre>
<p>We have set the <strong>userModel</strong>'s value in these four attributes in <kbd>onBindViewHolder()</kbd> function as follows:</p>
<pre>holder.rowName.text = mUsers[position].username<br/>holder.rowEmail.text = mUsers[position].email<br/>holder.rowContactNumber.text = mUsers[position].contactNumber<br/>holder.rowAddress.text = mUsers[position].address<br/></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing RecyclerView</h1>
                
            
            
                
<p><kbd>RecyclerView</kbd> is a list where we can see all the user list. <kbd>RecyclerView</kbd> is a part of design material that helps to make the list smoother and faster to load the data.</p>
<p>In the <kbd>MainActivity</kbd>, we set <kbd>RecycleView</kbd> in the <kbd>onCreate()</kbd> function as shown by this code:</p>
<pre>val userListAdapter = UserListAdapter(this)<br/>recyclerview.adapter = userListAdapter<br/>recyclerview.layoutManager =  LinearLayoutManager(this)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Modifying main activity</h1>
                
            
            
                
<p>Let's modify this <kbd>MainActivity</kbd> class to complete our project. Let's start by connecting the UI to the database. We will use the <kbd>RecyclerView</kbd> to show the list of data from the database. </p>
<p>Let's create a variable of <kbd>ViewModel</kbd> as shown by the following code:</p>
<pre>private lateinit var mMainViewModel: MainViewModel</pre>
<p>Use <kbd>ViewModelProviders</kbd> to connect the <kbd>MainViewModel</kbd> with <kbd>MainActivity</kbd>. In <kbd>onCreate()</kbd>, we will get the <kbd>ViewModel</kbd> from the <kbd>ViewModelProvider</kbd> as shown by the following code:</p>
<pre>mMainViewModel = ViewModelProviders.of(this).get(MainViewModel::class.java)</pre>
<p>To add the <kbd>LiveData</kbd> observer let's add this <kbd>observe()</kbd> for <kbd>getAllUsers()</kbd> as shown by the following code:</p>
<pre>mMainViewModel.getAllUsers().observe(this,<br/>    Observer {<br/>            userList -&gt; userListAdapter.setNewUser(userList!!)<br/>    })</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting data from another activity</h1>
                
            
            
                
<p>We mentioned in the <em>Creating new activity</em> section that we have passed the <em>Parcelable</em> user object to the <kbd>MainActivity</kbd>. To get this object, we need to create a request code. Let's create a request code like the following:</p>
<pre>private val requestCode: Int = 1<br/></pre>
<p>Now override the <kbd>onActivityResult()</kbd> function, where we will retrieve the passed object of the <kbd>NewUserActivity</kbd>.</p>
<p>Here is the code of <kbd>onActivityResult()</kbd> function:</p>
<pre>override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {<br/>    super.onActivityResult(requestCode, resultCode, data)<br/>    if (requestCode == this.requestCode &amp;&amp; resultCode == Activity.RESULT_OK){<br/>        data?.let {<br/>        val users: Users = it.getParcelableExtra(getString(R.string.result_replay)) as Users<br/>        mMainViewModel.insert(users)<br/>        }<br/>    }<br/>}</pre>
<p>The <kbd>getParcelableExtra()</kbd> is used to retrieve a <kbd>Parcelable</kbd> object. After then, we call the <kbd>mMainViewModel.insert(users)</kbd> to insert the returned <kbd>User</kbd> into the database.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding XML layouts</h1>
                
            
            
                
<p>In the <kbd>content_main.xml</kbd>, we add the <kbd>RecyclerView</kbd>. Here is the code of this layout:</p>
<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;android.support.constraint.ConstraintLayout<br/>        xmlns:android="http://schemas.android.com/apk/res/android"<br/>        xmlns:tools="http://schemas.android.com/tools"<br/>        xmlns:app="http://schemas.android.com/apk/res-auto"<br/>        android:layout_width="match_parent"<br/>        android:layout_height="match_parent"<br/>        app:layout_behavior="@string/appbar_scrolling_view_behavior"<br/>        tools:showIn="@layout/activity_main"<br/>        tools:context=".ui.MainActivity"&gt;<br/>    &lt;android.support.v7.widget.RecyclerView<br/>            android:id="@+id/recyclerview"<br/>            android:background="@android:color/darker_gray"<br/>            tools:listitem="@layout/recyclerview_item"<br/>            app:layout_constraintBottom_toBottomOf="parent"<br/>            app:layout_constraintStart_toStartOf="parent"<br/>            app:layout_constraintEnd_toEndOf="parent"<br/>            app:layout_constraintTop_toTopOf="parent"<br/>            android:layout_height="0dp" android:layout_width="0dp"/&gt;<br/>&lt;/android.support.constraint.ConstraintLayout&gt;</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Switching another activity</h1>
                
            
            
                
<p>In the <kbd>activity_main.xml</kbd>, we have added a <kbd>FloatingActionButton</kbd>, which we will use to go to <strong><kbd>NewUserActivity</kbd>. </strong>To complete this task, use the following code in the <kbd>onCreate()</kbd> with the mentioned request code:</p>
<pre>fab.setOnClickListener {<br/>    val intent = Intent(this@MainActivity, NewUserActivity::class.java)<br/>    startActivityForResult(intent, requestCode)<br/><br/>    /*Snackbar.make(view, "Replace with your own action", Snackbar.LENGTH_LONG)<br/>        .setAction("Action", null).show()*/<br/>}</pre>
<p>So, here is the complete code of <kbd>MainAcivity.kt</kbd>:</p>
<pre>class MainActivity : AppCompatActivity() {<br/><br/>    private val requestCode: Int = 1<br/><br/>    private lateinit var mMainViewModel: MainViewModel<br/><br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        setContentView(R.layout.activity_main)<br/>        setSupportActionBar(toolbar)<br/><br/>        val userListAdapter = UserListAdapter(this)<br/>        recyclerview.adapter = userListAdapter<br/>        recyclerview.layoutManager =  LinearLayoutManager(this)<br/><br/>        mMainViewModel = ViewModelProviders.of(this).get(MainViewModel::class.java)<br/>        mMainViewModel.getAllUsers().observe(this,<br/>            Observer {<br/>                    userList -&gt; userListAdapter.setNewUser(userList!!)<br/>            })<br/><br/><br/>        fab.setOnClickListener {<br/>            val intent = Intent(this@MainActivity, NewUserActivity::class.java)<br/>            startActivityForResult(intent, requestCode)<br/>        }<br/>    }<br/><br/>    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {<br/>        super.onActivityResult(requestCode, resultCode, data)<br/>        if (requestCode == this.requestCode &amp;&amp; resultCode == Activity.RESULT_OK){<br/>            data?.let {<br/>            val users: Users = it.getParcelableExtra(getString(R.string.result_replay)) as Users<br/>            mMainViewModel.insert(users)<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p>Now that we have completed the project, <em>run</em> the application. We will explore this in the next section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Run the app</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">After running the app on your Android device or emulator, you will see this screen:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/4e30c6d3-fb11-45ab-99ad-43a3e6d4ab73.png" style="width:21.50em;height:38.08em;"/></p>
<p>We can see our pre-added user details here. Now click the float button and go to the new user activity where you can write down the information of a user as shown by this screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/02cff585-854a-4cb1-bed2-014976dcde08.png" style="width:23.08em;height:41.33em;"/></p>
<p>Lastly, click the Save button. You can now see the new username, which is displayed as <strong>Naruto</strong> in this image:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a347746d-1a37-4c8a-8e10-fdd0e2378794.png" style="width:21.42em;height:38.25em;"/></p>
<p class="mce-root"/>
<p>So, in this way we have learned how to use <kbd>Room</kbd> for the local database. In the next chapter, you will see more use of this library in an Android application. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>The database itself is a large platform and we have covered those parts that are relevant to our Spring and Android projects and contents. In this chapter, we have learned what the database is, as well as looking at the various types of it. We have seen a brief description of the DBMs. After that, we have learned about the JDBC, which is an API specification for connecting and moving data from frontend to backend. Then we have developed a project using JDBC where we created, read, updated, and deleted data from the databases. After this topic, we have learned another API called JPA, which is an approach to ORM and a system that maps Java objects to database tables and vice-versa. Then we have learned more about the JPA and its use with the help of a project. There, we have also learned about CRUD-based REST API. Lastly, we have learned about the latest technology of Android called architecture components. Also, we looked at one of the components called <kbd>Room</kbd>, which is a wrap of the top level of the SQLite database. Finally, I want to reiterate that this database chapter has not explained everything. If you want to learn more about the database, you can read our recommended books, and we have mentioned the links with the names of the books and authors under the <em>Further reading</em> section. In the next chapter, you can learn about the concurrency, which means the ability of different units of a program, algorithm, or problem.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>What is the H2 in the Spring Boot?</li>
<li>What is a resource in REST API?</li>
<li>What is the full meaning of CRUD?</li>
<li>What is the difference between the DAO and repository?</li>
<li>What is SQLite?</li>
<li>What datatypes does SQLite support?</li>
<li>What are the standard SQLite commands?</li>
<li>What are the disadvantages of SQLite?</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<ul>
<li><em>Spring Persistence with Hibernate</em> (<a href="https://www.packtpub.com/application-development/spring-persistence-hibernate">https://www.packtpub.com/application-development/spring-persistence-hibernate</a>) by Ahmad Seddighi</li>
<li><em>Hands-On Full Stack Development with Spring Boot 2.0 and React</em> (<a href="https://www.packtpub.com/application-development/hands-full-stack-development-spring-boot-20-and-react">https://www.packtpub.com/application-development/hands-full-stack-development-spring-boot-20-and-react</a>) by Juha Hinkula</li>
<li><em>Working with Data and Cloud in Spring 5.0 [Video]</em> (<a href="https://www.packtpub.com/application-development/working-data-and-cloud-spring-50-video">https://www.packtpub.com/application-development/working-data-and-cloud-spring-50-video</a><a href="https://www.packtpub.com/application-development/working-data-and-cloud-spring-50-video">) by Ranga Rao Karanam</a></li>
<li><em>Android Database Programming</em> (<a href="https://www.packtpub.com/application-development/android-database-programming">https://www.packtpub.com/application-development/android-database-programming</a>) by Jason Wei</li>
</ul>


            

            
        
    </body></html>