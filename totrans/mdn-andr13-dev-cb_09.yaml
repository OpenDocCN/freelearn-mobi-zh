- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building for Large Screens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can all agree now that we live in a world with foldable phones, a technology
    we never anticipated, due to their growing demand and popularity. Ten years ago,
    if you had told a developer we would have foldable phones, no one would have believed
    it due to the ambiguity of screen complexity and the transfer of information.
  prefs: []
  type: TYPE_NORMAL
- en: However, now the devices are here with us. And since some of these devices run
    on the Android operating system, it’s vital to know how we developers will build
    our applications to cater to foldability, along with the number of Android tablets
    we’re now seeing on the market. The support for large screens seems now mandatory,
    and in this chapter, we will look at supporting large screens in the new Modern
    Android Development.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be covering the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Building adaptive layouts in Modern Android Development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building adaptive layouts using `ConstraintLayouts`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling large-screen configuration changes and continuity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding activity embedding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Material Theming in Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing your applications on a foldable device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The complete source code for this chapter can be found at [https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_nine](https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_nine).
  prefs: []
  type: TYPE_NORMAL
- en: Building adaptive layouts in Modern Android Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building the UI for your application in Modern Android Development, it
    is fair to say that you should consider ensuring the application is responsive
    to different screen sizes, orientations, and form factors. Finally, developers
    can now remove the lock in portrait mode. In this recipe, we will utilize ideas
    we learned from previous recipes and build an adaptive app for different screen
    sizes and orientations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be using the cities application to create a traveler profile, and our
    screen should be able to change based on different screen sizes and support foldable
    devices and tablets. To get the entire code, check out the *Technical* *requirements*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will create a new project, and this time, instead of picking
    the empty Compose Activity template, we will pick empty Compose Activity (`Material
    3`). `Material 3` seeks to improve our application’s look and feel in Android.
    It includes updated theming, components, and great features, such as Material
    You personalization using dynamic color:'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by creating an Empty Compose Activity (`Material3`) project and
    calling it `Traveller`; note that you can call your project anything you wish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Creating a new Empty Compose Activity (Material3) project](img/Figure_9.1_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Creating a new Empty Compose Activity (Material3) project
  prefs: []
  type: TYPE_NORMAL
- en: Complex applications utilize responsive UI, and in most cases, ensuring you
    choose the right navigation type for your application comes in handy. The Material
    library offers navigation components to developers, such as the bottom navigation,
    navigation drawer, and navigation rail. You can get the starter code for these
    in the *Technical* *requirements* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following dependency, and check the project for the correct version
    number, `1.1.0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When ensuring our code caters to adaptability, we have to remember a responsive
    UI retains data when a phone is rotated, folded, or unfolded. The most crucial
    part is ensuring we handle the posture. We will create a function, `cityPosture`,
    that takes `FoldingFeature` as input and returns a Boolean:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We handle the state based on the three provided states. We also annotate it
    with the experimental class because this API is still experimental, which means
    it can change in the future and is not very stable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to cover `isSeparating`, which listens to the `FLAT` *fully open*
    and the `isSeparating` Boolean, which calculates whether `FoldingFeature` should
    be considered, splitting the window into multiple physical areas that users can
    see as logically separate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will also create a sealed interface, `DevicePosture`. This is a Jetpack
    Compose UI component that allows you to detect a device’s posture or orientation,
    such as whether the device is in portrait or landscape mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our `MainActivity`, we now need to ensure we calculate the window size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will ensure we handle all sizes well by creating `postureStateFlow`,
    which will listen to our `DevicePosture` and act when `cityPosture` is either
    folded, unfolded, or normal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We now need to get set up with a foldable testing virtual device. You can repeat
    the steps from the first chapter on how to create a virtual device if you need
    a refresher; otherwise, you should go ahead and create a foldable device. The
    arrow in *Figure 9**.2* shows how you will control the foldable screens.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.2 – The foldable controls](img/Figure_9.2_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – The foldable controls
  prefs: []
  type: TYPE_NORMAL
- en: Then, finally, when you run the app, you will see that it changes based on folded
    and unfolded states, working well. *Figure 9**.3* shows when the state is folded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.3 – The folded state](img/Figure_9.3_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – The folded state
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 9**.4*, you can see that we changed the bottom navigation and now
    have our navigation drawer set to the side for more straightforward navigation.
    It should be acknowledged that this project is extensive, so we cannot cover all
    parts of the code. Make sure to utilize the Compose concepts learned in the previous
    chapter for this section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.4 – The full-screen state (not folded)](img/Figure_9.4_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – The full-screen state (not folded)
  prefs: []
  type: TYPE_NORMAL
- en: Note that when you expand the navigation drawer, you can see all items, and
    you should be able to navigate easily.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – The navigation drawer open](img/Figure_9.5_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – The navigation drawer open
  prefs: []
  type: TYPE_NORMAL
- en: You can also see on the side panel a more descriptive view of your UI, which
    helps debug issues.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – The device pose](img/Figure_9.6_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – The device pose
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The code base for this project is vast and hence, cannot be covered in just
    one recipe; you can find the full code in the *Technical* *requirements* section.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We covered the bottom navigation in [*Chapter 4*](B18827_04.xhtml#_idTextAnchor190),
    *Navigation in Modern Android Development*. In this chapter, however, we use it
    to showcase how your application can change as the screen changes if your application
    is installed on a foldable device, which is very important in Modern Android Development.
  prefs: []
  type: TYPE_NORMAL
- en: The navigation rail is used for medium-screen sizes, whereas the navigation
    drawer, just like in the old way of writing applications, is used as a side drawer
    and is suitable for large-screen devices. `FoldFeature` is a built-in Jetpack
    Compose UI component that allows you to create a folding animation effect when
    you click on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to use `FoldFeature` in your Android app. You can also customize
    `FoldFeature` by providing the necessary parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`foldableState`: This state controls the folding and unfolding of `FoldFeature`.
    You can create a `FoldState` instance using the `rememberFoldState()` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`foldedConten`t: Content will be displayed when `FoldFeature` is folded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expandedContent`: This is the content that will be displayed when `FoldFeature`
    is in its expanded state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`foldingIcon`: This is the icon that will be displayed to indicate the folding
    state of `FoldFeature`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A foldable device has the ability to be in various states and postures. The
    Jetpack `WindowManager` library’s `WindowLayoutInfo` class, which is what we use
    in our example, provides us with the following details. `state` helps describe
    the folded state the device is in. When the phone is fully opened, then the state
    is either `FLAT` or `HALF_OPENED`. We also get to play around with `orientation`,
    which is the orientation of the hinge.
  prefs: []
  type: TYPE_NORMAL
- en: The hinge can be either `HORIZONTAL` or `VERTICAL`. We have `occlusionType`,
    and this is the value that is `FULL` when the hinge hides part of the display.
    Otherwise, the value is `NONE`. Finally, we have `isSeparating`, which becomes
    valid when the hinge creates two logical displays.
  prefs: []
  type: TYPE_NORMAL
- en: Building adaptive layouts using ConstraintLayouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jetpack Compose, a declarative UI toolkit to build great UIs, is ideal to implement
    and design screen layouts that adjust automatically by themselves and render content
    well across different screen sizes.
  prefs: []
  type: TYPE_NORMAL
- en: This can be useful to consider when building your application, since the chance
    of it being installed in a foldable device is high. Furthermore, this can range
    from simple layout adjustments to filling up a foldable space that looks like
    a tablet.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to have read the previous chapters to follow along with this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will build a separate composable function to show you how
    to use `ConstraintLayout` in the same project instead of creating a new one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go ahead and open `Traveller`. Add a new package and call it `constraintllayoutexample`.
    Inside the package, create a Kotlin file, called `ConstraintLayoutExample`, and
    then add the following dependency to the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our example, we will create a fun `AndroidCommunity()` and use `ConstraintLayout`
    to create `title`, `aboutCommunity`, and `AndroidImage` references:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`createRefs()`, which means *create references*, simply creates a reference
    for each composable in our `ConstrainLayout`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let us go ahead and create our title text, `aboutCommunity`, and `AndroidImage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our title text has a modifier that has constraints defined, and if you have
    used XML before, you may notice that this works exactly how XML works. We provide
    constraints using the `constrainAs()` modifier, which, in our case, takes the
    references as a parameter and lets us specify its constraints in the body lambda.
    Hereafter, our constraints are specified using `linkTo(...)` or other methods,
    but in this case, we will use `linkTo(parent.top)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can now connect the parts together using a similar style, in addition, ensure
    you check the *Technical requirements* section for the entire code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we build the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, to run this part of the code, you can run the `@``Preview` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you run the application, it should render and adapt well to the screen
    sizes. For instance, if the state is full (which means not folded), data should
    be displayed on the entire screen (see *Figure 9**.7*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.7 – The full screen of the not folded state](img/Figure_9.7_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – The full screen of the not folded state
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 9**.8*, you can see a version of the data when the screen is folded
    and how it adapts to the specified dimensions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.8 – The folded state](img/Figure_9.8_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – The folded state
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use modifiers to adjust the spacing between components and use dimension
    resources to define the margin between an image and `aboutCommunity`. Our layout
    will adjust based on the screen size to look good on both small and large screens.
  prefs: []
  type: TYPE_NORMAL
- en: We also use `ConstraintLayout`, which is a layout manager that allows us to
    create complex layouts with a flat view hierarchy. It also has built-in support
    for responsive layouts to create different layouts for different screen sizes
    and orientations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best use cases for `ConstraintLayout` include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: When you want to avoid nesting multiple columns and rows; this can include when
    you want to position your elements on screen for easier code readability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing it when you need to use guidelines, chains, or barriers in your positioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We mentioned modifiers in previous chapters, which are like attributes in XML
    layouts. They allow us to apply different styles and behaviors to the components
    in our layout. You can use modifiers to change your component’s size, position,
    and other properties, based on the screen size.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we use dynamic padding and margins, and you can use them to
    adjust the spacing between components based on the screen size. For example, you
    can use a modifier to add more padding to a component on larger screens.
  prefs: []
  type: TYPE_NORMAL
- en: This allows you to create responsive layouts that adjust based on the screen
    size.
  prefs: []
  type: TYPE_NORMAL
- en: Handling large-screen configuration changes and continuity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android devices undergo various configuration changes during their operation.
    Some of the most notable, or standard, ones include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Screen orientation change**: This occurs when a user rotates a device’s screen,
    triggering a configuration change. This is when the device switches from portrait
    to landscape mode or vice versa.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Screen size change**: This is when a user changes the screen size of a device
    – for example, by plugging or unplugging an external display, triggering a configuration
    change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Language or locale change**: This is when a user changes the language or
    locale of a device, triggering a configuration change. This can affect the formatting
    of text and dates, among other things.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Theme change**: This is when a user changes a device’s theme, triggering
    a configuration change. This can affect the appearance of the UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keyboard availability change**: This is when a user attaches or detaches
    a keyboard from a device, triggering a configuration change. This can affect the
    layout of the UI, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we will look at leveraging this knowledge to better handle screen
    size changes when dealing with foldable devices.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first recipe, *Building adaptive layouts in Modern Android Development*,
    we discussed different state configurations and how to handle them better. In
    this recipe, we will learn how to use the already provided `rememberFoldableState`
    function in Jetpack Compose to handle screen changes in foldable devices.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s use the already created `Traveller` project for this example; you will
    not need to create a new project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to use `rememberFoldableState`, we will need to import it into our
    project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will create a new `val/ property foldableState` and initialize it
    with our `rememberFoldableState`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the `foldState` object, we can get information about foldable devices,
    make our application respond to the correct state, and display data as needed.
    The three states available are `STATE_FLAT`, `STATE_HALF_OPENED`, and `STATE_CLOSED`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then use this information to adjust our UI accordingly, such as showing
    or hiding certain elements based on the foldable state or specified position.
    Also, we can create two different layouts for when the device is folded and when
    it is unfolded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And that’s it; this will help solve the foldable state if you have a complex
    UI system that needs better handling.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Handling significant screen configuration changes, especially with foldable
    devices, can be challenging in Android Jetpack Compose. Here are some tips that
    can help you use the Configuration API. It allows you to get information about
    a device’s screen configuration, such as screen size, orientation, and foldable
    state. You can use this information to adjust your UI accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Compose’s layout system makes it easy to create responsive UIs that can adapt
    to different screen sizes and aspect ratios. Use flexible layouts such as columns
    and rows to create a UI that can scale up or down as needed.
  prefs: []
  type: TYPE_NORMAL
- en: The `rememberFoldableState` function lets you get information about a device’s
    foldable state and adjust your UI accordingly. For example, you can use this function
    to create two different layouts, one for when the device is folded and one for
    when it is unfolded.
  prefs: []
  type: TYPE_NORMAL
- en: Testing your app with different screen configurations is also essential to ensure
    that it works properly. You can use the Android emulator or physical devices to
    test your app.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding activity embedding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Jetpack Compose, activity embedding refers to the process of including a
    composable function within the context of an activity. This allows you to create
    custom views that can integrate seamlessly with existing Android activities.
  prefs: []
  type: TYPE_NORMAL
- en: To embed a composable function within an activity, you can use the `setContent`
    method of the activity. This method accepts a composable function as a parameter,
    which can be used to define the activity’s layout.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to have completed the previous recipes to follow along.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at an example of embedding a composable function in an activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `setContent` method embeds the `MyCustomView` composable
    function within `MainActivity`. When the activity is created, the `MyCustomView`
    function will be called to generate the activity’s layout.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `MyCustomView` function is defined as a composable function using the `@Composable`
    annotation. This allows the function to be called multiple times without causing
    any side effects. In this case, the function simply displays a `Text` composable
    with the text `Hello,` `Android Community!`.
  prefs: []
  type: TYPE_NORMAL
- en: By embedding composable functions within activities, you can create custom views
    that can be easily integrated into your Android app. This can be especially useful
    to create reusable components or customize the layout of existing activities.
  prefs: []
  type: TYPE_NORMAL
- en: Material Theming in Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Material Theming** in Compose is a design system introduced by Google that
    provides guidelines and principles to design user interfaces. Material Theming
    helps designers create interfaces that are consistent, easy to use, and visually
    appealing. Some key features of Material Theming in Jetpack Compose include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MaterialTheme` composable that allows you to apply a color palette to your
    entire app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Typography` composable that allows you to apply a typography style to your
    text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Shape` composable that allows you to apply a shape to your components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Icon` composable that allows you to use Material icons in your app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using Material Theming in Jetpack Compose, you can create interfaces that
    are consistent, easy to use, and visually appealing. Material Theming in Jetpack
    Compose helps you focus on designing your app’s functionality, while the design
    system takes care of the visual details.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be able to follow along, you need to have worked on previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many applications still do not use `Material 3`, but if you build a new application
    from scratch, it is highly recommended you go with `Material 3`. One thing to
    note is when you create a project, `Material 3` does not come pre-installed; this
    means you need to go ahead and update the Material libraries yourself to `Material
    3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example of implementing `Material 3` theming in Jetpack Compose
    for your Android applications:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to add the required `Material 3` dependencies to your app’s `build.gradle`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, you will need to declare your app theme:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, you can use your theme in the entire application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, we’ve used `Material 3` colors, typography, and shapes to create
    a consistent and visually appealing interface. We’ve also used `Material 3` icons
    to enhance the user experience. Finally, we’ve wrapped our app’s content in the
    `MyAppMaterialTheme` composable to apply the `Material` `3` theme.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here’s how `Material 3` works in Jetpack Compose. `Material 3` introduces new
    and updated components, such as `AppBar`, `BottomNavigation`, and `TabBar`, which
    can be used in Jetpack Compose using the `Androidx.compose.material3` package.
    These components have updated design and functionality, and they follow the `Material`
    `3` guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: Material 3 also introduces a new theming system that allows for more customization
    and flexibility – that is, in Jetpack Compose, `Material 3` theming can be applied
    using the `MaterialTheme3` composable. This composable allows you to customize
    the color scheme, typography, and shapes of your app, and it also provides new
    options to customize the elevation and shadows of your components.
  prefs: []
  type: TYPE_NORMAL
- en: The icons are now modern and easily accessible, which is a big plus for us developers.
    Finally, Material 3 introduces a new typography system that provides updated styles
    and guidelines for typography in your app. In Jetpack Compose, `Material 3` typography
    can be applied using the `Material3Typography` object, which provides several
    predefined styles for your text.
  prefs: []
  type: TYPE_NORMAL
- en: By using `Material 3` in Jetpack Compose, you can create modern and visually
    appealing interfaces that follow the latest design guidelines. Also note that
    `Material 3` components, theming, icons, and typography can all be used together
    to create a cohesive and consistent design system for your app.
  prefs: []
  type: TYPE_NORMAL
- en: See also…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is much to cover in Material Design, and trying to cover all components
    in a single recipe will not do it justice. To learn more about the components
    and how to ensure your application follows the Material Design guideline, read
    more here: [https://material.io/components](https://material.io/components).'
  prefs: []
  type: TYPE_NORMAL
- en: Testing your applications on a foldable device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing your apps on foldable devices is essential to ensure they work correctly
    and provide an excellent user experience. In this recipe, we will look at some
    tips to test your apps on foldable devices in Jetpack Compose.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to have done the previous recipes. You can access the entire code
    in the *Technical* *requirements* section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some tips to test your applications on foldable devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use an emulator**: You can use the Android emulator to test your app on foldable
    devices without buying a physical device. The emulator provides a range of foldable
    device configurations that you can use to test your app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use real devices**: Testing your app on an actual foldable device can provide
    a more accurate representation of how your app will work on these devices. If
    you have access to a foldable device, it’s highly recommended to test your app
    on it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test different screen modes**: Foldable devices come in different screen
    modes, such as single-screen, dual-screen, and extended screens. It’s essential
    to test your app on different screen modes to ensure it works correctly in all
    modes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test with different screen sizes**: Foldable devices come in different sizes,
    so it’s crucial to test your app on different screen sizes to ensure it works
    well on all devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test app transition**: Testing your app’s transition between different screen
    modes can help you identify any issues with an app’s layout or behavior. Make
    sure to test all the transition modes, such as fold, unfold, and hinge.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use automated testing**: Automated testing can help you test your app on
    different screen sizes, modes, and orientations more efficiently. You can use
    tools such as Espresso or UI Automator to write automated tests for your app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Overall, testing your app on foldable devices requires careful consideration
    of a device’s unique features and abilities. By following these tips, you can
    ensure that your app is optimized for foldable devices and provides an excellent
    user experience.
  prefs: []
  type: TYPE_NORMAL
