<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Testing &#x2013; Let's Fail Gracefully"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Testing – Let's Fail Gracefully</h1></div></div></div><p>
<span class="emphasis"><em>"Truth will sooner come out from error than from confusion."</em></span>
</p><p>
<span class="emphasis"><em>—<span class="emphasis"><em>Francis Bacon</em></span>
</em></span>
</p><p>In order to maintain high quality of a software product, testing is a very important part of the software development life cycle.<a id="id440" class="indexterm"/> In this chapter we will learn how we can test RubyMotion applications. We will learn to write unit tests, which can test an isolated code, and then learn functional testing, which will help us automate the UI tests. The following topics will be covered in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Unit testing</li><li class="listitem" style="list-style-type: disc">Functional testing</li><li class="listitem" style="list-style-type: disc">Device events</li></ul></div><div class="section" title="Unit testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec47"/>Unit testing</h1></div></div></div><p>The goal of unit testing<a id="id441" class="indexterm"/> is to isolate each part of the program and show that the individual parts function properly. RubyMotion uses MacBacon, which is an iOS flavor of Bacon<a id="id442" class="indexterm"/>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note34"/>Note</h3><p>Bacon is a smaller clone of RSpec. With less than 350 LOCs, we nevertheless get all the essential features.</p></div></div><p>Here, we will also follow <span class="strong"><strong>Test Driven Development</strong></span> (<span class="strong"><strong>TDD</strong></span>), <a id="id443" class="indexterm"/>a way of working where unit tests are created before the code itself is written. Of course, the tests will fail initially because we don't have anything. That's the philosophy of TDD; first we write the test case, it fails, we then refractor our code and once again write the feature code, and this time our test cases pass and the code is considered complete.</p><p>The idea here is that the developer himself wears the hat of a tester. We first document the feature in the form of a test, which fails, then we write our code and refractor, and once again<a id="id444" class="indexterm"/> document with a test case for the next feature.</p><p>First, let's create an application, which we will be using to learn how to write test cases for use with TDD.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$motion create LearnTest</strong></span>
</pre></div><p>In the folder structure, we can see a <code class="literal">spec</code> folder and a file <code class="literal">main_spec.rb</code> placed inside this folder. This is the default test file generated by the RubyMotion generator; this is where we write our test cases.</p><p>Let's write our first test case in the <code class="literal">main_spec.rb file</code> inside the <code class="literal">spec</code> folder as follows:</p><div class="informalexample"><pre class="programlisting">describe "Application 'LearnTest'" do
  before do
    @app = UIApplication.sharedApplication
  end

  it "has one window" do
    @app.windows.size.should == 1
  end
end</pre></div><p>Bacon gives you a way to encapsulate what you're testing via the <code class="literal">describe</code> block<a id="id445" class="indexterm"/>. As the name suggests, the <code class="literal">describe</code> block is used to describe the behavior of a class as follows:</p><div class="informalexample"><pre class="programlisting">describe "Application 'LearnTest'" do
end</pre></div><p>Tests are written using the <code class="literal">it</code> block. The test has a window, which checks if our application has a window as follows:</p><div class="informalexample"><pre class="programlisting">  it "has one window" do
    @app.windows.size.should == 1
  end</pre></div><p>As you can see, the syntax of these tests is very readable and you can easily understand what it means. In this case, <code class="literal">@app.windows.size.should == 1</code> means that your application should have one window.</p><p>The<a id="id446" class="indexterm"/> <code class="literal">describe()</code> method clasps into the Bacon API and gives us the <code class="literal">Spec::ExampleGroup</code> class<a id="id447" class="indexterm"/>. As the name suggests, it is a group of examples. These examples are actually the expected behavior of the object. If you're familiar with the xUnit tools such as <code class="literal">Test::Unit</code>, you can think of an <code class="literal">ExampleGroup</code> class<a id="id448" class="indexterm"/> as being akin to a test case.</p><p>Let's run the test case with the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ rake spec</strong></span>
<span class="strong"><strong>Build ./build/iPhoneSimulator-6.0-Development</strong></span>
<span class="strong"><strong>  Compile ./app/app_delegate.rb</strong></span>
<span class="strong"><strong>  Compile /Library/RubyMotion/lib/motion/spec.rb</strong></span>
<span class="strong"><strong>  Compile /Library/RubyMotion/lib/motion/spec/helpers/ui.rb</strong></span>
<span class="strong"><strong>  Compile ./spec/main_spec.rb</strong></span>
<span class="strong"><strong>    Create ./build/iPhoneSimulator-6.0-Development/LearnTest_spec.app</strong></span>
<span class="strong"><strong>      Link ./build/iPhoneSimulator-6.0-Development/LearnTest_spec.app/LearnTest</strong></span>
<span class="strong"><strong>  Create ./build/iPhoneSimulator-6.0-Development/LearnTest_spec.app/Info.plist</strong></span>
<span class="strong"><strong>  Create ./build/iPhoneSimulator-6.0-Development/LearnTest_spec.app/PkgInfo</strong></span>
<span class="strong"><strong>  Create ./build/iPhoneSimulator-6.0-Development/LearnTest_spec.dSYM</strong></span>
<span class="strong"><strong>  Simulate ./build/iPhoneSimulator-6.0-Development/LearnTest_spec.app</strong></span>
<span class="strong"><strong>Application 'LearnTest'</strong></span>
<span class="strong"><strong>  has one window [FAILED]</strong></span>

<span class="strong"><strong>Bacon::Error: 0.==(1) failed</strong></span>
<span class="strong"><strong>  spec.rb:649:in 'satisfy:': Application 'LearnTest' - has one window</strong></span>
<span class="strong"><strong>  spec.rb:663:in 'method_missing:'</strong></span>
<span class="strong"><strong>  spec.rb:279:in 'block in run_spec_block'</strong></span>
<span class="strong"><strong>  spec.rb:403:in 'execute_block'</strong></span>
<span class="strong"><strong>  spec.rb:279:in 'run_spec_block'</strong></span>
<span class="strong"><strong>  spec.rb:294:in 'run'</strong></span>

<span class="strong"><strong>1 specifications (1 requirements), 1 failures, 0 errors</strong></span>
</pre></div><p>We can see<a id="id449" class="indexterm"/> that one test failed (<code class="literal">Bacon::Error: 0.==(1)</code>). That is exactly what we wanted.</p><p>This means that <code class="literal">@app.windows.size</code> should expect the value as 1 but the actual value right now is 0. This is because till now we have not created a window in our application.</p><p>Next, let's write the code to create a window and update the <code class="literal">app_delegate.rb</code> file with the following code:</p><div class="informalexample"><pre class="programlisting">class AppDelegate
  def application(application, didFinishLaunchingWithOptions:launchOptions)
    @window = UIWindow.alloc.initWithFrame(UIScreen.mainScreen.applicationFrame)
    @window.makeKeyAndVisible
  true
  end
end</pre></div><p>Let's run the <code class="literal">specs</code> file as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$rake spec</strong></span>
<span class="strong"><strong>Application 'LearnTest'</strong></span>
<span class="strong"><strong>  - has one window</strong></span>

<span class="strong"><strong>1 specifications (1 requirements), 0 failures, 0 errors</strong></span>
</pre></div><p>We see that our test has passed and the code is therefore complete; mission accomplished!</p><p>The following<a id="id450" class="indexterm"/> are some commonly used assertions with MacBacon:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">should.</code> and <code class="literal">should.be</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">should.equal</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">should.match</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">should.be.identical_to</code>/<code class="literal">should.be.same_as</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">should.raise(*exceptions) { }</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">should.change { }</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">should.throw(symbol) { }</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">should.satisfy { |object| }</code></li></ul></div><p>Now let's create one more test by adding the following code to your <code class="literal">main_spec.rb</code> file:</p><div class="informalexample"><pre class="programlisting">it "should set rootviewcontroller as RootViewController" do
   @app.keyWindow.rootViewController.class.should == RootViewController
end</pre></div><p>This test checks whether we have the <code class="literal">rootViewController</code> property<a id="id451" class="indexterm"/> in our application whose name should be <code class="literal">RootViewController</code>. Run this test case and it should fail, as we have not yet created <code class="literal">RootViewController</code>.</p><p>Let's create a file <code class="literal">root_view_controller.rb</code> in the <code class="literal">app</code> folder as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>class RootViewController  &lt; UIViewController</strong></span>
<span class="strong"><strong>def viewDidLoad</strong></span>

<span class="strong"><strong>      end</strong></span>
<span class="strong"><strong>end</strong></span>
</pre></div><p>Also update the <code class="literal">app_delegate.rb</code> file by adding the following line:</p><div class="informalexample"><pre class="programlisting">@window.rootViewController = RootViewController.alloc.init</pre></div><p>Now when we run the <code class="literal">specs file</code>, we will find that all the test cases are passed.</p><p>Next, let's add some functionality to our application. How about we calculate the sum of the squares of numbers? Let's first write the tests for this.</p><p>Add the<a id="id452" class="indexterm"/> following <code class="literal">specs</code> code to the <code class="literal">main_spec.rb</code> file in the <code class="literal">spec</code> folder:</p><div class="informalexample"><pre class="programlisting">describe "sum_of_square_number" do  
  it "should return sum of squares of numbers" do
    array = [2,4,1]
    controller.sum_of_square_number(array).should.equal 21
  end

  it "should return 0 if array is blank" do
    array = []
    controller.sum_of_square_number(array).should.equal 0
  end
end</pre></div><p>When we run the test, they will surely fail, as we have not yet created the <code class="literal">sum_of_square_number</code> method<a id="id453" class="indexterm"/>. So let's create this method and its logic so that our <code class="literal">specs</code> tests pass, update the <code class="literal">root_view_controller.rb</code> file, and add the following method:</p><div class="informalexample"><pre class="programlisting">def sum_of_square_number(array)
  sum = 0
  array.each do |number|  
    sum = sum + number*number
  end
  sum
end</pre></div><p>This time, when we run our <code class="literal">specs</code> tests they will pass.</p><p>So far we have learned about testing a piece of code, but it is equally important that we test the user interface, <a id="id454" class="indexterm"/>so in the next section we will write a functional test.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip33"/>Tip</h3><p>You can create multiple files in your <code class="literal">spec</code> folder. RubyMotion automatically runs all the files with the <code class="literal">.rb</code> extension. You can also run individual files even from different locations with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>rake spec files=foo_spec,spec/bar_spec.rb</strong></span>
</pre></div></div></div></div></div>
<div class="section" title="Functional testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec48"/>Functional testing</h1></div></div></div><p>RubyMotion lets us write functional tests for our controllers and interacts with its views through a set <a id="id455" class="indexterm"/>of high-level event generating APIs, by leveraging the functionality of Apple's <code class="literal">UIAutomation</code> framework without forcing us to write the tests in JavaScript.<a id="id456" class="indexterm"/>
</p><p>Let's now write tests for user interface of the same application. In the following test case, we will test whether we have a label and a button on the screen.</p><p>Create the <code class="literal">spec</code> file <code class="literal">restro_view_controller_spec.rb</code> in the <code class="literal">spec</code> folder:</p><div class="informalexample"><pre class="programlisting">it "should have a label and a button" do
  view('Click Button').should.not.equal nil
  button = view('Click Me')
  button.should.not.equal nil
  button.isEnabled.should.equal true
end</pre></div><p>
<code class="literal">The view(label)</code> property<a id="id457" class="indexterm"/> returns the view that matches the specified accessibility label. The <code class="literal">view</code> command traverses down through the view hierarchy, starting from the current window. If no view matches our condition, it keeps retrying it until the timeout, which defaults to three seconds. This means you don't need to worry about whether or not the view you're looking for is still being loaded or animated.</p><p>Finally, if the timeout passes and no view matches, an exception will be raised.</p><p>The default timeout value can be changed through the <code class="literal">Bacon::Functional.default_timeout</code> property<a id="id458" class="indexterm"/>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip34"/>Tip</h3><p>You can also check what buttons are available on view with the classname as follows:</p><div class="informalexample"><pre class="programlisting">views(UIButton) # =&gt; [button1, button2]</pre></div></div></div><p>Now to pass this <a id="id459" class="indexterm"/>test, let's write the code for this functionality and update the file <code class="literal">root_view_controller.rb</code> with the following code:</p><div class="informalexample"><pre class="programlisting">def viewDidLoad
  super
  view.backgroundColor = UIColor.whiteColor
  @label = UILabel.new
  @label.text = 'Click Button'
  @label.textAlignment = UITextAlignmentCenter
  @label.frame = [[80,50],[150,50]]
  view.addSubview(@label)
  @normal_button = UIButton.buttonWithType(UIButtonTypeRoundedRect)
  @normal_button.frame = [[80,150],[180,37]]
  @normal_button.setTitle("Click Me", forState:UIControlStateNormal)
  @normal_button.addTarget(self, action:'buttonIsPressed', forControlEvents:UIControlEventTouchDown)
  view.addSubview(@normal_button)
end</pre></div><p>Let's fire up the terminal and run the application with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$rake</strong></span>
</pre></div><p>The following screenshot shows the output of the preceding command:</p><div class="mediaobject"><img src="graphics/5220OT_08_01.jpg" alt="Functional testing"/></div><p>We have created a label and a button in this View and now, when we run our <code class="literal">spec test</code>, it passes. Next, we want to calculate the sum of the squares of the first 5 numbers on click of a button. Let's first write<a id="id460" class="indexterm"/> the <code class="literal">spec</code> code for this functionality. Update the file <code class="literal">restro_view_controller_spec.rb</code> with the following code:</p><div class="informalexample"><pre class="programlisting">it "should show sum of squares on click of button" do
  tap 'Click Me'
  view('55').should.not.equal nil
end</pre></div><p>The <code class="literal">tap</code> command clicks on the button with the label <span class="strong"><strong>Click Me</strong></span>. There are many options available with the <code class="literal">tap</code> command. We will know more about them as we proceed with this chapter.</p><p>Now let's write the corresponding code for this <code class="literal">spec</code> test and update the file <code class="literal">root_view_controller.rb</code> with the following code:</p><div class="informalexample"><pre class="programlisting">def buttonIsPressed
  array = [1,2,3,4,5]
  @label.text = sum_of_square_number(array).to_s
end</pre></div><p>Let's fire up the terminal and test our application with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$rake</strong></span>
</pre></div><p>The following screenshot shows the output of the preceding command:</p><div class="mediaobject"><img src="graphics/5220OT_08_02.jpg" alt="Functional testing"/></div><p>We are now<a id="id461" class="indexterm"/> familiar with the basic functioning of testing. Next, we will learn how to test the device events with RubyMotion.</p></div>
<div class="section" title="Device events"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec49"/>Device events</h1></div></div></div><p>Most of the iOS applications make use of the various device capabilities. As a good practice, we must test these features<a id="id462" class="indexterm"/> to deliver high quality apps. RubyMotion gives us an environment to test some device capabilities. Let's discuss a few of them in this section.</p><div class="section" title="Rotate device"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec65"/>Rotate device</h2></div></div></div><p>We can test the rotation<a id="id463" class="indexterm"/> of the device by calling the following event:</p><div class="informalexample"><pre class="programlisting">rotate_device(:to =&gt; orientation, :button =&gt; location)</pre></div><p>The <code class="literal">rotate_device</code> command <a id="id464" class="indexterm"/>allows us to pass the following two arguments:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">to</code>: This passes the orientation to rotate the device; it can either have portrait or landscape as a value.</li><li class="listitem" style="list-style-type: disc"><code class="literal">button</code>: The <code class="literal">button</code> here indicates the position of the <span class="strong"><strong>home</strong></span> button; it makes sense if we pass the values based on the first value of orientation. In portrait mode, we can opt for the <code class="literal">:bottom</code> or <code class="literal">:top button</code> location. In landscape mode, we can opt for <code class="literal">:left</code> or <code class="literal">:right</code> with respect to the button location, for example, <code class="literal">rotate_device</code> <code class="literal">:to</code> =&gt; <code class="literal">:portrait</code>, <code class="literal">:button</code> =&gt; <code class="literal">:bottom</code>.</li></ul></div><p>This device event will rotate the device to the portrait orientation with the <span class="strong"><strong>home</strong></span> button at the bottom.</p><p>Now let's use <a id="id465" class="indexterm"/>this rotation in our sample application from the previous section. We want to ensure that our application only works in portrait mode. For this we must disable the landscape mode. Let's add a test case for this scenario. Add the following code in the file <code class="literal">root_view_controller_spec.rb</code>:</p><div class="informalexample"><pre class="programlisting">it "has default orientations for portrait" do
   rotate_device :to =&gt; :landscape
   controller.interfaceOrientation.should == UIInterfaceOrientationPortrait

   rotate_device :to =&gt; :portrait
   controller.interfaceOrientation.should == UIInterfaceOrientationPortrait
end</pre></div><p>With the preceding test case, we rotate the device first in landscape mode and then in portrait mode, and then we test that each rotation is actually in portrait mode.</p><p>Let's fire up the terminal and run the test as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$rake spec</strong></span>
<span class="strong"><strong>Application 'LearnTest'</strong></span>
<span class="strong"><strong>    has one window</strong></span>
<span class="strong"><strong>    should set rootviewcontroller as RootViewController</strong></span>
<span class="strong"><strong>RootViewController</strong></span>
<span class="strong"><strong>    should have label and button</strong></span>
<span class="strong"><strong>    should show sum of square on click of button</strong></span>
<span class="strong"><strong>    has default orientations for portrait [FAILED]</strong></span>

<span class="strong"><strong>sum_of_square_number</strong></span>
<span class="strong"><strong>    should written sum of square of numbers</strong></span>
<span class="strong"><strong>    should written 0 if array is blank</strong></span>

<span class="strong"><strong>Bacon::Error: 4.==(1) failed</strong></span>
<span class="strong"><strong>  spec.rb:649:in 'satisfy:': RootViewController - has default orientations for portrait</strong></span>
<span class="strong"><strong>  spec.rb:663:in 'method_missing:'</strong></span>
<span class="strong"><strong>  spec.rb:279:in 'block in run_spec_block'</strong></span>
<span class="strong"><strong>  spec.rb:403:in 'execute_block'</strong></span>
<span class="strong"><strong>  spec.rb:279:in 'run_spec_block'</strong></span>
<span class="strong"><strong>  spec.rb:294:in 'run'</strong></span>
</pre></div><p>As expected, it failed. Let's write its corresponding code to make our app work only in portrait mode.</p><p>Update <code class="literal">Rakefile</code> with the following line of code:</p><div class="informalexample"><pre class="programlisting">
app.interface_orientations = [:portrait]
</pre></div><p>Let's test our<a id="id466" class="indexterm"/> <code class="literal">spec</code> file once again and check the output on the console:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$rake spec</strong></span>

<span class="strong"><strong>Application 'LearnTest'</strong></span>
<span class="strong"><strong>  - has one window</strong></span>
<span class="strong"><strong>  - should set rootviewcontroller as RootViewController</strong></span>

<span class="strong"><strong>RootViewController</strong></span>
<span class="strong"><strong>  - should have label and button</strong></span>
<span class="strong"><strong>  - should show sum of square on click of button</strong></span>
<span class="strong"><strong>  - has default orientations for portrait</strong></span>

<span class="strong"><strong>sum_of_square_number</strong></span>
<span class="strong"><strong>  - should written sum of square of numbers</strong></span>
<span class="strong"><strong>  - should written 0 if array is blank</strong></span>

<span class="strong"><strong>7 specifications (10 requirements), 0 failures, 0 errors</strong></span>
</pre></div><p>All tests passed as expected. Now, let's run the application in a simulator with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$rake</strong></span>
</pre></div><p>Rotate the device by selecting <span class="strong"><strong>Hardware</strong></span> | <span class="strong"><strong>Rotate Left</strong></span> in the simulator menu as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/5220OT_08_03.jpg" alt="Rotate device"/></div><p>You can see that <a id="id467" class="indexterm"/>even after rotation, the interface orientation does not change as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/5220OT_08_04.jpg" alt="Rotate device"/></div></div><div class="section" title="Accelerometer device event"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec66"/>Accelerometer device event</h2></div></div></div><p>Accelerometer <a id="id468" class="indexterm"/>allows us to measure the linear acceleration of the device for your application. We can test the accelerometer features either on a device or with the following <code class="literal">accelerate</code> event:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>accelerate(:x =&gt; x_axis_acceleration, :y =&gt; y_axis_acceleration,</strong></span>
<span class="strong"><strong>             :z =&gt; z_axis_acceleration, :duration =&gt; duration)</strong></span>
</pre></div><p>The following parameters can be passed with <code class="literal">accelerate</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">x</code>: If you hold your device in the portrait orientation and the screen is facing you, the x axis will run from left to right, with values on the left as negative and values on the right as positive.</li><li class="listitem" style="list-style-type: disc"><code class="literal">y</code>: If you hold<a id="id469" class="indexterm"/> your device in the portrait orientation and the screen is facing you, the y axis will run from bottom to top, with values on the bottom as negative and values on the top as positive.</li><li class="listitem" style="list-style-type: disc"><code class="literal">z</code>: If you hold your device in the portrait orientation and the screen is facing you, the z axis will run from back to front, with values at the back as negative and values towards the front as positive. For example, accelerate: x =&gt; 0, :y =&gt; 0, :z =&gt; -1.</li></ul></div><div class="mediaobject"><img src="graphics/5220OT_08_05.jpg" alt="Accelerometer device event"/></div><p>This test case event simulates a device lying on its back.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note35"/>Note</h3><p>To trigger a shake motion event, we can use the following method: <code class="literal">shake()</code>
</p></div></div></div><div class="section" title="Gestures"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec67"/>Gestures</h2></div></div></div><p>A user of an iOS application <a id="id470" class="indexterm"/>uses the app in a number of ways, by tapping or touching the screen and pinching or rotating. With RubyMotion, we can test most <a id="id471" class="indexterm"/>of these gestures; let's discuss a few of them in this section.</p><p>Most of the gestures operate on views. We can specify the location of our event on the view by either using CGPoint or with the following constants:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">:top</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">:top_left</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">:top_right</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">:bottom_right</code><a id="id472" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">:bottom</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">:bottom_left</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">:left</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">:right</code><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note36"/>Note</h3><p>CGPoint lets us<a id="id473" class="indexterm"/> access a structure that contains a point in a two-dimensional coordinate system, for example, CGPoint.new(100, 200).</p></div></div></li></ul></div><div class="section" title="Tap"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec14"/>Tap</h3></div></div></div><p>To simulate a <a id="id474" class="indexterm"/>tapping event on a view, we can specify a label or a view, and some specific properties<a id="id475" class="indexterm"/> as follows:</p><div class="informalexample"><pre class="programlisting">tap(label_or_view, :at =&gt; location, :times =&gt; number_of_taps, :touches =&gt; number_of_fingers)</pre></div><p>Let's understand what the purpose of the optional parameters is:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">at</code>: We can specify <a id="id476" class="indexterm"/>the location on the view where we want the tap to simulate; the default location is the center of the view.</li><li class="listitem" style="list-style-type: disc"><code class="literal">times</code>: This specifies<a id="id477" class="indexterm"/> the number of times to tap the view. The default is a single tap.</li><li class="listitem" style="list-style-type: disc"><code class="literal">touches</code>: iPhone and iPad are multitouch devices; many apps exploit this feature of the iOS devices. <a id="id478" class="indexterm"/>You can specify the number of fingers that will be used to tap the view. The default is a single touch.</li></ul></div><p>The following example will tap <code class="literal">Test Label</code> with the default setting of tapping a view once with a single touch:</p><div class="informalexample"><pre class="programlisting">tap "Test Label"</pre></div><p>In the next example, we will test the view labeled <code class="literal">Test Label</code> by tapping five times with two fingers:</p><div class="informalexample"><pre class="programlisting">tap 'Test Label', :times =&gt; 5, :touches =&gt; 2</pre></div></div><div class="section" title="Flick"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec15"/>Flick</h3></div></div></div><p>Flick generates a <a id="id479" class="indexterm"/>sharp moment of the drag gesture as follows:</p><div class="informalexample"><pre class="programlisting">flick(label_or_view, :from =&gt; location, :to =&gt; location, :duration =&gt; duration)</pre></div><p>We can pass the following<a id="id480" class="indexterm"/> options with the <code class="literal">flick</code> method:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">from</code>: Specifies the<a id="id481" class="indexterm"/> location on the view to start the drag gesture.</li><li class="listitem" style="list-style-type: disc"><code class="literal">to</code>: Specifies the location<a id="id482" class="indexterm"/> on the view to end the drag gesture.</li></ul></div><p>The following example generates a flick gesture to the right of the view:</p><div class="informalexample"><pre class="programlisting">flick "test label", :to =&gt; :right</pre></div></div><div class="section" title="Pinch open"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec16"/>Pinch open</h3></div></div></div><p>Pinch open is a<a id="id483" class="indexterm"/> gesture using two fingers, which is generally used for zooming the images. With the following <a id="id484" class="indexterm"/>method we can generate a pinch open gesture:</p><div class="informalexample"><pre class="programlisting">pinch_open(label_or_view, :from =&gt; location, :to =&gt; location, :duration =&gt; duration)</pre></div><p>We can pass the following options with the <code class="literal">pinch_open</code> method:</p><p>
<code class="literal">from</code>: This denotes<a id="id485" class="indexterm"/> the starting point for two fingers to begin the pinch open gesture; by default, it is to the left of the view.</p><p>
<code class="literal">to</code>: This denotes<a id="id486" class="indexterm"/> the ending point for two fingers to finish the pinch open gesture; it defaults to the right.</p><p>The following example zooms in on the content view of a <code class="literal">UIScrollView</code> class:</p><div class="informalexample"><pre class="programlisting">view('Test Zoom').zoomScale # =&gt; 1.0
pinch_open 'Test Zoom'
view('Test Zoom').zoomScale # =&gt; 2.0</pre></div></div><div class="section" title="Pinch close"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec17"/>Pinch close</h3></div></div></div><p>Pinch close<a id="id487" class="indexterm"/> is a gesture<a id="id488" class="indexterm"/> using two fingers, which is generally used for zooming out on images. With the following method we can generate a pinch close gesture:</p><div class="informalexample"><pre class="programlisting">pinch_close(label_or_view, :from =&gt; location, :to =&gt; location, :duration =&gt; duration)</pre></div><p>We can pass the following options with the <code class="literal">pinch_close</code> method:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">from</code>: This<a id="id489" class="indexterm"/> denotes the starting point for two fingers to begin the pinch close gesture; by default, it is to the right of the view.</li><li class="listitem" style="list-style-type: disc"><code class="literal">to</code>: This denotes the ending<a id="id490" class="indexterm"/> point for two fingers to<a id="id491" class="indexterm"/> finish the pinch close gesture; by default, it is to the left of the view.</li></ul></div><p>The following <a id="id492" class="indexterm"/>example zooms out of the content view of a <code class="literal">UIScrollView</code> class:</p><div class="informalexample"><pre class="programlisting">view('Test Zoom').zoomScale # =&gt; 1.0
pinch_close 'Test Zoom'
view('Test Zoom').zoomScale # =&gt; 0.5</pre></div></div><div class="section" title="Drag"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec18"/>Drag</h3></div></div></div><p>A drag gesture is generally<a id="id493" class="indexterm"/> used for panning and scrolling; it always has a <a id="id494" class="indexterm"/>start and end point. With the following method we can generate a drag gesture:</p><div class="informalexample"><pre class="programlisting">drag(label_or_view, :from =&gt; location, :to =&gt; location, :number_of_points =&gt; steps,
     :points =&gt; path, :touches =&gt; number_of_fingers, :duration =&gt; duration)</pre></div><p>We can pass the following options with the <code class="literal">drag</code> method:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">from</code>: This denotes the part<a id="id495" class="indexterm"/> of the view where the drag gesture will begin. If not specified, it defaults to none.</li><li class="listitem" style="list-style-type: disc"><code class="literal">to</code>: This denotes the part of the view where the drag gesture will end. If not specified, it defaults to none.<a id="id496" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">number_of_points</code>: The number<a id="id497" class="indexterm"/> of points between <code class="literal">:from</code> and <code class="literal">:to</code>. It defaults to 20.</li><li class="listitem" style="list-style-type: disc"><code class="literal">points</code>: An array of <a id="id498" class="indexterm"/>CGPoint instances that specifies the drag path.</li><li class="listitem" style="list-style-type: disc"><code class="literal">touches</code>: The number <a id="id499" class="indexterm"/>of fingers to be used to drag. It defaults to a single touch.</li></ul></div><p>Keep in mind that scrolling in a direction means dragging in the opposite direction.</p><p>The following code will scroll down in a scroll view:</p><div class="informalexample"><pre class="programlisting">view('Some Scrollable scrollview').contentOffset.y # =&gt; 0
drag 'Some Scrollable scrollview', :from =&gt; :bottom
view('Some Scrollable scrollview').contentOffset.y # =&gt; 400</pre></div></div><div class="section" title="Rotation"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec19"/>Rotation</h3></div></div></div><p>To test the clockwise<a id="id500" class="indexterm"/> and anticlockwise rotation gesture, the following method is<a id="id501" class="indexterm"/> used. This method will simulate the rotation gesture around the center point of the view.</p><div class="informalexample"><pre class="programlisting">rotate(label_or_view, :radians =&gt; angle, :degrees =&gt; angle, :touches =&gt; number_of_fingers, :duration =&gt; duration)</pre></div><p>We can<a id="id502" class="indexterm"/> pass the following options with the <code class="literal">rotate</code> method:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">radians</code>: The angle of rotation in radians. It defaults to π.</li><li class="listitem" style="list-style-type: disc"><code class="literal">degrees</code>: The angle of rotation in degrees. It defaults to 180.</li><li class="listitem" style="list-style-type: disc"><code class="literal">touches</code>: The number of fingers used to rotate. It defaults to 2.</li></ul></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec50"/>Summary</h1></div></div></div><p>Let's recap all that we have learned in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Unit test cases</li><li class="listitem" style="list-style-type: disc">Functional test cases</li><li class="listitem" style="list-style-type: disc">How to test device events</li></ul></div><p>So far we have covered the basics and advanced topics related to RubyMotion. And now we are ready to do some fun stuff. In the next chapter we will learn to create games with RubyMotion. Gaming apps are one of (if not the) most popular genres of apps on the App Store. Most of us pass the time playing games on our iOS devices, so why not learn how to use RubyMotion to create our own game. In the next chapter we will learn how to create a game using RubyMotion.</p></div></body></html>