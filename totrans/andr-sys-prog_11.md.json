["```kt\nI SurfaceFlinger: SurfaceFlinger is starting \nI SurfaceFlinger: SurfaceFlinger's main thread ready to run. Initializing graphics H/W... \nD libEGL  : loaded /system/lib/egl/libGLES_mesa.so \nW linker  : /system/lib/libglapi.so has text relocations. This is wasting memory and prevents security hardening. Please fix. \nI HAL     : loaded HAL id=gralloc path=/system/lib/hw/gralloc.default.so hmi=0x5 handle=0xb7145664 \nI EGL-DRI2: found extension DRI_Core version 1 \nI EGL-DRI2: found extension DRI_SWRast version 5 \nI EGL-DRI2: found extension DRI_TexBuffer version 2 \nI EGL-DRI2: found extension DRI_IMAGE version 11 \nI HAL     : loaded HAL id=gralloc path=/system/lib/hw/gralloc.default.so hmi=0x0 handle=0xb7145664 \nI powerbtn: open event0(Power Button) ok fd=4 \nW gralloc : page flipping not supported (yres_virtual=768, requested=1536) \nI gralloc : using (fd=12) \nI gralloc : id           = VESA VGA \nI gralloc : xres         = 1024 px \nI gralloc : yres         = 768 px \nI gralloc : xres_virtual = 1024 px \nI gralloc : yres_virtual = 768 px \nI gralloc : bpp          = 32 \nI gralloc : r            = 16:8 \nI gralloc : g            =  8:8 \nI gralloc : b            =  0:8 \nI gralloc : a            = 24:8 \nI gralloc : stride       = 4096 \nI gralloc : fbSize       = 12582912 \nI gralloc : width        = 163 mm (159.568100 dpi) \nI gralloc : height       = 122 mm (159.895081 dpi) \nI gralloc : refresh rate = 65.46 Hz \nE SurfaceFlinger: hwcomposer module not found \n\n```", "```kt\nI SurfaceFlinger: EGL information: \nI SurfaceFlinger: vendor    : Android \nI SurfaceFlinger: version   : 1.4 Android META-EGL \nI SurfaceFlinger: extensions: EGL_KHR_get_all_proc_addresses EGL_ANDROID_presentation_time EGL_KHR_swap_buffers_with_damage EGL_KHR_image_base EGL_KHR_gl_texture_2D_image EGL_KHR_gl_texture_3D_image EGL_KHR_gl_texture_cubemap_image EGL_KHR_gl_renderbuffer_image EGL_KHR_reusable_sync EGL_KHR_fence_sync EGL_KHR_create_context EGL_KHR_surfaceless_context EGL_ANDROID_image_native_buffer EGL_KHR_wait_sync EGL_ANDROID_recordable  \nI SurfaceFlinger: Client API: OpenGL_ES \nI SurfaceFlinger: EGLSurface: 8-8-8-8, config=0xb46a3800 \n\n```", "```kt\nI SurfaceFlinger: OpenGL ES informations: \nI SurfaceFlinger: vendor    : VMware, Inc. \nI SurfaceFlinger: renderer  : Gallium 0.4 on llvmpipe (LLVM 3.7, 256 bits) \nI SurfaceFlinger: version   : OpenGL ES 3.0 Mesa 12.0.1 (git-c3bb2e3) \nI SurfaceFlinger: extensions: GL_EXT_blend_minmax GL_EXT_multi_draw_arrays GL_EXT_texture_compression_dxt1 GL_EXT_texture_format_BGRA8888 GL_OES_compressed_ETC1_RGB8_texture GL_OES_depth24 GL_OES_element_index_uint GL_OES_fbo_render_mipmap GL_OES_mapbuffer GL_OES_rgb8_rgba8 GL_OES_standard_derivatives GL_OES_stencil8 GL_OES_texture_3D GL_OES_texture_float GL_OES_texture_float_linear GL_OES_texture_half_float GL_OES_texture_half_float_linear GL_OES_texture_npot GL_EXT_texture_sRGB_decode GL_OES_EGL_image GL_OES_depth_texture GL_OES_packed_depth_stencil GL_EXT_texture_type_2_10_10_10_REV GL_OES_get_program_binary GL_APPLE_texture_max_level GL_EXT_discard_framebuffer GL_EXT_read_format_bgra GL_NV_fbo_color_attachments GL_OES_EGL_image_external GL_OES_EGL_sync GL_OES_vertex_array_object GL_ANGLE_texture_compression_dxt3 GL_ANGLE_texture_compression_dxt5 GL_EXT_texture_rg GL_EXT_unpack_subimage GL_NV_draw_buffers GL_NV_read_buffer GL_NV_read_depth GL_NV_read_depth_stencil GL_NV_read_stencil GL_EXT_draw_buffers GL_EXT_map_buffer_ra \nI SurfaceFlinger: GL_MAX_TEXTURE_SIZE = 8192 \nI SurfaceFlinger: GL_MAX_VIEWPORT_DIMS = 8192 \nD SurfaceFlinger: Open /dev/tty0 OK \nI HAL     : loaded HAL id=gralloc path=/system/lib/hw/gralloc.default.so hmi=0xb769a108 handle=0xb7145664 \nI HAL     : loaded HAL id=gralloc path=/system/lib/hw/gralloc.default.so hmi=0xb769a108 handle=0xb7145664 \nD SurfaceFlinger: Set power mode=2, type=0 flinger=0xb70e2000 \nD SurfaceFlinger: shader cache generated - 24 shaders in 25.081509 ms \n\n```", "```kt\nI SurfaceFlinger: SurfaceFlinger is starting \nI SurfaceFlinger: SurfaceFlinger's main thread ready to run. Initializing graphics H/W... \n\n```", "```kt\nvoid SurfaceFlinger::init() { \n    ALOGI(  \"SurfaceFlinger's main thread ready to run. \" \n            \"Initializing graphics H/W...\"); \n\n    Mutex::Autolock _l(mStateLock); \n\n    // initialize EGL for the default display \n    mEGLDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY); \n    eglInitialize(mEGLDisplay, NULL, NULL); \n\n    ... \n\n    // Initialize the H/W composer object.  There may or may not  \n    // be an actual hardware composer underneath. \n    mHwc = new HWComposer(this, \n            *static_cast<HWComposer::EventHandler *>(this)); \n\n    // get a RenderEngine for the given display / config \n    mRenderEngine = RenderEngine::create(mEGLDisplay, mHwc-\n    >getVisualID()); \n\n    // retrieve the EGL context that was selected/created \n    mEGLContext = mRenderEngine->getEGLContext(); \n\n```", "```kt\nEGLDisplay eglGetDisplay(EGLNativeDisplayType display) \n{ \n    clearError(); \n\n    uintptr_t index = reinterpret_cast<uintptr_t>(display); \n    if (index >= NUM_DISPLAYS) { \n        return setError(EGL_BAD_PARAMETER, EGL_NO_DISPLAY); \n    } \n\n    if (egl_init_drivers() == EGL_FALSE) { \n        return setError(EGL_BAD_PARAMETER, EGL_NO_DISPLAY); \n    } \n\n    EGLDisplay dpy = egl_display_t::getFromNativeDisplay(display); \n    return dpy; \n} \n\n```", "```kt\nstatic EGLBoolean egl_init_drivers_locked() { \n    if (sEarlyInitState) { \n        // initialized by static ctor. should be set here. \n        return EGL_FALSE; \n    } \n\n    // get our driver loader \n    Loader& loader(Loader::getInstance()); \n\n    // dynamically load our EGL implementation \n    egl_connection_t* cnx = &gEGLImpl; \n    if (cnx->dso == 0) { \n        cnx->hooks[egl_connection_t::GLESv1_INDEX] = \n                &gHooks[egl_connection_t::GLESv1_INDEX]; \n        cnx->hooks[egl_connection_t::GLESv2_INDEX] = \n                &gHooks[egl_connection_t::GLESv2_INDEX]; \n        cnx->dso = loader.open(cnx); \n    } \n\n    return cnx->dso ? EGL_TRUE : EGL_FALSE; \n} \n\nstatic pthread_mutex_t sInitDriverMutex = PTHREAD_MUTEX_INITIALIZER; \n\nEGLBoolean egl_init_drivers() { \n    EGLBoolean res; \n    pthread_mutex_lock(&sInitDriverMutex); \n    res = egl_init_drivers_locked(); \n    pthread_mutex_unlock(&sInitDriverMutex); \n    return res; \n} \n\n```", "```kt\nstruct egl_connection_t { \n    enum { \n        GLESv1_INDEX = 0, \n        GLESv2_INDEX = 1 \n    }; \n\n    inline egl_connection_t() : dso(0) { } \n    void *              dso; \n    gl_hooks_t *        hooks[2]; \n    EGLint              major; \n    EGLint              minor; \n    egl_t               egl; \n\n    void*               libEgl; \n    void*               libGles1; \n    void*               libGles2; \n}; \n\n```", "```kt\nvoid* Loader::open(egl_connection_t* cnx) \n{ \n    void* dso; \n    driver_t* hnd = 0; \n\n    dso = load_driver(\"GLES\", cnx, EGL | GLESv1_CM | GLESv2); \n    if (dso) { \n        hnd = new driver_t(dso); \n    } else { \n        // Always load EGL first \n        dso = load_driver(\"EGL\", cnx, EGL); \n        if (dso) { \n            hnd = new driver_t(dso); \n            hnd->set( load_driver(\"GLESv1_CM\", cnx, GLESv1_CM), \n            GLESv1_CM ); \n            hnd->set( load_driver(\"GLESv2\",    cnx, GLESv2),    GLESv2 ); \n        } \n    } \n\n    LOG_ALWAYS_FATAL_IF(!hnd, \"couldn't find an OpenGL ES \n    implementation\"); \n\n#if defined(__LP64__) \n    cnx->libEgl   = load_wrapper(\"/system/lib64/libEGL.so\"); \n    cnx->libGles2 = load_wrapper(\"/system/lib64/libGLESv2.so\"); \n    cnx->libGles1 = load_wrapper(\"/system/lib64/libGLESv1_CM.so\"); \n#else \n    cnx->libEgl   = load_wrapper(\"/system/lib/libEGL.so\"); \n    cnx->libGles2 = load_wrapper(\"/system/lib/libGLESv2.so\"); \n    cnx->libGles1 = load_wrapper(\"/system/lib/libGLESv1_CM.so\"); \n#endif \n    LOG_ALWAYS_FATAL_IF(!cnx->libEgl, \n            \"couldn't load system EGL wrapper libraries\"); \n\n    LOG_ALWAYS_FATAL_IF(!cnx->libGles2 || !cnx->libGles1, \n            \"couldn't load system OpenGL ES wrapper libraries\"); \n\n    return (void*)hnd; \n} \n\n```", "```kt\nvoid *Loader::load_driver(const char* kind, \n        egl_connection_t* cnx, uint32_t mask) \n{ \n    class MatchFile { \n    public: \n        static String8 find(const char* kind) { \n    ... \n    }; \n\n    String8 absolutePath = MatchFile::find(kind); \n    if (absolutePath.isEmpty()) { \n        // this happens often, we don't want to log an error \n        return 0; \n    } \n    const char* const driver_absolute_path = absolutePath.string(); \n\n    void* dso = dlopen(driver_absolute_path, RTLD_NOW | RTLD_LOCAL); \n    if (dso == 0) { \n        const char* err = dlerror(); \n        ALOGE(\"load_driver(%s): %s\", driver_absolute_path, err?\n        err:\"unknown\"); \n        return 0; \n    } \n\n    ALOGD(\"loaded %s\", driver_absolute_path); \n\n    if (mask & EGL) { \n        getProcAddress = (getProcAddressType)dlsym(dso, \n        \"eglGetProcAddress\"); \n\n        ALOGE_IF(!getProcAddress, \n                \"can't find eglGetProcAddress() in %s\", \n                driver_absolute_path); \n\n        egl_t* egl = &cnx->egl; \n        __eglMustCastToProperFunctionPointerType* curr = \n            (__eglMustCastToProperFunctionPointerType*)egl; \n        char const * const * api = egl_names; \n        while (*api) { \n            char const * name = *api; \n            __eglMustCastToProperFunctionPointerType f = \n                (__eglMustCastToProperFunctionPointerType)dlsym(dso, \n                name); \n            if (f == NULL) { \n                // couldn't find the entry-point, use \n                // eglGetProcAddress() \n\n                f = getProcAddress(name); \n                if (f == NULL) { \n                    f = (__eglMustCastToProperFunctionPointerType)0; \n                } \n            } \n            *curr++ = f; \n            api++; \n        } \n    } \n\n    if (mask & GLESv1_CM) { \n        init_api(dso, gl_names, \n            (__eglMustCastToProperFunctionPointerType*) \n                &cnx->hooks[egl_connection_t::GLESv1_INDEX]->gl, \n               getProcAddress); \n    } \n\n    if (mask & GLESv2) { \n      init_api(dso, gl_names, \n            (__eglMustCastToProperFunctionPointerType*) \n                &cnx->hooks[egl_connection_t::GLESv2_INDEX]->gl, \n            getProcAddress); \n    } \n\n    return dso; \n} \n\n```", "```kt\nmRenderEngine = RenderEngine::create(mEGLDisplay, mHwc->getVisualID()); \n\n```", "```kt\nEGLConfig RenderEngine::chooseEglConfig(EGLDisplay display, int format) { \n    status_t err; \n    EGLConfig config; \n\n    // First try to get an ES2 config \n    err = selectEGLConfig(display, format, EGL_OPENGL_ES2_BIT, \n    &config); \n    ... \n    eglGetConfigAttrib(display, config, EGL_ALPHA_SIZE, &a); \n    ALOGI(\"EGL information:\"); \n    ALOGI(\"vendor    : %s\", eglQueryString(display, EGL_VENDOR)); \n    ALOGI(\"version   : %s\", eglQueryString(display, EGL_VERSION)); \n    ALOGI(\"extensions: %s\", eglQueryString(display, EGL_EXTENSIONS)); \n    ALOGI(\"Client API: %s\", eglQueryString(display, \n    EGL_CLIENT_APIS)?:\"Not \n    Supported\"); \n    ALOGI(\"EGLSurface: %d-%d-%d-%d, config=%p\", r, g, b, a, config); \n\n    return config; \n} \n\n```", "```kt\nRenderEngine* RenderEngine::create(EGLDisplay display, int hwcFormat) { \n    EGLConfig config = EGL_NO_CONFIG; \n    if (!findExtension( \n            eglQueryStringImplementationANDROID(display,  \n            EGL_EXTENSIONS), \n            \"EGL_ANDROIDX_no_config_context\")) { \n        config = chooseEglConfig(display, hwcFormat); \n    } \n\n    ... \n\n    engine->setEGLHandles(config, ctxt); \n\n    ALOGI(\"OpenGL ES informations:\"); \n    ALOGI(\"vendor    : %s\", extensions.getVendor()); \n    ALOGI(\"renderer  : %s\", extensions.getRenderer()); \n    ALOGI(\"version   : %s\", extensions.getVersion()); \n    ALOGI(\"extensions: %s\", extensions.getExtension()); \n    ALOGI(\"GL_MAX_TEXTURE_SIZE = %zu\", engine->getMaxTextureSize()); \n    ALOGI(\"GL_MAX_VIEWPORT_DIMS = %zu\", engine->getMaxViewportDims()); \n\n    eglMakeCurrent(display, EGL_NO_SURFACE, EGL_NO_SURFACE, \n    EGL_NO_CONTEXT); \n    eglDestroySurface(display, dummy); \n\n    return engine; \n} \n\n```", "```kt\n$ cd {your AOSP root folder}\n$ source build/envsetup.sh\n$ lunch x86vbox-eng  \n\n```", "```kt\n$ cd $HOME\n$ git clone https://github.com/shugaoye/fbtest\n$ cd fbtest\n$ git checkout -b android-x86 remotes/origin/android-x86\n$ make  \n\n```", "```kt\n# Paths and settings \nTARGET_PRODUCT = x86vbox \nANDROID_ROOT   = $(OUT)/../../../.. \nBIONIC_LIBC    = $(ANDROID_ROOT)/bionic/libc \nPRODUCT_OUT    = $(ANDROID_ROOT)/out/target/product/$(TARGET_PRODUCT) \nCROSS_COMPILE  = \\ \n    $(ANDROID_ROOT)/prebuilts/gcc/linux-x86/x86/x86_64-linux-android-  \n    4.9/bin/x86_64-linux-android- \n\nARCH_NAME = x86 \n\n# Tool names \nAS            = $(CROSS_COMPILE)as \nAR            = $(CROSS_COMPILE)ar \n... \n\n```", "```kt\n(debug-late)@android: /android # system/xbin/modprobe uvesafb  \n\n```", "```kt\n(debug-late)@android:/android # fbset \n\nmode \"640x480-60\" \n # D: 23.845 MHz, H: 29.844 kHz, V: 60.048 Hz \n geometry 640 480 640 9830 16 \n timings 41937 80 16 13 1 63 3 \n accel false \n rgba 5/11,6/5,5/0,0/0 \nendmode  \n\n```", "```kt\n(debug-late)@android:/android # fbset vga \nfbset: /etc/fb.modes: No such file or directory \nfbset: unknown video mode 'vga'   \n\n```", "```kt\nmode \"640x480-60\" \n        # D: 23.845 MHz, H: 29.844 kHz, V: 60.048 Hz  \n        geometry 640 480 640 9830 16  \n        timings 41937 80 16 13 1 63 3  \n        accel false  \n        rgba 5/11,6/5,5/0,0/0  \nendmode \n\nmode \"1024x768-60\"  \n        # D: 64.033 MHz, H: 47.714 kHz, V: 60.018 Hz  \n        geometry 1024 768 1024 768 32  \n        timings 15617 159 52 23 1 107 3  \n        accel false  \n        rgba 8/16,8/8,8/0,8/24  \nendmode  \n\n```", "```kt\n(debug-late)@android:/android # fbset 1024x768-60  \n\n```", "```kt\n(debug-late)@android:/android # fbtest -f /dev/fb0 -l\nListing all tests \ntest001: Draw a 16x12 checkerboard pattern \ntest002: Draw a grid and some circles \ntest003: Draw the 16 Linux console colors \ntest004: Show the penguins \ntest005: Draw the default color palette \ntest006: Draw grayscale bands \ntest007: DirectColor test \ntest008: Draw the UV color space \ntest009: Show the penguins using copy_rect \ntest010: Hello world \ntest011: Panning test \ntest012: Filling squares   \n\n```", "```kt\n(debug-late)@android:/android # fbtest -f /dev/fb0 test002  \n\n```", "```kt\nfunction init_uvesafb() \n{ \n    case \"$PRODUCT\" in \n        ET2002*) \n            UVESA_MODE=${UVESA_MODE:-1600x900} \n            ;; \n        *) \n            ;; \n    esac \n\n    [ \"$HWACCEL\" = \"0\" ] && bpp=16 || bpp=32 \n    modprobe uvesafb mode_option=${UVESA_MODE:-1024x768}-$bpp ${UVESA_OPTION:-    \n    mtrr=3 scroll=redraw} \n} \n\nfunction init_hal_gralloc() \n{ \n    case \"$(cat /proc/fb | head -1)\" in \n        *virtiodrmfb) \n#            set_property ro.hardware.hwcomposer drm \n            ;& \n        0*inteldrmfb|0*radeondrmfb|0*nouveaufb|0*svgadrmfb) \n            set_property ro.hardware.gralloc drm \n            set_drm_mode \n            ;; \n        \"\") \n            init_uvesafb \n            ;& \n        0*) \n            ;; \n    esac \n\n    [ -n \"$DEBUG\" ] && set_property debug.egl.trace error \n} \n\n```", "```kt\nroot@x86vbox:/ # cat /proc/fb \n0 VESA VGA  \n\n```", "```kt\n# modprobe uvesafb mode_option=1024x768-32 mtrr=3 scroll=redraw  \n\n```", "```kt\n# cat /sys/bus/platform/drivers/uvesafb/uvesafb.0/vbe_modes\n640x400-8, 0x0100 \n640x480-8, 0x0101 \n800x600-8, 0x0103 \n1024x768-8, 0x0105 \n1280x1024-8, 0x0107 \n320x200-15, 0x010d \n320x200-16, 0x010e \n320x200-24, 0x010f \n640x480-15, 0x0110 \n640x480-16, 0x0111 \n640x480-24, 0x0112 \n800x600-15, 0x0113 \n800x600-16, 0x0114 \n800x600-24, 0x0115 \n1024x768-15, 0x0116 \n1024x768-16, 0x0117 \n1024x768-24, 0x0118 \n1280x1024-15, 0x0119 \n1280x1024-16, 0x011a \n1280x1024-24, 0x011b \n320x200-32, 0x0140 \n640x400-32, 0x0141 \n640x480-32, 0x0142 \n800x600-32, 0x0143 \n1024x768-32, 0x0144 \n1280x1024-32, 0x0145 \n320x200-8, 0x0146 \n1600x1200-32, 0x0147 \n1152x864-8, 0x0148 \n1152x864-15, 0x0149 \n1152x864-16, 0x014a \n1152x864-24, 0x014b \n1152x864-32, 0x014c  \n\n```", "```kt\n$ cd /usr/share/virtualbox\n$ ls\nnls                    src                     VBoxSysInfo.sh\nrdesktop-vrdp-keymaps  VBoxCreateUSBNode.sh\nrdesktop-vrdp.tar.gz   **VBoxGuestAdditions.iso**  \n\n```", "```kt\n$ ls\ndeffiles    routines.sh      vboxadd-x11                       x86\ninstaller   vboxadd          **VBoxGuestAdditions-amd64.tar.bz2**\ninstall.sh  vboxadd-service  **VBoxGuestAdditions-x86.tar.bz2**  \n\n```", "```kt\n$ source build/envsetup.sh\n$ lunch x86vbox-eng\n$ cd $HOME\n$ git clone https://github.com/shugaoye/vboxguest-linux-modules\n$ cd vboxguest-linux-modules\n$ make BUILD_TARGET_ARCH=x86 KERN_DIR=$OUT/obj/KERNEL_OBJ  \n\n```", "```kt\n$ ls\nbuild_in_tmp  Makefile   vboxguest.ko  vboxsf.ko  vboxvideo.ko\nLICENSE       vboxguest  vboxsf        vboxvideo  \n\n```", "```kt\n$ croot\n$ cd device/generic/x86vbox\n$ ls vbox\nvboxguest.ko  vboxsf.ko  vboxvideo.ko  \n\n```", "```kt\n... \nPRODUCT_COPY_FILES += \\ \n    device/generic/x86vbox/vbox/vboxguest.ko:system/vendor/vbox/vboxguest.ko \\ \n    device/generic/x86vbox/vbox/vboxsf.ko:system/vendor/vbox/vboxsf.ko \\ \n    device/generic/x86vbox/vbox/vboxvideo.ko:system/vendor/vbox/vboxvideo.ko \\ \n... \n\n```", "```kt\n$ ls mount.vboxsf/ \nAndroid.mk  mount.vboxsf.c  vbsfmount.h \n\n```", "```kt\nLOCAL_PATH:= $(call my-dir) \ninclude $(CLEAR_VARS) \n\nLOCAL_SRC_FILES:= mount.vboxsf.c \n\nLOCAL_CFLAGS:=-O2 -g \n#LOCAL_CFLAGS+=-DLINUX \n\nLOCAL_MODULE:=mount.vboxsf \nLOCAL_MODULE_TAGS := optional \n\ninclude $(BUILD_EXECUTABLE) \n\n```", "```kt\n... \nPRODUCT_PACKAGES += \\ \n    mount.vboxsf \\ \n... \n\n```", "```kt\nload_modules() \n{ \n   if [ -z \"$FOUND\" ]; then \n         auto_detect \n   fi \n\n   # 3G modules \n   for m in $EXTMOD; do \n         busybox modprobe $m \n   done \n\n    if [ -n \"$VBOX_GUEST_ADDITIONS\" ]; then \n         echo \"Loading VBOX_GUEST_ADDITIONS ...\" \n         insmod /android/system/vendor/vbox/vboxguest.ko \n         insmod /android/system/vendor/vbox/vboxsf.ko \n         if [ ! -e /android$SDCARD ]; then \n               mkdir /android$SDCARD \n               /android/system/bin/mount.vboxsf sdcard /android$SDCARD \n         fi \n   fi \n} \n\n```", "```kt\nlabel 1\\. x86vbox (2 stages boot) \nmenu x86vbox_initrd \nkernel x86vbox/kernel \nappend ip=dhcp console=ttyS3,115200 androidboot.selinux=permissive buildvariant=eng initrd=x86vbox/initrd.img androidboot.hardware=x86vbox DEBUG=2 SRC=/android-x86vbox ROOT=/dev/sda1 VBOX_GUEST_ADDITIONS=1 SDCARD=vendor DATA=sda2 X86VBOX=1 \n\n```", "```kt\n/android/system/bin/mount.vboxsf sdcard /android$SDCARD \n\n```", "```kt\n   if [ -n \"$VBOX_VIDEO_DRIVER\" ]; then \n       modprobe ttm \n       modprobe drm_kms_helper \n       insmod /android/system/vendor/vbox/vboxvideo.ko \n   fi \n\n```", "```kt\n[   25.240357] vboxguest: misc device minor 53, IRQ 20, I/O port d040, MMIO at) \n[   25.261044] [drm] Initialized drm 1.1.0 20060810                             \n[   25.290777] [drm] VRAM 08000000                                              \n[   25.309754] [TTM] Zone  kernel: Available graphics memory: 440884 kiB        \n[   25.337733] [TTM] Zone highmem: Available graphics memory: 1034776 kiB       \n[   25.349078] [TTM] Initializing pool allocator                                \n[   25.349735] fbcon: vboxdrmfb (fb0) is primary device                         \n[   25.360984] Console: switching to colour frame buffer device 100x37          \n[   25.380299] vboxvideo 0000:00:02.0: fb0: vboxdrmfb frame buffer device       \n[   25.388745] [drm] Initialized vboxvideo 1.0.0 20130823 for 0000:00:02.0 on m0 \n\n```", "```kt\n(debug-late)@android:/android # fbset \n\nmode \"800x600-0\" \n # D: 0.000 MHz, H: 0.000 kHz, V: 0.000 Hz \n geometry 800 600 800 600 32\n timings 0 0 0 0 0 0 0\n accel true\n rgba 8/16,8/8,8/0,0/0\nendmode  \n\n```", "```kt\n(debug-late)@android:/android # cat /proc/fb \n0 vboxdrmfb                                        \n\n```", "```kt\n$ repo init https://github.com/shugaoye/manifests -b android-7.1.1_r4_ch11_aosp\n$ repo sync  \n\n```", "```kt\n$ source build/envsetup.sh\n$ lunch x86vbox-eng\n$ make -j4 \n\n```", "```kt\n$ make initrd USE_SQUASHFS=0  \n\n```"]