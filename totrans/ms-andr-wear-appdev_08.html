<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Creating Custom UI</h1></div></div></div><div><table border="0" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p>
<em>"I have said that she had no face, but that meant she had a thousand faces."</em>                                                                                         
</p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<em>C. S. Lewis</em></td></tr></table></div><p>In this chapter, we will cover the design principles that are central to the Android Wear UI spaces and go over a few common Wear UI patterns. We then extend the <code class="literal">OnThisDay</code> activity to present the feed in a user-friendly format.</p><div><h3 class="title"><a id="note15"/>Note</h3><p>The code accompanying this chapter is available for reference on GitHub (<a class="ulink" href="https://github.com/siddii/mastering-android-wear/tree/master/Chapter_8">https://github.com/siddii/mastering-android-wear/tree/master/Chapter_8</a>). For the sake of brevity, only code snippets are included as needed. The reader is encouraged to download the referenced code from GitHub and follow along as they progress through the chapter.</p></div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec52"/>Android Wear UI design</h1></div></div></div><p>By now, it should be clear to us that wearable apps cannot always follow the same UI patterns that their handheld counterparts might. Wearable devices have a significantly smaller form factor and interacting with them places heavier constraints on user actions. For this reason, the Android Wear user interface APIs are functionally divided into <em>Suggest</em> functions and <em>Demand</em> functions.</p><p>The<em> Suggest</em> functions are embodied by the <code class="literal">Context</code> stream—a stream of information presented in a manner that is proactive and suggestive. Users are shown a vertical list of informational cards, which can be scrolled through until the user wishes to interact with a specific card.</p><p>The<em> Demand</em> functions are reflected in the cue card metaphor. A cue card can be opened by saying <strong>OK Google</strong>, or, we can open it by tapping on the background of the home screen. Each voice command activates a type of voice intent, which in turn can be associated with multiple applications.</p><p>When presented with intent, the user will have the opportunity to choose which application they would like the intent activated for. Applications can respond by adding/updating a stream card or launching another application.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec53"/>Common UI patterns</h1></div></div></div><p>We will touch upon the most commonly implemented UI patterns in Android Wear development.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec36"/>Cards</h2></div></div></div><p>The cards that are displayed in the Context stream can be standard notifications, single-action cards, or an expandable stack that groups related notifications together. In each case, an icon located at the top-right edge of the card indicates the application that the card is associated with.</p><p>In some cases, a single notification card does not suffice and more details may be needed. A swipe from right to left can reveal detail cards in addition to the main Context stream card. A swipe from left to right on a card causes it to be removed from the Context stream.</p><p>It is noteworthy that notifications dismissed on the wearable will cause them to be dismissed on a paired handheld as well due to the synchronized state shared by paired devices.</p><p>A card can optionally display action buttons to the right of detail cards. These actions may run on the wearable itself. Alternatively, they may be delegated to the companion handheld or they can cause a full-screen activity to run.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec8"/>Countdowns and confirmations</h3></div></div></div><p>When a user taps on an action button shown to the right of a detail card, the system can display a confirmation animation when the action completes.</p><p>In some cases, it may be desired to give the user a chance to interrupt an action before it executes. One way to address this is to display a customizable countdown animation prior to the action invocation.</p><p>Some actions may be critical in nature and it may be desired to highlight this by showing the user a confirmation step. The user would then have to confirm their intention to execute the action.</p><p>As developers, we should always weigh the option to delegate any heavy lifting work to the companion handheld whenever it is possible to do so. If this is the case for an action invoked on a card in the Context stream, then we may choose to display an animation on the wearable once the action button has been tapped by the user and the corresponding app has been launched on the handheld device.</p><p>There is also the option to have on-card actions. These are actions that execute on the card itself. These are ideal when there is only one possible action that a tap can have. For instance, a car icon displaying on a notification showing an address can only imply directions and is thus a good candidate to be an on-card action. An on-card action should be unambiguous in its purpose.</p><p>The alternative (that is, when there are multiple possible actions) is to invoke them via action buttons to the right of a detail card. For instance, in the case of a person's name, an on-card action is ambiguous, so separate action buttons would work better, for example, for actions such as call, e-mail, show details, and so on.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec9"/>Card stacks</h3></div></div></div><p>Some cards may be related and it makes sense to group them together in a stack. For instance, to display new mail notifications, a card stack can group all new mail notifications together.</p><p>Users would click on the card stack to make it fan out and display the top edge of each card in the stack. Further tapping on a fanned-out card will open the card to its fully expanded state in the vertical list that is the Context stream.</p><p>When the user swipes vertically away from a card stack, all the cards in the stack return to their fully collapsed state and the singular stack displays again in the Context stream.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec10"/>2D Pickers</h3></div></div></div><p>The 2D Picker is a flexible UI pattern used in Android Wear apps. It allows us to build
one-dimensional lists of cards or two-dimensional grids of cards, as dictated by requirements.</p><p>Furthermore, the direction of the scroll can be set as either horizontal or vertical. Data presented to the user is distributed across pages, and each page then corresponds to a card.</p><p>One intuitive presentation is to display a vertical list of cards to the user comprising (say) results of a search. Each card in the vertical list presents a small amount of information, and more information can be obtained by scrolling horizontally from it to display subsequent cards containing the remaining pages of information.</p><p>The 2D Picker pattern is implemented by adding an instance of a <code class="literal">GridViewPager</code> element to the layout of the activity in question. This pager must then have an adapter set for it of the <code class="literal">GridPagerAdapter</code> type.</p><p>To make things simpler, an abstract class extending the <code class="literal">GridPageAdapter</code> class named <code class="literal">FragmentGridPageAdapter</code> defines the common behavior your adapter will need, so all you have to do is extend the <code class="literal">FragmentGridPageAdapter</code> class to implement your own adapter to provide a set of pages to populate the <code class="literal">GridViewPager</code> element with.</p><p>When using a 2D Picker presentation, we must ensure that we optimize it to get the speed. This can be done by keeping the cards simple and minimizing the number of cards in the picker.</p><p>The 2D Picker should be destroyed when the user makes a selection. Users may also initiate an exit from a 2D picker by swiping down on the first card or swiping right on a left-most card.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec37"/>Selection lists</h2></div></div></div><p>This is a common pattern whereby possible choices are presented in a simple scrollable list. Users select an item from the list and thereby invoke an action.</p><p>The Android Wear UI library provides an implementation of a list that is optimized for wearables, namely the <code class="literal">WearableListView</code> element. To create a list of this kind, you add a <code class="literal">WearableListView</code> element to your activity's layout definition and then set its adapter to an instance of your custom layout implementation.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec54"/>Revisiting the OnThisDay activity</h1></div></div></div><p>Note that our initial implementation of the <code class="literal">OnThisDayActivity</code> activity from <a class="link" title="Chapter 5. Synchronizing Data" href="part0041.xhtml#aid-173721">Chapter 5</a>, <em>Synchronizing Data</em>, utilized a <code class="literal">TextView</code> method within a <code class="literal">ScrollView</code> method. Let's spruce that up using a few simple UI patterns we introduced in this chapter. We will intentionally keep this code simple to give you a chance to grasp the new API classes we use. You are encouraged to contrive use cases and experiment with more interesting patterns such as the 2D Picker.</p><p>Enough talk. It's time to write some code. We're now ready to improve our initial <em>On this day</em> feed presentation with a vertical list comprising cards. Each card can be dismissed by a swipe from left to right. The result is a far more usable application.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec38"/>The OnThisDayActivity activity</h2></div></div></div><p>The following <code class="literal">showOnThisDay</code> method creates and sets up a <code class="literal">GridViewPager</code> instance that properly handles the layout depending on the display:</p><pre class="programlisting">private void showOnThisDay(OnThisDay onThisDay) &#13;
{&#13;
  final Resources res = getResources();&#13;
  final GridViewPager pager = (GridViewPager) findViewById(R.id.pager); &#13;
  pager.setOnApplyWindowInsetsListener(new   View.OnApplyWindowInsetsListener()  &#13;
  {&#13;
    @Override&#13;
    public WindowInsets onApplyWindowInsets(View v, WindowInsets insets) &#13;
    {&#13;
      // Adjust page margins: &#13;
      // A little extra horizontal spacing between pages looks a bit &#13;
      // less crowded on a round display.&#13;
&#13;
      final boolean round = insets.isRound();&#13;
      int rowMargin = res.getDimensionPixelOffset(R.dimen.page_row_margin);&#13;
      int colMargin = res.getDimensionPixelOffset(round ? R.dimen.page_column_margin_round : R.dimen.page_column_margin);&#13;
      pager.setPageMargins(rowMargin, colMargin);&#13;
    &#13;
      // GridViewPager relies on insets to properly handle &#13;
      // layout for round displays. They must be explicitly &#13;
      // applied since this listener has taken them over.&#13;
    &#13;
      pager.onApplyWindowInsets(insets);&#13;
      return insets; &#13;
    } &#13;
  }); &#13;
  pager.setAdapter(new OnThisDayGridPagerAdapter(this,   getFragmentManager(), onThisDay)); &#13;
  DotsPageIndicator dotsPageIndicator = (DotsPageIndicator) findViewById(R.id.page_indicator); &#13;
  DotsPageIndicator.setPager(pager);&#13;
}</pre><p>The <code class="literal">DotsPageIndicator</code> is a page indicator for the <code class="literal">GridViewPager</code> class that helps to identify the current page with respect to the available pages on the current row. Dots represent pages; the current page can be distinguished by a dot of a distinct color and/or size.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec39"/>The activity layout</h2></div></div></div><p>The following activity layout shows the declaration of a <code class="literal">GridViewPage</code>r element where previously (in <a class="link" title="Chapter 5. Synchronizing Data" href="part0041.xhtml#aid-173721">Chapter 5</a>, <em>Synchronizing Data</em>) we had a <code class="literal">TextView</code> method within a <code class="literal">ScrollView</code> method:</p><pre class="programlisting">&lt;android.support.wearable.view.BoxInsetLayout&#13;
&#13;
  &#13;
  android:layout_width="match_parent"&#13;
  android:layout_height="match_parent"&#13;
  android:background="@color/yellow_orange"&gt;&#13;
&#13;
  &lt;FrameLayout &#13;
    android:layout_width="match_parent"&#13;
    android:layout_height="match_parent" &gt;&#13;
&#13;
    &lt;android.support.wearable.view.GridViewPager&#13;
      android:id="@+id/pager"&#13;
      android:layout_width="match_parent"&#13;
      android:layout_height="match_parent"&#13;
      android:keepScreenOn="true" /&gt;&#13;
&#13;
    &lt;android.support.wearable.view.DotsPageIndicator&#13;
      android:id="@+id/page_indicator"&#13;
      android:layout_width="wrap_content"&#13;
      android:layout_height="wrap_content"&#13;
      android:layout_gravity="center_horizontal|bottom"&gt; &#13;
    &lt;/android.support.wearable.view.DotsPageIndicator&gt;&#13;
  &lt;/FrameLayout&gt;&#13;
&lt;/android.support.wearable.view.BoxInsetLayout&gt;</pre><p>We define an <code class="literal">OnThisDayGridPagerAdapter</code> class extending the <code class="literal">FragmentGridPagerAdapter</code> class. An instance of this class is set as the adapter attribute of the <code class="literal">GridViewPager</code> element. A private inner class named <code class="literal">Row</code> is used as a convenience container for Fragment objects:</p><pre class="programlisting">public class OnThisDayGridPagerAdapter extends FragmentGridPagerAdapter &#13;
{&#13;
  private final Context mContext;&#13;
  private OnThisDay onThisDay;&#13;
  private List&lt;Row&gt; mRows;&#13;
  private ColorDrawable mDefaultBg;&#13;
  private ColorDrawable mClearBg;&#13;
  public OnThisDayGridPagerAdapter(Context ctx, FragmentManager fm, OnThisDay onThisDay) &#13;
  {&#13;
    super(fm);&#13;
    mContext = ctx;&#13;
    this.onThisDay = onThisDay;&#13;
    mRows = new ArrayList&lt;OnThisDayGridPagerAdapter.Row&gt;();&#13;
    ArrayList&lt;String&gt; listItems = onThisDay.getListItems();&#13;
    for (String listItem: listItems) &#13;
    {&#13;
      mRows.add(new Row(cardFragment("On This Day - " + (listItems.indexOf(listItem) + 1), listItem))); &#13;
    } &#13;
  }&#13;
  private Fragment cardFragment(String title, String content) &#13;
  { &#13;
    Resources res = mContext.getResources(); &#13;
    CardFragment fragment = CardFragment.create(title, content);&#13;
    // Add some extra bottom margin to leave room for the page indicator&#13;
    fragment.setCardMarginBottom( res.getDimensionPixelSize(R.dimen.card_margin_bottom));&#13;
    return fragment; &#13;
  }&#13;
  /** A convenient container for a row of fragments. */&#13;
  private class Row &#13;
  {&#13;
    final List&lt;Fragment&gt; columns = new ArrayList&lt;Fragment&gt;();&#13;
    public Row(Fragment... fragments) &#13;
    {&#13;
      for (Fragment f : fragments) &#13;
      { &#13;
        add(f); &#13;
      } &#13;
    }&#13;
    public void add(Fragment f) &#13;
    {&#13;
      columns.add(f); &#13;
    }&#13;
    Fragment getColumn(int i) &#13;
    {&#13;
      return columns.get(i); &#13;
    }&#13;
    public int getColumnCount() &#13;
    {&#13;
      return columns.size(); &#13;
    } &#13;
  }&#13;
  &#13;
  @Override&#13;
  public Fragment getFragment(int row, int col) &#13;
  { &#13;
    Row adapterRow = mRows.get(row);&#13;
    return adapterRow.getColumn(col); &#13;
  }&#13;
&#13;
  @Override&#13;
  public Drawable getBackgroundForRow(final int row) &#13;
  {&#13;
    return mContext.getResources().getDrawable(R.drawable.page_background); &#13;
  }&#13;
&#13;
  @Override&#13;
  public int getRowCount() &#13;
  {&#13;
    return mRows.size(); &#13;
  }&#13;
&#13;
  @Override&#13;
  public int getColumnCount(int rowNum) &#13;
  {&#13;
    return mRows.get(rowNum).getColumnCount(); &#13;
  }&#13;
}</pre><p>We run the application and choose the <strong>On this day…</strong> activity, as shown in the following screenshot:</p><p>
</p><div><img src="img/image00202.jpeg" alt="The activity layout"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Each item from the feed result is now presented as a card in a scrollable vertical list, as shown in the following screenshot:</p><p>
</p><div><img src="img/image00203.jpeg" alt="The activity layout"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>You can take a look at the second example by just scrolling vertically:</p><p>
</p><div><img src="img/image00204.jpeg" alt="The activity layout"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec55"/>Summary</h1></div></div></div><p>In this chapter, we went over Android Wear design principles and surveyed the common UI patterns that the majority of wearable applications implement. We then put the API to use by writing some code to augment the <strong>On this day...</strong> activity of the <code class="literal">Today</code> app from <a class="link" title="Chapter 5. Synchronizing Data" href="part0041.xhtml#aid-173721">Chapter 5</a>, <em>Synchronizing Data</em>, with a <code class="literal">GridViewPager</code> component that displays a list of cards and lets the user interact with them.</p></div></body></html>