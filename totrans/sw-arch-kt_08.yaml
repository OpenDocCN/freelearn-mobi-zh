- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Domain-Driven Design (DDD)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Engineers are often not the experts in business domains. Yet, they’re responsible
    for building complex applications that represent real-world domains. Traditionally,
    software architectures often struggle to express the intricacies and subtlety
    of business domains effectively, leading to systems that are challenging to understand,
    maintain, and evolve. This is where **domain-driven design** (**DDD**) is brought
    into play.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 7*](B21737_07.xhtml#_idTextAnchor255), we covered three architectural
    styles around the concept of having a dedicated layer to host business logic within
    an application. DDD aims to help engineers identify business behaviors that belong
    to the corresponding domain and the boundaries around it so that they can be implemented
    in the Core, Domain, or Use Case layer of an application.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter explores the powerful software design approach of DDD, which centers
    around the business domain in the software design process. It focuses on capturing
    and expressing the core business concepts, rules, and behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll dive deep into the theoretical principles and practical implementation
    strategies of DDD, illustrated by real-life examples. Then, we’ll explore how
    this approach can be used to build maintainable, scalable, and flexible software
    systems that align closely with business requirements.
  prefs: []
  type: TYPE_NORMAL
- en: By applying DDD, we can gain a better understanding of the domain and create
    a common language between domain experts and software developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re going to cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentals of DDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strategic and tactical designs in DDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modeling activities in DDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the code files used in this chapter on GitHub: [https://github.com/Packt
    Publishing/Software-Architecture-with-Kotlin/tree/main/chapter-8](https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-8%0D)'
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentals of DDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of DDD is to close the gap between the technical implementation of
    software and the business domain it serves. DDD heavily focuses on building software
    that accurately models the core concepts, business rules, and behaviors of the
    domain so that the software system is closely aligned with the needs of the business.
    This results in it being valuable, maintainable, flexible, and sustainable for
    the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'DDD highlights the distinction between the problem space and the solution space:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem space**: The problem space is the reality of the business – that
    is, the current circumstances of the business operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution space**: The solution space is the software system we have or will
    build to solve specific business cases in the problem space'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The dominant part of the problem space is the **domain**, which represents
    specific business use cases and operations. The solution space provides a way
    to model the domain to solve the given business cases, hence the name **domain
    model**. This relationship is illustrated in *Figure 8**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Problem space and solution space](img/B21737_08_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Problem space and solution space
  prefs: []
  type: TYPE_NORMAL
- en: 'A domain model abstracts and selects certain elements in the domain so that
    a software system can be built upon it. The abstraction and selection result in
    the domain model is never 100% correct and complete. It is exactly what statistician
    *George Box* wrote in 1976 in a paper published in the *Journal of the American*
    *Statistical Association*:'
  prefs: []
  type: TYPE_NORMAL
- en: “*All models are wrong, but some* *are useful.*”
  prefs: []
  type: TYPE_NORMAL
- en: In DDD, domain models don’t aim to be complete and accurate; instead, they aim
    to be useful in specific business contexts.
  prefs: []
  type: TYPE_NORMAL
- en: DDD encourages engineers to gain a deep understanding of the domain for which
    they’re building software. There are domain experts who understand what software
    they need to get the job done. This is particularly true for the domains that
    originally used manual processes or paperwork to operate the business. Software
    systems are often seen as automation tools for business operations. Having a domain
    expert who operates the business brings a lot of value to engineers in building
    the corresponding software.
  prefs: []
  type: TYPE_NORMAL
- en: 'DDD comprises two design methodologies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Strategic design**: This focuses on the overall structure and organization
    among multiple cohesive areas, named bounded contexts, within a larger business
    domain. It works toward a flexible and loose coupling system among bounded contexts
    by defining their collaborations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tactical design**: This refers to patterns, tools, and practices that make
    it simpler to build helpful domain models. We use tactical design when we have
    complex business logic to model or when complexity may be introduced in the future.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s important to point out that DDD has nothing to do with what technology
    and frameworks are chosen. Modeling a business domain is purely the way a software
    system should be built, not which tools are used.
  prefs: []
  type: TYPE_NORMAL
- en: DDD – strategic design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s recommended to start DDD with strategic design to establish the big picture
    before drilling down into the more granular tactical design. The very first step
    is known as **ubiquitous language**.
  prefs: []
  type: TYPE_NORMAL
- en: Ubiquitous language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using a common language between engineers and domain experts is crucial to the
    success of software systems. Business domains often involve a lot of industry
    terms, specialized concepts, and subtle rules. However, not all of them can be
    applied to the scope of a software system. On the other hand, engineering involves
    a lot of technical terms, methodologies, and best practices, all of which are
    needed for the given software system.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ubiquitous language** is a term that was introduced by *Eric Evans* in his
    book *Domain-Driven Design: Tackling Complexity in the Heart of Software*, published
    in 2004\. It serves as a common understanding and mental model of the domain that’s
    shared between engineers and domain experts. It aims for a consistent, well-defined,
    and precise language to eliminate misunderstandings and ambiguities. It’s a continuous,
    collaborative effort to build a common ground for effective and meaningful communication.
    Ubiquitous language is the common tongue between the domain and the domain model.'
  prefs: []
  type: TYPE_NORMAL
- en: Ubiquitous language is also a form of documentation and the knowledge base of
    systems. Once established, new team members can understand the domain and the
    existing code base quickly. It also facilitates knowledge transfer among teams
    and stakeholders, thus promoting better collaboration and reducing the risk of
    information loss.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ubiquitous language is the overlapping part between domain expert language
    and engineering language and implies a mutual understanding, as shown in *Figure
    8**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Ubiquitous language in DDD](img/B21737_08_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Ubiquitous language in DDD
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefits of ubiquitous language manifest themselves in various forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Glossary**: A glossary of terms and concepts and their definitions, available
    for everyone to read and learn about the business domain. Each term is reviewed
    and agreed upon by everyone involved in the development process. Ideally, there
    should be a process where changes can be submitted, reviewed, approved, and tracked
    in an auditable repository such as **GitHub**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documentation**: All documents related to the business domain should use
    the same terms and concepts that are defined in the glossary. These documents
    include user manuals, operation instructions, project plans, architectural design
    documents, diagrams, user stories, screen mockups, presentations, API documentation,
    and more. Any new term and concept should be added to the glossary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private large language modules (LLMs)**: The business domain knowledge, including
    terms, concepts, rules, and processes, can be used to train an LLM so that it
    can answer questions, complete text, generate dialog, and even become a part of
    the customer service bot. It does, however, require carefully crafting the input
    that’s given to the model to generate the desired outputs or responses. This process
    is called **prompt engineering**, but it’s beyond the scope of this book. OpenAI’s
    documentation has a section on prompt engineering that provides practical guidance:
    https://platform.openai.com/docs/guides/prompt-engineering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Source code**: The names of source files, functions, interfaces, classes,
    and even variables should use the same terms that have been defined in the glossary.
    Message payloads, database tables and fields, log messages, and error messages
    should also use these terms and concepts whenever applicable. These terms are
    used in every element in the code base. Seeing the same language everywhere related
    to the business domain for a software system is what we define as ubiquitous language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subdomains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **subdomain** is a distinct area of the business domain that has its own set
    of concepts and business rules. The language that’s used in a subdomain is part
    of ubiquitous language, and the corresponding concepts within the subdomain naturally
    form their own group.
  prefs: []
  type: TYPE_NORMAL
- en: Subdomains help break down the complexity of large domains into smaller, more
    manageable parts, allowing teams to focus on understanding and addressing the
    unique requirements and challenges of each subdomain. Subdomains belong to the
    problem space, and they may not always have a one-to-one mapping with a part of
    the system in the solution space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Subdomains can be categorized into three groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Core domains**: Core domains are at the heart of business operations. Without
    them, there’s no problem to solve, and there’s no reason to build software systems.
    Core subdomains are the most critical part of an organization to differentiate
    them from competitors. They also have the most complex business cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supporting subdomains**: Supporting subdomains provide peripheral tools and
    functionalities that complement and accelerate the core subdomains, but they aren’t
    the primary area of expertise for the business. They’re typically well-known capabilities
    where corresponding solutions can be found in the market or outsourced. They’re
    still relevant to the business but don’t provide significant competitive advantages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generic subdomains**: Generic subdomains refer to common problems that aren’t
    specific to the business. Their corresponding solutions are off-the-shelf commercial
    products. They’re essential for running business operations, but they don’t directly
    contribute to the core value proposition of the business.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By identifying and modeling subdomains, DDD enables the development of cohesive,
    modular, and loosely coupled software systems. This leads us to an important concept
    in the solution space known as bounded contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Bounded contexts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B21737_06.xhtml#_idTextAnchor212), we mentioned the importance
    of identifying highly cohesive functions and grouping them as individual deployable
    artifacts so that we don’t end up building a large monolithic application that’s
    expensive to maintain, difficult to understand, and almost impossible to optimize.
    The system can be broken down into bounded contexts.
  prefs: []
  type: TYPE_NORMAL
- en: A **bounded context** is a concept in the solution space. It represents a cohesive
    area of the business domain. It has its own scope, responsibilities, and rules
    that don’t overlap with other bounded contexts. A bounded context should have
    a clear purpose and a clear boundary. A well-defined bounded context gives a straightforward
    answer to whether a term or a rule belongs to the within or outside of the context.
    Within a bounded context, each building block has a specific semantic and purpose.
  prefs: []
  type: TYPE_NORMAL
- en: It takes away some parts of the complex business domain and turns them into
    a smaller and more manageable unit. Eventually, the sum of a sufficient collection
    of bound contexts is the overall domain model and thus eliminates the chance of
    it becoming a monolithic application.
  prefs: []
  type: TYPE_NORMAL
- en: A bounded context should represent one subdomain only, but a subdomain model
    might need a small portion of another subdomain model to function properly.
  prefs: []
  type: TYPE_NORMAL
- en: Also, a bounded context should have its own source code repository. It has its
    own data schema and data that are only shared with other bounded contexts via
    external representations defined in API documentation. It should also have dedicated
    deployable artifacts. They can be released independently without dependency on
    or affecting other bounded contexts. They should have their own release cadence.
  prefs: []
  type: TYPE_NORMAL
- en: A bounded context should be owned by one team only. The team has full autonomy
    in the choice of frameworks and development methodologies. In [*Chapter 1*](B21737_01.xhtml#_idTextAnchor013),
    we mentioned **Conway’s law**, which states that an organization often produces
    software systems that mirror the internal structures of the organization. Instead
    of being constrained by the organization structure, teams should be re-structured
    based on the bounded contexts that are discovered during the DDD process.
  prefs: []
  type: TYPE_NORMAL
- en: Context mapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because bounded contexts break down a system, they need to collaborate for the
    system to function and achieve the overall goals. **Context mapping** is a technique
    that can be used to identify the relationships and interactions among bounded
    contexts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the common patterns in this relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Partnership**: Two or more bounded contexts establish a collaborative relationship.
    This involves establishing close collaboration, shared understanding, and joint
    decision-making to address a specific business need. Even bounded contexts have
    their own goals, but their goals are connected to help solve a particular problem.
    So, they succeed and fail together:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Partnership](img/B21737_08_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Partnership
  prefs: []
  type: TYPE_NORMAL
- en: '**Shared kernel**: Two bounded contexts share a subset of their model or code.
    They might share the same data schema, a source code module, or compiled code
    as an artifact. However, it’s considered an anti-pattern to share a data schema
    or raw source code between two bounded contexts. However, it’s acceptable for
    two bounded contexts to depend on the same artifact that’s treated as a shared
    library:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Shared kernel](img/B21737_08_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – Shared kernel
  prefs: []
  type: TYPE_NORMAL
- en: '**Customer-supplier**: The upstream bounded context supplies data, while the
    downstream bounded context consumes that data. The customer and the supplier collaborate
    and agree on the protocol of the data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Customer-supplier](img/B21737_08_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Customer-supplier
  prefs: []
  type: TYPE_NORMAL
- en: '**Conformist**: The upstream bounded context supplies data and dictates the
    protocol of the data. The downstream bounded context conforms to the protocol
    and consumes that data. The upstream bounded context can be an external system
    or use an industry-standard protocol, making it unable to accommodate the downstream
    bounded context:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Conformist](img/B21737_08_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – Conformist
  prefs: []
  type: TYPE_NORMAL
- en: '**Anti-corruption layer**: The upstream bounded context supplies data and dominates
    the protocol of the data. The downstream bounded context, however, isn’t willing
    to conform to the protocol. Instead, the downstream bounded context builds an
    anti-corruption layer to consume the data and translate it into the structure
    that it desires:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Anti-corruption layer](img/B21737_08_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – Anti-corruption layer
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several scenarios where the downstream bounded context decides not
    to conform:'
  prefs: []
  type: TYPE_NORMAL
- en: The upstream bounded context uses an inconvenient data protocol, making it difficult
    to integrate and consume the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The upstream bounded context is unreliable, changes often, or occasionally brings
    breaking changes that the downstream bounded context intends to minimize so that
    the impact of any issue brought by the upstream bounded context is diminished
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data protocol used in the upstream bounded context brings conflicting or
    irrelevant data to the downstream bounded context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The downstream bounded context reflects the core domain, which warrants reasons
    not to depend on a foreign data protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Separate ways**: There are no interactions between bounded contexts as they’ve
    decided to go separate ways. This can be due to integration being too expensive,
    unsustainable, or impossible. The following are some example scenarios where this
    has occurred:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The teams for each bounded context have a tough time collaborating and agreeing.
    This can be due to legacy systems being involved or just organizational politics.
    Instead of dragging on the long negotiation process, the bounded context finds
    it easier and quicker to replicate the logic in its own spaces.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The models between bounded contexts are too different for the conformist pattern
    to be used or too expensive for the anti-corruption layer pattern to be used compared
    to implementing tailored logic in its own bounded context. The upstream bounded
    context may only supply part of the data required by the downstream bounded context,
    while the downstream bounded context can replicate a part of the logic but create
    a complete model that’s suitable for its specific purpose.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Often, it’s in the generic subdomain where collaboration has little value compared
    to replicating the logic in the respective bounded contexts. It could be that
    certain libraries are used to generate data, hence why the cost of integration
    isn’t justified.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open-host service**: A bounded context defines and exposes a public API that
    other bounded contexts can use to extend its functionality. The public API is
    intentionally decoupled from the internal model so that both can be evolved independently.
    The internal model of the bounded context also remains private:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Open-host service](img/B21737_08_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – Open-host service
  prefs: []
  type: TYPE_NORMAL
- en: '**Published language**: The published language focuses on establishing a shared
    language and glossary among bounded contexts. The published language doesn’t intend
    to conform to its ubiquitous language, though there’s no need to re-invent vocabulary
    if an appropriate term already exists in ubiquitous language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Published language intends to expose a protocol that’s convenient for consuming
    bounded contexts. It’s expressed in an integration-oriented language that’s usually
    not related to any programming language. Also, each bounded context should be
    able to translate between published language and corresponding internal models.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Published language ensures a consistent understanding of domain concepts and
    facilitates communication among bounded contexts.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Published language can be defined in many well-known formats, such as **OpenAPI**,
    **Avro**, **Protobuf**, fixed-length values, and comma-separated values.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Applying strategic design to a real-life example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve outlined the techniques and methods that are used in strategic
    design in DDD. Now, we’re going to apply them to the same real-life example we’ve
    been using throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – synopsis of the business problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s revisit the real-life example of households exchanging services. The
    team managed to find a senior lady who started to exchange services in the village.
    The team interviewed her, and their notes were captured. Here’s the synopsis that
    was validated and clarified with her as the domain expert:'
  prefs: []
  type: TYPE_NORMAL
- en: “We’re a tight-knit community where villagers frequently exchange services to
    support each other. The village consists of various households, each with its
    unique skills, talents, and needs. The households recognized that by offering
    their services, they could help one another and create a stronger community.
  prefs: []
  type: TYPE_NORMAL
- en: In this village, there were households specializing in different areas, such
    as carpentry, farming, cooking, and childcare. For instance, Mr. Whittington was
    a skilled carpenter who built and repaired furniture. When Mrs. Barker needed
    a new dining table, she approached Mr. Whittington to request his services.
  prefs: []
  type: TYPE_NORMAL
- en: In return for Mr. Whittington’s carpentry work, Mrs. Barker offered fresh produce
    from her farm to Mr. Carpenter’s household throughout the year.
  prefs: []
  type: TYPE_NORMAL
- en: Mrs. Barker drafted a contract to capture the details of the exchange, such
    as materials and dimensions of the table, what and how much fresh produce to provide,
    and a timeline. Mr. Whittington reviewed the contract and made a few adjustments.
    In the end, both Mr. Whittington and Mrs. Barker signed the contract.
  prefs: []
  type: TYPE_NORMAL
- en: This arrangement helped Mr. Whittington and his family have a steady supply
    of nutritious food while allowing Mrs. Barker to enjoy beautifully crafted furniture
    in her home.
  prefs: []
  type: TYPE_NORMAL
- en: These exchanges created the fabric of the village’s social and economic ecosystem.
    They fostered trust, cooperation, and mutual support among households, creating
    a harmonious and resilient community.”
  prefs: []
  type: TYPE_NORMAL
- en: Through this interview, the team captured the essence of the household service
    exchanges in the village. The team now understands the motivations, interactions,
    and benefits involved in the process.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – ubiquitous language
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At this point, the domain expert and the team can start to develop a shared
    understanding of the domain by identifying the following concepts mentioned in
    domain storytelling:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Household**: A group of villagers who live together in the same place of
    residence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Services**: The skills that a household specializes in and can be offered
    to another household.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contract**: An agreement of the details of the services that have been exchanged
    between two households.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Draft contract**: A contract initiated by a household for another household
    to review.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Agreed contract**: A contract has its details mutually agreed upon and signed
    by the two households involved. An agreed contract is ready to be exercised.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exercised contract**: A contract in which services performed by both households
    are completed, as per the details of each service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the basis of the **ubiquitous language** in the form of a **glossary**.
    It’s developed by both the domain expert and the team.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – subdomains
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Identifying subdomains is the next step of the DDD process. With the help of
    the glossary, the team has identified **Contract** as the core domain and **Household**
    as a supporting subdomain.
  prefs: []
  type: TYPE_NORMAL
- en: '**Contract** is the core domain as it’s the heart of the business domain. Without
    it, there’s no need to build a system. Household is an essential supporting subdomain
    so that the households involved in each contract can be identified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Household** itself can’t be a core domain because it’s technically possible
    to solve the business problem with a Household subdomain. If households are merely
    names in each contract without capabilities to verify and identify them, there
    could be a cutdown version of the system that has no Household subdomain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The team also recognized the need to notify households at several stages of
    a contract, such as when a contract is mutually agreed upon and ready to be exercised.
    Here, **notification** is also identified as a generic subdomain.
  prefs: []
  type: TYPE_NORMAL
- en: 'The core domain and the subdomains that have been identified are illustrated
    in *Figure 8**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – Core domain and subdomains](img/B21737_08_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – Core domain and subdomains
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 – bounded contexts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the core domain and subdomains defined in the problem space, it’s time
    to identify bounded contexts in the solution space. As mentioned previously, bounded
    contexts are defined by their scopes, responsibilities, and purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The team understands that Contract is the core domain, and there are two workflows
    with contracts. The first one starts from a contract drafted until agreed. The
    second one starts from agreed until exercised. The team also understands that
    the only connecting point of these two workflows is an agreed contract.
  prefs: []
  type: TYPE_NORMAL
- en: There are team members who suggest one bounded context for the whole Contract
    core domain. There are also others suggesting one bounded context for the first
    journey and another one for the second.
  prefs: []
  type: TYPE_NORMAL
- en: The team decides that the first journey of a contract from drafted to exercised
    is a bounded context and names it **Contract Service**. This bounded context maintains
    the workflow of contract from drafted to agreed, and then to exercised. However,
    a contract must involve two different households and services provided by each
    household. As a result, **Contract Service** covers the major portion of the Contract
    domain and a small portion of the Household subdomain to validate a contract.
  prefs: []
  type: TYPE_NORMAL
- en: The supporting subdomain, Household, also needs a bounded context to support
    the classic **Create, Read, Update, and Delete** (**CRUD**) operations of households.
    The corresponding bounded context is named **Household Service**.
  prefs: []
  type: TYPE_NORMAL
- en: The solution intends to notify households involved in a contract when it’s upon
    agreed or exercised. This generic subdomain, Notification, is covered by a bounded
    context named **Notification Service**.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 8**.10* demonstrates how the bounded contexts overlay the core domain
    and subdomains:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Bounded contexts, core domain, and subdomains](img/B21737_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – Bounded contexts, core domain, and subdomains
  prefs: []
  type: TYPE_NORMAL
- en: '**Household Service** is the only bounded context that’s dedicated to its subdomain.
    Other bounded contexts have a major subdomain or core domain while also covering
    small portions of other subdomains so that they can function.'
  prefs: []
  type: TYPE_NORMAL
- en: Step 5 – context mapping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The relationships among bounded contexts need to be defined via context mapping.
  prefs: []
  type: TYPE_NORMAL
- en: '**Household Service** has no upstream dependencies, but **Contract Service**
    needs to receive household information to carry out their operations.'
  prefs: []
  type: TYPE_NORMAL
- en: A household under Household Service contains information such as the household’s
    name, contact email address, list of member names, residential address, and more.
    **Contract Service** only cares about the household name to validate a contract
    and the contact email address to be able to request a notification to be sent
    to a given household.
  prefs: []
  type: TYPE_NORMAL
- en: Since **Contract Service** represents the core domain, it’s beneficial to avoid
    bringing in elements from other bounded contexts using an anti-corruption layer
    when communicating with **Household Service**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Notification Service**, as a generic bounded context, only needs to receive
    notification requests from a household and integrate with an email service provider
    to achieve its goal. It has a small portion of concepts that are supported by
    **Household Service** and **Contract Service**, but they dissolve into an email
    address, a title, and a body text. This is a customer-supplier relationship where
    **Notification Service** is the customer and other bounded contexts are suppliers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The overall **context map** is shown in *Figure 8**.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – Context mapping](img/B21737_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – Context mapping
  prefs: []
  type: TYPE_NORMAL
- en: The team and the domain expert have established ubiquitous language with a glossary
    as the output. They’ve also identified the core domain and subdomains. Finally,
    they’ve identified bounded contexts and the mapping among them.
  prefs: []
  type: TYPE_NORMAL
- en: The team now has a big picture of the whole household exchange service business
    model with strategic design in DDD. From now on, the team can focus on each of
    the bounded Contexts and their internal models.
  prefs: []
  type: TYPE_NORMAL
- en: DDD – tactical design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tactical design focuses on the internal model and relationships within a bounded
    context. It aims to create a highly cohesive domain model that expresses the essential
    business concepts and aligns with the ubiquitous language that’s used within the
    context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tactical design consists of several building blocks that provide a foundation
    for designing and building a bounded context within complex business domains:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Address` class is a value object as it has no identity but encapsulates multiple
    fields that form an address:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Household` class is an entity that’s been identified by `name`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Party` class is an aggregate because it contains the `Household` entity class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Contract` class is an aggregate root as it’s a top-level entrance to other
    aggregates, such as `Party`, and other entities, such as `Household`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The entry point to read and modify the state of an aggregate is called an **aggregate
    root**. Aggregates take part in maintaining the integrity of the domain model
    and ensuring all related entities are linked together sensibly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Domain services**: Domain services encapsulate domain behaviors that aren’t
    tied to a specific entity or value object. They enforce collaboration among multiple
    objects. Domain services help maintain the cohesion and integrity of the domain
    model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repositories**: A repository stores and retrieves domain objects. It defines
    the possible storage and retrieval options for domain objects but abstracts away
    the actual storage implementation. A repository can be persistent, similar to
    databases or files. It can also be transient, similar to an in-memory cache. Persistence,
    availability, isolation levels, and underlying storage methods are the only implementation
    details. In other words, the **domain service** doesn’t need to make technology
    choices for data storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Domain events**: Domain events represent things that have happened within
    a bounded context. They’re all named in the past tense and are immutable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Putting these building blocks together, the scope of tactical design in DDD
    can be illustrated like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12 – Tactical design in DDD](img/B21737_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 – Tactical design in DDD
  prefs: []
  type: TYPE_NORMAL
- en: Here, **Bounded Context** is the core of the application. Then, we have **Core**,
    which is the same concept that we covered in [*Chapter 7*](B21737_07.xhtml#_idTextAnchor255)
    when we talked about layered architectures – it’s a pure business concern area
    free of technology choices. This is also where all elements of tactical design
    are located.
  prefs: []
  type: TYPE_NORMAL
- en: The application transforms an external request into an internal request that
    **Domain Service** handles. The request is validated and handled by a set of business
    rules that are in **Domain Service** or the corresponding **Aggregate**. Then,
    **Domain Service** accesses **Aggregate** from the root **Entity** to access the
    underlying entities and other value objects. After, **Domain Service** uses **Repository**
    to persist and retrieve entities as part of the handling process.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, **Domain Service** returns a response to the originator of the request.
    The application transforms the internal response into an external response. Meanwhile,
    domain events are produced due to request handling. These events are picked up
    by the application, transformed into external events, and published.
  prefs: []
  type: TYPE_NORMAL
- en: Applying tactical design to a real-life example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Previously, the team defined three bounded contexts during strategic design
    for the real-life example of households exchanging services. Here, the team will
    pick one bounded context and go through the tactical design exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – identify aggregates, entities, and value objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The bounded context that’s been chosen here is **Contract Service**, which
    represents the core domain of **Contract**. The goal of this bounded context is
    to maintain the life cycle of a contract from when it was first drafted to when
    it’s mutually exercised. The team has identified an aggregate with the following
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The **Contract** aggregate starts with the root **Contract** entity. The **Contract**
    entity is identified by an ID. The Contract entity contains two value objects
    of the same type: **Party**. The **Party** value object only holds the necessary
    fields to represent a party of a contract. The **Party** value object holds a
    **Household** entity.'
  prefs: []
  type: TYPE_NORMAL
- en: The **Household** entity is local to **Contract Service** as it only contains
    a name and email address that are relevant to the bounded context. Here, **Household
    Service** supplies a full **Household** entity from the bounded context of **Household
    Service**. The foreign entity contains other fields such as residential address;
    these are ignored when the anti-corruption layer in **Contract Service** transforms
    the foreign entity into the local **Household** entity.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, the local **Household** entity only contains a name and a contact
    email address. The local **Household** entity is identified by its name.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – identify domain services, repositories, and domain events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having defined the aggregate with the root, entities, and value objects underneath
    it, the team can identify the operations required by the bounded context to achieve
    its goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three major operations in this bounded context:'
  prefs: []
  type: TYPE_NORMAL
- en: A contract is drafted by a household
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A contract is agreed upon by all households involved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A contract is exercised by all households involved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The corresponding timestamp should be set on the contract when these operations
    take place. The service should also notify the downstream bounded context using
    events.
  prefs: []
  type: TYPE_NORMAL
- en: '**Contract Service** validates incoming requests such as whether the contract
    and the household exist, and whether the contract should change. If everything
    goes well, a timestamp is set against the corresponding service in the contract.
    If a contract has been drafted, agreed upon, or exercised, a corresponding domain
    event is published.'
  prefs: []
  type: TYPE_NORMAL
- en: To support this operation, **Contract Service** needs to know both households.
    They are supplied by domain events published by upstream bounded contexts.
  prefs: []
  type: TYPE_NORMAL
- en: This bounded context consumes **Household Updated Event** published by **Household
    Service**. The **Household** entity is converted from this event and is stored
    in **Household Repository**.
  prefs: []
  type: TYPE_NORMAL
- en: The **Household** entity local to **Contract Service** is a trimmed down of
    the original **Household** entity in **Household Service**. **Contract Service**
    should only take the fields from **Household** that are relevant to the operations
    within its bounded context. Meanwhile, **Household Service** contains the full
    set of fields of **Household** relevant to the whole business domain.
  prefs: []
  type: TYPE_NORMAL
- en: These repositories serve as local caches, so **Contract Service** remains if
    other bounded contexts are unavailable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The inside of the bounded context can be seen in *Figure 8**.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – Inside the bounded context – Contract Service](img/B21737_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 – Inside the bounded context – Contract Service
  prefs: []
  type: TYPE_NORMAL
- en: The domain expert and the team have run through both strategic and tactical
    designs for the real-life example. They’ve covered ubiquitous language, subdomains,
    bounded contexts, context mapping, aggregates, entities, value objects, domain
    services, domain events, and repositories. Through these exercises, the domain
    expert and the team have established a shared understanding of the business problems,
    and they now have a useful model that they can use as a foundation for building
    a software system.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few formats of DDD workshops that any organization can consider
    bringing in to improve communication and collaboration among stakeholders and
    engineers. The next section will briefly introduce them and their formats.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling activities for DDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our real-life example, we covered how the solution evolves and emerges from
    the input of the team and the domain expert. It’s important to understand the
    actual modeling activities that are involved in DDD so that we can put them into
    practice.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few popular modeling activities that drive the direction of the
    design from both the team and the domain expert.
  prefs: []
  type: TYPE_NORMAL
- en: Domain expert interview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The concept of a domain expert interview was made popular by *Eric Evans* in
    his book *Domain-Driven Design: Tackling Complexity in the Heart of Software*,
    published in 2003.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Performing a domain expert interview is an approach that you can use to gain
    deep insights into the business domain and understand its intricacies. It is particularly
    applicable in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: The domain expert is external to the organization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The domain expert has only limited time to be involved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The organization starts a new line of business and brings in domain experts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The team is new and doesn’t have much prior knowledge of the domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some guidelines for conducting effective domain expert interviews
    in DDD:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identify the right experts**: Identify individuals, both internally and externally,
    who possess in-depth knowledge and expertise in the specific domain. Look for
    subject matter experts, experienced practitioners, or individuals who have a deep
    understanding of the business processes and rules involved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prepare an interview plan**: State clear objectives of the interview. Develop
    an outline of each topic. Prepare a list of questions, preferably open-ended ones,
    to ask. Pay attention to potential pain points and areas of uncertainty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Establish a comfortable environment**: Establish a collaborative atmosphere
    with the domain expert during the interview. Make them feel comfortable and valued.
    Clearly explain the interview’s purpose and outline the topics to be covered.
    Emphasize that their opinions are critical for your project’s success. Create
    an atmosphere where they feel free to share their knowledge and experiences.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Active listening**: During the interview, practice active listening. Pay
    close attention to the expert’s verbal responses and non-verbal communication.
    Clarify their answers whenever necessary and ask follow-up questions to delve
    deeper into specific areas of interest. Show genuine interest in their insights
    and validate their contributions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Capture notes**: Take thorough and detailed notes during the interview. Document
    important concepts, terms, processes, and examples that the expert shares. Record
    key details, such as business rules, decision-making criteria, and exceptions.
    Use visual aids, such as diagrams or sketches, to capture their explanations and
    mental models.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Validate and clarify information**: After the interview, review the notes
    that were taken and validate the information that’s been gathered. Clarify with
    the domain expert or have follow-up discussions on ambiguity or uncertainty. It’s
    important to ensure that the team has a clear and accurate understanding of the
    domain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Share and validate your findings**: After the interview, share your findings
    with the domain expert and other stakeholders to validate your understanding.
    Actively seek their feedback and incorporate any corrections or additional insights
    they may provide. By incorporating their input, the domain model can be refined
    and improved, ensuring that the software system accurately reflects the intricacies
    and requirements of the business domain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The domain expert interview is an iterative process. As the team understands
    more of the domain, new questions arise. Continuous collaboration and feedback
    with domain experts throughout the project can significantly contribute to the
    success of your DDD implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Event storming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Event storming is a domain modeling technique that was developed by *Alberto
    Brandolini* in 2013\. Event storming requires the team, domain experts, and other
    stakeholders to gather in the same place, ideally in person, and garner a mix
    of perspectives and knowledge about the domain.
  prefs: []
  type: TYPE_NORMAL
- en: An in-person event storming session requires a large whiteboard, many marker
    pens of assorted colors, and many stickies of many colors. Alternatively, online
    collaboration drawing tools that have the same elements can suffice.
  prefs: []
  type: TYPE_NORMAL
- en: Participants are expected to actively engage in every activity of the process.
    They’re expected to move some stickies, erase lines, and draw some lines on the
    board simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: The session starts with outlining the scope of the session. It should focus
    on a specific business process or domain participants want to explore. This could
    also be a specific feature, a user journey, or a critical aspect of the domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Afterward, the session can be run in the following sequence. If necessary,
    participants can go back and correct any sticky notes as they learn more in later
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Contract Agreed` or `Household Updated`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Arrange the events**: Once there’s a collection of domain events, work on
    the domain events on the whiteboard. Group duplicated events, remove irrelevant
    events, or correct ambiguous events. Place the events in chronological order,
    creating a timeline from left to right. This helps visualize the flow of events
    and their sequence.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Add actors and commands**: Identify the actors or entities involved in the
    events. These could be system components or human users. Capture actors as sticky
    notes but use a different color (for example, yellow). Place them above or below
    the relevant events.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify any commands or actions that trigger the events and associate them
    with the respective events. Commands are the user’s intent to do certain things.
    Commands or actions should use a new color (for example, blue) for stickies.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Identify external systems that trigger the events. Use a dedicated color (for
    example, red) for the stickies.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Explore policies and business rules**: Pay attention to policies, constraints,
    and business rules associated with the events. Capture them as separate sticky
    notes of a new color (for example, purple) and link them to the relevant events,
    commands, or actors. These rules help shape the behavior and interactions within
    the domain.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Discuss and refine the model**: Facilitate discussions among the participants
    alongside the stickies for events, actors, commands, external systems, and policies.
    Encourage them to share their knowledge, insights, and questions related to events
    and their relationships. Refine the model by rearranging, adding, or removing
    stickies during the discussions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Identify aggregates and bounded contexts**: Look for patterns and events
    that often go together. This cluster of events may indicate potential aggregates.
    Identify bounded contexts, which are cohesive areas of the domain with well-defined
    purposes, boundaries, and language.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Capture insights and next steps**: Capture any valuable insights, questions,
    or areas of uncertainty that arise. Make note of any follow-up actions or further
    investigations needed to refine the domain model.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Event storming is also an iterative process. Sometimes, it takes multiple sessions
    to fully explore and refine the domain model. Encourage collaboration, active
    participation, and idea sharing among the participants to gain a common understanding
    and drive the software system aligned with the business objectives.
  prefs: []
  type: TYPE_NORMAL
- en: Domain storytelling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Domain storytelling** was introduced in 2019 by *Stefan Hofer* and *Henning
    Schwentner* in their book *Domain Storytelling: A Collaborative Approach to* *Domain-Driven
    Design.*'
  prefs: []
  type: TYPE_NORMAL
- en: Domain storytelling is a collaborative and interactive approach to gaining a
    deeper understanding of a complex business domain. The team, domain experts, and
    other stakeholders come together, ideally in person, to develop stories that depict
    various aspects of the business domain.
  prefs: []
  type: TYPE_NORMAL
- en: Like event storming, an in-person domain storytelling session requires a large
    whiteboard, many marker pens, and many stickies. Again, online whiteboard collaboration
    tools that have the same elements can suffice.
  prefs: []
  type: TYPE_NORMAL
- en: Domain experts and stakeholders draw out a real-life business scenario by putting
    stickies on the whiteboard and connecting them with marker pens.
  prefs: []
  type: TYPE_NORMAL
- en: 'The domain story about drafting a contract may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – A domain story about drafting a contract](img/B21737_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.14 – A domain story about drafting a contract
  prefs: []
  type: TYPE_NORMAL
- en: These stories capture the context, challenges, interactions, and relationships
    within the domain. As the story is being told, everyone actively listens, asks
    questions, provides background information such as business rules, motivation,
    and pain points, or even picks up a pen and draws.
  prefs: []
  type: TYPE_NORMAL
- en: Participants may want to adopt a certain format, such as the **Business Process
    Modeling Notation** (**BPMN**) mentioned in [*Chapter 2*](B21737_02.xhtml#_idTextAnchor045),
    but this isn’t mandatory. The essence of the exercise is communication and collaboration
    to align everyone on a shared understanding. Also, domain experts may not be familiar
    with the standard visual notions. Instead of having them struggle to get the right
    notions, participants should focus on getting the right information instead.
  prefs: []
  type: TYPE_NORMAL
- en: Participants should use this opportunity to clear up any ambiguous, unclear,
    and misused languages to aim for ubiquitous language.
  prefs: []
  type: TYPE_NORMAL
- en: The visual representation serves as a shared artifact that can be referred to
    and refined throughout the development process.
  prefs: []
  type: TYPE_NORMAL
- en: Domain storytelling helps bridge the gap between the team and domain experts
    by collaboratively working toward a shared language and understanding of the domain.
    It helps uncover hidden requirements, edge cases, and exceptional scenarios that
    may often be found in the middle or late stage of development. As a result, it
    reduces the cost of design modifications and lowers the risks of scope creep.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, domain storytelling provides a user-centric perspective to software
    systems by emphasizing the needs, goals, and experiences of the users within the
    stories. It aids the team and domain experts in identifying bounded contexts,
    aggregate roots, and domain entities, promoting a robust and accurate domain model.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, domain storytelling serves as a powerful tool for domain exploration,
    analysis, and communication. It helps build a shared understanding of the domain,
    facilitates collaboration between stakeholders and the team, and supports building
    software systems that accurately reflect the intricacy and requirements of the
    business domain.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing modeling activities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All modeling activities in DDD are iterative. They continuously refine and shape
    the software systems as participants understand more the subject matters, and
    as business evolves.
  prefs: []
  type: TYPE_NORMAL
- en: However, the dynamics of these three activities are different. In a domain expert
    interview, the team drives the interview by preparing the topics and questions.
    The domain experts primarily react to these materials, and the team actively listens
    and responds. In event storming, everyone works on all stickies on the board,
    guided by the knowledge shared among domain experts and stakeholders. Finally,
    in domain storytelling, it’s the narrative of the domain experts and stakeholders
    but on a whiteboard, with the teams actively listening, reacting, and asking questions.
  prefs: []
  type: TYPE_NORMAL
- en: They’re all good tools to use. Domain expert interviews are particularly useful
    if it’s difficult to have the domain experts available. Event storming is useful
    if everyone has some knowledge and experience about the domain. It focuses on
    visualizing the flow of events in a timeline from left to right. Domain storytelling
    focuses on capturing domain knowledge with a narrative story. It doesn’t require
    a timeline to be created from left to right and doesn’t require all labels that
    event storming uses to be used.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we delved into two major design approaches in DDD. We covered
    the fundamental concepts of strategic design to get the bigger picture of the
    domain while providing a real-life example. Here, we covered concepts such as
    ubiquitous language, subdomains, bounded contexts, and context mapping.
  prefs: []
  type: TYPE_NORMAL
- en: Afterward, we explored tactical design by using a bounded context from the strategic
    design example. We showcased how to identify aggregates, entities, value objects,
    domain services, repositories, and domain events.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also covered three popular modeling activities in DDD and discussed their
    agendas: the domain expert interview, event storming, and domain storytelling.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should be able to plan and design an architecture with the
    DDD approach, using at least one of the modeling activities outlined.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’re going to deep dive into some of the architectural
    patterns based on DDD, namely **Command and Query Responsibility Segregation**
    (**CQRS**) and **event sourcing**.
  prefs: []
  type: TYPE_NORMAL
