<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer015">&#13;
			<h1 id="_idParaDest-138"><em class="italic"><a id="_idTextAnchor144"/>Chapter 5</em>: Introducing Functional Programming</h1>&#13;
			<p>This chapter will discuss the fundamental principles of <strong class="bold">functional programming</strong> and how they fit into the <strong class="bold">Kotlin</strong> programming language.</p>&#13;
			<p>As you'll discover, we've already touched on some of the concepts in this chapter, as it would have been hard to discuss the benefits of the language up until now without touching on functional programming concepts such as <strong class="bold">data immutability</strong> and <strong class="bold">functions as values</strong>. But as we did before, we'll look at those features from a different angle.</p>&#13;
			<p>In this chapter, we will cover the following topics:</p>&#13;
			<ul>&#13;
				<li>Reasoning behind the functional approach</li>&#13;
				<li>Immutability</li>&#13;
				<li>Functions as values</li>&#13;
				<li>Expressions, not statements</li>&#13;
				<li>Recursion</li>&#13;
			</ul>&#13;
			<p>After completing this chapter, you'll understand how the concepts of functional programming are embedded in the Kotlin language and when to use them.</p>&#13;
			<h1 id="_idParaDest-139"><a id="_idTextAnchor145"/>Technical requirements</h1>&#13;
			<p>For this chapter, you will need to install the following:</p>&#13;
			<ul>&#13;
				<li><strong class="bold">IntelliJ IDEA</strong> <strong class="bold">Community Edition</strong> (<a href="https://www.jetbrains.com/idea/download/">https://www.jetbrains.com/idea/download/</a>)</li>&#13;
				<li><strong class="bold">OpenJDK</strong> <strong class="bold">11</strong> (or higher) (<a href="https://openjdk.java.net/install/">https://openjdk.java.net/install/</a>)</li>&#13;
			</ul>&#13;
			<p>You can find the code files for this chapter on <strong class="bold">GitHub</strong> at <a href="https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter05">https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter05</a>.</p>&#13;
			<h1 id="_idParaDest-140"><a id="_idTextAnchor146"/>Reasoning behind the functional approach</h1>&#13;
			<p><strong class="bold">Functional programming</strong> has <a id="_idIndexMarker393"/>been around for as long as other programming paradigms, for example, procedural and object-oriented programming. But in the past 15 years, it has gained significant momentum. The reason for this is that something else stalled: <strong class="bold">CPU</strong> speeds. We cannot speed up our CPUs as much as we did in the past, so we must <strong class="bold">parallelize</strong> our programs. And it turns out that the functional programming paradigm is exceptionally good at running parallel tasks. </p>&#13;
			<p>The evolution of multicore processors is a fascinating topic in itself, but we'll cover it only briefly here. Workstations have had multiple processors since at least the 1980s to support the running of tasks from different users in parallel. Since workstations were massive during this era, they didn't need to worry about cramming everything into one chip. But when multiprocessors came to the consumer market around 2005, it became necessary to have one physical unit that could work in parallel. This is why we have multiple cores in one chip in our PC or laptop.</p>&#13;
			<p>But that's not the only reason we use functional programming. Here are a few more:</p>&#13;
			<ul>&#13;
				<li>Functional programming favors pure functions, and pure functions are usually easier to reason about and test.</li>&#13;
				<li>Code written in a functional way is often more declarative than imperative, dealing with the <em class="italic">what</em> instead of the <em class="italic">how</em>, and this can be a benefit.</li>&#13;
			</ul>&#13;
			<p>In the following sections, we'll explore the different aspects of functional programming, starting with <em class="italic">immutability</em>.</p>&#13;
			<h1 id="_idParaDest-141"><a id="_idTextAnchor147"/>Immutability</h1>&#13;
			<p>One of<a id="_idIndexMarker394"/> the fundamental<a id="_idIndexMarker395"/> concepts of functional programming is <strong class="bold">immutability</strong>. This means that from the moment the function receives input to the moment the function returns output, the object doesn't change. <em class="italic">But how could it change?</em> Well, let's look at a simple example:</p>&#13;
			<p class="source-code">fun &lt;T&gt; printAndClear(list: MutableList&lt;T&gt;) {</p>&#13;
			<p class="source-code">    for (e in list) {</p>&#13;
			<p class="source-code">        println(e)</p>&#13;
			<p class="source-code">        list.remove(e)</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p class="source-code">printAndClear(mutableListOf("a", "b", "c"))</p>&#13;
			<p>This code would output <strong class="source-inline">a</strong> first, and then we would receive <strong class="source-inline">ConcurrentModificationException</strong>. </p>&#13;
			<p>The reason for this is that the <strong class="source-inline">for-each</strong> loop uses an iterator (which we already discussed in the previous chapter), and by mutating the list inside the loop, we interfere with its <a id="_idIndexMarker396"/>operation. However, this<a id="_idIndexMarker397"/> raises a question:</p>&#13;
			<p><em class="italic">Wouldn't it be great if we could protect ourselves from these runtime exceptions in the first place?</em></p>&#13;
			<p>Let's see how <em class="italic">immutable collections</em> can help us with this. </p>&#13;
			<h2 id="_idParaDest-142"><a id="_idTextAnchor148"/>Immutable collections</h2>&#13;
			<p>In <a href="B17816_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Kotlin</em>, we<a id="_idIndexMarker398"/> already mentioned that collections in Kotlin are <a id="_idIndexMarker399"/>immutable by default, which is unlike many other languages.</p>&#13;
			<p>The previous problem is caused by us not following the <em class="italic">single-responsibility principle</em>, which states that a function should do only one thing and do it well. Our function tries both to remove elements from an array and to print them at the same time.</p>&#13;
			<p>If we change the argument from <strong class="source-inline">MutableList</strong> to <strong class="source-inline">List</strong>, we won't be able to invoke the <strong class="source-inline">remove()</strong> function on it, resolving our current problem. But this raises another question:</p>&#13;
			<p><em class="italic">What if we need an empty list?</em></p>&#13;
			<p>In this case, our function should return a new object:</p>&#13;
			<p class="source-code">private fun &lt;T&gt; printAndClear(list: MutableList&lt;T&gt;): </p>&#13;
			<p class="source-code">  <strong class="bold">MutableList&lt;T&gt;</strong> {</p>&#13;
			<p class="source-code">    for (e in list) {</p>&#13;
			<p class="source-code">        println(e)</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">    return mutableListOf()</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>In general, functions that don't return any values should be avoided in functional programming, as it usually means that they have a side effect.</p>&#13;
			<p>However, it's not enough that the collection <em class="italic">type</em> is immutable. The <em class="italic">content</em> of the collection should be immutable as well. To understand this better, let's look at the following simple class:</p>&#13;
			<p class="source-code">data class Player(var score: Int)</p>&#13;
			<p>You can see that this class has only one variable: <strong class="source-inline">score</strong>. </p>&#13;
			<p>Next, we'll create a single instance of the <strong class="source-inline">data</strong> <strong class="source-inline">class</strong> and put it in an immutable collection:</p>&#13;
			<p class="source-code">val scores = listOf(Player(0))</p>&#13;
			<p>We could<a id="_idIndexMarker400"/> put multiple <a id="_idIndexMarker401"/>instances of this class inside the collection, but to illustrate our point, only one is needed.</p>&#13;
			<p>Next, let's introduce the concept of <em class="italic">threads</em>.</p>&#13;
			<h2 id="_idParaDest-143"><a id="_idTextAnchor149"/>The problem with shared mutable state</h2>&#13;
			<p>If you aren't<a id="_idIndexMarker402"/> familiar with <strong class="bold">threads</strong>, don't<a id="_idIndexMarker403"/> worry, we'll discuss them in detail in <a href="B17816_06_ePub.xhtml#_idTextAnchor164"><em class="italic">Chapter 6</em></a>, <em class="italic">Threads and Coroutines</em>. All you need to know for now is that threads allow the code to run <em class="italic">concurrently</em>. When using concurrent code and code that utilizes multiple CPUs, functional programming really helps. You may find that any other example that doesn't involve concurrency at all may seem rather convoluted or artificial. </p>&#13;
			<p>For now, let's create a list that contains two threads:</p>&#13;
			<p class="source-code">val threads = List(2) {</p>&#13;
			<p class="source-code">        thread {</p>&#13;
			<p class="source-code">            for (i in 1..1000) {</p>&#13;
			<p class="source-code">                scores[0].score++</p>&#13;
			<p class="source-code">            }</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p>As you can see, each thread increments <strong class="source-inline">score</strong> by <strong class="source-inline">1000</strong> in total, using a regular <strong class="source-inline">for </strong>loop.</p>&#13;
			<p>We wait for the threads to complete by using <strong class="source-inline">join()</strong>, and then we check the counter value:</p>&#13;
			<p class="source-code">for (t in threads) {</p>&#13;
			<p class="source-code">    t.join()</p>&#13;
			<p class="source-code">}</p>&#13;
			<p class="source-code">println(scores[0].score) // Less than 2000 for sure</p>&#13;
			<p>If you run the code yourself, the value will be anything under <strong class="source-inline">2000</strong>.</p>&#13;
			<p>This is a <a id="_idIndexMarker404"/>classic case of a <em class="italic">race condition</em> for<a id="_idIndexMarker405"/> mutable variables. The number you'll get will be different every time you run this code. The reason for this may be familiar to you if you have encountered concurrency previously. And, it has nothing to do with threads not completing their work, by the way. You can make sure of this by adding a print message after the loop:</p>&#13;
			<p class="source-code">thread { </p>&#13;
			<p class="source-code">    for (i in 1..1000) { </p>&#13;
			<p class="source-code">        scores[0].score = scores[0].score + 1 </p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">    println("Done")</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>This also isn't the fault of using the increment (<strong class="source-inline">++</strong>) operator. As you can see, we used the long notation to increment the value, but if you run it again as many times as possible, you would still get the wrong results.</p>&#13;
			<p>The reason for this behavior is that the addition operation and the assignment operation are not <em class="italic">atomic</em>. Two threads may override the addition operations of each other, resulting in the number not being incremented enough times.</p>&#13;
			<p>Here, we used an extreme example of a collection that contains exactly one element. In the real world, the collections you will be working with will usually contain multiple elements. For example, you would track scores for multiple players, or even maintain a ranking system for thousands of players simultaneously. This would complicate the example even further. </p>&#13;
			<p>What you need to remember is the following: even if a collection is immutable, it may still <em class="italic">contain</em> mutable <a id="_idIndexMarker406"/>objects<a id="_idIndexMarker407"/> inside. Mutable objects are not thread-safe. </p>&#13;
			<p>Next, let's look at <em class="italic">tuples</em>, which are an example of immutable objects. </p>&#13;
			<h2 id="_idParaDest-144"><a id="_idTextAnchor150"/>Tuples</h2>&#13;
			<p>In functional <a id="_idIndexMarker408"/>programming, a <strong class="bold">tuple</strong> is<a id="_idIndexMarker409"/> a piece of data that cannot be changed after it is created. One of the most basic tuples in Kotlin is <strong class="source-inline">pair</strong>:</p>&#13;
			<p class="source-code">val pair = "a" to 1</p>&#13;
			<p><strong class="source-inline">pair</strong> contains two properties – called <strong class="source-inline">first</strong> and <strong class="source-inline">second</strong> – and is immutable:</p>&#13;
			<p class="source-code">pair.first = "b" // Doesn't work</p>&#13;
			<p class="source-code">pair.second = 2  // Still doesn't</p>&#13;
			<p>We can <em class="italic">destructure</em> <strong class="source-inline">pair</strong> into two separate values using a <em class="italic">destructure declaration</em>:</p>&#13;
			<p class="source-code">val (key, value) = pair</p>&#13;
			<p class="source-code">println("$key =&gt; $value")</p>&#13;
			<p>When iterating over a map, we also work with another type of tuple: <strong class="source-inline">Map.Entry</strong>:</p>&#13;
			<p class="source-code">for (p in mapOf(1 to "Sunday", 2 to "Monday")) {</p>&#13;
			<p class="source-code">   println("${p.key} ${p.value}")</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>This tuple already has <strong class="source-inline">key</strong> and <strong class="source-inline">value</strong> members, instead of <strong class="source-inline">first</strong> and <strong class="source-inline">second</strong>.</p>&#13;
			<p>In addition to <strong class="source-inline">pair</strong>, there is a <strong class="source-inline">Triple</strong> tuple that also contains a <strong class="source-inline">third</strong> value:</p>&#13;
			<p class="source-code">val firstEdition = Triple("Design Patterns with Kotlin",   310, 2018)</p>&#13;
			<p>In general, <strong class="source-inline">data</strong> classes are usually a good implementation for tuples because they provide clear naming. If you look at the preceding example, it's not immediately obvious that the <strong class="source-inline">310</strong> value represents the number of pages. </p>&#13;
			<p>However, as we saw in the previous section, not every <strong class="source-inline">data</strong> class is a proper tuple. You need to make sure that all of its members are <em class="italic">values</em> and not <em class="italic">variables</em>. You also need to check whether any nested collections or classes it has are immutable as well. </p>&#13;
			<p>Now, let's <a id="_idIndexMarker410"/>discuss another important<a id="_idIndexMarker411"/> topic in functional programming: functions as a first-class citizen of the language.</p>&#13;
			<h1 id="_idParaDest-145"><a id="_idTextAnchor151"/>Functions as values</h1>&#13;
			<p>We already<a id="_idIndexMarker412"/> covered some of the functional capabilities of Kotlin in the chapters dedicated to design patterns. The <strong class="bold">Strategy</strong> and <strong class="bold">Command</strong> design<a id="_idIndexMarker413"/> patterns <a id="_idIndexMarker414"/>are only two examples that rely heavily on the ability to accept functions as arguments, return functions, store functions as values, or put functions inside of collections. In this section, we'll cover some other aspects of functional programming in Kotlin, such as <em class="italic">function purity</em> and <em class="italic">currying</em>.</p>&#13;
			<h2 id="_idParaDest-146"><a id="_idTextAnchor152"/>Learning about higher-order functions</h2>&#13;
			<p>As we <a id="_idIndexMarker415"/>discussed previously, in Kotlin, it's possible for a function to return another function. Let's look at the following simple function to understand this syntax in depth:</p>&#13;
			<p class="source-code">fun generateMultiply(): (Int) -&gt; Int {</p>&#13;
			<p class="source-code">    return fun(x: Int): Int {</p>&#13;
			<p class="source-code">        return x * 2</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Here, our <strong class="source-inline">generateMultiply</strong> function returns another function that doesn't have a name. Functions <a id="_idIndexMarker416"/>without a name are called <strong class="bold">anonymous functions</strong>.</p>&#13;
			<p>We could also rewrite the preceding code using shorter syntax:</p>&#13;
			<p class="source-code">fun generateMultiply(): (Int) -&gt; Int {</p>&#13;
			<p class="source-code">    return { x: Int -&gt;</p>&#13;
			<p class="source-code">        x * 2</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">} </p>&#13;
			<p>If a function<a id="_idIndexMarker417"/> without a name uses short syntax, it's <a id="_idIndexMarker418"/>called a <strong class="bold">lambda function</strong>.</p>&#13;
			<p>Next, let's look at the signature of the return type:</p>&#13;
			<p class="source-code">(Int) -&gt; Int</p>&#13;
			<p>From that signature, we know that the function that we return will accept a single integer as input and produce an integer as output. </p>&#13;
			<p>If a function doesn't accept any arguments, we denote that using empty round brackets:</p>&#13;
			<p class="source-code">() -&gt; Int</p>&#13;
			<p>If a function doesn't return anything, we use the <strong class="source-inline">Unit</strong> type to specify that:</p>&#13;
			<p class="source-code">(Int) -&gt; Unit</p>&#13;
			<p>Functions in Kotlin can be assigned to a variable or value to be invoked later on:</p>&#13;
			<p class="source-code">val multiplyFunction = generateMultiply()</p>&#13;
			<p class="source-code">...</p>&#13;
			<p class="source-code">println(multiplyFunction(3, 4))</p>&#13;
			<p>The function assigned to a variable is<a id="_idIndexMarker419"/> usually called a <strong class="bold">literal function</strong>. </p>&#13;
			<p>We applied this in <a href="B17816_04_ePub.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">Getting Familiar with Behavioral Patterns</em>, when discussing the Strategy design pattern. </p>&#13;
			<p>It's also possible to specify a function as a parameter:</p>&#13;
			<p class="source-code">fun mathInvoker(x: Int, y: Int, mathFunction: (Int, Int) -&gt;   Int) {</p>&#13;
			<p class="source-code">    println(mathFunction(x, y))</p>&#13;
			<p class="source-code">}</p>&#13;
			<p class="source-code">mathInvoker(5, 6, multiplyFunction)</p>&#13;
			<p>If a function<a id="_idIndexMarker420"/> is the last parameter, it can also be supplied in an ad hoc fashion, outside of the brackets:</p>&#13;
			<p class="source-code">mathInvoker(7, 8) { x, y -&gt;</p>&#13;
			<p class="source-code">   x * y</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>This syntax is<a id="_idIndexMarker421"/> also<a id="_idIndexMarker422"/> called <strong class="bold">trailing lambda</strong> or <strong class="bold">call suffix</strong>. We saw an example of this in <a href="B17816_04_ePub.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">Getting Familiar with Behavioral Patterns</em>, when discussing the Interpreter design pattern. </p>&#13;
			<p>Now that we've covered the basic syntax of functions, let's see how they can be used.</p>&#13;
			<h2 id="_idParaDest-147"><a id="_idTextAnchor153"/>Higher-order functions in a standard library</h2>&#13;
			<p>When <a id="_idIndexMarker423"/>working with Kotlin, something you will be doing on a daily basis is working with <em class="italic">collections</em>. As we mentioned briefly in <a href="B17816_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Kotlin</em>, collections have support for higher-order functions.</p>&#13;
			<p>For example, in the previous chapters, to print elements of a collection one by one, we used a boring <strong class="source-inline">for-each</strong> loop:</p>&#13;
			<p class="source-code">val dwarfs = listOf("Dwalin", "Balin", "Kili", "Fili",   "Dori", "Nori", "Ori", "Oin", "Gloin", "Bifur", "Bofur",   "Bombur", "Thorin")</p>&#13;
			<p class="source-code">for (d in dwarfs) {</p>&#13;
			<p class="source-code">    println(d)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Many of you probably groaned at seeing this. But I hope you didn't stop reading the book altogether. Of course, there is also another way to achieve the same goal that is common in many programming languages: a <strong class="source-inline">forEach</strong> function:</p>&#13;
			<p class="source-code">dwarfs.forEach { d -&gt; </p>&#13;
			<p class="source-code">    println(d)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>This function is one of the most basic examples of a higher-order function. Let's see how it's declared:</p>&#13;
			<p class="source-code">fun &lt;T&gt; Iterable&lt;T&gt;.forEach(action: (T) -&gt; Unit)</p>&#13;
			<p>Here, <strong class="source-inline">action</strong> is a <a id="_idIndexMarker424"/>function that receives an element of a collection and doesn't return anything. This function presents an opportunity to discuss another aspect of Kotlin: the <strong class="source-inline">it</strong> notation. </p>&#13;
			<h1 id="_idParaDest-148"><a id="_idTextAnchor154"/>The it notation</h1>&#13;
			<p>It is very common<a id="_idIndexMarker425"/> in functional programming to keep your functions small and simple. The simpler the function, the easier it is to understand, and the more chances it has to be reused in other places. And the aim <em class="italic">of reusing</em> code is one of the basic Kotlin principles.</p>&#13;
			<p>Notice that in the preceding example, we didn't specify the type of the <strong class="source-inline">d</strong> variable. We could do this using the same colon notation we have used elsewhere:</p>&#13;
			<p class="source-code">dwarfs.forEach { d: String -&gt;  </p>&#13;
			<p class="source-code">    println(d) </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>However, usually, we don't need to do this because the compiler can figure this out from the generic types that we use. After all, <strong class="source-inline">dwarfs</strong> is of the <strong class="source-inline">List&lt;String&gt;</strong> type, so <strong class="source-inline">d</strong> is of the <strong class="source-inline">String</strong> type as well.</p>&#13;
			<p>The type of the argument is not the only part that we can omit when writing short lambdas like this one. If a lambda takes a single argument, we can use the implicit name for it, which in this case, is <strong class="source-inline">it</strong>:</p>&#13;
			<p class="source-code">dwarfs.forEach {</p>&#13;
			<p class="source-code">    println(it)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>In cases where we need to invoke a single function to a single parameter, we could also use a <em class="italic">function reference</em>. We saw an example of this in <a href="B17816_04_ePub.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">Getting Familiar with Behavioral Patterns</em>, when discussing the Strategy design pattern:</p>&#13;
			<p class="source-code">dwarfs.forEach(::println)</p>&#13;
			<p>We'll use the <a id="_idIndexMarker426"/>shortest notation in most of the following examples. It is advised to use the longer syntax for cases such as <em class="italic">one lambda nested in another</em>. In those cases, giving proper names for the parameters is more important than conciseness.</p>&#13;
			<h2 id="_idParaDest-149"><a id="_idTextAnchor155"/>Closures</h2>&#13;
			<p>In the object-oriented<a id="_idIndexMarker427"/> paradigm, state is always stored within objects. But in functional programming, this isn't necessarily the case. Let's look at the following function as an example:</p>&#13;
			<p class="source-code">fun counter(): () -&gt; Int {</p>&#13;
			<p class="source-code">    var i = 0</p>&#13;
			<p class="source-code">    return { i++ }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>The preceding example is clearly a higher-order function, as you can see by its <strong class="source-inline">return</strong> type. It returns a function with zero arguments that produces an integer. </p>&#13;
			<p>Let's store it in a variable, in the way we've already learned, and invoke it multiple times:</p>&#13;
			<p class="source-code">val next = counter()</p>&#13;
			<p class="source-code">println(next())</p>&#13;
			<p class="source-code">println(next())</p>&#13;
			<p class="source-code">println(next())</p>&#13;
			<p>As you can see, the function is able to keep a state, in this case, the value of a counter, even though it is not part of an object.</p>&#13;
			<p>This is called<a id="_idIndexMarker428"/> a <strong class="bold">closure</strong>. The lambda has access to all of the local variables of the function that wraps it, and those local variables persist, as long as the reference to the lambda is kept.</p>&#13;
			<p>The use of<a id="_idIndexMarker429"/> closures is another tool in the functional programming toolbox that reduces the need to define lots of classes that simply wrap a single function with some state.</p>&#13;
			<h2 id="_idParaDest-150"><a id="_idTextAnchor156"/>Pure functions</h2>&#13;
			<p>A <strong class="bold">pure function</strong> is a<a id="_idIndexMarker430"/> function without any<a id="_idIndexMarker431"/> side effects. A <strong class="bold">side effect</strong> can be considered anything that accesses or changes the external state. The external state can be a non-local variable (where a variable from a closure is still considered to be non-local) or any kind of IO (that is, reading or writing to a file or using any kind of network capabilities). </p>&#13;
			<p class="callout-heading">Important Note:</p>&#13;
			<p class="callout">For those not familiar with the term, <strong class="bold">IO</strong> stands for <strong class="bold">Input/Output</strong>, and this covers any kind of interaction that is external to our program, such as writing to files or reading from a network.</p>&#13;
			<p>For example, the lambda we just discussed in the <em class="italic">Closures</em> section is not considered <em class="italic">pure</em> because it can return different output for the same input when it is invoked multiple times. </p>&#13;
			<p><strong class="bold">Impure functions</strong> are hard to <a id="_idIndexMarker432"/>test and to reason about in general, as the result they return may depend on the order of execution or on factors that we can't control (such as network issues). </p>&#13;
			<p>One thing to remember is that logging or even printing to a console still involves IO and is subject to the same set of problems. </p>&#13;
			<p>Let's look at the following simple function:</p>&#13;
			<p class="source-code">fun sayHello() = println("Hello")</p>&#13;
			<p><em class="italic">So, in this case, how do you ensure that Hello is printed?</em> The task is not as simple as it seems, as we'll need some way to capture the standard output – that is, the same console where we usually see stuff printed. </p>&#13;
			<p>We'll <a id="_idIndexMarker433"/>compare <a id="_idIndexMarker434"/>it to the following function:</p>&#13;
			<p class="source-code">fun hello() = "Hello"</p>&#13;
			<p>The following function doesn't have any side effects. That makes it a lot easier to test:</p>&#13;
			<p class="source-code">fun testHello(): Boolean {</p>&#13;
			<p class="source-code">    return "Hello" == hello()</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>The <strong class="source-inline">hello()</strong> function may look a bit meaningless, but that's actually one of the properties of pure functions. Their invocation could be replaced by their result if we knew it ahead of time. This is often<a id="_idIndexMarker435"/> called <strong class="bold">referential transparency</strong>.</p>&#13;
			<p>As we mentioned earlier, not every function written in Kotlin is a pure function:</p>&#13;
			<p class="source-code">fun &lt;T&gt; removeFirst(list: MutableList&lt;T&gt;): T {</p>&#13;
			<p class="source-code">    return list.removeAt(0)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>If we call the function twice on the same list, it will return different results:</p>&#13;
			<p class="source-code">val list = mutableListOf(1, 2, 3)</p>&#13;
			<p class="source-code">println(removeFirst(list)) // Prints 1</p>&#13;
			<p class="source-code">println(removeFirst(list)) // Prints 2</p>&#13;
			<p>Compare the preceding function to this one:</p>&#13;
			<p class="source-code">fun &lt;T&gt; withoutFirst(list: List&lt;T&gt;): T {</p>&#13;
			<p class="source-code">    return ArrayList(list).removeAt(0)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Now, our function is totally predictable, no matter how many times we invoke it:</p>&#13;
			<p class="source-code">val list = mutableListOf(1, 2, 3)</p>&#13;
			<p class="source-code">println(withoutFirst(list)) // It's 1</p>&#13;
			<p class="source-code">println(withoutFirst(list)) // Still 1</p>&#13;
			<p>As you can see, in this instance, we used an immutable interface, <strong class="source-inline">List&lt;T&gt;</strong>, which helps us by preventing the possibility of mutating our input. When combined with the immutable values we discussed in the previous section, pure functions allow easier testing by <a id="_idIndexMarker436"/>providing predictable results and the<a id="_idIndexMarker437"/> parallelization of our algorithms.</p>&#13;
			<p>A system that utilizes pure functions is easier to reason about because it doesn't rely on any external factors – what you see is what you get.</p>&#13;
			<h2 id="_idParaDest-151"><a id="_idTextAnchor157"/>Currying</h2>&#13;
			<p><strong class="bold">Currying</strong> is a<a id="_idIndexMarker438"/> way <a id="_idIndexMarker439"/>to translate a function that takes a number of arguments into a chain of functions, where each function takes a single argument. This may sound confusing, so let's look at a simple example:</p>&#13;
			<p class="source-code">fun subtract(x: Int, y: Int): Int {</p>&#13;
			<p class="source-code">    return x - y</p>&#13;
			<p class="source-code">}</p>&#13;
			<p class="source-code">println(subtract(50, 8))</p>&#13;
			<p>This is a function that takes two arguments as an input and returns the difference between them. However, some languages allow us to invoke this function with the following syntax:</p>&#13;
			<p class="source-code">subtract(50)(8)</p>&#13;
			<p>This is what currying looks like. Currying allows us to take a function with multiple arguments (in our case, two) and convert this function into a set of functions, where each one takes only a single argument. </p>&#13;
			<p>Let's examine how this can be achieved in Kotlin. We've already seen how we can return a function from another function:</p>&#13;
			<p class="source-code">fun subtract(x: Int): (Int) -&gt; Int {</p>&#13;
			<p class="source-code">    return fun(y: Int): Int {</p>&#13;
			<p class="source-code">        return x - y</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Here is <a id="_idIndexMarker440"/>the<a id="_idIndexMarker441"/> shorter form of the preceding code:</p>&#13;
			<p class="source-code">fun subtract(x: Int) = fun(y: Int): Int {</p>&#13;
			<p class="source-code">    return x - y</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>In the preceding example, we use single-expression syntax to return an anonymous function without the need to declare the <strong class="source-inline">return</strong> type or use the <strong class="source-inline">return</strong> keyword.</p>&#13;
			<p>And here it is in an even shorter form:</p>&#13;
			<p class="source-code">fun subtract(x: Int) = {y: Int -&gt; x - y}</p>&#13;
			<p>Now, an anonymous function is translated to a lambda, with the <strong class="source-inline">return</strong> type of the lambda inferred as well.</p>&#13;
			<p>Although not very useful by itself, it's still an interesting concept to grasp. And if you're a <strong class="bold">JavaScript</strong> developer looking for a new job, make sure you understand it fully, since it's asked about in nearly every interview.</p>&#13;
			<p>One real-world scenario where you might want to use currying is <em class="italic">logging</em>. A <strong class="source-inline">log</strong> function usually looks something like this:</p>&#13;
			<p class="source-code">enum class LogLevel {</p>&#13;
			<p class="source-code">    ERROR, WARNING, INFO</p>&#13;
			<p class="source-code">}</p>&#13;
			<p class="source-code">fun log(level: LogLevel, message: String) =     println("$level: $message")</p>&#13;
			<p>We could fix the log level by storing the function in a variable:</p>&#13;
			<p class="source-code">val errorLog = fun(message: String) {</p>&#13;
			<p class="source-code">    log(LogLevel.ERROR, message)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Notice that<a id="_idIndexMarker442"/> the <strong class="source-inline">errorLog</strong> function is easier to use<a id="_idIndexMarker443"/> than the regular <strong class="source-inline">log</strong> function because it accepts one argument instead of two. However, this raises a question:</p>&#13;
			<p><em class="italic">What if we don't want to create all of the possible loggers ahead of time?</em></p>&#13;
			<p>In this case, we can use currying. The <em class="italic">curried</em> version of this code would look like this:</p>&#13;
			<p class="source-code">fun createLogger(level: LogLevel): (String) -&gt; Unit {</p>&#13;
			<p class="source-code">    return { message: String -&gt;</p>&#13;
			<p class="source-code">        log(level, message)</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Now, it's up to whoever uses our code to create the logger they want:</p>&#13;
			<p class="source-code">val infoLogger = createLogger(LogLevel.INFO)</p>&#13;
			<p class="source-code">infoLogger("Log something")</p>&#13;
			<p>This, in fact, is very similar to the Factory design pattern we covered in <a href="B17816_02_ePub.xhtml#_idTextAnchor062"><em class="italic">Chapter 2</em></a>, <em class="italic">Working with Creational Patterns</em>. Again, the power of a modern language decreases the number of custom classes we need to implement to achieve the same behavior. </p>&#13;
			<p>Next, let's talk about another powerful technique that can save us from having to do the same <a id="_idIndexMarker444"/>computation<a id="_idIndexMarker445"/> over and over again. </p>&#13;
			<h2 id="_idParaDest-152"><a id="_idTextAnchor158"/>Memoization</h2>&#13;
			<p>If our function<a id="_idIndexMarker446"/> always returns the same <a id="_idIndexMarker447"/>output for the same input, we can easily map its input to the output, caching the results in the process. This technique is called <strong class="bold">memoization</strong>.</p>&#13;
			<p>A common task when developing different types of systems or solving problems is finding a way to avoid repeating the same computation multiple times. Let's assume we receive multiple lists of integers, and for each list, we would like to print its sum:</p>&#13;
			<p class="source-code">val input = listOf(</p>&#13;
			<p class="source-code">    setOf(1, 2, 3),</p>&#13;
			<p class="source-code">    setOf(3, 1, 2),</p>&#13;
			<p class="source-code">    setOf(2, 3, 1),</p>&#13;
			<p class="source-code">    setOf(4, 5, 6)</p>&#13;
			<p class="source-code">)</p>&#13;
			<p>Looking at the input, you can see that the first three sets are in fact equal – the difference is only in the order of the elements, so calculating the sum three times would be wasteful. </p>&#13;
			<p>The sum calculation can be easily described as a pure function:</p>&#13;
			<p class="source-code">fun sum(numbers: Set&lt;Int&gt;): Double {</p>&#13;
			<p class="source-code">    return numbers.sumByDouble { it.toDouble() }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>This function does not depend on any external state and doesn't change the external state in any way. So, it is safe for the same input to replace the call to this function with the value it had returned previously. </p>&#13;
			<p>We could store the results of a previous computation for the same set in a mutable map:</p>&#13;
			<p class="source-code">val resultsCache = mutableMapOf&lt;Set&lt;Int&gt;, Double&gt;()</p>&#13;
			<p>To avoid creating too many classes, we could use a higher-order function that would wrap the result in the cache that we created earlier:</p>&#13;
			<p class="source-code">fun summarizer(): (Set&lt;Int&gt;) -&gt; Double {</p>&#13;
			<p class="source-code">    val resultsCache = mutableMapOf&lt;Set&lt;Int&gt;, Double&gt;()</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">    return { numbers: Set&lt;Int&gt; -&gt;</p>&#13;
			<p class="source-code">        resultsCache.computeIfAbsent(numbers, ::sum)</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Here, we <a id="_idIndexMarker448"/>use <a id="_idIndexMarker449"/>a method reference operator (<strong class="source-inline">::</strong>) to tell <strong class="source-inline">computeIfAbsent</strong> to use the <strong class="source-inline">sum()</strong> method in the event where the input hasn't been cached yet. </p>&#13;
			<p>Note that <strong class="source-inline">sum()</strong> is a pure function, while <strong class="source-inline">summarize()</strong> is not. The latter will behave differently for the same input. But that's exactly what we want in this case.</p>&#13;
			<p>Running the following code on the preceding input will invoke the sum function only twice:</p>&#13;
			<p class="source-code">val summarizer = summarizer()</p>&#13;
			<p class="source-code">input.forEach {</p>&#13;
			<p class="source-code">    println(summarizer(it))</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>The combination of immutable objects, pure functions, and closures provides us with a powerful tool for performance optimization. Just remember: nothing is free. We trade one resource, CPU time, for another resource, which is memory. And it's up to you to decide which resource is more expensive in each case.</p>&#13;
			<h1 id="_idParaDest-153"><a id="_idTextAnchor159"/>Using expressions instead of statements</h1>&#13;
			<p>A <strong class="bold">statement</strong> is a block of <a id="_idIndexMarker450"/>code that <em class="italic">doesn't return</em> anything. An <strong class="bold">expression</strong>, on the other hand, <em class="italic">returns a new value</em>. Since statements produce no results, the only way for them to be useful is to mutate the state, whether that's changing a variable, changing a data structure, or performing some kind of IO.</p>&#13;
			<p>Functional programming tries to avoid mutating the state as much as possible. Theoretically, the more we rely on expressions, the more our functions will be pure, with all the benefits of functional purity.</p>&#13;
			<p>We've used the <strong class="source-inline">if</strong> expression many times already, so one of its benefits should be clear: it's less verbose and, for that reason, less error-prone than the <strong class="source-inline">if</strong> statement from other languages.</p>&#13;
			<h2 id="_idParaDest-154"><a id="_idTextAnchor160"/>Pattern matching</h2>&#13;
			<p>The<a id="_idIndexMarker451"/> concept <a id="_idIndexMarker452"/>of <strong class="bold">pattern matching</strong> will seem like <strong class="source-inline">switch</strong>/<strong class="source-inline">case</strong> on steroids. We've already seen how the <strong class="source-inline">when</strong> expression can be used, which we explored in <a href="B17816_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Kotlin</em>, so let's briefly discuss why this concept is important for the functional paradigm.</p>&#13;
			<p>You may know that in Java, <strong class="source-inline">switch</strong> accepts only some primitive types, strings, or enums.</p>&#13;
			<p>Consider the following code, which is usually used to demonstrate how polymorphism is implemented in the language:</p>&#13;
			<p class="source-code">class Cat : Animal {</p>&#13;
			<p class="source-code">    fun purr(): String {</p>&#13;
			<p class="source-code">        return "Purr-purr";</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p class="source-code">class Dog : Animal {</p>&#13;
			<p class="source-code">    fun bark(): String {</p>&#13;
			<p class="source-code">        return "Bark-bark";</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p class="source-code">interface Animal</p>&#13;
			<p>If we were<a id="_idIndexMarker453"/> to <a id="_idIndexMarker454"/>decide which of the functions to call, we would need to write code akin to the following:</p>&#13;
			<p class="source-code">fun getSound(animal: Animal): String {</p>&#13;
			<p class="source-code">    var sound: String? = null;</p>&#13;
			<p class="source-code">    if (animal is Cat) {</p>&#13;
			<p class="source-code">        sound = (animal as Cat).purr();</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">    else if (animal is Dog) {</p>&#13;
			<p class="source-code">        sound = (animal as Dog).bark();</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">    if (sound == null) {</p>&#13;
			<p class="source-code">        throw RuntimeException();</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">    return sound;</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>This code attempts to figure out at runtime what methods the <strong class="source-inline">getSound</strong> class implements.</p>&#13;
			<p>This method could be shortened by introducing multiple returns, but in real projects, multiple returns are usually a bad practice. </p>&#13;
			<p>Since we don't have a <strong class="source-inline">switch</strong> statement for classes, we need to use an <strong class="source-inline">if</strong> statement instead. </p>&#13;
			<p>Now, let's compare the preceding code with the following Kotlin code:</p>&#13;
			<p class="source-code">fun getSound(animal: Animal) = when(animal) {</p>&#13;
			<p class="source-code">    is Cat -&gt; animal.purr()</p>&#13;
			<p class="source-code">    is Dog -&gt; animal.bark()</p>&#13;
			<p class="source-code">    else -&gt; throw RuntimeException("Unknown animal")</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Since <strong class="source-inline">when</strong> is an expression, we avoided declaring the intermediate variable we previously had altogether. In addition, the code that uses pattern matching doesn't need any type checks and casts.</p>&#13;
			<p>Now we've learned<a id="_idIndexMarker455"/> how<a id="_idIndexMarker456"/> to replace imperative <strong class="source-inline">if</strong> statements with much more functional <strong class="source-inline">when</strong> expressions, let's see how we can replace imperative loops in our code by using <em class="italic">recursion</em>.</p>&#13;
			<h1 id="_idParaDest-155"><a id="_idTextAnchor161"/>Recursion</h1>&#13;
			<p><strong class="bold">Recursion</strong> is a <a id="_idIndexMarker457"/>function<a id="_idIndexMarker458"/> invoking itself with new arguments. Many well-known algorithms, such as <strong class="bold">Depth First Search</strong>, rely on <a id="_idIndexMarker459"/>recursion.</p>&#13;
			<p>Here is an example of a very inefficient function that uses recursion to calculate the sum of all the numbers in a given list:</p>&#13;
			<p class="source-code">fun sumRec(i: Int, sum: Long, numbers: List&lt;Int&gt;): Long {</p>&#13;
			<p class="source-code">    return if (i == numbers.size) {</p>&#13;
			<p class="source-code">        return sum</p>&#13;
			<p class="source-code">    } else {</p>&#13;
			<p class="source-code">        sumRec(i+1, numbers[i] + sum, numbers)</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>We often try to avoid recursion due to the stack overflow errors that we may receive if our call stack is too deep. You can call this function with a list that contains a million numbers to demonstrate this:</p>&#13;
			<p class="source-code">val numbers = List(1_000_000) {it}</p>&#13;
			<p class="source-code">println(sumRec(0,  numbers)) </p>&#13;
			<p class="source-code">// Crashed pretty soon, around 7K</p>&#13;
			<p>However, Kotlin supports an <a id="_idIndexMarker460"/>optimization called <strong class="bold">tail recursion</strong>. One of the great benefits of tail recursion is that it avoids the dreaded stack overflow exception. If there is only a <a id="_idIndexMarker461"/>single<a id="_idIndexMarker462"/> recursive call in our function, we can use that optimization.</p>&#13;
			<p>Let's rewrite our recursive function using a new keyword, <strong class="source-inline">tailrec</strong>, to avoid this problem:</p>&#13;
			<p class="source-code">tailrec fun sumRec(i: Int, sum: Long, numbers: List&lt;Int&gt;): </p>&#13;
			<p class="source-code">  Long {</p>&#13;
			<p class="source-code">    return if (i == numbers.size) {</p>&#13;
			<p class="source-code">        return sum</p>&#13;
			<p class="source-code">    } else {</p>&#13;
			<p class="source-code">        sumRec(i+1, numbers[i] + sum, numbers)</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Now, the compiler will optimize our call and avoid the exception completely. </p>&#13;
			<p>However, this <a id="_idIndexMarker463"/>optimization doesn't work if you have multiple recursive calls, such as in the <strong class="bold">Merge Sort</strong> algorithm. </p>&#13;
			<p>Let's examine the following function, which is the <em class="italic">sort</em> part of the Merge Sort algorithm:</p>&#13;
			<p class="source-code">tailrec fun mergeSort(numbers: List&lt;Int&gt;): List&lt;Int&gt; {</p>&#13;
			<p class="source-code">    return when {</p>&#13;
			<p class="source-code">        numbers.size &lt;= 1 -&gt; numbers</p>&#13;
			<p class="source-code">        numbers.size == 2 -&gt; {</p>&#13;
			<p class="source-code">            return if (numbers[0] &lt; numbers[1]) {</p>&#13;
			<p class="source-code">                numbers</p>&#13;
			<p class="source-code">            } else {</p>&#13;
			<p class="source-code">                listOf(numbers[1], numbers[0])</p>&#13;
			<p class="source-code">            }</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">        else -&gt; {</p>&#13;
			<p class="source-code"><strong class="bold">            val left = mergeSort(numbers.slice               (0..numbers.size / 2))</strong></p>&#13;
			<p class="source-code"><strong class="bold">            val right = mergeSort(numbers.slice               (numbers.size / 2 + 1 until numbers.size))</strong></p>&#13;
			<p class="source-code">            return merge(left, right)</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">} </p>&#13;
			<p>Notice that there <a id="_idIndexMarker464"/>are <a id="_idIndexMarker465"/>two recursive calls instead of one. The Kotlin compiler will then issue the following warning:</p>&#13;
			<p class="source-code">&gt; "A function is marked as tail-recursive but no tail calls are found"</p>&#13;
			<h1 id="_idParaDest-156"><a id="_idTextAnchor162"/>Summary</h1>&#13;
			<p>You should now have a better understanding of functional programming and its benefits, as well as how Kotlin approaches this topic. We've discussed the concepts of <em class="italic">immutability</em> and <em class="italic">pure functions</em>, and how combining these results in more testable code that is easier to maintain. </p>&#13;
			<p>We discussed how Kotlin supports <em class="italic">closures</em>, which allow a function to access the variables of the function that wraps it and effectively store the state between executions. This enables techniques such as <em class="italic">currying</em> and <em class="italic">memoization</em> that allow us to fix some of the function arguments (by acting as defaults) and remember the value returned from a function in order to avoid recalculating it. </p>&#13;
			<p>We learned that Kotlin uses the <strong class="source-inline">tailrec</strong> keyword to allow the compiler to optimize <em class="italic">tail recursion</em>. We also looked at <em class="italic">higher-order functions</em>, <em class="italic">expressions versus statements</em>, and <em class="italic">pattern matching</em>. All of these concepts allow us to write code that is easier to test and has less risk of concurrency bugs. </p>&#13;
			<p>In the next chapter, we'll put this knowledge to practical use and discover how <strong class="bold">reactive programming</strong> builds upon functional programming to create scalable and resilient systems.</p>&#13;
			<h1 id="_idParaDest-157"><a id="_idTextAnchor163"/>Questions </h1>&#13;
			<ol>&#13;
				<li>What are higher-order functions? </li>&#13;
				<li>What is the <strong class="source-inline">tailrec</strong> keyword in Kotlin? </li>&#13;
				<li>What are pure functions? </li>&#13;
			</ol>&#13;
		</div>&#13;
	</div></body></html>