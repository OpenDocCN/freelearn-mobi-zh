<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-138"><em class="italic"><a id="_idTextAnchor144"/>Chapter 5</em>: Introducing Functional Programming</h1>&#13;
			<p>This chapter will discuss the fundamental principles of <strong class="bold">functional programming</strong> and how they fit into the <strong class="bold">Kotlin</strong> programming language.</p>&#13;
			<p>As you'll discover, we've already touched on some of the concepts in this chapter, as it would have been hard to discuss the benefits of the language up until now without touching on functional programming concepts such as <strong class="bold">data immutability</strong> and <strong class="bold">functions as values</strong>. But as we did before, we'll look at those features from a different angle.</p>&#13;
			<p>In this chapter, we will cover the following topics:</p>&#13;
			<ul>&#13;
				<li>Reasoning behind the functional approach</li>&#13;
				<li>Immutability</li>&#13;
				<li>Functions as values</li>&#13;
				<li>Expressions, not statements</li>&#13;
				<li>Recursion</li>&#13;
			</ul>&#13;
			<p>After completing this chapter, you'll understand how the concepts of functional programming are embedded in the Kotlin language and when to use them.</p>&#13;
			<h1 id="_idParaDest-139"><a id="_idTextAnchor145"/>Technical requirements</h1>&#13;
			<p>For this chapter, you will need to install the following:</p>&#13;
			<ul>&#13;
				<li><strong class="bold">IntelliJ IDEA</strong> <strong class="bold">Community Edition</strong> (<a href="https://www.jetbrains.com/idea/download/">https://www.jetbrains.com/idea/download/</a>)</li>&#13;
				<li><strong class="bold">OpenJDK</strong> <strong class="bold">11</strong> (or higher) (<a href="https://openjdk.java.net/install/">https://openjdk.java.net/install/</a>)</li>&#13;
			</ul>&#13;
			<p>You can find the code files for this chapter on <strong class="bold">GitHub</strong> at <a href="https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter05">https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter05</a>.</p>&#13;
			<h1 id="_idParaDest-140"><a id="_idTextAnchor146"/>Reasoning behind the functional approach</h1>&#13;
			<p><strong class="bold">Functional programming</strong> has <a id="_idIndexMarker393"/>been around for as long as other programming paradigms, for example, procedural and object-oriented programming. But in the past 15 years, it has gained significant momentum. The reason for this is that something else stalled: <strong class="bold">CPU</strong> speeds. We cannot speed up our CPUs as much as we did in the past, so we must <strong class="bold">parallelize</strong> our programs. And it turns out that the functional programming paradigm is exceptionally good at running parallel tasks. </p>&#13;
			<p>The evolution of multicore processors is a fascinating topic in itself, but we'll cover it only briefly here. Workstations have had multiple processors since at least the 1980s to support the running of tasks from different users in parallel. Since workstations were massive during this era, they didn't need to worry about cramming everything into one chip. But when multiprocessors came to the consumer market around 2005, it became necessary to have one physical unit that could work in parallel. This is why we have multiple cores in one chip in our PC or laptop.</p>&#13;
			<p>But that's not the only reason we use functional programming. Here are a few more:</p>&#13;
			<ul>&#13;
				<li>Functional programming favors pure functions, and pure functions are usually easier to reason about and test.</li>&#13;
				<li>Code written in a functional way is often more declarative than imperative, dealing with the <em class="italic">what</em> instead of the <em class="italic">how</em>, and this can be a benefit.</li>&#13;
			</ul>&#13;
			<p>In the following sections, we'll explore the different aspects of functional programming, starting with <em class="italic">immutability</em>.</p>&#13;
			<h1 id="_idParaDest-141"><a id="_idTextAnchor147"/>Immutability</h1>&#13;
			<p>One of<a id="_idIndexMarker394"/> the fundamental<a id="_idIndexMarker395"/> concepts of functional programming is <strong class="bold">immutability</strong>. This means that from the moment the function receives input to the moment the function returns output, the object doesn't change. <em class="italic">But how could it change?</em> Well, let's look at a simple example:</p>&#13;
			<pre>fun &lt;T&gt; printAndClear(list: MutableList&lt;T&gt;) {</pre>&#13;
			<pre>    for (e in list) {</pre>&#13;
			<pre>        println(e)</pre>&#13;
			<pre>        list.remove(e)</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<pre>printAndClear(mutableListOf("a", "b", "c"))</pre>&#13;
			<p>This code would output <code>a</code> first, and then we would receive <code>ConcurrentModificationException</code>. </p>&#13;
			<p>The reason for this is that the <code>for-each</code> loop uses an iterator (which we already discussed in the previous chapter), and by mutating the list inside the loop, we interfere with its <a id="_idIndexMarker396"/>operation. However, this<a id="_idIndexMarker397"/> raises a question:</p>&#13;
			<p><em class="italic">Wouldn't it be great if we could protect ourselves from these runtime exceptions in the first place?</em></p>&#13;
			<p>Let's see how <em class="italic">immutable collections</em> can help us with this. </p>&#13;
			<h2 id="_idParaDest-142"><a id="_idTextAnchor148"/>Immutable collections</h2>&#13;
			<p>In <a href="B17816_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Kotlin</em>, we<a id="_idIndexMarker398"/> already mentioned that collections in Kotlin are <a id="_idIndexMarker399"/>immutable by default, which is unlike many other languages.</p>&#13;
			<p>The previous problem is caused by us not following the <em class="italic">single-responsibility principle</em>, which states that a function should do only one thing and do it well. Our function tries both to remove elements from an array and to print them at the same time.</p>&#13;
			<p>If we change the argument from <code>MutableList</code> to <code>List</code>, we won't be able to invoke the <code>remove()</code> function on it, resolving our current problem. But this raises another question:</p>&#13;
			<p><em class="italic">What if we need an empty list?</em></p>&#13;
			<p>In this case, our function should return a new object:</p>&#13;
			<pre>private fun &lt;T&gt; printAndClear(list: MutableList&lt;T&gt;): </pre>&#13;
			<pre>  <strong class="bold">MutableList&lt;T&gt;</strong> {</pre>&#13;
			<pre>    for (e in list) {</pre>&#13;
			<pre>        println(e)</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>    return mutableListOf()</pre>&#13;
			<pre>}</pre>&#13;
			<p>In general, functions that don't return any values should be avoided in functional programming, as it usually means that they have a side effect.</p>&#13;
			<p>However, it's not enough that the collection <em class="italic">type</em> is immutable. The <em class="italic">content</em> of the collection should be immutable as well. To understand this better, let's look at the following simple class:</p>&#13;
			<pre>data class Player(var score: Int)</pre>&#13;
			<p>You can see that this class has only one variable: <code>score</code>. </p>&#13;
			<p>Next, we'll create a single instance of the <code>data</code> <code>class</code> and put it in an immutable collection:</p>&#13;
			<pre>val scores = listOf(Player(0))</pre>&#13;
			<p>We could<a id="_idIndexMarker400"/> put multiple <a id="_idIndexMarker401"/>instances of this class inside the collection, but to illustrate our point, only one is needed.</p>&#13;
			<p>Next, let's introduce the concept of <em class="italic">threads</em>.</p>&#13;
			<h2 id="_idParaDest-143"><a id="_idTextAnchor149"/>The problem with shared mutable state</h2>&#13;
			<p>If you aren't<a id="_idIndexMarker402"/> familiar with <strong class="bold">threads</strong>, don't<a id="_idIndexMarker403"/> worry, we'll discuss them in detail in <a href="B17816_06_ePub.xhtml#_idTextAnchor164"><em class="italic">Chapter 6</em></a>, <em class="italic">Threads and Coroutines</em>. All you need to know for now is that threads allow the code to run <em class="italic">concurrently</em>. When using concurrent code and code that utilizes multiple CPUs, functional programming really helps. You may find that any other example that doesn't involve concurrency at all may seem rather convoluted or artificial. </p>&#13;
			<p>For now, let's create a list that contains two threads:</p>&#13;
			<pre>val threads = List(2) {</pre>&#13;
			<pre>        thread {</pre>&#13;
			<pre>            for (i in 1..1000) {</pre>&#13;
			<pre>                scores[0].score++</pre>&#13;
			<pre>            }</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>    }</pre>&#13;
			<p>As you can see, each thread increments <code>score</code> by <code>1000</code> in total, using a regular <code>for </code>loop.</p>&#13;
			<p>We wait for the threads to complete by using <code>join()</code>, and then we check the counter value:</p>&#13;
			<pre>for (t in threads) {</pre>&#13;
			<pre>    t.join()</pre>&#13;
			<pre>}</pre>&#13;
			<pre>println(scores[0].score) // Less than 2000 for sure</pre>&#13;
			<p>If you run the code yourself, the value will be anything under <code>2000</code>.</p>&#13;
			<p>This is a <a id="_idIndexMarker404"/>classic case of a <em class="italic">race condition</em> for<a id="_idIndexMarker405"/> mutable variables. The number you'll get will be different every time you run this code. The reason for this may be familiar to you if you have encountered concurrency previously. And, it has nothing to do with threads not completing their work, by the way. You can make sure of this by adding a print message after the loop:</p>&#13;
			<pre>thread { </pre>&#13;
			<pre>    for (i in 1..1000) { </pre>&#13;
			<pre>        scores[0].score = scores[0].score + 1 </pre>&#13;
			<pre>    }</pre>&#13;
			<pre>    println("Done")</pre>&#13;
			<pre>}</pre>&#13;
			<p>This also isn't the fault of using the increment (<code>++</code>) operator. As you can see, we used the long notation to increment the value, but if you run it again as many times as possible, you would still get the wrong results.</p>&#13;
			<p>The reason for this behavior is that the addition operation and the assignment operation are not <em class="italic">atomic</em>. Two threads may override the addition operations of each other, resulting in the number not being incremented enough times.</p>&#13;
			<p>Here, we used an extreme example of a collection that contains exactly one element. In the real world, the collections you will be working with will usually contain multiple elements. For example, you would track scores for multiple players, or even maintain a ranking system for thousands of players simultaneously. This would complicate the example even further. </p>&#13;
			<p>What you need to remember is the following: even if a collection is immutable, it may still <em class="italic">contain</em> mutable <a id="_idIndexMarker406"/>objects<a id="_idIndexMarker407"/> inside. Mutable objects are not thread-safe. </p>&#13;
			<p>Next, let's look at <em class="italic">tuples</em>, which are an example of immutable objects. </p>&#13;
			<h2 id="_idParaDest-144"><a id="_idTextAnchor150"/>Tuples</h2>&#13;
			<p>In functional <a id="_idIndexMarker408"/>programming, a <code>pair</code>:</p>&#13;
			<pre>val pair = "a" to 1</pre>&#13;
			<p><code>pair</code> contains two properties – called <code>first</code> and <code>second</code> – and is immutable:</p>&#13;
			<pre>pair.first = "b" // Doesn't work</pre>&#13;
			<pre>pair.second = 2  // Still doesn't</pre>&#13;
			<p>We can <em class="italic">destructure</em> <code>pair</code> into two separate values using a <em class="italic">destructure declaration</em>:</p>&#13;
			<pre>val (key, value) = pair</pre>&#13;
			<pre>println("$key =&gt; $value")</pre>&#13;
			<p>When iterating over a map, we also work with another type of tuple: <code>Map.Entry</code>:</p>&#13;
			<pre>for (p in mapOf(1 to "Sunday", 2 to "Monday")) {</pre>&#13;
			<pre>   println("${p.key} ${p.value}")</pre>&#13;
			<pre>}</pre>&#13;
			<p>This tuple already has <code>key</code> and <code>value</code> members, instead of <code>first</code> and <code>second</code>.</p>&#13;
			<p>In addition to <code>pair</code>, there is a <code>Triple</code> tuple that also contains a <code>third</code> value:</p>&#13;
			<pre>val firstEdition = Triple("Design Patterns with Kotlin",   310, 2018)</pre>&#13;
			<p>In general, <code>data</code> classes are usually a good implementation for tuples because they provide clear naming. If you look at the preceding example, it's not immediately obvious that the <code>310</code> value represents the number of pages. </p>&#13;
			<p>However, as we saw in the previous section, not every <code>data</code> class is a proper tuple. You need to make sure that all of its members are <em class="italic">values</em> and not <em class="italic">variables</em>. You also need to check whether any nested collections or classes it has are immutable as well. </p>&#13;
			<p>Now, let's <a id="_idIndexMarker410"/>discuss another important<a id="_idIndexMarker411"/> topic in functional programming: functions as a first-class citizen of the language.</p>&#13;
			<h1 id="_idParaDest-145"><a id="_idTextAnchor151"/>Functions as values</h1>&#13;
			<p>We already<a id="_idIndexMarker412"/> covered some of the functional capabilities of Kotlin in the chapters dedicated to design patterns. The <strong class="bold">Strategy</strong> and <strong class="bold">Command</strong> design<a id="_idIndexMarker413"/> patterns <a id="_idIndexMarker414"/>are only two examples that rely heavily on the ability to accept functions as arguments, return functions, store functions as values, or put functions inside of collections. In this section, we'll cover some other aspects of functional programming in Kotlin, such as <em class="italic">function purity</em> and <em class="italic">currying</em>.</p>&#13;
			<h2 id="_idParaDest-146"><a id="_idTextAnchor152"/>Learning about higher-order functions</h2>&#13;
			<p>As we <a id="_idIndexMarker415"/>discussed previously, in Kotlin, it's possible for a function to return another function. Let's look at the following simple function to understand this syntax in depth:</p>&#13;
			<pre>fun generateMultiply(): (Int) -&gt; Int {</pre>&#13;
			<pre>    return fun(x: Int): Int {</pre>&#13;
			<pre>        return x * 2</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Here, our <code>generateMultiply</code> function returns another function that doesn't have a name. Functions <a id="_idIndexMarker416"/>without a name are called <strong class="bold">anonymous functions</strong>.</p>&#13;
			<p>We could also rewrite the preceding code using shorter syntax:</p>&#13;
			<pre>fun generateMultiply(): (Int) -&gt; Int {</pre>&#13;
			<pre>    return { x: Int -&gt;</pre>&#13;
			<pre>        x * 2</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>} </pre>&#13;
			<p>If a function<a id="_idIndexMarker417"/> without a name uses short syntax, it's <a id="_idIndexMarker418"/>called a <strong class="bold">lambda function</strong>.</p>&#13;
			<p>Next, let's look at the signature of the return type:</p>&#13;
			<pre>(Int) -&gt; Int</pre>&#13;
			<p>From that signature, we know that the function that we return will accept a single integer as input and produce an integer as output. </p>&#13;
			<p>If a function doesn't accept any arguments, we denote that using empty round brackets:</p>&#13;
			<pre>() -&gt; Int</pre>&#13;
			<p>If a function doesn't return anything, we use the <code>Unit</code> type to specify that:</p>&#13;
			<pre>(Int) -&gt; Unit</pre>&#13;
			<p>Functions in Kotlin can be assigned to a variable or value to be invoked later on:</p>&#13;
			<pre>val multiplyFunction = generateMultiply()</pre>&#13;
			<pre>...</pre>&#13;
			<pre>println(multiplyFunction(3, 4))</pre>&#13;
			<p>The function assigned to a variable is<a id="_idIndexMarker419"/> usually called a <strong class="bold">literal function</strong>. </p>&#13;
			<p>We applied this in <a href="B17816_04_ePub.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">Getting Familiar with Behavioral Patterns</em>, when discussing the Strategy design pattern. </p>&#13;
			<p>It's also possible to specify a function as a parameter:</p>&#13;
			<pre>fun mathInvoker(x: Int, y: Int, mathFunction: (Int, Int) -&gt;   Int) {</pre>&#13;
			<pre>    println(mathFunction(x, y))</pre>&#13;
			<pre>}</pre>&#13;
			<pre>mathInvoker(5, 6, multiplyFunction)</pre>&#13;
			<p>If a function<a id="_idIndexMarker420"/> is the last parameter, it can also be supplied in an ad hoc fashion, outside of the brackets:</p>&#13;
			<pre>mathInvoker(7, 8) { x, y -&gt;</pre>&#13;
			<pre>   x * y</pre>&#13;
			<pre>}</pre>&#13;
			<p>This syntax is<a id="_idIndexMarker421"/> also<a id="_idIndexMarker422"/> called <strong class="bold">trailing lambda</strong> or <strong class="bold">call suffix</strong>. We saw an example of this in <a href="B17816_04_ePub.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">Getting Familiar with Behavioral Patterns</em>, when discussing the Interpreter design pattern. </p>&#13;
			<p>Now that we've covered the basic syntax of functions, let's see how they can be used.</p>&#13;
			<h2 id="_idParaDest-147"><a id="_idTextAnchor153"/>Higher-order functions in a standard library</h2>&#13;
			<p>When <a id="_idIndexMarker423"/>working with Kotlin, something you will be doing on a daily basis is working with <em class="italic">collections</em>. As we mentioned briefly in <a href="B17816_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Kotlin</em>, collections have support for higher-order functions.</p>&#13;
			<p>For example, in the previous chapters, to print elements of a collection one by one, we used a boring <code>for-each</code> loop:</p>&#13;
			<pre>val dwarfs = listOf("Dwalin", "Balin", "Kili", "Fili",   "Dori", "Nori", "Ori", "Oin", "Gloin", "Bifur", "Bofur",   "Bombur", "Thorin")</pre>&#13;
			<pre>for (d in dwarfs) {</pre>&#13;
			<pre>    println(d)</pre>&#13;
			<pre>}</pre>&#13;
			<p>Many of you probably groaned at seeing this. But I hope you didn't stop reading the book altogether. Of course, there is also another way to achieve the same goal that is common in many programming languages: a <code>forEach</code> function:</p>&#13;
			<pre>dwarfs.forEach { d -&gt; </pre>&#13;
			<pre>    println(d)</pre>&#13;
			<pre>}</pre>&#13;
			<p>This function is one of the most basic examples of a higher-order function. Let's see how it's declared:</p>&#13;
			<pre>fun &lt;T&gt; Iterable&lt;T&gt;.forEach(action: (T) -&gt; Unit)</pre>&#13;
			<p>Here, <code>action</code> is a <a id="_idIndexMarker424"/>function that receives an element of a collection and doesn't return anything. This function presents an opportunity to discuss another aspect of Kotlin: the <code>it</code> notation. </p>&#13;
			<h1 id="_idParaDest-148"><a id="_idTextAnchor154"/>The it notation</h1>&#13;
			<p>It is very common<a id="_idIndexMarker425"/> in functional programming to keep your functions small and simple. The simpler the function, the easier it is to understand, and the more chances it has to be reused in other places. And the aim <em class="italic">of reusing</em> code is one of the basic Kotlin principles.</p>&#13;
			<p>Notice that in the preceding example, we didn't specify the type of the <code>d</code> variable. We could do this using the same colon notation we have used elsewhere:</p>&#13;
			<pre>dwarfs.forEach { d: String -&gt;  </pre>&#13;
			<pre>    println(d) </pre>&#13;
			<pre>}</pre>&#13;
			<p>However, usually, we don't need to do this because the compiler can figure this out from the generic types that we use. After all, <code>dwarfs</code> is of the <code>List&lt;String&gt;</code> type, so <code>d</code> is of the <code>String</code> type as well.</p>&#13;
			<p>The type of the argument is not the only part that we can omit when writing short lambdas like this one. If a lambda takes a single argument, we can use the implicit name for it, which in this case, is <code>it</code>:</p>&#13;
			<pre>dwarfs.forEach {</pre>&#13;
			<pre>    println(it)</pre>&#13;
			<pre>}</pre>&#13;
			<p>In cases where we need to invoke a single function to a single parameter, we could also use a <em class="italic">function reference</em>. We saw an example of this in <a href="B17816_04_ePub.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">Getting Familiar with Behavioral Patterns</em>, when discussing the Strategy design pattern:</p>&#13;
			<pre>dwarfs.forEach(::println)</pre>&#13;
			<p>We'll use the <a id="_idIndexMarker426"/>shortest notation in most of the following examples. It is advised to use the longer syntax for cases such as <em class="italic">one lambda nested in another</em>. In those cases, giving proper names for the parameters is more important than conciseness.</p>&#13;
			<h2 id="_idParaDest-149"><a id="_idTextAnchor155"/>Closures</h2>&#13;
			<p>In the object-oriented<a id="_idIndexMarker427"/> paradigm, state is always stored within objects. But in functional programming, this isn't necessarily the case. Let's look at the following function as an example:</p>&#13;
			<pre>fun counter(): () -&gt; Int {</pre>&#13;
			<pre>    var i = 0</pre>&#13;
			<pre>    return { i++ }</pre>&#13;
			<pre>}</pre>&#13;
			<p>The preceding example is clearly a higher-order function, as you can see by its <code>return</code> type. It returns a function with zero arguments that produces an integer. </p>&#13;
			<p>Let's store it in a variable, in the way we've already learned, and invoke it multiple times:</p>&#13;
			<pre>val next = counter()</pre>&#13;
			<pre>println(next())</pre>&#13;
			<pre>println(next())</pre>&#13;
			<pre>println(next())</pre>&#13;
			<p>As you can see, the function is able to keep a state, in this case, the value of a counter, even though it is not part of an object.</p>&#13;
			<p>This is called<a id="_idIndexMarker428"/> a <strong class="bold">closure</strong>. The lambda has access to all of the local variables of the function that wraps it, and those local variables persist, as long as the reference to the lambda is kept.</p>&#13;
			<p>The use of<a id="_idIndexMarker429"/> closures is another tool in the functional programming toolbox that reduces the need to define lots of classes that simply wrap a single function with some state.</p>&#13;
			<h2 id="_idParaDest-150"><a id="_idTextAnchor156"/>Pure functions</h2>&#13;
			<p>A <strong class="bold">pure function</strong> is a<a id="_idIndexMarker430"/> function without any<a id="_idIndexMarker431"/> side effects. A <strong class="bold">side effect</strong> can be considered anything that accesses or changes the external state. The external state can be a non-local variable (where a variable from a closure is still considered to be non-local) or any kind of IO (that is, reading or writing to a file or using any kind of network capabilities). </p>&#13;
			<p class="callout-heading">Important Note:</p>&#13;
			<p class="callout">For those not familiar with the term, <strong class="bold">IO</strong> stands for <strong class="bold">Input/Output</strong>, and this covers any kind of interaction that is external to our program, such as writing to files or reading from a network.</p>&#13;
			<p>For example, the lambda we just discussed in the <em class="italic">Closures</em> section is not considered <em class="italic">pure</em> because it can return different output for the same input when it is invoked multiple times. </p>&#13;
			<p><strong class="bold">Impure functions</strong> are hard to <a id="_idIndexMarker432"/>test and to reason about in general, as the result they return may depend on the order of execution or on factors that we can't control (such as network issues). </p>&#13;
			<p>One thing to remember is that logging or even printing to a console still involves IO and is subject to the same set of problems. </p>&#13;
			<p>Let's look at the following simple function:</p>&#13;
			<pre>fun sayHello() = println("Hello")</pre>&#13;
			<p><em class="italic">So, in this case, how do you ensure that Hello is printed?</em> The task is not as simple as it seems, as we'll need some way to capture the standard output – that is, the same console where we usually see stuff printed. </p>&#13;
			<p>We'll <a id="_idIndexMarker433"/>compare <a id="_idIndexMarker434"/>it to the following function:</p>&#13;
			<pre>fun hello() = "Hello"</pre>&#13;
			<p>The following function doesn't have any side effects. That makes it a lot easier to test:</p>&#13;
			<pre>fun testHello(): Boolean {</pre>&#13;
			<pre>    return "Hello" == hello()</pre>&#13;
			<pre>}</pre>&#13;
			<p>The <code>hello()</code> function may look a bit meaningless, but that's actually one of the properties of pure functions. Their invocation could be replaced by their result if we knew it ahead of time. This is often<a id="_idIndexMarker435"/> called <strong class="bold">referential transparency</strong>.</p>&#13;
			<p>As we mentioned earlier, not every function written in Kotlin is a pure function:</p>&#13;
			<pre>fun &lt;T&gt; removeFirst(list: MutableList&lt;T&gt;): T {</pre>&#13;
			<pre>    return list.removeAt(0)</pre>&#13;
			<pre>}</pre>&#13;
			<p>If we call the function twice on the same list, it will return different results:</p>&#13;
			<pre>val list = mutableListOf(1, 2, 3)</pre>&#13;
			<pre>println(removeFirst(list)) // Prints 1</pre>&#13;
			<pre>println(removeFirst(list)) // Prints 2</pre>&#13;
			<p>Compare the preceding function to this one:</p>&#13;
			<pre>fun &lt;T&gt; withoutFirst(list: List&lt;T&gt;): T {</pre>&#13;
			<pre>    return ArrayList(list).removeAt(0)</pre>&#13;
			<pre>}</pre>&#13;
			<p>Now, our function is totally predictable, no matter how many times we invoke it:</p>&#13;
			<pre>val list = mutableListOf(1, 2, 3)</pre>&#13;
			<pre>println(withoutFirst(list)) // It's 1</pre>&#13;
			<pre>println(withoutFirst(list)) // Still 1</pre>&#13;
			<p>As you can see, in this instance, we used an immutable interface, <code>List&lt;T&gt;</code>, which helps us by preventing the possibility of mutating our input. When combined with the immutable values we discussed in the previous section, pure functions allow easier testing by <a id="_idIndexMarker436"/>providing predictable results and the<a id="_idIndexMarker437"/> parallelization of our algorithms.</p>&#13;
			<p>A system that utilizes pure functions is easier to reason about because it doesn't rely on any external factors – what you see is what you get.</p>&#13;
			<h2 id="_idParaDest-151"><a id="_idTextAnchor157"/>Currying</h2>&#13;
			<p><strong class="bold">Currying</strong> is a<a id="_idIndexMarker438"/> way <a id="_idIndexMarker439"/>to translate a function that takes a number of arguments into a chain of functions, where each function takes a single argument. This may sound confusing, so let's look at a simple example:</p>&#13;
			<pre>fun subtract(x: Int, y: Int): Int {</pre>&#13;
			<pre>    return x - y</pre>&#13;
			<pre>}</pre>&#13;
			<pre>println(subtract(50, 8))</pre>&#13;
			<p>This is a function that takes two arguments as an input and returns the difference between them. However, some languages allow us to invoke this function with the following syntax:</p>&#13;
			<pre>subtract(50)(8)</pre>&#13;
			<p>This is what currying looks like. Currying allows us to take a function with multiple arguments (in our case, two) and convert this function into a set of functions, where each one takes only a single argument. </p>&#13;
			<p>Let's examine how this can be achieved in Kotlin. We've already seen how we can return a function from another function:</p>&#13;
			<pre>fun subtract(x: Int): (Int) -&gt; Int {</pre>&#13;
			<pre>    return fun(y: Int): Int {</pre>&#13;
			<pre>        return x - y</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Here is <a id="_idIndexMarker440"/>the<a id="_idIndexMarker441"/> shorter form of the preceding code:</p>&#13;
			<pre>fun subtract(x: Int) = fun(y: Int): Int {</pre>&#13;
			<pre>    return x - y</pre>&#13;
			<pre>}</pre>&#13;
			<p>In the preceding example, we use single-expression syntax to return an anonymous function without the need to declare the <code>return</code> type or use the <code>return</code> keyword.</p>&#13;
			<p>And here it is in an even shorter form:</p>&#13;
			<pre>fun subtract(x: Int) = {y: Int -&gt; x - y}</pre>&#13;
			<p>Now, an anonymous function is translated to a lambda, with the <code>return</code> type of the lambda inferred as well.</p>&#13;
			<p>Although not very useful by itself, it's still an interesting concept to grasp. And if you're a <strong class="bold">JavaScript</strong> developer looking for a new job, make sure you understand it fully, since it's asked about in nearly every interview.</p>&#13;
			<p>One real-world scenario where you might want to use currying is <em class="italic">logging</em>. A <code>log</code> function usually looks something like this:</p>&#13;
			<pre>enum class LogLevel {</pre>&#13;
			<pre>    ERROR, WARNING, INFO</pre>&#13;
			<pre>}</pre>&#13;
			<pre>fun log(level: LogLevel, message: String) =     println("$level: $message")</pre>&#13;
			<p>We could fix the log level by storing the function in a variable:</p>&#13;
			<pre>val errorLog = fun(message: String) {</pre>&#13;
			<pre>    log(LogLevel.ERROR, message)</pre>&#13;
			<pre>}</pre>&#13;
			<p>Notice that<a id="_idIndexMarker442"/> the <code>errorLog</code> function is easier to use<a id="_idIndexMarker443"/> than the regular <code>log</code> function because it accepts one argument instead of two. However, this raises a question:</p>&#13;
			<p><em class="italic">What if we don't want to create all of the possible loggers ahead of time?</em></p>&#13;
			<p>In this case, we can use currying. The <em class="italic">curried</em> version of this code would look like this:</p>&#13;
			<pre>fun createLogger(level: LogLevel): (String) -&gt; Unit {</pre>&#13;
			<pre>    return { message: String -&gt;</pre>&#13;
			<pre>        log(level, message)</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Now, it's up to whoever uses our code to create the logger they want:</p>&#13;
			<pre>val infoLogger = createLogger(LogLevel.INFO)</pre>&#13;
			<pre>infoLogger("Log something")</pre>&#13;
			<p>This, in fact, is very similar to the Factory design pattern we covered in <a href="B17816_02_ePub.xhtml#_idTextAnchor062"><em class="italic">Chapter 2</em></a>, <em class="italic">Working with Creational Patterns</em>. Again, the power of a modern language decreases the number of custom classes we need to implement to achieve the same behavior. </p>&#13;
			<p>Next, let's talk about another powerful technique that can save us from having to do the same <a id="_idIndexMarker444"/>computation<a id="_idIndexMarker445"/> over and over again. </p>&#13;
			<h2 id="_idParaDest-152"><a id="_idTextAnchor158"/>Memoization</h2>&#13;
			<p>If our function<a id="_idIndexMarker446"/> always returns the same <a id="_idIndexMarker447"/>output for the same input, we can easily map its input to the output, caching the results in the process. This technique is called <strong class="bold">memoization</strong>.</p>&#13;
			<p>A common task when developing different types of systems or solving problems is finding a way to avoid repeating the same computation multiple times. Let's assume we receive multiple lists of integers, and for each list, we would like to print its sum:</p>&#13;
			<pre>val input = listOf(</pre>&#13;
			<pre>    setOf(1, 2, 3),</pre>&#13;
			<pre>    setOf(3, 1, 2),</pre>&#13;
			<pre>    setOf(2, 3, 1),</pre>&#13;
			<pre>    setOf(4, 5, 6)</pre>&#13;
			<pre>)</pre>&#13;
			<p>Looking at the input, you can see that the first three sets are in fact equal – the difference is only in the order of the elements, so calculating the sum three times would be wasteful. </p>&#13;
			<p>The sum calculation can be easily described as a pure function:</p>&#13;
			<pre>fun sum(numbers: Set&lt;Int&gt;): Double {</pre>&#13;
			<pre>    return numbers.sumByDouble { it.toDouble() }</pre>&#13;
			<pre>}</pre>&#13;
			<p>This function does not depend on any external state and doesn't change the external state in any way. So, it is safe for the same input to replace the call to this function with the value it had returned previously. </p>&#13;
			<p>We could store the results of a previous computation for the same set in a mutable map:</p>&#13;
			<pre>val resultsCache = mutableMapOf&lt;Set&lt;Int&gt;, Double&gt;()</pre>&#13;
			<p>To avoid creating too many classes, we could use a higher-order function that would wrap the result in the cache that we created earlier:</p>&#13;
			<pre>fun summarizer(): (Set&lt;Int&gt;) -&gt; Double {</pre>&#13;
			<pre>    val resultsCache = mutableMapOf&lt;Set&lt;Int&gt;, Double&gt;()</pre>&#13;
			<pre> </pre>&#13;
			<pre>    return { numbers: Set&lt;Int&gt; -&gt;</pre>&#13;
			<pre>        resultsCache.computeIfAbsent(numbers, ::sum)</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Here, we <a id="_idIndexMarker448"/>use <a id="_idIndexMarker449"/>a method reference operator (<code>::</code>) to tell <code>computeIfAbsent</code> to use the <code>sum()</code> method in the event where the input hasn't been cached yet. </p>&#13;
			<p>Note that <code>sum()</code> is a pure function, while <code>summarize()</code> is not. The latter will behave differently for the same input. But that's exactly what we want in this case.</p>&#13;
			<p>Running the following code on the preceding input will invoke the sum function only twice:</p>&#13;
			<pre>val summarizer = summarizer()</pre>&#13;
			<pre>input.forEach {</pre>&#13;
			<pre>    println(summarizer(it))</pre>&#13;
			<pre>}</pre>&#13;
			<p>The combination of immutable objects, pure functions, and closures provides us with a powerful tool for performance optimization. Just remember: nothing is free. We trade one resource, CPU time, for another resource, which is memory. And it's up to you to decide which resource is more expensive in each case.</p>&#13;
			<h1 id="_idParaDest-153"><a id="_idTextAnchor159"/>Using expressions instead of statements</h1>&#13;
			<p>A <strong class="bold">statement</strong> is a block of <a id="_idIndexMarker450"/>code that <em class="italic">doesn't return</em> anything. An <strong class="bold">expression</strong>, on the other hand, <em class="italic">returns a new value</em>. Since statements produce no results, the only way for them to be useful is to mutate the state, whether that's changing a variable, changing a data structure, or performing some kind of IO.</p>&#13;
			<p>Functional programming tries to avoid mutating the state as much as possible. Theoretically, the more we rely on expressions, the more our functions will be pure, with all the benefits of functional purity.</p>&#13;
			<p>We've used the <code>if</code> expression many times already, so one of its benefits should be clear: it's less verbose and, for that reason, less error-prone than the <code>if</code> statement from other languages.</p>&#13;
			<h2 id="_idParaDest-154"><a id="_idTextAnchor160"/>Pattern matching</h2>&#13;
			<p>The<a id="_idIndexMarker451"/> concept <a id="_idIndexMarker452"/>of <code>switch</code>/<code>case</code> on steroids. We've already seen how the <code>when</code> expression can be used, which we explored in <a href="B17816_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Kotlin</em>, so let's briefly discuss why this concept is important for the functional paradigm.</p>&#13;
			<p>You may know that in Java, <code>switch</code> accepts only some primitive types, strings, or enums.</p>&#13;
			<p>Consider the following code, which is usually used to demonstrate how polymorphism is implemented in the language:</p>&#13;
			<pre>class Cat : Animal {</pre>&#13;
			<pre>    fun purr(): String {</pre>&#13;
			<pre>        return "Purr-purr";</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<pre>class Dog : Animal {</pre>&#13;
			<pre>    fun bark(): String {</pre>&#13;
			<pre>        return "Bark-bark";</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<pre>interface Animal</pre>&#13;
			<p>If we were<a id="_idIndexMarker453"/> to <a id="_idIndexMarker454"/>decide which of the functions to call, we would need to write code akin to the following:</p>&#13;
			<pre>fun getSound(animal: Animal): String {</pre>&#13;
			<pre>    var sound: String? = null;</pre>&#13;
			<pre>    if (animal is Cat) {</pre>&#13;
			<pre>        sound = (animal as Cat).purr();</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>    else if (animal is Dog) {</pre>&#13;
			<pre>        sound = (animal as Dog).bark();</pre>&#13;
			<pre>    }</pre>&#13;
			<pre> </pre>&#13;
			<pre>    if (sound == null) {</pre>&#13;
			<pre>        throw RuntimeException();</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>    return sound;</pre>&#13;
			<pre>}</pre>&#13;
			<p>This code attempts to figure out at runtime what methods the <code>getSound</code> class implements.</p>&#13;
			<p>This method could be shortened by introducing multiple returns, but in real projects, multiple returns are usually a bad practice. </p>&#13;
			<p>Since we don't have a <code>switch</code> statement for classes, we need to use an <code>if</code> statement instead. </p>&#13;
			<p>Now, let's compare the preceding code with the following Kotlin code:</p>&#13;
			<pre>fun getSound(animal: Animal) = when(animal) {</pre>&#13;
			<pre>    is Cat -&gt; animal.purr()</pre>&#13;
			<pre>    is Dog -&gt; animal.bark()</pre>&#13;
			<pre>    else -&gt; throw RuntimeException("Unknown animal")</pre>&#13;
			<pre>}</pre>&#13;
			<p>Since <code>when</code> is an expression, we avoided declaring the intermediate variable we previously had altogether. In addition, the code that uses pattern matching doesn't need any type checks and casts.</p>&#13;
			<p>Now we've learned<a id="_idIndexMarker455"/> how<a id="_idIndexMarker456"/> to replace imperative <code>if</code> statements with much more functional <code>when</code> expressions, let's see how we can replace imperative loops in our code by using <em class="italic">recursion</em>.</p>&#13;
			<h1 id="_idParaDest-155"><a id="_idTextAnchor161"/>Recursion</h1>&#13;
			<p><strong class="bold">Recursion</strong> is a <a id="_idIndexMarker457"/>function<a id="_idIndexMarker458"/> invoking itself with new arguments. Many well-known algorithms, such as <strong class="bold">Depth First Search</strong>, rely on <a id="_idIndexMarker459"/>recursion.</p>&#13;
			<p>Here is an example of a very inefficient function that uses recursion to calculate the sum of all the numbers in a given list:</p>&#13;
			<pre>fun sumRec(i: Int, sum: Long, numbers: List&lt;Int&gt;): Long {</pre>&#13;
			<pre>    return if (i == numbers.size) {</pre>&#13;
			<pre>        return sum</pre>&#13;
			<pre>    } else {</pre>&#13;
			<pre>        sumRec(i+1, numbers[i] + sum, numbers)</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>We often try to avoid recursion due to the stack overflow errors that we may receive if our call stack is too deep. You can call this function with a list that contains a million numbers to demonstrate this:</p>&#13;
			<pre>val numbers = List(1_000_000) {it}</pre>&#13;
			<pre>println(sumRec(0,  numbers)) </pre>&#13;
			<pre>// Crashed pretty soon, around 7K</pre>&#13;
			<p>However, Kotlin supports an <a id="_idIndexMarker460"/>optimization called <strong class="bold">tail recursion</strong>. One of the great benefits of tail recursion is that it avoids the dreaded stack overflow exception. If there is only a <a id="_idIndexMarker461"/>single<a id="_idIndexMarker462"/> recursive call in our function, we can use that optimization.</p>&#13;
			<p>Let's rewrite our recursive function using a new keyword, <code>tailrec</code>, to avoid this problem:</p>&#13;
			<pre>tailrec fun sumRec(i: Int, sum: Long, numbers: List&lt;Int&gt;): </pre>&#13;
			<pre>  Long {</pre>&#13;
			<pre>    return if (i == numbers.size) {</pre>&#13;
			<pre>        return sum</pre>&#13;
			<pre>    } else {</pre>&#13;
			<pre>        sumRec(i+1, numbers[i] + sum, numbers)</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Now, the compiler will optimize our call and avoid the exception completely. </p>&#13;
			<p>However, this <a id="_idIndexMarker463"/>optimization doesn't work if you have multiple recursive calls, such as in the <strong class="bold">Merge Sort</strong> algorithm. </p>&#13;
			<p>Let's examine the following function, which is the <em class="italic">sort</em> part of the Merge Sort algorithm:</p>&#13;
			<pre>tailrec fun mergeSort(numbers: List&lt;Int&gt;): List&lt;Int&gt; {</pre>&#13;
			<pre>    return when {</pre>&#13;
			<pre>        numbers.size &lt;= 1 -&gt; numbers</pre>&#13;
			<pre>        numbers.size == 2 -&gt; {</pre>&#13;
			<pre>            return if (numbers[0] &lt; numbers[1]) {</pre>&#13;
			<pre>                numbers</pre>&#13;
			<pre>            } else {</pre>&#13;
			<pre>                listOf(numbers[1], numbers[0])</pre>&#13;
			<pre>            }</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>        else -&gt; {</pre>&#13;
			<pre><strong class="bold">            val left = mergeSort(numbers.slice               (0..numbers.size / 2))</strong></pre>&#13;
			<pre><strong class="bold">            val right = mergeSort(numbers.slice               (numbers.size / 2 + 1 until numbers.size))</strong></pre>&#13;
			<pre>            return merge(left, right)</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>} </pre>&#13;
			<p>Notice that there <a id="_idIndexMarker464"/>are <a id="_idIndexMarker465"/>two recursive calls instead of one. The Kotlin compiler will then issue the following warning:</p>&#13;
			<pre>&gt; "A function is marked as tail-recursive but no tail calls are found"</pre>&#13;
			<h1 id="_idParaDest-156"><a id="_idTextAnchor162"/>Summary</h1>&#13;
			<p>You should now have a better understanding of functional programming and its benefits, as well as how Kotlin approaches this topic. We've discussed the concepts of <em class="italic">immutability</em> and <em class="italic">pure functions</em>, and how combining these results in more testable code that is easier to maintain. </p>&#13;
			<p>We discussed how Kotlin supports <em class="italic">closures</em>, which allow a function to access the variables of the function that wraps it and effectively store the state between executions. This enables techniques such as <em class="italic">currying</em> and <em class="italic">memoization</em> that allow us to fix some of the function arguments (by acting as defaults) and remember the value returned from a function in order to avoid recalculating it. </p>&#13;
			<p>We learned that Kotlin uses the <code>tailrec</code> keyword to allow the compiler to optimize <em class="italic">tail recursion</em>. We also looked at <em class="italic">higher-order functions</em>, <em class="italic">expressions versus statements</em>, and <em class="italic">pattern matching</em>. All of these concepts allow us to write code that is easier to test and has less risk of concurrency bugs. </p>&#13;
			<p>In the next chapter, we'll put this knowledge to practical use and discover how <strong class="bold">reactive programming</strong> builds upon functional programming to create scalable and resilient systems.</p>&#13;
			<h1 id="_idParaDest-157"><a id="_idTextAnchor163"/>Questions </h1>&#13;
			<ol>&#13;
				<li>What are higher-order functions? </li>&#13;
				<li>What is the <code>tailrec</code> keyword in Kotlin? </li>&#13;
				<li>What are pure functions? </li>&#13;
			</ol>&#13;
		</p>&#13;
	</div></body></html>