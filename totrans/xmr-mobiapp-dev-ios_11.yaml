- en: Chapter 11. Handling Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From time to time it is important for an application to store or manipulate
    data. With the advent of LINQ, manipulation is extremely simple now. The problem,
    though, is that you need to store the data somehow. Thankfully this too is simple
    using SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using SQLite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up an SQLite helper class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using LINQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dangers of using LINQ on iOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using SQLite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQLite is a very simple database system that is also extremely powerful. It
    is outside the scope of this book to give you a master class on using SQLite,
    but understanding how to set up and use the system will help.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and setting up SQLite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Installing can be performed in one of two ways; either you can install from
    the Xamarin component market (it is useful as it supplies you with examples and
    also the Android version) or you can download and install the software manually.
    As there are no additional libraries (SQLite comes as a single C# file) either
    way is good.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have either copied the C# file or installed the component, the `SQLite.net`
    implementation is ready for use. It is as simple as inserting the following `using`
    directive at the top of the source file, and it''s done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Database basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An easy way to consider a database is like an old card index system (commonly
    known as a **cardex** system). Information (data) can be added, updated, read,
    or deleted—and SQLite gives you that facility within the mobile environment. The
    data is stored in a file with tables (the table can be considered as the box that
    holds the cards) holding the information you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the cardex system can be used though, the method of storage has to be
    defined. The simplest method of doing it is to create a class containing the primitive
    types. SQLite can only store certain types of data: `integer`, `real`, `text`,
    `none`, and `numeric`. No other types are permitted—this includes arrays and collections
    (such as `List<T>`) The types normally used in programming (such as `string` and
    `double`) are **mapped** to these internal types.'
  prefs: []
  type: TYPE_NORMAL
- en: A table also requires a primary key. This is the main index key which is typically
    auto-incremented. In a data class, this would be defined using `[PrimaryKey, AutoIncrement]`.
  prefs: []
  type: TYPE_NORMAL
- en: A simple database class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a demonstration, a simple database class can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `demoTable` variable can then be brought into the database.
  prefs: []
  type: TYPE_NORMAL
- en: Create a connection to the database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before the database can be used, a connection to the server needs to be set
    up. As with any class, the database class needs to be set up. I've called mine
    `DataManager`. SQLite needs a path to the database file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code sets up an instance of the `DataManager`. To enable the
    database to be used across the app, the following should be added to the `AppDelegate`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Within the `DataManager` class, a lock is required (in order to prevent more
    than one operation occurring on the database at any time), as is a local copy
    of the database path.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the table needs to be set up in the database.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll notice that you will need to define a class with the following constants
    in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `DBClauseVacuum` constant is used on the final Execute query. The `DBClauseSyncOff`
    constant is used on the first.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you may have noticed something about using SQLite. It is being
    used as if it is a normal method within a class. This is fine as it is.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an SQLite helper class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typically using SQLite would require you to make and store the connection globally
    (to save device resources and reduce the possibility of a security problem) and
    then for every call to the database set up a set of queries and issues. Even for
    a trivial database, this can lead to many lines of repeated code and more the
    lines of code you have, the greater is the potential for bugs to crop up.
  prefs: []
  type: TYPE_NORMAL
- en: A helper class encapsulates all of the functionalities you will need and is
    very easy to write.
  prefs: []
  type: TYPE_NORMAL
- en: Writing helper class methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As I mentioned at the outset, databases allow you to read/write from/to a table.
    To start with, it makes sense to be able to read data. The following are two classes:
    the first returns `List<demoRow>` and the other returns a name for the given ID.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: There is very little difference between the two methods except for the database
    call. The List version requires a query—this is used when a non-primitive type
    is used and the data is expected back out. The `ExecuteScalar` method expects
    rows that are of primitive type to be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing these helper methods would be the same as accessing any other method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Adding data to the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data addition comes in the form of inserting or updating, and unlike a read,
    data addition needs to be trapped in case the insert or update fails and the database
    needs to be rolled back to before the attempt to add data.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, an insert or update can be handled in one method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Again, for the preceding code to work, a single instance of `demoRow` class
    needs to be passed into the method. Using a `List` of `demoRow` is simple to handle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Data manipulation using LINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Accessing a database continually puts a strain onto the system it is sitting
    on and if you consider the number of databases being used at any one time, it
    quickly becomes clear that the overhead of continually hitting the SQL service
    will be high.
  prefs: []
  type: TYPE_NORMAL
- en: LINQ allows database style queries to be applied to data and the results come
    out. While there are many excellent books out there (quite a few of them are free),
    I will cover a couple of convenient methods of using LINQ within an iOS application.
  prefs: []
  type: TYPE_NORMAL
- en: 'While LINQ is extremely powerful, not everything with LINQ will work without
    a problem when coding on iOS. The main reason is how the iPhone works. Quite simply,
    iOS wants to know what is going to happen **Ahead Of Time** (**AOT**). It doesn''t
    like surprises and really doesn''t like data structures it wasn''t aware of. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code should not cause an issue. But think of it another way—how
    big is `List` is going to be? When you're working ahead of time, space allocations
    are typically finite. (For example, an array of `int` values may have 20 values
    worth of memory reserved and nothing more, the AOT system likes this—it knows
    ahead of time that there will need to be 20 lots of `int` reserved.)
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, when using LINQ within an application, you may encounter
    random crashes—it is unlikely, but it may happen and it's worth mentioning it.
  prefs: []
  type: TYPE_NORMAL
- en: LINQ – a whistle-stop tour
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For my examples, I'll use the `demoRow` table already used in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Somewhere in the returned `List` there is the name `Fred Moriarty` and I want
    to get from `List` the instance of the class with that name in it. I know there
    is only one instance of this name in the list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code takes the table and returns the single instance. If the name
    is not found, `null` (or the default value) is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Say my list contains a number of `Fred Bloggs` instances in the `Name` field.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Before LINQ came along, this would have been quite a slow affair and would
    have required a code such as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous examples are very simple. LINQ can perform very complex operations
    as well, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here we have two lists (`ContactList` and `invites`). The LINQ query creates
    two loops and selects the instance tester when `UserID` from the outer loop matches
    `UserId` from the inner loop. The result is pretty much instant.
  prefs: []
  type: TYPE_NORMAL
- en: SELECT and WHERE in LINQ – a common cause of confusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A very common error that at some point everyone meets with LINQ is mixing the
    `WHERE` syntax up with the `SELECT` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: The `WHERE` syntax is a condition (for example, `WHERE ID==311` or `WHERE A==B`).
    It only returns the condition set. In the following example, `testClass` is a
    list, it contains a class of which there is a string called `Value`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `retString` variable will contain a `List<string>` of all results from `testString`
    where `Value == "fred"`.
  prefs: []
  type: TYPE_NORMAL
- en: The `SELECT` syntax returns something for all items in the object passed in
    it. The result might be the items themselves but can be something else.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code transforms the contents of `inString` to be in upper case
    and is output to a list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here `Func<inString, outString>` transforms the elements of `inString` to `outString`
    and outputs the element as an `outString` list.
  prefs: []
  type: TYPE_NORMAL
- en: Using Select in LINQ
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Take the following example and remember `Select` performs a transform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*But what is happening?* The `Select` statement is performed on the string
    array `teams`. It then specifies a lambda expression (`t=>`) which in turn transforms
    the expression to be upper case (`ToUpper()`).'
  prefs: []
  type: TYPE_NORMAL
- en: The `Select` statement (as has been seen in the previous code) has an overloaded
    method as well. Again, it is a transforming method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If the code was run and a suitable output was used, you would see `E`, `Ol`,
    `Lee`—the index at the start is 0, so no characters are seen.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing SQL with LINQ
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depending on your needs, it may be a better option to replace an SQLite database
    with a series of `List<T>` classes and use LINQ to replace the SQL queries. For
    example, if you have a very simple database (such as our `demoTable` database)
    which has a very limited scope for manipulation to be used, it may be a better
    idea to use a list of classes, add to them as you would normally do, and perform
    the queries using LINQ. Without the hit on the database server, this may yield
    a faster response time from the application.
  prefs: []
  type: TYPE_NORMAL
- en: For a more complex table structure where the SQL itself performs a `JOIN` to
    another table or there are complex manipulations involved, using LINQ may not
    result in a usable system.
  prefs: []
  type: TYPE_NORMAL
- en: LINQ can perform `JOIN` conditions as well as most other functions that SQLite
    can perform—just not as easily.
  prefs: []
  type: TYPE_NORMAL
- en: Remember though, LINQ on the iPhone may decide to just die whereas SQLite won't.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data storage on the iPhone can be simple and can also be fraught with problems.
    For safety and reliability, the SQLite option is preferred on the iPhone. For
    speed, you can't beat LINQ but you must ensure that you test the LINQ project
    on a physical device when using LINQ.
  prefs: []
  type: TYPE_NORMAL
