- en: 'Chapter 3. User Interface: View Controllers'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading a view with a view controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating through different view controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing controllers in tabs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a table controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modal view controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom view controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using view controllers efficiently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining different view controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iPad view controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a user interface for different devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have discussed views and how to use them. In most cases of real-world
    application scenarios, views alone are not enough. Apple provides another base
    class, the `UIViewController`, which is responsible for managing views. A view
    controller can respond to device notifications, such as when the device rotates,
    or can provide different ways for displaying and dismissing multiple views or
    even other view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: We will also see how to use the most common view controllers to create applications
    that manage multiple views.
  prefs: []
  type: TYPE_NORMAL
- en: 'These view controllers are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UIViewController:` This is the base class of all view controllers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UINavigationController:` This is the view controller that provides various
    ways of navigating through different view controllers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UITabBarController:` This is a view controller that displays multiple view
    controllers in a tab-like interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UITableViewController:` This is a view controller that is used to display
    data in a list form'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iPad-specific view controllers:** These are view controllers that only apply
    to the iPad device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Furthermore, we will discuss combining different controllers, how to create
    custom controllers and use them, and we will create an application that can be
    deployed in both the iPhone and iPad.
  prefs: []
  type: TYPE_NORMAL
- en: Loading a view with a view controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the `UIViewController` class to manage
    views.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new iPhone empty project in MonoDevelop, and name it `ViewControllerApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add a new file to the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the project in the **Solution** pad and select **Add | New File**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the dialog box that will appear, select **iPhone View** with **Controller**
    from the **MonoTouch** section. Name it `MainViewController`, and click on the
    **New** button. MonoDevelop will create a new `XIB` file and will automatically
    open the `MainViewController.cs` source file. This file contains a class that
    overrides the `UIViewController`, and we can implement any code related to our
    view controller in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `MainViewController.xib` file in Interface Builder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `UILabel` on the view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create and connect an outlet for it inside the `MainViewController` class, and
    name it `myLabel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the text `View in controller!` in the label.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the `XIB` document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back in MonoDevelop, enter the following code in the `FinishedLaunching()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we add a new **iPhone View with Controller** file in a project, in this
    case `MainViewController`, MonoDevelop basically creates and adds three files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MainViewController.xib:` This is the XIB file that contains the controller.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`MainViewController.cs:` This is the C# source file that implements the class
    of our controller.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`MainViewController.designer.cs:` This is the auto-generated source file that
    reflects the changes we make to the controller in Interface Builder.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice that we do not need to add an outlet for the view, since this is taken
    care of by MonoDevelop. We initialize the controller through its class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we display its view through the controller''s `View` by setting it as
    the `RootViewController` of our application''s window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project we have just created only shows how we can add a controller with
    a view. Notice that we created the outlet for the label inside the `MainViewController`
    class, which acts as the file''s owner object in the `XIB` file. To provide some
    functionality for the `MainViewController`, add the following method in the `MainViewController`
    class in the `MainViewController.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This method overrides the `UIViewController.ViewDidLoad()` method, which is
    executed when the controller loads its view.
  prefs: []
  type: TYPE_NORMAL
- en: UIViewController methods to override
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The methods that the `UIViewController` class contains are the ones that we
    override to use its features. Some of these methods are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewDidUnload():` It is called when the view is unloaded'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewWillAppear():` It is called when the view is about to appear on the screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewDidAppear():` It is called when the view has been displayed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewWillDisappear():` It is called when the view is about to disappear, for
    example, when another controller is about to be displayed `ViewDidDisappear():`
    It is called when the view has disappeared'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Navigating through different view controllers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 1](ch01.html "Chapter 1. Development Tools"),Development Tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating an iPhone project with MonoDevelop*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Accessing the UI with outlets*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating through different view controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the `UINavigationController` class
    to navigate among multiple view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UINavigationController` is a controller that provides a hierarchical navigation
    functionality with multiple view controllers. Create a new iPhone empty project
    in MonoDevelop, and name it `NavigationControllerApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add three new **iPhone View with Controller** files in the project, and name
    them `RootViewController, ViewController1`, and `ViewController2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following field in the `AppDelegate` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same class, add the following code in the `FinishedLaunching` method,
    above the `window.MakeKeyAndVisible()`; line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `RootViewController.xib` file in Interface Builder, and add two buttons
    with their corresponding outlets. Set their titles to `First View` and `Second
    View` respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open both the `ViewController1.xib` and `ViewController2.xib`, and add a button
    in each one with the title `Pop to root`. Do not forget to connect the buttons
    with outlets and save the documents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in the `RootViewController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In both `ViewController1` and `ViewController2` classes, enter the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator. Tap on each of the buttons
    to see and navigate through the available views.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `UINavigationController` preserves a stack of controllers. The `UIViewController`
    class has a property named `NavigationController`. In normal situations, this
    property returns null. But, if the controller is pushed into a navigation controller''s
    stack, it returns the instance of the navigation controller it is being pushed
    in. So this way, at any point in the hierarchy of controllers, access to the navigation
    controller is provided. To display a controller, we call the `UINavigationController.PushViewController(UIViewController,
    bool)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the `RootViewController` is the topmost or root controller in the
    navigation stack. A navigation controller must have at least one view controller
    that will act as its root controller. We set it when we create the instance of
    the UINavigationController class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To return to the root controller, we call the `PopToRootViewController(bool)`
    method inside the current controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `bool` parameters in both the methods are used for transitioning between
    controllers with animation.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this simple example, we provided backward navigation to the root controller
    with buttons. Notice that there is an arrow-shaped button at the top bar. That
    bar is called the **navigation** bar, and is of the type `UINavigationBar`. The
    arrow-shaped button is called the **back** button and is of the type `UIBarButtonItem`.
    The back button, when it exists, always navigates to the previous controller in
    the navigation stack.
  prefs: []
  type: TYPE_NORMAL
- en: Managing navigation bar buttons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To change, add, and hide the buttons of the navigation bar, we can use the
    following methods of our currently displayed view controller''s `NavigationItem`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SetLeftBarButtonItem:` It adds a custom button on the left of the navigation
    bar, replacing the default **Back** button'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetRightBarButtonItem:` It adds a custom button on the right side of the navigation
    bar'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetHidesBackButton:` It sets the visibility of the default **Back** button'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To remove or hide the custom left or right buttons on the navigation bar, call
    the appropriate methods, passing `null` instead of a `UIBarButtonItem` object.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Modal view controllers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using view controllers efficiently*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Combining different view controllers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 11](ch11.html "Chapter 11. Graphics and Animation"),Graphics and Animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Pushing view controllers with animation*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing controllers in tabs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to display multiple view controllers in a
    tabbed interface.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UITabBarController` provides a way of displaying different view controllers
    on the same hierarchy level divided into a tab-like interface. Create a new iPhone
    empty project in MonoDevelop, and name it `TabControllerApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add two **iPhone View with Controller** files to the project. Name them `MainController`
    and `SettingsController`.
  prefs: []
  type: TYPE_NORMAL
- en: Open both controllers in Interface Builder, and set different background colors
    for their views and save the documents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following field in the `AppDelegate` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter the following code in the `FinishedLaunching()` method, above the `window.MakeKeyAndVisible()`;
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Tap on each of the tabs at the bottom of the screen, and see their respective
    views shown. The console output is displayed in the **Application Output** pad
    in MonoDevelop. The following screenshot shows the screen of the simulator, with
    the **Settings** tab selected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/1468EXP_03_01 .jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `UITabBarController` displays one tab for each of the controllers it manages.
    That tab is of the type `UITabBarItem,` and it can accept both text and images.
    The `UITabBarController` class holds information about the controllers it contains.
    We can determine which controller was selected by the user through the `ViewControllerSelected`
    event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UITabBarSelectionEventArgs` object holds an instance of the selected controller
    in the property `ViewController`. By accessing the `UIViewController.TabBarItem`
    property, we can determine which controller was selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we output its `Title` property.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just like the `UIViewController` class' `NavigationController` property, where
    it returns the instance of the `UINavigationController` it is part of, the `TabBarItem`
    property will hold an instance only when the controller is part of a `UITabBarController`.
    In other cases it will return `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we initialize the tab controller, we set the controllers it will contain
    through the `SetViewControllers` method, passing an array of view controller objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The controller can accept as many controllers as we want, but if we add six
    or more, four will be displayed with their tabs, while a fifth predefined **More**
    tab will represent all the remaining controllers. That is to keep the interface
    easily accessible by the user, by keeping the tabs to a specific size suitable
    for human fingers. When we add more than six controllers in a tab bar controller
    interface, by default the object provides an **Edit** button on top in the **More**
    tab, which allows the user to rearrange the order of controllers. If we want to
    exclude some controllers from this functionality, we have to remove it from the
    `CustomizableViewControllers` array.
  prefs: []
  type: TYPE_NORMAL
- en: Useful UITabBarController properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some more useful properties of the `UITabBarController` class are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewControllers:` It returns an array containing all the controllers that
    the tab controller holds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SelectedIndex:` It returns the zero-based index of the selected tab'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SelectedViewController:` It returns the currently selected controller'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note on tab bar interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although we can add whatever type of controllers we want in a `UITabBarController`,
    we must not add a `UITabBarController` in another controller, such as a `UINavigationController`.
    We can, however, add a `UINavigationController` in a `UITabBarController`. This
    is because the tab bar interface is provided for implementing different controllers
    as different application modes and not hierarchical screens.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Using view controllers efficiently*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Combining different view controllers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a table controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to create and add a `UITableViewController`
    to a project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UITableViewController` is used to display a `UITableView`. A `UITableView`
    provides an interface for displaying data in a list form. Create a new iPhone
    empty project in MonoDevelop, and name it `TableControllerApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add an **iPhone View Controller** to the project, and name it `TableController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code in the `FinishedLaunching` method of the `AppDelegate`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Change the inheritance of the `TableController` class from `UIViewController`
    to `UITableViewController:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `TableController.xib` in Interface Builder, and delete its view by
    selecting it and pressing backspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag-and-drop a `UITableView` in its place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `UITableView` to show the outlet panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click-and-drag from the **New Referencing Outlet** to the **File's Owner** object,
    as shown in the following screenshot:![How to do it...](img/1468EXP_03_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select view from the small panel that will appear on the **File's Owner** object
    when you release the button. This connects the `UITableView` we have just added
    to the `view` outlet of the **File's Owner** object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we add a `UITableView` in an Interface Builder document, its view is displayed
    with some predefined data. The data only appears at design time and not at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The `UITableViewController` contains a view of the type `UITableView`. This
    view is responsible for displaying the data and can be customized in many ways.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from the `View` property, we can access the view of the `UITableViewController`
    through its `TableView` property. Both properties return the same object.
  prefs: []
  type: TYPE_NORMAL
- en: UITableViewController-specific property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `UITableViewController` has one more property: `ClearsSelectionOnViewWillAppear`.
    When it is set to `true`, the controller will clear the selected row automatically
    whenever the view appears.'
  prefs: []
  type: TYPE_NORMAL
- en: How to populate data with a `UITableView` is discussed thoroughly in [Chapter
    5](ch05.html "Chapter 5. Displaying Data"),Displaying Data.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Modal view controllers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 5](ch05.html "Chapter 5. Displaying Data"),Displaying Data:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Displaying data in a table*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modal view controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will discuss how to display view controllers modally.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **Modal view controller** is any controller that is presented above other
    views or controllers. The concept is similar to displaying a **WinForm** as a
    dialog, which takes control of the interface and does not allow access to other
    windows of the application, unless it is dismissed. Create a new iPhone empty
    project in MonoDevelop, and name it `ModalControllerApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add two views with controllers to the project, and name them `MainController`
    and `ModalController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `MainController.xib` file in Interface Builder, and add a button on
    its view with the title `Present`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create and connect the appropriate outlet for the button. Save the document
    and open the `ModalController.xib` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a button on its view with the title `Dismiss`, and create the appropriate
    outlet for it. Set its view's background color to something other than white.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save the document and enter the following code in the `MainController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, override the `ViewDidLoad()` method in the `ModalController` class,
    and enter the following code in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add code to display the main controller in the `FinishedLaunching()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap on the **Present** button and watch the modal controller present itself
    on top of the main controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap on the **Dismiss** button to hide it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each controller object has two methods that handle presenting and dismissing
    controllers modally. In our example, we call the `PresentModalViewController (UIViewController,
    bool)` method to present a controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Its first parameter represents the controller we want to display modally, and
    the second parameter determines if we want the presentation to be animated. To
    dismiss the controller, we call its `DismissModalViewControllerAnimated(bool)`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It accepts only one parameter that toggles the animation for the dismissal.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can define the type of animation for a modal view controller presentation
    with the controller''s `ModalTransitionStyle` property. Enter the following line
    of code before presenting the modal controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The main controller will flip to present the modal controller, giving the impression
    it is attached behind it.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a modal controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each controller that presents another controller modally provides access to
    its "child" controller through the `ModalController` property. If you need to
    access this property, make sure to do it before the `DismissModalViewControllerAnimated()`
    method is called.
  prefs: []
  type: TYPE_NORMAL
- en: How many modal controllers?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In theory, we can present an unlimited number of modal controllers. Of course,
    there are two restrictions on this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory is not unlimited:** View controllers consume memory, so the more view
    controllers we present, the worse performance we get.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Bad user experience:** Presenting many controllers modally discomforts the
    user with repetition.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Navigating through different view controllers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Providing controllers in tabs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 11](ch11.html "Chapter 11. Graphics and Animation"),Graphics and Animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Pushing view controllers with animation*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom view controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to create a subclass of `UIViewController`
    and use it to derive view controllers contained in an `XIB` file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task, we will see how to create a custom view controller that will act
    as a base controller, providing common functionality among its inheritors. The
    functionality we will add to our base controller to share with its inheritor classes
    will be to output the current touch position in the **Application Output** pad
    in MonoDevelop. Create a new iPhone empty project in MonoDevelop, and name it
    `CustomControllerApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add a new empty C# class in the project, and name it BaseController.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in the BaseController.cs file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, add an **iPhone View with Controller** file to the project, and name it
    `DerivedController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the class it inherits from `UIViewController` to `BaseController` in
    its class definition: `public partial class DerivedController : BaseController`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, add the derived controller''s view to the main window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click-and-drag the mouse pointer on the white surface, and watch MonoDevelop's
    **Application Output** pad displaying the current position of the pointer on the
    simulator's screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What we have done here is create a base controller class that can be used in
    multiple MonoTouch projects. The functionality we have added to this controller
    is to respond to user touches. Any controller that inherits it will inherit the
    same functionality. The code we have added to create the `BaseController` class
    is fairly simple. The constructor we implemented is merely a copy of the constructors
    that MonoDevelop creates in the class implementations when we add new view controllers
    in a project. There is only one slight modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This is the base constructor that will get called when we initialize the `DerivedController`
    class with the `new` keyword through our derived object's `DerivedController()`
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The derived controller can also be added to another `XIB` file and used directly
    in code through outlets.
  prefs: []
  type: TYPE_NORMAL
- en: Subclassing view controllers from XIBs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we would like to create a base controller that derives from a controller
    contained in an `XIB` file, the process is similar.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Loading a view with a controller*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using view controllers efficiently*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 2](ch02.html "Chapter 2. User Interface: Views"),User Interface: Views:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Adding and customizing views*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using view controllers efficiently
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn about the basic guidelines on efficient view controller
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open the project `TabControllerApp` we created in the recipe *Providing controllers
    in tabs* earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open the `MainController.xib` file in Interface Builder, and add a `UIButton`
    and a `UILabel`. Connect them with outlets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in the `MainController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap on the button in the **Main** tab to display the contents of our list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to the **Settings** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Hardware | Simulate Memory Warning** in the menu bar of the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Watch the output in the **Application Output** of MainDevelop, and switch back
    to the **Main** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This project does not provide any useful functionality. Its main purpose is
    to show how to use view controllers properly.
  prefs: []
  type: TYPE_NORMAL
- en: When iOS needs more memory to perform various operations, it issues memory warnings.
    When a memory warning occurs, all UI objects that are handled by a controller
    and are not in use are purged from memory to free up more memory.
  prefs: []
  type: TYPE_NORMAL
- en: The simulator provides a way for developers to recreate such a scenario, with
    the **Hardware | Simulate Memory Warning** action we selected from the menu bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we were in the **Settings** tab, the contents of the `MainController`
    were purged from memory. Inside the `DidReceiveMemoryWarning` method, we clean
    up any non-UI objects, which otherwise would remain in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in the `ViewDidUnload` method, we only need to release any UI objects
    that are retained by outlets. Note that this is where we unhook any handlers from
    events these objects might hold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When we select the **Main** tab again, the `ViewDidLoad` method will be called
    once more, after the view of the controller and all views and outlets it contains
    are loaded.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a memory warning occurs, instances of objects not related directly with
    the UI will remain in memory. In rare cases when there is not enough memory for
    specific tasks, the operating system might terminate our application if it occupies
    much of the available memory. To prevent such situations, we need to be careful
    to clean up all the objects and resources that are not needed, freeing up more
    memory for iOS.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Never access a controller''s view inside the `ViewDidUnload` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: That is because even when we request the return value of a view controller's
    `View` property, it causes the view to be loaded again, which in most cases will
    mean that no memory will be released.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Providing controllers in tabs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 1](ch01.html "Chapter 1. Development Tools"),Development Tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Interface builder*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 4](ch04.html "Chapter 4. Data Management"),'
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating files*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating an SQLite database*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining different view controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to display a `UINavigationController` within
    a `UITabBarController`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new iPhone empty project in MonoDevelop, and name it `CombinedControllerApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These are the steps to create this project:'
  prefs: []
  type: TYPE_NORMAL
- en: Add three iPhone View Controller files to the project, and name them `MainController,
    SettingsController`, and `AfterMainController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `UIButton` on the view of `MainController` in Interface Builder, and save
    the document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in the `MainController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following fields in the `AppDelegate` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code in the `FinishedLaunching` method of the `AppDelegate`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator. Tap the button in the `MainController`
    to push the `AfterMainController` in the navigation stack, and then switch between
    the **Main** and **Settings** tabs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The complete solution can be found in the `CombinedControllerApp` folder. What
    we have managed to do with this project is to provide a user interface with three
    different screens, which is not confusing for the user.
  prefs: []
  type: TYPE_NORMAL
- en: The tab bar contains two system-defined items, each representing a different
    view controller. We implemented the first item in the tab bar controller with
    a navigation controller. This way, we can provide more screens that are related
    with a specific part of our application (**Main** plus **AfterMain)**, leaving
    another part of our application directly accessible at any time **(Settings)**.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The way this project combines three different controllers (a `UITabBarController`,
    a `UINavigationController`, and a `UIViewController)` is perfectly acceptable.
    We could even replace the second tab item with another navigation controller to
    provide even more screens for another section of the application, or even add
    another tab item.
  prefs: []
  type: TYPE_NORMAL
- en: However, as stated in the *Providing controllers in tabs* recipe in this chapter,
    it would not be acceptable if we added a `UITabBarController` inside a `UINavigationController`.
    If we want to provide tab-like behavior inside a navigation controller, we should
    use its `UIToolbar` to do so.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Navigating through different view controllers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Providing controllers in tabs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a user interface for different devices*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iPad view controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will discuss the controllers that are only available to the
    iPad.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new iPad empty project, and name it `iPadControllerApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add two iPad views with controllers to the project, and name them `FirstController`
    and `SecondController`. Set different colors for their background views. In `SecondController`,
    also add a `UIToolbar` on the top of its view, and connect it to an outlet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following fields in the `AppDelegate` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The `UISplitViewController` class is available only to the iPad.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following code in the `FinishedLaunching` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the following nested class in `AppDelegate:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a property in the `SecondController` class, which returns the toolbar outlet
    that we created in *step 1:*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, compile and run the application in the simulator. Tap on the button
    in the toolbar to make the `FirstController` appear. The result should be similar
    to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/1468EXP_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The complete solution can be found in the `iPadControllerApp` folder. There
    are two iPad-specific controllers: `UISplitViewController` and `UIPopoverController`.
    Both of them are being used here, although the `UIPopoverController` is not used
    directly.'
  prefs: []
  type: TYPE_NORMAL
- en: The `UISplitViewController` helps to take full advantage of the iPad's larger
    screen. It provides a way of displaying two different views simultaneously on
    the same screen area. It does this by displaying one controller in full-screen
    in portrait orientation and the other controller smaller, in a popover. A **popover**
    is basically a view, which is displayed on top of other controllers (and their
    views), much like a modal view controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide access to both controllers in our project to the user, we have implemented
    a class that inherits from `UISpliViewControllerDelegate` and assigned it to our
    split controller inside the `FinishedLaunching()` method. The `Delegate` object
    we created overrides two methods. In the first method, we assign a button to the
    toolbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WillHideViewController()` method is executed whenever the `UISplitViewController`
    changes orientation from landscape to portrait, and its smaller controller is
    about to be hidden. So, to display it, we provide a button on the full-screen
    controller''s toolbar. When we tap on that button, the other controller will appear
    in a popover. When the orientation changes from portrait to landscape, the smaller
    controller appears besides the larger controller, without the need for a popover.
    So, we no longer need the button on the toolbar, hence we override the `WillShowViewController`
    to remove the button from the toolbar. We do this by assigning an empty `UIBarButtonItem[]`
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the device rotates, the interface does not respond automatically. To instruct
    the view controller to rotate its views, we override the `ShouldAutorotateToInterface
    Orientation(UIInterfaceOrientation)` method **in both the controllers of the split
    view controller:**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: iPad-specific controller usage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although all other controllers are available to both the iPhone and the iPad,
    these two controllers cannot be used on the iPhone. An exception will occur in
    this case.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating a user interface for different devices*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 9](ch09.html "Chapter 9. Interacting with Device Hardware"), Interacting
    with Device Hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Rotating the device*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a user interface for different devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to create an application that will support
    both the iPhone and the iPad.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new Universal empty project in MonoDevelop, and name it `UniversalApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add a new **iPhone View Controller** to the project, and name it `MainController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open it in Interface Builder, and add a label and an outlet for it on the view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the text `Running on an iPhone!` in the label.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the background of the view to a color other than white. Do the same for
    the label, and save the document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code in the `MainViewController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code in the `FinishedLaunching()` in the `AppDelegate` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the message of the label, stating that it is running on an iPhone. Terminate
    the execution in MonoDevelop, and click on **Run | Run With | iPad Simulator x.x**
    (where **x.x** is the corresponding iOS version installed on the system, here
    **5.0)** on the menu bar.![How to do it...](img/1468EXP_03_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the message stating that the application is running on an iPad!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we create a universal project in MonoDevelop, the basic difference lies
    in the application settings file `(Info.plist)` , where the application is declared
    to support both the iPhone and the iPad.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that we have added an **iPhone View with Controller** does not prevent
    us from using the same controller for both devices. Remember, all controllers
    are available for all devices, except for the ones discussed in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `ViewDidLoad` method, we check which device the application is running
    on, by checking the `UserInterfaceIdiom` property of the `UIDevice.CurrentDevice`
    static property, and provide a frame for the view that is sized to the iPad screen's
    dimensions {768, 1024}.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This takes care of sizing the views contained in a project according to which
    device the application is running on. But, it does not guarantee that all the
    controls will be sized and positioned correctly. To avoid cluttered user interfaces,
    we have to make sure to adjust the `Autosizing` property of our controls and views
    so that they will be resized and positioned correctly on different screens.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Using view controllers efficiently*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*iPad view controllers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 1](ch01.html "Chapter 1. Development Tools") , Development Tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating an iPhone project with MonoDevelop*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Interface builder*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
