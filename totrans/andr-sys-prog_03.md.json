["```kt\nLightsManager lights =  \nLocalServices.getService(LightsManager.class); \nmBacklight = lights.getLight(LightsManager.LIGHT_ID_BACKLIGHT); \nmBacklight.setBrightness(brightness); \n\n```", "```kt\nstruct hw_module_t; \nstruct hw_module_methods_t; \nstruct hw_device_t; \n\n```", "```kt\n/* \n * The emulator lights Module \n */ \nstruct hw_module_t HAL_MODULE_INFO_SYM = { \n    .tag = HARDWARE_MODULE_TAG, \n    .version_major = 1, \n    .version_minor = 0, \n    .id = LIGHTS_HARDWARE_MODULE_ID, \n    .name = \"Goldfish lights Module\", \n    .author = \"The Android Open Source Project\", \n    .methods = &lights_module_methods, \n}; \n\n```", "```kt\nstatic struct hw_module_methods_t lights_module_methods = { \n    .open =  open_lights, \n}; \n\n```", "```kt\n/** Open a new instance of a lights device using name */ \nstatic int \nopen_lights( const struct hw_module_t* module, char const *name, \nstruct hw_device_t **device ) \n{ \n    void* set_light; \n\n    if (0 == strcmp( LIGHT_ID_BACKLIGHT, name )) { \n      set_light = set_light_backlight; \n    } else if (0 == strcmp( LIGHT_ID_KEYBOARD, name )) { \n      set_light = set_light_keyboard; \n    } else if (0 == strcmp( LIGHT_ID_BUTTONS, name )) { \n      set_light = set_light_buttons; \n    } else if (0 == strcmp( LIGHT_ID_BATTERY, name )) { \n      set_light = set_light_battery; \n    } else if (0 == strcmp( LIGHT_ID_NOTIFICATIONS, name )) { \n      set_light = set_light_notifications; \n    } else if (0 == strcmp( LIGHT_ID_ATTENTION, name )) { \n       set_light = set_light_attention; \n    } else { \n        D( \"%s: %s light isn't supported yet.\", __FUNCTION__, name ); \n        return -EINVAL; \n    } \n\nstruct light_device_t *dev = \n    malloc( sizeof(struct light_device_t) ); \n    if (dev == NULL) { \n        return -EINVAL; \n    } \n    memset( dev, 0, sizeof(*dev) ); \n\n    dev->common.tag = HARDWARE_DEVICE_TAG; \n    dev->common.version = 0; \n    dev->common.module = (struct hw_module_t*)module; \n    dev->common.close = (int (*)(struct hw_device_t*))close_lights; \n    dev->set_light = set_light; \n\n    *device = (struct hw_device_t*)dev; \n    return 0; \n} \n\n```", "```kt\nstatic int \nset_light_backlight( struct light_device_t* dev, struct light_state_t const* state ) \n{ \n    /* Get Lights service. */ \n    intfd = qemud_channel_open( LIGHTS_SERVICE_NAME ); \n\n    if (fd < 0) { \n      ... \n\n    /* send backlight command to perform the backlight setting. */ \n    if (qemud_channel_send( fd, buffer, -1 ) < 0) { \n        E( \"%s: could not query lcd_backlight: %s\",\n        __FUNCTION__, strerror(errno) ); \n        close( fd ); \n        return -1; \n    } \n\n    close( fd ); \n    return 0; \n} \n\n```", "```kt\nLightsManager lights =  \nLocalServices.getService(LightsManager.class); \nmBacklight = lights.getLight(LightsManager.LIGHT_ID_BACKLIGHT); \n\n```", "```kt\n$ ls\nLight.java  LightsManager.java  LightsService.java  \n\n```", "```kt\npackage com.android.server.lights; \n\npublic abstract class LightsManager { \n    public static final intLIGHT_ID_BACKLIGHT = 0; \n    public static final intLIGHT_ID_KEYBOARD = 1; \n    public static final intLIGHT_ID_BUTTONS = 2; \n    public static final intLIGHT_ID_BATTERY = 3; \n    public static final intLIGHT_ID_NOTIFICATIONS = 4; \n    public static final intLIGHT_ID_ATTENTION = 5; \n    public static final intLIGHT_ID_BLUETOOTH = 6; \n    public static final intLIGHT_ID_WIFI = 7; \n    public static final intLIGHT_ID_COUNT = 8; \n\n    public abstract Light getLight(int id); \n} \n\n```", "```kt\npackage com.android.server.lights; \n\npublic abstract class Light { \n    public static final intLIGHT_FLASH_NONE = 0; \n    public static final intLIGHT_FLASH_TIMED = 1; \n    public static final intLIGHT_FLASH_HARDWARE = 2; \n\n    /** \n     * Light brightness is managed by a user setting. \n     */ \n    public static final intBRIGHTNESS_MODE_USER = 0; \n\n    /** \n     * Light brightness is managed by a light sensor. \n     */ \n    public static final intBRIGHTNESS_MODE_SENSOR = 1; \n\n    public abstract void setBrightness(int brightness); \n    public abstract void setBrightness(int brightness, \n    intbrightnessMode); \n    public abstract void setColor(int color); \n    public abstract void setFlashing(int color, int mode, intonMS, \n    intoffMS); \n    public abstract void pulse(); \n    public abstract void pulse(int color, intonMS); \n    public abstract void turnOff(); \n} \n\n```", "```kt\n... \nprivate final class LightImpl extends Light { \n\n        private LightImpl(int id) { \n            mId = id; \n        } \n\n        @Override \n        public void setBrightness(int brightness) { \n            setBrightness(brightness, BRIGHTNESS_MODE_USER); \n        } \n... \n\n```", "```kt\nprivate void setLightLocked(int color, int mode, int onMS, int offMS, int brightnessMode) { \n     if (color != mColor || mode != mMode || onMS != mOnMS\n     || offMS != mOffMS) { \n         if (DEBUG) Slog.v(TAG, \"setLight #\" + mId + \": color=#\" \n                 + Integer.toHexString(color)); \n         mColor = color; \n         mMode = mode; \n         mOnMS = onMS; \n         mOffMS = offMS; \n         Trace.traceBegin(Trace.TRACE_TAG_POWER, \n         \"setLight(\" + mId + \", 0x\" +  \n         Integer.toHexString(color) + \")\"); \n         try { \n setLight_native(mNativePointer, \n              mId, color, mode, onMS, offMS, \n              brightnessMode); \n         } finally { \n             Trace.traceEnd(Trace.TRACE_TAG_POWER); \n         } \n     } \n} \n\n```", "```kt\npublic LightsService(Context context) { \n    super(context); \n\n    mNativePointer = init_native(); \n\n    for (inti = 0; i<LightsManager.LIGHT_ID_COUNT; i++) { \n      mLights[i] = new LightImpl(i); \n    } \n} \n\n... \n\n@Override \nprotected void finalize() throws Throwable { \n finalize_native(mNativePointer); \n    super.finalize(); \n} \n\n... \n\nprivate static native long init_native(); \nprivate static native void finalize_native(long ptr); \n\nstatic native void setLight_native(long ptr, int light, int color, int mode, int onMS, int offMS, int brightnessMode); \n\n```", "```kt\nstatic jlong init_native(JNIEnv* /* env */, jobject /* clazz */) \n{ \n    int err; \n    hw_module_t* module; \n    Devices* devices; \n\n    devices = (Devices*)malloc(sizeof(Devices)); \n\n    err = hw_get_module(LIGHTS_HARDWARE_MODULE_ID,  \n        (hw_module_tconst**)&module); \n    if (err == 0) { \n        devices->lights[LIGHT_INDEX_BACKLIGHT] \n                = get_device(module, LIGHT_ID_BACKLIGHT); \n        devices->lights[LIGHT_INDEX_KEYBOARD] \n                = get_device(module, LIGHT_ID_KEYBOARD); \n        devices->lights[LIGHT_INDEX_BUTTONS] \n                = get_device(module, LIGHT_ID_BUTTONS); \n        devices->lights[LIGHT_INDEX_BATTERY] \n                = get_device(module, LIGHT_ID_BATTERY); \n        devices->lights[LIGHT_INDEX_NOTIFICATIONS] \n                = get_device(module, LIGHT_ID_NOTIFICATIONS); \n        devices->lights[LIGHT_INDEX_ATTENTION] \n                = get_device(module, LIGHT_ID_ATTENTION); \n        devices->lights[LIGHT_INDEX_BLUETOOTH] \n                = get_device(module, LIGHT_ID_BLUETOOTH); \n        devices->lights[LIGHT_INDEX_WIFI] \n                = get_device(module, LIGHT_ID_WIFI); \n    } else { \n        memset(devices, 0, sizeof(Devices)); \n    } \n\n    return (jlong)devices; \n} \n\n```", "```kt\nstatic light_device_t* get_device(hw_module_t* module, char const* name) \n{ \n    int err; \n    hw_device_t* device; \n    err = module->methods->open(module, name, &device); \n    if (err == 0) { \n        return (light_device_t*)device; \n    } else { \n        return NULL; \n    } \n} \n\n```", "```kt\nstatic void setLight_native(JNIEnv* /* env */, jobject /* clazz */, jlong ptr, jint light, jint colorARGB, jint flashMode, jint onMS, jint offMS, jint brightnessMode) \n{ \n    Devices* devices = (Devices*)ptr; \n    light_state_t state; \n\n    if (light < 0 || light >= LIGHT_COUNT || devices->lights[light] == \n    NULL) { \n        return ; \n    } \n\n    memset(&state, 0, sizeof(light_state_t)); \n    state.color = colorARGB; \n    state.flashMode = flashMode; \n    state.flashOnMS = onMS; \n    state.flashOffMS = offMS; \n    state.brightnessMode = brightnessMode; \n\n    { \n        ALOGD_IF_SLOW(50, \"Excessive delay setting light\"); \n        devices->lights[light]->set_light(devices->lights[light], \n        &state); \n    } \n} \n\n```", "```kt\nstatic void finalize_native(JNIEnv* /* env */, jobject /* clazz */, jlong ptr) \n{ \n    Devices* devices = (Devices*)ptr; \n    if (devices == NULL) { \n        return; \n    } \n\n    free(devices); \n} \n\n```", "```kt\n0x00 CMD_INT_DISABLE   Disable device. \n0x01 CMD_INT_ENABLE    Enable device. \n0x02 CMD_WRITE_BUFFER  Write buffer from kernel to device. \n0x03 CMD_READ_BUFFER   Read buffer from device to kernel. \n\n```", "```kt\n$ git clone https://android.googlesource.com/kernel/goldfish.git \n$ cd goldfish \n$ git checkout -b android-goldfish-3.10 origin/android-goldfish-3.10 \n$ make i386_ranchu_defconfig \n$ make \n\n```", "```kt\nstatic ssize_t goldfish_pipe_read_write(struct file *filp, char __user *buffer, size_t bufflen, int is_write) \n{ \n... \n    /* Now, try to transfer the bytes in the current page */ \n    spin_lock_irqsave(&dev->lock, irq_flags); \n    if (access_with_param(dev, is_write ? CMD_WRITE_BUFFER : \n    CMD_READ_BUFFER, xaddr, avail, pipe, &status)) { \n      writel((u32)(u64)pipe, dev->base + PIPE_REG_CHANNEL); \n#ifdef CONFIG_64BIT \n    writel((u32)((u64)pipe >> 32), dev->base + PIPE_REG_CHANNEL_HIGH); \n#endif \n    writel(avail, dev->base + PIPE_REG_SIZE); \n    writel(xaddr, dev->base + PIPE_REG_ADDRESS); \n#ifdef CONFIG_64BIT \n    writel((u32)((u64)xaddr>> 32), dev->base + PIPE_REG_ADDRESS_HIGH); \n#endif \n    writel(is_write ? CMD_WRITE_BUFFER : CMD_READ_BUFFER, \n      dev->base + PIPE_REG_COMMAND); \n    status = readl(dev->base + PIPE_REG_STATUS); \n} \n    spin_unlock_irqrestore(&dev->lock, irq_flags); \n\nif (status > 0 && !is_write) \n    set_page_dirty(page); \nput_page(page); \n... \n\n```", "```kt\nwrite_channel(<channel>) \nwrite_address(<buffer-address>) \nREG_SIZE    = <buffer-size> \nREG_CMD     = CMD_WRITE_BUFFER/CMD_READ_BUFFER \nstatus = REG_STATUS \n\n```", "```kt\n/* A value that will not be set by qemu emulator */ \n#define INITIAL_BATCH_RESULT (0xdeadbeaf) \nstatic int access_with_param(struct goldfish_pipe_dev *dev, const int cmd, unsigned long address, unsigned long avail, struct goldfish_pipe *pipe, int *status) \n{ \n   struct access_params *aps = dev->aps; \n\n   if (aps == NULL) \n         return -1; \n\n   aps->result = INITIAL_BATCH_RESULT; \n   aps->channel = (unsigned long)pipe; \n   aps->size = avail; \n   aps->address = address; \n   aps->cmd = cmd; \n   writel(cmd, dev->base + PIPE_REG_ACCESS_PARAMS); \n   /* \n    * If the aps->result has not changed, that means \n    * that the batch command failed \n    */ \n   if (aps->result == INITIAL_BATCH_RESULT) \n         return -1; \n   *status = aps->result; \n   return 0; \n} \n\n```"]