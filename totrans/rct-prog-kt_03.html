<html><head></head><body>
        

                            
                    <h1 class="header-title">Observables, Observers, and Subjects</h1>
                
            
            
                
<p>Observables and subscribers are at the base of reactive programming. We can say that they are the building blocks of reactive programming. In the previous two chapters, you already got a glimpse of <kbd>Observables</kbd> and <kbd>subject</kbd>. We observed on data with <kbd>observable</kbd>/<kbd>subject</kbd> instances; but that's not all we want; instead, we want to get all the actions and data changes reactively into the <kbd>observable</kbd> instances, making the application completely reactive. Also, while reading the previous chapters, you may have wondered how exactly does it operate? In this chapter, let's have a foundation of the pillars of reactive programming—<kbd>Observables</kbd>, <kbd>Observers</kbd>, and <kbd>subjects</kbd>:</p>
<ul>
<li>We will look into details of transforming various data sources to <kbd>observable</kbd> instances</li>
<li>You will learn about various types of <kbd>Observables</kbd></li>
<li>How to use <kbd>Observer</kbd> instances and subscriptions, and, lastly, <kbd>subjects</kbd> and their various implementations</li>
</ul>
<p class="mce-root">We will also learn about various factory methods of <kbd>Observable</kbd>.</p>
<p>There's a lot to understand in this chapter, so let's start with understanding <kbd>Observables</kbd> first.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Observables</h1>
                
            
            
                
<p>As we discussed earlier, in reactive programming, <kbd>Observable</kbd> has an underlying computation that produces values that can be consumed by a consumer (<kbd>Observer</kbd>). The most important thing here is that the consumer (<kbd>Observer</kbd>) doesn't pull values here; rather, <kbd>Observable</kbd> pushes the value to the consumer. So, we may say, an <kbd>Observable</kbd> is a push-based, composable iterator that emits its items through a series of operators to the final <kbd>Observer</kbd>, which finally consumes the items. Let's now break things sequentially to understand it better:</p>
<ul>
<li><kbd>Observer</kbd> subscribes to <kbd>Observable</kbd></li>
<li><kbd>Observable</kbd> starts emitting items that it has in it</li>
<li><kbd>Observer</kbd> reacts to whatever item <kbd>Observable</kbd> emits</li>
</ul>
<p>So, let's delve into how an <kbd>Observable</kbd> works through its events/methods, namely, <kbd>onNext</kbd>, <kbd>onComplete</kbd>, and <kbd>onError</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How Observable works</h1>
                
            
            
                
<p>As we stated earlier, an <kbd>Observable</kbd> has three most important events/methods; let's discuss them one by one:</p>
<ul>
<li><kbd>onNext</kbd>: <kbd>Observable</kbd> passes all items one by one to this method.</li>
<li><kbd>onComplete</kbd>: When all items have gone through the <kbd>onNext</kbd> method, <kbd>Observable</kbd> calls the <kbd>onComplete</kbd> method.</li>
<li><kbd>onError</kbd>: When <kbd>Observable</kbd> faces any error, it calls the <kbd>onError</kbd> method to deal with the error, if defined. Note that both <kbd>onError</kbd> and <kbd>onComplete</kbd> are terminal events, and if <kbd>onError</kbd> is called, then it would never call <kbd>onComplete</kbd> and vice versa.</li>
</ul>
<p>One thing to note here, the item in <kbd>Observable</kbd> that we are talking about can be anything; it is defined as <kbd>Observable&lt;T&gt;</kbd>, where <kbd>T</kbd> can be any class; even an <kbd>array</kbd>/<kbd>list</kbd> can be assigned as an <kbd>Observable</kbd>.</p>
<p class="mce-root CDPAlignLeft CDPAlign">Let's look at the following image:</p>
<div><img height="419" width="535" src="img/919f75a0-7206-483e-aaae-2f3cb15ccda7.png"/></div>
<p class="mce-root CDPAlignLeft CDPAlign">Let's look at this code example to understand it better:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
 
      val observer:Observer&lt;Any&gt; = object :Observer&lt;Any&gt;{//1 
        override fun onComplete() {//2 
            println("All Completed") 
        } 
 
        override fun onNext(item: Any) {//3 
            println("Next $item") 
        } 
 
        override fun onError(e: Throwable) {//4 
            println("Error Occured $e") 
        } 
 
        override fun onSubscribe(d: Disposable) {//5 
            println("Subscribed to $d") 
        } 
      } 
 
      val observable: Observable&lt;Any&gt; = listOf<br/>      ("One", 2, "Three", "Four", 4.5, "Five", 6.0f).toObservable() //6 
 
      observable.subscribe(observer)//7 
 
      val observableOnList: Observable&lt;List&lt;Any&gt;&gt; =<br/>      Observable.just(listOf("One", 2, "Three", "Four", <br/>      4.5, "Five", 6.0f), 
        listOf("List with Single Item"), 
        listOf(1,2,3,4,5,6))//8 
       observableOnList.subscribe(observer)//9 
   } </pre>
<p>In the preceding example, we declared the <kbd>observer</kbd> instance of <kbd>Any</kbd> datatype on comment <kbd>(1)</kbd>.</p>
<p>Here, we are taking benefit of the <kbd>Any</kbd> datatype. In Kotlin, every class is a child class of <kbd>Any</kbd>. Also, in Kotlin, everything is class and object; there is no separate primitive datatype.</p>
<p>The <kbd>observer</kbd> interface has four methods declared in it. The <kbd>onComplete()</kbd> method at comment <kbd>2</kbd> gets called when <kbd>Observable</kbd> is finished with all its items without any error. On comment <kbd>3</kbd>, we defined the <kbd>onNext(item: Any)</kbd> function, which will be called by <kbd>observable</kbd> for each item it has to emit. In that method, we will print the data to the console. On comment <kbd>4</kbd>, we defined the <kbd>onError(e: Throwable)</kbd> method, which will be called in case any error is faced by <kbd>Observable</kbd>. On comment <kbd>5</kbd>, the <kbd>onSubscribe(d: Disposable)</kbd> method will get called whenever <kbd>Observer</kbd> subscribes to <kbd>Observable</kbd>. On comment <kbd>6</kbd>, we will create <kbd>Observable</kbd> from a <kbd>list</kbd> (<kbd>val observable</kbd>) and subscribe to <kbd>observable</kbd> with <kbd>observer</kbd> on comment <kbd>7</kbd>. On comment <kbd>8</kbd>, we will create an observable (<kbd>val observableOnList</kbd>) again, this it holds lists as items.</p>
<p>The output of the program is as follows:</p>
<div><img src="img/a506ff43-49cd-4d87-8cae-33bd129186dc.png"/></div>
<p class="mce-root CDPAlignLeft CDPAlign">So, as you can see in the output, for the first subscription (comment <kbd>7</kbd>), when we subscribe to <kbd>Observable</kbd>, it calls the <kbd>onSubscribe</kbd> method, and then <kbd>Observable</kbd> starts emitting items as <kbd>Observer</kbd> starts receiving them on the <kbd>onNext</kbd> method and prints them. When all items are emitted from <kbd>Observable</kbd>, it calls the <kbd>onComplete</kbd> method to denote that all items have been successfully emitted. Same with the second one, except that, here, each item is a list.</p>
<p>So, as we gained some basis in <kbd>Observables</kbd>, let's learn various ways to create <kbd>Observable</kbd>—factory methods for <kbd>Observable</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding the Observable.create method</h1>
                
            
            
                
<p>You can create your own <kbd>Observable</kbd> with the <kbd>Observable.create</kbd> method at any time. This method takes an instance of the <kbd>ObservableEmitter&lt;T&gt;</kbd> interface as a source to observe on. So, let's consider this following example:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
 
      val observer: Observer&lt;String&gt; = object : Observer&lt;String&gt; { 
        override fun onComplete() { 
          println("All Completed") 
        } 
 
        override fun onNext(item: String) { 
          println("Next $item") 
        } 
 
        override fun onError(e: Throwable) { 
          println("Error Occured ${e.message}") 
        } 
 
        override fun onSubscribe(d: Disposable) { 
          println("New Subscription ") 
        } 
    }//Create Observer 
 
    val observable:Observable&lt;String&gt; = Observable.create&lt;String&gt; {//1 
      it.onNext("Emit 1") 
      it.onNext("Emit 2") 
      it.onNext("Emit 3") 
      it.onNext("Emit 4") 
      it.onComplete() 
    } 
 
    observable.subscribe(observer) 
 
    val observable2:Observable&lt;String&gt; = Observable.create&lt;String&gt; {//2 
      it.onNext("Emit 1") 
      it.onNext("Emit 2") 
      it.onNext("Emit 3") 
      it.onNext("Emit 4") 
      it.onError(Exception("My Custom Exception")) 
    } 
 
    observable2.subscribe(observer) 
   } </pre>
<p>First, we created an instance of the <kbd>Observer</kbd> interface as the previous example. I will not elaborate on <kbd>observer</kbd>, as we have already seen an overview in the previous example, and we will see it in detail later in this chapter.</p>
<p>On comment <kbd>1</kbd>, we created <kbd>Observable</kbd> with the <kbd>Observable.create</kbd> method; we emitted four <kbd>string</kbd> from <kbd>Observable</kbd> with the help of the <kbd>onNext</kbd> method, and then notified it is complete with the <kbd>onComplete</kbd> method.</p>
<p>On comment <kbd>2</kbd>, we did almost the same, except here instead of calling <kbd>onComplete</kbd>, we called <kbd>onError</kbd> with a custom <kbd>Exception</kbd>.</p>
<p>Here is the output of the program:</p>
<div><img src="img/d101c509-0137-4601-8a3e-8603ef587d0c.png"/></div>
<p>The <kbd>Observable.create</kbd> method is useful, especially when you are working with a custom data structure and want to have control over what values are getting emitted. You can also emit values to <kbd>Observer</kbd> from a different thread.</p>
<p>Note that the <kbd>Observable</kbd> contract (<a href="http://reactivex.io/documentation/contract.html">http://reactivex.io/documentation/contract.html</a>) states that <kbd>Observable</kbd> must issue notifications to <kbd>observers</kbd> serially (not in parallel). They may issue these notifications from different threads, but there must be a formal happens—before relationship between the notifications.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding the Observable.from methods</h1>
                
            
            
                
<p>The <kbd>Observable.from</kbd> methods are comparatively simpler than the <kbd>Observable.create</kbd> method. You can create <kbd>Observable</kbd> instances from nearly every Kotlin structure with the help of <kbd>from</kbd> methods.</p>
<p>Note that in RxKotlin 1, you will have <kbd>Observale.from</kbd> as a method; however, from RxKotlin 2.0 (as with RxJava2.0), operator overloads have been renamed with a postfix, such as <kbd>fromArray</kbd>, <kbd>fromIterable</kbd>, <kbd>fromFuture</kbd>, and so on.</p>
<p>So, let's take a look at this code:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
 
      val observer: Observer&lt;String&gt; = object : Observer&lt;String&gt; { 
        override fun onComplete() { 
          println("All Completed") 
        } 
 
        override fun onNext(item: String) { 
          println("Next $item") 
        } 
 
        override fun onError(e: Throwable) { 
          println("Error Occured ${e.message}") 
        } 
 
        override fun onSubscribe(d: Disposable) { 
          println("New Subscription ") 
        } 
      }//Create Observer 
 
      val list = listOf("String 1","String 2","String 3","String 4") 
      val observableFromIterable: Observable&lt;String&gt; =<br/>      Observable.fromIterable(list)//1 
      observableFromIterable.subscribe(observer) 
 
 
      val callable = object : Callable&lt;String&gt; { 
        override fun call(): String { 
          return "From Callable" 
        } 
      } 
      val observableFromCallable:Observable&lt;String&gt; =<br/>      Observable.fromCallable(callable)//2 
      observableFromCallable.subscribe(observer) 
 
      val future:Future&lt;String&gt; = object :Future&lt;String&gt; { 
        override fun get(): String = "Hello From Future" 
 
        override fun get(timeout: Long, unit: TimeUnit?): String  =<br/>        "Hello From Future" 
 
        override fun isDone(): Boolean = true 
 
        override fun isCancelled(): Boolean = false 
 
        override fun cancel(mayInterruptIfRunning: Boolean):<br/>        Boolean = false 
 
      } 
      val observableFromFuture:Observable&lt;String&gt; = <br/>      Observable.fromFuture(future)//3 
      observableFromFuture.subscribe(observer) 
    } </pre>
<p>On comment <kbd>1</kbd>, I used the <kbd>Observable.fromIterable</kbd> method to create <kbd>Observable</kbd> from an <kbd>Iterable</kbd> instance (here, <kbd>List</kbd>). On comment <kbd>2</kbd>, I called the <kbd>Observable.fromCallable</kbd> method to create <kbd>Observable</kbd> from a <kbd>Callable</kbd> instance, and same for comment <kbd>3</kbd>, where I called the <kbd>Observable.fromFuture</kbd> method to derive <kbd>Observable</kbd> from a <kbd>Future</kbd> instance.</p>
<p>Here is the output:</p>
<div><img src="img/e5892068-ffc1-4437-afeb-5ac26c1c8fb8.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding the toObservable extension function</h1>
                
            
            
                
<p>Thanks to the extension functions of Kotlin, you can turn any <kbd>Iterable</kbd> instance, such as <kbd>List</kbd>, to <kbd>Observable</kbd> without much effort; we have already used this method in <a href="0c50d487-2455-4385-b1c6-822eae0591bf.xhtml" target="_blank">Chapter 1</a>, <em>A Short Introduction to Reactive Programming</em>, however, take a look at this:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
 
      val observer: Observer&lt;String&gt; = object : Observer&lt;String&gt; { 
        override fun onComplete() { 
            println("All Completed") 
        } 
 
        override fun onNext(item: String) { 
            println("Next $item") 
        } 
 
        override fun onError(e: Throwable) { 
            println("Error Occured ${e.message}") 
        } 
 
        override fun onSubscribe(d: Disposable) { 
            println("New Subscription ") 
        } 
      }//Create Observer 
 
      val list:List&lt;String&gt; = listOf<br/>      ("String 1","String 2","String 3","String 4") 
 
      val observable:Observable&lt;String&gt; = list.toObservable() 
 
      observable.subscribe(observer) 
    } </pre>
<p>And the following is the output:</p>
<div><img src="img/355f9436-754f-4a24-bd20-0e71f7c5ac62.png"/></div>
<p class="mce-root CDPAlignLeft CDPAlign">So, aren't you curious to look into the <kbd>toObservable</kbd> method? Let's do it. You can find this method inside the <kbd>observable.kt</kbd> file provided with the <kbd>RxKotlin</kbd> package:</p>
<pre>    fun &lt;T : Any&gt; Iterator&lt;T&gt;.toObservable(): Observable&lt;T&gt; = <br/>    toIterable().toObservable() 
    fun &lt;T : Any&gt; Iterable&lt;T&gt;.toObservable(): Observable&lt;T&gt; = <br/>    Observable.fromIterable(this) 
    fun &lt;T : Any&gt; Sequence&lt;T&gt;.toObservable(): Observable&lt;T&gt; =<br/>    asIterable().toObservable() 
 
    fun &lt;T : Any&gt; Iterable&lt;Observable&lt;out T&gt;&gt;.merge(): Observable&lt;T&gt; = <br/>    Observable.merge(this.toObservable()) 
    fun &lt;T : Any&gt; Iterable&lt;Observable&lt;out T&gt;&gt;.mergeDelayError(): <br/>    Observable&lt;T&gt; = Observable.mergeDelayError(this.toObservable()) </pre>
<p>So, it basically uses the <kbd>Observable.from</kbd> method internally; thanks again to extension functions of Kotlin.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding the Observable.just method</h1>
                
            
            
                
<p>Another interesting factory method is <kbd>Observable.just</kbd>; this method creates <kbd>Observable</kbd> and adds the parameters passed to it as the only items of the <kbd>Observable</kbd>. Note that if you pass an <kbd>Iterable</kbd> instance to <kbd>Observable.just</kbd> as a single parameter, it will take the entire <kbd>list</kbd> as a single item, unlike <kbd>Observable.from</kbd>, where it will create items of <kbd>Observable</kbd> from each item in <kbd>Iterable</kbd>.</p>
<p>Here is what happens when you call <kbd>Observable.just</kbd>:</p>
<ul>
<li>You call <kbd>Observable.just</kbd> with parameters</li>
<li><kbd>Observable.just</kbd> will create <kbd>Observable</kbd></li>
<li>It will emit each of its parameters as the <kbd>onNext</kbd> notification</li>
<li>When all parameters are emitted successfully, it will emit the <kbd>onComplete</kbd> notification</li>
</ul>
<p>Let's look at this code example to understand it better:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val observer: Observer&lt;Any&gt; = object : Observer&lt;Any&gt; { 
        override fun onComplete() { 
            println("All Completed") 
        } 
 
        override fun onNext(item: Any) { 
            println("Next $item") 
        } 
 
        override fun onError(e: Throwable) { 
            println("Error Occured ${e.message}") 
        } 
 
        override fun onSubscribe(d: Disposable) { 
            println("New Subscription ") 
        } 
       }//Create Observer 
 
       Observable.just("A String").subscribe(observer) 
       Observable.just(54).subscribe(observer) 
       Observable.just(listOf("String 1","String 2","String 3",<br/>       "String 4")).subscribe(observer) 
       Observable.just(mapOf(Pair("Key 1","Value 1"),Pair<br/>       ("Key 2","Value 2"),Pair("Key 3","Value<br/>       3"))).subscribe(observer) 
       Observable.just(arrayListOf(1,2,3,4,5,6)).subscribe(observer) 
       Observable.just("String 1","String 2",<br/>       "String 3").subscribe(observer)//1 
      } </pre>
<p>And here is the output:</p>
<div><img src="img/97067b1c-8d93-46a3-9404-c19a85540637.png"/></div>
<p>As you can see in the output, lists and maps are also treated as a single item, but look at comment <kbd>1</kbd> in the code where I passed three strings as parameters of the <kbd>Observable.just</kbd> method. <kbd>Observable.just</kbd> took each of the parameters as a separate item and emitted them accordingly (see the output).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Other Observable factory methods</h1>
                
            
            
                
<p>Before moving forward with <kbd>Observer</kbd>, subscribing, unsubscribing, and <kbd>Subjects</kbd>, let's try our hands on a few other factory methods of <kbd>Observable</kbd>.</p>
<p>So, let's look at this code first, and then we will try to learn it line by line:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val observer: Observer&lt;Any&gt; = object : Observer&lt;Any&gt; { 
        override fun onComplete() { 
            println("All Completed") 
        } 
 
        override fun onNext(item: Any) { 
            println("Next $item") 
        } 
 
        override fun onError(e: Throwable) { 
            println("Error Occured ${e.message}") 
        } 
 
        override fun onSubscribe(d: Disposable) { 
            println("New Subscription ") 
        } 
      }//Create Observer 
 
      Observable.range(1,10).subscribe(observer)//(1) 
      Observable.empty&lt;String&gt;().subscribe(observer)//(2) 
 
      runBlocking {    <br/>        Observable.interval(300,TimeUnit.MILLISECONDS).<br/>        subscribe(observer)//(3) 
        delay(900) 
        Observable.timer(400,TimeUnit.MILLISECONDS).<br/>        subscribe(observer)//(4) 
        delay(450) 
     }   
 
   } </pre>
<p>On comment <kbd>(1)</kbd>, we created <kbd>Observable</kbd> with the <kbd>Observable.range()</kbd> factory method. This method creates an <kbd>Observable</kbd> and emits integers with the supplied <kbd>start</kbd> parameter until it emits a number of integers as per the <kbd>count</kbd> parameter.</p>
<p>On comment <kbd>(2)</kbd>, we created <kbd>Observable</kbd> with the <kbd>Observable.empty()</kbd> method. This method creates <kbd>Observable</kbd> and emits <kbd>onComplete()</kbd> right away, without emitting any items with <kbd>onNext()</kbd>.</p>
<p>On comment <kbd>(3)</kbd> and comment <kbd>(4)</kbd>, we used two interesting <kbd>Observable</kbd> factory methods. The method on comment <kbd>(3)</kbd>, <kbd>Observable.interval()</kbd>, emits numbers sequentially starting from <kbd>0</kbd>, after each specified interval. It will continue emitting until you unsubscribe and until the program runs. Whereas, the method on comment <kbd>(4)</kbd>, <kbd>Observable.timer()</kbd>, will emit only once with <kbd>0</kbd> after the specified time elapsed.</p>
<p>Here is the output if you are curious:</p>
<div><img src="img/8d2d28f9-914d-4f1b-a1d8-ef3c70ee112e.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Subscribers - the Observer interface</h1>
                
            
            
                
<p>The <kbd>Subscriber</kbd> from RxKotlin 1.x,  essentially became an <kbd>Observer</kbd> in RxKotlin 2.x. There is an <kbd>Observer</kbd> interface in RxKotlin 1.x, but <kbd>Subscriber</kbd> is what you pass to the <kbd>subscribe()</kbd> method, and it implements <kbd>Observer</kbd>. However, In RxJava 2.x, <kbd>Subscriber</kbd> only exists when talking about <kbd>Flowables</kbd>, which we will cover in <a href="44e60d80-46e4-4b97-a0ad-4047a5d7bfb7.xhtml" target="_blank">Chapter 4</a>, <em>Introduction to Backpressure and Flowables</em>.</p>
<p>As you can see in the previous examples in this chapter, <kbd>Observer</kbd> is an interface with four methods in it—<kbd>onNext(item:T)</kbd>, <kbd>onError(error:Throwable)</kbd>, <kbd>onComplete()</kbd>, and <kbd>onSubscribe(d:Disposable)</kbd>. As stated earlier, when we connect <kbd>Observable</kbd> to <kbd>Observer</kbd>, it looks for these four methods in <kbd>Observer</kbd> and calls them. So, the following is a short description of the four methods:</p>
<ul>
<li><kbd>onNext</kbd>: <kbd>Observable</kbd> calls this method of <kbd>Observer</kbd> to pass each of the items one by one.</li>
<li><kbd>onComplete</kbd>: When <kbd>Observable</kbd> wants to denote, it's done with passing items to the <kbd>onNext</kbd> method, and it calls the <kbd>onComplete</kbd> method of <kbd>Observer</kbd>.</li>
<li><kbd>onError</kbd>: When <kbd>Observable</kbd> faces any error, it calls the <kbd>onError</kbd> method to deal with the error if defined in the <kbd>Observer</kbd>, otherwise, it throws the exception.</li>
<li><kbd>onSubscribe</kbd>: This method is called whenever a new <kbd>Observable</kbd> subscribes to the <kbd>Observer</kbd>.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Subscribing and disposing</h1>
                
            
            
                
<p>So, we have <kbd>Observable</kbd> (the thing that should be observed upon) and we have <kbd>Observer</kbd> (that should observe); now what? How to connect them? <kbd>Observable</kbd> and <kbd>Observer</kbd> are like an input device (be it keyboard or mouse) and the computer, we need something to connect them (even wireless input devices have some connectivity channels, be it Bluetooth or Wi-Fi).</p>
<p>The <kbd>subscribe</kbd> operator serves the purpose of the media by connecting an <kbd>Observable</kbd> to <kbd>Observer</kbd>. We can pass one to three methods (<kbd>onNext</kbd>, <kbd>onComplete</kbd>, <kbd>onError</kbd>) to the <kbd>subscribe</kbd> operator, or we can pass an instance of the <kbd>Observer</kbd> interface to the <kbd>subscribe</kbd> operator to get the <kbd>Observable</kbd> connected with an <kbd>Observer</kbd>.</p>
<p>So, let's take a look at the following example now:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val observable:Observable&lt;Int&gt; = Observable.range(1,5)//1 
 
      observable.subscribe({//2 
        //onNext method 
        println("Next $it") 
      },{ 
        //onError Method 
        println("Error ${it.message}") 
      },{ 
        //onComplete Method 
        println("Done") 
     }) 
 
     val observer: Observer&lt;Int&gt; = object : Observer&lt;Int&gt; {//3 
        override fun onComplete() { 
          println("All Completed") 
        } 
 
        override fun onNext(item: Int) { 
          println("Next $item") 
        } 
 
        override fun onError(e: Throwable) { 
          println("Error Occurred ${e.message}") 
        } 
 
        override fun onSubscribe(d: Disposable) { 
          println("New Subscription ") 
        } 
    } 
 
    observable.subscribe(observer) 
  } </pre>
<p>In this example, we have created <kbd>Observable</kbd> instance (on comment <kbd>1</kbd>) and used it twice with different overload <kbd>subscribe</kbd> operators. On comment <kbd>2</kbd>, we have passed three methods as arguments to the <kbd>subscribe</kbd> method. The first parameter is the <kbd>onNext</kbd> method, the second one is the <kbd>onError</kbd> method, and last, <kbd>onComplete</kbd>. On comment <kbd>2</kbd>, we have passed an instance of the <kbd>Observer</kbd> interface.</p>
<p>The output can be easily predicted as follows:</p>
<div><img height="304" width="416" src="img/14269583-2a72-4485-acb0-aa6c06611a2b.jpg"/></div>
<p class="mce-root CDPAlignLeft CDPAlign">So, we have got the concepts of subscribing, and we can do it now. What if you want to stop the emissions after some period of subscription? There must be a way, right? So let's inspect this.</p>
<p>Remember the <kbd>onSubscribe</kbd> method of <kbd>Observer</kbd>? There was a parameter on that method that we have not talked about yet. While you <kbd>subscribe</kbd>, if you pass the methods instead of the <kbd>Observer</kbd> instance, then the <kbd>subscribe</kbd> operator will return an instance of <kbd>Disposable</kbd>, or if you use an instance of <kbd>Observer</kbd>, then you will get the instance of <kbd>Disposable</kbd> in the parameter of the <kbd>onSubscribe</kbd> method.</p>
<p>You can use the instance of the <kbd>Disposable</kbd> interface to stop emissions at any given time. Let's take a look at this example:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      runBlocking { 
        val observale:Observable&lt;Long&gt; = <br/>        Observable.interval(100,TimeUnit.MILLISECONDS)//1 
        val observer:Observer&lt;Long&gt; = object : Observer&lt;Long&gt; { 
          lateinit var disposable:Disposable//2 
 
          override fun onSubscribe(d: Disposable) { 
            disposable = d//3 
          } 
 
          override fun onNext(item: Long) { 
            println("Received $item") 
            if(item&gt;=10 &amp;&amp; !disposable.isDisposed) {//4 
              disposable.dispose()//5 
              println("Disposed") 
            } 
          } 
 
          override fun onError(e: Throwable) { 
            println("Error ${e.message}") 
          } 
 
          override fun onComplete() { 
            println("Complete") 
          } 
 
        } 
 
        observale.subscribe(observer) 
        delay(1500)//6 
     } 
    } </pre>
<p>I hope you remember the <kbd>Observable.interval</kbd> factory method, from just few pages ago in this chapter. This method takes two parameters describing the interval period and time unit, then, it prints integers sequentially, starting from <kbd>0</kbd>. <kbd>Observable</kbd> created with interval never completes and never stops until you stop them or the program stops execution. I thought it will be the perfect fit in this scenario, as here we want to stop the <kbd>Observable</kbd> midway.</p>
<p>So, in this example on comment <kbd>1</kbd>, we created an <kbd>Observable</kbd> with the <kbd>Observable.interval</kbd> factory method that will emit an integer after each <kbd>100</kbd> millisecond interval.</p>
<p>On comment <kbd>2</kbd>, I have declared a <kbd>lateinit var disposable</kbd> of type <kbd>Disposable</kbd> (<kbd>lateinit</kbd> means the variable will get initialized at a later point of time). On comment <kbd>3</kbd>, inside the <kbd>onSubscribe</kbd> method, we will assign the received parameter value to the <kbd>disposable</kbd> variable.</p>
<p>We intend to stop the execution after the sequence reaches <kbd>10</kbd>, that is, after <kbd>10</kbd> is emitted, the emission should be stopped immediately. To achieve that, we placed a check inside the <kbd>onNext</kbd> method, where we are checking if the value of the emitted item is equal to or greater than <kbd>10</kbd>, and if the emission is not already stopped (disposed), then we will dispose the emission (comment <kbd>5</kbd>).</p>
<p>Here is the output:</p>
<pre><strong>Received 0</strong>
<strong>Received 1</strong>
<strong>Received 2</strong>
<strong>Received 3</strong>
<strong>Received 4</strong>
<strong>Received 5</strong>
<strong>Received 6</strong>
<strong>Received 7</strong>
<strong>Received 8</strong>
<strong>Received 9</strong>
<strong>Received 10</strong>
<strong>Disposed</strong></pre>
<p>From the output, we can see that no integer got emitted after the <kbd>disposable.dispose()</kbd> method was called, although the execution waited 500 milliseconds more (100*10=1000 milliseconds to print sequence until <kbd>10</kbd>, and we called the <kbd>delay</kbd> method with 1500, thus 500 milliseconds after emitting <kbd>10</kbd>).</p>
<p>If you are curious to know the <kbd>Disposable</kbd> interface, then the following is the definition:</p>
<pre>    interface Disposable { 
      /** 
      * Dispose the resource, the operation should be idempotent. 
      */ 
      fun dispose() 
      /** 
      * Returns true if this resource has been disposed. 
      * @return true if this resource has been disposed 
      */ 
      val isDisposed:Boolean 
    } </pre>
<p>It has one property that denotes if the emission is already notified to stop (<kbd>disposed</kbd>) and a method to notify the emission to stop (<kbd>dispose</kbd>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Hot and Cold Observables</h1>
                
            
            
                
<p>So, as we have a grip on the basic concepts of <kbd>Observables</kbd> and <kbd>Observers</kbd> by now, let's move to something more interesting and advanced. The <kbd>Observables</kbd> that we are talking all about can be categorized into two categories based on their behavior. As the heading suggests, the two categories are <kbd>Hot Obervables</kbd> and <kbd>Cold Observable</kbd>. I can bet that, by now, you are craving to know more about <kbd>Hot</kbd> and <kbd>Cold Observables</kbd>, aren't you? So, let's dive into it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Cold Observables</h1>
                
            
            
                
<p>Take a careful look at all the previous examples. In all the examples, if you subscribe to the same <kbd>Observable</kbd> multiple times, you will get the emissions from the beginning for all the subscriptions. Don't believe it? Take a look at the following example:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val observable: Observable&lt;String&gt; = listOf<br/>      ("String 1","String 2","String 3","String 4").toObservable()//1 
 
      observable.subscribe({//2 
        println("Received $it") 
      },{ 
        println("Error ${it.message}") 
      },{ 
        println("Done") 
      }) 
 
      observable.subscribe({//3 
        println("Received $it") 
      },{ 
        println("Error ${it.message}") 
      },{ 
        println("Done") 
     }) 
    } </pre>
<p>Here is its output:</p>
<div><img src="img/ae275fc1-b456-4a0e-9530-2db959bff3fd.png"/></div>
<p class="mce-root CDPAlignLeft CDPAlign">The program is quite straightforward. Declared an <kbd>Observable</kbd> on comment <kbd>1</kbd>, subscribed to the <kbd>Observable</kbd> twice—on comment <kbd>2</kbd> and <kbd>3</kbd>. Now, look at the output. For both the subscribe calls, you got the exact same emission from the first one to the last one.</p>
<p>Those <kbd>Observables</kbd>, which have this particular behavior, that is, emitting items from the beginning for each subscription, are called <kbd>Cold Observable</kbd>. To be more specific, <kbd>Cold Observables</kbd> start running upon subscriptions and <kbd>Cold Observable</kbd> starts pushing items after <kbd>subscribe</kbd> gets called, and pushes the same sequence of items on each subscription.</p>
<p>All the <kbd>Observable</kbd> factory methods we have used up until this chapter return <kbd>Cold Observables</kbd>. <kbd>Cold Observables</kbd> resemble data. When we are working with data, for example, say, while working with SQLite or Room database in Android, we rely more on <kbd>Cold Observables</kbd> than <kbd>Hot Observables</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Hot Observables</h1>
                
            
            
                
<p><kbd>Cold Observables</kbd> are passive, they don't emit anything until subscribe is called. <kbd>Hot Observables</kbd> are contrary to <kbd>Cold Observables</kbd>; it doesn't need subscriptions to start emission. While you can compare <kbd>Cold Observables</kbd> to CD/DVD recordings, <kbd>Hot Observables</kbd> are like TV channels—they continue broadcasting (emitting) their content, irrespective of whether anyone is watching (Observing) it or not.</p>
<p><kbd>Hot Observables</kbd> resemble events more than data. The events may carry data with them, but there is a time-sensitive component where <kbd>Observers</kbd> that subscribed lately can miss out previously emitted data. They are specifically useful for UI events while working with Android/JavaFX/Swing. They are also very useful in resembling server requests.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Introducing the ConnectableObservable object</h1>
                
            
            
                
<p>A great example of <kbd>Hot Observables</kbd> is <kbd>ConnectableObservable</kbd>. It is one of the most helpful forms of <kbd>Hot Observables</kbd> as well. It can turn any <kbd>Observable</kbd>, even a <kbd>Cold Observable</kbd>, into a <kbd>Hot Observable</kbd>. It doesn't start emitting on the <kbd>subscribe</kbd> call; instead, it gets activated after you call the <kbd>connect</kbd> method. You have to make the <kbd>subscribe</kbd> calls before calling <kbd>connect</kbd>; any <kbd>subscribe</kbd> calls after calling connect will miss the emissions fired previously.</p>
<p>Let's consider the following code snippet:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val connectableObservable = listOf<br/>      ("String 1","String 2","String 3","String 4","String<br/>      5").toObservable() 
      .publish()//1 
      connectableObservable.subscribe({ println<br/>      ("Subscription 1: $it") })//2 
      connectableObservable.map(String::reversed)//3 
      .subscribe({ println("Subscription 2 $it")})//4 
      connectableObservable.connect()//5 
      connectableObservable.subscribe({ println<br/>      ("Subscription 3: $it") })//6 //Will not receive emissions 
    } </pre>
<p>The main purpose of <kbd>ConnectableObservable</kbd> is for <kbd>Observables</kbd> with multiple subscriptions to connect all subscriptions of an <kbd>Observable</kbd> together so that they can react to a single push; contrary to <kbd>Cold Observables</kbd> that repeats operations for doing the push, and pushes separately for each subscription, thus repeating the cycle. <kbd>ConnectableObservable</kbd> connects all <kbd>subscriptions</kbd> (<kbd>Observers</kbd>) called before the <kbd>connect</kbd> method and relays a single push to all <kbd>Observers</kbd>, <kbd>Observers</kbd> then react to/process that push.</p>
<p>In the preceding example, we created <kbd>Observable</kbd> with the <kbd>toObservable()</kbd> method, then, on comment <kbd>1</kbd>, we used the <kbd>publish</kbd> operator to convert <kbd>Cold Observable</kbd> into <kbd>ConnectableObservable</kbd>.</p>
<p>On comment <kbd>2</kbd>, we subscribed to <kbd>connectableObservable</kbd>. On comment <kbd>3</kbd>, we used the <kbd>map</kbd> operator to reverse <kbd>String</kbd>, and, on comment <kbd>4</kbd>, we subscribed to the mapped <kbd>connectableObservable</kbd>.</p>
<p>On comment <kbd>5</kbd>, we called <kbd>connect</kbd> method, and emissions got started to both <kbd>Observers</kbd>.</p>
<p>Note that we used the <kbd>map</kbd> operator in this example on comment <kbd>3</kbd>. We will discuss the <kbd>map</kbd> operator in detail in <a href="e395e42a-afc0-4424-9d0f-2de06e19989d.xhtml" target="_blank">Chapter 5</a>, <em>Asynchronous Data Operators and Transformations</em>. However, here is the definition, if you are curious. The <kbd>map</kbd> operator applies a function of your choosing to each item emitted by the source <kbd>Observable</kbd>, and returns an <kbd>Observable</kbd> that emits the results of these function applications.</p>
<p>Here is the output:</p>
<div><img height="201" width="503" src="img/7e4d31f4-e707-4f13-9e93-0f2e7ee48dc0.png"/></div>
<p>Note that, as the output suggests, each emission goes to each <kbd>Observer</kbd> simultaneously, and they are processing data in an interleaved fashion.</p>
<p>This mechanism of emitting from <kbd>Observable</kbd> once and then relaying the emission to all <kbd>Subscriptions</kbd>/<kbd>Observers</kbd> is known as <strong>multicasting</strong>.</p>
<p>Also note that the <kbd>subscribe</kbd> call on comment <kbd>6</kbd>, after <kbd>connect</kbd>, has not received any emissions, as <kbd>ConnectableObservable</kbd> is hot, and any new subscriptions occurred after connect will miss out the emissions fired previously (between the call of the <kbd>connect</kbd> method and the new subscription, remember that, within a few milliseconds, computers can do a lot of tasks); in this case, it missed all the emissions.</p>
<p>The following piece of code is another example to make you understand it better:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val connectableObservable =  <br/>      Observable.interval(100,TimeUnit.MILLISECONDS) 
      .publish()//1 
      connectableObservable. 
      subscribe({ println("Subscription 1: $it") })//2 
      connectableObservable 
      .subscribe({ println("Subscription 2 $it")})//3 
      connectableObservable.connect()//4 
      runBlocking { delay(500) }//5 
 
      connectableObservable. 
      subscribe({ println("Subscription 3: $it") })//6 
      runBlocking { delay(500) }//7 
    } </pre>
<p>This example is almost the same as the previous one, just a few tweaks.</p>
<p>Here, we used the <kbd>Observable.interval</kbd> method to create <kbd>Observable</kbd>; the benefit is that, as it takes an interval before each emission, it will give some room to the subscription after connect to get a few emissions.</p>
<p>On comment <kbd>1</kbd>, we converted <kbd>Cold Observable</kbd> to <kbd>ConnectableObservable</kbd>, as with the previous one, and did two subscriptions and then connected, as in the previous example (comment <kbd>2</kbd>, <kbd>3</kbd>, <kbd>4</kbd>).</p>
<p>We called delay right after connect on comment <kbd>5</kbd>, then subscribed again on comment <kbd>6</kbd>, and again a delay on comment <kbd>7</kbd> to allow the <kbd>3</kbd><sup>rd</sup> subscription to print some data.</p>
<p>The following output will allow us to understand better:</p>
<div><img src="img/bcd8f60d-15e5-4168-b18b-6d90822b6a24.png"/></div>
<p>Go through the output carefully to note that the <kbd>3</kbd><sup>rd</sup> subscription received emissions from sequence <kbd>5</kbd>, and missed all previous ones (there were <kbd>5</kbd> emissions before the <kbd>3rd subscription</kbd>—500 millisecond delay/100 millisecond interval).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Subjects</h1>
                
            
            
                
<p>Another great way to implement <kbd>Hot Observables</kbd> is <kbd>Subject</kbd>. Basically, it is a combination of <kbd>Observable</kbd> and <kbd>Observer</kbd>, as it has many common behaviors to both <kbd>Observables</kbd> and <kbd>Observers</kbd>. Like <kbd>Hot Observables</kbd>, it maintains an internal <kbd>Observer</kbd> <kbd>list</kbd> and relays a single push to every <kbd>Observer</kbd> subscribed to it at the time of emission.</p>
<p>So, let's take a look at what <kbd>Subject</kbd> has to offer us. And why is it called a combination of <kbd>Observables</kbd> and <kbd>Observers</kbd>? Please refer to the following points:</p>
<ul>
<li>It has all the operators that <kbd>Observable</kbd> should have.</li>
<li>Like <kbd>Observer</kbd>, it can listen to any value emitted to it.</li>
<li>After <kbd>Subject</kbd> is completed/errored/unsubscribed, it cannot be reused.</li>
<li>The most interesting point is that it passes values through itself. As an explanation, if you pass a value with <kbd>onNext</kbd> to a <kbd>Subject</kbd> (<kbd>Observer</kbd>) side, it will come out of the <kbd>Observable</kbd> side of it.</li>
</ul>
<p>So, <kbd>Subject</kbd> is a combination of <kbd>Observable</kbd> and <kbd>Observer</kbd>. You have already seen the use of <kbd>Subject</kbd> in the previous chapters, but, to make things clearer, let's take a new example:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val observable = Observable.interval(100, <br/>      TimeUnit.MILLISECONDS)//1 
      val subject = PublishSubject.create&lt;Long&gt;()//2 
      observable.subscribe(subject)//3 
      subject.subscribe({//4 
        println("Received $it") 
    }) 
    runBlocking { delay(1100) }//5 
   } </pre>
<p>Let's check the output first, and then we will explain the code:</p>
<div><img src="img/5c44c2ba-d572-4d82-8192-fb39bc96079f.png"/></div>
<p class="mce-root CDPAlignLeft CDPAlign">Now, let's understand the code. In this program, we have used the good old <kbd>Observable.interval</kbd> method. So, on comment <kbd>1</kbd>, we again created an instance of <kbd>Observable</kbd> with <kbd>Observable.interval</kbd>, with a 100 millisecond interval.</p>
<p>On comment <kbd>2</kbd>, we created <kbd>Subject</kbd> with <kbd>PublishSubject.create()</kbd>.</p>
<p>There are many types of <kbd>Subject</kbd> available. <kbd>PublishSubject</kbd> is one of them. <kbd>PublishSubject</kbd> emits to an <kbd>observer</kbd> only those items that are emitted by the <kbd>Observable</kbd> sources subsequent to the time of the subscription.<br/>
We will discuss in detail about the various types of <kbd>Subject</kbd> in the next section in this chapter.</p>
<p>On comment <kbd>3</kbd>, we used the <kbd>Subject</kbd> instance just like <kbd>Observer</kbd>, to subscribe to the emissions by the <kbd>Observable</kbd> instance. On comment <kbd>4</kbd>, we used the <kbd>Subject</kbd> instance like an <kbd>Observable</kbd> and subscribed with lambda to listen to the emissions by the <kbd>Subject</kbd> instance.</p>
<p>You probably got used to it with the code in comment <kbd>5</kbd>; if not, then we used it to make the program wait for <kbd>1100</kbd> milliseconds so that we can see the outputs made by the interval program. You can think of the <kbd>delay</kbd> method as similar to the <kbd>sleep</kbd> method in Java, the only difference here is that you must use <kbd>delay</kbd> inside a <kbd>Coroutine context</kbd>, so, in order to use <kbd>delay</kbd> method, you have to specify and start a <kbd>Coroutine context</kbd>; this is not quite possible always. The <kbd>runBlocking</kbd> method is there to help you in that scenario; it mocks a <kbd>Coroutine context</kbd> inside the calling thread while blocking that thread until <kbd>runBlocking</kbd> completes executing all its code.</p>
<p>The <kbd>Subject</kbd> instance listens to the emissions by the <kbd>Observable</kbd> instance and then broadcasts those emissions to its <kbd>Observers</kbd>, very likely, to a TV Channel broadcasting a Film (from a CD/DVD recording).</p>
<p>You are probably thinking, what is the benefit of that? When I can directly <kbd>subscribe</kbd> and <kbd>Observer</kbd> to <kbd>Observable</kbd>, why should I use <kbd>PublishSubject</kbd> in between? To find the answers, let's modify this code a little bit in a way that will help us understand it better:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val observable = Observable.interval(100,<br/>      TimeUnit.MILLISECONDS)//1 
      val subject = PublishSubject.create&lt;Long&gt;()//2 
      observable.subscribe(subject)//3 
      subject.subscribe({//4 
        println("Subscription 1 Received $it") 
      }) 
      runBlocking { delay(1100) }//5 
      subject.subscribe({//6 
        println("Subscription 2 Received $it") 
      }) 
      runBlocking { delay(1100) }//7 
    }  </pre>
<p>Here, the code is almost the same until comment <kbd>5</kbd> (except on <kbd>Subscribe</kbd> on comment <kbd>3</kbd>, where I prepended <kbd>Subscription</kbd> <kbd>1</kbd> to the <kbd>String</kbd> output).</p>
<p>On comment <kbd>6</kbd>, we again subscribed to <kbd>subject</kbd>. As we are subscribing after <kbd>1100</kbd> milliseconds, it should receive emissions after the first 11 emissions. On comment <kbd>7</kbd>, we are again making the program wait by <kbd>1100</kbd> milliseconds.</p>
<p>Let's see the output:</p>
<pre><strong>Subscription 1 Received 0</strong>
<strong>Subscription 1 Received 1</strong>
<strong>Subscription 1 Received 2</strong>
<strong>Subscription 1 Received 3</strong>
<strong>Subscription 1 Received 4</strong>
<strong>Subscription 1 Received 5</strong>
<strong>Subscription 1 Received 6</strong>
<strong>Subscription 1 Received 7</strong>
<strong>Subscription 1 Received 8</strong>
<strong>Subscription 1 Received 9</strong>
<strong>Subscription 1 Received 10</strong>
<strong>Subscription 1 Received 11</strong>
<strong>Subscription 2 Received 11</strong>
<strong>Subscription 1 Received 12</strong>
<strong>Subscription 2 Received 12</strong>
<strong>Subscription 1 Received 13</strong>
<strong>Subscription 2 Received 13</strong>
<strong>Subscription 1 Received 14</strong>
<strong>Subscription 2 Received 14</strong>
<strong>Subscription 1 Received 15</strong>
<strong>Subscription 2 Received 15</strong>
<strong>Subscription 1 Received 16</strong>
<strong>Subscription 2 Received 16</strong>
<strong>Subscription 1 Received 17</strong>
<strong>Subscription 2 Received 17</strong>
<strong>Subscription 1 Received 18</strong>
<strong>Subscription 2 Received 18<br/></strong><strong>Subscription 1 Received 19</strong>
<strong>Subscription 2 Received 19</strong>
<strong>Subscription 1 Received 20</strong>
<strong>Subscription 2 Received 20</strong>
<strong>Subscription 1 Received 21</strong>
<strong>Subscription 2 Received 21</strong>  </pre>
<p>In the output, it is printing the second subscription from the <kbd>12</kbd><sup>th</sup> emission (sequence <kbd>11</kbd>). So, <kbd>Subject</kbd> doesn't replay the actions such as <kbd>Cold Observables</kbd>, it just relays the emission to all <kbd>Observers</kbd>, turning a <kbd>Cold Observable</kbd> into <kbd>Hot Oberservale</kbd> one.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Varieties of Subject</h1>
                
            
            
                
<p>As we mentioned earlier, there are a lot of varieties available for <kbd>Subject</kbd>s. As we have gained some grip in <kbd>Subject</kbd>, let's now dive into varieties of <kbd>Subject</kbd> to understand it better. So, these are some of the most useful and important varieties of <kbd>Subject</kbd>, which we will discuss here:</p>
<ul>
<li><kbd>AsyncSubject</kbd></li>
<li><kbd>PublishSubject</kbd></li>
<li><kbd>BehaviorSubject</kbd></li>
<li><kbd>ReplaySubject</kbd></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding AsyncSubject</h1>
                
            
            
                
<p><kbd>AsyncSubject</kbd> only emits the last value of the source observable (<kbd>Observable</kbd> it listens on), and the last emission only. To say things more clearly, <kbd>AsyncSubject</kbd> will emit the last value it got, and will emit it only one time.</p>
<p>This is a marble diagram for <kbd>AsyncSubject</kbd>, which has been taken from ReactiveX documentation (<a href="http://reactivex.io/documentation/subject.html">http://reactivex.io/documentation/subject.html</a>):</p>
<div><img height="280" width="442" src="img/beb3bc54-c9d7-4e3c-b25c-a102fcb273b3.png"/></div>
<p>Let's consider the following code example:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val observable = Observable.just(1,2,3,4)//1 
      val subject = AsyncSubject.create&lt;Int&gt;()//2 
      observable.subscribe(subject)//3 
      subject.subscribe({//4 
        //onNext 
        println("Received $it") 
      },{ 
        //onError 
        it.printStackTrace() 
      },{ 
        //onComplete 
        println("Complete") 
      }) 
      subject.onComplete()//5 
    } </pre>
<p>Here is the output:</p>
<pre><strong>Received 4</strong>
<strong>Complete</strong></pre>
<p>In this example, we created an example with <kbd>Observable.just</kbd>, with <kbd>4</kbd> integers (on comment <kbd>1</kbd>). Then, on comment <kbd>2</kbd>, we created an <kbd>AsyncSubject</kbd> example. After that, on comment <kbd>3</kbd> and <kbd>4</kbd>, like the previous example, we subscribed to the <kbd>observable instance</kbd> with <kbd>subject</kbd> and then subscribed to the <kbd>Subject</kbd> instance with lambda; only this time, we passed all the three methods—<kbd>onNext</kbd>, <kbd>onError</kbd>, and <kbd>onComplete</kbd>.</p>
<p>On comment <kbd>6</kbd>, we called <kbd>onComplete</kbd>.</p>
<p>As the output suggests, <kbd>Subject</kbd> only emitted the last value it got, that is, <kbd>4</kbd>.</p>
<p>On <kbd>Subject</kbd> instances, you can pass values directly with the <kbd>onNext</kbd> method, without subscribing to any <kbd>Observable</kbd>. Recall the examples in the previous chapters where we used <kbd>Subject</kbd> (<kbd>PublishSubject</kbd>); there, we only used <kbd>onNext</kbd> to pass the values. You can subscribe to another <kbd>Observable</kbd> with <kbd>Subject</kbd>, or pass values with <kbd>onNext</kbd>. Basically, when you subscribe to <kbd>Observable</kbd> with <kbd>Subject</kbd>, <kbd>Subject</kbd> calls its <kbd>onNext</kbd> internally upon <kbd>Observable</kbd>'s value emission.</p>
<p>Have doubts? Let's tweak the code a little. Instead of subscribing to an <kbd>Observable</kbd>, we will call <kbd>onNext</kbd> only to pass values, and will have another subscription. Here is the code, to do so:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val subject = AsyncSubject.create&lt;Int&gt;() 
      subject.onNext(1) 
      subject.onNext(2) 
      subject.onNext(3) 
      subject.onNext(4) 
      subject.subscribe({ 
        //onNext 
        println("S1 Received $it") 
      },{ 
        //onError 
        it.printStackTrace() 
      },{ 
        //onComplete 
        println("S1 Complete") 
      }) 
      subject.onNext(5) 
      subject.subscribe({ 
        //onNext 
        println("S2 Received $it") 
      },{ 
        //onError 
        it.printStackTrace() 
      },{ 
        //onComplete 
        println("S2 Complete") 
      }) 
      subject.onComplete() 
    } </pre>
<p>Here is the output:</p>
<div><img height="138" width="420" src="img/05ff90e1-c0fa-442e-9e9a-3daf83c4277d.jpg"/></div>
<p>Here, we passed all values via <kbd>onNext</kbd>; it only emitted the last value it got (<kbd>5</kbd>) to both of the subscriptions. Look carefully, the <kbd>1</kbd><sup>st</sup> subscription was before passing the last value. As <kbd>ConnectableObservable</kbd> starts emitting on call of <kbd>connect</kbd>, <kbd>AsyncSubject</kbd> emits its only value on call of <kbd>onComplete</kbd> only.</p>
<p>Note that as the outputs suggest, <kbd>AsyncSubject</kbd> doesn't in an interleave manner, that is, it will replay its action multiple times to emit the value to multiple <kbd>Observers</kbd>, although it is only one value.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding PublishSubject</h1>
                
            
            
                
<p><kbd>PublishSubject</kbd> emits all subsequent values that it got at the time of subscription, whether it got the value via the <kbd>onNext</kbd> method or through another subscription. We have already seen the application of <kbd>PublishSubject</kbd>, and it is the most commonly used <kbd>Subject</kbd> variant.</p>
<p>Here is a graphical representation of <kbd>PublishSubject</kbd> which has been taken from ReactiveX documentation (<a href="http://reactivex.io/documentation/subject.html">http://reactivex.io/documentation/subject.html</a>):</p>
<div><img height="285" width="450" src="img/0346f006-649d-4f52-a166-7be1b02c12f0.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding BehaviorSubject</h1>
                
            
            
                
<p>What if we combine <kbd>AsyncSubject</kbd> and <kbd>PublishSubject</kbd>? Or mix the benefits of both? <kbd>BehaviorSubject</kbd> emits the last item it got before the subscription and all the subsequent items at the time of subscription while working with multicasting, that is, it keeps an internal <kbd>list</kbd> of <kbd>Observers</kbd> and relays the same emit to all of its <kbd>Observers</kbd> without replaying.</p>
<p>Here is the graphical representation which has been taken from ReactiveX documentation (<a href="http://reactivex.io/documentation/subject.html">http://reactivex.io/documentation/subject.html</a>):</p>
<div><img height="293" width="463" src="img/f45c48ad-aaa8-4225-8572-7e9ef9f358fd.png"/></div>
<p>Let's modify the last example with <kbd>BehaviorSubject</kbd> and see what happens:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val subject = BehaviorSubject.create&lt;Int&gt;() 
      subject.onNext(1) 
      subject.onNext(2) 
      subject.onNext(3) 
      subject.onNext(4) 
      subject.subscribe({ 
        //onNext 
        println("S1 Received $it") 
      },{ 
        //onError 
        it.printStackTrace() 
      },{ 
        //onComplete 
        println("S1 Complete") 
      }) 
      subject.onNext(5) 
      subject.subscribe({ 
        //onNext 
        println("S2 Received $it") 
      },{ 
        //onError 
        it.printStackTrace() 
      },{ 
        //onComplete 
        println("S2 Complete") 
      }) 
      subject.onComplete() 
    } </pre>
<p>Here, I took the last example where we worked with <kbd>AsyncSubject</kbd>, and modified it with <kbd>BehaviorSubject</kbd>. So, let's see the output and understand <kbd>BehaviorSubject</kbd>:</p>
<pre><strong>S1 Received 4</strong>
<strong>S1 Received 5</strong>
<strong>S2 Received 5</strong>
<strong>S1 Complete</strong>
<strong>S2 Complete</strong></pre>
<p>While the <kbd>1</kbd><sup>st</sup> subscription gets <kbd>4</kbd> and <kbd>5</kbd>; <kbd>4</kbd> was emitted before its subscription and <kbd>5</kbd> after. For the <kbd>2</kbd><sup>nd</sup> subscription, it only got <kbd>5</kbd>, which was emitted before its subscription.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding ReplaySubject</h1>
                
            
            
                
<p>It is more like <kbd>Cold Observable</kbd>; it will replay all the items it got, regardless of when <kbd>Observer</kbd> subscribes.</p>
<p>Here is the graphical representation:</p>
<div><img height="280" width="442" src="img/c7550a0a-2d57-4c56-beca-ce76ce213749.png"/></div>
<p class="packt_figure">Image credit: <a href="http://reactivex.io/documentation/subject.html">http://reactivex.io/documentation/subject.html</a></p>
<p>Let's modify the previous program with <kbd>ReplaySubject</kbd>:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val subject = ReplaySubject.create&lt;Int&gt;() 
      subject.onNext(1) 
      subject.onNext(2) 
      subject.onNext(3) 
      subject.onNext(4) 
      subject.subscribe({ 
        //onNext 
        println("S1 Received $it") 
      },{ 
        //onError 
        it.printStackTrace() 
      },{ 
        //onComplete 
        println("S1 Complete") 
      }) 
      subject.onNext(5) 
      subject.subscribe({ 
        //onNext 
        println("S2 Received $it") 
      },{ 
        //onError 
        it.printStackTrace() 
      },{ 
        //onComplete 
        println("S2 Complete") 
      }) 
      subject.onComplete() 
    } </pre>
<p>And, here is the output:</p>
<pre><strong>S1 Received 1</strong>
<strong>S1 Received 2</strong>
<strong>S1 Received 3</strong>
<strong>S1 Received 4</strong>
<strong>S1 Received 5</strong>
<strong>S2 Received 1</strong>
<strong>S2 Received 2</strong>
<strong>S2 Received 3</strong>
<strong>S2 Received 4</strong>
<strong>S2 Received 5</strong>
<strong>S1 Complete</strong>
<strong>S2 Complete</strong>  </pre>
<p>It emitted all of the items for both the subscriptions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p class="mce-root CDPAlignLeft CDPAlign">In this chapter, we learned about <kbd>Observables</kbd> and <kbd>Observers</kbd> and how to use them. We worked with several examples to get our grips strong on them. We learned that there are two categories of <kbd>Observables</kbd>—<kbd>Hot Observables</kbd> and <kbd>Cold Observables</kbd>. We also learned about several <kbd>Subject</kbd> and its variant. Several <kbd>Subject</kbd> are basically a combination of <kbd>Observables</kbd> and many <kbd>Observer</kbd>.</p>
<p>While <kbd>Observables</kbd> provide us with great flexibilities and power, it too has some disadvantages, such as backpressure. Curious about it? Want to know more about the disadvantages of <kbd>Observables</kbd> and how to overcome them? Rush to the fourth chapter then.</p>


            

            
        
    </body></html>