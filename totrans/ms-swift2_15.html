<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch15"/>Chapter 15. Swift Formatting and Style Guide</h1></div></div></div><p>Throughout my development experience, every time I learned a new programming language, there was usually some mention of how code for that language should be written and formatted. Early in my development career (which was a long time ago), these recommendations were very basic formatting recommendations, such as how to indent your code, or just having one statement per line. It really wasn't until the last 10 to 12 years that I started to see complex and detailed formatting and style guides for different programming languages. Today, you will be hard pressed to find a development shop with more than two or three developers who did not have style/formatting guides for each language that they use. Even companies that do not create their own style guides generally refer back to some standard guide published by other companies, such as Google, Oracle, or Microsoft. These style guides help teams to write consistent and easy-to-maintain code.</p><div><div><div><div><h1 class="title"><a id="ch15lvl1sec90"/>What is a programming style guide?</h1></div></div></div><p>Coding styles are very <a class="indexterm" id="id653"/>personal and every developer has his or her own preferred style. These styles can vary from language to language, person to person, and also change over time. The personal nature of coding styles can make it difficult to have a consistent and readable code base when numerous individuals are contributing to the code.</p><p>While most developers might have their own preferred styles, the recommended or preferred style between languages can vary. As an example, in C#, when we name a method or function, it is preferred to use camel case with the first letter being capitalized. While in most languages, such as C, Objective-C, and Java, it is also recommended that we use camel case, but we should make the first letter lower case.</p><p>The best applications are coded properly, and by properly, we do not just mean that they function correctly but also that they are easy to maintain and the code is easy to read. It is hard for large projects and companies with a large number of developers to have code that is easy to maintain and read if every developer uses their own coding style. This is why companies and projects with multiple developers usually adopt programming style guides for each language that they use.</p><p>A programming<a class="indexterm" id="id654"/> style guide defines a set of rules and guidelines that a developer should follow while writing applications with a specific language within a project or company. These style guides can differ greatly between companies or projects and reflect how that company or project expects code to be written. These guides can also change over time. It is important to follow these style guides to maintain a consistent code base.</p><p>A lot of developers do not like the idea of being told how they should write code, and claim that as long as their code functions correctly, why should it matter how they format their code. I link this to a basketball team. If all of the players come in believing that how they want to play is correct and believe that the team is better when they are doing their own thing, then that team is probably going to lose the majority of their games. It is impossible for a basketball team (or any sports team, for that matter) to win the majority of their games unless they are working together. It is up to the coach to make sure that everyone is working together and executing the same game plan, just like it is up to the team leader of the development project to make sure all the developers are writing code according to the adopted style guide.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch15lvl1sec91"/>Your style guide</h1></div></div></div><p>The style guide that we<a class="indexterm" id="id655"/> define in this book is just a guide. It reflects the author's opinion on how Swift code should be written and is meant to be a good starting point for creating your own style guide. If you really like this guide and adopt it as it is, great. If there are parts that you do not agree with and you change them within your guide, that is great as well. The appropriate style for you and your team is the one that you and your team feel comfortable with, and it may or may not be different from the guide in this book. We should also point out that Swift is a very young language and people are still trying to figure out the appropriate style to use with Swift; therefore, what is recommended today maybe frowned upon tomorrow. Don't be afraid to adjust your style guide as needed.</p><p>One thing that is noticeable in the style guide within this chapter, and most good style guides, is that there is very little explanation about why each item is preferred or not preferred. Style guides should give enough details so that the reader understands the preferred and non-preferred methods for each item, but should also be small and compact to make it easy and quick to read. </p><p>If a developer has questions about why a particular method is preferred, he or she should bring that concern up to the development group.</p><p>With that in mind, let's get started with the guide.</p><div><div><div><div><h2 class="title"><a id="ch15lvl2sec129"/>Do not use semicolons at the end of statements</h2></div></div></div><p>Unlike a lot of languages, Swift does not require semicolons at the end of statements. Therefore, we<a class="indexterm" id="id656"/> should not use them. Let's take a look at the following code:</p><div><pre class="programlisting">//Preferred Method
var name = "Jon"
print(name)

//Non-preferred Method
var name = "Jon";
print(name);</pre></div></div><div><div><div><div><h2 class="title"><a id="ch15lvl2sec130"/>Do not use parentheses for conditional statements</h2></div></div></div><p>Unlike a lot <a class="indexterm" id="id657"/>of languages, the parentheses are not required around conditional statements; therefore, we should avoid using them unless they are needed for clarification. Let's take a look at the following code:</p><div><pre class="programlisting">//Preferred Method
if speed == 300000000 {
    print("Speed of light")
}

//Non-Preferred Method
if (speed == 300000000) {
    print("Speed of light")
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch15lvl2sec131"/>Naming</h2></div></div></div><p>We should always use<a class="indexterm" id="id658"/> descriptive names with camel case for classes, methods, variables, constants, and so on. Let's look at some general naming<a class="indexterm" id="id659"/> rules.</p><div><div><div><div><h3 class="title"><a id="ch15lvl3sec29"/>Classes</h3></div></div></div><p>Class names <a class="indexterm" id="id660"/>should have a descriptive name that describes what the class is for. The name should begin with a capital letter and be in camel case. Here are examples of proper names and non-proper names based on<a class="indexterm" id="id661"/> our style guide:</p><div><pre class="programlisting">// Proper Naming Convention
BaseballTeam
LaptopComputer
//Non-Proper Naming Convention
baseballTeam          //Starts with a lowercase letter
Laptop_Computer       //Uses an underscore</pre></div></div><div><div><div><div><h3 class="title"><a id="ch15lvl3sec30"/>Functions and methods</h3></div></div></div><p>Function names<a class="indexterm" id="id662"/> should be descriptive, describing<a class="indexterm" id="id663"/> the function or method. They should begin with a lowercase letter and be in camel case. Here are some examples of proper and non-proper names:</p><div><pre class="programlisting">//Proper Naming Convention
getCityName
playSound

//
//Non-Proper Naming Convention
get_city_name         //All lowercase and has an underscore
PlaySound             //Begins with an upper case letter</pre></div></div><div><div><div><div><h3 class="title"><a id="ch15lvl3sec31"/>Constants and variables</h3></div></div></div><p>Constants and variables<a class="indexterm" id="id664"/> should have a descriptive name. Generally, they begin with a lowercase letter and are in camel case. The only exception is<a class="indexterm" id="id665"/> when the constant is global; in that case, the name of the constant should contain all the uppercase characters with the words separated by underscores. I have seen numerous guides that frown on having all uppercase names, but I personally like them for constants in the global scope because it stands out that they are globally, not locally, scoped. Here are some examples of proper and non-proper names:</p><div><pre class="programlisting">//Proper Names
playerName
driveSize
PLAYERS_ON_A_TEAM    //Only for globally scoped constants

//Non-Proper Names
PlayerName           //Starts with uppercase letter
drive_size           //Has underscore in name</pre></div></div><div><div><div><div><h3 class="title"><a id="ch15lvl3sec32"/>Indenting</h3></div></div></div><p>The indenting width in Xcode, by default, is defined as four spaces, and the tab width is also defined as <a class="indexterm" id="id666"/>four spaces. We should leave this as the default. The following screenshot shows the indentation setting in Xcode:</p><div><img alt="Indenting" src="img/B05115_15_01.jpg"/></div><p>We should also add an extra blank line between functions/methods. We should also use a blank line to <a class="indexterm" id="id667"/>separate the functionality within a function or method. That being said, using many blank lines within a function or method might signify that we should break the function into multiple functions.</p></div></div><div><div><div><div><h2 class="title"><a id="ch15lvl2sec132"/>Comments</h2></div></div></div><p>We should use comments as needed to explain how and why our code is written. We should use block <a class="indexterm" id="id668"/>comments before classes and functions, while we should use the double slashes to comment code in line. Here is an example of how to write comments:</p><div><pre class="programlisting">/**
* This is a block comment that should be used
* to explain a class or function
*/
public class EmployeeClass {
  // This is an inline comment with double slashes
  var firstName = ""
  var lastName = ""

  /**
Use Block comments for functions

  :parm: paramName  use this tag for parameters
  :returns:  explain what is returned
  */
  func getFullName() -&gt; String {
    return firstName + " " + lastName
  }
}</pre></div><p>When we are<a class="indexterm" id="id669"/> commenting methods, we should also use the documentation tags that will generate documentation in Xcode, as shown in the preceding example. At a minimum, we should use the following tags if they apply to our method:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">:param</code>: This is used for parameters</li><li class="listitem" style="list-style-type: disc"><code class="literal">:return</code>: This is used for what is returned</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch15lvl2sec133"/>Using the self keyword</h2></div></div></div><p>Since Swift does<a class="indexterm" id="id670"/> not require us to use the <code class="literal">self</code> keyword when accessing properties or invoking methods of an object, we should avoid using it unless we need to distinguish between an object's property and local variables. Here is an example of when you should use the <code class="literal">self</code> keyword:</p><div><pre class="programlisting">public class EmployeeClass {
  var firstName = ""
  var lastName = ""
  func setName(firstName: String, lastName: String) {
    self.firstName = firstName
    self.lastName = lastName
  }
}</pre></div><p>Here is an example of when not to use the <code class="literal">self</code> keyword:</p><div><pre class="programlisting">public class EmployeeClass {
    var firstName = ""
    var lastName = ""
    func getFullName() -&gt; String {
        return self.firstName + " " + self.lastName
    }
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch15lvl2sec134"/>Types</h2></div></div></div><p>We should always<a class="indexterm" id="id671"/> use Swift native types when possible. If we remember, Swift offers bridging to Objective-C types, so even if we are using a Swift native type, we still have access to the full set of methods offered by Objective-C types. The following code shows the preferred and non-preferred ways to use native types:</p><div><pre class="programlisting">//Preferred way
let amount = 25.34
let amountStr = (amount as NSNumber).stringValue

//Non-preferred way
let amount: NSNumber = 25.34
let amountStr = amount.stringValue</pre></div></div><div><div><div><div><h2 class="title"><a id="ch15lvl2sec135"/>Constants and variables</h2></div></div></div><p>The difference between <a class="indexterm" id="id672"/>constants and variables is that the value of a constant never changes, whereas the value of a variable may change. Wherever possible, we should define constants rather than variables.</p><p>One of the easiest <a class="indexterm" id="id673"/>ways of doing this is to define everything as a constant, by default, and then change the definition to a variable only after you reach a point in your code that requires you to change it. With Swift 2, you will get a warning if you define a variable and then never change the value within your code.</p></div><div><div><div><div><h2 class="title"><a id="ch15lvl2sec136"/>Optional types</h2></div></div></div><p>Only use optional<a class="indexterm" id="id674"/> types when absolutely necessary. If there is no absolute need for a nil value to be assigned to a variable, we should not define it as <a class="indexterm" id="id675"/>an optional.</p><div><div><div><div><h3 class="title"><a id="ch15lvl3sec33"/>Use optional binding</h3></div></div></div><p>We should avoid <a class="indexterm" id="id676"/>forced unwrapping of optionals as there is rarely any need to do this. We should prefer optional binding or optional chaining for force unwrapping.</p><p>The following examples show the preferred and non-preferred methods where the <code class="literal">myOptional</code> variable is defined as an optional:</p><div><pre class="programlisting">//Preferred Method Optional Binding
if let value = myOptional {
  // code if myOptional is not nil
} else {
  // code if myOptional is nil
}

//Non-Preferred Method
if myOptional != nil {
  // code if myOptional is not nil
} else {
  //  code if myOptional is nil
}</pre></div><p>If there is more than one optional that we need to unwrap, we should include them on the same line rather than unwrapping them on separate lines if our business logic does not require separate paths if the unwrapping fails. The following examples show the preferred and non-preferred methods:</p><div><pre class="programlisting">//Preferred Method Optional Binding
if let value1 = myOptional1, value2 = myOptional2 {
  // code if myOptional1 and myOptional2 is not nil
} else {
  // code if myOptional1 and myOptional2 is nil
}

//Non-Preferred Method Optional Binding
if let value1 = myOptional1 {
    if let value2 = myOptional2 {
        // code if myOptional is not nil
    } else {
     // code if myOptional2 is nil
    }   
} else {
  // code if myOptional1 is nil
}</pre></div></div><div><div><div><div><h3 class="title"><a id="ch15lvl3sec34"/>Use optional chaining over optional binding for multiple unwrapping</h3></div></div></div><p>When we need to <a class="indexterm" id="id677"/>unwrap multiple layers, we should use optional chaining over multiple optional binding statements. The following example shows the preferred and non-preferred methods:</p><div><pre class="programlisting">//Preferred Method
if let color = jon.pet?.collar?.color {
    print("The color of the collar is \(color)")
} else {
    print("Cannot retrieve color")
}

//Non-Preferred Method
if let tmpPet = jon.pet, tmpCollar = tmpPet.collar  {
    print("The color of the collar is \(tmpCollar.color)")
} else {
    print("Cannot retrieve color")
}</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch15lvl2sec137"/>Use type inference</h2></div></div></div><p>Rather than defining the <a class="indexterm" id="id678"/>variable types, we should let Swift infer the type. The only time we should define the variable or constant type is when we are not giving it a value while defining it. Let's take a look at the following code:</p><div><pre class="programlisting">//Preferred method
var myVar = "String Type"  //Infers a String type
var myNum = 2.25           //Infers a Double type

//Non-Preferred method
var myVar: String = "String Type"
var myNum: Double = 2.25</pre></div></div><div><div><div><div><h2 class="title"><a id="ch15lvl2sec138"/>Use shorthand declaration for collections</h2></div></div></div><p>When declaring<a class="indexterm" id="id679"/> native Swift collection types, we should use the shorthand syntax, and unless absolutely necessary, we should initialize the collection. The following example shows the preferred and non-preferred methods:</p><div><pre class="programlisting">//Preferred Method
var myDictionary: [String: String] = [:]
var strArray: [String] = []
var strOptional: String?

//
//Non-Preferred Method
var myDictionary: Dictionary&lt;String,String&gt;
var strArray: Array&lt;String&gt;
var strOptional: Optional&lt;String&gt;</pre></div></div><div><div><div><div><h2 class="title"><a id="ch15lvl2sec139"/>Use for-in loops over for loops</h2></div></div></div><p>We should use <code class="literal">for-in</code> loops over <code class="literal">for</code> loops, especially when looping through collections. The<a class="indexterm" id="id680"/> following examples show the preferred and non-preferred methods:</p><div><pre class="programlisting">//Preferred Method
for str in strArray {
    print(str)
}
for num in 0...3 {
    print(num)
}

//
//Non-Preferred Method
for var i = 0; i &lt; strArray.count; i++ {
    print(strArray[i])
}

for var num = 0; num &lt;= 3; num++ {
    print(num)
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch15lvl2sec140"/>Use switch rather than multiple if statements</h2></div></div></div><p>Wherever possible, we<a class="indexterm" id="id681"/> should prefer to use a single <code class="literal">switch</code> statement over multiple <code class="literal">if</code> statements. The following example shows the preferred and non-preferred methods:</p><div><pre class="programlisting">//Preferred Method
let speed = 300000000
switch speed {
case 300000000:
    print("Speed of light")
case 340:
    print("Speed of sound")
default:
    print("Unknown speed")
}

//Non-preferred Method
let speed = 300000000
if speed == 300000000 {
    print("Speed of light")
} else if speed == 340 {
    print("Speed of sound")
} else {
    print("Unknown speed")
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch15lvl2sec141"/>Don't leave commented-out code in your application</h2></div></div></div><p>If we comment<a class="indexterm" id="id682"/> out a block of code while we attempt to replace it, once we are comfortable with the changes, we should remove the code that we commented out. Having large blocks of code commented out can make the code base look messy and harder to follow.</p></div><div><div><div><div><h2 class="title"><a id="ch15lvl2sec142"/>Grand Central Dispatch</h2></div></div></div><p>Grand Central Dispatch, which<a class="indexterm" id="id683"/> was discussed in <a class="link" href="ch14.html" title="Chapter 14. Concurrency and Parallelism in Swift">Chapter 14</a>, <em>Concurrency and Parallelism in Swift</em>, is a low-level C-based API that allows specific tasks to be queued up for execution and schedules the execution on any of the available processor cores.</p></div><div><div><div><div><h2 class="title"><a id="ch15lvl2sec143"/>Set the attribute in the dispatch_queue_create() function</h2></div></div></div><p>When using the<a class="indexterm" id="id684"/> <code class="literal">dispath_queue_create()</code> function to create a serial queue, we are able to set the <code class="literal">attribute</code> parameter to <code class="literal">nil</code> (which defines a serial queue); however, we should always set the attribute to <code class="literal">DISPATCH_QUEUE_SERIAL</code> or <code class="literal">DISPATCH_QUEUE_CONCURRENT</code> to explicitly define what type of queue we are creating. The following example shows the preferred and non-preferred methods:</p><div><pre class="programlisting">//Preferred method
let queue2 = dispatch_queue_create("squeue.hoffman.jon", DISPATCH_QUEUE_SERIAL)

//Non-Preferred method
let queue2 = dispatch_queue_create("squeue.hoffman.jon", nil)</pre></div></div><div><div><div><div><h2 class="title"><a id="ch15lvl2sec144"/>Use a reverse DNS name for the tag parameter of the dispatch_queue_create() function</h2></div></div></div><p>We are able to set<a class="indexterm" id="id685"/> the <code class="literal">tag</code> parameter of the <code class="literal">dispatch_queue_create</code> function to any valid string; however, for consistency and easy troubleshooting, we should always use a reverse DNS naming scheme. The following code shows the preferred and non-preferred methods:</p><div><pre class="programlisting">//Preferred method
let queue2 = dispatch_queue_create("squeue.hoffman.jon", DISPATCH_QUEUE_SERIAL)

let queue = dispatch_queue_create("cqueue.hoffman.jon", DISPATCH_QUEUE_CONCURRENT)

//Non-Preferred method
let queue2 = dispatch_queue_create("Serial_Queue", DISPATCH_QUEUE_SERIAL)

let queue = dispatch_queue_create("Concurrent_Queue", DISPATCH_QUEUE_CONCURRENT)</pre></div></div><div><div><div><div><h2 class="title"><a id="ch15lvl2sec145"/>Use dispatch_get_global_queue() over dispatch_queue_create()</h2></div></div></div><p>While it is perfectly <a class="indexterm" id="id686"/>acceptable to use the <code class="literal">dispatch_queue_create()</code> function to create a new concurrent queue, we should prefer to use the <code class="literal">dispatch_get_global_queue()</code> function to retrieve a concurrent queue that is already created for use. The following examples show the preferred and non-preferred methods:</p><div><pre class="programlisting">//Preferred Method
let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)

//Non-preferred Method
let queue = dispatch_queue_create("cqueue.hoffman.jon", DISPATCH_QUEUE_CONCURRENT)</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch15lvl1sec92"/>Summary</h1></div></div></div><p>When we are developing an application in a team environment, it is important to have a well-defined coding style that everyone on the team adheres to. This allows us to have a code base that is easy to read and maintain.</p><p>If a style guide remains static for too long, it means that it is probably not keeping up with the latest changes within the language. What is too long is different for each language. For example, with the C language, too long will be defined in years, since the language is very stable; however, with Swift, the language is so new and changes are coming pretty often, so too long can probably be defined as a couple of months.</p><p>It is recommended that we keep our style guides in a versioning control system so that we can refer to the older versions if need be. This allows us to pull the older versions of the style guide and refer back to them when we are looking at older code.</p></div></body></html>