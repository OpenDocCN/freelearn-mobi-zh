<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;OpenGL ES 3.0 on Android/iOS"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. OpenGL ES 3.0 on Android/iOS</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Programming shaders in OpenGL ES shading language 3.0</li><li class="listitem" style="list-style-type: disc">Loading and compiling a shader program</li><li class="listitem" style="list-style-type: disc">Linking a shader program</li><li class="listitem" style="list-style-type: disc">Checking errors in OpenGL ES 3.0</li><li class="listitem" style="list-style-type: disc">Using the per-vertex attribute to send data to a shader</li><li class="listitem" style="list-style-type: disc">Using uniform variables to send data to a shader</li><li class="listitem" style="list-style-type: disc">Programming OpenGL ES 3.0 Hello World Triangle</li><li class="listitem" style="list-style-type: disc">Using JNI on Android to communicate with C/C++</li><li class="listitem" style="list-style-type: disc">Developing an Android OpenGL ES 3.0 application</li><li class="listitem" style="list-style-type: disc">Developing an iOS OpenGL ES 3.0 application</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Introduction</h1></div></div></div><p>OpenGL ES 3.0 stands for Open Graphics Library for embedded systems version 3.0. It is a set of standard API specifications established by the Khronos Group. The Khronos Group is an <a id="id0" class="indexterm"/>association of members and organizations that are focused on producing open standards for royalty-free APIs. OpenGL ES 3.0 specifications were publicly released in August 2012. These specifications are backward compatible with OpenGL ES 2.0, which is a well-known de facto standard for embedded systems to render 2D and 3D graphics. Embedded operating systems such as Android, iOS, BlackBerry, Bada, Windows, and many others support OpenGL ES.</p><p>OpenGL ES 3D APIs are the stripped-down version of OpenGL, which is a cross-platform standard 3D API on a desktop environment for Linux, various flavors of UNIX, Mac OS, and Windows. This stripped-down version is mainly focused on providing the capabilities of 3D graphics as per embedded system requirements such as low-power consumption, limited processing capabilities, and small memory footprints.</p><p>The OpenGL ES 2.0/3.0 graphics library is shading-language compliant, unlike its predecessor 1.1. The major difference between OpenGL ES 1.1 and OpenGL ES 2.0/3.0 is the graphics pipeline architecture. The graphics pipeline framework for the former is known as a fixed function pipeline, and for the latter, it is a programmable pipeline. These frameworks are explained in the following table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>OpenGL ES version</p>
</th><th style="text-align: left" valign="bottom">
<p>Architecture pipeline type</p>
</th><th style="text-align: left" valign="bottom">
<p>Need shader</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>1.1</p>
</td><td style="text-align: left" valign="top">
<p>Fixed function pipeline</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>2.0 and 3.0</p>
</td><td style="text-align: left" valign="top">
<p>Programmable pipeline</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td></tr></tbody></table></div><p>A pipeline is a set of <a id="id1" class="indexterm"/>events that occur in a predefined fixed sequence, from the moment input data is given to the graphic engine to the output generated data for rendering the frame. A frame refers to an image produced as an output on the screen by the graphics engine.</p><p>Each frame in a fixed function pipeline architecture is generated by a fixed set of algorithms, calculations, and sequences of events. You can only specify what you want, but not how it will be calculated. For example, if you are interested in applying some light shading on your solid sphere model, then you will need to specify the light position, its intensity, material properties, and other similar attributes. The fixed pipeline uses these inputs and takes care of all the physics and mathematics required to generate the light shading. Therefore, you don't need to worry, as the how factor is fully abstracted. The good side of the fixed function pipeline is that it is very easy to understand and quick to program.</p><p>In contrast, with the <a id="id2" class="indexterm"/>programmable pipeline architecture, you not only need to specify what you want to achieve, but you also need to mention how to implement it. This pipeline also provides extraordinary capabilities through shaders. Shaders are the special programs that control your scene's geometry and shading appearance. For example, in order to achieve the same light-shading effect on solid sphere, you must know the basics of physics and mathematics in order to program the light-shading techniques. Since you are programming the behavior of light shading, you can fully control it. This opens up endless possibilities to create infinite shading effects. Shaders are super fast. They execute <a id="id3" class="indexterm"/>rendering in parallel-processing mode using <span class="strong"><strong>Graphics Processing Unit</strong></span> (<span class="strong"><strong>GPU</strong></span>).</p><p>Now, the question is if fixed function pipeline is doing all the light physics and mathematical abstraction, then why do we need to understand it for programmable pipelines? The reason is with fixed pipeline, we can only do finite graphics capabilities, and it cannot be used to produce realistic graphics effectively. However, the programmable pipeline opens endless possibilities and opportunities to produce state-of-art graphics rendering.</p><p>This chapter will provide OpenGL ES 3.0 development on Android and iOS. We will begin this chapter by understanding the basic programming of the OpenGL ES 3.0 with the help of a simple example to render a triangle on the screen. You will learn how to set up and create your first application on both platforms step by step.</p><p><span class="strong"><strong>Understanding EGL</strong></span>: The <a id="id4" class="indexterm"/>OpenGL ES APIs require the EGL as a prerequisite before they can effectively be used on the hardware devices. The EGL provides an interface between the OpenGL ES APIs and the underlying native windowing system. Different OS vendors have their own ways to manage the creation of drawing surfaces, communication with hardware devices, and other configurations to manage the rendering context. EGL provides an abstraction, how the underlying system needs to be implemented in a platform-independent way. The platform vendor's SDK provides an implementation of EGL through their own framework. These can be directly used in the application to accomplish the development task quickly. For example, the iOS provides EGL through the EAGL (<code class="literal">EAGLContext</code>) class in conjunction with <code class="literal">GLkit</code> to create <code class="literal">GLSurface</code>. On the Android platform, the <code class="literal">GLView</code> class provides interfaces for EGL through <code class="literal">GLView.EGLContextFactory</code> and <code class="literal">GLView.EGLConfigChooser</code>.</p><p>The EGL provides <a id="id5" class="indexterm"/>two important things to OpenGL ES APIs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Rendering context</strong></span>: This stores the data structure and important OpenGL ES states that are essentially required for rendering purpose</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Drawing surface</strong></span>: This provides the drawing surface to render primitives</li></ul></div><p>The following screenshot shows the programmable pipeline architecture of OpenGL ES 3.0:</p><div class="mediaobject"><img src="graphics/B02491_01_12.jpg" alt="Introduction"/></div><p>EGL works on top of the native windowing system, such as WGL (Windows), GLX, or X-Windows (Linux), or Mac OS X's Quartz. With EGL specifications, cross-platform development becomes easier.</p><p>EGL provides the following responsibilities:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Checking <a id="id6" class="indexterm"/>the available configuration to create rendering context of the device windowing system</li><li class="listitem" style="list-style-type: disc">Creating the OpenGL rendering surface for drawing</li><li class="listitem" style="list-style-type: disc">Compatibility and interfacing with other graphics APIs such as OpenVG, OpenAL, and so on</li><li class="listitem" style="list-style-type: disc">Managing resources such as texture mapping<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>You can refer <a id="id7" class="indexterm"/>to the following link for more information on EGL <a class="ulink" href="http://www.khronos.org/egl">http://www.khronos.org/egl</a>.</p></div></div></li></ul></div></div></div>
<div class="section" title="Programming shaders in OpenGL ES shading language 3.0"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Programming shaders in OpenGL ES shading language 3.0</h1></div></div></div><p>OpenGL ES <a id="id8" class="indexterm"/>shading language 3.0 (also called as <a id="id9" class="indexterm"/>GLSL) is a C-like language that allows us to writes shaders <a id="id10" class="indexterm"/>for programmable processors in the OpenGL ES processing pipeline. Shaders are the small programs that run on the GPU in parallel. Without these programs, it is impossible to write OpenGL ES 3.0 programs.</p><p>OpenGL ES 3.0 supports two type of shaders: vertex shader and fragment shader. Each shader has specific responsibilities. For example, the vertex shader is used to process geometric vertices; however, the fragment shader processes the pixels or fragment color information. More specially, the vertex shader processes the vertex information by applying 2D/3D transformation. The output of the vertex shader goes to the rasterizer where the fragments are produced. The fragments are processed by the fragment shader, which is responsible for coloring them.</p><p>The order of execution of the shaders is fixed; the vertex shader is always executed first, followed by the fragment shader. Each shader can share its processed data with the next stage in the pipeline. The GLSL facilitates user-defined variables such as C language; these variables are used for input and output purposes. There are also inbuilt variables that track the states in the shaders to make decisions while processing data in these shaders. For example, the fragment shader provides a state where the incoming fragment can be tested to see if it belongs to the front face or back face of a polygon.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Getting ready</h2></div></div></div><p>There are two types of processors in the OpenGL ES 3.0 processing pipeline to execute vertex shader and fragment shader executables; it is called programmable processing unit:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Vertex processor</strong></span>: The <a id="id11" class="indexterm"/>vertex processor is a programmable <a id="id12" class="indexterm"/>unit that operates on the incoming vertices and related data. It uses the vertex shader executable and run it on the <a id="id13" class="indexterm"/>vertex processor. The vertex shader needs to be programmed, compiled, and linked first in order to generate an executable, which can then be run on the vertex processor.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Fragment processor</strong></span>: This is another programmable unit in the OpenGL ES pipeline that <a id="id14" class="indexterm"/>operates on fragments and related data. The fragment processor uses the fragment shader executable to process fragment <a id="id15" class="indexterm"/>or pixel data. The fragment <a id="id16" class="indexterm"/>processor is responsible for calculating colors of the fragment. They cannot change the position of the fragments. They also cannot access neighboring fragments. However, they can discard the pixels. The computed color values from this shader are used to update the framebuffer memory and texture memory.</li></ul></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>How to do it...</h2></div></div></div><p>Here are the <a id="id17" class="indexterm"/>sample codes for vertex and fragment shaders:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Program the following vertex shader and store it into the <code class="literal">vertexShader</code> character type array variable:<div class="informalexample"><pre class="programlisting">#version 300 es             
in vec4     VertexPosition;     
in vec4     VertexColor;        
uniform float  RadianAngle;

out vec4     TriangleColor;     
mat2 rotation = mat2(cos(RadianAngle),sin(RadianAngle),
                    -sin(RadianAngle),cos(RadianAngle));
void main() {
  gl_Position = mat4(rotation)*VertexPosition;
  TriangleColor = VertexColor;
}</pre></div></li><li class="listitem">Program the following fragment shader and store it into another character array type variable called <code class="literal">fragmentShader</code>:<div class="informalexample"><pre class="programlisting">#version 300 es         
precision mediump float;
in vec4   TriangleColor;  
out vec4  FragColor;     
void main() {           
  FragColor = TriangleColor;
};</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>How it works...</h2></div></div></div><p>Like most of the languages, the shader program also starts its control from the <code class="literal">main()</code> function. In both shader programs, the first line, <code class="literal">#version 300 es</code>, specifies the GLES shading language version number, which is 3.0 in the present case. The vertex shader receives a per-vertex input variable <code class="literal">VertexPosition</code>. The data type of this variable is <code class="literal">vec4</code>, which is one of the inbuilt data types provided by OpenGL ES Shading Language. The <code class="literal">in</code> keyword in the beginning of the variable specifies that it is an incoming variable and it receives <a id="id18" class="indexterm"/>some data outside the scope of our current shader program. Similarly, the <code class="literal">out</code> keyword specifies that the variable is used to send some data value to the next stage of the shader. Similarly, the color information data is received in <code class="literal">VertexColor</code>. This color information is passed to <code class="literal">TriangleColor</code>, which sends this information to the fragment shader, and is the next stage of the processing pipeline.</p><p>The <code class="literal">RadianAngle</code> is a uniform type of variable that contains the rotation angle. This angle is used to calculate rotation matrix into <code class="literal">rotation</code>. Refer to following <span class="emphasis"><em>See also</em></span> section to get reference for the <code class="literal">per-vertex</code> attribute and <code class="literal">uniform</code> variables.</p><p>The input values <a id="id19" class="indexterm"/>received by <code class="literal">VertexPosition</code> are multiplied using the rotation matrix, which will rotate the geometry of our triangle. This value is assigned to <code class="literal">gl_Position</code>. The <code class="literal">gl_Position</code> is an inbuilt variable of the vertex shader. This variable is supposed to write the vertex position in the homogeneous form. This value can be used by any of the fixed functionality stages, such as primitive assembly, rasterization, culling, and so on. Refer to the <span class="emphasis"><em>The fixed function and programmable pipeline architecture</em></span> recipe in <a class="link" href="apa.html" title="Appendix A. Supplementary Information on OpenGL ES 3.0">Appendix</a>, <span class="emphasis"><em>Supplementary Information on OpenGL ES 3.0,</em></span> for more information on the fixed stages.</p><p>In the fragment shader, the precision keyword specifies the default precision of all floating types (and aggregates, such as <code class="literal">mat4</code> and <code class="literal">vec4</code>) to be <code class="literal">mediump</code>. The acceptable values of such declared types need to fall within the range specified by the declared precision. OpenGL ES Shading Language supports three types of the precision: <code class="literal">lowp</code>, <code class="literal">mediump</code> and <code class="literal">highp</code>. Specifying the precision in the fragment shader is compulsory. However, for vertex, if the precision is not specified, it is consider to be highest (<code class="literal">highp</code>).</p><p><code class="literal">FragColor</code> is an <code class="literal">out</code> <a id="id20" class="indexterm"/>variable, which sends the calculated color values for each fragment to the next stage. It accepts the value in the RGBA color format.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>There's more…</h2></div></div></div><p>As mentioned there are three types of precision qualifiers, the following table describes these:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Qualifier</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="bottom">
<p><code class="literal">highp</code></p>
</td><td style="text-align: left" valign="bottom">
<p>These variables provide the maximum range and precision. But they can cause operations to run more slowly on some implementations; generally, vertices have high precision.</p>
</td></tr><tr><td style="text-align: left" valign="bottom">
<p><code class="literal">lowp</code></p>
</td><td style="text-align: left" valign="bottom">
<p>These variables may typically be used to store high dynamic range colors and low precision geometry.</p>
</td></tr><tr><td style="text-align: left" valign="bottom">
<p><code class="literal">mediump</code></p>
</td><td style="text-align: left" valign="bottom">
<p>These variables may typically be used to store 8-bit color values.</p>
</td></tr></tbody></table></div><p>The range and precision of these precision qualifiers are shown here:</p><div class="mediaobject"><img src="graphics/B02491_01_18.jpg" alt="There's more…"/></div><p>The preceding image is taken from page 48 of <a class="ulink" href="https://www.khronos.org/registry/gles/specs/3.0/GLSL_ES_Specification_3.00.3.pdf">https://www.khronos.org/registry/gles/specs/3.0/GLSL_ES_Specification_3.00.3.pdf</a>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p><span class="strong"><strong>Downloading the example code</strong></span></p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Loading and compiling a shader program</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Using the per-vertex attribute to send data to a shader</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Using uniform variables to send data to a shader</em></span></li></ul></div></div></div>
<div class="section" title="Loading and compiling a shader program"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Loading and compiling a shader program</h1></div></div></div><p>The shader <a id="id21" class="indexterm"/>program created in the previous recipe needs to be loaded and <a id="id22" class="indexterm"/>compiled into a binary form. This recipe will be helpful in understanding the procedure of loading and compiling a shader program.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec18"/>Getting ready</h2></div></div></div><p>Compiling and linking a shader is necessary so that these programs are understandable and executable by the underlying graphics hardware/platform (that is, the vertex and fragment processors).</p><p>The following figure provides an overview of the complete process of creating a shader executable. The different number labels help us understand the order of flow in the build process. Each stage within the build process is marked with the respective OpenGL ES APIs responsible for it.</p><div class="mediaobject"><img src="graphics/B02491_01_13.jpg" alt="Getting ready"/></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec19"/> How to do it...</h2></div></div></div><p>In order to load <a id="id23" class="indexterm"/>and compile the shader source, use the following <a id="id24" class="indexterm"/>steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a <code class="literal">NativeTemplate.h</code>/<code class="literal">NativeTemplate.cpp</code> and define a function named <code class="literal">loadAndCompileShader</code> in it. Use the following code, and proceed to the next step for detailed information about this function:<div class="informalexample"><pre class="programlisting">GLuint loadAndCompileShader(GLenum shaderType, const char* sourceCode) {
     // Create the shader
  GLuint shader = glCreateShader(shaderType);
  if ( shader ) {
     // Pass the shader source code
     glShaderSource(shader, 1, &amp;sourceCode, NULL);

     // Compile the shader source code
     glCompileShader(shader);
     
     // Check the status of compilation
     GLint compiled = 0;
     glGetShaderiv(shader,GL_COMPILE_STATUS,&amp;compiled);
     if (!compiled) {
   
      // Get the info log for compilation failure
       GLint infoLen = 0;
       glGetShaderiv(shader,GL_INFO_LOG_LENGTH, &amp;infoLen);
       if (infoLen) {
          char* buf = (char*) malloc(infoLen);
          if (buf) {
            glGetShaderInfoLog(shader, infoLen, NULL, buf);
            printf("Could not compile shader %s:" buf);
            free(buf);
          }

      // Delete the shader program
          glDeleteShader(shader);
          shader = 0;
       }
    }
  }
  return shader;
}</pre></div><p>This function <a id="id25" class="indexterm"/>is responsible for loading and <a id="id26" class="indexterm"/>compiling a shader source. The argument <code class="literal">shaderType</code> accepts the type of shader that needs to be loaded and compiled; it can be <code class="literal">GL_VERTEX_SHADER</code> or <code class="literal">GL_FRAGMENT_SHADER</code>. The <code class="literal">sourceCode</code> specifies the source program of the corresponding shader.</p></li><li class="listitem">Create an empty shader object using the <code class="literal">glCreateShader</code> OpenGL ES 3.0 API. This shader object is responsible for loading the vertex or fragment source code depending on the specified <code class="literal">shaderType</code> parameter:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Syntax</strong></span>:<div class="informalexample"><pre class="programlisting">GLuint glCreateShader(  Glenum shaderType);</pre></div><p>This API returns a non-zero value if the object is successfully created. This value is used as a handle to reference this object. On failure, this function returns <code class="literal">0</code>. The <code class="literal">shaderType</code> argument specifies the type of the shader to be created. It must be either <code class="literal">GL_VERTEX_SHADER</code> or <code class="literal">GL_FRAGMENT_SHADER</code>:</p><div class="informalexample"><pre class="programlisting">// Create the shader object
GLuint shader = glCreateShader(shaderType);</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>Unlike in C++, where object creation is transparent, in OpenGL ES, the objects are created behind the curtains. You can access, use, and delete the objects as and when required. All the objects are identified by a unique identifier, which can be used for programming purposes.</p></div></div><p>The created <a id="id27" class="indexterm"/>empty shader object (<code class="literal">shader</code>) needs to be bound first with the shader source in order to compile it. This <a id="id28" class="indexterm"/>binding is performed by using the <code class="literal">glShaderSource</code> API:</p><div class="informalexample"><pre class="programlisting">// Load the shader source code
glShaderSource(shader, 1, &amp;sourceCode, NULL);</pre></div><p>The API sets the shader code string in the shader object, <code class="literal">shader</code>. The source string is simply copied in the shader object; it is not parsed or scanned.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Syntax</strong></span>:<div class="informalexample"><pre class="programlisting">void glShaderSource(GLuint shader, GLsizei count, const GLchar * const *string, const GLint *length);</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">shader</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the handle of the shader object whose source code needs to bind</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">count</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the number of elements in the string and length arrays</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">string</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies the array of pointers to strings containing source code that needs to be loaded</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">length</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies the array of string lengths</p>
</td></tr></tbody></table></div></li></ul></div><p>The count specifies the number of strings in the array. If the length array is <code class="literal">NULL</code>, this means that all the strings are null terminated. If the values inside in this array are non-zero, it specifies the length of the corresponding string. Any value less than <code class="literal">0</code> is assumed it to be a null-terminated string.</p></li><li class="listitem">Compile the shader using the <code class="literal">glCompileShader</code> API. It accepts a shader object handle shader:<div class="informalexample"><pre class="programlisting">       glCompileShader(shader);    // Compile the shader</pre></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Syntax</strong></span>:<div class="informalexample"><pre class="programlisting">void glCompileShader (GLuint shader);</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">shader</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the handle of the shader object that needs to be compiled</p>
</td></tr></tbody></table></div></li></ul></div></li><li class="listitem">The compilation <a id="id29" class="indexterm"/>status of the shader is stored as a state <a id="id30" class="indexterm"/>of the shader object. This state can be retrieved using the <code class="literal">glGetShaderiv</code> OpenGL ES API:<div class="informalexample"><pre class="programlisting">     GLint compiled = 0;    // Check compilation status
     glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;compiled);</pre></div><p>The <code class="literal">glGetShaderiv</code> API accepts the handle of the shader and <code class="literal">GL_COMPILE_STATUS</code> as an argument to check the status of the compilation. It retrieves the status in params. The params returns <code class="literal">GL_TRUE</code> if the last compilation was successful. Otherwise, it returns <code class="literal">GL_FALSE</code>.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Syntax</strong></span>:<div class="informalexample"><pre class="programlisting">void glGetShaderiv(GLuint shader, GLenum pname, GLint *params);</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">shader</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the handle of the shader object whose compilation status needs to be checked.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">pname</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies the object's state parameter. The symbolic names accepted are <code class="literal">GL_SHADER_TYPE</code>, <code class="literal">GL_DELETE_STATUS</code>, <code class="literal">GL_COMPILE_STATUS</code>, <code class="literal">GL_INFO_LOG_LENGTH</code>, and <code class="literal">GL_SHADER_SOURCE_LENGTH</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">params</code></p>
</td><td style="text-align: left" valign="top">
<p>This returns the requested object parameter state.</p>
</td></tr></tbody></table></div><p>In the case of compilation failure, the <code class="literal">glGetShaderiv</code> API can also be used to retrieve the information log from the OpenGL ES state machine by passing <code class="literal">GL_INFO_LOG_LENGTH</code> as the parameter. The <code class="literal">infoLen</code> returns the length of the information log. If the returned value is <code class="literal">0</code>, it means there is no information log. If the <code class="literal">infoLen</code> value is greater than <code class="literal">0</code>, then the information log message can be retrieved using <code class="literal">glGetShaderInfoLog</code>:</p><div class="informalexample"><pre class="programlisting">       if (!compiled) {      // Handle Errors
          GLint infoLen = 0; // Check error string length
          glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &amp;infoLen);
          . . . . .
       }</pre></div></li></ul></div></li><li class="listitem">Use <code class="literal">glGetShaderInfoLog</code> to <a id="id31" class="indexterm"/>get the error report:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Syntax</strong></span>:<div class="informalexample"><pre class="programlisting">void glGetShaderInfoLog(GLuint shader, GLsizei maxLength, GLsizei*length, GLchar* infoLog);</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">shader</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the handle of the shader object whose information log is required</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">maxLength</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the size of the character buffer to store the returned information log</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">length</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the length of the string returned by the information length</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">infoLog</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies array of characters</p>
</td></tr></tbody></table></div></li></ul></div></li><li class="listitem">The shader is deleted <a id="id32" class="indexterm"/>if the shader source cannot be compiled. Delete the shader object using the <code class="literal">glDeleteShader</code> API.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Syntax</strong></span>:<div class="informalexample"><pre class="programlisting">void glDeleteShader(GLuint shader);</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">shader</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the handle of the shader object that needs to be deleted</p>
</td></tr></tbody></table></div></li></ul></div></li><li class="listitem">Return the shader object ID if the shader is compiled successfully:<div class="informalexample"><pre class="programlisting">return shader; // Return the shader object ID</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec20"/>How it works...</h2></div></div></div><p>The <code class="literal">loadAndCompileShader</code> function first creates an empty shader object. This empty object is referenced by the <code class="literal">shader</code> variable. This object is bound with the source code of the corresponding shader. The source code is compiled through a shader object using the <code class="literal">glCompileShader</code> API. If the compilation is successful, the shader object handle is returned successfully. Otherwise, the shader object returns <code class="literal">0</code> and needs to be deleted explicitly using <code class="literal">glDeleteShader</code>. The status of the compilation can be checked using <code class="literal">glGetShaderiv</code> with <code class="literal">GL_COMPILE_STATUS</code>.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec21"/>There's more...</h2></div></div></div><p>In order to differentiate among various versions of OpenGL ES and GL Shading Language, it is useful to get this information from the current driver of your device. This will be helpful to make the program robust and manageable by avoiding errors caused by version upgrade or application being installed on older versions of OpenGL ES and GLSL. The <a id="id33" class="indexterm"/>other vital information can be queried from the current <a id="id34" class="indexterm"/>driver, such as the vendor, renderer, and available extensions supported by the device driver. This information can be queried using the <code class="literal">glGetString</code> API. This API accepts a symbolic constant and returns the queried system metrics in the string form. The <code class="literal">printGLString</code> wrapper function in our program helps in printing device metrics:</p><div class="informalexample"><pre class="programlisting">static void printGLString(const char *name, GLenum s) {
    printf("GL %s = %s\n", name, (const char *) glGetString(s));
}
// Print the OpenGL ES system metrics
void printOpenGLESInfo(){
   printGLString("Version",    GL_VERSION);
   printGLString("Vendor",    GL_VENDOR);
   printGLString("Renderer",    GL_RENDERER);
   printGLString("Extensions",    GL_EXTENSIONS);
   printGLString("GLSL version",  GL_SHADING_LANGUAGE_VERSION);
}</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec22"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Linking a shader program</em></span></li></ul></div></div></div>
<div class="section" title="Linking a shader program"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Linking a shader program</h1></div></div></div><p>Linking is a process of <a id="id35" class="indexterm"/>aggregating a set (vertex and fragment) of shaders into one program that maps to the entirety of the programmable phases of the OpenGL ES 3.0 graphics pipeline. The shaders are compiled using shader objects, as we created in the previous recipe. These objects are used to create special objects called program objects to link it to the OpenGL ES 3.0 pipeline. In this recipe, you will understand the shader linking process.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec23"/>How to do it...</h2></div></div></div><p>The following instructions provides a step-by-step procedure to link as shader:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new function, <code class="literal">linkShader</code>, in <code class="literal">NativeTemplate.cpp</code>.This will be the wrapper function to link a shader program to the OpenGL ES 3.0 pipeline. Follow these steps to understand this program in detail:<div class="informalexample"><pre class="programlisting">GLuint linkShader(GLuint vertShaderID,GLuint fragShaderID){
    if (!vertShaderID || !fragShaderID){ // Fails! return
   return 0; 
 }

   // Create an empty program object
    GLuint program = glCreateProgram();
    if (program) {
   // Attach vertex and fragment shader to it
      glAttachShader(program, vertShaderID);
      glAttachShader(program, fragShaderID);
        
   // Link the program
glLinkProgram(program);
      GLint linkStatus = GL_FALSE;
      glGetProgramiv(program, GL_LINK_STATUS, &amp;linkStatus);

      if (linkStatus != GL_TRUE) {
          GLint bufLength = 0;
          glGetProgramiv(program, GL_INFO_LOG_LENGTH,
          &amp;bufLength);
          if (bufLength) {
             char* buf = (char*) malloc(bufLength);
if(buf) { glGetProgramInfoLog(program,bufLength,NULL,buf);
          printf("Could not link program:\n%s\n", buf);
            free(buf);
            }
         }
          glDeleteProgram(program);
          program = 0;
      }
  }
  return program;
}</pre></div></li><li class="listitem">Create a program object with <code class="literal">glCreateProgram</code>. This API creates an empty program object using which the shader objects will be linked:<div class="informalexample"><pre class="programlisting">GLuint program = glCreateProgram(); //Create shader program</pre></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Syntax</strong></span>:<div class="informalexample"><pre class="programlisting">GLint glCreateProgram( void);</pre></div></li></ul></div></li><li class="listitem">Attach shader objects <a id="id36" class="indexterm"/>to the program object using the <code class="literal">glAttachShader</code> API. It is necessary to attach the shaders to the program object in order to create the program executable:<div class="informalexample"><pre class="programlisting"> // Attach the vertex and fragment shader
 glAttachShader(program, vertShaderID);
 glAttachShader(program, fragShaderID);</pre></div><p>Here is the syntax of the <code class="literal">glAttachShader</code> API:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Syntax</strong></span>:<div class="informalexample"><pre class="programlisting">void glAttachShader(GLuint program, GLuint shader);</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">program</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies the program object to which the shader object (shader) will be attached</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">shader</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies the program object that is to be attached</p>
</td></tr></tbody></table></div></li></ul></div></li><li class="listitem">The shader must be linked to the program in order to create the program executable. The linking process is performed using <code class="literal">glLinkProgram</code>. This API links the program object, specified by the <code class="literal">program</code> identifier, which must contain the attached vertex and fragment shaders objects:<div class="informalexample"><pre class="programlisting">glLinkProgram(program); // Link the shader program</pre></div></li><li class="listitem">The status of the link operation can be checked using <code class="literal">glGetShaderiv</code>. This API accepts program and <code class="literal">GL_LINK_STATUS</code> as arguments. This will return <code class="literal">GL_TRUE</code> if the last link on program was successful; otherwise, it will return <code class="literal">GL_FALSE</code>.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Syntax</strong></span>:<div class="informalexample"><pre class="programlisting">void glGetProgramiv(GLuint program, GLenum pname, GLint *params);</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">program</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies the program object to be queried</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">pname</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies symbolic state parameters</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">params</code></p>
</td><td style="text-align: left" valign="top">
<p>This returns the requested program object parameter state</p>
</td></tr></tbody></table></div><p>If link status is returned <code class="literal">GL_FALSE</code>, the program object must release its allocated memory using <code class="literal">glDeleteProgram</code>. This API undoes all the effects of <code class="literal">glCreateProgram</code>. It also invalidates the handle with which it was associated.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Syntax</strong></span>:<div class="informalexample"><pre class="programlisting">void glDeleteProgram(Glint program);</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">program</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies the handle of program that needs to be deleted</p>
</td></tr></tbody></table></div></li></ul></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec24"/>How it works...</h2></div></div></div><p>The <code class="literal">linkShader</code> wrapper function links the shader. It accepts two parameters: <code class="literal">vertShaderID</code> and <code class="literal">fragShaderID</code>. They are identifiers of the compiled shader objects. The <code class="literal">createProgram</code> function creates a program object. It is another OpenGL ES object to which shader objects are <a id="id37" class="indexterm"/>attached using <code class="literal">glAttachShader</code>. The shader objects can be detached from the program object if they are no longer in need. The program object is responsible for creating the executable program that runs on the programmable processor. A program in OpenGL ES is an executable in the OpenGL ES 3.0 pipeline that runs on the vertex and fragment processors.</p><p>The program object is linked using <code class="literal">glLinkShader</code>. If the linking fails, the program object must be deleted using <code class="literal">glDeleteProgram</code>. When a program object is deleted it automatically detached the shader objects associated with it. The shader objects need to be deleted explicitly. If a program object is requested for deletion, it will only be deleted until it's not being used by some other rendering context in the current OpenGL ES state.</p><p>If the program's object link successfully, then one or more executable will be created, depending on the number of shaders attached with the program. The executable can be used at runtime with the help of the <code class="literal">glUseProgram</code> API. It makes the executable a part of the current OpenGL ES state.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec25"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Checking errors in OpenGL ES 3.0</em></span></li></ul></div></div></div>
<div class="section" title="Checking errors in OpenGL ES 3.0"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Checking errors in OpenGL ES 3.0</h1></div></div></div><p>While <a id="id38" class="indexterm"/>programming, it is very common to get unexpected <a id="id39" class="indexterm"/>results or errors in the programmed source code. It's important to make sure that the program does not generate any error. In such a case, you would like to handle the error gracefully. This section will guide us to track errors in the OpenGL ES 3.0 and GL shading language.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec26"/>How to do it...</h2></div></div></div><p>OpenGL ES 3.0 allows us to check the error using a simple routine called <code class="literal">getGlError</code>. The following wrapper function prints all the error messages occurred in the programming:</p><div class="informalexample"><pre class="programlisting">static void checkGlError(const char* op) {
     for(GLint error = glGetError(); error; error= glGetError()){
        printf("after %s() glError (0x%x)\n", op, error);
     }
}</pre></div><p>The <code class="literal">getGlError</code> <a id="id40" class="indexterm"/>returns an error code. The following table <a id="id41" class="indexterm"/>describes these errors:</p><p><span class="strong"><strong>Syntax</strong></span>:</p><div class="informalexample"><pre class="programlisting">GLenum glGetError(void);</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Error code</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">GL_NO_ERROR</code></p>
</td><td style="text-align: left" valign="top">
<p>This indicates if no error found</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">GL_INVALID_ENUM</code></p>
</td><td style="text-align: left" valign="top">
<p>This indicates if the <code class="literal">GLenum</code> argument is out of range</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">GL_INVALID_VALUE</code></p>
</td><td style="text-align: left" valign="top">
<p>This indicates if the numeric argument is out of range</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">GL_INVALID_OPERATION</code></p>
</td><td style="text-align: left" valign="top">
<p>This indicates if the operation illegal in current state</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">GL_STACK_OVERFLOW</code></p>
</td><td style="text-align: left" valign="top">
<p>This indicates if the command would cause a stack overflow</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">GL_STACK_UNDERFLOW</code></p>
</td><td style="text-align: left" valign="top">
<p>This indicates if the command would cause a stack underflow</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">GL_OUT_OF_MEMORY</code></p>
</td><td style="text-align: left" valign="top">
<p>This indicates if there is not enough memory left to execute the command</p>
</td></tr></tbody></table></div><p>Here are few examples of code that produce OpenGL ES errors:</p><div class="informalexample"><pre class="programlisting">// Gives a GL_INVALID_ENUM error
glEnable(GL_TRIANGLES);

// Gives a GL_INVALID_VALUE
// when attribID &gt;= GL_MAX_VERTEX_ATTRIBS
glEnableVertexAttribArray(attribID);</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec27"/>How it works...</h2></div></div></div><p>When OpenGL ES detects an error, it records the error into an error flag. Each error has a unique numeric code and symbolic name. OpenGL ES does not track each time an error has occurred. Due to performance reasons, detecting errors may degrade the rendering performance <a id="id42" class="indexterm"/>therefore, the error flag is not set <a id="id43" class="indexterm"/>until the <code class="literal">glGetError</code> routine is called. If there is no error detected, this routine will always return <code class="literal">GL_NO_ERRORS</code>. In distributed environment, there may be several error flags, therefore, it is advisable to call the <code class="literal">glGetError</code> routine in the loop, as this routine can record multiple error flags.</p></div></div>
<div class="section" title="Using the per-vertex attribute to send data to a shader"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Using the per-vertex attribute to send data to a shader</h1></div></div></div><p>The <a id="id44" class="indexterm"/>per-vertex attribute in the shader <a id="id45" class="indexterm"/>programming helps receive data in the vertex shader from OpenGL ES program for each unique vertex attribute. The received data value is not shared among the vertices. The vertex coordinates, normal coordinates, texture coordinates, color information, and so on are the example of per-vertex attributes. The per-vertex attributes are meant for vertex shaders only, they cannot be directly available to the fragment shader. Instead, they are shared via the vertex shader through out variables.</p><p>Typically, the shaders are executed on the GPU that allows parallel processing of several vertices at the same time using multicore processors. In order to process the vertex information in the vertex shader, we need some mechanism that sends the data residing on the client side (CPU) to the shader on the server side (GPU). This recipe will be helpful to understand the use of per-vertex attributes to communicate with shaders.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec28"/>Getting ready</h2></div></div></div><p>The vertex shader in the <span class="emphasis"><em>Programming shaders in GL shading language 3.0</em></span> recipe contains two per-vertex attributes named <code class="literal">VertexPosition</code> and <code class="literal">VertexColor</code>:</p><div class="informalexample"><pre class="programlisting">// Incoming vertex info from program to vertex shader
in vec4  VertexPosition;
in vec4  VertexColor;</pre></div><p>The <code class="literal">VertexPosition</code> contains the 3D coordinates of the triangle that defines the shape of the object that we intend to draw on the screen. The <code class="literal">VertexColor</code> contains the color information on each vertex of this geometry.</p><p>In the vertex shader, a non-negative attribute location ID uniquely identifies each vertex attribute. This attribute location is assigned at the compile time if not specified in the vertex shader program. For more information on specifying the ID, refer to the <span class="emphasis"><em>See also</em></span> section of this recipe.</p><p>Basically, the logic of sending data to their shader is very simple. It's a two-step process:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Query attribute</strong></span>: Query the vertex attribute location ID from the shader.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Attach data to the attribute</strong></span>: Attach this ID to the data. This will create a bridge between the data and the per-vertex attribute specified using the ID. The OpenGL ES processing pipeline takes care of sending data.</li></ul></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec29"/>How to do it...</h2></div></div></div><p>Follow this <a id="id46" class="indexterm"/>procedure to send data to a <a id="id47" class="indexterm"/>shader using the per-vertex attribute:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Declare two global variables in <code class="literal">NativeTemplate.cpp</code> to store the queried attribute location IDs of <code class="literal">VertexPosition</code> and <code class="literal">VertexColor</code>:<div class="informalexample"><pre class="programlisting">GLuint positionAttribHandle;
GLuint colorAttribHandle;</pre></div></li><li class="listitem">Query the vertex attribute location using the <code class="literal">glGetAttribLocation</code> API:<div class="informalexample"><pre class="programlisting">positionAttribHandle = glGetAttribLocation
(programID, "VertexPosition");
colorAttribHandle    = glGetAttribLocation
(programID, "VertexColor");</pre></div><p>This API provides a convenient way to query an attribute location from a shader. The return value must be greater than or equals to <code class="literal">0</code> in order to ensure that attribute with given name exists.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Syntax</strong></span>:<div class="informalexample"><pre class="programlisting">GLint glGetAttribLocation(GLuint program, const GLchar *name);</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">program</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the handle of a successfully linked OpenGL program</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">name</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the name of the vertex attribute in the shader source program</p>
</td></tr></tbody></table></div></li></ul></div></li><li class="listitem">Send the data to the shader using the <code class="literal">glVertexAttribPointer</code> OpenGL ES API:<div class="informalexample"><pre class="programlisting">// Send data to shader using queried attrib location
glVertexAttribPointer(positionAttribHandle, 2, GL_FLOAT,
      GL_FALSE, 0, gTriangleVertices);
glVertexAttribPointer(colorAttribHandle, 3, GL_FLOAT, GL_FALSE, 0, gTriangleColors);</pre></div><p>The data associated with geometry is passed in the form of an array using the generic vertex attribute with the help of the <code class="literal">glVertexAttribPointer</code> API.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Syntax</strong></span>:<div class="informalexample"><pre class="programlisting">void glVertexAttribPointer(GLuint index, GLint size, GLenum type,  GLboolean normalized, GLsizei stride, const GLvoid * pointer);</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">index</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the index of the generic vertex attribute.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">size</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies the number of components per generic vertex attribute. The number must be <code class="literal">1</code>, <code class="literal">2</code>, <code class="literal">3</code>,or <code class="literal">4</code>. The initial value is <code class="literal">4</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">type</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the data type of each component in the array containing geometry info.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">normalized</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies whether any fixed-point data values should be normalized (<code class="literal">GL_TRUE</code>) or converted directly as fixed-point values (<code class="literal">GL_FALSE</code>) when they are accessed.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">stride</code></p>
</td><td style="text-align: left" valign="top">
<p>This is used for consecutive generic attribute; it specifies the offset between them.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">pointer</code></p>
</td><td style="text-align: left" valign="top">
<p>These are pointers to the first attribute of the array data.</p>
</td></tr></tbody></table></div></li></ul></div></li><li class="listitem">The generic <a id="id48" class="indexterm"/>vertex <a id="id49" class="indexterm"/>attributes in the shaders must be enabled by using the <code class="literal">glEnableVertexAttribArray</code> OpenGL ES API:<div class="informalexample"><pre class="programlisting">    // Enable vertex position attribute
    glEnableVertexAttribArray(positionAttribHandle);
    glEnableVertexAttribArray(colorAttribHandle);</pre></div><p>It's important to enable the attribute location. This allows us to access data on the shader side. By default, the vertex attributes are disabled.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Syntax</strong></span>:<div class="informalexample"><pre class="programlisting">void glEnableVertexAttribArray(GLuint index);</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">index</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the index of the generic vertex attribute to be enabled</p>
</td></tr></tbody></table></div></li></ul></div></li><li class="listitem">Similarly, the attribute can be disabled using <code class="literal">glDisableVertexAttribArray</code>. This API has the same syntax as that of <code class="literal">glEnableVertexAttribArray</code>.</li><li class="listitem">Store the incoming per-vertex attribute color <code class="literal">VertexColor</code> into the outgoing attribute <code class="literal">TriangleColor</code> in order to send it to the next stage (fragment shader):<div class="informalexample"><pre class="programlisting">in vec4 VertexColor; // Incoming data from CPU
. . .
out vec4 TriangleColor; // Outgoing to next stage
void main() {
      . . . 
      TriangleColor = VertexColor;
}</pre></div></li><li class="listitem">Receive the color information from the vertex shader and set the fragment color:<div class="informalexample"><pre class="programlisting">in vec4   TriangleColor; // Incoming from vertex shader
out vec4   FragColor;     // The fragment color
void main() {           
      FragColor = TriangleColor;
};</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec30"/>How it works...</h2></div></div></div><p>The per-vertex attribute <a id="id50" class="indexterm"/>variables <code class="literal">VertexPosition</code> and <code class="literal">VertexColor</code> defined in the vertex shader are the lifelines of the vertex shader. These lifelines constantly provide the data information form the client side (OpenGL ES program or CPU) to server side (GPU). Each per-vertex attribute has a unique attribute location available in the shader that can be queried using <code class="literal">glGetAttribLocation</code>. The per-vertex queried attribute locations are stored in <code class="literal">positionAttribHandle</code>; <code class="literal">colorAttribHandle</code> must be bound with the data <a id="id51" class="indexterm"/>using attribute location with <code class="literal">glVertexAttribPointer</code>. This API establishes a logical connection between client and server side. Now, the data is ready to flow from our data structures to the shader. The last important thing is the enabling of the attribute on the shader side for optimization purposes. By default, all the attribute are disabled. Therefore, even if the data is supplied for the client side, it is not visible at the server side. The <code class="literal">glEnableVertexAttribArray</code> API allows us to enable the per-vertex attributes on the shader side.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec31"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to <a id="id52" class="indexterm"/>the <span class="emphasis"><em>Managing variable attributes with qualifiers</em></span> recipe in <a class="link" href="ch03.html" title="Chapter 3. New Features of OpenGL ES 3.0">Chapter 3</a>, <span class="emphasis"><em>New Features of OpenGL ES 3.0</em></span></li></ul></div></div></div>
<div class="section" title="Using uniform variables to send data to a shader"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Using uniform variables to send data to a shader</h1></div></div></div><p>The uniform <a id="id53" class="indexterm"/>variables contain the data values that are global. They are shared by all vertices and fragments in the vertex and fragment shaders. Generally, some information that is not specific to the per-vertex is treated in the <a id="id54" class="indexterm"/>form of uniform variables. The uniform variable could exist in both the vertex and fragment shaders.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec32"/>Getting ready</h2></div></div></div><p>The vertex shader we programmed in the <span class="emphasis"><em>Programming shaders in OpenGL ES shading language 3.0 recipe</em></span> contains a uniform variable <code class="literal">RadianAngle</code>. This variable is used to rotate the rendered triangle:</p><div class="informalexample"><pre class="programlisting">// Uniform variable for rotating triangle
uniform float  RadianAngle;</pre></div><p>This variable will be updated on the client side (CPU) and send to the shader at server side (GPU) using special OpenGL ES 3.0 APIs. Similar to per-vertex attributes for uniform variables, we need to query and bind data in order to make it available in the shader.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec33"/>How to do it...</h2></div></div></div><p>Follow these steps to send data to a shader using uniform variables:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Declare a global variable in <code class="literal">NativeTemplate.cpp</code> to store the queried attribute location IDs of <code class="literal">radianAngle</code>:<div class="informalexample"><pre class="programlisting">GLuint radianAngle;</pre></div></li><li class="listitem">Query the uniform variable location using the <code class="literal">glGetUniformLocation</code> API:<div class="informalexample"><pre class="programlisting">radianAngle=glGetUniformLocation(programID,"RadianAngle");</pre></div><p>This API will return a value greater than or equal to <code class="literal">0</code> to ensure that a uniform variable with the given name exists.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Syntax</strong></span>:<div class="informalexample"><pre class="programlisting">GLint glGetUniformLocation(GLuint program,const GLchar *name)</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">program</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the handle of a successfully linked OpenGL ES program</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">name</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the name of the uniform variable in the shader source program</p>
</td></tr></tbody></table></div></li></ul></div></li><li class="listitem">Send the <a id="id55" class="indexterm"/>updated radian value to the shader using the <code class="literal">glUniform1f</code> API:<div class="informalexample"><pre class="programlisting">float degree = 0; // Global degree variable
float radian;     // Global radian variable

// Update angle and convert it into radian
radian = degree++/57.2957795; 
// Send updated data in the vertex shader uniform 
glUniform1f(radianAngle, radian);</pre></div><p>There are many variants of the <code class="literal">glUniform</code> API.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Syntax</strong></span>:<div class="informalexample"><pre class="programlisting">void glUniform1f(GLint location, GLfloat v0);</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">location</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the index of the uniform variable in the shader</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">v0</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the data value of type float that needs to be sent</p>
</td></tr></tbody></table></div></li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>For more information on other variants, refer to OpenGL ES 3.0 Reference Pages at <a class="ulink" href="http://www.khronos.org/opengles/sdk/docs/man3/">http://www.khronos.org/opengles/sdk/docs/man3/</a>.</p></div></div></li><li class="listitem">Use a <a id="id56" class="indexterm"/>general form of 2D rotation to apply on the entire incoming vertex coordinates:<div class="informalexample"><pre class="programlisting">. . . . 
uniform float  RadianAngle;
mat2 rotation = mat2(cos(RadianAngle),sin(RadianAngle),
                    -sin(RadianAngle),cos(RadianAngle));
void main() {
  gl_Position = mat4(rotation)*VertexPosition;
  . . . . .
}</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec34"/>How it works...</h2></div></div></div><p>The uniform variable <code class="literal">RadianAngle</code> defined in the vertex shader is used to apply rotation transformation on the incoming per-vertex attribute <code class="literal">VertexPosition</code>. On the client side, this uniform variable is queried using <code class="literal">glGetUniformLocation</code>. This API returns the index of the uniform variable and stores it in <code class="literal">radianAngle</code>. This index will be used to bind the updated data information that is stored the radian with the <code class="literal">glUniform1f</code> OpenGL ES 3.0 API. Finally, the updated data reaches the vertex shader executable, where the general form of the Euler rotation is calculated:</p><div class="informalexample"><pre class="programlisting">mat2 rotation = mat2(cos(RadianAngle),sin(RadianAngle),
              -sin(RadianAngle),cos(RadianAngle));</pre></div><p>The rotation <a id="id57" class="indexterm"/>transformation is calculated in the form of 2 x 2 matrix rotation, which is later promoted to a 4 x 4 matrix when multiplied <a id="id58" class="indexterm"/>by <code class="literal">VertexPosition</code>. The resultant vertices cause to rotate the triangle in a 2D space.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec35"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to the <span class="emphasis"><em>Grouping uniforms and creating buffer objects</em></span> recipe in <a class="link" href="ch03.html" title="Chapter 3. New Features of OpenGL ES 3.0">Chapter 3</a>, <span class="emphasis"><em>New Features of OpenGL ES 3.0</em></span></li></ul></div></div></div>
<div class="section" title="Programming OpenGL ES 3.0 Hello World Triangle"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Programming OpenGL ES 3.0 Hello World Triangle</h1></div></div></div><p>This recipe <a id="id59" class="indexterm"/>basically comprises of all the knowledge we gathered from our previous recipes in this chapter. The output of this recipe will be a <code class="literal">NativeTemplate.h/cpp</code> file that contains OpenGL ES 3.0 code, which demonstrates a rotating colored triangle. The output of this recipe is not executable on its own. It needs a host application that provides the necessary OpenGL ES 3.0 prerequisites to render this program on a device screen. Therefore, this recipe will be used later by the following two recipes, which will provide the host environment for OpenGL ES 3.0 in Android and iOS:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Developing Android OpenGL ES 3.0 application</li><li class="listitem" style="list-style-type: disc">Developing iOS OpenGL ES 3.0 application</li></ul></div><p>This recipe will provide all the necessary prerequisites that are required to set up OpenGL ES, rendering and querying necessary attributes from shaders to render our OpenGL ES 3.0 "Hello World Triangle" program. In this program, we will render a simple colored triangle on the screen.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec36"/>Getting ready</h2></div></div></div><p>OpenGL ES requires a physical size (pixels) to define a 2D rendering surface called a viewport. This is used to define the OpenGL ES Framebuffer size.</p><p>A buffer in OpenGL ES is a 2D array in the memory that represents pixels in the viewport region. OpenGL ES has three types of buffers: color buffer, depth buffer, and stencil buffer. These buffers are collectively known as a framebuffer. All the drawings commands effect the information in the framebuffer.</p><p>The life cycle of this recipe is broadly divided into three states:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Initialization</strong></span>: Shaders are compiled and linked to create program objects</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Resizing</strong></span>: This state defines the viewport size of rendering surface</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Rendering</strong></span>: This state uses the shader program object to render geometry on screen</li></ul></div><p>In our recipe, these states are represented by the <code class="literal">GraphicsInit()</code>, <code class="literal">GraphicsResize()</code>, and <code class="literal">GraphicsRender()</code> functions.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec37"/>How to do it...</h2></div></div></div><p>Follow these <a id="id60" class="indexterm"/>steps to program this recipe:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Use the <code class="literal">NativeTemplate.cpp</code> file and create a <code class="literal">createProgramExec</code> function. This is a high-level function to load, compile, and link a shader program. This function will return the program object ID after successful execution:<div class="informalexample"><pre class="programlisting">GLuint createProgramExec(const char* vertexSource, const
                                   char* fragmentSource) {
GLuint vsID = loadAndCompileShader(GL_VERTEX_SHADER,
vertexSource);
GLuint fsID = loadAndCompileShader(GL_FRAGMENT_SHADER, 
fragmentSource);
   return linkShader(vsID, fsID);
}</pre></div><p>Visit the loading and compiling a shader program and linking a shader program recipes for more information on the working of <code class="literal">loadAndCompileShader</code> and <code class="literal">linkShader</code>.</p></li><li class="listitem">Use <code class="literal">NativeTemplate.cpp</code>, create a function <code class="literal">GraphicsInit</code> and create the shader program object by calling <code class="literal">createProgramExec</code>:<div class="informalexample"><pre class="programlisting">GLuint programID; // Global shader program handler
bool GraphicsInit(){

// Print GLES3.0 system metrics
printOpenGLESInfo();
  
// Create program object and cache the ID
programID = createProgramExec(vertexShader,
fragmentShader);
    if (!programID) { // Failure !!! return 
       printf("Could not create program."); return false;
    }
    checkGlError("GraphicsInit"); // Check for errors
}</pre></div></li><li class="listitem">Create a <a id="id61" class="indexterm"/>new function <code class="literal">GraphicsResize</code>. This will set the viewport region:<div class="informalexample"><pre class="programlisting">// Set viewing window dimensions 
bool GraphicsResize( int width, int height ){
    glViewport(0, 0, width, height);
}</pre></div><p>The viewport determines the portion of the OpenGL ES surface window on which the rendering of the primitives will be performed. The viewport in OpenGL ES is set using the <code class="literal">glViewPort</code> API.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Syntax</strong></span>:<div class="informalexample"><pre class="programlisting">void glViewport( GLint x, GLint y, GLsizei width, GLsizei height);</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">x</code>, <code class="literal">y</code></p>
</td><td style="text-align: left" valign="top">
<p>These represent lower-left rectangle for viewport specified in pixels</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">width</code>, <code class="literal">height</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies the width and height of the viewport in pixels</p>
</td></tr></tbody></table></div></li></ul></div></li><li class="listitem">Create the <code class="literal">gTriangleVertices</code> global variable that contains the vertices of the triangle:<div class="informalexample"><pre class="programlisting">GLfloat gTriangleVertices[] = { 
{ 0.0f,  0.5f}, // Vertex 0
{-0.5f, -0.5f}, // Vertex 1
{ 0.5f, -0.5f}  // Vertex 2
}; // Triangle vertices</pre></div></li><li class="listitem">Create the <code class="literal">GraphicsRender</code> renderer function. This function is responsible for rendering the scene. Add the following code in it and perform the following steps to understand this function:<div class="informalexample"><pre class="programlisting">bool GraphicsRender(){
    // Which buffer to clear? – color buffer
    glClear( GL_COLOR_BUFFER_BIT );
    
    // Clear color with black color
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    
    // Use shader program and apply 
    glUseProgram( programID );
    radian = degree++/57.2957795;

// Query and send the uniform variable.    
radianAngle = glGetUniformLocation(programID, "RadianAngle");
    glUniform1f(radianAngle, radian);

    // Query 'VertexPosition' from vertex shader
    positionAttribHandle = glGetAttribLocation
                            (programID, "VertexPosition");
    colorAttribHandle    = glGetAttribLocation
                             (programID, "VertexColor");

    // Send data to shader using queried attribute
    glVertexAttribPointer(positionAttribHandle, 2, 
               GL_FLOAT, GL_FALSE, 0, gTriangleVertices);
    glVertexAttribPointer(colorAttribHandle, 3, 
              GL_FLOAT, GL_FALSE, 0, gTriangleColors);
  
    // Enable vertex position attribute
    glEnableVertexAttribArray(positionAttribHandle);
    glEnableVertexAttribArray(colorAttribHandle);
    
    // Draw 3 triangle vertices from 0th index
    glDrawArrays(GL_TRIANGLES, 0, 3);
}</pre></div></li><li class="listitem">Choose the <a id="id62" class="indexterm"/>appropriate buffer from the framebuffer (color, depth, and stencil) that we want to clear each time the frame is rendered using the <code class="literal">glClear</code> API. In our recipe, we want to clear color buffer. The <code class="literal">glClear</code> API can be used to select the buffers that needs to be cleared. This API accepts a bitwise <code class="literal">OR</code> argument mask that can be used to set any combination of buffers.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Syntax</strong></span>:<div class="informalexample"><pre class="programlisting">void glClear( GLbitfield mask )</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">mask</code></p>
</td><td style="text-align: left" valign="top">
<p>Bitwise <code class="literal">OR</code> masks, each mask points to a specific buffer. These masks are <code class="literal">GL_COLOR_BUFFER_BIT</code>, <code class="literal">GL_DEPTH_BUFFER_BIT</code>, and <code class="literal">GL_STENCIL_BUFFER_BIT</code>.</p>
</td></tr></tbody></table></div><p>The possible value mask could be a bitwise or of <code class="literal">GL_COLOR_BUFFER_BIT</code> (color buffer), <code class="literal">GL_DEPTH_BUFFER_BIT</code> (depth buffer) and  <code class="literal">GL_STENCIL_BUFFER_BIT</code> (stencil buffer).</p><div class="informalexample"><pre class="programlisting">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)</pre></div></li></ul></div></li><li class="listitem">Clear the color buffer with black color using the <code class="literal">glClearColor</code> API. This buffer is responsible for storing color information of the scene. It accepts the argument as RGBA space that ranges between 0.0 and 1.0.</li><li class="listitem">Use a shader program and set as the current rendering state using the <code class="literal">glUseProgram</code> API. The <code class="literal">glUseProgram</code> API installs the program object specified by the program as the current rendering state. The program's executable for the vertex shader runs on the programmable vertex processor. Similarly, the <a id="id63" class="indexterm"/>fragment shader executable runs on the programmable fragment processor.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Syntax</strong></span>:<div class="informalexample"><pre class="programlisting">void glUseProgram(GLuint program);</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">program</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies the handle (ID) of the shader program.</p>
</td></tr></tbody></table></div></li></ul></div></li><li class="listitem">Query the <code class="literal">VertexPosition</code> generic vertex attribute location ID from the vertex shader into <code class="literal">positionAttribHandle</code> using <code class="literal">glGetAttribLocation</code>. This location will be used to send triangle vertex data that is stored in <code class="literal">gTriangleVertices</code> to the shader using <code class="literal">glVertexAttribPointer</code>. Follow the same instruction in order to get the handle of <code class="literal">VertexColor</code> into <code class="literal">colorAttributeHandle</code>:<div class="informalexample"><pre class="programlisting">// Query attribute location &amp; send data using them
positionAttribHandle = glGetAttribLocation
                         (programID, "VertexPosition");
colorAttribHandle = glGetAttribLocation
                         (programID, "VertexColor");
glVertexAttribPointer(positionAttribHandle, 2, GL_FLOAT,
GL_FALSE, 0, gTriangleVertices);
glVertexAttribPointer(colorAttribHandle, 3, GL_FLOAT, 
                         GL_FALSE, 0, gTriangleColors);</pre></div></li><li class="listitem">Enable the generic vertex attribute location using <code class="literal">positionAttribHandle</code> before the rendering call and render the triangle geometry. Similarly, for the per-vertex color information, use <code class="literal">colorAttribHandle</code>:<div class="informalexample"><pre class="programlisting">glEnableVertexAttribArray(positionAttribHandle);
glDrawArrays(GL_TRIANGLES, 0, 3);</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec38"/>How it works...</h2></div></div></div><p>When the application starts, the control begins with <code class="literal">GraphicsInit</code>, where the system metrics are printed out to make sure that the device supports OpenGL ES 3.0. The OpenGL ES programmable pipeline requires vertex shader and fragment shader program executables in the rendering pipeline. The program object contains one or more executables after attaching the compiled shader objects and linking them to program. In the <code class="literal">createProgramExec</code> function the vertex and fragment shaders are compiled and linked, in order to generate the program object.</p><p>The <code class="literal">GraphicsResize</code> function generates the viewport of the given dimension. This is used internally by OpenGL ES 3.0 to maintain the framebuffer. In our current application, it is used to manage color buffer. Refer to the <span class="emphasis"><em>There's more …</em></span> section for more information on other available buffers in OpenGL ES 3.0.</p><p>Finally, the rendering of the scene is performed by <code class="literal">GraphicsRender</code>, this function clears the color buffer with black background and renders the triangle on the screen. It uses a shader object program and <a id="id64" class="indexterm"/>sets it as the current rendering state using the <code class="literal">glUseProgram</code> API.</p><p>Each time a frame is rendered, data is sent from the client side (CPU) to the shader executable on the server side (GPU) using <code class="literal">glVertexAttribPointer</code>. This function uses the queried generic vertex attribute to bind the data with OpenGL ES pipeline.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec39"/>There's more...</h2></div></div></div><p>There are other buffers also available in OpenGL ES 3.0:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Depth buffer</strong></span>: This is used to prevent background pixels from rendering if there is a closer pixel available. The rule of prevention of the pixels can be controlled using special depth rules provided by OpenGL ES 3.0. For more information on this, refer to <a class="link" href="ch02.html" title="Chapter 2. OpenGL ES 3.0 Essentials">Chapter 2</a>, <span class="emphasis"><em>OpenGL ES 3.0 Essentials</em></span>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Stencil buffer</strong></span>: The stencil buffer stores the per-pixel information and is used to limit the area of rendering.</li></ul></div><p>The OpenGL ES API allows us to control each buffer separately. These buffers can be enabled and disabled as per the requirement of the rendering. The OpenGL ES can use any of these buffers (including color buffer) directly to act differently. These buffers can be set via preset values <a id="id65" class="indexterm"/>by using OpenGL ES APIs, such as <code class="literal">glClearColor</code>, <code class="literal">glClearDepthf</code>, and <code class="literal">glClearStencil</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>You can refer to <a class="ulink" href="http://www.khronos.org/opengles/sdk/docs/man3/">http://www.khronos.org/opengles/sdk/docs/man3/</a> for more information on <code class="literal">glClearDepthf</code>, <code class="literal">glClearStencilAPI</code> and all other APIs. The same link can be used to explore OpenGL ES 3.0 official API specifications.</p></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec40"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to the <span class="emphasis"><em>Depth testing in OpenGL ES 3.0</em></span> recipe in <a class="link" href="ch02.html" title="Chapter 2. OpenGL ES 3.0 Essentials">Chapter 2</a>, <span class="emphasis"><em>OpenGL ES 3.0 Essentials</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Developing an Android OpenGL ES 3.0 application</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Developing an iOS OpenGL ES 3.0 application</em></span></li></ul></div></div></div>
<div class="section" title="Using JNI on Android to communicate with C/C++"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec17"/>Using JNI on Android to communicate with C/C++</h1></div></div></div><p>Android <a id="id66" class="indexterm"/>applications are typically developed in Java. However, at times, there could be requirements for the development of C/C++ code or <a id="id67" class="indexterm"/>for reusing an existing C/C++ library in Android. For example, if you are looking to develop for cross-platform deployment, then there is no better option than choosing C/C++ as the development language. The code in this book is written in C/C++ to meet cross-platform requirements. This recipe will provide a demo to communicate with C/C++ code from an Android Java application. You will learn how to call the C/C++ method from Java using <span class="strong"><strong>Java Native Interface</strong></span> (<span class="strong"><strong>JNI</strong></span>).</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec41"/>Getting ready</h2></div></div></div><p>JNI creates a bridge between Java and native code via JNI interfaces. The Android NDK provides all the necessary tools such as libraries, source files, and compilers to help in building native code. It is believed that the development of the native code is faster, compared to Java code. Therefore, native development is better for memory management, performance, and cross-platform development.</p><p>In our first recipe, you will learn to program C/C++ code in the Android Java application. In this recipe, we will create a UI <code class="literal">TextView</code> control in the Android framework and display its contents as a string message sent from the C/C++ code. Java communicates with C/C++ through static/shared libraries, the NDK uses JNI and provides a means to develop these libraries under a Java environment.</p><p>As a prerequisite for NDK development, you must add Android NDK into the PATH environment variable, so that the NDK APIs are directly accessible from the command-line terminal.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec42"/>How to do it...</h2></div></div></div><p>Follow these <a id="id68" class="indexterm"/>steps to create an Android application with JNI support:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a New Android application project by going to <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>Android Application Project</strong></span>.</li><li class="listitem">Set <span class="strong"><strong>Application Name</strong></span> as <code class="literal">HelloNativeDev</code>, <span class="strong"><strong>Project Name</strong></span> as <code class="literal">CookbookNativeDev</code>, and <span class="strong"><strong>Package Name</strong></span> as <code class="literal">com.cookbookgles</code>. You can provide the names as per your choice—there is no restriction:<div class="mediaobject"><img src="graphics/B02491_01_14.jpg" alt="How to do it..."/></div></li><li class="listitem">Accept the default settings and click on <span class="strong"><strong>Next</strong></span> until the <span class="strong"><strong>Create Activity</strong></span> page appears. Select <span class="strong"><strong>Blank Activity</strong></span> from the given options and click on <span class="strong"><strong>Next</strong></span>.</li><li class="listitem">On the last <span class="strong"><strong>Blank Activity</strong></span> page, change <span class="strong"><strong>Activity Name</strong></span> to <code class="literal">NativeDevActivity</code>, and click on <span class="strong"><strong>Finish</strong></span>. This will create the project solution, as shown here:<div class="mediaobject"><img src="graphics/B02491_01_15.jpg" alt="How to do it..."/></div><p>The <a id="id69" class="indexterm"/>project solution contains various <a id="id70" class="indexterm"/>files and folders in it. Each of these has a specific role and responsibility, which is shown in the preceding image.</p></li><li class="listitem">Go to <code class="literal">src</code> | <code class="literal">com.cookbookgles</code> | <code class="literal">NativeDevActivity.java</code> and replace the code with the following code snippet. Compile and execute the program. This will generate the necessary classes, which will be used by JNI:<div class="informalexample"><pre class="programlisting">package com.cookbookgles;

import android.os.Bundle;
import android.widget.TextView;
import android.app.Activity;

public class NativeDevActivity extends Activity {

   static {
     //Comment #1
     // "jniNativeDev.dll" in Windows.
     System.loadLibrary("jniNativeDev");
   }
 
     //Comment #2
     // Native method that returns a Java String
     // to be displayed on the TextView
     public native String getMessage();
 
     @Override
     public void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     
     //Comment #3
     // Create a TextView widget.
     TextView textView = new TextView(this);
     
     //Comment #4
     // Retrieve the text from native method
     // getMessage() and set as text to be displayed
     textView.setText(getMessage());
     setContentView(textView);
   }
}</pre></div></li><li class="listitem">Add a <a id="id71" class="indexterm"/>new folder named <code class="literal">JNI</code> in the project solution. This folder will contain all the C/C++ files. Create <a id="id72" class="indexterm"/>another new folder <code class="literal">include</code> inside <code class="literal">JNI</code>. This will be used for header files. Add <code class="literal">HelloCookbookJNI.h</code> and <code class="literal">HelloCookbookJNI.c</code> under <code class="literal">include</code> and <code class="literal">JNI</code> folders, respectively. Add the following code:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">HelloCookbookJNI.h</code>:<div class="informalexample"><pre class="programlisting">#ifndef _Included_com_cookbook_JNIActivity
#define _Included_com_cookbook_JNIActivity
#include &lt;jni.h&gt;

JNIEXPORT jstring JNICALL Java_com_cookbookgles_ NativeDevActivity_getMessage(JNIEnv *, jobject);

#endif</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">HelloCookbookJNI.c</code>:<div class="informalexample"><pre class="programlisting">#include "include/HelloCookbookJNI.h"
 
JNIEXPORT jstring JNICALL Java_com_cookbookgles_ NativeDevActivity_getMessage(JNIEnv *env, jobject thisObj){
    return (*env)-&gt;NewStringUTF(env, 
               "Hello from Cookbook native code.");
}
</pre></div></li></ul></div><p>The JNI function syntax is as follows:</p><div class="informalexample"><pre class="programlisting">JNIEXPORT &lt;return type&gt; JNICALL &lt;static function name&gt; (JNIEnv *, jobject);</pre></div><p>The function name under JNI contains the complete hierarchical path of the location where it is defined in the project. The rules are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The function name should be prefixed by <code class="literal">Java_</code></li><li class="listitem" style="list-style-type: disc">Starting from the package name (<code class="literal">com.cookbookgles</code>), each hierarchical folder and filename must be concatenated</li><li class="listitem" style="list-style-type: disc">Each concatenation must contain an underscore (<code class="literal">_</code>) between two consecutive names</li></ul></div><p>For example:</p><div class="informalexample"><pre class="programlisting">    com.cookbookgles -&gt; NativeDevActivity.java -&gt; getMessage()</pre></div><p>The name of the function will be defined as follows:</p><div class="informalexample"><pre class="programlisting">Java_com_cookbookgles_NativeDevActivity_getMessage</pre></div><p>The full signature and name are given here:</p><div class="informalexample"><pre class="programlisting">JNIEXPORT jstring JNICALL Java_com_cookbookgles_NativeDevActivity_getMessage (JNIEnv *, jobject);</pre></div><p>This process can be <a id="id73" class="indexterm"/>automated using the javah tool. <a id="id74" class="indexterm"/>For more information, refer to the <span class="emphasis"><em>There more …</em></span> section):</p></li><li class="listitem">Add <code class="literal">Android.mk</code> under JNI. Add the following code:<div class="informalexample"><pre class="programlisting">// Android.mk
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)

LOCAL_MODULE    := JNINativeDev
LOCAL_SRC_FILES := HelloCookbookJNI.c

include $(BUILD_SHARED_LIBRARY)</pre></div><p>The native code build process uses <code class="literal">Android.mk</code> for compilation of files. This makefile instructs the NDK compiler list of all the files that need to be compiled. It also maintains the order of files in which they need to be compiled.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">LOCAL_PATH</code> is a predefined variable. It sets the path of the build system to the path of the current working directory. In other words, it is used to locate source files in the development tree It is specified with the current directory path using <code class="literal">$(call my-dir)</code>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">include $(CLEAR_VARS)</code> helps the build system to remove any previous existing variables. It makes sure that no system or local variables are used from other modules. Such a multiple declaration of the same variable across different makefiles can confuse the build system. This command cleans all the local predefined variables, such as <code class="literal">LOCAL_PATH</code>, <code class="literal">LOCAL_MODULE</code>, and <code class="literal">LOCAL_SRC_FILES</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">LOCAL_MODULE</code> is a system variable that contains the name of the library exported by JNI. On successful compilation of the native code, JNI will generate a library with the name specified in <code class="literal">LOCAL_MODULE</code>. In the current recipe, it is <code class="literal">JNINativeDev.so</code>. <code class="literal">LOCAL_SRC_FILE</code> helps the JNI compiler understand which files need to undergo compilation.</li><li class="listitem" style="list-style-type: disc"><code class="literal">include $(BUILD_SHARED_LIBRARY)</code> helps the compiler build the library into a dynamic form (for example, <code class="literal">.dll</code> on Windows or <code class="literal">.so</code> on Linux). These libraries can also be built into static form using <code class="literal">include $(BUILD_STATIC_LIBRARY)</code>. This recipe uses the shared library.</li></ul></div></li><li class="listitem">Open a <a id="id75" class="indexterm"/>command-line terminal. Go to the <a id="id76" class="indexterm"/>current <code class="literal">JNI</code> folder path and execute <code class="literal">ndk-build</code>. This command, with the help of <code class="literal">Android.mk</code>, compiles the source files and generates the shared library called <code class="literal">JNINativeDev.so</code> in the <code class="literal">CookbookNativeDev\libs\armeabi</code> folder path:<div class="mediaobject"><img src="graphics/B02491_01_03.jpg" alt="How to do it..."/></div></li><li class="listitem">Inside <code class="literal">NativeDevActivity.java</code>, you need to load the library before using it:<div class="informalexample"><pre class="programlisting">System.loadLibrary("jniNativeDev");</pre></div></li><li class="listitem">Connect your physical Android device to the system and execute the Android project with <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>F11</em></span>. This will display the following output on the screen. You can <a id="id77" class="indexterm"/>access the first example in the sample code folder <code class="literal">simpleJNI</code>:<div class="mediaobject"><img src="graphics/B02491_01_04.jpg" alt="How to do it..."/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>All of the recipes in this book use the Android device as a target. You can also make use of Android emulators. The primary reason to avoid the use of emulation here is the spotty support available for Android emulator and slower performance.</p></div></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec43"/>How it works...</h2></div></div></div><p>The regular Java code needs to know how to call the native C code. This is done by declaring functions in Java files where each function's signature is prefixed with a <code class="literal">native</code> keyword. The definition of these functions is defined in C/C++ source files. These functions need to redeclare in the header files, which must be located in the <code class="literal">JNI</code> folder. These declarations are in a special syntax rule that the <code class="literal">ndk</code> build understands. The functions are finally made available to Java in the form of shared or static libraries. You need to call this shared/static library within the Java code to use these exported functions.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec44"/>There's more…</h2></div></div></div><p>In this recipe, you learned the convention to produce the JNI function's native method signatures. While working on large projects, sometimes, it is cumbersome to make such changes as the code <a id="id78" class="indexterm"/>could be significantly large. Additionally, the chances of human errors are also substantially high.</p><p>Alternately, the <span class="strong"><strong>javah tool</strong></span> can be used to automate this process. It generates the C header and source files that are needed to implement native methods. It reads a Java class file and creates a C-language header file in the current working directory. The generated header and source <a id="id79" class="indexterm"/>files are used by C programs to reference an object's instance variables from the native source code. A <a id="id80" class="indexterm"/>detailed description of the usage of this tool is beyond the scope of this book. However, I highly recommend that you refer to the <span class="emphasis"><em>See also</em></span> section for more information on this.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec45"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You can <a id="id81" class="indexterm"/>learn JNI programming (JNI specification) in detail from <a class="ulink" href="http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html">http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html</a></li><li class="listitem" style="list-style-type: disc">The javah <a id="id82" class="indexterm"/>tool reference is available at <a class="ulink" href="http://docs.oracle.com/javase/7/docs/technotes/tools/windows/javah.html">http://docs.oracle.com/javase/7/docs/technotes/tools/windows/javah.html</a></li></ul></div></div></div>
<div class="section" title="Developing an Android OpenGL ES 3.0 application"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec18"/>Developing an Android OpenGL ES 3.0 application</h1></div></div></div><p>This recipe <a id="id83" class="indexterm"/>uses the NDK and JNI knowledge from the previous recipe to develop our first Android OpenGL ES 3.0 application. We will use our source code for <code class="literal">NativeTemplate.h</code>/<code class="literal">NativeTemplate.cpp</code> that we programmed in the <span class="emphasis"><em>Programming OpenGL ES 3.0 Hello World Triangle</em></span> recipe. <a id="id84" class="indexterm"/>This recipe uses the Android framework to provide the necessary services to host the OpenGL ES program in it.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec46"/>Getting ready</h2></div></div></div><p>For our first Android OpenGL ES 3.0 recipe, we advise you to locate the sample <code class="literal">AndroidHelloWorldTriangle</code> recipe with this chapter. It will be helpful to import the contents to quickly build the application. To import recipes, refer to the <span class="emphasis"><em>Opening a sample project in Android ADT and iOS</em></span> recipe in <a class="link" href="apa.html" title="Appendix A. Supplementary Information on OpenGL ES 3.0">Appendix</a>, <span class="emphasis"><em>Supplementary Information on OpenGL ES 3.0</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec47"/>How to do it...</h2></div></div></div><p>Here is the step-by-step procedure to program our first OpenGL ES 3.0 application in Android:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a blank activity project by going to <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>Android Project</strong></span>. Provide a proper name for the application and project. For example, specify <span class="strong"><strong>Application Name</strong></span> as <code class="literal">AndroidBlueTriangle</code>, <span class="strong"><strong>Project Name</strong></span> as <code class="literal">AndroidBlueTriangle</code>, and specify <span class="strong"><strong>Package Name</strong></span> as <code class="literal">cookbookgles</code>. The package name in Java is equivalent to the namespace concept in C/C++.</li><li class="listitem">On the last page, specify <span class="strong"><strong>Activity Name</strong></span> as <code class="literal">GLESActivity</code>, <span class="strong"><strong>Layout Name</strong></span> as <code class="literal">activity_gles</code>, and <span class="strong"><strong>Navigation Type</strong></span> as <code class="literal">None</code>.</li><li class="listitem">In <span class="strong"><strong>Package Explorer</strong></span>, browse to <code class="literal">AndroidBlueTriangle</code> | <code class="literal">src</code> | <code class="literal">cookbook.gles</code>. Here, you will find our <code class="literal">GLESActivity</code> class. Under the same package called <code class="literal">cookbook.gles</code>, add two new classes called <code class="literal">GLESView</code> and <code class="literal">GLESNativeLib</code>. In order to add a new class, right-click on the <code class="literal">cookbookgles</code> package in the package explorer and go to <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>Class</strong></span>.</li><li class="listitem">Use the sample recipe <code class="literal">AndroidBlueTriangle</code> and copy/paste the contents of <code class="literal">GLESActivity.java</code>, <code class="literal">GLESView.java</code>, and <code class="literal">GLESNativeLib.java</code> to the respective files of your project. In the next section, you will better understand these files and the classes contained in them.</li><li class="listitem">Add a new folder called JNI under this project. Inside this folder, create <code class="literal">Android.mk</code>, <code class="literal">Application.mk</code>, <code class="literal">NativeTemplate.h</code>, and <code class="literal">NativeTemplate.cpp</code>. The <code class="literal">android.mk</code> native code makefile is used by the JNI, as discussed in the previous recipe. Use <code class="literal">HelloWorldAndroid</code> to copy the contents of these two files from source to their respective files.</li><li class="listitem">For <a id="id85" class="indexterm"/>OpenGL ES 3.0, <code class="literal">Android.mk</code> must contain the <code class="literal">-lEGL</code> and <code class="literal">-lGLESv3</code> flags in order to link with the EGL and OpenGL ES 3.0 libraries. Also, as we target Android devices running Android version 18 (Jelly Bean), the <code class="literal">Applicaton.mk</code> must contain the <code class="literal">APP_PLATFORM:=android-18</code> platform.<div class="mediaobject"><img src="graphics/B02491_01_16.jpg" alt="How to do it..."/></div></li><li class="listitem">Open the command-line terminal and run <code class="literal">ndk-build</code> inside the <code class="literal">jni</code> folder. Under Eclipse, refresh <span class="strong"><strong>Package Explorer</strong></span> so that the library created by <code class="literal">ndk-build</code> is updated in the project. Here is the rendering output upon execution:<div class="mediaobject"><img src="graphics/B02491_01_07.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec48"/>How it works...</h2></div></div></div><p>The first <a id="id86" class="indexterm"/>Android recipe for OpenGL ES 3.0 contains two OpenGL ES classes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">GLESActivity</code> is an extended version of Activity. Activity is an application component that allows various types of views on the screen. Each activity has a window region, within which various type of views are rendered. For our requirements, we need a surface where we can render OpenGL ES. Therefore, the <code class="literal">GLESActivity</code> class is using <code class="literal">GLESView</code> for viewing purpose.</li><li class="listitem" style="list-style-type: disc"><code class="literal">GLESView</code> is our custom class that is extended from <code class="literal">GLSurfaceView</code>. It provides a surface for OpenGL ES rendering. It helps OpenGL ES know about various events, such as the status of activity, whether it is in active or sleep mode, whether it has changed its dimensions, and so on. <code class="literal">GLSurfaceView</code> provides some important class interfaces. Among them, the three most important ones are as follows:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">GLSurfaceView.EGLConfigChooser</code>: This class is responsible for choosing the correct EGL configuration, as per our requirements. Basically, an EGL is an interface between the OpenGL ES APIs and the rendering context. In order to use the correct rendering context, we should know the EGL configuration that suits our requirements. In this recipe, we have extended <code class="literal">ConfigChooser</code> from <code class="literal">GLSurfaceView.EGLconfigChooser</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">GLSurfaceView.EGLContextFactory</code>: The rendering context is very much dependent on the device hardware configuration. OpenGL ES APIs do not know or care about creating the rendering context. Your local SDK provider is responsible for providing an interface to create it and attach it to your local application system. In Android, it is accomplished with the <code class="literal">EGLContextFactory</code> class. This requires EGL configuration. We have already seen how the <code class="literal">EGLConfigChooser</code> class gave us the correct EGL configuration, as per our requirement. You need to use this configuration to create your custom <code class="literal">ContextFactory</code>, which is the extended version of <code class="literal">GLSurfaceView.EGLContextFactory</code> in our recipe.<p>To create OpenGL ES 3.0 context, use the <code class="literal">eglCreateContext</code> function. This function accepts an attribute list where the second item belongs to the OpenGL ES version, which must be 3.0. See the sample code give here <a id="id87" class="indexterm"/>for OpenGL ES 3.0 support:</p><div class="informalexample"><pre class="programlisting">private static double glVersion = 3.0;
int[] attrib_list = {EGL_CONTEXT_CLIENT_VERSION, (int) glVersion, EGL10.EGL_NONE };
EGLContext context = egl.eglCreateContext(display, eglConfig, EGL10.EGL_NO_CONTEXT,  attrib_list);</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">GLSurfaceView.Renderer</code>: This provides the interface to manage OpenGL ES calls to render a frame. It calls the render function in loop.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">NativeTemplate.cpp</code>: This is the native code file that contains OpenGL ES commands responsible for rendering the blue triangle on screen.</li></ul></div><p>When the Android OpenGL ES framework launches an activity, it first checks the available EGL configurations on device and chooses the one best suited to our requirements. This configuration is used to create OpenGL ES rendering context. Finally, rendering is performed by <code class="literal">GLSurfaceRenderer,</code> where it calls the native OpenGL ES code with the help of the <code class="literal">GLESNativeLib</code> class.</p><p>The OpenGL ES rendering source is coded in <code class="literal">NativeTemplate.cpp</code>, which is exposed to the Android framework via the <code class="literal">libglNative.so</code> static library. This library is compiled from the NDK using the <code class="literal">ndk-build</code> command and is automatically stored under the folder <code class="literal">AndroidBlueTriangle</code> | <code class="literal">libs</code> | <code class="literal">armeabi</code> | <code class="literal">libglNative.so</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>After compilation of an NDK build, the library generated is prefixed with <code class="literal">lib</code>. If the name mentioned in <code class="literal">Android.mk</code> is already prefixed with <code class="literal">lib</code>, then this prefixing is discarded.</p></div></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec49"/>There's more...</h2></div></div></div><p>You can explore <a id="id88" class="indexterm"/>more about the official Android OpenGL ES and its framework classes at <a class="ulink" href="http://developer.android.com/reference/android/opengl/package-summary.html">http://developer.android.com/reference/android/opengl/package-summary.html</a>.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec50"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to the <span class="emphasis"><em>Software requirements for OpenGL ES 3.0 – Android ADT</em></span> recipe in <a class="link" href="apa.html" title="Appendix A. Supplementary Information on OpenGL ES 3.0">Appendix</a>, <span class="emphasis"><em>Supplementary Information on OpenGL ES 3.0</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Using JNI on Android to communicate with C/C++</em></span></li></ul></div></div></div>
<div class="section" title="Developing an iOS OpenGL ES 3.0 application"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec19"/>Developing an iOS OpenGL ES 3.0 application</h1></div></div></div><p>Development <a id="id89" class="indexterm"/>of OpenGL ES applications on iOS is much simpler compared to Android. The iOS 7 SDK, Xcode 5.0, and later versions support OpenGL ES 3.0. Using App Wizard in Xcode 5.0, the OpenGL ES 3.0 applications can be developed effortlessly.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec51"/>Getting ready</h2></div></div></div><p>Make sure that you should have iOS 7 support in your Xcode IDE. For more information, refer to the <span class="emphasis"><em>Software requirements for OpenGL ES 3.0 – Android ADT</em></span> recipe in <a class="link" href="apa.html" title="Appendix A. Supplementary Information on OpenGL ES 3.0">Appendix</a>, <span class="emphasis"><em>Supplementary Information on OpenGL ES 3.0</em></span>. It's advisable to import the sample recipe <code class="literal">iOSHelloWorldTriangle</code> in the Xcode. This will be helpful in understanding the theory quickly.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec52"/>How to do it...</h2></div></div></div><p>Here are the step-by-step descriptions of the first iOS OpenGL ES 3.0 application:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>The development of an OpenGL ES 3.0 application uses Xcode App Wizard.</p></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open Xcode, go to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>Project</strong></span>, select <span class="strong"><strong>OpenGL Game</strong></span>, and then click on <span class="strong"><strong>Next</strong></span>.</li><li class="listitem">Give <span class="strong"><strong>Product Name</strong></span>, <span class="strong"><strong>Organization Name</strong></span>, and <span class="strong"><strong>Company Identifier</strong></span> as per your choice. For example, we are using <code class="literal">iOSBlueTriangle</code>, <code class="literal">macbook</code>, and <code class="literal">Cookbook</code>, respectively. Go to the <span class="strong"><strong>Next</strong></span> page, select the location, and create project.</li><li class="listitem">Delete <code class="literal">ViewController.m</code> from the project navigator. Instead, we will use our own file. Go to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Add Files</strong></span> to <code class="literal">iOSBlueTriangle</code>. Now, locate the source code provided with this book and open the <code class="literal">HelloWorldiOS</code> folder. Select <code class="literal">ViewController.mm</code>, <code class="literal">NativeTemplate.cpp</code>, and <code class="literal">NativeTemplate.h</code>, and add these into the project. Feel free to explore these added files. Build (<span class="emphasis"><em>command</em></span> + <span class="emphasis"><em>B</em></span>) and execute (<span class="emphasis"><em>command</em></span> + <span class="emphasis"><em>R</em></span>) the project.</li><li class="listitem">The development of OpenGL ES in Xcode makes sure that the correct version of OpenGL ES is used. It is automatically resolved by the Xcode build system using <span class="strong"><strong>Deployment Target</strong></span>. If the deployment target is iOS 7, then OpenGL ES 3.0 libraries are used; otherwise, OpenGL ES 2.0 libraries are used. If <a id="id90" class="indexterm"/>the code in source files uses fixed function pipeline programming APIs, then it is understood that OpenGL ES 1.1 is used. For our current recipe, make sure you have set <span class="strong"><strong>Deployment Target</strong></span> to <span class="strong"><strong>7.0</strong></span>:<div class="mediaobject"><img src="graphics/B02491_01_17.jpg" alt="How to do it..."/></div></li></ol></div><p>The program handles reference counting by itself. Therefore, it is advised that you disable the <span class="strong"><strong>automatic </strong></span><a id="id91" class="indexterm"/>
<span class="strong"><strong>reference count</strong></span> (<span class="strong"><strong>ARC</strong></span>) to build the program. Otherwise, the compilation may fail. Follow these steps to disable the ARC:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Click on you project in the organizer on the left-hand side</li><li class="listitem" style="list-style-type: disc">Select your target in the next column</li><li class="listitem" style="list-style-type: disc">Select the <span class="strong"><strong>Build Settings</strong></span> tab at the top</li><li class="listitem" style="list-style-type: disc">Scroll down to <span class="strong"><strong>Objective-C Automatic Reference Counting</strong></span> (it may be listed as <code class="literal">CLANG_ENABLE_OBJC_ARC</code> under the <span class="strong"><strong>User-Defined</strong></span> settings group) and set it to <span class="strong"><strong>NO</strong></span></li></ul></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec53"/>How it works...</h2></div></div></div><p>The Xcode provides an app wizard to the build the applications for iOS 7.0. The OpenGL ES development uses GLKit, which was introduced in iOS 5.0. The GLKit is an OpenGL ES development framework in objective C/C++. It is used to develop 3D graphics applications for programmable pipeline architecture. Since we are developing a portable application that works across platforms, this kit might not be fully helpful for us (GLKit is in Objective C/C++) in that direction. We will create our custom graphics development framework, which will be helpful for portable applications across Android and iOS. We will use GLKit to <a id="id92" class="indexterm"/>build the bridge between our graphics development framework kit and iOS. We will introduce this framework in <a class="link" href="ch02.html" title="Chapter 2. OpenGL ES 3.0 Essentials">Chapter 2</a>, <span class="emphasis"><em>OpenGL ES 3.0 Essentials</em></span>.</p><p>The app wizard creates two classes for us, <code class="literal">AppDelegate</code> and <code class="literal">ViewController</code>. These classes are described here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">AppDelegate</code>: This class is inherited from <code class="literal">UIResponder&lt;UIApplicationDelegate&gt;</code>, which defines the interfaces for a <code class="literal">UIobject</code> that respond to touch and motion events. <code class="literal">UIApplication</code> and <code class="literal">UIView</code> are also derived from <code class="literal">UIResponder</code>. In iOS, the <code class="literal">UIApplication</code> class provides a centralized point of control to the underlying OS to coordinate with applications. Each <code class="literal">UIApplication</code> must implement some methods for <code class="literal">UIApplicationDelegate</code>, which provides the information on the key event happening with in an application. For example, such key events could be application launching, termination, memory status, and state transition.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ViewController</code>: GLKit provides a standard <code class="literal">View</code> and <code class="literal">Controller</code> analogy, through <code class="literal">GLKitView</code> and <code class="literal">GLKitController</code>. <code class="literal">ViewController</code> is derived from <code class="literal">GLKitController</code>. Both classes work together to accomplish the rendering job. <code class="literal">GLKitView</code> manages the frame buffer object for the application. It takes the responsibility of rendering a draw command into the framebuffer when it is updated. However, <code class="literal">GLKitController</code> provides the necessary interfaces to control the pace of frames and their rendering loop:<div class="informalexample"><pre class="programlisting">//AppDelegate.h
#import &lt;UIKit/UIKit.h&gt;

@class ViewController;
@interface AppDelegate : UIResponder &lt;UIApplicationDelegate&gt;
@property (strong, nonatomic) UIWindow *window;
@property (strong, nonatomic) ViewController *viewController;
@end</pre></div></li></ul></div><p>When iOS launches an application, it creates an instance of <code class="literal">UIResponder</code>, which basically creates the application object. This application object is a service for the application to provide a physical space in the screen window. This windowing is provided by the object of <code class="literal">UIWindow</code>, which will be created during the construction of <code class="literal">UIApplication</code>. This <a id="id93" class="indexterm"/>window object contains the desired view to display something on screen. In our case, this view should be some OpenGL rendering surface, which is provided by <code class="literal">GLKitController</code> to display. When the class object of <code class="literal">GLKitController</code> is created, it automatically creates the view associated with it. This helps the application to provide the necessary OpenGL rendering surface:</p><div class="informalexample"><pre class="programlisting">// AppDelegate.m
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
self.window = [[[UIWindow alloc] initWithFrame:[[UIScreen mainScreen]  bounds]] autorelease];
// Override point for customization after application launch.
self.viewController = [[[ViewController alloc] initWithNibName:@"ViewController" bundle:nil] autorelease];
self.window.rootViewController = self.viewController;
[self.window makeKeyAndVisible];
return YES;
}</pre></div><p>The <code class="literal">didFinishLaunchingWithOptions</code> interface from <code class="literal">UIApplicationDelete</code> informs <a id="id94" class="indexterm"/>the event status of the application that it has completed loading. Within this event, we created the window and set the <code class="literal">ViewController</code>.</p><p>When a subclass from <code class="literal">GLKitController</code> is extended, it's very important that we override the <code class="literal">viewDidLoad</code> and <code class="literal">viewDidUnload</code> methods:</p><div class="informalexample"><pre class="programlisting">//  ViewController.mm
- (void)viewDidLoad
{
  [super viewDidLoad];
    
  self.context = [[[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3] autorelease];
  if (!self.context) {
    NSLog(@"Failed to create ES context");
  }
    
  GLKView *view = (GLKView *)self.view;
  view.context = self.context;
  view.drawableDepthFormat = GLKViewDrawableDepthFormat24;
  
  [self setupGL];
}</pre></div><p>The <code class="literal">viewDidLoad</code> method helps create the rendering context and set up all its drawable properties for an appropriate configuration. To create an OpenGL ES 3.0 render context, we use <code class="literal">initWithAPI</code>. It accepts <code class="literal">kEAGLRenderingAPIOpenGLES3</code> as an argument. This argument makes sure that the rendering context is meant for OpenGL ES 3.0 version.</p><p>We can modify the rendering context properties to configure the format of the drawable frame buffer object, such as <code class="literal">drawableColorFormat</code>, <code class="literal">drawableDepthFormat</code>, <code class="literal">drawableStencilFormat</code> and <code class="literal">drawableMultisample</code>.</p><p>This method is also a <a id="id95" class="indexterm"/>good place for initialization and other resource allocations. The last line is calling the setupGL <code class="literal">function[self setupGL]</code> in the objective C++ language syntax. Therefore, it is equivalent to this <code class="literal">setupGL()</code> in C++:</p><div class="informalexample"><pre class="programlisting">//  ViewController.mm
- (void)setupGL
{
  [EAGLContext setCurrentContext:self.context];
  GLint defaultFBO, defaultRBO;

  glGetIntegerv(GL_FRAMEBUFFER_BINDING &amp;defaultFBO);
  glGetIntegerv(GL_RENDERBUFFER_BINDING, &amp;defaultRBO);
  glBindFramebuffer( GL_FRAMEBUFFER, defaultFBO );
  glBindRenderbuffer( GL_RENDERBUFFER, defaultRBO );
    
  setupGraphics(self.view.bounds.size.width,
  self.view.bounds.size.height);

}</pre></div><p>The setupGL function sets the current context with the one we created in <code class="literal">viewDidApplication</code>. This is very important to make the OpenGL ES APIs work. The <code class="literal">glBindFramebuffer</code> and <code class="literal">glBindRenderbuffer</code> APIs help the other APIs to know which target framebuffer to render on. In OpenGLES, the data is rendered in a rectangular array of information buffer container called a framebuffer. A framebuffer comprises many other helping buffers, such as color, depth, and stencil buffer, to accomplish rendering on the screen window. Sometimes, there could be cases where we may lose framebuffer or the render buffer. In such cases, it is advisable to bind these buffers with these two functions before you call any OpenGL ES3.0 API.</p><p>In order to render our application, we must override the <code class="literal">drawRect</code> method:</p><div class="informalexample"><pre class="programlisting">//  ViewController.mm
- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect
{
    renderFrame();
}</pre></div><p>The <code class="literal">renderFrame</code> <a id="id96" class="indexterm"/>function contains all the necessary code to render blue triangle.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec54"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to the <span class="emphasis"><em>The fixed function and programmable pipeline architecture</em></span> recipe in <a class="link" href="apa.html" title="Appendix A. Supplementary Information on OpenGL ES 3.0">Appendix</a>, <span class="emphasis"><em>Supplementary Information on OpenGL ES 3.0</em></span></li><li class="listitem" style="list-style-type: disc">Refer to the <span class="emphasis"><em>Software requirements for OpenGL ES 3.0 – iOS</em></span> recipe in <a class="link" href="apa.html" title="Appendix A. Supplementary Information on OpenGL ES 3.0">Appendix</a>, <span class="emphasis"><em>Supplementary Information on OpenGL ES 3.0</em></span></li><li class="listitem" style="list-style-type: disc">Refer to the <span class="emphasis"><em>Building prototypes using the GLPI framework</em></span> recipe, <a class="link" href="ch02.html" title="Chapter 2. OpenGL ES 3.0 Essentials">Chapter 2</a>, <span class="emphasis"><em>OpenGL ES 3.0 Essentials</em></span></li></ul></div></div></div></body></html>