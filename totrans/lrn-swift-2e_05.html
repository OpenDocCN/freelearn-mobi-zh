<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;A Modern Paradigm &#x2013; Closures and Functional Programming"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. A Modern Paradigm – Closures and Functional Programming</h1></div></div></div><p>So far, we have been programming using the paradigm called <a class="indexterm" id="id225"/>
<span class="strong"><strong>object-oriented programming</strong></span>, where everything in a program is represented as an object that can be manipulated and passed around to other objects. This is the most popular way to create apps because it is a very intuitive way to think about software and it goes well with the way Apple has designed their frameworks. However, there are some drawbacks to this technique. The biggest one is that the state of data can be very hard to track and reason about. If we have a thousand different objects floating around in our app, all with different information, it can be hard to track down where the bugs occurred and it can be hard to understand how the whole system fits together. Another paradigm of programming that can help with this problem is called <a class="indexterm" id="id226"/>
<span class="strong"><strong>functional programming</strong></span>.</p><p>Some programming languages are designed to use only functional programming, but Swift is designed primarily as an object-oriented language with the ability to use functional programming concepts. In this chapter, we will explore how to implement these functional programming concepts in Swift and what they are used for. To do this, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Functional programming philosophy</li><li class="listitem" style="list-style-type: disc">Closures</li><li class="listitem" style="list-style-type: disc">Building blocks of functional programming in Swift</li><li class="listitem" style="list-style-type: disc">Lazy evaluation</li><li class="listitem" style="list-style-type: disc">Example</li></ul></div><div class="section" title="Functional programming philosophy"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec36"/>Functional programming philosophy</h1></div></div></div><p>Before we jump<a class="indexterm" id="id227"/> into writing code, let's discuss the ideas and motivations behind functional programming.</p><div class="section" title="State and side effects"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec42"/>State and side effects</h2></div></div></div><p>Functional <a class="indexterm" id="id228"/>programming makes it significantly easier to think of each component in isolation. This includes things such as types, functions, and methods. If we can wrap our minds around everything that is input into these code components and everything that should be returned from them, we could analyze the code easily to ensure that there are no bugs and it performs well. Every type is created with a certain number of parameters and each method and function in a program has a <a class="indexterm" id="id229"/>certain number of parameters and return values. Normally, we think about these as the only inputs and outputs, but the reality is that often there are more. We refer to these extra inputs and outputs as <span class="strong"><strong>state</strong></span>.</p><p>In a more general sense, state is any stored information, however temporary, that can be changed. Let's consider a simple <code class="literal">double</code> function:</p><div class="informalexample"><pre class="programlisting">func double(input: Int) -&gt; Int {
    return input * 2
}</pre></div><p>This is a great example of a <a class="indexterm" id="id230"/>
<span class="strong"><strong>stateless</strong></span> function. No matter what else is happening in the entire universe of the program, this method will always return the same value, if it is given the same input. An input of <code class="literal">2</code> will always return <code class="literal">4</code>.</p><p>Now, let's look at a method with state:</p><div class="informalexample"><pre class="programlisting">struct Ball {
    var radius: Double
    
    mutating func growByAmount(amount: Double) -&gt; Double {
        self.radius = self.radius + amount
        return self.radius
    }
}</pre></div><p>If you call this method repeatedly, with the same input on the same <code class="literal">Ball</code> instance, you will get a different result every time. This is because there is an additional input in this method, which is the instance it is being called on. It is otherwise referred to as <code class="literal">self</code>. <code class="literal">self</code> is actually both an input and an output of this method, because the original value of radius affects the output and <code class="literal">radius</code> is changed by the end of the method. This is still not very difficult to reason about, as long as you keep in mind that <code class="literal">self</code> is always another input and output. However, you can imagine that with a more complex data structure, it can be hard to track every possible input and output from a piece of code. As soon as that starts to happen, it becomes easier for bugs to get created, because we will almost certainly have, unexpected inputs causing unexpected outputs.</p><p><span class="strong"><strong>Side effects</strong></span> are an even worse type of extra input or output. They are the unexpected changes to <a class="indexterm" id="id231"/>state, seemingly unrelated to the code being run. If we simply rename our preceding method to something a little less clear, its effect on the instance becomes unexpected:</p><div class="informalexample"><pre class="programlisting">mutating func currentRadiusPlusAmount(amount: Double) -&gt; Double {
    self.radius = self.radius + amount
    return self.radius
}</pre></div><p>Based on its name, you wouldn't expect this method to change the actual value of <code class="literal">radius</code>. This means that if you didn't see the actual implementation, you would expect this method to keep returning the same value if called with the same amount on the same instance. Unpredictability is a terrible thing to have as a programmer.</p><p>In its strictest form, functional programming eliminates all state and therefore side effects. We will never go that far in Swift, but we will often use functional programming techniques to reduce state and side effects to increase the predictability of our code, drastically.</p></div><div class="section" title="Declarative versus imperative code"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec43"/>Declarative versus imperative code</h2></div></div></div><p>Besides <a class="indexterm" id="id232"/>predictability, the other effect that functional programming has on our code is that it becomes more <a class="indexterm" id="id233"/>
<span class="strong"><strong>declarative</strong></span>. This means that the code shows us how we expect information to flow through our application. This is in contrast to what we have been doing with object-oriented programming, which we call<a class="indexterm" id="id234"/> <span class="strong"><strong>imperative code</strong></span>. This is the difference between writing a code that loops through an array to add only certain elements to a new array and running a filter on the array. The former would look similar to this:</p><div class="informalexample"><pre class="programlisting">var originalArray = [1,2,3,4,5]
var greaterThanThree = [Int]()
for num in originalArray {
    if num &gt; 3 {
        greaterThanThree.append(num)
    }
}
print(greaterThanThree) // [4,5]</pre></div><p>Running a filter on the array would look similar to this:</p><div class="informalexample"><pre class="programlisting">var originalArray = [1,2,3,4,5]
var greaterThanThree = originalArray.filter {$0 &gt; 3}
print(greaterThanThree) // [4,5]</pre></div><p>Don't worry if you don't understand the second example yet. This is what we are going to cover in the rest of this chapter. The general idea is that with imperative codes, we are going to issue a series of commands with the intent of the code as a secondary, subtler idea. To understand that we are creating a copy of <code class="literal">originalArray</code> with only elements greater than <code class="literal">3</code>, we have to read the code and mentally step through what is happening. In the second example, we are stating in the code itself that we are filtering the original array. Ultimately, these ideas exist on a spectrum and it is hard to have something be 100% declarative or imperative, but the principles of each are important.</p><p>So far, with <a class="indexterm" id="id235"/>our imperative code, most of it just defines what our data should look like and how it can be manipulated. Even with high quality abstractions, understanding a section of code can often involve jumping between lots of methods, tracing the execution. In declarative code, logic can be more centralized and often more easily read, based on well-named methods.</p><p>You can also think of imperative codes as if it were as a factory where each person makes a car in its entirety while thinking of declarative code as if it were a factory with an assembly line. In order to understand what the person is doing in a non-assembly line factory, you have to watch the whole process unfold one step at a time. They will probably be pulling in all kinds of tools at different times and it will be hard to follow. In a factory with an assembly line, you can determine what is happening by looking at each step in the assembly line one at a time.</p><p>Now that we understand some of the motivations of functional programming, let's look at the Swift features that make it possible.</p></div></div></div>
<div class="section" title="Closures"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec37"/>Closures</h1></div></div></div><p>In Swift, functions <a class="indexterm" id="id236"/>are considered first-class citizens, which means that they can be treated the same as any other type. They can be assigned to variables and be passed in and out of other functions. When treated this way, we call them <span class="strong"><strong>closures</strong></span>. This is an extremely critical piece to write more declarative code because it allows us to treat functionalities like objects. Instead of thinking of functions as a collection of code to be executed, we can start to think about them more like a recipe to get something done. Just like you can give just about any recipe to a chef to cook, you can create types and methods that take a closure to perform some customizable behavior.</p><div class="section" title="Closures as variables"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec44"/>Closures as variables</h2></div></div></div><p>Let's take <a class="indexterm" id="id237"/>a look at how closures work in Swift. The simplest way to capture a closure in a variable is to define the function and then use its name to assign it to a variable:</p><div class="informalexample"><pre class="programlisting">func double(input: Int) -&gt; Int {
        return input * 2
}

var doubleClosure = double
print(doubleClosure(2)) // 4</pre></div><p>As you can<a class="indexterm" id="id238"/> see, <code class="literal">doubleClosure</code> can be used just like the normal function name after being assigned. There is actually no difference between using <code class="literal">double</code> and <code class="literal">doubleClosure</code>. Note that we can now think of this closure as an object that will double anything passed to it.</p><p>If you look at the type of <code class="literal">doubleClosure</code> by holding the option key and click on the name, you will see that the type is defined as <code class="literal">(Int) -&gt; Int</code>. The basic type of any closure is <code class="literal">(ParamterType1, ParameterType2, …) -&gt; ReturnType</code>.</p><p>Using this syntax, we can also define our closure inline, such as:</p><div class="informalexample"><pre class="programlisting">var doubleClosure2 = { (input: Double) -&gt; Double in
    return input * 2
}</pre></div><p>We begin and end any closure with curly brackets (<code class="literal">{}</code>). Then, we follow the opening curly bracket with the type for the closure, which will include input parameters and a return value. Finally, we separate the type definition from the actual implementation with the <code class="literal">in</code> keyword.</p><p>An absence of a return type is defined as <code class="literal">Void</code> or <code class="literal">()</code>. Even though you may see that some programmers use parentheses, <code class="literal">Void</code> is preferred for return declarations:</p><div class="informalexample"><pre class="programlisting">var printDouble = { (input: Double) -&gt; Void in
    print(input * 2)
}</pre></div><p>Essentially, <code class="literal">()</code> is an empty tuple meaning it holds no value and it is more commonly used for the input parameters, in case the closure doesn't take any parameters at all:</p><div class="informalexample"><pre class="programlisting">var makeHelloWorld = { () -&gt; String in
    return "Hello World!"
}</pre></div><p>So far, even though we can change our thinking about the block of code by making it into a closure, it is not terribly useful. To really make closures useful, we need to start passing them into other functions.</p></div><div class="section" title="Closures as parameters"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec45"/>Closures as parameters</h2></div></div></div><p>We can <a class="indexterm" id="id239"/>define a function to take a closure as a parameter, using the same type syntax we saw previously:</p><div class="informalexample"><pre class="programlisting">func firstInNumbers(
    numbers: [Int],
    passingTest: (number: Int) -&gt; Bool
    ) -&gt; Int?
{
    for number in numbers {
        if passingTest(number: number) {
            return number
        }
    }
    return nil
}</pre></div><p>Here, we <a class="indexterm" id="id240"/>have a function that can find the first number in an array that passes some arbitrary test. The syntax at the end of the function declaration may be confusing but it should be clear if you work from the inside out. The type for <code class="literal">passingTest</code> is <code class="literal">(number: Int) -&gt; Bool</code>. That is then the second parameter of the whole <code class="literal">firstInNumbers</code> function, which returns an <code class="literal">Int?</code>. If we want to use this function to find the first number greater than three, we can create a custom test and pass that into the function:</p><div class="informalexample"><pre class="programlisting">let numbers = [1,2,3,4,5]
func greaterThanThree(number: Int) -&gt; Bool {
    return number &gt; 3
}
var firstNumber = firstInNumbers(numbers, greaterThanThree)
print(firstNumber) // "Optional(4)"</pre></div><p>Here, we are essentially passing a little bundle of functionality to the <code class="literal">firstInNumbers:</code> function that lets us drastically enhance what a single function can normally do. This is an incredibly useful technique. Looping through an array to find an element can be very verbose. Instead, we can use this function to find an element showing only the important part of the code: the test.</p><p>We can even define our test right in a call to the function:</p><div class="informalexample"><pre class="programlisting">firstNumber = firstInNumbers(numbers, passingTest: { (number: Int) -&gt; Bool in
    return number &gt; 3
})</pre></div><p>Even though this is more concise, it's pretty complex; hence, Swift allows us to cut out some of the unnecessary syntax.</p></div><div class="section" title="Syntactic sugar"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec46"/>Syntactic sugar</h2></div></div></div><p>First, we <a class="indexterm" id="id241"/>can make use of type inference for the type of <code class="literal">number</code>. The compiler knows that number needs to be <code class="literal">Int</code> based on the definition of <code class="literal">firstInNumbers:passingTest:</code>. It also knows that the closure has to return <code class="literal">Bool</code>. Now, we can rewrite our call, as shown:</p><div class="informalexample"><pre class="programlisting">firstNumber = firstInNumbers(numbers, passingTest: { (number) in
    return number &gt; 3
})</pre></div><p>This looks cleaner, but the parentheses around <code class="literal">number</code> are not required; we could leave those out. In <a class="indexterm" id="id242"/>addition, if we have closure as the last parameter of a function, we can provide the closure outside the parentheses for the function call:</p><div class="informalexample"><pre class="programlisting">firstNumber = firstInNumbers(numbers) { number in
    return number &gt; 3
}</pre></div><p>Note that the closing parenthesis for the function parameters moved from being after the closure to before it. This is looking pretty great, but we can go even further. For a single line closure, we don't even have to write the <code class="literal">return</code> keyword because it is implied:</p><div class="informalexample"><pre class="programlisting">firstNumber = firstInNumbers(numbers) { number in
    number &gt; 3
}</pre></div><p>Lastly, we don't always need to give a name to the parameters of closures. If you leave out the names altogether, each parameter can be referenced using the syntax <code class="literal">$&lt;ParemterIndex&gt;</code>. Just like with arrays, the index starts at <code class="literal">0</code>. This helps us write this call very concisely in a single line:</p><div class="informalexample"><pre class="programlisting">firstNumber = firstInNumbers(numbers) { $0 &gt; 3 }</pre></div><p>This is a long way from our original syntax. You can mix and match all of these different techniques to make sure that your code is as understandable as possible. As we have discussed before, understandability is a balance between being concise and clear. It is up to you in each circumstance to decide how much syntax you want to cut out. To me, it is not immediately clear what the closure is without it having a name. My preferred syntax for this is to use the parameter name in the call:</p><div class="informalexample"><pre class="programlisting">firstNumber = firstInNumbers(numbers, passingTest: {$0 &gt; 3})</pre></div><p>This makes it clear that the closure is a test to see which number we want to pull out of the list.</p><p>Now that we know what a closure is and how to use one, we can discuss some of the core features of Swift that allow us to write a functional style code.</p></div></div>
<div class="section" title="Building blocks of functional programming in Swift"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec38"/>Building blocks of functional programming in Swift</h1></div></div></div><p>The first <a class="indexterm" id="id243"/>thing to realize is that Swift is not a <a class="indexterm" id="id244"/>functional programming language. At its core, it will always be an object-oriented programming language. However, since functions in Swift are first-class citizens, we can use some of the core techniques. Swift provides some built-in methods to get us started.</p><div class="section" title="Filter"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec47"/>Filter</h2></div></div></div><p>The first <a class="indexterm" id="id245"/>method we are going to discuss is called <span class="strong"><strong>filter</strong></span>. As the name suggests, this method is used to filter elements in a list. For example, we can filter our <code class="literal">numbers</code> array to include only even numbers:</p><div class="informalexample"><pre class="programlisting">var evenNumbers = numbers.filter({ element in
    element % 2 == 0
}) // [2, 4]</pre></div><p>The closure we provide to filter will be called once for each element in the array. It is tasked with returning <code class="literal">true</code> if the element needs to be included in the result and <code class="literal">false</code> otherwise. The preceding closure takes advantage of the implied return value and simply returns <code class="literal">true</code> if the number has a remainder of zero when being divided by two.</p><p>Note that the filter does not change the <code class="literal">numbers</code> variable; it simply returns a filtered copy. Changing the value will modify the state, which we want to avoid.</p><p>This method provides us with a concise way to filter a list in virtually any way we want. It is also the beginning of building up a vocabulary of transformations, which we can perform on data. One could argue that all applications just transform data from one form to another, so this vocabulary helps us achieve the maximum functionality we want in any app.</p></div><div class="section" title="Reduce"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec48"/>Reduce</h2></div></div></div><p>Swift also <a class="indexterm" id="id246"/>provides a method called <span class="strong"><strong>reduce</strong></span>. The purpose of reduce is to condense a list down to a single value. Reduce works by iterating over every value and combining it with a single value that represents all previous elements. This is just like mixing a bunch of ingredients in a bowl for a recipe. We will take one ingredient at a time and combine it in the bowl until we are left with just a single bowl of ingredients.</p><p>Let's take a look at what the reduce function looks like in our code. We can use it to sum up the values in our number array:</p><div class="informalexample"><pre class="programlisting">var sum = numbers.reduce(0, combine: { previousSum, element in
    previousSum + element
}) // 15</pre></div><p>As you can see, reduce takes two parameters. The first parameter is a value with which to start combining each item in the list. The second is a closure that will do the combining. Similar to filter, this closure is called once for each element in the array. The first parameter of the closure is the value after combing each of the previous elements with the initial value. The second parameter is the next element.</p><p>So the first time the closure is called, it is called with <code class="literal">0</code> (the initial value) and <code class="literal">1 </code>(the first element of the list); it then returns <code class="literal">1</code>. This means that it is then called again with <code class="literal">1</code> (the value from the last call) and <code class="literal">2</code> (the next element in the list) returning <code class="literal">3</code>. This will continue until it is combining the running sum of <code class="literal">10</code>, with the last element <code class="literal">5</code>, returning a final result of <code class="literal">15</code>. It becomes very simple once we break it down.</p><p><span class="strong"><strong>Reduce</strong></span> is <a class="indexterm" id="id247"/>another great vocabulary item to add to our skill-set. It can reduce any list of information into a single value by analyzing data to generate a document from a list of images and much more.</p><p>Also, we can start to chain our functions together. If we want to find the sum of all the even numbers in our list, we can run the following code:</p><div class="informalexample"><pre class="programlisting">var evenSum = numbers.filter({$0 % 2 == 0}).reduce(0, combine: {$0 + $1}) // 6</pre></div><p>Now, we can actually do one more thing to shorten this. Every arithmetic operation, including addition (<code class="literal">+</code>) is really just another function or closure. Addition is a function that takes two values of the same type and returns their sum. This means that we can simply pass the addition function as our combine closure:</p><div class="informalexample"><pre class="programlisting">evenSum = numbers.filter({$0 % 2 == 0}).reduce(0, combine: +) // 6</pre></div><p>Now we are getting fancy!</p><p>Also, keep in mind that the combined value does not need to be the same type that is in the original list. Instead of summing the values, we could combine them all into one string:</p><div class="informalexample"><pre class="programlisting">let string = numbers.reduce("", combine: {"\($0)\($1)"}) // "12345"</pre></div><p>Here I am using string interpolation to create a string that starts with the running value and ends with the next element.</p></div><div class="section" title="Map"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec49"/>Map</h2></div></div></div><p><span class="strong"><strong>Map</strong></span> is a<a class="indexterm" id="id248"/> method to transform every element in a list to another value. For example, we can add one to every number in the list:</p><div class="informalexample"><pre class="programlisting">let plusOne = numbers.map({ element -&gt; Int in
    return element + 1
}) // [2, 3, 4, 5, 6]</pre></div><p>As you can probably guess, the closure that map takes is called once for each element in the list. As a parameter, it takes the element and is expected to return the new value to be added to the resulting array.</p><p>Just like with reduce, the transformed type does not need to match. We can convert all of our numbers to strings:</p><div class="informalexample"><pre class="programlisting">let strings = numbers.map {String($0)}</pre></div><p>Map is incredibly versatile. It can be used to convert a list of data into a list of views to display the data, convert a list of image paths to their loaded images, and so on.</p><p>The map <a class="indexterm" id="id249"/>method is a great choice to perform calculations on each element of a list, but it should be used only when it makes sense to put the result of the calculation back into a list. You could technically use it to iterate through a list and perform some other action, but in that case, a for-in loop is more appropriate.</p></div><div class="section" title="Sort"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec50"/>Sort</h2></div></div></div><p>The last built-in <a class="indexterm" id="id250"/>functional method we will discuss is called <span class="strong"><strong>sorted</strong></span>. As the name suggests, sorted allows you to change the order of a list. For example, if we want to reorder our numbers list to go from largest to smallest:</p><div class="informalexample"><pre class="programlisting">numbers.sort({ element1, element2 in
    element1 &gt; element2
}) // [5, 4, 3, 2, 1]</pre></div><p>The closure that is passed into sorted is called <code class="literal">isOrderedBefore</code>. This means that it takes two elements in the list as input and it should return <code class="literal">true</code> if the first element is to be ordered before the second element. We cannot rely on the closure to be called a certain number of times, nor the elements it will be called with, but it will be called until the sorting algorithm has enough knowledge to come up with a new order.</p><p>In our case, we return <code class="literal">true</code> any time the first argument is greater than the second argument. This results in larger elements always coming before smaller elements.</p><p>This is a great method because sorting is a very common task and often data will need to be sorted in multiple ways, depending on the user's interaction. Using this method, you could design multiple sorting closures and change the one being used based on the user's interaction.</p></div><div class="section" title="How these affect the state and nature of code"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec51"/>How these affect the state and nature of code</h2></div></div></div><p>There are more <a class="indexterm" id="id251"/>built-in functional methods and we will learn to write our own in the next chapter on generics, but these are a core few to help you start thinking about certain problems in a functional way. So how do these methods help us avoid state?</p><p>These methods, along with others, can be combined in infinite ways to transform data and perform actions. No matter how complex the combination is, there is no way to interfere with each individual step. There are no side effects because the only inputs are the result of the preceding step and the only outputs are what will be passed on to the next step.</p><p>You can also see that complex transformations can all be declared in a concise and centralized place. A reader of the code doesn't need to trace the changing values of many variables; they <a class="indexterm" id="id252"/>can simply look at the code and see what processes it will go through.</p></div></div>
<div class="section" title="Lazy evaluation"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec39"/>Lazy evaluation</h1></div></div></div><p>A <a class="indexterm" id="id253"/>powerful feature of Swift is the ability to make these operations lazily evaluated. This means that, just like a lazy person would do, a value is only calculated when it is absolutely necessary and at the latest point possible.</p><p>First, it is important to realize the order in which these methods are executed. For example, what if we only want the first element of our numbers to be mapped to strings:</p><div class="informalexample"><pre class="programlisting">var firstString = numbers.map({String($0)}).first</pre></div><p>This works well, except that we actually converted every number to a string to get to just the first one. That is because each step of the chain is completed in its entirety before the next one can be executed. To prevent this, Swift has a built-in method called <span class="strong"><strong>lazy</strong></span>.</p><p>Lazy creates a new version of a container that only pulls specific values from it when it is specifically requested. This means that lazy essentially allows each element to flow through a series of functions one at a time, as it is needed. You can think about it like a lazy version of a worker. If you ask someone lazy to look up the capital of Cameroon, they aren't going to compile a list of the capitals of all countries before they get the answer. They are only going to do the work necessary to get that specific answer. That work may involve multiple steps, but they would only have to do those steps for the specific countries you ask for.</p><p>Now, let's look at what lazy looks like in code. You use it to convert a normal list into a lazy list:</p><div class="informalexample"><pre class="programlisting">firstString = numbers.lazy.map({String($0)}).first</pre></div><p>Now, instead of calling map directly on <code class="literal">numbers</code>, we called it on the lazy version of <code class="literal">numbers</code>. This makes it so that every time a value is requested from the result, it only processes a single element out of the input array. In our preceding example, the <code class="literal">map</code> method will only have been performed once.</p><p>This even applies to looping through a result:</p><div class="informalexample"><pre class="programlisting">let lazyStrings = numbers.lazy.map({String($0)})
for string in lazyStrings {
    print(string)
}</pre></div><p>Each number is converted to a string only upon the next iteration of the for-in loop. If we were to <a class="indexterm" id="id254"/>break out of that loop early, the rest of the values would not be calculated. This is a great way to save processing time, especially on large lists.</p></div>
<div class="section" title="Example"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec40"/>Example</h1></div></div></div><p>Let's take a <a class="indexterm" id="id255"/>look at what this looks like in practice. We can use some of the techniques we learned in this chapter to write a different and possibly better implementation of our party inviter.</p><p>We can start by defining the same input data:</p><div class="informalexample"><pre class="programlisting">//: List of people to invite
let invitees = [
    "Sarah",
    "Jamison",
    "Marcos",
    "Roana",
    "Neena",
]

//: Dictionary of shows organized by genre
var showsByGenre = [
    "Comedy": "Modern Family",
    "Drama": "Breaking Bad",
    "Variety": "The Colbert Report",
]</pre></div><p>In this implementation, we are making the invitees list, which is just a constant list of names and the shows by genre dictionary variable. This is because we are going to be mapping our invitees list to a list of invitation text. As we do the mapping, we will have to pick a random genre to assign to the current invitee, and in order to avoid assigning the same genre more than once, we can remove the genre from the dictionary.</p><p>So let's write the random <code class="literal">genre</code> function:</p><div class="informalexample"><pre class="programlisting">func pickAndRemoveRandomGenre() -&gt; (genre: String, example: String)? {
    let genres = Array(showsByGenre.keys)
    guard genres.count &gt; 0 else {
        return nil
    }

    let genre = genres[Int(rand()) % genres.count]
    let example = showsByGenre[genre]!
    showsByGenre[genre] = nil
    return (genre: genre, example: example)
}</pre></div><p>We start by creating an array of just the keys of the shows by genre dictionary. Then, if there are no genres left, we simply return nil. Otherwise, we pick out a random genre, remove it from the dictionary, and return it and the show example.</p><p>Now we can use that function to map the invitees to a list of invitations:</p><div class="informalexample"><pre class="programlisting">let invitations: [String] = invitees
.map({ name in
    guard let (genre, example) = pickAndRemoveRandomGenre() else {
        return "\(name), just bring yourself"
    }
    return "\(name), bring a \(genre) show"
        + "\n\(example) is a great \(genre)"
})</pre></div><p>Here <a class="indexterm" id="id256"/>we try to pick a random genre. If we can't, we return an invitation saying that the invitee should just bring themselves. If we can, we return an invitation saying what genre they should bring with the example show. The one new thing to note here is that we are using the sequence <code class="literal">"\n"</code> in our string. This is a newline character and it signals that a new line should be started in the text.</p><p>The last step is to print out the invitations. To do that, we can print out the invitations as a string joined by newline characters:</p><div class="informalexample"><pre class="programlisting">print(invitations.joinWithSeparator("\n"))</pre></div><p>This works pretty well but there is one problem. The first invitees we listed will always be assigned a genre because the order they are processed in never changes. To fix this, we can write a function to shuffle the invitees before we begin to map the function:</p><div class="informalexample"><pre class="programlisting">func shuffle(array: [String]) -&gt; [String] {
    return array
        .map({ ($0, Int(rand())) })
        .sort({ $0.1 &lt; $1.1 })
        .map({$0.0})
}</pre></div><p>In order to shuffle an array, we go through three steps: First, we map the array to a tuple with the original element and a random number. Second, we sort the tuples based on those random numbers. Finally, we map the tuples back to just their original elements.</p><p>Now, all we have to do is add a call to this function to our sequence:</p><div class="informalexample"><pre class="programlisting">let invitations: [String] = shuffle(invitees)
.map({ name in
    guard let (genre, example) = pickAndRemoveRandomGenre() else {
        return "\(name), just bring yourself"
    }
    return "\(name), bring a \(genre) show"
        + "\n\(example) is a great \(genre)"
})</pre></div><p>This implementation is not necessarily better than our previous implementations, but it definitely has its<a class="indexterm" id="id257"/> advantages. We have taken steps towards reducing the state by implementing it as a series of data transformations. The big hiccup in that is that we are still maintaining state in the genre dictionary. We can certainly do more to eliminate that as well, but this gives you a good idea of how we can start to think about problems in a functional way. The more ways in which we can think about a problem, the higher our odds of coming up with the best solution.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec41"/>Summary</h1></div></div></div><p>In this chapter, we have had to shift the way we think about code. At the very least, this is a great exercise so we don't get set in our programming ways. We have covered the philosophy behind functional programming and how it differs from object-oriented programming. We have looked into the specifics of closures and how they enable functional programming techniques in Swift. Lastly, we explored some of the specific functional methods that Swift has built in.</p><p>The sign of a truly great programmer is not someone who knows a lot about one tool, but one who knows which tool to use when. We get there by learning and practicing using lots of different tools and techniques without ever becoming too attached to a specific one.</p><p>Once you are comfortable with the concepts of closures and functional programming, you are ready to move on to our next topic, generics. Generics is our first opportunity to make the strongly typed nature of Swift really work for us.</p></div></body></html>