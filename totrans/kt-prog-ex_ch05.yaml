- en: Building the Messenger Android App – Part I
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建信使Android应用程序 – 第I部分
- en: In the previous chapter, we began building the messenger application by designing
    and implementing a REST application programming interface that the client messenger
    application will communicate with. Over the course of implementing the backend
    API, we covered many things, such as working with Spring Boot, RESTful application
    programming interfaces and how they work, creating databases with PostgreSQL,
    and deploying Spring Boot web applications to AWS, to name a few.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们开始构建信使应用程序，通过设计和实现客户端信使应用程序将与之通信的REST应用程序编程接口。在实现后端API的过程中，我们涵盖了众多内容，例如使用Spring
    Boot、RESTful应用程序编程接口及其工作原理、使用PostgreSQL创建数据库，以及将Spring Boot Web应用程序部署到AWS等，仅举几例。
- en: 'In this chapter, we will go one step further in our application development
    journey by implementing the Android Messenger application and integrating it with
    the RESTful API we created in [Chapter 4](kt-prog-ex_ch04.html), *Designing and
    Implementing the Messenger Backend with Spring Boot 2.0*. In the process of developing
    the Messenger Android app, we will learn a vast array of new topics, such as:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过实现Android Messenger应用程序并将其与我们创建的RESTful API（[第4章](kt-prog-ex_ch04.html)，*使用Spring
    Boot 2.0设计和实现Messenger后端*）集成，进一步深入我们的应用程序开发之旅。在开发Messenger Android应用程序的过程中，我们将学习大量新主题，例如：
- en: Building MVP Android applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建MVP Android应用程序
- en: Server communication via HTTP
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过HTTP进行服务器通信
- en: Working with Retrofit
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Retrofit进行操作
- en: Reactive programming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式编程
- en: Using token-based authentication in an Android app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android应用中使用基于令牌的认证
- en: Over the course of this chapter, you will learn firsthand how powerful Kotlin
    is in the Android application development domain. Let's dive into the development
    of the Messenger app.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将亲身体验到Kotlin在Android应用程序开发领域的强大功能。让我们深入到信使应用程序的开发中。
- en: Developing the Messenger app
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发信使应用程序
- en: First, we need to create a new Android Studio project for the application. Create
    a new Android Studio project with the name `Messenger` and the package name `com.example.messenger`.
    Feel free to take a look at [Chapter 1](kt-prog-ex_ch01.html), *The Fundamentals*,
    to refresh your memory on Android project creation. In the process of project
    setup, when asked to create a new launcher activity, name the activity `LoginActivity`
    and make it an empty activity.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为应用程序创建一个新的Android Studio项目。创建一个名为`Messenger`、包名为`com.example.messenger`的新Android
    Studio项目。您可以随意查看[第1章](kt-prog-ex_ch01.html)，*基础*，以刷新您对Android项目创建的记忆。在项目设置过程中，当被要求创建一个新的启动器活动时，将活动命名为`LoginActivity`并使其成为一个空活动。
- en: Including project dependencies
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包含项目依赖项
- en: 'Over the course of this chapter, we will make use of a number of external application
    dependencies. As such, it is important we include them in the project now. Open
    your module-level `build.gradle` file and add the following dependencies to it:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用多个外部应用程序依赖项。因此，现在将它们包含在项目中非常重要。打开您的模块级`build.gradle`文件，并添加以下依赖项到其中：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Ensure that no conflicting Android support library versions exist in the `build.gradle`
    file. Now modify the `build.gradle` project file to include the `jcenter` and
    Google repositories as well as the Android build tools dependency:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在`build.gradle`文件中不存在冲突的Android支持库版本。现在修改`build.gradle`项目文件，以包含`jcenter`和Google仓库以及Android构建工具依赖项：
- en: 'Top-level build file where you can add configuration options common to all
    sub-projects/modules:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级构建文件，其中您可以添加适用于所有子项目/模块的配置选项：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Don't worry, about what the dependencies added for now, all will be revealed
    over the course of this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心现在添加的依赖项，所有内容将在本章中一一揭晓。
- en: Developing the Login UI
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发登录用户界面
- en: Once the project is created, create a new package named `ui` in the `com.example.messenger`
    application source package. This package will hold all the user-interface-related
    classes and logic of the Android application. Create a `login` package within
    `ui`.  As you may have guessed, this package will hold classes and logic pertaining
    to the user-login process. Go ahead and move `LoginActivity` to the `login` package.
    Having moved `LoginActivity`, our first order of business is to create a suitable
    layout for the login activity.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目创建完成，在`com.example.messenger`应用程序源包中创建一个名为`ui`的新包。这个包将包含Android应用程序中所有与用户界面相关的类和逻辑。在`ui`包内创建一个`login`包。正如你可能已经猜到的，这个包将包含与用户登录过程相关的类和逻辑。将`LoginActivity`移动到`login`包中。移动了`LoginActivity`之后，我们的首要任务是创建一个适合登录活动的布局。
- en: 'Locate the `activity_login.xml` layout resource file and change the following
    content:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 定位到`activity_login.xml`布局资源文件并更改以下内容：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There are string and dimension resources that we have made use of here that
    we have not yet created in the appropriate `.xml` resource files. We must add
    these resources at this juncture. While we are at it, we will also include resources
    that we will require later on in the application development phase so as to eliminate
    the need to jump back and forth between program files and resource files. Open
    the project''s string resource file (`strings.xml`) and ensure the following resources
    are added to it:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了一些字符串和尺寸资源，但我们还没有在适当的`.xml`资源文件中创建它们。我们必须在此处添加这些资源。同时，我们还将包括在应用程序开发阶段后期可能需要的资源，以消除在程序文件和资源文件之间跳转的需要。打开项目的字符串资源文件（`strings.xml`）并确保以下资源被添加到其中：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now create a dimensions resource file (`dimens.xml`) and add the following
    dimension resources to it:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个尺寸资源文件（`dimens.xml`）并将以下尺寸资源添加到其中：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that the necessary project resources have been added, navigate back to
    `activity_login.xml` and toggle the design preview screen to view the layout that
    has been created:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经添加了必要的项目资源，导航回`activity_login.xml`并切换设计预览屏幕以查看创建的布局：
- en: '![](img/36fd17e0-95ab-4357-933c-b2118da19fc8.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/36fd17e0-95ab-4357-933c-b2118da19fc8.jpg)'
- en: The layout is simple but functional, which is perfect for this simple messenger
    application we are building.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 布局简单但实用，这对于我们正在构建的简单消息应用来说非常完美。
- en: Creating the login view
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建登录视图
- en: 'Now we have to work on `LoginActivity`. As we are building this application
    utilizing the MVP pattern, `LoginActivity` is effectively a view.  Obviously,
    `LoginActivity` is quite different from any generic view. It is a view that is
    concerned with login procedures. We can identify a set of necessary behaviors
    that a view presenting a login interface to a user must possess. Such behaviors
    are:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须处理`LoginActivity`。由于我们正在使用MVP模式构建此应用程序，`LoginActivity`实际上是一个视图。显然，`LoginActivity`与任何通用视图都大不相同。它是一个关注登录过程的视图。我们可以确定一组必要的操作，一个向用户展示登录界面的视图必须具备这些操作。这些行为包括：
- en: It must show a progress bar to a user when the login is in progress
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当登录正在进行时，它必须向用户显示进度条
- en: It must be capable of hiding the progress bar when the need arises
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要时，它必须能够隐藏进度条
- en: It must be able to show appropriate field errors to users when encountered
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须能够在遇到时向用户显示适当的字段错误
- en: It must be able to navigate the user to his home screen
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须能够将用户导航到其主页
- en: It must be able to navigate an unregistered user to a signup screen
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须能够将未注册用户导航到注册屏幕
- en: 'Having identified the preceding behaviors, we must ensure that `LoginActivity`—as
    a login view—exhibits such behaviors. A perfect way to do this is to utilize an
    interface. Create a `LoginView` interface in the `login` package containing the
    following content:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 确定了前面的行为后，我们必须确保`LoginActivity`——作为一个登录视图——展现出这些行为。一个完美的方法是利用接口。在`login`包中创建一个名为`LoginView`的接口，包含以下内容：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So far, so good with `LoginView`. There are a few issues with our interface
    though. A `LoginView` must have the ability to bind its layout views to appropriate
    object representations. In addition, a `LoginView` must be able to provide feedback
    to the user if an authentication error occurs. You may be thinking that neither
    of these two behaviors should be distinct to a `LoginView`. You are right. All
    views should have the ability to bind layout elements to programmatic objects.
    In addition, a signup view should also be able to provide the user with some kind
    of feedback if there is a problem during authentication.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`LoginView`的情况还不错。不过，我们的接口存在一些问题。一个`LoginView`必须能够将其布局视图绑定到适当的对象表示。此外，如果发生身份验证错误，`LoginView`必须能够向用户提供反馈。你可能认为这两个行为都不应该与`LoginView`区分开来。你说得对。所有视图都应该能够将布局元素绑定到程序性对象。此外，注册视图也应该能够在身份验证过程中出现问题时向用户提供某种形式的反馈。
- en: 'We will create two distinct interfaces to enforce these behaviors. We will
    name the first interface `BaseView`. Create a `base` package in `com.example.messenger.ui`
    and add an interface named `BaseView` to the package with the following content:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个不同的接口来强制执行这些行为。我们将第一个接口命名为`BaseView`。在`com.example.messenger.ui`中创建一个`base`包，并向该包中添加一个名为`BaseView`的接口，内容如下：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `BaseView` interface enforces that an implementing class declares `bindViews()`
    and `getContext()` functions for view bindings and context retrievals, respectively.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseView`接口强制实现类声明`bindViews()`和`getContext()`函数，分别用于视图绑定和上下文检索。'
- en: 'Now create an `auth` package in `com.example.messenger.ui` and add an interface
    named `AuthView` to the package with the following content:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`com.example.messenger.ui`中创建一个`auth`包，并向该包中添加一个名为`AuthView`的接口，内容如下：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Fantastic job! Now go back to the `LoginView` interface and ensure that it
    extends `BaseView` and `AuthView`, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！现在回到`LoginView`接口，确保它扩展`BaseView`和`AuthView`，如下所示：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By declaring the `LoginView` interface as an extension of `BaseView` and `AuthView`,
    we ensure that every class that implements `LoginView` must declare the `bindViews()`,
    `getContext()`, and `showAuthError()` functions in addition to those declared
    in `LoginView`. It is important to note that any class that implements `LoginView`
    is effectively of the `LoginView`, `BaseView`, and `AuthView` type. The characteristic
    of a class possessing many types is known as polymorphism.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`LoginView`接口声明为`BaseView`和`AuthView`的扩展，我们确保每个实现`LoginView`的类都必须声明`bindViews()`、`getContext()`和`showAuthError()`函数，以及`LoginView`中声明的那些函数。重要的是要注意，任何实现`LoginView`的类实际上都是`LoginView`、`BaseView`和`AuthView`类型的。一个类具有许多类型的特征被称为多态。
- en: 'Having set up the `LoginView`, we can go ahead and work on `LoginActivity`.
    Firstly we will create `LoginActivity` to implement the methods declared in  `BaseView`
    and `AuthView` after which we will add the methods specific to a `LoginView`.
    `LoginActivity` is shown in the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置了`LoginView`之后，我们可以继续工作在`LoginActivity`上。首先，我们将创建`LoginActivity`以实现`BaseView`和`AuthView`中声明的方
    法，然后我们将添加特定于`LoginView`的方法。`LoginActivity`的代码如下：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Binds layout view object references to view elements when invoked:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用时将布局视图对象引用绑定到视图元素：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So far so good. We have successfully implemented `BaseView` and `AuthView` methods
    in `LoginActivity`. We still must work on the `LoginView` specific methods `showProgress()`,
    `hideProgress()`, `setUsernameError()`, `setPasswordError()`, `navigateToSignUp()`
    and `navigateToHome()`. The required implementation of these  methods is given
    below. Go ahead and add them to `LoginActivity`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利。我们已经成功地在`LoginActivity`中实现了`BaseView`和`AuthView`方法。我们仍然必须处理`LoginView`特定的方法`showProgress()`、`hideProgress()`、`setUsernameError()`、`setPasswordError()`、`navigateToSignUp()`和`navigateToHome()`。这些方法的必要实现如下。继续并将它们添加到`LoginActivity`中。
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Adding all the defined methods earlier, you have made the `LoginActivity` class
    to implement `LoginView` as well as the `View.OnClickListener` interface. As such,
    `LoginActivity` provides implementations for functions declared within these interfaces.
    Notice how the current instance of the `LoginActivity` is passed as an argument
    to `btnLogin.setOnClickListener()` via `this`. We can do this because we have
    declared `LoginActivity` to implement the `View.OnClickListener` interface. As
    such, `LoginActivity` is a valid `View.OnClickListener` instance (this is a perfect
    example of polymorphism at work).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 添加之前定义的所有方法后，你使`LoginActivity`类实现了`LoginView`以及`View.OnClickListener`接口。因此，`LoginActivity`提供了这些接口中声明的函数的实现。注意当前`LoginActivity`实例是如何通过`this`传递给`btnLogin.setOnClickListener()`的。我们可以这样做，因为我们已经将`LoginActivity`声明为实现了`View.OnClickListener`接口。因此，`LoginActivity`是一个有效的`View.OnClickListener`实例（这是一个多态工作的完美例子）。
- en: Now that we have done some reasonable work on the login view, we must create
    an appropriate model to handle login logic. We must also create the necessary
    services and data repositories that this model will communicate with. We will
    first work on the required services and then develop the necessary data repositories
    before we build the interactor.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对登录视图做了一些合理的工作，我们必须创建一个适当的模型来处理登录逻辑。我们还需要创建这个模型将与之通信的必要服务和数据存储库。我们首先将处理所需的服务，然后开发必要的数据存储库，最后构建交互器。
- en: Creating the Messenger API service and data repositories
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Messenger API服务和数据存储库
- en: 'A critical thing that we must consider before getting too deep in our application
    development process is data storage. We must ask ourselves two very important
    questions: Where will data be stored, and how will the stored data be accessed?'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入我们的应用程序开发过程之前，我们必须考虑一个关键问题：数据存储。我们必须问自己两个非常重要的问题：数据将存储在哪里，以及如何访问存储的数据？
- en: Pertaining to the location of data storage, data will be stored both locally
    (on the Android device) and remotely (on the Messenger API). The answer to the
    second question is similarly straightforward. To access stored data, we need to
    create suitable models, services, and repositories to facilitate data retrieval.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数据存储的位置，数据将同时本地存储（在Android设备上）和远程存储（在Messenger API上）。第二个问题的答案同样简单直接。为了访问存储的数据，我们需要创建合适的模型、服务和存储库以方便数据检索。
- en: Storing data locally with SharedPreferences
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SharedPreferences本地存储数据
- en: First and foremost, we need to take care of local storage. As this is a simple
    application, we do not need to store much data locally. The only data we need
    to store on the device are access tokens and user details. We will be using `SharedPreferences`
    to do this.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先最重要的是，我们需要注意本地存储。由于这是一个简单的应用程序，我们不需要在本地存储很多数据。我们只需要在设备上存储访问令牌和用户详情。我们将使用`SharedPreferences`来完成这项工作。
- en: 'First things first, create a `data` package within the application''s `source`
    package. We previously identified that we are going to be working with data stored
    locally and remotely. Hence, create two additional packages within `data`. Name
    the first `local` and the second `remote`. Similar to the approach that we used
    for the *Tetris* application that we created in [Chapter 2](kt-prog-ex_ch02.html), *Building
    an Android Application – Tetris* and [Chapter 3](kt-prog-ex_ch03.html), *Implementing
    Tetris Logic and Functionality*, we will be using an `AppPreferences` class to
    persist data locally. Create an `AppPreferences` class within `local` and populate
    it with the following content:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在应用程序的`source`包内创建一个`data`包。我们之前已经确定我们将要处理本地和远程存储的数据。因此，在`data`包内创建两个额外的包。第一个命名为`local`，第二个命名为`remote`。类似于我们在[第2章](kt-prog-ex_ch02.html)中创建的*Tetris*应用程序所采用的方法，即[构建Android应用程序
    – Tetris](kt-prog-ex_ch03.html)和[实现Tetris逻辑和功能](kt-prog-ex_ch03.html)，我们将使用`AppPreferences`类来本地持久化数据。在`local`包内创建一个`AppPreferences`类，并填充以下内容：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Returns an instance of `UserVO` containing appropriate user details:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 返回包含适当用户详情的`UserVO`实例：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Stores user details passed in `UserVO` to the application''s `SharedPreferences`
    file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 将通过`UserVO`传递给应用程序的`SharedPreferences`文件的用户详情存储起来：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In `AppPreferences`, we defined the `storeAccessToken(String)`, `storeUserDetails(UserVO)`,
    and `clear()` functions. `storeAccessToken(String)` will be used to store an access
    token retrieved from the remote server to the local preferences file. `storeUserDetails(UserVO)`
    takes a user value object (a data object that contains user information) as its
    only argument and stores the information contained in the value object to the
    preferences file. The `clear()` method, as the name implies, clears all values
    that have been stored in the preferences file. The `AppPreferences` instance also
    has `accessToken` and  `userDetails` properties, each having specialized getter
    functions to retrieve their appropriate values. In addition to this the functions
    and properties defined in `AppPreferences`, we also created a companion object
    possessing a single `create(Context)` function. The `create()` method, as the
    name implies, creates and returns a new `AppPreferences` instance for use. We
    made the primary constructor of `AppPreferences` private as we require that any
    class utilizing `AppPreferences` make use of `create()` for the instantiation
    of `AppPreferences`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AppPreferences`中，我们定义了`storeAccessToken(String)`、`storeUserDetails(UserVO)`和`clear()`函数。`storeAccessToken(String)`将用于将远程服务器检索到的访问令牌存储到本地首选项文件中。`storeUserDetails(UserVO)`接受一个用户值对象（包含用户信息的数据对象）作为其唯一参数，并将值对象中包含的信息存储到首选项文件中。`clear()`方法，正如其名称所暗示的，清除首选项文件中存储的所有值。`AppPreferences`实例还具有`accessToken`和`userDetails`属性，每个属性都有专门的getter函数来检索其适当的值。除了在`AppPreferences`中定义的函数和属性之外，我们还创建了一个拥有单个`create(Context)`函数的伴生对象。`create()`方法，正如其名称所暗示的，创建并返回一个新的`AppPreferences`实例以供使用。我们将`AppPreferences`的主要构造函数设为私有，因为我们要求任何使用`AppPreferences`的类都使用`create()`来实例化`AppPreferences`。
- en: Creating value objects
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建值对象
- en: Similar to what we did when creating the messenger backend, we need to create
    value objects to model common types of data we will be handling across the application.
    Create a `vo` package in the `data` package. The value objects we are creating
    are already familiar to you. In fact, they are exactly the same as those we created
    during the development of the API. We are going to create `ConversationListVO`,
    `ConversationVO`, `UserListVO`, `UserVO`, and `MessageVO`. Create Kotlin files
    to hold each of these value objects in the `vo` package. Before creating any list
    value object data models, we have to create the basic models. These models are
    `UserVO`, `MessageVO`, and `ConversationVO`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们创建消息后端时所做的类似，我们需要创建值对象来模拟我们将要在整个应用程序中处理的数据的常见类型。在`data`包中创建一个`vo`包。我们正在创建的值对象对你来说已经很熟悉了。事实上，它们与我们开发API时创建的完全相同。我们将创建`ConversationListVO`、`ConversationVO`、`UserListVO`、`UserVO`和`MessageVO`。在`vo`包中创建Kotlin文件以保存这些值对象。在创建任何列表值对象数据模型之前，我们必须创建基本模型。这些模型是`UserVO`、`MessageVO`和`ConversationVO`。
- en: 'Create a `UserVO` data class, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`UserVO`数据类，如下所示：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As we have created value objects in the past, the previous code doesn''t need
    much explaining. Add `MessageVO` to your `MessageVO.kt` file, as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们之前已经创建了值对象，所以之前的代码不需要太多解释。将`MessageVO`添加到你的`MessageVO.kt`文件中，如下所示：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now create a `ConversationVo` data class in `ConversationVO.kt`, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`ConversationVO.kt`中创建一个`ConversationVo`数据类，如下所示：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Having created the basic value objects, let''s create `ConversationListVO`
    and `UserListVO`, shall we? `ConversationListVO` is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了基本值对象之后，让我们创建`ConversationListVO`和`UserListVO`，好吗？`ConversationListVO`如下所示：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `ConversationListVO` data class has a single `conversations` property of
    the `List` type that can only contain elements of the `ConversationVO` type. The `UserListVO` data
    class is similar to `ConversationListVO`, with the exception that it has a user''s
    property, which can only contain elements of the `UserVO` type instead of a `conversations`
    property. The following is the `UserListVO` data class:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConversationListVO`数据类有一个单一的`conversations`属性，其类型为`List`，只能包含`ConversationVO`类型的元素。`UserListVO`数据类与`ConversationListVO`类似，但有一个用户的属性，只能包含`UserVO`类型的元素，而不是`conversations`属性。以下是`UserListVO`数据类：'
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Retrieving remote data
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取远程数据
- en: We have already established that important data necessary for the functioning
    the messenger Android App will be stored remotely on the messenger backend. It
    is imperative that we have an efficient means by which our Android application
    can access the data held by the backend. To do this, the Messenger application
    needs to be able to communicate with the API via HTTP.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定，对于 Messenger Android 应用程序的功能至关重要的重要数据将存储在远程的 Messenger 后端。我们必须有一种有效的方法，让我们的
    Android 应用程序能够访问后端持有的数据。为此，Messenger 应用程序需要能够通过 HTTP 与 API 进行通信。
- en: Communicating with a remote server
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与远程服务器通信
- en: There are a number of ways that communication with a remote server can be achieved
    in Android. Common networking libraries used across the Android community are
    **Retrofit**, **OkHttp**, and **Volley**. Each of these libraries has its advantages
    and drawbacks. We will be making use of Retrofit in this project, but for the
    sake of knowledge, we will take a look at how to communicate with a remote server
    using OkHttp.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 中，有多种方式可以实现与远程服务器的通信。Android 社区中常用的网络库有 **Retrofit**、**OkHttp** 和
    **Volley**。每个库都有其优点和缺点。我们将在这个项目中使用 Retrofit，但为了知识普及，我们将看看如何使用 OkHttp 与远程服务器通信。
- en: Communicating with servers using OkHttp
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OkHttp 与服务器通信
- en: 'OkHttp is an efficient and easy-to-use HTTP client. It supports both synchronous
    and asynchronous network calls. Using OkHttp on Android is easy. Simply add its
    dependency to a project''s module-level `build.gradle` file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: OkHttp 是一个高效且易于使用的 HTTP 客户端。它支持同步和异步网络调用。在 Android 上使用 OkHttp 很简单。只需将其依赖项添加到项目模块级别的
    `build.gradle` 文件中：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Sending requests to a server with OkHttp
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OkHttp 向服务器发送请求
- en: 'As previously stated, OkHttp''s APIs were built with ease of use in mind. As
    a consequence, sending requests via OkHttp is quick and hassle-free. The following
    is a `post(String, String)` method that takes a URL and JSON request body as its
    arguments and sends a POST request to the specified URL with the JSON body:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，OkHttp 的 API 是为了易于使用而构建的。因此，通过 OkHttp 发送请求既快又无烦恼。以下是一个 `post(String, String)`
    方法，它接受一个 URL 和 JSON 请求体作为参数，并将带有 JSON 体的 POST 请求发送到指定的 URL：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Using the preceding function is straightforward. Invoke it with appropriate
    values, as you would any other function:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的函数很简单。像调用任何其他函数一样，用适当的值调用它：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Easy, right? Glad you agree. Communicating with a remote server is fun with
    OkHttp but using Retrofit to do this is even more fun. We are almost ready to
    work with Retrofit, but, before we explore Retrofit, it's a good idea to properly
    model the data we will be sending in our HTTP requests.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 简单，对吧？很高兴你同意。使用 OkHttp 与远程服务器通信很有趣，但使用 Retrofit 来做这件事更有趣。我们几乎准备好使用 Retrofit
    了，但在我们探索 Retrofit 之前，正确地模拟我们将在 HTTP 请求中发送的数据是个好主意。
- en: Modeling request data
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟请求数据
- en: We will make use of data classes to model the HTTP request data we wish to send
    to our API. Go ahead and create a `request` package in the `remote` package. There
    are four obvious requests that contain data payloads, which we will be sending
    to the API. These are login requests, message requests, status update requests,
    and requests containing user data. These four requests will be modeled by `LoginRequestObject`,
    `MessageRequestObject`, `StatusUpdateRequestObject`, and `UserRequest` objects,
    respectively.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用数据类来模拟我们希望发送到 API 的 HTTP 请求数据。在 `remote` 包中创建一个 `request` 包。有四个明显的请求包含数据负载，我们将向
    API 发送这些请求。这些请求分别是登录请求、消息请求、状态更新请求和包含用户数据的请求。这四个请求将分别由 `LoginRequestObject`、`MessageRequestObject`、`StatusUpdateRequestObject`
    和 `UserRequest` 对象来模拟。
- en: 'The following code snippet shows the `LoginRequestObject` data class. Go ahead
    and add it to the `request` package and do the same for other request objects
    that follow:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了 `LoginRequestObject` 数据类。请将其添加到 `request` 包中，并为后续的其他请求对象做同样的事情：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `LoginRequestObject` data class possesses the `username` and `password`
    properties because these are the credentials that need to be supplied to the login
    endpoint of the API. The `MessageRequestObject` data class is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoginRequestObject` 数据类具有 `username` 和 `password` 属性，因为这些是需要提供给 API 登录端点的凭证。`MessageRequestObject`
    数据类如下：'
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`MessageRequestObject` possesses two properties as well. These are `recipientId`—the
    ID of a user receiving a message—and `message` —the body of the message being
    sent:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageRequestObject` 也有两个属性。这些是 `recipientId`——接收消息的用户 ID，以及 `message`——发送的消息正文：'
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `StatusUpdateRequestObject` data class has a single `status` property.
    As the name implies, this is the status that a user wants to update their current
    status message to:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`StatusUpdateRequestObject` 数据类有一个单一的 `status` 属性。正如其名所示，这是用户想要更新其当前状态消息的状态：'
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`UserRequestObject` is similar to `LoginRequestObject` with the exception that
    it contains an additional `phoneNumber` property. This request object has varying
    use cases, such as to contain user signup data being sent to the API.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserRequestObject` 与 `LoginRequestObject` 类似，但额外包含一个 `phoneNumber` 属性。此请求对象有多种用途，例如用于包含发送到
    API 的用户注册数据。'
- en: Having created the necessary request objects, we can go ahead and create the
    actual `MessengerApiService`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了必要的请求对象后，我们可以继续创建实际的 `MessengerApiService`。
- en: Creating the Messenger API service
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Messenger API 服务
- en: It's time for us to create a service that performs the all-important job of
    communicating with the Messenger API we created in [Chapter 4](kt-prog-ex_ch04.html),
    *Designing and Implementing the Messenger Backend with Spring Boot 2.0*. We will
    be making use of Retrofit and Retrofit's RxJava adapter to create this service.
    Retrofit is a type-safe HTTP client for Android and Java built by Square Inc.,
    and RxJava is an open source implementation of ReactiveX written in and for Java.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是我们创建一个执行与我们在第 4 章[设计并实现 Messenger 后端](kt-prog-ex_ch04.html)中创建的 Messenger
    API 通信的至关重要的工作的服务的时候了。我们将使用 Retrofit 和 Retrofit 的 RxJava 适配器来创建此服务。Retrofit 是由
    Square Inc. 为 Android 和 Java 构建的类型安全的 HTTP 客户端，RxJava 是用 Java 编写并针对 Java 的开源的
    ReactiveX 实现。
- en: 'We added Retrofit to our Android project at the beginning of this chapter with
    the following line:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开头，我们使用以下行将 Retrofit 添加到我们的 Android 项目中：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We also added Retrofit''s RxJava adapter dependency to our module-level `build.gradle`
    script, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在模块级别的 `build.gradle` 脚本中添加了 Retrofit 的 RxJava 适配器依赖，如下所示：
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The first step in creating a service with Retrofit is to define an interface
    that describes your HTTP API. Create a `service` package within your application
    `source` package and add the `MessengerApiService` interface, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Retrofit 创建服务的第一步是定义一个接口，该接口描述了你的 HTTP API。在你的应用程序 `source` 包中创建一个 `service`
    包，并添加 `MessengerApiService` 接口，如下所示：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As can be observed from the preceding code snippet, Retrofit relies on the
    use of annotations to properly describe HTTP requests to be sent. Take the following
    snippet, for example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，Retrofit 依赖于使用注解来正确描述要发送的 HTTP 请求。以下是一个示例片段：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `@POST` annotation tells Retrofit that this function describes an HTTP POST
    request that is mapped to the `/login` path. The `@Headers` annotation is used
    to specify the headers of the HTTP request. In the HTTP request described in the preceding
    code snippet, the `Content-Type` header has been set to `application/json`. Hence,
    the content being sent by this request is JSON.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`@POST` 注解告诉 Retrofit，此函数描述了一个映射到 `/login` 路径的 HTTP POST 请求。`@Headers` 注解用于指定
    HTTP 请求的头部。在前述代码片段中描述的 HTTP 请求中，`Content-Type` 头部已被设置为 `application/json`。因此，此请求发送的内容是
    JSON。'
- en: The `@Body` annotation specifies that the `user` argument passed to `login()`
    contains the data of the JSON request body to be sent to the API. `user` is of
    the `LoginRequestObject` type (we previously created this request object). Lastly,
    the function is declared to return an `Observable` object containing a `retrofit2.Response`
    object.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Body` 注解指定传递给 `login()` 的 `user` 参数包含要发送到 API 的 JSON 请求体中的数据。`user` 是 `LoginRequestObject`
    类型（我们之前创建了此请求对象）。最后，该函数被声明为返回一个包含 `retrofit2.Response` 对象的 `Observable` 对象。'
- en: 'Besides the `@POST`, `@Headers`, and `@Body` annotations, we made use of `@GET`,
    `@PUT`, `@Path`, and `@Header`. `@GET` and `@PUT` are used to specify `GET` and
    `PUT` requests, respectively. The `@Path` annotation is used to declare a value
    as a path argument of the HTTP request being sent. Take the following `showUser()`
    function, for example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `@POST`、`@Headers` 和 `@Body` 注解之外，我们还使用了 `@GET`、`@PUT`、`@Path` 和 `@Header`。`@GET`
    和 `@PUT` 分别用于指定 `GET` 和 `PUT` 请求。`@Path` 注解用于声明一个值作为发送的 HTTP 请求的路径参数。以下是一个示例 `showUser()`
    函数：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`showUser` is a function that describes a GET request with the `users/{userId}`
    path. `{userId}` is not actually part of the HTTP request path. Retrofit will
    replace `{userId}` with the value passed to the `userId` argument of `showUser()`.
    Notice how `userId` is annotated with `@Path("userId")`. This lets retrofit know
    that `userId` holds a value that should be placed where `{userId}` is located
    in the HTTP request URL path.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`showUser` 是一个描述带有 `users/{userId}` 路径的 GET 请求的函数。`{userId}` 实际上不是 HTTP 请求路径的一部分。Retrofit
    会将传递给 `showUser()` 的 `userId` 参数的值替换 `{userId}`。注意 `userId` 被注解为 `@Path("userId")`。这使
    Retrofit 知道 `userId` 持有一个值，应该放置在 HTTP 请求 URL 路径中的 `{userId}` 位置。'
- en: '`@Header` is similar to `@Headers`, with the exception that it is used to specify
    a single header key-value pair in an HTTP request to be sent. Annotating authorization
    with `@Header("Authorization")` sets the `Authorization` header of the HTTP request
    sent to the value held within authorization.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Header` 与 `@Headers` 类似，但不同之处在于它用于在 HTTP 请求中指定单个头键值对。使用 `@Header("Authorization")`
    注解授权将 HTTP 请求的 `Authorization` 头设置为授权中持有的值。'
- en: 'Now that we have created an appropriate `MessengerApiService` interface to
    model the HTTP API that our application will communicate with, we need to be able
    to retrieve an instance of this service. We can easily do this by creating a `Factory`
    companion object that''s in charge of the creation of `MessengerApiService` instances:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个适当的 `MessengerApiService` 接口来模拟我们的应用程序将要与之通信的 HTTP API，我们需要能够检索这个服务的实例。我们可以通过创建一个负责创建
    `MessengerApiService` 实例的 `Factory` 伴生对象来轻松做到这一点：
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It returns an instance of `MessengerApiService` when invoked. A new instance
    of `MessengerApiService` is created, if one has not been previously created
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当被调用时，它返回一个 `MessengerApiService` 的实例。如果没有之前创建过实例，将创建一个新的 `MessengerApiService`
    实例。
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`Factory` possesses a single `getInstance()` function that builds and returns
    an instance of `MessengerApiService` when called. An instance of `Retrofit.Builder`
    is used to create the interface. We set  the `CallAdapterFactory` in use to `RxJava2CallAdapterFactory`
    and we set the `ConverterFactory` in use to `GsonConverterFactory` (this handles
    JSON serialization and deserialization). Don''t forget to replace `"{AWS_URL}"` with
    the URL of the Messenger API AWS EC2 instance deployed in [Chapter 4](kt-prog-ex_ch04.html),
    *Designing and Implementing the Messenger Backend with Spring Boot 2.0*.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`Factory` 拥有一个单一的 `getInstance()` 函数，当被调用时构建并返回一个 `MessengerApiService` 的实例。使用
    `Retrofit.Builder` 的一个实例来创建接口。我们将使用的 `CallAdapterFactory` 设置为 `RxJava2CallAdapterFactory`，并将使用的
    `ConverterFactory` 设置为 `GsonConverterFactory`（这处理 JSON 序列化和反序列化）。不要忘记将 `"{AWS_URL}"`
    替换为在 [第 4 章](kt-prog-ex_ch04.html)，“使用 Spring Boot 2.0 设计和实现 Messenger 后端”中部署的
    Messenger API AWS EC2 实例的 URL。'
- en: 'After creating the `Retrofit.Builder()` instance successfully, we use it to
    create an instance of `MessengerApiService`, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 成功创建 `Retrofit.Builder()` 实例后，我们使用它来创建 `MessengerApiService` 的实例，如下所示：
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Lastly, the service is returned for use by `getInstance()`. Regardless of the
    fact that we have created a suitable service to communicate with the Messenger
    API, it cannot be used to communicate with a network without specifying the necessary
    permissions in the `AndroidManifest`. Open the project''s `AndroidManifest` and
    add the following two lines of code within the `<manifest></manifest>` tag:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，服务通过 `getInstance()` 返回以供使用。尽管我们已经创建了一个适合与 Messenger API 通信的服务，但如果没有在 `AndroidManifest`
    中指定必要的权限，则无法用于与网络通信。打开项目的 `AndroidManifest` 并在 `<manifest></manifest>` 标签内添加以下两行代码：
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now that we have the messenger service ready to go, it is time that we create
    appropriate repositories to exploit this service.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了消息服务，是时候创建适当的仓库来利用这个服务了。
- en: Implementing data repositories
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现数据仓库
- en: You are already familiar with repositories, so there is no need for an introduction
    to them. The repositories we are about to create are similar to those created
    for the Messenger API in [Chapter 4](kt-prog-ex_ch04.html), *Designing and Implementing
    the Messenger Backend with Spring Boot 2.0*. The only difference is that the data
    source for the repositories we are about to implement is a remote server, not
    a database residing on a host.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经熟悉了仓库，因此无需对它们进行介绍。我们即将创建的仓库与 [第 4 章](kt-prog-ex_ch04.html)，“使用 Spring Boot
    2.0 设计和实现 Messenger 后端”中为 Messenger API 创建的仓库类似。唯一的区别是我们即将实现的仓库的数据源是一个远程服务器，而不是位于主机上的数据库。
- en: 'Create a `repository` package within the `remote` package. First and foremost,
    we are going to implement a user repository to retrieve data pertaining to application
    users. Add a `UserRepository` interface to the repository, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `remote` 包内创建一个 `repository` 包。首先，我们将实现一个用户存储库来检索与应用程序用户相关的数据。将以下内容的 `UserRepository`
    接口添加到存储库中：
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As this is an interface, we need to create a class that implements the functions
    specified within `UserRepository`. We will name this class `UserRepositoryImpl`.
    Create a new `UserRepositoryImpl` within the repositories package, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个接口，我们需要创建一个实现 `UserRepository` 中指定函数的类。我们将把这个类命名为 `UserRepositoryImpl`。在存储库包中创建一个新的
    `UserRepositoryImpl`，如下所示：
- en: '[PRE37]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The preceding `UserRepositoryImpl` class has two instance variables: `preferences`
    and `service`. The `preferences` variable is an instance of the `AppPreferences`
    class we created earlier and `service` is an instance of `MessengerApiService`
    retrieved by the `getInstance()` function defined in the `Factory` companion object
    in the `MessengerApiService` interface.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `UserRepositoryImpl` 类有两个实例变量：`preferences` 和 `service`。`preferences` 变量是我们之前创建的
    `AppPreferences` 类的实例，而 `service` 是通过在 `MessengerApiService` 接口中的 `Factory` 伴随对象中定义的
    `getInstance()` 函数检索到的 `MessengerApiService` 实例。
- en: '`UserRepositoryImpl` provides implementations of the `findById()`, `all()`,
    and `echoDetails()` functions defined in `UserRepository`. The three functions
    implemented make use of `service` to retrieve the required data residing on the
    server via HTTP-appropriate requests. `findById()` calls the `showUser()` function
    in service to send a request to the Messenger API to retrieve the details of the
    user with the specified user ID. The `showUser()` function requires the authorization
    token of the currently logged-in user as its second argument. We provide this
    required token via the `AppPreferences` instance by passing `preferences.accessToken`
    as the second argument to the function.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserRepositoryImpl` 为在 `UserRepository` 中定义的 `findById()`、`all()` 和 `echoDetails()`
    函数提供实现。这三个函数的实现使用了 `service` 来通过 HTTP 适当的请求从服务器检索所需的数据。`findById()` 调用 `service`
    中的 `showUser()` 函数，向 Messenger API 发送请求以检索指定用户 ID 的用户详情。`showUser()` 函数需要当前登录用户的授权令牌作为其第二个参数。我们通过将
    `preferences.accessToken` 作为函数的第二个参数传递给 `AppPreferences` 实例来提供所需的令牌。'
- en: The `all()` function makes use of `MessengerApiService#listUsers()` to retrieve
    all the users that are registered on the messenger service. The `echoDetails()` function
    makes use of the `MessengerApiService#echoDetails()` function to get the details
    of the currently logged-in user.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`all()` 函数使用 `MessengerApiService#listUsers()` 来检索在信使服务上注册的所有用户。`echoDetails()`
    函数使用 `MessengerApiService#echoDetails()` 函数来获取当前登录用户的详细信息。'
- en: 'Let''s create a conversation repository to facilitate the access of data pertaining
    to conversations. Add a `ConversationRepository` interface to `com.example.messenger.data.remote.repository`
    with the following content:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个会话存储库，以方便访问与对话相关的数据。将以下内容的 `ConversationRepository` 接口添加到 `com.example.messenger.data.remote.repository`：
- en: '[PRE38]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now create a corresponding `ConversationRepositoryImpl` class in the package,
    as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在包中创建一个相应的 `ConversationRepositoryImpl` 类，如下所示：
- en: '[PRE39]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'It retrieves information pertaining to a conversation with the requested conversation
    ID from the Messenger API:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 它从 Messenger API 中检索与请求的会话 ID 相关的会话信息：
- en: '[PRE40]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It retrieves all active conversations of current user from API when invoked:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当被调用时，它从 API 中检索当前用户的全部活跃会话：
- en: '[PRE41]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`findConversationById(Long)` retrieves the conversation thread with the corresponding
    ID passed to the function. The `all()` function simply retrieves all of the current
    user''s active conversations.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`findConversationById(Long)` 通过函数传递的相应 ID 检索对应的会话线程。`all()` 函数简单地检索当前用户的全部活跃会话。'
- en: Creating the login interactor
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建登录交互器
- en: 'It is time to create our login interaction, which will serve as the model that
    the login presenter will interact with. Create a `LoginInteractor` interface in
    the `login` package containing the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候创建我们的登录交互器了，它将作为登录演示者与之交互的模型。在 `login` 包中创建一个 `LoginInteractor` 接口，包含以下代码：
- en: '[PRE42]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you may have noticed, `LoginInteractor` extends `AuthInteractor`. This is
    similar to the way that `LoginView` extends `AuthView`. The `AuthInteractor` interface
    declares behaviors and characteristics that must be implemented by any interactor
    that handles authentication-related logic. Let's implement the `AuthInteractor`
    interface now.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，`LoginInteractor` 扩展了 `AuthInteractor`。这与 `LoginView` 扩展 `AuthView`
    的方式类似。`AuthInteractor` 接口声明了任何处理身份验证相关逻辑的交互器必须实现的行为和特征。现在让我们实现 `AuthInteractor`
    接口。
- en: 'Go ahead and add an `AuthInteractor` interface to the `com.exampla.messenger.auth`
    package:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 继续在 `com.exampla.messenger.auth` 包中添加一个 `AuthInteractor` 接口：
- en: '[PRE43]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Every interactor that is an `AuthInteractor` must have the following fields:
    `userDetails`, `accessToken`, `submittedUsername`, and `submittedPassword`. In
    addition, an interactor that implements `AuthInteractor` must have `persistAccessToken(AppPreferences)`
    and `persistUserDetails(AppPreferences)` methods. As the names of the methods
    suggest, they persist access tokens and user details to the application''s `SharedPreferences`
    file. As you might have guessed, we need to create an implementation class for
    the `LoginInteractor`. We will call this class `LoginInteractorImpl`.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `AuthInteractor` 交互器都必须有以下字段：`userDetails`、`accessToken`、`submittedUsername`
    和 `submittedPassword`。此外，实现 `AuthInteractor` 的交互器必须具有 `persistAccessToken(AppPreferences)`
    和 `persistUserDetails(AppPreferences)` 方法。正如方法名所暗示的，它们将访问令牌和用户详细信息持久化到应用程序的 `SharedPreferences`
    文件中。正如你可能已经猜到的，我们需要为 `LoginInteractor` 创建一个实现类。我们将把这个类称为 `LoginInteractorImpl`。
- en: 'The following is the `LoginInteractorImpl` class with its implemented `login()`
    method. Add it to the `login` package within the `ui` package:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 `LoginInteractorImpl` 类实现了 `login()` 方法。将其添加到 `ui` 包内的 `login` 包中：
- en: '[PRE44]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If an empty `username` is submitted in the login form, the `username` is invalid.
    The listener''s `onUsernameError()` function is called when this happens:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在登录表单中提交了空 `username`，则 `username` 无效。当发生这种情况时，会调用监听器的 `onUsernameError()`
    函数：
- en: '[PRE45]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Call the listener''s `onPasswordError()` function when an empty `password`
    is submitted:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当提交空 `password` 时，调用监听器的 `onPasswordError()` 函数：
- en: '[PRE46]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Initializing model''s `submittedUsername` and `submittedPassword` fields and
    creating appropriate `LoginRequestObject`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化模型的 `submittedUsername` 和 `submittedPassword` 字段，并创建适当的 `LoginRequestObject`：
- en: '[PRE47]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Using `MessengerApiService` to send a login request to Messenger API.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `MessengerApiService` 向 Messenger API 发送登录请求。
- en: '[PRE48]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Branched reached when an HTTP 403 (forbidden) status code is returned by the
    server. This indicates that the login failed and the user is not
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器返回 HTTP 403（禁止）状态码时，会发生分支。这表示登录失败，用户无权访问服务器。
- en: authorized to access the server.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 无权访问服务器。
- en: '[PRE49]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`login()` works by first verifying that the provided `username` and `password`
    arguments are not blank. The `onUsernameError()` function of the `onAuthFinishedListener`
    is invoked when a blank username is encountered and `onPasswordError()` is invoked
    when a blank password is encountered. If neither the username nor password provided
    is blank, it then makes use of `MessengerApiService` to send a login request to
    the messenger API. If the login request is successful, then it sets the `accessToken`
    property to the access token retrieved from the `Authorization` header of the
    API response and then invoked the listener''s `onAuthSuccess()` function. In a
    scenario when the login request fails, the `onAuthError()` listener function is
    invoked.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`login()` 函数通过首先验证提供的 `username` 和 `password` 参数是否为空来工作。当遇到空用户名时，会调用 `onAuthFinishedListener`
    的 `onUsernameError()` 函数，当遇到空密码时，会调用 `onPasswordError()` 函数。如果提供的用户名和密码都不为空，它将利用
    `MessengerApiService` 向信使 API 发送登录请求。如果登录请求成功，它将 `accessToken` 属性设置为从 API 响应的
    `Authorization` 标头中检索到的访问令牌，然后调用监听器的 `onAuthSuccess()` 函数。在登录请求失败的情况下，会调用 `onAuthError()`
    监听器函数。'
- en: 'Having understood the login process, add the `retrieveDetails()`, `persistAccessToken()`
    and `persistUserDetails()` methods below to `LoginInteractorImpl`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了登录过程之后，将下面的 `retrieveDetails()`、`persistAccessToken()` 和 `persistUserDetails()`
    方法添加到 `LoginInteractorImpl` 中：
- en: '[PRE50]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'It retrieves details of user upon initial login:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 它在初始登录时检索用户详细信息：
- en: '[PRE51]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Make sure to read through the comments in the preceding code snippet carefully.
    They thoroughly explain the workings of the `LoginInteractor`. It is now time
    to work on the `LoginPresenter`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要仔细阅读前面代码片段中的注释。它们详细解释了 `LoginInteractor` 的工作原理。现在是时候开始处理 `LoginPresenter`
    了。
- en: Creating the login presenter
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建登录演示者
- en: 'A presenter, as we saw in [Chapter 3](kt-prog-ex_ch03.html), *Implementing
    Tetris Logic and Functionality*, is the middleman between a view and a model.
    It is necessary to create suitable presenters for views to properly facilitate
    clean view-model interactions. Creating a presenter is fairly easy. We need to
    first create an interface that properly declares the behaviors that will be exhibited
    by the presenter. Create a `LoginPresenter` interface in the `login` package with
    the following code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第3章](kt-prog-ex_ch03.html)中看到的，**演示者**是视图和模型之间的中间人。为了正确促进干净的视图-模型交互，有必要为视图创建合适的演示者。创建一个演示者相当简单。我们首先需要创建一个接口，以正确声明演示者将展示的行为。在`login`包中创建一个`LoginPresenter`接口，代码如下：
- en: '[PRE52]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'As can be easily seen in the preceding code snippet, we want a class that acts
    as a `LoginPresenter` for a `LoginView` to possess an `executeLogin(String, String)`
    function. This function will be called by the view and will then interact with
    a model handling the login logic for the application. We will need to create a
    `LoginPresenterImpl` class that implements `LoginPresenter`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如前代码片段所示，我们希望一个作为`LoginView`的`LoginPresenter`的类的`executeLogin(String, String)`函数。这个函数将由视图调用，然后将与处理应用程序登录逻辑的模型进行交互。我们需要创建一个实现`LoginPresenter`的`LoginPresenterImpl`类：
- en: '[PRE53]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `LoginPresenterImpl` class implements `LoginPresenter`, `AuthInteractor.onAuthFinishedListener`,
    and `LoginInteractor.OnDetailsRetrievalFinishedListener`, and, as such, implements
    all behaviors required by the interfaces. `LoginPresenterImpl` overrides seven
    functions in all: `onPasswordError()`, `onUsernameError()`, `onAuthSuccess()`,
    `onAuthError()`, `onDetailsRetrievalSuccess()`, `onDetailsRetrievalError()`, and
    `executeLogin(String, String)`. The interaction between the `LoginPresenter` and
    `LoginInteractor` can be seen within the `onAuthSuccess()` and `executeLogin(String,
    String)` functions. When a user submits their login details, the `LoginView` calls
    the `executeLogin(String, String)` function in `LoginPresenter`. In turn, `LoginPresenter`
    uses `LoginInteractor` to handle the actual login procedure by calling the `login(String,
    String)` function of `LoginInteractor`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoginPresenterImpl`类实现了`LoginPresenter`、`AuthInteractor.onAuthFinishedListener`和`LoginInteractor.OnDetailsRetrievalFinishedListener`，因此实现了接口所需的所有行为。`LoginPresenterImpl`覆盖了七个函数：`onPasswordError()`、`onUsernameError()`、`onAuthSuccess()`、`onAuthError()`、`onDetailsRetrievalSuccess()`、`onDetailsRetrievalError()`和`executeLogin(String,
    String)`。`LoginPresenter`和`LoginInteractor`之间的交互可以在`onAuthSuccess()`和`executeLogin(String,
    String)`函数中看到。当用户提交他们的登录详情时，`LoginView`调用`LoginPresenter`中的`executeLogin(String,
    String)`函数。反过来，`LoginPresenter`使用`LoginInteractor`通过调用`login(String, String)`函数来处理实际的登录过程。'
- en: If the user login is successful, the `onAuthSuccess()` callback function of
    `LoginPresenter` is invoked by the `LoginInteractor`. This then leads to the storing
    of the access token returned by the server and the retrieval of the logged-in
    user's account details. When the login request is declined by the server, `onAuthError()`
    is called and an informative error message is displayed to the user.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户登录成功，`LoginInteractor`将调用`LoginPresenter`的`onAuthSuccess()`回调函数。这随后导致存储服务器返回的访问令牌和检索已登录用户的账户详情。当服务器拒绝登录请求时，调用`onAuthError()`并显示一个有用的错误信息给用户。
- en: When a user's account details are successfully retrieved by the interactor,
    the `onDetailsRetrievalSuccess()` callback of `LoginPresenter` is invoked. This
    leads to the storage of the account details. The progress bar shown to the user
    over the course of the login is then hidden with `view.hideProgress()`, after
    which the user is navigated to the home screen with `view.navigateToHome()`. If
    the retrieval of user details fails, `onDetailsRetrievalError()` is called by
    `LoginInteractor`. The presenter then requests another attempt at retrieving the
    user's account details by calling `interactor.retrieveDetails(preferences, this)`
    once more.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当交互者成功检索到用户的账户详情时，`LoginPresenter`的`onDetailsRetrievalSuccess()`回调被调用。这导致存储账户详情。在登录过程中向用户显示的进度条随后通过`view.hideProgress()`隐藏，之后用户通过`view.navigateToHome()`导航到主屏幕。如果用户详情的检索失败，`LoginInteractor`将调用`onDetailsRetrievalError()`。然后演示者通过再次调用`interactor.retrieveDetails(preferences,
    this)`请求再次尝试检索用户的账户详情。
- en: Finishing the LoginView
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成LoginView
- en: 'If you recall, we did not finish our implementation of the `LoginView` earlier.
    Functions such as `navigateToSignUp()`, `navigateToHome()`, and `onClick(view:
    View)` were left with empty bodies. In addition, the `LoginView` did not interact
    in any way with the `LoginPresenter`. Let''s fix that now, shall we?'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你还记得，我们之前没有完成 `LoginView` 的实现。例如 `navigateToSignUp()`、`navigateToHome()`
    和 `onClick(view: View)` 等函数都留有空的实现。此外，`LoginView` 与 `LoginPresenter` 没有任何交互。现在让我们来修复这个问题，好吗？'
- en: Fist things first, to navigate a user to the signup screen and home screen,
    we need views for these screens to exist. We won't concern ourselves with implementing
    layouts for them now (that will be done in the following sections). We just need
    them to exist. Create the `signup` and `main` packages under `com.example.messenger.ui`.
    Create a new empty activity called `SignUpActivity` in the `signup` package and
    an empty activity called `MainActivity` within `main`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了将用户导航到注册屏幕和主页，我们需要这些屏幕的视图存在。我们现在不会关注实现它们的布局（这将在接下来的章节中完成）。我们只需要它们存在。在 `com.example.messenger.ui`
    下创建 `signup` 和 `main` 包。在 `signup` 包中创建一个名为 `SignUpActivity` 的新空活动，在 `main` 包中创建一个名为
    `MainActivity` 的新空活动。
- en: 'Now open `LoginActivity.kt`. We need to modify the previously mentioned functions
    to perform their respective tasks. In addition, we need to add private properties
    for a `LoginPresenter` instance and an `AppPreferences` instance. These changes
    are made in the following code snippet:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开 `LoginActivity.kt`。我们需要修改之前提到的函数以执行它们各自的任务。此外，我们需要为 `LoginPresenter` 实例和
    `AppPreferences` 实例添加私有属性。以下代码片段展示了这些更改：
- en: Firstly, add the properties below to the top of the `LoginActivity` class.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将以下属性添加到 `LoginActivity` 类的顶部。
- en: '[PRE54]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now modify `navigateToSignUp()`, `navigateToHome()`, and `onClick(view: View)` as
    shown in the following snippet:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '现在修改 `navigateToSignUp()`、`navigateToHome()` 和 `onClick(view: View)`，如下面的代码片段所示：'
- en: '[PRE55]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`navigateToSignUp()` uses an explicit intent to start `SignUpActivity` when
    called. `navigateToHome()` operates similarly to `navigateToSignUp()`—it starts
    `MainActivity`. A major difference between `navigateToHome()` and `navigateToSignUp()`
    is that `navigateToHome()` destroys the current `LoginActivity` instance by calling
    `finish()` before starting the `MainActivity`.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`navigateToSignUp()` 使用显式意图在调用时启动 `SignUpActivity`。`navigateToHome()` 与 `navigateToSignUp()`
    操作类似——它启动 `MainActivity`。`navigateToHome()` 和 `navigateToSignUp()` 之间的一个主要区别是，在启动
    `MainActivity` 之前，`navigateToHome()` 会通过调用 `finish()` 销毁当前的 `LoginActivity` 实例。'
- en: The `onClick()` method uses the `LoginPresenter` to begin the login process
    in the scenario that the login button is clicked. Otherwise, if the signup button
    is clicked, the `SignUpActivity` is started with `navigateToSignUp()`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`onClick()` 方法在点击登录按钮的情况下使用 `LoginPresenter` 开始登录过程。否则，如果点击注册按钮，将使用 `navigateToSignUp()`
    启动 `SignUpActivity`。'
- en: Great job thus far! We have created the necessary view, presenter, and model
    for login-related application logic. We need to keep in mind that before we can
    log in a user, we need to have registered a user on the platform first. Thus,
    we must implement our signup logic. We will do this in the following section.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，做得很好！我们已经创建了与登录相关应用逻辑所需的所有视图、表示和模型。我们需要记住，在我们可以登录用户之前，我们首先需要在平台上注册用户。因此，我们必须实现我们的注册逻辑。我们将在下一节中这样做。
- en: Developing the signup UI
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发注册 UI
- en: Let's develop the signup user interface. First, we have to implement the necessary
    views, starting from the layout of `SignUpActivity`. We do not need much in terms
    of elements for our `SignUpActivity` layout. We need three input fields to take
    the username, password, and phone number of a user to be registered. In addition,
    we need a button to submit the signup form as well as a progress bar to show when
    the signup is in progress.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开发注册用户界面。首先，我们必须实现必要的视图，从 `SignUpActivity` 的布局开始。在我们的 `SignUpActivity` 布局中，我们不需要很多元素。我们需要三个输入字段来获取要注册的用户的用户名、密码和电话号码。此外，我们还需要一个提交注册表单的按钮以及一个进度条来显示注册正在进行。
- en: 'The following is our `activity_sign_up.xml` layout:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们 `activity_sign_up.xml` 布局的代码：
- en: '[PRE56]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The visual translation of the XML layout written earlier is as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 之前编写的 XML 布局的视觉翻译如下：
- en: '![](img/3479aa1d-d799-44cf-a594-53284db40d6e.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3479aa1d-d799-44cf-a594-53284db40d6e.jpg)'
- en: As you can see, the layout we designed contains all the necessary elements we
    previously mentioned.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们设计的布局包含了我们之前提到的所有必要元素。
- en: Creating the signup interactor
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建注册交互器
- en: 'Now we will implement a signup interactor to act as a model that our yet-to-be-implemented
    signup presenter will communicate with. Create a `SignUpInteractor` interface
    within the `signup` package, as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将实现一个注册交互器，作为我们尚未实现的注册展示器的通信模型。在 `signup` 包内创建一个 `SignUpInteractor` 接口，如下所示：
- en: '[PRE57]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You may have noticed that `SignUpInteractor` extends `AuthInteractor`. Similar
    to a `LoginInteractor`, a `SignUpInteractor` requires the use of `userDetails`,
    `accessToken`, `submittedUsername`, and `submittedPassword` properties. In addition,
    `SignUpInteractor` needs to be able to persist the access token of a user as well
    as their user details by using the `persistAccessToken(AppPreferences)` and `persistUserDetails(AppPreferences)`
    functions, which are declared in the `AuthInteractor` interface.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到 `SignUpInteractor` 继承自 `AuthInteractor`。类似于 `LoginInteractor`，`SignUpInteractor`
    需要使用 `userDetails`、`accessToken`、`submittedUsername` 和 `submittedPassword` 属性。此外，`SignUpInteractor`
    需要能够通过 `persistAccessToken(AppPreferences)` 和 `persistUserDetails(AppPreferences)`
    函数持久化用户的访问令牌和用户详情，这些函数在 `AuthInteractor` 接口中声明。
- en: We created an `OnSignUpFinishedListener` interface within `SignUpInteractor`
    declaring callbacks that must be implemented by an `OnSignUpFinishedListener`.
    This listener will be our `SignUpPresenter` when we implement it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `SignUpInteractor` 中创建了一个 `OnSignUpFinishedListener` 接口，声明了必须由 `OnSignUpFinishedListener`
    实现的回调。当我们将它实现时，这个监听器将是我们的 `SignUpPresenter`。
- en: 'In creating `SignUpInteractorImpl`, we shall start first and foremost with
    its property declarations and the implementation of its `login()` method. Create
    `SignUpInteractorImpl` which is as follows. Ensure that you add it to the same
    package as `SignUpInteractor`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 `SignUpInteractorImpl` 时，我们首先应该从其属性声明和 `login()` 方法的实现开始。创建如下所示的 `SignUpInteractorImpl`。确保将其添加到与
    `SignUpInteractor` 相同的包中：
- en: '[PRE58]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Registering a new user to the Messenger platform with the `MessengerApiService`
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `MessengerApiService` 将新用户注册到 Messenger 平台。
- en: '[PRE59]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now add the `getAuthorization()`, `persistAccessToken()` and `persistUserDetails()`
    methods below to `SignUpInteractorImpl`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将 `getAuthorization()`、`persistAccessToken()` 和 `persistUserDetails()` 方法添加到
    `SignUpInteractorImpl` 中：
- en: '[PRE60]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Let''s log the registered user in to the platform with the `MessengerApiService`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `MessengerApiService` 将注册用户登录到平台：
- en: '[PRE61]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, user has been successfully logged in. Hence, we invoke listener''s `onAuthSuccess()`
    callback:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用户已成功登录。因此，我们调用监听器的 `onAuthSuccess()` 回调：
- en: '[PRE62]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `SignUpInteractorImpl` class is a straightforward implementation of the
    `SignUpInteractor` interface. Lines 19 to 22 contain property declarations for
    `userDetails`, `accessToken`, `submittedUsername`, and `submittedPassword` that
    must be possessed by an `AuthInteractor`. `signUp(String, String, String, SignUpInteractor.OnSignUpFinishedListener)`
    contains the signup logic for the application. If all values submitted by a user
    are valid, then the user is registered on the platform with the `createUser(UserRequestObject)`
    function of the `MessengerApiService` that we created with Retrofit.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`SignUpInteractorImpl` 类是 `SignUpInteractor` 接口的直接实现。第 19 行到 22 行包含了 `userDetails`、`accessToken`、`submittedUsername`
    和 `submittedPassword` 的属性声明，这些属性必须由 `AuthInteractor` 拥有。`signUp(String, String,
    String, SignUpInteractor.OnSignUpFinishedListener)` 包含了应用程序的注册逻辑。如果用户提交的所有值都有效，则用户将通过我们使用
    Retrofit 创建的 `MessengerApiService` 的 `createUser(UserRequestObject)` 函数在平台上注册。'
- en: '`getAuthorization(AuthInteractor.onAuthFinishedListener)` is called to authorize
    a newly registered user of the messenger platform. Make sure to peruse the comments
    within `SignUpInteractorImpl` for more information.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `getAuthorization(AuthInteractor.onAuthFinishedListener)` 以授权新注册的 messenger
    平台用户。请确保仔细阅读 `SignUpInteractorImpl` 中的注释以获取更多信息。
- en: Next on our agenda is the creation of the `SignUpPresenter`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们的任务是创建 `SignUpPresenter`。
- en: Creating the signup presenter
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建注册展示器
- en: 'As we did when creating the `LoginPresenter`, we need to create a `SignUpPresenter`
    interface along with a `SignUpPresenterImpl` class. The `SignUpPresenter` we are
    making is in no way complex. For this application, we need our signup presenter
    to possess a property of the `AppPreferences` type as well as a function that
    executes the signup process. The following is the `SignUpPresenter` interface:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建 `LoginPresenter` 时，我们需要创建一个 `SignUpPresenter` 接口以及一个 `SignUpPresenterImpl`
    类。我们创建的 `SignUpPresenter` 并不复杂。对于这个应用程序，我们需要我们的注册展示器拥有 `AppPreferences` 类型的属性以及一个执行注册过程的函数。以下是我们创建的
    `SignUpPresenter` 接口：
- en: '[PRE63]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, here is the code for our `SignUpPresenter` implementation:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，以下是我们的 `SignUpPresenter` 实现的代码：
- en: '[PRE64]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `onSuccess()` callback below is invoked when user is successfully signed
    up:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户成功注册时，以下 `onSuccess()` 回调会被调用：
- en: '[PRE65]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The callback invoked when an error occurs during user sign up:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 用户注册过程中发生错误时调用的回调：
- en: '[PRE66]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The preceding `SignUpPresenterImpl` class implements the `SignUpPresenter`,
    `SignUpInteractor.OnSignUpFinishedListener`, and `AuthInteractor.onAuthFinishedListener`
    interfaces, and, as such, provides implementations for a number of required functions.
    These functions are `onSuccess()`, `onError()`, `onUsernameError()`, `onPasswordError()`,
    `onPhoneNumberError()`, `executeSignUp(String, String, String)`, `onAuthSuccess()`,
    and `onAuthError()`. `SignUpPresenterImpl` takes a single argument as its primary
    constructor. This argument must be of the `SignUpView` type.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 `SignUpPresenterImpl` 类实现了 `SignUpPresenter`、`SignUpInteractor.OnSignUpFinishedListener`
    和 `AuthInteractor.onAuthFinishedListener` 接口，因此提供了许多必需函数的实现。这些函数包括 `onSuccess()`、`onError()`、`onUsernameError()`、`onPasswordError()`、`onPhoneNumberError()`、`executeSignUp(String,
    String, String)`、`onAuthSuccess()` 和 `onAuthError()`。`SignUpPresenterImpl` 以 `SignUpView`
    类型作为其主构造函数的单个参数。
- en: '`executeSignUp(String, String, String)` is a function that will be invoked
    by a `SignUpView` to begin the user registration process. `onSuccess()` is called
    when a user''s signup request is successful. The function immediately invokes
    the interactor''s `getAuthorization()` function to get an access token for the
    newly registered user. In a scenario when a signup request fails, the `onError()`
    callback is invoked. This hides the progress bar being shown to the user and displays
    an appropriate error message.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`executeSignUp(String, String, String)` 是一个由 `SignUpView` 调用来开始用户注册过程的函数。当用户的注册请求成功时，会调用
    `onSuccess()`。该函数立即调用交互器的 `getAuthorization()` 函数来获取新注册用户的访问令牌。在注册请求失败的情况下，会调用
    `onError()` 回调。这会隐藏向用户显示的进度条，并显示适当的错误信息。'
- en: The `onUsernameError()`, `onPasswordError()`, and `onPhoneNumberError()` methods
    are callbacks invoked upon the occurrence of an error in a submitted username,
    password, or phone number, respectively. `onAuthSuccess()` is a callback invoked
    when the authorization procedure is successful. On the other hand, `onAuthError()`
    is invoked when the authorization fails.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当提交的用户名、密码或电话号码发生错误时，会调用 `onUsernameError()`、`onPasswordError()` 和 `onPhoneNumberError()`
    方法作为回调。`onAuthSuccess()` 是在授权过程成功时调用的回调。另一方面，当授权失败时，会调用 `onAuthError()`。
- en: Creating the signup view
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建注册视图
- en: 'It is time to work on the `SignUpView`. First we need to create a `SignUpView`
    interface, after which we will make `SignUpActivity` implement this interface.
    Note that in our application, a `SignUpView` is an extension of `BaseView` and
    `AuthView`. The following is the `SignUpView` interface:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始工作于 `SignUpView` 了。首先我们需要创建一个 `SignUpView` 接口，之后我们将让 `SignUpActivity` 实现这个接口。请注意，在我们的应用中，一个
    `SignUpView` 是 `BaseView` 和 `AuthView` 的扩展。以下就是 `SignUpView` 接口：
- en: '[PRE67]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now we shall modify the `SignUpActivity` class in the project to implement
    the `SignUpView` and make use of the `SignUpPresenter`. Add the changes in the
    following code snippet to `SignUpActivity`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将修改项目中的 `SignUpActivity` 类以实现 `SignUpView` 并使用 `SignUpPresenter`。将以下代码片段中的更改添加到
    `SignUpActivity`：
- en: '[PRE68]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now add the `setUsernameError()`, `setPasswordError()`, `showAuthError()`,
    `showSignUpError()` and `getContext()` functions shown below to `SignUpActivity`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将下面的 `setUsernameError()`, `setPasswordError()`, `showAuthError()`, `showSignUpError()`
    和 `getContext()` 函数添加到 `SignUpActivity` 中：
- en: '[PRE69]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Great work thus far! At this point, we are half of the way through the development
    of the Messenger application. You deserve a round of applause for your efforts.
    But we still have some work to do—especially with the main UI. We will finish
    up the remainder of the Messenger application in the next chapter.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经做得很好了！在这个阶段，我们完成了 Messenger 应用开发的一半。你的努力值得掌声。但我们还有一些工作要做——特别是主 UI。我们将在下一章完成
    Messenger 应用的剩余部分。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we began the development of the Messenger Android application.
    In the process of doing so, we covered a vast array of topics. We got down and
    dirty with the Model-View-Presenter pattern and explored in detail how to create
    an application utilizing this modern development approach.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始了 Messenger Android 应用的开发。在这个过程中，我们涵盖了众多主题。我们深入研究了 Model-View-Presenter
    模式，并详细探讨了如何利用这种现代开发方法创建应用。
- en: Further into the chapter, we learned about reactive programming and made extensive
    use of RxJava and RxAndroid. We learned how to communicate with a remote server
    using OkHttp and Retrofit, after which we took things one step further and implemented
    a fully functional Retrofit service to communicate with the Messenger API we developed
    in [Chapter 4](kt-prog-ex_ch04.html), *Designing and Implementing the Messenger
    Backend with Spring Boot 2.0*.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的进一步内容中，我们学习了响应式编程，并广泛使用了RxJava和RxAndroid。我们学习了如何使用OkHttp和Retrofit与远程服务器进行通信，之后我们更进一步，实现了一个完全功能性的Retrofit服务，用于与我们开发的[第4章](kt-prog-ex_ch04.html)中提到的信使API进行通信，*使用Spring
    Boot 2.0设计和实现信使后端*。
- en: In the next chapter, we will finish our work with the Messenger application.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将完成我们对信使应用程序的工作。
