- en: Building the Messenger Android App – Part I
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we began building the messenger application by designing
    and implementing a REST application programming interface that the client messenger
    application will communicate with. Over the course of implementing the backend
    API, we covered many things, such as working with Spring Boot, RESTful application
    programming interfaces and how they work, creating databases with PostgreSQL,
    and deploying Spring Boot web applications to AWS, to name a few.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will go one step further in our application development
    journey by implementing the Android Messenger application and integrating it with
    the RESTful API we created in [Chapter 4](kt-prog-ex_ch04.html), *Designing and
    Implementing the Messenger Backend with Spring Boot 2.0*. In the process of developing
    the Messenger Android app, we will learn a vast array of new topics, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Building MVP Android applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server communication via HTTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Retrofit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using token-based authentication in an Android app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Over the course of this chapter, you will learn firsthand how powerful Kotlin
    is in the Android application development domain. Let's dive into the development
    of the Messenger app.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the Messenger app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we need to create a new Android Studio project for the application. Create
    a new Android Studio project with the name `Messenger` and the package name `com.example.messenger`.
    Feel free to take a look at [Chapter 1](kt-prog-ex_ch01.html), *The Fundamentals*,
    to refresh your memory on Android project creation. In the process of project
    setup, when asked to create a new launcher activity, name the activity `LoginActivity`
    and make it an empty activity.
  prefs: []
  type: TYPE_NORMAL
- en: Including project dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Over the course of this chapter, we will make use of a number of external application
    dependencies. As such, it is important we include them in the project now. Open
    your module-level `build.gradle` file and add the following dependencies to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that no conflicting Android support library versions exist in the `build.gradle`
    file. Now modify the `build.gradle` project file to include the `jcenter` and
    Google repositories as well as the Android build tools dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Top-level build file where you can add configuration options common to all
    sub-projects/modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Don't worry, about what the dependencies added for now, all will be revealed
    over the course of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the Login UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the project is created, create a new package named `ui` in the `com.example.messenger`
    application source package. This package will hold all the user-interface-related
    classes and logic of the Android application. Create a `login` package within
    `ui`.  As you may have guessed, this package will hold classes and logic pertaining
    to the user-login process. Go ahead and move `LoginActivity` to the `login` package.
    Having moved `LoginActivity`, our first order of business is to create a suitable
    layout for the login activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Locate the `activity_login.xml` layout resource file and change the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There are string and dimension resources that we have made use of here that
    we have not yet created in the appropriate `.xml` resource files. We must add
    these resources at this juncture. While we are at it, we will also include resources
    that we will require later on in the application development phase so as to eliminate
    the need to jump back and forth between program files and resource files. Open
    the project''s string resource file (`strings.xml`) and ensure the following resources
    are added to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a dimensions resource file (`dimens.xml`) and add the following
    dimension resources to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the necessary project resources have been added, navigate back to
    `activity_login.xml` and toggle the design preview screen to view the layout that
    has been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/36fd17e0-95ab-4357-933c-b2118da19fc8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The layout is simple but functional, which is perfect for this simple messenger
    application we are building.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the login view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we have to work on `LoginActivity`. As we are building this application
    utilizing the MVP pattern, `LoginActivity` is effectively a view.  Obviously,
    `LoginActivity` is quite different from any generic view. It is a view that is
    concerned with login procedures. We can identify a set of necessary behaviors
    that a view presenting a login interface to a user must possess. Such behaviors
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: It must show a progress bar to a user when the login is in progress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must be capable of hiding the progress bar when the need arises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must be able to show appropriate field errors to users when encountered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must be able to navigate the user to his home screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must be able to navigate an unregistered user to a signup screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Having identified the preceding behaviors, we must ensure that `LoginActivity`—as
    a login view—exhibits such behaviors. A perfect way to do this is to utilize an
    interface. Create a `LoginView` interface in the `login` package containing the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: So far, so good with `LoginView`. There are a few issues with our interface
    though. A `LoginView` must have the ability to bind its layout views to appropriate
    object representations. In addition, a `LoginView` must be able to provide feedback
    to the user if an authentication error occurs. You may be thinking that neither
    of these two behaviors should be distinct to a `LoginView`. You are right. All
    views should have the ability to bind layout elements to programmatic objects.
    In addition, a signup view should also be able to provide the user with some kind
    of feedback if there is a problem during authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create two distinct interfaces to enforce these behaviors. We will
    name the first interface `BaseView`. Create a `base` package in `com.example.messenger.ui`
    and add an interface named `BaseView` to the package with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `BaseView` interface enforces that an implementing class declares `bindViews()`
    and `getContext()` functions for view bindings and context retrievals, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now create an `auth` package in `com.example.messenger.ui` and add an interface
    named `AuthView` to the package with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Fantastic job! Now go back to the `LoginView` interface and ensure that it
    extends `BaseView` and `AuthView`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: By declaring the `LoginView` interface as an extension of `BaseView` and `AuthView`,
    we ensure that every class that implements `LoginView` must declare the `bindViews()`,
    `getContext()`, and `showAuthError()` functions in addition to those declared
    in `LoginView`. It is important to note that any class that implements `LoginView`
    is effectively of the `LoginView`, `BaseView`, and `AuthView` type. The characteristic
    of a class possessing many types is known as polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having set up the `LoginView`, we can go ahead and work on `LoginActivity`.
    Firstly we will create `LoginActivity` to implement the methods declared in  `BaseView`
    and `AuthView` after which we will add the methods specific to a `LoginView`.
    `LoginActivity` is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Binds layout view object references to view elements when invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: So far so good. We have successfully implemented `BaseView` and `AuthView` methods
    in `LoginActivity`. We still must work on the `LoginView` specific methods `showProgress()`,
    `hideProgress()`, `setUsernameError()`, `setPasswordError()`, `navigateToSignUp()`
    and `navigateToHome()`. The required implementation of these  methods is given
    below. Go ahead and add them to `LoginActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Adding all the defined methods earlier, you have made the `LoginActivity` class
    to implement `LoginView` as well as the `View.OnClickListener` interface. As such,
    `LoginActivity` provides implementations for functions declared within these interfaces.
    Notice how the current instance of the `LoginActivity` is passed as an argument
    to `btnLogin.setOnClickListener()` via `this`. We can do this because we have
    declared `LoginActivity` to implement the `View.OnClickListener` interface. As
    such, `LoginActivity` is a valid `View.OnClickListener` instance (this is a perfect
    example of polymorphism at work).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have done some reasonable work on the login view, we must create
    an appropriate model to handle login logic. We must also create the necessary
    services and data repositories that this model will communicate with. We will
    first work on the required services and then develop the necessary data repositories
    before we build the interactor.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Messenger API service and data repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A critical thing that we must consider before getting too deep in our application
    development process is data storage. We must ask ourselves two very important
    questions: Where will data be stored, and how will the stored data be accessed?'
  prefs: []
  type: TYPE_NORMAL
- en: Pertaining to the location of data storage, data will be stored both locally
    (on the Android device) and remotely (on the Messenger API). The answer to the
    second question is similarly straightforward. To access stored data, we need to
    create suitable models, services, and repositories to facilitate data retrieval.
  prefs: []
  type: TYPE_NORMAL
- en: Storing data locally with SharedPreferences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First and foremost, we need to take care of local storage. As this is a simple
    application, we do not need to store much data locally. The only data we need
    to store on the device are access tokens and user details. We will be using `SharedPreferences`
    to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'First things first, create a `data` package within the application''s `source`
    package. We previously identified that we are going to be working with data stored
    locally and remotely. Hence, create two additional packages within `data`. Name
    the first `local` and the second `remote`. Similar to the approach that we used
    for the *Tetris* application that we created in [Chapter 2](kt-prog-ex_ch02.html), *Building
    an Android Application – Tetris* and [Chapter 3](kt-prog-ex_ch03.html), *Implementing
    Tetris Logic and Functionality*, we will be using an `AppPreferences` class to
    persist data locally. Create an `AppPreferences` class within `local` and populate
    it with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Returns an instance of `UserVO` containing appropriate user details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Stores user details passed in `UserVO` to the application''s `SharedPreferences`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In `AppPreferences`, we defined the `storeAccessToken(String)`, `storeUserDetails(UserVO)`,
    and `clear()` functions. `storeAccessToken(String)` will be used to store an access
    token retrieved from the remote server to the local preferences file. `storeUserDetails(UserVO)`
    takes a user value object (a data object that contains user information) as its
    only argument and stores the information contained in the value object to the
    preferences file. The `clear()` method, as the name implies, clears all values
    that have been stored in the preferences file. The `AppPreferences` instance also
    has `accessToken` and  `userDetails` properties, each having specialized getter
    functions to retrieve their appropriate values. In addition to this the functions
    and properties defined in `AppPreferences`, we also created a companion object
    possessing a single `create(Context)` function. The `create()` method, as the
    name implies, creates and returns a new `AppPreferences` instance for use. We
    made the primary constructor of `AppPreferences` private as we require that any
    class utilizing `AppPreferences` make use of `create()` for the instantiation
    of `AppPreferences`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating value objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to what we did when creating the messenger backend, we need to create
    value objects to model common types of data we will be handling across the application.
    Create a `vo` package in the `data` package. The value objects we are creating
    are already familiar to you. In fact, they are exactly the same as those we created
    during the development of the API. We are going to create `ConversationListVO`,
    `ConversationVO`, `UserListVO`, `UserVO`, and `MessageVO`. Create Kotlin files
    to hold each of these value objects in the `vo` package. Before creating any list
    value object data models, we have to create the basic models. These models are
    `UserVO`, `MessageVO`, and `ConversationVO`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `UserVO` data class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have created value objects in the past, the previous code doesn''t need
    much explaining. Add `MessageVO` to your `MessageVO.kt` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a `ConversationVo` data class in `ConversationVO.kt`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Having created the basic value objects, let''s create `ConversationListVO`
    and `UserListVO`, shall we? `ConversationListVO` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ConversationListVO` data class has a single `conversations` property of
    the `List` type that can only contain elements of the `ConversationVO` type. The `UserListVO` data
    class is similar to `ConversationListVO`, with the exception that it has a user''s
    property, which can only contain elements of the `UserVO` type instead of a `conversations`
    property. The following is the `UserListVO` data class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Retrieving remote data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already established that important data necessary for the functioning
    the messenger Android App will be stored remotely on the messenger backend. It
    is imperative that we have an efficient means by which our Android application
    can access the data held by the backend. To do this, the Messenger application
    needs to be able to communicate with the API via HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with a remote server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of ways that communication with a remote server can be achieved
    in Android. Common networking libraries used across the Android community are
    **Retrofit**, **OkHttp**, and **Volley**. Each of these libraries has its advantages
    and drawbacks. We will be making use of Retrofit in this project, but for the
    sake of knowledge, we will take a look at how to communicate with a remote server
    using OkHttp.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with servers using OkHttp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OkHttp is an efficient and easy-to-use HTTP client. It supports both synchronous
    and asynchronous network calls. Using OkHttp on Android is easy. Simply add its
    dependency to a project''s module-level `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Sending requests to a server with OkHttp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As previously stated, OkHttp''s APIs were built with ease of use in mind. As
    a consequence, sending requests via OkHttp is quick and hassle-free. The following
    is a `post(String, String)` method that takes a URL and JSON request body as its
    arguments and sends a POST request to the specified URL with the JSON body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the preceding function is straightforward. Invoke it with appropriate
    values, as you would any other function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Easy, right? Glad you agree. Communicating with a remote server is fun with
    OkHttp but using Retrofit to do this is even more fun. We are almost ready to
    work with Retrofit, but, before we explore Retrofit, it's a good idea to properly
    model the data we will be sending in our HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling request data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will make use of data classes to model the HTTP request data we wish to send
    to our API. Go ahead and create a `request` package in the `remote` package. There
    are four obvious requests that contain data payloads, which we will be sending
    to the API. These are login requests, message requests, status update requests,
    and requests containing user data. These four requests will be modeled by `LoginRequestObject`,
    `MessageRequestObject`, `StatusUpdateRequestObject`, and `UserRequest` objects,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows the `LoginRequestObject` data class. Go ahead
    and add it to the `request` package and do the same for other request objects
    that follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LoginRequestObject` data class possesses the `username` and `password`
    properties because these are the credentials that need to be supplied to the login
    endpoint of the API. The `MessageRequestObject` data class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`MessageRequestObject` possesses two properties as well. These are `recipientId`—the
    ID of a user receiving a message—and `message` —the body of the message being
    sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `StatusUpdateRequestObject` data class has a single `status` property.
    As the name implies, this is the status that a user wants to update their current
    status message to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`UserRequestObject` is similar to `LoginRequestObject` with the exception that
    it contains an additional `phoneNumber` property. This request object has varying
    use cases, such as to contain user signup data being sent to the API.'
  prefs: []
  type: TYPE_NORMAL
- en: Having created the necessary request objects, we can go ahead and create the
    actual `MessengerApiService`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Messenger API service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time for us to create a service that performs the all-important job of
    communicating with the Messenger API we created in [Chapter 4](kt-prog-ex_ch04.html),
    *Designing and Implementing the Messenger Backend with Spring Boot 2.0*. We will
    be making use of Retrofit and Retrofit's RxJava adapter to create this service.
    Retrofit is a type-safe HTTP client for Android and Java built by Square Inc.,
    and RxJava is an open source implementation of ReactiveX written in and for Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'We added Retrofit to our Android project at the beginning of this chapter with
    the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We also added Retrofit''s RxJava adapter dependency to our module-level `build.gradle`
    script, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step in creating a service with Retrofit is to define an interface
    that describes your HTTP API. Create a `service` package within your application
    `source` package and add the `MessengerApiService` interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As can be observed from the preceding code snippet, Retrofit relies on the
    use of annotations to properly describe HTTP requests to be sent. Take the following
    snippet, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `@POST` annotation tells Retrofit that this function describes an HTTP POST
    request that is mapped to the `/login` path. The `@Headers` annotation is used
    to specify the headers of the HTTP request. In the HTTP request described in the preceding
    code snippet, the `Content-Type` header has been set to `application/json`. Hence,
    the content being sent by this request is JSON.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Body` annotation specifies that the `user` argument passed to `login()`
    contains the data of the JSON request body to be sent to the API. `user` is of
    the `LoginRequestObject` type (we previously created this request object). Lastly,
    the function is declared to return an `Observable` object containing a `retrofit2.Response`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the `@POST`, `@Headers`, and `@Body` annotations, we made use of `@GET`,
    `@PUT`, `@Path`, and `@Header`. `@GET` and `@PUT` are used to specify `GET` and
    `PUT` requests, respectively. The `@Path` annotation is used to declare a value
    as a path argument of the HTTP request being sent. Take the following `showUser()`
    function, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`showUser` is a function that describes a GET request with the `users/{userId}`
    path. `{userId}` is not actually part of the HTTP request path. Retrofit will
    replace `{userId}` with the value passed to the `userId` argument of `showUser()`.
    Notice how `userId` is annotated with `@Path("userId")`. This lets retrofit know
    that `userId` holds a value that should be placed where `{userId}` is located
    in the HTTP request URL path.'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Header` is similar to `@Headers`, with the exception that it is used to specify
    a single header key-value pair in an HTTP request to be sent. Annotating authorization
    with `@Header("Authorization")` sets the `Authorization` header of the HTTP request
    sent to the value held within authorization.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have created an appropriate `MessengerApiService` interface to
    model the HTTP API that our application will communicate with, we need to be able
    to retrieve an instance of this service. We can easily do this by creating a `Factory`
    companion object that''s in charge of the creation of `MessengerApiService` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: It returns an instance of `MessengerApiService` when invoked. A new instance
    of `MessengerApiService` is created, if one has not been previously created
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`Factory` possesses a single `getInstance()` function that builds and returns
    an instance of `MessengerApiService` when called. An instance of `Retrofit.Builder`
    is used to create the interface. We set  the `CallAdapterFactory` in use to `RxJava2CallAdapterFactory`
    and we set the `ConverterFactory` in use to `GsonConverterFactory` (this handles
    JSON serialization and deserialization). Don''t forget to replace `"{AWS_URL}"` with
    the URL of the Messenger API AWS EC2 instance deployed in [Chapter 4](kt-prog-ex_ch04.html),
    *Designing and Implementing the Messenger Backend with Spring Boot 2.0*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the `Retrofit.Builder()` instance successfully, we use it to
    create an instance of `MessengerApiService`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, the service is returned for use by `getInstance()`. Regardless of the
    fact that we have created a suitable service to communicate with the Messenger
    API, it cannot be used to communicate with a network without specifying the necessary
    permissions in the `AndroidManifest`. Open the project''s `AndroidManifest` and
    add the following two lines of code within the `<manifest></manifest>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the messenger service ready to go, it is time that we create
    appropriate repositories to exploit this service.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing data repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are already familiar with repositories, so there is no need for an introduction
    to them. The repositories we are about to create are similar to those created
    for the Messenger API in [Chapter 4](kt-prog-ex_ch04.html), *Designing and Implementing
    the Messenger Backend with Spring Boot 2.0*. The only difference is that the data
    source for the repositories we are about to implement is a remote server, not
    a database residing on a host.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `repository` package within the `remote` package. First and foremost,
    we are going to implement a user repository to retrieve data pertaining to application
    users. Add a `UserRepository` interface to the repository, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'As this is an interface, we need to create a class that implements the functions
    specified within `UserRepository`. We will name this class `UserRepositoryImpl`.
    Create a new `UserRepositoryImpl` within the repositories package, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `UserRepositoryImpl` class has two instance variables: `preferences`
    and `service`. The `preferences` variable is an instance of the `AppPreferences`
    class we created earlier and `service` is an instance of `MessengerApiService`
    retrieved by the `getInstance()` function defined in the `Factory` companion object
    in the `MessengerApiService` interface.'
  prefs: []
  type: TYPE_NORMAL
- en: '`UserRepositoryImpl` provides implementations of the `findById()`, `all()`,
    and `echoDetails()` functions defined in `UserRepository`. The three functions
    implemented make use of `service` to retrieve the required data residing on the
    server via HTTP-appropriate requests. `findById()` calls the `showUser()` function
    in service to send a request to the Messenger API to retrieve the details of the
    user with the specified user ID. The `showUser()` function requires the authorization
    token of the currently logged-in user as its second argument. We provide this
    required token via the `AppPreferences` instance by passing `preferences.accessToken`
    as the second argument to the function.'
  prefs: []
  type: TYPE_NORMAL
- en: The `all()` function makes use of `MessengerApiService#listUsers()` to retrieve
    all the users that are registered on the messenger service. The `echoDetails()` function
    makes use of the `MessengerApiService#echoDetails()` function to get the details
    of the currently logged-in user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a conversation repository to facilitate the access of data pertaining
    to conversations. Add a `ConversationRepository` interface to `com.example.messenger.data.remote.repository`
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a corresponding `ConversationRepositoryImpl` class in the package,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'It retrieves information pertaining to a conversation with the requested conversation
    ID from the Messenger API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'It retrieves all active conversations of current user from API when invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`findConversationById(Long)` retrieves the conversation thread with the corresponding
    ID passed to the function. The `all()` function simply retrieves all of the current
    user''s active conversations.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the login interactor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is time to create our login interaction, which will serve as the model that
    the login presenter will interact with. Create a `LoginInteractor` interface in
    the `login` package containing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As you may have noticed, `LoginInteractor` extends `AuthInteractor`. This is
    similar to the way that `LoginView` extends `AuthView`. The `AuthInteractor` interface
    declares behaviors and characteristics that must be implemented by any interactor
    that handles authentication-related logic. Let's implement the `AuthInteractor`
    interface now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and add an `AuthInteractor` interface to the `com.exampla.messenger.auth`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Every interactor that is an `AuthInteractor` must have the following fields:
    `userDetails`, `accessToken`, `submittedUsername`, and `submittedPassword`. In
    addition, an interactor that implements `AuthInteractor` must have `persistAccessToken(AppPreferences)`
    and `persistUserDetails(AppPreferences)` methods. As the names of the methods
    suggest, they persist access tokens and user details to the application''s `SharedPreferences`
    file. As you might have guessed, we need to create an implementation class for
    the `LoginInteractor`. We will call this class `LoginInteractorImpl`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the `LoginInteractorImpl` class with its implemented `login()`
    method. Add it to the `login` package within the `ui` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If an empty `username` is submitted in the login form, the `username` is invalid.
    The listener''s `onUsernameError()` function is called when this happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the listener''s `onPasswordError()` function when an empty `password`
    is submitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Initializing model''s `submittedUsername` and `submittedPassword` fields and
    creating appropriate `LoginRequestObject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Using `MessengerApiService` to send a login request to Messenger API.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Branched reached when an HTTP 403 (forbidden) status code is returned by the
    server. This indicates that the login failed and the user is not
  prefs: []
  type: TYPE_NORMAL
- en: authorized to access the server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '`login()` works by first verifying that the provided `username` and `password`
    arguments are not blank. The `onUsernameError()` function of the `onAuthFinishedListener`
    is invoked when a blank username is encountered and `onPasswordError()` is invoked
    when a blank password is encountered. If neither the username nor password provided
    is blank, it then makes use of `MessengerApiService` to send a login request to
    the messenger API. If the login request is successful, then it sets the `accessToken`
    property to the access token retrieved from the `Authorization` header of the
    API response and then invoked the listener''s `onAuthSuccess()` function. In a
    scenario when the login request fails, the `onAuthError()` listener function is
    invoked.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Having understood the login process, add the `retrieveDetails()`, `persistAccessToken()`
    and `persistUserDetails()` methods below to `LoginInteractorImpl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'It retrieves details of user upon initial login:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Make sure to read through the comments in the preceding code snippet carefully.
    They thoroughly explain the workings of the `LoginInteractor`. It is now time
    to work on the `LoginPresenter`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the login presenter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A presenter, as we saw in [Chapter 3](kt-prog-ex_ch03.html), *Implementing
    Tetris Logic and Functionality*, is the middleman between a view and a model.
    It is necessary to create suitable presenters for views to properly facilitate
    clean view-model interactions. Creating a presenter is fairly easy. We need to
    first create an interface that properly declares the behaviors that will be exhibited
    by the presenter. Create a `LoginPresenter` interface in the `login` package with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'As can be easily seen in the preceding code snippet, we want a class that acts
    as a `LoginPresenter` for a `LoginView` to possess an `executeLogin(String, String)`
    function. This function will be called by the view and will then interact with
    a model handling the login logic for the application. We will need to create a
    `LoginPresenterImpl` class that implements `LoginPresenter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `LoginPresenterImpl` class implements `LoginPresenter`, `AuthInteractor.onAuthFinishedListener`,
    and `LoginInteractor.OnDetailsRetrievalFinishedListener`, and, as such, implements
    all behaviors required by the interfaces. `LoginPresenterImpl` overrides seven
    functions in all: `onPasswordError()`, `onUsernameError()`, `onAuthSuccess()`,
    `onAuthError()`, `onDetailsRetrievalSuccess()`, `onDetailsRetrievalError()`, and
    `executeLogin(String, String)`. The interaction between the `LoginPresenter` and
    `LoginInteractor` can be seen within the `onAuthSuccess()` and `executeLogin(String,
    String)` functions. When a user submits their login details, the `LoginView` calls
    the `executeLogin(String, String)` function in `LoginPresenter`. In turn, `LoginPresenter`
    uses `LoginInteractor` to handle the actual login procedure by calling the `login(String,
    String)` function of `LoginInteractor`.
  prefs: []
  type: TYPE_NORMAL
- en: If the user login is successful, the `onAuthSuccess()` callback function of
    `LoginPresenter` is invoked by the `LoginInteractor`. This then leads to the storing
    of the access token returned by the server and the retrieval of the logged-in
    user's account details. When the login request is declined by the server, `onAuthError()`
    is called and an informative error message is displayed to the user.
  prefs: []
  type: TYPE_NORMAL
- en: When a user's account details are successfully retrieved by the interactor,
    the `onDetailsRetrievalSuccess()` callback of `LoginPresenter` is invoked. This
    leads to the storage of the account details. The progress bar shown to the user
    over the course of the login is then hidden with `view.hideProgress()`, after
    which the user is navigated to the home screen with `view.navigateToHome()`. If
    the retrieval of user details fails, `onDetailsRetrievalError()` is called by
    `LoginInteractor`. The presenter then requests another attempt at retrieving the
    user's account details by calling `interactor.retrieveDetails(preferences, this)`
    once more.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing the LoginView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you recall, we did not finish our implementation of the `LoginView` earlier.
    Functions such as `navigateToSignUp()`, `navigateToHome()`, and `onClick(view:
    View)` were left with empty bodies. In addition, the `LoginView` did not interact
    in any way with the `LoginPresenter`. Let''s fix that now, shall we?'
  prefs: []
  type: TYPE_NORMAL
- en: Fist things first, to navigate a user to the signup screen and home screen,
    we need views for these screens to exist. We won't concern ourselves with implementing
    layouts for them now (that will be done in the following sections). We just need
    them to exist. Create the `signup` and `main` packages under `com.example.messenger.ui`.
    Create a new empty activity called `SignUpActivity` in the `signup` package and
    an empty activity called `MainActivity` within `main`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open `LoginActivity.kt`. We need to modify the previously mentioned functions
    to perform their respective tasks. In addition, we need to add private properties
    for a `LoginPresenter` instance and an `AppPreferences` instance. These changes
    are made in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, add the properties below to the top of the `LoginActivity` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now modify `navigateToSignUp()`, `navigateToHome()`, and `onClick(view: View)` as
    shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '`navigateToSignUp()` uses an explicit intent to start `SignUpActivity` when
    called. `navigateToHome()` operates similarly to `navigateToSignUp()`—it starts
    `MainActivity`. A major difference between `navigateToHome()` and `navigateToSignUp()`
    is that `navigateToHome()` destroys the current `LoginActivity` instance by calling
    `finish()` before starting the `MainActivity`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `onClick()` method uses the `LoginPresenter` to begin the login process
    in the scenario that the login button is clicked. Otherwise, if the signup button
    is clicked, the `SignUpActivity` is started with `navigateToSignUp()`.
  prefs: []
  type: TYPE_NORMAL
- en: Great job thus far! We have created the necessary view, presenter, and model
    for login-related application logic. We need to keep in mind that before we can
    log in a user, we need to have registered a user on the platform first. Thus,
    we must implement our signup logic. We will do this in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the signup UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's develop the signup user interface. First, we have to implement the necessary
    views, starting from the layout of `SignUpActivity`. We do not need much in terms
    of elements for our `SignUpActivity` layout. We need three input fields to take
    the username, password, and phone number of a user to be registered. In addition,
    we need a button to submit the signup form as well as a progress bar to show when
    the signup is in progress.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is our `activity_sign_up.xml` layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The visual translation of the XML layout written earlier is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3479aa1d-d799-44cf-a594-53284db40d6e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the layout we designed contains all the necessary elements we
    previously mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the signup interactor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we will implement a signup interactor to act as a model that our yet-to-be-implemented
    signup presenter will communicate with. Create a `SignUpInteractor` interface
    within the `signup` package, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that `SignUpInteractor` extends `AuthInteractor`. Similar
    to a `LoginInteractor`, a `SignUpInteractor` requires the use of `userDetails`,
    `accessToken`, `submittedUsername`, and `submittedPassword` properties. In addition,
    `SignUpInteractor` needs to be able to persist the access token of a user as well
    as their user details by using the `persistAccessToken(AppPreferences)` and `persistUserDetails(AppPreferences)`
    functions, which are declared in the `AuthInteractor` interface.
  prefs: []
  type: TYPE_NORMAL
- en: We created an `OnSignUpFinishedListener` interface within `SignUpInteractor`
    declaring callbacks that must be implemented by an `OnSignUpFinishedListener`.
    This listener will be our `SignUpPresenter` when we implement it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In creating `SignUpInteractorImpl`, we shall start first and foremost with
    its property declarations and the implementation of its `login()` method. Create
    `SignUpInteractorImpl` which is as follows. Ensure that you add it to the same
    package as `SignUpInteractor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Registering a new user to the Messenger platform with the `MessengerApiService`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add the `getAuthorization()`, `persistAccessToken()` and `persistUserDetails()`
    methods below to `SignUpInteractorImpl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s log the registered user in to the platform with the `MessengerApiService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, user has been successfully logged in. Hence, we invoke listener''s `onAuthSuccess()`
    callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The `SignUpInteractorImpl` class is a straightforward implementation of the
    `SignUpInteractor` interface. Lines 19 to 22 contain property declarations for
    `userDetails`, `accessToken`, `submittedUsername`, and `submittedPassword` that
    must be possessed by an `AuthInteractor`. `signUp(String, String, String, SignUpInteractor.OnSignUpFinishedListener)`
    contains the signup logic for the application. If all values submitted by a user
    are valid, then the user is registered on the platform with the `createUser(UserRequestObject)`
    function of the `MessengerApiService` that we created with Retrofit.
  prefs: []
  type: TYPE_NORMAL
- en: '`getAuthorization(AuthInteractor.onAuthFinishedListener)` is called to authorize
    a newly registered user of the messenger platform. Make sure to peruse the comments
    within `SignUpInteractorImpl` for more information.'
  prefs: []
  type: TYPE_NORMAL
- en: Next on our agenda is the creation of the `SignUpPresenter`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the signup presenter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we did when creating the `LoginPresenter`, we need to create a `SignUpPresenter`
    interface along with a `SignUpPresenterImpl` class. The `SignUpPresenter` we are
    making is in no way complex. For this application, we need our signup presenter
    to possess a property of the `AppPreferences` type as well as a function that
    executes the signup process. The following is the `SignUpPresenter` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, here is the code for our `SignUpPresenter` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onSuccess()` callback below is invoked when user is successfully signed
    up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The callback invoked when an error occurs during user sign up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `SignUpPresenterImpl` class implements the `SignUpPresenter`,
    `SignUpInteractor.OnSignUpFinishedListener`, and `AuthInteractor.onAuthFinishedListener`
    interfaces, and, as such, provides implementations for a number of required functions.
    These functions are `onSuccess()`, `onError()`, `onUsernameError()`, `onPasswordError()`,
    `onPhoneNumberError()`, `executeSignUp(String, String, String)`, `onAuthSuccess()`,
    and `onAuthError()`. `SignUpPresenterImpl` takes a single argument as its primary
    constructor. This argument must be of the `SignUpView` type.
  prefs: []
  type: TYPE_NORMAL
- en: '`executeSignUp(String, String, String)` is a function that will be invoked
    by a `SignUpView` to begin the user registration process. `onSuccess()` is called
    when a user''s signup request is successful. The function immediately invokes
    the interactor''s `getAuthorization()` function to get an access token for the
    newly registered user. In a scenario when a signup request fails, the `onError()`
    callback is invoked. This hides the progress bar being shown to the user and displays
    an appropriate error message.'
  prefs: []
  type: TYPE_NORMAL
- en: The `onUsernameError()`, `onPasswordError()`, and `onPhoneNumberError()` methods
    are callbacks invoked upon the occurrence of an error in a submitted username,
    password, or phone number, respectively. `onAuthSuccess()` is a callback invoked
    when the authorization procedure is successful. On the other hand, `onAuthError()`
    is invoked when the authorization fails.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the signup view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is time to work on the `SignUpView`. First we need to create a `SignUpView`
    interface, after which we will make `SignUpActivity` implement this interface.
    Note that in our application, a `SignUpView` is an extension of `BaseView` and
    `AuthView`. The following is the `SignUpView` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we shall modify the `SignUpActivity` class in the project to implement
    the `SignUpView` and make use of the `SignUpPresenter`. Add the changes in the
    following code snippet to `SignUpActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add the `setUsernameError()`, `setPasswordError()`, `showAuthError()`,
    `showSignUpError()` and `getContext()` functions shown below to `SignUpActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Great work thus far! At this point, we are half of the way through the development
    of the Messenger application. You deserve a round of applause for your efforts.
    But we still have some work to do—especially with the main UI. We will finish
    up the remainder of the Messenger application in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we began the development of the Messenger Android application.
    In the process of doing so, we covered a vast array of topics. We got down and
    dirty with the Model-View-Presenter pattern and explored in detail how to create
    an application utilizing this modern development approach.
  prefs: []
  type: TYPE_NORMAL
- en: Further into the chapter, we learned about reactive programming and made extensive
    use of RxJava and RxAndroid. We learned how to communicate with a remote server
    using OkHttp and Retrofit, after which we took things one step further and implemented
    a fully functional Retrofit service to communicate with the Messenger API we developed
    in [Chapter 4](kt-prog-ex_ch04.html), *Designing and Implementing the Messenger
    Backend with Spring Boot 2.0*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will finish our work with the Messenger application.
  prefs: []
  type: TYPE_NORMAL
