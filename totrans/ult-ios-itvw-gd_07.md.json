["```swift\nvar name: String?\n```", "```swift\nvar name: String? = \"Avi\"if let unwrappedValue = name {\n    print(\"The unwrapped value is: \\(unwrappedValue)\")\n} else {\n    print(\"The optional was nil\")\n}\nif let statement safely “extracts” the value from the unwrappedValue variable and provides an else statement in case it is nil.\n```", "```swift\nvar name: String? = \"Avi\"if let name {\n    print(\"The unwrapped value is: \\(name)\")\n} else {\n    print(\"The optional was nil\")\n}\n```", "```swift\n    func checkPerson(name: String, age: Int, address: Address?) -> Bool\n    ```", "```swift\n    func getParentViewController() -> UIViewController?\n    ```", "```swift\n    struct Person {    var name: String    var age: Int    var address: String?}\n    ```", "```swift\n    if let value = optionalValue {    // Do something with the unwrapped value}\n    ```", "```swift\n    if let country = person.address?.country {    print(\"The person lives in \\(country).\")} else {    print(\"The person's address is unknown.\")}\n    ```", "```swift\n    guard let value = optionalValue else {    return}// Do something with the unwrapped value\n    ```", "```swift\n    let value = optionalValue!// Do something with the unwrapped value\n    ```", "```swift\n    let value = optionalValue ?? defaultValue\n    ```", "```swift\nlet value = optionalValue!\n```", "```swift\nvar maybeString: String?maybeString = \"Hello\"\nif let unwrappedString = maybeString {\n    // If the optional has a value, print it\n    print(unwrappedString) // Output: Hello\n    print(maybeString!) // force unwrapping\n}\n```", "```swift\nclass ViewController: UIViewController {    // Declare an IBOutlet\n    @IBOutlet var label: UILabel!\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // Force unwrap the label outlet\n        label.text = \"Hello World!\"\n    }\n}\n```", "```swift\noverride func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {    let cell = tableView.dequeueReusableCell\n        (withIdentifier: \"customCell\", for: indexPath) as!\n            CustomTableViewCell\n    // configure the cell using the properties and methods\n       of the custom class\n    return cell\n}\n```", "```swift\nclass Game {    private var gameOver: Bool = false\n    public func restart() {\n        gameOver = false\n        // Other restart logic here\n    }\n}\n```", "```swift\nclass SomeClass: SomeDelegate {    var completion: ((Bool) -> Void)?\n    Func startAsyncOperation(completion: @escaping ((Bool) -> Void)) {\n        self.completion = completion\n        // Start async operation\n        NetworkManager.shared.performAsyncOperation (delegate: self)\n    }\n    func operationDidFinish(success: Bool) {\n        self.completion?(success)\n    }\n}\nprotocol SomeDelegate: AnyObject {\n    func operationDidFinish(success: Bool)\n}\n```", "```swift\nlet someObject = SomeClass()someObject.startAsyncOperation { success in\n    if success {\n        print(\"Async operation succeeded\")\n    } else {\n        print(\"Async operation failed\")\n    }\n}\n```", "```swift\nclass SomeClass {    let someProperty = \"property value\"\n    var closure: (() -> Void)?\n    func setupClosure() {\n        closure = {\n            print(self.someProperty)\n        }\n    }\n}\nlet someObject = SomeClass()\nsomeObject.setupClosure()\n```", "```swift\nclass SomeClass {    let someProperty = \"property value\"\n    var closure: (() -> Void)?\n    func setupClosure() {\n        closure = { [weak self] in\n            guard let self else { return }\n            print(self.someProperty)\n        }\n    }\n}\n```", "```swift\nclass Country {    let name: String\n    var capital: CapitalCity?\n    init(name: String) {\n        self.name = name\n    }\n    deinit {\n        print(\"\\(name) is no longer a country.\")\n    }\n}\nclass CapitalCity {\n    let name: String\n    unowned let country: Country\n    init(name: String, country: Country) {\n        self.name = name\n        self.country = country\n    }\n    deinit {\n        print(\"\\(name) is no longer a capital city.\")\n    }\n}\n```", "```swift\nclass Rectangle {    var width: Double\n    var height: Double\n    var area: Double {\n        return width * height\n    }\n}\n```", "```swift\nclass ExpensiveObject {    // Some expensive initialization\n}\nclass MyClass {\n    lazy var expensiveObject = ExpensiveObject()\n}\n```", "```swift\nclass MyData {    lazy var largeData: [String] = {\n        // load large data from a file or remote API\n        return loadLargeData()\n    }()\n    private func loadLargeData() -> [String] {\n        // perform the expensive operation to load the\n           large data\n        // here we just return an array of string but it\n           could be some large data\n        return [\"large\",\"data\",\"loaded\"]\n    }\n}\nlet data = MyData()\n// the largeData is not loaded until this point\nprint(data.largeData)\n```", "```swift\nprotocol MyProtocol {    // existing protocol requirements\n}\nextension MyProtocol {\n    func newMethod() {\n        // implementation\n    }\n}\n```", "```swift\nstruct MyStruct: MyProtocol {    // existing struct properties and methods\n}\nlet myStruct = MyStruct()\nmyStruct.newMethod()\n```", "```swift\nfunc reverseArray<T>(arr: [T]) -> [T] {    var reversedArr: [T] = []\n    for i in stride(from: arr.count - 1, through: 0, by: -1) {\n        reversedArr.append(arr[i])\n    }\n    return reversedArr\n}\nlet numbers = [1, 2, 3, 4, 5]\nlet reversedNumbers = reverseArray(arr: numbers)\n// reversedNumbers is [5, 4, 3, 2, 1]\nlet words = [\"apple\", \"banana\", \"cherry\"]\nlet reversedWords = reverseArray(arr: words)\n// reversedWords is [\"cherry\", \"banana\", \"apple\"]\n```", "```swift\nfunc reverseArray<T>(arr: [T]) -> [T]\n```", "```swift\nclass Cache<T> {    private var cache = [String: T]()\n    func set(value: T, for key: String) {\n        cache[key] = value\n    }\n    func get(for key: String) -> T? {\n        return cache[key]\n    }\n}\n```", "```swift\nlet cache = Cache<[Int]>()cache.set(value: [1, 2, 3, 4, 5], for: \"numbers\")\nlet cachedNumbers = cache.get(for: \"numbers\")\n// cachedNumbers is [1, 2, 3, 4, 5]\n```", "```swift\nprotocol DataSource {    associatedtype Data\n    func fetchData() -> Data\n}\n```", "```swift\nstruct LocalDataSource: DataSource {    typealias Data = [Int]\n    func fetchData() -> [Int] {\n    }\n}\n```", "```swift\nlet result = try? someThrowingFunction()if result != nil {\n    // Use the result\n} else {\n    // Handle the error\n}\n```", "```swift\nlet result = try! someThrowingFunction()\n```", "```swift\n    func readFile(at path: String) throws -> String { … }\n    ```", "```swift\n    enum FileError: Error {    case fileNotFound}\n    ```", "```swift\n    enum FileError: Error {    case fileNotFound}func readFile(at path: String) throws -> String {    guard let data = FileManager.default.contents        (atPath: path) else {        throw FileError.fileNotFound    }    return String(data: data, encoding: .utf8) ?? \"\"}\n    ```", "```swift\nclass ViewController: UIViewController {    var delegate: ViewControllerDelegate?\n}\nprotocol ViewControllerDelegate: class {\n    func didTapButton()\n}\nclass AnotherViewController: UIViewController,\n    ViewControllerDelegate {\n    weak var viewController: ViewController?\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        viewController = ViewController()\n        viewController!.delegate = self\n    }\n    func didTapButton() {\n        // Perform some action\n    }\n}\n```"]