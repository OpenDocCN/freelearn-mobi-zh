<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Best Practices and Securing Your Application</h1></div></div></div><p>The Android operating system was designed in anticipation of hackers attempting to perform common attacks, such as social engineering attacks that try to trick the user into handing over their personal information or installing malware.</p><p>Android comes with built-in security features that significantly reduce the chances of security exploits succeeding, and that limit the impact of any attacks that <em>do</em> succeed.</p><p>These built-in security controls provide you, your application, and your users with a certain level of protection by default. Nevertheless, following security best practices is essential for further reducing the chances of your app leaving users vulnerable to exploits, data leaks, and other security-related issues.</p><p>In this chapter, we're going to look at how you can make the most of Android's built-in security features. Towards the end of this chapter, I'll also look at some best practices we haven't covered in detail in any of the previous chapters, including how to design more effective notifications and ensuring that your app is accessible to all users.</p><div><div><div><div><h1 class="title"><a id="ch10lvl1sec62"/>Keeping user data secure</h1></div></div></div><p>The most common security concern for your typical Android user is whether the applications they've chosen to install can access the sensitive data stored on their device.</p><p>If your app has access to the user's data, then you have a responsibility to make sure that data remains secure. One of the quickest and easiest ways of protecting user data is to take a long hard look at whether your app really needs access to this data at all. If you minimize the data your app has access to in the first place, then you minimize the risk of your app inadvertently exposing personal information. You also reduce the chances of attackers being tempted to try and exploit your application in order to gain access to the sensitive data it's privy to. You should always be on the lookout for ways to create the same effect <em>without</em> your app requiring direct access to sensitive data.</p><p>Wherever possible, don't store usernames or passwords on the user's device. Instead, your app should perform initial authentication using the username and password supplied by the user, and then switch to a short-lived, service-specific authorization token.</p><p>To help protect your users from phishing attacks, you should also minimize the number of times your app asks for user credentials. This way, a phishing attack is more likely to strike the user as suspicious, as it'll be out of character for your app to ask for sensitive information.</p><div><div><h3 class="title"><a id="note109"/>Note</h3><p>If your app does need access to passwords and usernames, keep in mind that you may be legally required to provide a privacy policy explaining how your app uses and stores this data.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec127"/>Connecting to a network</h2></div></div></div><p>Network transactions pose an inherent security risk, particularly since mobile users are more likely to connect to unsecured wireless networks such as public Wi-Fi hotspots.</p><p>Whenever your app connects to a network, it's crucial that you implement the following best practices, in order to help keep your users safe:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use <code class="literal">HTTPS</code> over <code class="literal">HTTP</code> wherever possible. Also, never automatically trust <em>any</em> data downloaded from insecure protocols such as <code class="literal">HTTP</code>.</li><li class="listitem" style="list-style-type: disc">Implement authenticated, encrypted, socket-level communication using the <code class="literal">SSLSocket</code> class.</li><li class="listitem" style="list-style-type: disc">When you're handling sensitive IPC, use an Android IPC mechanism that can authenticate the identity of the application connecting to your IPC, such as a <code class="literal">Binder</code>, <code class="literal">Intent</code>, <code class="literal">BroadcastReceiver</code>, or <code class="literal">Messenger with a Service</code>. This is more secure than using localhost network ports.</li><li class="listitem" style="list-style-type: disc">Don't use unauthenticated SMS data to perform sensitive commands. SMS are neither encrypted nor strongly authenticated by default, and are therefore susceptible to interception on the network.</li><li class="listitem" style="list-style-type: disc">When sending data messages from a web server to your app, you should use the <strong>Google Cloud Messaging APIs</strong> and IP networking wherever possible.</li></ul></div><p>Android N also introduces the concept of a <strong>network security configuration</strong> file, which you can use to create custom network security settings for your app without having to modify your actual application code. You can use this new network security configuration file to:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Specify which certificate authorities are trusted for your app's secure connections</li><li class="listitem" style="list-style-type: disc">Restrict an app's secure connections to specific, named certificates</li><li class="listitem" style="list-style-type: disc">Debug secure connections in your app without added risk to the installed base</li><li class="listitem" style="list-style-type: disc">Protect apps from accidentally using clear-text traffic, which is a particular security risk as it transmits potentially sensitive data in a human-readable format</li></ul></div><p>To create a network security configuration file, create a new XML values resource file with the following path:</p><pre class="programlisting">res/xml/network_security_config.xml:</pre><p>Then reference this file in your project's Manifest:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt; &#13;
 &#13;
... &#13;
 &#13;
&lt;app ...&gt; &#13;
 &#13;
   &lt;meta-data android:name="android.security.net.config" &#13;
              android:resource="@xml/network_security_config" /&gt; &#13;
   &#13;
... &#13;
 &#13;
&lt;/app&gt; &#13;
</pre><p>The structure of a simple network configuration file is as follows:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt; &#13;
&lt;network-security-config&gt; &#13;
   &lt;base-config&gt; &#13;
 &#13;
//This is the default configuration used by all connections that are not covered by a specific domain-config// &#13;
 &#13;
       &lt;trust-anchors&gt; &#13;
 &#13;
&lt;certificates src="img/trusted_cas"/&gt; &#13;
 &#13;
        //This is a reference to an XML file where you'd name any trusted Certificate Authorities//  &#13;
 &#13;
       &lt;/trust-anchors&gt; &#13;
 &#13;
   &lt;/base-config&gt; &#13;
 &#13;
   &lt;domain-config&gt; &#13;
 &#13;
       &lt;domain&gt;mydomain.com&lt;/domain&gt; &#13;
 &#13;
... &#13;
... &#13;
 &#13;
 //This is where you'd create a configuration to use for connections to a specific destination, in this example that's www.mydomain.com//   &#13;
 &#13;
        &lt;/domain-config&gt; &#13;
&lt;/network-security-config&gt;&#13;
</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec63"/>Requesting permissions</h1></div></div></div><p>Android devices do a lot—from snapping photos and recording videos, to providing directions, posting to social media, and sending SMS messages. This means your typical Android device has access to <em>huge</em> amounts of sensitive information.</p><p>The good news is that Android does a lot to help keep this information secure. The platform is based on a privilege-separated system where apps run separately from one another and from the system, in a limited-access sandbox. This restricts the data and features each app has access to. By default, no Android app has permission to perform any operation that could adversely affect the operating system, the user, or other applications, which helps prevent malicious apps from corrupting data or accessing sensitive information. These permissions also restrict each app's access to device features not provided by the basic sandbox, protecting the user from apps making unauthorized use of hardware (such as accessing the device's camera) or external communication channels (such as connecting to the Internet).</p><p>However, there are legitimate reasons why your app might need to access the user's information or device capabilities, such as an SMS app that requires access to your contacts list or a video recording app that needs to access the device's camera. If your app does require access to protected information or features, then you'll need to prompt the user for access. The user then has the choice to accept or deny this permission request.</p><p>Originally, Android apps requested all the permissions they might possibly need up front before the user could even download the app from Google Play. If the user didn't want to grant the app one or more of the requested permissions, their only option was to abandon the installation altogether, and go looking for an alternative app.</p><p>Android 6.0 completely overhauled this permissions model, replacing it with new <strong>runtime permissions</strong>.</p><p>Beginning with Android 6.0, apps request permissions one by one while the app is running, as and when that app requires access to protected services, data, or device features.</p><p>For example, imagine you'd developed a note-taking app that supports traditional text notes, but also gives users the option to record voice memos. Before Android 6.0, the user would have to grant this app permission to access the microphone at install time. However, under the new permissions model, the user can launch your note-taking app and write as many text memos as they want, potentially without the app ever requesting access to the microphone. Your app will only request microphone access when the user tries to record a voice memo for the first time, as this permission is required to complete the current task.</p><p>In Android 6.0 and higher, users can change an app's permissions manually at any time, by opening their device's <strong>Settings</strong> and selecting <strong>Apps</strong>. At this point, they'll see a list of all the apps installed on their device. They can then select any app from the list, and tap <strong>Permissions</strong> to see all the permission categories this particular app has access to.</p><p>
</p><div><img src="img/B05061_10_1.jpg" alt="Requesting permissions"/></div><p>
</p><p>The user can revoke any permission, by dragging that permission's slider to the <strong>Off</strong> position.</p><p>
</p><div><img src="img/B05061_10_2.jpg" alt="Requesting permissions"/></div><p>
</p><p>This new permission model has a number of benefits for both users and developers:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The user no longer has to read through a list of permissions before they can install an app, which makes for a more streamlined installation process.</li><li class="listitem" style="list-style-type: disc">If you release an update that requires new permissions, previously the user had to accept these permissions before they could install the update. In Android 6.0 and higher, apps update automatically and will then make any new permission requests associated with the update, as and when (and if) those permissions are required.</li><li class="listitem" style="list-style-type: disc">Users have more control over the information and features each app has access to. The new permission model gives users the option to deny individual permission requests, something that wasn't possible in previous versions of Android. For example, a user who has downloaded an image-editing app may be happy to give that app access to their gallery, but more hesitate to grant that same app access to their device's camera. In previous versions of Android, the user <em>had</em> to grant that app all the permissions it requested up front, or not install the app at all. However in Android 6.0 and higher, the user is free to deny the app access to their camera, if they're not comfortable with that particular permission request.</li></ul></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Users are more likely to understand why your app is requesting each permission, as requests now happen in context when the user is trying to access a related feature for the first time. And when users understand why your app is requesting access to sensitive information or device features, they're more likely to grant those requests.</li></ul></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec128"/>The new permissions model – backwards compatibility</h2></div></div></div><p>Under the new permissions model, users can revoke any permission they've previously granted to any app, at any time, even if that app targets API level 22 or lower. This means you need to test that your app continues to function normally if the user denies one or more of its permission requests—<em>regardless </em>of your app's <code class="literal">targetSdkVersion</code> value.</p><p>Initially, if your app winds up on a device running Android 5.1 (API level 22) or lower, <em>or</em> your app's <code class="literal">targetSdkVersion</code> is 22 or lower, the system defaults to the old permissions model and makes all permission requests up front, at install time. If the user denies these permissions requests, then the system won't install the app. Similarly, if you add a new permission to an updated version of your app, the system will ask the user to grant these new permissions before they can install the update.</p><p>However, users can <em>still</em> revoke previously granted permissions manually by selecting their device's <strong>Settings</strong>, followed by <strong>Apps</strong>, and then selecting your app from the list.</p><p>If your app targets an earlier version of the Android platform and you <em>haven't</em> accounted for the new permissions model, your app may no longer function normally (or at all) if the user chooses to revoke one or more of your app's permissions manually. The system will warn the user that revoking permissions for apps targeting earlier versions of Android can cause the app in question to stop working, but the user still has the option to go ahead and revoke these permissions, if they really want to.</p><p>Even if your app targets pre-6.0 versions of the Android platform only, you shouldn't just assume that you can ignore the new permissions model. You should still aim to create an app that provides a good user experience, even if the user chooses to revoke some (or all) of its previously granted permissions.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec129"/>Permission groups</h2></div></div></div><p>Android's permissions are divided into two categories:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Normal permissions:<p>These permissions give your app access to data or resources outside of its sandbox, but pose very little direct risk to the user's privacy, the operation of the device, or to other apps.</p><p>If you declare that your app requires a normal permission in its <code class="literal">Manifest</code>, the system will automatically grant your app that permission.</p></li><li class="listitem" style="list-style-type: disc">Dangerous permissions:<p>These permissions give your app access to data or resources that could pose a risk to the user's privacy, or that may affect the user's stored data, other apps, or the device's normal operation. For example, being able to read the user's contacts list is considered a dangerous permission.</p><p>If the user's device is running Android 6.0 (API Level 23) or higher <em>and</em> your app's <code class="literal">targetSdkVersion</code> is 23 or higher, then dangerous permissions trigger a permission request only when the user tries to perform an operation that requires this permission. For example, if your app requires the <code class="literal">READ_CONTACTS</code> permission, the system may ask for that permission the first time the user tries to create an SMS message.</p><p>If your app winds up on a device running Android 5.1 or lower, or its <code class="literal">targetSdkVersion</code> is 22 or lower, the Android system will ask the user to grant all dangerous permissions at install time.</p></li></ul></div><p>In addition to the <em>normal</em> and <em>dangerous</em> ratings, Android groups related permissions into permission groups. When your app requests access to a permission, the user will be presented with a dialogue requesting access to that entire permissions group.</p><p>If your app requests a dangerous permission and the user has already granted your app access to another dangerous permission from that same group, the system will grant that permission automatically without requiring any additional input from the user.</p><p>This approach helps mobile users make more informed decisions about what parts of their device and what information each app should have access to<em> without </em>overwhelming them with technical information or too many permission requests.</p><p>Permissions are divided into nine groups:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Calendar</li><li class="listitem" style="list-style-type: disc">Camera</li><li class="listitem" style="list-style-type: disc">Contacts</li><li class="listitem" style="list-style-type: disc">Location</li><li class="listitem" style="list-style-type: disc">Microphone</li><li class="listitem" style="list-style-type: disc">Phone</li><li class="listitem" style="list-style-type: disc">Body sensors</li><li class="listitem" style="list-style-type: disc">SMS</li><li class="listitem" style="list-style-type: disc">Storage</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec130"/>Declaring permissions</h2></div></div></div><p>As you develop your app, make a note every time your app requires access to resources or information that it doesn't create itself, or whenever it attempts to perform actions that could impact the user's privacy, the behavior of other apps, or the device in general. Most of the time these actions will require your app to make a permissions request.</p><p>To declare a permission, open your project's <code class="literal">Manifest</code> and add a <code class="literal">&lt;uses-permission&gt;</code> element as a child of the top-level <code class="literal">&lt;manifest&gt;</code> element:</p><pre class="programlisting">&lt;manifest     &#13;
  &#13;
 package="com.me.app.myapp" &gt; &#13;
 &#13;
&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/&gt; &#13;
       android:label="@string/permlab_fineLocation" &#13;
 &#13;
//Provide a label for each permission your app requests, using android:label. This label is displayed to the user when they're viewing a list of permissions. Try to keep this label short - a few words will usually be sufficient//   &#13;
 &#13;
       android:description="@string/permdesc_fineLocation" &#13;
 &#13;
//Describe what granting this permission request will allow your app to do, using the android:description attribute. Ideally, your descriptions will be two sentences long - the first should describe the permission that's being requested, and the second should warn the user about the dangers of granting this particular permission//   &#13;
 &#13;
       android:protectionLevel="dangerous" /&gt; &#13;
 &#13;
//Indicates the potential risk associated with this permission. The possible values are normal, dangerous, signature, and SignatureOrSystem//   &#13;
   ... &#13;
&lt;/manifest&gt; &#13;
</pre><p>Here's how the string resources for this permission's label and description might look:</p><pre class="programlisting"> &lt;string name="permlab_fineLocation"&gt;Precise location (GPS and network-based)&lt;/string&gt; &#13;
 &#13;
   &lt;string name="permdesc_fineLocation"&gt; &#13;
This app will be able to retrieve your precise location using the GPS or network location sources. Apps may consume additional battery power while using location services&lt;/string&gt; &#13;
</pre><div><div><div><div><h3 class="title"><a id="ch10lvl3sec86"/>Verifying permissions</h3></div></div></div><p>Your app won't always need to ask for permission to access protected information or features—if your app currently has access to the microphone, then it won't need to request this permission, for example. However, since users running Android 6.0 and higher can revoke previously granted permissions at any time, your app will need to check whether it currently has access to protected information or features, every time it needs to act on the related permission. Even if the user granted this permission previously, in Android 6.0 and higher there's no guarantee the user hasn't manually revoked that permission at some point.</p><p>To determine whether your app currently has permission to access information or features, you need to call the <code class="literal">ContextCompat.checkSelfPermission()</code>method. For example, this code snippet shows you how to check whether your app has permission to access the Internet:</p><pre class="programlisting">int permissionCheck = ContextCompat.checkSelfPermission(this,                Manifest.permission.INTERNET); &#13;
</pre><div><div><h3 class="title"><a id="note110"/>Note</h3><p>
<code class="literal">ContextCompat.checkSelfPermission()</code> is available as part of revision 23 of the <code class="literal">support-v4 library </code>for backwards compatibility (<a class="ulink" href="http://developer.android.com/tools/support-library/features.html?utm_campaign=runtime-permissions-827&amp;utm_source=dac&amp;utm_medium=blog#v4">http://developer.android.com/tools/support-library/features.html?utm_campaign=runtime-permissions-827&amp;utm_source=dac&amp;utm_medium=blog#v4</a>).</p></div></div><p>If your app currently has access to the requested permission, <code class="literal">ContextCompat.checkSelfPermission</code> will return <code class="literal">PackageManager.PERMISSION_GRANTED</code> and your app can proceed with the operation. If the user hasn't granted your app this permission, or they granted the permission but then revoked it at some point, this method returns <code class="literal">PackageManager.PERMISSION_DENIED</code> and you'll need to request that permission by calling one of the <code class="literal">requestPermission</code> methods:</p><pre class="programlisting">if (ContextCompat.checkSelfPermission(myActivity, &#13;
               Manifest.permission.INTERNET) &#13;
 &#13;
//Does this app have permission to access the Internet?//  &#13;
 &#13;
       != PackageManager.PERMISSION_GRANTED) { &#13;
      if (ActivityCompat.shouldShowRequestPermissionRationale(myActivity, &#13;
           Manifest.permission.INTERNET)) { &#13;
 &#13;
//If shouldShowRequestPermissionRationale returns true, the app doesn't currently have this permission, and you'll need to request access//  &#13;
           .......... &#13;
      .......... &#13;
  &#13;
   } else { &#13;
 &#13;
         ActivityCompat.requestPermissions(myActivity, &#13;
 &#13;
//Request the permission. Note, when your app calls requestPermissions(),the system displays a standard dialogue that you cannot customize. If you want to provide some additional information, such as an explanation about why your app needs this permission, you must do so before calling requestPermissions()// &#13;
 &#13;
               new String[]{Manifest.permission.INTERNET}, &#13;
               MY_PERMISSIONS_REQUEST_INTERNET); &#13;
    &#13;
   } &#13;
} &#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec87"/>Handling the permissions request response</h3></div></div></div><p>When your app makes a permission request, the system presents a dialogue to the user. When the user responds, the system invokes your app's <code class="literal">onRequestPermissionsResult()</code> method and passes it the user's response. To find out whether the user has granted or denied the permission request, your app needs to override that method:</p><pre class="programlisting">@Override &#13;
public void onRequestPermissionsResult(int requestCode, &#13;
       String permissions[], int[] grantResults) { &#13;
//The Activity's onRequestPermissionsResult method is called and passes the user's response//  &#13;
   switch (requestCode) { &#13;
       case MY_PERMISSIONS_REQUEST_INTERNET: { &#13;
                    if (grantResults[0] == PackageManager.PERMISSION_GRANTED) { &#13;
........ &#13;
......... &#13;
// If the user has granted the permission, this is where you'd perform your app's Internet-related tasks//  &#13;
 &#13;
           } else { &#13;
.......   &#13;
....... &#13;
// The user has denied the permission request. This is where you'd disable the functionality that depends on Internet access. Since denying a permission may prevent parts of your app from working correctly, you may also want to provide some feedback explaining what impact denying this permission will have on your app's functionality//   &#13;
 &#13;
           } &#13;
           return; &#13;
       } &#13;
 &#13;
  &#13;
   } &#13;
} &#13;
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec131"/>Permissions and &lt;uses-feature&gt;</h2></div></div></div><p>It's possible that your app may rely on certain hardware or software features being present on the user's device, for example your typical camera app will almost certainly require a device with camera hardware.</p><p>To prevent users from installing your app on devices that don't have the hardware or software necessary to support it, you need to add the <code class="literal">&lt;uses-feature</code>&gt; declaration to your project's <code class="literal">Manifest</code>:</p><pre class="programlisting">&lt;uses-feature android:name="android.hardware.camera" /&gt; &#13;
</pre><p>You then specify whether your app requires this feature to function at all (<code class="literal">true</code>) or whether it prefers to have this feature but can function without it if necessary (<code class="literal">false</code>):</p><pre class="programlisting">&lt;uses-feature android:name="android.hardware.camera" &#13;
             android:required="true"/&gt; &#13;
</pre><p>Although the Android system won't check your app's <code class="literal">Manifest</code> for <code class="literal">&lt;uses-feature&gt;</code> elements, Google Play does use your app's <code class="literal">&lt;uses-feature&gt;</code> elements to decide whether your app is compatible with the user's device. Google Play won't allow any user to install an app that it deems incompatible with their device's hardware or software.</p><div><div><h3 class="title"><a id="note111"/>Note</h3><p>If you add <code class="literal">&lt;uses-feature&gt; </code>elements to your <code class="literal">Manifest</code> but don't include the <code class="literal">android:required</code> attribute, Google Play assumes that your app requires this feature (<code class="literal">android:required="true"</code>).</p></div></div><p>Ideally, you should declare all your project's hardware and software requirements, but there are a few safeguards in place just in case you forget to mention one or more <code class="literal">&lt;uses-feature&gt;</code> elements.</p><p>Google Play checks your app's <em>regular</em> permissions for any implicit hardware-related features. If it finds any, it adds the corresponding hardware or software feature to your app's metadata, and then takes these into account when deciding whether each potential user can or cannot install your app.</p><p>This does help to prevent users from downloading incompatible apps, but it can also be a bit of a nuisance. Imagine your app requests <code class="literal">android.permission.CAMERA</code> but you didn't include <code class="literal">&lt;uses-feature android:name="android.hardware.camera"&gt;</code> in your <code class="literal">Manifest.</code> In this scenario, Google Play will assume that your app requires camera hardware to function, and consequently won't allow anyone to install your app on a device that doesn't have a camera. If your app doesn't actually require a camera, this misunderstanding could prevent people with perfectly compatible devices from installing your app.</p><p>To prevent this misunderstanding, you need to open your project's <code class="literal">Manifest</code> and specify that a camera is preferred, but not essential:</p><pre class="programlisting">&lt;uses-feature android:name="android.hardware.camera" android:required="false" /&gt; &#13;
</pre><p>For a full list of all the permissions that imply feature requirements, check out the official Android docs (
<a class="ulink" href="http://developer.android.com/guide/topics/manifest/uses-feature-element.html#permissions">http://developer.android.com/guide/topics/manifest/uses-feature-element.html#permissions</a>
).</p><div><div><h3 class="title"><a id="note112"/>Note</h3><p>Declaring a <code class="literal">&lt;uses-feature&gt;</code> doesn't automatically grant your app permission to access the related features or information. You'll <em>still</em> need to request every permission your app requires, as normal.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec132"/>Best practices for app permissions</h2></div></div></div><p>Despite everything this new runtime permissions model has to offer, it does present developers with a few new challenges. Firstly, since your app can request permissions at any time, issuing your permission requests at exactly the right time is now an important part of the user experience.</p><p>Secondly, since the user can now deny individual permissions, you'll need to ensure that your app continues to provide a good experience regardless of whether the user chooses to deny one or more of your application's permission requests.</p><div><div><h3 class="title"><a id="note113"/>Note</h3><p>This doesn't mean that your app has to function even if the user consistently denies its requests. It's possible that denying a certain permission may render your app completely unable to perform its core functionality. However, even if this is the case, you can still provide a good user experience by letting the user know <em>why</em> your app has suddenly stopped working. For example, whenever the user tries to launch your app, you might display a dialogue box listing all the missing permissions that your app requires in order to function, and then giving the user an easy way of granting these permissions.</p></div></div><p>In this section, we're going to look at all the best practices surrounding permissions, so you can make more informed decisions about which permissions your app requests, in addition to <em>when</em> and <em>where</em> it issues those requests.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec88"/>Making as few permission requests as possible</h3></div></div></div><p>This is the golden rule of permission requests.</p><p>Permissions are designed to protect the user and the device, so your app should <em>only</em> request permissions that it requires to function. Research (<a class="ulink" href="http://repository.cmu.edu/hcii/268">http://repository.cmu.edu/hcii/268</a>) suggests that the amount and type of permissions an app requests directly affects user behavior. When confronted with two apps that have similar functionality, users are more likely to opt for the one that requires fewer permissions.</p><p>If you're going to reach the widest possible audience, you need to limit the number of permissions your app requires. This is particularly important under the new permissions model, as requests are made as the user is interacting with your app. Imagine you've got lost on your way to an important meeting—you open up the map application you downloaded the night before, only to be confronted with permission requests every time you try to interact with the app. Not what you want when you're in a rush! It's incredibly easy to overwhelm a busy, multi-tasking mobile user with too much information.</p><p>If in doubt, remember that it's easier to add permissions to your app later via updates, than it is to remove them—so it's better to play it safe with a less-is-more approach.</p><div><div><h3 class="title"><a id="tip114"/>Tip</h3><p>
<strong>Automatic permission adjustments</strong></p><p>New releases of the Android platform may bring new restrictions, which can result in your app needing to request permissions that it didn't previously require. To make sure your app continues to work for users who are running the latest and greatest version of Android, the system may step in and automatically add these new permission requests to your project's <code class="literal">Manifest</code>.</p><p>When deciding whether to automatically add permissions to your app, Android takes a look at your app's <code class="literal">targetSdkVersion</code>. If the value is lower than the version where the new permissions were added, the system may add these permissions automatically. This can result in your app requesting permissions that it doesn't necessarily need—definitely not a good thing!</p><p>To avoid this, make it a priority to test your project against new releases of the Android platform, and then update your <code class="literal">targetSdkVersion</code> as soon as you're confident that your app is compatible with this latest release.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec89"/>Requesting critical permissions up front</h3></div></div></div><p>If your app's core functionality hinges on having access to certain permissions, you should request these critical permissions up front. This is because users are more likely to take the time to read and therefore <em>grant </em>permission dialogues the first time they launch your app, rather than grant permission requests that interrupt them when they're midway through performing an important task in your app.</p><p>For non-critical permissions, you should wait until the user tries to access a related feature and then request that permission in context.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec90"/>Providing extra information where necessary</h3></div></div></div><p>Ideally, your permission requests should be self-explanatory, <em>especially</em> on devices running Android 6.0 or higher, where apps request permissions in context. For example, if a user taps your app's <strong>Take a photo for your profile picture</strong> button, chances are they aren't going to be confused when your app requests access to their camera.</p><p>However, if you suspect that it may not be immediately obvious why your app is requesting a certain permission, then you'll want to provide the user with some more information. Your users are always going to feel more comfortable when they understand why an app is requesting access to information or features. If you <em>don't</em> provide this information, then your users may suspect that you're leaving them in the dark on purpose.</p><p>Just be wary of explaining <em>everything</em>. You shouldn't need to provide an explanation for every permission your app requests. If you overwhelm the user with too much information, they're going to get frustrated by the constant interruptions, and may end up either skim-reading your explanations (bad) or skipping them completely (worse).</p><p>If you find yourself providing an explanation <em>every time</em> your app makes a permission request, this may be an indication of a deeper problem with how your app is handling sensitive data or using device features. Maybe your app is requesting too many permissions? Or maybe it's requesting miscellaneous permissions that are unrelated to its core functionality?</p><p>Remember that permission request dialogues aren't the only way of communicating with your users. You may want to consider other ways of giving the user the information they need to better understand the context of your app's permission requests. For example, you could:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Add this information to your app's Google Play description.</li><li class="listitem" style="list-style-type: disc">Create a privacy policy outlining the information your app needs access to and how it uses this information.</li><li class="listitem" style="list-style-type: disc">Create support documentation that your users can turn to if they need more information, such as an online user manual or a <strong>Help</strong> section inside your app.</li><li class="listitem" style="list-style-type: disc">Update your UI so permission requests are more self-explanatory. Your users may be confused if they tap a stock avatar and your app suddenly requests access to their camera, however if the stock photo has a <strong>Tap here to take a profile picture</strong> label, then your users are <em>far </em>less likely to be confused.</li><li class="listitem" style="list-style-type: disc">Create dedicated support channels for your users such as forums, social media pages, or an e-mail address where they can reach out to you with any questions.</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec91"/>Paying attention to permissions required by libraries</h3></div></div></div><p>When you include a library in your project, your project inherits any permissions that library requests. Before you use <em>any</em> library, always check what permissions that library requires, and what it uses those permissions for.</p><p>Adding multiple libraries to your project without checking their permissions first can quickly land you in hot water with your users, as from the user's perspective it's your app that's making these requests, and not an external library. These libraries may even request permissions that seem completely unrelated to your app, potentially making your users even more suspicious.</p><p>If you need to include a library in your project but are concerned that it requires too many permissions, then you can always look for an alternative library that provides similar functionality but doesn't make quite so many permission requests.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec92"/>Being transparent about accessing the camera and microphone</h3></div></div></div><p>Sometimes your app may need to access particularly sensitive features, such as the device's camera or microphone. Most of the time your app won't require <em>constant </em>access to these features, but once the user has granted your app access, how do they know that it isn't constantly pulling information from their microphone and camera?</p><p>No one likes to feel they're being watched, so you should be up front about when your app is accessing the device's camera or microphone. For example, you could display a pop-up with a timer indicating that your app is going to turn the device's camera on in 3, 2, 1, or you could display a flashing microphone icon in the corner of the screen whenever your app is <em>listening</em> to the user.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec93"/>Considering alternatives</h3></div></div></div><p>Even if your app does require access to protected information or features, you may be able to engineer your app so it doesn't have to make these requests itself.</p><p>An app only needs to request permissions for actions that it performs directly - <em>not</em> when it's asking other apps to perform a task on its behalf, or supply it with information. For example, instead of requesting access to the device's camera, you could use <code class="literal">MediaStore.ACTION_IMAGE_CAPTURE</code> to launch a camera app that the user has already installed on their device. You can also use system intents to request information from other apps, such as requesting contact information from the user's Contacts app, rather than issuing the <code class="literal">READ_CONTACTS</code> permission.</p><p>The major downside to this approach is that it presents the user with a dialogue every time your app needs to access the protected information or feature, so consider whether the frequency or timing of these requests is likely to irritate your users.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec64"/>Notifications</h1></div></div></div><p>Notifications underwent a massive overhaul in Android Lollipop, getting both a Material Design makeover <em>and</em> new methods that help Android sort notifications more intelligently.</p><p>In Android 5.0 and higher, you can annotate your notifications with the <code class="literal">setPriority()</code> method. Low-priority notifications may be hidden from the user, while higher-priority notifications are more likely to interrupt whatever the user is currently doing.</p><p>The different priority levels are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Notification.PRIORITY_MAX</code>: Used for critical and urgent notifications that alert the user to a condition that's time-sensitive, or that they may need to resolve before they can continue with the current task.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Notification.PRIORITY_HIGH</code>: Typically used for important communications such as chat messages. High-priority notifications appear in a floating <em>heads-up</em> window that contains action buttons. Action buttons allow the user to act on, or dismiss, the heads-up notification without having to navigate away from the current screen.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Notification.PRIORITY_LOW</code>: Used for less urgent notifications.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Notification.PRIORITY_MIN</code>: Used for contextual or background information. Minimum-priority notifications aren't usually shown to the user except under special circumstances, such as detailed notification logs.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Notification.PRIORITY_DEFAULT</code>: You can use this priority flag for all notifications that don't fall into any of the more specific priority categories.</li></ul></div><p>Many Android devices feature a notification LED that you can use to inform users about events that are happening inside your app, even when the screen is off. Assigning your app's notifications a priority level of <code class="literal">MAX</code>, <code class="literal">HIGH</code>, or <code class="literal">DEFAULT</code> should cause the LED to glow.</p><p>In Android 5.0 and higher, notifications also appear on the device's lockscreen, which means you need to consider whether your notifications contain information that users might not want to appear on their lockscreen for the whole world to see.</p><p>You can use <code class="literal">setVisibility()</code> to tell Android how much information it should display on the lockscreen, and assign it one of the following values:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">VISIBILITY_SECRET</code>: No part of the notification appears on the lockscreen. This is recommended if your app's notifications contain personal or potentially embarrassing information.</li><li class="listitem" style="list-style-type: disc"><code class="literal">VISIBILITY_PRIVATE</code>: The notification displays some basic information on the lockscreen, but most of the information is hidden.</li><li class="listitem" style="list-style-type: disc"><code class="literal">VISIBILITY_PUBLIC</code>: The notification appears on the lockscreen in its entirety.</li></ul></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec133"/>Notification best practices</h2></div></div></div><p>Design your notifications well, and they'll provide real value to your users—plus, they'll serve as a handy way of enticing users back to your app, by presenting them with interesting and timely updates about events that are happening inside your application.</p><p>To make the most out of Android's notification system, you should keep the following best practices in mind.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec94"/>Providing the right content</h3></div></div></div><p>At the very least, your notifications should contain:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A title (<code class="literal">setContentTitle</code>) and secondary text (<code class="literal">setContentText</code>)</li><li class="listitem" style="list-style-type: disc">A timestamp; note this indicates when the event occurred and <em>not </em>when the notification was posted</li><li class="listitem" style="list-style-type: disc">The notification type (optional)</li></ul></div><p>To make sure the user can recognize your app's pending notifications in the system bar, you should include a distinct app icon (<code class="literal">setSmallIcon</code>).</p><p>Your notification icon should be simple and avoid any excessive detail, but at the same time it must be eye-catching and distinct from the other notification icons users may encounter. You should use the Material Light action bar icon style and avoid opaque backgrounds—basically, your notification icon should be a white-on-transparent background image.</p><p>If you're struggling for inspiration, try booting up your Android device and taking a look at the kind of notification icons other applications are using.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec95"/>Using notifications sparingly</h3></div></div></div><p>Every time you issue a notification, you're interrupting whatever the user is doing at that moment, so it's important you use notifications sparingly.</p><p>You should <em>never</em> use notifications to alert the user about background operations that don't require their input or that aren't time-sensitive. You also shouldn't use notifications to alert the user about events that are already happening on screen. Instead, inform the user about these events in context via your app's UI. For example, if the user has unlocked a new level in your gaming app, and that app is currently on screen, you should alert them via an on screen message rather than firing off a notification.</p><p>Even though notifications can be useful for reminding the user about your application, you should <em>never</em> use unnecessary notifications to tempt the user into launching your app. In the long run, unimportant or unwanted notifications are only going to make users view your app as an attention-seeker, which may even lead to them uninstalling your app and leaving you a negative review on Google Play.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec96"/>Giving users a choice</h3></div></div></div><p>Ideally, you should give your users the option to change your app's notifications settings, such as switching between sound alerts and vibration alerts, or even allowing users to disable notifications entirely.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec97"/>Categorising notifications</h3></div></div></div><p>When ranking and filtering notifications, the Android system may take an app's category into consideration, so you should assign a suitable category to each of your app's notifications. To do this, use the <code class="literal">setCategory()</code> option and choose from the following supported categories:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">CATEGORY_ALARM</code>: Alarm or timer</li><li class="listitem" style="list-style-type: disc"><code class="literal">CATEGORY_CALL</code>: An incoming voice or video call</li><li class="listitem" style="list-style-type: disc"><code class="literal">CATEGORY_EMAIL</code>: Asynchronous bulk message</li><li class="listitem" style="list-style-type: disc"><code class="literal">CATEGORY_ERROR</code>: An error in a background operation</li><li class="listitem" style="list-style-type: disc"><code class="literal">CATEGORY_EVENT</code>: Calendar event</li><li class="listitem" style="list-style-type: disc"><code class="literal">CATEGORY_MESSAGE</code>: Incoming direct message, such as an SMS</li><li class="listitem" style="list-style-type: disc"><code class="literal">CATEGORY_PROGRESS</code>: The progress of an operation running in the background</li><li class="listitem" style="list-style-type: disc"><code class="literal">CATEGORY_PROMO</code>: A promotion or advert</li><li class="listitem" style="list-style-type: disc"><code class="literal">CATEGORY_RECOMMENDATION</code>: A specific, timely recommendation</li><li class="listitem" style="list-style-type: disc"><code class="literal">CATEGORY_SERVICE</code>: An indication of a service that's running in the background</li><li class="listitem" style="list-style-type: disc"><code class="literal">CATEGORY_SOCIAL</code>: A social network or sharing update</li><li class="listitem" style="list-style-type: disc"><code class="literal">CATEGORY_STATUS</code>: Ongoing information about device or contextual status</li><li class="listitem" style="list-style-type: disc"><code class="literal">CATEGORY_SYSTEM</code>: This category is reserved for system or device status updates</li><li class="listitem" style="list-style-type: disc"><code class="literal">CATEGORY_TRANSPORT</code>: Media transport control for playback</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec98"/>Making use of actions</h3></div></div></div><p>You can also add action buttons to your notifications. Action buttons allow users to perform common tasks from the notification UI, without them having to open the originating app.</p><p>You add a button to your notification using the following syntax:</p><pre class="programlisting">NotificationCompat.Builder nBuilder = new NotificationCompat.Builder(context) &#13;
       .setContentTitle("This is a notification title")  &#13;
 &#13;
//Sets the notification's title// &#13;
 &#13;
      .setContentText("This is the notification's body text.")  &#13;
 &#13;
//Sets the second line of the notification's text// &#13;
 &#13;
            .addAction(R.drawable.accept, "Download", pIntent) &#13;
 &#13;
//Adds a 'Download' action to this notification, complete with icon// &#13;
 &#13;
      .addAction(R.drawable.cancel, "Cancel", pIntent); &#13;
 &#13;
//Adds a 'Cancel' button, complete with icon - this time the R.drawable.cancel icon//  &#13;
</pre><div><div><h3 class="title"><a id="tip115"/>Tip</h3><p>Each action should have its own icon and its own name.</p></div></div><p>Although optional, it's generally a good idea to add at least one action to each of your app's notifications. Just don't get carried away—limit yourself to a maximum of three actions per notification.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec99"/>Using expanded layouts</h3></div></div></div><p>For users running Android 4.1 and higher, you can supply two different visual styles for each of your app's notifications:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Normal view</strong>: This is the default, compact layout.</li><li class="listitem" style="list-style-type: disc"><strong>Big view style</strong>: A separate layout that appears when the user expands your notification by pinching or dragging it open.</li></ul></div><p>You have a choice of three different big view styles.</p><div><div><div><div><h4 class="title"><a id="ch10lvl4sec25"/>Big text style</h4></div></div></div><p>This layout provides additional text that's displayed in the detail area of the expanded notification, in place of the notification's regular <code class="literal">setContentText</code>:</p><pre class="programlisting">.setStyle(new NotificationCompat.BigTextStyle() &#13;
               .bigText("This text replaces the context text in the big view")) &#13;
</pre></div><div><div><div><div><h4 class="title"><a id="ch10lvl4sec26"/>Big picture style</h4></div></div></div><p>This layout includes a large image attachment:</p><pre class="programlisting">.setStyle(new Notification.BigPictureStyle() &#13;
        .bigPicture(aBigImage)) &#13;
</pre></div><div><div><div><div><h4 class="title"><a id="ch10lvl4sec27"/>Inbox style</h4></div></div></div><p>This layout includes a list of up to five items:</p><pre class="programlisting">.setStyle(new Notification.InboxStyle() &#13;
        .addLine(string1) &#13;
        .addLine(string2) &#13;
        .addLine(string3) &#13;
        .setSummaryText("+2 more")) &#13;
</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec134"/>Direct reply notifications</h2></div></div></div><p>Google are adding a few new features to notifications in the upcoming release of Android <em>N</em>, including an <strong>inline reply</strong> action button that allows users to reply directly from the notification UI.</p><p>Direct reply notifications are particularly big news for messaging apps, as they give users the ability to reply without even having to launch the messaging app. You may have already encountered direct reply notifications in Google Hangouts.</p><p>To create a notification action that supports direct reply, you need to create an instance of <code class="literal">RemoteInput.Builder</code> and then add it to your notification action.</p><p>The following code adds a <code class="literal">RemoteInput</code> to a <code class="literal">Notification.Action</code>, and creates a <strong>Quick Reply</strong> key. When the user triggers the action, the notification prompts the user to input their response:</p><pre class="programlisting">private static final String KEY_QUICK_REPLY = "key_quick_reply"; &#13;
String replyLabel = getResources().getString(R.string.reply_label); &#13;
RemoteInput remoteInput = new RemoteInput.Builder(KEY_QUICK_REPLY) &#13;
       .setLabel(replyLabel) &#13;
       .build(); &#13;
</pre><p>To retrieve the user's input from the notification interface, you need to call <code class="literal">getResultsFromIntent(Intent)</code> and pass the notification action's intent as the input parameter:</p><pre class="programlisting">   Bundle remoteInput =&#13;
 RemoteInput.getResultsFromIntent(intent); &#13;
 &#13;
//This method returns a Bundle that contains the text response// &#13;
 &#13;
   if (remoteInput != null) { &#13;
           return remoteInput.getCharSequence(KEY_QUICK_REPLY); &#13;
 &#13;
//Query the bundle using the result key, which is provided to the RemoteInput.Builder constructor// &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec135"/>Bundled notifications</h2></div></div></div><p>Don't you just hate it when you connect to the Internet first thing in the morning and your Gmail app instantly bombards you with a <strong>4 new messages</strong> notification, but doesn't give you any more information about those individual e-mails? Not particularly helpful!</p><p>When you receive a notification that consists of multiple items, the only thing you can really do is open the app and take a look at the individual events that make up this grouped notification.</p><p>However, the upcoming release of Android N promises to fix this problem by introducing <strong>bundled notifications</strong>. This new notification style allows you to group multiple notifications from the same app into a single, bundled notification. A bundled notification consists of a parent notification that displays summary information for that group, plus individual notification items.</p><p>If the user wants to see more information about these individual items, they can <em>unfurl</em> the bundled notification card into separate, smaller notifications by swiping down with two fingers. When the user expands a bundled notification, the system reveals more information about each child notification. The user can then act on each of these mini-notifications individually, for example they might choose to dismiss the first three notifications about spam e-mails, but open the fourth e-mail. This is similar to the Notification Stacks feature you may have encountered in Android Wear.</p><div><div><h3 class="title"><a id="note116"/>Note</h3><p>Bundled notifications are particularly useful when your app has the potential to generate multiple notifications where each child notification is actionable.</p></div></div><p>To group notifications, call <code class="literal">setGroup()</code> for each notification you want to add to the same notification stack, and then assign these notifications the same key:</p><pre class="programlisting">final static String GROUP_KEY_MESSAGES = "group_key_messages"; &#13;
Notification notif = new NotificationCompat.Builder(mContext) &#13;
        .setContentTitle("New SMS from " + sender1) &#13;
        .setContentText(subject1) &#13;
        .setSmallIcon(R.drawable.new_message) &#13;
        .setGroup(GROUP_KEY_MESSAGES) &#13;
        .build(); &#13;
</pre><p>When you create another notification that belongs to this stack, you just need to assign it the same group key:</p><pre class="programlisting">Notification notif2 = new NotificationCompat.Builder(mContext) &#13;
   .setContentTitle("New SMS from " + sender1) &#13;
    .setContentText(subject2) &#13;
     .setGroup(GROUP_KEY_MESSAGES) &#13;
  .build(); &#13;
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec65"/>Application widgets</h1></div></div></div><p>Widgets provide users with a small, convenient sample of your application's most important data, typically from the comfort of their home screen.</p><p>To create a basic app widget, you need to complete the process described in the following sections.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec136"/>Declaring an AppWidgetProvider class in your project's Manifest</h2></div></div></div><p>The <code class="literal">AppWidgetProvider</code> class defines the methods that allow you to programmatically interact with your app widget based on broadcast events.</p><p>Here's an example of a basic <code class="literal">AppWidgetProvider</code> implementation:</p><pre class="programlisting">&lt;receiver android:name="MyAppWidgetProvider" &gt; &#13;
 &#13;
//Specifies the AppWidgetProvider that's used by this widget// &#13;
 &#13;
   &lt;intent-filter&gt; &#13;
 &#13;
       &lt;action android:name="android.appwidget.action.APPWIDGET_UPDATE" /&gt; &#13;
 &#13;
//The &lt;action&gt; element specifies that this AppWidgetProvider accepts the ACTION_APPWIDGET_UPDATE. This is the only broadcast event you need to declare explicitly, as the AppWidgetManager class forwards all other app widget broadcasts to the AppWidgetProvider automatically// &#13;
 &#13;
   &lt;/intent-filter&gt; &#13;
 &#13;
   &lt;meta-data android:name="android.appwidget.provider" &#13;
 &#13;
//Specifies the AppWidgetProviderInfo resource, which in this example is   &#13;
android.appwidget.provider// &#13;
 &#13;
              android:resource="@xml/my_appwidget_info" /&gt; &#13;
 &#13;
//The &lt;meta-data&gt; element also requires an android:resource attribute, which specifies the location of the AppWidgetProviderInfo resource// &#13;
 &#13;
&lt;/receiver&gt; &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec137"/>Creating an AppWidgetProviderInfo file</h2></div></div></div><p>The next step is defining the basic qualities of your widget, such as its minimum width and height, and how often it's updated. Create a <code class="literal">res/xml </code>directory, if your project doesn't already contain one, and then create a new XML layout file. In this example, we're using <code class="literal">my_appwidget_info.xml</code>:</p><pre class="programlisting">&lt;appwidget-provider  &#13;
 &#13;
   android:minWidth="50dp" &#13;
 &#13;
   android:minHeight="50dp" &#13;
 &#13;
//Specifies the minimum height and width the widget consumes by default// &#13;
 &#13;
   android:updatePeriodMillis="80000000" &#13;
 &#13;
//This is how often the app widget framework requests an update from the AppWidgetProvider. By default, if the device is asleep when the widget requests an update, the device will wake up in order to perform this operation. For the sake of the user's battery, don't set this value too low//  &#13;
 &#13;
   android:initialLayout="@layout/my_appwidget" &#13;
 &#13;
//The layout resource where you'll define the widget's layout// &#13;
 &#13;
   android:resizeMode="horizontal" &#13;
 &#13;
//Specifies how the widget can be resized. The possible values are horizontal, vertical, and none. You can also combine these values, for example android:resizeMode="horizontal|vertical"// &#13;
 &#13;
   android:widgetCategory="home_screen"&gt; &#13;
 &#13;
//Declares whether your widget can be displayed on the home screen (home_screen), the lockscreen (keyguard) or both. Only devices running lower than Android 5.0 support lockscreen widgets//  &#13;
 &#13;
&lt;/appwidget-provider&gt; &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec138"/>Creating the widget's layout</h2></div></div></div><p>You define your widget's layout in XML in the same way you create a regular layout resource file. The only major difference is that app widget layouts are based on <code class="literal">RemoteViews</code>, which don't support every layout and view.</p><p>As a result, app widgets support the following layout classes only:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">FrameLayout</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">GridLayout</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">LinearLayout</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">RelativeLayout</code></li></ul></div><p>They also only support the following widget classes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">AdapterViewFlipper</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">AnalogClock</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Button</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Chronometer</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">GridView</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ImageButton</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ImageView</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ListView</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ProgressBar</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">StackView</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">TextView</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ViewFlipper</code></li></ul></div><div><div><h3 class="title"><a id="note117"/>Note</h3><p>
<code class="literal">RemoteViews</code> also support <code class="literal">ViewStubs</code>.</p></div></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec100"/>App widget best practices</h3></div></div></div><p>Well-designed app widgets that display useful information serve as a constant reminder about how great your app is, tempting the user to launch your application—or at the very least, making them less likely to uninstall your app.</p><p>To make sure your widget presents your application in the best possible light, make sure you adhere to the following best practices.</p><div><div><div><div><h4 class="title"><a id="ch10lvl4sec28"/>Including margins for earlier versions of Android</h4></div></div></div><p>Your widgets shouldn't extend to the edges of the screen or bump up against other widgets, as this can make the user's home screen look messy and cluttered. The solution is to add a margin around each edge of your widgets, something that Android 4.0 and higher does automatically whenever the user places a widget on their home screen. To take advantage of this behavior, you just need to set your app's <code class="literal">targetSdkVersion</code> to <code class="literal">14</code> or greater.</p><p>Since Android 4.0 and greater applies margins to your app automatically, you shouldn't add any extra margins to your widget when it's installed on devices running Android 4.0 and over. However you <em>will</em> still need to add margins when your app is installed on devices running earlier versions of Android.</p><p>The solution is to create two <code class="literal">dimens.xml</code> files that specify different margins for different versions of Android:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">res/values-v14/dimens.xml</code>: This file defines the 0dp margins for devices running Android 4.0 and greater:</li></ul></div><pre class="programlisting">        &lt;dimen name="widget_margins"&gt;0dp&lt;/dimen&gt;</pre><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">res/values/dimens.xml</code>: This file defines the margins for devices running versions of Android lower than 4.0:</li></ul></div><pre class="programlisting">        &lt;dimen name="widget_margins"&gt;10dp&lt;/dimen&gt; &#13;
</pre><p>You can then reference these <code class="literal">dimens.xml</code> values in your widget's layout resource file, and the Android system will select the appropriate <code class="literal">widget_margins</code> value at runtime:</p><pre class="programlisting">android:padding="@dimen/widget_margins" &#13;
</pre></div><div><div><div><div><h4 class="title"><a id="ch10lvl4sec29"/>Providing flexible graphics and layouts</h4></div></div></div><p>The Android home screen is divided into a grid. The user can place app widgets inside free cells, and then stretch them horizontally and/or vertically to occupy a different number of cells.</p><p>To ensure your widget's layout is flexible enough to be able to adapt to different grid sizes, you should define your widget's background using stretchable nine-patch images, and then use flexible layouts such as <code class="literal">LinearLayout</code>, <code class="literal">RelativeLayout</code> or <code class="literal">FrameLayout</code>.</p></div><div><div><div><div><h4 class="title"><a id="ch10lvl4sec30"/>Not updating too often</h4></div></div></div><p>If the device is asleep when the app widget framework requests an update from the <code class="literal">AppWidgetProvider</code>, the device will wake up in order to perform this operation. Requesting too many updates is a surefire way to drain the user's battery and may result in them uninstalling your app, or at the very least banishing your app widget from their home screen.</p><p>It's important to consider how often your widget really needs to receive new information, for example you'll typically need to update a weather or news widget less often than a widget that alerts users about incoming e-mails.</p><p>If you're building a widget that <em>does </em>require frequent updates, then it's generally a good idea to perform these updates based on an alarm that won't wake the device. If this alarm goes off while the device is asleep, this update won't be performed until the next time the device wakes up, so it has less impact on the device's battery.</p><p>To create this kind of alarm, use the <code class="literal">AlarmManager </code>to set an alarm with an <code class="literal">Intent</code> that your <code class="literal">AppWidgetProvider</code> receives, and then set the alarm type to either <code class="literal">ELAPSED_REALTIME</code> or <code class="literal">RTC</code>, for example:</p><pre class="programlisting">alarmManager.setRepeating(AlarmManager.RTC... &#13;
</pre><p>Finally, set the widget's <code class="literal">updatePeriodMillis</code> to zero so it won't override your alarm and wake the device.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec66"/>Accessibility best practices</h1></div></div></div><p>Your app is only truly accessible when everyone can navigate it, understand it, and use it successfully, including people who may have visual, physical, or age-related limitations.</p><p>Android has several in built accessibility features that help you optimize your app for users with visual or physical disabilities, so the good news is that, in most cases, creating an accessible app won't require any extensive changes to your code.</p><p>In this section, I'll show you how to use these built-in platform features to make sure <em>everyone</em> can enjoy using your app.</p><div><div><h3 class="title"><a id="note118"/>Note</h3><p>If your app is part of a team effort, then it's important that everyone on your team keeps accessibility in mind. If you're working with a designer or a team of testers, then it's a good idea to make sure they're also familiar with the following accessibility guidelines.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec139"/>Adding descriptive text to your UI controls</h2></div></div></div><p>If you've designed your UI well, you shouldn't have to add an explicit label to every on screen element, for example a button with a telephone icon inside a <strong>Contacts</strong> app has a pretty obvious purpose. However, users with vision impairments may not be able to pick up on these visual clues, so you'll need to provide them with some additional information.</p><p>You should provide content descriptions for every UI component that doesn't feature visible text. Also consider whether these descriptions alone provide sufficient context for the user to fully understand the related visual elements—without any visual context, a <strong>Delete</strong> or <strong>Call the selected contact</strong> content description may not be particularly helpful.</p><p>The text in the description attribute <em>doesn't</em> appear on screen, but if the user enables speech-based accessibility services such as TalkBack, this description is read aloud when the user navigates to that item.</p><p>You can add a description using the <code class="literal">android:contentDescription</code> XML layout attribute:</p><pre class="programlisting">&lt;ImageButton &#13;
   android:id="@+id/newSMS" &#13;
   android:src="img/newSMS" &#13;
   android:contentDescription="@string/newSMS"/&gt; &#13;
</pre><p>Imagine that the value of <code class="literal">@string/newSMS</code> is <code class="literal">Create a new SMS message</code>. When the user hovers over this icon with an accessibility service enabled, this description will be read aloud and the user will then understand what this UI element does.</p><div><div><h3 class="title"><a id="note119"/>Note</h3><p>For <code class="literal">EditTexts,</code> your top priority should be helping the user to understand what content they're expected to enter into this empty field, so you should provide an <code class="literal">android:hint</code> attribute <em>instead</em> of a content description. Once the user has entered some text into the <code class="literal">EditText</code>, the accessibility service will read this text aloud, instead of the <code class="literal">android:hint</code> value.</p></div></div><p>There'll be situations where you want to base an item's content description on dynamic elements, such as the state of a slider or the currently selected text in a list. If this is the case, then you'll need to edit the content description at runtime using the <code class="literal">setContentDescription()</code> method.</p><p>Providing descriptions is particularly important for <code class="literal">ImageButton</code>, <code class="literal">ImageView</code>, and <code class="literal">Checkbox</code> components, but you should add content descriptions wherever you suspect that users with different abilities might benefit from some additional information. Just don't get carried away and add unnecessary descriptions, as this just increases the noise the user encounters as they're trying to decipher your UI, making it more difficult for them to pull useful information from their accessibility service.</p><p>Wherever possible, use Android's standard controls as they have <code class="literal">ContentDescriptions</code> built in by default, and therefore work automatically with accessibility services such as TalkBack.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec140"/>Designing for focus navigation</h2></div></div></div><p>Focus navigation is where your users employ directional controls to navigate the individual elements that make up your app's UI, similar to the four-way remote control navigation on a television. Users with limited vision or limited manual dexterity often use this mode of navigation instead of touchscreen navigation.</p><p>Directional controllers can be software-based or hardware-based, such as a trackball, D-pad, or external keyboard. Users may also choose to enable the gestures navigation mode available in devices running Android 4.1 and higher.</p><p>To make sure your users can successfully navigate your app using a directional controller, you need to verify that all your UI input controls can be reached and activated without using the touchscreen. You should also verify that clicking a directional controller's center, or <strong>OK</strong> button, has the same effect as touching a control that already has focus.</p><p>In order to support focus navigation, you should ensure that all your app's navigational elements are focusable. You can achieve this by adding the <code class="literal">android:focusable="true"</code> attribute to your UI elements, or perform this modification at runtime using the <code class="literal">View.setFocusable()</code> method on each UI control.</p><p>The UI controls provided by the Android framework are focusable by default, and the system visually indicates focus by changing the control's appearance.</p><p>When a user navigates in any direction using directional controls, focus is passed from one UI element to another, as determined by the focus order. The system determines the focus order automatically based on an algorithm that finds the nearest neighbor in a given direction.</p><p>However, sometimes the results may not be quite what you had in mind, or they may not provide the best experience for the user. If this is the case, Android provides four optional XML attributes that you can use to override this automatic focus order and dictate <em>exactly </em>which view will receive focus when the user navigates in that direction:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">android:nextFocusUp</code>: Defines the next view to receive focus when the user navigates up</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:nextFocusDown</code>: Defines the next view to receive focus when the user navigates down</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:nextFocusLeft</code>: Defines the next view to receive focus when the user navigates left</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:nextFocusRight</code>: Defines the next view to receive focus when the user navigates right</li></ul></div><p>The following example XML shows two focusable UI elements where the <code class="literal">android:nextFocusDown</code> and <code class="literal">android:nextFocusUp </code>attributes have been set explicitly. The <code class="literal">Button </code>is located to the right of the <code class="literal">TextView</code>, however thanks to the magic of <code class="literal">nextFocus</code> properties, the user can reach the <code class="literal">Button</code> element by pressing the down arrow when the focus is on <code class="literal">TextView</code>:</p><pre class="programlisting">   &lt;TextView android:id="@+id/text" &#13;
      android:text="Hello, world" &#13;
        android:focusable="true" &#13;
       android:nextFocusDown="@+id/Button" &#13;
       ... /&gt; &#13;
   &lt;Button android:id="@+id/button" &#13;
       android:focusable="true" &#13;
        &#13;
       android:nextFocusUp="@id/text" &#13;
       ... /&gt; &#13;
</pre><p>The easiest way to test your navigation is to run your app in the emulator and navigate around your UI using the emulator's arrow keys and <strong>OK</strong> button only. Check that the navigation works as expected in all directions, including when you're navigating in reverse.</p><div><div><h3 class="title"><a id="note120"/>Note</h3><p>You can also modify the focus order of UI components at runtime, using methods such as <code class="literal">setNextFocusDownId()</code> and <code class="literal">setNextFocusRightId().</code>
</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec141"/>Custom view controls</h2></div></div></div><p>If you build custom interface controls, make sure you implement accessibility interfaces for these custom views and provide content descriptions.</p><div><div><h3 class="title"><a id="note121"/>Note</h3><p>If you want your custom controls to be compatible with all versions of Android back to 1.6, you'll need to use the Support Library to implement the latest accessibility features.</p></div></div><p>When creating custom views, you need to make sure these views are successfully creating <code class="literal">AccessibilityEvents</code> whenever the user selects an item or changes focus, as accessibility events are an important part of providing accessibility features such as text-to-speech.</p><p>To generate <code class="literal">AccessibilityEvents</code>, call <code class="literal">sendAccessibilityEvent(int)</code> with a parameter representing the type of event that's occurred. You'll find a complete list of the event types Android currently supports in the <code class="literal">AccessibilityEvent </code>reference documentation (<a class="ulink" href="http://developer.android.com/reference/android/view/accessibility/AccessibilityEvent.html">http://developer.android.com/reference/android/view/accessibility/AccessibilityEvent.html</a>).</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec101"/>Providing alternatives to audio prompts</h3></div></div></div><p>To assist users who are hearing impaired, you should avoid including any audio-only feedback in your app. You should always accompany your app's audio feedback with a secondary feedback mechanism, such as closed captions, a transcript, on screen notifications, or another visual alternative.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec142"/>Testing various font sizes</h2></div></div></div><p>Android users can change the size of the font that appears across their device manually, from their device's <strong>Settings |</strong>
<strong> Accessibility </strong>screen. To make sure these size changes also affect the text within your app, define your app's text and associated containers in scaled pixels (<code class="literal">sp</code>).</p><p>Also, keep in mind that when users have large fonts enabled, your app's text may become larger than the space you originally allocated for it, so you'll need to check that your text and UI looks good and functions normally even when the user has large text enabled. In particular, make sure that your UI elements don't overlap and that all touchable elements remain reachable across various text sizes.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec143"/>Using recommended touch target sizes</h2></div></div></div><p>Make sure all your app's touch targets are at least 48 x 48dp, and ensure that the space between on screen elements is always at least 8dp. This helps to ensure your UI is easier to navigate for people with manual dexterity challenges, but also for children with developing motor skills.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec144"/>Providing alternatives to affordances that time out</h2></div></div></div><p>Some apps feature icons or controls that disappear after a certain amount of time, for example it's common for video playback controls to fade out once the user is a few seconds into the video.</p><p>This poses a problem for people who are using accessibility features such as TalkBack, as TalkBack waits until the user has focused on a control before it reads that control's description. If your UI has controls that fade out quickly, these controls may actually vanish before the user has a chance to focus on them—which means they never get read out, and therefore the user won't be aware of their existence.</p><p>For this reason, you shouldn't rely on timed-out controls for high-priority tasks or important functions. If your UI does feature timed-out controls, you may want to disable this functionality when accessibility services are enabled, so these timed-out controls no longer disappear.</p><p>To ensure users with visual impairments can read your text more easily, it's recommended that you use a contrast ratio of 4.5:1 between your app's background and text. As a general rule, the smaller your text, the more contrast you'll need to use.</p><p>Also bear in mind that some of your users may be colorblind, so you shouldn't use color signals as the only means of conveying important information. In addition to color, you can use elements such as patterns, shapes, size, textures, or text.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec67"/>Testing your application's accessibility features</h1></div></div></div><p>Testing is a crucial part of creating an accessible app, as it can uncover problems with user interaction that you might not otherwise have spotted.</p><p>Testing your app's accessibility features typically involves:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using your app with audible feedback enabled:<p>Audible accessibility services provide audio prompts that dictate the on screen content to your users as they move around your UI. The most effective way of testing the experience you're providing to users with visual impairments is to enable an audible accessibility service on your Android device and then interact with your app using sound alone.</p><p>For Android users, feedback is typically provided via the TalkBack accessibility service. TalkBack comes preinstalled on many Android devices (open your device's <strong>Settings </strong>and select <strong>Accessibility</strong>, followed by <strong>TalkBack</strong>) but you can also download TalkBack for free from Google Play.</p><p>Once you've enabled an audible accessibility service, spend some time navigating around your app using the spoken feedback only. Look for any opportunities to improve the experience for users who might be interacting with your app without sighted assistance.</p><p>You should also check that your app provides enough information for the user to understand and act on each on screen element using a service such as TalkBack, <em>without</em> overloading them with too much information. This can be a tricky balancing act—too much or too little information will make it equally difficult for the user to decipher your UI.</p></li><li class="listitem" style="list-style-type: disc">Navigating your app using directional controls only, instead of the touchscreen</li></ul></div><p>As part of accessibility testing, you should verify that your app is easy to navigate using directional controls only, meaning without using the touchscreen, and ensure that users can move focus between your app's UI elements in a way that makes sense.</p><p>If available, you can use a physical device with a D-pad or trackball, but if your device doesn't have these hardware features you can use a software-based directional controller instead, or use the Android emulator and its simulated keyboard controls. You may even want to use TalkBack gestures (<a class="ulink" href="https://support.google.com/accessibility/android/answer/6151827">https://support.google.com/accessibility/android/answer/6151827</a>), which allow users to navigate apps (and their device in general) using very specific gestures.</p></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec68"/>Summary</h1></div></div></div><p>In this final chapter, we covered some best practices that I hadn't explored in detail in previous chapters, including app security and accessibility best practices. You also learned how to create more useful notifications, and began to explore the new notification options coming up in Android N.</p><p>If you want to learn more about developing effective Android apps, you'll find lots of additional information in the Android docs (<a class="ulink" href="http://developer.android.com/training/index.html">http://developer.android.com/training/index.html</a>), at the Android blog (<a class="ulink" href="http://android-developers.blogspot.co.uk/">http://android-developers.blogspot.co.uk/</a>), or by checking out some of Google's code samples (<a class="ulink" href="http://developer.android.com/samples/index.html">http://developer.android.com/samples/index.html</a>).</p></div></body></html>