["```java\n    struct Vertex\n    {\n    public:\n       glm::vec3 position; //Store X/Y/Z coordinate.\n       glm::vec2 uv;       //Store Tex coordinate.\n       glm::vec3 normal;   //Store Normal information.\n       glm::vec3 tangent;  //Store Tangent information.\n       . . . . .\n    };\n    ```", "```java\n    struct FaceIndex\n    {\n        short vertexIndex; // Face's vertex Index\n        short normalIndex; // Face's normal Index\n        short uvIndex;     // Face's texCoord Index\n         . . . . .\n    };\n    ```", "```java\n    struct Mesh\n    {\n        // Obj File name\n        char fileName[MAX_FILE_NAME];\n\n        // List of Face Indices For vertex, uvs, normal\n       std::vector<FaceIndex> vecFaceIndex;\n\n        // List of vertices containing interleaved \n     // information forposition, uv, and normals\n       std::vector<Vertex>    vertices;\n\n        // List of vertices containing positions\n       std::vector<glm::vec3> positions;\n\n        // List of vertices containing normal\n       std::vector<glm::vec3> normals;\n\n        // List of vertices containing uvs\n       std::vector<glm::vec2> uvs;\n\n        //! List of tangents\n       std::vector<glm::vec4> tangents;\n\n        // List of face indices\n       std::vector<unsigned short> indices;\n    };\n    ```", "```java\n    OBJMesh waveFrontObjectModel;\n    objMeshModel = waveFrontObjectModel.ParseObjModel(fname);\n    ```", "```java\n    Mesh* OBJMesh::ParseObjModel(char* path, bool flatShading)\n    {\n        ParseFileInfo(path);         // Parse's the obj file\n        CreateInterleavedArray();    // Interleaved data array\n        CalculateNormal(flatShading);// Generate the normal\n        if(objMeshModel.uvs.size())\n            { CalculateTangents(); } // Generate tangents\n        ClearMesh();                 // Release alloc resources\n        return &objMeshModel;\n    }\n    ```", "```java\n    strcpy(objMeshModel.fileName, path);\n    while(!eofReached)\n    {\n        c = fgetc(pFile);\n        switch(c)\n        {\n            case '#': // Ignore (This is a comment)\n            case 'u': // Ignore\n            case 's': // Ignore\n            case 'g': // Grouping not supported\n                while(fgetc(pFile) != '\\n'); \n    // Skip till new next line not reached.\n                break;\n\n    #ifdef __IPHONE_4_0\n          case EOF:\n    #else\n          case (unsigned char)EOF:\n    #endif\n                eofReached = true;\n                break;\n\n            case 'v': // Load the vertices.\n                c = fgetc(pFile); \n    // The next character will\n               // let us know what vertex attribute to load\n                ScanVertexNormalAndUV( pFile, c );\n                break;\n\n            case 'f': \n    // 'f' means it is a face index information \n    // in the form of v/u/n\n                ScanFaceIndex( pFile, c );\n                break;\n        }\n    }\n    ```", "```java\n           bool OBJMesh::ScanVertexNormalAndUV( FILE* pFile, char c )\n    {\n    float  x, y, z, u, v;\n    switch(c)\n    {\n       case ' ': // Load vertices\n          fscanf(pFile,\"%f %f %f\\n\",&x,&y,&z);\n          objMeshModel.positions.push_back(glm::vec3(x, y, z));\n       break;\n       case 'n': // Loading normal coordinate comp. x,y,z\n           fscanf(pFile,\"%f %f %f\\n\",&x,&y,&z);\n          objMeshModel.normals.push_back(glm::vec3(x, y, z));\n          break;\n       case 't': // Loading Texture coordinates (UV)\n    fscanf(pFile,\"%f %f\\n\",&u,&v);\n             objMeshModel.uvs.push_back(glm::vec2(u, v));\n    break;\n       default:\n            return false;\n    }\n    }\n    ```", "```java\n        // Allocate enough space to store vertices and indices\n\n      objMeshModel.vertices.resize(obMeshModl.vecFacIndex.size());\n            objMeshModel.indices.resize(obMeshModl.vecFacIndex.size());\n\n           // Get the total number of indices.\n            objMeshModel.indexCount = objMeshModel.indices.size();\n\n           // Create the interleaved vertex information\n      // containing position, uv and normal.\n            for(int i = 0; i < objMeshModel.vecFaceIndex.size(); i++)\n            {\n    //Position information must be available always\n    int index = objMeshModel.vecFaceIndex.at(i + 0).vertexIndex;\n    objMeshModel.vertices[i].position =\n                       objMeshModel.positions.at(index);\n    objMeshModel.indices[i] =\n                 (GLushort)objMeshModel.vecFaceIndex.at(i).vertexIndex;\n\n    // If UV information is available.\n    if(objMeshModel.uvs.size()){\n    index = objMeshModel.vecFaceIndex.at(i).uvIndex;\n       objMeshModel.vertices[i].uv =\n     objMeshModel.uvs.at(index);\n    }\n\n    // If Normal information is available.\n    if(objMeshModel.normals.size()){\n    index = objMeshModel.vecFaceIndex.at(i ).normalIndex;\n    objMeshModel.vertices[i].normal =\n    objMeshModel.normals.at(index);\n    }\n    }\n    ```", "```java\n    bool OBJMesh::ClearMesh()\n    {\n      objMeshModel.positions.clear();  // Clear positions\n      objMeshModel.normals.clear();    // Clear normals\n      objMeshModel.uvs.clear();        // Clear tex Coords\n      objMeshModel.indices.clear();      // Clear indices\n      objMeshModel.vecFaceIndex.clear(); // Clear FaceIdx \n      return true;\n    }\n    ```", "```java\n    // Function ObjLoader::ObjLoader( Renderer* parent )\n    ObjLoader::ObjLoader( Renderer* parent )\n    {\n    . . . . . . . \n    objMeshModel= waveFrontObjectModel.ParseObjModel(fname);\n    IndexCount  = waveFrontObjectModel.IndexTotal();\n    stride      = (2 * sizeof(glm::vec3) )+ sizeof(glm::vec2);\n              offset      = (GLvoid*) (sizeof(glm::vec3) + sizeof(glm::vec2));\n\n              // Create the VBO for our obj model vertices.\n              GLuint vertexBuffer; glGenBuffers(1, &vertexBuffer);\n             glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);\n          glBufferData(GL_ARRAY_BUFFER, objMeshModel->vertices.size()\n                   * sizeof(objMeshModel->vertices[0]),\n                   &objMeshModel->vertices[0], GL_STATIC_DRAW);\n\n    // Create the Vertex Array Object (VAO)\n              glGenVertexArrays(1, &OBJ_VAO_Id);\n              glBindVertexArray(OBJ_VAO_Id);\n    // Bind VBO, enable attributes and draw geometry\n       glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);\n       glEnableVertexAttribArray(VERTEX_POSITION);\n              glEnableVertexAttribArray(NORMAL_POSITION);\n              glVertexAttribPointer\n          (VERTEX_POSITION, 3, GL_FLOAT, GL_FALSE, stride, 0);\n              glVertexAttribPointer\n          (NORMAL_POSITION, 3,GL_FLOAT,GL_FALSE,stride,offset);\n              glBindVertexArray(0); //Use default VAO\n    ```", "```java\n    // Calculates the flat or smooth normal on the fly\nFunction OBJMesh::CalculateNormal(bool flatShading)\n{\nif( objMeshModel.normals.size() == 0 ){\n    // Make space to store the normal information\nobjMeshModel.normals.resize(objMeshModel.positions.size());\nint index0, index1, index2;\nglm::vec3 a, b, c;\nfor(int i=0; i<objMeshModel.indices.size();i += 3){\n    // Use indices to retrieve the vertices\n          index0 = objMeshModel.indices.at(i);\n          index1 = objMeshModel.indices.at(i+1);\n          index2 = objMeshModel.indices.at(i+2);\n    // Retrieve each triangles vertex    \n          a = objMeshModel.positions.at(index0);\n          b = objMeshModel.positions.at(index1);\n          c = objMeshModel.positions.at(index2);\n    // Calculate the normal triangle face.\n         glm::vec3 faceNormal =  glm::cross((b - a), (c - a));\n\n         if ( flatShading ){\n    // Calculate normals for flat shading\n             objMeshModel.vertices[i].normal += faceNormal;\n             objMeshModel.vertices[i+1].normal += faceNormal;\n             objMeshModel.vertices[i+2].normal += faceNormal;\n          }\n          else{\n             objMeshModel.normals[index0] += faceNormal;\n             objMeshModel.normals[index1] += faceNormal;\n             objMeshModel.normals[index2] += faceNormal;\n          }\n}\n        // Calculate normals for smooth shading\n        if ( !flatShading ){\n        for(int i = 0;i<objMeshModel.vecFaceIndex.size(); i++){\n        int index=objMeshModel.vecFaceIndex.at\n(i +0).vertexIndex;\n        objMeshModel.vertices[i].normal=\n                               objMeshModel.normals.at(index);\n      }\n   }\n          // Store the calculated normal in normalized form\nfor (int j=0;j<objMeshModel.vertices.size(); j++){\nobjMeshModel.vertices[j].normal = \nglm::normalize (objMeshModel.vertices[j].normal);\n}\n}    \n}\n```", "```java\nLOCAL_PATH := $(call my-dir)\ninclude $(CLEAR_VARS)\n# Name of the shared library\nLOCAL_MODULE    := mylib3ds\nLOCAL_SRC_FILES := \\\n   lib3ds/viewport.c \\\n   lib3ds/vector.c \\\n   lib3ds/tracks.c \\\n   lib3ds/tcb.c \\\n   lib3ds/shadow.c \\\n   lib3ds/quat.c \\\n   lib3ds/node.c \\\n   lib3ds/mesh.c \\\n   lib3ds/matrix.c \\\n   lib3ds/material.c \\\n   lib3ds/light.c \\\n   lib3ds/io.c \\\n   lib3ds/file.c \\\n   lib3ds/ease.c \\\n   lib3ds/chunk.c \\\n   lib3ds/camera.c \\\n   lib3ds/background.c \\\n   lib3ds/atmosphere.c\n# Included libraries and compile time flags\nLOCAL_LDLIBS := -lz\nLOCAL_CFLAGS := -I. -g\n# Build as shared library\ninclude $(BUILD_SHARED_LIBRARY)\n```", "```java\nMY_CUR_LOCAL_PATH := $(call my-dir)\nFRAMEWORK_DIR   = ../../../../GLPIFramework\nLIB3DS_DIR = $(FRAMEWORK_DIR)/3DSParser\n\ninclude $(CLEAR_VARS)\n\ninclude$(MY_CUR_LOCAL_PATH)/../GLPIFramework/zlib/Android.mk \\\n$(MY_CUR_LOCAL_PATH)/../GLPIFramework/3DSParser/Android.mk\n# Source file for compilation\nLOCAL_SRC_FILES := $(FRAMEWORK_DIR)/GLutils.cpp \\\n. . . . .\n. . . . .\n$(SCENE_DIR)/Renderer.cpp \\\n$(SCENE_DIR)/3DSLoader.cpp \\\n../../NativeTemplate.cpp\n# Include the 3DS library\nLOCAL_SHARED_LIBRARIES := zlib mylib3ds\n```", "```java\npublic class GLESNativeLib {\nstatic {\n   System.loadLibrary(\"zlib\");\n   System.loadLibrary(\"mylib3ds\");\n   System.loadLibrary(\"glNative\");\n}\n   . . . . . . Other code\n}\n```", "```java\n    Lib3dsFile* Loader3DS::load3dsModel(const char* fileName){\n       Lib3dsFile* file = lib3ds_file_load(fileName);\n       if (!file) {\n       LOGI(\"*ERROR*\\nLoading file %s failed\\n\", fileName);\n          return NULL;\n       }\n       . . . . . .\n       . . . . . . \n       return file;\n    }\n    ```", "```java\n    if( !file->nodes )\n    {\n       Lib3dsMesh *mesh;\n       Lib3dsNode *node;\n       for(mesh=file->meshes; mesh!=NULL; mesh=mesh->next){\n          node = lib3ds_node_new_object();\n          strcpy(node->name, mesh->name);\n          node->parent_id = LIB3DS_NO_PARENT;\n          lib3ds_file_insert_node(file, node);\n       }\n    }\n    ```", "```java\n    void Loader3DS::Render(Lib3dsFile* file)\n    {\n       . . . . . . .\n       Lib3dsNode *p;\n       for (Lib3dsNode* p=file->nodes; p!=0; p=p->next ){\n           RenderNodes( file, p );\n       }\n       . . . . . . .\n    }\n    ```", "```java\n    void RenderNodes(Lib3dsFile* file,Lib3dsNode *node){\n       . . . . . . . \n    // Use appropriate shader\n    glUseProgram( program->ProgramID );\n\n    Lib3dsNode *tempNode;\n    for(tempNode=node->child;tempNode!=0;\n    tempNode=tempNode->next)     {\n          RenderNodes(file, tempNode);\n                                 }\n    }\n    ```", "```java\n    // Check the user.p variable if empty is assigned\n    MyLib3dsUserData \n    if (!mesh->user.p){\n      MyLib3dsUserData* myPObject = new MyLib3dsUserData;\n      mesh->user.p = (void*)myPObject;\n    }\n    ```", "```java\n    void Loader3DS::BuildMesh(Lib3dsMesh *mesh)\n    {\n     MyLib3dsUserData* userObj=(MyLib3dsUsrData*)mesh->user.p;\n\n        // Allocation memory for vertex positions\n        meshVert = new float[ mesh->points * 3 ];\n       . . . . .\n\n        // Allocate memory for texture\n        meshTexture = new float[ mesh->texels * 2 ];\n        . . . . .\n\n        // Allocate memory for normal\n        meshNormal = new Lib3dsVector[ 3 * mesh->faces ];\n        lib3ds_mesh_calculate_normals(mesh, meshNormal);\n\n        // Allocate memory for face information\n        faceIndex = new unsigned short[mesh->faces*3];\n        . . . . .\n\n        // Create the VBO and populate the VBO data \n        glGenBuffers( 1, (GLuint *)&vId );\n        glBindBuffer( GL_ARRAY_BUFFER, vId );\n        . . . . .\n\n        // Create and populate the IBO with index info. \n        glGenBuffers( 1, (GLuint *)&iId );\n        glBindBuffer( GL_ARRAY_BUFFER, iId );\n        . . . . .\n\n        // Create and Bind Vertex Array Object\n        glGenVertexArrays(1, &VAOId);\n        glBindVertexArray(VAOId);\n        . . . . .\n\n        // Cache the information in the User data structure\n        userObj->vertexId   = vId;\n        userObj->indexId    = iId;\n        userObj->VAOId      = VAOId;\n        . . . . .\n    }\n    ```", "```java\n     MyLib3dsUserData* userObj=(MyLib3dsUserData*)mesh->user.p;\n     // If VAO is not created, create using BuildMesh. \n     if ( !userObj->VAOId ) {\n           BuildMesh( mesh );\n     }\n     else {\n          // Apply Transformation & set material information\n          SetMaterialInfo( mesh );\n          //Bind to VAO & draw primitives\n          glBindVertexArray(userObj->VAOId);\n          glDrawElements(GL_TRIANGLES, userObj->indexNum,\n                      GL_UNSIGNED_SHORT, (void*)0);\n          glBindVertexArray(0); //Bind to default VAO\n     }\n    ```", "```java\nvoid Loader3DS::SetMaterialInfo( Lib3dsMesh *mesh )\n{\n   Lib3dsMaterial *material = 0;\n   if ( mesh->faces ) {\n      // Get associated material with the mesh\n      material = lib3ds_file_material_by_name\n                      (file, mesh->faceL[0].material);\n   }\n\n   if( !material ){\n       return;\n   }\n\n   // Set Ambient, Diffuse and Specular light component\n   glUniform4f(UniformKa, material->ambient[0], \n   material->ambient[1], material->ambient[2], \n   material->ambient[3]);\n   glUniform4f(UniformKd, material->diffuse[0], \n   material->diffuse[1], material->diffuse[2], \n   material->diffuse[3]);\n   glUniform4f(UniformKs,material->specular[0],\n   material->specular[1], material->specular[2], \n   material->specular[3]);\n   glUniform1f(UniformKsh, material->shininess);\n}\n```"]