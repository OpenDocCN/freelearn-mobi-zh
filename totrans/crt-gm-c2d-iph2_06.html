<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Cycles of Light"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Cycles of Light</h1></div></div></div><p>In this chapter, we will be shifting gears and developing a multiplayer iPad game. This game will include both two players on the same iPad as well as using Bluetooth connectivity with GameKit for a real head-to-head battle.</p><p>In this chapter, we cover the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">CCSprite movement without using actions</li><li class="listitem" style="list-style-type: disc">Dynamic sprite stretching</li><li class="listitem" style="list-style-type: disc">Efficient reuse of images</li><li class="listitem" style="list-style-type: disc">Drawing with CCRenderTexture</li><li class="listitem" style="list-style-type: disc">Using glScissor to clip drawing areas</li><li class="listitem" style="list-style-type: disc">GameKit PeerPicker</li><li class="listitem" style="list-style-type: disc">Bluetooth connectivity</li><li class="listitem" style="list-style-type: disc">Sending and Receiving data</li></ul></div><div class="section" title="The game is…"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec53"/>The game is…</h1></div></div></div><p>In this chapter, we will be making a tribute to <a id="id1243" class="indexterm"/>
<a id="id1244" class="indexterm"/>the "Light Cycles of TRON" game from the golden era of arcades. Each player has a bike driven in an enclosed game field. The bike has a fixed speed, and can only turn at right angles. The bike leaves a wall as a trail behind it. It is fatal to run into the walls created by the bikes. It is also fatal to run into the outside walls. To put our own spin on the game, our "bikes" will be light bulbs, each with their own "glow" of the appropriate color.</p><p>This is a two-player only game. Two players can play on the same iPad (positioned at opposite ends), or via a Bluetooth connection between two iPads. The game will be fully playable between Retina and non-Retina iPads at the same time. </p><p>Our finished game will look like the following screenshot:</p><div class="mediaobject"><img src="graphics/9007_06_01.jpg" alt="The game is…"/></div></div></div>
<div class="section" title="Design review"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec54"/>Design review</h1></div></div></div><p>We will begin by discussing the approach that we will use for the design. One of our core design decisions for this game is to use as few graphic files as possible, without sacrificing the look and feel of the game. If you look at the source graphics, we only have four images: a white button with a right arrow on it, a light bulb, a white "bulb glow" image, and a white square image 1 x 1 point in size. <a id="id1245" class="indexterm"/>From those images, we will drive the entire game.</p><p>Structurally, we want separate classes for the bike and the button. The bike will handle all of its own movement, and the button class will send messages directly to the bike it is controlling, so there is very little direct interaction with the game layer itself. The walls will be generated from the white square graphic, using on-the-fly scaling to stretch the walls behind the bike. All walls will be stored inside the game layer, since there is substantial need to share the walls between the bikes.</p><p>We will also use a separate layer for the "grid" graphics behind the playfield, because it truly is visual "fluff" with no interaction with the actual game field. This grid will have some visual effects, so it will never be static. This grid will be generated completely by the code, using the <code class="literal">CCRenderTexture</code> class to draw it when the game initializes.</p></div>
<div class="section" title="Let's build a bike"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec55"/>Let's build a bike</h1></div></div></div><p>We want to start with the basic element of the <a id="id1246" class="indexterm"/>game, the <code class="literal">CLBike</code> class<a id="id1247" class="indexterm"/>
<a id="id1248" class="indexterm"/>. We will look at this class in <a id="id1249" class="indexterm"/>detail here, but first we want to see the <code class="literal">CLDefinitions.h</code> file.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1250" class="indexterm"/>
<a id="id1251" class="indexterm"/>
<code class="literal">CLDefinitions.h</code>
</p><div class="informalexample"><pre class="programlisting">// Audio definitions
#define SND_BUTTON @"button.caf"
#define SND_TURN @"bike_turn.caf"

// Graphics definitions
#define IMG_BIKE @"lightbulb.png"
#define IMG_GLOW @"glow.png"
#define IMG_BUTTON @"rightarrow.png"
#define IMG_SPECK @"whitespeck.png"

typedef enum {
    kBluePlayer,
    kRedPlayer
} PlayerID;

typedef enum {
    kNoChange, // NoChange only used in bluetooth games
    kUp,
    kRight,
    kLeft,
    kDown
} Direction;</pre></div><p>Here we have a few definition for our graphic and sound assets. Centralizing the definitions makes it much easier to change your filenames in one place, rather than hunting through your code for all references.</p><p>We also create two <code class="literal">typedef</code> <code class="literal">enum</code> definition<a id="id1252" class="indexterm"/>s. The <code class="literal">PlayerID</code>
<a id="id1253" class="indexterm"/>
<a id="id1254" class="indexterm"/> holds a value to make it easier to determine which player is being addressed. Likewise, we define <code class="literal">Direction</code> so we can use our directions without needing to keep notes to identify which number represents which direction. As we have mentioned before, these <code class="literal">typedef</code> <code class="literal">enum</code> are "integers in disguise", so we can pass these in as an integer if we ever need to (and we will later).</p><div class="section" title="CLBike header"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec67"/>CLBike header</h2></div></div></div><p>Now, we will look at the complete <a id="id1255" class="indexterm"/>header for the <code class="literal">CLBike</code> class<a id="id1256" class="indexterm"/>
<a id="id1257" class="indexterm"/>
<a id="id1258" class="indexterm"/>.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1259" class="indexterm"/>
<a id="id1260" class="indexterm"/>
<code class="literal">CLBike.h</code>
</p><div class="informalexample"><pre class="programlisting">#import &lt;Foundation/Foundation.h&gt;
#import "cocos2d.h"
#import "CLDefinitions.h"

@class CLPlayfieldLayer;

@interface CLBike : CCSprite {
    CGSize size; // Window size returned from CCDirector

    CLPlayfieldLayer *myPlayfield; // game layer
    
    PlayerID _thisPlayerID; // Player Number
    
    ccColor3B _wallColor; // Blue or green color
    
    float _bikeSpeed; // rate of travel for this bike
    Direction _bikeDirection; // facing which direction?
    
    CCSprite *glow; // The colored bulb glow sprite
    
    CCSprite *_currentWall; // Wall connected to bike
    CCSprite *_priorWall; // Wall created before current
    
    NSInteger wallWidth; // How wide the walls are
    
    BOOL isRemotePlayer; // Is this a non-local player?
    BOOL isCrashed; // Did this bike crash?
}

@property (nonatomic, assign) PlayerID thisPlayerID;
@property (nonatomic, assign) float bikeSpeed;
@property (nonatomic, assign) Direction bikeDirection;
@property (nonatomic, assign) ccColor3B wallColor;
@property (nonatomic, assign) BOOL isRemotePlayer;
@property (nonatomic, assign) BOOL isCrashed;
@property (nonatomic, retain) CCSprite *currentWall;
@property (nonatomic, retain) CCSprite *priorWall;

+(id) bikeForPlayer:(PlayerID)playerID 
           PlayerNo:(NSInteger)playerNo 
            onLayer:(CLPlayfieldLayer*)thisLayer
           isRemote:(BOOL)remotePlayer;

-(void) moveForDistance:(float)dist;
-(void) move;
-(void) turnRight;
-(void) turnLeft;
-(void) crash;

-(CGPoint) wallAnchorPoint;

@end</pre></div><p>Most of these variables will be discussed during the explanation of the <code class="literal">CLBike.m</code> file, but there are a few items to touch on here. We keep a variable for <code class="literal">myPlayfield</code>, so the bike will be able to call methods from the main <code class="literal">CLPlayfieldLayer</code> class. You will notice that we do not <code class="literal">#import</code> that class, but instead use an <code class="literal">@class</code> line. As you may recall from <a class="link" href="ch03.html" title="Chapter 3. Thumping Moles for Fun">Chapter 3</a>, <span class="emphasis"><em>Thumping Moles for Fun</em></span> and <a class="link" href="ch04.html" title="Chapter 4. Give a Snake a Snack…">Chapter 4</a>, <span class="emphasis"><em>Give a Snake a Snack...</em></span>, this is a forward-declaration. It identifies that there will be a class by that name, but it doesn't know anything else about it in the header. <a id="id1261" class="indexterm"/>The reason we use this is because the <code class="literal">CLPlayfieldLayer.m</code> file will import the <code class="literal">CLBike.h</code> header, so we would be stuck in a loop as the two classes try to import each other.</p><p>We also have a class "convenience" <a id="id1262" class="indexterm"/>method here:</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1263" class="indexterm"/>
<a id="id1264" class="indexterm"/>
<code class="literal">FileCLBike.h</code>
</p><div class="informalexample"><pre class="programlisting">+(id) bikeForPlayer:(PlayerID)playerID 
           PlayerNo:(NSInteger)playerNo 
            onLayer:(CLPlayfieldLayer*)thisLayer
           isRemote:(BOOL)remotePlayer;</pre></div><p>Even though the <code class="literal">CLBike</code> class is a subclass of <code class="literal">CCSprite</code>, we have several other details of the class that we need to set up, so we have opted for this convenience method. We need to know the <code class="literal">playerID</code> (<code class="literal">kRedPlayer</code> or <code class="literal">kBluePlayer</code>), and the <a id="id1265" class="indexterm"/>
<a id="id1266" class="indexterm"/>
<code class="literal">playerNo</code> variable, which defines which "control position" the player is in. Player no. 1 is on the "home button" end of the iPad, and player no. 2 will play from the "top" of the iPad. We also pass the parent layer to the bike. The final argument is the Boolean variable <code class="literal">isRemote</code>, which identifies whether or not this bike will be controlled by someone who is not "local" to this iPad (that is during a Bluetooth game).</p><p>We also expose many variables and methods as properties in this class. This is because we want the other classes to be able to "ask" the bike for a <a id="id1267" class="indexterm"/>lot of information. We also need to be able to completely control the bike from outside the class. If you recall from our design discussion, we want the control buttons to send messages directly to the bike, so we have to expose all of the control methods.</p></div><div class="section" title="CLBike implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec68"/>CLBike implementation</h2></div></div></div><p>Now that we have a flavor for the <a id="id1268" class="indexterm"/>
<a id="id1269" class="indexterm"/>
<code class="literal">CLBike</code> header, we will move on to the implementation file. We will step through the core of the class here, and <a id="id1270" class="indexterm"/>
<a id="id1271" class="indexterm"/>will revisit it later when we discuss playing over Bluetooth.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1272" class="indexterm"/>
<a id="id1273" class="indexterm"/>
<code class="literal">CLBike.m</code>
</p><div class="informalexample"><pre class="programlisting">#import "CLBike.h"
#import "CLPlayfieldLayer.h"
#import "SimpleAudioEngine.h"

@implementation CLBike

@synthesize thisPlayerID = _thisPlayerID;
@synthesize bikeSpeed = _bikeSpeed;
@synthesize bikeDirection = _bikeDirection;
@synthesize wallColor = _wallColor;
@synthesize currentWall = _currentWall;
@synthesize priorWall = _priorWall;
@synthesize isRemotePlayer;
@synthesize isCrashed;

+(id) bikeForPlayer:(PlayerID)playerID 
           PlayerNo:(NSInteger)playerNo 
            onLayer:(CLPlayfieldLayer*)thisLayer
           isRemote:(BOOL)remotePlayer
{
    return [[[self alloc] initForPlayer:playerID 
                               PlayerNo:playerNo 
                                onLayer:thisLayer
                               isRemote:remotePlayer] 
            autorelease];   
}</pre></div><p>It is worth pointing out that we do have the <code class="literal">#import "CLPlayfieldLayer.h"</code> statement at the top of this file. This is the "pair" to the <code class="literal">@class</code> forward-declaration statement we used in the header. We need to use the <code class="literal">#import</code> line here because we will need the <code class="literal">CLBike</code> class to have access to the methods of the <a id="id1274" class="indexterm"/>
<a id="id1275" class="indexterm"/>
<code class="literal">CLPlayfieldLayer</code> class.</p><p>As we said earlier, we built a convenience method for creating a new bike. To adhere to the definition of a convenience method, we perform an <code class="literal">alloc</code>, an <code class="literal">init</code>, and mark the instantiated object as an <code class="literal">autorelease</code> object.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">CLBike.m</code> (<code class="literal">initForPlayer</code>, part 1)</p><div class="informalexample"><pre class="programlisting">-(id) initForPlayer:(PlayerID)playerID 
           PlayerNo:(NSInteger)playerNo 
            onLayer:(CLPlayfieldLayer*)thisLayer
           isRemote:(BOOL)remotePlayer {
    if(self = [super initWithSpriteFrameName:IMG_BIKE]) {
        myPlayfield = thisLayer;
        
        isRemotePlayer = remotePlayer;
        
        size = [[CCDirector sharedDirector] winSize];
        
        self.thisPlayerID = playerID;
        self.bikeSpeed = 3.0;
        self.bikeDirection = kUp;
        self.anchorPoint = ccp(0.5,0);
        self.scale = 0.25;
        self.isCrashed = NO;
        
        // Set the player's wall color
        switch (self.thisPlayerID) {
            case kRedPlayer:
                self.wallColor = ccc3(255, 75, 75);
                break;
            case kBluePlayer:
                self.wallColor = ccc3(75, 75, 255);
                break;
        }</pre></div><p>Here we begin the <a id="id1276" class="indexterm"/>
<a id="id1277" class="indexterm"/>
<code class="literal">initForPlayer:</code> method. The "super" class of <code class="literal">CLBike</code> is <code class="literal">CCSprite</code>, so we can call <code class="literal">initWithSpriteFrameName:</code> from the super class. This takes care of the initialization of the standard <code class="literal">CCSprite</code> aspects of our class. We only need to concern ourselves with the specialized <code class="literal">CLBike</code> initialization.</p><p>We keep the reference to the layer passed (in <code class="literal">myPlayfield</code>), the <code class="literal">playerID</code> (in <code class="literal">self.thisPlayerID</code>), and the Boolean value of the <code class="literal">remotePlayer</code> variable (in <code class="literal">isRemotePlayer</code>). The <code class="literal">playerNo</code> value is not stored in a variable, as it will only be used while building the player's bike.</p><p>We set the default values for the bike to be facing up (<code class="literal">kUp</code>) with a <code class="literal">bikeSpeed</code> of <code class="literal">3.0</code>, and a <code class="literal">scale</code> of <code class="literal">0.25</code>. We also set the <code class="literal">anchorPoint</code> to <code class="literal">ccp(0.5, 0)</code> which is a point which is centered on the rear end of the <a id="id1278" class="indexterm"/>bike.</p><p>Because we want to optimize our graphics, we will need to <a id="id1279" class="indexterm"/>know what the player's color is. We don't want to set the sprite's color at all, because it would make the sprite look like a colored blob instead of a light bulb. Instead, we use <code class="literal">ccc3(r,g,b)</code> to build the colors we want, which are tinted slightly off pure red and pure blue, and then store them in the property <code class="literal">wallColor</code>.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">CLBike.m</code> (<code class="literal">initForPlayer</code>, part 2)</p><div class="informalexample"><pre class="programlisting">switch (playerNo) {
            case 1:
                // Starts at bottom of screen
                [self setPosition:ccp(size.width/2,64)];
                break;
            case 2:
                // Starts at top of screen
                [self setPosition:ccp(size.width/2,960)];
                self.bikeDirection = kDown;
                break;
        }
        
        [self rotateBike];
        
        glow = [CCSprite spriteWithSpriteFrameName:IMG_GLOW];
        [glow setAnchorPoint:[self anchorPoint]];
        [glow setPosition:ccp(34,26)];
        [glow setColor:self.wallColor];
        [self addChild:glow z:-1];

        // Bike's wall init here
    }
    return self;
}</pre></div><p>Here we see the only code in the <code class="literal">CLBike</code> class that uses the <code class="literal">playerNo</code> value. If this is player 1, then the bike's starting position is centered toward the bottom of the screen. Player 2 is centered near the top of the screen, and their direction is changed to <code class="literal">kDown</code>. Once we have changed the bike's direction, we call the <code class="literal">rotateBike</code> method, which will correctly rotate the bike graphic (more on that method <a id="id1280" class="indexterm"/>shortly). </p><p>We then add our "glow" graphic. This uses the solid white glow image, which we set to the color stored as the player's <code class="literal">wallColor</code>. We set the position as a little offset from the bike's position, to account for differences in the source image dimensions. We set the anchor point using the same <code class="literal">anchorPoint</code> value as the bike itself, and then we add the glow as a child of the bike (<code class="literal">self</code> in this class refers to the <code class="literal">CLBike</code> object), with a Z value of <code class="literal">-1</code>. This puts the glow behind the light bulb sprite. This lets us see the detail of the bulb, but also have the glowing effect visible through the transparent parts of the light bulb graphic.</p><p>The following screenshot shows the red bike, before and <a id="id1281" class="indexterm"/>after we add the glow:</p><div class="mediaobject"><img src="graphics/9007_06_02.jpg" alt="CLBike implementation"/></div><p>We will add some code to the end of this method later, but this will suffice for now.</p></div><div class="section" title="Bike rotation"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec69"/>Bike rotation</h2></div></div></div><p>We have seen one method in this class that we haven't addressed yet, and it is simple enough to address now. After we position the bike, <a id="id1282" class="indexterm"/>we call the <a id="id1283" class="indexterm"/>
<a id="id1284" class="indexterm"/>
<code class="literal">rotateBike</code> <a id="id1285" class="indexterm"/>method.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">CLBike.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) rotateBike {
    // Rotate the bike to match the direction
    switch (self.bikeDirection) {
        case kUp:
            self.rotation = 0;
            break;
        case kRight:
            self.rotation = 90;
            break;
        case kDown:
            self.rotation = 180;
            break;
        case kLeft:
            self.rotation = -90;
            break;
        default:
            break;
    }
}</pre></div><p>We use a <code class="literal">switch</code> clause on the <a id="id1286" class="indexterm"/>
<a id="id1287" class="indexterm"/>
<code class="literal">self.bikeDirection</code> property. We then check which direction the bike is facing. Depending on the direction, we set the rotation for the sprite. The values chosen are simple right angles. So if the bike is facing in direction <code class="literal">kRight</code>, for example, we rotate the sprite to 90 degrees. If the bike is facing left, we rotate to -90 degrees. The movement will be controlled <a id="id1288" class="indexterm"/>separately, so this graphic rotation is purely cosmetic. If we had chosen a symmetrical player graphic, we <a id="id1289" class="indexterm"/>may not need to rotate at all.</p></div><div class="section" title="Turning the bike"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec70"/>Turning the bike</h2></div></div></div><p>Rotating the bike graphics is all well and good, but we need to be able to change the actual direction in which the bike is travelling. We build two <a id="id1290" class="indexterm"/>methods <a id="id1291" class="indexterm"/>to control this: <code class="literal">turnLeft</code> and <code class="literal">turnRight</code>. We will look at the <code class="literal">turnRight</code> <a id="id1292" class="indexterm"/>
<a id="id1293" class="indexterm"/>method here.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">CLBike.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) turnRight {
    // Turn the bike to the right
    switch (self.bikeDirection) {
        case kUp:
            self.bikeDirection = kRight;
            break;
        case kRight:
            self.bikeDirection = kDown;
            break;
        case kDown:
            self.bikeDirection = kLeft;
            break;
        case kLeft:
            self.bikeDirection = kUp;
            break;
        default:
            break;
    }
    
    // Rotate the bike to the new direction
    [self rotateBike];
    
    // Play the turn sound
    [[SimpleAudioEngine sharedEngine] playEffect:SND_TURN];
    
    // Wall assignments

    // Remote game
}</pre></div><p>When we call the <code class="literal">turnRight</code> method, we use a switch statement to determine the current <code class="literal">bikeDirection</code>. We then set the new <code class="literal">bikeDirection</code> that is appropriate for this turn. So, if you were going in the <code class="literal">kUp</code> direction and turned right, your new direction is <code class="literal">kRight</code>. If you were going <code class="literal">kRight</code>, the new direction is <code class="literal">kDown</code>. After the new direction has been set, we call to the <a id="id1294" class="indexterm"/>
<a id="id1295" class="indexterm"/>
<code class="literal">rotateBike</code> method we just discussed. We play a simple sound effect for the turn, and that's all we need to do at this <a id="id1296" class="indexterm"/>point. We have placeholders for two additional pieces of code that we will add later (wall assignments and remote game).</p><p>The <a id="id1297" class="indexterm"/>
<a id="id1298" class="indexterm"/>
<code class="literal">turnLeft</code> method is nearly identical, except we obviously use a different set of new directions in the <code class="literal">switch</code> statement, so the bike will correctly turn to the left. There will be a slight difference in the remote game section that we will add later.</p><p>We could have compressed these two methods into <a id="id1299" class="indexterm"/>one, with a conditional <span class="emphasis"><em>if</em></span> statement for the parts of the code that differ. We have opted for reading clarity in this case, as the repeated code is really not that difficult to debug.</p></div></div>
<div class="section" title="Building walls"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec56"/>Building walls</h1></div></div></div><p>Next, we will turn our attention to the creation of the game walls. <a id="id1300" class="indexterm"/>There are two types of walls we need to address: walls created by a player's bike and the border walls around the playing grid. We <a id="id1301" class="indexterm"/>will start by looking at how we can build our boundary walls.</p><div class="section" title="Boundary walls"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec71"/>Boundary walls</h2></div></div></div><p>Before we look at the code, it is important to know two items that are set up in our <code class="literal">init</code> method of the <a id="id1302" class="indexterm"/>
<a id="id1303" class="indexterm"/>
<code class="literal">CLPlayfieldLayer</code> class. First, our <code class="literal">CCSpriteBatchNode</code> is in the variable <code class="literal">cyclesheet</code>. <a id="id1304" class="indexterm"/>The second is that we have created an <code class="literal">NSMutableArray</code> called <code class="literal">bikeWalls</code> that will hold the <code class="literal">CCSprite</code> objects for all created walls (we will see this later, when we look at the <code class="literal">init</code> method in the <code class="literal">CLPlayfieldLayer</code> class). This array will be used in our collision detection, so we need to <a id="id1305" class="indexterm"/>have our outer walls included in it.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1306" class="indexterm"/>
<a id="id1307" class="indexterm"/>
<code class="literal">CLPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) createWallFrom:(CGPoint)orig to:(CGPoint)dest {
    CCSprite *aWall = [CCSprite 
                       spriteWithSpriteFrameName:IMG_SPECK];
    [aWall setColor:ccYELLOW];
    [aWall setPosition:orig];
    [aWall setAnchorPoint:ccp(0,0)];
    [aWall setScaleX:ABS(orig.x - dest.x) + 3];
    [aWall setScaleY:ABS(orig.y - dest.y) + 3];
    [cyclesheet addChild:aWall];
    
    [bikeWalls addObject:aWall]; 
}</pre></div><p>The first method we need is the ability to create a wall between two specified points, <code class="literal">orig</code> and <code class="literal">dest</code>, passed to it. If you recall from the beginning of the chapter, we said one of our goals with this game was to optimize the use of graphics. Here we see the first "real" use of that idea. We are using the image defined as <code class="literal">IMG_SPECK</code>, which is the file <code class="literal">whitespeck.png</code> in the sprite sheet. This is a 1 x 1 point white square image. We use this tiny image to create the wall sprite. We set the color to yellow, which works really well on a white sprite. Using <code class="literal">setColor</code> works in the opposite way to what most people expect. Instead of adding color to the sprite, it actually <a id="id1308" class="indexterm"/>reduces the appropriate color registers to give the desired effect.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>Setting a sprite to white (<code class="literal">ccWHITE</code>) actually sets the color to the original color. This dynamic is important to know if you are doing anything interesting with sprite colors. For example, if you set a sprite's color to blue and there is nothing in the blue register, the sprite could turn black. It is these unintended consequences that make it very appealing to use white sprites if your intention is to colorize them in-game.</p></div></div><p>Back to the code. We set the position of the sprite to the <code class="literal">orig</code> value we were passed, and we set the anchor point to the bottom-left corner. We do this to keep in check with the background we will be adding later. We then have a couple of odd lines for the <code class="literal">setScaleX</code> and <code class="literal">setScaleY</code>. Because we want to use this routine to draw all four walls, we won't know in which direction we are drawing. The formula in each of these lines does the same thing: Subtract the x (or y) values from each other. Take the absolute value (<code class="literal">ABS</code>) of the result. This will turn the negatives into positives. We then add 3 points, so we end up with a thick line (and avoid zero scale in the "thin" direction). This will take that simple 1 x 1 point graphic and stretch it out into a <a id="id1309" class="indexterm"/>line the full length we requested, with a thickness of 3 points. This approach works well for horizontal or vertical lines, but will make a big rectangle if you use coordinates that are not straight lines. Our game uses only straight lines, so this will suit our needs perfectly.</p><p>We wrap up this method by adding the wall as a child of <code class="literal">cyclesheet</code>, and adding the created wall to the <code class="literal">bikeWalls</code> array. Now we have seen how to build a wall, we need another method to pass all of the coordinates we need to build the outer walls.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">CLPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) createOuterWalls {
    // Bottom
    [self createWallFrom:ccp(59,62) to:ccp(709,62)];
    // Top
    [self createWallFrom:ccp(59,962) to:ccp(709,962)];
    // Left
    [self createWallFrom:ccp(59,62) to:ccp(59,962)];
    // Right
    [self createWallFrom:ccp(709,62) to:ccp(709,962)];
}</pre></div><p>We have decided that the desired offset from the left and right edges is 59 points. The offset from the top and bottom is 62 points. We <a id="id1310" class="indexterm"/>call the <a id="id1311" class="indexterm"/>
<code class="literal">createWallFrom</code> method for each of the four boundary walls, and our work is done here.</p></div><div class="section" title="Bike walls"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec72"/>Bike walls</h2></div></div></div><p>Now we get to the real core of the cycles of light experience: the bike walls. Each bike will begin with a wall created behind it, and the walls will <a id="id1312" class="indexterm"/>stretch until the bike turns. We start a <a id="id1313" class="indexterm"/>new wall from that point.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">CLPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(CCSprite*) createWallFromBike:(CLBike*)thisBike {
    
    CCSprite *aWall = [CCSprite 
                       spriteWithSpriteFrameName:IMG_SPECK];
    [aWall setColor:thisBike.wallColor];
    [aWall setAnchorPoint:[thisBike wallAnchorPoint]];
    [aWall setPosition:thisBike.position];
    
    [cyclesheet addChild:aWall];
    
    [bikeWalls addObject:aWall];
    
    return aWall;
}</pre></div><p>This code is very similar to what we used for building the outer walls, with a few notable exceptions. When this method is called, the <code class="literal">CLBike</code> instance of the player's bike will be passed to it. We use this to get most of the parameters we need for the wall. We set the wall's color to the <code class="literal">wallColor</code> of the bike. We set the wall's position to the same position occupied by the bike. We also set the <code class="literal">anchorPoint</code> using a method called <code class="literal">wallAnchorPoint</code> that is part of the <code class="literal">CLBike</code> class (we'll look at that in just a moment).</p><p>We do not scale the wall sprite when it is created, so it is a single dot under the bike. We will handle the scaling of these walls from within the bike's movement code.</p><p>Like the other method, we still add the wall to the <code class="literal">cyclesheet</code> and to the <code class="literal">bikeWalls</code> array. However, we also return the wall to the caller. This is because the bike will need to know what wall is being created. Let's hop over to the <a id="id1314" class="indexterm"/>
<a id="id1315" class="indexterm"/>
<code class="literal">CLBike</code> class to see what's going on there.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">CLBike.m</code>
</p><div class="informalexample"><pre class="programlisting">-(CGPoint) wallAnchorPoint {
    // Calculate the anchor point, based on direction
    switch (self.bikeDirection) {
        case kUp:
            return ccp(0.5,0);
            break;
        case kRight:
            return ccp(0,0.5);
            break;
        case kDown:
            return ccp(0.5,1);
            break;
        case kLeft:
            return ccp(1,0.5);
            break;
        default:
            return ccp(0.5,0.5);
            break;
    }
}</pre></div><p>Here we have another method that uses the <code class="literal">bikeDirection</code> in a <a id="id1316" class="indexterm"/>
<a id="id1317" class="indexterm"/>
<code class="literal">switch</code> statement to determine a course of action. We set the anchor point to be at the center rear of the bike. So if the bike is currently going in direction <code class="literal">kRight</code>, then the anchor point should be set so <code class="literal">x</code> is equal to <code class="literal">0</code> (left edge) and <code class="literal">y</code> is equal to <code class="literal">0.5</code> (centered). We return the anchor point as a <code class="literal">ccp()</code> for all possible values of <code class="literal">bikeDirection</code>.</p><p>You will also notice that we return the value directly to the calling method. The only place where this method is called is from the <a id="id1318" class="indexterm"/>
<a id="id1319" class="indexterm"/>
<code class="literal">createWallFromBike</code> method we just reviewed. The reason we use the bike to determine the anchor point is that we want the wall to be <a id="id1320" class="indexterm"/>attached to the rear end of the bike, no matter what direction it is heading. In this way, each time we create a bike, the wall is anchored correctly. If you're curious what it looks like when you incorrectly anchor a wall in the game, consider the following screenshot:</p><div class="mediaobject"><img src="graphics/9007_06_03.jpg" alt="Bike walls"/></div><p>The same code was used in both of these images, except the <code class="literal">wallAnchorPoint</code> <a id="id1321" class="indexterm"/>method was not used in the "Bad Anchor Points" example.</p></div><div class="section" title="Bike integration"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec73"/>Bike integration</h2></div></div></div><p>Now let's look at the code changes needed to integrate the <a id="id1322" class="indexterm"/>walls into <code class="literal">CLBike</code>.</p><p>Filename: <code class="literal">CLBike.m</code> (<code class="literal">initForPlayer</code> end of method)</p><div class="informalexample"><pre class="programlisting">        // Bike's wall init here
        wallWidth = 5;
        
        self.priorWall = nil;
        self.currentWall = [myPlayfield 
                            createWallFromBike:self];</pre></div><p>Here we set a <code class="literal">wallWidth</code> to <code class="literal">5</code>, and we set the <code class="literal">priorWall</code> to <code class="literal">nil</code>. Then we store the returned value of the <code class="literal">createWallFromBike</code> in the <a id="id1323" class="indexterm"/>
<a id="id1324" class="indexterm"/>
<code class="literal">self.currentWall</code> property. To avoid colliding with the prior wall when you turn, we <a id="id1325" class="indexterm"/>need to be able to hold references to both the current wall and the wall just before it. Of course, here we are simply initializing the <code class="literal">priorWall</code> as <code class="literal">nil</code> for good measure.</p><p>We also need to insert identical code in both the <a id="id1326" class="indexterm"/>
<a id="id1327" class="indexterm"/>
<code class="literal">turnRight</code> and <a id="id1328" class="indexterm"/>
<a id="id1329" class="indexterm"/>
<code class="literal">turnLeft</code> methods of the <code class="literal">CLBike</code>. </p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">CLBike.m</code> (inside <code class="literal">turnRight</code> method)</p><div class="informalexample"><pre class="programlisting">    // Wall assignments
    self.priorWall = self.currentWall;
    self.currentWall = [myPlayfield 
                        createWallFromBike:self];</pre></div><p>Both turn methods get identical "wall" code. This is the same as in the original <code class="literal">init</code> method, except here we first point the <code class="literal">priorWall</code> to the <code class="literal">currentWall</code> before we generate a new wall into the <a id="id1330" class="indexterm"/>
<a id="id1331" class="indexterm"/>
<code class="literal">currentWall</code> property. Because the <code class="literal">currentWall</code> property will first release the reference to the old wall before it creates a new one, this leaves the <code class="literal">priorWall</code> variable pointing to the previous wall, <a id="id1332" class="indexterm"/>and the <code class="literal">currentWall</code> is now <a id="id1333" class="indexterm"/>connected to the newly instantiated wall.</p></div></div>
<div class="section" title="Bike movement"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec57"/>Bike movement</h1></div></div></div><p>We will now move on to examine how we move the bike. Because the walls are central to the bike movement code, we left the movement until we <a id="id1334" class="indexterm"/>understood the walls. <a id="id1335" class="indexterm"/>The movement is broken down into two methods.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1336" class="indexterm"/>
<a id="id1337" class="indexterm"/>
<code class="literal">CLBike.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) move {
    // Move this bike (if local player)
    [self moveForDistance:self.bikeSpeed];
    
    // Remote game
}</pre></div><p>This is the easy method. This looks a little silly now, but it will make more sense once we add the "remote game" functionality later. For now, this is just a pass-through to the <code class="literal">moveForDistance</code> <a id="id1338" class="indexterm"/>
<a id="id1339" class="indexterm"/>method, passing the <a id="id1340" class="indexterm"/>
<a id="id1341" class="indexterm"/>
<code class="literal">bikeSpeed</code> parameter.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1342" class="indexterm"/>
<a id="id1343" class="indexterm"/>
<code class="literal">CLBike.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void)moveForDistance:(float)dist {
    // Update bike position and scales the currentWall
    switch (self.bikeDirection) {
        case kUp:
            [self setPosition:ccp(self.position.x,
                                  self.position.y + 
                                  dist)];
            [self.currentWall setScaleY:
             ABS(self.currentWall.position.y - 
                 self.position.y)];
            
            [self.currentWall setScaleX:wallWidth];
            
            break;
        case kDown:
            [self setPosition:ccp(self.position.x,
                                  self.position.y - 
                                  dist)];
            
            [self.currentWall setScaleY:
             ABS(self.currentWall.position.y
                 - self.position.y)];
            
            [self.currentWall setScaleX:wallWidth];
            
            break;
        case kLeft:
            [self setPosition:ccp(self.position.x - 
                                  dist,
                                  self.position.y)];
            
            [self.currentWall setScaleX:
             ABS(self.currentWall.position.x 
                 - self.position.x)];
            
            [self.currentWall setScaleY:wallWidth];
            
            break;
        case kRight:
            [self setPosition:ccp(self.position.x + 
                                  dist,
                                  self.position.y)];
            
            [self.currentWall setScaleX:
             ABS(self.currentWall.position.x 
                 - self.position.x)];
            
            [self.currentWall setScaleY:wallWidth];
            
            break;
        default:
            break;
    }
}</pre></div><p>We again use the common <a id="id1344" class="indexterm"/>
<a id="id1345" class="indexterm"/>
<code class="literal">switch</code> statement on the <code class="literal">bikeDirection</code>. For each direction the bike is travelling, we first set the new position for the bike. This position is adding (or subtracting) the value of <code class="literal">dist</code> (the <code class="literal">bikeSpeed</code> we <a id="id1346" class="indexterm"/>passed in) to the appropriate x or y <a id="id1347" class="indexterm"/>position. For example, if the bike is moving in the <code class="literal">kUp</code> direction, we add <code class="literal">dist</code> to the <code class="literal">y</code> position. To move down, we subtract <code class="literal">dist</code> from the <code class="literal">y</code> value.</p><p>The next two lines of code in each case are adjusting the <code class="literal">scaleX</code> and <code class="literal">scaleY</code> of the <code class="literal">currentWall</code>. If the bike is travelling in a y direction (up or down), we set the <code class="literal">scaleX</code> to the value of <code class="literal">wallWidth</code>. If the bike is travelling in an x direction (left or right), we set the <code class="literal">scaleY</code> to the value of <code class="literal">wallWidth</code>.</p><p>For the scale in the direction the bike is travelling, we take the absolute value (<code class="literal">ABS</code>) of the <code class="literal">currentWall</code> <a id="id1348" class="indexterm"/>
<a id="id1349" class="indexterm"/>position minus the bike's current position. This will effectively stretch the wall from its origin to the bike with every move. This is exactly the same type of wall stretching we used when we created the outer walls, <a id="id1350" class="indexterm"/>except this is dynamically resizing the wall every time the bike moves.</p><p>That's all it takes to make the bike move, and for the <a id="id1351" class="indexterm"/>walls to grow appropriately.</p></div>
<div class="section" title="Control buttons"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec58"/>Control buttons</h1></div></div></div><p>Now that the bike and walls are fleshed out, we turn our attention to the control buttons. As we have mentioned before, we are optimizing our graphics, so we actually only have a single black and white button to use for all the control <a id="id1352" class="indexterm"/>buttons. Let's look at the class header first.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1353" class="indexterm"/>
<a id="id1354" class="indexterm"/>
<a id="id1355" class="indexterm"/>
<code class="literal">CLButton.h</code>
</p><div class="informalexample"><pre class="programlisting">#import &lt;Foundation/Foundation.h&gt;
#import "cocos2d.h"
#import "CLDefinitions.h"
#import "CLBike.h"

@interface CLButton : CCSprite &lt;CCTargetedTouchDelegate&gt; {
    BOOL isLeft; // Is this a left turn button?
    CLBike *parentBike; // Bike the button controls
    CLPlayfieldLayer *myPlayfield; // main game layer
}

+(id) buttonForBike:(CLBike*)thisBike
         asPlayerNo:(NSInteger)playerNo
             isLeft:(BOOL)isLeftButton
            onLayer:(CLPlayfieldLayer*)thisLayer;

@end</pre></div><p>Here we have kept references to both <code class="literal">myPlayfield</code> and the <code class="literal">parentBike</code>. The variable <code class="literal">myPlayfield</code> references the main playfield layer of our game. The <a id="id1356" class="indexterm"/>
<a id="id1357" class="indexterm"/>
<code class="literal">parentBike</code> is the bike that will be controlled by this button. The Boolean variable <code class="literal">isLeft</code> is used to determine if this is a left turn button. If this is set to <code class="literal">NO</code>, it is a right turn button.</p><p>We also have a convenience method to establish the class, which accepts values on behalf of these three variables, as well as a <a id="id1358" class="indexterm"/>
<a id="id1359" class="indexterm"/>
<code class="literal">playerNo</code> variable. The buttons need to know this for the same reason that we used it in the <code class="literal">CLBike</code> class; the <a id="id1360" class="indexterm"/>buttons need to know on which <a id="id1361" class="indexterm"/>end of the iPad they should be drawn.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">CLButton.m</code>
</p><div class="informalexample"><pre class="programlisting">#import "CLButton.h"
#import "CLDefinitions.h"
#import "CLPlayfieldLayer.h"

@implementation CLButton

#pragma mark Initialization
+(id) buttonForBike:(CLBike*)thisBike 
         asPlayerNo:(NSInteger)playerNo 
             isLeft:(BOOL)isLeftButton
            onLayer:(CLPlayfieldLayer*)thisLayer {
    return [[[self alloc] initForBike:thisBike 
                           asPlayerNo:playerNo 
                               isLeft:isLeftButton
                              onLayer:thisLayer] 
            autorelease];   
}</pre></div><p>Here we see the beginning of the implementation. We flesh out the class method, which follows the convenience method of building an autoreleased object.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1362" class="indexterm"/>
<a id="id1363" class="indexterm"/>
<code class="literal">CLButton.m</code>
</p><div class="informalexample"><pre class="programlisting">-(id) initForBike:(CLBike*)thisBike 
       asPlayerNo:(NSInteger)playerNo 
           isLeft:(BOOL)isLeftButton
            onLayer:(CLPlayfieldLayer*)thisLayer {   
    if( self = [super initWithSpriteFrameName:IMG_BUTTON]) {

        // Store whether this is a left button
        isLeft = isLeftButton;

        // Keep track of the parent bike
        parentBike = thisBike;

        // Keep track of the parent layer
        myPlayfield = thisLayer;
        
        // Set the tint of the button
        [self setColor:parentBike.wallColor];

        // Base values for positioning
        float newY = 30;
        float newX = [[CCDirector sharedDirector] 
                      winSize].width / 4;
        
        // Selective logic to position the buttons
        switch (playerNo) {
            case 1:
                if (isLeft) {
                    // Flip the image so it points left
                    [self setFlipX:YES];
                } else {
                    // Move it to the right
                    newX *= 3;
                } 
                break;
            case 2:
                // Player 2 is upside down at the top
                newY = 994;

                // Flip the buttons to face player
                [self setFlipY:YES];

                if (isLeft) {
                    // Move it to the right
                    newX *= 3;
                } else {
                    // Flip the image so it points left
                    [self setFlipX:YES];
                }
                break;
        }
 
        [self setPosition:ccp(newX, newY)];
        
    }
    return self;
}</pre></div><p>In the <a id="id1364" class="indexterm"/>
<a id="id1365" class="indexterm"/>
<code class="literal">initForBike</code> method, we begin by setting the three variables we saw in the header to their passed values. We then call <code class="literal">setColor</code> and tint the (formerly white) button to the <code class="literal">wallColor</code> of the <code class="literal">parentBike</code>. So now we will have a red or blue button, reflecting the player it controls.</p><p>We set "base" values of the <code class="literal">newX</code> to be ¼ of the screen width, and <code class="literal">newY</code> to be 30. We then have a switch statement using the <code class="literal">playerNo</code> variable to handle the placement of the buttons. For player 1, we check if this is the left button (the <code class="literal">isLeft</code> Boolean). If it is, we flip the button on its X axis. This is because our source graphic has the arrow pointing to the right. If it is the right button, we multiply the <code class="literal">newX</code> value by 3, so we are ¾ of the way across the screen.</p><p>For player 2, the logic is a little different, because we need to create the buttons at the top of the iPad, and completely backwards, compared to player 1. We reset the <code class="literal">newY</code> value to 994 (1024 – 30). We also flip the buttons on the Y <a id="id1366" class="indexterm"/>axis, so they will be facing the player.  If the button is the left button, we need multiply the <code class="literal">newX</code> by 3 to move it to ¾ of the <a id="id1367" class="indexterm"/>way across the screen. This will put it on the left, relative to the player. If it is the right button, we flip it on the X axis. Notice the <code class="literal">flipX</code> and <code class="literal">newX</code> are exactly opposite to the way we handled player 1. Finally, we set the position to <code class="literal">newX</code>, <code class="literal">newY</code>.</p><div class="section" title="Touching buttons"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec74"/>Touching buttons</h2></div></div></div><p>As you might imagine, we need a touch handler <a id="id1368" class="indexterm"/>for the <a id="id1369" class="indexterm"/>buttons.  </p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1370" class="indexterm"/>
<a id="id1371" class="indexterm"/>
<code class="literal">CLButton.m</code>
</p><div class="informalexample"><pre class="programlisting">-(BOOL) ccTouchBegan:(UITouch *)touch withEvent:(UIEvent *)event {
    // Prevent touches if the layer not accepting touches
    if (myPlayfield.isTouchBlocked) {
        return NO;
    }
    
    CGPoint loc = [touch locationInView:[touch view]];
    CGPoint convLoc = [[CCDirector sharedDirector]
                       convertToGL:loc];
    
    // Create an expanded hit box for this class
    CGRect hitRect = CGRectInset(self.boundingBox, 0, -50.0);
    
    // If touched, send a turn msg to the parent bike
    if (CGRectContainsPoint(hitRect, convLoc)) {
        if (isLeft) {
            [self flashButton];
            [parentBike turnLeft];
        } else {
            [self flashButton];
            [parentBike turnRight];
        }
    }

    return YES;
}</pre></div><p>We begin by making sure that <code class="literal">myPlayfield</code> does not have the <code class="literal">isTouchBlocked</code> Boolean set to <code class="literal">YES</code>. This is used during the game over routine to prevent rapid touching of the screen from exiting the game screen too fast. Here, we don't want to accept any touches on the buttons if the game is in this state.</p><p>We then convert the touch to OpenGL coordinates so we can determine what we touched. Now we define the <code class="literal">hitRect</code>, using something called <code class="literal">CGRectInset</code>. <code class="literal">CGRectInset</code> is used for transforming a <code class="literal">CGRect</code>. In this case, we are altering the bounding box for our evaluation. <code class="literal">CGRectInset</code> takes three arguments: a <code class="literal">CGRect</code>, the x inset, and the y inset. Using positive values will shrink the <a id="id1372" class="indexterm"/>
<code class="literal">CGRect</code>. Negative values will expand the <code class="literal">CGRect</code>. In our case, we are expanding the y value to effectively <a id="id1373" class="indexterm"/>double the hit zone for the button. We do this because during testing, we determined that the button graphics, while visually satisfying, were a little too small to hit effectively during an exciting game. Rather than make huge buttons, we opted to <a id="id1374" class="indexterm"/>simply expand the hit box. </p><p>We then check to see if the <code class="literal">hitRect</code> contains the touched location. If it does, we then send either the <code class="literal">turnLeft</code> or <code class="literal">turnRight</code> message to the <code class="literal">parentBike</code>.  </p></div><div class="section" title="Flashing with blocks"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec75"/>Flashing with blocks</h2></div></div></div><p>We also call to <a id="id1375" class="indexterm"/>
<code class="literal">flashButton</code> to give visual <a id="id1376" class="indexterm"/>
<a id="id1377" class="indexterm"/>feedback to the users.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1378" class="indexterm"/>
<a id="id1379" class="indexterm"/>
<code class="literal">CLButton.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) flashButton {
    // Tint to the original white color
    CCTintTo *tintA = [CCTintTo actionWithDuration:0.1
                                               red:255 
                                             green:255 
                                              blue:255];
    // Tint back to the original color
    CCCallBlock *tintB = [CCCallBlock actionWithBlock:
                ^{[self setColor:parentBike.wallColor];}];
    // Run these two actions in sequence
    [self runAction:[CCSequence actions: tintA, 
                     tintB, nil]];
}</pre></div><p>Here is the code for the <a id="id1380" class="indexterm"/>
<a id="id1381" class="indexterm"/>
<code class="literal">flashButton</code> method. We use the <code class="literal">CCTintTo</code> action to set the button to its original white color, and immediately set it back, using a <a id="id1382" class="indexterm"/>
<a id="id1383" class="indexterm"/>
<code class="literal">CCCallBlock</code> action. As we haven't really talked about blocks before, now is a good time.</p><p>A block is a self-contained chunk of code that can save a lot of "extra" code, and can use variables internally. Our example here is extremely simple, <a id="id1384" class="indexterm"/>but the syntax might seem foreign. A block is wrapped in a structure like the following:</p><div class="informalexample"><pre class="programlisting"> ^{
[self dosomething];
  }</pre></div><p>There's a lot that can be done with blocks, but here it really saves us from building another method simply to make one call to <code class="literal">setColor</code>. (We could have built a separate method, and called it with <code class="literal">CCCallFunc</code> if we didn't want to use a block).</p><p>It is worth noting that blocks are only available in iOS 4.0 or <a id="id1385" class="indexterm"/>higher, so code meant for older devices cannot use them. To learn about using blocks, we suggest consulting Apple's documentation on the topic at: <a class="ulink" href="http://developer.apple.com/library/ios/#documentation/cocoa/Conceptual/Blocks/Articles/00_Introduction.html">http://developer.apple.com/library/ios/#documentation/cocoa/Conceptual/Blocks/Articles/00_Introduction.html</a>
</p></div><div class="section" title="Finishing the buttons"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec76"/>Finishing the buttons</h2></div></div></div><p>We would be remiss if we didn't also include <a id="id1386" class="indexterm"/>the <code class="literal">onEnter</code>
<a id="id1387" class="indexterm"/>
<a id="id1388" class="indexterm"/> and <a id="id1389" class="indexterm"/>
<a id="id1390" class="indexterm"/>
<code class="literal">onExit</code> methods for the <a id="id1391" class="indexterm"/>
<code class="literal">CLButton</code> class.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1392" class="indexterm"/>
<a id="id1393" class="indexterm"/>
<code class="literal">CLButton.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void)onEnter
{
    [[[CCDirector sharedDirector] touchDispatcher] 
     addTargetedDelegate:self 
     priority:0 
     swallowsTouches:NO];
    
    [super onEnter];
}
-(void)onExit
{
    parentBike = nil;
    myPlayfield = nil;
    
    [[[CCDirector sharedDirector] touchDispatcher] 
     removeDelegate:self];
    
    [super onExit];
}</pre></div><p>We register a delegate with the touch dispatcher in the <code class="literal">onEnter</code> method, and we remove that delegate in the <a id="id1394" class="indexterm"/>
<a id="id1395" class="indexterm"/>
<code class="literal">onExit</code> method. We also set both the <code class="literal">parentBike</code> and <code class="literal">myPlayfield</code> to <code class="literal">nil</code>. It is always important to clean up after yourself. If we <a id="id1396" class="indexterm"/>had failed to remove the delegate, <a id="id1397" class="indexterm"/>this object would never be deallocated, and would leak.</p></div></div>
<div class="section" title="Building the background grid"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec59"/>Building the background grid</h1></div></div></div><p>If we were to leave the background as it is, the game would look rather dull, with a black background. One option would be to simply drop in a background graphic to enhance the look. That would work, but we want to do something more dynamic to give the game some life. We will begin by using <code class="literal">CCRenderTexture</code> to <a id="id1398" class="indexterm"/>build a sprite with a <a id="id1399" class="indexterm"/>grid pattern on it.</p><p>A <a id="id1400" class="indexterm"/>
<a id="id1401" class="indexterm"/>
<code class="literal">CCRenderTexture</code> can be thought of as a second "blank sheet of paper" on which we can draw primitive shapes (like lines), draw sprites upon, and generally do anything visual on it. The power of the <code class="literal">CCRenderTexture</code> is that you can then use the resulting image as a sprite. One of the primary benefits for our project is that we can draw our grid on it once, and use it. If we were to put the <a id="id1402" class="indexterm"/>
<a id="id1403" class="indexterm"/>
<code class="literal">ccDrawLine</code> calls into our main layer's <code class="literal">draw</code> method, it would be drawing them from scratch with every refresh. In our case, we are drawing the lines once, and then using the resulting textured sprite without the additional overhead of redrawing the lines.</p><p>Let's look at the <a id="id1404" class="indexterm"/>
<a id="id1405" class="indexterm"/>
<code class="literal">init</code> method first.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1406" class="indexterm"/>
<a id="id1407" class="indexterm"/>
<code class="literal">CLRenderGrid.m</code>
</p><div class="informalexample"><pre class="programlisting">-(id) init {
    if(self = [super init]) {

        CGSize size = [[CCDirector sharedDirector] winSize];
    
        // create a blank render texture
        firstGrid = [[CCRenderTexture alloc] 
            initWithWidth:700 height:950 
            pixelFormat:kCCTexture2DPixelFormat_RGBA8888];

        // Draw the first grid in a render texture
        [self drawGrid];

        [[firstGrid sprite] setAnchorPoint:ccp(0.5,0.5)];
        [[firstGrid sprite] setPosition:ccp(size.width/2,
                                    size.height/2)];
        [[firstGrid sprite] setOpacity:50];
        
        // Override the default blend
        [[firstGrid sprite] setBlendFunc:
            (ccBlendFunc){GL_SRC_ALPHA,
             GL_ONE_MINUS_SRC_ALPHA}];
        
        [self addChild:firstGrid];
        

        // Second grid

        // Start grids moving

    }
    return self;
}</pre></div><p>We begin by creating <code class="literal">firstGrid</code> as a <code class="literal">CCRenderTexture</code> with the dimensions 700 x 950. This is slightly larger than will be visible, but we want to be able to move it around later without seeing the edges. We will skip the <a id="id1408" class="indexterm"/>
<a id="id1409" class="indexterm"/>
<code class="literal">drawGrid</code> method call for now. We set the anchor point to the center and position the <code class="literal">firstGrid</code> sprite in the center of the layer. It is important to note that to access the sprite properties of the <code class="literal">CCRenderTexture</code>, <a id="id1410" class="indexterm"/>
<a id="id1411" class="indexterm"/>you must specify <code class="literal">[firstGrid sprite] </code>to get to them. The <code class="literal">CCRenderTexture</code> itself does not have these properties. <a id="id1412" class="indexterm"/>We also set our opacity to <code class="literal">50</code>, so the resulting sprite will be semi-transparent.</p><p>The next call, <a id="id1413" class="indexterm"/>
<a id="id1414" class="indexterm"/>
<code class="literal">setBlendFunc</code>, is not often seen in <a id="id1415" class="indexterm"/>tutorials or code samples. The values set here force the sprite to use the "normal" sprite blending function. By default, a <code class="literal">CCRenderTexture</code> uses the blend function <code class="literal">GL_ONE, GL_ONE_MINUS_SRC_ALPHA</code>, which effectively negates any opacity settings used. A tutorial on OpenGL blending functions is beyond the scope of this discussion. For further reading on the topic, a good starting point is: <a class="ulink" href="http://www.khronos.org/opengles/sdk/docs/man/xhtml/glBlendFunc.xml">http://www.khronos.org/opengles/sdk/docs/man/xhtml/glBlendFunc.xml</a>
</p><p>We wrap this up by adding the <code class="literal">firstGrid</code> to the layer. We have two placeholders for code we will add later.</p><div class="section" title="Drawing the grid"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec77"/>Drawing the grid</h2></div></div></div><p>Now we will see how we draw to the render <a id="id1416" class="indexterm"/>
<a id="id1417" class="indexterm"/>texture.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1418" class="indexterm"/>
<a id="id1419" class="indexterm"/>
<code class="literal">CLRenderGrid.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) drawGrid {
    // Start drawing on the Render Texture
    [firstGrid begin];
    
    glLineWidth( 3.0f * CC_CONTENT_SCALE_FACTOR() );
    ccDrawColor4F(1, 1, 1, 1);
    
    float left = 0;
    float right = firstGrid.sprite.textureRect.size.width;
    float top = firstGrid.sprite.textureRect.size.height;
    float bottom = 0;
    float gridSize = 40;
    
    // Draw the vertical lines
    for (float x = left; x &lt;= right; x+=gridSize) {
        ccDrawLine(ccp(x, bottom), ccp(x, top));
    }
    
    // Draw the horizontal lines
    for (float y = bottom; y &lt;= top; y+=gridSize) {
        ccDrawLine(ccp(left, y), ccp(right, y));
    }
    
    // Done drawing on the Render Texture
    [firstGrid end];
    
}</pre></div><p>To begin drawing on the render texture, we make the call to <code class="literal">begin</code>. To stop drawing, we call <code class="literal">end</code>. Everything in the middle is direct OpenGL drawing commands. We set the <code class="literal">glLineWidth</code> <a id="id1420" class="indexterm"/>
<a id="id1421" class="indexterm"/>parameter to set the drawing pen size to 3 points wide. Whenever you are diving into drawing with OpenGL, you must keep in mind it does not have any direct knowledge of the points versus pixels scaling that cocos2d converts for you. Everything is in pixels only. So, to draw a line 3 points wide, we multiply the desired point size by the <code class="literal">CC_CONTENT_SCALE_FACTOR()</code>, which will be 1 for non-Retina devices, and 2 for Retina devices. This will give us the desired effect of a 3 point wide line, regardless of the display capabilities of the device. <a id="id1422" class="indexterm"/>By using this <a id="id1423" class="indexterm"/>scale factor "helper", it also means the code will not fail if we find ourselves using a device with a scale factor of 3 (though it doesn't exist, yet). We then set the drawing color using <code class="literal">ccDrawColor4F()</code>. The values of 1,1,1, and 1 translate to r, g, b, and a values, with all fully "on". This is an opaque white color.</p><p>We set floats to help us keep our code readable. We set the left and bottom to <code class="literal">0</code>, since we want to fill the render texture's space with our drawing. Likewise, we set the right and top to the total width and height (respectively) of the render texture's canvas. By "asking" the <code class="literal">firstGrid.sprite</code> for the size of the texture, it means we can change the size of the render texture in the <code class="literal">init</code> method without adjusting this code at all. We also set the grid size to <code class="literal">40</code> pixels wide. This is a fairly arbitrary number. Smaller numbers create a tighter grid, larger numbers have more open space.</p><p>We then use a <a id="id1424" class="indexterm"/>
<a id="id1425" class="indexterm"/>
<code class="literal">for</code> statement to draw the vertical lines. We loop through the <code class="literal">x</code> values from left to right, based on the floats we set earlier. One callout here is that we are not using the typical <code class="literal">x++</code> as the incrementor. Instead, we are using <code class="literal">x+=gridSize</code> as the incrementor. This controls the size of the "step" between the iterations. Using this means that the first iteration will use a value of 0, the second will be 40, then 80, and so forth. This will be perfectly placed for each line. We use the <a id="id1426" class="indexterm"/>
<a id="id1427" class="indexterm"/>
<code class="literal">ccDrawLine</code> function to draw a line from the bottom of the screen to the top with a constant value of x. This line is drawn every step of the loop, so it will fill the render texture with the vertical lines we need, at a 40 pixel spacing.</p><p>We then do exactly the same thing for the horizontal lines. This time we iterate through values of y, and draw from the left to the right at a constant y value. By the end, we have a perfectly drawn square grid.</p><p>In the interest of good memory management, we must <a id="id1428" class="indexterm"/>remember that we have alloc'd the <code class="literal">firstGrid</code>, <a id="id1429" class="indexterm"/>so we need to dealloc it appropriately.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1430" class="indexterm"/>
<a id="id1431" class="indexterm"/>
<code class="literal">CLRenderGrid.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) dealloc {
    [firstGrid release];

    [super dealloc];
}</pre></div><p>It is important to always release whatever you have retained.</p></div><div class="section" title="The second grid"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec78"/>The second grid</h2></div></div></div><p>We actually want to have two grids to give more visual fluff. We could draw the grid onto another render texture, but that seems a bit silly, since we already have drawn it the way we want it. Instead, we will clone the texture into a new <a id="id1432" class="indexterm"/>sprite. Insert the following code at the "second grid" placeholder.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1433" class="indexterm"/>
<a id="id1434" class="indexterm"/>
<code class="literal">CLRenderTexture.m</code> (inside <code class="literal">init</code> method)</p><div class="informalexample"><pre class="programlisting">        // Second grid
        // Clone the grid as a separate sprite
        secondGrid = [CCSprite spriteWithTexture:
                      [[firstGrid sprite] texture]];
        [secondGrid setAnchorPoint:ccp(0.5,0.5)];
        [secondGrid setPosition:ccp(size.width/2,
                                    size.height/2)];
        [secondGrid setOpacity:60];
        [secondGrid setColor:ccWHITE];
        [self addChild:secondGrid];</pre></div><p>This is very similar to the settings we used for the <code class="literal">firstGrid</code>, except when we instantiate the sprite, we use <code class="literal">spriteWithTexture</code>, and pass it the texture of the sprite contained in the <code class="literal">firstGrid</code> object. This allows us to have a second sprite exactly like the render texture's sprite, but it will only behave as a sprite. This means we will not be able to draw more on the <code class="literal">secondGrid</code> (sprite only), but we could <a id="id1435" class="indexterm"/>draw more on the <code class="literal">firstGrid</code> (<code class="literal">CCRenderTexture</code>).</p></div><div class="section" title="Moving grids"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec79"/>Moving grids</h2></div></div></div><p>Now we have two identical grids on top of each other. <a id="id1436" class="indexterm"/>What we want is to set them both into continuous motion, preferably something we can start and forget about. We will be <a id="id1437" class="indexterm"/>using <a id="id1438" class="indexterm"/>
<a id="id1439" class="indexterm"/>
<code class="literal">CCRepeatForever</code> actions to make it happen.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1440" class="indexterm"/>
<a id="id1441" class="indexterm"/>
<code class="literal">CLRenderGrid.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) moveFirstGrid {
    // Set up actions to shift the grid around
    CCMoveBy *left = [CCMoveBy actionWithDuration:1.0
                            position:ccp(-10,-10)];
    CCMoveBy *right = [CCMoveBy actionWithDuration:1.0
                            position:ccp(20,20)];
    CCMoveBy *back = [CCMoveBy actionWithDuration:1.0
                            position:ccp(-10,-10)];
 
    CCTintBy *tintA = [CCTintBy actionWithDuration:8.0
                        red:255 green:255 blue:0];
    CCTintBy *tintB = [CCTintBy actionWithDuration:4.0
                        red:0 green:255 blue:255];
    
    CCRepeatForever *repeater = [CCRepeatForever 
        actionWithAction:[CCSequence actions:
                          left,
                          right,
                          back, nil]];
    CCRepeatForever *repeater2 = [CCRepeatForever
                                  actionWithAction:
                                  [CCSequence actions:
                                   tintA, tintB, nil]];

    [[firstGrid sprite] runAction:repeater];
    [[firstGrid sprite] runAction:repeater2];    
}</pre></div><p>Here we set up two "sets" of actions. The first set moves the grid around in a perfectly repeating pattern (after all three actions are run, the coordinates are back to where you started). The second set of actions uses the <code class="literal">TintBy</code> action to alter the colors in a slow fading pattern. Looking at the durations, it is a full 12 seconds for a complete cycle of this set of tints. We then wrap both of these sets of actions into a <code class="literal">CCSequence</code> inside a <code class="literal">CCRepeatForever</code> <a id="id1442" class="indexterm"/>
<a id="id1443" class="indexterm"/>action. Because the two sets of actions affect different aspects of the sprite, they can be run simultaneously. We run these both on the <code class="literal">firstGrid</code> sprite.</p><p>We do nearly the same thing on the second grid, although we move the grid in the other diagonal direction, and we tint from black to white, in an 11 second cycle. We run this on the <code class="literal">secondGrid</code>. (Consult the code bundle for this <a id="id1444" class="indexterm"/>book to see the movement code for the <code class="literal">secondGrid</code> sprite.)</p><p>To tie it all together, we insert the following lines into the <a id="id1445" class="indexterm"/>
<code class="literal">init</code> method at the "start grids moving" placeholder.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">CLRenderGrid.m</code> (inside <a id="id1446" class="indexterm"/>
<a id="id1447" class="indexterm"/>
<code class="literal">init</code> method)</p><div class="informalexample"><pre class="programlisting">        // Start grids moving
        [self moveFirstGrid];
        [self moveSecondGrid];</pre></div></div><div class="section" title="The glScissor"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec80"/>The glScissor</h2></div></div></div><p>We have one problem remaining. The grid is <a id="id1448" class="indexterm"/>larger than the part of the screen we want to draw it in. Ideally, we want the grid to move <a id="id1449" class="indexterm"/>around, but only be visible inside the yellow outer walls. Using the OpenGL <code class="literal">glScissor</code> is exactly what we need. Like its name suggests, the <code class="literal">glScissor</code> is used to clip an image from being visible. Here, we want to trim the visible graphics for this entire layer at the yellow line.</p><p>The following screenshot shows a before and after comparison:</p><div class="mediaobject"><img src="graphics/9007_06_04.jpg" alt="The glScissor"/></div><p>As you may have noticed, the <code class="literal">CLRenderGrid</code> is a subclass of <code class="literal">CCLayer</code>, so we have the same coordinate space for the layer that we do for the main grid. We can easily use <code class="literal">glScissor</code> to fix the problem.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1450" class="indexterm"/>
<a id="id1451" class="indexterm"/>
<code class="literal">CLRenderGrid.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) visit {
    // We use the glScissor to clip the edges
    // So we can shift stuff around in here, but not
    // go outside our boundaries
    glEnable(GL_SCISSOR_TEST);
    glScissor(59 * CC_CONTENT_SCALE_FACTOR(),
              62 * CC_CONTENT_SCALE_FACTOR(),
              650 * CC_CONTENT_SCALE_FACTOR(),
              900 * CC_CONTENT_SCALE_FACTOR());
    [super visit];
   glDisable(GL_SCISSOR_TEST);
}</pre></div><p>Here we use the same coordinates we used for drawing the outer walls in the main playfield layer. As we said earlier, OpenGL is not <a id="id1452" class="indexterm"/>aware of the scale of the device, so we multiply each value by the <code class="literal">CC_CONTENT_SCALE_FACTOR()</code>. This will give the same clipping boundaries in Retina and non-Retina devices.</p></div></div>
<div class="section" title="The playfield"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec60"/>The playfield</h1></div></div></div><p>We have assembled most of the "external" components, so it is time to turn our attention to the <code class="literal">CLPlayfieldLayer</code> class itself. <a id="id1453" class="indexterm"/>Let's dive into the class instantiation and <code class="literal">init</code> methods <a id="id1454" class="indexterm"/>first.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1455" class="indexterm"/>
<a id="id1456" class="indexterm"/>
<code class="literal">CLPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">+(id) gameWithRemoteGame:(BOOL)isRemoteGame {
    return [[[self alloc] initWithRemoteGame:isRemoteGame] autorelease];
}

-(id) initWithRemoteGame:(BOOL)isRemoteGame {
    if(self = [super init]) {

        size = [[CCDirector sharedDirector] winSize];
        
        // Load the spritesheet
        [[CCSpriteFrameCache sharedSpriteFrameCache]
           addSpriteFramesWithFile:@"cyclesheet.plist"];
        cyclesheet = [CCSpriteBatchNode
           batchNodeWithFile:@"cyclesheet.png"];
        
        // Add the batch node to the layer
        [self addChild:cyclesheet z:1];
        
        bikeWalls = [[NSMutableArray alloc] init];
        remoteGame = isRemoteGame;
        isGameOver = NO;
        isTouchBlocked = NO;
        // Build the background grid
        CCNode *grid = [CLRenderGrid node];
        [self addChild:grid z:-1];
        
        // Build the outer walls
        [self createOuterWalls];
        
    }
    return self;
}</pre></div><p>We use another convenience method here, this time only accepting one parameter, <code class="literal">isRemoteGame</code>. For a local only game this will be <code class="literal">NO</code>, and <code class="literal">YES</code> if it is a Bluetooth game. </p><p>The <a id="id1457" class="indexterm"/>
<a id="id1458" class="indexterm"/>
<code class="literal">initWithRemoteGame</code> method is fairly basic. We set up our <code class="literal">cyclesheet</code> batch node, establish the <a id="id1459" class="indexterm"/>
<a id="id1460" class="indexterm"/>
<code class="literal">bikeWalls</code> array, and set a few Boolean values. We also add our <code class="literal">CLRenderGrid</code> as a child with a Z order of <code class="literal">-1</code>, to keep it behind the rest of the game. Then we add our outer walls, and that's it.</p><p>We put the actual bike building calls in the <code class="literal">onEnterTransitionDidFinish</code> method. We do this because if we choose to use a transition to enter the <a id="id1461" class="indexterm"/>scene, we don't want the game starting <a id="id1462" class="indexterm"/>up before the transition is complete.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">CLPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) onEnterTransitionDidFinish {
    if (remoteGame) {
        // Remote Game
        [self findPeer:self];
    } else {
        // Initial Player Setup
        [self generateRedAsPlayerNo:1 isRemote:NO];
        [self generateBlueAsPlayerNo:2 isRemote:NO];
        [self scheduleUpdate]; 
    }
    [super onEnterTransitionDidFinish];
}</pre></div><p>We have left a small piece of the remote game code here, so you can see the difference in how we set up the start of the game. For a local game only, we set up <a id="id1463" class="indexterm"/>both players, and schedule the update. We will look at the "generate" methods next.</p><div class="section" title="Generating the bikes"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec81"/>Generating the bikes</h2></div></div></div><p>Adding the player bikes and buttons to the playfield is trivial here, since we have done most of the work in the <a id="id1464" class="indexterm"/>
<a id="id1465" class="indexterm"/>
<code class="literal">CLBike</code> and <a id="id1466" class="indexterm"/>
<a id="id1467" class="indexterm"/>
<code class="literal">CLButton</code> classes. We use <a id="id1468" class="indexterm"/>nearly identical methods for the red and blue bikes, <a id="id1469" class="indexterm"/>so we will only include one here.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">CLPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) generateRedAsPlayerNo:(NSInteger)playerNo
                     isRemote:(BOOL)remotePlayer {
    // Generate the red player's bike
    redBike = [CLBike bikeForPlayer:kRedPlayer 
                           PlayerNo:playerNo 
                            onLayer:self 
                           isRemote:remotePlayer];
    [cyclesheet addChild:redBike];
    
    // Only create buttons for the local player
    if (remotePlayer == NO) {
        
        CLButton *right = [CLButton 
                           buttonForBike:redBike
                           asPlayerNo:playerNo
                           isLeft:NO 
                           onLayer:self];
        [cyclesheet addChild:right];
        
        CLButton *left = [CLButton 
                          buttonForBike:redBike
                          asPlayerNo:playerNo
                          isLeft:YES
                          onLayer:self];
        [cyclesheet addChild:left];
    }
}</pre></div><p>Here we instantiate a new <code class="literal">redBike</code>, specifying that it belongs to <code class="literal">kRedPlayer</code>, and we add it to the sheet. We then check if this is a <code class="literal">remotePlayer</code>. If it is not, then we also build the right and left buttons for the player. (Remote players do not need to have buttons drawn for this device). You will notice that we do not retain a reference to the buttons we create. The buttons need to know about the layer (as we saw earlier), and they need to know about the bike they are controlling, but the layer doesn't need to do anything special with the buttons except to add them as children of the layer. They are self-sufficient, so we can build them and ignore them here.</p><p>The <a id="id1470" class="indexterm"/>
<a id="id1471" class="indexterm"/>
<code class="literal">generateBlueAsPlayerNo:isRemote:</code> method is nearly identical, except the initial bike creation is instantiated as <code class="literal">blueBike</code>, with <code class="literal">kBluePlayer</code> as the parameter. As we discussed in the <code class="literal">CLBike</code> class earlier, we could <a id="id1472" class="indexterm"/>probably collapse this into a single <a id="id1473" class="indexterm"/>method, but separate methods like this are easier to follow.</p></div><div class="section" title="Collision handling"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec82"/>Collision handling</h2></div></div></div><p>When it comes to collision handling, we have already put all of the pieces into place to make collisions easy to check for. We have all <a id="id1474" class="indexterm"/>walls in the <a id="id1475" class="indexterm"/>game stored in the <code class="literal">bikeWalls</code> array. Each bike keeps track of both the <code class="literal">currentWall</code> and <a id="id1476" class="indexterm"/>
<a id="id1477" class="indexterm"/>
<code class="literal">priorWall</code> objects created by that bike. This is all we need to do to check for all possible collisions.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1478" class="indexterm"/>
<a id="id1479" class="indexterm"/>
<code class="literal">CLPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) checkForCollisions {
    for (CCSprite *aWall in bikeWalls) {
        // Compare wall to blue bike
        if (CGRectIntersectsRect([aWall boundingBox],
                                 [blueBike boundingBox]) 
            &amp;&amp; aWall != blueBike.currentWall 
            &amp;&amp; aWall != blueBike.priorWall) {
                  [self crashForBike:blueBike];
            break;
        }  
        //Compare wall to red bike
        if (CGRectIntersectsRect([aWall boundingBox], 
                                 [redBike boundingBox]) 
            &amp;&amp; aWall != redBike.currentWall 
            &amp;&amp; aWall != redBike.priorWall) {
                  [self crashForBike:redBike];
            break;
        }
        
    }
}</pre></div><p>When we check for collisions, we iterate through all the wall sprites in the <code class="literal">bikeWalls</code> array. We first check for the <code class="literal">blueBike</code>. If its <code class="literal">boundingBox</code> intersects with the wall and the wall is not the <code class="literal">currentWall </code>or <code class="literal">priorWall</code> of the<code class="literal"> blueBike</code>, then that bike crashed. We do the same check for the <code class="literal">redBike</code>, this time making sure it is not the <code class="literal">currentWall</code> or <code class="literal">priorWall</code> of the <code class="literal">redBike</code>. The question is probably coming to mind: why two walls for each bike? Isn't tracking the <code class="literal">currentWall</code> object enough? </p><p>When a bike turns, it turns at an abrupt right angle. <a id="id1480" class="indexterm"/>The ending of the <code class="literal">priorWall</code> is at exactly the same point as the origin of the new <code class="literal">currentWall</code>. For a single update cycle, the bike is on this exact point. If we don't track the <code class="literal">priorWall</code>, then the bike will <a id="id1481" class="indexterm"/>crash on that point. As there is no way the bike can correctly crash into the <code class="literal">priorWall</code>, we can safely ignore any collisions with it.</p></div><div class="section" title="Making it move"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec83"/>Making it move</h2></div></div></div><p>We use a very simple <a id="id1482" class="indexterm"/>
<code class="literal">update</code> method, <a id="id1483" class="indexterm"/>which actually passes most of the control to the bikes themselves.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">CLPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) update:(ccTime)dt {
    // We only use the move method if this is a local
    // player.  We move the opponent via the data 
    // connection
    if (![redBike isRemotePlayer]) {
        [redBike move];
    }

    if (![blueBike isRemotePlayer]) {
        [blueBike move];
    }

    [self checkForCollisions];
}</pre></div><p>If the player is not a remote player, we tell the bike to move, using the <code class="literal">move</code> method we saw earlier. (In case you're wondering, we will handle the remote player's moves more explicitly). We then check for collisions after every move.</p></div><div class="section" title="Crashing bikes"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec84"/>Crashing bikes</h2></div></div></div><p>Now we will look at what happens when a bike <a id="id1484" class="indexterm"/>crashes. We want a little visual flair, <a id="id1485" class="indexterm"/>so we will put the actual "crash" code in the <code class="literal">CLBike</code> class, but the core handler is in the <a id="id1486" class="indexterm"/>
<a id="id1487" class="indexterm"/>
<code class="literal">CLPlayfieldLayer</code> class, because the entire game needs to know about the crash, not just the bike.</p><p>
<span class="strong"><strong>Filename:</strong></span> <code class="literal">CLPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) crashForBike:(CLBike*)thisBike {
    [self unscheduleUpdate];

    // The bike crash sequence
    [thisBike crash];
    
    // Prevent all touches for now
    isTouchBlocked = YES;
    
    // Identify game over
    isGameOver = YES;

    // Game over sequence
    [self displayGameOver];
}</pre></div><p>We unscheduled the <code class="literal">update</code> method, told the bike that it crashed, and set a couple of<code class="literal"> </code>Boolean values. We used the <a id="id1488" class="indexterm"/>
<a id="id1489" class="indexterm"/>
<code class="literal">isTouchesBlocked</code> variable to prevent the player from rapidly mashing buttons and exiting the game without seeing the results. Players need a little time to enjoy their victory, or ponder their defeat. <a id="id1490" class="indexterm"/>We will not cover the <a id="id1491" class="indexterm"/>
<a id="id1492" class="indexterm"/>
<code class="literal">displayGameOver</code> method in the book. Please consult the source code for that method. (It is a fairly basic "Red Player Wins!" label, not much more than that.)</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1493" class="indexterm"/>
<a id="id1494" class="indexterm"/>
<code class="literal">CLBike.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) crash {
    self.isCrashed = YES;
    
    [glow removeFromParentAndCleanup:NO];
    
    CCScaleTo *scale = [CCScaleTo actionWithDuration:0.5
                                               scale:2];
    CCFadeOut *fade = [CCFadeOut actionWithDuration:1.0];
    
    [self runAction:[CCSequence actions:scale, fade, nil]];
}</pre></div><p>Here we see the <a id="id1495" class="indexterm"/>
<a id="id1496" class="indexterm"/>
<code class="literal">crash</code> method. We remove the glow image, scale the sprite up to be really big, and then quickly fade it out. We also set the <code class="literal">isCrashed</code> variable to <a id="id1497" class="indexterm"/>
<code class="literal">YES</code>, which is used in the <code class="literal">displayGameOver</code> <a id="id1498" class="indexterm"/>
<a id="id1499" class="indexterm"/>method to determine who won and who lost.</p></div></div>
<div class="section" title="Bluetooth multiplayer"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec61"/>Bluetooth multiplayer</h1></div></div></div><p>We now have a complete two-player game on the same iPad. Now we will turn our attention to using GameKit to create a local Bluetooth game between two iPads. A word of caution to begin this discussion: this does not work correctly on the simulator, so you must have two iPads (any generation will do) in <a id="id1500" class="indexterm"/>order to test this code.</p><p>To get the game prepared for using GameKit, we need to make sure the <code class="literal">GameKit.framework</code> is included in our project. You can check this by selecting your target project, and selecting the "Build Phases" heading. <a id="id1501" class="indexterm"/>Then, expand the <span class="strong"><strong>Link Binary With Libraries</strong></span> tab, and see if it is listed. If it is not, click on the <span class="strong"><strong>+</strong></span> button at the bottom of the section, and select <code class="literal">GameKit.framework</code>.</p><p>In Xcode, it looks like the following screenshot:</p><div class="mediaobject"><img src="graphics/9007_06_05.jpg" alt="Bluetooth multiplayer"/></div><p>We also need to make a couple of additions to the <code class="literal">CLPlayfieldLayer.h</code> file to include the GameKit.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1502" class="indexterm"/>
<a id="id1503" class="indexterm"/>
<code class="literal">CLPlayfieldLayer.h</code> (partial)</p><div class="informalexample"><pre class="programlisting">#import &lt;GameKit/GameKit.h&gt;

@interface CLPlayfieldLayer : CCLayer &lt;GKPeerPickerControllerDelegate, GKSessionDelegate&gt; {</pre></div><p>As you can see, we have imported GameKit with the "framework style" angle brackets, and we have declared two delegate types for our <a id="id1504" class="indexterm"/>
<a id="id1505" class="indexterm"/>
<code class="literal">CLPlayfieldLayer</code> class. This will let us receive the callbacks from GameKit.</p><p>We also need a few specific variables in the header.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1506" class="indexterm"/>
<a id="id1507" class="indexterm"/>
<code class="literal">CLPlayfieldLayer.h</code> (partial):</p><div class="informalexample"><pre class="programlisting">     // GameKit specific variables
    GKPeerPickerController *gkPicker; // Peer Picker
    GKSession *gkSession; // The session
    NSString *gamePeerId; // Identifier from peer
    NSInteger playerNumber; // To assign bike colors
    GKPeerConnectionState currentState;</pre></div><p>The first three are needed by GameKit itself, and the <code class="literal">playerNumber</code> is a variable that we will be using to handle the issue of which player gets which color bike. The <code class="literal">currentState</code> is our own variable that we will be using to <a id="id1508" class="indexterm"/>handle refused connections.</p><div class="section" title="Peer Picker"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec85"/>Peer Picker</h2></div></div></div><p>We will be using the default Peer Picker that comes as part of GameKit. This is a full GUI interface for finding players and making the connection between the devices. This GUI is called the <span class="strong"><strong>Peer Picker</strong></span>. <a id="id1509" class="indexterm"/>
<a id="id1510" class="indexterm"/>There are quite a few callbacks that are needed, so don't be put off by the amount of code we are about to see. Most of it is boilerplate and can be re-used with little, if any, modifications in other projects.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1511" class="indexterm"/>
<a id="id1512" class="indexterm"/>
<code class="literal">CLPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) findPeer:(id)sender {
    //Initialize and show the picker
    gkPicker = [[GKPeerPickerController alloc] init];
    gkPicker.delegate = self;
    gkPicker.connectionTypesMask = 
                GKPeerPickerConnectionTypeNearby;
    [gkPicker show];
    
    playerNumber = 1;
}</pre></div><p>We begin by creating the <code class="literal">GKPeerPickerController</code>, setting its delegate, and specifying the connection mask. The <a id="id1513" class="indexterm"/>
<a id="id1514" class="indexterm"/>
<code class="literal">connectionTypesMask</code> property controls what types of connections are considered when looking for a game. The value we have specified, <code class="literal">GKPeerPickerConnectionTypeNearby</code>, limits the Peer Picker to local Bluetooth connections only. We also set the starting <code class="literal">playerNumber</code> to be 1. For the purposes of this game, player no. 1 is the red player, and player no. 2 is the blue player.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1515" class="indexterm"/>
<a id="id1516" class="indexterm"/>
<code class="literal">CLPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(GKSession*) peerPickerController:(GKPeerPickerController*)picker 
sessionForConnectionType:(GKPeerPickerConnectionType)type {
     gkSession = [[GKSession alloc] 
             initWithSessionID:@"Ch6_Cycles"
             displayName:nil 
             sessionMode:GKSessionModePeer];
             gkSession.delegate = self;
             return gkSession;
}</pre></div><p>Here we establish the <code class="literal">GKSession</code> for the connection. We limit the available connections even further by specifying the <code class="literal">SessionID</code>. In our case, it is <code class="literal">"Ch6_Cycles"</code>, which is the way our game identifies itself. This <code class="literal">SessionID</code> must match between the devices, or they will not be able to "see" each other. This does mean that both players must have the game running at the same time in order to attempt to connect with each other.</p><p>We also set the <code class="literal">sessionMode</code> to be <code class="literal">GKSessionModePeer</code>. There are three types of sessions: client, server, and peer. A <a id="id1517" class="indexterm"/>
<a id="id1518" class="indexterm"/>
<span class="strong"><strong>peer</strong></span> is essentially a client and server at the same time. This means it can initiate connections to a server (or another peer), or it can receive connections from a client (or another peer). In most cases, you would want to set this to peer, so you can send and receive connection requests.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1519" class="indexterm"/>
<a id="id1520" class="indexterm"/>
<code class="literal">CLPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) peerPickerController:(GKPeerPickerController*)picker
              didConnectPeer:(NSString*)peerID 
                   toSession:(GKSession*)currSession {
    // Dismiss the peerPicker
    [gkSession setDataReceiveHandler:self
                         withContext:NULL];
    [gkPicker dismiss];
    gkPicker.delegate = nil;
    [gkPicker autorelease];
    
    //Set the other player's ID
    gamePeerId = peerID;
}</pre></div><p>This callback will be called when a connection to a peer is made. It will configure the <code class="literal">gkSession</code> that was created in the previous method to identify the receiver of the data (self, in our case). We also dismiss the <code class="literal">gkPicker</code>, since we are done picking our opponent. Finally, we store the <code class="literal">peerID</code> in the <code class="literal">gamePeerId</code> variable. This <code class="literal">peerID</code> is how the devices identify themselves. We store this because we will need it when we want to send messages to the other player.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">CLPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) peerPickerControllerDidCancel: (GKPeerPickerController*)picker
{
    //User cancelled.  Release the delegate.
    picker.delegate = nil;
    [picker autorelease];

    // If there is a session, cancel it
    if(gkSession != nil) {
        [self invalidateSession:gkSession];
        gkSession = nil;
    }

    // Return to the main menu
    [self returnToMainMenu];
}</pre></div><p>The final callback we need for the Peer Picker is the <code class="literal">peerPickerControllerDidCancel</code> <a id="id1521" class="indexterm"/>
<a id="id1522" class="indexterm"/>method. This is called if, at any point while the Peer Picker was active, the user clicked on <span class="strong"><strong>Cancel</strong></span>. In this method, we release the delegate and invalidate (get rid of) the session that was created. <a id="id1523" class="indexterm"/>The <code class="literal">invalidateSession</code> <a id="id1524" class="indexterm"/>
<a id="id1525" class="indexterm"/>method will be covered shortly. We also added our own behavior, the call to the <a id="id1526" class="indexterm"/>
<a id="id1527" class="indexterm"/>
<code class="literal">returnToMainMenu</code> method.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1528" class="indexterm"/>
<code class="literal">CLPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) returnToMainMenu {
    // If there is a GameKit Session, invalidate it
    if(gkSession != nil) {
        [self invalidateSession:gkSession];
        gkSession = nil;
    }
    
    [[CCDirector sharedDirector] 
             replaceScene:[CLMenuScene node]];
}</pre></div><p>The <a id="id1529" class="indexterm"/>
<a id="id1530" class="indexterm"/>
<code class="literal">returnToMainMenu</code> method checks to see if we have a <code class="literal">gkSession</code>, and will invalidate the session if needed. We then call the <a id="id1531" class="indexterm"/>
<a id="id1532" class="indexterm"/>
<code class="literal">replaceScene</code> method to go back to the menu scene.</p><p>The following screenshot gives an example of what the Peer Picker GUI looks like: </p><div class="mediaobject"><img src="graphics/9007_06_06.jpg" alt="Peer Picker"/></div></div><div class="section" title="Session callbacks"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec86"/>Session callbacks</h2></div></div></div><p>Now we will look at the session delegate callback methods. <a id="id1533" class="indexterm"/>These callbacks will be triggered based on the current state of the <code class="literal">gkSession</code> we created with the Peer Picker. There are a <a id="id1534" class="indexterm"/>few smaller methods that we will examine first.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">CLPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) session:(GKSession*)session 
didReceiveConnectionRequestFromPeer:(NSString*)peerI {
    //We are player 2 (blue)
    playerNumber = 2;
}</pre></div><p>This method is called when the game receives a connection request from a peer. This means that the other player is taking the role of client, and the current device is being asked to take the role of the server. We made the design decision that the client is always red, and the server is always blue. Since this request makes us the server, we change the <code class="literal">playerNumber</code> variable to <a id="id1535" class="indexterm"/>
<a id="id1536" class="indexterm"/>2 to identify this device as the blue player. Since this method will only be called by one of the two devices, we can be certain the other player is red.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1537" class="indexterm"/>
<code class="literal">CLPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) session:(GKSession*)session 
     connectionWithPeerFailed:(NSString*)peerID 
                    withError:(NSError*)error {
    // Connection Failed
    [gkPicker dismiss];
    gkPicker.delegate = nil;
    [gkPicker autorelease];

    [self returnToMainMenu];
}

-(void) session:(GKSession*)session 
                didFailWithError:(NSError*)error {
    // Connection Failed
    [gkPicker dismiss];
    gkPicker.delegate = nil;
    [gkPicker autorelease];
    
    [self returnToMainMenu];
}</pre></div><p>These two methods are called when there is a connection error. There's nothing we can do, so we have both methods dismiss the Peer Picker, and <a id="id1538" class="indexterm"/>return the player to the main menu.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">CLPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) invalidateSession:(GKSession*)session {
    if(session != nil) {
        [session disconnectFromAllPeers];
        session.available = NO;
        [session setDataReceiveHandler: nil 
                           withContext: NULL];
        session.delegate = nil;
        [session autorelease];
        session = nil;
    }
}</pre></div><p>This method is called when we need to abandon the session. As we saw earlier, this will be called when the user cancels out of the Peer Picker. If the session exists, it disconnects from all peers, marks itself unavailable, removes all delegates, and <a id="id1539" class="indexterm"/>gets rid of the session.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">CLPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) session:(GKSession*)session peer:(NSString*)peerID 
          didChangeState:(GKPeerConnectionState)state {
    if (currentState == GKPeerStateConnecting &amp;&amp;
        state != GKPeerStateConnected) {
          // Reset the player number
          playerNumber = 1;
    } else if(state == GKPeerStateConnected){
         //We have now connected to a peer
        if (playerNumber == 2) {
            // We are the server, blue player
            [self generateRedAsPlayerNo:2 isRemote:YES];
            [self generateBlueAsPlayerNo:1 isRemote:NO];
        } else {
            // We are the client, red player
            [self generateRedAsPlayerNo:1 isRemote:NO];
            [self generateBlueAsPlayerNo:2 isRemote:YES]; 
        }
        // Start the game
        [self scheduleUpdate];    
  } else if(state == GKPeerStateDisconnected) {
      // We were disconnected
      [self unscheduleUpdate];
      // User alert
      NSString *msg = [NSString stringWithFormat:
                         @"Lost device %@.", 
                    [session displayNameForPeer:peerID]];
      UIAlertView *alert = [[UIAlertView alloc] 
                        initWithTitle:@"Lost Connection" 
                        message:msg delegate:self 
                        cancelButtonTitle:@"Game Aborted" 
                        otherButtonTitles:nil];
      [alert show];
      [alert release];
        
      [self returnToMainMenu];
  }
    // Keep the current state
    currentState = state;
}</pre></div><p>This method is called whenever the session's state changes. We begin by checking for one specific condition. When PeerPicker receives a request, the device that would be the server will be presented with the option to accept or decline the connection. We need to identify if the user pressed the "Decline" button. We check to see if the <code class="literal">currentState</code> (which is set at the bottom of this method, now holding the value from the last call to this method) is <code class="literal">GKPeerStateConnecting</code>, and the new state (the state variable) is not <code class="literal">GKPeerStateConnected</code>, then we reset the <code class="literal">playerNumber</code>. Why do we do this? When the connection request is first received, the <code class="literal">session:didReceiveConnectionRequestFromPeer:</code> method <a id="id1540" class="indexterm"/>
<a id="id1541" class="indexterm"/>was called. As we saw earlier, that sets the <code class="literal">playerNumber</code> to 2. As there is no callback received when the "Decline" button is pressed in the PeerPicker, this is the only way we can trap this situation, so we can "undo" the <code class="literal">playerNumber</code> being set to 2. Why do we care? If we do not have this trap in place, here is a scenario that can happen:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Device 1 requests connection to Device 2. (Device 2 is now PlayerNumber 2)</li><li class="listitem" style="list-style-type: disc">Device 2 declines the connection.</li><li class="listitem" style="list-style-type: disc">Device 2 requests connection to Device 1. (Device 1 is now PlayerNumber 2)</li><li class="listitem" style="list-style-type: disc">Device 1 accepts the connection.</li><li class="listitem" style="list-style-type: disc">Game starts, and both players are BLUE, and think their opponent is RED.</li></ul></div><p>By trapping the "Decline" condition, we can avoid this undesirable situation.</p><p>There are two standard states we need to handle: <code class="literal">GKPeerStateConnected</code> and <code class="literal">GKPeerStateDisconnected</code>. If the game is connected, we check which <code class="literal">playerNumber</code> we are. If this is <code class="literal">playerNumber</code> 2 (server) we set up the bikes correctly for this side of the game. The remote player is red, starting at the top of the device (remember, that is what the <code class="literal">AsPlayerNo:2</code> represents), and we specify that this is a remote player, which means there will be no control buttons created. The <a id="id1542" class="indexterm"/>local player is blue, in position 1 (bottom of iPad), with control buttons created.</p><p>If this is <code class="literal">playerNumber</code> 1 (client) then we do everything backwards. The local player is red with buttons, the remote player is blue, without buttons.</p><p>We then schedule the update method, and the game is on!</p><p>If the state is changed to <code class="literal">GKPeerStateDisconnected</code>, we unschedule the update (in case the game was running when disconnected), and we create a <code class="literal">UIAlert</code> object to inform the player that they lost their connection.</p></div><div class="section" title="Sending messages"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec87"/>Sending messages</h2></div></div></div><p>So we have a connection. Now what? We need to be able to send messages to the remote device, and accept messages from the remote device. We have determined we only need to send two types of data: move distance and turn direction. We will never send "real" data for both at the same time, so we will need to parse out the <a id="id1543" class="indexterm"/>
<a id="id1544" class="indexterm"/>messages and take appropriate action. Let's look at the data sending method first.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1545" class="indexterm"/>
<code class="literal">CLPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) sendDataWithDirection:(Direction)dir 
                   orDistance:(float)dist {

    //Pack data
    NSMutableData *dataToSend = [[NSMutableData alloc] init];
    NSKeyedArchiver *archiver = [[NSKeyedArchiver alloc]
                initForWritingWithMutableData:dataToSend];

    [archiver encodeInt:dir forKey:@"direction"];
    [archiver encodeFloat:dist forKey:@"distance"];
    
    [archiver finishEncoding];
    
    // Send the data, reliably
        [gkSession sendData:dataToSend toPeers:
         [NSArray arrayWithObject:gamePeerId] 
               withDataMode:GKSendDataReliable
                      error:nil];

    [archiver release];
    [dataToSend release];
}</pre></div><p>Here we pass the turn direction, <code class="literal">dir</code>, and the distance travelled, <code class="literal">dist</code>. We create an <code class="literal">NSMutableData</code> object and wrap that in an <code class="literal">NSKeyedArchiver</code>. We encode both variables with explicitly named keys, and we send the data via the <code class="literal">gkSession</code>. In the <code class="literal">sendData</code> method, you see that we are using the <code class="literal">gamePeerId</code> we stored earlier, and we are also sending the data in a mode called <a id="id1546" class="indexterm"/>
<a id="id1547" class="indexterm"/>
<code class="literal">GKSendDataReliable</code>. When you send data, you can either send it reliably or unreliably. The difference is that reliable packets must arrive and be processed in order. Unreliable data gives no guarantee of when it will be delivered, nor in which order the messages will be <a id="id1548" class="indexterm"/>received and processed. <a id="id1549" class="indexterm"/>Since we definitely need our data to arrive in order, on time, we send this reliably.</p></div><div class="section" title="Receiving data"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec88"/>Receiving data</h2></div></div></div><p>Now let's see how to receive and process the data when <a id="id1550" class="indexterm"/>we receive it.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">CLPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) receiveData:(NSData*)data fromPeer:(NSString*)peer
          inSession:(GKSession*)session context:(void*)context {

    NSKeyedUnarchiver *unarchiver = [[NSKeyedUnarchiver 
                    alloc] initForReadingWithData:data];

    Direction dir = [unarchiver 
                     decodeIntForKey:@"direction"];
    NSInteger dist = [unarchiver 
                      decodeFloatForKey:@"distance"];

    // Determine which bike to use, hold in whichBike 
    CLBike *whichBike = ((playerNumber == 1)? blueBike:
                         redBike);
    
    // Process the data
    if (dir == kNoChange) {
        // This was a move forward packet
        [whichBike moveForDistance:dist];
    } else if (dir == kLeft) {
        // This is a turn left packet
        [whichBike turnLeft];
    } else if (dir == kRight) {
        // This is a turn right packet
        [whichBike turnRight];
    }
}</pre></div><p>When we receive data, we create an <a id="id1551" class="indexterm"/>
<a id="id1552" class="indexterm"/>
<code class="literal">NSKeyedUnarchiver</code> to interface with the data received. We decode both variables, and store them in local variables <code class="literal">dir</code> and <code class="literal">dist</code> (we use the same names in both methods to avoid confusion). We then check to see which player is local to this device. If the local player is number 1, then the messages we are receiving must be for the blue bike. Otherwise, they would be the red bike. We create <code class="literal">whichBike</code>, which will point to whichever bike we have determined should be moved. Then, we check to see if the direction is <code class="literal">kNoChange</code>. If <a id="id1553" class="indexterm"/>it is, then <a id="id1554" class="indexterm"/>this is a movement packet, so we call to the <code class="literal">moveForDistance </code>method for <code class="literal">whichBike</code>, and pass it the value of <code class="literal">dist</code>. This will explicitly move the remote player's bike on the local game. We then check to see if the direction was <code class="literal">kLeft</code> or <code class="literal">kRight</code>. For each, we call to the bike's <code class="literal">turnLeft</code> or <code class="literal">turnRight</code> method, as needed.</p></div><div class="section" title="Upgrading our bikes"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec89"/>Upgrading our bikes</h2></div></div></div><p>The <code class="literal">receiveData</code> <a id="id1555" class="indexterm"/>
<a id="id1556" class="indexterm"/>method we just reviewed will <a id="id1557" class="indexterm"/>handle everything we need in how to handle moving the remote bike on the local device. <a id="id1558" class="indexterm"/>Now we need to upgrade our <a id="id1559" class="indexterm"/>
<a id="id1560" class="indexterm"/>
<code class="literal">CLBike</code> class to be able to send the appropriate messages to the remote device.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">CLBike.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) sendPacketForMove:(float)distance {
    // We only send a packet if we are playing a remote
    // game, and this bike is the LOCAL player
    if (myPlayfield.remoteGame &amp;&amp; self.isRemotePlayer == NO) {
        [myPlayfield sendDataWithDirection:kNoChange
                                orDistance:distance];
    }
}</pre></div><p>In this method, we check to make sure we are playing a remote game, and that this bike does not belong to a remote player. If both of these conditions pass, we call to the <code class="literal">sendData</code> method in the <code class="literal">CLPlayfieldLayer</code>, and pass it the <code class="literal">distance</code> argument. We also pass the direction as <code class="literal">kNoChange</code>, so we know there is no <a id="id1561" class="indexterm"/>turn included in this message. So what calls this method? In the <a id="id1562" class="indexterm"/>
<a id="id1563" class="indexterm"/>
<code class="literal">move</code> method of the <code class="literal">CLBike</code> class, we left a placeholder "remote game". Let's fill that in now.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1564" class="indexterm"/>
<a id="id1565" class="indexterm"/>
<code class="literal">CLBike.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) move {
    // Move this bike (if local player)
    [self moveForDistance:self.bikeSpeed];
    
    // Remote game
    [self sendPacketForMove:self.bikeSpeed];
}</pre></div><p>As you recall from the <code class="literal">update</code> method in the <a id="id1566" class="indexterm"/>
<a id="id1567" class="indexterm"/>
<code class="literal">CLPlayfieldLayer</code> class, we only call <code class="literal">move</code> if the bike is a local player. So the local player's bike will move itself (locally) and then send the message for the other device to move this bike on the other device. This is the reason we separated the <code class="literal">move</code> method from the <code class="literal">moveForDistance</code> method. The remote player's moves are processed directly through the <code class="literal">moveForDistance</code> method, so we will not re-send the remote player's moves back to this <a id="id1568" class="indexterm"/>player's device.</p><p>We follow a similar approach for the turn commands. First we build a similar send method for turns.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">CLBike.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) sendPacketForTurn:(Direction)turnDir {
    // We only send a packet if we are playing a remote
    // game, and this bike is the LOCAL player
    if (myPlayfield.remoteGame &amp;&amp; self.isRemotePlayer == NO) {
        [myPlayfield sendDataWithDirection:turnDir
                                orDistance:0];
    }
}</pre></div><p>Just as we did with the <a id="id1569" class="indexterm"/>
<a id="id1570" class="indexterm"/>
<code class="literal">sendPacketForMove</code> method earlier, we make sure this is a remote game and that the bike does not belong to a remote player. We then send the <code class="literal">turnDir</code> argument with a <code class="literal">distance</code> of <code class="literal">0</code>. As we saw with the <code class="literal">receiveData</code> method, the turns will be processed first, so it actually doesn't matter what value we send for distance, but it is a good idea to fill in default values to avoid unintended consequences of unexpected data.</p><p>To call this method, we insert code into the end of the <code class="literal">turnRight</code> and <code class="literal">turnLeft</code> methods we discussed earlier. In both methods, we insert the new code at the "Remote game" placeholder.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">CLBike.m</code> (<code class="literal">turnRight</code>)</p><div class="informalexample"><pre class="programlisting">    // Remote game
    [self sendPacketForTurn:kRight];</pre></div><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">CLBike.m</code> (<code class="literal">turnLeft</code>):</p><div class="informalexample"><pre class="programlisting">    // Remote game
    [self sendPacketForTurn:kLeft];</pre></div><p>Now, every time the player turns, we call to the <code class="literal">sendPacketForTurn</code> method, and if this is a local player, we will send the appropriate message to the <a id="id1571" class="indexterm"/>remote device.</p></div><div class="section" title="Why send moves?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec90"/>Why send moves?</h2></div></div></div><p>A natural question on a game like this is why do we send the move, if it is a predetermined, constant rate? The primary reason we do this is to avoid game glitches if a message was to get delayed.</p><p>Imagine a game where red is the local player, and blue is the remote player. We have implemented the game so we are only sending turns, <a id="id1572" class="indexterm"/>not move forward messages. So on each update, the local device moves both players forward a distance of 5 points. Blue turns, but the message is delayed slightly, so it is <a id="id1573" class="indexterm"/>received two update cycles late. On the local (red player) game, blue has moved forward 10 points, then turned. On the remote (blue player) game, the blue player has turned, then moved forward 10. This means the two devices have a different image of the game board, and we cannot bring them back into sync. So blue might appear to crash into a wall on the red player's iPad, but is actually still alive and playing on their different version of the game board. The only way to avoid this sort of board mutation on this type of game is to do as we have and explicitly send every movement to the other player. <a id="id1574" class="indexterm"/>This way we can guarantee that the game board as seen by either player is exactly the same.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec62"/>Summary</h1></div></div></div><p>In this chapter, we implemented our first iPad game, our first simultaneous two-player game, and our first two-player Bluetooth game. We spent some time learning about how we can optimize our images to make a lot out of very few graphic assets. We also saw how we can create a simple animated background using <code class="literal">CCRenderTexture</code>, and used <code class="literal">glScissor</code> to cut that moving image to fit a non-moving screen area.</p><p>We covered the basics of a GameKit two player game, and hopefully we had some fun along the way. There is a lot to learn about optimization for networked games, and we have so far only scratched the surface with what is possible. There is also a whole world of other connectivity and lag issues you will face when you branch out to include Internet-based multiplayer games. If you are interested in exploring that, I advise you to read up on Apple's documentation and use your favorite search engine to find other resources, as network communication code is a specialty unto itself.</p><p>In the next chapter, we will revisit Box2D to build an old school top-down pool game. We will implement a rules system as well as experiment with different control mechanics. Rack 'em up, and let's start the next chapter! </p></div></body></html>