<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Camera, Video, and Multimedia</h1></div></div></div><p>Recent years have brought about great advancements in mobile multimedia technologies, with many people not only listening to music and watching movies on their mobile devices but using them to produce high quality media of their own. The SDK provides APIs that allow us to include both media playback as well as media capture, and with the camera APIs being completely overhauled, there has never been a better time to be developing Android multimedia apps.</p><p>Many multimedia features can be very easily incorporated into our apps by simply harnessing the system's native applications such as the camera. Alternatively, we can work directly with the APIs and develop apps that handle all the photos and videos capturing process themselves, although this is no simple task. One thing that is simple to achieve, though, is including the recording and playing of multimedia, including audio, within our apps.</p><p>In this chapter, you will:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Preview images using the native Camera app</li><li class="listitem" style="list-style-type: disc">Automatically refactor code</li><li class="listitem" style="list-style-type: disc">Save images from the native camera to our app</li><li class="listitem" style="list-style-type: disc">Handle IO exceptions</li><li class="listitem" style="list-style-type: disc">Create a unique filename</li><li class="listitem" style="list-style-type: disc">Add images to the device gallery</li><li class="listitem" style="list-style-type: disc">Make images private</li><li class="listitem" style="list-style-type: disc">Capture and play back video</li><li class="listitem" style="list-style-type: disc">Add video controls</li><li class="listitem" style="list-style-type: disc">Handle video interruptions without losing position</li><li class="listitem" style="list-style-type: disc">Package videos with an app</li><li class="listitem" style="list-style-type: disc">Play videos from memory</li><li class="listitem" style="list-style-type: disc">Stream video from the Web</li><li class="listitem" style="list-style-type: disc">Record audio files with a MediaRecorder</li><li class="listitem" style="list-style-type: disc">Play back audio files with a MediaPlayer</li></ul></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec40"/>Capturing images</h1></div></div></div><p>More often<a id="id364" class="indexterm"/> than not, when including image or video capture in our apps, all we need to do is take advantage of the fact that the system already has applications designed for these purposes and we can call upon them with an Intent, in just the same way that we call Activities inside our own apps. We do not even need to know which app is called, as the system will automatically seek out the most appropriate, even offering the user a choice when one is available.</p><p>Here, we will include a photo taking function in our Ancient Britain app that harnesses the native Camera application to capture an image, display it in a view and save it to a specific directory. We will then make our image available to the device gallery and other apps. This is not a short exercise, so we will split it into three parts: preparing and refactoring, previewing a camera shot, and saving a camera shot.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec43"/>Refactoring code</h2></div></div></div><p>To save <a id="id365" class="indexterm"/>time, we will not set up another button for our camera function. Instead we will reuse the ImageView that currently takes the user to the relevant Wikipedia page. We will also need to set some permissions and feature uses and add a new graphic. Follow these steps to prepare the Ancient Britain app, which we began in <a class="link" href="ch04.html" title="Chapter 4. Managing RecyclerViews and Their Data">Chapter 4</a>, <em>Managing RecyclerViews and Their Data</em> to incorporate calls to the native camera:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">Ancient Britain</code> project in Android Studio and open the manifest file.</li><li class="listitem">Include these tags:<div><pre class="programlisting">&lt;uses-feature android:name="android.hardware.camera"
  android:required="true" /&gt;

&lt;uses-permission android:name="android.permission.CAMERA" /&gt;

&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;</pre></div></li><li class="listitem">Find an icon-sized image, suitable for a camera function, such as the following:<div><img src="img/B04321_09_01.jpg" alt="Refactoring code"/></div></li><li class="listitem">Save<a id="id366" class="indexterm"/> this in the <code class="literal">res/drawable</code> directory in file explorer view and replace the <code class="literal">web_icon.png</code> file with the one you just made.</li><li class="listitem">Open the <code class="literal">DetailActivity.java</code> file.</li><li class="listitem">Locate the following line and right-click on <code class="literal">detailWebLink</code>:<div><pre class="programlisting">ImageView <strong>detailWebLink</strong> = (ImageView) findViewById(R.id.detail_web_link);</pre></div></li><li class="listitem">Press <em>Shift</em> + <em>F6</em> and rename the instance <code class="literal">detailCameraButton</code>.</li><li class="listitem">Do the same for the XML reference, renaming it <code class="literal">detail_camera_button</code>.</li><li class="listitem">Select <code class="literal">web_icon</code> in the <code class="literal">drawable</code> folder in the project explorer and rename it <code class="literal">camera_icon</code>.<div><img src="img/B04321_09_02.jpg" alt="Refactoring code"/></div></li></ol></div><p>The first thing we did here, was apply permissions and feature to the manifest, the feature being included here so as to prevent devices without cameras being able to find it on the Play store.</p><div><div><h3 class="title"><a id="tip24"/>Tip</h3><p>If you are developing for API level 17 or below, you will need to add the permission: <code class="literal">android.permission.CAMERA</code>.</p></div></div><p>The<a id="id367" class="indexterm"/> refactoring that we did next was not strictly necessary but made the code easier to follow and demonstrated just how easy it is to rename things with the <em>F6</em> key. The effects propagate throughout the project, for example when we renamed an XML reference in Java, the corresponding layout file was edited accordingly, and there are many handy refactoring tools available through the Refactor menu.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec44"/>Previewing the camera output</h2></div></div></div><p>To preview<a id="id368" class="indexterm"/> the camera, we need to fire an intent that calls the native camera as well as a way of responding when the camera returns to our app. These three steps achieve that:</p><div><ol class="orderedlist arabic"><li class="listitem">Add these fields to the <code class="literal">detailActivity</code> class:<div><pre class="programlisting">private static final int PREVIEW_REQUEST_CODE = 1;
private static final int SAVE_REQUEST_CODE = 2;
private String photoPath;
private File photoFile;</pre></div></li><li class="listitem">Replace the <code class="literal">onClick()</code> method of the now, <code class="literal">detailCameraButton</code> button's <code class="literal">onClickListener</code> with this code:<div><pre class="programlisting">@Override
public void onClick(View v) {
  Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
  if (intent.resolveActivity(getPackageManager()) != null) {
    startActivityForResult(intent, PREVIEW_REQUEST_CODE);
  }
}</pre></div></li><li class="listitem">Provide the class with the following <code class="literal">onActivityResult()</code> method:<div><pre class="programlisting">  @Override
  protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    if (requestCode == PREVIEW_REQUEST_CODE &amp;&amp; resultCode == RESULT_OK) {
      Bundle extras = data.getExtras();
      Bitmap imageBitmap = (Bitmap) extras.get("data");
      detailImage.setImageBitmap(imageBitmap);
    } else if (requestCode == SAVE_REQUEST_CODE &amp;&amp; resultCode == RESULT_OK) {
      // To complete
    }
  }</pre></div></li></ol></div><p>You<a id="id369" class="indexterm"/> can now run the app. Clicking the camera icon will allow you to take a picture which will be displayed in the layout's other <code class="literal">ImageView</code>.</p><div><img src="img/B04321_09_03.jpg" alt="Previewing the camera output"/></div><p>The intent we create here is called on the <code class="literal">MediaStore</code> class, using a constant that opens the native camera. Note how the Camera Activity is protected by the intent's <code class="literal">resolveActivity()</code> method. If there is no app on the device that can fulfill the request and the intent is fired, then the app will crash. The <code class="literal">PacketManager()</code> will contain nothing if no suitable app is found.</p><p>When control is handed back to our app, the <code class="literal">onActivityResult()</code> method is called. The <code class="literal">requestCode</code> is used to check where the camera Activity was called from and the <code class="literal">resultCode</code> to test that it worked. We used the data value pair <code class="literal">data</code> to extract the bitmap the camera returned in its Bundle. This particular image is only a thumbnail. The full image<a id="id370" class="indexterm"/> is available and next we will see how to store it on the SD card.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec45"/>Saving the camera output</h2></div></div></div><p>Again to <a id="id371" class="indexterm"/>save time and extra coding, we will use an existing widget as a button to trigger an Intent to save as well as take a photo. We will replace the main image view's <code class="literal">onTouchListener</code> with an <code class="literal">onClickListener</code> and call the methods we need from there. Follow these steps to see how:</p><div><ol class="orderedlist arabic"><li class="listitem">In the <code class="literal">detailActivity</code> class, replace the line <code class="literal">detailImage.setOnTouchListener(listener);</code> in the <code class="literal">onCreate()</code> method with this code:<div><pre class="programlisting">detailImage.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        takePhoto();
    }
});</pre></div></li><li class="listitem">Create the <code class="literal">takePhoto()</code> method to look like this:<div><pre class="programlisting">private void takePhoto() {
  Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
  if (takePictureIntent.resolveActivity(getPackageManager()) != null) {
    File photoFile = null;
    try {
      photoFile = filename();
    } catch (IOException ex) {
      Toast toast = Toast.makeText(getApplicationContext(),
        "No SD card",
        Toast.LENGTH_SHORT);
      toast.show();
    }
    if (photoFile != null) {
      takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(photoFile));
      startActivityForResult(takePictureIntent, SAVE_REQUEST_CODE);
    }
  }
}</pre></div></li><li class="listitem">Include the <code class="literal">filename()</code> method like so:<div><pre class="programlisting">private File filename() throws IOException {
  String time = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
  String file = MainData.nameArray[MainActivity.currentItem] + "_" + time + "_";
  File dir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES);
  File image = File.createTempFile(file, ".jpg", dir);
  photoPath = "file:" + image.getAbsolutePath();
  return image;
}</pre></div></li><li class="listitem">In <a id="id372" class="indexterm"/>the <code class="literal">onActivityResult()</code> method, replace the commented <code class="literal">// To complete line with this code</code>:<div><pre class="programlisting">else if (requestCode == SAVE_REQUEST_CODE &amp;&amp; resultCode == RESULT_OK) {
  <strong>Intent intent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);</strong>
  <strong>Uri contentUri = Uri.fromFile(photoFile);</strong>
  <strong>intent.setData(contentUri);</strong>
  <strong>this.sendBroadcast(intent);</strong>
}</pre></div></li><li class="listitem">You can now run and test the app. Tapping the camera icon replaces the main image with the one just taken and tapping on the image itself will let you save a picture to the device's SD card in the Pictures directory.<div><img src="img/B04321_09_04.jpg" alt="Saving the camera output"/></div></li></ol></div><p>Clearly, the <a id="id373" class="indexterm"/>way this example processes user input, is a little on the clumsy side. Ideally, we would have added new buttons or even another Activity to handle previewing and saving images. We took this approach for the sake of brevity and to highlight the processes themselves. The two methods applied warrant a little examination themselves.</p><p>The <code class="literal">takePhoto()</code> method fires the same intent as the camera button's <code class="literal">onClick()</code> method. A different request code is used to show how we can call the same external Activity but respond differently depending on where it was called from. Android generally manages exceptions rather well, but we cannot guarantee the presence of a SD card and it makes sense to try to catch this exception. We could create a message. If the creation of the File <code class="literal">photoFile</code> is successful (and it rarely isn't), it can be included in our Intent with the line <code class="literal">takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(photoFile));</code>.</p><p>When creating a filename, we need to be careful that it does not collide with others. Without a lot of precautionary code, this can be done by setting up a unique filename, which is done here by appending a timestamp. This method is called during our attempt to catch system exceptions and therefore requires the throws <code class="literal">IOException</code> declaration.</p><p>Finally, we added some code in the <code class="literal">else</code> clause of our <code class="literal">onActivityResult()</code> method, which is called after the image is saved and control returned to our app. The <code class="literal">ACTION_MEDIA_SCANNER_SCAN_FILE</code> Intent is a request to the media scanner to add it to the media database the next time it is run. This means that our image will appear in the native gallery app and be available to any other app that uses the media database, such as wallpaper pickers.</p><p>If you want your images to be only available from within your app, it is not enough simply to omit these lines, as the images are still accessible from any file browsing software. To prevent this, use <code class="literal">Environment.getExternalFilesDir()</code> instead of <code class="literal">Environment.getExternalStoragePublicDirectory()</code>. This will also have the effect of deleting these files when your app is uninstalled.</p><div><div><h3 class="title"><a id="tip25"/>Tip</h3><p>The media scanner does not necessarily run at predictable times and, when testing, you may have to restart your device or emulator to force it to include your file.</p></div></div><p>Commandeering the platform's camera like this is a wonderfully convenient way to incorporate its functionality with a minimum of coding. Of course, it is quite possible to recreate a camera or a video app from scratch and we will take a quick look at how that can be done shortly. First, let us see how to record and play back video in the same way we did here with the camera.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec41"/>Capturing and playing video</h1></div></div></div><p>Using native<a id="id374" class="indexterm"/> apps to capture video content from within our own apps is achieved in an almost identical way, to the one we just applied. The main difference is that <a id="id375" class="indexterm"/>when dealing with video content a lot of the functionality is provided by the purpose-built widget, the <code class="literal">VideoView</code>. We will also add video control buttons with the <code class="literal">MediaController</code> and see how to pause a video when our app is sent to the background. Follow these steps to build a simple video app:</p><div><ol class="orderedlist arabic"><li class="listitem">Start a new Android Studio project.</li><li class="listitem">Add the feature uses and permissions we included in the last exercise to the manifest.</li><li class="listitem">Open the <code class="literal">activity_main.xml</code> file and replace the <code class="literal">TextView</code> with this <code class="literal">VideoView</code>:<div><pre class="programlisting">&lt;VideoView
  android:id="@+id/video_view"
  android:layout_width="match_parent"
  android:layout_height="match_parent" /&gt;</pre></div></li><li class="listitem">Open the <code class="literal">MainActivity.java</code> and add these fields:<div><pre class="programlisting">private static final int VIDEO_REQUEST_CODE = 1;
private android.widget.VideoView videoView;
private int position = 0;
private MediaController mediaController;</pre></div></li><li class="listitem">Include this code in the <code class="literal">onCreate()</code> method:<div><pre class="programlisting">videoView = (VideoView) findViewById(R.id.video_view);

if (mediaController == null) {
  mediaController = new MediaController(this);
}
videoView.setMediaController(mediaController);

takeVideo();.
Add the takeVideo() method, like so:
private void takeVideo() {
  Intent takeVideoIntent = new Intent(MediaStore.ACTION_VIDEO_CAPTURE);
  if (takeVideoIntent.resolveActivity(getPackageManager()) != null) {
    startActivityForResult(takeVideoIntent, VIDEO_REQUEST_CODE);
  }
}</pre></div></li><li class="listitem">Then the <code class="literal">onActivityResult()</code> method:<div><pre class="programlisting">@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
  if (requestCode == VIDEO_REQUEST_CODE &amp;&amp; resultCode == RESULT_OK) {
    Uri videoUri = data.getData();
    videoView.setVideoURI(videoUri);
  }
}</pre></div></li><li class="listitem">If you<a id="id376" class="indexterm"/> test the project now, you will be able to record <a id="id377" class="indexterm"/>and play back a video. However, if the Activity loses focus and restarts, the video will also start from the beginning.<p>To rectify this, add these two methods:</p><div><pre class="programlisting">@Override
public void onSaveInstanceState(Bundle savedInstanceState) {
  super.onSaveInstanceState(savedInstanceState);
  savedInstanceState.putInt("Position", videoView.getCurrentPosition());
  videoView.pause();
}

@Override
public void onRestoreInstanceState(Bundle savedInstanceState) {
  super.onRestoreInstanceState(savedInstanceState);
  position = savedInstanceState.getInt("Position");
  videoView.seekTo(position);
}</pre></div></li><li class="listitem">If you now test the app and interrupt the playback with another app, and then return to the Activity, it will resume from where it left off.<div><img src="img/B04321_09_05.jpg" alt="Capturing and playing video"/></div></li></ol></div><p>Up until <a id="id378" class="indexterm"/>step 6, the way we dispatched our intent to capture video was <a id="id379" class="indexterm"/>almost identical to the method we used for still images, with the exception of the <code class="literal">MediaController</code>, which adds the familiar controls we all associate with video playback. When dealing with videos, particularly long ones, the user may wish to pause playback and engage with another app. To ensure that the video resumes from the last position when the user returns, we had to intercept the Activity lifecycle before the app is sent to the background with the <code class="literal">onSaveInstanceState()</code> method and again when it returns with <code class="literal">onRestoreInstanceState()</code>. We used <code class="literal">VideoView.pause()</code> and <code class="literal">VideoView.seekTo()</code> here. The following methods are available in <code class="literal">VideoView</code> for controlling video playback:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">VideoView.start()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">VideoView.pause()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">VideoView.resume()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">VideoView.seekTo(position)</code></li></ul></div><p>As useful as it is to be able to provide video recording capabilities in our apps, there are often times when we will want to play videos packaged within our app, or from an external source such as the device SD card or even streamed from the Internet. The example above only requires a few minor adjustments and the next section shows how to adapt it to play video from other sources than the camera itself.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec46"/>Playing video from memory and the Internet</h2></div></div></div><p>There are <a id="id380" class="indexterm"/>countless reasons why we might want to include video <a id="id381" class="indexterm"/>content in our app or play videos produced by other apps, and in this section we will see how to package videos within our app and how to play videos from the device's storage and the Web. The following exercise will take you through how to do each of these:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the project that we just worked on.</li><li class="listitem">Create a new folder in the <code class="literal">res</code> directory called <code class="literal">raw</code>.<div><img src="img/B04321_09_06.jpg" alt="Playing video from memory and the Internet"/></div></li><li class="listitem">Find a short video file with one of the following formats, name it <code class="literal">movie</code>, and paste it into the <code class="literal">res/raw</code> folder: <code class="literal">.webm</code>, <code class="literal">.3gp</code>, <code class="literal">.mp4</code>, or <code class="literal">.mkv</code>.</li><li class="listitem">Open the <code class="literal">MainActivity</code> file.</li><li class="listitem">In the <code class="literal">onCreate()</code> method, comment out the call to <code class="literal">takePhoto()</code> and add these two lines:<div><pre class="programlisting">videoView.setVideoURI(Uri.parse("android.resource://" + getPackageName() + "/" + R.raw.movie));
videoView.start();</pre></div></li><li class="listitem">If playing an in-app video is what you are after, you can stop here and run the app.</li><li class="listitem">To play a video stored on the device's SD card, replace the lines you just entered with these:<div><pre class="programlisting">videoView.setVideoPath("/sdcard/some_directory/some_movie.mp4");
videoView.start();</pre></div></li><li class="listitem">If run, the app will now play the indicated file from the SD card. To stream a video, use this code:<div><pre class="programlisting">videoView.setVideoPath("http://www.your_site.com/movies/movie.mp4");
videoView.start();</pre></div></li></ol></div><p>That's all there is to it. We stored our in-app video in the <code class="literal">res/raw</code> directory. Although not included, when we create a project, <code class="literal">raw</code> is a recognized resource folder and can be used for<a id="id382" class="indexterm"/> storing any file that we do not want compiled <a id="id383" class="indexterm"/>when the project is built and/or packaged.</p><p>The other thing to note about this otherwise straightforward code is how we use <code class="literal">VideoView.setVideoPath()</code> when loading from internal storage or the Web, rather than <code class="literal">VideoView.setVideoURI()</code>.</p><p>Calling other apps, such as the camera app, is a very convenient way to incorporate such features without a great deal of coding. There are, of course, times when we will want a deeper integration of the camera APIs. This requires building the camera from the ground up and is beyond the scope of this chapter. However, Android 5 does introduce a whole new set of camera APIs, the <code class="literal">android.hardware.camera2</code>, which supersedes the <code class="literal">android.hardware.Camera</code> APIs. <strong>Camera2</strong> allows for some exciting new features, such as control over individual cameras and improved storage capabilities, and although there is no room to build a camera2 app from scratch here, there is a very informative sample, packaged with the SDK, which we will now take a look at.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec47"/>Exploring the camera2 APIs</h2></div></div></div><p>The camera2 APIs <a id="id384" class="indexterm"/>are a lot more sophisticated than their<a id="id385" class="indexterm"/> predecessors, but they are also a lot more involved. Building<a id="id386" class="indexterm"/> a camera app from scratch is far from simple. Fortunately, Android packages numerous sample apps within the SDK and there is a suitable camera2 sample, that we can take a look at.</p><p>Samples can be loaded directly into the Android Studio from the Quick Start pane of the startup window <strong>File</strong> | <strong>Import Sample...</strong> from within the IDE.</p><div><img src="img/B04321_09_07.jpg" alt="Exploring the camera2 APIs"/></div><p>Most camera2 processes begin with the <code class="literal">CameraManager</code>. This class allows us to identify and connect to<a id="id387" class="indexterm"/> any cameras attached to the device, as well as <a id="id388" class="indexterm"/>determining their properties. In the sample, the <code class="literal">Camera2BasicFragment</code> class is where most of the interesting work is done and you can see <a id="id389" class="indexterm"/>how a <code class="literal">CameraManager</code> is used in the <code class="literal">openCamera()</code> method to open a camera, and in <code class="literal">setUpCameraOutputs()</code> to acquire the camera ID and whether it is the front-facing camera using the <code class="literal">CameraCharateristics</code> class. This class can be seen in action in the <code class="literal">setUpCameraOutputs()</code> method too, where it is used to rule out the front-facing camera.</p><p>The <code class="literal">CameraDevice</code> is the class used to represent individual cameras within an app, and is used for setting up a <code class="literal">CaptureRequest</code> and a <code class="literal">CaptureRequestSession</code> for the actual process of taking photos. This also gives us control over functions such as auto focus and white balance. The <code class="literal">CameraCaptureSession</code> is where camera2 features, such as being able to take multiple images in a burst, are made available.</p><p>It is well worth exploring and experimenting with the <code class="literal">Camer2Basic</code> sample, and there is also a <code class="literal">Camera2Video</code> sample. If you are interested in building a camera app from scratch using Android 5 capabilities, then the official documentation at <a class="ulink" href="http://developer.android.com/reference/android/hardware/camera2/package-summary.html">http://developer.android.com/reference/android/hardware/camera2/package-summary.html</a> is well worth checking out.</p><p>The Camera2 APIs, despite their sophistication, have one serious drawback: they are the one set of Android 5 APIs that cannot be made backward compatible easily. Any app that relies largely on camera and video functions would require an necessary amount of alternative code to make it available for older platforms. Jelly Bean and KitKat current occupy over three-quarters of the market and look likely to make up a significant proportion of your target audience for a good time to come. Unless you plan to utilize camera2-specific<a id="id390" class="indexterm"/> features, such as capturing images in RAW<a id="id391" class="indexterm"/> format or taking multiple shots in a burst, you should seriously <a id="id392" class="indexterm"/>consider using the original Camera APIs, which despite having depreciated are still perfectly usable.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec42"/>Recording and playing audio</h1></div></div></div><p>We saw earlier in the chapter how to capture and play multimedia content using native apps <a id="id393" class="indexterm"/>and the <code class="literal">VideoView</code>. There is also another very handy tool for<a id="id394" class="indexterm"/> recording and playing media files, especially audio: the <code class="literal">MediaRecorder</code> class. The <code class="literal">MediaRecorder</code> allows us to simply set such things as audio source, output location, and format, as well as giving us control over play and record functions. In this exercise, we will develop a small app that records and plays back audio captured with a device's inbuilt microphone:</p><div><ol class="orderedlist arabic"><li class="listitem">Start a new Android Studio project.</li><li class="listitem">Find three button-sized media images like those below and place them in your <code class="literal">drawable</code> folder.<div><img src="img/B04321_09_08.jpg" alt="Recording and playing audio"/></div></li><li class="listitem">Call them Play, Record, and Stop.</li><li class="listitem">Open the manifest files and include these permissions:<div><pre class="programlisting">&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;
&lt;uses-permission android:name="android.permission.RECORD_AUDIO" /&gt;</pre></div></li><li class="listitem">Create a layout similar to the one here:<div><img src="img/B04321_09_09.jpg" alt="Recording and playing audio"/></div></li><li class="listitem">Use <code class="literal">ImageViews</code> as the buttons and give them the IDs <code class="literal">record_button</code>, <code class="literal">stop_button</code> and <code class="literal">play_button</code>. Call the <code class="literal">TextView</code>, <code class="literal">text_view</code>.</li><li class="listitem">Open <a id="id395" class="indexterm"/>the <code class="literal">MainActivity</code> and include these two fields:<div><pre class="programlisting">private MediaRecorder recorder;
private String filename;</pre></div></li><li class="listitem">In <a id="id396" class="indexterm"/>the <code class="literal">onCreate()</code> method, add this <code class="literal">TextView</code>:<div><pre class="programlisting">final TextView textView = (TextView) findViewById(R.id.text_view);</pre></div></li><li class="listitem">Add this file path:<div><pre class="programlisting">filename = Environment.getExternalStorageDirectory().getAbsolutePath() + "/recording.3gp";</pre></div></li><li class="listitem">Then these <code class="literal">MediaRecorder</code> configurations:<div><pre class="programlisting">recorder = new MediaRecorder();
recorder.setAudioSource(MediaRecorder.AudioSource.MIC);
recorder.setAudioEncoder(MediaRecorder.OutputFormat.AMR_NB);
recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);
recorder.setOutputFile(filename);</pre></div></li><li class="listitem">Each <code class="literal">ImageView</code> we created in the layout requires an <code class="literal">OnClickListener</code> within the <code class="literal">onCreate()</code> method as follows:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">ImageView <code class="literal">recordButton</code>:<div><pre class="programlisting">ImageView recordButton = (ImageView) findViewById(R.id.record_button);
recordButton.setOnClickListener(new View.OnClickListener() {

  @Override
  public void onClick(View view) {
    try {
      recorder.prepare();
    } catch (IOException e) {
    }
    recorder.start();
    textView.setText("Recording...");
  }
});</pre></div></li><li class="listitem" style="list-style-type: disc">ImageView <code class="literal">stopButton</code>:<div><pre class="programlisting">ImageView stopButton = (ImageView) findViewById(R.id.stop_button);
stopButton.setOnClickListener(new View.OnClickListener() {

  @Override
  public void onClick(View view) {
    recorder.stop();
    recorder.release();
    textView.setText("Recording complete");
  }
});</pre></div></li><li class="listitem" style="list-style-type: disc">ImageView <code class="literal">playButton</code>:<div><pre class="programlisting">ImageView playButton = (ImageView) findViewById(R.id.play_button);
playButton.setOnClickListener(new View.OnClickListener() {

  @Override
  public void onClick(View view) {
    try {
      play();
    } catch (IOException e) {
    }
    textView.setText("Playing...");
  }
});</pre></div></li></ul></div></li><li class="listitem">Finally, add the <code class="literal">play()</code> method, which looks like this:<div><pre class="programlisting">public void play() throws IllegalArgumentException, SecurityException, IllegalStateException, IOException {
  MediaPlayer player = new MediaPlayer();
  player.setDataSource(filename);
  player.prepare();
  player.start();
}</pre></div></li><li class="listitem">You can now run the app on a handset (as the stock emulators do not yet have the microphone functionality) and record and play back audio. The file <code class="literal">recording.3gp</code> can be found in the root directory of the SD card.</li></ol></div><p>The <code class="literal">MediaRecorder</code> class makes light work of recording audio and can also be used to record<a id="id397" class="indexterm"/> video. Like the <code class="literal">MediaPlayer</code> class we used to play the audio back, this is <a id="id398" class="indexterm"/>similarly intuitive to use. The use of <code class="literal">MediaRecorder.release()</code> is important, as without it the system would continue to use resources. We only prepared and played the file here, but the <code class="literal">MediaPlayer</code> can do a lot more and it is well worth taking a look at its documentation, which can be found at <a class="ulink" href="http://developer.android.com/reference/android/media/MediaPlayer.html">http://developer.android.com/reference/android/media/MediaPlayer.html</a>.</p><p>Again, we used <code class="literal">Environment.getExternalStorageDirectory()</code> to automatically select the user's preferred external storage device and although we took a different approach to the way we managed multimedia earlier in the chapter, either method can be applied in many situations. The <code class="literal">MediaRecorder</code> and <code class="literal">MediaPlayer</code> together provide a simple but powerful way to incorporate audio in our apps.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec43"/>Summary</h1></div></div></div><p>Multimedia such as audio and video have become an integral part of the way we use our mobile devices. Whether it is to create it or consume it, including multimedia functionality in our apps gives them greater appeal and usefulness. In this chapter, we saw how to incorporate native apps such as the camera into our own apps, saving us a great deal of coding in the process. We saw how to capture, record, and play back camera images, video, and finally audio.</p><p>This concludes not just our exploration of Android 5 multimedia, but also, more or less, the programming aspect of this book, as the final chapter looks at how we can take our finished product and make it available to the world, and how to hopefully turn our hard work into a financial gain. There are one or two exercises in the chapter, as we will look at how to make our apps backwards compatible to reach a larger number of potential users, and we will return one last time to the Ancient Britain app to add a mobile advertisement to it using the Google AdMob service.</p></div></body></html>