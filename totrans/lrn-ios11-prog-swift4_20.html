<html><head></head><body>
      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Working with Photo Filters</h1>
            
         </header>
         
         
         <article>
            
            
            <p>In this chapter, we focus on creating photos for a restaurant and how to use the camera
               and camera roll. We give the user the ability to take a picture and apply a filter
               to that picture. In the next chapter, we tie the last chapter and this chapter all
               together by completing the work on the review form and enabling users to save their
               reviews. We will also learn how to save photos as well.
            </p>
            
            <p>In this chapter, you will learn:</p>
            
            <ul>
               
               <li>How to use the camera roll to get pictures</li>
               
               <li>How to use the camera to take pictures and bring them into our app</li>
               
               <li>How to apply filters to our pictures and get them ready to save to the device</li>
               
            </ul>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Understanding filters </h1>
            
         </header>
         
         
         <article>
            
            
            <p>Based on our design, we know that we are going to need to apply filters to a photo.
               Instead of just creating an array of filters, we are going to use a plist to load
               in a set of filters that we want. You can find the <kbd>FilterData.plist</kbd> file inside this chapter's <kbd>asset</kbd> folder. Drag and drop this file into the <kbd>Model</kbd> folder that is inside the <kbd>Review</kbd> folder. Make sure that <kbd>Copy</kbd> items if needed is checked and then hit <span class="packt_screen">Finish</span>.
            </p>
            
            <p>Let's take a look at the plist and see what it contains:</p>
            
            <div class="CDPAlignCenter CDPAlign"><img height="457" src="assets/d412f909-485a-41ba-9252-b5de33d3cf94.png" width="362"/></div>
            
            <p>This list only has 10 of over 170 filters and effects that you can use. If you would
               like to see a full list of filters, you can find the list at <a href="http://tinyurl.com/coreimage-ios">http://tinyurl.com/coreimage-ios</a>. Feel free to add, remove, or update any filters. Now that we have seen what our
               plist looks like, we need to create a model that represents this data. We also need
               to create a <kbd>Manager</kbd> class to manage our items. Let's create the model first:
            </p>
            
            <ol>
               
               <li>Right-click the <kbd>Model</kbd> folder in the <kbd>Review</kbd> folder and select <span class="packt_screen">New File</span>.
               </li>
               
               <li>Inside the <span class="packt_screen">Choose a template for your new file</span> screen, select <span class="packt_screen">iOS</span> at the top, and then <span class="packt_screen">Swift File</span>. Then, hit <span class="packt_screen">Next</span>.
               </li>
               
               <li>Name this file <kbd>FilterItem</kbd> and hit <span class="packt_screen">Create</span>.
               </li>
               
               <li>Next, we need to define our struct; therefore, add the following under the <kbd>import</kbd> statement:
               </li>
               
            </ol>
            <pre style="padding-left: 60px">class FilterItem: NSObject {<br/>   let filter:String<br/>   let name:String<br/>   init(dict:[String:AnyObject]) {<br/>       name  = dict[name] as! String<br/>         filter = dict[filter] as! String<br/>   }<br/>}</pre>
            <p>The <kbd>filter</kbd> property will be the class passed to apply the filter; and the <kbd>name</kbd> property will be used as a display.
            </p>
            
            <p>Let's create our <kbd>FilterManager</kbd> file next:
            </p>
            
            <ol>
               
               <li>Right-click the <kbd>Photo Filter</kbd> folder and select <span class="packt_screen">New File</span>.
               </li>
               
               <li>Inside of the <span class="packt_screen">Choose a template for your new file</span> screen, select <span class="packt_screen">iOS</span> at the top, and then <span class="packt_screen">Swift File</span>. Then, hit <span class="packt_screen">Next</span>.
               </li>
               
               <li>Name this file <kbd>FilterManager</kbd> and hit <span class="packt_screen">Create</span>.
               </li>
               
            </ol>
            
            <p> </p>
            
            <ol start="4">
               
               <li>Next, we need to define our class definition; therefore, add the following under the
                  <kbd>import</kbd> statement:
               </li>
               
            </ol>
            <pre style="padding-left: 60px">class FilterManager: DataManager {<br/>    func fetch(completionHandler:(_ items:[FilterItem]) -&gt; Swift.Void) {<br/>        var items:[FilterItem] = []<br/>        for data in load(file: "FilterData") {<br/>            items.append(FilterItem(dict: data))<br/>        }<br/>        completionHandler(items)<br/>    }<br/>}</pre>
            <p>This file uses our <kbd>DataManager</kbd> base class, which converts our plist data into an array of dictionary objects. Once
               that is complete, we create <kbd>FilterItems</kbd> from that.
            </p>
            
            <p>Next, we need to create a file that takes a <kbd>FilterItem</kbd> and apply a filter to an image. Since we are going to do this in numerous places,
               it is best to have all of this code in one place. Therefore, we are going to create
               a file that handles all of this processing for us. Let's create our <kbd>ImageFiltering</kbd> file:
            </p>
            
            <ol>
               
               <li>Right-click the <kbd>Photo Filter</kbd> folder and select <span class="packt_screen">New File</span>.
               </li>
               
               <li>Inside the <span class="packt_screen">Choose a template for your new file</span> screen, select <span class="packt_screen">iOS</span> at the top, and then <span class="packt_screen">Swift File</span>. Then, hit <span class="packt_screen">Next</span>.
               </li>
               
               <li>Name this file <kbd>ImageFiltering</kbd>, and hit <span class="packt_screen">Create</span>.
               </li>
               
               <li>Update your file to the following:</li>
               
            </ol>
            <pre style="padding-left: 60px">import UIKit<br/>import CoreImage<br/><br/>protocol ImageFiltering {<br/>    func apply(filter:String, originalImage:UIImage) -&gt; UIImage<br/>}<br/><br/>protocol ImageFilteringDelegate:class {<br/>    func filterSelected(item:FilterItem)<br/>}<br/><br/>extension ImageFiltering {<br/>    func apply(filter:String, originalImage:UIImage) -&gt; UIImage {<br/>        let initialCIImage = CIImage(image: originalImage, options: nil)<br/>        let originalOrientation = originalImage.imageOrientation<br/>        guard let ciFilter = CIFilter(name: filter) else {<br/>            print("filter not found")<br/>            return UIImage()<br/>        }<br/>        ciFilter.setValue(initialCIImage, forKey: kCIInputImageKey)<br/>        let context = CIContext()<br/>        let filteredCIImage = (ciFilter.outputImage)!<br/>        let filteredCGImage = context.createCGImage(filteredCIImage, from: filteredCIImage.extent)<br/>        return UIImage(cgImage: filteredCGImage!, scale: 1.0, orientation: originalOrientation)<br/>    }<br/>}</pre>
            <p>Let's break down each section so that we can understand what we are doing with this
               code:
            </p>
            <pre>import UIKit<br/>import CoreImage</pre>
            <p><kbd>CoreImage</kbd> give us access to the image processing we need for filtering.
            </p>
            <pre>protocol ImageFiltering {<br/>  func apply(filter:String, originalImage:UIImage) -&gt; UIImage<br/>}</pre>
            <p>Creating this protocol allows us to have other classes conform to it, therefore giving
               us access to the method and allowing us to use it wherever we want.
            </p>
            <pre>protocol ImageFilteringDelegate:class {<br/>  func filterSelected(item:FilterItem)<br/>}</pre>
            <p>This protocol is used when a filter is selected, and when we need the selected filter,
               is passed from one View or View Controller to another. The extension has the <kbd>apply(filter:originalImage:)</kbd> method in it. In this method, we are creating an extension and adding all of the
               code that we are going to use for applying filters to images.
            </p>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Creating our filter scroller </h1>
            
         </header>
         
         
         <article>
            
            
            <p>After a user selects a photo to use, we present the user with a screen, which contains
               that image. In the following image, we have a scroller, also known as a <kbd>UIScrollView</kbd>, which allows us to create content that scrolls either horizontally or vertically.
               The <kbd>UIScrollView</kbd> displays an image (thumbnail) with the filter applied to it as well as the name of
               the filter. This image and name represent our filters visually to our users.
            </p>
            
            <p>When the user taps on the image, the user sees the selected filter change the primary
               image. Let's look at an example:
            </p>
            
            <div class="CDPAlignCenter CDPAlign"><img height="393" src="assets/3b3ece40-d88f-47b7-a6f2-86b6954ab1c2.png" width="221"/></div>
            
            <p>We are now going to create the elements inside the <kbd>UIScrollView</kbd>. Since we have created a lot inside storyboard, let's create the <kbd>PhotoItem</kbd> entirely in code:
            </p>
            
            <ol>
               
               <li>Right-click the <kbd>Review</kbd> folder and select <span class="packt_screen">New File</span>.
               </li>
               
               <li>Inside the <span class="packt_screen">Choose a template for your new file</span> screen, select <span class="packt_screen">iOS</span> at the top, and then <span class="packt_screen">Swift File</span>. Then, hit <span class="packt_screen">Next</span>.
               </li>
               
               <li>Name this file <kbd>PhotoItem</kbd> and hit <span class="packt_screen">Create</span>.
               </li>
               
               <li>Update your file to the following:</li>
               
            </ol>
            <pre style="padding-left: 60px">import UIKit<br/> <br/>class PhotoItem: UIView, ImageFiltering {<br/>}</pre>
            <ol start="5">
               
               <li>Next, add your variables inside of the class declaration:</li>
               
            </ol>
            <pre style="padding-left: 60px">var imgThumb:UIImageView?<br/>var lblTitle:UILabel?<br/>var data:FilterItem?<br/>weak var delegate: ImageFilteringDelegate?</pre>
            <p style="padding-left: 60px">Here, we are creating a delegate, which is used to let any class know when something
               happens. We use this delegate when someone taps on the object itself, which allows
               us to pass the <kbd>FilterItem</kbd> data to a parent class.
            </p>
            
            <div style="padding-left: 60px">
               
               <p>You have used this pattern already plenty of times. Table Views and Collection Views
                  both have delegates to which you conform.
               </p>
               
            </div>
            
            <ol start="6">
               
               <li>Now, we need to add our <kbd>init</kbd> methods. Add the following after your variables:
               </li>
               
            </ol>
            <pre style="padding-left: 60px">required init?(coder aDecoder: NSCoder) {<br/>   fatalError(init(coder:) has not been implemented)<br/>}<br/><br/>init(frame:CGRect, image:UIImage, item:FilterItem) {<br/>    super.init(frame: frame)<br/>    setDefaults(item: item)<br/>    createThumbnail(image: image, item: item)<br/>    createLabel(item: item)<br/>}</pre>
            <p style="padding-left: 60px">Whenever you create a <kbd>UIView</kbd>, you are required to add this method. If you do not, it gives you an error, and then
               you have to add it.
            </p>
            
            <p style="padding-left: 60px">This is a custom <kbd>init()</kbd> method, which allows us to pass data (here, the frame, image, and filter items) when
               the item gets created. We have a few errors because we have not created the methods
               we added to our <kbd>init()</kbd> method.
            </p>
            
            <ol start="7">
               
               <li>Next, let's create an extension and add the following methods:</li>
               
            </ol>
            <pre style="padding-left: 60px">private extension PhotoItem {<br/>  func setDefaults(item:FilterItem) {<br/>    data = item<br/>    let tap = UITapGestureRecognizer(target: self, <br/>    action:#selector(thumbTapped))<br/>    self.addGestureRecognizer(tap)<br/>    self.backgroundColor = .clear<br/>  }<br/> <br/>  func createThumbnail(image:UIImage, item:FilterItem) {<br/>    if item.filter != "None" {<br/>      let filteredImg = apply(filter: item.filter, originalImage: image)<br/>      imgThumb = UIImageView(image: filteredImg)<br/>    }<br/>    else { imgThumb = UIImageView(image: image) }<br/> <br/>    guard let thumb = imgThumb else {<br/>      return<br/>    }<br/> <br/>    thumb.contentMode = .scaleAspectFill<br/>    thumb.frame = CGRect(x: 0, y: 22, width: 102, height: 102)<br/>    thumb.clipsToBounds = true<br/>  <br/>    addSubview(thumb)<br/>  }<br/> <br/>  func createLabel(item:FilterItem) {<br/>    lblTitle = UILabel(frame: CGRect(x: 0, y: 0, width: 102, height: 22))<br/> <br/>    guard let label = lblTitle else {<br/>      return<br/>    }<br/> <br/>    label.text = item.name<br/>    label.font = UIFont.systemFont(ofSize: 12.0)<br/>    label.textAlignment = .center<br/>    label.backgroundColor = .clear<br/> <br/> <br/>    addSubview(label)<br/>  }<br/>}</pre>
            <p style="padding-left: 60px">Our <kbd>setDefaults()</kbd> method is used to create a tap gesture. When the item gets tapped, we call the <kbd>thumbTapped</kbd> method. We also set the data and the background color of this method.
            </p>
            
            <p style="padding-left: 60px">The <kbd>createThumbnail(image: item:)</kbd> is used to create an image and apply a filter to the image. Then, we are setting
               its frame and adding the image to the View.
            </p>
            
            <p style="padding-left: 60px">With our final method, <kbd>createLabel(item:)</kbd>, we are creating a label and passing in the name of the filter. Then, we are setting
               its frame and adding the label to the View.  We have two more methods we need to add
               to our extension. 
            </p>
            
            <ol start="8">
               
               <li>Add the following after the <kbd>createLabel(item:)</kbd> method:
               </li>
               
            </ol>
            <pre style="padding-left: 60px">@objc func thumbTapped() {<br/>  if let data = self.data {<br/>    filterSelected(item: data)<br/>  }<br/>}<br/><br/>func filterSelected(item:FilterItem) {<br/>  delegate?.filterSelected(item: item)<br/>}</pre>
            <p>The <kbd>thumbTapped()</kbd> method is used to detect taps. When the user taps the item, it calls <kbd>filterSelected</kbd>.
            </p>
            
            <p>The <kbd>filterSelected(item:)</kbd> method is the protocol we created earlier; and all we are doing is calling the <kbd>delegate</kbd> method, <kbd>filterSelected</kbd>. We see what happens next when the selected filter gets called.
            </p>
            
            <p class="mce-root">Our <kbd>PhotoItem</kbd> is complete; now we need to work on our cell for our <kbd>Filter</kbd> collection view.
            </p>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Creating a filter cell</h1>
            
         </header>
         
         
         <article>
            
            
            <p>We already created our cell that we need in the storyboard. However, before we create
               our View Controller, we need to create a filter cell.  This cell is used to display
               all of the available filters.
            </p>
            
            <ol>
               
               <li>Right-click the <kbd>Photo Filter</kbd> folder in the <kbd>Controller</kbd> folder in the <kbd>Review</kbd> folder and select <span class="packt_screen">New File</span>.
               </li>
               
               <li>Inside the <span class="packt_screen">Choose a template for your new file</span> screen, select <span class="packt_screen">iOS</span> at the top, and then <span class="packt_screen">Cocoa Touch Class</span>. Then, hit <span class="packt_screen">Next</span>.
               </li>
               
            </ol>
            
            <p> </p>
            
            <ol start="3">
               
               <li>In the options screen that appears, add the following:</li>
               
            </ol>
            
            <p style="padding-left: 60px">New file:</p>
            
            <ul>
               
               <li>
                  
                  <ul>
                     
                     <li><span class="packt_screen">Class</span>: <kbd>FilterCell</kbd></li>
                     
                     <li><span class="packt_screen">Subclass</span>: <kbd>UICollectionViewCell</kbd></li>
                     
                     <li><span class="packt_screen">Also create XIB</span>: Unchecked
                     </li>
                     
                     <li><span class="packt_screen">Language</span>: <kbd>Swift</kbd></li>
                     
                  </ul>
                  
               </li>
               
            </ul>
            
            <ol start="4">
               
               <li>Click <span class="packt_screen">Next</span>, and then <span class="packt_screen">Create</span>.
               </li>
               
               <li>Update your file to the following:</li>
               
            </ol>
            <pre style="padding-left: 60px">class FilterCell: UICollectionViewCell {<br/>  @IBOutlet var lblName:UILabel!<br/>  @IBOutlet var imgThumb: UIImageView! <br/>}<br/><br/>extension FilterCell: ImageFiltering {<br/>  func set(image:UIImage, item:FilterItem) {<br/>    if item.filter != "None" {<br/>      let filteredImg = apply(filter: item.filter, originalImage: image)<br/>      imgThumb.image = filteredImg<br/>    }<br/>    else { imgThumb.image = image }<br/> <br/>    lblName.text = item.name<br/> <br/>    roundedCorners()<br/>  }<br/> <br/>  func roundedCorners() {<br/>    imgThumb.layer.cornerRadius = 9<br/>    imgThumb.layer.masksToBounds = true<br/>  }<br/>}</pre>
            <p style="padding-left: 60px">Our cell is pretty basic: we are setting an image and giving it rounded corners.</p>
            
            <ol start="6">
               
               <li>Open <kbd>PhotoFilter.storyboard</kbd>.
               </li>
               
               <li>In the Outline view, select the <span class="packt_screen">Collection View</span> cell. Then, in the Utilities panel, under the Identity inspector set the <span class="packt_screen">Custom Class</span> to <span class="packt_screen">FilterCell</span>.
               </li>
               
               <li>In the Attributes inspector, set the <span class="packt_screen">Identifier</span> to <span class="packt_screen">filterCell</span>.
               </li>
               
            </ol>
            
            <p> </p>
            
            <ol start="9">
               
               <li>Next, connect your outlets for both <kbd>lblName</kbd> and <kbd>imgThumb</kbd>.
               </li>
               
               <li>We need to make sure we can dismiss our modal when we click the <span class="packt_screen">Add Photo</span> button. We already added the method we needed, but we just need to add this to the
                  storyboard. CTL drag from <span class="packt_screen">Cancel</span> to the <span class="packt_screen">Exit</span> icon:
               </li>
               
            </ol>
            
            <div class="CDPAlignCenter CDPAlign"><img height="204" src="assets/ea622357-f11c-4373-825e-316424dc4eed.png" width="572"/></div>
            
            <ol start="11">
               
               <li>In the popup, select <kbd>unwindReviewCancelWithSegue</kbd>:
               </li>
               
            </ol>
            
            <div class="CDPAlignCenter CDPAlign"><img height="70" src="assets/ee2ec13c-1429-426a-b9df-fbb1767d4fe8.jpg" width="219"/></div>
            
            <ol start="12">
               
               <li>In the Navigation controller, select the Navigation bar in the Outline view. Then,
                  in the Attributes inspector, uncheck <span class="packt_screen">Translucent</span>:
               </li>
               
            </ol>
            
            <div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/106f8ba6-5457-41b7-a336-22fdb3553868.png"/></div>
            
            <p>Adding this makes sure our navigation bar is a solid white color and not translucent.</p>
            
            <p>We are done with setting up the cell and storyboard setup. Let's move to creating
               our View Controller.
            </p>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Creating our apply filter view controller</h1>
            
         </header>
         
         
         <article>
            
            
            <p>Now we need to create our <kbd>PhotoFilterViewController</kbd>:
            </p>
            
            <ol>
               
               <li>Right-click the <kbd>Photo Filter</kbd> folder in the <kbd>Controller</kbd> folder in the <kbd>Review</kbd> folder and select <span class="packt_screen">New File</span>.
               </li>
               
               <li>Inside the <span class="packt_screen">Choose a template for your new file</span> screen, select <span class="packt_screen">iOS</span> at the top, and then <span class="packt_screen">Cocoa Touch Class</span>. Then, hit <span class="packt_screen">Next</span>.
               </li>
               
               <li>In the options screen that appears, add the following:</li>
               
            </ol>
            
            <p style="padding-left: 60px">New file:</p>
            
            <ul>
               
               <li>
                  
                  <ul>
                     
                     <li><span class="packt_screen">Class</span>: <kbd>PhotoFilterViewController</kbd></li>
                     
                     <li><span class="packt_screen">Subclass</span>: <kbd>UIViewController</kbd></li>
                     
                     <li><span class="packt_screen">Also create XIB</span>: Unchecked
                     </li>
                     
                     <li><span class="packt_screen">Language</span>: <kbd>Swift</kbd></li>
                     
                  </ul>
                  
               </li>
               
            </ul>
            
            <ol start="4">
               
               <li>Click <span class="packt_screen">Next</span> and then <span class="packt_screen">Create</span>.
               </li>
               
            </ol>
            
            <p style="padding-left: 60px">When the file opens, delete everything after the <kbd>viewDidLoad()</kbd> method.
            </p>
            
            <ol start="5">
               
               <li>Then, add the following:</li>
               
            </ol>
            <pre style="padding-left: 60px">class PhotoFilterViewController: UIViewController {<br/>    var image: UIImage?<br/>    var thumbnail: UIImage?<br/>    let manager = FilterManager()<br/>    var selectedRestaurantID:Int?<br/>    var data:[FilterItem] = []<br/>    @IBOutlet var collectionView: UICollectionView!<br/>    @IBOutlet weak var imgExample: UIImageView!<br/><br/>    override func viewDidLoad() {<br/>        super.viewDidLoad()<br/>        initialize()<br/>    }<br/>}</pre>
            <p style="padding-left: 60px">Here, we are setting up our variables and our <kbd>initialize()</kbd> method. You can ignore the error, as we fix this next by creating an extension after
               our class definition.
            </p>
            
            <ol start="6">
               
               <li>Add the following extension:</li>
               
            </ol>
            <pre style="padding-left: 60px">// MARK: - Private Extension<br/>private extension PhotoFilterViewController {<br/> <br/>  func initialize() {<br/>    requestAccess()<br/>    setupCollectionView()<br/>    checkSource()<br/>  }<br/>}</pre>
            <p style="padding-left: 60px">We are creating some basic functions that we need.  Our first function is our <kbd>initialize()</kbd> method, which calls three new methods.  Let's create those three methods next.
            </p>
            
            <ol start="7">
               
               <li>Add the following methods after the <kbd>initialize()</kbd> method:
               </li>
               
            </ol>
            <pre style="padding-left: 60px">func requestAccess() {<br/>  AVCaptureDevice.requestAccess(for: AVMediaType.video) { granted in<br/>    if granted {}<br/>  }<br/>}<br/><br/>func setupCollectionView() {<br/>  let layout = UICollectionViewFlowLayout()<br/>  layout.scrollDirection = .horizontal<br/>  layout.sectionInset = UIEdgeInsets(top: 7, left: 7, bottom: 7, right: 7)<br/>  layout.minimumInteritemSpacing = 0<br/>  layout.minimumLineSpacing = 7<br/> <br/>  collectionView?.collectionViewLayout = layout<br/>  collectionView?.delegate = self<br/>  collectionView?.dataSource = self<br/>}<br/><br/>func checkSource() {<br/>  let cameraMediaType = AVMediaType.video<br/>  let cameraAuthorizationStatus = AVCaptureDevice.authorizationStatus(for: cameraMediaType)<br/> <br/>  switch cameraAuthorizationStatus {<br/>    case .authorized:<br/>    showCameraUserInterface()<br/>    case .restricted, .denied:<br/>    break<br/>    case .notDetermined:<br/>    AVCaptureDevice.requestAccess(for: cameraMediaType) { granted in<br/>      if granted {<br/>        self.showCameraUserInterface()<br/>      }<br/>    }<br/>  }<br/>}</pre>
            <p style="padding-left: 60px">Our next method, <kbd>setupCollectionView()</kbd> method, is our basic setup for our collection view. We are doing something different
               with the <kbd>delegate</kbd> and <kbd>dataSource</kbd>. In the previous chapters, we set this up using the Outlet inspector.  This time,
               I am setting them up in code. Either can be done; there is no right or wrong way,
               but pick one way and stick with it in the entire app. I did both only for demonstration
               purposes.
            </p>
            
            <p style="padding-left: 60px">The next method requests user access to their camera or the photo library. The <kbd>checkSource()</kbd>, checks whether you are running this in the simulator or phone. If you are running
               the simulator, you automatically get the photo library since there is no camera. If
               you are on a device, then the user has access to their camera. Now, we need to add
               two more helper methods. Let's add them first and then discuss after.
            </p>
            
            <ol start="8">
               
               <li>Add the following methods:</li>
               
            </ol>
            <pre style="padding-left: 60px">func showApplyFilter() {<br/>    manager.fetch { (items) in<br/>        if data.count &gt; 0 { data.removeAll() }<br/>        data = items<br/>        if let image = self.image {<br/>            imgExample.image = image<br/>            collectionView.reloadData()<br/>        }<br/>    }<br/>}<br/><br/>func filterItem(at indexPath: IndexPath) -&gt; FilterItem{<br/>    return data[indexPath.item]<br/>}</pre>
            <p>The first method <kbd>showApplyFilter()</kbd> is used to create the filter content inside of our collection view. The <kbd>filterItem(at:)</kbd> is used when the user selects a <kbd>filter</kbd> item.  We will pass the index position of the Collection View and create a filter
               item from it.  This item is used to display the currently selected filter in the larger
               image above our Collection View. 
            </p>
            
            <p>Let's work on getting items displayed in our Collection View. As we have done in the
               past, we have a few methods that are required for our Collection View to display cells.
               Add the following extension under our private extension:
            </p>
            <pre>extension PhotoFilterViewController: UICollectionViewDataSource {<br/>    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int {<br/>        return data.count<br/>    }<br/><br/>    func numberOfSections(in collectionView: UICollectionView) -&gt; Int {<br/>        return 1<br/>    }<br/><br/>    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell {<br/>        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "filterCell", for: indexPath) as! FilterCell<br/>        let item = self.data[indexPath.row]<br/>        if let img = self.thumbnail {<br/>            cell.set(image: img, item: item)<br/>        }<br/>        return cell<br/>    }<br/>}</pre>
            <p>We have done this before, but let's go over the methods again. Our <kbd>-collectionView:numberOfItemsInSection:</kbd> is responsible for the number of items in each section. For this collection view,
               it means the number of filter items we are going to display. Next, we have <kbd>-numberOfSectionsInCollectionView:</kbd>, which tells our Collection View how many sections we have; in our case, we only
               have one. Finally, we have the <kbd>-collectionView:cellForItemAtIndexPath:</kbd> this is the method that gets run for every cell we need to create. In this method,
               we are creating a filter cell.
            </p>
            
            <p>Now that we have our basic collection view set up, we need to make sure our Collection
               View is laid out correctly. Let's add another extension in this file that is responsible
               for the layout of items for our Collection View. Add the following extension and method
               after the last extension we just added:
            </p>
            <pre>extension PhotoFilterViewController: UICollectionViewDelegateFlowLayout {<br/>    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -&gt; CGSize {<br/>        let screenRect = collectionView.frame.size.height<br/>        let screenHt = screenRect - 14<br/>        return CGSize(width: 150, height: screenHt)<br/>    }<br/>}</pre>
            <p>This extension just sets up our cell size and spacing. Save the file. Next, let's
               hook up our two <kbd>IBOutlets</kbd>:
            </p>
            
            <ol>
               
               <li>Open the <kbd>PhotoFilter.storyboard</kbd>.
               </li>
               
               <li>Select the View Controller in the Outline view, and then the Identity inspector in
                  the Utilities panel.
               </li>
               
               <li>Under <span class="packt_screen">Custom Class</span>, in the <span class="packt_screen">Class</span> drop-down menu, select or type <kbd>PhotoFilterViewController</kbd> and hit <em>Enter</em>.
               </li>
               
               <li>Then, select the Connections inspector in the Utilities panel.</li>
               
               <li>Under Outlets, click and drag from the empty circle of each of the components, <kbd>imgExample</kbd>, <kbd>collectionView</kbd>, and <kbd>onPhotoTapped:</kbd>, to the <kbd>Image View</kbd>, <kbd>CollectionView View</kbd>, <kbd>Camera Icon (inside Navigation Bar at the top)</kbd>, respectively, in the scene. Now, please open the <kbd>PhotoFilterViewController.swift</kbd> file again, and let's add some more code.
               </li>
               
            </ol>
            
            <p style="padding-left: 60px">Our Collection View is set up, but we need to add some more code before we can get
               everything else working. Next, we need to add two more extensions that handle when
               a user uses the camera and photo library and the second one that is for our custom
               protocol we created earlier. We will need to use <kbd>AVFoundation</kbd> and <kbd>MobileCoreServices</kbd> in our app. <kbd>AVFoundation</kbd> is a framework that gives us access to the camera and <kbd>MobileCoreServices</kbd> gives us access to the filters. At the top of the file under import <kbd>UIKit</kbd>: 
            </p>
            <pre style="padding-left: 60px">import AVFoundation<br/>import MobileCoreServices</pre>
            <ol start="6">
               
               <li>Now, let's add the first extension we will need for access to the camera and photo
                  library:
               </li>
               
            </ol>
            <pre style="padding-left: 60px">extension PhotoFilterViewController: UIImagePickerControllerDelegate, UINavigationControllerDelegate {<br/><br/>    func imagePickerControllerDidCancel(_ picker: UIImagePickerController) {<br/>        picker.dismiss(animated: true, completion: nil)<br/>    }<br/><br/>    func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) {<br/>        let image = info[UIImagePickerControllerEditedImage] as? UIImage<br/>        if let img = image {<br/>            self.thumbnail = generate(image: img, ratio: CGFloat(102))<br/>            self.image = generate(image: img, ratio: CGFloat(752))<br/>        }<br/>        picker.dismiss(animated: true, completion: {<br/>            self.showApplyFilter()<br/>        })<br/>    }<br/><br/>    func showCameraUserInterface() {<br/>        let imagePicker = UIImagePickerController()<br/>        imagePicker.delegate = self<br/>        #if (arch(i386) || arch(x86_64)) &amp;&amp; os(iOS)<br/>            imagePicker.sourceType = UIImagePickerControllerSourceType.photoLibrary<br/>        #else<br/>            imagePicker.sourceType = UIImagePickerControllerSourceType.camera<br/>            imagePicker.showsCameraControls = true<br/>        #endif<br/>        imagePicker.mediaTypes = [kUTTypeImage as String]<br/>        imagePicker.allowsEditing = true<br/>        self.present(imagePicker, animated: true, completion: nil)<br/>    }<br/><br/>    func generate(image:UIImage, ratio:CGFloat) -&gt; UIImage {<br/>        let size = image.size<br/>        var croppedSize:CGSize?<br/>        var offsetX:CGFloat = 0.0<br/>        var offsetY:CGFloat = 0.0<br/>        if size.width &gt; size.height {<br/>            offsetX = (size.height - size.width) / 2<br/>            croppedSize = CGSize(width: size.height, height: size.height)<br/>        }<br/>        else {<br/>            offsetY = (size.width - size.height) / 2<br/>            croppedSize = CGSize(width: size.width, height: size.width)<br/>        }<br/>        guard let cropped = croppedSize, let cgImage = image.cgImage else {<br/>            return UIImage()<br/>        }<br/>        let clippedRect = CGRect(x: offsetX * -1, y: offsetY * -1, width: cropped.width, height: cropped.height)<br/>        let imgRef = cgImage.cropping(to: clippedRect)<br/>        let rect = CGRect(x: 0.0, y: 0.0, width: ratio, height: ratio)<br/>        UIGraphicsBeginImageContext(rect.size)<br/>        if let ref = imgRef {<br/>            UIImage(cgImage: ref).draw(in: rect)<br/>        }<br/>        let thumbnail = UIGraphicsGetImageFromCurrentImageContext()<br/>        UIGraphicsEndImageContext()<br/>        guard let thumb = thumbnail else { return UIImage() }<br/>        return thumb<br/>    }<br/>}</pre>
            <p>This extensions that we created for <kbd>UIImagePickerControllerDelegate</kbd> and <kbd>UINavigationControllerDelegate</kbd> have two methods we need to implement. We also have some custom helper methods that
               we use. The <kbd>-imagePickerControllerDidCancel: method()</kbd> is called when the user hit the <span class="packt_screen">Cancel</span> button; therefore, we just dismiss the <kbd>Controller</kbd> and do nothing.
            </p>
            
            <p>The <kbd>-imagePickerController:didFinishPickingMediaWithInfo: method()</kbd> is used when we get the image from the <kbd>Picker</kbd> once it is dismissed. We set our thumbnail and image values here; then, we apply
               the <kbd>generate()</kbd> method in order to get them in a smaller size. Finally, we dismiss the <kbd>Controller</kbd> and then call <kbd>showApplyFilter()</kbd> to add our selected image to our filter view.
            </p>
            
            <p>The <kbd>showCameraUserInterface()</kbd> is used to show the camera interface along with the camera controls. As I mentioned
               earlier, the code first checks to see if you are running the simulator and, if so,
               it shows the photo library. If you are running on a device, you see the camera interface. 
               The <kbd>generate(image:ratio:)</kbd> method is what we use to take the images and crop them to the size we need and return
               an image in a smaller size. The photo library and camera images are quite large. Therefore,
               if we did not use this method, it would take a long time for UI to go through and
               do everything we need.
            </p>
            
            <p>We just have one more extension to add, and that is for the custom protocols we created
               earlier. Add the following extension at the bottom of your <kbd>PhotoFilterViewController</kbd>:
            </p>
            <pre>extension PhotoFilterViewController: ImageFiltering, ImageFilteringDelegate {<br/>    func filterSelected(item: FilterItem) {<br/>        let filteredImg = image<br/>        if let img = filteredImg {<br/>            if item.filter != "None" {<br/>                imgExample.image = self.apply(filter: item.filter, originalImage: img)<br/>            }<br/>            else {<br/>                imgExample.image = img<br/>            }<br/>        }<br/>    }<br/>}</pre>
            <p>The <kbd>filterSelected(item:)</kbd> gets the selected filter item and applies the filter to our <kbd>imgExample</kbd>. We have an <kbd>if</kbd> statement that checks to see if the user selected <kbd>None</kbd> and, if so, shows the image without any filters. Before we can run it, we need to
               get the user's permission to use the camera or access the user's photo library.
            </p>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Getting permission </h1>
            
         </header>
         
         
         <article>
            
            
            <p>Apple requires that, if we use the camera or access the camera roll, we must let the
               user know that we are doing so and why. If you fail to do this, your code regarding
               the camera will not work and your app will be rejected when you submit it. Let's take
               care of this now.
            </p>
            
            <p>Open the <kbd>Info.plist</kbd> file and add the following two keys by hovering over any key and hitting the plus
               icon for the first key and then repeating for the second key:
            </p>
            
            <ul>
               
               <li><kbd>- NSPhotoLibraryUsageDescription</kbd></li>
               
               <li><kbd>- NSCameraUsageDescription</kbd></li>
               
            </ul>
            
            <p>For each key's value, enter anything you want as an alert that the user will see.
               In the following example, the value is set as <kbd>The app uses your camera to take pictures</kbd>:
            </p>
            
            <div class="CDPAlignCenter CDPAlign"><img height="263" src="assets/b3c3c983-671b-4a3c-bb33-d738260d8c1f.png" width="443"/></div>
            
            <p>Please make sure if you are submitting this to the store that you put in the appropriate
               verbiage. This verbiage is seen by the user as well as Apple. Let's build and run
               the project by hitting the Play button (or using <em>cmd</em> + <em>R</em>). You should now be able to get a photo from the photo library or use the camera.
            </p>
            
            <div class="CDPAlignCenter CDPAlign"><img height="516" src="assets/adf72994-dd24-4815-bd02-9284256f4e34.png" width="274"/></div>
            
            <p>Once you have a photo, the window dismisses and you can apply a filter and save it.</p>
            
            <p class="mce-root"/>
            
            <div class="CDPAlignCenter CDPAlign"><img height="504" src="assets/d4f95a4a-5447-4595-b21a-fd81402aa6d8.png" width="270"/></div>
            
            <p>We are not actually saving the photo yet. We do this in the next chapter.</p>
            
            
            
         </article>
         
         
         
      </section>
      
   

      
      <section>
         
         
         <header>
            
            <h1 class="header-title">Summary</h1>
            
         </header>
         
         
         <article>
            
            
            <p>In this chapter, we covered a lot of new things. You learned how to use the camera
               and how to integrate the camera roll when a camera is not available. We used a <kbd>UICollectionView</kbd> horizontally for the first time, to put in a row of images. This chapter had a lot
               of code and there may be some parts that were confusing. Review these parts and make
               sure that you fully understand them. There are numerous things in this chapter that
               you can reuse in many other apps.
            </p>
            
            <p>In the next chapter, we will be able to save photos and reviews to restaurants.</p>
            
            
            
         </article>
         
         
         
      </section>
      
   </body></html>