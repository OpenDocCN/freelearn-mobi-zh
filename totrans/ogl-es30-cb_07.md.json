["```java\n               LOCAL_PATH := $(call my-dir)\n               include $(CLEAR_VARS)\n\n               LOCAL_MODULE    := GLPipng\n               LOCAL_SRC_FILES := png.c pngerror.c pngget.c \\\n               pngmem.c pngpread.c pngread.c pngrio.c \\\n               pngrtran.c pngrutil.c pngset.c pngtrans.c \\\n               pngwio.c pngwrite.c pngwtran.c pngwutil.c\n\n               LOCAL_LDLIBS := -lz\n               LOCAL_CFLAGS := -I. -g\n               include $(BUILD_SHARED_LIBRARY)\n        ```", "```java\n    include $(MY_CUR_LOCAL_PATH)/../ ../../../GLPIFramework/libpng/Android.mk\n    ```", "```java\n    LOCAL_SHARED_LIBRARIES := GLPipng\n    ```", "```java\n    <manifest ...><uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />...</manifest>\n    ```", "```java\n    SimpleText::SimpleText( Renderer* parent ){\n        . . . .\n       modelType          = ImageDemoType;\n       char fname[MAX_PATH]= {\"\"};\n\n        #ifdef __APPLE__\n          GLUtils::extractPath( getenv( \"FILESYSTEM\" ), fname );\n        #else\n           strcpy( fname, \"/sdcard/Images/\" );\n        #endif\n\n        strcat( fname, \"cartoon.png\" );\n        image = new PngImage();\n        image->loadImage(fname);\n    }\n    ```", "```java\n        void PngImage::loadImage(char* fileName, bool generateTexID = true, GLenum target = GL_TEXTURE_2D );\n        ```", "```java\n        bool PngImage::loadImage(char* fileName, \n                       bool generateTexID, GLenum target ){\n\n        // Get the image bits from the png file.\n        memData.bitsraw = read_png_file( fileName);\n\n           // Generate the texture ID if it is not produced before\n           if ( generateTexID ){\n                GLuint texID;\n                glGenTextures ( 1,&texID );\n                memData.texID = texID;\n\n              // Depending upon the target type bind the\n              // texture using generated texture ID handler \n\n                if (target == GL_TEXTURE_2D){\n                    glBindTexture(GL_TEXTURE_2D,texID );\n                }\n           // Similarly, handle cases like GL_TEXTURE_2D, \n                // GL_TEXTURE_3D, and GL_TEXTURE_2D_ARRAY etc.\n            }\n\n            // Get the colorType from ligpng for current \n            // image and prepare the texture accordingly\n            switch (colorType) {\n               case PNG_COLOR_TYPE_RGB_ALPHA: {\n                    glTexImage2D ( target,  0, GL_RGBA,\n                     memData.width, memData.height, 0, GL_RGBA,\n                     GL_UNSIGNED_BYTE,memData.bitsraw);\n                break; \n                }\n               // Similarly, handle other cases: -\n              // PNG_COLOR_TYPE_GRAY,PNG_COLOR_TYPE_RGBetc.\n\n            }\n\n                     // Release the allocate memory for image bits.\n            free(memData.bitsraw);\n            memData.bitsraw=NULL;return true;\n        }\n        ```", "```java\n        void glGenTextures(GLsizei n, GLuint * textures);\n        ```", "```java\n        GLuint texID;\n        glGenTextures   ( 1,&texID );\n        memData.texID = texID;\n        ```", "```java\n             if (target == GL_TEXTURE_2D){\n                glBindTexture ( GL_TEXTURE_2D,texID );\n              }\n    ```", "```java\n        void glBindTexture(GLenum target, GLuint texture);\n        ```", "```java\n    glTexImage2D ( target, 0, GL_RGBA,  memData.width,\n    memData.height,0,GL_RGBA,GL_UNSIGNED_BYTE,memData.bitsraw);\n    ```", "```java\n        void glTexImage2D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * data);\n        ```", "```java\n    #version 300 es\n    layout(location = 0) in vec3  VertexPosition;\n    layout(location = 1) in vec2  VertexTexCoord;\n    out vec2 TexCoord;\n    uniform mat4 ModelViewProjectMatrix;\n\n    void main( void ) {\n      TexCoord = VertexTexCoord;\n      gl_Position=ModelViewProjectMatrix*vec4(VertexPosition,1.0);\n    }\n    ```", "```java\n    #version 300 es\n    precision mediump float;\n    in vec2 TexCoord;\n    uniform sampler2D Tex1;\n    layout(location = 0) out vec4 outColor;\n\n    void main() {\n        outColor = texture(Tex1, TexCoord);\n    }\n    ```", "```java\n    float quad[12] = { -1.0, -1.0,  0.0, 1.0, -1.0,  0.0,\n                       -1.0, 1.0, -0.0, 1.0, 1.0, -0.0 };\n    float texCoords[8] = { 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0 };\n    ```", "```java\n    glActiveTexture(GL_TEXTURE0); //Make texture unit 0 active.\n    glBindTexture(GL_TEXTURE_2D, image->getTextureID());\n    ```", "```java\n       TEX = ProgramManagerObj->ProgramGetUniformLocation\n                               ( program, (char *) \"Tex1\" );\n        glUniform1i(TEX, 0);\n    ```", "```java\n       glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);\n       glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n       glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_CLAMP_TO_EDGE);\n       glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_CLAMP_TO_EDGE);\n    ```", "```java\n          glUseProgram(program->ProgramID);\n          glDisable(GL_CULL_FACE); // Disable culling\n          glEnable(GL_BLEND);      // Enable blending\n          glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);\n                                   //Send Vertices\n          glEnableVertexAttribArray(VERTEX_POSITION); \n          glEnableVertexAttribArray(TEX_COORD); //Send Tex Coordinate\n          glVertexAttribPointer\n          TEX_COORD, 2, GL_FLOAT, GL_FALSE, 0, texCoords);\n          glVertexAttribPointer\n          (VERTEX_POSITION, 3, GL_FLOAT, GL_FALSE, 0, quad);\n          glUniformMatrix4fv\n          ( MVP, 1, GL_FALSE,( float * )TransformObj->\n          TransformGetModelViewProjectionMatrix() );\n    ```", "```java\n   TEX = ProgramManagerObj->ProgramGetUniformLocation\n   ( program, (char *) \"Tex1\" );\n   glUniform1i(TEX, 0);\n```", "```java\nvoid glGenerateMipmap(GLenum target);\n```", "```java\n   struct ETC2Header {\n     char name[4];                 // \"PKM \"\n     char version[2];              // \"20\" for ETC2\n     unsigned short format;        // Format\n     unsigned short paddedWidth;   // Texture width,(big-endian)\n     unsigned short paddedHeight;  // Texture height,(big-endian)\n     unsigned short origWidth;    // Original width(big-endian)\n     unsigned short origHeight;   // Original height(big-endian)\n   };\n```", "```java\nvoid glCompressedTexImage2D(GLenum target, GLint level, Glint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum imageSize, const GLvoid * data);\n```", "```java\n        char fname[MAX_PATH]= {\"\"};\n        #ifdef __APPLE__\n        GLUtils::extractPath( getenv( \"FILESYSTEM\" ), fname );\n        #else\n        strcpy( fname, \"/sdcard/Images/\" );\n        #endif\n        strcat( fname, \"SmallEarth.pkm\" );\n       compressImage = new CompressedImage();\n       compressImage->loadImage(fname);\n    ```", "```java\n       FILE *fp = fopen(fileName, \"rb\");\n       if (!fp){ return false; }\n       ETC2Header pkmfile;    \n       fread(&pkmfile, sizeof(ETC2Header), 1, fp);\n    ```", "```java\n       pkmfile.format      = swap_uint16(pkmfile.format);\n       pkmfile.paddedWidth = swap_uint16(pkmfile.paddedWidth);\n       pkmfile.paddedHeight = swap_uint16(pkmfile.paddedHeight);\n       pkmfile.origWidth   =  swap_uint16(pkmfile.origWidth);\n       pkmfile.origHeight  = swap_uint16(pkmfile.origHeight);\n    ```", "```java\n       memData.width   = pkmfile.paddedWidth;  // Texture Width\n       memData.height  = pkmfile.paddedHeight; // Texture Height\n\n       // This only handles the pkmfile format\n       unsigned int imageSize =       ceil(memData.width/4)*ceil(memData.height/4)*8;\n       memData.bitsraw = (unsigned char*) malloc(imageSize);\n\n       fread(memData.bitsraw, imageSize, 1, fp); //Load Payload\n       if (!memData.bitsraw){ return false; }\n    ```", "```java\n       GLuint texID;\n       glGenTextures( 1,&texID );\n       glBindTexture( GL_TEXTURE_2D,texID );\n       glCompressedTexImage2D(GL_TEXTURE_2D, 0, GL_COMPRESSED_RGB8\n       _PUNCHTHROUGH_ALPHA1_ETC2, memData.width,memData.height,\n       0,imageSize, memData.bitsraw);\n    ```", "```java\nimageSize = ceil(memData.width/4) * ceil(memData.height/4) * 8;\n```", "```java\n    #version 300 es\n    precision mediump float;\n\n    in vec2 TexCoord;\n    uniform sampler2D TexFragile; // First Texture\n    uniform sampler2D TexWood;    // Second Texture\n\n    layout(location = 0) out vec4 Color;\n\n    void main() {\n       vec4 TextureFragile = texture(TexFragile, TexCoord);\n       vec4 TextureWood    = texture(TexWood, TexCoord);  \n       Color=mix(TextureWood,TextureFragile,TextureFragile.a);\n    }\n    ```", "```java\n    void MultipleTexture::loadMultiTexture(){\n        glUseProgram( program->ProgramID );\n        // Query uniform samplers location\n        TEX  = ProgramManagerObj->ProgramGetUniformLocation\n                        ( program, (char *) \"TexFragile\" );\n        TEX2 = ProgramManagerObj->ProgramGetUniformLocation\n                        ( program, (char *) \"TexWood\" );\n    }\n    ```", "```java\n         glActiveTexture(GL_TEXTURE1);\n          image = new PngImage();\n          image->loadImage(creatPath(fname, (char*)\"fragile.png\"));\n    ```", "```java\n       glTexParameterf\n       (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n       glTexParameterf\n       (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n       glUniform1i(TEX, 1);\n    ```", "```java\n       glUniform1i(TEX, 1); // Attached to texture unit 1\n    ```", "```java\n       glActiveTexture(GL_TEXTURE2);\n       image->loadImage(creatPath(fname, (char*)\"woodenBox.png\"));\n       image2 = new PngImage();\n       image2->loadImage(fname);\n       glTexParameterf\n       (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n       glTexParameterf\n       (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n       glUniform1i(TEX2, 2); // Attached to texture unit 2\n    ```", "```java\n    //CubeMappingVertex.glsl\n    #version 300 es\n\n    layout(location = 0) in vec4  VertexPosition;\n    uniform mat4 MVP;\n    out vec4 Vertex;\n\n    void main( void ) {\n      Vertex = VertexPosition;\n      gl_Position\n\n    x       =MVP*VertexPosition;\n    }\n    ```", "```java\n    //CubeMappingFragment.glsl\n    #version 300 es\n    precision mediump float;\n    uniform samplerCube CubeMapTexture;\n    in vec4 Vertex;\n    layout(location = 0) out vec4 outColor;\n\n    void main() {\n     outColor = texture(\n      CubeMapTexture, Vertex.xyz);\n    }\n    ```", "```java\n    void Cube::InitModel(){\n       //Load and compile shaders . . . .\n       . . . .\n       createCubeMap(); // Create the Cube Map\n    }\n\n    void Skybox::createCubeMap(){\n       glActiveTexture(GL_TEXTURE1);\n       char fname[MAX_PATH]= {\"\"};\n       image = new PngImage();\n\n       image->loadImage(creatPath(fname, (char*)\"Right.png\"),\n                     true,  GL_TEXTURE_CUBE_MAP_POSITIVE_X);\n       image->loadImage(creatPath(fname, (char*)\"Left.png\"),  \n                      false, GL_TEXTURE_CUBE_MAP_NEGATIVE_X);\n       image->loadImage(creatPath(fname, (char*)\"Top.png\"),\n                      false, GL_TEXTURE_CUBE_MAP_POSITIVE_Y);\n       image->loadImage(creatPath(fname, (char*)\"Bottom.png\"),\n                      false, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y);\n       image->loadImage(creatPath(fname, (char*)\"Front.png\"),  \n                      false, GL_TEXTURE_CUBE_MAP_POSITIVE_Z);\n       image->loadImage(creatPath(fname, (char*)\"Back.png\"),\n                      false, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z);\n\n       glTexParameterf(GL_TEXTURE_CUBE_MAP,\n                      GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n       glTexParameterf(GL_TEXTURE_CUBE_MAP,\n                      GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\n       // The clamping is important for Skyboxes \n       // due to texel filtering\n       glTexParameterf(GL_TEXTURE_CUBE_MAP,\n                      GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);\n       glTexParameterf(GL_TEXTURE_CUBE_MAP,\n                      GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n       glTexParameterf(GL_TEXTURE_CUBE_MAP,\n                      GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n\n       uniformTex=ProgramManagerObj->ProgramGetUniformLocation\n                      (program,(char*)\"CubeMapTexture\" );\n\n       if (uniformTex >= 0)\n          { glUniform1i(uniformTex, 1); }\n    }\n    ```", "```java\n    glActiveTexture(GL_TEXTURE1);\n    ```", "```java\n       void Skybox::Render(){\n       glDisable(GL_CULL_FACE); glDisable(GL_DEPTH_TEST);\n       glUseProgram( program->ProgramID );\n       // Transform as per your scene requirement. . .\n       glBindBuffer( GL_ARRAY_BUFFER, vId );\n       glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, iId );\n       glDrawElements(GL_TRIANGLES,36,GL_UNSIGNED_SHORT,(void*)0);\n             }\n    ```", "```java\n    #include \"ObjLoader.h\"\n    #include \"Skybox.h\"\n\n    void Renderer::createModels(){\n       clearModels();\n       addModel( new Skybox ( this ) );\n       addModel( new ObjLoader ( this ) );\n    }\n    ```", "```java\n    #version 300 es\n\n    // Vertex information\n    layout(location = 0) in vec4  VertexPosition;\n    layout(location = 1) in vec3  Normal;\n    uniform vec3    CameraPosition;\n\n    // Model View Project matrix\n    uniform mat4    MODELVIEWPROJECTIONMATRIX, MODELMATRIX;\n    uniform mat3    NormalMatrix;\n\n    vec3 worldCoordPosition, worldCoordNormal;\n    out vec3 reflectedDirection;\n\n    void main( void ) {\n       worldCoordPosition = vec3(MODELMATRIX * VertexPosition);\n       worldCoordNormal   = normalize(vec3( MODELMATRIX *\n       vec4(Normal, 0.0)));\n\n       // Make negative normals positive so that the face \n       // of back side will still remain illuminated, \n       // otherwise these will appear complete black \n       // when object is rotated and back side faces\n        // the camera.\n       if(worldCoordNormal.z < 0.0){\n          worldCoordNormal.z = -worldCoordNormal.z;\n        }\n        worldView = normalize(CameraPosition – worldCoordPosition);\n        reflectedDirection = reflect(worldView, worldCoordNormal );\n        gl_Position = MODELVIEWPROJECTIONMATRIX * VertexPosition;\n    }\n    ```", "```java\n    #version 300 es\n    precision mediump float;\n    uniform samplerCube CubeMap;\n    in vec3    reflectedDirection;\n\n    layout(location = 0) out vec4 outColor;\n    void main() {\n        outColor = texture(CubeMap, reflectedDirection); }\n    ```", "```java\n    uniform float    RefractIndex;\n    out vec3 refractedDirection;\n    void main() {\n      . . . . . .\n      refractedDirection =\n          -refract(worldView, worldCoordNormal, RefractIndex);\n      gl_Position = MODELVIEWPROJECTIONMATRIX * VertexPosition;\n    }\n    ```", "```java\n    void ObjLoader::InitModel()\n    {\n       glUseProgram( program->ProgramID );\n       char uniformTex = ProgramManagerObj>\n       ProgramGetUniformLocation(program, (char*)\"CubeMap\");\n       if (uniformTex >= 0) {\n       glUniform1i(uniformTex, 1);\n       }\n       char Camera = ProgramManagerObj->\n       ProgramGetUniformLocation(program, \"CameraPosition\");\n       if (Camera >= 0){\n       glm::vec3 cp = RendererHandler->getCameraPosition();\n       glUniform3fv(Camera, 1, (float*)&cp);\n       }\n\n       MVP = ProgramManagerObj->ProgramGetUniformLocation\n       ( program, ( char* )\"MODELVIEWPROJECTIONMATRIX\" );\n       M   = ProgramManagerObj->ProgramGetUniformLocation\n       ( program, ( char* )\"MODELMATRIX\" );\n       NormalMatrix  = ProgramManagerObj->\n       ProgramGetUniformLocation(program, (char*)\"NormalMatrix\");\n       return;\n    }\n    ```", "```java\ngenType reflect(genType I, genType N);\n```", "```java\ngenType refract(genType I, genType N, float RI);\n```", "```java\n    #include \"ObjLoader.h\"\n    #include \"SimpleTexture.h\"\n    class DemoFBO : public Model\n    {\n     private:\n        void InitModel();\n        ObjLoader* objModel;\n        SimpleText* textureQuad;\n        GLuint fboId, rboId, textureId, depthTextureId;\n     public:\n        DemoFBO( Renderer* parent = 0);\n        ~DemoFBO();\n        unsigned int generateTexture\n    (int width,int height,bool isDepth=false);\n        void GenerateFBO(); . . . .\n    };\n    ```", "```java\n    unsigned int DemoFBO::generateTexture\n    (int width, int height, bool isDepth) {\n    unsigned int texId;\n    glGenTextures(1, &texId);\n        glBindTexture(GL_TEXTURE_2D, texId);\n       . . . . Set Minification and Maxification filters\n       if (isDepth){\n         glTexImage2D( GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT32F,\n             width, height, 0,GL_DEPTH_COMPONENT, GL_FLOAT, 0);  \n       }\n       else{\n         glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height,\n             0, GL_RGBA, GL_UNSIGNED_BYTE, 0);\n       }\n\n       int error;\n       error = glGetError();\n       if(error != 0){\n          std::cout<<\"Error: Fail to generate texture.\"<<error;\n       }\n       glBindTexture(GL_TEXTURE_2D,0);\n       return texId;\n    }\n    ```", "```java\n    void DemoFBO::GenerateFBO(){\n       // create a frame buffer object\n       glGenFramebuffers(1, &fboId);\n       glBindFramebuffer(GL_FRAMEBUFFER, fboId);\n\n       textureId = createTexture(TEXTURE_WIDTH,TEXTURE_HEIGHT);\n       depthTextureId = createTexture(\n       TEXTURE_WIDTH,TEXTURE_HEIGHT, true);\n       // attach texture to FBO color attachment point\n       glFramebufferTexture2D(\n       GL_FRAMEBUFFER,       //1.fbo target: GL_FRAMEBUFFER\n       GL_COLOR_ATTACHMENT0, //2.Color attachment point\n       GL_TEXTURE_2D,        //3.tex target: GL_TEXTURE_2D\n       textureId,            //4.Color texture ID\n       0);                   //5.mipmap level: 0(base)\n\n       // Attach texture to FBO depth attachment point\n       glFramebufferTexture2D(\n       GL_FRAMEBUFFER,       //1.fbo target: GL_FRAMEBUFFER\n       GL_DEPTH_ATTACHMENT,  //2.Depth attachment point\n       GL_TEXTURE_2D,        //3.tex target: GL_TEXTURE_2D\n       depthTextureId,       //4.depth texture ID\n       0);                   //5.mipmap level: 0(base)\n\n       // check FBO status\n       GLenum status = glCheckFramebufferStatus(GL_FRAMEBUFFER);\n       if(status != GL_FRAMEBUFFER_COMPLETE){\n       printf(\"Framebuffer creation fails\");\n       }\n    }\n    ```", "```java\n    void DemoFBO::InitModel(){\n       objModel->InitModel();\n       textureQuad->InitModel();\n       GenerateFBO();\n    }\n    ```", "```java\n    void DemoFBO::Render(){// Render to Texture\n        int CurrentFbo;\n        glGetIntegerv(GL_FRAMEBUFFER_BINDING, &CurrentFbo);\n        glBindFramebuffer(GL_FRAMEBUFFER,fboId);\n        glViewport(0, 0, TEXTURE_WIDTH, TEXTURE_HEIGHT);\n        glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);\n        objModel->Render();\n        glBindFramebuffer(GL_FRAMEBUFFER, CurrentFbo);\n        TransformObj->TransformError();\n\n        // Render Quad with render buffer mapped.\n        glViewport(0, 0, RendererHandler->screenWidthPixel()*2,\n                    RendererHandler->screenHeightPixel()*2);\n        glClearColor(0.710,0.610,0.30,1.0);\n        glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);\n        glActiveTexture (GL_TEXTURE0);\n        glBindTexture(GL_TEXTURE_2D, textureId);\n        textureQuad->Render();\n        TransformObj->TransformError();\n    }\n    ```", "```java\nglFramebufferTexture2D(GL_FRAMEBUFFER,GL_COLOR_ATTACHMENT0,GL_TEXTURE_2D,textureId,0);  \nglFramebufferTexture2D(GL_FRAMEBUFFER,GL_DEPTH_ATTACHMENT,GL_TEXTURE_2D,depthTextureId,0);\n```", "```java\nvoid glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);\n```", "```java\nvoid DemoFBO::GenerateFBOWithRenderBuffer()\n{\n    // create a frame buffer object\n    glGenFramebuffers(1, &fboId);\n    glBindFramebuffer(GL_FRAMEBUFFER, fboId);\n    // attach the texture to FBO color attachment point\n    textureId = generateTexture(TEXTURE_WIDTH,TEXTURE_HEIGHT);\n    glFramebufferTexture2D(GL_FRAMEBUFFER,GL_COLOR_ATTACHMENT0,\n                           GL_TEXTURE_2D,textureId,0);\n    // create a renderbuffer object to store depth info\n    glGenRenderbuffers(1, &rboId);\n    glBindRenderbuffer(GL_RENDERBUFFER, rboId);\n    glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16,\n                            TEXTURE_WIDTH,TEXTURE_HEIGHT);\n\n    // attach the renderbuffer to depth attachment point\n    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,\n                             GL_RENDERBUFFER, rboId);\n\n    // check FBO status\n    GLenum status = glCheckFramebufferStatus(GL_FRAMEBUFFER);\n    if(status != GL_FRAMEBUFFER_COMPLETE)\n        {printf(\"Framebuffer creation fails\"); }\n}\n```", "```java\nvoid glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);\n```", "```java\n  GLsync glFramebufferRenderbuffer(GLenum target, GLenum\n    attachment, GLenum renderbuffertarget, GLuint renderbuffer);\n```", "```java\n    class HeightField: public Model\n    {\n\n    public:\n       HeightField(Renderer* parent, float rDimension, float\n                    cDimension, int Rows = 10, int Columns = 10);\n       ~HeightField();\n\n        void InitModel();             // Initialize Model class\n        void Render();               // Render the Model class\n\n    private:\n        Image* image;                // Image object\n       int imageHeight, imageWidth; // Image texture dimension\n        char MVP, TEX;               // uniform attrib locations\n        float rot;\n\n        GLint NormalMatrix;\n        GLuint HeightFieldVAO_Id;     // VAO of Height Field\n        GLuint vId, iId;              // VBO and IBO\n        int faces;                    // Number of faces\n\n        // Size of vertices, texture, faces indexes, color\n        int sizeofVertex, sizeofTex, sizeofFace, sizeofColor;\n        float *v, *n, *tex;           // temporary buffers\n        unsigned short *faceIdx;\n    };\n    ```", "```java\n              HeightField::HeightField(Renderer*parent, float rDimension,\n                                 float cDimension, int Rows, int Columns)\n    {\n        . . . .\n        // Load height map image & grass texture file.    \n         . . . . . .\n\n       // Load HeightMap.png\n       imageHeightMap->loadImage(fname); \n\n       // Load grass.png \n          imageGrass->loadImage(fname);    \n\n          faces = Rows * Columns; // Front side faces\n          v     = new float[3 * (Rows + 1) * (Columns + 1)];\n          n     = new float[3 * (Rows + 1) * (Columns + 1)];\n        tex   = new float[2 * (Rows + 1) * (Columns + 1)];\n\n          faceIdx= new  unsigned short [6 * Rows * Columns];\n          sizeofVertex = sizeof(float)*3*(Rows+1)*(Columns+1);\n          sizeofTex    = sizeof(float)*2*(Rows+1)*(Columns+1);\n        sizeofFace  = sizeof(unsigned short) * 6 * Rows * Columns;\n\n       float x2, z2; \n       x2     = rDimension/2.0f;     \n       z2     = cDimension/2.0f;\n\n       float zFactor, xFactor;    \n       zFactor   = cDimension/Columns;\n       xFactor   = rDimension/Rows;\n\n       float texi, texj;\n       texi       = 1.0f/Columns;   \n       texj       = 1.0f/ Rows;\n\n       float x, z; int vidx = 0, tidx = 0;\n\n       // Calculate the Vertices,Normals and TexCoords\n          for( int i = 0; i <= Columns; i++ ) {\n             z = zFactor * i - z2; // Column\n\n             for( int j = 0; j <= Rows; j++ ) {\n                 x = xFactor * j - x2; // Row\n\n                 // Vertex position\n                 v[vidx]      =x;\n                 v[vidx+1]   =0.0f;  \n                 v[vidx+2]   =z;\n\n                // Normals along +Y direction\n                n[vidx]      =0.0f; \n                n[vidx+1]    =1.0f;  \n                n[vidx+2]    =0.0f;\n\n                 // Jump to the next vertex index\n                  vidx += 3; \n\n                 // Texture coordinates\n                 tex[tidx]   =j*texj; \n                 tex[tidx+1] =i*texi;\n\n                 // Jump to the next vertex index\n                tidx += 2;\n            }\n        }\n\n       // Calculate the face indices\n        unsigned int rowStart, nextRowStart, idx = 0; \n        for( int i = 0; i < Columns; i++ ) {\n            rowStart = i * (Rows+1);\n            nextRowStart = (i+1) * (Rows+1);\n            for( int j = 0; j < Rows; j++ ) {\n                faceIdx[idx]    = rowStart + j;\n                faceIdx[idx+1]  = nextRowStart + j;\n                faceIdx[idx+2]  = nextRowStart + j + 1;\n                faceIdx[idx+3]  = rowStart + j;\n                faceIdx[idx+4]  = nextRowStart + j + 1;\n                faceIdx[idx+5]  = rowStart + j + 1;\n                idx += 6;\n            }\n        }\n\n         // Generate and bind the VBO and IBO\n        // Create the Vertex Array object for height field\n        . . . . . . .\n\n       // Refer to:- Managing VBO's with vertex array\n       // objects (VAO), OpenGL ES 3.0 New Features\n\n         // Bind the VBO and IBO for VAO and\n        // Delete temporary buffer\n        . . . . . . .\n    }\n    ```", "```java\n       void HeightField::InitModel(){\n    . .Compile and Link shaders\n\n       glUseProgram( program->ProgramID );    \n       TEX_HEIGHT = ProgramManagerObj->\n       ProgramGetUniformLocation(program, \"ImageTexture\");\n       glActiveTexture (GL_TEXTURE0);\n       if (imageHeightMap) {\n       glBindTexture(GL_TEXTURE_2D, imageHeightMap->getTextureID());\n       glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);\n    glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_REPEAT);\n\n    TEX_GRASS = ProgramManagerObj->\n    ProgramGetUniformLocation(program,\"ImageGrassTexture\");\n    glActiveTexture (GL_TEXTURE1);\n    if (imageGrass) {\n       glBindTexture(GL_TEXTURE_2D, imageGrass->getTextureID());\n\n       glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);\n       glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);\n       glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_REPEAT);\n       glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_REPEAT);\n    }\n\n       MVP = ProgramManagerObj->ProgramGetUniformLocation\n       ( program, (char*)\"ModelViewProjectionMatrix\" );\n       FACTOR = ProgramManagerObj->ProgramGetUniformLocation\n       ( program, (char*)\"heightFactor\" );\n       if ( FACTOR >= 0 ){\n       glUniform1f(FACTOR, 3);\n       }\n    }\n    ```", "```java\n    #version 300 es\n    layout(location = 0) in vec4  VertexPosition;\n    layout(location = 2) in vec2  TexCoords;\n    uniform mat4    ModelViewProjectionMatrix;\n\n    out vec2    TextureCoord;\n    out vec3    vertexColor;\n    uniform sampler2D HeightMapTexture;\n    uniform float heightFactor;\n    void main()\n    {\n        TextureCoord    = TexCoords;\n        vec4 height     = texture(HeightMapTexture, TexCoords);\n        if(heightFactor>0){\n            height /= heightFactor;\n        }else{\n           height = 0.333; // Assumption, some arbitrary value\n        }\n\n        gl_Position = ModelViewProjectionMatrix * vec4(\n               VertexPosition.x, height.r, VertexPosition.z, 1.0);\n    }\n    ```", "```java\n    #version 300 es\n    precision mediump float;\n\n    layout(location = 0) out vec4 FinalColor;\n    uniform sampler2D ImageGrassTexture;\n    in vec2    TextureCoord;\n\n    void main() {\n        FinalColor = texture(ImageGrassTexture, TextureCoord);\n    }\n    ```", "```java\n    void Renderer::createModels(){\n       clearModels();\n       addModel( new HeightField( this, 5, 5, 50, 50 ));\n    }\n    ```", "```java\n    #version 300 es\n    // Vertex information\n    layout(location = 0) in vec4  VertexPosition;\n    layout(location = 1) in vec3  Normal;\n    layout(location = 2) in vec2  TexCoords;\n    layout (location = 3) in vec4 VertexTangent;\n\n    // Model View Project matrix\n    uniform mat4    ModelViewProjectionMatrix, ModelViewMatrix;\n    uniform mat3    NormalMatrix;\n    uniform mediump vec3 LightPosition;\n    out vec2    textureCoord;\n    out vec3    eyeCoord;\n    out mat3    tangentSpace;\n\n    void main(){\n        // Transform normal and tangent to eye space\n        vec3 norm = normalize(NormalMatrix * Normal);\n        vec3 tang = normalize(NormalMatrix * vec3(VertexTangent));\n\n        // Compute the binormal\n        vec3 binormal = cross( norm, tang );\n\n        // Matrix for transformation to tangent space\n        tangentSpace = mat3(tang.x, binormal.x, norm.x, tang.y,\n             binormal.y, norm.y, tang.z, binormal.z, norm.z );\n\n        // Transform view direction to tangent space\n        eyeCoord=vec3(ModelViewMatrix*VertexPosition)*tangentSpace;\n        textureCoord = TexCoords;\n        gl_Position  = ModelViewProjectionMatrix * VertexPosition;\n    }\n    ```", "```java\n    #version 300 es\n    precision mediump float;\n\n    // Light information\n    uniform vec3 LightAmbient,LightSpecular,LightDiffuse, \n                                      LightPosition;\n\n    // Material information\n    uniform vec3 MaterialAmbient,MaterialSpecular, \n                                         MaterialDiffuse,;\n    uniform float ShininessFactor;\n\n    in vec2 textureCoord; \n    in vec3 eyeCoord;\n    in mat3 tangentSpace;\n    layout(location = 0) out vec4 FinalColor;\n\n    vec3 normalizeNormal, normalizeEyeCoord, normalizeLightVec;\n\n    vec3 V, R, ambient, diffuse, specular;\n\n    float sIntensity, cosAngle;\n\n    vec3 PhongShading( vec3 norm, vec3 MaterialDiffuse ) {\n        normalizeNormal   = normalize( norm ) ;\n        normalizeEyeCoord = normalize( eyeCoord);\n        normalizeLightVec = normalize( (LightPosition-eyeCoord)\n                              *tangentSpace);\n\n        // Diffuse Intensity\n        cosAngle = max( 0.0, dot(normalizeNormal,\n                             normalizeLightVec )); \n\n        // Viewer's vector\n        V = -normalizeEyeCoord; \n        R = reflect( -normalizeLightVec, normalizeNormal);\n        sIntensity = pow(max(0.0,dot(R,V)),ShininessFactor);\n\n        // ADS as result of Material & Light interaction\n        ambient = MaterialAmbient * LightAmbient;\n        diffuse = MaterialDiffuse * LightDiffuse * cosAngle;\n        specular= MaterialSpecular*LightSpecular*sIntensity;\n\n        return  ambient + diffuse + specular;\n    }\n\n    uniform sampler2D ImageTexture, ImageTextureNormal;\n\n    void main() {\n      //Lookup normal map\n       vec4 normalMap = texture(ImageTextureNormal, vec2(1.0-\n                       textureCoord.x, textureCoord.y));\n\n      //Convert[0,1] -> [-1,1]\n       normalMap      =  (2.0*normalMap-1.0); \n      vec4 texColor   = texture(ImageTexture, vec2(1.0 –\n                          textureCoord.x, textureCoord.y));\n       FinalColor     = vec4( PhongShading(normalMap.xyz,\n                          texColor.rgb), 1.0 );\n    }\n    ```", "```java\nbool OBJMesh::CalculateTangents(){\n    vector<vec3> tan1Accum, tan2Accum; // Accumulated tangents\n    objMeshModel.tangents.resize(objMeshModel.positions.size());\n\n    for( uint i = 0; i < objMeshModel.positions.size(); i++ ) {\n     tan1Accum.push_back(vec3(0.0f));tan2Accum.push_back(vec3(0.0f));\n     objMeshModel.tangents.push_back(vec4(0.0f));\n    }\n\n    int index0, index1, index2, index0uv, index1uv, index2uv;\n\n    // Compute the tangent vector\n    for( uint i = 0; i < objMeshModel.vecFaceIndex.size(); i += 3 ){\n       index0 = objMeshModel.vecFaceIndex.at(i).vertexIndex;\n       index1 = objMeshModel.vecFaceIndex.at(i+1).vertexIndex;\n       index2 = objMeshModel.vecFaceIndex.at(i+2).vertexIndex;\n\n      const vec3 &p0 = objMeshModel.positions.at(index0);\n      const vec3 &p1 = objMeshModel.positions.at(index1);\n      const vec3 &p2 = objMeshModel.positions.at(index2);\n\n      index0uv = objMeshModel.vecFaceIndex.at(i).uvIndex;\n      index1uv = objMeshModel.vecFaceIndex.at(i+1).uvIndex;\n      index2uv = objMeshModel.vecFaceIndex.at(i+2).uvIndex;\n\n      const vec2 &tc1 = objMeshModel.uvs.at(index0uv);\n      const vec2 &tc2 = objMeshModel.uvs.at(index1uv);\n      const vec2 &tc3 = objMeshModel.uvs.at(index2uv);\n\n      // Using Equation 1\n      vec3 q1 = p1 - p0; \n       vec3 q2 = p2 - p0;\n\n      // Using Equation 2\n      float s1 = tc2.x-tc1.x, s2 = tc3.x-tc1.x; \n      float t1 = tc2.y-tc1.y, t2 = tc3.y-tc1.y;\n\n   // From Equation 5\n      float r = 1.0f / (s1 * t2 - s2 * t1);\n\n      // Using Equation 5\n      vec3 tan( (t2*q1.x - t1*q2.x) * r,\n                 (t2*q1.y - t1*q2.y) * r,\n                 (t2*q1.z - t1*q2.z) * r);  \n      vec3 bTan( (s1*q2.x - s2*q1.x) * r,\n                 (s1*q2.y - s2*q1.y) * r,\n                 (s1*q2.z - s2*q1.z) * r);\n\n        tan1Accum[index0] += tan1; tan1Accum[index1] += tan1;\n        tan1Accum[index2] += tan1; tan2Accum[index0] += bTan;\n        tan2Accum[index1] += bTan; tan2Accum[index2] += bTan;\n    }\n\n    for( uint i = 0; i < objMeshModel.positions.size(); ++i ){\n      objMeshModel.tangents[i] = vec4(\n                       glm::normalize(tan1Accum[i] ),1.0);\n    }\n\n    for(int i = 0; i < objMeshModel.vecFaceIndex.size(); i++){\n     int index = objMeshModel.vecFaceIndex.at(i + 0).vertexIndex;\n    objMeshModel.vertices[i].tangent=objMeshModel.tangents.at(index);\n    }\n\n   // Clear & Return\n    tan1Accum.clear();tan2Accum.clear(); \n  return true; \n}\n```"]