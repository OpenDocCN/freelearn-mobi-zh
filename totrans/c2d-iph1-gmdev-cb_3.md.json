["```swift\n#import <Foundation/Foundation.h>\n/* This returns the full absolute path to a specified file in the bundle */\nNSString* getActualPath( NSString* file )\n{\nNSArray* path = [file componentsSeparatedByString: @\".\"];\nNSString* actualPath = [[NSBundle mainBundle] pathForResource: [path objectAtIndex: 0] ofType: [path objectAtIndex: 1]];\nreturn actualPath;\n}\n@implementation Ch2_ReadingPlistFiles\n-(CCLayer*) runRecipe {\n//Initialize a read-only dictionary from our file\nNSString *fileName = @\"scene1.plist\";\nNSDictionary *dict = [NSDictionary dictionaryWithContentsOfFile:getActualPath(fileName)];\n//Process this dictionary\n[self processMap:dict];\nreturn self;\n}\n-(void) processMap:(NSDictionary*)dict {\n//Loop through all dictionary nodes to process individual types\nNSArray *nodes = [dict objectForKey:@\"nodes\"];\nfor (id node in nodes) {\nif([[node objectForKey:@\"type\"] isEqualToString:@\"spriteFile\"]){\n[self processSpriteFile:node];\n}else if([[node objectForKey:@\"type\"] isEqualToString:@\"texturedPolygon\"]){\n[self processTexturedPolygon:node];\n}\n}\n}\n/* Process the 'spriteFile' type */\n-(void) processSpriteFile:(NSDictionary*)nodeDict {\n//Init the sprite\nNSString *file = [nodeDict objectForKey:@\"file\"];\nCCSprite *sprite = [CCSprite spriteWithFile:file];\n//Set sprite position\nNSDictionary *posDict = [nodeDict objectForKey:@\"position\"];\nsprite.position = ccp([[posDict objectForKey:@\"x\"] floatValue], [[posDict objectForKey:@\"y\"] floatValue]);\n//Each numeric value is an NSString or NSNumber that must be cast into a float\nsprite.scale = [[nodeDict objectForKey:@\"scale\"] floatValue];\n//Set the anchor point so objects are positioned from the bottom-up\nsprite.anchorPoint = ccp(0.5,0);\n//We set the sprite Z according to its Y to produce an isometric perspective\nfloat z = [self getZFromY:[[posDict objectForKey:@\"y\"] floatValue]];\nif([nodeDict objectForKey:@\"z\"]){\nz = [[nodeDict objectForKey:@\"z\"] floatValue];\n}\n//Finally, add the sprite\n[self addChild:sprite z:z];\n}\n/* Process the 'texturedPolygon' type */\n-(void) processTexturedPolygon:(NSDictionary*)nodeDict {\n//Process vertices\nNSMutableArray *vertices = [[[NSMutableArray alloc] init] autorelease];\nNSArray *vertexData = [nodeDict objectForKey:@\"vertices\"];\nfor(id vData in vertexData){\nfloat x = [[vData objectForKey:@\"x\"] floatValue];\nfloat y = [[vData objectForKey:@\"y\"] floatValue];\n[vertices addObject:[NSValue valueWithCGPoint:ccp(x,y)]];\n}\n//Init our textured polygon\nNSString *file = [nodeDict objectForKey:@\"file\"];\nccTexParams params = {GL_NEAREST,GL_NEAREST_MIPMAP_NEAREST,GL_REPEAT,GL_REPEAT};\nTexturedPolygon *texturedPoly = [TexturedPolygon createWithFile:file withVertices:vertices];\n[texturedPoly.texture setTexParameters:&params];\n[texturedPoly retain];\n//Set position\nNSDictionary *posDict = [nodeDict objectForKey:@\"position\"];\ntexturedPoly.position = ccp([[posDict objectForKey:@\"x\"] floatValue], [[posDict objectForKey:@\"y\"] floatValue]);\n//Add the texturedPolygon behind any sprites\n[self addChild:texturedPoly z:0];\n}\n/* Our simple method used to order sprites by depth */\n-(float) getZFromY:(float)y {\nreturn 320-y;\n}\n@end\n\n```", "```swift\n#import \"ActualPath.h\"\n@implementation Ch2_ReadingJsonFiles\n-(CCLayer*) runRecipe {\n//Initialize a read-only dictionary from our file\nNSString *fileName = @\"scene2.json\";\nNSString *jsonString = [[[NSString alloc] initWithContentsOfFile:getActualPath(fileName) encoding:NSUTF8StringEncoding error:nil] autorelease];\nNSData *jsonData = [jsonString dataUsingEncoding:NSUTF32BigEndianStringEncoding];\nNSDictionary *dict = [[CJSONDeserializer deserializer] deserializeAsDictionary:jsonData error:nil];\n//Process this dictionary\n[self processMap:dict];\nreturn self;\n}\n-(void) processMap:(NSDictionary*)dict {\nNSArray *nodes = [dict objectForKey:@\"nodes\"];\nfor (id node in nodes) {\nif([[node objectForKey:@\"type\"] isEqualToString:@\"spriteFile\"]){\n[self processSpriteFile:node];\n}else if([[node objectForKey:@\"type\"] isEqualToString:@\"texturedPolygon\"]){\n[self processTexturedPolygon:node];\n}\n}\n}\n/* Process the 'spriteFile' type */\n-(void) processSpriteFile:(NSDictionary*)nodeDict {\n/* CODE OMITTED */\n}\n/* Process the 'texturedPolygon' type */\n-(void) processTexturedPolygon:(NSDictionary*)nodeDict {\n/* CODE OMITTED */\n}\n/* Our simple method used to order sprites by depth */\n-(float) getZFromY:(float)y {\nreturn 320-y;\n}\n@end\n\n```", "```swift\n{ \"nodes\":\n[ { \"type\":\"spriteFile\", \"file\":\"tree.png\", \"position\":{\"x\":250,\"y\":50}, \"scale\":0.9 },\n{ \"type\":\"spriteFile\", \"file\":\"tree_shadow.png\", \"position\":{\"x\":195,\"y\":51}, \"scale\":0.9, \"z\":-100 },\n{ \"type\":\"spriteFile\", \"file\":\"cheshire_cat.png\", \"position\":{\"x\":120,\"y\":70}, \"scale\":0.3 },\n{ \"type\":\"spriteFile\", \"file\":\"actor_shadow.png\", \"position\":{\"x\":120,\"y\":65}, \"scale\":1.75, \"z\":-100 },\n{ \"type\":\"texturedPolygon\", \"file\":\"grass_texture.png\", \"position\":{\"x\":16,\"y\":16},\n\"vertices\":[{\"x\":0,\"y\":0},{\"x\":480,\"y\":0},{\"x\":480,\"y\":320},{\"x\":0,\"y\":320}] },\n{ \"type\":\"rectangle\", \"position\":{\"x\":0,\"y\":0}, \"size\":{\"x\":480,\"y\":320}, \"meta\": [{\"type\":\"boundary\"}] }\n]\n}\n\n```", "```swift\n#import \"GDataXMLNode.h\"\n@implementation Ch2_ReadingXmlFiles\n-(CCLayer*) runRecipe {\n//Read our file in as an NSData object\nNSString *fileName = @\"scene3.xml\";\nNSString *xmlString = [[[NSString alloc] initWithContentsOfFile:getActualPath(fileName) encoding:NSUTF8StringEncoding error:nil] autorelease];\nNSData *xmlData = [xmlString dataUsingEncoding:NSUTF32BigEndianStringEncoding];\n//Initialize a new GDataXMLDocument with our data\nGDataXMLDocument *doc = [[[GDataXMLDocument alloc] initWithData:xmlData options:0 error:nil] autorelease];\n//Process that document\n[self processMap:doc];\nreturn self;\n}\n-(void) processMap:(GDataXMLDocument*)doc {\n//Find all elements of 'node' type\nNSArray *nodes = [doc.rootElement elementsForName:@\"node\"];\n//Loop through each element\nfor (GDataXMLElement *node in nodes) {\n//Find the first (and assumed only) element with the name 'type' in this node\nNSString *type = [[[node elementsForName:@\"type\"] objectAtIndex:0] stringValue];\n//Process specific node types\nif([type isEqualToString:@\"spriteFile\"]){\n[self processSpriteFile:node];\n}else if([type isEqualToString:@\"texturedPolygon\"]){\n[self processTexturedPolygon:node];\n}\n}\n}\n/* Process the 'spriteFile' type */\n-(void) processSpriteFile:(GDataXMLElement*)node {\n//Init the sprite\nNSString *file = [[[node elementsForName:@\"file\"] objectAtIndex:0] stringValue];\nCCSprite *sprite = [CCSprite spriteWithFile:file];\n//Set sprite position\nGDataXMLElement *posElement = [[node elementsForName:@\"position\"] objectAtIndex:0];\nsprite.position = ccp( [[[[posElement elementsForName:@\"x\"] objectAtIndex:0] stringValue] floatValue],\n[[[[posElement elementsForName:@\"y\"] objectAtIndex:0] stringValue] floatValue]);\n//Each element is considered a string first\nsprite.scale = [[[[node elementsForName:@\"scale\"] objectAtIndex:0] stringValue] floatValue];\n//Set the anchor point\nsprite.anchorPoint = ccp(0.5,0);\n//We set the sprite Z according to its Y to produce an isometric perspective\nfloat z = [self getZFromY:sprite.position.y];\nif([node elementsForName:@\"z\"].count > 0){\nz = [[[[node elementsForName:@\"z\"] objectAtIndex:0] stringValue] floatValue];\n}\n//Finally, add the sprite\n[self addChild:sprite z:z];\n}\n/* Process the 'texturedPolygon' type */\n-(void) processTexturedPolygon:(GDataXMLElement*)node {\n//Process vertices\nNSMutableArray *vertices = [[[NSMutableArray alloc] init] autorelease];\nNSArray *vertexData = [[[node elementsForName:@\"vertices\"] objectAtIndex:0] elementsForName:@\"vertex\"];\nfor(id vData in vertexData){\nGDataXMLElement *vertexElement = (GDataXMLElement*)vData;\nfloat x = [[[[vertexElement elementsForName:@\"x\"] objectAtIndex:0] stringValue] floatValue];\nfloat y = [[[[vertexElement elementsForName:@\"y\"] objectAtIndex:0] stringValue] floatValue];\n[vertices addObject:[NSValue valueWithCGPoint:ccp(x,y)]];\n}\n//Init our textured polygon\nNSString *file = [[[node elementsForName:@\"file\"] objectAtIndex:0] stringValue];\nccTexParams params = {GL_NEAREST,GL_NEAREST_MIPMAP_NEAREST,GL_REPEAT,GL_REPEAT};\nTexturedPolygon *texturedPoly = [TexturedPolygon createWithFile:file withVertices:vertices];\n[texturedPoly.texture setTexParameters:&params];\n//Set position\nGDataXMLElement *posElement = [[node elementsForName:@\"position\"] objectAtIndex:0];\ntexturedPoly.position = ccp( [[[[posElement elementsForName:@\"x\"] objectAtIndex:0] stringValue] floatValue],\n[[[[posElement elementsForName:@\"y\"] objectAtIndex:0] stringValue] floatValue]);\n//Add the texturedPolygon behind any sprites\n[self addChild:texturedPoly z:0];\n}\n/* Our simple method used to order sprites by depth */\n-(float) getZFromY:(float)y {\nreturn 320-y;\n}\n@end\n\n```", "```swift\n<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n<nodes>\n<node>\n<type>spriteFile</type>\n<file>boulder.png</file>\n<position><x>250</x><y>50</y></position>\n<scale>0.9</scale>\n</node>\n<node>\n<type>texturedPolygon</type>\n<file>cracked_earth_texture.png</file>\n<position> <x>32</x><y>32</y> </position>\n<vertices>\n<vertex> <x>0</x><y>0</y> </vertex>\n<vertex> <x>480</x><y>0</y> </vertex>\n<vertex> <x>480</x><y>320</y> </vertex>\n<vertex> <x>0</x><y>320</y> </vertex>\n</vertices>\n</node>\n</nodes>\n\n```", "```swift\n@implementation Ch2_SavingSimpleData\n-(CCLayer*) runRecipe {\n//Set font size\n[CCMenuItemFont setFontSize:30];\n//Add main label\nCCLabelBMFont *chooseDifficultyLabel = [CCLabelBMFont labelWithString:@\"CHOOSE DIFFICULTY:\" fntFile:@\"eurostile_30.fnt\"];\nchooseDifficultyLabel.position = ccp(240,250);\nchooseDifficultyLabel.scale = 0.5f;\n[self addChild:chooseDifficultyLabel z:1];\n//Add difficulty choices\neasyMIF = [CCMenuItemFont itemFromString:@\"Easy\" target:self selector:@selector(chooseEasy)];\n/* CODE OMITTED */\nmainMenu = [CCMenu menuWithItems:easyMIF, mediumMIF, hardMIF, insaneMIF, nil];\n[mainMenu alignItemsVertically];\nmainMenu.position = ccp(240,140);\n[self addChild:mainMenu z:1];\n//Load any previously chosen difficulty\n[self loadDifficulty];\nreturn self;\n}\n-(void) loadDifficulty {\n//If a difficulty is set we use that, otherwise we choose Medium\nNSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];\nif([defaults stringForKey:@\"simple_data_difficulty\"]){\ndifficulty = [defaults stringForKey:@\"simple_data_difficulty\"];\n[self setDifficultyFromValue];\n}else{\n[self chooseMedium];\n}\n}\n-(void) saveDifficulty {\n//Save our difficulty\nNSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];\n[defaults setObject:difficulty forKey:@\"simple_data_difficulty\"];\n[defaults synchronize];\n}\n-(void) setDifficultyFromValue {\n//More menu color management\n[self resetMenuColors];\nif([difficulty isEqualToString:@\"Easy\"]){\n[easyMIF setColor:ccc3(255,0,0)];\n}else if([difficulty isEqualToString:@\"Medium\"]){\n[mediumMIF setColor:ccc3(255,0,0)];\n}/* CODE OMITTED */\n[self saveDifficulty];\n}\n/* Shortcut callback methods */\n-(void) chooseEasy {\ndifficulty = @\"Easy\";\n[self setDifficultyFromValue];\n}\n/* CODE OMITTED */\n@end\n\n```", "```swift\n    if([defaults stringForKey:@\"simple_data_difficulty\"]){\n    difficulty = [defaults stringForKey:@\"simple_data_difficulty\"];\n    }\n\n    ```", "```swift\n    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];\n    [defaults setObject:difficulty forKey:@\"simple_data_difficulty\"];\n    [defaults synchronize];\n\n    ```", "```swift\n//SimpleCharacter.h\n@interface SimpleCharacter : NSObject <NSCoding> {\nNSString *charColor; NSString *charClass;\nint strength; int dexterity; int constitution;\nint intelligence; int wisdom; int charisma;\n}\n@property (readwrite, assign) NSString *charColor;\n@property (readwrite, assign) NSString *charClass;\n@property (readwrite, assign) int strength;\n/* CODE OMITTED */\n@end\n@implementation SimpleCharacter\n@synthesize charColor, charClass, strength, dexterity, constitution, intelligence, wisdom, charisma;\n/* This merely adds this character with the proper color to a CCNode */\n-(void) addCharacterToNode:(CCNode *)node atPosition:(CGPoint)position {\nccColor3B color;\nif([charColor isEqualToString:@\"Red\"]){\ncolor = ccc3(255,0,0);\n}else if([charColor isEqualToString:@\"Blue\"]){\ncolor = ccc3(0,0,255);\n}/* CODE OMITTED */\nCCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];\n[cache addSpriteFramesWithFile:@\"dnd_characters.plist\"];\nCCSprite *drawing = [CCSprite spriteWithSpriteFrame:[cache spriteFrameByName:[NSString stringWithFormat:@\"dnd_%@_drawing.png\",charClass]]];\nCCSprite *colors = [CCSprite spriteWithSpriteFrame:[cache spriteFrameByName:[NSString stringWithFormat:@\"dnd_%@_colors.png\",charClass]]];\ndrawing.position = position; colors.position = position;\ndrawing.scale = 1.5f; colors.scale = 1.5f;\ncolors.color = color;\n[node addChild:colors z:0 tag:0];\n[node addChild:drawing z:1 tag:1];\n}\n/* This method determines how data is encoded into an NSCoder object */\n- (void) encodeWithCoder: (NSCoder *)coder {\n[coder encodeObject:charColor];\n[coder encodeObject:charClass];\n[coder encodeObject:[NSNumber numberWithInt:strength]];\n/* CODE OMITTED */\n}\n/* This method determines how data is read out from an NSCode object */\n-(id) initWithCoder: (NSCoder *) coder {\n[super init];\ncharColor = [[coder decodeObject] retain];\ncharClass = [[coder decodeObject] retain];\nstrength = [[coder decodeObject] intValue];\n/* CODE OMITTED */\nreturn self;\n}\n/* Initialization */\n-(id) init {\nself = [super init];\nif (self) {\ncharColor = @\"Red\"; charClass = @\"Wizard\";\nstrength = 10; dexterity = 10; constitution = 10;\nintelligence = 10; wisdom = 10; charisma = 10;\n}\nreturn self;\n}\n/* All objects must be released here */\n- (void) dealloc {\n[charColor release]; [charClass release]; [super dealloc];\n}\n@end\n@implementation Ch2_ArchivingObjects\n-(CCLayer*) runRecipe {\n//Load our character\n[self loadCharacter];\nreturn self;\n}\n-(void) loadCharacter {\n//Our archive file name\nNSString *fileName = @\"dnd_character.archive\";\n//We get our file path\nNSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);\nNSString *documentsDirectory = [paths objectAtIndex:0];\nNSString *filePath = [documentsDirectory stringByAppendingPathComponent:fileName];\nif(![[NSFileManager defaultManager] fileExistsAtPath:filePath]){\n//If file doesn't exist in document directory create a new default character and save it\ncharacter = [[SimpleCharacter alloc] init];\n[NSKeyedArchiver archiveRootObject:character toFile:filePath];\n}else{\n//If it does we load it\ncharacter = [[NSKeyedUnarchiver unarchiveObjectWithFile:filePath] retain];\n}\n//Add character and reload HUD\n[character addCharacterToNode:self atPosition:ccp(300,180)];\n[self loadHUD];\n}\n-(void) saveCharacter {\n//Our archive file name\nNSString *fileName = @\"dnd_character.archive\";\n//We get our file path\nNSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);\nNSString *documentsDirectory = [paths objectAtIndex:0];\nNSString *filePath = [documentsDirectory stringByAppendingPathComponent:fileName];\n//Save character\n[NSKeyedArchiver archiveRootObject:character toFile:filePath];\n}\n-(void) deleteData {\n//Our archive file name\nNSString *fileName = @\"dnd_character.archive\";\n//We get our file path\nNSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);\nNSString *documentsDirectory = [paths objectAtIndex:0];\nNSString *filePath = [documentsDirectory stringByAppendingPathComponent:fileName];\n//Delete our file\n[[NSFileManager defaultManager] removeItemAtPath:filePath error:nil];\n//Set removal message\n[message setString:@\"Data deleted!\"];\n//Remove character node and load a new default character\n[self removeCharacter];\n[self loadCharacter];\n}\n@end\n\n```", "```swift\n    - (void) encodeWithCoder: (NSCoder *)coder;\n    -(id) initWithCoder: (NSCoder *) coder;\n\n    ```", "```swift\n    NSString *fileName = @\"my.file\";\n    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);\n    NSString *documentsDirectory = [paths objectAtIndex:0];\n    NSString *filePath = [documentsDirectory stringByAppendingPathComponent:fileName];\n\n    ```", "```swift\n    if([[NSFileManager defaultManager] fileExistsAtPath:filePath]){\n    [[NSFileManager defaultManager] removeItemAtPath:filePath error:nil];\n    }\n\n    ```", "```swift\n    //Archive\n    character = [[SimpleCharacter alloc] init];\n    [NSKeyedArchiver archiveRootObject:character toFile:filePath];\n    //Un-archive\n    character = [[NSKeyedUnarchiver unarchiveObjectWithFile:filePath] retain];\n\n    ```", "```swift\n#import \"GameHelper.h\"\n//Implementation\n@implementation Ch3_MutatingNestedMetadata\n-(CCLayer*) runRecipe {\n[super runRecipe];\n//Load JSON data\nNSString *fileName = @\"data_to_mutate.json\";\nNSString *jsonString = [[[NSString alloc] initWithContentsOfFile:getActualPath(fileName) encoding:NSUTF8StringEncoding error:nil] autorelease];\nNSData *jsonData = [jsonString dataUsingEncoding:NSUTF32BigEndianStringEncoding];\nNSDictionary *dict = [[CJSONDeserializer deserializer] deserializeAsDictionary:jsonData error:nil];\n//Create deep mutable copy\ndictMutable = [GameHelper makeRecMutableCopy:dict];\n[dictMutable retain];\n//Show JSON data\n[self showJsonData:dictMutable];\n//Add randomize button\n[CCMenuItemFont setFontSize:30];\nCCMenuItemFont *randomizeItem = [CCMenuItemFont itemFromString:@\"Randomize Data\" target:self selector:@selector(randomizeData)];\nCCMenu *menu = [CCMenu menuWithItems:randomizeItem, nil];\nmenu.position = ccp(240,140);\n[self addChild:menu z:1];\nreturn self;\n}\n-(void) showJsonData:(NSDictionary*)dict {\n[self showMessage:@\"\"];\n//Loop through all dictionary nodes to process individual types\nNSMutableDictionary *nodes = [dict objectForKey:@\"people\"];\nfor (NSMutableDictionary* node in nodes) {\nfloat height = [[node objectForKey:@\"height\"] floatValue];\nfloat weight = [[node objectForKey:@\"weight\"] floatValue];\nNSString *name = [node objectForKey:@\"name\"];\n[self appendMessage:[NSString stringWithFormat:@\"%@: %din %dlbs\", name, (int)height, (int)weight]];\n}\nnested metadatamutating}\n-(void) randomizeData {\n//Randomize some data in 'dictMutable'\nNSMutableArray *nodes = [dictMutable objectForKey:@\"people\"];\nfor (NSMutableDictionary* node in nodes) {\n[node setObject:[NSNumber numberWithFloat:(float)(arc4random()%48)+30.0f] forKey:@\"height\"];\n[node setObject:[NSNumber numberWithFloat:(float)(arc4random()%100)+100.0f] forKey:@\"weight\"];\n}\n[self showJsonData:dictMutable];\n}\n@end\n\n```", "```swift\n+(NSMutableDictionary*) makeRecMutableCopy:(NSDictionary*)dict;\n\n```", "```swift\n#import \"ActualPath.h\"\n@implementation Ch2_SavingDataPlist\n-(CCLayer*) runRecipe {\n[self loadHiScores];\nreturn self;\n}\n-(void) loadHiScores {\n//Our template and file names\nNSString *templateName = @\"whackamole_template.plist\";\nNSString *fileName = @\"whackamole.plist\";\n//Our dictionary\nNSMutableDictionary *fileDict;\n//We get our file path\nNSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);\nNSString *documentsDirectory = [paths objectAtIndex:0];\nNSString *filePath = [documentsDirectory stringByAppendingPathComponent:fileName];\nif(![[NSFileManager defaultManager] fileExistsAtPath:filePath]){\n//If file doesn't exist in document directory create a new one from the template\nfileDict = [NSMutableDictionary dictionaryWithContentsOfFile:getActualPath(templateName)];\n}else{\n//If it does we load it in the dict\nfileDict = [NSMutableDictionary dictionaryWithContentsOfFile:filePath];\n}\n//Load hi scores into our dictionary\nhiScores = [fileDict objectForKey:@\"hiscores\"];\n//Set the 'hiScore' variable (the highest score)\nfor(id score in hiScores){\nint scoreNum = [[score objectForKey:@\"score\"] intValue];\nif(hiScore < scoreNum){\nhiScore = scoreNum;\n}\n}\n//Write dict to file\n[fileDict writeToFile:filePath atomically:YES];\n}\n-(void) addHiScore {\n//Our template and file names\nNSString *templateName = @\"whackamole_template.plist\";\nNSString *fileName = @\"whackamole.plist\";\n//Our dictionary\nNSMutableDictionary *fileDict;\n//We get our file path\nNSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);\nNSString *documentsDirectory = [paths objectAtIndex:0];\nNSString *filePath = [documentsDirectory stringByAppendingPathComponent:fileName];\nif(![[NSFileManager defaultManager] fileExistsAtPath:filePath]){\n//If file doesn't exist in document directory create a new one from the template\nfileDict = [NSMutableDictionary dictionaryWithContentsOfFile:getActualPath(templateName)];\n}else{\n//If it does we load it in the dict\nfileDict = [NSMutableDictionary dictionaryWithContentsOfFile:filePath];\n}\n//Load hi scores into our dictionary\nhiScores = [fileDict objectForKey:@\"hiscores\"];\n//Add hi score\nbool scoreRecorded = NO;\n//Add score if player's name already exists\nfor(id score in hiScores){\nNSMutableDictionary *scoreDict = (NSMutableDictionary*)score;\nif([[scoreDict objectForKey:@\"name\"] isEqualToString:currentPlayerName]){\nif([[scoreDict objectForKey:@\"score\"] intValue] < currentScore){\n[scoreDict setValue:[NSNumber numberWithInt:currentScore] forKey:@\"score\"];\n}\nscoreRecorded = YES;\n}\n}\n//Add new score if player's name doesn't exist\nif(!scoreRecorded){\nNSMutableDictionary *newScore = [[NSMutableDictionary alloc] init];\n[newScore setObject:currentPlayerName forKey:@\"name\"];\n[newScore setObject:[NSNumber numberWithInt:currentScore] forKey:@\"score\"];\n[hiScores addObject:newScore];\n}\n//Write dict to file\n[fileDict writeToFile:filePath atomically:YES];\n}\n-(void) deleteHiScores {\n//Our file name\nNSString *fileName = @\"whackamole.plist\";\n//We get our file path\nNSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);\nNSString *documentsDirectory = [paths objectAtIndex:0];\nNSString *filePath = [documentsDirectory stringByAppendingPathComponent:fileName];\n//Delete our file\n[[NSFileManager defaultManager] removeItemAtPath:filePath error:nil];\n[message setString:@\"Hi scores deleted!\"];\nhiScore = 0;\n[self loadHiScores];\n}\n@end\n\n```", "```swift\nfileDict = [NSMutableDictionary dictionaryWithContentsOfFile:filePath];\n\n```", "```swift\n[fileDict writeToFile:filePath atomically:YES];\n\n```", "```swift\n#import \"ActualPath.h\"\n#import <Foundation/Foundation.h>\n#import \"FMDatabase.h\"\n@implementation Ch2_SavingDataSQLite\n-(CCLayer*) runRecipe {\n[self loadHiScores];\nreturn self;\n}\n-(void) dealloc {\n//Release our database\n[db close]; [db release]; [super dealloc];\n}\n-(NSArray *) createDictionariesArrayFromFMResultSet:(FMResultSet *)rs fields:(NSString *)fields {\n//Parse field string into an array\nNSArray * listFields = [fields componentsSeparatedByString:@\",\"];\n//Create an array of dictionaries from each field\nNSMutableArray * items = [NSMutableArray arrayWithCapacity:1];\nwhile ([rs next]) {\nNSMutableDictionary * item = [NSMutableDictionary dictionaryWithCapacity:1];\nfor (int i = 0; i < [listFields count]; i++) {\nNSString * key = [listFields objectAtIndex:i];\nNSString * value = [rs stringForColumn: key];\nif (value == NULL) value = @\"\";\n[item setObject:value forKey:key];\n}\n[items addObject:item];\n}\n[rs close];\nreturn items;\n}\n-(void) writeNewScore:(int)score forName:(NSString*)name {\n//Find the hi score with this name\nNSString *selectQuery = [NSString stringWithFormat:@\"SELECT * FROM hiscores WHERE name = '%@'\", name];\nFMResultSet *rs = [db executeQuery:selectQuery];\n//What is the score? Is there a score at all?\nint storedScore = -1;\nwhile([rs next]){\nstoredScore = [[rs stringForColumn:@\"score\"] intValue];\n}\n[rs close];\nif(storedScore == -1){\n//Name doesn't exist, add it\nNSString *insertQuery = [NSString stringWithFormat:@\"INSERT INTO hiscores (name, score) VALUES ('%@','%i')\", name, score];\nrs = [db executeQuery:insertQuery];\nwhile([rs next]){};\n[rs close];\n}else if(score > storedScore){\n//Write new score for existing name\nNSString *updateQuery = [NSString stringWithFormat:@\"UPDATE hiscores SET score='%i' WHERE name='%@'\", score, name];\nrs = [db executeQuery:updateQuery];\nwhile([rs next]){};\n[rs close];\n}\n}\n-(void) loadHiScores {\n//Our file and template names\nNSString *fileName = @\"skeetshooter.sqlite\";\nNSString *templateName = @\"skeetshooter_template.sqlite\";\n//We get our file path\nNSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);\nNSString *documentsDirectory = [paths objectAtIndex:0];\nNSString *filePath = [documentsDirectory stringByAppendingPathComponent:fileName];\n//If file doesn't exist in document directory create a new one from the template\nif(![[NSFileManager defaultManager] fileExistsAtPath:filePath]){\n[[NSFileManager defaultManager] copyItemAtPath:getActualPath(templateName)\ntoPath:[NSString stringWithFormat:@\"%@/%@\", documentsDirectory, fileName] error:nil];\n}\n//Initialize the database\nif(!db){\ndb = [FMDatabase databaseWithPath:filePath];\n[db setLogsErrors:YES];\n[db setTraceExecution:YES];\n[db retain];\nif(![db open]){ NSLog(@\"Could not open db.\");\n}else{ NSLog(@\"DB opened successfully.\");}\n}\n//Select all hi scores\nFMResultSet *rs = [db executeQuery:@\"select * from hiscores\"];\n//Load them into an array of dictionaries\nhiScores = [[NSMutableArray alloc] init];\nhiScores = [self createDictionariesArrayFromFMResultSet:rs fields:@\"name,score\"];\n//Set hi score\nfor(id score in hiScores){\nint scoreNum = [[score objectForKey:@\"score\"] intValue];\nif(hiScore < scoreNum){\nhiScore = scoreNum;\n}\n}\n}\n-(void) addHiScore {\n//Add hi score to db\n[self writeNewScore:currentScore forName:currentPlayerName];\n//Reset dictionary\nFMResultSet *rs = [db executeQuery:@\"SELECT * FROM hiscores\"];\nhiScores = [self createDictionariesArrayFromFMResultSet:rs fields:@\"name,score\"];\n}\n-(void) deleteHiScores {\n//Our file name\nNSString *fileName = @\"skeetshooter.sqlite\";\n//We get our file path\nNSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);\nNSString *documentsDirectory = [paths objectAtIndex:0];\nNSString *filePath = [documentsDirectory stringByAppendingPathComponent:fileName];\n//Delete our file\n[[NSFileManager defaultManager] removeItemAtPath:filePath error:nil];\n[message setString:@\"Hi scores deleted!\"];\nhiScore = 0;\n//Close and release our db pointer\n[db close]; [db release]; db = nil;\n//Load new blank hi scores\n[self loadHiScores];\n}\n@end\n\n```", "```swift\n- (FMResultSet *)executeQuery:(NSString*)sql;\n\n```", "```swift\nFMResultSet *rs = [db executeQuery:@\"SELECT * FROM mytable\"];\nwhile([rs next]){\nsomevalue = [[rs stringForColumn:@\"myfield\"] intValue];\n}\n[rs close];\n\n```", "```swift\n    //Hiscore.h\n    #import <CoreData/CoreData.h>\n    @interface Hiscore : NSManagedObject\n    {}\n    @property (nonatomic, retain) NSString * name;\n    @property (nonatomic, retain) NSNumber * score;\n    @end\n    //Hiscore.m\n    #import \"Hiscore.h\"\n    @implementation Hiscore\n    @dynamic name;\n    @dynamic score;\n    @end\n\n    ```", "```swift\n#import <UIKit/UIKit.h>\n#import \"Hiscore.h\"\n@interface Ch2_SavingDataCoreData : SimpleTimedGameRecipe <NSFetchedResultsControllerDelegate>\n{\nNSManagedObjectModel *managedObjectModel;\nNSManagedObjectContext *managedObjectContext;\nNSPersistentStoreCoordinator *persistentStoreCoordinator;\n}\n@property (nonatomic, retain, readonly) NSManagedObjectModel *managedObjectModel;\n@property (nonatomic, retain, readonly) NSManagedObjectContext *managedObjectContext;\n@property (nonatomic, retain, readonly) NSPersistentStoreCoordinator *persistentStoreCoordinator;\n@end\n@implementation Ch2_SavingDataCoreData\n-(CCLayer*) runRecipe {\n[self loadHiScores];\nreturn self;\n}\n/* Returns the managed object context for the application.\nIf the context doesn't already exist, it is created and bound to the persistent store coordinator for the application. */\n- (NSManagedObjectContext *) managedObjectContext {\n//Return the managedObjectContext if it already exists\nif (managedObjectContext != nil) {\nreturn managedObjectContext;\n}\n//Init the managedObjectContext\nNSPersistentStoreCoordinator *coordinator = [self persistentStoreCoordinator];\nif (coordinator != nil) {\nmanagedObjectContext = [[NSManagedObjectContext alloc] init];\n[managedObjectContext setPersistentStoreCoordinator: coordinator];\n}\nreturn managedObjectContext;\n}\n/* Returns the managed object model for the application.\nIf the model doesn't already exist, it is created by merging all of the models found in the application bundle. */\n- (NSManagedObjectModel *)managedObjectModel {\n//Return the managedObjectModel if it already exists\nif (managedObjectModel != nil) {\nreturn managedObjectModel;\n}\n//Init the managedObjectModel\nmanagedObjectModel = [[NSManagedObjectModel mergedModelFromBundles:nil] retain];\nreturn managedObjectModel;\n}\n/* Returns the persistent store coordinator for the application.\nIf the coordinator doesn't already exist, it is created and the application's store added to it. */\n- (NSPersistentStoreCoordinator *)persistentStoreCoordinator {\n//Return the persistentStoreCoordinator if it already exists\nif (persistentStoreCoordinator != nil) {\nreturn persistentStoreCoordinator;\n}\n//Our file name\nNSString *fileName = @\"memory.sqlite\";\n//We get our file path\nNSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);\nNSString *documentsDirectory = [paths objectAtIndex:0];\nNSString *filePath = [documentsDirectory stringByAppendingPathComponent:fileName];\nNSURL *filePathURL = [NSURL fileURLWithPath:filePath];\n//Init the persistentStoreCoordinator\npersistentStoreCoordinator = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:[self managedObjectModel]];\n[persistentStoreCoordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:filePathURL options:nil error:nil];\nreturn persistentStoreCoordinator;\n}\n-(void) loadHiScores {\n//Initialization\nmanagedObjectContext = self.managedObjectContext;\n//Attempt to create SQLite database\nNSEntityDescription *entity;\n@try{\n//Define our table/entity to use\nentity = [NSEntityDescription entityForName:@\"Hiscore\" inManagedObjectContext:managedObjectContext];\n}@catch (NSException *exception){\nNSLog(@\"Caught %@: %@\", [exception name], [exception reason]);\n//Copy SQLite template because creation failed\nNSString *fileName = @\"memory.sqlite\";\nNSString *templateName = @\"memory_template.sqlite\";\n//File paths\nNSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);\nNSString *documentsDirectory = [paths objectAtIndex:0];\nNSString *filePath = [documentsDirectory stringByAppendingPathComponent:fileName];\nif(![[NSFileManager defaultManager] fileExistsAtPath:filePath]){\n//If file doesn't exist in document directory create a new one from the template\n[[NSFileManager defaultManager] copyItemAtPath:getActualPath(templateName)\ntoPath:[NSString stringWithFormat:@\"%@/%@\", documentsDirectory, fileName] error:nil];\n}\n//Finally define our table/entity to use\nentity = [NSEntityDescription entityForName:@\"Hiscore\" inManagedObjectContext:managedObjectContext];\n}\n//Set up the fetch request\nNSFetchRequest *request = [[NSFetchRequest alloc] init];\n[request setEntity:entity];\n//Define how we will sort the records with a descriptor\nNSSortDescriptor *sortDescriptor = [[NSSortDescriptor alloc] initWithKey:@\"score\" ascending:NO];\nNSArray *sortDescriptors = [NSArray arrayWithObject:sortDescriptor];\n[request setSortDescriptors:sortDescriptors];\n[sortDescriptor release];\n//Init hiScores\nhiScores = [[managedObjectContext executeFetchRequest:request error:nil] mutableCopy];\n//Add an intial score if necessary\nif(hiScores.count < 1){\ncurrentScore = 0;\ncurrentPlayerName = @\"Player1\";\n[self addHiScore];\nhiScores = [[managedObjectContext executeFetchRequest:request error:nil] mutableCopy];\n}\n//Set the hi score\nHiscore *highest = [hiScores objectAtIndex:0];\nhiScore = [highest.score intValue];\n}\n-(void) addHiScore {\nbool hasScore = NO;\n//Add score if player's name already exists\nfor(id score in hiScores){\nHiscore *hiscore = (Hiscore*)score;\nif([hiscore.name isEqualToString:currentPlayerName]){\nhasScore = YES;\nif(currentScore > [hiscore.score intValue]){\nhiscore.score = [NSNumber numberWithInt:currentScore];\n}\n}\n}\n//Add new score if player's name doesn't exist\nif(!hasScore){\nHiscore *hiscoreObj = (Hiscore *)[NSEntityDescription insertNewObjectForEntityForName:@\"Hiscore\" inManagedObjectContext:managedObjectContext];\n[hiscoreObj setName:currentPlayerName];\n[hiscoreObj setScore:[NSNumber numberWithInt:currentScore]];\n[hiScores addObject:hiscoreObj];\n}\n//Save managedObjectContext\n[managedObjectContext save:nil];\n}\n-(void) deleteHiScores {\n//Delete all Hi Score objects\nNSFetchRequest * allHiScores = [[NSFetchRequest alloc] init];\n[allHiScores setEntity:[NSEntityDescription entityForName:@\"Hiscore\" inManagedObjectContext:managedObjectContext]];\n[allHiScores setIncludesPropertyValues:NO]; //only fetch the managedObjectID\nNSArray * hs = [managedObjectContext executeFetchRequest:allHiScores error:nil];\n[allHiScores release];\nfor (NSManagedObject *h in hs) {\n[managedObjectContext deleteObject:h];\n}\n//Our file name\nNSString *fileName = @\"memory.sqlite\";\n//We get our file path\nNSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);\nNSString *documentsDirectory = [paths objectAtIndex:0];\nNSString *filePath = [documentsDirectory stringByAppendingPathComponent:fileName];\n//Delete our file\n[[NSFileManager defaultManager] removeItemAtPath:filePath error:nil];\n[message setString:@\"Hi scores deleted!\"];\nhiScore = 0;\n[hiScores removeAllObjects];\n[hiScores release];\nhiScores = nil;\n//Finally, load clean hi scores\n[self loadHiScores];\n}\n@end\n\n```", "```swift\nNSFetchRequest *request = [[NSFetchRequest alloc] init];\n[request setEntity:entity];\n//Define how we will sort the records with a descriptor\nNSSortDescriptor *sortDescriptor = [[NSSortDescriptor alloc] initWithKey:@\"score\" ascending:NO];\nNSArray *sortDescriptors = [NSArray arrayWithObject:sortDescriptor];\n[request setSortDescriptors:sortDescriptors];\n[sortDescriptor release];\n//Load hiScores\nhiScores = [[managedObjectContext executeFetchRequest:request error:nil] mutableCopy];\n\n```", "```swift\n[managedObjectContext save:nil];\n\n```", "```swift\nHiscore *hiscoreObj = (Hiscore *)[NSEntityDescription insertNewObjectForEntityForName:@\"Hiscore\" inManagedObjectContext:managedObjectContext];\n[hiscoreObj setName:currentPlayerName];\n[hiscoreObj setScore:[NSNumber numberWithInt:currentScore]];\n[hiScores addObject:hiscoreObj];\n\n```", "```swift\n    NSError *error = nil;\n    if (![hiscore.managedObjectContext save:&error]) {\n    NSLog(@\"Unresolved error %@, %@\", error, [error userInfo]);\n    exit(-1);\n    }\n\n    ```"]