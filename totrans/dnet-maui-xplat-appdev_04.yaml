- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: User Interface Design with XAML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we created a new .NET MAUI project named `PassXYZ.Vault`.
    As we progress through this book, we will enhance it with the skills and knowledge
    we acquire. In the last chapter, we got a glimpse of user interface implementation
    in XAML. In this chapter, we will delve deeper into creating user interfaces using
    XAML.
  prefs: []
  type: TYPE_NORMAL
- en: The **eXtensible Application Markup Language (XAML)** is an XML-based language
    that is used to define user interfaces for **Windows Presentation Foundation (WPF)**,
    **Universal Windows Platform (UWP)**, Xamarin.Forms, and .NET MAUI. The XAML dialects
    in these platforms share the same syntax but differ in their vocabularies.
  prefs: []
  type: TYPE_NORMAL
- en: XAML allows developers to define user interfaces in XML-based *markup language*
    rather than in any *programming language*. It is possible to write all our user
    interfaces in code, but user interface design with XAML will be more succinct
    and more visually coherent. Because XAML does not use a programming language,
    it cannot contain code. This is a disadvantage, but it is also an advantage as
    it forces the developer to separate the logic from the user interface design.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create a XAML page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic XAML syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XAML markup extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to design user interfaces with the master-detail pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Localization of .NET MAUI apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test and debug the source code in this chapter, you need to have Visual Studio
    2022 installed on your PC. Please refer to the *Development environment setup*
    section in *Chapter 1*, *Getting Started with .NET MAUI*, for the details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for this chapter is available in the following GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/2nd/chapter03](https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/2nd/chapter03)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To check out the source code of this chapter, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To find out more about the source code in this book, please refer to the *Managing
    the source code in this book* section in *Chapter 2*, *Building Our First .NET
    MAUI App*.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a XAML page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we delve into XAML syntax, let’s first understand how to create a XAML
    page in Visual Studio and through the **dotnet** command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a XAML page using Visual Studio, right-click on the project node,
    then select **Add > New Item…**. This will bring up the dialog box shown in *Figure
    3.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21554_03_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Adding a XAML page'
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, select **Content Page** from the templates and click **Add**.
    This action will generate a pair of files – a XAML file and a C# code-behind file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same can be achieved using a `dotnet` command. To locate all .NET MAUI
    templates, we can use the following `dotnet` command in the PowerShell console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21554_03_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: dotnet command for listing templates'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding output, we can observe that the short name of the XAML content
    page is `maui-page-xaml`. We can create a XAML page using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21554_03_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: Creating a XAML page'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding command will generate two files named `ItemsPage.xaml` and `ItemsPage.xaml.cs`.
    You may notice a warning message about post-creation actions. This is a known
    issue, and you can find more information about it at [https://github.com/dotnet/maui/issues/4994](https://github.com/dotnet/maui/issues/4994).
  prefs: []
  type: TYPE_NORMAL
- en: However, this is not something we need to worry about.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the “code-behind”?**'
  prefs: []
  type: TYPE_NORMAL
- en: In .NET MAUI, the term **code-behind** refers to the code file associated with
    a **user interface (UI)** definition file, typically a XAML file. The code-behind
    file contains the logic for handling UI events, data binding, and other app functionality
    related to the UI. The code-behind file is a C# (.cs) file with the same name
    as the related XAML file. For example, if we have an `ItemsPage.xaml` file, the
    code-behind file will be named `ItemsPage.xaml.cs`.
  prefs: []
  type: TYPE_NORMAL
- en: The code-behind file includes a class that inherits from a .NET MAUI base page
    type, usually `ContentPage`, `NavigationPage`, or `TabbedPage`. The class declaration
    is marked as a partial class that matches the class definition in the XAML file,
    allowing for seamless integration between the XAML UI definition and its corresponding
    code.
  prefs: []
  type: TYPE_NORMAL
- en: XAML syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since XAML is an XML-based language, to understand it better, we need to understand
    basic XML syntax first. In an XML file, it starts with an XML declaration or prolog.
    The content of XML or XAML files includes a hierarchy of elements. Each element
    may have attributes associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s review `App.xaml` in the project that we created in *Chapter 2*, *Building
    Our First .NET MAUI App*, as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3.1: `App.xaml` ([https://epa.ms/App3-1](https://epa.ms/App3-1))'
  prefs: []
  type: TYPE_NORMAL
- en: XML declaration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the start of `App.xaml`, we can see the following XML declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This declaration specifies the version of XML being used and the character encoding.
    In `App.xaml`, XML version 1.0 is used and the character encoding is set to UTF-8.
  prefs: []
  type: TYPE_NORMAL
- en: Element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Listing 3.1*, the content of `App.xaml` begins with the `Application` root
    element. Every XML document must contain a single root element that encompasses
    all other elements. Elements can have child elements, also known as nested elements,
    such as `ResourceDictionary`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Elements are composed of a start tag, the content, and an end tag, as seen
    in the `Application` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The start tag is enclosed in angle brackets (e.g., `<Application>`), and the
    end tag includes a forward slash before the element name (e.g., `</Application>`).
    The content can be any text or nested elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'For an empty element, the end tag can be omitted by adding a forward slash
    at the end of the start tag, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When discussing an XML element, we may use the terms **element**, **node**,
    and **tag**. **Element** refers to the start and end tag of that element together.
    **Tag** refers to either the start or end tag of the element. **Node** refers
    to an element and all its inner content, including all child elements.
  prefs: []
  type: TYPE_NORMAL
- en: A XAML document consists of many nested elements, with only one top element,
    known as the root element. In .NET MAUI, the root element is usually `Application`,
    `ContentPage`, `Shell`, or `ResourceDictionary`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each XAML file, we typically have a corresponding C# code-behind file.
    Let’s review the code-behind file in *Listing 3.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3.2: `App.xaml.cs` ([https://epa.ms/App3-2](https://epa.ms/App3-2))'
  prefs: []
  type: TYPE_NORMAL
- en: In XAML, elements usually represent actual C# classes that are instantiated
    to objects at runtime. Together, the XAML and code-behind files define a complete
    class. For example, `App.xaml` (*Listing 3.1*) and `App.xaml.cs` (*Listing 3.2*)
    define the `App` class, which is a sub-class of `Application`.
  prefs: []
  type: TYPE_NORMAL
- en: '**(1)** The `App` class, whose full name is `PassXYZ.Vault.App`, is the same
    as the one defined in the XAML file using the `x:Class` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**(2)** In the constructor of the `App` class, the `InitializeComponent` method
    is called to load the XAML and parse it. UI elements defined in the XAML file
    are created at this point. We can access these UI elements by the name defined
    with the `x:Name` attribute, as we’ll see shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: Attribute
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An element can have multiple unique attributes. An attribute provides additional
    information about XML elements. An XML attribute is a name-value pair attached
    to an element. In XAML, an element represents a C# class and the attributes represent
    the members of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the above, four attributes – `x:Name`, `VerticalOptions`, `IsEnabled`,
    and `Text` – are defined for the `Button` element. To define an attribute, we
    need to specify the attribute’s name and value with an equal sign. The attribute
    value should be enclosed in double or single quotes. For example, `IsEnabled`
    is the attribute name and `"True"` is the attribute value.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the `x:Name` attribute is a special one. It does not refer
    to a member of the `Button` class, but rather refers to the variable holding the
    instance of the `Button` class. Without the `x:Name` attribute, an anonymous instance
    of the `Button` class will be created. With the `x:Name` attribute declared, we
    can refer to the instance of the `Button` class using the `loginButton` variable
    in the code-behind file.
  prefs: []
  type: TYPE_NORMAL
- en: XML and XAML namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In XML or XAML, we can declare namespaces just like we do in C#. Namespaces
    help to group elements and attributes to avoid name conflicts when the same name
    is used in a different scope. Namespaces can be defined using the `xmlns` attribute
    with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The XAML namespace definition has two components: a prefix and an identifier.
    Both the prefix and the identifier can be any string, as allowed by the W3C namespaces
    in the XML 1.0 specification. If the prefix is omitted, the namespace becomes
    the default namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Listing 3.1*, the following namespace is the default one:'
  prefs: []
  type: TYPE_NORMAL
- en: This default namespace allows us to refer to .NET MAUI classes without a prefix,
    such as `ContentPage`, `Label`, or `Button`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the namespace declaration, the `x` prefix is used, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: The `xmlns:x` namespace declaration specifies elements and attributes that are
    intrinsic to XAML. This namespace is one of the most important ones that we will
    use in the UI design with XAML. To comprehend its usage, we can create a content
    page with an identical structure using both C# and XAML in the subsequent sections.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new page using XAML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let’s create a new page using XAML. To create a content page in XAML,
    we can use the `dotnet` command, as we have done previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command generates a XAML file (`NewPage1.xaml`) and a C# code-behind
    file (`NewPage1.xaml.cs`). We can update the XAML file to the following. Since
    we aren’t adding any logic, we can ignore the code-behind file (`NewPage1.xaml.cs`)
    in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NewPage1.xaml`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`NewPage1.xaml.cs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For comparison purposes with the XAML version we just created, let’s create
    the same content page using C# only in the next section. Then we will have a look
    at the lines numbered in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the same new page using C#
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create the same content page using only C# code, let’s use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command generates a content page in the `NewPage1.cs` C# file.
    We can implement the same logic in C# like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NewPage1.cs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have created the same content page (`NewPage1`) twice in both XAML
    and C#. XAML cannot contain programming logic, but it can be used to declare user
    interface elements and put the logic in the C# code-behind file. Within both versions
    of `NewPage1`, we created a content page that contains `Label` and `BoxView` elements.
    In the XAML version, we used attributes defined in the `xmlns:x` namespace to
    specify the UI elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(1)** A content page called `NewPage1` is created in XAML. The `x:Class`
    attribute specifies the class name – that is, `NewPage1`. In the C# code-behind
    file, a partial class of `NewPage1` is defined. In the constructor, the `InitializeComponent`
    method is invoked to load the UI defined in XAML.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[1]** We can create the same content page, `NewPage1`, using C# directly
    as a derived class of `ContentPage`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We defined a `StackLayout` in the content page and the variable name used to
    refer to it is **layout** in both the XAML and C# versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(2)** In XAML, `x:Name` specifies the variable name of `StackLayout`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[2]** In C#, we can declare the variable as `layout`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**(3)** `x:FactoryMethod` specifies a factory method that can be used to initialize
    an object.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[3]** In C# code, we can call the `Color.FromRgba` function directly, but
    we have to use the `x:FactoryMethod` attribute in XAML to do the same.'
  prefs: []
  type: TYPE_NORMAL
- en: '**(4)** `x:Arguments` is used to specify arguments when we call `Color.FromRgba`
    in XAML.'
  prefs: []
  type: TYPE_NORMAL
- en: '**(5)** `x:Int` is used to specify integer arguments. For other data types,
    we can use `x:Double`, `xChar`, or `x:Boolean`.'
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the `xmlns:x` namespace, please refer to the Microsoft
    documentation at [https://learn.microsoft.com/en-us/dotnet/maui/xaml/namespaces/](https://learn.microsoft.com/en-us/dotnet/maui/xaml/namespaces/).
  prefs: []
  type: TYPE_NORMAL
- en: '**Common Language Runtime (CLR)** types can be referenced in XAML by declaring
    a XAML namespace with a prefix. As shown in *Listing 3.1*, we can refer to our
    C# namespace, `PassXYZ.Vault`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To declare a CLR namespace, we can use `clr-namespace:` or `using:`. If the
    CLR namespace is defined in a different assembly, `assembly=` is used to specify
    the assembly that contains the referenced CLR namespace. The value is the name
    of the assembly without the file extension. In our case, it has been omitted since
    the `PassXYZ.Vault` namespace is within the same assembly as our application code.
  prefs: []
  type: TYPE_NORMAL
- en: We will see more uses of namespaces later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: XAML markup extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though we can initialize class instances using XAML elements and set class
    members using XAML attributes, we can only set them as predefined constants in
    a XAML document.
  prefs: []
  type: TYPE_NORMAL
- en: To enhance the power and flexibility of XAML by allowing element attributes
    to be set from a variety of sources, we can use XAML markup extensions. With XAML
    markup extensions, we can set an attribute to values defined somewhere else, or
    a result processed by code at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'XAML markup extensions can be specified in curly braces, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, both the `BackgroundColor` and `Command` attributes have
    been set to markup extensions. `BackgroundColor` has been set to `DynamicResource`
    and `Command` has been set to the `OpenWebCommand` method defined in the view
    model.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we’ve provided a brief introduction to markup extensions, so don’t concern
    yourself with the usage of markup extensions for now. We will delve deeper into
    markup extensions when we use them later. In the next chapter, *Chapter 4*, *Exploring
    MVVM and Data Binding*, we will detail the usage of data binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please refer to the following Microsoft documentation to find out more information
    about markup extensions: [https://learn.microsoft.com/en-us/dotnet/maui/xaml/markup-extensions/consume](https://learn.microsoft.com/en-us/dotnet/maui/xaml/markup-extensions/consume).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve learned the basics about XAML, we can use it to work on our user
    interface design.
  prefs: []
  type: TYPE_NORMAL
- en: Building a user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Equipped with basic knowledge of XAML, let’s take a bird’s-eye view of the .NET
    MAUI user interface building blocks. We will explore them in greater depth as
    we encounter them in subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: A page is the top-level user interface element that typically occupies all the
    screens or windows. We introduced how to create pages using the Visual Studio
    template or `dotnet` command at the beginning of this chapter. Each page generally
    contains at least one layout element, which is used to organize the design of
    controls on a page. Examples of pages are `ContentPage`, `NavigationPage`, `TabbedPage`,
    `FlyoutPage`, and `Shell`.
  prefs: []
  type: TYPE_NORMAL
- en: Within a content page, we utilize views (or controls) as the building blocks
    of the user interface. To organize views into groups, we can use layout components
    as containers for the views.
  prefs: []
  type: TYPE_NORMAL
- en: Layouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Layouts** are container components that help organize and arrange UI elements
    (or views) within your app. They control the position, size, and alignment of
    the UI components based on specific rules.'
  prefs: []
  type: TYPE_NORMAL
- en: Layouts allow you to create consistent and adaptive user interfaces that work
    on different screen sizes and device orientations. Examples include `StackLayout`,
    `Grid`, `FlexLayout`, `RelativeLayout`, and `AbsoluteLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: StackLayout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`StackLayout` organizes elements in a one-dimensional stack, either horizontally
    or vertically. It is often used as a parent layout, which contains other child
    layouts. The default orientation is vertical. However, we should not use `StackLayout`
    to generate a layout similar to a table by using nested `StackLayout` horizontally
    and vertically. The following code shows an example of bad practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we employed a `StackLayout` as the parent layout, where
    the default orientation is vertical. Then, we nested multiple `StackLayout` controls
    with a horizontal orientation to generate a form for data entry.
  prefs: []
  type: TYPE_NORMAL
- en: However, using nested `StackLayouts` to create a layout similar to a table is
    not optimized for such scenarios, and it might lead to performance and layout
    issues. In this situation, we should utilize the `Grid` control.
  prefs: []
  type: TYPE_NORMAL
- en: '`StackLayout` is a frequently used layout control. There are two sub-types
    of `StackLayout` that help us directly design the layout horizontally or vertically.'
  prefs: []
  type: TYPE_NORMAL
- en: HorizontalStackLayout
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`HorizontalStackLayout` is a one-dimensional horizontal stack. For example,
    we can generate a row like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: VerticalStackLayout
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`VerticalStackLayout` is a one-dimensional vertical stack. For example, we
    can display an error message after a form is submitted with an error like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Grid
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Grid` organizes elements in rows and columns. We can specify rows and columns
    with the `RowDefinitions` and `ColumnDefinitions` properties. In the previous
    example, we created a form where the user can enter their name, age, and address
    using a nested `StackLayout`. We can do this in the `Grid` layout like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we created a `Grid` layout with two columns and three
    rows.
  prefs: []
  type: TYPE_NORMAL
- en: FlexLayout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`FlexLayout` is similar to a `StackLayout` in that it displays child elements
    either horizontally or vertically in a stack. The difference is a `FlexLayout`
    can also wrap its children if there are too many to fit in a single row or column.
    As an example, we can create a `FlexLayout` with five labels in a row. If we specify
    the `Direction` property as `Row`, these labels will be displayed in one row.
    We can also specify the `Wrap` property, which can cause the items to wrap to
    the next row if there are too many items to fit in a row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: AbsoluteLayout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`AbsoluteLayout` is a layout control that enables you to position and size
    child elements based on X and Y coordinates in addition to width and height. It
    is particularly useful in scenarios where you need fine-grained control over the
    exact position and size of your UI elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some common use cases for `AbsoluteLayout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Overlap UI elements**: `AbsoluteLayout` allows you to position elements on
    top of others, which can create some effective visuals or display content over
    a background image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom controls**: If you are developing custom controls that require precise
    control over the layout of their components, `AbsoluteLayout` should be your go-to
    choice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complex UI presentation**: You may need to create intricate UIs that don’t
    fit within a standard grid or stack layout. In such scenarios, `AbsoluteLayout`
    gives you the control required to position items accurately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Positioning based on the parent size**: `AbsoluteLayout` allows you to position
    children relative to the bounds of their parent. This makes it easier to place
    elements at specific positions or in response to certain events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Animations**: If you need to animate elements, such as moving them around
    the screen or resizing them, `AbsoluteLayout` can simplify this process by providing
    direct access to the location, width, and height properties of child elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generally speaking, there are three benefits of using `AbsoluteLayout` for
    building layouts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Precise control**: `AbsoluteLayout` provides control over the position, size,
    and layering of child elements, which can be beneficial when working on custom
    or complex UI designs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: Since `AbsoluteLayout` doesn’t require complex calculations
    to arrange elements, it can offer better performance compared to other layout
    types, especially when dealing with a large number of child elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Responsive layouts**: With the support of proportional values, `AbsoluteLayout`
    can help create responsive designs that can scale with different screen sizes
    and orientations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, it’s important to note that using `AbsoluteLayout` everywhere is not
    recommended. It is better suited for specific scenarios where other layouts cannot
    meet the required design or functionality requirements. The disadvantages of `AbsoluteLayout`
    include the difficulty of maintaining the responsive behavior of the UI and the
    potential for unexpected behavior when there are changes to the parent or child
    elements. Instead, you should use other layouts (e.g., `Grid`, `StackLayout`,
    or `FlexLayout`) whenever their features are adequate for your design needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we are creating a `BoxView` control in the layout
    at (0, 0) with both width and height equal to `10`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We have provided an overview of layout controls. For more detailed information,
    please refer to the following Microsoft documentation: [https://learn.microsoft.com/en-us/dotnet/maui/user-interface/layouts/](https://learn.microsoft.com/en-us/dotnet/maui/user-interface/layouts/).'
  prefs: []
  type: TYPE_NORMAL
- en: Views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Views** (also known as controls) are the individual UI elements that users
    interact with or that display content on a screen. They are placed within layouts
    and, in turn, on pages. Views include basic UI controls like `Label`, `Button`,
    `Entry`, and `Image`, as well as more advanced UI controls, such as `CollectionView`,
    `ListView`, and `WebView`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Please refer to the following Microsoft document about the controls in .NET
    MAUI: [https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/](https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll go through some controls that will be frequently used
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Label
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Label` is used to display single-line or multi-line text. It can display text
    with a certain format, such as color, space, text decorations, and even HTML text.
    To create a `Label`, we can use the simplest format, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the user interface design, we usually use icons to decorate other controls
    or display images as backgrounds. The `Image` control can display an image from
    a local file, a URI, an embedded resource, or a stream. The following code shows
    an example of how to create an `Image` control in the simplest form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Editor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our app, the users need to enter or edit a single line of text or multiple
    lines of text. We have two controls to serve this purpose: `Editor` and `Entry`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Editor` can be used to enter or edit multiple lines of text. The following
    is an example of the `Editor` control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Entry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Entry` can be used to enter or edit a single line of text. To design a login
    page, we can use `Entry` controls to enter a username and password. When users
    interact with an `Entry`, the behavior of the keyboard can be customized through
    the `Keyboard` property.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When users enter their passwords, the `IsPassword` property can be set to reflect
    the typical behavior on a login page. The following is an example of a password
    entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: ListView
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In user interface design, a common use case involves displaying a collection
    of data. In .NET MAUI, several controls can be utilized to display a collection
    of data, such as `CollectionView`, `ListView`, and `CarouselView`. In our app,
    we will employ `ListView` to display password entries, groups, and the contents
    of an entry. We will introduce the usage of `ListView` when introducing `ItemsPage`
    and `ItemDetailPage` in *Chapter 4*, *Exploring MVVM and Data Binding*.
  prefs: []
  type: TYPE_NORMAL
- en: With all these building blocks in place, we can construct a content page. Typically,
    an application consists of multiple pages implementing different functionalities.
    To create a functional app, we need to navigate between these pages.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation refers to the process of moving between various pages or views within
    your app, enabling users to interact with multiple screens and access a range
    of features. Navigation is a crucial aspect of app design, as it determines the
    user’s journey through the app and assists them in finding the information they
    require. In .NET MAUI, navigation management is handled using `NavigationPage`,
    `TabbedPage`, `Shell`, or custom navigation if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Master-detail UI design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are various ways to implement navigation within an app. In our app’s navigation
    design, we employ the master-detail pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The master-detail pattern is a widely utilized user interface design approach.
    Many examples of it can be found in frequently used apps. For instance, in the
    Mail app on Windows, a list of emails is displayed in the master view along with
    the details of the selected email:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2: Mail in Windows](img/B21554_03_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: Mail in Windows'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 3.4*, three panels are present in the design. The left panel resembles
    a navigation drawer. When selecting a folder from the left panel, a list of emails
    is shown in the middle panel. The currently selected email is displayed in the
    right panel.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Navigation drawers** provide access to destinations and app functionality,
    such as the menu in the desktop environment. It typically slides in from the left
    and is triggered by tapping an icon in the top-left corner of the screen. It displays
    a list of choices to navigate to and is widely used in mobile and web user interface
    design. Xamarin.Forms and .NET MAUI `Shell` use navigation drawers as their top-level
    navigation methods.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The original KeePass UI design, shown in *Figure 3.5*, also uses three panels
    (left, right, and bottom) on the main page. The left panel is a classic tree view
    that acts like a navigation drawer. The right panel is used to display the list
    of password entries, while the bottom panel serves to exhibit the details of an
    entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3: KeePass UI design](img/B21554_03_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: KeePass UI design'
  prefs: []
  type: TYPE_NORMAL
- en: The master-detail pattern works well on a wide range of device types and display
    sizes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering different display sizes, two popular modes can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: Side-by-side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stacked
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Side-by-side
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When ample horizontal space is available on a large display, the side-by-side
    approach tends to be a sensible choice. The Mail app in *Figure 3.4* and the KeePass
    app in *Figure 3.5* serve as good examples. In this mode, both the master view
    and the detail view can be seen simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Stacked
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using a mobile device, the screen size is typically smaller, with the vertical
    space being larger than the horizontal one. In such instances, the stacked approach
    is more suitable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the stacked mode, the master view occupies the entire screen space. Upon
    making a selection, the detail view then takes up the full screen space:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21554_03_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: PassXYZ.Vault'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 3.6*, we can observe the app navigation from the user’s perspective.
    We have a list of flyout items to choose from:'
  prefs: []
  type: TYPE_NORMAL
- en: '**About**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Browse**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logout**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upon selecting **Browse**, we view the list of items on the master page (`ItemsPage`).
    From this page, if we choose an item, we will go to the item’s detail page (`ItemDetailPage`).
    If we want to select another item, we must return to the master page and make
    another selection.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss flyout items in *Chapter 5*, *Navigation Using .NET MAUI Shell
    and NavigationPage*. In this section, we will examine the implementation of `ItemsPage`
    and `ItemDetailPage`. However, before delving into the specifics, let’s explore
    layouts, which serve as containers for user interface elements.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation in the master-detail UI design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As shown in *Figure 3.6*, we employ a stacked master-detail pattern in our navigation
    scheme. There is a flyout menu to display a list of pages. Within this list of
    pages, a page of the `ItemsPage` type is utilized to display a list of password
    entries. When users select an entry, details about the password entry are shown
    in `ItemDetailPage`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s review the implementation of `ItemsPage` and `ItemDetailPage`.
  prefs: []
  type: TYPE_NORMAL
- en: ItemDetailPage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our app, `ItemDetailPage` serves as the detail page of the master-detail
    pattern, displaying an item’s content. In `ItemDetailPage`, we essentially present
    the `Item` data model. Although it appears quite simple for now, we will gradually
    enhance it throughout this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3.3: `Item.cs` ([https://epa.ms/Item3-3](https://epa.ms/Item3-3))'
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Listing 3.3*, the `Item` class includes three properties: `ID`,
    `Text`, and `Description`. The `Item` instance is loaded by the `LoadItemId` function
    in `ItemDetailViewModel`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In `LoadItemId`, the `GetItemAsync` method of the `IDataStore` interface is
    invoked to obtain the item by its ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'After loading the item, we can present the data to the user in `ItemDetailPage.xaml`,
    as shown in *Listing 3.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3.4: `ItemDetailPage.xaml` ([https://epa.ms/ItemDetailPage3-4](https://epa.ms/ItemDetailPage3-4))'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3.4* represents the XAML file of `ItemDetailPage`. The item detail
    content page includes an instance of `StackLayout` and four instances of `Label`.'
  prefs: []
  type: TYPE_NORMAL
- en: Within `StackLayout`, the default orientation is `Vertical`, causing the `Label`
    controls to be arranged vertically on the item detail page (refer to *Figure 3.4*).
    Both `Name` and `Description` are linked to the model data in the view model through
    data binding, which will be introduced in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: ItemsPage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ItemsPage` serves as the master page of the master-detail pattern in our app,
    presenting a list of items that users can browse.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3.5* showcases the implementation of `ItemsPage`. To display a list
    of items, a `ListView` control is employed. `ListView` is a control designed for
    displaying a scrollable vertical list of selectable data items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3.5: `ItemsPage.xaml` ([https://epa.ms/ItemsPage3-5](https://epa.ms/ItemsPage3-5))'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine this code in greater detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(1)** `x:Class`: This is utilized to define the class name of a partial class
    shared between the markup and code-behind file. `PassXYZ.Vault.Views.ItemsPage`
    is the class name defined here.'
  prefs: []
  type: TYPE_NORMAL
- en: '**(3)** `x:Name`: While `x:Class` defines the class name in XAML, `x:Name`
    defines the instance name. We can refer to the `BrowseItemsPage` instance name
    in the code-behind file.'
  prefs: []
  type: TYPE_NORMAL
- en: '**(2)** `x:DataType`: Setting `x:DataType` to the appropriate type defined
    in the view model enables compiled binding, which can significantly improve performance.
    The view model referred to here is `ItemsViewModel`.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the standard namespace, we have defined two more namespaces so
    that we can reference the objects in the view model **(5)** and model **(6)**.
    We will discuss the view model and model in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**(4)** We define a `ListView` control for displaying the list of items. The
    `ListView` control comprises numerous properties. The following properties must
    be defined when using the `ListView` control:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ItemsSource`, of the `IEnumerable` type, specifies the collection of items
    to display. It binds to `Items`, which is defined in the view model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ItemTemplate`, of the `DataTemplate` type, specifies the template to apply
    to each item in the collection of items to be displayed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In *Listing 3.5*, `DataTemplate` is collapsed. Upon expanding it, we will see
    the following code snippet. This default implementation comes from the Visual
    Studio template. The appearance of this data template is inadequate, and we will
    enhance it later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This `DataTemplate` implementation comprises a `ViewCell` consisting of a `StackLayout`
    with two `Label` controls, as seen in the preview in *Figure 3.6*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DataTemplate` implementation must reference a `Cell` class to display
    items. There are built-in cells available, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TextCell`, which displays primary and secondary text on separate lines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ImageCell`, which exhibits an image alongside primary and secondary text on
    separate lines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SwitchCell`, which showcases text and a switch that can be switched on or
    off.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EntryCell`, which presents a label and text that’s editable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewCell`, which is a custom cell with an appearance defined by a `View`.
    This cell type should be utilized when fully customizing the appearance of each
    item in a `ListView`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typically, `SwitchCell` and `EntryCell` are only used in a `TableView` and can’t
    be employed in a `ListView`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s examine this code in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(1)** To improve `ViewCell`''s appearance, we replaced the `StackLayout`
    with `Grid` as the layout class. `Grid` is a layout that organizes its children
    into rows and columns.'
  prefs: []
  type: TYPE_NORMAL
- en: '**(2)** Since we want to display two rows with an icon on the left, we created
    a grid containing two columns and two rows, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21554_03_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7: Layout of an entry or a group'
  prefs: []
  type: TYPE_NORMAL
- en: We can use different font styles for `Name` and `Description` so that users
    can easily differentiate them visually.
  prefs: []
  type: TYPE_NORMAL
- en: '**(3)** To center the icon within the first two columns, we merged the two
    rows into a `Grid` control. The attached `Grid.RowSpan` property can be used to
    merge rows.'
  prefs: []
  type: TYPE_NORMAL
- en: A `Grid` can function as a parent layout containing other child layouts. To
    maintain a specific size for the icon and position it at the center of the merged
    cell, we can use another `Grid` as the parent of the `Image` control. This child
    `Grid` contains only one row and one column with a specific size.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Image` control, we can use a default image (`icon.png`) from the resource.
    Customization can be applied once we introduce our model in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the customized `ViewCell`, we can display a key-value pair of data with an
    associated icon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to *Figure 3.8* for the improved preview:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21554_03_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.8: Improved ItemsPage'
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, we’ve covered the fundamentals of user interface design
    using XAML. A common challenge in user interface design is providing support for
    multiple languages. In the remainder of this chapter, we will learn how to support
    multiple languages when designing user interfaces in XAML.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting multiple languages – localization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To accommodate multiple languages, we can utilize the .NET built-in mechanism
    for localizing applications. In .NET, resources files can be used to support localization
    by consolidating all text and other resources required for an application’s user
    interface in one location. In a XAML file, we can use the `x:Static` markup extension
    to access the string defined in resources files.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a .resx file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can generate a resources file for each supported language. Resources files
    are XML files with a `.resx` extension, which are compiled into binary resources
    files during the build process. To add a resources file, right-click the project
    node and select **Add > New Item... > Resources File**, as shown in *Figure 3.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7: Creating a Resources File](img/B21554_03_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.9: Creating a resources file'
  prefs: []
  type: TYPE_NORMAL
- en: We can create the `Resources.resx` resources file in the `Properties` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'To support different cultures, we can add additional resources files with cultural
    information as part of the resources file’s name:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Resources.resx`: The resources file for the default culture, which we will
    set to **en-US** (US English).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Resources.zh-Hans.resx`: The resources file for the **zh-Hans** culture, which
    is simplified Chinese.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Resources.zh-Hant.resx`: The resources file for the **zh-Hant** culture, which
    is traditional Chinese.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Upon creating the resources file, the following `ItemGroup` will be added to
    the project file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To edit a resources file, click on the resources file and edit it in the resource
    editor, as shown in *Figure 3.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8: Resource editor](img/B21554_03_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.10: Resource editor'
  prefs: []
  type: TYPE_NORMAL
- en: 'The resources file includes a list of key-value pairs for different languages:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Name` field represents the string name that can be referenced in both XAML
    and C# files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Value` field contains the language-specific string that will be used according
    to the system language settings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Comment` field is employed as a remark for the key-value pair.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To specify the default language, we need to set the value of `NeutralLanguage`
    in `<PropertyGroup>` in the project file, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In our project, we will use US English as the default culture, so `NeutralLanguage`
    is set to `en-US`.
  prefs: []
  type: TYPE_NORMAL
- en: Localizing text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the resources files have been configured, we can use localized content
    in our XAML file or C# files. Currently, our project contains five content pages.
    Let’s modify `AboutPage` to support localization, as shown in *Listing 3.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3.6: `AboutPage.xaml` ([https://epa.ms/AboutPage3-6](https://epa.ms/AboutPage3-6))'
  prefs: []
  type: TYPE_NORMAL
- en: 'Text localization is done using the generated `Resources` class. This class
    is named based on the default resources file name. In *Listing 3.6* `AboutPage.xaml`,
    we added a new namespace **(1)** for the `Resources` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Label` control **(2)**, to display our application name, we can refer
    to the resource string using the `x:Static` XAML markup extension, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In *Listing 3.6*, we collapsed most of the source code for conciseness. Please
    refer to the short URL of this book’s GitHub repository to review the full source
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Localized text can be used in both XAML and C#. To use a resource string in
    C#, we can examine the `Title` property in *Listing 3.6*. The `Title` property
    of `AboutPage` is connected to the `Title` property in the `AboutViewModel` class.
    Let’s see how we can use a resource string in *Listing 3.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3.7: `AboutViewModel.cs` ([https://epa.ms/AboutViewModel3-7](https://epa.ms/AboutViewModel3-7))'
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Listing 3.7*, **(1)** we added the `PassXYZ.Vault.Properties` namespace
    first. **(2)** We refer to the resource string as `Properties.Resources.About`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we update `AboutPage` with localization support, we can test it in the
    supported languages, as shown in *Figure 3.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21554_03_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.11: AboutPage in different languages'
  prefs: []
  type: TYPE_NORMAL
- en: In `AboutPage`, many resource strings are used for localization. In *Listing
    3.6* and *Listing 3.7*, we collapsed most of the code; you can refer to the short
    URL for this book’s GitHub repository to review the source code online.
  prefs: []
  type: TYPE_NORMAL
- en: '**.NET MVVM Community Toolkit**'
  prefs: []
  type: TYPE_NORMAL
- en: The .NET MVVM Community Toolkit is a comprehensive collection of helpers and
    tools aimed at simplifying the development process of applications following the
    **Model-View-View-Model** (**MVVM**) pattern based on .NET libraries.
  prefs: []
  type: TYPE_NORMAL
- en: The toolkit provides a wide array of features aimed at reducing boilerplate
    code, including converters, helpers, behaviors, commands, and services aimed at
    facilitating communication between classes in the MVVM pattern.
  prefs: []
  type: TYPE_NORMAL
- en: More details about the .NET MVVM Community Toolkit will be introduced in the
    next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored XAML syntax and applied the knowledge we gained
    to enhance the appearance of `ItemsPage`. We will persist in refining the user
    interface of other pages throughout this book. To support multiple languages,
    we delved into .NET localization and created multiple resources files for the
    `US-en`, `zh-Hans`, and `zh-Hant` languages. Additionally, we discovered how to
    access strings in the resources files using the XAML markup extension. Lastly,
    we utilized `AboutPage` as an example to demonstrate the use of localized text
    in both XAML and C#.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue improving our app by introducing MVVM
    and data binding.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '.NET Multi-platform App UI documentation: [https://learn.microsoft.com/en-us/dotnet/maui/](https://learn.microsoft.com/en-us/dotnet/maui/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'XAML - .NET MAUI: [https://learn.microsoft.com/en-us/dotnet/maui/xaml/](https://learn.microsoft.com/en-us/dotnet/maui/xaml/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'XAML markup extensions: [https://learn.microsoft.com/en-us/dotnet/maui/xaml/fundamentals/markup-extensions](https://learn.microsoft.com/en-us/dotnet/maui/xaml/fundamentals/markup-extensions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'KeePass – An open-source password manager: [https://keepass.info/](https://keepass.info/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leave a review!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below for a 40% discount code.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Leave_a_review_QR.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Limited Offer*'
  prefs: []
  type: TYPE_NORMAL
