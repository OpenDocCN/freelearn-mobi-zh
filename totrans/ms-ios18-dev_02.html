<html><head></head><body>
		<div id="_idContainer016">
			<h1 id="_idParaDest-33" class="chapter-number"><a id="_idTextAnchor043"/><st c="0">2</st></h1>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor044"/><st c="2">Simplifying Our Entities  with SwiftData</st></h1>
			<p><st c="41">Let’s start our journey to mastering iOS 18 with one of the most important and useful frameworks Apple has released in the last few years – </st><span class="No-Break"><st c="182">SwiftData.</st></span></p>
			<p><strong class="bold"><st c="192">SwiftData</st></strong><st c="202"> is an </st><a id="_idIndexMarker042"/><st c="209">excellent example of Swift macro usage, taking the old and beloved Core Data framework to a whole new level of simplicity and adapting it to the modern world of Swift and </st><span class="No-Break"><st c="380">declarative programming.</st></span></p>
			<p><st c="404">In this chapter, we will do </st><span class="No-Break"><st c="433">the following:</st></span></p>
			<ul>
				<li><st c="447">Understand the </st><span class="No-Break"><st c="463">SwiftData background</st></span></li>
				<li><st c="483">Define a data model, including its relationships </st><span class="No-Break"><st c="533">and attributes</st></span></li>
				<li><st c="547">Learn about the SwiftData container </st><span class="No-Break"><st c="584">and configurations</st></span></li>
				<li><st c="602">Fetch and manipulate data using the </st><span class="No-Break"><st c="639">model context</st></span></li>
				<li><st c="652">Migrate our data to new </st><span class="No-Break"><st c="677">version schemas</st></span></li>
			</ul>
			<p><st c="692">It’s going to be a long ride with an exciting new framework! </st><st c="754">So, after the technical requirements, let’s start with some background on </st><span class="No-Break"><st c="828">the framework.</st></span></p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor045"/><st c="842">Technical requirements</st></h1>
			<p><st c="865">This chapter includes many code examples, some of which can be found in the following </st><span class="No-Break"><st c="952">GitHub repository:</st></span></p>
			<p><a href="https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%202"><span class="No-Break"><st c="970">https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%202</st></span></a></p>
			<p><st c="1056">To run them, we will need Xcode 16 </st><span class="No-Break"><st c="1092">or newer.</st></span></p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor046"/><st c="1101">Understanding SwiftData’s background</st></h1>
			<p><st c="1138">To understand SwiftData’s background and its roots, it’s important to go one step backward and </st><a id="_idIndexMarker043"/><st c="1234">learn about the </st><strong class="bold"><st c="1250">Core </st></strong><span class="No-Break"><strong class="bold"><st c="1255">Data</st></strong></span><span class="No-Break"><st c="1259"> framework.</st></span></p>
			<p><st c="1270">Core Data has been the primary data framework for Apple platforms for many years, even before iOS </st><span class="No-Break"><st c="1369">was born.</st></span></p>
			<p><st c="1378">Core Data was </st><a id="_idIndexMarker044"/><st c="1393">added to iOS in iOS 3, bringing the power of handling a data graph to mobile devices flexibly and efficiently. </st><st c="1504">Note that I haven’t mentioned the word </st><em class="italic"><st c="1543">database</st></em><st c="1551"> or </st><em class="italic"><st c="1555">persistency</st></em><st c="1566">, and that’s for a good reason. </st><st c="1598">We should remember that Core Data is not an </st><strong class="bold"><st c="1642">SQLite</st></strong><st c="1648"> wrapper, even though its persistent store is based on SQLite in most cases. </st><st c="1725">The primary goal of Core Data is to handle our app’s </st><span class="No-Break"><st c="1778">data layer.</st></span></p>
			<p><st c="1789">But what does it mean to handle the app’s data layer? </st><st c="1844">Well, most apps work with several layers – the UI, business logic, and data layer. </st><st c="1927">The data layer is built upon data entities that define the core items that our app works with. </st><st c="2022">For example, a to-do app can have entities such as a </st><em class="italic"><st c="2075">list</st></em><st c="2079">, </st><em class="italic"><st c="2081">task,</st></em><st c="2086"> or </st><em class="italic"><st c="2090">reminder</st></em><st c="2098">. A music app can have entities such as an </st><em class="italic"><st c="2141">album</st></em><st c="2146">, </st><em class="italic"><st c="2148">song</st></em><st c="2152">, </st><span class="No-Break"><st c="2154">or </st></span><span class="No-Break"><em class="italic"><st c="2157">playlist</st></em></span><span class="No-Break"><st c="2165">.</st></span></p>
			<p><st c="2166">The data layer defines the different entities and how they are related. </st><st c="2239">For example, an album can contain many songs, and a list can contain many tasks. </st><st c="2320">if there’s a need for persistence, the data layer also handles how the different entities’ data is saved to disk. </st><st c="2434">According to our understanding of a data layer, Core Data fulfills its role as an app data layer by defining its data model, handling persistency, migrations, and even undo operations. </st><st c="2619">So, if Core Data is such an excellent framework for handling data, why do we </st><span class="No-Break"><st c="2696">need SwiftData?</st></span></p>
			<p><st c="2711">Core Data is a great framework, but it was designed for different times when we used to code with Objective-C, and UIkit hadn’t even been created. </st><st c="2859">Ever since then, the iOS development world has changed significantly – we now have Swift, and moreover, we have SwiftUI. </st><st c="2980">Even though Core Data has received updates to support Swift and SwiftUI, it still felt outdated in a world of type-safety, multithreading, and declarative programming. </st><st c="3148">Fetching and observing data changes have become cumbersome in Core Data, as we use design patterns more suitable for the UIkit/Objective-C era. </st><st c="3292">In this context, SwiftData promises to bring a modern, straightforward framework to handle data much more flawlessly, using the full power of Swift </st><span class="No-Break"><st c="3440">and Combine.</st></span></p>
			<p><st c="3452">One of the best things about SwiftData is that it uses </st><em class="italic"><st c="3508">Swift macros</st></em><st c="3520"> – the same Swift macros we learned about in </st><a href="B21795_10.xhtml#_idTextAnchor329"><span class="No-Break"><em class="italic"><st c="3565">Chapter 10</st></em></span></a><st c="3575">. The macros help us elegantly implement SwiftData without using </st><span class="No-Break"><st c="3640">boilerplate code.</st></span></p>
			<p><st c="3657">It’s time to get into business and create our first </st><span class="No-Break"><st c="3710">SwiftData models!</st></span></p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor047"/><st c="3727">Defining a SwiftData model</st></h1>
			<p><st c="3754">Usually, when </st><a id="_idIndexMarker045"/><st c="3769">discussing a data framework, it is common to start with the basic setup. </st><st c="3842">However, this time, we will begin with the model itself. </st><st c="3899">Why is that? </st><st c="3912">Because I want to demonstrate how simple and easy it is to convert an existing data model to a SwiftData model, using the following piece </st><span class="No-Break"><st c="4050">of code:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="4058">import SwiftData</st></strong>
<strong class="bold"><st c="4075">@Model</st></strong><st c="4082">
class Book {
    var author: String
    var title: String
    var publishedDate: Date
    init(author: String, title: String, publishedDate:
      Date) {
        self.author = author
        self.title = title
        self.publishedDate = publishedDate
    }
}</st></pre>			<p><st c="4294">In this code, we see a standard </st><strong class="source-inline"><st c="4327">Book</st></strong><st c="4331"> class, with the addition of a macro named </st><strong class="source-inline"><st c="4374">@Model</st></strong><st c="4380">. Before we expand the </st><strong class="source-inline"><st c="4403">@Model</st></strong><st c="4409"> macro and see what it does precisely, let’s focus on what happens when we </st><span class="No-Break"><st c="4484">add it.</st></span></p>
			<p><st c="4491">Adding the </st><strong class="source-inline"><st c="4503">@Model</st></strong><st c="4509"> macro is all it takes to convert a regular class into a model backed with a persistent store. </st><st c="4604">Similar to how Core Data entities work, the class name is the entity name, and its variables are the </st><span class="No-Break"><st c="4705">entity attributes.</st></span></p>
			<p><st c="4723">When we </st><a id="_idIndexMarker046"/><st c="4732">compare that to Core Data, we can see that the model declaration process is backward – in Core Data, we declare the model in the model editor and then generate its class, whereas in SwiftData, we take a regular class and make it </st><span class="No-Break"><st c="4961">a model.</st></span></p>
			<p><st c="4969">But what does </st><strong class="source-inline"><st c="4984">@Model</st></strong><st c="4990"> macro really do? </st><st c="5008">Let’s expand it </st><span class="No-Break"><st c="5024">and see.</st></span></p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor048"/><st c="5032">Expanding the @Model macro</st></h2>
			<p><st c="5059">We already </st><a id="_idIndexMarker047"/><st c="5071">know what a Swift Macro is capable of, and SwiftData is a great chance to explore a new </st><span class="No-Break"><st c="5159">macro implementation.</st></span></p>
			<p><st c="5180">To expand the macro, we can right-click on the </st><strong class="source-inline"><st c="5228">@Model</st></strong><st c="5234"> name and select </st><strong class="bold"><st c="5251">Expand Macro</st></strong><st c="5263"> from the pop-up menu. </st><st c="5286">The class body now looks </st><span class="No-Break"><st c="5311">like this:</st></span></p>
			<pre class="source-code"><st c="5321">
@Transient
private var _$backingData: any SwiftData.BackingData&lt;Book&gt;
  = Book.createBackingData()
public var persistentBackingData: any
  SwiftData.BackingData&lt;Book&gt; {
    get {
        _$backingData
    }
    set {
        _$backingData = newValue
    }
}
static var schemaMetadata:
  [SwiftData.Schema.PropertyMetadata] {
  return [
    SwiftData.Schema.PropertyMetadata(name: "author",
      keypath: \Book.author, defaultValue: nil, metadata:
      nil),
    SwiftData.Schema.PropertyMetadata(name: "title",
      keypath: \Book.title, defaultValue: nil, metadata:
      nil),
    SwiftData.Schema.PropertyMetadata(name:
      "publishedDate", keypath: \Book.publishedDate,
      defaultValue: nil, metadata: nil)
  ]
}
required init(backingData: any SwiftData.BackingData&lt;Book&gt;) {
  _author = _SwiftDataNoType()
  _title = _SwiftDataNoType()
  _publishedDate = _SwiftDataNoType()
  self.persistentBackingData = backingData
}
@Transient
private let _$observationRegistrar = Observation.ObservationRegistrar()
struct _SwiftDataNoType {
}
extension Book: SwiftData.PersistentModel {
}
extension Book: Observation.Observable {
}</st></pre>			<p><st c="6354">So, what happened </st><a id="_idIndexMarker048"/><st c="6373">to our beautiful and minimal </st><strong class="source-inline"><st c="6402">Book</st></strong><st c="6406"> class? </st><st c="6414">It appears that the </st><strong class="source-inline"><st c="6434">@Model</st></strong><st c="6440"> macro has been quite </st><span class="No-Break"><st c="6462">active here.</st></span></p>
			<p><st c="6474">To simplify it, let’s try to break </st><span class="No-Break"><st c="6510">it down:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="6518">Our </st></strong><strong class="source-inline"><st c="6523">Book</st></strong><strong class="bold"><st c="6527"> class now conforms to two protocols</st></strong><st c="6563">: These fundamental protocols are </st><strong class="source-inline"><st c="6598">PersistentModel</st></strong><st c="6613"> and </st><strong class="source-inline"><st c="6618">Observable</st></strong><st c="6628">. The </st><strong class="source-inline"><st c="6634">PersistentModel</st></strong><st c="6649"> protocol helps SwiftData work with our style and access its attributes. </st><st c="6722">The </st><strong class="source-inline"><st c="6726">Observable</st></strong><st c="6736"> protocol allows us to be notified of changes to </st><span class="No-Break"><st c="6785">the data.</st></span></li>
				<li><strong class="bold"><st c="6794">Having backing data and metadata properties</st></strong><st c="6838">: If we go even deeper with our exploration and try to understand what the </st><strong class="source-inline"><st c="6914">PersistentModel</st></strong><st c="6929"> protocol is, we will discover that it requires the implementation of two variables –</st><strong class="source-inline"><st c="7014">backingData</st></strong><st c="7026"> and </st><strong class="source-inline"><st c="7031">schemaMetaData</st></strong><st c="7045">. We can see their implementation directly in our macro-expanded code. </st><st c="7116">These variables help SwiftData to store and retrieve our entity information specifically for our properties. </st><st c="7225">And perhaps this is where the real power of Swift Macro comes into play – the ability to generate code that is custom-made for </st><span class="No-Break"><st c="7352">our class.</st></span></li>
				<li><strong class="bold"><st c="7362">We have property macros</st></strong><st c="7386">: If we look at the class properties, we can see that they have their macros now. </st><st c="7469">Expanding them reveals that they have now become a computed variable, so we can store and retrieve data not from just our memory but also from our backing </st><span class="No-Break"><st c="7624">data store:</st></span><pre class="source-code">
<strong class="bold"><st c="7635">@_PersistedProperty</st></strong><st c="7655">
var author: String
</st><strong class="bold"><st c="7675">@_PersistedProperty</st></strong><st c="7694">
var title: String
</st><strong class="bold"><st c="7713">@_PersistedProperty</st></strong><st c="7732">
var publishedDate: Date</st></pre></li>			</ul>
			<p><st c="7756">Additional lines </st><a id="_idIndexMarker049"/><st c="7774">of code wrap everything together, such as the observation and </st><span class="No-Break"><st c="7836">registering attributes.</st></span></p>
			<p><st c="7859">Is this complicated? </st><st c="7881">A little bit. </st><st c="7895">But that’s one of the benefits of having a macro – to simplify complex implementations. </st><st c="7983">What’s important to understand is that every class marked with a </st><strong class="source-inline"><st c="8048">@Model</st></strong><st c="8054"> macro immediately receives a store of its own and is added to the </st><span class="No-Break"><st c="8121">SwiftData schema.</st></span></p>
			<p><st c="8138">However, to add a more complex data model, we need to be able to define relationships between our models. </st><st c="8245">Let’s see how </st><span class="No-Break"><st c="8259">it works.</st></span></p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor049"/><st c="8268">Adding relationships</st></h2>
			<p><st c="8289">Unlike real life, in SwiftData, relationships </st><span class="No-Break"><st c="8336">are simple.</st></span></p>
			<p><st c="8347">A </st><strong class="bold"><st c="8350">relationship</st></strong><st c="8362"> is a </st><a id="_idIndexMarker050"/><st c="8368">database scheme that defines how entities are linked to each other, and in Core Data, we have two types of relationships – </st><strong class="bold"><st c="8491">to-one</st></strong><st c="8497"> and </st><strong class="bold"><st c="8502">to-many</st></strong><st c="8509">. In short, a </st><em class="italic"><st c="8523">to-one</st></em><st c="8529"> relationship means that we will have one instance of the other kind for each entity instance. </st><st c="8624">An example of that would be cars and engines – every car has one, and only one, engine, so that will make the relationship between them a </st><em class="italic"><st c="8762">to-one</st></em><st c="8768"> relationship. </st><st c="8783">However, cars and wheels have a </st><em class="italic"><st c="8815">to-many</st></em><st c="8822"> relationship because a car can have </st><span class="No-Break"><st c="8859">multiple wheels.</st></span></p>
			<p><st c="8875">Even though the explanation is simple enough, it gets even simpler in SwiftData. </st><st c="8957">If we want to define a relationship between models, we just need to create another variable, as </st><span class="No-Break"><st c="9053">shown here:</st></span></p>
			<pre class="source-code"><st c="9064">
@Model
class Book {
    var title: String
    var publishedDate: Date
    </st><strong class="bold"><st c="9127">var author: Author</st></strong><strong class="bold"><st c="9145">var pages: [Page]</st></strong><st c="9163">
    init(author: Author, title: String, publishedDate:
      Date) {
        self.title = title
        self.publishedDate = publishedDate
        </st><strong class="bold"><st c="9277">self.author = author</st></strong><strong class="bold"><st c="9297">self.pages = []</st></strong><st c="9313">
    }
}</st></pre>			<p><st c="9317">In our </st><a id="_idIndexMarker051"/><st c="9325">example, we added the following two properties to the </st><span class="No-Break"><strong class="source-inline"><st c="9379">Book</st></strong></span><span class="No-Break"><st c="9383"> class:</st></span></p>
			<ul>
				<li><strong class="source-inline"><st c="9390">Author</st></strong><st c="9397">: This is a </st><em class="italic"><st c="9410">to-one</st></em><st c="9416"> relationship to the </st><strong class="source-inline"><st c="9437">Author</st></strong><st c="9443"> entity because, in our case, each book has only </st><span class="No-Break"><st c="9492">one author</st></span></li>
				<li><strong class="source-inline"><st c="9502">pages</st></strong><st c="9508">: In the case of </st><strong class="source-inline"><st c="9526">Page</st></strong><st c="9530"> entity, we </st><a id="_idTextAnchor050"/><a id="_idTextAnchor051"/><st c="9542">have a </st><em class="italic"><st c="9549">to-many</st></em><st c="9556"> relationship, since a book can contain </st><span class="No-Break"><st c="9596">multiple pages</st></span></li>
			</ul>
			<p><st c="9610">One thing to note is that we also need to mark both </st><strong class="source-inline"><st c="9663">Page</st></strong><st c="9667"> and </st><strong class="source-inline"><st c="9672">Author</st></strong><st c="9678"> entities with the </st><strong class="source-inline"><st c="9697">@Model</st></strong><st c="9703"> macro, as they must be part of our schema. </st><st c="9747">This can be seen in the </st><span class="No-Break"><st c="9771">following code:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="9786">@Model</st></strong><st c="9793">
class Author {
    var name: String
    init() {
        self.name = ""
    }
}
</st><strong class="bold"><st c="9854">@Model</st></strong><st c="9860">
class Page {
    var content: String
    var order: Int
    init(content: String, order: Int) {
        self.content = content
        self.order = order
    }
}</st></pre>			<p><st c="9990">Is adding </st><a id="_idIndexMarker052"/><st c="10001">models so simple? </st><st c="10019">The short answer is, yes! </st><st c="10045">Linking entities to each other in SwiftData is as easy as adding </st><span class="No-Break"><st c="10110">a property.</st></span></p>
			<p><st c="10121">The longer answer is, well, we’ll have to do extra work to customize the relationships a little bit. </st><st c="10223">Let’s meet the </st><strong class="source-inline"><st c="10238">@</st></strong><span class="No-Break"><strong class="source-inline"><st c="10239">Relationship</st></strong></span><span class="No-Break"><st c="10251"> macro.</st></span></p>
			<p><st c="10258">If you’re familiar with Core Data relationships, you probably know there is more than declaring </st><em class="italic"><st c="10355">to-many</st></em> <span class="No-Break"><st c="10362">and </st></span><span class="No-Break"><em class="italic"><st c="10367">to-one</st></em></span><span class="No-Break"><st c="10373">.</st></span></p>
			<p class="callout-heading"><st c="10374">To-many and to-one relationships</st></p>
			<p class="callout"><st c="10407">To-one relationships </st><a id="_idIndexMarker053"/><st c="10429">represent associations between entities where </st><a id="_idIndexMarker054"/><st c="10475">one instance of an entity is related to another single instance of a different entity. </st><st c="10562">Conversely, to-many relationships represent associations where one instance of an entity can be related to multiple instances of another entity. </st><st c="10707">For example, in a bookstore database, a to-one relationship could connect a “book” entity to an “author” entity, as each book has one author. </st><st c="10849">In contrast, a to-many relationship could connect a “book” entity to a “category” entity, as a book can belong to </st><span class="No-Break"><st c="10963">multiple categories.</st></span></p>
			<p><st c="10983">We can customize our relationship using the </st><strong class="source-inline"><st c="11028">@Relationship</st></strong><st c="11041"> macro in two </st><span class="No-Break"><st c="11055">primary ways.</st></span></p>
			<p><st c="11068">Let’s start with defining the </st><span class="No-Break"><st c="11099">deletion rules.</st></span></p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor052"/><st c="11114">SwiftData relationship deletion rules</st></h2>
			<p><st c="11152">What happens to </st><strong class="source-inline"><st c="11169">pages</st></strong><st c="11174"> and </st><strong class="source-inline"><st c="11179">author</st></strong><st c="11185"> entities if we delete a book? </st><st c="11216">Logically, all the book pages </st><a id="_idIndexMarker055"/><st c="11246">need to be deleted, but the author needs to be retained because they might be linked to another book. </st><st c="11348">We can represent this logic with </st><em class="italic"><st c="11381">deletion rules</st></em><st c="11395">; if you’re familiar with Core Data, it is basically the same as </st><span class="No-Break"><st c="11461">in SwiftData.</st></span></p>
			<p><st c="11474">This is how we can define the logic to a property </st><span class="No-Break"><st c="11525">in SwiftData:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="11538">@Relationship(.unique, deleteRule: .cascade)</st></strong><st c="11583"> var pages: [Page]</st></pre>			<p><st c="11601">In our code example, we defined the delete rule </st><span class="No-Break"><st c="11650">as </st></span><span class="No-Break"><strong class="source-inline"><st c="11653">cascade</st></strong></span><span class="No-Break"><st c="11660">.</st></span></p>
			<p><st c="11661">We have four different </st><span class="No-Break"><st c="11685">deletion rules:</st></span></p>
			<ul>
				<li><strong class="source-inline"><st c="11700">cascade</st></strong><st c="11708">: Deletes any </st><span class="No-Break"><st c="11723">related objects</st></span></li>
				<li><strong class="source-inline"><st c="11738">deny</st></strong><st c="11743">: Prevents deletion of an object if it contains one or more references to </st><span class="No-Break"><st c="11818">other objects</st></span></li>
				<li><strong class="source-inline"><st c="11831">nullify</st></strong><st c="11839">: Nullifies the related object’s reference to the </st><span class="No-Break"><st c="11890">deleted object</st></span></li>
				<li><strong class="source-inline"><st c="11904">noAction</st></strong><st c="11913">: In this case, nothing will happen to the </st><span class="No-Break"><st c="11957">other object</st></span></li>
			</ul>
			<p><st c="11969">We should remember that a deletio</st><a id="_idTextAnchor053"/><a id="_idTextAnchor054"/><st c="12003">n rule is not arbitrary; it should be based on our app </st><span class="No-Break"><st c="12059">business ideas.</st></span></p>
			<p><st c="12074">For example, the reason why a book has a </st><em class="italic"><st c="12116">to-one</st></em><st c="12122"> connection to an author sounds logical, but there are books with co-authors as well. </st><st c="12208">So, this is something that should be aligned with our </st><span class="No-Break"><st c="12262">product manager.</st></span></p>
			<p><st c="12278">Most of us </st><a id="_idIndexMarker056"/><st c="12290">are more familiar with the term </st><em class="italic"><st c="12322">one-to-many</st></em><st c="12333"> than </st><em class="italic"><st c="12339">to-many</st></em><st c="12346">. This is because relationships between objects go both ways – the fact that each book has one author doesn’t mean that each author has only one book. </st><st c="12497">So, as part of th</st><a id="_idTextAnchor055"/><a id="_idTextAnchor056"/><st c="12514">e relationship definition, we also need to define its </st><span class="No-Break"><st c="12569">inverse relationship.</st></span></p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor057"/><st c="12590">Defining the inverse relationship</st></h2>
			<p><st c="12624">Why do we need to define the inverse relationship? </st><st c="12676">We need to realize that relationships </st><a id="_idIndexMarker057"/><st c="12714">always have two sides (like in real life!), and we need to maintain them to have a proper </st><span class="No-Break"><st c="12804">data schema.</st></span></p>
			<p><st c="12816">When establishing a relationship between a book and its pages, it’s better to define the inverse relationship as well. </st><st c="12936">This way, we can create a proper reference back to </st><span class="No-Break"><st c="12987">the book.</st></span></p>
			<p><st c="12996">Let’s see how to create an inverse relationship between a book and its pages through the </st><span class="No-Break"><st c="13086">following code:</st></span></p>
			<pre class="source-code"><st c="13101">
@Model
class Book {
…
</st><strong class="bold"><st c="13124">    @Relationship(inverse: \Page.book) var pages: [Page] =</st></strong>
<strong class="bold"><st c="13178">      []</st></strong><st c="13181">
…
}
@Model
class Page {
    var content: String
</st><strong class="bold"><st c="13225">    var book: Book?</st></strong><st c="13240">
    init(content: String) {
        self.content = content
    }
}</st></pre>			<p><st c="13291">Looking at the code, we can see that we define the relationship as </st><span class="No-Break"><st c="13359">a keypath:</st></span></p>
			<pre class="source-code"><st c="13369">
\Page.book</st></pre>			<p><st c="13380">A keypath can </st><a id="_idIndexMarker058"/><st c="13395">help us avoid typos and mistakes when defining the </st><span class="No-Break"><st c="13446">inverse property.</st></span></p>
			<p><st c="13463">Moreover, if we add a new page to the </st><strong class="source-inline"><st c="13502">pages</st></strong><st c="13507"> property, SwiftData will automatically set the Page’s </st><strong class="source-inline"><st c="13562">book</st></strong><st c="13566"> property to the </st><span class="No-Break"><st c="13583">new book:</st></span></p>
			<pre class="source-code"><st c="13592">
let newPage = Page(content: "Swift Data")
newPage.book = book
// book.pages property </st><strong class="bold"><st c="13678">contains</st></strong><st c="13686"> 'newPage'</st></pre>			<p><st c="13696">SwiftData knows how to do that using our </st><span class="No-Break"><st c="13738">inverse declaration.</st></span></p>
			<p><st c="13758">The inverse relationship may sound like an obvious feature – if we have a book with several pages, and each page is related to a book, isn’t it obvious that the </st><strong class="source-inline"><st c="13920">book</st></strong><st c="13924"> property in the </st><strong class="source-inline"><st c="13941">page</st></strong><st c="13945"> class is the inverse relationship? </st><st c="13981">However, in reality, it’s not obvious. </st><st c="14020">There are several real-world use cases when relationships can be much </st><span class="No-Break"><st c="14090">more complex.</st></span></p>
			<p><st c="14103">Let’s take, for example, the data structure of a folder tree – each folder has its sub-folders. </st><st c="14200">This means that a folder has a </st><em class="italic"><st c="14231">to-one</st></em><st c="14237"> relationship to its parent and a </st><em class="italic"><st c="14271">to-many</st></em><st c="14278"> relationship to its children. </st><st c="14309">Let’s see that in </st><span class="No-Break"><st c="14327">the code:</st></span></p>
			<pre class="source-code"><st c="14336">
@Model
class Folder {
    var parent: Folder?
    </st><st c="14379">@Relationship(inverse: \Folder.parent) var subFolders:
      [Folder]
    var name: String
    var id: UUID
    init(parent: Folder? </st><st c="14494">= nil, subFolders: [Folder], name:
      String, id: UUID) {
        self.parent = parent
        self.subFolders = subFolders
        self.name = name
        self.id = id
    }
}</st></pre>			<p><st c="14632">This example </st><a id="_idIndexMarker059"/><st c="14646">demonstrates what a </st><strong class="source-inline"><st c="14666">Folder</st></strong><st c="14672"> class looks like when trying to create a multi-level hierarchical structure. </st><st c="14750">In this case, we must define the inverse relationship to </st><span class="No-Break"><st c="14807">avoid cycles.</st></span></p>
			<p><st c="14820">Now that we know how relationships work in SwiftData, let’s see more ways to customize our model, using the </st><strong class="source-inline"><st c="14929">@</st></strong><span class="No-Break"><strong class="source-inline"><st c="14930">Attribute</st></strong></span><span class="No-Break"><st c="14939"> macro.</st></span></p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor058"/><st c="14946">Adding the @Attribute macro</st></h2>
			<p><st c="14974">So far, we have learned how to declare new entities, properties, and even relationships between </st><a id="_idIndexMarker060"/><st c="15071">our entities. </st><st c="15085">It looks like we can do anything with our data entities! </st><st c="15142">Now, it’s essential to drill down to the </st><span class="No-Break"><st c="15183">property level.</st></span></p>
			<p><st c="15198">Along with our </st><strong class="source-inline"><st c="15214">@Model</st></strong><st c="15220"> and </st><strong class="source-inline"><st c="15225">@Relationship</st></strong><st c="15238"> macros, we now have the </st><strong class="source-inline"><st c="15263">@Attribute</st></strong><st c="15273"> macro to define the behavior of a </st><span class="No-Break"><st c="15308">specific property.</st></span></p>
			<p><st c="15326">If you remember from Core Data, each attribute has an inspector window where we can configure an attribute’s behavior (</st><span class="No-Break"><em class="italic"><st c="15446">Figure 2</st></em></span><span class="No-Break"><em class="italic"><st c="15455">.1</st></em></span><span class="No-Break"><st c="15457">):</st></span></p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/B21795_02_1.jpg" alt="Figure 2.1: The Attribute inspector in Core Data"/><st c="15460"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="15805">Figure 2.1: The Attribute inspector in Core Data</st></p>
			<p><span class="No-Break"><em class="italic"><st c="15853">Figure 2</st></em></span><em class="italic"><st c="15862">.1</st></em><st c="15864"> shows what it looks like when we select one of the attributes (</st><strong class="source-inline"><st c="15928">firstName</st></strong><st c="15938"> in this example) and how we can customize </st><span class="No-Break"><st c="15981">its behavior.</st></span></p>
			<p><st c="15994">We can </st><a id="_idIndexMarker061"/><st c="16002">define some of these settings in SwiftData as part of the property declaration. </st><st c="16082">For example, the Optional feature, as seen in </st><span class="No-Break"><em class="italic"><st c="16128">Figure 2</st></em></span><em class="italic"><st c="16136">.1</st></em><st c="16138">, is defined by marking a property as Swift optional type, and the default value is part of </st><span class="No-Break"><st c="16230">variable initialization:</st></span></p>
			<pre class="source-code"><st c="16254">
var firstName: String? </st><st c="16278">= "MyName"</st></pre>			<p><st c="16288">However, other settings need to be declared as part of the </st><strong class="source-inline"><st c="16348">@</st></strong><span class="No-Break"><strong class="source-inline"><st c="16349">Attribute</st></strong></span><span class="No-Break"><st c="16358"> macro.</st></span></p>
			<p><st c="16365">Let’s start with the most common one, </st><strong class="source-inline"><st c="16404">unique</st></strong><st c="16410">, and making attributes unique is an important feature of many databases, </st><span class="No-Break"><st c="16484">including </st></span><span class="No-Break"><em class="italic"><st c="16494">SQLite</st></em></span><span class="No-Break"><st c="16500">.</st></span></p>
			<p><st c="16501">The following are a few </st><span class="No-Break"><st c="16526">reasons why:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="16538">Setting up a primary key</st></strong><st c="16563">: A primary key represents a record’s unique identifier. </st><st c="16621">We use a primary key to ensure that there are no duplicates in </st><span class="No-Break"><st c="16684">our table.</st></span></li>
				<li><strong class="bold"><st c="16694">Supporting indexing</st></strong><st c="16714">: Unique attributes can help us index our database for searching </st><span class="No-Break"><st c="16780">and retrieval.</st></span></li>
				<li><strong class="bold"><st c="16794">Helping with data validation</st></strong><st c="16823">: Utilizing unique attributes goes beyond primary keys and extends to other distinctive attributes, enhancing our ability to validate data </st><span class="No-Break"><st c="16963">during insertion.</st></span></li>
			</ul>
			<p><st c="16980">Even though </st><em class="italic"><st c="16993">SQLite</st></em><st c="16999"> supports unique attributes, Core Data doesn’t have a built-in way to support </st><a id="_idIndexMarker062"/><st c="17077">unique identifiers, derived from its design philosophy to offer complete flexibility </st><span class="No-Break"><st c="17162">to developers.</st></span></p>
			<p><st c="17176">Conversely, SwiftData supports unique attributes out of </st><span class="No-Break"><st c="17233">the box:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="17241">@Attribute(.unique)</st></strong><st c="17261"> var id: UUID = UUID()</st></pre>			<p><st c="17283">Adding the </st><strong class="source-inline"><st c="17295">@Attribute</st></strong><st c="17305"> macro with the </st><strong class="source-inline"><st c="17321">.unique</st></strong><st c="17328"> option makes our database’s specific property </st><span class="No-Break"><st c="17375">values unique.</st></span></p>
			<p><strong class="source-inline"><st c="17389">UUID</st></strong><st c="17394"> is a classic example of a unique value for a property, but we can apply that to any other type of property, such as user IDs </st><span class="No-Break"><st c="17520">and names.</st></span></p>
			<p><st c="17530">But what does it really mean to make a property </st><em class="italic"><st c="17579">unique</st></em><st c="17585">? What will happen when we try to insert an instance with an already existing </st><span class="No-Break"><st c="17663">unique attribute?</st></span></p>
			<p><st c="17680">In the case of a unique property, SwiftData performs an </st><strong class="bold"><st c="17737">upsert</st></strong><st c="17743">, which is also called an </st><strong class="source-inline"><st c="17769">INSERT</st></strong><st c="17775"> or </st><strong class="source-inline"><st c="17779">UPDATE</st></strong><st c="17785"> operation. </st><st c="17797">This means that if an instance with a unique value already exists, SwiftData will not create a new object in its store but, rather, update the </st><span class="No-Break"><st c="17940">existing instance.</st></span></p>
			<p><st c="17958">Declaring a property as unique using the </st><strong class="source-inline"><st c="18000">@Attribute</st></strong><st c="18010"> macro is straightforward. </st><st c="18037">However, sometimes we need something more sophisticated. </st><st c="18094">For example, let’s say we have a </st><strong class="source-inline"><st c="18127">Book</st></strong><st c="18131"> model with </st><strong class="source-inline"><st c="18143">name</st></strong><st c="18147"> and </st><strong class="source-inline"><st c="18152">publicationName</st></strong><st c="18167"> properties. </st><st c="18180">In our case, we can have two books with the same name or the same </st><strong class="source-inline"><st c="18246">publicationName</st></strong><st c="18261">, but we can’t have two books when both properties are identical. </st><st c="18327">The combination of </st><strong class="source-inline"><st c="18346">publicationName</st></strong><st c="18361"> and </st><strong class="source-inline"><st c="18366">name</st></strong><st c="18370"> creates the book’s </st><span class="No-Break"><st c="18390">unique identity.</st></span></p>
			<p><st c="18406">One solution is maintaining a property that tries to build a unique ID from these two properties. </st><st c="18505">Another elegant option is to use the </st><strong class="source-inline"><st c="18542">#Unique</st></strong><st c="18549"> macro to define more complex </st><span class="No-Break"><st c="18579">uniqueness requirements:</st></span></p>
			<pre class="source-code"><st c="18603">
@Model
class Book {
</st><strong class="bold"><st c="18624">    #Unique&lt;Book&gt;([\.name, \.publicationName])</st></strong><st c="18666">
    var publicationName: String = "Packt"
    var name: String
}</st></pre>			<p><st c="18723">In this code example, we enforce the uniqueness of the </st><strong class="source-inline"><st c="18779">Book</st></strong><st c="18783"> model by combining two key paths. </st><st c="18818">Just like the attribute parameter, </st><strong class="source-inline"><st c="18853">.unique</st></strong><st c="18860">, if we try to insert a new book instance </st><a id="_idIndexMarker063"/><st c="18902">when we already have one with the same name and publication name, SwiftData will perform an </st><strong class="source-inline"><st c="18994">upsert</st></strong><st c="19000"> operation and update </st><span class="No-Break"><st c="19022">that instance.</st></span></p>
			<p><st c="19036">Even though SwiftData handles unique attributes well, it is important to ensure we carefully pick unique attributes and key paths according to an application’s requirements. </st><st c="19211">Too many unique attributes can cause complexity and </st><span class="No-Break"><st c="19263">performance issues.</st></span></p>
			<p><st c="19282">Unique attributes are great for simplifying the task of handling duplicate instances. </st><st c="19369">Another attribute feature that can make our life simpler </st><span class="No-Break"><st c="19426">is </st></span><span class="No-Break"><em class="italic"><st c="19429">transient</st></em></span><span class="No-Break"><st c="19438">.</st></span></p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor059"/><st c="19439">Going non-persistent with transient</st></h2>
			<p><st c="19475">The nice thing about working with SwiftData is that all properties automatically become the entity’s </st><a id="_idIndexMarker064"/><st c="19577">attributes and are saved persistently to the local data store. </st><st c="19640">However, sometimes, there are cases where we want to have a property that is </st><em class="italic"><st c="19717">memory-only</st></em><st c="19728"> and not saved persistently. </st><st c="19757">A formatted version of one of the values is an excellent example of such a property. </st><st c="19842">One option to achieve that is to create a function or a computed variable, and then return a value based on the relevant property. </st><st c="19973">However, there are other cases where a computed variable or a function is not a convenient solution. </st><st c="20074">Let’s say we want a temporary counter or to maintain a flag relevant only to an application’s current </st><span class="No-Break"><st c="20176">life cycle.</st></span></p>
			<p><st c="20187">For these kinds of cases, we </st><a id="_idIndexMarker065"/><st c="20217">have a </st><em class="italic"><st c="20224">transient</st></em><st c="20233"> attribute. </st><st c="20245">Transient attribute is not a new idea – Core Data had transient properties from its early versions. </st><st c="20345">Since SwiftData is based on Core Data fundamentals, it supports transient properties out of </st><span class="No-Break"><st c="20437">the box.</st></span></p>
			<p><st c="20445">Here is how we declare a </st><em class="italic"><st c="20471">transient</st></em><st c="20480"> property </st><span class="No-Break"><st c="20490">in SwiftData:</st></span></p>
			<pre class="source-code"><st c="20503">
@Transient
var openCounter: Int = 0</st></pre>			<p><st c="20539">In this code snippet, the </st><strong class="source-inline"><st c="20566">openCounter</st></strong><st c="20577"> variable will not be saved locally to the persistent </st><a id="_idIndexMarker066"/><st c="20631">store and will be initialized each time we fetch the entity from </st><span class="No-Break"><st c="20696">our database.</st></span></p>
			<p><st c="20709">Transient properties may sound like a minor feature, but there are many cases where it really makes the difference, and the transient macro provides this flexibility. </st><st c="20877">Full names or calculated ages are great examples </st><span class="No-Break"><st c="20926">of that.</st></span></p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor060"/><st c="20934">Exploring the container</st></h1>
			<p><st c="20958">Until now, we discussed how to declare the different entities using the </st><strong class="source-inline"><st c="21031">@Model</st></strong><st c="21037"> macro, define their </st><a id="_idIndexMarker067"/><st c="21058">relationships using the </st><strong class="source-inline"><st c="21082">@Relationship</st></strong><st c="21095"> macro, and customize their attributes using the </st><strong class="source-inline"><st c="21144">@</st></strong><span class="No-Break"><strong class="source-inline"><st c="21145">Attribute</st></strong></span><span class="No-Break"><st c="21154"> macro.</st></span></p>
			<p><st c="21161">However, we haven’t discussed setting up SwiftData to work with a schema and a </st><span class="No-Break"><st c="21241">persistent store.</st></span></p>
			<p><st c="21258">When we delved into the </st><strong class="source-inline"><st c="21283">@Model</st></strong><st c="21289"> macro, drawing parallels with Core Data was straightforward and remains so now. </st><st c="21370">In Core Data, we set up the stack using </st><strong class="source-inline"><st c="21410">NSPersistentContainer</st></strong><st c="21431">, which encapsulates the different components, such as the data model, the store, and the context, into one stack that we can </st><span class="No-Break"><st c="21557">work with.</st></span></p>
			<p><st c="21567">In SwiftData, we use </st><strong class="source-inline"><st c="21589">ModelContainer</st></strong><st c="21603">, which has the </st><span class="No-Break"><st c="21619">same responsibility.</st></span></p>
			<p><st c="21639">Let’s try to understand how </st><span class="No-Break"><st c="21668">it works.</st></span></p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor061"/><st c="21677">Setting up ModelContainer</st></h2>
			<p><strong class="source-inline"><st c="21703">ModelContainer</st></strong><st c="21718"> is essential </st><a id="_idIndexMarker068"/><st c="21732">for working with SwiftData. </st><st c="21760">The reason is that SwiftData has three main components that the container encapsulates and </st><span class="No-Break"><st c="21851">wraps together:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="21866">The data model</st></strong><st c="21881">: This is what we defined in the </st><em class="italic"><st c="21915">Defining a SwiftData model </st></em><st c="21942">section, adding the </st><strong class="source-inline"><st c="21962">@Model</st></strong><st c="21968"> macro to </st><span class="No-Break"><st c="21978">our entities</st></span></li>
				<li><strong class="bold"><st c="21990">The store</st></strong><st c="22000">: The backend store where we will save </st><span class="No-Break"><st c="22040">our data</st></span></li>
				<li><strong class="bold"><st c="22048">The context</st></strong><st c="22060">: This is our link to the store and the sandbox, where we can add, edit, and delete </st><span class="No-Break"><st c="22145">different records</st></span></li>
			</ul>
			<p><st c="22162">Here is the basic and minimal way to create </st><span class="No-Break"><st c="22207">a container:</st></span></p>
			<pre class="source-code"><st c="22219">
    var container: ModelContainer = {
        do {
            retur</st><a id="_idTextAnchor062"/><a id="_idTextAnchor063"/><a id="_idTextAnchor064"/><a id="_idTextAnchor065"/><st c="22264">n try </st><strong class="bold"><st c="22271">ModelContainer</st></strong><st c="22285">(for:
              Schema([</st><strong class="bold"><st c="22300">Book.self, Author.self, Page.self</st></strong><st c="22334">]) )
        } catch {
            fatalError("Could not create ModelContainer:
              \(error)")
        }
    }()</st></pre>			<p><st c="22411">In this code, we create an object from the </st><strong class="source-inline"><st c="22455">ModelContainer</st></strong><st c="22469"> type and provide it with the three models we made earlier in the </st><em class="italic"><st c="22535">Defining a SwiftData </st></em><span class="No-Break"><em class="italic"><st c="22556">Model</st></em></span><span class="No-Break"><st c="22561"> section.</st></span></p>
			<p><st c="22570">Note that, in our case, we have one parameter, </st><strong class="source-inline"><st c="22618">Schema</st></strong><st c="22624">, which holds all the different models relevant to our container – </st><strong class="source-inline"><st c="22691">Book</st></strong><st c="22695">, </st><strong class="source-inline"><st c="22697">Author</st></strong><st c="22703">, </st><span class="No-Break"><st c="22705">and </st></span><span class="No-Break"><strong class="source-inline"><st c="22709">Page</st></strong></span><span class="No-Break"><st c="22713">.</st></span></p>
			<p><st c="22714">The fact that we need to provide a list of models may raise some eyebrows – why do we need to do that? </st><st c="22818">Can’t Xcode locate all the models and add them automatically? </st><st c="22880">The </st><strong class="source-inline"><st c="22884">@Model</st></strong><st c="22890"> macro indeed expands code at compile time, but it doesn’t mean SwiftData is aware of all our entities when we set it up at the beginning of the app run. </st><st c="23044">So, whenever we add a new model, we must add it to the list of models in our </st><span class="No-Break"><strong class="source-inline"><st c="23121">Schema</st></strong></span><span class="No-Break"><st c="23127"> parameter.</st></span></p>
			<p><st c="23138">Regarding including the </st><strong class="source-inline"><st c="23163">Book</st></strong><st c="23167"> entity independently from the </st><strong class="source-inline"><st c="23198">Author</st></strong><st c="23204"> entity – when we add the </st><strong class="source-inline"><st c="23230">Book</st></strong><st c="23234"> model to the models’ list, it automatically consists of all associated models, including those related to the models further down the </st><a id="_idTextAnchor066"/><a id="_idTextAnchor067"/><st c="23369">hierarchy. </st><st c="23380">It means that, theoretically, we can include only the root object while doing something </st><span class="No-Break"><st c="23468">like that:</st></span></p>
			<pre class="source-code"><st c="23478">
Schema([Book.self])</st></pre>			<p><st c="23498">And that </st><a id="_idIndexMarker069"/><st c="23508">will be enough to include </st><strong class="source-inline"><st c="23534">Author</st></strong> <span class="No-Break"><st c="23540">and </st></span><span class="No-Break"><strong class="source-inline"><st c="23545">Page</st></strong></span><span class="No-Break"><st c="23549">.</st></span></p>
			<p><st c="23550">So, what will we do with the container instance we just created? </st><st c="23616">Let’s see in the </st><span class="No-Break"><st c="23633">next section.</st></span></p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor068"/><st c="23646">Connecting the container using the modelContainer modifier</st></h2>
			<p><st c="23705">Now that </st><a id="_idIndexMarker070"/><st c="23715">we have a model container, we want to link it somehow to our UI so that we can start </st><span class="No-Break"><st c="23800">using it.</st></span></p>
			<p><st c="23809">To do that, we will use the </st><strong class="source-inline"><st c="23838">modelContainer</st></strong><st c="23852"> modifier to connect the container to </st><span class="No-Break"><st c="23890">our scene:</st></span></p>
			<pre class="source-code"><st c="23900">
var body: some Scene {
        WindowGroup {
            ContentView()
        }
</st><strong class="bold"><st c="23954">        .modelContainer(container)</st></strong><st c="23980">
    }</st></pre>			<p><st c="23982">In our code example, we add the </st><strong class="source-inline"><st c="24014">modelContainer</st></strong><st c="24028"> modifier to our </st><strong class="source-inline"><st c="24045">WindowGroup</st></strong><st c="24056">, thus making it available to the </st><span class="No-Break"><st c="24090">whole app.</st></span></p>
			<p><st c="24100">Instead of creating a connector and connecting it to </st><strong class="source-inline"><st c="24154">WindowGroup</st></strong><st c="24165">, we can use another </st><strong class="source-inline"><st c="24186">modeContainer</st></strong> <strong class="source-inline"><st c="24199">init</st></strong><st c="24204"> method and pass only the list </st><span class="No-Break"><st c="24235">of entities:</st></span></p>
			<pre class="source-code"><st c="24247">
.modelContainer(for: [Book.self, Author.self, Page.self])</st></pre>			<p><st c="24304">Passing the list of entities can be a simple and easy way of setting up a container. </st><st c="24390">So, why do we need the </st><strong class="source-inline"><st c="24413">ModelContainer</st></strong><st c="24427"> class? </st><st c="24435">The simple answer is, as always, to provide more customization. </st><st c="24499">Let’s </st><span class="No-Break"><st c="24505">see how!</st></span></p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor069"/><st c="24513">Working with ModelConfiguration</st></h2>
			<p><st c="24545">The </st><strong class="source-inline"><st c="24550">ModelContainer</st></strong><st c="24564"> offers us more than just scheme passing; it empowers us to configure our </st><strong class="source-inline"><st c="24638">SwiftData</st></strong><st c="24647"> store for specific models and customize it to our </st><span class="No-Break"><st c="24698">particular requirements.</st></span></p>
			<p><st c="24722">To do </st><a id="_idIndexMarker071"/><st c="24729">that, we will use the </st><strong class="source-inline"><st c="24751">ModelConfiguration</st></strong><st c="24769"> struct, </st><span class="No-Break"><st c="24778">as follows:</st></span></p>
			<pre class="source-code"><st c="24789">
var modelContainer: ModelContainer = {
        do {
            let schema = Schema([Book.self, Author.self,
              Page.self])
            </st><strong class="bold"><st c="24891">let modelConfiguration =</st></strong>
<strong class="bold"><st c="24915">              ModelConfiguration(schema: schema,</st></strong>
<strong class="bold"><st c="24950">                isStoredInMemoryOnly: true)</st></strong><st c="24978">
            return try ModelContainer(for: schema,
              </st><strong class="bold"><st c="25018">configurations: [modelConfiguration]</st></strong><st c="25054">)
        } catch {
            fatalError("Could not create ModelContainer:
              \(error)")
        }
    }()</st></pre>			<p><st c="25128">Let’s try to understand what is happening in this code snippet. </st><st c="25193">First, we create a schema with a list of our models. </st><st c="25246">Then, we declare a model configuration struct, pass the schema, and set its backend store to in-memory. </st><st c="25350">Finally, we return a model container based on our schema and a set containing the configuration we </st><span class="No-Break"><st c="25449">just created.</st></span></p>
			<p><st c="25462">All this process feels a little bit awkward, clumsy, and redundant – why do we need to create a configuration if we’re passing the same schema again? </st><st c="25613">And why is it a set? </st><st c="25634">The main configuration idea is to provide different behavior for a different set </st><span class="No-Break"><st c="25715">of models.</st></span></p>
			<p><st c="25725">Here’s an example. </st><st c="25745">Imagine we have a brainstorm sketch app. </st><st c="25786">We want to sketch and store our concepts in the app’s persistent storage while all drawings on the whiteboard canvas remain </st><span class="No-Break"><st c="25910">in memory.</st></span></p>
			<p><st c="25920">In this case, we can </st><a id="_idIndexMarker072"/><st c="25942">create two configurations, one for in-memory and one for </st><a id="_idIndexMarker073"/><st c="25999">persistent storage and </st><span class="No-Break"><strong class="bold"><st c="26022">CloudKit</st></strong></span><span class="No-Break"><st c="26030"> integration:</st></span></p>
			<pre class="source-code"><st c="26043">
var modelContainer: ModelContainer = {
      do {
          let </st><strong class="bold"><st c="26092">brainstormDataConfiguration</st></strong><st c="26119"> =
            ModelConfiguration("brainstorm_configuration",
            schema: schemaForBrainstorm,
            isStoredInMemoryOnly: true)
          let </st><strong class="bold"><st c="26230">projectsDataConfiguration</st></strong><st c="26255"> =
            ModelConfiguration("projects_configuration",
            schema: schemaForProjects,
            cloudKitDatabase: .automatic)
          return try ModelContainer(for: fullSchema,
            configurations: [</st><strong class="bold"><st c="26420">brainstormDataConfiguration,</st></strong>
<strong class="bold"><st c="26449">            projectsDataConfiguration</st></strong><st c="26475">])
        } catch {
            fatalError("Could not create ModelContainer:
              \(error)")
        }
    }()</st></pre>			<p><st c="26550">In our example, we created two different schemas – a list of models for brainstorming and a list of models for the </st><span class="No-Break"><st c="26666">user projects.</st></span></p>
			<p><st c="26680">Based on these models, we create two different configurations. </st><st c="26744">The idea brainstorming configuration is saved in memory, and the projects’ configuration is saved locally and syncs </st><span class="No-Break"><st c="26860">to CloudKit.</st></span></p>
			<p><st c="26872">Working with two different configurations and schemas for two app features is a great example of model configuration usage. </st><st c="26997">We can use the model configuration for additional customization, such as </st><span class="No-Break"><st c="27070">the following:</st></span></p>
			<ul>
				<li><st c="27084">Different </st><span class="No-Break"><st c="27095">store files</st></span></li>
				<li><st c="27106">Different </st><span class="No-Break"><st c="27117">group containers</st></span></li>
				<li><st c="27133">Different </st><span class="No-Break"><st c="27144">auto-saving mechanisms</st></span></li>
			</ul>
			<p><st c="27166">However, let’s suppose we don’t need the model configuration to configure different behavior </st><a id="_idIndexMarker074"/><st c="27260">for different groups of models. </st><st c="27292">In that case, we can work directly with the model container and initiate it with the </st><span class="No-Break"><st c="27377">entire schema.</st></span></p>
			<p><st c="27391">We now know how to declare and group our models for a schema to be used in a model container. </st><st c="27486">But there’s one crucial thing missing – how to insert, update, and fetch data. </st><st c="27565">We will</st><a id="_idTextAnchor070"/><a id="_idTextAnchor071"/><st c="27572"> do that by placing the missing piece in the puzzle – </st><span class="No-Break"><st c="27626">the context.</st></span></p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor072"/><st c="27638">Fetching and manipulating our data using model context</st></h1>
			<p><st c="27693">Developers familiar with Core Data are also familiar with the idea of </st><strong class="bold"><st c="27764">context</st></strong><st c="27771">. Context is our data </st><a id="_idIndexMarker075"/><st c="27793">sandbox. </st><st c="27802">This is the place where we can manipulate </st><a id="_idIndexMarker076"/><st c="27844">and fetch data, and it’s the link </st><a id="_idIndexMarker077"/><st c="27878">between our models and the </st><span class="No-Break"><st c="27905">persistent store.</st></span></p>
			<p><st c="27922">To gain </st><a id="_idIndexMarker078"/><st c="27931">access to our context from our SwiftUI view, we can use an environment variable </st><span class="No-Break"><st c="28011">named </st></span><span class="No-Break"><strong class="source-inline"><st c="28017">modelContext</st></strong></span><span class="No-Break"><st c="28029">:</st></span></p>
			<pre class="source-code"><st c="28031">
struct ContentView: View {
    </st><strong class="bold"><st c="28059">@Environment(\.modelContext)</st></strong><st c="28087"> private var modelContext
}</st></pre>			<p><st c="28114">The </st><strong class="source-inline"><st c="28119">modelContext</st></strong><st c="28131"> environment variable is available whenever we set up our scene using the </st><span class="No-Break"><strong class="source-inline"><st c="28205">modelContainer</st></strong></span><span class="No-Break"><st c="28219"> modifier.</st></span></p>
			<p><st c="28229">In non-SwiftUI </st><a id="_idIndexMarker079"/><st c="28245">instances, we can access the </st><a id="_idIndexMarker080"/><st c="28274">context using our model container </st><span class="No-Break"><strong class="source-inline"><st c="28308">mainContext</st></strong></span><span class="No-Break"><st c="28319"> property:</st></span></p>
			<pre class="source-code"><st c="28329">
let modelContext = modelContainer.mainContext</st></pre>			<p><st c="28375">To understand </st><a id="_idIndexMarker081"/><st c="28390">how to work with a model context, we’ll </st><a id="_idIndexMarker082"/><st c="28430">start with the most basic operation, saving new objects for </st><span class="No-Break"><st c="28490">our store.</st></span></p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor073"/><st c="28500">Saving new objects</st></h2>
			<p><st c="28519">At the beginning of this chapter, in the </st><em class="italic"><st c="28561">Defining a SwiftData model</st></em><st c="28587"> section, we learned that our models are just Swift classes marked with a </st><strong class="source-inline"><st c="28661">@</st></strong><span class="No-Break"><strong class="source-inline"><st c="28662">Model</st></strong></span><span class="No-Break"><st c="28667"> macro.</st></span></p>
			<p><st c="28674">The way we </st><a id="_idIndexMarker083"/><st c="28686">define a model in SwiftData also means that the creation of a new instance is straightforward </st><span class="No-Break"><st c="28780">for us:</st></span></p>
			<pre class="source-code"><st c="28787">
let newBook = Book(name: "Mastering iOS 18 – the future")</st></pre>			<p><st c="28845">Our next step is adding that book instance to </st><span class="No-Break"><st c="28892">our context:</st></span></p>
			<pre class="source-code"><st c="28904">
modelContext.insert(newBook)</st></pre>			<p><st c="28933">Adding </st><strong class="source-inline"><st c="28941">newBook</st></strong><st c="28948"> to the model context doesn’t necessarily mean it is being saved to our persistent store, but it does mean that it is in our context and is ready to be pushed forward to our store. </st><st c="29129">Having our entity in our context helps us manage the interaction between our app and the underlying persistent store. </st><st c="29247">In our context, we can make changes, adding and deleting information without actually saving these actions to our data store. </st><st c="29373">The context is beneficial when working with concurrency operations or when we want to manage </st><span class="No-Break"><st c="29466">undo operations.</st></span></p>
			<p><st c="29482">To actually save to the persistent store, we can use the context </st><span class="No-Break"><strong class="source-inline"><st c="29548">save()</st></strong></span><span class="No-Break"><st c="29554"> method:</st></span></p>
			<pre class="source-code"><st c="29562">
try? </st><st c="29568">modelContext.</st><strong class="bold"><st c="29581">save()</st></strong></pre>			<p><st c="29588">The </st><strong class="source-inline"><st c="29593">save()</st></strong><st c="29599"> method pushes changes to the store for each model, according to </st><span class="No-Break"><st c="29664">its configuration.</st></span></p>
			<p><st c="29682">The way the </st><strong class="source-inline"><st c="29695">save()</st></strong><st c="29701"> method works resembles how Core Data works. </st><st c="29746">But there’s one difference here. </st><st c="29779">SwiftData allows us to have an </st><em class="italic"><st c="29810">auto-save</st></em><st c="29819"> feature for the </st><span class="No-Break"><st c="29836">model container:</st></span></p>
			<pre class="source-code"><st c="29852">
var body: some Scene {
        WindowGroup {
            ContentView()
        }
        .modelContainer(for: Book.self, </st><strong class="bold"><st c="29938">isAutosaveEnabled:</st></strong>
<strong class="bold"><st c="29956">          false</st></strong><st c="29962">)
    }</st></pre>			<p><st c="29966">In our code </st><a id="_idIndexMarker084"/><st c="29979">example, we set the </st><strong class="source-inline"><st c="29999">isAutosaveEnabled</st></strong><st c="30016"> parameter to </st><strong class="source-inline"><st c="30030">false</st></strong><st c="30035">. By default, SwiftData auto-saves every change we make to the persistent store, so there’s no need to call the </st><strong class="source-inline"><st c="30147">save()</st></strong><st c="30153"> function unless you have a </st><span class="No-Break"><st c="30181">perfect reason.</st></span></p>
			<p><st c="30196">Due to performance considerations, SwiftData doesn’t save every single time we perform a change to the context but, rather, in the following </st><span class="No-Break"><st c="30338">two situations:</st></span></p>
			<ul>
				<li><st c="30353">During the app life cycle – for example, when moving from the foreground to </st><span class="No-Break"><st c="30430">the background</st></span></li>
				<li><st c="30444">In a certain time period after we perform </st><span class="No-Break"><st c="30487">the change</st></span></li>
			</ul>
			<p><st c="30497">Now that we know how to create and insert new objects, we can move on </st><span class="No-Break"><st c="30568">to fetching.</st></span></p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor074"/><st c="30580">Fetching objects</st></h2>
			<p><st c="30597">Fetching objects in SwiftData is slightly different than what we know from Core Data, as there are </st><a id="_idIndexMarker085"/><st c="30697">two primary ways to </st><span class="No-Break"><st c="30717">retrieve data.</st></span></p>
			<p><st c="30731">The first way </st><a id="_idIndexMarker086"/><st c="30746">is to fetch an object, or objects, </st><em class="italic"><st c="30781">based on a predicate</st></em><st c="30801"> as part of an app flow – for example, fetching objects to sync with the server or to make some kind </st><span class="No-Break"><st c="30902">of calculation.</st></span></p>
			<p><st c="30917">The second way is to fetch objects </st><em class="italic"><st c="30953">based on a query</st></em><st c="30969"> and bind them to the SwiftUI view. </st><st c="31005">An example would be when we want to bind a collection of objects to </st><span class="No-Break"><st c="31073">a list.</st></span></p>
			<p><st c="31080">Let’s go over both ways and explore new structures and macros that SwiftData brings to </st><span class="No-Break"><st c="31168">our project.</st></span></p>
			<h3><st c="31180">Fetching objects using FetchDescriptor</st></h3>
			<p><strong class="source-inline"><st c="31219">FetchDescriptor</st></strong><st c="31235"> is a struct equivalent to </st><strong class="source-inline"><st c="31262">NSFetchRequest</st></strong><st c="31276"> in </st><span class="No-Break"><st c="31280">Core Data.</st></span></p>
			<p><st c="31290">Like </st><strong class="source-inline"><st c="31296">NSFetchRequest</st></strong><st c="31310">, </st><strong class="source-inline"><st c="31312">FetchDescriptor</st></strong><st c="31327"> also works with a specific type of object; to use it, we can pass an optional predicate and </st><span class="No-Break"><st c="31420">sort descriptor.</st></span></p>
			<p><st c="31436">Here’s </st><a id="_idIndexMarker087"/><st c="31444">an example of how to </st><span class="No-Break"><st c="31465">use </st></span><span class="No-Break"><strong class="source-inline"><st c="31469">FetchDescriptor</st></strong></span><span class="No-Break"><st c="31484">:</st></span></p>
			<pre class="source-code"><st c="31486">
let fetchDesciprtor = </st><strong class="bold"><st c="31509">FetchDescriptor</st></strong><st c="31524">&lt;Book&gt;(predicate:
  #Predicate { $0.name == "My Book"})
        let book = try?
          </st><st c="31595">modelContext.fetch(fetchDesciprtor).first</st></pre>			<p><st c="31636">If you look closely, you can see that </st><strong class="source-inline"><st c="31675">FetchDescriptor</st></strong><st c="31690"> is not the only new type we encounter in this context, as we also have a new </st><strong class="source-inline"><st c="31768">Predicate</st></strong><st c="31777"> macro that creates </st><strong class="source-inline"><st c="31797">PredicateExpression</st></strong><st c="31816"> (a new type in </st><span class="No-Break"><st c="31832">iOS 17).</st></span></p>
			<p><st c="31840">Unlike the familiar </st><strong class="source-inline"><st c="31861">NSPredicate</st></strong><st c="31872">, the </st><strong class="source-inline"><st c="31878">Predicate</st></strong><st c="31887"> macro works a little bit differently. </st><st c="31926">Instead of creating a query, we have a closure where we define the condition of the return instances, like the array </st><span class="No-Break"><st c="32043">filter method.</st></span></p>
			<p><st c="32057">The following example returns books with more than </st><span class="No-Break"><st c="32109">10 pages:</st></span></p>
			<pre class="source-code"><st c="32118">
let fetchDesciprtor = FetchDescriptor&lt;Book&gt;(predicate:
  #Predicate { book in
            return book.pages.count &gt; 10
        })</st></pre>			<p><st c="32226">Using the </st><strong class="source-inline"><st c="32237">#Predicate</st></strong><st c="32247"> macro is simple and doesn’t require us to use a special syntax to perform </st><span class="No-Break"><st c="32322">complex queries.</st></span></p>
			<p><st c="32338">In most cases, we won’t have to use </st><strong class="source-inline"><st c="32375">FetchDescriptor</st></strong><st c="32390">. If we want to connect data to our SwiftUI views, SwiftData has a better solution – the </st><strong class="source-inline"><st c="32479">@</st></strong><span class="No-Break"><strong class="source-inline"><st c="32480">Query</st></strong></span><span class="No-Break"><st c="32485"> macro.</st></span></p>
			<h3><st c="32492">Conn</st><a id="_idTextAnchor075"/><a id="_idTextAnchor076"/><st c="32497">ecting data to a view using the @Query macro</st></h3>
			<p><st c="32542">Data is there to be seen. </st><st c="32569">Showing information to the user is perhaps the most common task </st><a id="_idIndexMarker088"/><st c="32633">for iOS developers, and SwiftData’s </st><a id="_idIndexMarker089"/><st c="32669">goal is just to </st><span class="No-Break"><st c="32685">simplify that.</st></span></p>
			<p><st c="32699">As part </st><a id="_idIndexMarker090"/><st c="32708">of the SwiftData package, we now have an </st><strong class="source-inline"><st c="32749">@Query</st></strong><st c="32755"> macro that helps us present information in </st><span class="No-Break"><st c="32799">SwiftUI views:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="32813">@Query private var books: [Book]</st></strong><st c="32846">
var body: some View {
List {
        ForEach(books) { book in
            Text(book.name)
        }
    }
}</st></pre>			<p><st c="32922">This example displays a simple list of </st><strong class="source-inline"><st c="32962">Book</st></strong><st c="32966"> items based on the </st><strong class="source-inline"><st c="32986">books</st></strong><st c="32991"> variable. </st><st c="33002">The </st><strong class="source-inline"><st c="33006">@Query</st></strong><st c="33012"> macro before the variable declaration makes the variable a state of the view, ensuring that data is constantly updated. </st><st c="33133">This means that we get an instant UI update whenever we insert a new book into our </st><span class="No-Break"><st c="33216">persistent store.</st></span></p>
			<p><st c="33233">This is pretty remarkable for just one </st><span class="No-Break"><st c="33273">additional word!</st></span></p>
			<p><st c="33289">The </st><strong class="source-inline"><st c="33294">@Query</st></strong><st c="33300"> macro also has two important additional features – filter </st><span class="No-Break"><st c="33359">and sorting.</st></span></p>
			<h4><st c="33371">Filtering the query</st></h4>
			<p><st c="33391">The chances </st><a id="_idIndexMarker091"/><st c="33404">that we will fetch </st><em class="italic"><st c="33423">all</st></em><st c="33426"> the items of a particular entity are pretty low, and the previous example of fetching all the books and presenting them is more common in tutorials and </st><span class="No-Break"><st c="33579">demo presentations.</st></span></p>
			<p><st c="33598">In real life, we want to filter our queries. </st><st c="33644">To do that, we can use </st><strong class="source-inline"><st c="33667">#Predicate</st></strong><st c="33677">, which we learned about in the </st><em class="italic"><st c="33709">Fetching objects using </st></em><span class="No-Break"><em class="italic"><st c="33732">FetchDescriptor</st></em></span><span class="No-Break"><st c="33747"> section:</st></span></p>
			<pre class="source-code"><st c="33756">
@Query(</st><strong class="bold"><st c="33764">filter: #Predicate&lt;Book&gt; {</st></strong>
<strong class="bold"><st c="33791">        $0.pages.count &gt; 300</st></strong>
<strong class="bold"><st c="33812">    })</st></strong><st c="33815"> private var bigBooks: [Book]</st></pre>			<p><st c="33844">In this example, we added a filter to our </st><strong class="source-inline"><st c="33887">@Query</st></strong><st c="33893"> that returns only books that contain more than </st><span class="No-Break"><st c="33941">300 pages.</st></span></p>
			<p><st c="33951">Of course, we can perform even more complex queries by upgrading our Swift expression inside </st><span class="No-Break"><st c="34045">the predicate:</st></span></p>
			<pre class="source-code"><st c="34059">
@Query(filter: </st><strong class="bold"><st c="34075">#Predicate&lt;Book&gt; {</st></strong>
<strong class="bold"><st c="34093">        $0.pages.count &gt; 300 &amp;&amp; (!$0.isRead ||</st></strong>
<strong class="bold"><st c="34132">          $0.isFavorite)</st></strong><st c="34147">
    }) private var bigBooks: [Book]</st></pre>			<p><st c="34179">In this example, we filter books that contain more than 300 pages, but this time, we also want to </st><a id="_idIndexMarker092"/><st c="34278">receive books that we haven’t read or are marked as favorites. </st><st c="34341">The fact that we use a Swift expression to filter our results makes our queries more descriptive and powerful </st><span class="No-Break"><st c="34451">than </st></span><span class="No-Break"><strong class="source-inline"><st c="34456">NSPredicate</st></strong></span><span class="No-Break"><st c="34467">.</st></span></p>
			<p><st c="34468">However, when displaying data in a list, it is not enough to filter it; it is also crucial to sort it. </st><st c="34572">That’s the job of our second main </st><strong class="source-inline"><st c="34606">@</st></strong><span class="No-Break"><strong class="source-inline"><st c="34607">Query</st></strong></span><span class="No-Break"><st c="34612"> feature.</st></span></p>
			<h4><st c="34621">Sorting the data</st></h4>
			<p><st c="34638">Sorting is an essential aspect of presenting information to our users. </st><st c="34710">We should remember </st><a id="_idIndexMarker093"/><st c="34729">that sorting is not a lightweight task; it requires a complex algorithm to be </st><span class="No-Break"><st c="34807">done efficiently.</st></span></p>
			<p><st c="34824">That’s why we need to ensure that we can sort by a property whose type conforms to the </st><strong class="source-inline"><st c="34912">SortComparator</st></strong><st c="34926"> protocol, introduced as part of </st><span class="No-Break"><st c="34959">iOS 15.</st></span></p>
			<p><st c="34966">Let’s see how we can sort our </st><span class="No-Break"><st c="34997">filtered books:</st></span></p>
			<pre class="source-code"><st c="35012">
@Query(filter: #Predicate&lt;Book&gt; {
        $0.pages.count &gt; 300
    }, </st><strong class="bold"><st c="35071">sort: [SortDescriptor(\Book.name),</st></strong>
<strong class="bold"><st c="35105">         SortDescriptor(\Book.pages.count)]</st></strong><st c="35140">) private var
         big</st><a id="_idTextAnchor077"/><a id="_idTextAnchor078"/><a id="_idTextAnchor079"/><a id="_idTextAnchor080"/><st c="35158">Books: [Book]</st></pre>			<p><st c="35172">In this example, we pass an array of </st><strong class="source-inline"><st c="35210">SortDescriptor</st></strong><st c="35224"> – we first sort by the book name and then by its number of pages. </st><st c="35291">It’s pretty easy to use </st><strong class="source-inline"><st c="35315">SortDescriptor</st></strong><st c="35329"> – we initialize it using a key path to the desired property, just like in the </st><span class="No-Break"><st c="35408">preceding example.</st></span></p>
			<p><st c="35426">Performing sorting with SwiftData is extremely simple. </st><st c="35482">However, under the hood, it requires </st><a id="_idIndexMarker094"/><st c="35519">running algorithms that must be optimized for performance in order to work efficiently. </st><st c="35607">We don’t need these optimizations when working with 100 or 200 records. </st><st c="35679">However, there are cases when our data store contains thousands of records. </st><st c="35755">For these cases, we need to index </st><span class="No-Break"><st c="35789">our data.</st></span></p>
			<h3><st c="35798">Adding the #Index macro for performance</st></h3>
			<p><st c="35838">Before we index our data, let’s try to understand what it means exactly. </st><st c="35912">When performing </st><a id="_idIndexMarker095"/><st c="35928">read operations such as sorting or querying, we expect our app to work seamlessly with thousands of records. </st><st c="36037">Obviously, performing a full-table scan to find a book named </st><em class="italic"><st c="36098">Mastering iOS 18</st></em><st c="36114"> is inefficient. </st><st c="36131">So, what do we do? </st><st c="36150">Like a book index, the database index contains keys that help it locate a specific record. </st><st c="36241">For example, if we want to index our book’s </st><strong class="source-inline"><st c="36285">name</st></strong><st c="36289"> property, we can create a data structure, such as a B-tree, which can help us locate the exact instance according to </st><span class="No-Break"><st c="36407">its name.</st></span></p>
			<p><st c="36416">In SwiftData, we don’t need to create any structure to index our data. </st><st c="36488">All we need to do is add the </st><strong class="source-inline"><st c="36517">#Index</st></strong><st c="36523"> macro to </st><span class="No-Break"><st c="36533">our model:</st></span></p>
			<pre class="source-code"><st c="36543">
@Model
class Book {
</st><strong class="bold"><st c="36564">    #Index&lt;Book&gt;([\.name], [\.name, \.publicationName])</st></strong><st c="36615">
    var publicationName: String = "Packt"
    var name: String
}</st></pre>			<p><st c="36672">If the preceding code looks familiar, that’s because we did something similar when we added the </st><strong class="source-inline"><st c="36769">#Unique</st></strong><st c="36776"> macro to our model in the </st><em class="italic"><st c="36803">Adding the @Attribute </st></em><span class="No-Break"><em class="italic"><st c="36825">macro</st></em></span><span class="No-Break"><st c="36830"> section.</st></span></p>
			<p><st c="36839">In this case, we decided to add two indexes to </st><span class="No-Break"><st c="36887">our model:</st></span></p>
			<ul>
				<li><st c="36897">The first is to index the name property, allowing an app to sort records by name or query data for a specific </st><span class="No-Break"><st c="37008">book name.</st></span></li>
				<li><st c="37018">The second index is based on the combination of the </st><strong class="source-inline"><st c="37071">name</st></strong><st c="37075"> and </st><span class="No-Break"><strong class="source-inline"><st c="37080">publicationName</st></strong></span><span class="No-Break"><st c="37095"> properties</st></span></li>
			</ul>
			<p><st c="37106">If you remember from the </st><em class="italic"><st c="37132">Adding the @Attribute macro</st></em><st c="37159"> section, we decided that this combination defines our book’s uniqueness. </st><st c="37233">Creating an index for this combination can help us quickly find a specific book </st><span class="No-Break"><st c="37313">when needed.</st></span></p>
			<p><st c="37325">Indexing looks like magic – we add another key path to the list of indexes, and everything works faster. </st><st c="37431">So, why not do that for all properties? </st><st c="37471">What’s </st><span class="No-Break"><st c="37478">the catch?</st></span></p>
			<p><st c="37488">It’s because </st><a id="_idIndexMarker096"/><st c="37502">indexing comes with a price. </st><st c="37531">First, we need to duplicate some of our data. </st><st c="37577">If we need to index the name property, we need to create a structure that contains all the names. </st><st c="37675">This results in additional storage for our app. </st><st c="37723">But adding an index doesn’t stop with storage – it also affects performance. </st><st c="37800">Indexing is not a one-time operation, as it requires maintenance. </st><st c="37866">Each </st><strong class="source-inline"><st c="37871">insert</st></strong><st c="37877">, </st><strong class="source-inline"><st c="37879">update</st></strong><st c="37885">, or </st><strong class="source-inline"><st c="37890">delete</st></strong><st c="37896"> operation requires SwiftData to maintain the index structure, impacting the </st><span class="No-Break"><st c="37973">operation performance.</st></span></p>
			<p><st c="37995">In summary, indexing is a great SwiftData feature. </st><st c="38047">However, use it carefully and balance its benefits with </st><span class="No-Break"><st c="38103">its costs.</st></span></p>
			<p><st c="38113">We’ve learned so many things so far! </st><st c="38151">We’ve learned how to define models, create instances, fetch them, and connect them to </st><span class="No-Break"><st c="38237">the UI.</st></span></p>
			<p><st c="38244">But we know that m</st><a id="_idTextAnchor081"/><a id="_idTextAnchor082"/><st c="38263">aintaining a persistent store is much more than that. </st><st c="38318">Our first app version is so much different than our 50th version, and it also means that our data schema will change during our app version’s life cycle. </st><st c="38472">But what should we do once we already have a store full of data? </st><st c="38537">That’s our next topic – how to perform </st><span class="No-Break"><st c="38576">data migration.</st></span></p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor083"/><st c="38591">Migrating our data to a new schema</st></h1>
			<p><st c="38626">Data migration is not a weird expression for those who have worked with Core Data. </st><st c="38710">It is obvious </st><a id="_idIndexMarker097"/><st c="38724">that we need to change our schema as our </st><span class="No-Break"><st c="38765">app evolves.</st></span></p>
			<p><st c="38777">There are two types of migrations – </st><em class="italic"><st c="38814">lightweight</st></em><st c="38825"> and </st><em class="italic"><st c="38830">custom</st></em><st c="38836"> migration. </st><st c="38848">With lightweight migration, we perform changes that don’t require custom logic. </st><st c="38928">For example, adding an entity, a property, and a relationship are all good examples of lightweight migration. </st><st c="39038">Conversely, changing a property type, making a property unique, and creating a new property based on other properties are examples of custom migrations. </st><st c="39191">Now that we know what migration types we have, it’s important to understand when it is relevant to perform </st><span class="No-Break"><st c="39298">a migration.</st></span></p>
			<p><st c="39310">When we’re in our development stage, migration is unnecessary before we have an official version of our app on the App Store. </st><st c="39437">We only need to perform migration when an end user holds </st><a id="_idIndexMarker098"/><st c="39494">a version with an older schema. </st><st c="39526">This also means that if we perform schema changes in several versions, we must ensure that SwiftData knows how to migrate throughout all </st><span class="No-Break"><st c="39663">these versions.</st></span></p>
			<p><st c="39678">Now, let’s discuss how SwiftData migration works and what the essential migration </st><span class="No-Break"><st c="39761">components are.</st></span></p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor084"/><st c="39776">Learning the basic migration process</st></h2>
			<p><st c="39813">A SwiftData </st><a id="_idIndexMarker099"/><st c="39826">migration has three </st><span class="No-Break"><st c="39846">main components:</st></span></p>
			<ul>
				<li><strong class="source-inline"><st c="39862">VersiondSchema</st></strong><st c="39877">: Describes a specific </st><span class="No-Break"><st c="39901">schema version</st></span></li>
				<li><strong class="source-inline"><st c="39915">MigrationStage</st></strong><st c="39930">: Describes the migration process between two versions of the </st><span class="No-Break"><st c="39993">same schema</st></span></li>
				<li><strong class="source-inline"><st c="40004">SchemaMigrationPlan</st></strong><st c="40024">: Describes how the schema migration stages are based on the </st><span class="No-Break"><st c="40086">migration stages</st></span></li>
			</ul>
			<p><st c="40102">Let’s try to describe how everything is connected, using </st><span class="No-Break"><em class="italic"><st c="40160">Figure 2</st></em></span><span class="No-Break"><em class="italic"><st c="40168">.2</st></em></span><span class="No-Break"><st c="40170">:</st></span></p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/B21795_02_2.jpg" alt="Figure 2.2: A migration process between three different versions"/><st c="40172"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="40295">Figure 2.2: A migration process between three different versions</st></p>
			<p><span class="No-Break"><em class="italic"><st c="40359">Figure 2</st></em></span><em class="italic"><st c="40368">.2</st></em><st c="40370"> shows three different version schemas for three different versions. </st><st c="40439">We create a migration </st><a id="_idIndexMarker100"/><st c="40461">stage each time we migrate the app from one version to another. </st><st c="40525">Once we have the various stages, we can wrap them into one big </st><span class="No-Break"><st c="40588">migration plan.</st></span></p>
			<p><st c="40603">Returning to our book’s app, let’s try to migrate our schema to support a </st><strong class="source-inline"><st c="40678">subtitle</st></strong><st c="40686"> for our </st><span class="No-Break"><strong class="source-inline"><st c="40695">Book</st></strong></span><span class="No-Break"><st c="40699"> entity.</st></span></p>
			<p><st c="40707">First, we need to create our </st><span class="No-Break"><st c="40737">version schemas.</st></span></p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor085"/><st c="40753">Creating a version schema</st></h2>
			<p><st c="40779">To migrate </st><a id="_idIndexMarker101"/><st c="40791">our book to a new schema, we need to create two version schemas – the first is our current schema, and the second is the </st><span class="No-Break"><st c="40912">destination schema:</st></span></p>
			<pre class="source-code"><st c="40931">
enum BookSchemaV1: VersionedSchema {
    static var versionIdentifier: Schema.Version
    { return .init(1, 0, 0) }
    static var models: [any PersistentModel.Type] {
        [Book.self]
    }
    @Model class Book {
        var name: String
        init(name: String) {
            self.name = name
        }
    }
}
enum BookSchemaV2: VersionedSchema {
    static var versionIdentifier: Schema.Version
    {return .init(1, 1, 0) }
    static var models: [any PersistentModel.Type] {
        [</st><a id="_idTextAnchor086"/><a id="_idTextAnchor087"/><st c="41339">Book.self]
    }
    @Model class Book {
</st><strong class="bold"><st c="41373">        var subtitle: String = ""</st></strong><st c="41398">
        var name: String
        init(subtitle: String, name: String) {
</st><strong class="bold"><st c="41455">            self.subtitle = subtitle</st></strong><st c="41479">
            self.name = name
        }
    }
}</st></pre>			<p><st c="41502">In this code, we created two enums that conform to the </st><strong class="source-inline"><st c="41558">VersionedSchema</st></strong><st c="41573"> protocol. </st><st c="41584">As part of </st><a id="_idIndexMarker102"/><st c="41595">the protocol definition, we need to define the version identifier and what models </st><span class="No-Break"><st c="41677">will change.</st></span></p>
			<p><st c="41689">We added a new </st><strong class="source-inline"><st c="41705">subtitle</st></strong><st c="41713"> property to the second version in this case. </st><st c="41759">We need to update the schema we use across the app, with the new </st><span class="No-Break"><st c="41824">property included.</st></span></p>
			<p><st c="41842">Our next step is to define the different stages and the </st><span class="No-Break"><st c="41899">migration plan.</st></span></p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor088"/><st c="41914">Creating the migration stages and plan</st></h2>
			<p><st c="41953">We should </st><a id="_idIndexMarker103"/><st c="41964">consider the versioned schemas as the building blocks of our migration process. </st><span class="No-Break"><em class="italic"><st c="42044">Figure 2</st></em></span><em class="italic"><st c="42052">.2</st></em><st c="42054"> shows that we create the migration stages based on the </st><span class="No-Break"><st c="42110">versioned schemas.</st></span></p>
			<p><st c="42128">Here’s an example of a </st><span class="No-Break"><st c="42152">migration stage:</st></span></p>
			<pre class="source-code"><st c="42168">
static let migrateV1toV2 =
  </st><strong class="bold"><st c="42196">MigrationStage.lightweight</st></strong><st c="42222">(fromVersion:
  BookSchemaV1.self, toVersion: BookSchemaV2.self)</st></pre>			<p><st c="42285">The </st><strong class="source-inline"><st c="42290">migrateV1toV2</st></strong><st c="42303"> stage handles the migration from </st><strong class="source-inline"><st c="42337">BookSchemaV1</st></strong><st c="42349"> to </st><strong class="source-inline"><st c="42353">BookSchemaV2</st></strong><st c="42365">. Note that this is a lightweight migration – we only added a property, so this is all that we need to create </st><span class="No-Break"><st c="42475">the stage.</st></span></p>
			<p><st c="42485">What about a custom migration? </st><st c="42517">With a custom migration, we need to provide a closure that handles data before and after the migration stage, where we perform all the </st><span class="No-Break"><st c="42652">required changes.</st></span></p>
			<p><st c="42669">Here’s an example of a custom transition from version V2 to V3, where we have removed the subtitle property and added it as part of the </st><span class="No-Break"><st c="42806">book name:</st></span></p>
			<pre class="source-code"><st c="42816">
static let migrateV2toV3 =
  </st><strong class="bold"><st c="42844">MigrationStage.custom</st></strong><st c="42865">(fromVersion: BookSchemaV2.self,
  toVersion: BookSchemaV3.self, </st><strong class="bold"><st c="42929">willMigrate</st></strong><st c="42940">: { context in
        if let books = try?
          </st><st c="42976">context.fetch(FetchDescriptor&lt;Boo</st><a id="_idTextAnchor089"/><a id="_idTextAnchor090"/><st c="43009">k&gt;()) {
            for book in books {
                let newName = book.name + " " +
                  book.subtitle
book.name = newName
            }
        }
        try? </st><st c="43113">context.save()
    }, didMigrate: nil)</st></pre>			<p><st c="43147">As we can </st><a id="_idIndexMarker104"/><st c="43158">see in the code example, our </st><strong class="source-inline"><st c="43187">willMigrate</st></strong><st c="43198"> closure receives a context to work with, and SwiftData performs that closure </st><span class="No-Break"><st c="43276">when needed.</st></span></p>
			<p><st c="43288">We fetch all the books and assemble a new name from the book name and its subtitle property. </st><st c="43382">At the end of the closure code, we </st><span class="No-Break"><st c="43417">call </st></span><span class="No-Break"><strong class="source-inline"><st c="43422">context.save()</st></strong></span><span class="No-Break"><st c="43436">.</st></span></p>
			<p><st c="43437">Now that we have both migration steps, we can create our </st><span class="No-Break"><st c="43495">migration plan:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="43510">enum MyMigrationPlan: SchemaMigrationPlan</st></strong><st c="43552"> {
    static var schemas: [VersionedSchema.Type] {
        [BookSchemaV1.self, BookSchemaV2.self,
          BookSchemaV3.self]
    }
    </st><strong class="bold"><st c="43660">static var stages: [MigrationStage] {</st></strong>
<strong class="bold"><st c="43697">        [migrateV1toV2, migrateV2toV3]</st></strong>
<strong class="bold"><st c="43728">    }</st></strong><st c="43730">
    static let migrateV1toV2 =
      MigrationStage.lightweight(fromVersion:
      BookSchemaV1.self, toVersion: BookSchemaV2.self)
    static let migrateV2toV3 =
      MigrationStage.custom(fromVersion: BookSchemaV2.self,
      toVersion: BookSchemaV3.self, willMigrate:{context in
        if let books = try?
          </st><st c="44002">context.fetch(FetchDescriptor&lt;Book&gt;()) {
            for book in books {
                let newName = book.name + " " +
                  book.subtitle
                book.name = newName
            }
        }
        try? </st><st c="44138">context.save()
    }, didMigrate: nil)
}</st></pre>			<p><st c="44174">The migration </st><a id="_idIndexMarker105"/><st c="44189">plan is just another Enum conforming to </st><strong class="source-inline"><st c="44229">SchemaMigrationPlan</st></strong><st c="44248">, with static variables describing the list of schemas and stages (not something we haven’t </st><span class="No-Break"><st c="44340">seen before).</st></span></p>
			<p><st c="44353">Now, we have a migration plan, but SwiftData doesn’t know what to do with it. </st><st c="44432">Our next step will be connecting the migration plan to our </st><span class="No-Break"><st c="44491">SwiftData container.</st></span></p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor091"/><st c="44511">Connecting the migration plan to our container</st></h2>
			<p><st c="44558">Connecting </st><a id="_idIndexMarker106"/><st c="44570">the migration plan to our container is perhaps the most straightforward step in </st><span class="No-Break"><st c="44650">the process.</st></span></p>
			<p><st c="44662">The </st><strong class="source-inline"><st c="44667">ModelContainer</st></strong><st c="44681"> struct has a </st><strong class="source-inline"><st c="44695">migrationPlan</st></strong><st c="44708"> property specifically for that, and we need to pass the migration plan </st><span class="No-Break"><st c="44780">Enum type:</st></span></p>
			<pre class="source-code"><st c="44790">
return try ModelContainer(for: schema, </st><strong class="bold"><st c="44830">migrationPlan:</st></strong>
<strong class="bold"><st c="44844">  MyMigrationPlan.self,</st></strong><st c="44866"> configurations:
   [modelConfiguration])</st></pre>			<p><st c="44904">Note the way that migrations work in SwiftData in terms of a language paradigm. </st><st c="44985">We don’t have to initialize anything, since we only pass the schemas, stages, and plan types. </st><st c="45079">The reason is the way SwiftUI works – since we work in an immutable environment, it is much more convenient to work with static variables and types instead </st><span class="No-Break"><st c="45235">of instances.</st></span></p>
			<p><st c="45248">Migration in SwiftData is not a simple task. </st><st c="45294">It involves conforming to multiple protocols, maintaining schema versions, and understanding how a store is built to switch between lightweight and </st><span class="No-Break"><st c="45442">custom migration.</st></span></p>
			<p><st c="45459">But this is because migration, in general, is a complex and sensitive process. </st><st c="45539">Trying to carefully plan beforehand how our schema looks can reduce the number of schema versions and stages, easing our process when considering</st><a id="_idTextAnchor092"/><a id="_idTextAnchor093"/><st c="45684"> that we will have to migrate our store at </st><span class="No-Break"><st c="45727">some point.</st></span></p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor094"/><st c="45738">Summary</st></h1>
			<p><st c="45746">SwiftData holds significance for iOS developers looking to support iOS 17 and above, representing a natural progression from Apple’s previous framework, Core Data. </st><st c="45911">Within the context of a declarative Swift environment, SwiftData aligns more seamlessly </st><span class="No-Break"><st c="45999">than before.</st></span></p>
			<p><st c="46011">In this chapter, we’ve learned about SwiftData’s background, defined the different SwiftData models, created relationships, and customized the model attributes. </st><st c="46173">We moved on to the container – a component that wraps everything together, performs fetches, and saves. </st><st c="46277">Lastly, we migrated our data from different schema versions using lightweight and custom migrations. </st><st c="46378">Throughout the chapter, we saw the heavy use of Swift macros and protocols, which are more suitable for the modern world of Swift compared </st><span class="No-Break"><st c="46517">to Objective-C.</st></span></p>
			<p><st c="46532">That’s a lot for one chapter! </st><st c="46563">Remember that the data layer is c</st><a id="_idTextAnchor095"/><a id="_idTextAnchor096"/><st c="46596">omplex to manage and maintain, and there’s much more to learn. </st><st c="46660">The data layer is one side of our project; the other side is, of course, the UI. </st><st c="46741">To complete our understanding of the data layer, it’s essential to explore how the UI can monitor changes. </st><st c="46848">This is why our forthcoming chapter will focus on the </st><span class="No-Break"><st c="46902">observation framework.</st></span></p>
		</div>
	<div id="charCountTotal" value="46924"/></body></html>