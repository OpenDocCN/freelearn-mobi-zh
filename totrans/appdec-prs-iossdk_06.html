<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Users and Roles</h1></div></div></div><p>Most of the applications these days are handling the user accounts and they help users to access their data securely. Parse provides you with the <code class="literal">PFUser</code> class specifically wrapped with all the functionality required to handle the user's data. All the applications usually contain some sort of users. With Parse and the <code class="literal">PFUser</code> class, you can easily integrate functionality for authenticating and storing data about users within your application. This class helps you to add the user account functionality in your application.</p><p>
<code class="literal">PFUser</code> inherits from PFObject, thus provides you with all the features of a standard PFObject, such as the flexible schema for data feeding, and the dictionary-based key value relationship. <code class="literal">PFUser</code> has access to all the methods of PFObject, in addition to that, <code class="literal">PFUser</code> has some additional methods which help to manage account information precisely.</p><p>In this chapter, you will learn about handling users in detail, and along with that, you will learn to provide roles to the users to limit the access to the data to all users.</p><div><div><div><div><h1 class="title"><a id="ch06lvl1sec38"/>PFUser</h1></div></div></div><p>This<a id="id148" class="indexterm"/> class allows you to manage user accounts on Parse. It has several properties that differentiate it from PFObject, which are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">username</code>: Username for the user (mandatory)</li><li class="listitem" style="list-style-type: disc"><code class="literal">password</code>: Password for the user (mandatory while signup)</li><li class="listitem" style="list-style-type: disc"><code class="literal">email</code>: E-mail ID of the user (optional)</li></ul></div><p>These properties will internally call the <code class="literal">setObject:forKey:</code> method, so you don't need to call this externally. We will explore these fields in detail in the upcoming topics.</p><p>All the <code class="literal">PFUser</code> objects will be stored in the <code class="literal">User</code> class. You can access the <code class="literal">User</code> class in your application's <strong>Data Browser</strong>. This class also allows you to add custom fields to users, such as adding the phone numbers and such relevant details.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec39"/>User login</h1></div></div></div><p>In<a id="id149" class="indexterm"/> most of the application, the first step is to have an effective login process. Parse provides you with a stable Plug and Play login setup. You can use various login processes to validate users, such as Facebook, Twitter, or the e-mail address of the user. This process is explained in detail in the following topics.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec44"/>Signing up</h2></div></div></div><p>You can<a id="id150" class="indexterm"/> use the following code to illustrate a way to allow the users to sign up using an e-mail ID and password:</p><div><pre class="programlisting">- (void)signUp {
    PFUser *user = [PFUser user];
    user.username = @"demo name";
    user.password = @"demo pass";
    user.email = @"demo@example.com";
 
    // other fields can be set just like with PFObject
    [user setObject:@"user display name" forKey:@"displayName"];
 
    [user signUpInBackgroundWithBlock:^(BOOL succeeded, NSError *error) {
      if (!error) {
          // Successfully signed up
      } else {
          NSString *errorString = [[error userInfo] objectForKey:@"error"];
          // Show the errorString somewhere and let the user try again.
      }
    }];
}</pre></div><p>The <code class="literal">signUpInBackgroundWithBlock:</code> method<a id="id151" class="indexterm"/> will asynchronously (recommended) create a new user on your Parse application. This method wraps up the basic validations, such as e-mail authentication, and uniqueness of username and e-mail ID. Parse saves all your passwords on the cloud in hashes. You can save the user's e-mail ID as its username as well.</p><p>There are various flavors of the <code class="literal">signUp</code> methods<a id="id152" class="indexterm"/>, which are available on Parse. You can access all these methods from the list of methods in the API docs.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec45"/>Verifying the user</h2></div></div></div><p>Parse<a id="id153" class="indexterm"/> also enables you to verify the e-mail ID of the user. After verification of an e-mail ID, the <code class="literal">emailVerified</code> key will be added by the <code class="literal">PFUser</code> class. This field contains false values and it updates to true as soon as the user has verified his/her e-mail address through their IDs.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec40"/>Logging in</h1></div></div></div><p>After<a id="id154" class="indexterm"/> signing up, the user will log in to his/her account for accessing the application. For allowing the user to log in to the application, you can use the <code class="literal">logInWithUsernameInBackground:password:</code> class method of the <code class="literal">PFUser</code> class:</p><div><pre class="programlisting">[PFUser logInWithUsernameInBackground:@"demoName" password:@"demopass"
  block:^(PFUser *user, NSError *error) {
    if (user) {
        // Successful login.
    } else {
        // The login failed. Check error to see why.
    }
}];</pre></div><p>After successfully login, you can access the <code class="literal">PFUser</code> object, which will hold all the user-related data.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec46"/>Saving the user's data</h2></div></div></div><p>It is<a id="id155" class="indexterm"/> cumbersome for the users of the application to log in every time they open the application. To avoid such cases, you need to save your user data using cache. Saving user's details will allow users to use the application without passing through the login process every time. The <code class="literal">PFUser</code> class provides an automatic caching policy, and the cached object is saved in the <code class="literal">currentUser</code> object:</p><div><pre class="programlisting">PFUser *currentUser = [PFUser currentUser];
if (currentUser) {
    // do stuff with the user
} else {
    // show the signup or login screen
}</pre></div><p>You can reset the current user by calling the <code class="literal">logOut</code> method<a id="id156" class="indexterm"/> on the <code class="literal">PFUser</code> class:</p><div><pre class="programlisting">[PFUser logOut];</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec47"/>Creating an anonymous user</h2></div></div></div><p>You can <a id="id157" class="indexterm"/>allow <a id="id158" class="indexterm"/>users to use your application without forcing then to log in to your application. An anonymous user can be created without a username and password, with all the features of <code class="literal">PFUser</code>. You can convert anonymous users to normal users anytime by providing them with a Facebook, Twitter, or e-mail ID login.</p><p>The following code demonstrates a way to create an anonymous user:</p><div><pre class="programlisting">[PFAnonymousUtils logInWithBlock:^(PFUser *user, NSError *error) {
    if (error) {
      NSLog(@"Anonymous login failed.");
    } else {
      NSLog(@"Anonymous user logged in.");
    }
}];</pre></div><p>All the data of an anonymous user will be inaccessible after logout. However, if the user registers itself as a normal user, all the data will be persistent and can be accessed by the user.</p><p>Parse provides methods to check whether the user is linked or not. The following code will demonstrate a way to check whether the user is anonymous:</p><div><pre class="programlisting">if ([PFAnonymousUtils isLinkedWithUser:[PFUser currentUser]]) {
    [self enableSignUpButton];
} else {
    [self enableLogOutButton];
}</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec41"/>Resetting passwords</h1></div></div></div><a id="id159" class="indexterm"/><p>Often users forget their username and <a id="id160" class="indexterm"/>password when they start to log in to your application. In such cases, you need to provide the user with a way to reset their password. Parse provides you with the <code class="literal">requestPasswordResetForEmailInBackground:</code> method<a id="id161" class="indexterm"/> to securely reset the user password.</p><p>The following code will illustrate the use of the reset password function:</p><div><pre class="programlisting">[PFUser requestPasswordResetForEmailInBackground:@"demo@example.com"];</pre></div><p>The reset password link will be sent to the provided e-mail ID, and from there the user can enter the new password for the application.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec48"/>Writing user queries</h2></div></div></div><p>The<a id="id162" class="indexterm"/> following code will demonstrate the way to write query on the <code class="literal">PFUser</code> class:</p><div><pre class="programlisting">PFQuery *query = [PFUser query];
[query whereKey:@"gender" equalTo:@"female"]; // find all the women
NSArray *girls = [query findObjects];</pre></div><p>The previous code will provide you with all the female users in the output.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec42"/>Providing security</h1></div></div></div><p>While you <a id="id163" class="indexterm"/>are saving the data of the user, it's important<a id="id164" class="indexterm"/> that all the user data should be secure. User data and associated information are significant and they should be saved securely. Parse allows you to save your data securely on the cloud.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec49"/>Updating the user object</h2></div></div></div><p>The <code class="literal">PFUser</code> class <a id="id165" class="indexterm"/>is already secured. Data saved in <code class="literal">PFUser</code> can be updated only by that user. Moreover, you cannot call any <code class="literal">save</code> or <code class="literal">delete</code> methods <a id="id166" class="indexterm"/>on the <a id="id167" class="indexterm"/>
<code class="literal">PFUser</code> class. The only methods that can update the data on the <code class="literal">PFUser</code> class are the <code class="literal">logIn</code> and <code class="literal">signUp</code> methods. This ensures that only the user can update their data on the cloud:</p><div><pre class="programlisting">The following code will illustrate the security of the user on cloud.
PFUser *user = [PFUser logInWithUsername:@"my_username" password:@"my_password"];
user.username = "my_new_username"; // attempt to change username
[user save]; // This succeeds, since the user was authenticated on the device
 
// Get the user from a non-authenticated method
PFQuery *query = [PFUser query];
PFUser *userAgain = (PFUser *)[query getObjectWithId:user.objectId];
 
userAgain.username = "another_username";
 
// This will throw an exception, since the PFUser is not authenticated
[userAgain save];</pre></div><p>To fetch the authentic copy of the user object, use the <code class="literal">currentUser</code> method, you can check the authenticity of the user by using the <code class="literal">isAuthenticated</code> Boolean property.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec50"/>Securing objects</h2></div></div></div><p>You can<a id="id168" class="indexterm"/> use the <code class="literal">PFUser</code>'s security model for other objects as well. You can specify the read and write permissions on the objects saved on Parse. You can allow specific group users, which can read the object, and other groups of users, which can modify the object. For security, each object is provided with the access control list, implemented by the <code class="literal">PFACL</code> class.</p><p>The following code will illustrate a way to set the privacy of the object of the current user on Parse:</p><div><pre class="programlisting">PFObject *privateNote = [PFObject objectWithClassName:@"Note"];
[privateNote setObject:@"This note is private!" forKey:@"content"];
privateNote.ACL = [PFACL ACLWithUser:[PFUser currentUser]];
[privateNote saveInBackground];</pre></div><p>The <code class="literal">ACLWithUser</code> method<a id="id169" class="indexterm"/> helps you to generate the ACL that limit the access of the object to the current user only. The ACL is updated after calling the <code class="literal">save</code> method. The protected data will be accessible to users on the devices on which they are logged in.</p><p>You can update the permissions of your Parse objects, respective to users. The following two methods will help you to update the permissions of your Parse objects:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To provide read access use <code class="literal">setReadAccess:forUser:</code></li><li class="listitem" style="list-style-type: disc">To provide write access use <code class="literal">setWriteAccess:forUser:</code></li></ul></div><p>The following code will illustrate a way to set read and write access:</p><div><pre class="programlisting">PFObject *groupMessage = [PFObject objectWithClassName:@"Message"];
PFACL *groupACL = [PFACL ACL];
     
// userList is an NSArray with the users we are sending this message to.
for (PFUser *user in userList) {
    [groupACL setReadAccess:YES forUser:user];
    [groupACL setWriteAccess:YES forUser:user];
}
 
groupMessage.ACL = groupACL;
[groupMessage saveInBackground];</pre></div><p>You can also grant read/write permission to all users using the <code class="literal">setPublicReadAccess:</code> and <code class="literal">setPublicWriteAccess:</code> methods.</p><p>To provide a common access control list for all objects of your application, you can change the default ACLs:</p><div><pre class="programlisting">PFACL *defaultACL = [PFACL ACL];
[defaultACL setPublicReadAccess:YES];
[PFACL setDefaultACL:defaultACL withAccessForCurrentUser:YES];</pre></div><p>In the previous <a id="id170" class="indexterm"/>code, we are updating the default ACL to provide public access to all the objects.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec43"/>Assigning roles</h1></div></div></div><p>As your <a id="id171" class="indexterm"/>application grows, ACL becomes insufficient. You need to be more constrained and have a better approach to control the user access. Parse provides you with the roles to solve the problem. Roles allow you to create logical groups of users. Role is an object that contains users and other roles. Updating the permission of any role will update the permission of all the associated users in that role.</p><p>For example, you can divide your application users into Administrators, Standard Users, and Guests roles. Altering the permissions of any role will update the permission of all the users belonging to that group. The class that provides functionality of the role is <code class="literal">PFRole</code>. This class inherits from PFObject, so all the methods are accessible in the <code class="literal">PFRole</code> as well.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec51"/>PFRole</h2></div></div></div><p>The <code class="literal">PFRole</code> class<a id="id172" class="indexterm"/> provides you with the following additional properties<a id="id173" class="indexterm"/> other than the properties in PFObject:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">name</code>: This field will store the name of the role, such as Administrators or Standard Users.</li><li class="listitem" style="list-style-type: disc"><code class="literal">users</code>: This field will store the <code class="literal">PFUser</code> object as a relation. The user will inherit all the permissions of the role to which it's associated.</li><li class="listitem" style="list-style-type: disc"><code class="literal">roles</code>: This field will hold the actual permissions for the <code class="literal">PFRole</code> object.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec52"/>Securing the role object</h2></div></div></div><p>The<a id="id174" class="indexterm"/> <code class="literal">PFRole</code> class<a id="id175" class="indexterm"/> uses the same ACL security like all the other Parse objects.</p><p>The following code will illustrate a way to create a new <code class="literal">PFRole</code> object:</p><div><pre class="programlisting">// By specifying no write privileges for the ACL, we can ensure the role cannot be altered.
PFACL *roleACL = [PFACL ACL];
[roleACL setPublicReadAccess:YES];
PFRole *role = [PFRole roleWithName:@"Administrator" acl:roleACL];
[role saveInBackground];</pre></div><p>The previous <a id="id176" class="indexterm"/>code will create a new <code class="literal">role</code> object, which now can be associated with the <code class="literal">User</code> object. The user access control will be updated according to the <code class="literal">role</code> object.</p><p>The following code will associate <code class="literal">User</code> with the <code class="literal">role</code> object and update the user ACL with the new ACL provided by the role:</p><div><pre class="programlisting">PFRole *role = [PFRole roleWithName:roleName acl:roleACL];
for (PFUser *user in usersToAddToRole) {
  [role.users addObject:user];
}
for (PFRole *childRole in rolesToAddToRole) {
  [role.roles addObject:childRole];
}
[role saveInBackground];</pre></div><p>Take great care while assigning ACLs to your roles, as they will directly impact the user's accessibility.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec53"/>Securing other objects</h2></div></div></div><p>Now you <a id="id177" class="indexterm"/>have learned to provide roles to the user. In the <code class="literal">PFACL</code> class of the user object, you can provide which users and roles should be granted read or write access to which object.</p><p>The following code will illustrate the usage of roles in <code class="literal">PFObject</code>:</p><div><pre class="programlisting">PFObject *wallPost = [PFObject objectWithClassName:@"WallPost"];
PFACL *postACL = [PFACL ACL];
[postACL setWriteAccess:YES forRole:@"Administrator"];
wallPost.ACL = postACL;
[wallPost saveInBackground];</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec54"/>Implementing role hierarchy</h2></div></div></div><p>You can provide <a id="id178" class="indexterm"/>one role as the subset of another. This <a id="id179" class="indexterm"/>means that one role can contain another. You can create a parent-child relationship between roles. The result of such a relationship is that any permission granted to the parent will be implicitly granted to all its child roles.</p><p>For example, you can say that the <code class="literal">Administrator</code> role contains all the permissions that are granted in<a id="id180" class="indexterm"/> the <code class="literal">Moderator</code> role. The following code will explain the implementation of the role hierarchy:</p><div><pre class="programlisting">PFRole *administrators = /* Your "Administrators" role */;
PFRole *moderators = /* Your "Moderators" role */;
[moderators.roles addObject:administrators];
[moderators saveInBackground];</pre></div><p>The previous code will add a relationship between the <code class="literal">Administrator</code> and <code class="literal">Moderator</code> role. Here, the <code class="literal">Administrator</code> role is a child role of <code class="literal">Moderator</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec44"/>Summary</h1></div></div></div><p>In this chapter, we explored the users and role management of the application using Parse.</p><p>We started by exploring <code class="literal">PFUser</code> with its properties and login process.</p><p>Then, we learned about the security of users and other objects.</p><p>Finally, we explored <code class="literal">PFRole</code> to extend the user permissions and security along with grouping the users.</p><p>In the next chapter, we will learn about social media (Facebook, Twitter) integration in application using Parse.</p></div></body></html>