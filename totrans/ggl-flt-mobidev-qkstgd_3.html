<html><head></head><body>
        

                            
                    <h1 class="header-title">Widgets, Widgets Everywhere</h1>
                
            
            
                
<p class="mce-root">In Flutter, the concept of widgets is very important. As stated in <a href="6f964d6d-1e08-460b-9c4b-79023fa9816d.xhtml" target="_blank">Chapter 1</a>, <em>Introducing Flutter</em>, everything in Flutter is a widget. You might have a lot of questions about widgets, such as "What are the basic types of widgets?", "How do I create one?", "What are some good example of widgets?",<em> </em>and so on.</p>
<p>In this chapter, we will explore these questions together. We will first take a look at the widgets catalog and understand the fundamental widgets that will help you build apps with Flutter. We will also learn how to create custom widgets and then take a look at the concept of routing and navigating in a Flutter app. All of these topics will be covered in the following sections:</p>
<ul>
<li>Widgets Catalog</li>
<li>Creating widgets</li>
<li>Routing and navigation</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Widgets Catalog</h1>
                
            
            
                
<p>The Flutter team built this very good website called the <strong>Widgets Catalog</strong> (<a href="https://flutter.io/widgets/">https://flutter.io/widgets/</a>) where you can explore the variety of components that already exist in Flutter, divided by category. You will be using a lot of these widgets in your applications, so the more you know about them, the more efficiently you can use them in your application.</p>
<p>However, there are a few fundamental widgets listed that will help you get familiar with the types of widgets you will find in the Widgets Catalog. The following is a list of those widgets:</p>
<ul>
<li><kbd>Container</kbd></li>
<li><kbd>Image</kbd></li>
<li><kbd>Text</kbd></li>
<li><kbd>Icon</kbd></li>
<li><kbd>RaisedButton</kbd></li>
<li><kbd>Scaffold</kbd></li>
<li><kbd>Appbar</kbd></li>
<li><kbd>PlaceHolder</kbd></li>
<li><kbd>Row</kbd></li>
<li><kbd>Column</kbd></li>
<li><kbd>ListView</kbd></li>
</ul>
<p>Let's explore these widgets one by one in detail.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Container</h1>
                
            
            
                
<p>This is one of the complex widgets in the catalog. It is used to contain a child widget within your parent widget, which it does by applying some styling properties on it. </p>
<p>A container makes it possible to apply a variety of features, for example, background color, aligning the child within the container, setting some constraints to the size of the child, and applying some decoration or transformation property to the child (for example, you can rotate a widget). When we look at the amount of things you can do with this widget, it can be considered a complex widget. But in most cases, we will need only a couple of its features.</p>
<p>Now, let's take a look at the code to display the widget. The code will look as follows:</p>
<pre>Center(<br/> child: Container(<br/>   decoration: BoxDecoration(border: Border.all()),<br/>    height: 200.0,<br/>    width: 200.0,<br/>  ),<br/>),</pre>
<p>The following output will be displayed:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-408 image-border" src="img/69d034f0-00c5-4654-b184-efd3d15efff3.png" style="width:23.08em;height:36.75em;"/></p>
<p>Sometimes, you will need to show a widget based on a conditional expression—for example, in this case:</p>
<pre>function getIcon(bool condition) {<br/>    if (condition == true) return Icon(Icons.edit);<br/>    else return Container();  <br/> }</pre>
<p>The preceding code shows the conditional expression for a container. It works like most of the conditional expressions, where if the condition is true, you will get your regular widget. But if the condition is false, you will get something called a<em> </em><strong>null</strong> widget. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Image</h1>
                
            
            
                
<p>Displaying images on your application is one feature that your app must have. There are hardly any apps today that lack the functionality to display an image. And, to do this, the image widget comes into the picture. We can use the following code to use an image widget:</p>
<pre>Center(<br/>  child: Container(<br/>    height: 200.0,<br/>    width: 200.0,<br/>    child: Image.network("https://flutter.io/images/flutter-mark-square-100.png"),<br/>  ),<br/>),</pre>
<p>The following output will be displayed when you use the preceding code:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-409 image-border" src="img/464b9cba-65c7-4b61-95bc-76167d9db23b.png" style="width:20.58em;height:32.75em;"/></p>
<p>You can explore the several constructors it has to offer, but I suggest that you try and use them depending on the source you want to use. For example, if you have an <kbd>imageProvider</kbd>, you will use the default constructor, but if you have the image in an <kbd>AssetBundle</kbd>, you should use the <kbd>Image.asset</kbd> constructor. </p>
<p>This is an image-displaying widget, and images come in a few different formats. Here's the list of image formats supported by the image widget:</p>
<ul>
<li><kbd>JPEG</kbd></li>
<li><kbd>PNG</kbd></li>
<li><kbd>GIF</kbd></li>
<li><kbd>Animated GIF</kbd></li>
<li><kbd>WebP</kbd></li>
<li><kbd>Animated WebP</kbd></li>
<li><kbd>BMP</kbd></li>
<li><kbd>WBMP</kbd></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Text</h1>
                
            
            
                
<p>This widget is as self-explanatory as the last one. It is used for displaying text on the screen with a single style. We can also display the text on a single line or multiple lines; this depends on the layout constraints. The style argument when using this widget is optional. If the style argument is not provided, the widget will use the style from enclosing <kbd>DefaultTextStyle</kbd>, and if the provided style's <kbd>TextStyle.inherit</kbd> property is true, the given style will be merged with the default one.</p>
<p>The following code can be used for using a text widget:</p>
<pre>Center(<br/>  child: Container(<br/>    height: 200.0,<br/>    width: 200.0,<br/>    child: Text("This is a text"),<br/>  ),<br/>),</pre>
<p>The following screenshot will display how the widget is displayed on the screen:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-410 image-border" src="img/2f16ef43-e15f-4e4c-a4b5-79fe15e8a754.png" style="width:24.25em;height:38.58em;"/></p>
<p>There may be instances when you want to do more with this text widget. For example, to apply more than one style (to display some bold words in a line) to text, you can use the <kbd>TextSpan.rich</kbd> constructor, or to add interactivity to the text, you can use use a <kbd>GestureDetector</kbd>. </p>
<p>I would suggest using <kbd>FlatButton</kbd>, instead of a text widget for interactivity.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Icon</h1>
                
            
            
                
<p>The icon widget is used to draw an icon using the font described in <kbd>IconData</kbd>, such as a material's predefined <kbd>IconData</kbd> in the <kbd>Icon</kbd> class.</p>
<p>The following code can be used to use the <kbd>Icon</kbd> widget:</p>
<pre>Center(<br/>  child: Container(<br/>    height: 200.0,<br/>    width: 200.0,<br/>    child: Icon(Icons.flag),<br/>  ),<br/>),</pre>
<p>The following is a screenshot displaying how the <kbd>Icon</kbd> widget looks on the screen:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-411 image-border" src="img/3c2a4a8a-fe6a-4bef-bd9f-3ce6c596047c.png" style="width:19.83em;height:31.58em;"/></p>
<p>Just like the text widget, we can add interactivity with the <kbd>Icon</kbd> widget too. To do that, we can use <kbd>GestureDetector</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">RaisedButton</h1>
                
            
            
                
<p>This widget is used to display a simple elevated button. The button is elevated because the button is based on a material widget whose elevation increases when the button is pressed. If the <kbd>onPressed</kbd> callback is null, then the button will be disabled, and it will resemble a flat button in <kbd>disabledColor</kbd>.</p>
<p>The following code can be used to use the <kbd>RaisedButton</kbd> widget:</p>
<pre>Center(<br/>  child: Container(<br/>    height: 200.0,<br/>    width: 200.0,<br/>    child: RaisedButton(<br/>      onPressed: () =&gt; print("on pressed"),<br/>      child: Text("BUTTON"),<br/>      color: Colors.blue,<br/>    ),<br/>  ),<br/>),</pre>
<p>The following screenshot will be displayed when you use the preceding code:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-415 image-border" src="img/37aa21dd-e07c-4788-b2b8-44b595ad7183.png" style="width:18.08em;height:28.75em;"/></p>
<p>The suggestion is to use <kbd>RaisedButton</kbd> to add dimension in otherwise mostly flat layouts. I would recommend not using such a button in a dialog or a card.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Scaffold</h1>
                
            
            
                
<p><strong>Scaffold</strong> is a basic layout structure based on material design. In practice, if you use material design, every screen of your app will have a <kbd>Scaffold</kbd> as its base. The <kbd>Scaffold</kbd> widget is used for showing drawers, snackbars, bottomsheets, floating-action buttons, and so on, by offering APIs. To display a snackbar or a bottomsheet, you must use <kbd>Scaffoldstate</kbd> for the current context. We can use it via <kbd>Scaffold.of</kbd> and use the <kbd>ScaffoldState.showSnackbar</kbd> function.</p>
<p>The following code can be used to display a <kbd>snackbar</kbd> using <kbd>Scaffold</kbd>:</p>
<pre>Center(<br/>      child: Container(<br/>        height: 200.0,<br/>        width: 200.0,<br/>        child: RaisedButton(<br/>          onPressed: () {<br/>            Scaffold.of(context).showSnackBar(SnackBar(<br/>                  content: Text("HELLO!"),<br/>                ));<br/>          },<br/>          child: Text("BUTTON"),<br/>          color: Colors.blue,<br/>        ),<br/>      ),<br/>    ), </pre>
<p>The following is the output that will be displayed using the preceding code:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-416 image-border" src="img/996b8ed0-4a35-47dd-b1fb-46f363220e03.png" style="width:23.08em;height:36.67em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">AppBar</h1>
                
            
            
                
<p><kbd>AppBar</kbd> is basically used as a property of <kbd>Scaffold</kbd>, and the majority of <kbd>Scaffold</kbd>s have app bars. The app bar consists of a toolbar and potentially other widgets. For example, it can host <kbd>TabBar</kbd>, <kbd>FlexibleSpaceBar</kbd>, or some actions optionally followed by <kbd>PopupMenuButton</kbd> for less common operations.</p>
<p>The property that's used for <kbd>AppBar</kbd> is <kbd>Scaffold.appBar</kbd>. It looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-418 image-border" src="img/657a576e-36b4-479d-a94c-d2e09baf555e.png" style="width:23.25em;height:23.50em;"/></p>
<p>The preceding diagram displays where each widget will be placed by the <kbd>appBar</kbd> component.</p>
<p>If the leading widget is omitted and <kbd>Scaffold</kbd> has a drawer, then <kbd>appBar</kbd> will place a button to open the drawer. If the nearest navigator has any previous routes, a <kbd>BackButton</kbd> will be inserted.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">PlaceHolder</h1>
                
            
            
                
<p><kbd>PlaceHolder</kbd> is another widget that explains itself through its name. The <kbd>PlaceHolder</kbd> widget is used for holding a place for a widget. It draws a box that represents where other widgets will be added later.</p>
<p>The following code can be used for a <kbd>PlaceHolder</kbd> widget:</p>
<pre> Center(<br/>      child: Container(<br/>        height: 200.0,<br/>        width: 200.0,<br/>        child: Placeholder(),<br/>      ),<br/>    ),</pre>
<p>The preceding code will display the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-419 image-border" src="img/c622dd11-9e66-49fc-ab3d-c93292da18e1.png" style="width:19.08em;height:30.33em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Column</h1>
                
            
            
                
<p><kbd>Column</kbd> is essential for composing layout in Flutter apps. It displays its children in a vertical array. The following code can be used for the <kbd>Column</kbd> widget:</p>
<pre>Center(<br/>      child: Column(<br/>        crossAxisAlignment: CrossAxisAlignment.center,<br/>        mainAxisAlignment: MainAxisAlignment.spaceEvenly,<br/>        children: &lt;Widget&gt;[<br/>          Container(<br/>            height: 20.0,<br/>            width: 20.0,<br/>            color: Colors.red,<br/>          ),<br/>          Container(<br/>            height: 20.0,<br/>            width: 20.0,<br/>            color: Colors.green,<br/>          ),<br/>          Container(<br/>            height: 20.0,<br/>            width: 20.0,<br/>            color: Colors.yellow,<br/>          ),<br/>        ],<br/>      ),<br/>    ),</pre>
<p>The following output will be displayed:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-420 image-border" src="img/ba02c14e-4061-43f2-926c-5dd57b6223bc.png" style="width:21.00em;height:33.33em;"/></p>
<p>The <kbd>Column</kbd> widget, however, does not support scrolling; for that, we can use <kbd>ListView</kbd>.</p>
<p>Note that it will be considered as an error by the system if you have more children in a column that will fit into the available room. That's because the column doesn't have the ability to recycle the layout.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Row</h1>
                
            
            
                
<div><p>The <kbd>Row</kbd> widget is similar to the <kbd>Column</kbd> widget, but still different. We can say that it is the horizontal version of <kbd>column</kbd>. It draws the children in a horizontal array.</p>
<p>The following code can be used for a <kbd>Row</kbd> widget:</p>
<pre>enter(<br/>      child: Row(<br/>        crossAxisAlignment: CrossAxisAlignment.center,<br/>        mainAxisAlignment: MainAxisAlignment.spaceEvenly,<br/>        children: &lt;Widget&gt;[<br/>Container(<br/>            height: 20.0,<br/>            width: 20.0,<br/>            color: Colors.red,<br/>          ),<br/>          Container(<br/>            height: 20.0,<br/>            width: 20.0,<br/>            color: Colors.green,<br/>          ),<br/>          Container(<br/>            height: 20.0,<br/>            width: 20.0,<br/>            color: Colors.yellow,<br/>          ),<br/>        ],<br/>      ),<br/>    ),</pre>
<p>The following output will be displayed:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-421 image-border" src="img/a31ab713-91b4-48a4-a69f-61fda765c3af.png" style="width:20.83em;height:33.08em;"/></p>
</div>
<p>The story in regard to scrolling remains the same as for the <kbd>Column</kbd> widget. It is recommended to use <kbd>ListView</kbd> if you want to scroll the children.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">ListView</h1>
                
            
            
                
<p><kbd>ListView</kbd> behaves similar to a column or a row; the only difference is that its children can be scrolled.</p>
<p>There are three constructors for the <kbd>ListView</kbd> widget:</p>
<ul>
<li>The default takes a list of widgets in its children property. This is a good choice for small lists because to build it, the list will process every child.</li>
<li><kbd>ListView.builder</kbd> takes an indexed builder to build the children on demand. This is the choice to pick if you have a large number of children, because every time the list processes only the visible children.</li>
<li><kbd>ListView.custom</kbd> takes <kbd>SliverChildDelegate</kbd>, which provides the ability to customize more aspects of <kbd>ListView</kbd>.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">A note about Row, Column, and ListView</h1>
                
            
            
                
<p>Sometimes, it can happen that you get a runtime exception at the time of building a row or a column that's been placed in another row/column or in any scenario that does not provide a maximum height constraint.</p>
<p>The problem is that the inner widget should fill all the remaining space, but the outer widget has no specific size and should fill the available space too. So, they can't understand where to stop, and then an exception is thrown. </p>
<p>To solve such a problem, you must understand why the inner column/row is receiving unbounded constraints. Consider the following:</p>
<ul>
<li>If the column/row is placed in another column/row, you can try to wrap the inner widget in an expanded widget, indicating that it should take the remaining space of the outer widget and not all the space it desires</li>
<li>If the widget is placed in a <kbd>Listview</kbd> and is wrapped in an expanded or flexible, then that key is to remove that wrapping widget and to set the size of the inner widget manually</li>
</ul>
<p>Another problem you may have to encounter the yellow-and-black-striped banner as shown in following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-422 image-border" src="img/1cbd5007-fc27-4e4c-b7de-813e4ee51547.png" style="width:23.17em;height:36.83em;"/></p>
<p>This banner indicates that a row or column overflows its size. The solution is to use <kbd>ListView</kbd> and let the content scroll, or just to reduce the size of the children.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating widgets</h1>
                
            
            
                
<p>We saw a number of widgets in the previous section, but there might be a possibility that you don't find the right ready-to-use widget that you want or that you want to combine more widgets in order to create a reusable group. Therefore, you have to create a custom widget.</p>
<p>There are two types of widget in Flutter that you can use to create your own custom widgets:</p>
<ul>
<li>Stateless widgets</li>
<li>Stateful widgets</li>
</ul>
<p>Let's take a look at them in a bit more detail.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Stateless widgets</h1>
                
            
            
                
<p><strong>Stateless widgets</strong> remain the same even if the user interacts with them. This kind of widget has no state, so they can't change according to an internal state. They can only react to higher widget changes.</p>
<p>To build a stateless widget, we will extend the <kbd>StatelessWidget</kbd> abstract class, as follows:</p>
<pre>class MyApp extends StatelessWidget {<br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return MaterialApp(<br/>      title: 'Flutter Demo',<br/>      theme: ThemeData(<br/>        primarySwatch: Colors.blue,<br/>      ),<br/>      home: MyHomePage(title: 'Flutter Demo Home Page'),<br/>    );<br/>  }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Stateful widgets</h1>
                
            
            
                
<p><strong>Stateful widgets</strong> are dynamic components that have an internal state to manage. A stateful widget can react to state changes and change accordingly. The state is stored in a <kbd>State</kbd> object. To create a <kbd>StatefulWidget</kbd>, you have to extend the <kbd>StatefulWidget</kbd> abstract class, as shown in the following code:</p>
<pre>class MyHomePage extends StatefulWidget {<br/>  MyHomePage({Key key, this.title}) : super(key: key);<br/>  final String title;<br/><br/>  @override<br/>  _MyHomePageState createState() =&gt; new _MyHomePageState();<br/>}</pre>
<p class="mce-root"/>
<p>The state will be a class extending the <kbd>State&lt;T extends StatefulWidget&gt;</kbd> abstract class. Let's take a look at example where the widget changes the background color according to its state. The code for this is as follows:</p>
<pre>class _MyHomePageState extends State&lt;MyHomePage&gt; {<br/>  bool value = false;<br/><br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return new Scaffold(<br/>      backgroundColor: value ? Colors.black : Colors.white,<br/>      appBar: new AppBar(<br/>        title: new Text(widget.title),<br/>      ),<br/>      body: Center(<br/>        child: Switch(<br/>            value: value,<br/>            onChanged: (v) {<br/>              setState(() {<br/>                value = v;<br/>              });<br/>            }),<br/>      ),<br/>    );<br/>  }<br/>}</pre>
<p>To trigger the framework to rebuild the widget and apply the changes, you have to call the <kbd>setState()</kbd> function, or it won't see any changes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Routing and navigation</h1>
                
            
            
                
<p>We've just looked at how to use widgets, but you won't be using just one widget. In a typical application, it's normal to find more than one screen. When an application has more than one screen, it is essential for the users to have a clear route to move through those pages, and to do so routing and navigating through the pages becomes very important for your application.</p>
<p>To do this, if you are from an Android background, you would use more activities or fragments, and in iOS, you would create a new <kbd>viewControllers</kbd>.</p>
<p>In the Flutter world, new screens are widgets! To navigate to a new route, we can use the <kbd>Navigator.push()</kbd> function, passing as an argument the current context and a new <kbd>MaterialPageRoute</kbd>:</p>
<pre>Within the `FirstScreen` Widget<br/> onPressed: () {<br/>   Navigator.push(<br/>     context,<br/>     MaterialPageRoute(builder: (context) =&gt; SecondScreen()),<br/>   );<br/> }</pre>
<p>The <kbd>SecondScreen</kbd> will be a normal widget that builds the screen. For example:</p>
<pre>class SecondScreen extends StatelessWidget {<br/>   @override<br/>   Widget build(BuildContext context) {<br/>     return Scaffold(<br/>       appBar: AppBar(<br/>         title: Text("Second Screen"),<br/>       ),<br/>     );<br/>   }<br/> }</pre>
<p>To navigate back, we will use another function of the navigator: <kbd>Navigator.pop()</kbd>. This function will remove the current route from the stack of routes that are managed by the navigator. We can also use this function to return a value to the users when moving through the screen. Let's take a look at this in detail in the next section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Returning a value when navigating</h1>
                
            
            
                
<p class="mce-root">Returning a value to the readers when moving from one screen to another screen can improve the user experience of your application. For example, just a simple <kbd>welcome</kbd> on the screen when opening an app, will increase the user experience. For this purpose, in Flutter, we have <kbd>Navigator.pop()</kbd>. </p>
<p><kbd>Navigator.pop()</kbd> takes the current context as an argument, but it has an optional dynamic argument. This means that you can return any value when popping a screen.</p>
<p>Taking a look at the return value of <kbd>Navigator.push()</kbd>, you can see that it returns a <kbd>Future&lt;dynamic&gt;</kbd>. So, when pushing a new screen, you can wait for the popped return value. For example:</p>
<pre>function getConfirmation(BuildContext context) async {<br/>  return await Navigator.push(context, MaterialPageRoute(<br/>    builder: (context) =&gt; ConfirmationScreen(),<br/>  ) ?? false;<br/>}]</pre>
<p>The <kbd>ConfirmationScreen</kbd> will be as shown:</p>
<pre>class ConfirmationScreen extends StatelessWidget {<br/>  Widget build(BuildContext context) =&gt; Scaffold(<br/>    body: ButtonBar(<br/>      children: &lt;Widget&gt;[<br/>        RaisedButton(<br/>          child: Text("OK"),<br/>          onPressed: () =&gt; Navigator.pop(context, true),<br/>        ),<br/>        RaisedButton(<br/>          child: Text("CANCEL"),<br/>          onPressed: () =&gt; Navigator.pop(context, false),<br/>        ),<br/>      ],<br/>    ),<br/>  );<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we went through the widget catalog; this catalog consists of a number basic widgets that we can start using instantly in our applications without building our own widgets. It is good to understand these basic widgets, as you will be using them in your application a lot. But there will be times when you will need a customized widget, to help you with that we went through stateless and stateful widgets, that will help you customize your widgets. And, finally, we learned how to navigate and route through those widgets.</p>
<p>What's next? There are more and more widgets you can use to build your apps. In the next chapter, we'll see some of them that can be used to build beautiful layouts.</p>


            

            
        
    </body></html>