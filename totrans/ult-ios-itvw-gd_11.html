<html><head></head><body>
		<div><h1 id="_idParaDest-164" class="chapter-number"><a id="_idTextAnchor249" class="calibre6 pcalibre pcalibre1"/>8</h1>
			<h1 id="_idParaDest-165" class="calibre5"><a id="_idTextAnchor250" class="calibre6 pcalibre pcalibre1"/>SwiftUI and Declarative Programming</h1>
			<p class="calibre3">The previous chapter was highly intensive. We discussed the most critical framework in iOS development besides <strong class="bold">Foundation</strong>.</p>
			<p class="calibre3">This chapter is more than just discussing a <a id="_idIndexMarker594" class="calibre6 pcalibre pcalibre1"/>framework – we will discuss an idea, a <strong class="bold">programming paradigm</strong>.</p>
			<p class="calibre3">We can’t approach a job interview today in iOS without a basic knowledge of declarative programming, a topic that was no more than “nice to have” a few years ago.</p>
			<p class="calibre3">If you have gaps in your knowledge or limited experience, read this chapter thoroughly to fill that knowledge gap before you start your interview.</p>
			<p class="calibre3">This chapter covers these exciting topics in declarative programming:</p>
			<ul class="calibre10">
				<li class="calibre11">Exploring a new era in the development</li>
				<li class="calibre11">Understanding declarative programming</li>
				<li class="calibre11">Learning states and observable objects</li>
				<li class="calibre11">Navigating SwiftUI views</li>
				<li class="calibre11">Expertise with the SwiftUI life cycle</li>
				<li class="calibre11">Expertise with Combine</li>
			</ul>
			<p class="calibre3">Let’s start with a brief background about declarative programming.</p>
			<h1 id="_idParaDest-166" class="calibre5"><a id="_idTextAnchor251" class="calibre6 pcalibre pcalibre1"/>Entering a new era of development</h1>
			<p class="calibre3">SwiftUI and Combine are not only interesting frameworks but also symbolize a new direction that Apple is leading us toward. This direction is not disconnected from the current industry standards, as we can observe from the presence of <strong class="bold">React</strong>, <strong class="bold">Flutter</strong>, and RxJava in the everyday work of many developers.</p>
			<p class="calibre3">The reason why I chose to dedicate a whole chapter to two frameworks that are still not widely used is that these two frameworks mark how iOS projects will look in the following decade.</p>
			<p class="calibre3">If you haven’t gained any experience with SwiftUI and Combine until now, the minimum you should do is understand the basic terms and concepts, which are part of the current chapter goal.</p>
			<p class="calibre3">First, let’s go over the most critical concept – declarative programming.</p>
			<h1 id="_idParaDest-167" class="calibre5"><a id="_idTextAnchor252" class="calibre6 pcalibre pcalibre1"/>Understanding declarative programming</h1>
			<p class="calibre3">Declarative<a id="_idIndexMarker595" class="calibre6 pcalibre pcalibre1"/> programming is a whole new programming paradigm that provides us with more readable and robust code. Declarative programming is not a new concept at all – in fact, we can find the roots of declarative programming 30–40 years ago. But only in the last decade has declarative programming gained popularity.</p>
			<p class="calibre3">Let’s try to get into more detail about declarative programming by answering some questions we may encounter during an interview.</p>
			<h2 id="_idParaDest-168" class="calibre7"><a id="_idTextAnchor253" class="calibre6 pcalibre pcalibre1"/>“What’s the difference between declarative programming and the “classic” programming paradigm, also known as imperative programming?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">If the workplace <a id="_idIndexMarker596" class="calibre6 pcalibre pcalibre1"/>we interview for<a id="_idIndexMarker597" class="calibre6 pcalibre pcalibre1"/> uses Combine or SwiftUI in its projects, we will probably have to answer some variant of this question. The reason is that the difference in how we approach code is so big that we cannot avoid restructuring our thoughts to answer that.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">In declarative programming, we <em class="italic">focus on the outcome and results of our code</em>. We observe changes and define precisely what the results would be on other objects and how data will be manipulated.</p>
			<p class="calibre3">In imperative programming, we <em class="italic">focus on the steps that lead to </em><em class="italic">our results</em>.</p>
			<p class="calibre3">At first glance, the difference doesn’t look clear. What does “focus on the results and not the steps” mean?</p>
			<p class="calibre3">Let’s try to explain that in code examples.</p>
			<p class="calibre3">We have a screen with a button (<code>UIButton</code>) and a text field (<code>UITextField</code>), and we want to enable or disable the button based on the text field input. Let’s see how we do that in<a id="_idIndexMarker598" class="calibre6 pcalibre pcalibre1"/> imperative <a id="_idIndexMarker599" class="calibre6 pcalibre pcalibre1"/>programming:</p>
			<pre class="source-code">
import UIKitclass ViewController: UIViewController {
    @IBOutlet weak var textField: UITextField!
    @IBOutlet weak var button: UIButton!
    override func viewDidLoad() {
        super.viewDidLoad()
        textField.addTarget(self, action: #selector
            (textFieldDidChange(_:)), for: .editingChanged)
        button.isEnabled = false
    }
    @objc private func textFieldDidChange(_ textField: UITextField) {
        button.isEnabled = textField.text?.isEmpty == false
    }
}</pre>
			<p class="calibre3">The code should be straightforward, as we wrote this pattern hundreds of times while working with imperative programming. Connecting a delegate to a test field is common in iOS development. But look how unclear it is – when we set up the text field, we define <em class="italic">what function will be called</em> when the user changes the text, not what will happen. It means we focus on the steps and implementation, not the final result.</p>
			<p class="calibre3">In the text field delegate function, we indeed update the <code>isEnabled</code> property of the button, but that piece of code is called in another function in another place, perhaps even in another file.</p>
			<p class="calibre3">Let’s see a<a id="_idIndexMarker600" class="calibre6 pcalibre pcalibre1"/> declarative<a id="_idIndexMarker601" class="calibre6 pcalibre pcalibre1"/> approach to the p<a id="_idTextAnchor254" class="calibre6 pcalibre pcalibre1"/>roblem:</p>
			<pre class="source-code">
import Combineimport UIKit
class ViewController: UIViewController {
    @IBOutlet weak var textField: UITextField!
    @IBOutlet weak var button: UIButton!
    private var subscriptions = Set&lt;AnyCancellable&gt;()
    override func viewDidLoad() {
        super.viewDidLoad()
textField.publisher(for: \.text)
         .map { $0?.isEmpty == false }
         .assign(to: \.isEnabled, on: button)
      .store(in: &amp;subscriptions)
}
}</pre>
			<p class="calibre3">In the preceding code, we can see a much clearer solution to enable a button based on a text field input. We observe the text field “editing changed” event, map the <code>isEmpty</code> property to another Boolean, and assign it to the button’s <code>isEnabled</code> property.</p>
			<p class="calibre3">This means we declare what happens when a particular value is changed without any control flows <a id="_idIndexMarker602" class="calibre6 pcalibre pcalibre1"/>or<a id="_idIndexMarker603" class="calibre6 pcalibre pcalibre1"/> delegates.</p>
			<p class="calibre3">The two coding paradigms contrast significantly when dealing with more complex workflows.</p>
			<h2 id="_idParaDest-169" class="calibre7"><a id="_idTextAnchor255" class="calibre6 pcalibre pcalibre1"/>“How does declarative programming help handle state management in iOS apps?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">There’s a strong <a id="_idIndexMarker604" class="calibre6 pcalibre pcalibre1"/>relationship<a id="_idIndexMarker605" class="calibre6 pcalibre pcalibre1"/> between declarative programming and state management. Before we answer that question, it is essential to understand what is considered a state and think about how you ever used a state in your apps.</p>
			<p class="calibre3">Generally, a state is a condition of our app, screen, or view.</p>
			<p class="calibre3">For example, a state can be a Boolean variable that represents whether the user is logged in to your app. Another example of a state is whether a button should be visible.</p>
			<p class="calibre3">It is clear that a state is something we all used in our apps before, and in declarative programming, the state is a primary topic.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">Look at my last example – “whether a button should be visible.” It seems like a great idea to have a state for button visibility. The problem is that every time we change the state value, we must also ensure that the button is updated.</p>
			<p class="calibre3">One option is to use a <code>didSet</code> property observer:</p>
			<pre class="source-code">
var isTextEmpty: Bool = true {        didSet {
            // Disable the button if the text is empty,
               enable it otherwise
            button.isEnabled = !isTextEmpty
        }
    }</pre>
			<p class="calibre3">Even though a <code>didSet</code> property observer is a simple way to bind the state to button visibility, it’s not the ideal solution for a few reasons:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Separation of concerns</strong>: A variable can only have one property observer, meaning we cannot separate different concerns or responsibilities. For instance, we cannot have one <strong class="source-inline1">didSet</strong> block for analytics and another <strong class="source-inline1">didSet</strong> block for UI updates.</li>
				<li class="calibre11"><strong class="bold">Not testable</strong>: This relates to the previous point. Because the <strong class="source-inline1">didSet</strong> block contains multiple actions, including possible UI changes, testing it can be challenging because it can have additional possible side effects.</li>
				<li class="calibre11"><strong class="bold">Can’t observe multiple variables</strong>: It’s nice to observe one property, but what if we want to observe changes in numerous properties and perform one action based on that change? <strong class="source-inline1">didSet</strong> is not suitable for that.</li>
			</ul>
			<p class="calibre3">Now, here’s <a id="_idIndexMarker606" class="calibre6 pcalibre pcalibre1"/>the Combine <a id="_idIndexMarker607" class="calibre6 pcalibre pcalibre1"/>example version:</p>
			<pre class="source-code">
    private var cancellables = Set&lt;AnyCancellable&gt;()    private var buttonVisible = PassthroughSubject&lt;Bool,
        Never&gt;()
    override func viewDidLoad() {
        super.viewDidLoad()
        buttonVisible
            .assign(to: \.isEnabled, on: button)
            .store(in: &amp;cancellables)
}</pre>
			<p class="calibre3">The Combine version is a much more elegant way of handling a state. We bind the state to button enablement just like we did with the <code>didSet</code> example. But this time, we also earn more benefits, such as the following:</p>
			<ul class="calibre10">
				<li class="calibre11">We can observe the <strong class="source-inline1">buttonVisible</strong> variable in <em class="italic">multiple places</em> for different purposes</li>
				<li class="calibre11">We can use multiple instances of <strong class="source-inline1">buttonVisible</strong> <em class="italic">along with </em><em class="italic">more variables</em></li>
				<li class="calibre11">We can perform <em class="italic">async operations</em> more efficiently and add sophisticated operators to the stream</li>
			</ul>
			<p class="calibre3">Declarative programming is suitable for handling states because it lets us explain precisely what <a id="_idIndexMarker608" class="calibre6 pcalibre pcalibre1"/>to do each<a id="_idIndexMarker609" class="calibre6 pcalibre pcalibre1"/> time the state changes, and that’s ideal for state management.</p>
			<p class="calibre3">Speaking of states – let’s dive in and go over states in SwiftUI, as they play a significant role in screen updates and layout.</p>
			<h1 id="_idParaDest-170" class="calibre5"><a id="_idTextAnchor256" class="calibre6 pcalibre pcalibre1"/>Learning states and observable objects</h1>
			<p class="calibre3">“States” is a<a id="_idIndexMarker610" class="calibre6 pcalibre pcalibre1"/> primary topic <a id="_idIndexMarker611" class="calibre6 pcalibre pcalibre1"/>in SwiftUI and declarative programming. Unlike imperative programming, where we can directly update UI elements on the screen, declarative programming <em class="italic">works in the opposite way</em> – we update the state, and the UI is updated according to our changes.</p>
			<p class="calibre3">In fact, using states is the only way to create dynamic views in SwiftUI.</p>
			<p class="calibre3">SwiftUI uses something called a property wrapper to mark certain variables as states.</p>
			<p class="calibre3">Here are some of them:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="source-inline1">@State</strong>: To manage simple UI state</li>
				<li class="calibre11"><strong class="source-inline1">@Binding</strong>: To allow two directional updates between the view and its children</li>
				<li class="calibre11"><strong class="source-inline1">@ObservedObject</strong>: To share data between views</li>
				<li class="calibre11"><strong class="source-inline1">@EnvironmentObject</strong>: To share data between views across an app</li>
			</ul>
			<p class="calibre3">When asked about SwiftUI, these different property wrappers play a significant role in understanding how SwiftUI works and building a full-featured app with SwiftUI.</p>
			<p class="calibre3">If you want to read more about managing user interface state in SwiftUI, you can visit <a href="https://developer.apple.com/documentation/swiftui/managing-user-interface-state" class="calibre6 pcalibre pcalibre1">https://developer.apple.com/documentation/swiftui/managing-user-interface-state</a>. For an<a id="_idIndexMarker612" class="calibre6 pcalibre pcalibre1"/> overview <a id="_idIndexMarker613" class="calibre6 pcalibre pcalibre1"/>of property wrappers, check out the link at <a href="https://www.swift.org/blog/property-wrappers/" class="calibre6 pcalibre pcalibre1">https://www.swift.org/blog/property-wrappers/</a>.</p>
			<p class="calibre3">Now, let’s look at two critical questions about that topic.</p>
			<h2 id="_idParaDest-171" class="calibre7"><a id="_idTextAnchor257" class="calibre6 pcalibre pcalibre1"/>“Can you explain the differences and use cases for the @State and @Binding property wrappers in SwiftUI?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">These two<a id="_idIndexMarker614" class="calibre6 pcalibre pcalibre1"/> property wrappers are fundamental<a id="_idIndexMarker615" class="calibre6 pcalibre pcalibre1"/> to understanding how SwiftUI works. Going back to the <em class="italic">Understanding declarative programming</em> section, <code>@State</code> and <code>@Binding</code> are pure implementations of the concept of declarative programming.</p>
			<p class="calibre3"><code>@State</code> and <code>@Binding</code> are essential wrappers to create complex and reusable views.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3"><code>@State</code> is a property wrapper used to manage local states within a view. It’s used for simple values managed by a single view, such as toggles or form data. When the value of a <code>@State</code> property changes, <strong class="bold">SwiftUI</strong> will automatically update the view to reflect the new state. Here’s an example:</p>
			<pre class="source-code">
struct MyView: View {    @State var toggleIsOn = false
    var body: some View {
        Toggle(isOn: $toggleIsOn) {
            Text("Toggle is on: \(toggleIsOn.description)")
        }
    }
}</pre>
			<p class="calibre3">The <code>toggleIsOn</code> variable is wrapped in <code>@State</code>, allowing the SwiftUI to observe and update <code>MyView</code> if needed. Within the view, there is <code>Toggle</code> that is linked to the <code>toggleIsOn</code> state. As the state value changes, a corresponding text is updated.</p>
			<p class="calibre3"><code>@Binding</code> is a property wrapper that provides a two-way connection between the child’s and parent’s views. It’s used to pass the state down the view hierarchy, allowing child views to modify values stored in a parent view. When the value of a <code>@Binding</code> property changes, both <a id="_idIndexMarker616" class="calibre6 pcalibre pcalibre1"/>the child and parent views<a id="_idIndexMarker617" class="calibre6 pcalibre pcalibre1"/> will be updated to reflect the new state. Here’s an example:</p>
			<pre class="source-code">
struct MyParentView: View {    @State var toggleIsOn = false
    var body: some View {
        VStack {
            MyChildView(toggleIsOn: $toggleIsOn)
            Text("Toggle is on: \(toggleIsOn.description)")
        }
    }
}
struct MyChildView: View {
    @Binding var toggleIsOn: Bool
    var body: some View {
        Toggle(isOn: $toggleIsOn) {
            Text("Toggle is on: \(toggleIsOn.description)")
        }
    }
}</pre>
			<p class="calibre3">In this example, <code>MyParentView</code> manages the <code>toggleIsOn</code> state and passes it down to <code>MyChildView</code> using a <code>@Binding</code> property. <code>MyChildView</code> can then modify the state by updating the <code>toggleIsOn</code> property. Both views are automatically updated to reflect the new state when this happens.</p>
			<p class="calibre3">We can see that <code>@State</code> and <code>@Binding</code> have a strong relationship. <code>@State</code> is <code>@Binding</code> of its child view. If we compare this to imperative programming with UIKit, the <code>@Binding</code> feature <a id="_idIndexMarker618" class="calibre6 pcalibre pcalibre1"/>is similar to the delegate <a id="_idIndexMarker619" class="calibre6 pcalibre pcalibre1"/>pattern we know and love but much more powerful, simple, and mainly declarative.</p>
			<h2 id="_idParaDest-172" class="calibre7"><a id="_idTextAnchor258" class="calibre6 pcalibre pcalibre1"/>“What is the purpose of @ObservedObject in SwiftUI, and in what situations would you use it instead of @State or @Binding?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">Now that <a id="_idIndexMarker620" class="calibre6 pcalibre pcalibre1"/>we know what <code>@State</code> and <code>@Bining</code> roles <a id="_idIndexMarker621" class="calibre6 pcalibre pcalibre1"/>are in SwiftUI, we must<a id="_idIndexMarker622" class="calibre6 pcalibre pcalibre1"/> understand <a id="_idIndexMarker623" class="calibre6 pcalibre pcalibre1"/>how <code>@ObservedObject</code> fits into our app architecture and how it differs from other view property wrappers.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">The <code>@ObservedObject</code> property wrapper in <code>@ObservedObject</code> will also automatically be updated.</p>
			<p class="calibre3">Can the observed object be a singleton? Definitely. More importantly, it should be the same instance we inject into the different views.</p>
			<p class="calibre3">Let’s look at <em class="italic">Figure 8</em><em class="italic">.1</em>:</p>
			<div><div><img src="img/Figure_8.1_B18653.jpg" alt="Figure 8.1: The role of an observed object in our app architecture" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.1: The role of an observed object in our app architecture</p>
			<p class="calibre3"><em class="italic">Figure 8</em><em class="italic">.1</em> shows the different dependencies when using an observed object. It is an excellent practice to add more layers to our app that manage stuff such as persistent data and networking, and keep the observed object to share the data between the views.</p>
			<p class="calibre3">Let’s see a<a id="_idIndexMarker624" class="calibre6 pcalibre pcalibre1"/> SwiftUI <a id="_idIndexMarker625" class="calibre6 pcalibre pcalibre1"/>code <a id="_idIndexMarker626" class="calibre6 pcalibre pcalibre1"/>example of <a id="_idIndexMarker627" class="calibre6 pcalibre pcalibre1"/>a contacts list with the observed object.</p>
			<p class="calibre3">First, the contacts list view:</p>
			<pre class="source-code">
import SwiftUIstruct ContactListView: View {
    @ObservedObject var viewModel : ContactViewModel
    var body: some View {
        List(viewModel.contacts) { contact in Text(contact.name ?? "")
        }
    }
}</pre>
			<p class="calibre3">We can see that the contacts list uses an observed object named <code>viewModel</code> that can be injected into the view or <a id="_idIndexMarker628" class="calibre6 pcalibre pcalibre1"/>used as a <code>@ObservedObject</code> is that SwiftUI doesn’t recreate it whenever it needs to refresh the view, so it can safely store data.</p>
			<p class="calibre3">Now, let’s <a id="_idIndexMarker629" class="calibre6 pcalibre pcalibre1"/>see <a id="_idIndexMarker630" class="calibre6 pcalibre pcalibre1"/>what<a id="_idIndexMarker631" class="calibre6 pcalibre pcalibre1"/> the <code>ContactViewModel</code> class<a id="_idIndexMarker632" class="calibre6 pcalibre pcalibre1"/> looks like:</p>
			<pre class="source-code">
class ContactViewModel: ObservableObject {    @Published var contacts = [Contact]()
    private let dataLayer: ContactDataLayer
    init(dataLayer: ContactDataLayer) {
        self.dataLayer = dataLayer
        loadContacts()
    }
    func loadContacts() {
        contacts = dataLayer.loadContacts()
    }
}</pre>
			<p class="calibre3">There are three important things to note in this code example:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Conforming to the </strong><strong class="source-inline1">ObservableObject</strong><strong class="bold"> protocol</strong>: If we want the class to be an observed object, we need it to conform to the <strong class="source-inline1">ObservableObject</strong> protocol.</li>
				<li class="calibre11"><strong class="bold">Using </strong><strong class="source-inline1">@Published</strong><strong class="bold"> for the contacts list</strong>: The contacts list variable has a <strong class="source-inline1">@Published</strong> property wrapper, which lets the view observe changes in the contacts list.</li>
				<li class="calibre11"><strong class="bold">DataLayer as a dependency</strong>: To adhere to the separation of concerns principle, we separate the actual fetching and storing from the sharing class. The only responsibility of the <strong class="source-inline1">ContactViewModel</strong> class is to share data between views. The <strong class="source-inline1">ContactDataLayer</strong> class does the persistent operations.</li>
			</ul>
			<p class="calibre3">To summarize, <code>ObservedObject</code> is a mechanism that facilitates data sharing among views. It is easy to grasp <a id="_idIndexMarker633" class="calibre6 pcalibre pcalibre1"/>and<a id="_idIndexMarker634" class="calibre6 pcalibre pcalibre1"/> incorporate <a id="_idIndexMarker635" class="calibre6 pcalibre pcalibre1"/>and can <a id="_idIndexMarker636" class="calibre6 pcalibre pcalibre1"/>help divide a project’s structure into distinct layers.</p>
			<h1 id="_idParaDest-173" class="calibre5"><a id="_idTextAnchor259" class="calibre6 pcalibre pcalibre1"/>Navigating SwiftUI views</h1>
			<p class="calibre3">Navigation in <a id="_idIndexMarker637" class="calibre6 pcalibre pcalibre1"/>mobile apps was always a critical issue. UIKit supported navigation from day one, and SwiftUI launched with essential support from <code>NavigationView</code>.</p>
			<p class="calibre3">Navigation in SwiftUI is quite different than UIKit. While in UIKit, we had to create a new view controller and push it to a stack using <code>UINavigationController</code>, in SwiftUI, it works slightly differently.</p>
			<p class="calibre3">Remember we discussed declarative programming earlier in this chapter? This is how navigation works in SwiftUI. Instead of creating and pushing a new view, we use the state to present sheets, modals, and links to navigate to a new view.</p>
			<p class="calibre3">Let’s see how to present a modal view using state modification in SwiftUI:</p>
			<pre class="source-code">
struct ContentView: View {    @State var isModalPresented = false
    var body: some View {
        VStack {
            Button("Present Modal") {
                isModalPresented = true
            }
        }
        .sheet(isPresented: $isModalPresented) {
            ModalView()
        }
    }
}</pre>
			<p class="calibre3">In this example, we have a state variable called <code>isModalPresented</code>. When a user taps the <code>Present Modal</code> button, we set <code>isModalPresented</code> to <code>true</code>, which triggers the view modifier <code>ModalView</code>.</p>
			<p class="calibre3">Presenting a modal using a state may feel weird for developers who worked years with imperative <a id="_idIndexMarker638" class="calibre6 pcalibre pcalibre1"/>programming, but this pattern fits naturally into declarative programming.</p>
			<p class="calibre3">Now, let’s move on to some interesting questions about SwiftUI navigation.</p>
			<h2 id="_idParaDest-174" class="calibre7"><a id="_idTextAnchor260" class="calibre6 pcalibre pcalibre1"/>“How do you pass data between views using the SwiftUI navigation system?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">Passing data between <a id="_idIndexMarker639" class="calibre6 pcalibre pcalibre1"/>views is critical to implementing an effective navigation pattern.</p>
			<p class="calibre3">And this is not a trivial question – other patterns enable us to navigate to a new view without passing data. We can use the observed object pattern, which we reviewed in the previous section, or we can use some global state manager to understand what data to present.</p>
			<p class="calibre3">However, it is considered a best practice to pass data to a new screen for better separation and modularity.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">The answer is that there are no tricks here that we don’t already know from other patterns in UIKit.</p>
			<p class="calibre3">The best way to pass data between views is to <em class="italic">inject the data when initiating the </em><em class="italic">new view</em>.</p>
			<p class="calibre3">Let’s create a<a id="_idIndexMarker640" class="calibre6 pcalibre pcalibre1"/> screen with a list of countries:</p>
			<pre class="source-code">
struct Country {    let name: String
}
class DataStore {
    let countries = [
        Country(name: "USA"),
        Country(name: "Canada"),
        Country(name: "Mexico")
    ]
}
struct CountryListView: View {
    let dataStore = DataStore()
    var body: some View {
        NavigationView {
            List(dataStore.countries, id: \.name)
                { country in
                NavigationLink(destination:
                    CountryDetailView(country: country)) {
                    Text(country.name)
                }
            }
            .navigationTitle("Countries")
        }
    }
}</pre>
			<p class="calibre3">Now, let’s create <code>CountryDetailView</code> with the <code>country</code> property:</p>
			<pre class="source-code">
struct CountryDetailView: View {    let country: Country
    var body: some View {
        Text("Selected country: \(country.name)")
            .navigationTitle("Country Detail")
    }
}</pre>
			<p class="calibre3">The <code>CountryDetailView</code> struct has a property named <code>country</code>. In Swift, the compiler automatically generates a member-wise initializer for their properties. We use that to pass the <code>country</code> object when initializing <code>CountryDetailView</code>.</p>
			<p class="calibre3">As we can see, it is straightforward to pass data between views just by using dependency injection. We can also evaluate that pattern and pass a state on one side and a binding on the next view<a id="_idIndexMarker641" class="calibre6 pcalibre pcalibre1"/> to create a two-directional update between the two views, such as a delegate pattern in UIKit.</p>
			<h2 id="_idParaDest-175" class="calibre7"><a id="_idTextAnchor261" class="calibre6 pcalibre pcalibre1"/>“Can you explain how to use @Environment(\.presentationMode) to dismiss a presented view in SwiftUI navigation?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">Using <code>NavigationLink</code> to<a id="_idIndexMarker642" class="calibre6 pcalibre pcalibre1"/> move<a id="_idIndexMarker643" class="calibre6 pcalibre pcalibre1"/> to a new place is easy, but how do we dismiss or navigate back?</p>
			<p class="calibre3">This question tests our understanding of navigation and a property wrapper called <code>@Environment</code>, which can expose environment variables that provide more capabilities.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3"><code>@Environment(\.presentationMode</code>) is a property wrapper that provides access to a view’s presentation mode, allowing us to dismiss a presented view in SwiftUI navigation.</p>
			<p class="calibre3">Here’s an example of how to use <code>@Environment(\.presentationMode)</code> to dismiss a presented view:</p>
			<pre class="source-code">
struct DetailView: View {    @Environment(\.presentationMode) var presentationMode
    var body: some View {
        VStack {
            Text("Detail View")
            Button("Dismiss") {
                presentationMode.wrappedValue.dismiss()
            }
        }
        .navigationTitle("Detail View")
    }
}</pre>
			<p class="calibre3">In this<a id="_idIndexMarker644" class="calibre6 pcalibre pcalibre1"/> example, we<a id="_idIndexMarker645" class="calibre6 pcalibre pcalibre1"/> have <code>DetailView</code> currently presented on the screen. We use the <code>@Environment(\.presentationMode)</code> property wrapper to access the view’s presentation mode.</p>
			<p class="calibre3">Once the user taps the <code>presentationMode</code> to dismiss the function, which takes us back to the previous screen.</p>
			<p class="calibre3">Note that if the view is not currently presented, we’ll get a runtime error trying to do that. Therefore, if we are not sure whether the view is presented before we dismiss it, we can check using the same presentation mode:</p>
			<pre class="source-code">
if presentationMode.wrappedValue.isPresented {    Button("Dismiss") {
        presentationMode.wrappedValue.dismiss()
    }
}</pre>
			<p class="calibre3">In this code example, the <strong class="bold">Dismiss</strong> button appears only if the view is presented, and since it’s declarative, it will be hidden when it’s not.</p>
			<p class="calibre3">Navigation is a <a id="_idIndexMarker646" class="calibre6 pcalibre pcalibre1"/>crucial<a id="_idIndexMarker647" class="calibre6 pcalibre pcalibre1"/> component of any mobile app, and in a way, it becomes even more straightforward with SwiftUI. The preceding two questions should be enough for us to prepare for this part of the interview.</p>
			<h1 id="_idParaDest-176" class="calibre5"><a id="_idTextAnchor262" class="calibre6 pcalibre pcalibre1"/>Expertise with the SwiftUI life cycle</h1>
			<p class="calibre3">We can’t build<a id="_idIndexMarker648" class="calibre6 pcalibre pcalibre1"/> UI screens without fully understanding the UI life cycle. States and modifiers such as <code>onChange</code> and <code>onAppear</code> are integral to the SwiftUI life cycle and essential to building a functional application.</p>
			<p class="calibre3">We already went on some of the things related to the SwiftUI life cycle in the previous sections – for example, observed objects and states are part of the SwiftUI life cycle. Now, we must understand how they work when a view needs to reload, change, or move to a new screen.</p>
			<h2 id="_idParaDest-177" class="calibre7"><a id="_idTextAnchor263" class="calibre6 pcalibre pcalibre1"/>“How does SwiftUI handle state changes during the view life cycle?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">SwiftUI’s approach to<a id="_idIndexMarker649" class="calibre6 pcalibre pcalibre1"/> state management differs from traditional UIKit or AppKit approaches, and it’s crucial to understand how SwiftUI handles state changes and updates to avoid unexpected behavior in our app.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">SwiftUI generates the view hierarchy based on the current state. SwiftUI generates a new view hierarchy whenever the state changes and compares it to the current displayed hierarchy.</p>
			<p class="calibre3">This means that all the variables are regenerated each time, except for the property wrappers such as <code>@State</code> and <code>@Binding</code>. The comparison to the current view tells SwiftUI what views it needs to update to reflect the new state. SwiftUI applies the changes to the user interface by adding, removing, or updating current views.</p>
			<p class="calibre3">This process is very efficient because SwiftUI only updates the parts of the user interface that need to be changed.</p>
			<p class="calibre3">Look at the following code:</p>
			<pre class="source-code">
struct ContentView: View {    @State var labelText = "Hello, World!"
    var body: some View {
        VStack {
            Text(labelText)
                .padding()
            Button("Change Label Text") {
                labelText = "New Label Text"
            }
        }
    }
}</pre>
			<p class="calibre3">When the user taps the button, it changes the <code>labelText</code> state. In this case, SwiftUI generates a new view with a new value for the label (<code>Text</code>) and compares it to the current view hierarchy. Since only <code>Text</code> was changed and the button stayed the same, SwiftUI will only <a id="_idIndexMarker650" class="calibre6 pcalibre pcalibre1"/>update <code>Text</code> and won’t render the whole screen to keep it much more efficient.</p>
			<h2 id="_idParaDest-178" class="calibre7"><a id="_idTextAnchor264" class="calibre6 pcalibre pcalibre1"/>“How do you use the onChange modifier in SwiftUI, and what state changes does it respond to?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">This question is <a id="_idIndexMarker651" class="calibre6 pcalibre pcalibre1"/>important because it assesses our<a id="_idIndexMarker652" class="calibre6 pcalibre pcalibre1"/> understanding of responding<a id="_idIndexMarker653" class="calibre6 pcalibre pcalibre1"/> to state <a id="_idIndexMarker654" class="calibre6 pcalibre pcalibre1"/>changes in SwiftUI. Responding to state changes is a fundamental aspect of building user interfaces in SwiftUI, and an <code>onChange</code> modifier is a key tool to accomplish this task.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">We use the <code>onChange</code> modifier to respond to changes in a specific state variable. When applied to a view, the <code>onChange</code> modifier will execute a closure when the specified state variable changes.</p>
			<p class="calibre3">Look at the following syntax:</p>
			<pre class="source-code">
.onChange(of: stateVariable) { newValue in    // Execute code here
}</pre>
			<p class="calibre3">In this syntax, <code>stateVariable</code> is the name of the state we want to observe, and <code>newValue</code> is the new value of that variable.</p>
			<p class="calibre3">Here are some use cases we can think of for the preceding:</p>
			<ul class="calibre10">
				<li class="calibre11">Updating a view’s layout in response to changes in a user’s input</li>
				<li class="calibre11">Changing the button color when it is tapped</li>
				<li class="calibre11">Updating the layout in response to an environmental change</li>
				<li class="calibre11">Responding to changes in a data model and presenting a banner</li>
				<li class="calibre11">Navigating to a new screen when networking loading has finished</li>
			</ul>
			<p class="calibre3">Here’s an example of the last use case – navigating to a new screen when network loading has finished<a id="_idIndexMarker655" class="calibre6 pcalibre pcalibre1"/> and<a id="_idIndexMarker656" class="calibre6 pcalibre pcalibre1"/> the<a id="_idIndexMarker657" class="calibre6 pcalibre pcalibre1"/> model <a id="_idIndexMarker658" class="calibre6 pcalibre pcalibre1"/>updates:</p>
			<pre class="source-code">
struct ContentView: View {    @StateObject var viewModel = ViewModel()
    @State private var navigateToDetail = false
    var body: some View {
        NavigationView {
            VStack {
                if viewModel.isLoading {
                    ProgressView("Loading...")
                } else {
                    Button("View Detail") {
                        viewModel.loadDetail()
                    }
                }
            }
            .onChange(of: viewModel.detail) { detail in
                if detail != nil {
                    navigateToDetail = true
                }
            }
            .sheet(isPresented: $navigateToDetail) {
                DetailView(detail: viewModel.detail!)
            }
            .navigationBarTitle("Content")
        }
    }
}</pre>
			<p class="calibre3">We can see that the code observes the <code>viewModel</code> detail property, and once it is populated, it <a id="_idIndexMarker659" class="calibre6 pcalibre pcalibre1"/>navigates<a id="_idIndexMarker660" class="calibre6 pcalibre pcalibre1"/> to <a id="_idIndexMarker661" class="calibre6 pcalibre pcalibre1"/>a <a id="_idIndexMarker662" class="calibre6 pcalibre pcalibre1"/>new view.</p>
			<h1 id="_idParaDest-179" class="calibre5"><a id="_idTextAnchor265" class="calibre6 pcalibre pcalibre1"/>Expertise in Combine</h1>
			<p class="calibre3">We already discussed<a id="_idIndexMarker663" class="calibre6 pcalibre pcalibre1"/> declarative programming throughout this chapter, so now, let’s focus on the Combine framework for a second.</p>
			<p class="calibre3">Apple introduced Combine in WWDC 2019 as part of the iOS 13 version. Combine is Apple’s response to other popular reactive frameworks, such as React<a id="_idIndexMarker664" class="calibre6 pcalibre pcalibre1"/> and <strong class="bold">RxSwift</strong>.</p>
			<p class="calibre3">The Combine framework helps developers build reactive applications with robust async operations and data updates.</p>
			<p class="calibre3">There are three main components in Combine:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Publishers</strong>: A publisher <a id="_idIndexMarker665" class="calibre6 pcalibre pcalibre1"/>is an object that emits a stream of values over time. Publishers can be thought of as a source of data, which can come from various sources, such as user input, network requests, or timers. Publishers can emit values of different types, such as integers, strings, or custom data types, and can emit an unlimited number of values or a finite number of values.</li>
				<li class="calibre11"><strong class="bold">Operators</strong>: Operators are functions that can be used to transform, filter, or combine streams of values emitted by publishers. Operators can take one or more publishers as input and return a new publisher that emits transformed values. Some examples of operators are <strong class="source-inline1">map</strong>, <strong class="source-inline1">filter</strong>, <strong class="source-inline1">flatMap</strong>, and <strong class="source-inline1">zip</strong>.</li>
				<li class="calibre11"><strong class="bold">Subscribers</strong>: A subscriber is an object that receives and processes values emitted by a publisher. Subscribers can be considered consumers of data, which can handle the values emitted by a publisher in various ways, such as printing to a console, updating a user interface, or storing in a database. A subscriber can receive values<a id="_idIndexMarker666" class="calibre6 pcalibre pcalibre1"/> of different types, requesting a certain number of values or receiving an unlimited number.</li>
			</ul>
			<p class="calibre3">By combining publishers, operators, and subscribers, we can create powerful data streams between the different parts of our app.</p>
			<p class="calibre3">Let’s see an <a id="_idIndexMarker667" class="calibre6 pcalibre pcalibre1"/>example of Combine usage:</p>
			<pre class="source-code">
import Combinelet numbersPublisher = PassthroughSubject&lt;Int, Never&gt;()
let lettersPublisher = PassthroughSubject&lt;String, Never&gt;()
let cancellable = Publishers
    .combineLatest(numbersPublisher, lettersPublisher)
    .map { (number, letter) -&gt; String in
        return "Number: \(number), Letter: \(letter)"
    }
    .filter { value in
        return value.count &gt; 10
    }
    .sink { value in
        print(value)
    }
numbersPublisher.send(1)
lettersPublisher.send("A")
numbersPublisher.send(2)
lettersPublisher.send("B")</pre>
			<p class="calibre3">In this example, we will demonstrate the different components in Combine, as previously described:</p>
			<ol class="calibre15">
				<li class="calibre11">We have two different publishers (<strong class="source-inline1">numbersPublisher</strong> and <strong class="source-inline1">lettersPublisher</strong>) that send different values over time.</li>
				<li class="calibre11">We <em class="italic">combine</em> these two publishers using the <strong class="source-inline1">combineLatest</strong> operator, which returns a publisher with the two most updated values each time one of the publishers is updated.</li>
				<li class="calibre11">We then <em class="italic">map the values</em> to one string using the <strong class="source-inline1">map</strong> operator, followed by a filter operator that returns only strings with more than 10 characters.</li>
				<li class="calibre11">The <strong class="source-inline1">sink</strong> method helps to <em class="italic">subscribe to the Combine stream</em> and print the output.</li>
			</ol>
			<p class="calibre3">This complex yet interesting Combine stream demonstrates all the different Combine components<a id="_idIndexMarker668" class="calibre6 pcalibre pcalibre1"/> effectively.</p>
			<p class="calibre3">If you want to read more about Combine basics and principles, you can visit <a href="https://developer.apple.com/documentation/combine#" class="calibre6 pcalibre pcalibre1">https://developer.apple.com/documentation/combine#</a>.</p>
			<p class="calibre3">Now, let’s move on to some questions about Combine.</p>
			<h2 id="_idParaDest-180" class="calibre7"><a id="_idTextAnchor266" class="calibre6 pcalibre pcalibre1"/>“Can you provide an example of how you would use Combine in an iOS app?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">The complex <a id="_idIndexMarker669" class="calibre6 pcalibre pcalibre1"/>Combine <a id="_idIndexMarker670" class="calibre6 pcalibre pcalibre1"/>example I just showed you is nice but not very practical, and it’s there only to explain Combine framework principles.</p>
			<p class="calibre3">The real challenge is understanding where to implement Combine in our app architecture in a real-world use case.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">Combine has many real-world use cases. Let’s name some of them:</p>
			<ul class="calibre10">
				<li class="calibre11">Performing <em class="italic">network requests</em> and handling data or errors</li>
				<li class="calibre11">Updating UI elements with <em class="italic">data bindings</em> or state changes</li>
				<li class="calibre11">Validating <em class="italic">user input</em> and showing feedback</li>
				<li class="calibre11">Implementing <em class="italic">MVVM</em> or other architectural patterns</li>
				<li class="calibre11">Working with timers, notifications, <em class="italic">key-value observing</em>, and so on</li>
			</ul>
			<p class="calibre3">Since we are requested to provide an example of where we would use Combine in our app, here’s one where we bind data to UI.</p>
			<p class="calibre3">In the following example, we observe the number of notifications and update the notifications<a id="_idIndexMarker671" class="calibre6 pcalibre pcalibre1"/> button<a id="_idIndexMarker672" class="calibre6 pcalibre pcalibre1"/> with the relevant image:</p>
			<pre class="source-code">
import UIKitimport Combine
class ViewController: UIViewController {
    @IBOutlet weak var notificationsButton: UIButton!
    private var cancellables = Set&lt;AnyCancellable&gt;()
    override func viewDidLoad() {
        super.viewDidLoad()
        let notificationsPublisher = NotificationsManager.
            shared.getNotificationsPublisher()
        notificationsPublisher
            .map { count -&gt; UIImage? in
                if count &gt; 0 {
                    return UIImage(systemName: "bell.
                        fill")?.withTintColor(.red)
                } else {
                    return UIImage(systemName: "bell")
                }
            }
            .assign(to: \.image, on: notificationsButton)
            .store(in: &amp;cancellables)
}</pre>
			<p class="calibre3">In our code example, we can see an excellent binding between data and a specific UI element. This example can also be used for other examples – title updates, color changes, button visibility, and so on.</p>
			<p class="calibre3">Binding data as a <a id="_idIndexMarker673" class="calibre6 pcalibre pcalibre1"/>UI element is also an excellent<a id="_idIndexMarker674" class="calibre6 pcalibre pcalibre1"/> technique in the <em class="italic">MVVM design pattern</em>, where we can bind a state between the view model and the view.</p>
			<p class="calibre3">Now, let’s see a more complex example of how to use Combine – to fetch data from a network request and update a table view while using the MVVM design pattern:</p>
			<pre class="source-code">
import UIKitimport Combine
struct Article: Codable {
    let title: String
    let description: String
    let url: URL
}
class ArticlesViewModel {
    private let url = URL(string: "https://api.example.com/articles")!
    private let decoder = JSONDecoder()
    @Published private(set) var articles: [Article] = []
    init() {
        fetchArticles()
    }
    private func fetchArticles() {
        URLSession.shared.dataTaskPublisher(for: url)
            .map { $0.data }
            .decode(type: [Article].self, decoder: decoder)
            .replaceError(with: [])
            .receive(on: DispatchQueue.main)
            .assign(to: &amp;$articles)
    }
}</pre>
			<p class="calibre3">The <code>fetchArticles()</code> function <a id="_idIndexMarker675" class="calibre6 pcalibre pcalibre1"/>does most of the job while<a id="_idIndexMarker676" class="calibre6 pcalibre pcalibre1"/> requesting data, mapping it, decoding it to the <code>articles</code> array, moving it to the main thread, and assigning the data to the <code>articles</code> <code>published</code> variable.</p>
			<p class="calibre3">Now, let’s look at the view controller:</p>
			<pre class="source-code">
class ArticlesTableViewController: UITableViewController {    private let viewModel = ArticlesViewModel()
    private var cancellables = Set&lt;AnyCancellable&gt;()
    override func viewDidLoad() {
        super.viewDidLoad()
        viewModel.$articles
            .receive(on: DispatchQueue.main)
            .sink(receiveValue: { [weak self] _ in
                self?.tableView.reloadData()
            })
            .store(in: &amp;cancellables)
    }
    override func tableView(_ tableView: UITableView,
        numberOfRowsInSection section: Int) -&gt; Int {
        return viewModel.articles.count
    }
    override func tableView(_ tableView: UITableView,
        cellForRowAt indexPath: IndexPath) -&gt;
            UITableViewCell {
        let cell = tableView.dequeueReusableCell
            (withIdentifier: "ArticleCell", for: indexPath)
        let article = viewModel.articles[indexPath.row]
        cell.textLabel?.text = article.title
        cell.detailTextLabel?.text = article.description
        return cell
    }
}</pre>
			<p class="calibre3">In the view controller, we bind the <code>articles</code> array to the table view by observing changes and reloading the data each time we get an update.</p>
			<p class="calibre3">The last example shows how to use Combine to chain different operators to perform a network request, parsing, moving to the main thread, and handling errors in a few lines of code.</p>
			<p class="calibre3">I think these two <a id="_idIndexMarker677" class="calibre6 pcalibre pcalibre1"/>examples represent many widespread use <a id="_idIndexMarker678" class="calibre6 pcalibre pcalibre1"/>cases with Combine. We should learn them thoroughly, which will help us answer this question efficiently.</p>
			<h2 id="_idParaDest-181" class="calibre7"><a id="_idTextAnchor267" class="calibre6 pcalibre pcalibre1"/>“How do you debug a Combine stream?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">We already know that <a id="_idIndexMarker679" class="calibre6 pcalibre pcalibre1"/>debugging is critical for developers, not only iOS developers.</p>
			<p class="calibre3">Most of our experience with debugging as iOS developers revolves around imperative programming and standard code flows. On the other hand, Combine brings something different to the table, with new challenges in the debugging area.</p>
			<p class="calibre3">In this question, the interviewer wants to hear how we handle Combine issues we may encounter in our job.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">We can debug Combine streams using Xcode built-in debugging tools, such as setting breakpoints, inspecting variables, and stepping through code execution.</p>
			<p class="calibre3">However, the Combine framework offers additional tools to help us debug. Let’s list two of them.</p>
			<h3 class="calibre9">Reading the console with print() and handleEvents()</h3>
			<p class="calibre3">The <code>print</code> operator <a id="_idIndexMarker680" class="calibre6 pcalibre pcalibre1"/>is a debugging<a id="_idIndexMarker681" class="calibre6 pcalibre pcalibre1"/> tool that allows <a id="_idIndexMarker682" class="calibre6 pcalibre pcalibre1"/>us<a id="_idIndexMarker683" class="calibre6 pcalibre pcalibre1"/> to print the events that flow through a Combine pipeline. We can use it to visualize the data transformations and identify unexpected behavior or errors. The <code>print</code> operator can be placed at any point in the pipeline and will print all events that occur downstream of it.</p>
			<p class="calibre3">Here’s an example that demonstrates how to use the <code>print</code> operator:</p>
			<pre class="source-code">
import Combinelet numbers = [1, 2, 3, 4, 5]
let publisher = numbers.publisher
let pipeline = publisher
    .map { $0 * 2 }
    .print("Debug:")
    .filter { $0 % 3 == 0 }
let subscriber = Subscribers.Sink&lt;Int, Never&gt;(
    receiveCompletion: { completion in
        print("Completion: \(completion)")
    },
    receiveValue: { value in
        print("Value: \(value)")
    }
)</pre>
			<p class="calibre3">In this <a id="_idIndexMarker684" class="calibre6 pcalibre pcalibre1"/>example, we <a id="_idIndexMarker685" class="calibre6 pcalibre pcalibre1"/>use<a id="_idIndexMarker686" class="calibre6 pcalibre pcalibre1"/> the <code>print</code> operator<a id="_idIndexMarker687" class="calibre6 pcalibre pcalibre1"/> to label the debug output with <code>"Debug:"</code>. This will help us distinguish the debug logs from any other output in the console. When we run this code, we will see the following output in the console:</p>
			<pre class="source-code">
Debug: receive subscription: (Sequence)Debug: request unlimited
Debug: receive value: (2)
Debug: receive value: (6)
Debug: receive value: (10)
Completion: finished</pre>
			<p class="calibre3">The <code>handleEvents</code> operator is similar to the <code>print</code> operator, but instead of printing the events, it allows us to trigger side effects at specific points in the pipeline.</p>
			<p class="calibre3">We can use it to perform actions such as logging, updating UI elements, or triggering notifications. The <code>handleEvents</code> operator can be placed at any point in the pipeline, and it will trigger the side effects for all events that occur downstream of it.</p>
			<p class="calibre3">Here’s an <a id="_idIndexMarker688" class="calibre6 pcalibre pcalibre1"/>example<a id="_idIndexMarker689" class="calibre6 pcalibre pcalibre1"/> that <a id="_idIndexMarker690" class="calibre6 pcalibre pcalibre1"/>demonstrates<a id="_idIndexMarker691" class="calibre6 pcalibre pcalibre1"/> how to use the <code>handleEvents</code> operator:</p>
			<pre class="source-code">
let pipeline = publisher    .map { $0 * 2 }
    .handleEvents(
        receiveSubscription: { subscription in
            print("Subscription: \(subscription)")
        },
        receiveOutput: { output in
            print("Output: \(output)")
        },
        receiveCompletion: { completion in
            print("Completion: \(completion)")
        },
        receiveCancel: {
            print("Cancelled")
        }
    )
    .filter { $0 % 3 == 0 }</pre>
			<p class="calibre3">With the <code>handleEvents</code> operator, we can print each event separately and have complete<a id="_idIndexMarker692" class="calibre6 pcalibre pcalibre1"/> control <a id="_idIndexMarker693" class="calibre6 pcalibre pcalibre1"/>of <a id="_idIndexMarker694" class="calibre6 pcalibre pcalibre1"/>our <a id="_idIndexMarker695" class="calibre6 pcalibre pcalibre1"/>printing operations.</p>
			<h3 class="calibre9">Including breakpoints in our stream</h3>
			<p class="calibre3">The Combine framework <a id="_idIndexMarker696" class="calibre6 pcalibre pcalibre1"/>provides additional operators to generate breakpoints in our streams.</p>
			<p class="calibre3">The first and primary operator is <code>breakpoint()</code>, which can help us pause a program at specific events, similar to <code>handleEvents()</code>:</p>
			<pre class="source-code">
let pipeline = publisher    .map { $0 * 2 }
    .breakpoint(
        receiveSubscription: { subscription in
            return false
        },
        receiveOutput: { output in
            print("Output: \(output)")
            return output &gt; 8
        },
        receiveCompletion: { completion in
            return true
        }
    )
    .filter { $0 % 3 == 0 }</pre>
			<p class="calibre3">In this code, we pause the program on completion or when the output is bigger than eight by returning <code>true</code> in the corresponding places.</p>
			<p class="calibre3">The second breakpoint operator is <code>breakpointOnError()</code>, which pauses the program when any of the upstream publishers throws an error:</p>
			<pre class="source-code">
let pipeline = publisher    .tryMap { value -&gt; Int in
        if value == 4 {
            throw ExampleError.example
        }
        return value * 2
    }
    .breakpointOnError()
    .filter { $0 % 3 == 0 }</pre>
			<p class="calibre3">This example is simple – the <code>tryMap</code> operator throws an error. Therefore, the program will pause, thanks<a id="_idIndexMarker697" class="calibre6 pcalibre pcalibre1"/> to the <code>breakpointOnError()</code> command.</p>
			<p class="calibre3">Both <code>breakpoint()</code> and <code>breakpointOnError()</code> are great ways to pause a program when we need to perform deep Combine issue investigations.</p>
			<h1 id="_idParaDest-182" class="calibre5"><a id="_idTextAnchor268" class="calibre6 pcalibre pcalibre1"/>Summary</h1>
			<p class="calibre3">In this chapter, we went over critical topics in declarative programming, SwiftUI, and Combine. We discussed the SwiftUI life cycle, debugging Combine, real-world examples, navigation, and states. By now, we should be fully covered for our interview when asked about SwiftUI and Combine.</p>
			<p class="calibre3">The next chapter is a bit different. We will discuss a critical layer in our architecture – the data layer and, specifically, the persistent data layer.</p>
		</div>
	</body></html>