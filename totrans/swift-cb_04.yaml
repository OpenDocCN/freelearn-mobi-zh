- en: Generics, Operators, and Nested Types
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型、运算符和嵌套类型
- en: 'Swift provides a number of advanced features for building functionality that
    is flexible but well defined so that it feels like you are extending the language
    itself. In this chapter, we will examine two of these features: **generics** and
    **operators**. We will also see how nested types allow logical grouping, access
    control, and namespacing for your constructs.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 提供了许多高级功能来构建灵活但定义良好的功能，这样它感觉就像是在扩展语言本身。在本章中，我们将检查其中两个功能：**泛型**和**运算符**。我们还将看到嵌套类型如何允许逻辑分组、访问控制和命名空间。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Using generics with types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用泛型与类型
- en: Using generics with functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用泛型与函数
- en: Using generics with protocols
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用泛型与协议
- en: Using advanced operators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高级运算符
- en: Defining option sets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义选项集
- en: Creating custom operators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义运算符
- en: Nesting types and namespacing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套类型和命名空间
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code for this chapter can be found in this book's GitHub repository
    at [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter04](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter04)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码都可以在这本书的 GitHub 仓库中找到：[https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter04](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter04)
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/39I7wuy](https://bit.ly/39I7wuy)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：[https://bit.ly/39I7wuy](https://bit.ly/39I7wuy)
- en: Using generics with types
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用泛型与类型
- en: When we build things in Swift that interact with other types, we often specify
    the type we are interacting with directly. This is helpful because it means we
    know the capabilities that the type has; we can put those capabilities to use
    and ensure that the outputs have the correct type. However, we now have a construct
    that can only interact with the specified type; it can't be reused with other
    types, even if the concepts are the same.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 Swift 中构建与其他类型交互的东西时，我们通常会直接指定我们正在与之交互的类型。这很有帮助，因为它意味着我们知道该类型具有哪些功能；我们可以使用这些功能，并确保输出具有正确的类型。然而，我们现在有一个只能与指定类型交互的构造；即使概念相同，它也不能与其他类型重用。
- en: '**Generics** give us the advantage of having a defined type while being generically
    applicable to other types. It is, perhaps, best illustrated with an example.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**泛型**让我们在泛型适用其他类型的同时拥有一个定义的类型。这或许可以通过一个例子来最好地说明。'
- en: In this recipe, we will create a generic class that stores the last five things
    it was given and returns them all upon request.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将创建一个泛型类，该类存储它最后接收的五个项目，并在请求时返回所有这些项目。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will create a custom collection object that will store the last five strings
    that the user copied so that they can paste not just the last string copied, but
    any of the last five. You can add strings to the list and ask for all the strings
    in the list, which will be returned newest to oldest:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个自定义集合对象，该对象将存储用户最后复制的五个字符串，以便他们可以粘贴不仅仅是最后复制的字符串，而是最后五个中的任何一个。你可以向列表中添加字符串，并请求列表中的所有字符串，这些字符串将按最新到最旧的顺序返回：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is great – it does just what we want. Now, let''s say that we want to
    add a list of five recent contacts to a contacts app. The concept is exactly the
    same as the list of copied strings, as we want to do the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这很棒——它正是我们想要的。现在，假设我们想在联系人应用中添加五个最近联系人的列表。这个概念与复制的字符串列表完全相同，因为我们想做到以下事情：
- en: Add something to a list.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向列表中添加内容。
- en: Get all the things on the list so that we can present them to the user.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取列表上的所有内容，以便我们可以向用户展示。
- en: However, because we specified that the `RecentList` object can only work with
    strings, it can't work with my custom `Person` object. We can use generics to
    make this more useful.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，因为我们指定了 `RecentList` 对象只能与字符串一起工作，所以它不能与我的自定义 `Person` 对象一起工作。我们可以使用泛型使这更有用。
- en: Let's see how to do this by making `RecentList` use generics.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使 `RecentList` 使用泛型来看看如何做到这一点。
- en: How to do it...
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'We will update our `RecentList` code to use generics, so it can be used with
    other types:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新我们的 `RecentList` 代码以使用泛型，使其可以与其他类型一起使用：
- en: 'Amend the `RecentList` object to define a generic type, `ListItemType`, which
    we use in place of `String`:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `RecentList` 对象以定义一个泛型类型 `ListItemType`，我们用它来代替 `String`：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Provide a specified type, `String`, when creating `RecentList`, which will
    be used to replace the generic type for this instance of `RecentList`:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建 `RecentList` 时提供指定的类型 `String`，这将用于替换此 `RecentList` 实例的泛型类型：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Instead of using generics, we could have replaced all the `String` references
    in `RecentlList` with `Any`, which would allow it to accept any type. However,
    this would allow the list to be made up of different types of things, which is
    not what we want. It would also require us to cast values that are returned, to
    make them useful.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以用泛型来替换 `RecentlList` 中的所有 `String` 引用为 `Any`，这样它就可以接受任何类型。然而，这将允许列表由不同类型的事物组成，这并不是我们想要的。它还要求我们对返回的值进行类型转换，以便它们变得有用。
- en: Let's examine how our newly genericized `RecentList` can be used for the other
    example we discussed earlier, the list of recent contacts.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来探讨一下如何将我们新泛化的 `RecentList` 用于我们之前讨论过的其他例子，即最近联系人的列表。
- en: 'Create a simple `Person` object:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的 `Person` 对象：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create some people to add to our recent contact list:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一些人员以添加到我们的最近联系人列表中：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create a new `RecentList`, providing the specific `Person` type:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `RecentList`，提供具体的 `Person` 类型：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add person objects to this list:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向此列表添加人员对象：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Get all the people in the list, and since this is typed as an array of `Person`
    objects, print their `name` property:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取列表中所有人，由于这被类型化为 `Person` 对象的数组，因此打印它们的 `name` 属性：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We now have a generic `RecentList` class that we have used with both strings
    and a custom `Person` class.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个泛型 `RecentList` 类，我们已用它与字符串和自定义的 `Person` 类一起使用。
- en: How it works...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To add generics to a `class` or `struct`, the generic type is defined in angle
    brackets after the class or struct name, and can be given any type name, although
    it should begin with a *capital letter* like other type names:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要将泛型添加到 `class` 或 `struct` 中，泛型类型在类或结构体名称之后用尖括号定义，并且可以给出任何类型名称，尽管它应该以一个 *大写字母*
    开头，就像其他类型名称一样：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This generic type now becomes a stand-in for the specific type that will be
    specified when it is used, and we can use this wherever we would use the specific
    type.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个泛型类型现在成为了一个替代品，用于在它被使用时指定的具体类型，我们可以在任何使用具体类型的地方使用它。
- en: 'It can be used as a property type:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以用作属性类型：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As a parameter value:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参数值：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And as a return type:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以及作为返回类型：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In many other programming languages that have a generics system, the generic
    type is often given a one-letter type name, usually `T`. Swift aims to be concise,
    but not at the expense of clarity, so I suggest using a more descriptive type
    name.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多拥有泛型系统的其他编程语言中，泛型类型通常被赋予一个单字母的类型名称，通常是 `T`。Swift 旨在简洁，但又不失清晰，所以我建议使用更具描述性的类型名称。
- en: 'A descriptive type name becomes especially important if you have multiple generic
    types, which you can have as a comma-separated list within the angle brackets:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有多个泛型类型，这在尖括号内可以用逗号分隔的列表表示，描述性类型名称就变得尤为重要：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have now created a generic `RecentList` object that can be used with any
    type.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在创建了一个泛型 `RecentList` 对象，它可以与任何类型一起使用。
- en: There's more...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: While being extremely generic has its advantages, you may wish to constrain
    which types can be used for the generic type, especially if you need to use some
    features of that constrained type.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然极端泛型有其优点，但你可能希望限制可以用于泛型类型的类型，特别是如果你需要使用该受限类型的某些功能。
- en: 'Let''s say that in addition to returning an array of items from `RecentList`,
    we want to be able to print out the list directly. To do this, we need to ensure
    that the type of item used in `RecentList` is something that can be converted
    into a *string* to be printed. There is already a `CustomStringConvertible` protocol
    that defines this behavior, so we want to ensure that any specific type used with
    `RecentList` conforms to `CustomStringConvertible`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 假设除了从 `RecentList` 返回一个项目数组外，我们还想能够直接打印出列表。为此，我们需要确保在 `RecentList` 中使用的项目类型是可以转换为要打印的
    *字符串* 的。已经有一个 `CustomStringConvertible` 协议定义了这种行为，因此我们想确保任何与 `RecentList` 一起使用的特定类型都符合
    `CustomStringConvertible`：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We add the constraint after the generic type name, separated by a colon, similar
    to how we specify protocol conformance and class inheritance. Indeed, while this
    example constrains the generic type to implement a protocol, we can instead specify
    a class that the specific type must be, or inherit from.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在泛型类型名称之后添加约束，用冒号分隔，类似于我们指定协议符合性和类继承的方式。实际上，虽然这个例子将泛型类型约束为实现一个协议，我们也可以指定一个特定类型必须是或继承自的类。
- en: 'Now that we have this constraint, we can be sure that any specific type given
    will conform to `CustomStringConvertible`, and will therefore have a `description`
    string that we can print, so let''s create a method to do that:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个约束，我们可以确信任何给定的特定类型都将符合`CustomStringConvertible`，因此将有一个可以打印的`description`字符串，所以让我们创建一个方法来做这件事：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The only thing left to do is to make our `Person` class conform to `CustomStringConvertible`
    so that it can continue to be used as a specific type in `RecentList`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一事情就是让我们的`Person`类符合`CustomStringConvertible`，以便它可以在`RecentList`中继续作为特定类型使用：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we can use this functionality with our `String` type''s `RecentlyList`
    and our `Person` type''s `RecentList`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用我们的`String`类型的`RecentlyList`和我们的`Person`类型的`RecentList`来使用此功能：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: By constraining the generic type, we could use features that we knew the type
    would have, to provide additional functionality.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过约束泛型类型，我们可以使用我们知道类型将具有的功能，以提供额外的功能。
- en: See also
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Further information about generic types can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/generics](http://swiftbook.link/docs/generics).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于泛型类型的信息可以在苹果关于Swift语言的文档中找到，请参阅[http://swiftbook.link/docs/generics](http://swiftbook.link/docs/generics)。
- en: Using generics with functions
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用泛型与函数
- en: In addition to being able to specify generic types, you can use generics to
    build functions that are both widely applicable and strongly typed. In this recipe,
    we will use generics with functions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可以指定泛型类型外，您还可以使用泛型构建既广泛适用又强类型的函数。在这个菜谱中，我们将使用泛型与函数。
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'We will use generics to create a function to help with placing values into
    a dictionary:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用泛型创建一个函数来帮助将值放入字典中：
- en: 'Create a generic function that inserts the same value into a dictionary for
    multiple keys:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个泛型函数，将相同的值插入字典的多个键中：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Use this function, passing in a single value and multiple keys, and the value
    is stored against each of the given keys:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此函数，传入单个值和多个键，值将存储在每个给定的键中：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Just like generics for types, the generic type for a function is specified
    within angle brackets:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 就像类型泛型一样，函数的泛型类型在尖括号内指定：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The defined generic type name can then be used as a type definition within the
    rest of the function definition. In our example, we want to define the type of
    our input item to be duplicated, and we also want the values that are held in
    the dictionary to be returned to be of the same type.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 定义好的泛型类型名称可以在函数定义的其余部分用作类型定义。在我们的例子中，我们希望定义输入项的类型为要复制的类型，并且我们还想让字典中持有的值返回的类型相同。
- en: 'Instead of using generics, we could have used the `Any` type in place of the
    generic type:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用泛型，我们可以用`Any`类型代替泛型类型：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, this approach presents a few problems for anyone using this function:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法给使用此函数的人带来了一些问题：
- en: They will get back a dictionary containing values of the `Any` type, which will
    need to be cast to a more useful type.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们将得到一个包含`Any`类型值的字典，这需要被转换为一个更有用的类型。
- en: Without seeing the implementation, they can't be sure that the dictionary contains
    values of the same type. One key may have a `String` stored against it, and another
    may have an `Int`.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有看到实现，他们不能确定字典包含相同类型的值。一个键可能存储了一个`String`，另一个键可能存储了一个`Int`。
- en: Without seeing the implementation, they can't be sure that the values of the
    returned dictionary are of the same type as the item provided.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有看到实现，他们不能确定返回字典中的值与提供的项具有相同的类型。
- en: By using a generic type, we allow the functionality to be widely applicable
    while enforcing our type logic at compile time.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用泛型类型，我们允许功能广泛适用，同时在编译时强制执行我们的类型逻辑。
- en: 'You''ll notice that unlike instantiating a type with generics, we don''t need
    to explicitly state the specific type to use when executing the function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，与使用泛型实例化类型不同，我们不需要在执行函数时明确指定要使用的特定类型：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is because the compiler is able to infer it from the type of the first
    parameter provided. Since `Parasite` is a string, and the compiler knows that
    the parameter has the `ItemType` generic type, the compiler infers that for this
    use of the method, the `ItemType` generic type becomes the specific type of `String`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为编译器能够从提供的第一个参数的类型推断它。由于`Parasite`是一个字符串，编译器知道该参数具有`ItemType`泛型类型，因此编译器推断出，对于此方法的使用，`ItemType`泛型类型成为`String`的具体类型。
- en: There's more...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We can increase the usability of our function by providing a generic type for
    the set of keys we provide as the second parameter:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过提供作为第二个参数提供的键集合的泛型类型来提高我们函数的可用性：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Multiple generic types are defined just as they were in the previous recipe,
    as a comma-separated list within the angle brackets.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类型定义与先前的食谱中一样，作为尖括号内的逗号分隔列表。
- en: All the collection types in Swift (array, dictionary, set, and so on) use generics,
    and in the preceding function, we are passing the generic type from our function
    into the set. Therefore, `KeyType` must conform to `Hashable`, since this is required
    for use in a `Set`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Swift中的所有集合类型（数组、字典、集合等）都使用泛型，在先前的函数中，我们将泛型类型从我们的函数传递到集合中。因此，`KeyType`必须符合`Hashable`协议，因为这是在`Set`中使用所必需的。
- en: 'If we wanted to make this constraint explicit or constrain the generic type
    for some other reason, this is defined after a colon:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使这个约束更明确，或者出于其他原因对泛型类型进行约束，那么这个约束定义在冒号之后：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Just as with the previous example, if both specific types we are using can
    be inferred from the input or output, we don''t need to specify it:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如先前的例子一样，如果我们使用的具体类型可以从输入或输出中推断出来，我们就不需要指定它：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We have used two generic types to improve the flexibility of our function.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了两个泛型类型来提高函数的灵活性。
- en: See also
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Further information about generic functions can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/generic-functions](http://swiftbook.link/docs/generic-functions).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于泛型函数的信息可以在Apple关于Swift语言的文档中找到，请参阅[http://swiftbook.link/docs/generic-functions](http://swiftbook.link/docs/generic-functions)。
- en: Using generics with protocols
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用协议与泛型结合
- en: So far in this chapter, we have seen how to use generics within types and functions.
    In this recipe, we will round off our journey through generics in Swift by looking
    at how they can be used in protocols. This will allow us to produce abstract interfaces
    while maintaining strongly typed requirements that allow for a more descriptive
    model.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经看到了如何在类型和函数中使用泛型。在本食谱中，我们将通过查看它们如何在协议中使用来结束我们在Swift中使用泛型的旅程。这将允许我们产生抽象接口，同时保持强类型要求，从而允许更详细的模型。
- en: In this recipe, we will build a model for a transport app in the UK with the
    goal of providing the distance and duration of a journey for different methods
    of transport.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将构建一个英国交通应用模型，目标是提供不同运输方式的旅程距离和持续时间。
- en: How to do it...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'The ways that people travel can be very different, so let''s start by defining
    transport methods in a generic way, and then specify what those travel methods
    are:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 人们的旅行方式可能非常不同，所以让我们首先以泛型方式定义运输方式，然后指定那些旅行方法：
- en: 'Define a protocol to define the features of a transport method:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个协议来定义运输方式的功能：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create a struct for traveling by train that implements the `TransportMethod`
    protocol:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个实现`TransportMethod`协议的用于火车旅行的结构体：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We need to define the `TrainStation` type that we put as `CollectionPoint`.
    Let''s do that as an enum:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要定义一个`TrainStation`类型，将其作为`CollectionPoint`使用。让我们以枚举的形式来完成它：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Since we plan to calculate the distance and duration of a journey, let''s create
    a `Journey` object to represent that journey from a starting point to an endpoint:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们计划计算旅程的距离和持续时间，让我们创建一个`Journey`对象来表示从起点到终点的旅程：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add the transport method as a property of the journey as this will be used
    for the duration calculation:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将运输方式作为旅程的一个属性添加，因为这将被用于持续时间计算：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To calculate the distance of our journey, we need the start and end to have
    definite locations. So, define a protocol that provides this location:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了计算旅程的距离，我们需要起始点和终点有明确的位置。因此，定义一个协议来提供这个位置：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Import the `CoreLocation` framework at the top of the playground:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在游乐场的顶部导入`CoreLocation`框架：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Constrain `CollectionPoint` associated type on `TransportMethod`, so that it
    must conform to the `TransportLocation` protocol we have just created:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TransportMethod`上约束`CollectionPoint`关联类型，使其必须符合我们刚刚创建的`TransportLocation`协议：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Use the location on the start and end of the `CollectionPoint` to calculate
    the distance and duration of the journey:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`CollectionPoint`的起始和结束位置来计算旅程的距离和持续时间：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Ensure our `TrainStation` enum conforms to `TransportLocation`, which is now
    a requirement:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保我们的`TrainStation`枚举符合`TransportLocation`协议，这是现在的要求：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Use our `Journey` object to calculate the distance and duration of a train
    journey:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们的`Journey`对象来计算火车旅程的距离和持续时间：
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'At the outset, it may not be clear which is the best structure to use to define
    a transport method, and there might be different structures appropriate for different
    travel methods. Therefore, we can define a transport method as a protocol that
    appropriate types can conform to:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在一开始，可能不清楚使用哪种结构来定义传输方法最好，可能存在适用于不同旅行方法的不同结构。因此，我们可以定义一个传输方法为一种协议，适当的类型可以符合：
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We define an associated generic type that we name `CollectionPoint`, which will
    represent the type of location that someone can be collected from when using this
    transport method. By using generics, we have ultimate flexibility in how a transport
    method chooses to define what can serve as a collection point.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个关联的泛型类型，我们将其命名为`CollectionPoint`，它将代表在使用此传输方法时某人可以被收集的类型。通过使用泛型，我们在如何定义可以作为集合点的任何内容方面具有最大的灵活性。
- en: Having defined an associated type, it can then be used as a placeholder in properties
    and methods for the specific type that will be defined when the protocol is used.
    We use it to define a default collection point that each transport method should
    provide.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了一个关联类型后，它就可以在协议使用时定义的具体类型中作为占位符使用。我们用它来定义每个传输方法应该提供的一个默认集合点。
- en: Each transport method also provides an average speed, which will be used later
    in calculating the travel time.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 每个传输方法还提供了一个平均速度，这将在计算旅行时间时被使用。
- en: 'Let''s look at a concrete example of a transport method to help define the
    model further:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个具体的传输方法示例，以帮助进一步定义模型：
- en: '[PRE37]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For `Train` to conform to the `TransportMethod` protocol, we must provide a
    specific version of the `CollectionPoint` generic type that is required by the
    protocol. In the case of traveling by train, the collection point will be a train
    station, so we now have to define the `TrainStation` type:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`Train`符合`TransportMethod`协议，我们必须提供一个协议所需的特定版本的`CollectionPoint`泛型类型。在乘坐火车旅行的情况下，集合点将是一个火车站，因此我们现在必须定义`TrainStation`类型：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Since there are a finite number of train stations that are discretely definable,
    an `enum` is a good way to represent them. I've only listed a small number above,
    for brevity.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于火车站的数量是有限的，并且可以离散地定义，所以`enum`是一个表示它们的良好方式。我上面只列出了少数几个，为了简洁。
- en: 'Our goal is to model a journey and calculate the duration of the journey over
    specific transport methods, so let''s create a `Journey` object:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目的是模拟一个旅程并计算在特定传输方法上的旅程持续时间，所以让我们创建一个`Journey`对象：
- en: '[PRE39]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: A journey takes place from one point to another, so we take the journey's start
    and end as input parameters. We need to have the flexibility to provide any type
    as the start and end, but we need them to be types connected to a transport method,
    with the same type for the start and end values. To accomplish this, we can have
    a generic type constrained to conform to the `TransportMethod` protocol; we can
    then define our start and end property types by referencing the `CollectionPoint`
    associated type of the generic type.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 旅程是从一个点到另一个点，因此我们将旅程的起点和终点作为输入参数。我们需要有灵活性来提供任何类型作为起点和终点，但我们需要它们是与传输方法相关联的类型，起点和终点的值类型相同。为了实现这一点，我们可以有一个泛型类型，它被约束为符合`TransportMethod`协议；然后我们可以通过引用泛型类型的`CollectionPoint`关联类型来定义我们的起点和终点属性类型。
- en: 'Our goal is to calculate the duration of a journey. To do this, we will need
    the speed of travel during the journey and the distance from start to end. Our
    `TransportMethod` protocol defines that it will provide an average speed, so let''s
    also take the transport method as an input to our journey:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是计算旅程的持续时间。为此，我们需要旅程中的旅行速度和起点到终点的距离。我们的`TransportMethod`协议定义了它将提供一个平均速度，所以让我们也将传输方法作为旅程的输入：
- en: '[PRE40]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: To get the distance of the journey, we need to calculate the distance between
    the start and end, but the type of both the start and end of the journey is the
    generic `CollectionPoint` type, which could be any type, and so does not have
    any location information that we can use to calculate distance.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取旅程的距离，我们需要计算起点和终点之间的距离，但旅程的起点和终点的类型都是泛型`CollectionPoint`类型，这可以是任何类型，因此没有我们可以用来计算距离的位置信息。
- en: 'To solve this, let''s constrain `CollectionPoint` so that it must conform to
    a new protocol, `TransportLocation`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，让我们约束`CollectionPoint`，使其必须符合一个新的协议`TransportLocation`：
- en: '[PRE41]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Anything conforming to `TransportLocation` must provide a location in the form
    of a `CLLocation` object. The `CLLocation` object is part of the `CoreLocation`
    framework on iOS. Further investigation of the `CoreLocation` framework is outside
    the scope of this book, but it''s enough to know that it provides ways to calculate
    the distance between two `CLLocation` objects, and we need to include the following
    at the top of this playground to use it:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 任何符合`TransportLocation`的都必须以`CLLocation`对象的形式提供一个位置。`CLLocation`对象是iOS上`CoreLocation`框架的一部分。对`CoreLocation`框架的进一步研究超出了本书的范围，但只需知道它提供了计算两个`CLLocation`对象之间距离的方法，我们只需要在playground的顶部包含以下内容来使用它：
- en: '[PRE42]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'With our `TransportLocation` protocol defined, we can constrain the `CollectionPoint`
    associated type on the `TransportMethod` protocol:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了`TransportLocation`协议之后，我们可以在`TransportMethod`协议上约束`CollectionPoint`关联类型：
- en: '[PRE43]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Since our `CollectionPoint` will now conform to `TransportLocation`, and therefore
    must have a location property, we can go back to our `Journey` object and use
    this to calculate the distance of the journey and the duration:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的`CollectionPoint`现在将符合`TransportLocation`，因此必须有一个位置属性，我们可以回到我们的`Journey`对象并使用它来计算行程的距离和持续时间：
- en: '[PRE44]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The last thing we need to do is to ensure that our `TrainStation` enum conforms
    to `TransportLocation` as this is now a requirement. To do this, we just need
    to declare conformance and add a `location` property:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是确保我们的`TrainStation`枚举符合`TransportLocation`，因为现在这是一个要求。为此，我们只需要声明符合性并添加一个`location`属性：
- en: '[PRE45]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s see how we would use our travel model to create a journey with specific
    types:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用我们的旅行模型来创建具有特定类型的行程：
- en: '[PRE46]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We have used generics with protocols to create a generic system without prescribing
    the type of Swift construct we need to use.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用泛型和协议创建了一个泛型系统，而没有规定我们需要使用的Swift构造类型。
- en: There's more...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this recipe, we made one type conform to `TransportMethod` – this was our
    `Train` struct. Let's look at another to see how tackling things in a protocol-oriented
    way allows flexibility in implementation.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使一个类型符合`TransportMethod`——这是我们`Train`结构体。让我们看看另一个例子，看看以协议为中心的方式处理事物如何允许实现上的灵活性。
- en: 'In the next `TransportMethod`, we will implement `Road`, but there are a number
    of different vehicle types that we can use to travel by road, and they may have
    different average speeds. Since we have a finite list of options for travel by
    road, let''s define it using an `enum`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个`TransportMethod`中，我们将实现`Road`，但我们可以使用多种不同的车辆类型通过公路旅行，它们可能有不同的平均速度。由于我们有有限的公路旅行选项，让我们使用一个`enum`来定义它：
- en: '[PRE47]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'A journey by train has a finite list of collection points, which is the train
    stations but almost anywhere can be a collection point when traveling by road.
    Therefore, we can define the collection point for `Road` to be any `CLLocation`,
    but `CLLocation` doesn''t conform to `TransportLocation`. We can solve this by
    extending `CLLocation` to add conformance:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 火车旅行有一个有限的集合点列表，即火车站，但几乎任何地方在公路旅行时都可以是一个集合点。因此，我们可以将`Road`的集合点定义为任何`CLLocation`，但`CLLocation`不符合`TransportLocation`。我们可以通过扩展`CLLocation`来添加符合性来解决此问题：
- en: '[PRE48]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, we can define a journey by road and calculate the duration:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过道路定义一次行程并计算其持续时间：
- en: '[PRE49]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: By taking a protocol-orientated approach to tackling the task of calculating
    a journey's duration, and by using protocol generics, we were able to use completely
    different, but appropriate, implementations for two transport methods while providing
    an interface so that they can be handled in a common way.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用面向协议的方法来解决计算行程持续时间的任务，并使用协议泛型，我们能够使用完全不同但适当的实现来处理两种运输方式，同时提供了一个接口，以便它们可以以相同的方式进行处理。
- en: For a train journey, we used an `enum` to model the train stations and a `struct`
    to model the transport method, and for `road,` we implemented an `enum` for the
    transport method and used the `CLLocation` object for the transport location.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于火车旅行，我们使用一个`enum`来模拟火车站，并使用一个`struct`来模拟运输方式；对于`road`，我们实现了一个`enum`来表示运输方式，并使用`CLLocation`对象作为运输位置。
- en: See also
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Further information about associated types can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/associated-types](http://swiftbook.link/docs/associated-types).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于关联类型的信息可以在Apple的Swift语言文档中找到，链接为[http://swiftbook.link/docs/associated-types](http://swiftbook.link/docs/associated-types)。
- en: Using advanced operators
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用高级运算符
- en: Swift is a programming language that takes a relatively small number of well-defined
    principles and builds on them to create expressive and powerful language features.
    The concept of mathematical operators, such as *+*, *-*, ***, and */* for addition,
    subtraction, multiplication, and division, respectively, seems so fundamental
    as to not warrant a mention. However, in Swift, this common mathematical functionality
    is built on top of an underlying operator system that is extensible and powerful.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Swift是一种编程语言，它采用相对较少的明确定义的原则，并在此基础上构建出表达性和强大的语言特性。数学运算符的概念，如*+*、*-*、***和*/*分别用于加法、减法、乘法和除法，似乎如此基本，以至于无需提及。然而，在Swift中，这种常见的数学功能是建立在可扩展和强大的底层运算符系统之上的。
- en: In this recipe, we will look at some of the more advanced operators provided
    by the Swift standard library, and in the next recipe, we will create our own
    custom operators.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将查看Swift标准库提供的某些更高级的运算符，在下一个菜谱中，我们将创建我们自己的自定义运算符。
- en: How to do it...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: The operators we will explore are known as bitwise operators and are used to
    manipulate numerical bit representations.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探索的运算符被称为位运算符，用于操作数值的位表示。
- en: 'An integer value in Swift can be represented in its binary form by prefixing
    the integer literal with `0b`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，可以通过在整型字面量前加上`0b`来表示整数的二进制形式：
- en: '[PRE50]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: A bit is the smallest value in a computer system, consisting of either a 1 or
    0\. The integers mentioned here can be represented by three bits, which are clearly
    visible when represented in binary form, as illustrated in the preceding snippet.
    The integer `six` can be represented by the three bits 1, 1, and 0.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 位是计算机系统中最小的值，由1或0组成。这里提到的整数可以用三个位来表示，这在二进制形式中非常明显，如前一个片段所示。整数`six`可以用三个位1、1和0来表示。
- en: 'These binary representations are really useful when you need to represent multiple
    options in one value. For example, let''s say that we want to indicate which devices
    are supported for a specific feature of an app. The available devices are as listed:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要在一个值中表示多个选项时，这些二进制表示非常有用。例如，假设我们想表示一个应用程序特定功能的受支持设备。可用的设备如下所示：
- en: Phone
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手机
- en: Tablet
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平板电脑
- en: Watch
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手表
- en: Laptop
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 笔记本电脑
- en: Desktop
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桌面
- en: TV
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电视
- en: Brain implant
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脑植入
- en: Certain features may be appropriate for all the devices, or you may still be
    working on a feature, and so it isn't currently appropriate for any device, or
    it may be a combination of different devices. We can have Boolean values for each
    of the devices to indicate whether the feature is supported for that device, but
    this is not the best solution as there is nothing intrinsically tying the properties
    to each other, and you can forget to update some of the values as circumstances
    change.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 某些功能可能适用于所有设备，或者你可能仍在开发一个功能，因此目前不适合任何设备，或者它可能是不同设备的组合。我们可以为每个设备有布尔值来表示该功能是否支持该设备，但这不是最佳解决方案，因为没有内在地将属性相互关联，并且你可能忘记在情况变化时更新一些值。
- en: 'Instead, we can represent all the supported devices with one integer value,
    and use each bit of the integer to represent a different device:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以用一个整数值来表示所有受支持的设备，并使用整数的每一位来表示不同的设备：
- en: '[PRE51]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To see how this enables us to store multiple devices in one value, let''s add
    together a number of device values:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要看看这如何使我们能够在单个值中存储多个设备，让我们将几个设备值相加：
- en: '[PRE52]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As each device is represented by a different bit, the device values are combined
    by adding the values, and they don't overlap.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个设备都由不同的位表示，设备值通过相加来组合，它们不会重叠。
- en: 'To test whether a particular device or combination of devices is supported,
    we can use a bitwise **AND** operation. A bitwise AND operation will compare the
    corresponding bits for two different binary values and will set that bit to 1
    in a new binary value if both bit input values are 1\. As an example, let''s test
    whether phones are supported in the combined value we created earlier:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试特定的设备或设备组合是否受支持，我们可以使用位运算的**AND**操作。位运算AND操作将比较两个不同二进制值对应的位，如果两个位输入值都是1，则在新二进制值中将该位设置为1。例如，让我们测试我们之前创建的合并值中是否支持手机：
- en: '[PRE53]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The result only has a 1-bit value for the rightmost bit because this is the
    only bit that was set to 1 in both the `Supported Devices` value and the `Phone`
    value.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 结果只对最右边的位有1位的值，因为这是在`Supported Devices`值和`Phone`值中唯一被设置为1的位。
- en: 'Once we have that result, we can directly compare it to the value for `Phone`,
    and if they are equal, then we know that the value of the supported devices included
    the `Phone` value:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们得到这个结果，我们可以直接将其与 `Phone` 的值进行比较，如果它们相等，那么我们知道支持的设备值中包含了 `Phone` 值：
- en: '[PRE54]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We now have a way to combine the possible options into one value, and a way
    to compare those values to see whether one is contained in another, using bitwise
    operations. The Swift standard library contains bitwise operators that allow us
    to perform these operations as easily as other mathematical operations, such as
    *+*, *-*, ***, and */*.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一种将可能的选项组合成一个值的方法，以及一种通过位运算比较这些值以查看一个是否包含在另一个中的方法。Swift 标准库包含位运算符，允许我们像其他数学运算（如
    *+*, *-*, ***, 和 */*）一样轻松地执行这些操作。
- en: 'Typically, an operator will be in the following form:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，运算符将采用以下形式：
- en: '[PRE55]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As it is when adding two numbers together:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在相加两个数字时一样：
- en: '[PRE56]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In the preceding example, we have these:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们有这些：
- en: '`2`: This is the left-hand side value.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`：这是左侧的值。'
- en: '`+`: This is the operator.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+`：这是运算符。'
- en: '`3`: This is the right-hand side value.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3`：这是右侧的值。'
- en: 'The **bit shift operator** (`<<`) will take an integer value on the left-hand
    side and shift it by the number of bit positions to the right-hand side. Therefore,
    we can use this to express our intention better when declaring the device values:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**位移运算符** (`<<`) 会将左侧的整数值向右移动指定的位数。因此，我们可以在声明设备值时更好地表达我们的意图：'
- en: '[PRE57]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The bitwise **AND** operator (`&`) will perform the same bit comparison that
    was previously described manually, and we can use this to create a function to
    determine whether a particular device exists within the value for the supported
    devices:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 位运算 **AND** 运算符 (`&`) 将执行之前手动描述的相同位比较，我们可以使用这个来创建一个函数，以确定特定设备是否存在于支持的设备值中：
- en: '[PRE58]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The Swift standard library also provides operators for the following logical
    operations:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 标准库还提供了以下逻辑运算的运算符：
- en: '**OR**: The OR operation, denoted by `|`, compares bits and sets the corresponding
    bit to 1 if either value has the bit set to 1\. For our devices, this will mean
    creating a union between two device combinations:'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OR**：OR 运算，用 `|` 表示，比较位，如果任一值将位设置为 1，则将相应的位设置为 1。对于我们的设备，这意味着在两个设备组合之间创建一个并集：'
- en: '[PRE59]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '**XOR (exclusive or)**: The XOR operation, denoted by `^`, will only set the
    bit to 1 if either value has the bit set to 1, but not if they both do:'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XOR（异或）**：XOR 运算，用 `^` 表示，只有在任一值将位设置为 1 但不是两者都设置时，才会将位设置为 1：'
- en: '[PRE60]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We have seen some of the advanced operators available to us, provided by the
    Swift standard library.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 Swift 标准库为我们提供的某些高级运算符。
- en: See also
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Further information about advanced operators can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/advanced-operators](http://swiftbook.link/docs/advanced-operators).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 关于高级运算符的更多信息可以在 Apple 的 Swift 语言文档中找到，请参阅 [http://swiftbook.link/docs/advanced-operators](http://swiftbook.link/docs/advanced-operators)。
- en: Defining option sets
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义选项集
- en: The use of bitwise operations to hold multiple options in one value is a common
    pattern and is used throughout the **Cocoa Touch framework**, with one example
    being `UIDeviceOrientation`. In Swift, there is a protocol, `OptionSet`, that
    formalizes this pattern and provides additional convenience. In this recipe, we
    will explore how to define your own option sets.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个值中持有多个选项的位运算使用是一个常见的模式，并且在 **Cocoa Touch 框架** 中被广泛使用，一个例子是 `UIDeviceOrientation`。在
    Swift 中，有一个协议 `OptionSet`，它正式化了这种模式并提供了一些便利。在这个菜谱中，我们将探讨如何定义自己的选项集。
- en: How to do it...
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Let''s rewrite our example from the last recipe, which defined supported device
    values, to use an `OptionSet`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写上一个菜谱中的示例，该示例定义了支持的设备值，以使用 `OptionSet`：
- en: '[PRE61]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: How it works...
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `OptionSet` protocol requires a `rawValue` property, and the convention
    is to define static constants for each of the options. Additionally, convenient
    combinations of options can also be defined as static constants, and `OptionSet`
    provides a convenience initializer, which allows an array of options to be provided,
    then the options are combined through bitwise addition and stored as one value.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`OptionSet` 协议需要一个 `rawValue` 属性，并且惯例是为每个选项定义静态常量。此外，还可以定义选项的方便组合作为静态常量，`OptionSet`
    提供了一个便利的初始化器，允许提供选项数组，然后通过位运算加法将选项组合成一个值。'
- en: 'The `OptionSet` protocol provides set-like manipulation and comparison methods
    that perform the same bitwise operations that we covered in the last recipe:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`OptionSet`协议提供了类似于集合的操纵和比较方法，这些方法执行与上一菜谱中覆盖的相同的位操作：'
- en: '[PRE62]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Many of the set methods that we examined in [Chapter 2](67605929-e031-49f6-83a9-9f7352e9bad3.xhtml),
    *Mastering the Building Blocks,* are also provided.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](67605929-e031-49f6-83a9-9f7352e9bad3.xhtml)，“掌握构建块”中检查的许多集合方法也提供了。
- en: See also
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Further information about the `OptionSet` protocol can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/optionset](http://swiftbook.link/docs/optionset).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`OptionSet`协议的更多信息可以在Apple的Swift语言文档中找到，请参阅[http://swiftbook.link/docs/optionset](http://swiftbook.link/docs/optionset)。
- en: Creating custom operators
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义操作符
- en: In an earlier recipe, we looked at some of the advanced operators that Swift
    offers on top of the common mathematical operators. In this recipe, we will look
    at how we can create our own operators, enabling very concisely expressive behaviors
    that feel like part of the language.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们查看了一些Swift在常见数学操作符之上提供的先进操作符。在这个菜谱中，我们将探讨我们如何创建自己的操作符，使表达的行为非常简洁，感觉像是语言的一部分。
- en: The custom operator we will create will be used to append the information in
    one value to the information in another value, producing a new value that contains
    the second value, followed by the first. The functionality we are looking to achieve
    is similar to the `>>` Unix command.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的自定义操作符将用于将一个值的信息追加到另一个值的信息中，产生一个新的值，该值包含第二个值，后跟第一个值。我们想要实现的功能类似于`>>`
    Unix命令。
- en: Getting ready
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's understand how the Unix command, `>>`, works, and in this recipe, we will
    implement something similar in Swift using a custom operator.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解Unix命令`>>`是如何工作的，在这个菜谱中，我们将使用自定义操作符在Swift中实现类似的功能。
- en: 'Since macOS is Unix-based, we can provide Unix commands within Terminal. Open
    up the Terminal application on your Mac:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 由于macOS是基于Unix的，我们可以在终端中提供Unix命令。打开你的Mac上的终端应用程序：
- en: '![](img/48084519-19b6-43b6-a8dc-6624eabb9d36.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48084519-19b6-43b6-a8dc-6624eabb9d36.png)'
- en: Figure 4.1 – Spotlight search
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 焦点搜索
- en: Type `cd ~/Desktop` and press *Enter to* move to the folder containing all the
    files and folders on your desktop. Type `touch Tasks.txt` and then press *Enter
    to* create a blank text file on your desktop, called `Tasks.txt`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`cd ~/Desktop`并按*Enter*移动到包含所有桌面文件和文件夹的文件夹。输入`touch Tasks.txt`然后按*Enter*在桌面上创建一个名为`Tasks.txt`的空白文本文件。
- en: 'To add tasks to our tasks text file we can type the following command, followed
    by *Enter*:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要将任务添加到我们的任务文本文件中，我们可以输入以下命令，然后按*Enter*：
- en: '[PRE63]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: If you open the text file on your desktop, you'll see that we have added buy
    milk on the first line.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开桌面上的文本文件，你会看到我们在第一行添加了购买牛奶。
- en: 'Enter another task in the same way:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 以相同的方式输入另一个任务：
- en: '[PRE64]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Reopen the `Tasks.txt` file, and you will see that mow the lawn has been added
    on the second line:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 重新打开`Tasks.txt`文件，你会看到割草已经被添加到第二行：
- en: '![](img/41f26fea-a607-412a-91ed-4262aa5f5ba7.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41f26fea-a607-412a-91ed-4262aa5f5ba7.png)'
- en: Figure 4.2 – Task result
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 任务结果
- en: Add a few more tasks in the same way, and you'll see that each task is appended
    to the text file on the next line.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 以相同的方式添加更多任务，你会看到每个任务都被追加到文本文件的下一行。
- en: 'The command we issue in Terminal takes the following form:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在终端中发出的命令具有以下形式：
- en: '[PRE65]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Let's create similar behavior in Swift; however, we can't use the same command
    string, `>>`, as this is already defined as bit shifting to the right, so let's
    make it `>>>`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Swift中创建类似的行为；然而，我们不能使用相同的命令字符串`>>`，因为这个已经被定义为向右位移位，所以让我们使用`>>>`。
- en: How to do it...
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will define and then use a new "append" operator `>>>`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义并使用一个新的“追加”操作符`>>>`：
- en: 'Declare an `infix operator`:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`中缀操作符`：
- en: '[PRE66]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Define the behavior for our operator when used with two strings:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义当使用两个字符串时我们的操作符的行为：
- en: '[PRE67]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Define the behavior for our operator when appending a `String` to an array
    of strings:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义当将`String`追加到字符串数组时我们的操作符的行为：
- en: '[PRE68]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Define the behavior for our operator when appending an array of strings to
    another array of strings:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义当将字符串数组追加到另一个字符串数组时我们的操作符的行为：
- en: '[PRE69]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'With these implementations in place, use our new operator to append things:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这些实现到位后，使用我们新的操作符来追加内容：
- en: '[PRE70]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Refactor the preceding two operator implementations to use a generic element
    type for arrays:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前两个操作符实现重构，以使用数组通用的元素类型：
- en: '[PRE71]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Use the operator with arrays of any type:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用操作符处理任何类型的数组：
- en: '[PRE72]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We can implement our custom append operator for our own custom types too.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以为我们自己的自定义类型实现我们的自定义追加操作符。
- en: 'Create a `Task` and a `TaskList` to hold it:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Task`和一个`TaskList`来保存它：
- en: '[PRE73]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Extend `TaskList` to add support for our new append operator:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展`TaskList`以添加对新的追加操作符的支持：
- en: '[PRE74]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Append a `Task` to a `TaskList` using our custom operator:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们的自定义操作符将一个`Task`追加到`TaskList`中：
- en: '[PRE75]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: How it works...
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First, we declared an `infix operator`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明了一个`中缀操作符`：
- en: '[PRE76]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Operators can come in three types:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符可以分为三种类型：
- en: '`prefix` – Operates on one value and is placed before the value. An example
    is the NOT operator:'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`前缀` – 对一个值进行操作，并将其放置在值之前。一个例子是NOT操作符：'
- en: '[PRE77]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '`postfix` – Operates on one value and is placed after the value. An example
    is the force unwrap operator:'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`后缀` – 对一个值进行操作，并将其放置在值之后。一个例子是强制解包操作符：'
- en: '[PRE78]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '`infix` - Operates on two values and is placed between them. An example is
    the addition operator:'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`中缀` - 对两个值进行操作，并将其放置在它们之间。一个例子是加法操作符：'
- en: '[PRE79]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Once we have defined the operator, we can write top-level functions that implement
    the behavior for each pair of types: one on the **left-hand side** (**LHS**) and
    one on the **right-hand side** (**RHS**). Method parameter overloading allows
    us to specify the operator implementation for multiple-type pairings.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了操作符，我们可以编写顶层函数来实现每种类型对的行为：一个在**左侧**（**LHS**）和一个在**右侧**（**RHS**）。方法参数重载允许我们为多类型配对指定操作符实现。
- en: 'We can define how to append one string to another when our operator is used
    with strings:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的操作符与字符串一起使用时，我们可以定义如何将一个字符串追加到另一个字符串上：
- en: '[PRE80]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We can implement appending a `String` to an array of strings:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现将一个`String`追加到字符串数组中：
- en: '[PRE81]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We can also implement appending the elements in an array of strings to another
    array of strings:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以实现将字符串数组中的元素追加到另一个字符串数组中：
- en: '[PRE82]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This allows us to use the operator with strings and arrays of strings, as those
    are the implementations we defined:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们使用操作符与字符串和字符串数组一起使用，因为这些是我们定义的实现：
- en: '[PRE83]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We can implement our appending operator on every type of array that we think
    might be useful, but instead, we can implement it as a generic function and have
    it work for all arrays.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们认为可能有用的每种数组类型上实现我们的追加操作符，但相反，我们可以将其实现为一个泛型函数，使其对所有数组都起作用。
- en: 'So, we can refactor the preceding two array implementations to use a generic
    element type:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以重构前面的两个数组实现，以使用泛型元素类型：
- en: '[PRE84]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'This allows us to use arrays of ints without having to explicitly define them
    for int arrays:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们使用整数数组，而无需显式地为整数数组定义它们：
- en: '[PRE85]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We can also implement it for our own custom types. Let''s create `Task` and
    `TaskList`, which might benefit from using the operator:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为我们自己的自定义类型实现它。让我们创建`Task`和`TaskList`，这可能有助于使用操作符：
- en: '[PRE86]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: We've added `CustomStringConvertible` conformance so that we can easily print
    out the result.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了`CustomStringConvertible`一致性，以便我们可以轻松地打印出结果。
- en: 'An alternative to implementing the use of an operator as a top-level function
    is to declare it within the relevant type as a static function. We''ll declare
    it within an extension on our `TaskList` object, but we can just as easily declare
    it within the main `TaskList` class declaration:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 实现操作符作为顶层函数的替代方法是将其声明为相关类型中的静态函数。我们将在`TaskList`对象的扩展中声明它，但我们也可以轻松地在`TaskList`主类声明中声明它：
- en: '[PRE87]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Implementing this within a type has a few advantages: The implementation code
    is right next to the type itself, making it easier to find, and taking advantage
    of any values or types that might have a private, or otherwise restricted, access
    control, which will prevent them from being visible to a top-level function.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型内部实现它有几个优点：实现代码紧挨着类型本身，这使得它更容易找到，并利用任何可能具有私有或受限制的访问控制的值或类型，这将防止它们对顶层函数可见。
- en: 'Now we can use our `>>>` operator to append a `Task` to a `TaskList`:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用我们的`>>>`操作符将一个`Task`追加到`TaskList`中：
- en: '[PRE88]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: We have created a custom operator, to allow more concise and expressive code.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个自定义操作符，以允许更简洁和更具表现力的代码。
- en: There's more...
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'Operators don''t just work individually – they are often used within the same
    expression as other operators; the mathematical operators are a helpful example
    of this:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符不仅单独工作，它们通常在同一个表达式中与其他操作符一起使用；数学操作符是这一点的有用例子：
- en: '[PRE89]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The order that each of these operations is performed in will affect the result.
    To understand the order in which the operations are performed, we can add brackets
    that will perform the same function:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些操作执行的顺序将影响结果。为了理解操作执行的顺序，我们可以添加括号，它们将执行相同的功能：
- en: '[PRE90]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'In Swift, the decision about how to order the operations is made using two
    concepts – precedence and associativity:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，关于如何排序运算的决定是通过两个概念——优先级和结合性——来实现的：
- en: '**Precedence**: This defines how important the operation type is. Therefore
    the operations with the highest precedence are performed first; for example, multiplication
    (*) has higher precedence than addition (+) and is therefore always performed
    first.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先级**：这定义了操作类型的重要性。因此，具有最高优先级的操作首先执行；例如，乘法（*）的优先级高于加法（+），因此总是首先执行。'
- en: '**Associativity**: This defines which side, left or right, a value should associate
    itself with for evaluation when it has an operation with the same precedence on
    either side. This has the effect of defining the order that operations of the
    same precedence should be evaluated in: left to right or right to left.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结合性**：这定义了当值在两侧具有相同优先级的操作时，它应该将自己与哪一侧关联起来进行评估。这具有定义具有相同优先级的操作应该按何种顺序评估的效果：从左到右或从右到左。'
- en: 'Let''s use this information to understand the operation ordering of the preceding
    mathematical operation. We have an expression comprising of one addition and two
    division operations. Division operations have higher precedence than addition
    operations; therefore, the division operations are evaluated first:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用这些信息来理解前面数学运算的操作顺序。我们有一个包含一个加法和两个除法运算的表达式。除法运算的优先级高于加法运算；因此，除法运算首先被评估：
- en: '[PRE91]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We now have two division operations that need to be evaluated before the addition
    operation. Since both are division operators, they have the same precedence, so
    we have to look at associativity to know in which order to evaluate them. The
    division operation has an associativity of `left`, so they should be evaluated
    from left to right. Therefore, `8 / 2` is evaluated first and `4 / 4` is evaluated
    next. This gives us the following:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个需要在加法运算之前评估的除法运算。由于它们都是除法运算符，它们具有相同的优先级，因此我们必须查看结合性以确定它们的评估顺序。除法运算的结合性为
    `left`，因此它们应该从左到右进行评估。因此，`8 / 2` 首先被评估，然后是 `4 / 4`。这给我们以下结果：
- en: '[PRE92]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We need to define precedence and associativity for our custom operator, as
    the compiler does not currently know how it should be ordered within an expression
    containing multiple operations. Because of this, the following expression will
    not compile:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为我们自定义的运算符定义优先级和结合性，因为编译器目前不知道它应该如何在包含多个运算的表达式中排序。因此，以下表达式将无法编译：
- en: '[PRE93]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Precedence and associativity are defined within a precedence group, and an operator
    can either conform to an existing group or one that has been newly defined.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 优先级和结合性是在优先级组内定义的，一个运算符可以符合一个现有的组或一个新定义的组。
- en: 'Let''s define a new precedence group for our appending operator:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的附加运算符定义一个新的优先级组：
- en: '[PRE94]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Here, we give it the name `AppendingPrecedence` and define its values within
    curly brackets. We'll set its associativity to the left to match mathematical
    operations, and to establish precedence, we define that this precedence group
    is higher than another precedence group and lower than some other precedence groups.
    For the appending operator, we'll set the precedence to be higher than addition,
    so it will be evaluated before the addition operators but after the multiplication
    operators. Both the `AdditionPrecendence` and `MultiplicationPrecedence` groups
    are defined by the *standard library*.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将其命名为 `AppendingPrecedence` 并在花括号内定义其值。我们将将其结合性设置为左侧，以匹配数学运算，并为了建立优先级，我们定义这个优先级组比另一个优先级组高，但比一些其他优先级组低。对于附加运算符，我们将优先级设置为高于加法，因此它将在加法运算符之前但乘法运算符之后进行评估。`AdditionPrecendence`
    和 `MultiplicationPrecedence` 组都是由 *标准库* 定义的。
- en: 'Now that we have a precedence group defined, we can ensure that our custom
    operator conforms to it:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了一个优先级组，我们可以确保我们的自定义运算符符合它：
- en: '[PRE95]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'With precedence and associativity declared, the composite expression previously
    created will now compile:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 声明了优先级和结合性后，之前创建的复合表达式现在可以编译：
- en: '[PRE96]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: We have defined how our custom operator works alongside other operators, allowing
    for complex combinations.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了我们的自定义操作符如何与其他操作符一起工作，从而允许复杂的组合。
- en: See also
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Further information about custom operators can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/custom-operators](http://swiftbook.link/docs/custom-operators).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 关于自定义操作符的更多信息可以在苹果关于Swift语言的文档中找到，请参阅[http://swiftbook.link/docs/custom-operators](http://swiftbook.link/docs/custom-operators)。
- en: Nesting types and namespacing
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套类型和命名空间
- en: In Objective-C, all objects are at the **top level** and are given a global
    scope. They can be said to be in the same **namespace**. This is one reason for
    the convention among Objective-C developers, including Apple, of prefixing their
    class names with two- or three-letter identifiers.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在Objective-C中，所有对象都在**顶层**，并且具有全局作用域。它们可以说是在同一个**命名空间**中。这是包括苹果在内的Objective-C开发者遵循的惯例，即在类名前加上两到三个字母标识符的原因之一。
- en: These prefix characters allow similarly named classes from different frameworks
    to be differentiated, for example, *UIView* from *UIKit* and *SKView* from *SpriteKit*.
    Swift solves this problem by allowing types to be nested within other types, providing
    namespacing with nested types and modules.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这些前缀字符允许来自不同框架的类似命名的类区分开来，例如，*UIView*来自*UIKit*和*SKView*来自*SpriteKit*。Swift通过允许类型嵌套在其他类型中，通过嵌套类型和模块提供命名空间来解决此问题。
- en: Any type can be defined as being nested within another type. This allows us
    to tightly associate one type with another, in addition to providing namespacing,
    which helps differentiate types with the same name. In this recipe, we will create
    some nested types to see if it affects how they are referenced.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类型都可以定义为嵌套在另一个类型中。这允许我们将一个类型紧密地关联到另一个类型上，除了提供命名空间外，还有助于区分具有相同名称的类型。在这个菜谱中，我们将创建一些嵌套类型，看看它们是否会影响它们的引用方式。
- en: How to do it...
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s build a system to monitor a physical device and the user interface that
    it displays. Both the device and the user interface have the concept of orientation,
    although each has a differing definition:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个系统来监控物理设备和它所显示的用户界面。设备和用户界面都有方向的概念，尽管每个的定义都不同：
- en: 'Define a class to represent the device:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个类来表示设备：
- en: '[PRE97]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Within this class, we have defined two enums, which only have value when used
    in relation to the `Device` class. Nesting the type also allows us to simplify
    the names of these types. It would be customary to name them `DeviceCategory`
    and `DeviceOrientation` to avoid confusion, but since they are nested, we can
    remove the `Device` prefix.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们定义了两个枚举，这些枚举只有在与`Device`类相关联时才有值。嵌套类型也允许我们简化这些类型的名称。按照惯例，我们可以将它们命名为`DeviceCategory`和`DeviceOrientation`以避免混淆，但由于它们是嵌套的，我们可以去掉`Device`前缀。
- en: Any use of the nested types, within the type that contains them, can be used
    without any qualifiers; however, this is not the case for use outside of the containing
    type.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含它们的类型内部使用嵌套类型时，可以不使用任何限定符；然而，在包含类型外部使用时并非如此。
- en: 'Access nested types from outside the containing type using dot syntax:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用点符号从包含类型外部访问嵌套类型：
- en: '[PRE98]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: To reference a nested type, we must first specify the containing type, so the
    `Orientation` enum, within the `Device` class, becomes `Device.Orientation`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 要引用嵌套类型，我们必须首先指定包含类型，因此`Device`类中的`Orientation`枚举变为`Device.Orientation`。
- en: 'Define a struct to represent a user interface:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个结构体来表示用户界面：
- en: '[PRE99]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Our `UserInterface` struct also includes a nested `Orientation` enum, but as
    these two enums lie in different namespaces, there is no naming conflict. As before,
    the nested types can be used without any qualifiers in the containing type.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`UserInterface`结构体还包括一个嵌套的`Orientation`枚举，但由于这两个枚举位于不同的命名空间中，因此不存在命名冲突。与之前一样，嵌套类型可以在包含类型中不使用任何限定符使用。
- en: Let's see how these two nested types can be used in conjunction with one another.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这两个嵌套类型如何相互结合使用。
- en: 'Create a function to convert from device orientation to user interface orientation:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数将设备方向转换为用户界面方向：
- en: '[PRE100]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: How it works...
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Our orientation conversion function specifies the full enum case for the `switch`
    statement and the `return` statements; for example:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的转换函数指定了`switch`语句和`return`语句的完整枚举情况；例如：
- en: '[PRE101]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'However, as we''ve seen previously when the compiler knows the type of the
    enum, only the case needs to be specified; the enum type can be removed. For our
    function, the input parameter type is `Device.Orientation` and the return type
    is `UserInterface.Orientation`, so the compiler does know enum types, and therefore
    we can remove the types:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们之前所看到的，当编译器知道枚举的类型时，只需要指定情况；可以移除枚举类型。对于我们的函数，输入参数类型是 `Device.Orientation`，返回类型是
    `UserInterface.Orientation`，因此编译器知道枚举类型，因此我们可以移除类型：
- en: '[PRE102]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Note that the `switch` case contains `.portrait` and returns `.portrait`, but
    these are cases from different enums, and the compiler knows the difference.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`switch` 语句中的 `.portrait` 情况返回 `.portrait`，但这些是来自不同枚举的情况，编译器知道它们的区别。
- en: There's more...
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We've seen how namespacing separates types nested within different containing
    types, but types within modules are also namespaced. This allows you to name your
    types without fear of collision with types in other modules.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了命名空间如何将嵌套在不同容器类型中的类型分开，但模块内的类型也是命名空间化的。这允许你命名你的类型，而不用担心与其他模块中的类型发生冲突。
- en: 'Let''s imagine that we are building an app for hospitals to keep track of their
    events and resources. As part of this, we create a class to represent surgical
    operations that we intend to track:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象我们正在为医院开发一个应用程序，以跟踪其事件和资源。作为其中的一部分，我们创建了一个类来表示我们打算跟踪的手术操作：
- en: '[PRE103]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'There is another class called `Operation`, provided by the **Foundation** framework,
    that can be used to execute and manage a long-running task. We can use both types
    of `Operation` side by side, because the `Foundation` framework is exposed as
    a module, and so the long-running `Operation` class can be used by referencing
    the `Foundation` module:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一个名为 `Operation` 的类，由 **Foundation** 框架提供，可以用来执行和管理长时间运行的任务。我们可以同时使用这两种类型的
    `Operation`，因为 `Foundation` 框架被公开为一个模块，因此可以通过引用 `Foundation` 模块来使用长时间运行的 `Operation`
    类：
- en: '[PRE104]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: We've seen how you can disambiguate two types with the same name, using the
    module they are within.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用它们所属的模块来区分具有相同名称的两个类型。
- en: See also
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Further information about nested types can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/nested-types](http://swiftbook.link/docs/nested-types).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 关于嵌套类型的更多信息可以在 Apple 的 Swift 语言文档中找到，请参阅 [http://swiftbook.link/docs/nested-types](http://swiftbook.link/docs/nested-types)。
