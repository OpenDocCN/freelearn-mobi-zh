- en: Generics, Operators, and Nested Types
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift provides a number of advanced features for building functionality that
    is flexible but well defined so that it feels like you are extending the language
    itself. In this chapter, we will examine two of these features: **generics** and
    **operators**. We will also see how nested types allow logical grouping, access
    control, and namespacing for your constructs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using generics with types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using generics with functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using generics with protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using advanced operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining option sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nesting types and namespacing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code for this chapter can be found in this book's GitHub repository
    at [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter04](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter04)
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/39I7wuy](https://bit.ly/39I7wuy)'
  prefs: []
  type: TYPE_NORMAL
- en: Using generics with types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we build things in Swift that interact with other types, we often specify
    the type we are interacting with directly. This is helpful because it means we
    know the capabilities that the type has; we can put those capabilities to use
    and ensure that the outputs have the correct type. However, we now have a construct
    that can only interact with the specified type; it can't be reused with other
    types, even if the concepts are the same.
  prefs: []
  type: TYPE_NORMAL
- en: '**Generics** give us the advantage of having a defined type while being generically
    applicable to other types. It is, perhaps, best illustrated with an example.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a generic class that stores the last five things
    it was given and returns them all upon request.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a custom collection object that will store the last five strings
    that the user copied so that they can paste not just the last string copied, but
    any of the last five. You can add strings to the list and ask for all the strings
    in the list, which will be returned newest to oldest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is great – it does just what we want. Now, let''s say that we want to
    add a list of five recent contacts to a contacts app. The concept is exactly the
    same as the list of copied strings, as we want to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add something to a list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get all the things on the list so that we can present them to the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, because we specified that the `RecentList` object can only work with
    strings, it can't work with my custom `Person` object. We can use generics to
    make this more useful.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how to do this by making `RecentList` use generics.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will update our `RecentList` code to use generics, so it can be used with
    other types:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Amend the `RecentList` object to define a generic type, `ListItemType`, which
    we use in place of `String`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Provide a specified type, `String`, when creating `RecentList`, which will
    be used to replace the generic type for this instance of `RecentList`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Instead of using generics, we could have replaced all the `String` references
    in `RecentlList` with `Any`, which would allow it to accept any type. However,
    this would allow the list to be made up of different types of things, which is
    not what we want. It would also require us to cast values that are returned, to
    make them useful.
  prefs: []
  type: TYPE_NORMAL
- en: Let's examine how our newly genericized `RecentList` can be used for the other
    example we discussed earlier, the list of recent contacts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a simple `Person` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Create some people to add to our recent contact list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `RecentList`, providing the specific `Person` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Add person objects to this list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Get all the people in the list, and since this is typed as an array of `Person`
    objects, print their `name` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We now have a generic `RecentList` class that we have used with both strings
    and a custom `Person` class.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add generics to a `class` or `struct`, the generic type is defined in angle
    brackets after the class or struct name, and can be given any type name, although
    it should begin with a *capital letter* like other type names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This generic type now becomes a stand-in for the specific type that will be
    specified when it is used, and we can use this wherever we would use the specific
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be used as a property type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As a parameter value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And as a return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In many other programming languages that have a generics system, the generic
    type is often given a one-letter type name, usually `T`. Swift aims to be concise,
    but not at the expense of clarity, so I suggest using a more descriptive type
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'A descriptive type name becomes especially important if you have multiple generic
    types, which you can have as a comma-separated list within the angle brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We have now created a generic `RecentList` object that can be used with any
    type.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While being extremely generic has its advantages, you may wish to constrain
    which types can be used for the generic type, especially if you need to use some
    features of that constrained type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that in addition to returning an array of items from `RecentList`,
    we want to be able to print out the list directly. To do this, we need to ensure
    that the type of item used in `RecentList` is something that can be converted
    into a *string* to be printed. There is already a `CustomStringConvertible` protocol
    that defines this behavior, so we want to ensure that any specific type used with
    `RecentList` conforms to `CustomStringConvertible`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We add the constraint after the generic type name, separated by a colon, similar
    to how we specify protocol conformance and class inheritance. Indeed, while this
    example constrains the generic type to implement a protocol, we can instead specify
    a class that the specific type must be, or inherit from.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have this constraint, we can be sure that any specific type given
    will conform to `CustomStringConvertible`, and will therefore have a `description`
    string that we can print, so let''s create a method to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing left to do is to make our `Person` class conform to `CustomStringConvertible`
    so that it can continue to be used as a specific type in `RecentList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use this functionality with our `String` type''s `RecentlyList`
    and our `Person` type''s `RecentList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: By constraining the generic type, we could use features that we knew the type
    would have, to provide additional functionality.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about generic types can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/generics](http://swiftbook.link/docs/generics).
  prefs: []
  type: TYPE_NORMAL
- en: Using generics with functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to being able to specify generic types, you can use generics to
    build functions that are both widely applicable and strongly typed. In this recipe,
    we will use generics with functions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use generics to create a function to help with placing values into
    a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a generic function that inserts the same value into a dictionary for
    multiple keys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Use this function, passing in a single value and multiple keys, and the value
    is stored against each of the given keys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like generics for types, the generic type for a function is specified
    within angle brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The defined generic type name can then be used as a type definition within the
    rest of the function definition. In our example, we want to define the type of
    our input item to be duplicated, and we also want the values that are held in
    the dictionary to be returned to be of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using generics, we could have used the `Any` type in place of the
    generic type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this approach presents a few problems for anyone using this function:'
  prefs: []
  type: TYPE_NORMAL
- en: They will get back a dictionary containing values of the `Any` type, which will
    need to be cast to a more useful type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without seeing the implementation, they can't be sure that the dictionary contains
    values of the same type. One key may have a `String` stored against it, and another
    may have an `Int`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without seeing the implementation, they can't be sure that the values of the
    returned dictionary are of the same type as the item provided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using a generic type, we allow the functionality to be widely applicable
    while enforcing our type logic at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll notice that unlike instantiating a type with generics, we don''t need
    to explicitly state the specific type to use when executing the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is because the compiler is able to infer it from the type of the first
    parameter provided. Since `Parasite` is a string, and the compiler knows that
    the parameter has the `ItemType` generic type, the compiler infers that for this
    use of the method, the `ItemType` generic type becomes the specific type of `String`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can increase the usability of our function by providing a generic type for
    the set of keys we provide as the second parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Multiple generic types are defined just as they were in the previous recipe,
    as a comma-separated list within the angle brackets.
  prefs: []
  type: TYPE_NORMAL
- en: All the collection types in Swift (array, dictionary, set, and so on) use generics,
    and in the preceding function, we are passing the generic type from our function
    into the set. Therefore, `KeyType` must conform to `Hashable`, since this is required
    for use in a `Set`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to make this constraint explicit or constrain the generic type
    for some other reason, this is defined after a colon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as with the previous example, if both specific types we are using can
    be inferred from the input or output, we don''t need to specify it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We have used two generic types to improve the flexibility of our function.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about generic functions can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/generic-functions](http://swiftbook.link/docs/generic-functions).
  prefs: []
  type: TYPE_NORMAL
- en: Using generics with protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, we have seen how to use generics within types and functions.
    In this recipe, we will round off our journey through generics in Swift by looking
    at how they can be used in protocols. This will allow us to produce abstract interfaces
    while maintaining strongly typed requirements that allow for a more descriptive
    model.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will build a model for a transport app in the UK with the
    goal of providing the distance and duration of a journey for different methods
    of transport.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ways that people travel can be very different, so let''s start by defining
    transport methods in a generic way, and then specify what those travel methods
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a protocol to define the features of a transport method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a struct for traveling by train that implements the `TransportMethod`
    protocol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to define the `TrainStation` type that we put as `CollectionPoint`.
    Let''s do that as an enum:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we plan to calculate the distance and duration of a journey, let''s create
    a `Journey` object to represent that journey from a starting point to an endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the transport method as a property of the journey as this will be used
    for the duration calculation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To calculate the distance of our journey, we need the start and end to have
    definite locations. So, define a protocol that provides this location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the `CoreLocation` framework at the top of the playground:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Constrain `CollectionPoint` associated type on `TransportMethod`, so that it
    must conform to the `TransportLocation` protocol we have just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the location on the start and end of the `CollectionPoint` to calculate
    the distance and duration of the journey:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure our `TrainStation` enum conforms to `TransportLocation`, which is now
    a requirement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Use our `Journey` object to calculate the distance and duration of a train
    journey:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the outset, it may not be clear which is the best structure to use to define
    a transport method, and there might be different structures appropriate for different
    travel methods. Therefore, we can define a transport method as a protocol that
    appropriate types can conform to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We define an associated generic type that we name `CollectionPoint`, which will
    represent the type of location that someone can be collected from when using this
    transport method. By using generics, we have ultimate flexibility in how a transport
    method chooses to define what can serve as a collection point.
  prefs: []
  type: TYPE_NORMAL
- en: Having defined an associated type, it can then be used as a placeholder in properties
    and methods for the specific type that will be defined when the protocol is used.
    We use it to define a default collection point that each transport method should
    provide.
  prefs: []
  type: TYPE_NORMAL
- en: Each transport method also provides an average speed, which will be used later
    in calculating the travel time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a concrete example of a transport method to help define the
    model further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'For `Train` to conform to the `TransportMethod` protocol, we must provide a
    specific version of the `CollectionPoint` generic type that is required by the
    protocol. In the case of traveling by train, the collection point will be a train
    station, so we now have to define the `TrainStation` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Since there are a finite number of train stations that are discretely definable,
    an `enum` is a good way to represent them. I've only listed a small number above,
    for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal is to model a journey and calculate the duration of the journey over
    specific transport methods, so let''s create a `Journey` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: A journey takes place from one point to another, so we take the journey's start
    and end as input parameters. We need to have the flexibility to provide any type
    as the start and end, but we need them to be types connected to a transport method,
    with the same type for the start and end values. To accomplish this, we can have
    a generic type constrained to conform to the `TransportMethod` protocol; we can
    then define our start and end property types by referencing the `CollectionPoint`
    associated type of the generic type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal is to calculate the duration of a journey. To do this, we will need
    the speed of travel during the journey and the distance from start to end. Our
    `TransportMethod` protocol defines that it will provide an average speed, so let''s
    also take the transport method as an input to our journey:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: To get the distance of the journey, we need to calculate the distance between
    the start and end, but the type of both the start and end of the journey is the
    generic `CollectionPoint` type, which could be any type, and so does not have
    any location information that we can use to calculate distance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this, let''s constrain `CollectionPoint` so that it must conform to
    a new protocol, `TransportLocation`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Anything conforming to `TransportLocation` must provide a location in the form
    of a `CLLocation` object. The `CLLocation` object is part of the `CoreLocation`
    framework on iOS. Further investigation of the `CoreLocation` framework is outside
    the scope of this book, but it''s enough to know that it provides ways to calculate
    the distance between two `CLLocation` objects, and we need to include the following
    at the top of this playground to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'With our `TransportLocation` protocol defined, we can constrain the `CollectionPoint`
    associated type on the `TransportMethod` protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Since our `CollectionPoint` will now conform to `TransportLocation`, and therefore
    must have a location property, we can go back to our `Journey` object and use
    this to calculate the distance of the journey and the duration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to do is to ensure that our `TrainStation` enum conforms
    to `TransportLocation` as this is now a requirement. To do this, we just need
    to declare conformance and add a `location` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how we would use our travel model to create a journey with specific
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We have used generics with protocols to create a generic system without prescribing
    the type of Swift construct we need to use.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we made one type conform to `TransportMethod` – this was our
    `Train` struct. Let's look at another to see how tackling things in a protocol-oriented
    way allows flexibility in implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next `TransportMethod`, we will implement `Road`, but there are a number
    of different vehicle types that we can use to travel by road, and they may have
    different average speeds. Since we have a finite list of options for travel by
    road, let''s define it using an `enum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'A journey by train has a finite list of collection points, which is the train
    stations but almost anywhere can be a collection point when traveling by road.
    Therefore, we can define the collection point for `Road` to be any `CLLocation`,
    but `CLLocation` doesn''t conform to `TransportLocation`. We can solve this by
    extending `CLLocation` to add conformance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can define a journey by road and calculate the duration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: By taking a protocol-orientated approach to tackling the task of calculating
    a journey's duration, and by using protocol generics, we were able to use completely
    different, but appropriate, implementations for two transport methods while providing
    an interface so that they can be handled in a common way.
  prefs: []
  type: TYPE_NORMAL
- en: For a train journey, we used an `enum` to model the train stations and a `struct`
    to model the transport method, and for `road,` we implemented an `enum` for the
    transport method and used the `CLLocation` object for the transport location.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about associated types can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/associated-types](http://swiftbook.link/docs/associated-types).
  prefs: []
  type: TYPE_NORMAL
- en: Using advanced operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swift is a programming language that takes a relatively small number of well-defined
    principles and builds on them to create expressive and powerful language features.
    The concept of mathematical operators, such as *+*, *-*, ***, and */* for addition,
    subtraction, multiplication, and division, respectively, seems so fundamental
    as to not warrant a mention. However, in Swift, this common mathematical functionality
    is built on top of an underlying operator system that is extensible and powerful.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will look at some of the more advanced operators provided
    by the Swift standard library, and in the next recipe, we will create our own
    custom operators.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The operators we will explore are known as bitwise operators and are used to
    manipulate numerical bit representations.
  prefs: []
  type: TYPE_NORMAL
- en: 'An integer value in Swift can be represented in its binary form by prefixing
    the integer literal with `0b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: A bit is the smallest value in a computer system, consisting of either a 1 or
    0\. The integers mentioned here can be represented by three bits, which are clearly
    visible when represented in binary form, as illustrated in the preceding snippet.
    The integer `six` can be represented by the three bits 1, 1, and 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'These binary representations are really useful when you need to represent multiple
    options in one value. For example, let''s say that we want to indicate which devices
    are supported for a specific feature of an app. The available devices are as listed:'
  prefs: []
  type: TYPE_NORMAL
- en: Phone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tablet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Watch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Laptop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Desktop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TV
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brain implant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Certain features may be appropriate for all the devices, or you may still be
    working on a feature, and so it isn't currently appropriate for any device, or
    it may be a combination of different devices. We can have Boolean values for each
    of the devices to indicate whether the feature is supported for that device, but
    this is not the best solution as there is nothing intrinsically tying the properties
    to each other, and you can forget to update some of the values as circumstances
    change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we can represent all the supported devices with one integer value,
    and use each bit of the integer to represent a different device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'To see how this enables us to store multiple devices in one value, let''s add
    together a number of device values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: As each device is represented by a different bit, the device values are combined
    by adding the values, and they don't overlap.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test whether a particular device or combination of devices is supported,
    we can use a bitwise **AND** operation. A bitwise AND operation will compare the
    corresponding bits for two different binary values and will set that bit to 1
    in a new binary value if both bit input values are 1\. As an example, let''s test
    whether phones are supported in the combined value we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The result only has a 1-bit value for the rightmost bit because this is the
    only bit that was set to 1 in both the `Supported Devices` value and the `Phone`
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have that result, we can directly compare it to the value for `Phone`,
    and if they are equal, then we know that the value of the supported devices included
    the `Phone` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We now have a way to combine the possible options into one value, and a way
    to compare those values to see whether one is contained in another, using bitwise
    operations. The Swift standard library contains bitwise operators that allow us
    to perform these operations as easily as other mathematical operations, such as
    *+*, *-*, ***, and */*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, an operator will be in the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'As it is when adding two numbers together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we have these:'
  prefs: []
  type: TYPE_NORMAL
- en: '`2`: This is the left-hand side value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+`: This is the operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3`: This is the right-hand side value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **bit shift operator** (`<<`) will take an integer value on the left-hand
    side and shift it by the number of bit positions to the right-hand side. Therefore,
    we can use this to express our intention better when declaring the device values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The bitwise **AND** operator (`&`) will perform the same bit comparison that
    was previously described manually, and we can use this to create a function to
    determine whether a particular device exists within the value for the supported
    devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The Swift standard library also provides operators for the following logical
    operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OR**: The OR operation, denoted by `|`, compares bits and sets the corresponding
    bit to 1 if either value has the bit set to 1\. For our devices, this will mean
    creating a union between two device combinations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '**XOR (exclusive or)**: The XOR operation, denoted by `^`, will only set the
    bit to 1 if either value has the bit set to 1, but not if they both do:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We have seen some of the advanced operators available to us, provided by the
    Swift standard library.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about advanced operators can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/advanced-operators](http://swiftbook.link/docs/advanced-operators).
  prefs: []
  type: TYPE_NORMAL
- en: Defining option sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The use of bitwise operations to hold multiple options in one value is a common
    pattern and is used throughout the **Cocoa Touch framework**, with one example
    being `UIDeviceOrientation`. In Swift, there is a protocol, `OptionSet`, that
    formalizes this pattern and provides additional convenience. In this recipe, we
    will explore how to define your own option sets.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s rewrite our example from the last recipe, which defined supported device
    values, to use an `OptionSet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `OptionSet` protocol requires a `rawValue` property, and the convention
    is to define static constants for each of the options. Additionally, convenient
    combinations of options can also be defined as static constants, and `OptionSet`
    provides a convenience initializer, which allows an array of options to be provided,
    then the options are combined through bitwise addition and stored as one value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `OptionSet` protocol provides set-like manipulation and comparison methods
    that perform the same bitwise operations that we covered in the last recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Many of the set methods that we examined in [Chapter 2](67605929-e031-49f6-83a9-9f7352e9bad3.xhtml),
    *Mastering the Building Blocks,* are also provided.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about the `OptionSet` protocol can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/optionset](http://swiftbook.link/docs/optionset).
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an earlier recipe, we looked at some of the advanced operators that Swift
    offers on top of the common mathematical operators. In this recipe, we will look
    at how we can create our own operators, enabling very concisely expressive behaviors
    that feel like part of the language.
  prefs: []
  type: TYPE_NORMAL
- en: The custom operator we will create will be used to append the information in
    one value to the information in another value, producing a new value that contains
    the second value, followed by the first. The functionality we are looking to achieve
    is similar to the `>>` Unix command.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's understand how the Unix command, `>>`, works, and in this recipe, we will
    implement something similar in Swift using a custom operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since macOS is Unix-based, we can provide Unix commands within Terminal. Open
    up the Terminal application on your Mac:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48084519-19b6-43b6-a8dc-6624eabb9d36.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Spotlight search
  prefs: []
  type: TYPE_NORMAL
- en: Type `cd ~/Desktop` and press *Enter to* move to the folder containing all the
    files and folders on your desktop. Type `touch Tasks.txt` and then press *Enter
    to* create a blank text file on your desktop, called `Tasks.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add tasks to our tasks text file we can type the following command, followed
    by *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: If you open the text file on your desktop, you'll see that we have added buy
    milk on the first line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter another task in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Reopen the `Tasks.txt` file, and you will see that mow the lawn has been added
    on the second line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41f26fea-a607-412a-91ed-4262aa5f5ba7.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Task result
  prefs: []
  type: TYPE_NORMAL
- en: Add a few more tasks in the same way, and you'll see that each task is appended
    to the text file on the next line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command we issue in Terminal takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Let's create similar behavior in Swift; however, we can't use the same command
    string, `>>`, as this is already defined as bit shifting to the right, so let's
    make it `>>>`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will define and then use a new "append" operator `>>>`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare an `infix operator`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the behavior for our operator when used with two strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the behavior for our operator when appending a `String` to an array
    of strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the behavior for our operator when appending an array of strings to
    another array of strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'With these implementations in place, use our new operator to append things:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Refactor the preceding two operator implementations to use a generic element
    type for arrays:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the operator with arrays of any type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: We can implement our custom append operator for our own custom types too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Task` and a `TaskList` to hold it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Extend `TaskList` to add support for our new append operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Append a `Task` to a `TaskList` using our custom operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we declared an `infix operator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Operators can come in three types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`prefix` – Operates on one value and is placed before the value. An example
    is the NOT operator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '`postfix` – Operates on one value and is placed after the value. An example
    is the force unwrap operator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '`infix` - Operates on two values and is placed between them. An example is
    the addition operator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have defined the operator, we can write top-level functions that implement
    the behavior for each pair of types: one on the **left-hand side** (**LHS**) and
    one on the **right-hand side** (**RHS**). Method parameter overloading allows
    us to specify the operator implementation for multiple-type pairings.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define how to append one string to another when our operator is used
    with strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'We can implement appending a `String` to an array of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also implement appending the elements in an array of strings to another
    array of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to use the operator with strings and arrays of strings, as those
    are the implementations we defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: We can implement our appending operator on every type of array that we think
    might be useful, but instead, we can implement it as a generic function and have
    it work for all arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we can refactor the preceding two array implementations to use a generic
    element type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to use arrays of ints without having to explicitly define them
    for int arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also implement it for our own custom types. Let''s create `Task` and
    `TaskList`, which might benefit from using the operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: We've added `CustomStringConvertible` conformance so that we can easily print
    out the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative to implementing the use of an operator as a top-level function
    is to declare it within the relevant type as a static function. We''ll declare
    it within an extension on our `TaskList` object, but we can just as easily declare
    it within the main `TaskList` class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Implementing this within a type has a few advantages: The implementation code
    is right next to the type itself, making it easier to find, and taking advantage
    of any values or types that might have a private, or otherwise restricted, access
    control, which will prevent them from being visible to a top-level function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can use our `>>>` operator to append a `Task` to a `TaskList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: We have created a custom operator, to allow more concise and expressive code.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Operators don''t just work individually – they are often used within the same
    expression as other operators; the mathematical operators are a helpful example
    of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The order that each of these operations is performed in will affect the result.
    To understand the order in which the operations are performed, we can add brackets
    that will perform the same function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'In Swift, the decision about how to order the operations is made using two
    concepts – precedence and associativity:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Precedence**: This defines how important the operation type is. Therefore
    the operations with the highest precedence are performed first; for example, multiplication
    (*) has higher precedence than addition (+) and is therefore always performed
    first.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Associativity**: This defines which side, left or right, a value should associate
    itself with for evaluation when it has an operation with the same precedence on
    either side. This has the effect of defining the order that operations of the
    same precedence should be evaluated in: left to right or right to left.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s use this information to understand the operation ordering of the preceding
    mathematical operation. We have an expression comprising of one addition and two
    division operations. Division operations have higher precedence than addition
    operations; therefore, the division operations are evaluated first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have two division operations that need to be evaluated before the addition
    operation. Since both are division operators, they have the same precedence, so
    we have to look at associativity to know in which order to evaluate them. The
    division operation has an associativity of `left`, so they should be evaluated
    from left to right. Therefore, `8 / 2` is evaluated first and `4 / 4` is evaluated
    next. This gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to define precedence and associativity for our custom operator, as
    the compiler does not currently know how it should be ordered within an expression
    containing multiple operations. Because of this, the following expression will
    not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Precedence and associativity are defined within a precedence group, and an operator
    can either conform to an existing group or one that has been newly defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a new precedence group for our appending operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Here, we give it the name `AppendingPrecedence` and define its values within
    curly brackets. We'll set its associativity to the left to match mathematical
    operations, and to establish precedence, we define that this precedence group
    is higher than another precedence group and lower than some other precedence groups.
    For the appending operator, we'll set the precedence to be higher than addition,
    so it will be evaluated before the addition operators but after the multiplication
    operators. Both the `AdditionPrecendence` and `MultiplicationPrecedence` groups
    are defined by the *standard library*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a precedence group defined, we can ensure that our custom
    operator conforms to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'With precedence and associativity declared, the composite expression previously
    created will now compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: We have defined how our custom operator works alongside other operators, allowing
    for complex combinations.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about custom operators can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/custom-operators](http://swiftbook.link/docs/custom-operators).
  prefs: []
  type: TYPE_NORMAL
- en: Nesting types and namespacing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Objective-C, all objects are at the **top level** and are given a global
    scope. They can be said to be in the same **namespace**. This is one reason for
    the convention among Objective-C developers, including Apple, of prefixing their
    class names with two- or three-letter identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: These prefix characters allow similarly named classes from different frameworks
    to be differentiated, for example, *UIView* from *UIKit* and *SKView* from *SpriteKit*.
    Swift solves this problem by allowing types to be nested within other types, providing
    namespacing with nested types and modules.
  prefs: []
  type: TYPE_NORMAL
- en: Any type can be defined as being nested within another type. This allows us
    to tightly associate one type with another, in addition to providing namespacing,
    which helps differentiate types with the same name. In this recipe, we will create
    some nested types to see if it affects how they are referenced.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s build a system to monitor a physical device and the user interface that
    it displays. Both the device and the user interface have the concept of orientation,
    although each has a differing definition:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a class to represent the device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Within this class, we have defined two enums, which only have value when used
    in relation to the `Device` class. Nesting the type also allows us to simplify
    the names of these types. It would be customary to name them `DeviceCategory`
    and `DeviceOrientation` to avoid confusion, but since they are nested, we can
    remove the `Device` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: Any use of the nested types, within the type that contains them, can be used
    without any qualifiers; however, this is not the case for use outside of the containing
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Access nested types from outside the containing type using dot syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: To reference a nested type, we must first specify the containing type, so the
    `Orientation` enum, within the `Device` class, becomes `Device.Orientation`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a struct to represent a user interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Our `UserInterface` struct also includes a nested `Orientation` enum, but as
    these two enums lie in different namespaces, there is no naming conflict. As before,
    the nested types can be used without any qualifiers in the containing type.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how these two nested types can be used in conjunction with one another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a function to convert from device orientation to user interface orientation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our orientation conversion function specifies the full enum case for the `switch`
    statement and the `return` statements; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'However, as we''ve seen previously when the compiler knows the type of the
    enum, only the case needs to be specified; the enum type can be removed. For our
    function, the input parameter type is `Device.Orientation` and the return type
    is `UserInterface.Orientation`, so the compiler does know enum types, and therefore
    we can remove the types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `switch` case contains `.portrait` and returns `.portrait`, but
    these are cases from different enums, and the compiler knows the difference.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've seen how namespacing separates types nested within different containing
    types, but types within modules are also namespaced. This allows you to name your
    types without fear of collision with types in other modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine that we are building an app for hospitals to keep track of their
    events and resources. As part of this, we create a class to represent surgical
    operations that we intend to track:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'There is another class called `Operation`, provided by the **Foundation** framework,
    that can be used to execute and manage a long-running task. We can use both types
    of `Operation` side by side, because the `Foundation` framework is exposed as
    a module, and so the long-running `Operation` class can be used by referencing
    the `Foundation` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: We've seen how you can disambiguate two types with the same name, using the
    module they are within.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about nested types can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/nested-types](http://swiftbook.link/docs/nested-types).
  prefs: []
  type: TYPE_NORMAL
