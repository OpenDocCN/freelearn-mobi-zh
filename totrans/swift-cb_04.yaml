- en: Generics, Operators, and Nested Types
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift provides a number of advanced features for building functionality that
    is flexible but well defined so that it feels like you are extending the language
    itself. In this chapter, we will examine two of these features: **generics** and
    **operators**. We will also see how nested types allow logical grouping, access
    control, and namespacing for your constructs.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Using generics with types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using generics with functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using generics with protocols
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using advanced operators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining option sets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom operators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nesting types and namespacing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code for this chapter can be found in this book's GitHub repository
    at [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter04](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter04)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/39I7wuy](https://bit.ly/39I7wuy)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Using generics with types
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we build things in Swift that interact with other types, we often specify
    the type we are interacting with directly. This is helpful because it means we
    know the capabilities that the type has; we can put those capabilities to use
    and ensure that the outputs have the correct type. However, we now have a construct
    that can only interact with the specified type; it can't be reused with other
    types, even if the concepts are the same.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '**Generics** give us the advantage of having a defined type while being generically
    applicable to other types. It is, perhaps, best illustrated with an example.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a generic class that stores the last five things
    it was given and returns them all upon request.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a custom collection object that will store the last five strings
    that the user copied so that they can paste not just the last string copied, but
    any of the last five. You can add strings to the list and ask for all the strings
    in the list, which will be returned newest to oldest:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is great – it does just what we want. Now, let''s say that we want to
    add a list of five recent contacts to a contacts app. The concept is exactly the
    same as the list of copied strings, as we want to do the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Add something to a list.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get all the things on the list so that we can present them to the user.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, because we specified that the `RecentList` object can only work with
    strings, it can't work with my custom `Person` object. We can use generics to
    make this more useful.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how to do this by making `RecentList` use generics.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will update our `RecentList` code to use generics, so it can be used with
    other types:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Amend the `RecentList` object to define a generic type, `ListItemType`, which
    we use in place of `String`:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Provide a specified type, `String`, when creating `RecentList`, which will
    be used to replace the generic type for this instance of `RecentList`:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Instead of using generics, we could have replaced all the `String` references
    in `RecentlList` with `Any`, which would allow it to accept any type. However,
    this would allow the list to be made up of different types of things, which is
    not what we want. It would also require us to cast values that are returned, to
    make them useful.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Let's examine how our newly genericized `RecentList` can be used for the other
    example we discussed earlier, the list of recent contacts.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a simple `Person` object:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create some people to add to our recent contact list:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create a new `RecentList`, providing the specific `Person` type:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add person objects to this list:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Get all the people in the list, and since this is typed as an array of `Person`
    objects, print their `name` property:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We now have a generic `RecentList` class that we have used with both strings
    and a custom `Person` class.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add generics to a `class` or `struct`, the generic type is defined in angle
    brackets after the class or struct name, and can be given any type name, although
    it should begin with a *capital letter* like other type names:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This generic type now becomes a stand-in for the specific type that will be
    specified when it is used, and we can use this wherever we would use the specific
    type.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be used as a property type:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As a parameter value:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And as a return type:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In many other programming languages that have a generics system, the generic
    type is often given a one-letter type name, usually `T`. Swift aims to be concise,
    but not at the expense of clarity, so I suggest using a more descriptive type
    name.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'A descriptive type name becomes especially important if you have multiple generic
    types, which you can have as a comma-separated list within the angle brackets:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have now created a generic `RecentList` object that can be used with any
    type.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While being extremely generic has its advantages, you may wish to constrain
    which types can be used for the generic type, especially if you need to use some
    features of that constrained type.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that in addition to returning an array of items from `RecentList`,
    we want to be able to print out the list directly. To do this, we need to ensure
    that the type of item used in `RecentList` is something that can be converted
    into a *string* to be printed. There is already a `CustomStringConvertible` protocol
    that defines this behavior, so we want to ensure that any specific type used with
    `RecentList` conforms to `CustomStringConvertible`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We add the constraint after the generic type name, separated by a colon, similar
    to how we specify protocol conformance and class inheritance. Indeed, while this
    example constrains the generic type to implement a protocol, we can instead specify
    a class that the specific type must be, or inherit from.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have this constraint, we can be sure that any specific type given
    will conform to `CustomStringConvertible`, and will therefore have a `description`
    string that we can print, so let''s create a method to do that:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The only thing left to do is to make our `Person` class conform to `CustomStringConvertible`
    so that it can continue to be used as a specific type in `RecentList`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we can use this functionality with our `String` type''s `RecentlyList`
    and our `Person` type''s `RecentList`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: By constraining the generic type, we could use features that we knew the type
    would have, to provide additional functionality.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about generic types can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/generics](http://swiftbook.link/docs/generics).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Using generics with functions
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to being able to specify generic types, you can use generics to
    build functions that are both widely applicable and strongly typed. In this recipe,
    we will use generics with functions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use generics to create a function to help with placing values into
    a dictionary:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a generic function that inserts the same value into a dictionary for
    multiple keys:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Use this function, passing in a single value and multiple keys, and the value
    is stored against each of the given keys:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like generics for types, the generic type for a function is specified
    within angle brackets:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The defined generic type name can then be used as a type definition within the
    rest of the function definition. In our example, we want to define the type of
    our input item to be duplicated, and we also want the values that are held in
    the dictionary to be returned to be of the same type.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using generics, we could have used the `Any` type in place of the
    generic type:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, this approach presents a few problems for anyone using this function:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: They will get back a dictionary containing values of the `Any` type, which will
    need to be cast to a more useful type.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without seeing the implementation, they can't be sure that the dictionary contains
    values of the same type. One key may have a `String` stored against it, and another
    may have an `Int`.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without seeing the implementation, they can't be sure that the values of the
    returned dictionary are of the same type as the item provided.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using a generic type, we allow the functionality to be widely applicable
    while enforcing our type logic at compile time.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll notice that unlike instantiating a type with generics, we don''t need
    to explicitly state the specific type to use when executing the function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is because the compiler is able to infer it from the type of the first
    parameter provided. Since `Parasite` is a string, and the compiler knows that
    the parameter has the `ItemType` generic type, the compiler infers that for this
    use of the method, the `ItemType` generic type becomes the specific type of `String`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can increase the usability of our function by providing a generic type for
    the set of keys we provide as the second parameter:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Multiple generic types are defined just as they were in the previous recipe,
    as a comma-separated list within the angle brackets.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: All the collection types in Swift (array, dictionary, set, and so on) use generics,
    and in the preceding function, we are passing the generic type from our function
    into the set. Therefore, `KeyType` must conform to `Hashable`, since this is required
    for use in a `Set`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to make this constraint explicit or constrain the generic type
    for some other reason, this is defined after a colon:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Just as with the previous example, if both specific types we are using can
    be inferred from the input or output, we don''t need to specify it:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We have used two generic types to improve the flexibility of our function.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about generic functions can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/generic-functions](http://swiftbook.link/docs/generic-functions).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Using generics with protocols
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, we have seen how to use generics within types and functions.
    In this recipe, we will round off our journey through generics in Swift by looking
    at how they can be used in protocols. This will allow us to produce abstract interfaces
    while maintaining strongly typed requirements that allow for a more descriptive
    model.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will build a model for a transport app in the UK with the
    goal of providing the distance and duration of a journey for different methods
    of transport.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ways that people travel can be very different, so let''s start by defining
    transport methods in a generic way, and then specify what those travel methods
    are:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a protocol to define the features of a transport method:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create a struct for traveling by train that implements the `TransportMethod`
    protocol:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We need to define the `TrainStation` type that we put as `CollectionPoint`.
    Let''s do that as an enum:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Since we plan to calculate the distance and duration of a journey, let''s create
    a `Journey` object to represent that journey from a starting point to an endpoint:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add the transport method as a property of the journey as this will be used
    for the duration calculation:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To calculate the distance of our journey, we need the start and end to have
    definite locations. So, define a protocol that provides this location:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Import the `CoreLocation` framework at the top of the playground:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Constrain `CollectionPoint` associated type on `TransportMethod`, so that it
    must conform to the `TransportLocation` protocol we have just created:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Use the location on the start and end of the `CollectionPoint` to calculate
    the distance and duration of the journey:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Ensure our `TrainStation` enum conforms to `TransportLocation`, which is now
    a requirement:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Use our `Journey` object to calculate the distance and duration of a train
    journey:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the outset, it may not be clear which is the best structure to use to define
    a transport method, and there might be different structures appropriate for different
    travel methods. Therefore, we can define a transport method as a protocol that
    appropriate types can conform to:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We define an associated generic type that we name `CollectionPoint`, which will
    represent the type of location that someone can be collected from when using this
    transport method. By using generics, we have ultimate flexibility in how a transport
    method chooses to define what can serve as a collection point.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Having defined an associated type, it can then be used as a placeholder in properties
    and methods for the specific type that will be defined when the protocol is used.
    We use it to define a default collection point that each transport method should
    provide.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Each transport method also provides an average speed, which will be used later
    in calculating the travel time.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a concrete example of a transport method to help define the
    model further:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For `Train` to conform to the `TransportMethod` protocol, we must provide a
    specific version of the `CollectionPoint` generic type that is required by the
    protocol. In the case of traveling by train, the collection point will be a train
    station, so we now have to define the `TrainStation` type:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Since there are a finite number of train stations that are discretely definable,
    an `enum` is a good way to represent them. I've only listed a small number above,
    for brevity.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal is to model a journey and calculate the duration of the journey over
    specific transport methods, so let''s create a `Journey` object:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: A journey takes place from one point to another, so we take the journey's start
    and end as input parameters. We need to have the flexibility to provide any type
    as the start and end, but we need them to be types connected to a transport method,
    with the same type for the start and end values. To accomplish this, we can have
    a generic type constrained to conform to the `TransportMethod` protocol; we can
    then define our start and end property types by referencing the `CollectionPoint`
    associated type of the generic type.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal is to calculate the duration of a journey. To do this, we will need
    the speed of travel during the journey and the distance from start to end. Our
    `TransportMethod` protocol defines that it will provide an average speed, so let''s
    also take the transport method as an input to our journey:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: To get the distance of the journey, we need to calculate the distance between
    the start and end, but the type of both the start and end of the journey is the
    generic `CollectionPoint` type, which could be any type, and so does not have
    any location information that we can use to calculate distance.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this, let''s constrain `CollectionPoint` so that it must conform to
    a new protocol, `TransportLocation`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Anything conforming to `TransportLocation` must provide a location in the form
    of a `CLLocation` object. The `CLLocation` object is part of the `CoreLocation`
    framework on iOS. Further investigation of the `CoreLocation` framework is outside
    the scope of this book, but it''s enough to know that it provides ways to calculate
    the distance between two `CLLocation` objects, and we need to include the following
    at the top of this playground to use it:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'With our `TransportLocation` protocol defined, we can constrain the `CollectionPoint`
    associated type on the `TransportMethod` protocol:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Since our `CollectionPoint` will now conform to `TransportLocation`, and therefore
    must have a location property, we can go back to our `Journey` object and use
    this to calculate the distance of the journey and the duration:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The last thing we need to do is to ensure that our `TrainStation` enum conforms
    to `TransportLocation` as this is now a requirement. To do this, we just need
    to declare conformance and add a `location` property:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s see how we would use our travel model to create a journey with specific
    types:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We have used generics with protocols to create a generic system without prescribing
    the type of Swift construct we need to use.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we made one type conform to `TransportMethod` – this was our
    `Train` struct. Let's look at another to see how tackling things in a protocol-oriented
    way allows flexibility in implementation.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next `TransportMethod`, we will implement `Road`, but there are a number
    of different vehicle types that we can use to travel by road, and they may have
    different average speeds. Since we have a finite list of options for travel by
    road, let''s define it using an `enum`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'A journey by train has a finite list of collection points, which is the train
    stations but almost anywhere can be a collection point when traveling by road.
    Therefore, we can define the collection point for `Road` to be any `CLLocation`,
    but `CLLocation` doesn''t conform to `TransportLocation`. We can solve this by
    extending `CLLocation` to add conformance:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, we can define a journey by road and calculate the duration:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: By taking a protocol-orientated approach to tackling the task of calculating
    a journey's duration, and by using protocol generics, we were able to use completely
    different, but appropriate, implementations for two transport methods while providing
    an interface so that they can be handled in a common way.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: For a train journey, we used an `enum` to model the train stations and a `struct`
    to model the transport method, and for `road,` we implemented an `enum` for the
    transport method and used the `CLLocation` object for the transport location.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about associated types can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/associated-types](http://swiftbook.link/docs/associated-types).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Using advanced operators
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swift is a programming language that takes a relatively small number of well-defined
    principles and builds on them to create expressive and powerful language features.
    The concept of mathematical operators, such as *+*, *-*, ***, and */* for addition,
    subtraction, multiplication, and division, respectively, seems so fundamental
    as to not warrant a mention. However, in Swift, this common mathematical functionality
    is built on top of an underlying operator system that is extensible and powerful.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will look at some of the more advanced operators provided
    by the Swift standard library, and in the next recipe, we will create our own
    custom operators.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The operators we will explore are known as bitwise operators and are used to
    manipulate numerical bit representations.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'An integer value in Swift can be represented in its binary form by prefixing
    the integer literal with `0b`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: A bit is the smallest value in a computer system, consisting of either a 1 or
    0\. The integers mentioned here can be represented by three bits, which are clearly
    visible when represented in binary form, as illustrated in the preceding snippet.
    The integer `six` can be represented by the three bits 1, 1, and 0.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'These binary representations are really useful when you need to represent multiple
    options in one value. For example, let''s say that we want to indicate which devices
    are supported for a specific feature of an app. The available devices are as listed:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Phone
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tablet
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Watch
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Laptop
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Desktop
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TV
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brain implant
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Certain features may be appropriate for all the devices, or you may still be
    working on a feature, and so it isn't currently appropriate for any device, or
    it may be a combination of different devices. We can have Boolean values for each
    of the devices to indicate whether the feature is supported for that device, but
    this is not the best solution as there is nothing intrinsically tying the properties
    to each other, and you can forget to update some of the values as circumstances
    change.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we can represent all the supported devices with one integer value,
    and use each bit of the integer to represent a different device:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To see how this enables us to store multiple devices in one value, let''s add
    together a number of device values:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As each device is represented by a different bit, the device values are combined
    by adding the values, and they don't overlap.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'To test whether a particular device or combination of devices is supported,
    we can use a bitwise **AND** operation. A bitwise AND operation will compare the
    corresponding bits for two different binary values and will set that bit to 1
    in a new binary value if both bit input values are 1\. As an example, let''s test
    whether phones are supported in the combined value we created earlier:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The result only has a 1-bit value for the rightmost bit because this is the
    only bit that was set to 1 in both the `Supported Devices` value and the `Phone`
    value.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have that result, we can directly compare it to the value for `Phone`,
    and if they are equal, then we know that the value of the supported devices included
    the `Phone` value:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We now have a way to combine the possible options into one value, and a way
    to compare those values to see whether one is contained in another, using bitwise
    operations. The Swift standard library contains bitwise operators that allow us
    to perform these operations as easily as other mathematical operations, such as
    *+*, *-*, ***, and */*.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, an operator will be in the following form:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As it is when adding two numbers together:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In the preceding example, we have these:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '`2`: This is the left-hand side value.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+`: This is the operator.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3`: This is the right-hand side value.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **bit shift operator** (`<<`) will take an integer value on the left-hand
    side and shift it by the number of bit positions to the right-hand side. Therefore,
    we can use this to express our intention better when declaring the device values:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The bitwise **AND** operator (`&`) will perform the same bit comparison that
    was previously described manually, and we can use this to create a function to
    determine whether a particular device exists within the value for the supported
    devices:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The Swift standard library also provides operators for the following logical
    operations:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '**OR**: The OR operation, denoted by `|`, compares bits and sets the corresponding
    bit to 1 if either value has the bit set to 1\. For our devices, this will mean
    creating a union between two device combinations:'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '**XOR (exclusive or)**: The XOR operation, denoted by `^`, will only set the
    bit to 1 if either value has the bit set to 1, but not if they both do:'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We have seen some of the advanced operators available to us, provided by the
    Swift standard library.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about advanced operators can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/advanced-operators](http://swiftbook.link/docs/advanced-operators).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Defining option sets
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The use of bitwise operations to hold multiple options in one value is a common
    pattern and is used throughout the **Cocoa Touch framework**, with one example
    being `UIDeviceOrientation`. In Swift, there is a protocol, `OptionSet`, that
    formalizes this pattern and provides additional convenience. In this recipe, we
    will explore how to define your own option sets.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s rewrite our example from the last recipe, which defined supported device
    values, to use an `OptionSet`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: How it works...
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `OptionSet` protocol requires a `rawValue` property, and the convention
    is to define static constants for each of the options. Additionally, convenient
    combinations of options can also be defined as static constants, and `OptionSet`
    provides a convenience initializer, which allows an array of options to be provided,
    then the options are combined through bitwise addition and stored as one value.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'The `OptionSet` protocol provides set-like manipulation and comparison methods
    that perform the same bitwise operations that we covered in the last recipe:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Many of the set methods that we examined in [Chapter 2](67605929-e031-49f6-83a9-9f7352e9bad3.xhtml),
    *Mastering the Building Blocks,* are also provided.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about the `OptionSet` protocol can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/optionset](http://swiftbook.link/docs/optionset).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom operators
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an earlier recipe, we looked at some of the advanced operators that Swift
    offers on top of the common mathematical operators. In this recipe, we will look
    at how we can create our own operators, enabling very concisely expressive behaviors
    that feel like part of the language.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: The custom operator we will create will be used to append the information in
    one value to the information in another value, producing a new value that contains
    the second value, followed by the first. The functionality we are looking to achieve
    is similar to the `>>` Unix command.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's understand how the Unix command, `>>`, works, and in this recipe, we will
    implement something similar in Swift using a custom operator.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Since macOS is Unix-based, we can provide Unix commands within Terminal. Open
    up the Terminal application on your Mac:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48084519-19b6-43b6-a8dc-6624eabb9d36.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Spotlight search
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Type `cd ~/Desktop` and press *Enter to* move to the folder containing all the
    files and folders on your desktop. Type `touch Tasks.txt` and then press *Enter
    to* create a blank text file on your desktop, called `Tasks.txt`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'To add tasks to our tasks text file we can type the following command, followed
    by *Enter*:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: If you open the text file on your desktop, you'll see that we have added buy
    milk on the first line.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter another task in the same way:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Reopen the `Tasks.txt` file, and you will see that mow the lawn has been added
    on the second line:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41f26fea-a607-412a-91ed-4262aa5f5ba7.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Task result
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Add a few more tasks in the same way, and you'll see that each task is appended
    to the text file on the next line.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'The command we issue in Terminal takes the following form:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Let's create similar behavior in Swift; however, we can't use the same command
    string, `>>`, as this is already defined as bit shifting to the right, so let's
    make it `>>>`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will define and then use a new "append" operator `>>>`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare an `infix operator`:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Define the behavior for our operator when used with two strings:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Define the behavior for our operator when appending a `String` to an array
    of strings:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Define the behavior for our operator when appending an array of strings to
    another array of strings:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'With these implementations in place, use our new operator to append things:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Refactor the preceding two operator implementations to use a generic element
    type for arrays:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Use the operator with arrays of any type:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We can implement our custom append operator for our own custom types too.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Task` and a `TaskList` to hold it:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Extend `TaskList` to add support for our new append operator:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Append a `Task` to a `TaskList` using our custom operator:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: How it works...
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we declared an `infix operator`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Operators can come in three types:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '`prefix` – Operates on one value and is placed before the value. An example
    is the NOT operator:'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '`postfix` – Operates on one value and is placed after the value. An example
    is the force unwrap operator:'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '`infix` - Operates on two values and is placed between them. An example is
    the addition operator:'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Once we have defined the operator, we can write top-level functions that implement
    the behavior for each pair of types: one on the **left-hand side** (**LHS**) and
    one on the **right-hand side** (**RHS**). Method parameter overloading allows
    us to specify the operator implementation for multiple-type pairings.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define how to append one string to another when our operator is used
    with strings:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We can implement appending a `String` to an array of strings:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We can also implement appending the elements in an array of strings to another
    array of strings:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This allows us to use the operator with strings and arrays of strings, as those
    are the implementations we defined:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We can implement our appending operator on every type of array that we think
    might be useful, but instead, we can implement it as a generic function and have
    it work for all arrays.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we can refactor the preceding two array implementations to use a generic
    element type:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'This allows us to use arrays of ints without having to explicitly define them
    for int arrays:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We can also implement it for our own custom types. Let''s create `Task` and
    `TaskList`, which might benefit from using the operator:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: We've added `CustomStringConvertible` conformance so that we can easily print
    out the result.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative to implementing the use of an operator as a top-level function
    is to declare it within the relevant type as a static function. We''ll declare
    it within an extension on our `TaskList` object, but we can just as easily declare
    it within the main `TaskList` class declaration:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Implementing this within a type has a few advantages: The implementation code
    is right next to the type itself, making it easier to find, and taking advantage
    of any values or types that might have a private, or otherwise restricted, access
    control, which will prevent them from being visible to a top-level function.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can use our `>>>` operator to append a `Task` to a `TaskList`:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: We have created a custom operator, to allow more concise and expressive code.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Operators don''t just work individually – they are often used within the same
    expression as other operators; the mathematical operators are a helpful example
    of this:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The order that each of these operations is performed in will affect the result.
    To understand the order in which the operations are performed, we can add brackets
    that will perform the same function:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'In Swift, the decision about how to order the operations is made using two
    concepts – precedence and associativity:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '**Precedence**: This defines how important the operation type is. Therefore
    the operations with the highest precedence are performed first; for example, multiplication
    (*) has higher precedence than addition (+) and is therefore always performed
    first.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Associativity**: This defines which side, left or right, a value should associate
    itself with for evaluation when it has an operation with the same precedence on
    either side. This has the effect of defining the order that operations of the
    same precedence should be evaluated in: left to right or right to left.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s use this information to understand the operation ordering of the preceding
    mathematical operation. We have an expression comprising of one addition and two
    division operations. Division operations have higher precedence than addition
    operations; therefore, the division operations are evaluated first:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We now have two division operations that need to be evaluated before the addition
    operation. Since both are division operators, they have the same precedence, so
    we have to look at associativity to know in which order to evaluate them. The
    division operation has an associativity of `left`, so they should be evaluated
    from left to right. Therefore, `8 / 2` is evaluated first and `4 / 4` is evaluated
    next. This gives us the following:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We need to define precedence and associativity for our custom operator, as
    the compiler does not currently know how it should be ordered within an expression
    containing multiple operations. Because of this, the following expression will
    not compile:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Precedence and associativity are defined within a precedence group, and an operator
    can either conform to an existing group or one that has been newly defined.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a new precedence group for our appending operator:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Here, we give it the name `AppendingPrecedence` and define its values within
    curly brackets. We'll set its associativity to the left to match mathematical
    operations, and to establish precedence, we define that this precedence group
    is higher than another precedence group and lower than some other precedence groups.
    For the appending operator, we'll set the precedence to be higher than addition,
    so it will be evaluated before the addition operators but after the multiplication
    operators. Both the `AdditionPrecendence` and `MultiplicationPrecedence` groups
    are defined by the *standard library*.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a precedence group defined, we can ensure that our custom
    operator conforms to it:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'With precedence and associativity declared, the composite expression previously
    created will now compile:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: We have defined how our custom operator works alongside other operators, allowing
    for complex combinations.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about custom operators can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/custom-operators](http://swiftbook.link/docs/custom-operators).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Nesting types and namespacing
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Objective-C, all objects are at the **top level** and are given a global
    scope. They can be said to be in the same **namespace**. This is one reason for
    the convention among Objective-C developers, including Apple, of prefixing their
    class names with two- or three-letter identifiers.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: These prefix characters allow similarly named classes from different frameworks
    to be differentiated, for example, *UIView* from *UIKit* and *SKView* from *SpriteKit*.
    Swift solves this problem by allowing types to be nested within other types, providing
    namespacing with nested types and modules.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Any type can be defined as being nested within another type. This allows us
    to tightly associate one type with another, in addition to providing namespacing,
    which helps differentiate types with the same name. In this recipe, we will create
    some nested types to see if it affects how they are referenced.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s build a system to monitor a physical device and the user interface that
    it displays. Both the device and the user interface have the concept of orientation,
    although each has a differing definition:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a class to represent the device:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Within this class, we have defined two enums, which only have value when used
    in relation to the `Device` class. Nesting the type also allows us to simplify
    the names of these types. It would be customary to name them `DeviceCategory`
    and `DeviceOrientation` to avoid confusion, but since they are nested, we can
    remove the `Device` prefix.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Any use of the nested types, within the type that contains them, can be used
    without any qualifiers; however, this is not the case for use outside of the containing
    type.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'Access nested types from outside the containing type using dot syntax:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: To reference a nested type, we must first specify the containing type, so the
    `Orientation` enum, within the `Device` class, becomes `Device.Orientation`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a struct to represent a user interface:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Our `UserInterface` struct also includes a nested `Orientation` enum, but as
    these two enums lie in different namespaces, there is no naming conflict. As before,
    the nested types can be used without any qualifiers in the containing type.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how these two nested types can be used in conjunction with one another.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a function to convert from device orientation to user interface orientation:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: How it works...
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our orientation conversion function specifies the full enum case for the `switch`
    statement and the `return` statements; for example:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'However, as we''ve seen previously when the compiler knows the type of the
    enum, only the case needs to be specified; the enum type can be removed. For our
    function, the input parameter type is `Device.Orientation` and the return type
    is `UserInterface.Orientation`, so the compiler does know enum types, and therefore
    we can remove the types:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们之前所看到的，当编译器知道枚举的类型时，只需要指定情况；可以移除枚举类型。对于我们的函数，输入参数类型是 `Device.Orientation`，返回类型是
    `UserInterface.Orientation`，因此编译器知道枚举类型，因此我们可以移除类型：
- en: '[PRE102]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Note that the `switch` case contains `.portrait` and returns `.portrait`, but
    these are cases from different enums, and the compiler knows the difference.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`switch` 语句中的 `.portrait` 情况返回 `.portrait`，但这些是来自不同枚举的情况，编译器知道它们的区别。
- en: There's more...
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We've seen how namespacing separates types nested within different containing
    types, but types within modules are also namespaced. This allows you to name your
    types without fear of collision with types in other modules.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了命名空间如何将嵌套在不同容器类型中的类型分开，但模块内的类型也是命名空间化的。这允许你命名你的类型，而不用担心与其他模块中的类型发生冲突。
- en: 'Let''s imagine that we are building an app for hospitals to keep track of their
    events and resources. As part of this, we create a class to represent surgical
    operations that we intend to track:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象我们正在为医院开发一个应用程序，以跟踪其事件和资源。作为其中的一部分，我们创建了一个类来表示我们打算跟踪的手术操作：
- en: '[PRE103]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'There is another class called `Operation`, provided by the **Foundation** framework,
    that can be used to execute and manage a long-running task. We can use both types
    of `Operation` side by side, because the `Foundation` framework is exposed as
    a module, and so the long-running `Operation` class can be used by referencing
    the `Foundation` module:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一个名为 `Operation` 的类，由 **Foundation** 框架提供，可以用来执行和管理长时间运行的任务。我们可以同时使用这两种类型的
    `Operation`，因为 `Foundation` 框架被公开为一个模块，因此可以通过引用 `Foundation` 模块来使用长时间运行的 `Operation`
    类：
- en: '[PRE104]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: We've seen how you can disambiguate two types with the same name, using the
    module they are within.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用它们所属的模块来区分具有相同名称的两个类型。
- en: See also
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Further information about nested types can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/nested-types](http://swiftbook.link/docs/nested-types).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 关于嵌套类型的更多信息可以在 Apple 的 Swift 语言文档中找到，请参阅 [http://swiftbook.link/docs/nested-types](http://swiftbook.link/docs/nested-types)。
