- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Architect Your App
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构你的应用程序
- en: The process of developing apps needs to be scalable in such a way that you can
    maintain the app over a long time and easily hand over the development of it to
    other developers or teams. To be able to do this, we need to properly think about
    the architecture of our apps. We will be looking at how to build our apps in this
    chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 开发应用程序的过程需要具有可扩展性，这样你就可以长期维护应用程序，并且可以轻松地将开发工作转交给其他开发者或团队。为了能够做到这一点，我们需要正确考虑我们应用程序的架构。在本章中，我们将探讨如何构建我们的应用程序。
- en: In this chapter, we will build on what we’ve learned from the previous chapters.
    We are going to look at the different architectures available for Android projects.
    We’ll dive deep into **MVVM architecture** and its different layers and how to
    use some of the Jetpack libraries within their architecture. Additionally, we’ll
    learn how to use advanced architecture features, such as dependency injection
    and Kotlin Gradle DSL, as well as version catalogs to define dependencies.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将基于前几章所学的内容进行构建。我们将探讨Android项目中可用的不同架构。我们将深入探讨**MVVM架构**及其不同层以及如何在架构中使用一些Jetpack库。此外，我们还将学习如何使用高级架构功能，例如依赖注入和Kotlin
    Gradle DSL，以及版本目录来定义依赖项。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Introduction to app architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序架构简介
- en: MVVM deep dive
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVVM深度解析
- en: Jetpack libraries
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jetpack库
- en: Dependency injection
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Migrating to Kotlin Gradle DSL and using version catalogs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迁移到Kotlin Gradle DSL和使用版本目录
- en: Technical Requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the instructions in this chapter, you will need to have Android Studio
    Hedgehog or later ([https://developer.android.com/studio](https://developer.android.com/studio))
    downloaded.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章中的说明，您需要下载Android Studio Hedgehog或更高版本([https://developer.android.com/studio](https://developer.android.com/studio))。
- en: You can find the code for this chapter at [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfive](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfive).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfive](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfive)找到本章的代码。
- en: Introduction to app architecture
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序架构简介
- en: 'So far, we have learned how to create apps and designed beautiful UIs with
    Material 3 and Jetpack Compose. We haven’t yet started adopting any architecture
    for our apps. In this section, we will look at some of the app architectures that
    we can use to build our apps. We will also look at some of the best practices
    that we can follow when building our apps. First, let’s see some of the benefits
    of using an app architecture:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何使用Material 3和Jetpack Compose创建应用程序并设计美观的用户界面。我们还没有开始为我们的应用程序采用任何架构。在本节中，我们将探讨一些我们可以用来构建应用程序的应用程序架构。我们还将探讨在构建应用程序时可以遵循的一些最佳实践。首先，让我们看看使用应用程序架构的一些好处：
- en: '**Separation of concerns**: Using an architecture allows us to separate our
    code into different layers. Each layer only does one thing. This makes it easy
    to separate and group our code into different layers. Each layer has its responsibility.
    This prevents things from being mixed up and makes it easier to maintain our code.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注点分离**：使用架构允许我们将代码分成不同的层。每一层只做一件事。这使得轻松地将代码分离和分组到不同的层变得容易。每一层都有其责任。这防止了事物被混淆，并使得维护代码变得更容易。'
- en: '**Easy testing**: Using an architecture makes it easy to test our code. We
    can easily test each layer of our code in isolation since things are not tightly
    coupled.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简易测试**：使用架构使得测试我们的代码变得容易。由于事物之间不是紧密耦合的，我们可以轻松地单独测试代码的每一层。'
- en: '**Easy to maintain**: Using an architecture makes it easy to maintain our code.
    We can easily make changes to our code without affecting other parts of our code.
    This makes it easy to maintain our code over the long term. We can also swap in
    and out different parts of the code, and since we have tests, we can test the
    different implementations and ensure that nothing breaks.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于维护**：使用架构使得维护我们的代码变得容易。我们可以轻松地修改代码，而不会影响代码的其他部分。这使得长期维护代码变得容易。我们还可以替换代码的不同部分，因为我们有测试，我们可以测试不同的实现并确保没有东西被破坏。'
- en: '**Easy to scale**: Using an architecture makes it easy to scale our code. We
    can easily add new features to our code without affecting other parts of our code.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于扩展**：使用架构使得扩展我们的代码变得容易。我们可以轻松地添加新功能到代码中，而不会影响代码的其他部分。'
- en: '**Easy to work in teams**: Using an architecture makes it easy to work in teams.
    Each team member or team can work on a different layer of the code. It makes it
    possible to work concurrently on different parts of the codebase.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于团队合作**：使用架构使得团队合作变得容易。每个团队成员或团队可以工作在代码的不同层。这使得在代码库的不同部分并行工作成为可能。'
- en: '**Promotes reusability**: Over time, we can place some of the commonly used
    code across the projects in common packages or modules, which can then be re-used
    across the project without having to repeat the code.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**促进可重用性**：随着时间的推移，我们可以将一些常用代码放置在项目中的通用包或模块中，然后可以在整个项目中重用这些代码，而无需重复编写代码。'
- en: 'When it comes to choosing an architecture for our apps, there are a lot of
    options that we can choose from. There isn’t a particular architecture that fits
    all the use cases, so it’s always recommended that we discuss things with our
    teams and see which architecture fits the use case. Each architecture has its
    pros and cons, and we or the whole team have to evaluate which one has more pros
    than cons. We can architect our app either by feature or by layers. When we architect
    by feature, we have layers that represent a feature. When we architect by layers,
    we have layers that represent a layer of our app. An example of architecting by
    feature is shown in the following points:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到为我们的应用选择架构时，我们有大量的选项可以选择。没有特定的架构适合所有用例，因此我们总是建议与我们的团队讨论，看看哪种架构适合用例。每种架构都有其优缺点，我们或整个团队必须评估哪个的优点多于缺点。我们可以通过功能或通过层来构建我们的应用架构。当我们按功能构建架构时，我们有代表功能的层。当我们按层构建架构时，我们有代表我们应用层的层。以下是一些按功能构建架构的示例：
- en: Home feature
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主页功能
- en: Profile feature
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个人资料功能
- en: Settings feature
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置功能
- en: The preceding example shows how we can architect our app by feature. We have
    the **Home**, **Profile**, and **Settings** features. Each feature has its layers
    and all the code related to that feature.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例展示了我们如何通过功能来构建我们的应用架构。我们有**主页**、**个人资料**和**设置**功能。每个功能都有自己的层，以及与该功能相关的所有代码。
- en: 'Some of the architectures that we can use to build our apps are the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用来构建应用的架构之一如下：
- en: '**Model, View, and ViewModel** (**MVVM**): This is the most commonly used architecture
    and is even recommended by Google to use with our apps. The app has the **Model**
    **View** and **ViewModel** layers. The Model layer is responsible for holding
    the data. The View layer is responsible for displaying the data. The ViewModel
    layer is responsible for holding the state of the data. It is also responsible
    for communicating with the Model and View layers. MMVM promotes the clear separation
    of concerns between the different layers. It also supports **data binding**, which
    makes it easy to update the UI when the data change. It also supports testing
    since the different layers are not tightly coupled. It also has less boilerplate
    code when compared to other architectures. However, it has its downsides, one
    of them being a large learning curve at times and this can become complex very
    easily, especially with lots of features.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型、视图和视图模型**（**MVVM**）：这是最常用的架构，甚至谷歌也推荐我们在应用中使用它。应用具有**模型**、**视图**和**视图模型**层。模型层负责存储数据。视图层负责显示数据。视图模型层负责存储数据的状态。它还负责与模型和视图层进行通信。MVVM促进了不同层之间关注点的清晰分离。它还支持**数据绑定**，这使得在数据变化时更新UI变得容易。与其他架构相比，它还有更少的样板代码。然而，它也有其缺点，其中之一是在某些时候学习曲线较大，并且很容易变得复杂，尤其是在有很多功能的情况下。'
- en: '**Model View Intent** (**MVI**): This has three key layers. The **Model** layer
    is responsible for holding the data. The **View** layer is responsible for displaying
    the data. The **Intent** layer represents user actions or events that are dispatched
    to the model to update a state. MVI promotes unidirectional **data flow**, where
    data flow in the same direction.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型视图意图**（**MVI**）：它有三个关键层。模型层负责存储数据。视图层负责显示数据。意图层代表用户操作或事件，这些操作或事件被调度到模型以更新状态。MVI促进单向**数据流**，数据流向同一方向。'
- en: '**Model View Controller** (**MVC**): This architecture has three layers. The
    **Model** layer represents the business logic and holds the data. The **View**
    layer is responsible for displaying the data. The **Controller** layer is responsible
    for and acts as an intermediary between the model and the view. It takes care
    of the user input and updates the view and the model. MVC is very straightforward,
    especially when starting out, and enables quick iterations and a showcase of app
    architecture. Its only problem is that it has a tight coupling between the layers,
    making it hard to test and scale.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型-视图-控制器**（**MVC**）：这种架构有三个层次。**模型**层代表业务逻辑并持有数据。**视图**层负责显示数据。**控制器**层负责并在模型和视图之间充当中间人。它处理用户输入并更新视图和模型。MVC
    非常直接，尤其是在开始时，它能够实现快速迭代和展示应用架构。它唯一的问题是层与层之间耦合紧密，这使得测试和扩展变得困难。'
- en: '**Model View Presenter** (**MVP**): This architecture has three layers. The
    **Model** layer represents the business logic and holds the data. The **View**
    layer displays the data and UI components and observes user interactions. The
    views delegate all UI-related logic to the presenters. The **Presenter** layer
    contains presentation logic and acts as an intermediary between the model and
    the view. It processes the user input and updates the view and the model. MVP
    has a good separation of concerns, and the code is easily testable. However, it
    has a lot of boilerplate code since every view must have its own presenter. It
    also has a large learning curve and can become complex very easily.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型-视图-表示者**（**MVP**）：这种架构有三个层次。**模型**层代表业务逻辑并持有数据。**视图**层显示数据和 UI 组件，并观察用户交互。视图将所有
    UI 相关逻辑委托给表示者。**表示者**层包含表示逻辑，并在模型和视图之间充当中间人。它处理用户输入并更新视图和模型。MVP 具有良好的关注点分离，代码易于测试。然而，由于每个视图都必须有自己的表示者，因此它有很多样板代码。它也有一个较大的学习曲线，并且很容易变得复杂。'
- en: Now that we understand the different architectures, let us look at MVVM and
    how we can use it in our apps.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了不同的架构，让我们看看 MVVM 以及我们如何在应用中使用它。
- en: Deep Diving into MVVM
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解 MVVM
- en: We have already seen the MVVM layers and their pros and cons. In this section,
    we are going to implement the MMVM architecture in our app step by step. We will
    start with the model layer, going upwards. Since we all love to have the company
    of our pets, we are going to use different types of pets as our data.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 MVVM 层及其优缺点。在本节中，我们将逐步在我们的应用中实现 MMVM 架构。我们将从模型层开始，向上进行。由于我们都喜欢有宠物的陪伴，我们将使用不同类型的宠物作为我们的数据。
- en: 'Let us start by creating a `com.packt.chapterfive` package; then, we select
    `data`. Inside this `data` package, let us create a `Pet` data class that will
    represent our pets:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个 `com.packt.chapterfive` 包；然后，我们选择 `data`。在这个 `data` 包内，让我们创建一个 `Pet`
    数据类，它将代表我们的宠物：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `Pet` data class holds all the data for our pets. Next, we will create
    a repository interface and its implementation that allows us to get these pets.
    Create a new file named `PetsRepository` inside the `data` package with the following
    code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pet` 数据类包含了我们宠物所有的数据。接下来，我们将创建一个仓库接口及其实现，以便我们能够获取这些宠物。在 `data` 包内创建一个名为 `PetsRepository`
    的新文件，并包含以下代码：'
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is an interface with one method that returns `List<Pet>`. Next, let us
    create the implementation class for our interface. While still inside the `data`
    package, create a new file named `PetsRepositoryImpl` with the following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含一个方法返回 `List<Pet>` 的接口。接下来，让我们为我们的接口创建实现类。仍然在 `data` 包内，创建一个名为 `PetsRepositoryImpl`
    的新文件，并包含以下代码：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To explain what the preceding code does, please see the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释前面代码的功能，请参阅以下内容：
- en: We created a class named `PetsRepositoryImpl`, which implements the `PetsRepository`
    interface
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `PetsRepositoryImpl` 的类，它实现了 `PetsRepository` 接口
- en: We override the `getPets()` method and return a list of pets. Our list has 10
    pets with **ID**, **name**, and **species**
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们重写了 `getPets()` 方法并返回一个宠物列表。我们的列表有 10 只宠物，包括 **ID**、**名称**和**种类**。
- en: We have used a pattern called the **repository pattern** to get our pets. The
    repository pattern is a pattern that allows us to abstract the data layer from
    the rest of the app. It allows us to get data from different sources without affecting
    the rest of the app. For example, we can get data from a local database or a remote
    server. The class is responsible for merging the data from the two sources and
    maintaining the source of truth for our data. The repository pattern also allows
    us to easily test our code since we can easily mock the repository and test the
    different layers of our app in isolation. Since our app is very simple at the
    moment, we have already completed the data/model layer of our architecture.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一种称为 **仓库模式** 的模式来获取我们的宠物。仓库模式是一种允许我们将数据层从应用程序的其余部分抽象出来的模式。它允许我们从不同的来源获取数据，而不会影响应用程序的其余部分。例如，我们可以从本地数据库或远程服务器获取数据。该类负责合并来自两个来源的数据，并维护我们数据的真实来源。仓库模式还允许我们轻松地测试我们的代码，因为我们可以轻松地模拟仓库并独立测试我们应用程序的不同层。由于我们的应用程序目前非常简单，我们已完成了我们架构的数据/模型层。
- en: 'Let us now create a `ViewModel` class for our `ViewModel` layer. Start by creating
    a `ViewModel` package inside the `com.packt.chapterfive` package. Inside this
    `ViewModel` package, create a new file named `PetsViewModel` with the following
    code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的 `ViewModel` 层创建一个 `ViewModel` 类。首先，在 `com.packt.chapterfive` 包内创建一个
    `ViewModel` 包。在这个 `ViewModel` 包内，创建一个名为 `PetsViewModel` 的新文件，并包含以下代码：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To explain what the preceding code does, please see the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释前面的代码做了什么，请参阅以下内容：
- en: We created a class named `PetsViewModel` that extends the `ViewModel` class.
    This is a class from the **Jetpack libraries**. It helps data persist across configuration
    changes. It also acts as the intermediary between the View and the Model layers.
    We use it to expose data to our views, act on user interactions, and update the
    data in the Model layer.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `PetsViewModel` 的类，它扩展了 `ViewModel` 类。这是一个来自 **Jetpack 库** 的类。它有助于数据在配置更改之间持久化。它还充当视图层和模型层之间的中介。我们使用它来向视图暴露数据，对用户交互进行操作，并在模型层中更新数据。
- en: We created a private property named `petsRepository` of type `PetsRepository`
    and initialized it with an instance of `PetsRepositoryImpl`. This is the repository
    we created earlier.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `petsRepository` 的私有属性，其类型为 `PetsRepository`，并用 `PetsRepositoryImpl`
    的一个实例初始化它。这是我们之前创建的仓库。
- en: We created a method named `getPets()` that returns a list of pets. We called
    the `getPets()` method from the `petsRepository` property and returned the result.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `getPets()` 的方法，它返回一个宠物列表。我们从 `petsRepository` 属性调用 `getPets()` 方法，并返回结果。
- en: With this, our `ViewModel` layer is ready to expose data to our views. Our `getPets()`
    method returns a list of pets. To display the list in `LazyColumn` composable.
    `LazyColumn` follows a lazy-loading approach, meaning that only the items currently
    visible on the screen are actively composed, reducing resource usage and improving
    performance. Let us see how a `LazyColumn` works under the hood.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的 `ViewModel` 层就准备好向我们的视图暴露数据了。我们的 `getPets()` 方法返回一个宠物列表。为了在 `LazyColumn`
    组合视图中显示列表，`LazyColumn` 采用懒加载方法，这意味着只有屏幕上当前可见的项目会被积极地组合，从而减少资源使用并提高性能。让我们看看 `LazyColumn`
    在底层是如何工作的。
- en: How LazyColumn works
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`LazyColumn` 的工作原理'
- en: 'This is how a `LazyColumn` works:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `LazyColumn` 的工作方式：
- en: '`LazyColumn` composes only the visible items on the screen. As the user scrolls,
    it dynamically composes and recomposes items, ensuring that only the necessary
    elements are rendered at any given time.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LazyColumn` 仅在屏幕上组合可见的项目。当用户滚动时，它会动态地组合和重新组合项目，确保在任何给定时间只渲染必要的元素。'
- en: '`RecyclerView`, `LazyColumn` reuses composables that move in and out of the
    viewport, minimizing memory usage and preventing unnecessary recomposition.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RecyclerView`，`LazyColumn` 重新使用在视图中移动进出的可组合项，最小化内存使用并防止不必要的重新组合。'
- en: '`LazyColumn` optimizes the rendering process, making it well-suited for displaying
    large datasets without consuming excessive resources.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LazyColumn` 优化了渲染过程，使其非常适合显示大量数据集而不会消耗过多的资源。'
- en: Now that we know how `LazyColumn` works, let’s see the benefits of using `LazyColumn`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了 `LazyColumn` 的工作原理，让我们看看使用 `LazyColumn` 的好处。
- en: Benefits of LazyColumn
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`LazyColumn` 的好处'
- en: 'Some of the benefits of `LazyColumn` are the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`LazyColumn` 的一些好处如下：'
- en: '`LazyColumn` efficiently manages memory by composing only the visible items,
    ensuring that the app does not unnecessarily store and render all items in a list
    at once. This is particularly beneficial for long lists or lists with complex
    UI elements.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LazyColumn` 通过仅组合可见项来高效管理内存，确保应用不会不必要地存储和渲染列表中的所有项。这对于长列表或包含复杂 UI 元素的列表尤其有益。'
- en: '**Improved rendering performance**: The lazy-loading mechanism significantly
    improves rendering performance, especially when dealing with extensive datasets.
    It avoids the overhead of rendering and managing all items simultaneously, resulting
    in smoother scrolling and reduced lag.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改进的渲染性能**：懒加载机制显著提高了渲染性能，尤其是在处理大量数据集时。它避免了同时渲染和管理所有项的开销，从而实现了更平滑的滚动和减少延迟。'
- en: '`LazyColumn`, allows us to express UI logic concisely. The code to create and
    manage large lists becomes more straightforward and readable compared to traditional
    Android View approaches.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LazyColumn` 允许我们简洁地表达 UI 逻辑。与传统的 Android View 方法相比，创建和管理大型列表的代码变得更加简单和易于阅读。'
- en: '`LazyColumn` automatically recomposes only the affected items, reducing the
    need for manual interventions to update the UI.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LazyColumn` 自动仅重新组合受影响的项，减少了手动干预以更新 UI 的需求。'
- en: '`LazyColumn` adapts well to different screen sizes and resolutions, offering
    a consistent and responsive user experience across various devices.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LazyColumn` 适应不同的屏幕尺寸和分辨率，在各种设备上提供一致和响应式的用户体验。'
- en: Now, we’re going to create a composable that displays pets.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个显示宠物的可组合组件。
- en: Creating a composable
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个可组合组件
- en: 'Follow these steps to create a composable:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个可组合组件：
- en: Create a new package named `views` inside the `com.packt.chapterfive` package.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `com.packt.chapterfive` 包内部创建一个名为 `views` 的新包。
- en: 'Inside this `views` package, create a new file named `PetsList` with the following
    code:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个 `views` 包内部，创建一个名为 `PetsList` 的新文件，并包含以下代码：
- en: '[PRE4]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we have created a composable named `PetList` that takes a modifier as
    a parameter. We then create an instance of `PetsViewModel` using the `viewModel()`
    function from the lifecycle utility library for `ViewModel` in compose. It helps
    us easily create an instance of our `PetsViewModel`. We then use the `LazyColumn`
    composable to display the pets. We pass the list of pets from the `ViewModel`
    to the `items` parameter of the `LazyColumn`. We then use the `Row` composable
    to display the name and species of each pet. We have now completed the view layer
    of our architecture.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为 `PetList` 的可组合组件，它接受一个修饰符作为参数。然后，我们使用生命周期实用库中为 `ViewModel` 在 compose
    中的 `viewModel()` 函数创建 `PetsViewModel` 的一个实例。这有助于我们轻松创建 `PetsViewModel` 的实例。接着，我们使用
    `LazyColumn` 可组合组件来显示宠物。我们将来自 `ViewModel` 的宠物列表传递给 `LazyColumn` 的 `items` 参数。然后，我们使用
    `Row` 可组合组件来显示每个宠物的名称和种类。现在，我们已经完成了我们架构中的视图层。
- en: 'To finally display our pets, we need to call our `PetList` composable inside
    the `setContent` block of our `MainActivity` class:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要最终显示我们的宠物，我们需要在 `MainActivity` 类的 `setContent` 块内部调用我们的 `PetList` 可组合组件：
- en: '[PRE5]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We are using the `Scaffold` composable, which we are already familiar with.
    In our `Scaffold`, we are passing in a `TopAppBar` and our `PetList` composable.
    We are also passing in `paddingValues` to our `PetList` composable. This is because
    we are using `paddingValues` to add padding to our `PetList` composable. We have
    now completed the MVVM architecture in our app. Let’s run the app and see the
    result:'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们正在使用我们已熟悉的 `Scaffold` 可组合组件。在我们的 `Scaffold` 中，我们传递了一个 `TopAppBar` 和我们的 `PetList`
    可组合组件。我们还向 `PetList` 可组合组件传递了 `paddingValues`。这是因为我们正在使用 `paddingValues` 为 `PetList`
    可组合组件添加填充。现在，我们已经完成了我们应用中的 MVVM 架构。让我们运行应用并查看结果：
- en: '![Figure 5.1 – Pet list](img/B19779_05_01.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 宠物列表](img/B19779_05_01.jpg)'
- en: Figure 5.1 – Pet list
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 宠物列表
- en: As seen from the preceding image, we have our list of pets with their name and
    species displayed in a list.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，我们有一个宠物列表，其中显示了宠物的名称和种类。
- en: We have mentioned **Jetpack libraries** a lot in this section but have not explained
    what they are. In the next section, we are going to look at Jetpack libraries
    in detail.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们多次提到了 **Jetpack 库**，但尚未解释它们是什么。在下一节中，我们将详细探讨 Jetpack 库。
- en: Jetpack libraries
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jetpack 库
- en: 'Jetpack Libraries are a collection of libraries and APIs from Google that help
    us developers create better apps using less code. They are normally created to
    address some pain points we, as developers, face while creating our apps. Let’s
    look at some of these pain points and some of the Jetpack libraries that were
    created to address them:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack Libraries是Google提供的一系列库和API，帮助我们开发者使用更少的代码创建更好的应用程序。它们通常是为了解决我们在创建应用程序时面临的一些痛点而创建的。让我们看看一些这些痛点以及为解决它们而创建的一些Jetpack库：
- en: '**Storing data locally and observing changes to the data**: We had to use **SQLite**
    to store data locally. Even for simple **Create**, **Read**, **Update**, and **Delete**
    (**CRUD**) operations, we had to write a lot of boilerplate code. We also had
    to write a lot of code to observe changes to the data. This is a lot of work for
    a simple task. Jetpack libraries, such as **Room** and **LiveData**, were created
    to address this pain point. Room is a library that allows us to easily store data
    locally. It also allows us to easily observe changes to the data. LiveData is
    a library that allows us to observe changes to data easily. It is also lifecycle-aware.
    This means it automatically stops observing data changes when the lifecycle of
    the component observing the data ends. This helps us avoid memory leaks in our
    apps. Room also has support for **Kotlin Coroutines**, which we will be looking
    at deeply in [*Chapter 6*](B19779_06.xhtml#_idTextAnchor084). This makes it easy
    to store and access data locally with less boilerplate code.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在本地存储数据和观察数据变化**：我们不得不使用**SQLite**来本地存储数据。即使是简单的**创建**、**读取**、**更新**和**删除**（**CRUD**）操作，我们也必须编写大量的模板代码。我们还需要编写大量代码来观察数据的变化。对于这样一个简单的任务来说，这是一项大量的工作。为了解决这个痛点，创建了Jetpack库，例如**Room**和**LiveData**。Room是一个库，使我们能够轻松地本地存储数据。它还允许我们轻松地观察数据的变化。LiveData是一个库，使我们能够轻松地观察数据的变化。它还具有生命周期感知功能。这意味着当观察数据的组件的生命周期结束时，它会自动停止观察数据变化。这有助于我们避免在应用程序中发生内存泄漏。Room还支持**Kotlin
    Coroutines**，我们将在[*第6章*](B19779_06.xhtml#_idTextAnchor084)中深入探讨。这使得使用更少的模板代码轻松地本地存储和访问数据变得容易。'
- en: '**Navigation was a challenging thing to achieve perfectly in our apps**: Lots
    of open-source libraries were created to solve this pain point. It also required
    a lot of boilerplate code to navigate between activities and fragments and maintain
    consistent and predictable back behavior. **Jetpack Navigation** was created to
    address this pain point. It allows us to navigate between screens in our app easily.
    It also allows us to easily maintain consistent and predictable back behavior.
    It also allows us to pass data between screens in our app. It also has support
    for Jetpack Compose and functions, such as deep links, which are supposed to open
    a specific screen in our app when a user clicks on a link.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在我们的应用程序中完美实现导航是一个挑战**：为了解决这个问题，创建了大量的开源库。在活动、片段之间导航并保持一致和可预测的返回行为也需要大量的模板代码。**Jetpack
    Navigation**就是为了解决这个痛点而创建的。它允许我们轻松地在应用程序中的屏幕之间导航。它还允许我们轻松地保持一致和可预测的返回行为。它还允许我们在应用程序的屏幕之间传递数据。它还支持Jetpack
    Compose和函数，例如深链接，当用户点击链接时，它应该打开我们应用程序中的特定屏幕。'
- en: '**Handling lifecycle in activities and fragments**: In Android, both activities
    and fragments have their own lifecycle, and it is particularly important for us
    to be aware of these lifecycles so that we can be able to do operations in the
    right lifecycle. For example, we should be observing data in our views when the
    lifecycle is in the started state and free up resources when the lifecycle is
    either in the stopped or destroyed state. Doing this was harder and required a
    lot of code, which could be bug-prone. The team at Google came up with the **lifecycle**
    library to help us manage lifecycles in our activities and fragments. Additionally,
    we have classes, such as the **ViewModel**, which we created earlier on, that
    allow your data to persist across configuration changes. Most of the Jetpack libraries
    are also lifecycle-aware, which makes it easy to use them in our apps. Taking
    the ViewModel as an example, it survives beyond the lifecycle of the activity
    or fragment that created it. This makes it easy for data to persist across configuration
    changes. It also makes it easy to share data between fragments and activities.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理活动和片段的生命周期**：在Android中，活动和片段都有自己的生命周期，对于我们来说，了解这些生命周期非常重要，这样我们才能在正确的生命周期中进行操作。例如，当生命周期处于启动状态时，我们应该在我们的视图中观察数据，当生命周期处于停止或销毁状态时，我们应该释放资源。这样做比较困难，需要大量的代码，而且容易出错。谷歌团队提出了**生命周期**库来帮助我们管理活动和片段的生命周期。此外，我们还有像**ViewModel**这样的类，这是我们之前创建的，它允许数据在配置更改之间持久化。大多数Jetpack库也是生命周期感知的，这使得它们在我们的应用中使用起来非常方便。以ViewModel为例，它在其创建的活动或片段的生命周期之外仍然存在。这使得数据在配置更改之间持久化变得容易。它还使得在片段和活动之间共享数据变得简单。'
- en: '**Loading infinite lists**: Most apps that we developers work on have a list
    of items that we want to show to our users. Often, this list of items can be large,
    and we cannot display all of them at once. We are supposed to display them in
    batches, which is called **pagination**. To achieve this by ourselves, we had
    to do several workarounds, such as observing the scroll position and fetching
    the next or previous batch of items when a user reaches the top or bottom of the
    list. Again, this was quite a bit of work, and the team at Google introduced the
    **Paging** library to help us achieve this. It allows us to load data in batches
    easily and display it to our users. It also has support for Jetpack Compose and
    Kotlin Coroutines. It makes it easy to display infinite lists in our apps.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加载无限列表**：我们开发者工作的大多数应用都需要向用户展示一个项目列表。通常，这个列表可能很大，我们无法一次性显示所有内容。我们应该分批显示它们，这被称为**分页**。为了我们自己实现这一点，我们必须做一些工作，比如观察滚动位置，当用户到达列表的顶部或底部时，获取下一批或上一批的项目。同样，这需要相当多的工作，谷歌团队引入了**Paging**库来帮助我们实现这一点。它允许我们轻松地批量加载数据并显示给用户。它还支持Jetpack
    Compose和Kotlin Coroutines。这使得在我们的应用中显示无限列表变得容易。'
- en: '**Handling background jobs**: Performing lengthy background tasks for apps
    proved to be somewhat challenging. The common issue was that some of the background
    jobs did not run due to the different restrictions that phone manufacturers add
    to the phones to improve their performance of the phone. The team at Google introduced
    the **WorkManager** library to help us achieve this. It allows us to schedule
    background jobs in our apps easily. It also supports periodic background jobs
    and ensures that our jobs run irrespective of the phone brand that the user is
    using.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理后台任务**：为应用执行长时间的后台任务证明是有些挑战性的。常见的问题是，由于手机制造商为了提高手机性能而在手机上添加的不同限制，一些后台任务没有运行。谷歌团队引入了**WorkManager**库来帮助我们实现这一点。它允许我们轻松地在我们的应用中安排后台任务。它还支持周期性后台任务，并确保我们的任务在用户使用的手机品牌无关的情况下运行。'
- en: '**Performance**: There was no clear guidance on how best we developers can
    improve the performance of our apps. That is not the case anymore; we have several
    Jetpack libraries to help us detect performance issues and improve the performance
    of our apps. A good example of this is the **baseline profiles**, which help improve
    app start-up time and make app interactions much smoother.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：关于我们开发者如何最好地提高应用性能并没有明确的指导。这种情况已经不再存在了；我们有几个Jetpack库来帮助我们检测性能问题并提高应用性能。一个很好的例子是**基准配置文件**，它有助于提高应用启动时间，并使应用交互更加流畅。'
- en: 'There are a lot of Jetpack libraries. You can explore all the available Jetpack
    libraries here: [https://developer.android.com/jetpack/androidx/explorer](https://developer.android.com/jetpack/androidx/explorer).
    The following are some of the benefits of using Jetpack libraries:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack 库有很多。您可以在以下位置探索所有可用的 Jetpack 库：[https://developer.android.com/jetpack/androidx/explorer](https://developer.android.com/jetpack/androidx/explorer)。以下是一些使用
    Jetpack 库的好处：
- en: We can follow the best practices
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以遵循最佳实践
- en: We can write less boilerplate code
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以编写更少的样板代码
- en: We reduce fragmentation
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们减少了碎片化
- en: The APIs work well together
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 之间协同工作良好
- en: We have already seen how to use a `ViewModel` class in this chapter. We will
    also be using other Jetpack libraries in the later chapters of this book.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中已经看到了如何使用 `ViewModel` 类。我们还将在这本书的后续章节中使用其他 Jetpack 库。
- en: We have looked at how the Jetpack Libraries fit in with the different layers
    of our architecture. In the next section, we are looking at an important topic
    in architecture, which is **dependency injection**.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了 Jetpack 库如何与我们的架构的不同层相匹配。在下一节中，我们将探讨架构中的一个重要主题，即 **依赖注入**。
- en: Dependency injection
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Dependency injection is a way for us to manage and provide dependencies that
    a class needs to do its work without the class having to create the dependencies
    itself. In this book, we will be using Koin ([https://insert-koin.io/](https://insert-koin.io/))
    as our dependency injection library.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是我们管理并提供类执行其工作所需的依赖项的一种方式，而无需类自己创建这些依赖项。在这本书中，我们将使用 Koin ([https://insert-koin.io/](https://insert-koin.io/))
    作为我们的依赖注入库。
- en: 'Our `PetsViewModel` class creates the `PetsRepository` class by itself. This
    is a suitable candidate for dependency injection. We will be refactoring this
    to use dependency injection. Let’s start by adding the Koin dependency to our
    app. Open the `build.gradle` file for the app module and add the following dependency:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `PetsViewModel` 类会自行创建 `PetsRepository` 类。这是一个适合依赖注入的候选者。我们将重构这部分代码以使用依赖注入。让我们首先将
    Koin 依赖添加到我们的应用中。打开应用模块的 `build.gradle` 文件，并添加以下依赖项：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We are adding the Koin `core`, `android,` and `compose` dependencies as well,
    which will be used in our project to provide the dependencies.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了 Koin 的 `core`、`android` 和 `compose` 依赖项，这些依赖项将在我们的项目中使用，以提供所需的依赖。
- en: 'After adding this to our project and syncing the project, we need to create
    Koin `PetsRepository` class. Create a new package named `di` inside the `com.packt.chapterfive`
    package. Inside this `di` package, create a new file named `Modules` and add the
    following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在将此添加到我们的项目并同步项目后，我们需要创建 Koin 的 `PetsRepository` 类。在 `com.packt.chapterfive`
    包内创建一个名为 `di` 的新包。在这个 `di` 包内，创建一个名为 `Modules` 的新文件，并添加以下代码：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code above, we are creating a new variable named `appModules`
    of the type module. We are using the `module` function from the Koin library to
    create a module. We are using the `single` function to create a single instance
    of the `PetsRepository` class. Koin has dependency injection scopes, such as `single`,
    `factory`, and `scoped`, that govern the lifecycle and visibility of dependency
    instances within the container. The `single` scope creates singleton instances
    that persist throughout the entire application, making it suitable for objects
    requiring a globally shared state, such as database instances. `Factory` scope
    generates new instances each time they are requested, fitting stateless utility
    classes or objects that don’t need to maintain a persistent state. The `scoped`
    scope ties instances to specific contexts, such as activity or fragment lifecycles,
    allowing them to be shared within a designated scope but recreated for different
    contexts. The `single` scope is particularly useful for managing global or long-lived
    dependencies efficiently, ensuring a single instance is shared consistently across
    various components of the application, thereby optimizing resource usage and maintaining
    a unified state. This is why we are using `single` to create an instance of our
    `PetsRepository` class. We are using the `PetsRepositoryImpl` class as the implementation
    of the `PetsRepository` interface.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们创建了一个名为 `appModules` 的新变量，其类型为模块。我们使用 Koin 库中的 `module` 函数创建一个模块。我们使用
    `single` 函数创建 `PetsRepository` 类的单个实例。Koin 有依赖注入作用域，如 `single`、`factory` 和 `scoped`，这些作用域控制容器内依赖实例的生命周期和可见性。`single`
    作用域创建单例实例，它们在整个应用程序中持续存在，适合需要全局共享状态的对象，例如数据库实例。`Factory` 作用域在每次请求时生成新实例，适合无状态的实用类或不需要维护持久状态的对象。`scoped`
    作用域将实例绑定到特定上下文，例如活动或片段生命周期，允许它们在指定的作用域内共享，但在不同的上下文中重新创建。`single` 作用域特别适用于有效地管理全局或长期依赖项，确保应用程序的各个组件之间始终共享单个实例，从而优化资源使用并维护统一的状态。这就是我们为什么使用
    `single` 来创建 `PetsRepository` 类的实例。我们使用 `PetsRepositoryImpl` 类作为 `PetsRepository`
    接口的实现。
- en: 'Next, we will refactor our `PetsViewModel` class to use dependency injection.
    Open the `PetsViewModel` class and update it as shown in the following code snippet:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将重构 `PetsViewModel` 类以使用依赖注入。打开 `PetsViewModel` 类，并按照以下代码片段进行更新：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code, we have removed the instantiation of the `PetsRepository`
    class from the `PetsViewModel` class. We have, instead, added a `constructor`
    that takes a `PetsRepository` parameter. We also need to create a new dependency
    for `ViewModel`, just below the `PetsRepository` dependency in our `appModules`
    variable. Let us add the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们从 `PetsViewModel` 类中移除了 `PetsRepository` 类的实例化。相反，我们添加了一个接受 `PetsRepository`
    参数的 `constructor`。我们还需要在 `appModules` 变量中 `PetsRepository` 依赖项下方创建一个新的 `ViewModel`
    依赖。让我们添加以下代码：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here, we are creating a `single` instance of the `PetsViewModel` class. We
    are using the `get()` function to get the `PetsRepository` dependency. We are
    passing it to the constructor of the `PetsViewModel` class. With this, our app
    is ready to use these dependencies. We will also change the way we create the
    `PetsViewModel` instance in our `PetList` composable. Open the `PetList` composable
    and update the initialization of `PetsViewModel`, as shown here:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建 `PetsViewModel` 类的一个 `single` 实例。我们使用 `get()` 函数获取 `PetsRepository`
    依赖项。我们将它传递给 `PetsViewModel` 类的构造函数。有了这个，我们的应用程序就准备好使用这些依赖项了。我们还将更改在 `PetList`
    可组合组件中创建 `PetsViewModel` 实例的方式。打开 `PetList` 可组合组件，并按照以下方式更新 `PetsViewModel` 的初始化，如下所示：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Instead of using the `ViewModel()` function from the lifecycle library, we are
    using the `koinViewModel()` function from the Koin library. This function helps
    us create an instance of the `PetsViewModel` class. This now returns an instance
    of `PetsViewModel` that has the `PetsRepository` dependency injected.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是使用生命周期库中的 `ViewModel()` 函数，而是使用 Koin 库中的 `koinViewModel()` 函数。这个函数帮助我们创建
    `PetsViewModel` 类的一个实例。现在它返回一个具有 `PetsRepository` 依赖注入的 `PetsViewModel` 实例。
- en: 'The last step in ensuring our app has dependency injection setup is to initialize
    Koin in our app. We will create a class that extends the `Application` class and
    initialize Koin in the `onCreate()` method. Create a new file named `ChapterFiveApplication`
    and add the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 确保我们的应用已设置依赖注入的最后一步是在我们的应用中初始化 Koin。我们将创建一个扩展 `Application` 类的类，并在 `onCreate()`
    方法中初始化 Koin。创建一个名为 `ChapterFiveApplication` 的新文件，并添加以下代码：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Our `ChapterFiveApplication` class extends the `Application` class. We are
    overriding the `onCreate()` method and calling the `startKoin()` function. We
    are using the `modules` parameter to pass in the `appModules` variable that we
    created earlier on. This initializes Koin in our app. We also need to update the
    `AndroidManifest.xml` file to use our `ChapterFiveApplication` class. Open the
    `AndroidManifest.xml` file and update the application tag with the name attribute,
    as shown here:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `ChapterFiveApplication` 类扩展了 `Application` 类。我们正在重写 `onCreate()` 方法并调用
    `startKoin()` 函数。我们使用 `modules` 参数传入我们之前创建的 `appModules` 变量。这初始化了我们的应用中的 Koin。我们还需要更新
    `AndroidManifest.xml` 文件以使用我们的 `ChapterFiveApplication` 类。打开 `AndroidManifest.xml`
    文件，并更新应用程序标签的名称属性，如下所示：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We are passing the name of our `ChapterFiveApplication` class to the name attribute.
    Now, if you run the app, it still runs as before, but this time, it uses dependency
    injection.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将我们的 `ChapterFiveApplication` 类的名称传递给名称属性。现在，如果你运行应用，它仍然像以前一样运行，但这次它使用了依赖注入。
- en: Now that we understand what dependency injection is and how to use it in our
    apps, let us look at **Kotlin Gradle DSL** and how we can use **version catalogs**
    to manage our dependencies.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了依赖注入是什么以及如何在我们的应用中使用它，让我们看看 **Kotlin Gradle DSL** 以及我们如何使用 **版本目录**
    来管理我们的依赖项。
- en: Migrating to Kotlin Gradle DSL and using version catalogs
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移到 Kotlin Gradle DSL 和使用版本目录
- en: In [*Chapter 1*](B19779_01.xhtml#_idTextAnchor015), one of the advantages of
    using Kotlin that we listed is that we can also write our Gradle files in Kotlin.
    In this section, we will look at how we can migrate our Gradle files to Kotlin
    Gradle DSL. We will also look at how we can use a version catalog to manage our
    dependencies.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第一章*](B19779_01.xhtml#_idTextAnchor015)中，我们列出的使用 Kotlin 的优点之一是，我们还可以用 Kotlin
    编写我们的 Gradle 文件。在本节中，我们将探讨如何将我们的 Gradle 文件迁移到 Kotlin Gradle DSL。我们还将探讨如何使用版本目录来管理我们的依赖项。
- en: 'Before we migrate, let’s see some of the benefits we get from using Kotlin
    Gradle DSL:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们迁移之前，让我们看看使用 Kotlin Gradle DSL 我们能得到的一些好处：
- en: '**Code autocompletion**: We get hints about the completion of our code in Gradle
    files as we are using Kotlin.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码自动完成**：由于我们正在使用 Kotlin，我们在 Gradle 文件中编写代码时会得到代码完成的提示。'
- en: '**Type safety**: We get compile time errors when we make mistakes in our Gradle
    files.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型安全**：当我们在我们 Gradle 文件中犯错时，我们会得到编译时错误。'
- en: '**Function calls and variable assignments**: We can use functions and variables
    in our Gradle files the same way we use them in our Kotlin code. It makes it even
    easier for us to write and understand.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数调用和变量赋值**：我们可以在 Gradle 文件中使用函数和变量，就像我们在 Kotlin 代码中使用它们一样。这使得我们编写和理解代码变得更加容易。'
- en: '**Compile time errors**: We get errors at compile time when we make mistakes
    in our Gradle files. This helps us avoid runtime errors when building our apps.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译时错误**：当我们在我们 Gradle 文件中犯错时，我们会得到编译时错误。这有助于我们在构建应用时避免运行时错误。'
- en: '**Official Android Studio Support**: From Android Studio Giraffe onwards, Kotlin
    Gradle DSL is the recommended way of creating our Gradle files. It is also the
    default way of creating our Gradle files in Android Studio Giraffe onwards.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**官方 Android Studio 支持**：从 Android Studio Giraffe 版本开始，Kotlin Gradle DSL 是创建我们的
    Gradle 文件的推荐方式。它也是从 Android Studio Giraffe 版本开始创建我们的 Gradle 文件的默认方式。'
- en: So many benefits, right? Let’s now migrate our app so as to use Kotlin Gradle
    DSL.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这么多好处，对吧？现在让我们迁移我们的应用，以便使用 Kotlin Gradle DSL。
- en: Migrating our app to Kotlin Gradle DSL
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将我们的应用迁移到 Kotlin Gradle DSL
- en: Important note
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If your apps already use Kotlin Gradle DSL, you can skip this section.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用已经使用了 Kotlin Gradle DSL，你可以跳过这一节。
- en: 'Follow these steps to migrate your app to Kotlin Gradle DSL:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将你的应用迁移到 Kotlin Gradle DSL：
- en: 'First, we have to rename all our Gradle files to have a `.kts` extension, which
    allows our IDE to recognize them as Kotlin Gradle files. Rename the `build.gradle(Project
    : chapterfive)`, `build.gradle(Module: app)`, and `settings.gradle` files to `build.gradle.kts(Project:
    chapterfive)`, `build.gradle.kts(Module: app)`, and `settings.gradle.kts`, respectively.
    This allows us to use Kotlin in our Gradle files now.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '首先，我们必须将所有 Gradle 文件重命名为具有 `.kts` 扩展名，这样我们的 IDE 就能识别它们为 Kotlin Gradle 文件。将
    `build.gradle(Project : chapterfive)`、`build.gradle(Module: app)` 和 `settings.gradle`
    文件分别重命名为 `build.gradle.kts(Project: chapterfive)`、`build.gradle.kts(Module: app)`
    和 `settings.gradle.kts`。这允许我们现在在 Gradle 文件中使用 Kotlin。'
- en: 'After renaming the files, we have to update their content to use Kotlin Gradle
    DSL. Let’s start with the `settings.gradle.kts` file. Open the `settings.gradle.kts`
    file and update it, as shown in the following code:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件重命名后，我们必须更新它们的内容以使用 Kotlin Gradle DSL。让我们从 `settings.gradle.kts` 文件开始。打开 `settings.gradle.kts`
    文件并更新它，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, update the `build.gradle.kts(Module: app)` file, as shown in the following
    code:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '接下来，更新 `build.gradle.kts(Module: app)` 文件，如下面的代码所示：'
- en: '[PRE14]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Lastly, update the `build.gradle.kts(Project: chapterfive)` file, as shown
    in the following snippet:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '最后，更新 `build.gradle.kts(Project: chapterfive)` 文件，如下面的代码片段所示：'
- en: '[PRE15]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After updating the files, we have to sync the project. We can do this by clicking
    on the Sync prompt that appears in the top right corner of the IDE. After syncing
    the project, we can now run the app, and it should run as before. We have now
    successfully migrated our app to use Kotlin Gradle DSL. You can also see that
    the syntax highlighting and the colors of the functions, methods, and variables
    change to reflect the Kotlin syntax. Some key changes about this migration to
    highlight are the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 更新文件后，我们必须同步项目。我们可以在 IDE 右上角出现的同步提示处点击进行同步。项目同步后，我们现在可以运行应用，它应该会像以前一样运行。我们现在已成功将应用迁移到使用
    Kotlin Gradle DSL。你还可以看到，语法高亮和函数、方法和变量的颜色已更改，以反映 Kotlin 语法。以下是一些关于这次迁移的关键变更，需要强调的是：
- en: To assign values to properties, we have to use the `=` operator specifically.
    For example, `minSdk 24` changes to `minSdk =` `24`.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了给属性赋值，我们必须特别使用 `=` 操作符。例如，`minSdk 24` 变更为 `minSdk = 24`。
- en: In our `android` config block, `namespace 'com.packt.chapterfive'` changes to
    `namespace = "com.packt.chapterfive"`. In Kotlin, we define strings using double
    quotes; that’s why we have to change the single quotes to double quotes in all
    the places we have strings.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的 `android` 配置块中，`namespace 'com.packt.chapterfive'` 变更为 `namespace = "com.packt.chapterfive"`。在
    Kotlin 中，我们使用双引号来定义字符串；这就是为什么我们必须将所有字符串处的单引号更改为双引号。
- en: In defining our dependencies, we have to use double quotes too. For example,
    `implementation 'androidx.activity:activity-compose:1.7.2'` changes to `implementation("androidx.activity:activity-compose:1.7.2")`.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在定义我们的依赖项时，我们也必须使用双引号。例如，`implementation 'androidx.activity:activity-compose:1.7.2'`
    变更为 `implementation("androidx.activity:activity-compose:1.7.2")`。
- en: Similarly, defining our plugins in the `plugins` block changes. For example,
    `id 'org.jetbrains.kotlin.android'` changes to `id("org.jetbrains.kotlin.android")`.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似地，在 `plugins` 块中定义我们的插件也会发生变化。例如，`id 'org.jetbrains.kotlin.android'` 变更为 `id("org.jetbrains.kotlin.android")`。
- en: Our project had minimal Gradle configurations, so if you have a complex project,
    you might need to do more migration; you can have a look at the Migrate to Kotlin
    DSL official documentation ([https://developer.android.com/build/migrate-to-kotlin-dsl](https://developer.android.com/build/migrate-to-kotlin-dsl))
    for more examples.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目 Gradle 配置最少，所以如果你有一个复杂的项目，你可能需要进行更多的迁移；你可以查看 Migrate to Kotlin DSL 官方文档（[https://developer.android.com/build/migrate-to-kotlin-dsl](https://developer.android.com/build/migrate-to-kotlin-dsl)）以获取更多示例。
- en: We have now migrated our app to use Kotlin Gradle DSL. In the next subsection,
    let’s look at how we can use a **versions catalog** to manage our dependencies.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已将应用迁移到使用 Kotlin Gradle DSL。在下一小节中，我们将探讨如何使用 **版本目录** 来管理我们的依赖项。
- en: Using a versions catalog
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用版本目录
- en: 'Quoting from the official documentation ([https://docs.gradle.org/current/userguide/platforms.html](https://docs.gradle.org/current/userguide/platforms.html)),
    a version catalog is a list of dependencies, represented as dependency co-ordinates,
    that a user can pick from when declaring dependencies in a build script. It helps
    us easily manage our dependencies and their versions in one central place. Currently,
    you can see that we define all our dependencies and their versions in our app-level
    `build.gradle.kts` file. Over time, and as you add more modules to your app, it
    becomes hard to share these dependencies, and we can find ourselves in situations
    where different modules have different versions of a similar dependency. This
    is where version catalogs come in to help us. Let’s see all the benefits that
    they offer:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 引用官方文档（[https://docs.gradle.org/current/userguide/platforms.html](https://docs.gradle.org/current/userguide/platforms.html)），版本目录是一份依赖项列表，以依赖项坐标的形式表示，用户在声明构建脚本中的依赖项时可以选择。它帮助我们轻松地在中央位置管理我们的依赖项及其版本。目前，您可以看到我们在应用级的`build.gradle.kts`文件中定义了所有依赖项及其版本。随着时间的推移，并且随着您向应用添加更多模块，共享这些依赖项变得困难，我们可能会发现自己处于不同模块具有类似依赖项不同版本的情况。这就是版本目录发挥作用帮助我们的时候。让我们看看它们提供的所有好处：
- en: They provide a central place to manage all our dependencies and their versions.
    They make it easier to share the dependencies across the project
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提供了一个集中管理所有依赖项及其版本的地方。这使得在整个项目中共享依赖项变得更加容易
- en: They have a simple and easy-to-use syntax
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们具有简单且易于使用的语法
- en: They show hints for dependencies that need to be updated
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们显示需要更新的依赖项的提示
- en: They make it easier to make changes, and these changes do not recompile the
    whole project, meaning the builds are faster
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们使得更改变得更加容易，并且这些更改不会重新编译整个项目，这意味着构建速度更快
- en: We can bundle dependencies together and share them across the project
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将依赖项捆绑在一起并在整个项目中共享它们
- en: They have official support and are recommended by Google to be used from Android
    Studio Giraffe going forward
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有官方支持，并且Google推荐从Android Studio Giraffe开始使用
- en: 'Let’s now see how we can use a version catalog in our app. In the `gradle`
    folder, create a new file named `libs.versions.toml`. In this file, here are some
    basic rules that we will follow:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何在我们的应用中使用版本目录。在`gradle`文件夹中，创建一个名为`libs.versions.toml`的新文件。在这个文件中，我们将遵循以下一些基本规则：
- en: We can use separators, such as -, _v, and . , that will be normalized by Gradle
    to “.” in the Catalog, allowing us to create subsections.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用分隔符，如`-`、`_v`和`.`，Gradle会将它们在目录中规范化为`.`，这样我们就可以创建子目录。
- en: We define variables using **CamelCase**.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用**驼峰式命名法**定义变量。
- en: For libraries, we normally check if we can add them to any existing bundles.
    For new libraries that are normally used together, we can create a new bundle
    for them.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于库，我们通常检查是否可以将它们添加到任何现有的捆绑包中。对于通常一起使用的新的库，我们可以为它们创建一个新的捆绑包。
- en: 'We will start by defining the versions for our dependencies as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义依赖项的版本，如下所示：
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, we are defining all the versions for the libraries that are in our app.
    We use the **versions** keyword to define the versions. We then define the versions
    for each library. As we edit this file, you will notice that the IDE prompts you
    to do a Gradle sync for our changes to be added to the project. For now, we can
    ignore this and continue editing the file. Next, we will define the bundles for
    our dependencies:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在定义我们应用中所有库的所有版本。我们使用**versions**关键字来定义版本。然后我们为每个库定义版本。当我们编辑此文件时，您将注意到IDE会提示我们进行Gradle同步，以便将我们的更改添加到项目中。目前，我们可以忽略这一点并继续编辑文件。接下来，我们将定义依赖项的捆绑包：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we have defined all the dependencies in our project using the **libraries**
    keyword.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用**libraries**关键字定义了我们项目中的所有依赖项。
- en: 'Next, let’s use the **bundles** keyword to create a bundle for Koin and compose
    dependencies as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用**bundles**关键字为Koin和compose依赖项创建一个捆绑包，如下所示：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `bundles` keyword allows us to group dependencies and use them as one.
    Now, we can sync the project. The last step is to update our app-level `build.gradle.kts`
    file to use the version catalog. Open the app-level `build.gradle.kts` file and
    update the dependencies block as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`bundles`关键字允许我们将依赖项分组并作为一个整体使用。现在，我们可以同步项目。最后一步是将我们的应用级`build.gradle.kts`文件更新为使用版本目录。打开应用级`build.gradle.kts`文件，并按以下方式更新依赖项块：'
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can now access the dependencies from our versions catalog file. Notice we
    must start with the **libs** keyword, and the next part is the names of the bundles
    or the dependencies, as per our version catalog. After adding these changes, we
    can now do Gradle sync. Build and run the app. The app displays a list of pets,
    as before, and nothing changes since we were only refactoring the dependencies.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以访问版本目录文件中的依赖项。请注意，我们必须以**libs**关键字开头，接下来是按照我们的版本目录命名的包或依赖项。添加这些更改后，我们现在可以进行Gradle同步。构建并运行应用。应用显示宠物列表，与之前一样，没有任何变化，因为我们只是重构了依赖项。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have built on what we learned from the previous chapters.
    We looked at the different architectures available for Android projects. We dived
    deep into MVVM architecture and its different layers and how to use some of the
    Jetpack libraries in this architecture. Additionally, we learned how to use advanced
    architecture features such as dependency injection and Kotlin Gradle DSL, as well
    as using Gradle version catalogs to define our dependencies.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们基于前几章所学的内容进行了扩展。我们探讨了适用于Android项目的不同架构。我们深入研究了MVVM架构及其不同层以及如何在架构中使用一些Jetpack库。此外，我们还学习了如何使用高级架构特性，如依赖注入和Kotlin
    Gradle DSL，以及使用Gradle版本目录来定义我们的依赖项。
- en: As we were creating the MVVM architecture, we used dummy pet data for our data
    layer. In the next chapter, we are going to learn how to make network calls to
    fetch data and display it in our app.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建MVVM架构的过程中，我们为数据层使用了虚拟宠物数据。在下一章中，我们将学习如何进行网络调用以获取数据并在我们的应用中显示它。
