<html><head></head><body>
		<div><h1 id="_idParaDest-134"><em class="italic"><a id="_idTextAnchor182"/>Chapter 7</em>: Flexible Code with Protocols, Generics, and Extensions </h1>
			<p>Seasoned programmers will (or should) know the core concepts of <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>). It's been around for a while, and it has shaped the way many of us develop and think about software. But a relatively new paradigm on the scene comes in the form of protocols with <strong class="bold">protocol-oriented programming</strong> (<strong class="bold">POP</strong>). Not intended as a replacement for OOP, POP has gained a lot of traction over the years, especially with the Swift community. </p>
			<p>In this chapter, we'll learn everything we need to know about POP, from standard implementation to associated types and then onto generics. By the end of this chapter, you'll be extremely confident with not only implementing POP in your app, but also understanding what it has to offer. </p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>Understanding and implementing protocols</li>
				<li>Getting the best out of extensions</li>
				<li>Adding flexibility with generics</li>
			</ul>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor183"/>Technical requirements </h1>
			<p>For this chapter, you'll need to download Xcode version 11.4 or above from Apple's App Store. </p>
			<p>You'll also need to be running the latest version of macOS (Catalina or above). Simply search for <code>Xcode</code> in the App Store and select and download the latest version. Launch Xcode and follow any additional installation instructions that your system may prompt you with. Once Xcode has fully launched, you're ready to go.</p>
			<p>Download the sample code from the following GitHub link: <a href="https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition/tree/master/Chapter%207%20-%20Playground/Protocols.playground">https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition/tree/master/Chapter%207%20-%20Playground/Protocols.playground</a></p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor184"/>Understanding and implementing protocols</h1>
			<p>Swift and <code>UIKit</code> have <a id="_idIndexMarker307"/>protocols at the core of their design. You might have noticed this when you were implementing custom <code>UIViewController</code> transitions, or when you worked on a table view or collection view. When you implement these features, you create objects that function as delegates for the transitions, table views, and collection views and conform them to specific protocols. When you worked on view controller transitions in <a href="B14717_05_Final_ASB_ePub.xhtml#_idTextAnchor141"><em class="italic">Chapter 5</em></a>, <em class="italic">Immersing Your Users with Animation</em>, we also implemented an <code>NSObject</code> subclass that conformed to <code>UIViewControllerAnimatedTransitioning</code>.</p>
			<p>With that said, let's take a deeper look at how we would handle creating and designing our own protocols to use in our Swift app.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor185"/>Defining your own protocols</h2>
			<p>Protocols are not <a id="_idIndexMarker308"/>confined to delegate behavior only. Defining a protocol is very similar to defining a class, struct, or enum. The main difference is that a protocol does not implement or store any values on its own. It acts as a contract between whoever calls an object that conforms to a protocol and the object that claims to conform to the protocol.</p>
			<p>Let's take a look at this by writing some code, we'll create a new playground in order to do this.</p>
			<p>Let's implement a simple protocol that defines the expectations for any object that claims to be a pet. The protocol will be called the <code>PetType</code> protocol. Protocols defined in UIKit and the Swift standard library use either <code>Type</code>, <code>Ing</code>, or <code>Able</code> as a suffix to indicate that the protocol defines a behavior rather than a concrete type. You should try to follow this convention as much as possible because it makes your code easier to understand for other developers:</p>
			<pre>protocol PetType {
    
    var name: String { get }
    var age: Int { get set }
    static var latinName: String { get }
    
    func sleep()
    
<a id="_idTextAnchor186"/><a id="_idTextAnchor187"/>}</pre>
			<p>The definition for <code>PetType</code> states that any object that claims to be <code>PetType</code> must have a get-only variable (a constant) called <code>name</code>, an <code>age</code> that can be changed because it specifies both <code>get</code> and <code>set</code>, a <code>sleep()</code> method that makes the pet rest, and finally, a static variable that describes the Latin name of <code>PetType</code>.</p>
			<p>Whenever you define that a<a id="_idIndexMarker309"/> protocol requires a certain variable to exist, you must also specify whether the variable should be gettable, settable, or both. If you specify that a certain method must be implemented, you write the method just as you usually would, but you stop at the first curly bracket. You only write down the method signature.</p>
			<p>A protocol can also require that the implementer has a static variable or method. This is convenient in the case of <code>PetType</code> because the Latin name of a pet does not necessarily belong to a specific pet, but to the entire species that the pet belongs to, so implementing this as a property of the type rather than the instance makes a lot of sense.</p>
			<p>To demonstrate how powerful a small protocol such as <code>PetType</code> can be, you will implement two pets: a cat and a dog. You'll also write a function that takes any pet and then makes them take a nap by calling the <code>sleep()</code> method.</p>
			<p>An OOP approach to this protocol could be to create a class called <code>Pet</code>, and then create two subclasses, <code>Cat</code> and <code>Dog</code>. A <code>sleep()</code> method would take an instance of <code>Pet</code>, and it would look a bit like this:</p>
			<pre>func sleep(pet: Pet) {
    pet.sleep()
}</pre>
			<p>Don't get me wrong, the preceding object-oriented approach works and on such a small scale, no real problems will occur. </p>
			<p>However, when the inheritance hierarchy grows, you typically end up with base classes that contain methods that are only relevant to a couple of subclasses. Alternatively, you will find yourself unable to add certain functionalities to a certain class because the inheritance hierarchy gets in the way after a while.</p>
			<p>Let's see what it looks like <a id="_idIndexMarker310"/>when you use the <code>PetType</code> protocol to solve this challenge without using inheritance at all:</p>
			<pre>struct Cat: PetType {
    
    let name: String
    var age: Int
    static let latinName: String = 'Felis catus'
    
    func sleep() {
        print('Cat: Zzzz')
    }
    
}
struct Dog: PetType {
    let name: String
    var age: Int
    static let latinName: String = 'Canis familiaris'
    
    func sleep() {
        print('Dog: Zzzz')
    }
    
}
func nap(pet: PetType) {
    pet.sleep()
}</pre>
			<p>We just managed to <a id="_idIndexMarker311"/>implement a single method that can take both the <code>Cat</code> and <code>Dog</code> objects and makes them take a nap. </p>
			<p>Instead of checking for a type, the code checks that the pet that is passed in conforms to the <code>PetType</code> protocol, and if it does, its <code>sleep()</code> method can be called because the protocol dictates that any <code>PetType</code> instance must implement a <code>sleep()</code> method. This brings us to the next topic of this chapter: checking for traits instead of types.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor188"/>Checking for traits instead of types</h2>
			<p>In classic OOP, you <a id="_idIndexMarker312"/>often create superclasses and subclasses to group together objects with similar capabilities. If you roughly model a group of felines in the animal kingdom with classes, you end up with a diagram that looks like this:</p>
			<div><div><img src="img/Figure_7.01_B14717.jpg" alt="Figure 7.1 – Object-orientated flow&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – Object-orientated flow</p>
			<p>If you try to model more animals, you will find that it's a complex task because some animals share a whole bunch of traits, although they are quite far apart from each other in the class diagram.</p>
			<p>One example would be that both cats and dogs are typically kept as pets. This means that they should optionally have an owner and maybe a home. But cats and dogs aren't the only animals kept as pets because fish, guinea pigs, rabbits, and even snakes are kept as pets. </p>
			<p>It would be tough to figure<a id="_idIndexMarker313"/> out a sensible way to restructure your class hierarchy in such a way that you don't have to redundantly add owners and homes to every pet in the hierarchy because it would be impossible to add these properties to the right classes selectively.</p>
			<p>This problem gets even worse when you write a function or method that prints a pet's home. You would either have to make that function accept any animal or write a separate implementation of the same function for each type that has the properties you're looking for. Neither of these approaches makes sense because you don't want to write the same function over and over again with just a different class for the parameter. Even if you choose to do this and you end up with a method that prints an animal's home address that accepts a <code>Fish</code> instance, passing an instance of <code>GreatWhiteShark</code> to a function called <code>printHomeAddress()</code> doesn't make a lot of sense either, because sharks typically don't have home addresses. Of course, the solution to this problem is to use protocols.</p>
			<p>In the situation described in the previous section, objects were mostly defined by what they are, not by what they do. We care about the fact that an animal is part of a particular family or type, not about whether it lives on land. You can't differentiate between animals that can fly and animals that can't because not all birds can fly.</p>
			<p>Inheritance isn't compatible with this way of thinking. Imagine a definition for a <code>Pigeon</code> struct that looks like this:</p>
			<pre>struct Pigeon: Bird, FlyingType, OmnivoreType, Domesticatable</pre>
			<p>Since <code>Pigeon</code> is a struct, you<a id="_idIndexMarker314"/> know that <code>Bird</code> isn't a struct or class—it's a protocol that defines a couple of requirements about what it means to be a bird.</p>
			<p>The <code>Pigeon</code> struct also conforms to the <code>FlyingType</code>, <code>OmnivoreType</code>, and <code>Domesticatable</code> protocols. Each of these protocols tells you something about <code>Pigeon</code> regarding its capabilities or traits. The definition explains what a pigeon is and does instead of merely communicating that it inherits from a certain type of bird.</p>
			<p>For example, almost all birds can fly, but there are some exceptions to the rule. You could model this with classes, but this approach is tedious and might be inflexible, depending on your needs and how your code evolves.</p>
			<p>Setting the <code>Pigeon</code> struct up with protocols is powerful; you can now write a <code>printHomeAddress()</code> function and set it up so that it accepts any object that conforms to <code>Domesticatable</code>:</p>
			<pre>protocol Domesticatable {
    var homeAddress: String? { get }
}
func printHomeAddress(animal: Domesticatable) {
    if let address = animal.homeAddress {
        print(address)
    }
}</pre>
			<p>The <code>Domesticatable</code> protocol requires an optional <code>homeAddress</code> property. Not every animal that can be domesticated actually is. </p>
			<p>For example, think about the pigeon; some pigeons are kept as pets, but most aren't. This also applies to cats and dogs, because not every cat or dog has a home.</p>
			<p>This approach is powerful, but shifting your mind from an object-oriented mindset, where you think of an inheritance hierarchy, to a protocol-oriented mindset, where you focus on traits instead of inheritance, isn't easy.</p>
			<p>Let's expand the example code a bit more by defining <code>OmnivoreType</code>, <code>HerbivoreType</code>, and <code>CarnivoreType</code>. These types will represent the three main types of eaters in the animal kingdom. You can make use of inheritance inside of these protocols because <code>OmnivoreType</code> is both <code>HerbivoreType</code> and <code>CarnivoreType</code>, so you can make <code>OmnivoreType</code> inherit<a id="_idIndexMarker315"/> from both of these protocols:</p>
			<pre>protocol Domesticatable {
    var homeAddress: String? { get }
}
protocol HerbivoreType {
    var favoritePlant: String { get }
}
protocol CarnivoreType {
    var favoriteMeat: String { get }
}
protocol OmnivoreType: HerbivoreType, CarnivoreType { }</pre>
			<p>Composing two protocols into one like you did in the preceding example is powerful, but be careful when you do this. </p>
			<p>You don't want to create a crazy inheritance graph like you would when you do OOP; you just learned that inheritance could be wildly complex and inflexible. </p>
			<p>Imagine writing two new<a id="_idIndexMarker316"/> functions, one to print a carnivore's favorite meat and one to print a herbivore's favorite plant. Those functions would look like this:</p>
			<pre>func printFavoriteMeat(forAnimal animal: CarnivoreType) {
    print(animal.favoriteMeat)
}
func printFavoritePlant(forAnimal animal: HerbivoreType) {
    print(animal.favoritePlant)
}</pre>
			<p>The preceding code might be exactly what you would write yourself. However, neither of these methods accepts <code>OmnivoreType</code>. This is perfectly fine because <code>OmnivoreType</code> inherits from <code>HerbivoreType</code> and <code>CarnivoreType</code>. </p>
			<p>This works in the same way that you're used to in classical OOP, with the main exception being that <code>OmnivoreType</code> inherits from multiple protocols instead of just one. </p>
			<p>This means that the <code>printFavoritePlant()</code> function accepts a <code>Pigeon</code> instance as its argument because <code>Pigeon</code> conforms to <code>OmnivoreType</code>, which inherits from <code>HerbivoreType</code>.</p>
			<p>Using protocols to compose your objects like this can drastically simplify your code. Instead of thinking about complex inheritance structures, you can compose your objects with protocols that define certain traits. The beauty of this is that it makes defining new objects relatively easy.</p>
			<p>Imagine that a new type of animal is discovered, one that can fly, swim, and lives on land. This weird new species would be really hard to add to an inheritance-based architecture since it doesn't fit in with other animals.</p>
			<p>When using protocols, you could add conformance to the <code>FlyingType</code>, <code>LandType</code>, and <code>SwimmingType</code> protocols and you'd be all set. Any methods or functions that take a <code>LandType</code> animal as an argument will happily accept your new animal since it conforms to the <code>LandType</code> protocol.</p>
			<p>Getting the hang of this way of thinking isn't simple, and it will require some practice. But any time you're getting ready to create a superclass or subclass, ask yourself why. If you're trying to encapsulate a certain trait in that class, try using a protocol.</p>
			<p>This will train you to think differently about your objects, and before you know it, your code will be cleaner, more readable, and more flexible, using protocols and checking for traits instead of taking action based on what an object is.</p>
			<p>As you've seen, a protocol <a id="_idIndexMarker317"/>doesn't need to have a lot of requirements; sometimes one or two are enough to convey the right meaning. Don't hesitate to create protocols with just a single property or method; as your projects grow over time and your requirements change, you will thank yourself for doing so.</p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor189"/>Extending your protocols with default behavior</h2>
			<p>The previous examples <a id="_idIndexMarker318"/>have mainly used variables as the <a id="_idIndexMarker319"/>requirements for protocols. One slight downside of protocols is that they can result in a bit of code duplication.</p>
			<p>For example, every object that is <code>HerbivoreType</code> has a <code>favoriteMeat</code> variable. This means that you have to duplicate this variable in every object that conforms to <code>HerbivoreType</code>. Usually, you want as little code repetition as possible, and repeating a variable over and over again might seem like a step backward.</p>
			<p>Even though it's nice if you don't have to declare the same property over and over again, there's a certain danger in not doing this. If your app grows to a large size, you won't remember every class, subclass, and superclass all of the time. This means that changing or removing a specific property can have undesired side-effects in other classes.</p>
			<p>Declaring the same properties on every object that conforms to a certain protocol isn't that big a deal; it usually takes just a few lines of code to do this. However, protocols can also require certain methods to be present on objects that conform to them.</p>
			<p>Declaring them over and over again can be cumbersome, especially if the implementation is the same for most objects. Luckily, you can make use of protocol extensions to implement a certain degree of default functionality.</p>
			<p>To explore protocol extensions, let's move the <code>printHomeAddress()</code> function into the <code>Domesticatable</code> protocol so all <code>Domesticatable</code> objects can print their own home addresses. The first approach you can take is to immediately define the method on a protocol extension<a id="_idIndexMarker320"/> without adding it to the protocol's requirements:</p>
			<pre>extension Domesticatable {
    func printHomeAddress() {
        if let address = homeAddress {
            print(address)
        }
    }
}</pre>
			<p>By defining the <code>printHomeAddress()</code> method in the protocol extension, every object that conforms to <code>Domesticatable</code> has the following method available without having to<a id="_idIndexMarker321"/> implement it with the object itself:</p>
			<pre>let pidgeon = Pigeon(favoriteMeat: 'Insects',
                       favoritePlant: 'Seeds',
                       homeAddress: 'Greater Manchester,                        England')
pidgeon.printHomeAddress()</pre>
			<p>This technique is very convenient if you want to implement default behavior that's associated with a protocol.</p>
			<p>You didn't even have to add the <code>printHomeAddress()</code> method as a requirement to the protocol. However, this approach will give you some strange results if you're not careful. The following snippet shows an example of such odd results by adding a custom implementation of <code>printHomeAddress()</code> to the <code>Pigeon</code> struct:</p>
			<pre>struct Pigeon: Bird, FlyingType, OmnivoreType, Domesticatable {
    let favoriteMeat: String
    let favoritePlant: String
    let homeAddress: String?
    
    func printHomeAddress() {
        if let address = homeAddress {
            print('address: \(address.uppercased())')
        }
    }
}</pre>
			<p>When<a id="_idIndexMarker322"/> you call <code>myPigeon.printHomeAddress()</code>, the custom implementation is used to print the address. However, if you define a function, such as <code>printAddress(animal:)</code>, that takes a <code>Domesticatable</code> object as its parameter, the default implementation provided by the protocol is used.</p>
			<p>This happens <a id="_idIndexMarker323"/>because <code>printHomeAddress()</code> isn't a requirement of the protocol. Therefore, if you call <code>printHomeAddress()</code> on a <code>Domesticatable</code> object, the implementation from the protocol extension is used. If you use the same snippet as in the preceding section, but change the <code>Domesticatable</code> protocol as shown in the following code, both calls to <code>printHomeAddress()</code> print the same thing, that is, the custom implementation in the <code>Pigeon</code> struct:</p>
			<pre>protocol Domesticatable {
    var homeAddress: String? { get }
<strong class="bold">    func printHomeAddress()</strong>
}</pre>
			<p>This behavior is likely to be unexpected in most cases, so it's usually a good idea to define all methods you use in the protocol requirements unless you're absolutely sure you want the behavior you just saw.</p>
			<p>Protocol extensions can't hold stored properties. This means that you can't add your variables to the protocol to provide a default implementation for them. Even though extensions can't hold stored properties, there are situations where you can still add a computed <a id="_idIndexMarker324"/>property to a protocol extension to avoid <a id="_idIndexMarker325"/>duplicating the same variable in multiple places. Let's take a look at an example:</p>
			<pre>protocol Domesticatable {
    var homeAddress: String? { get }
    var hasHomeAddress: Bool { get }
    func printHomeAddress()
}
extension Domesticatable {
    var hasHomeAddress: Bool {
        return homeAddress != nil
    }
    
    func printHomeAddress() {
        if let address = homeAddress {
            print(address)
        }
    }
}</pre>
			<p>If you want to be able to check whether a <code>Domesticatable</code> has a home address, you can add a requirement for a Bool value, <code>hasHomeAddress</code>. If the <code>homeAddress</code> property is set, <code>hasHomeAddress</code> should be true. Otherwise, it should be false.</p>
			<p>This property is computed in the protocol extension, so you don't have to add this property to all <code>Domesticatable</code> objects. In this case, it makes a lot of sense to use a computed property because the way its value is computed should most likely be the same across all <code>Domesticatable</code> objects.</p>
			<p>Implementing <a id="_idIndexMarker326"/>default behaviors in protocol extensions <a id="_idIndexMarker327"/>makes the protocol-oriented approach we've seen before even more powerful; you can essentially mimic a feature called multiple inheritance without all the downsides of subclassing.</p>
			<p>Simply adding conformance to a protocol can add all kinds of functionality to your objects, and if the protocol extensions allow it, you won't need to add anything else to your code. Let's see how you can make protocols and extensions even more powerful with associated types.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor190"/>Improving your protocols with associated types</h2>
			<p>One more <a id="_idIndexMarker328"/>awesome aspect of protocol-oriented <a id="_idIndexMarker329"/>programming is the use of associated types. An associated type is a generic, non-existing type that can be used in your protocol like any type that does exist.</p>
			<p>The real type of this generic is determined by the compiler based on the context it's used in. This description is abstract, and you might not immediately understand why or how an associated type can benefit your protocols. After all, aren't protocols themselves a very flexible way to make several unrelated objects fit certain criteria based on the protocols they conform to?</p>
			<p>To illustrate and discover the use of associated types, you will expand your animal kingdom a bit. What you should do is give the herbivores an <code>eat</code> method and an array to keep track of the plants they've eaten, as follows:</p>
			<pre>protocol HerbivoreType {
    var plantsEaten: [PlantType] { get set }
    mutating func eat(plant: PlantType)
}
extension HerbivoreType {
    mutating func eat(plant: PlantType) {
        plantsEaten.append(plant)
    }
}</pre>
			<p>This code looks fine at first sight. An herbivore eats plants, and this is established by this protocol. The <code>PlantType</code> protocol is defined as follows:</p>
			<pre>protocol PlantType {
    var latinName: String { get }
}</pre>
			<p>Let's define<a id="_idIndexMarker330"/> two different plant types and an animal that<a id="_idIndexMarker331"/> will be used to demonstrate the problem with the preceding code:</p>
			<pre>struct Grass: PlantType{ var latinName = 'Poaceae'
}
struct Pine: PlantType{ var latinName = 'Pinus'
}
struct Cow: HerbivoreType {
    var plantsEaten = [PlantType]()
}</pre>
			<p>There shouldn't be a big surprise here. Let's continue with creating a <code>Cow</code> instance and feed it <code>Pine</code>:</p>
			<pre>var cow = Cow()
let pine = Pine()
cow.eat(plant: pine)</pre>
			<p>This doesn't<a id="_idIndexMarker332"/> really make sense. Cows don't eat pines; they <a id="_idIndexMarker333"/>eat grass! We need some way to limit this cow's food intake because this approach isn't going to work.</p>
			<p>Currently, you can feed <code>HerbivoreType</code> animals anything that's considered a plant. You need some way to limit the types of food your cows are given. In this case, you should restrict <code>FoodType</code> to <code>Grass</code> only, without having to define the <code>eat(plant:)</code> method for every plant type you might want to feed a <code>HerbivoreType</code>.</p>
			<p>The problem you're facing now is that all <code>HerbivoreType</code> animals mainly eat one plant type, and not all plant types are a good fit for all herbivores. This is where associated types are a great solution. An associated type for the <code>HerbivoreType</code> protocol can constrain the <code>PlantType</code> that a certain herbivore can eat to a single type that is defined by <code>HerbivoreType</code>. Let's see what this looks like:</p>
			<pre>protocol HerbivoreType {
    associatedtype Plant: PlantType
    var plantsEaten: [Plant] { get set }
    mutating func eat(plant: Plant)
}
extension HerbivoreType {
    mutating func eat(plant: Plant) {
        print('eating a \(plant.latinName)')
        plantsEaten.append(plant)
    }
}</pre>
			<p>The first highlighted line associates the generic <code>Plant</code> type, which doesn't exist as a real type, with the protocol. A constraint has been added to <code>Plant</code> to ensure that it's a <code>PlantType</code>.</p>
			<p>The second highlighted line demonstrates how the <code>Plant</code> associated type is used as a <code>PlantType</code>. The plant type itself is merely an alias for any type that conforms to <code>PlantType</code> and is used as the type of object we use for <code>plantsEaten</code> and the <code>eat</code> methods. Let's redefine the <code>Cow</code> struct to see this associated type in action:</p>
			<pre>struct Cow: HerbivoreType {
    var plantsEaten = [Grass]()
}</pre>
			<p>Instead of making <code>plantsEaten</code> a <code>PlantType</code> array, it's now defined as an array of <code>Grass</code>. In the protocol and the definition, the type of plant is now <code>Grass</code>. </p>
			<p>The compiler <a id="_idIndexMarker334"/>understands this because the <code>plantsEaten</code> array is <a id="_idIndexMarker335"/>defined as <code>[Grass]</code>. Let's define a second <code>HerbivoreType</code> that eats a different type of <code>PlantType</code>:</p>
			<pre>struct Carrot: PlantType {
    let latinName = 'Daucus carota'
}
struct Rabbit: HerbivoreType {
    var plantsEaten = [Carrot]()
}</pre>
			<p>If you try to feed a cow some carrots, or if you attempt to feed the rabbit a pine, the compiler will throw errors. The reason for this is that the associated type constraint allows you to define the type of <code>Plant</code> in each struct separately.</p>
			<p>One side note about associated types is that it's not always possible for the compiler to correctly infer the real type for an associated type. In our current example, this would happen if we didn't have the <code>plantsEaten</code> array in the protocol. </p>
			<p>The solution would be to define a <code>typealias</code> on types that conform to <code>HerbivoreType</code> so that the compiler understands which type <code>Plant</code> represents:</p>
			<pre>protocol HerbivoreType {
    associatedtype Plant: PlantType
    var plantsEaten: [Plant] { get set }
    mutating func eat(plant: Plant)
}</pre>
			<p>Associated types can be really powerful when used correctly, but sometimes using them can also cause you a lot of headaches because of the amount of inferring the compiler has to do. </p>
			<p>If you forget a few <a id="_idIndexMarker336"/>tiny steps, the compiler can quickly lose track <a id="_idIndexMarker337"/>of what you're trying to do, and the error messages aren't always the most unambiguous messages. </p>
			<p>Keep this in mind when you're using associated types, and try to make sure that you're as explicit as possible about the type you're looking to be associated with. </p>
			<p>Sometimes, adding a type alias to give the compiler a helping hand is better than trying to get the compiler to infer everything on its own correctly.</p>
			<p>This type of flexibility is not limited to protocols. You can also add generic properties to functions, classes, structs, and enums. Let's see how this works and how it can make your code extremely flexible.</p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor191"/>Adding flexibility with generics</h1>
			<p>Programming with<a id="_idIndexMarker338"/> generics is not always easy, but it does make your code extremely flexible. When you use something such as generics, you are always making a trade-off between the simplicity of your program and the flexibility of your code. Sometimes it's worth it to introduce a little bit of complexity to allow your code to be written in otherwise impossible ways.</p>
			<p>For instance, consider the <code>Cow</code> struct you saw before. To specify the generic associated type on the <code>HerbivoreType</code> protocol, a type alias was added to the <code>Cow</code> struct. Now imagine that not all cows like to eat grass. Maybe some cows prefer flowers, corn, or something else. You would not be able to express this using the type alias.</p>
			<p>To represent a case where you might want to use a different <code>PlantType</code> for every cow instance, you can add a generic to the <code>Cow</code> itself. The following snippet shows how you can do this:</p>
			<pre>struct Cow&lt;Plant: PlantType&gt;: HerbivoreType {
    var plantsEaten = [Plant]()
}</pre>
			<p>Between <code>&lt;</code> and <code>&gt;</code>, the generic type name is specified as <code>Plant</code>. This generic is constrained to the <code>PlantType</code> type. </p>
			<p>This means that any type that will act as <code>Plant</code> has to conform to <code>PlantType</code>. The protocol will see that <code>Cow</code> has a generic <code>Plant</code> type now, so there is no need to add a type alias. When you create an instance of <code>Cow</code>, you can now pass every instance its own <code>PlantType</code>:</p>
			<pre>let grassCow = Cow&lt;Grass&gt;()
let flowerCow = Cow&lt;Flower&gt;()</pre>
			<p>Applying generics to<a id="_idIndexMarker339"/> instances like this is more common than you might think. An <code>Array</code> instance uses generics to determine what kind of elements it contains. The following two lines of code are identical in functionality:</p>
			<pre>let strings = [String]()
let strings = Array&lt;String&gt;()</pre>
			<p>The first line uses a convenient syntax to create an array of strings. The second line uses the <code>Array</code> initializer and explicitly specifies the type of element it will contain.</p>
			<p>Sometimes, you might find yourself writing a function or method that can benefit from a generic argument or return type. An excellent example of a generic function is <code>map</code>. With <code>map</code>, you can transform an array of items into an array of different items. You can define your own simple version of <code>map</code> as follows:</p>
			<pre>func simpleMap&lt;T, U&gt;(_ input: [T], transform: (T) -&gt; U) -&gt; [U] {
    
    var output = [U]()
    for item in input {
        output.append(transform(item))
    }
    
    return output
}</pre>
			<p>Here, <code>simpleMap(_:transform:)</code> has two generic types, <code>T</code> and <code>U</code>. These names are common placeholders for generics, so they make it clear to anybody reading this code that they are about to deal with generics. </p>
			<p>In this sample, the function expects an input of <code>[T]</code>, which you can read as an array of something. It also expects a closure that takes an argument, <code>T</code>, and returns <code>U</code>. </p>
			<p>You can interpret this as the closure taking an element out of that array of something, and it transforms it into something else.</p>
			<p>The function finally<a id="_idIndexMarker340"/> returns an array of <code>[U]</code>, or in other words, an array of something else.</p>
			<p>You would use <code>simpleMap(_:transform:)</code> as follows:</p>
			<pre>let result = simpleMap([1, 2, 3]) { item in
    return item * 2
}
print(result) // [2, 4, 6]</pre>
			<p>Generics are not always easy to understand, and it's okay if they take you a little while to get used to it. They are a powerful and complex topic that we could write many more pages about. </p>
			<p>The best way to get into them is to use them, practice with them, and read as much as you can about them. For now, you <a id="_idIndexMarker341"/>should have more than enough to think about and play with.</p>
			<p>Note that generics are not limited to structs and functions. You can also add generics to your enums and classes in the same way you add them to a struct.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor192"/>Summary</h1>
			<p>In this chapter, you saw how you can leverage the power of protocols to work with an object's traits or capabilities, rather than just using its class as the only way of measuring its capabilities. Then, you saw how protocols can be extended to implement a default functionality. This enables you to compose powerful types by merely adding protocol conformance, instead of creating a subclass. </p>
			<p>You also saw how protocol extensions behave depending on your protocol requirements, and that it's wise to have anything that's in the protocol extension defined as a protocol requirement. This makes the protocol behavior more predictable.</p>
			<p>Finally, you learned how associated types work and how they can take your protocols to the next level by adding generic types to your protocols that can be tweaked for every type that conforms to your protocol. You even saw how you can apply generics to other objects, such as functions and structs.</p>
			<p>The concepts shown in this chapter are pretty advanced, sophisticated, and powerful. To truly master their use, you'll need to train yourself to think regarding traits instead of an inheritance hierarchy. </p>
			<p>Once you've mastered this, you can experiment with protocol extensions and generic types. It's okay if you don't fully understand these topics right off the bat; they're completely different and new ways of thinking for most programmers with OOP experience. </p>
			<p>Now that we've explored some of the theory behind protocols and value types, in the next chapter, you will learn how you can put this new knowledge to use by shortly revisiting the Contacts app from our previous chapters to improve the code you wrote there.</p>
		</div>
	</body></html>