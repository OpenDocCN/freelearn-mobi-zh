<html><head></head><body>
		<div id="_idContainer078">
			<h1 id="_idParaDest-134"><em class="italic"><a id="_idTextAnchor182"/>Chapter 7</em>: Flexible Code with Protocols, Generics, and Extensions </h1>
			<p>Seasoned programmers will (or should) know the core concepts of <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>). It's been around for a while, and it has shaped the way many of us develop and think about software. But a relatively new paradigm on the scene comes in the form of protocols with <strong class="bold">protocol-oriented programming</strong> (<strong class="bold">POP</strong>). Not intended as a replacement for OOP, POP has gained a lot of traction over the years, especially with the Swift community. </p>
			<p>In this chapter, we'll learn everything we need to know about POP, from standard implementation to associated types and then onto generics. By the end of this chapter, you'll be extremely confident with not only implementing POP in your app, but also understanding what it has to offer. </p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>Understanding and implementing protocols</li>
				<li>Getting the best out of extensions</li>
				<li>Adding flexibility with generics</li>
			</ul>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor183"/>Technical requirements </h1>
			<p>For this chapter, you'll need to download Xcode version 11.4 or above from Apple's App Store. </p>
			<p>You'll also need to be running the latest version of macOS (Catalina or above). Simply search for <strong class="source-inline">Xcode</strong> in the App Store and select and download the latest version. Launch Xcode and follow any additional installation instructions that your system may prompt you with. Once Xcode has fully launched, you're ready to go.</p>
			<p>Download the sample code from the following GitHub link: <a href="https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition/tree/master/Chapter%207%20-%20Playground/Protocols.playground">https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition/tree/master/Chapter%207%20-%20Playground/Protocols.playground</a></p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor184"/>Understanding and implementing protocols</h1>
			<p>Swift and <strong class="source-inline">UIKit</strong> have <a id="_idIndexMarker307"/>protocols at the core of their design. You might have noticed this when you were implementing custom <strong class="source-inline">UIViewController</strong> transitions, or when you worked on a table view or collection view. When you implement these features, you create objects that function as delegates for the transitions, table views, and collection views and conform them to specific protocols. When you worked on view controller transitions in <a href="B14717_05_Final_ASB_ePub.xhtml#_idTextAnchor141"><em class="italic">Chapter 5</em></a>, <em class="italic">Immersing Your Users with Animation</em>, we also implemented an <strong class="source-inline">NSObject</strong> subclass that conformed to <strong class="source-inline">UIViewControllerAnimatedTransitioning</strong>.</p>
			<p>With that said, let's take a deeper look at how we would handle creating and designing our own protocols to use in our Swift app.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor185"/>Defining your own protocols</h2>
			<p>Protocols are not <a id="_idIndexMarker308"/>confined to delegate behavior only. Defining a protocol is very similar to defining a class, struct, or enum. The main difference is that a protocol does not implement or store any values on its own. It acts as a contract between whoever calls an object that conforms to a protocol and the object that claims to conform to the protocol.</p>
			<p>Let's take a look at this by writing some code, we'll create a new playground in order to do this.</p>
			<p>Let's implement a simple protocol that defines the expectations for any object that claims to be a pet. The protocol will be called the <strong class="source-inline">PetType</strong> protocol. Protocols defined in UIKit and the Swift standard library use either <strong class="source-inline">Type</strong>, <strong class="source-inline">Ing</strong>, or <strong class="source-inline">Able</strong> as a suffix to indicate that the protocol defines a behavior rather than a concrete type. You should try to follow this convention as much as possible because it makes your code easier to understand for other developers:</p>
			<p class="source-code">protocol PetType {</p>
			<p class="source-code">    </p>
			<p class="source-code">    var name: String { get }</p>
			<p class="source-code">    var age: Int { get set }</p>
			<p class="source-code">    static var latinName: String { get }</p>
			<p class="source-code">    </p>
			<p class="source-code">    func sleep()</p>
			<p class="source-code">    </p>
			<p class="source-code"><a id="_idTextAnchor186"/><a id="_idTextAnchor187"/>}</p>
			<p>The definition for <strong class="source-inline">PetType</strong> states that any object that claims to be <strong class="source-inline">PetType</strong> must have a get-only variable (a constant) called <strong class="source-inline">name</strong>, an <strong class="source-inline">age</strong> that can be changed because it specifies both <strong class="source-inline">get</strong> and <strong class="source-inline">set</strong>, a <strong class="source-inline">sleep()</strong> method that makes the pet rest, and finally, a static variable that describes the Latin name of <strong class="source-inline">PetType</strong>.</p>
			<p>Whenever you define that a<a id="_idIndexMarker309"/> protocol requires a certain variable to exist, you must also specify whether the variable should be gettable, settable, or both. If you specify that a certain method must be implemented, you write the method just as you usually would, but you stop at the first curly bracket. You only write down the method signature.</p>
			<p>A protocol can also require that the implementer has a static variable or method. This is convenient in the case of <strong class="source-inline">PetType</strong> because the Latin name of a pet does not necessarily belong to a specific pet, but to the entire species that the pet belongs to, so implementing this as a property of the type rather than the instance makes a lot of sense.</p>
			<p>To demonstrate how powerful a small protocol such as <strong class="source-inline">PetType</strong> can be, you will implement two pets: a cat and a dog. You'll also write a function that takes any pet and then makes them take a nap by calling the <strong class="source-inline">sleep()</strong> method.</p>
			<p>An OOP approach to this protocol could be to create a class called <strong class="source-inline">Pet</strong>, and then create two subclasses, <strong class="source-inline">Cat</strong> and <strong class="source-inline">Dog</strong>. A <strong class="source-inline">sleep()</strong> method would take an instance of <strong class="source-inline">Pet</strong>, and it would look a bit like this:</p>
			<p class="source-code">func sleep(pet: Pet) {</p>
			<p class="source-code">    pet.sleep()</p>
			<p class="source-code">}</p>
			<p>Don't get me wrong, the preceding object-oriented approach works and on such a small scale, no real problems will occur. </p>
			<p>However, when the inheritance hierarchy grows, you typically end up with base classes that contain methods that are only relevant to a couple of subclasses. Alternatively, you will find yourself unable to add certain functionalities to a certain class because the inheritance hierarchy gets in the way after a while.</p>
			<p>Let's see what it looks like <a id="_idIndexMarker310"/>when you use the <strong class="source-inline">PetType</strong> protocol to solve this challenge without using inheritance at all:</p>
			<p class="source-code">struct Cat: PetType {</p>
			<p class="source-code">    </p>
			<p class="source-code">    let name: String</p>
			<p class="source-code">    var age: Int</p>
			<p class="source-code">    static let latinName: String = 'Felis catus'</p>
			<p class="source-code">    </p>
			<p class="source-code">    func sleep() {</p>
			<p class="source-code">        print('Cat: Zzzz')</p>
			<p class="source-code">    }</p>
			<p class="source-code">    </p>
			<p class="source-code">}</p>
			<p class="source-code">struct Dog: PetType {</p>
			<p class="source-code">    let name: String</p>
			<p class="source-code">    var age: Int</p>
			<p class="source-code">    static let latinName: String = 'Canis familiaris'</p>
			<p class="source-code">    </p>
			<p class="source-code">    func sleep() {</p>
			<p class="source-code">        print('Dog: Zzzz')</p>
			<p class="source-code">    }</p>
			<p class="source-code">    </p>
			<p class="source-code">}</p>
			<p class="source-code">func nap(pet: PetType) {</p>
			<p class="source-code">    pet.sleep()</p>
			<p class="source-code">}</p>
			<p>We just managed to <a id="_idIndexMarker311"/>implement a single method that can take both the <strong class="source-inline">Cat</strong> and <strong class="source-inline">Dog</strong> objects and makes them take a nap. </p>
			<p>Instead of checking for a type, the code checks that the pet that is passed in conforms to the <strong class="source-inline">PetType</strong> protocol, and if it does, its <strong class="source-inline">sleep()</strong> method can be called because the protocol dictates that any <strong class="source-inline">PetType</strong> instance must implement a <strong class="source-inline">sleep()</strong> method. This brings us to the next topic of this chapter: checking for traits instead of types.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor188"/>Checking for traits instead of types</h2>
			<p>In classic OOP, you <a id="_idIndexMarker312"/>often create superclasses and subclasses to group together objects with similar capabilities. If you roughly model a group of felines in the animal kingdom with classes, you end up with a diagram that looks like this:</p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/Figure_7.01_B14717.jpg" alt="Figure 7.1 – Object-orientated flow&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – Object-orientated flow</p>
			<p>If you try to model more animals, you will find that it's a complex task because some animals share a whole bunch of traits, although they are quite far apart from each other in the class diagram.</p>
			<p>One example would be that both cats and dogs are typically kept as pets. This means that they should optionally have an owner and maybe a home. But cats and dogs aren't the only animals kept as pets because fish, guinea pigs, rabbits, and even snakes are kept as pets. </p>
			<p>It would be tough to figure<a id="_idIndexMarker313"/> out a sensible way to restructure your class hierarchy in such a way that you don't have to redundantly add owners and homes to every pet in the hierarchy because it would be impossible to add these properties to the right classes selectively.</p>
			<p>This problem gets even worse when you write a function or method that prints a pet's home. You would either have to make that function accept any animal or write a separate implementation of the same function for each type that has the properties you're looking for. Neither of these approaches makes sense because you don't want to write the same function over and over again with just a different class for the parameter. Even if you choose to do this and you end up with a method that prints an animal's home address that accepts a <strong class="source-inline">Fish</strong> instance, passing an instance of <strong class="source-inline">GreatWhiteShark</strong> to a function called <strong class="source-inline">printHomeAddress()</strong> doesn't make a lot of sense either, because sharks typically don't have home addresses. Of course, the solution to this problem is to use protocols.</p>
			<p>In the situation described in the previous section, objects were mostly defined by what they are, not by what they do. We care about the fact that an animal is part of a particular family or type, not about whether it lives on land. You can't differentiate between animals that can fly and animals that can't because not all birds can fly.</p>
			<p>Inheritance isn't compatible with this way of thinking. Imagine a definition for a <strong class="source-inline">Pigeon</strong> struct that looks like this:</p>
			<p class="source-code">struct Pigeon: Bird, FlyingType, OmnivoreType, Domesticatable</p>
			<p>Since <strong class="source-inline">Pigeon</strong> is a struct, you<a id="_idIndexMarker314"/> know that <strong class="source-inline">Bird</strong> isn't a struct or class—it's a protocol that defines a couple of requirements about what it means to be a bird.</p>
			<p>The <strong class="source-inline">Pigeon</strong> struct also conforms to the <strong class="source-inline">FlyingType</strong>, <strong class="source-inline">OmnivoreType</strong>, and <strong class="source-inline">Domesticatable</strong> protocols. Each of these protocols tells you something about <strong class="source-inline">Pigeon</strong> regarding its capabilities or traits. The definition explains what a pigeon is and does instead of merely communicating that it inherits from a certain type of bird.</p>
			<p>For example, almost all birds can fly, but there are some exceptions to the rule. You could model this with classes, but this approach is tedious and might be inflexible, depending on your needs and how your code evolves.</p>
			<p>Setting the <strong class="source-inline">Pigeon</strong> struct up with protocols is powerful; you can now write a <strong class="source-inline">printHomeAddress()</strong> function and set it up so that it accepts any object that conforms to <strong class="source-inline">Domesticatable</strong>:</p>
			<p class="source-code">protocol Domesticatable {</p>
			<p class="source-code">    var homeAddress: String? { get }</p>
			<p class="source-code">}</p>
			<p class="source-code">func printHomeAddress(animal: Domesticatable) {</p>
			<p class="source-code">    if let address = animal.homeAddress {</p>
			<p class="source-code">        print(address)</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">Domesticatable</strong> protocol requires an optional <strong class="source-inline">homeAddress</strong> property. Not every animal that can be domesticated actually is. </p>
			<p>For example, think about the pigeon; some pigeons are kept as pets, but most aren't. This also applies to cats and dogs, because not every cat or dog has a home.</p>
			<p>This approach is powerful, but shifting your mind from an object-oriented mindset, where you think of an inheritance hierarchy, to a protocol-oriented mindset, where you focus on traits instead of inheritance, isn't easy.</p>
			<p>Let's expand the example code a bit more by defining <strong class="source-inline">OmnivoreType</strong>, <strong class="source-inline">HerbivoreType</strong>, and <strong class="source-inline">CarnivoreType</strong>. These types will represent the three main types of eaters in the animal kingdom. You can make use of inheritance inside of these protocols because <strong class="source-inline">OmnivoreType</strong> is both <strong class="source-inline">HerbivoreType</strong> and <strong class="source-inline">CarnivoreType</strong>, so you can make <strong class="source-inline">OmnivoreType</strong> inherit<a id="_idIndexMarker315"/> from both of these protocols:</p>
			<p class="source-code">protocol Domesticatable {</p>
			<p class="source-code">    var homeAddress: String? { get }</p>
			<p class="source-code">}</p>
			<p class="source-code">protocol HerbivoreType {</p>
			<p class="source-code">    var favoritePlant: String { get }</p>
			<p class="source-code">}</p>
			<p class="source-code">protocol CarnivoreType {</p>
			<p class="source-code">    var favoriteMeat: String { get }</p>
			<p class="source-code">}</p>
			<p class="source-code">protocol OmnivoreType: HerbivoreType, CarnivoreType { }</p>
			<p>Composing two protocols into one like you did in the preceding example is powerful, but be careful when you do this. </p>
			<p>You don't want to create a crazy inheritance graph like you would when you do OOP; you just learned that inheritance could be wildly complex and inflexible. </p>
			<p>Imagine writing two new<a id="_idIndexMarker316"/> functions, one to print a carnivore's favorite meat and one to print a herbivore's favorite plant. Those functions would look like this:</p>
			<p class="source-code">func printFavoriteMeat(forAnimal animal: CarnivoreType) {</p>
			<p class="source-code">    print(animal.favoriteMeat)</p>
			<p class="source-code">}</p>
			<p class="source-code">func printFavoritePlant(forAnimal animal: HerbivoreType) {</p>
			<p class="source-code">    print(animal.favoritePlant)</p>
			<p class="source-code">}</p>
			<p>The preceding code might be exactly what you would write yourself. However, neither of these methods accepts <strong class="source-inline">OmnivoreType</strong>. This is perfectly fine because <strong class="source-inline">OmnivoreType</strong> inherits from <strong class="source-inline">HerbivoreType</strong> and <strong class="source-inline">CarnivoreType</strong>. </p>
			<p>This works in the same way that you're used to in classical OOP, with the main exception being that <strong class="source-inline">OmnivoreType</strong> inherits from multiple protocols instead of just one. </p>
			<p>This means that the <strong class="source-inline">printFavoritePlant()</strong> function accepts a <strong class="source-inline">Pigeon</strong> instance as its argument because <strong class="source-inline">Pigeon</strong> conforms to <strong class="source-inline">OmnivoreType</strong>, which inherits from <strong class="source-inline">HerbivoreType</strong>.</p>
			<p>Using protocols to compose your objects like this can drastically simplify your code. Instead of thinking about complex inheritance structures, you can compose your objects with protocols that define certain traits. The beauty of this is that it makes defining new objects relatively easy.</p>
			<p>Imagine that a new type of animal is discovered, one that can fly, swim, and lives on land. This weird new species would be really hard to add to an inheritance-based architecture since it doesn't fit in with other animals.</p>
			<p>When using protocols, you could add conformance to the <strong class="source-inline">FlyingType</strong>, <strong class="source-inline">LandType</strong>, and <strong class="source-inline">SwimmingType</strong> protocols and you'd be all set. Any methods or functions that take a <strong class="source-inline">LandType</strong> animal as an argument will happily accept your new animal since it conforms to the <strong class="source-inline">LandType</strong> protocol.</p>
			<p>Getting the hang of this way of thinking isn't simple, and it will require some practice. But any time you're getting ready to create a superclass or subclass, ask yourself why. If you're trying to encapsulate a certain trait in that class, try using a protocol.</p>
			<p>This will train you to think differently about your objects, and before you know it, your code will be cleaner, more readable, and more flexible, using protocols and checking for traits instead of taking action based on what an object is.</p>
			<p>As you've seen, a protocol <a id="_idIndexMarker317"/>doesn't need to have a lot of requirements; sometimes one or two are enough to convey the right meaning. Don't hesitate to create protocols with just a single property or method; as your projects grow over time and your requirements change, you will thank yourself for doing so.</p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor189"/>Extending your protocols with default behavior</h2>
			<p>The previous examples <a id="_idIndexMarker318"/>have mainly used variables as the <a id="_idIndexMarker319"/>requirements for protocols. One slight downside of protocols is that they can result in a bit of code duplication.</p>
			<p>For example, every object that is <strong class="source-inline">HerbivoreType</strong> has a <strong class="source-inline">favoriteMeat</strong> variable. This means that you have to duplicate this variable in every object that conforms to <strong class="source-inline">HerbivoreType</strong>. Usually, you want as little code repetition as possible, and repeating a variable over and over again might seem like a step backward.</p>
			<p>Even though it's nice if you don't have to declare the same property over and over again, there's a certain danger in not doing this. If your app grows to a large size, you won't remember every class, subclass, and superclass all of the time. This means that changing or removing a specific property can have undesired side-effects in other classes.</p>
			<p>Declaring the same properties on every object that conforms to a certain protocol isn't that big a deal; it usually takes just a few lines of code to do this. However, protocols can also require certain methods to be present on objects that conform to them.</p>
			<p>Declaring them over and over again can be cumbersome, especially if the implementation is the same for most objects. Luckily, you can make use of protocol extensions to implement a certain degree of default functionality.</p>
			<p>To explore protocol extensions, let's move the <strong class="source-inline">printHomeAddress()</strong> function into the <strong class="source-inline">Domesticatable</strong> protocol so all <strong class="source-inline">Domesticatable</strong> objects can print their own home addresses. The first approach you can take is to immediately define the method on a protocol extension<a id="_idIndexMarker320"/> without adding it to the protocol's requirements:</p>
			<p class="source-code">extension Domesticatable {</p>
			<p class="source-code">    func printHomeAddress() {</p>
			<p class="source-code">        if let address = homeAddress {</p>
			<p class="source-code">            print(address)</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>By defining the <strong class="source-inline">printHomeAddress()</strong> method in the protocol extension, every object that conforms to <strong class="source-inline">Domesticatable</strong> has the following method available without having to<a id="_idIndexMarker321"/> implement it with the object itself:</p>
			<p class="source-code">let pidgeon = Pigeon(favoriteMeat: 'Insects',</p>
			<p class="source-code">                       favoritePlant: 'Seeds',</p>
			<p class="source-code">                       homeAddress: 'Greater Manchester,                        England')</p>
			<p class="source-code">pidgeon.printHomeAddress()</p>
			<p>This technique is very convenient if you want to implement default behavior that's associated with a protocol.</p>
			<p>You didn't even have to add the <strong class="source-inline">printHomeAddress()</strong> method as a requirement to the protocol. However, this approach will give you some strange results if you're not careful. The following snippet shows an example of such odd results by adding a custom implementation of <strong class="source-inline">printHomeAddress()</strong> to the <strong class="source-inline">Pigeon</strong> struct:</p>
			<p class="source-code">struct Pigeon: Bird, FlyingType, OmnivoreType, Domesticatable {</p>
			<p class="source-code">    let favoriteMeat: String</p>
			<p class="source-code">    let favoritePlant: String</p>
			<p class="source-code">    let homeAddress: String?</p>
			<p class="source-code">    </p>
			<p class="source-code">    func printHomeAddress() {</p>
			<p class="source-code">        if let address = homeAddress {</p>
			<p class="source-code">            print('address: \(address.uppercased())')</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>When<a id="_idIndexMarker322"/> you call <strong class="source-inline">myPigeon.printHomeAddress()</strong>, the custom implementation is used to print the address. However, if you define a function, such as <strong class="source-inline">printAddress(animal:)</strong>, that takes a <strong class="source-inline">Domesticatable</strong> object as its parameter, the default implementation provided by the protocol is used.</p>
			<p>This happens <a id="_idIndexMarker323"/>because <strong class="source-inline">printHomeAddress()</strong> isn't a requirement of the protocol. Therefore, if you call <strong class="source-inline">printHomeAddress()</strong> on a <strong class="source-inline">Domesticatable</strong> object, the implementation from the protocol extension is used. If you use the same snippet as in the preceding section, but change the <strong class="source-inline">Domesticatable</strong> protocol as shown in the following code, both calls to <strong class="source-inline">printHomeAddress()</strong> print the same thing, that is, the custom implementation in the <strong class="source-inline">Pigeon</strong> struct:</p>
			<p class="source-code">protocol Domesticatable {</p>
			<p class="source-code">    var homeAddress: String? { get }</p>
			<p class="source-code"><strong class="bold">    func printHomeAddress()</strong></p>
			<p class="source-code">}</p>
			<p>This behavior is likely to be unexpected in most cases, so it's usually a good idea to define all methods you use in the protocol requirements unless you're absolutely sure you want the behavior you just saw.</p>
			<p>Protocol extensions can't hold stored properties. This means that you can't add your variables to the protocol to provide a default implementation for them. Even though extensions can't hold stored properties, there are situations where you can still add a computed <a id="_idIndexMarker324"/>property to a protocol extension to avoid <a id="_idIndexMarker325"/>duplicating the same variable in multiple places. Let's take a look at an example:</p>
			<p class="source-code">protocol Domesticatable {</p>
			<p class="source-code">    var homeAddress: String? { get }</p>
			<p class="source-code">    var hasHomeAddress: Bool { get }</p>
			<p class="source-code">    func printHomeAddress()</p>
			<p class="source-code">}</p>
			<p class="source-code">extension Domesticatable {</p>
			<p class="source-code">    var hasHomeAddress: Bool {</p>
			<p class="source-code">        return homeAddress != nil</p>
			<p class="source-code">    }</p>
			<p class="source-code">    </p>
			<p class="source-code">    func printHomeAddress() {</p>
			<p class="source-code">        if let address = homeAddress {</p>
			<p class="source-code">            print(address)</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>If you want to be able to check whether a <strong class="source-inline">Domesticatable</strong> has a home address, you can add a requirement for a Bool value, <strong class="source-inline">hasHomeAddress</strong>. If the <strong class="source-inline">homeAddress</strong> property is set, <strong class="source-inline">hasHomeAddress</strong> should be true. Otherwise, it should be false.</p>
			<p>This property is computed in the protocol extension, so you don't have to add this property to all <strong class="source-inline">Domesticatable</strong> objects. In this case, it makes a lot of sense to use a computed property because the way its value is computed should most likely be the same across all <strong class="source-inline">Domesticatable</strong> objects.</p>
			<p>Implementing <a id="_idIndexMarker326"/>default behaviors in protocol extensions <a id="_idIndexMarker327"/>makes the protocol-oriented approach we've seen before even more powerful; you can essentially mimic a feature called multiple inheritance without all the downsides of subclassing.</p>
			<p>Simply adding conformance to a protocol can add all kinds of functionality to your objects, and if the protocol extensions allow it, you won't need to add anything else to your code. Let's see how you can make protocols and extensions even more powerful with associated types.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor190"/>Improving your protocols with associated types</h2>
			<p>One more <a id="_idIndexMarker328"/>awesome aspect of protocol-oriented <a id="_idIndexMarker329"/>programming is the use of associated types. An associated type is a generic, non-existing type that can be used in your protocol like any type that does exist.</p>
			<p>The real type of this generic is determined by the compiler based on the context it's used in. This description is abstract, and you might not immediately understand why or how an associated type can benefit your protocols. After all, aren't protocols themselves a very flexible way to make several unrelated objects fit certain criteria based on the protocols they conform to?</p>
			<p>To illustrate and discover the use of associated types, you will expand your animal kingdom a bit. What you should do is give the herbivores an <strong class="source-inline">eat</strong> method and an array to keep track of the plants they've eaten, as follows:</p>
			<p class="source-code">protocol HerbivoreType {</p>
			<p class="source-code">    var plantsEaten: [PlantType] { get set }</p>
			<p class="source-code">    mutating func eat(plant: PlantType)</p>
			<p class="source-code">}</p>
			<p class="source-code">extension HerbivoreType {</p>
			<p class="source-code">    mutating func eat(plant: PlantType) {</p>
			<p class="source-code">        plantsEaten.append(plant)</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This code looks fine at first sight. An herbivore eats plants, and this is established by this protocol. The <strong class="source-inline">PlantType</strong> protocol is defined as follows:</p>
			<p class="source-code">protocol PlantType {</p>
			<p class="source-code">    var latinName: String { get }</p>
			<p class="source-code">}</p>
			<p>Let's define<a id="_idIndexMarker330"/> two different plant types and an animal that<a id="_idIndexMarker331"/> will be used to demonstrate the problem with the preceding code:</p>
			<p class="source-code">struct Grass: PlantType{ var latinName = 'Poaceae'</p>
			<p class="source-code">}</p>
			<p class="source-code">struct Pine: PlantType{ var latinName = 'Pinus'</p>
			<p class="source-code">}</p>
			<p class="source-code">struct Cow: HerbivoreType {</p>
			<p class="source-code">    var plantsEaten = [PlantType]()</p>
			<p class="source-code">}</p>
			<p>There shouldn't be a big surprise here. Let's continue with creating a <strong class="source-inline">Cow</strong> instance and feed it <strong class="source-inline">Pine</strong>:</p>
			<p class="source-code">var cow = Cow()</p>
			<p class="source-code">let pine = Pine()</p>
			<p class="source-code">cow.eat(plant: pine)</p>
			<p>This doesn't<a id="_idIndexMarker332"/> really make sense. Cows don't eat pines; they <a id="_idIndexMarker333"/>eat grass! We need some way to limit this cow's food intake because this approach isn't going to work.</p>
			<p>Currently, you can feed <strong class="source-inline">HerbivoreType</strong> animals anything that's considered a plant. You need some way to limit the types of food your cows are given. In this case, you should restrict <strong class="source-inline">FoodType</strong> to <strong class="source-inline">Grass</strong> only, without having to define the <strong class="source-inline">eat(plant:)</strong> method for every plant type you might want to feed a <strong class="source-inline">HerbivoreType</strong>.</p>
			<p>The problem you're facing now is that all <strong class="source-inline">HerbivoreType</strong> animals mainly eat one plant type, and not all plant types are a good fit for all herbivores. This is where associated types are a great solution. An associated type for the <strong class="source-inline">HerbivoreType</strong> protocol can constrain the <strong class="source-inline">PlantType</strong> that a certain herbivore can eat to a single type that is defined by <strong class="source-inline">HerbivoreType</strong>. Let's see what this looks like:</p>
			<p class="source-code">protocol HerbivoreType {</p>
			<p class="source-code">    associatedtype Plant: PlantType</p>
			<p class="source-code">    var plantsEaten: [Plant] { get set }</p>
			<p class="source-code">    mutating func eat(plant: Plant)</p>
			<p class="source-code">}</p>
			<p class="source-code">extension HerbivoreType {</p>
			<p class="source-code">    mutating func eat(plant: Plant) {</p>
			<p class="source-code">        print('eating a \(plant.latinName)')</p>
			<p class="source-code">        plantsEaten.append(plant)</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The first highlighted line associates the generic <strong class="source-inline">Plant</strong> type, which doesn't exist as a real type, with the protocol. A constraint has been added to <strong class="source-inline">Plant</strong> to ensure that it's a <strong class="source-inline">PlantType</strong>.</p>
			<p>The second highlighted line demonstrates how the <strong class="source-inline">Plant</strong> associated type is used as a <strong class="source-inline">PlantType</strong>. The plant type itself is merely an alias for any type that conforms to <strong class="source-inline">PlantType</strong> and is used as the type of object we use for <strong class="source-inline">plantsEaten</strong> and the <strong class="source-inline">eat</strong> methods. Let's redefine the <strong class="source-inline">Cow</strong> struct to see this associated type in action:</p>
			<p class="source-code">struct Cow: HerbivoreType {</p>
			<p class="source-code">    var plantsEaten = [Grass]()</p>
			<p class="source-code">}</p>
			<p>Instead of making <strong class="source-inline">plantsEaten</strong> a <strong class="source-inline">PlantType</strong> array, it's now defined as an array of <strong class="source-inline">Grass</strong>. In the protocol and the definition, the type of plant is now <strong class="source-inline">Grass</strong>. </p>
			<p>The compiler <a id="_idIndexMarker334"/>understands this because the <strong class="source-inline">plantsEaten</strong> array is <a id="_idIndexMarker335"/>defined as <strong class="source-inline">[Grass]</strong>. Let's define a second <strong class="source-inline">HerbivoreType</strong> that eats a different type of <strong class="source-inline">PlantType</strong>:</p>
			<p class="source-code">struct Carrot: PlantType {</p>
			<p class="source-code">    let latinName = 'Daucus carota'</p>
			<p class="source-code">}</p>
			<p class="source-code">struct Rabbit: HerbivoreType {</p>
			<p class="source-code">    var plantsEaten = [Carrot]()</p>
			<p class="source-code">}</p>
			<p>If you try to feed a cow some carrots, or if you attempt to feed the rabbit a pine, the compiler will throw errors. The reason for this is that the associated type constraint allows you to define the type of <strong class="source-inline">Plant</strong> in each struct separately.</p>
			<p>One side note about associated types is that it's not always possible for the compiler to correctly infer the real type for an associated type. In our current example, this would happen if we didn't have the <strong class="source-inline">plantsEaten</strong> array in the protocol. </p>
			<p>The solution would be to define a <strong class="source-inline">typealias</strong> on types that conform to <strong class="source-inline">HerbivoreType</strong> so that the compiler understands which type <strong class="source-inline">Plant</strong> represents:</p>
			<p class="source-code">protocol HerbivoreType {</p>
			<p class="source-code">    associatedtype Plant: PlantType</p>
			<p class="source-code">    var plantsEaten: [Plant] { get set }</p>
			<p class="source-code">    mutating func eat(plant: Plant)</p>
			<p class="source-code">}</p>
			<p>Associated types can be really powerful when used correctly, but sometimes using them can also cause you a lot of headaches because of the amount of inferring the compiler has to do. </p>
			<p>If you forget a few <a id="_idIndexMarker336"/>tiny steps, the compiler can quickly lose track <a id="_idIndexMarker337"/>of what you're trying to do, and the error messages aren't always the most unambiguous messages. </p>
			<p>Keep this in mind when you're using associated types, and try to make sure that you're as explicit as possible about the type you're looking to be associated with. </p>
			<p>Sometimes, adding a type alias to give the compiler a helping hand is better than trying to get the compiler to infer everything on its own correctly.</p>
			<p>This type of flexibility is not limited to protocols. You can also add generic properties to functions, classes, structs, and enums. Let's see how this works and how it can make your code extremely flexible.</p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor191"/>Adding flexibility with generics</h1>
			<p>Programming with<a id="_idIndexMarker338"/> generics is not always easy, but it does make your code extremely flexible. When you use something such as generics, you are always making a trade-off between the simplicity of your program and the flexibility of your code. Sometimes it's worth it to introduce a little bit of complexity to allow your code to be written in otherwise impossible ways.</p>
			<p>For instance, consider the <strong class="source-inline">Cow</strong> struct you saw before. To specify the generic associated type on the <strong class="source-inline">HerbivoreType</strong> protocol, a type alias was added to the <strong class="source-inline">Cow</strong> struct. Now imagine that not all cows like to eat grass. Maybe some cows prefer flowers, corn, or something else. You would not be able to express this using the type alias.</p>
			<p>To represent a case where you might want to use a different <strong class="source-inline">PlantType</strong> for every cow instance, you can add a generic to the <strong class="source-inline">Cow</strong> itself. The following snippet shows how you can do this:</p>
			<p class="source-code">struct Cow&lt;Plant: PlantType&gt;: HerbivoreType {</p>
			<p class="source-code">    var plantsEaten = [Plant]()</p>
			<p class="source-code">}</p>
			<p>Between <strong class="source-inline">&lt;</strong> and <strong class="source-inline">&gt;</strong>, the generic type name is specified as <strong class="source-inline">Plant</strong>. This generic is constrained to the <strong class="source-inline">PlantType</strong> type. </p>
			<p>This means that any type that will act as <strong class="source-inline">Plant</strong> has to conform to <strong class="source-inline">PlantType</strong>. The protocol will see that <strong class="source-inline">Cow</strong> has a generic <strong class="source-inline">Plant</strong> type now, so there is no need to add a type alias. When you create an instance of <strong class="source-inline">Cow</strong>, you can now pass every instance its own <strong class="source-inline">PlantType</strong>:</p>
			<p class="source-code">let grassCow = Cow&lt;Grass&gt;()</p>
			<p class="source-code">let flowerCow = Cow&lt;Flower&gt;()</p>
			<p>Applying generics to<a id="_idIndexMarker339"/> instances like this is more common than you might think. An <strong class="source-inline">Array</strong> instance uses generics to determine what kind of elements it contains. The following two lines of code are identical in functionality:</p>
			<p class="source-code">let strings = [String]()</p>
			<p class="source-code">let strings = Array&lt;String&gt;()</p>
			<p>The first line uses a convenient syntax to create an array of strings. The second line uses the <strong class="source-inline">Array</strong> initializer and explicitly specifies the type of element it will contain.</p>
			<p>Sometimes, you might find yourself writing a function or method that can benefit from a generic argument or return type. An excellent example of a generic function is <strong class="source-inline">map</strong>. With <strong class="source-inline">map</strong>, you can transform an array of items into an array of different items. You can define your own simple version of <strong class="source-inline">map</strong> as follows:</p>
			<p class="source-code">func simpleMap&lt;T, U&gt;(_ input: [T], transform: (T) -&gt; U) -&gt; [U] {</p>
			<p class="source-code">    </p>
			<p class="source-code">    var output = [U]()</p>
			<p class="source-code">    for item in input {</p>
			<p class="source-code">        output.append(transform(item))</p>
			<p class="source-code">    }</p>
			<p class="source-code">    </p>
			<p class="source-code">    return output</p>
			<p class="source-code">}</p>
			<p>Here, <strong class="source-inline">simpleMap(_:transform:)</strong> has two generic types, <strong class="source-inline">T</strong> and <strong class="source-inline">U</strong>. These names are common placeholders for generics, so they make it clear to anybody reading this code that they are about to deal with generics. </p>
			<p>In this sample, the function expects an input of <strong class="source-inline">[T]</strong>, which you can read as an array of something. It also expects a closure that takes an argument, <strong class="source-inline">T</strong>, and returns <strong class="source-inline">U</strong>. </p>
			<p>You can interpret this as the closure taking an element out of that array of something, and it transforms it into something else.</p>
			<p>The function finally<a id="_idIndexMarker340"/> returns an array of <strong class="source-inline">[U]</strong>, or in other words, an array of something else.</p>
			<p>You would use <strong class="source-inline">simpleMap(_:transform:)</strong> as follows:</p>
			<p class="source-code">let result = simpleMap([1, 2, 3]) { item in</p>
			<p class="source-code">    return item * 2</p>
			<p class="source-code">}</p>
			<p class="source-code">print(result) // [2, 4, 6]</p>
			<p>Generics are not always easy to understand, and it's okay if they take you a little while to get used to it. They are a powerful and complex topic that we could write many more pages about. </p>
			<p>The best way to get into them is to use them, practice with them, and read as much as you can about them. For now, you <a id="_idIndexMarker341"/>should have more than enough to think about and play with.</p>
			<p>Note that generics are not limited to structs and functions. You can also add generics to your enums and classes in the same way you add them to a struct.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor192"/>Summary</h1>
			<p>In this chapter, you saw how you can leverage the power of protocols to work with an object's traits or capabilities, rather than just using its class as the only way of measuring its capabilities. Then, you saw how protocols can be extended to implement a default functionality. This enables you to compose powerful types by merely adding protocol conformance, instead of creating a subclass. </p>
			<p>You also saw how protocol extensions behave depending on your protocol requirements, and that it's wise to have anything that's in the protocol extension defined as a protocol requirement. This makes the protocol behavior more predictable.</p>
			<p>Finally, you learned how associated types work and how they can take your protocols to the next level by adding generic types to your protocols that can be tweaked for every type that conforms to your protocol. You even saw how you can apply generics to other objects, such as functions and structs.</p>
			<p>The concepts shown in this chapter are pretty advanced, sophisticated, and powerful. To truly master their use, you'll need to train yourself to think regarding traits instead of an inheritance hierarchy. </p>
			<p>Once you've mastered this, you can experiment with protocol extensions and generic types. It's okay if you don't fully understand these topics right off the bat; they're completely different and new ways of thinking for most programmers with OOP experience. </p>
			<p>Now that we've explored some of the theory behind protocols and value types, in the next chapter, you will learn how you can put this new knowledge to use by shortly revisiting the Contacts app from our previous chapters to improve the code you wrote there.</p>
		</div>
	</body></html>