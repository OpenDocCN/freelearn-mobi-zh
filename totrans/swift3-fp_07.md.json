["```swift\n// Optional value either contains a value or contains nil\nvar optionalString: String? = \"A String literal\"\noptionalString = nil\n\n```", "```swift\nvar aString: String = \"A String literal\"\naString = nil\n\n```", "```swift\nNSString *searchedItem = [self searchItem:@\"an item\"];\nNSString *text = @\"Found item: \";\nNSString *message = [text stringByAppendingString:searchedItem];\n\n```", "```swift\nenum Optional<T> {\n    case None\n    case Some(T)\n}\n\n```", "```swift\nprint(optionalString)\n\n```", "```swift\noptionalString = \"An optional String\"\nprint(optionalString!)\n\n```", "```swift\nif optionalString != nil {\n    print(optionalString!)\n}\n\n```", "```swift\nlet nilName: String? = nil\nif let familyName = nilName {\n    greetingfamilyName = \"Hello, Mr. \\(familyName)\"\n} else {\n    // Optional does not have a value\n}\n\n```", "```swift\nlet dict = [\"One\": 1, \"Two\": 2, \"Three\": 3]\n\nif let firstValue = dict[\"One\"] {\n    if let secondValue = dict[\"Two\"] {\n        if let thirdValue = dict[\"Three\"] {\n            // Do something with three values\n        }\n    }\n}\n\n```", "```swift\nif let\nfirstValue = dict[\"One\"],\nsecondValue = dict[\"Two\"],\nthirdValue = dict[\"Three\"] {\n    // Do something with three values\n}\n\n```", "```swift\nfunc greet(person: [String: String]) {\n    guard let name = person[\"name\"] else {\n        return\n    }\n    print(\"Hello Ms \\(name)!\")\n}\n\ngreet(person: [\"name\": \"Neco\"]) // prints \"Hello Ms Neco!\"\n\n```", "```swift\nfunc extractValue(dict: [String: Int]) {\n    guard let\n    firstValue = dict[\"One\"],\n    secondValue = dict[\"Two\"],\n    thirdValue = dict[\"Three\"]\n    else {\n        return\n    }\n    // Do something with three values\n} \n\n```", "```swift\nlet one = \"One\" \nlet firstValue = dict[\"One\"] \nlet implictlyUnwrappedFirstValue: Int! = dict[\"One\"]\n\n```", "```swift\nfunc checkForPath(path: String) -> String? {\n    // check for the path\n    return \"path\"\n}\n\nfunc readFile(path: String) -> String? {\n    if let restult = checkForPath(path: path) {\n        return restult\n    } else {\n        return nil\n    }\n}\n\n```", "```swift\nif let result = readFile(path: \"path/to\") {\n    // Do something with result\n}\n\n```", "```swift\nenum Result: ErrorProtocol {\n    case failure\n    case success\n}\n\nfunc readFile(path: String) throws -> String {\n    if let restult = checkForPath(path: path) {\n        return restult\n    } else {\n        throw Result.failure\n    }\n}\n\n```", "```swift\ndo {\n    let result = try readFile(path: \"path/to\")\n} catch {\n    print(error)\n}\n\n```", "```swift\ndo {\n    let result = try readFile(path: \"path/to\")\n} catch {\n    print(error)\n}\n\n```", "```swift\nlet result = try? readFile(path: \"path/to\")\n\n```", "```swift\nclass Residence {\n    var numberOfRooms = 1\n}\n\nclass Person {\n    var residence: Residence?\n}\n\n```", "```swift\nlet residence = Residence()\nresidence.numberOfRooms = 5\nlet sangeeth = Person()\nsangeeth.residence = residence\n\n```", "```swift\nif let roomCount = sangeeth.residence?.numberOfRooms {\n    // Use the roomCount\n    print(roomCount)\n}\n\n```", "```swift\nlet roomCount = sangeeth.residence!.numberOfRooms\n\n```", "```swift\nfunc mapOptionals<T, V>(transform: (T) -> V, input: T?) -> V? {\n    switch input {\n        case .some(let value): return transform(value)\n        case .none: return .none\n    }\n}\n\n```", "```swift\nclass User {\n    var name: String?\n}\n\n```", "```swift\nfunc extractUserName(name: String) -> String {\n    return \"\\(name)\"\n}\n\nvar nonOptionalUserName: String {\n    let user = User()\n    user.name = \"John Doe\"\n    let someUserName = mapOptionals(transform: extractUserName,\n      input: user.name)\n    return someUserName ?? \"\"\n}\n\n```", "```swift\ninfix operator <^> { associativity left }\n\nfunc <^><T, V>(transform: (T) -> V, input: T?) -> V? {\n    switch input {\n        case .some(let value): return transform(value)\n        case .none: return .none\n    }\n}\n\n```", "```swift\nvar nonOptionalUserName: String {\n    let user = User()\n    user.name = \"John Doe\"\n    let someUserName = extractUserName <^> user.name\n    return someUserName ?? \"\"\n}\n\n```", "```swift\nfunc apply<T, V>(transform: ((T) -> V)?, input: T?) -> V? {\n    switch transform {\n        case .some(let fx): return fx <^> input\n        case .none: return .none\n    }\n}\n\n```", "```swift\ninfix operator <*> { associativity left }\n\nfunc <*><T, V>(transform: ((T) -> V)?, input: T?) -> V? {\n    switch transform {\n        case .some(let fx): return fx <^> input\n        case .none: return .none\n    }\n}\n\n```", "```swift\nfunc extractFullUserName(firstName: String)(lastName: String) -> String {\n    return \"\\(firstName) \\(lastName)\"\n}\n\n```", "```swift\nfunc extractFullUserName(firstName: String) -> (String) -> String { \n    return { (lastName: String) -> String in\n        return \"\\(firstName) \\(lastName)\"\n    }\n}\n\n```", "```swift\nclass User { \n    var firstName: String? \n    var lastName: String? \n} \nvar fullName: String { \n    let user = User() \n    user.firstName = \"John\" \n    user.lastName = \"Doe\"\n    let fullUserName = extractFullUserName <^> user.firstName <*> \n      user.lastName\n    return fullUserName ?? \"\" \n}\n\n```", "```swift\nlet optionalString: String? = \"A String literal\" \nlet result = optionalString.map { \"\\($0) is mapped\" }\n\n```", "```swift\nlet optionalArray: [String?] = [\"First\", \"Second\", nil, \"Fourth\"] \nlet nonOptionalArray = optionalArray.flatMap { $0 } \nprint(nonOptionalArray) \n\n```"]