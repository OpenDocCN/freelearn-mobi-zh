<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Showing Images on the Screen</h1></div></div></div><p>One of the basic skills we need to obtain in order to develop games is <a id="id56" class="indexterm"/>
<strong>image manipulation</strong>. In this chapter, we'll discuss some aspects of this topic that will be useful for our game. We'll introduce the notion of Decks and Props and talk about how to handle them in order to make our game graphics.</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec28"/>Introduction to Decks and Props</h1></div></div></div><p>In Moai SDK, all of the assets (images, tilesets, meshes, and surfaces) are defined in Decks. You can think of a Deck as the geometry of an object. <a id="id57" class="indexterm"/>
<strong>Decks</strong> hold the actual image data for a sprite, for example. They're not shown in the screen, until you reference them using a Prop. You can think of Decks as the Prop's drawing method.</p><p>There are many types of Decks <a id="id58" class="indexterm"/>
<code class="literal">MOAIGfxQuad2D</code>, for example, handles one single image. <a id="id59" class="indexterm"/>
<code class="literal">MOAITileDeck2D</code>
<a id="id60" class="indexterm"/>
<a id="id61" class="indexterm"/> is used to load a tileset (or atlas) and reference its tiles (we will use it later in the book).</p><p>
<strong>Props</strong> are <a id="id62" class="indexterm"/>basically a collection of information and a reference to a given Deck. They hold information such as location, scale, and rotation; and are the actual objects that you see on the screen.</p><p>This separation is pretty useful, since it allows you to reuse the memory allocated to a specific asset. We will use this to handle all of our tiles and instead of loading the image for the back of the tile 20 times, we'll just load it once and point to it.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec29"/>Our first image</h1></div></div></div><p>The first thing we need to do is to have an actual <a id="id63" class="indexterm"/>image. We'll use the back of a tile from our <em>Concentration</em> game in this example, you can get it from the book's website, along with the full source code for this example.</p><p>To begin with, we need a layer. A <a id="id64" class="indexterm"/>
<strong>layer</strong> groups together one or more Props and serves as a way to control rendering priorities between different Prop sets. For example, you can have one layer for the background and another one on top of it for the objects, and when you add a new Prop on the background layer, it will <a id="id65" class="indexterm"/>be displayed below the Props on the objects layer.</p><div><div><h3 class="title"><a id="note04"/>Note</h3><p>
<code class="literal">MOAILayer</code> <a id="id66" class="indexterm"/>inherits from <a id="id67" class="indexterm"/>
<code class="literal">MOAIProp</code>, so you can think of it as a Prop that groups other Props. You can call any of the methods of <code class="literal">MOAIProp</code> on a layer.</p></div></div><p>In order to create a layer, you have to <a id="id68" class="indexterm"/>instantiate <code class="literal">MOAILayer2D</code> as follows (type this below the viewport initialization in the code for <a class="link" href="ch04.html" title="Chapter 4. Our First Game with Moai">Chapter 4</a>, <em>Our First Game with Moai</em>):</p><div><ol class="orderedlist arabic"><li class="listitem">First of all we create our layer:<div><pre class="programlisting">layer = MOAILayer2D.new ()</pre></div></li><li class="listitem">We need to tell that layer to use our viewport. This is done using the <code class="literal">setViewport()</code> <a id="id69" class="indexterm"/>method.<div><pre class="programlisting">layer:setViewport ( viewport )</pre></div></li><li class="listitem">Now we have to create our Deck. Since we're only displaying a simple image, we will use <code class="literal">MOAIGfxQuad2D</code> which serves that purpose.<div><ol class="orderedlist arabic"><li class="listitem">We create the Deck object.<div><pre class="programlisting">imageGfx = MOAIGfxQuad2D.new ()</pre></div></li><li class="listitem">We use the <a id="id70" class="indexterm"/><code class="literal">setTexture()</code> method and pass the path of our asset to it (in this case the back of a tile). This is where we tell the Deck to actually use our image.<div><pre class="programlisting">imageGfx:setTexture ( 'assets/tile_back.png' )</pre></div></li><li class="listitem">The third line sets the geometry. <code class="literal">MOAIGfxQuad2D</code> has a rectangular geometry. In order to define it, we can use <code class="literal">setRect</code>, which receives four numbers, <code class="literal">xMin</code>, <code class="literal">yMin</code>, <code class="literal">xMax</code>, and <code class="literal">yMax</code>.<div><pre class="programlisting">imageGfx:setRect ( -31, -31, 31, 31 )</pre></div></li></ol></div><p>We'll use the convention that the object coordinate <code class="literal">(0, 0)</code> is in the center. In this way, since we want to show the image with a 62 x 62 size, the actual rectangle that holds it can be defined as the rectangle that has <code class="literal">xMin = -31</code>, <code class="literal">yMin = -31</code>, <code class="literal">xMax = 31</code>, and <code class="literal">yMax = 31</code>, since we want it to have its <code class="literal">(0,0)</code> at the center of the image. We could define it with <code class="literal">setRect ( 0, 0, 62, 62 )</code> and the center would be at the upper-left corner, but let's keep <code class="literal">(0,0)</code> at the center of the image convention for simplicity. Just note that this is pretty powerful. You could define the rectangles differently according to how you want to manipulate them.</p><div><img src="img/5064_05_01.jpg" alt="Our first image"/></div></li><li class="listitem">The next step is to <a id="id71" class="indexterm"/>set up our Prop.<div><ol class="orderedlist arabic"><li class="listitem">First of all we create Prop.<div><pre class="programlisting">imageProp = MOAIProp2D.new ()</pre></div></li><li class="listitem">Then we tell the Prop to use <code class="literal">imageGfx</code> as the Deck. This is the point where we connect them together. We're saying that this prop will be an instance of our back of tile image.<div><pre class="programlisting">imageProp:setDeck (imageGfx)</pre></div></li><li class="listitem">The third line moves the Prop to the center of the screen.<div><pre class="programlisting">imageProp:setLoc (0, 0)</pre></div><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>We're using the <code class="literal">setLoc()</code> <a id="id72" class="indexterm"/>method to move the image to the back of the tile. You can change the parameters and see how it behaves. By default, <code class="literal">(0,0)</code> is the center of the screen, so negative values in <em>x</em> will move the object to the left and positive ones to the right. Negative values in <em>y</em> will move the object down and positive ones will move it up. This is not the same as the typical coordinate system used in computer graphics, which sets <code class="literal">(0,0)</code> at the top-left corner and the <em>y</em> axis grows downward.</p></div></div></li></ol></div></li><li class="listitem">The next step is to insert our Prop into the layer we created, so it will render when the layer is rendered.<div><pre class="programlisting">layer:insertProp (imageProp)</pre></div></li><li class="listitem">And the last step is to make that layer renderable.<div><pre class="programlisting">renderTable = { layer }
MOAIRenderMgr.setRenderTable (renderTable)</pre></div></li></ol></div><p>This is an interesting thing to talk about. What we are doing here is, first, creating a table that contains the layer as its first object, and then telling <code class="literal">MOAIRenderMgr</code> to use that table for rendering.</p><p>In order to configure rendering, we need to tell <code class="literal">MOAIRenderMgr</code> what we want to render. This is done using the <a id="id73" class="indexterm"/>
<strong>Render table</strong>. As we discussed in <a class="link" href="ch03.html" title="Chapter 3. Basic Moai SDK Concepts">Chapter 3</a>, <em>Basic Moai SDK Concepts</em>, the table and subtables that you pass using <code class="literal">setRenderTable()</code> are the ones that will be rendered during the next rendering step. So, for example if you want to remove all of the objects that are rendering, you don't need to iterate through them, you just have to pass an empty table to the <a id="id74" class="indexterm"/>
<code class="literal">setRenderTable()</code> method.</p><p>You have to be careful when handling this. Keep an eye on the table you're rendering if objects suddenly disappear.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec30"/>Coordinate systems</h1></div></div></div><p>Sooner or later, if you're <a id="id75" class="indexterm"/>developing multi-platform games, you'll need to understand the different coordinate systems that are involved.</p><p>In Moai SDK, we have at least three coordinate systems that are important to remember and to make good use of.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec14"/>Window/Screen coordinates</h2></div></div></div><p>This is the coordinate system <a id="id76" class="indexterm"/>
<a id="id77" class="indexterm"/>attached to your window. You will typically have to deal with it when receiving mouse or touchscreen input. You might also use it to design your GUI. If you ever experience any <a id="id78" class="indexterm"/>
<a id="id79" class="indexterm"/>strange behavior when clicking, always double-check that you're correctly transforming input coordinates to world or even model coordinates.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec15"/>World coordinates</h2></div></div></div><p>This is the coordinate system <a id="id80" class="indexterm"/>that you define when setting the scale for the viewport, and is the one that you'll normally use when positioning Props on the screen. <a id="id81" class="indexterm"/>This is where the multi-platform magic happens, since this coordinate system is the one that abstracts different screen resolutions so that you don't need to take them all into account. Aspect ratio changes need to be handled, but that's a separate topic by itself.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec16"/>Model coordinates</h2></div></div></div><p>This coordinate system is the <a id="id82" class="indexterm"/>one Props use. It's related to Prop geometry.</p><p>It's really useful when checking for collisions. <a id="id83" class="indexterm"/>Given an arbitrary point in the world, converting it to model coordinates will give you a point that has a certain offset in <em>x</em> and <em>y</em> from the Prop's center. If you know the Prop's size, you can actually check if the point is inside the Prop's bounds.</p><p>Changing between coordinate systems can simplify your game's logic a lot.</p><div><img src="img/5064_05_02.jpg" alt="Model coordinates"/></div><p>Luckily, this coordinate nightmare is really <a id="id84" class="indexterm"/>easy to address in Moai SDK.</p><p>There are some methods that will help us in this task:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">MOAILayer2D</code> has methods to <a id="id85" class="indexterm"/>transform between window and world coordinates (<code class="literal">wndToWorld</code> and <code class="literal">worldToWnd</code>).</li><li class="listitem" style="list-style-type: disc"><code class="literal">MOAIProp2D</code> has methods to <a id="id86" class="indexterm"/>transform between world and model coordinates (<code class="literal">modelToWorld</code> and <code class="literal">worldToModel</code>).</li></ul></div><p>So, you will want to use these <a id="id87" class="indexterm"/>methods in order to do your calculations based on what entity you're working with. We will use this when implementing the gameplay for our <em>Concentration</em> game.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec31"/>Blend modes</h1></div></div></div><p>A nice feature that you'll be <a id="id88" class="indexterm"/>playing with for sure is <strong>blend modes</strong>.</p><p>Moai SDK gives you the ability to define the blending mode for a certain Prop using the <code class="literal">setBlendMode()</code> method. <a id="id89" class="indexterm"/>This will allow you to modify the way its pixels are rendered on the screen.</p><p>You can choose between <code class="literal">MOAIProp2D.BLEND_NORMAL</code>, <code class="literal">MOAIProp2D.BLEND_ADD</code>, and <code class="literal">MOAIProp2D.BLEND_MULTIPLY</code>.</p><p>
<code class="literal">MOAIProp2D.BLEND_NORMAL</code> is the <a id="id90" class="indexterm"/>default behavior and basically paints over pixels, covering whatever is underneath.</p><p>
<code class="literal">MOAIProp2D.BLEND_ADD</code> does additive <a id="id91" class="indexterm"/>blending. It adds the value for the pixel you're trying to draw to the previous value of the pixel on the screen. This is really useful for particle systems and to obtain that popular glowing effect used to create <em>Tron</em>-like <a id="id92" class="indexterm"/>lights. It can also be used to create static lighting for a scene.</p><p>
<code class="literal">MOAIProp2D.BLEND_MULTIPLY</code> <a id="id93" class="indexterm"/>multiplies the values of the pixel on the screen and the one it's trying to paint. This is really useful for creating static shadows.</p><div><img src="img/5064_05_03.jpg" alt="Blend modes"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec32"/>Summary</h1></div></div></div><p>In this chapter, we learned about Decks and Props—objects that Moai SDK provides to handle images. We saw how to combine these objects, along with the viewport, and show an image on the screen. We also talked about coordinate systems and the importance of understanding them, and when to use which in order to make calculations easier (and correct!). We also introduced the usage of blend modes, which will come in handy for creating nice effects with lights and shadows.</p><p>The next chapter will be the basis of our minimalist game framework, the Resource Manager. This contains code that will handle loading and caching objects in memory. We'll use it to avoid repeating initialization code when we need to use images or sounds.</p></div></body></html>