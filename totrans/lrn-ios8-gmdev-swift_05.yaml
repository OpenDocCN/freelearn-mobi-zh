- en: Chapter 5. Animation and Particles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we created a basic game. In this chapter, we will make
    the game more lively and the characters a little more believable. Instead of just
    static images, we will add animation. We will also look at SpriteKit's inbuilt
    particle effects creator.
  prefs: []
  type: TYPE_NORMAL
- en: For character animation, we will look at how SpriteKit creates animations and
    also at an external tool called **Texture Packer**, developed by Code'n'Web. We
    will see how it simplifies the process of animation. We will also be covering
    a concept called **sprite sheets**, which is fundamental and is used to optimize
    a game's performance.
  prefs: []
  type: TYPE_NORMAL
- en: We will first look at how SpriteKit gets an inbuilt sprite sheet generator and
    makes the animation process simpler. Then we will look at Texture Packer, which
    simplifies the process even further. So let's see what a sprite sheet is.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Sprite sheet animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic SpriteKit animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Texture Packer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a hero sprite sheet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating the hero
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Particle systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The particle designer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a particle effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a particle system to the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sprite sheet animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, what we were doing was using a single file for the player, enemy,
    rocket, and bullet. Every time we create a new rocket, the game goes and gets
    the memory, and finds and retrieves the image. The process is repeated every time
    a bullet is created. This is okay for a simple game such as ours, but later, when
    we start creating more complex games with a lot more enemies and bullet types,
    the process will become very taxing on the device, and the performance of the
    game will be affected.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem, sprite sheets are used. A sprite sheet contains all the
    images that we will use in the game in a single file, instead of 10 images sitting
    at 10 different memory locations. The sprite sheet image file will also be accompanied
    by a data file, which will contain the location and size of each of the images
    located in the sprite sheet. At the start of the game, the sprite sheet image
    and data file are loaded into the cache once. Then, every time the rocket or the
    bullet is called, the game knows where the sprite sheet is and simply loads the
    image from it.
  prefs: []
  type: TYPE_NORMAL
- en: The sprite sheet file needs to be as compact as possible, so images might be
    rotated to make it more compact. The data file will keep track of this, and when
    creating the frames in game, it will make the image upright again.
  prefs: []
  type: TYPE_NORMAL
- en: '![Sprite sheet animation](img/B04014_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When animating in the game, each of the frames for the corresponding animation
    will be stored in an array and made to loop at a particular predefined speed.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, in SpriteKit, all you have to do is provide the frames. At runtime,
    SpriteKit automatically creates a sprite sheet, which we can use in the game.
    We will use SpriteKit's inbuilt sprite sheet creator to create the enemy animation.
    Later, we will create the player animation using Texture Packer.
  prefs: []
  type: TYPE_NORMAL
- en: Basic SpriteKit animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create the enemy animation, we first have to give the images to SpriteKit.
    Since we have to provide **1x** and **2x** images for each frame, we could create
    four image sets; name them `enemy1`, `enemy2`, `enemy3`, and `enemy4`; and then
    drag **1x** and **2x** for each set. Although it is absolutely possible to do
    it this way, it is highly tedious. There is an alternate, less tedious way of
    doing it. While naming each frame, for the **1x** image of a frame you can add
    the numbers `1`, `2`, `3`, and `4` at the end of the file to show the frame names.
    For the **2x** version of a frame, you need to add `@2x` at the end to tell SpriteKit
    that this file is twice the size of the original version of the image. So, for
    the first frame, the **1x** file will be `enemy_1.png`, and the filename for the
    **2x** version of the frame will be `enemy_1@2x.png` (here, I am using an underscore
    because the regular enemy image we used in the previous chapter was already named
    `enemy1.png`).
  prefs: []
  type: TYPE_NORMAL
- en: The `@2x` bit is a keyword, so make sure that you don't name your image regularly
    with `@2x`, as it will cause some unexpected outcomes. This naming convention
    should be used only if you have a **1x** version of an image. To tell SpriteKit
    which image is the **2x**, version you add `@2x` at the end of the file to show
    that this image is twice the size of the other one.
  prefs: []
  type: TYPE_NORMAL
- en: So, for creating the enemy animation, we will have four frames of animation.
    Thus, we will have an image for each frame. Additionally, for the **2x** version,
    we will need four more images that are twice the size, with the filename ending
    with `@2x`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The frames for enemy animation are provided in this chapter''s `Resources`
    folder. Get all the images and place them in a new folder on the desktop. Now,
    to tell Xcode that a sprite sheet has to be created from the images provided,
    click on the folder in which all the images are present and rename it to `enemyAnim.atlas`.
    This is very important; if you don''t do this, then the sprite sheet won''t be
    created. The folder should appear as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic SpriteKit animation](img/B04014_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Drag and drop the folder into the project folder. When the window opens up,
    as shown in the following screenshot, make sure that the **Copy items if needed**
    box is checked and the current project is the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic SpriteKit animation](img/B04014_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click on **Finish** to continue. Now the folder will be inside the project,
    and we can start adding the code to animate the enemy character. Instead of using
    a static image when the enemy is created, we will change the `addEnemy` function,
    as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s check whether what I said earlier is correct. If we replace the
    enemy variable with the name of the image of the first frame, the game should
    still work. So, in the place where we create an enemy, instead of passing the
    enemy image set, we will pass the first frame of the animation to the `enemyNode`
    variable. Change the line for creating the enemy node to the following in the
    `addEnemy` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This won't animate the character because it is still taking only the first frame
    of the animation and displaying it. But at least, we can be sure that the frame
    is loading properly. You don't have to add the extension when passing the name,
    so `.png` is not required. Neither do you have to say `@2x` to load the image
    for a higher resolution, as SpriteKit will automatically take the absence of `@2x`
    to mean the **1x** resolution, and get the `@2` image file's name for **2x** resolutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s go ahead and load the other frames so that we can animate the enemy.
    After the `addChild(enemyNode)` line, add the following lines of code in the `addEnemy`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: First, we load the sprite sheet in a constant called `textureAtlas` using the
    **texture atlas** class in SpriteKit. Wait! What is a texture atlas? Well, it
    is just another name for a sprite sheet. You can call it either, but they mean
    the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: After loading the sprite sheet, we create an array to store all the textures,
    or the frames of the animation.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have four animation frames to load, namely `enemy_1`, `enemy_2`, `enemy_3`,
    and `enemy_4`, we create a `for` loop and iterate from `1` to `4`. Like any array,
    we append the four files to the `textureArray` variable we created. We assign
    each texture using the `textureNamed` function of the `SkTextureAtlas` class.
    Similar to how we log things on the screen or change text dynamically, we use
    the `\()` operator to provide the names of the four files. Once the images are
    stored in the array, we create an action so that we can run through the frames
    at a certain speed. The `animateWithTextures` function of SKAction takes in an
    array of textures and a duration for which each frame should be displayed on the
    screen. So here, we give the `textureArray` variable storing all the textures,
    and give 0.2 or 200 milliseconds as the time for which each frame will be displayed.
    However, this will run the animation only once. For the animation to run again
    and again, we use the `repeatForever` action. So, we create a new constant called
    `animate` and store the `repeatForever` action in it by passing the animation
    to it. Finally, we run the action on the `enemyNode` variable. Now you can build
    and run to see the enemy character getting animated.
  prefs: []
  type: TYPE_NORMAL
- en: That's all pretty good, but there is an easier way so that we don't have to
    create separate sets of frames for the **1x** and **2x** resolutions for the game.
    Moreover, while creating the array of textures, we need to know beforehand how
    many frames need to be looped through in the animation. In the case of the enemy,
    we know that there are four frames in the animation, so we looped from `1` to
    `4`. What if we are not aware of this information? It may lead to errors or the
    animation looking clunky if we loop less or more than the total number of frames
    of the animation.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, to animate the player, we will be using the Texture Packer way of
    animating.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Texture Packer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Texture Packer is a very popular piece of software that is used by industry
    professionals such as Disney, Zynga, and WG Games to create sprite sheets. You
    can download it from [https://www.codeandweb.com/](https://www.codeandweb.com/).
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring Texture Packer](img/B04014_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is similar to how we created the images earlier when creating enemy animations.
    To create sprite sheet animation using Texture Packer, you also have to create
    the individual frames in Photoshop or Illustrator first. I have already made them
    and have each of the images for the individual frames ready.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the trial version of Texture Packer to follow along the tutorial.
    When downloading, choose the version that is suitable for your operating system.
    Fortunately, Texture Packer is available for all major operating systems, including
    Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you have downloaded Texture Packer, you get three options: you can click
    to try the full version for a week, purchase the license, or click on **Essential
    version** to use a trial version. In the trial version, some professional features
    are disabled, so I recommend trying the professional features for a week.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you click on the option, you should see the interface, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring Texture Packer](img/B04014_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, you can either open an existing project by clicking on the **Open Project**
    button in the bottom-left corner of the screen, or select the framework for which
    you wish to create the sprite sheet.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, Texture Packer supports a wide range of frameworks and formats,
    including Cocos2d, Unity, Corona, Swift, and many more. We need to select **Swift**
    from the list and click on **Create Project**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Texture Packer has three panels; let's start from the left. The left panel will
    display the names of all the images that you have selected to create the sprite
    sheet. Here, you can drag and drop individual images or full folders containing
    your assets. The middle panel is a preview window. It shows you how the images
    are packed. The right panel gives you options to choose where you would like to
    store the packed texture and data file to be published, and what the format of
    the packed image should be. The layout section gives a lot of flexibility to set
    up individual images in the texture packer. Finally, we have different modes for
    optimizing the sprite sheets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some of the key items in the settings panel on the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring Texture Packer](img/B04014_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Under **Data**, we define all of the information regarding the data file to
    be exported. This includes **Data Format**, **Atlas Bundle**, and **Swift Class
    file**. The explanation of each of these fields is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data Format**: As we saw earlier, each exported file creates a sprite sheet
    that has a collection of images and a data file that keeps track of the positions
    on that sprite sheet. The data format usually changes depending on the framework
    or the engine you selected. Since we selected SpriteKit initially and selected
    **Swift** as the language, the format is of type `swift`. Suppose we were using
    the Objective-C language. Then there is a separate option for that as well. So,
    be mindful while selecting the format, otherwise you will have to start over if
    you wish to develop the sprite sheet for another format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Atlas Bundle**: This is the location where you want the exported image and
    data file to be saved. So, you will get a `.png` image file and a `.plist` data
    file containing information about the sprite sheet once the file is published.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Swift Class file**: Along with the image and the data file, Texture Packer
    will also create a helper class containing information that will be imported along
    with the image and data file to make the animation code even simpler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Texture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the **Texture** section, we will specify the sprite sheet image''s file
    details. This includes details regarding **Texture Format**, **Png Opt Level**,
    and **Pixel format**. The explanation of these fields is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Texture Format**: The default is set to `.png`, but other formats are also
    supported. Apart from PNG, you can also use the PVR format. This format is used
    for data protections because it is easier to copy data from regular PNG files.
    Also, PVR formats provide superior image compression. However, be aware that it
    can be used only on Apple devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Png Opt Level**: This is used to set the quality of the PNG file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pixel format**: This sets the RGB format to be used. Usually, you would want
    this to be set at the default value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we specify the layout of the sprite sheet image. The following fields
    can be seen in the **Layout** section:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Max Size**: You can specify the maximum width and height of the sprite sheet,
    depending on the framework. Usually, all frameworks allow up to 4092 x 4092, but
    this mostly depends on the framework, so check the maximum size the framework
    allows before creating the sprite sheet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Size constraints**: Some frameworks prefer the sprite sheets to be in the
    POT format (or the powers of 2), that is, 32 x 32, 64 x 64, 256 x 256, and so
    on. If this is the case, then you need to select accordingly. Otherwise, you can
    choose **Anysize**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scaling variants**: This is used for scaling up or scaling down the image.
    If you are going to be creating images for different resolutions, such as **1x**,
    **2x** and **3x**, then this option allows you to create resources, depending
    on the different resolutions you are developing the game for. Moreover, there
    will be no need to go into the graphics software, shrink the images, and pack
    them again for all the resolutions individually.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Algorithm**: This is the code logic that will be used to create sprite sheets,
    and it will make sure that the images are packed in the most efficient manner.
    In the Basic version, you will have to use **Basic** from the drop-down menu,
    unlike the Pro version, where you can choose **MaxRects**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multipack**: If the PNG image file exceeds the maximum size, then Texture
    Packer will automatically create an additional sprite sheet and data files for
    the images that it wasn''t able to incorporate into the previous sprite sheet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sprites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we specify any special treatment for individual sprites in the sprite
    sheet. There is one field in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Trim mode**: Removes the extra alpha surrounding each image making the sprite
    sheet more compact and thereby deceasing file size even further.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the hero spritesheet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a folder called `heroAnim` in the `Resources` folder for this chapter.
    This folder contains another folder, which contains the individual frames for
    the hero's idle animations. Drag and drop the `heroAnim` folder into the left
    panel of Texture Packer.
  prefs: []
  type: TYPE_NORMAL
- en: You will see the folder structure of the `heroAnim` folder here. Under it, you
    will see the `idle` folder where you will see the individual files for the frames.
    In the preview pane, you will see the preview of the sprite sheet that will be
    created from the images provided.
  prefs: []
  type: TYPE_NORMAL
- en: In the **Layout** section, click on the **Scaling variants** button. From the
    drop-down list in the pre-sets, select **SpriteKit @2x/@1x**. This will automatically
    create sprite sheets for both **2x** and **1x** resolutions by scaling down the
    image by 50 percent and saving it for the **1x** mode.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the hero spritesheet](img/B04014_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, under the data heading, select the location where you want the sprite
    sheet image and data file to be saved. The files will be saved in the location
    inside a folder with the `.atlasc` extension, and this folder will contain the
    image and data files. Next, select the location for the class file to be saved.
    You can save it to whichever location you want, but make sure that you remember
    where you have saved it because it will be required later.
  prefs: []
  type: TYPE_NORMAL
- en: Also make sure that you save the current file at some location so that if you
    want to make some changes to the file later, you will be able to open it and make
    the changes with ease. One thing to note is that if you change the location of
    the `heroAnim` folder, then the reference will be lost and you will have to reimport
    the image. Keep the images, sprite sheet, class, and Texture Packer file in a
    separate folder so that all of the relevant data for the file is in the same directory.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to create the sprite sheet, click on the **Publish Sprite Sheet** button
    at the top. Now we can animate the hero.
  prefs: []
  type: TYPE_NORMAL
- en: Animating the hero
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To animate the hero in the game, drag the `.atlasc` folder and the Swift class
    file into the project. Then, in the `init` function, add the following code right
    after adding the hero to the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: And that's all! You can build and run the game to see the hero getting animated.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we first create a reference to the Swift class that was created in Texture
    Packer. Next, we create a constant called `heroIdleArray` and assign the array
    for the idle animation that is already created in the `heroAnim.swift` class.
    If this wasn't there, then we would have had to manually create an array and store
    the frames, as we did for the enemy. The next three steps are exactly the same
    as how we created the animation for the enemy. We create an animation constant,
    pass the array and the delay that we want for each frame, then create another
    action to repeat the animation over and over, and finally run the animation of
    the hero.
  prefs: []
  type: TYPE_NORMAL
- en: So, we see that we didn't have to create two sets of images, as Texture Packer
    created them for us, and we didn't have to create an array for the idle animation
    either. This becomes even more important if we later have to create a run, walk,
    jump, or attack animation. We can't be creating an array each time. In fact, in
    other frameworks, that's what needs to be done if we want to create different
    animations. This process is so much easier using Texture Packer for SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the Swift class created by Texture Packer so that you can get
    a better understanding of what is happening and how the array is created. So,
    open the `heroAnim.swift` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: I named the class `heroAnim` while creating the file in Texture Packer, so that
    is why the name of the class is the same as what I named it. Secondly, you will
    notice that the four images that we used to create the sprite sheet are named
    `hero_idle_1`, `hero_idle_2`, `hero_idle_3`, and `hero_idle_4`. So, at the start
    of the class, it automatically creates constants for the four filenames equal
    to the string names.
  prefs: []
  type: TYPE_NORMAL
- en: Then the class creates an `SKTextureAtlas` constant called `textureAtlas`. This
    texture atlas is created from the `heroAnim.atlasc` folder. So, although the name
    is the same as that of the class, this is the sprite sheet file; don't get confused.
  prefs: []
  type: TYPE_NORMAL
- en: After getting the texture atlas, four functions are created to get the four
    images stored in the texture atlas with the constant names defined earlier. Then
    a new function is finally created, which adds the four images into an array and
    returns the array. This function is named similar to how we named the image files
    that were used to create the animation. This makes it convenient to know the name
    of the function to call when assigning the array while creating the animation
    action. Also remember that all of this is done automatically in Texture Packer.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the idle animation, if we have two images for the run cycle and call
    them `heroRun1.png` and `heroRun2.png`, then the function that will return the
    `run` array will be called `heroRun()`. An easy way to remember this would be
    to replace any number with open and closed brackets to get the function name and
    the array of frames.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is also important to note this: while naming your images required for creating
    the frames for animation, make sure you use the same naming convention for all
    the frames, just like the case of naming the frames. For example, while naming
    frames for animation, I usually name the files in the form of `name_action_number`.
    It can also be like `nameActionNumber`, as we named the run animation example,
    but make sure you are consistent.'
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to make sure that the numbering of the files is in the
    order in which you want the animation to be played. This is because when the animation
    is played, frame 1 will be played first, then frame 2, then frame 3, and so on.
    If your image is incorrectly numbered, the animation will be played in that order
    and it might look a little funny when it gets played.
  prefs: []
  type: TYPE_NORMAL
- en: These are the only things that you need to be careful about. If you are consistent
    in naming and numbering your files, then correctly creating animations in Texture
    Packer is a breeze. Texture Packer does most of the dirty work for you and leaves
    no room for error as it mostly automates the process for you.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at how to create particles in a game.
  prefs: []
  type: TYPE_NORMAL
- en: Particle systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **particle system** is a collection of sprites or particles. Each particle
    system has an emitter from where the particles will be created. A particle system
    also determines the behavior of the particles in the system. Hence it can be said
    that a particle is the smallest entity that creates the particle system.
  prefs: []
  type: TYPE_NORMAL
- en: A very easy example of a particle system is Rain. **Rain** is a particle system
    in which each rain drop is a particle and a cloud has a lot of emitters from where
    the droplets, or particles, are created.
  prefs: []
  type: TYPE_NORMAL
- en: We create a particle system instead of creating individual particles because
    with a particle system, we can create different kinds of effects using the same
    particle. For example, we saw Rain, which is a particle system. What if we wanted
    another effect, such as water coming out of the faucet? Here, the particle is
    the same—a water droplet—but a rain droplet behaves differently. When water is
    falling from the faucet, each drop falls with a force and is created with a single
    emitter—the faucet outlet. So, we can change the particle system to have one emitter
    and give the particles an initial downward force. In this way, we will have the
    same particle behaving differently, instead of coding the system from scratch
    again.
  prefs: []
  type: TYPE_NORMAL
- en: In SpriteKit, as in any other framework, each particle is an image that is controlled
    by a particle system that has one or more emitters. An **emitter** controls the
    spawning, movement, and destruction of the particle system.
  prefs: []
  type: TYPE_NORMAL
- en: For rendering the particle system, a **SpriteKit particle file** (`.sks`) is
    created. It can contain a particle system of any size, and allows for rotation
    and scaling of the entire particle system.
  prefs: []
  type: TYPE_NORMAL
- en: Designing particles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SpriteKit has an inbuilt particle designer. This designer has a pretty good
    user interface that can be used to create your own particle systems. SpriteKit
    also includes a number of default particle systems that are already included and
    can be created by selecting the particle system that you want for your game from
    the drop-down menu.
  prefs: []
  type: TYPE_NORMAL
- en: To create a new particle system, go to **File** and select **New File**. You
    can also create a new file by right-clicking on the root folder of your project.
    In the **iOS** panel on the left, select **Resource**, then select **SpriteKit
    Particle File**, and click on **Next**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing particles](img/B04014_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, from the drop-down menu, you can select from the eight default particle
    systems that come included in SpriteKit. You can select from **Bokeh**, **Fire**,
    **Fireflies**, **Magic**, **Rain**, **Smoke**, **Snow**, and **Spark**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing particles](img/B04014_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For this example, I selected **Fire**. Once you have selected the particle system
    of your choice, click on **Next**. We will have to give the particle system a
    filename that we can call it by later when we want to create that effect in the
    game, so I named it `fireParticle`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing particles](img/B04014_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once you're done, you will see a `fireParticle.sks` file created in your project
    and the fire particle burning bright in the editor panel. By default, it is created
    in the center of the screen. Click anywhere in the editor panel and the fire particle
    system will be moved to that location. You can also click and move the mouse around
    to see that the particle system moves along with the mouse arrow.
  prefs: []
  type: TYPE_NORMAL
- en: You will also see that the **Utilities** panel has changed and a whole bunch
    of variables with changeable parameters have appeared. You can change these parameters
    to create your own custom particle system.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go through each of these basic parameters so that you can understand what
    each of these variables do and how, by changing each of the parameters, the behavior
    of the particle system can be changed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing particles](img/B04014_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Name
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we want to refer to the particle system by name in code, we can give a name
    here so that we can refer to it later. Similar to how we gave a name to the `enemyNode`
    to check whether the node passed to the `movingSprite` class was the enemy, and
    then we perform a certain function based on that information.
  prefs: []
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Background** parameter sets the color of the background. Changing it doesn't
    affect the particle. It is purely for the purpose of visibility. If your particles
    are black, you can change the background to white so that you can see clearly
    how the particle looks and behaves.
  prefs: []
  type: TYPE_NORMAL
- en: Particle Texture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Particle Texture** parameter is the texture or image that will be displayed
    for each particle. Currently `spark.png` is used as the texture. You can change
    this to the enemy, bullet, rocket, or hero image if you want to.
  prefs: []
  type: TYPE_NORMAL
- en: Particles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Particles** parameter controls the rate at which particles are emitted
    and the number of particles you want the emitter to emit. To control the rate,
    you can increase or decrease the birth rate parameter. We can decrease the rate
    of emission to decrease the value of the birth rate, or if we want the particles
    to be emitted faster, we can increase it. To cap the number of particles, we change
    the maximum value to the number of particles we want the emitter to emit. If we
    want the emitter to continuously emit particles, we keep the value at 0.
  prefs: []
  type: TYPE_NORMAL
- en: Lifetime
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a particle is created, **Lifetime** decides for how long it stays on the
    screen before getting deleted. Here, every particle stays on the screen for 2.5
    seconds. **Range** is used to bring in some randomness in the particles' behavior.
    Suppose we change this range value to 1\. Then some particles will be on the screen
    for 2.0 seconds while others will be there for 3.0 seconds, before getting deleted.
    So, the random value created is plus or minus half of the range value in addition
    to the initial value.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how **Range** works: it takes the first value then gets a value by
    either adding or subtracting half of the range value from it so that it will look
    as if each particle has a different lifetime, as in life, not all particles behave
    in the same way.'
  prefs: []
  type: TYPE_NORMAL
- en: Position Range
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default position at the beginning is the center of the screen. By looking
    at the **Position Range** keyword in the name of the variable, you might have
    guessed that the value that we are inputting is range value. Here, the `x` value
    is `55.65`, which means that when a particle is being spawned, it spawns anywhere
    between `-27.825` to `+27.825` in the *x* direction from the center. The emission
    point is denoted by a small green dot on the editor view. The `y` value is `5`,
    which means that from the center, the particle will be generated anywhere between
    `-2.5` and `+2.5` in the *y* direction. If you change the `X` and `Y` values to
    `0`, you will see all particles getting emitted from the green dot.
  prefs: []
  type: TYPE_NORMAL
- en: Angle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Angle** parameter determines the angle at which the particles are created.
    Since we want the flames to start moving up in this case, the angle is approximately
    90 degrees. You can change this value to `45` as well, which will make it look
    as if there was some wind acting on the fire. To add some randomness to the initial
    angle, the range is kept at `20`. Otherwise, all particles will be going straight
    up, which will look very unnatural.
  prefs: []
  type: TYPE_NORMAL
- en: Speed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the speed at which the particles will start moving when created. Here,
    they start moving at an average speed of 100\. There is a range of 50, which means
    that some will move at the minimum speed of 75 and others will move at the maximum
    of 125.
  prefs: []
  type: TYPE_NORMAL
- en: Acceleration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can accelerate a particle in the *x* and *y* directions, for example, in
    the case of a jet engine or a comet. To create this effect, you have to change
    the `X` position's range to `5` and increase the `Y` acceleration to around `500`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Acceleration](img/B04014_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Alpha
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This defines the level of opacity or transparency of each particle. If the value
    of **Alpha** is zero, then the particle will be completely transparent, while
    `1` means that it will be completely visible. There is also a **Range** value
    that you can specify. The **Speed** parameter determines the rate at which the
    **Alpha** value of each particle changes per second. So, it starts visible as
    soon as it is created, and over a period of time, it becomes transparent as the
    value of **Alpha** is reduced.
  prefs: []
  type: TYPE_NORMAL
- en: Scale
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to **Alpha**, the **Scale** value ranges from `0` to `1`. At `0`, the
    image is completely invisible; and at `1`, it is at its original size. Thus, at
    `0.5` the object will be half the size; and at `2.0`, it will be double the size
    in both the `x` and `y` directions. Here, the object has a start value of 0.5
    and a range of 0.4\. So, the initial start size of any particle will be between
    `0.3` and `0.7`. Since **Speed** is `-0.5`, it will slowly become smaller over
    a period of time after it has spawned.
  prefs: []
  type: TYPE_NORMAL
- en: Rotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As soon as a particle is created, we can make it rotate by giving it a start
    value and a range to generate random speeds of rotation. We can also increase
    or decrease the speed of rotation over a period of time by changing the **Speed**
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Color Blend
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Color Blend is used to blend one color with another. Here, the initial factor
    is `1` and **Range** is `0`, so we are using the original color that is assigned.
    Since we are not color blending, we have kept the **Speed** value as `0`. We can
    change the speed to `-0.125` to see that the color slowly blends to white, and
    the colors become lighter at the end of the particle's life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Color Ramp
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here, we can specify the color of the particle to be generated. The particle
    texture image is always kept white so that we have the liberty to change the color
    of the object in code whenever we want. So here, even though the texture or image
    color is white, the color of the flame is orange.
  prefs: []
  type: TYPE_NORMAL
- en: We can also assign different colors to the particle at different stages of its
    life.
  prefs: []
  type: TYPE_NORMAL
- en: '![Color Ramp](img/B04014_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The other four variables—**Blend Mode**, **Field Mask**, **Custom Shader**,
    and **Custom Shader Uniform**—pertain to shaders and shader programming, which
    is beyond the scope of this book. Using shaders, you can create custom effects
    and behavior for the particles.
  prefs: []
  type: TYPE_NORMAL
- en: You can play around with **Blend Mode** a little if you know how it works, as
    it is very similar to what you see in Photoshop. If you know Photoshop, you will
    be familiar with **Add**, **Subtract**, **Multiply**, **Screen**, **Replace**,
    and **Alpha**. You can select each of these and see the effect it has on the particle
    system.
  prefs: []
  type: TYPE_NORMAL
- en: That is all of the information required for now for designing our own particle
    system for the game. Let's now create the particle system that we will be using
    in the game.
  prefs: []
  type: TYPE_NORMAL
- en: Creating particle effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the game, we will be creating a very simple explosion particle system, and
    it will be shown every time the hero fires a rocket. We will be using our own
    custom sprite for the image. So, go to the resources folder for the chapter and
    drag and drop the `smoke.png` image into the project. Don't forget to add it as
    a copy, and make sure that the current game is the target.
  prefs: []
  type: TYPE_NORMAL
- en: Now create a new particle system, name the file `explosionParticle`, and save
    it to your project. You can use fire, smoke, or any of the default particle systems.
    It doesn't matter, as we will be changing the values to our specification anyway.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating particle effects](img/B04014_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you can see the parameters of the particle system
    I created using the default particle as a base.
  prefs: []
  type: TYPE_NORMAL
- en: I named it `explosionParticle` just in case I have to refer to the particle
    system in code. Then I kept the background as default, as I was still able to
    see the particle quite clearly.
  prefs: []
  type: TYPE_NORMAL
- en: I changed the texture to the smoke image file that was imported earlier, and
    replaced the default image with it. For **Birthrate**, I kept the value at approximately
    `65`; you can change it as per your needs. I kept the maximum number of particles
    at `12` so that after creating 12 particles, the emitter will stop creating any
    new particles.
  prefs: []
  type: TYPE_NORMAL
- en: The **Lifetime** parameter is kept at around `8` and **Range** at around `16`.
    You might say that some particles might be destroyed as soon as they are created.
    Well, that is true and it is also true about smoke particles in general. There
    are some particles in smoke that we don't even get to see when a gun is fired,
    so the behavior will be realistic even though it looks cartoony.
  prefs: []
  type: TYPE_NORMAL
- en: The **Position Range** parameter is approximately `4` along the `x` direction
    and `9` along the `y` direction. This is just to create the particle at a random
    position around the initial position specified so that all particles don't look
    as if they were emerging from the same point.
  prefs: []
  type: TYPE_NORMAL
- en: The **Angle** parameter is kept between `0` and `360`, as we want the smoke
    particles to move in all directions around the point at which they were created.
  prefs: []
  type: TYPE_NORMAL
- en: The **Speed** parameter of each particle at the start is kept at approximately
    `48`, and the **Range** is about `90`. This will make some particles move slower
    and others a lot faster. In fact, some particles may not move at all or move very
    slowly, making the behavior more realistic once again.
  prefs: []
  type: TYPE_NORMAL
- en: The **Acceleration** parameter is kept at `0` for both the **X** and **Y** directions,
    as it is not required, but you can tinker with these values to see whether you
    like the effect.
  prefs: []
  type: TYPE_NORMAL
- en: As we want the smoke particle to fade slowly, we assign an initial value and
    range, and reduce the value of the alpha by slowly reducing its value by increasing
    the **Speed** parameter to `-1`. Since the size of the image is huge, I scaled
    it to `0.25` to make it smaller and gave it a range so that the size is randomized.
    I changed the speed value to `-0.125` so that the size of each particle slowly
    reduces over a period of time.
  prefs: []
  type: TYPE_NORMAL
- en: The particle needs to rotate as soon as it is created, so I gave it an initial
    value and **Range**. I increased the **Speed** parameter so that the particle
    rotates faster over a period of time.
  prefs: []
  type: TYPE_NORMAL
- en: As I am not color blending, I kept the factor at `1` and the range and speed
    at `0`. I changed the color of the particle to a shade of light blue to make it
    look cartoony. Black would have been a little too dark and more realistic.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I changed **Blend Mode** to **Alpha** because I didn't want additive
    blend mode. You can make the required changes to your particle file and press
    *command* + *S* to save the file.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a particle system to the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The file particle system is now ready to be called in to the game. So, open
    the `GameplayScene.swift` file and, in the `addRocket` function, add the following
    code right after where we added the rocket to the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a new constant called `explosionParticle` of the `SKEmitterNode`
    type, and pass the filename for the particle system we created earlier. Whenever
    you want to create a particle system, you will have to use `SKEmitterNode`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we place the particle system at the nozzle of the hero's bazooka. This
    is similar to how we placed the hero's rockets. Finally, we add the particle to
    the scene.
  prefs: []
  type: TYPE_NORMAL
- en: We don't have to worry about removing each particle, as the particle system
    will take care of that automatically. As each particle reaches the end of its
    lifetime, it is automatically removed from the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can build and run the game now, but you will see that the particle system
    takes a bit of time to create the particles. To make it look as if it is getting
    created instantaneously, we will add the following highlighted code after adding
    the particle to the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This line will fast forward the simulation to 0.25 seconds after creating the
    particle so that it looks as if the particles are getting created instantaneously.
    Build and run the game again to see the particles in action.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a particle system to the game](img/B04014_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are some additional parameters and properties present in the particle
    designer, such as `advanceSimuationTime`, that can be called and modified only
    in code. But it is better to design the majority of the particle through the designer
    and fine-tune it in code later when it is added to the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you want, you can create the particle system using code and define
    the parameters individually through the code, as shown in the following snippet,
    which will give the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: These are literally the same variables and parameters. The only difference is
    that here, it is in code format. Obviously, creating the particles using the designer
    is more convenient.
  prefs: []
  type: TYPE_NORMAL
- en: There are additional commands that can be used on the particle system that are
    available for your convenience at Apple's developer portal. You might want to
    go through it and experiment if you are interested.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to use actions and sprite sheets to create animation
    in the game. We looked at SpriteKit's inbuilt sprite sheet generator, and we used
    a professional tool called Texture Packer to create a sprite sheet. We also saw
    how easy it is to generate sprite sheets and animations using this professional
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to that, we saw an introduction to SpriteKit's particle designer,
    and created and implemented a particle system in the game.
  prefs: []
  type: TYPE_NORMAL
- en: There is still something missing in the game, however, and that is sound and
    font customization. We will be looking at this in the next chapter, which includes
    how to add the final touches to the game.
  prefs: []
  type: TYPE_NORMAL
