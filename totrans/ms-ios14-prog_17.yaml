- en: '*Chapter 17*: Using Augmented Reality'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第17章*: 使用增强现实'
- en: One of the major features that Apple shipped as part of iOS 11 was **ARKit**.
    ARKit enables developers to create amazing **Augmented Reality** (**AR**) experiences
    with only a minimal amount of code. Apple has continuously worked on improving
    ARKit, resulting in the release of ARKit 2 at WWDC 2018, ARKit 3 at WWDC 2019,
    and ARKit 4 at WWDC 2020\.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果在 iOS 11 中发布的一个主要功能是**ARKit**。ARKit 允许开发者仅用少量代码就创建惊人的**增强现实（AR**）体验。苹果一直在努力改进
    ARKit，在 2018 年的 WWDC 上发布了 ARKit 2，在 2019 年的 WWDC 上发布了 ARKit 3，在 2020 年的 WWDC 上发布了
    ARKit 4。
- en: In this chapter, you will learn what ARKit is, how it works, what you can do
    with it, and how you can implement an AR art gallery that uses several ARKit features,
    such as image tracking. We will also learn about some basic concepts from SpriteKit
    and SceneKit.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习什么是 ARKit，它是如何工作的，你可以用它做什么，以及如何实现一个使用多个 ARKit 功能（如图像跟踪）的 AR 艺术画廊。我们还将了解一些来自
    SpriteKit 和 SceneKit 的基本概念。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Understanding ARKit
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 ARKit
- en: Using ARKit Quick Look
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ARKit 快速查看
- en: Exploring SpriteKit
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 SpriteKit
- en: Exploring SceneKit
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 SceneKit
- en: Implementing an AR gallery
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现AR画廊
- en: By the end of this chapter, you will be able to integrate ARKit into your apps
    and implement your own ARKit experiences.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够将 ARKit 集成到你的应用程序中，并实现你自己的 ARKit 体验。
- en: Understanding ARKit
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 ARKit
- en: In this section, we will learn about **Augmented Reality (AR)** and ARKit. Augmented
    Reality (AR) is a topic that has captured the interest of app developers and designers
    for a long time now. Implementing an excellent AR experience had not been easy
    though, and many applications haven't lived up to the hype. Small details such
    as lighting and detecting walls, floors, and other objects have always been extremely
    complicated to implement and getting these details wrong has a negative impact
    on the quality of an AR experience.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解**增强现实（AR**）和 ARKit。增强现实（AR）是一个长期以来一直吸引着应用程序开发者和设计师兴趣的话题。尽管实现出色的 AR
    体验并不容易，但许多应用程序并没有达到预期的炒作。像照明和检测墙壁、地板和其他对象这样的小细节一直都非常复杂，而这些细节的错误会对 AR 体验的质量产生负面影响。
- en: 'Augmented reality apps usually have at least some of the following features:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 增强现实应用程序通常至少具有以下一些功能：
- en: They show a camera view.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们显示了一个相机视图。
- en: Content is shown as an overlay in the camera view.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容在相机视图中以叠加的形式显示。
- en: Content responds appropriately to the device's movement.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容能够适当地响应设备的移动。
- en: Content is attached to a specific location in the world.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容附着在世界的特定位置。
- en: Even though this list of features is simple, they aren't all trivial to implement.
    An AR experience relies heavily on reading the motion sensors from the device,
    as well as using image analysis to determine exactly how a user is moving and
    to learn what a 3D map of the world should look like.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个功能列表很简单，但它们并不都是容易实现的。AR体验在很大程度上依赖于读取设备的运动传感器，以及使用图像分析来确定用户的确切移动方式，并了解世界3D地图应该是什么样子。
- en: ARKit is Apple's way of giving developers the power to create great AR experiences.
    ARKit takes care of all the motion and image analysis to make sure you can focus
    on designing and implementing great content rather than getting slowed down by
    the intricate details involved in building an AR app.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ARKit 是苹果提供给开发者创建出色 AR 体验的力量的方式。ARKit 负责所有的运动和图像分析，以确保你可以专注于设计和实现优秀的内容，而不是被构建
    AR 应用程序所涉及的复杂细节所拖慢。
- en: Unfortunately, ARKit comes with a hefty hardware requirement for the devices
    that can run ARKit apps. Only devices with Apple's A9 chip or newer can run ARKit.
    This means that any device older than the iPhone 6s or the first iPad Pro cannot
    run ARKit apps.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，ARKit 对运行 ARKit 应用程序的设备有较高的硬件要求。只有配备苹果 A9 芯片或更新的设备才能运行 ARKit。这意味着任何比 iPhone
    6s 或第一代 iPad Pro 更旧的设备都无法运行 ARKit 应用程序。
- en: In the following sections, we will start by understanding how ARKit renders
    content on the device and how it tracks the physical environment around it in
    order to deliver the best AR experience.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将首先了解 ARKit 如何在设备上渲染内容，以及它是如何跟踪周围的物理环境，以提供最佳的 AR 体验。
- en: Understanding how ARKit renders content
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 ARKit 如何渲染内容
- en: 'ARKit itself only takes care of the massive calculations related to keeping
    track of the physical world the user is in. To render content in an ARKit app,
    you must use one of the following three rendering tools:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ARKit 本身只负责与跟踪用户所处的物理世界相关的庞大计算。要在 ARKit 应用中渲染内容，您必须使用以下三种渲染工具之一：
- en: SpriteKit
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SpriteKit
- en: SceneKit
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SceneKit
- en: Metal
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Metal
- en: Later in this chapter, you will have a quick look at SpriteKit and SceneKit,
    and you will ultimately implement your AR gallery using SceneKit. If you already
    have experience with any of the available rendering techniques, you should feel
    right at home when using ARKit.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，您将快速了解 SpriteKit 和 SceneKit，并最终使用 SceneKit 来实现您的 AR 画廊。如果您已经熟悉任何可用的渲染技术，那么在使用
    ARKit 时应该会感到非常自在。
- en: Implementing ARKit in your app is not limited to manually rendering the contents
    you want to show in AR. In iOS 12, Apple has added a feature called **ARKit Quick
    Look**. You can implement a special view controller in your app that takes care
    of placing a 3D model you supply in a scene. This is ideal if you're implementing
    a feature that allows users to preview products or other objects in the real world.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用中实现 ARKit 不仅限于手动渲染您想在 AR 中显示的内容。在 iOS 12 中，苹果增加了一个名为 **ARKit Quick Look**
    的功能。您可以在您的应用中实现一个特殊的视图控制器，负责放置您提供的 3D 模型。如果您正在实现允许用户在现实世界中预览产品或其他对象的特性，这将非常理想。
- en: Understanding how ARKit tracks the physical environment
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 ARKit 如何跟踪物理环境
- en: 'To understand how ARKit renders content, it''s essential that you understand
    how ARKit makes sense of the physical environment a user is in. When you implement
    an AR experience, you use an ARKit session. An ARKit session is represented by
    an instance of `ARSession`. Every `ARSession` uses an instance of `ARSessionConfiguration`
    to describe the tracking that it should do in the environment. The following diagram
    depicts the relationship between all objects involved in an ARKit session:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解 ARKit 如何渲染内容，您必须了解 ARKit 如何理解用户所处的物理环境。当您实现一个 AR 体验时，您使用一个 ARKit 会话。ARKit
    会话由 `ARSession` 的一个实例表示。每个 `ARSession` 都使用 `ARSessionConfiguration` 的一个实例来描述它在环境中应执行的跟踪。以下图表展示了在
    ARKit 会话中涉及的所有对象之间的关系：
- en: '![Figure 17.1 – ARKit session components'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 17.1 – ARKit 会话组件'
- en: '](img/Figure_17.01_B14717.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_17.01_B14717.jpg]'
- en: Figure 17.1 – ARKit session components
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.1 – ARKit 会话组件
- en: The preceding diagram shows how the session configuration is passed to the session.
    The session is then passed to a view that is responsible for rendering the scene.
    If you use SpriteKit to render the scene, the view is an instance of `ARSKView`.
    When you use SceneKit, this would be an instance of `ARSCNView`. Both the view
    and session have a delegate that will be informed about certain events that can
    occur during an ARKit session. You will learn more about these delegates later
    when you implement your AR gallery.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表显示了会话配置如何传递给会话。然后，会话被传递给一个负责渲染场景的视图。如果您使用 SpriteKit 来渲染场景，该视图是一个 `ARSKView`
    的实例。当您使用 SceneKit 时，这将是一个 `ARSCNView` 的实例。视图和会话都有一个代理，它将在 ARKit 会话期间通知某些事件。您将在实现您的
    AR 画廊时了解更多关于这些代理的信息。
- en: There are several different tracking options that you can configure on a session.
    One of the most basic tracking configurations is `AROrientationTrackingConfiguration`.
    This configuration only tracks the device's orientation, so not the user's movement
    in the environment. This kind of tracking monitors the device using three degrees
    of freedom. To be more specific, this tracking tracks the device's *x*, *y*, and
    *z* orientation. This kind of tracking is perfect if you're implementing something
    such as a 3D video where the user's movements can be ignored.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在会话上，您可以配置几种不同的跟踪选项。最基本的跟踪配置之一是 `AROrientationTrackingConfiguration`。此配置仅跟踪设备的方向，而不是用户在环境中的移动。这种跟踪使用三个自由度来监控设备。更具体地说，这种跟踪跟踪设备的
    *x*、*y* 和 *z* 方向。如果您的实现中可以忽略用户的移动，例如 3D 视频，这种跟踪方式非常合适。
- en: A more complex tracking configuration is `ARWorldTrackingConfiguration`, also
    known as **world tracking**. This type of configuration tracks the user's movements
    as well as the device's orientation. This means that a user can walk around an
    AR object to see it from all different sides. World tracking uses the device's
    motion sensors to determine the user's movements and the device's orientation.
    This is very accurate for short and small movements, but not accurate enough to
    track movements over long periods of time and distances. To make sure the AR experience
    remains as precise as possible, world tracking also performs some advanced computer
    vision tasks to analyze the camera feed to determine the user's location in an
    environment.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的跟踪配置是`ARWorldTrackingConfiguration`，也称为**世界跟踪**。此类配置跟踪用户的移动以及设备的方向。这意味着用户可以绕着AR对象走动，从不同的侧面观察它。世界跟踪使用设备的运动传感器来确定用户的移动和设备的方向。这对于短距离和小范围的移动非常准确，但不足以跟踪长时间和距离的移动。为了确保AR体验尽可能精确，世界跟踪还会执行一些高级计算机视觉任务，以分析摄像头流来确定用户在环境中的位置。
- en: In addition to tracking the user's movements, world tracking also uses computer
    vision to make sense of the environment that the AR session exists in. By detecting
    certain points of interest in the camera feed, world tracking can compare and
    analyze the position of these points in relation to the user's motion to determine
    the distances and sizes of objects. This technique also allows world tracking
    to detect walls and floors, for instance.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了跟踪用户的移动外，世界跟踪还使用计算机视觉来理解AR会话存在的环境。通过检测摄像头流中的某些兴趣点，世界跟踪可以比较和分析这些点相对于用户运动的位置，以确定对象的距离和大小。这种技术还允许世界跟踪检测墙壁和地板等。
- en: The world tracking configuration stores everything it learns about the environment
    in an `ARWorldMap`. This map contains all `ARAnchor` instances that represent
    different objects and points of interest that exist in the session.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 世界跟踪配置将学习到的关于环境的所有信息存储在`ARWorldMap`中。此地图包含所有代表会话中存在的不同对象和兴趣点的`ARAnchor`实例。
- en: There are several other special tracking types that you can use in your app.
    For instance, you can use `ARFaceTrackingConfiguration` on devices with a **TrueDepth**
    camera to track a user's face. This kind of tracking is perfect if you want to
    recreate Apple's Animoji feature that was added to the iPhone X and newer in iOS
    12\.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在应用程序中使用几种其他特殊跟踪类型。例如，您可以在具有**TrueDepth**摄像头的设备上使用`ARFaceTrackingConfiguration`来跟踪用户的脸部。如果您想在iOS
    12中添加到iPhone X及其后续版本中的Apple Animoji功能，这种跟踪方式非常完美。
- en: You can also configure your session so it automatically detects certain objects
    or images in a scene. To implement this, you can use `ARObjectScanningConfiguration`
    to scan for specific items or `ARImageTrackingConfiguration` to identify still
    images.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以配置会话，使其自动检测场景中的某些对象或图像。为此，您可以使用`ARObjectScanningConfiguration`来扫描特定项目，或使用`ARImageTrackingConfiguration`来识别静态图像。
- en: In this section, you have learned the basics of AR and ARKit, how ARKit renders
    content on the device, and how it tracks the physical environment around it. Before
    you get your hands dirty with implementing an ARKit session, let's explore the
    new **ARKit Quick Look** feature to see how simple it is for you to allow users
    of your app to preview items in AR.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您已经学习了AR和ARKit的基础知识，包括ARKit如何在设备上渲染内容，以及它是如何跟踪周围物理环境的。在您开始实现ARKit会话之前，让我们探索新的**ARKit快速预览**功能，看看它对您允许您的应用程序用户在AR中预览项目有多简单。
- en: Using ARKit Quick Look
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ARKit快速预览
- en: In this section, we will learn about ARKit Quick Look, a feature from Apple
    that allows users to preview virtual 3D or AR models with the camera of their
    device.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解ARKit快速预览功能，这是苹果公司的一项功能，允许用户使用设备的摄像头预览虚拟3D或AR模型。
- en: One of the great benefits that AR brings to end users is that it is now possible
    to preview certain objects in the real world. For instance, when you buy a new
    sofa, you might want to see what it looks like in the real world. Of course, it
    was possible to implement features such as this in iOS 11 using ARKit, and many
    developers have, but it wasn't as easy as it could be.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: AR为最终用户带来的一个巨大好处是，现在可以在现实世界中预览某些对象。例如，当您购买新的沙发时，您可能想看看它在现实世界中的样子。当然，在iOS 11中使用ARKit实现此类功能是可能的，许多开发者已经做到了，但这并不像可能的那样简单。
- en: iOS users can preview content using a feature called **Quick Look**. Quick Look
    can be used to preview certain types of content without having to launch any specific
    applications. This is convenient for users because they can quickly determine
    whether a particular document is the document they are looking for by previewing
    it in Quick Look.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 用户可以使用名为 **Quick Look** 的功能预览内容。Quick Look 可以用于预览某些类型的内容，而无需启动任何特定应用程序。这对用户来说很方便，因为他们可以通过在
    Quick Look 中预览来确定某个特定文档是否是他们正在寻找的文档。
- en: In iOS 12, Apple added the **USDZ** file format to the content types that can
    be previewed using Quick Look. Apple's USDZ format is a 3D file format based on
    Pixar's USD format that is used to represent 3D objects. Using Quick Look for
    3D models is not just available in apps; ARKit Quick Look can also be integrated
    on the web. Developers can use a special HTML tag on their web pages to link to
    a USDZ and Safari will display the model in an ARKit Quick Look view controller.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 12 中，苹果将 **USDZ** 文件格式添加到可以使用 Quick Look 预览的内容类型中。苹果的 USDZ 格式是基于皮克斯的 USD
    格式的一种 3D 文件格式，用于表示 3D 对象。使用 Quick Look 预览 3D 模型不仅限于应用中；ARKit Quick Look 还可以集成到网页上。开发者可以在他们的网页上使用特殊的
    HTML 标签来链接 USDZ，Safari 将在 ARKit 快速查看视图控制器中显示模型。
- en: Before you implement your AR gallery, it's a good idea to get a feel for how
    AR works on iOS by implementing the ARKit Quick Look view controller to show one
    of the models that Apple provides at [https://developer.apple.com/arkit/gallery/](https://developer.apple.com/arkit/gallery/).
    To download a model you like, all you need to do is navigate to this page on your
    Mac and click on an image. The USDZ file should start downloading automatically.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现你的 AR 画廊之前，了解 iOS 上 AR 的工作方式是一个好主意，可以通过实现 ARKit 快速查看视图控制器来展示苹果在 [https://developer.apple.com/arkit/gallery/](https://developer.apple.com/arkit/gallery/)
    提供的其中一个模型。要下载你喜欢的模型，你只需要在你的 Mac 上导航到这个页面并点击一个图像。USDZ 文件应该会自动开始下载。
- en: TIP
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Navigate to the ARKit gallery on a device that supports ARKit and tap on one
    of the models to see what ARKit Quick Look in Safari looks like.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到支持 ARKit 的设备的 ARKit 画廊，并点击其中一个模型，以查看 Safari 中的 ARKit 快速查看看起来是什么样子。
- en: In this section, we explained what Quick Look is. Now let's use it inside our
    own app in the next section.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们解释了什么是快速查看。现在让我们在下一节中将其用于我们自己的应用中。
- en: Implementing the ARKit Quick Look view controller
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 ARKit 快速查看视图控制器
- en: After obtaining a USDZ file from Apple's gallery, also make sure to capture
    the image that belongs to this file. Taking a screenshot of the model should be
    fine for testing purposes. Make sure to prepare your image in the different required
    sizes by scaling your screenshot up to two and three times the size of your screenshot.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从苹果的画廊获取 USDZ 文件后，还确保捕获属于此文件的图像。为了测试目的，对模型进行截图应该是可以的。确保通过将截图放大到两倍和三倍大小来准备不同所需的图像尺寸。
- en: 'Create a new project in Xcode and pick a name for your project. The sample
    project in this book''s code bundle is called `ARQuickLook`. Add your prepared
    image to the `Assets.xcassets` file. Also, drag your USDZ file into Xcode and
    make sure to add it to the app target by checking your app''s checkbox when importing
    the file:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xcode 中创建一个新的项目，并为你的项目选择一个名称。本书代码包中的示例项目名为 `ARQuickLook`。将你的准备好的图像添加到 `Assets.xcassets`
    文件中。此外，将你的 USDZ 文件拖动到 Xcode 中，并确保在导入文件时勾选你的应用复选框，将其添加到应用目标中：
- en: '![Figure 17.2 – Importing the USDZ model'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 17.2 – 导入 USDZ 模型'
- en: '](img/Figure_17.02_B14717.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_17.02_B14717.jpg)'
- en: Figure 17.2 – Importing the USDZ model
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.2 – 导入 USDZ 模型
- en: Next, open the storyboard file and drag an image view to the view controller.
    Add the proper constraints to the image so it's centered in the view controller
    and give it a width and height of `200` points. Make sure to check the **User
    Interaction Enabled** checkbox in **Attributes Inspector** and set your model
    image as the image for the image view.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开故事板文件，将一个图像视图拖动到视图控制器中。为图像添加适当的约束，使其在视图控制器中居中，并设置其宽度和高度为`200`点。确保在**属性检查器**中勾选**用户交互启用**复选框，并将你的模型图像设置为图像视图的图像。
- en: After doing this, open `ViewController.swift`, add `@IBOutlet` for the image
    view, and connect the image in the storyboard to this outlet. If the details regarding
    outlets are a little bit fuzzy right now, refer to the sample project in the code
    bundle for a refresher. The image view in the sample project uses an outlet called
    `guitarImage`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，打开`ViewController.swift`，为图像视图添加`@IBOutlet`，并将故事板中的图像连接到这个出口。如果关于出口的细节现在有点模糊，请参考代码包中的示例项目以刷新记忆。示例项目中的图像视图使用了一个名为`guitarImage`的出口。
- en: The next steps to implement Quick Look for the USDZ model are to add a tap gesture
    recognizer to the image view and then trigger the Quick Look view controller when
    a user taps on the image.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为USDZ模型实现快速查看的下一步是在图像视图上添加一个轻点手势识别器，然后当用户轻点图像时触发快速查看视图控制器。
- en: Quick Look uses delegation to object one or more items that it should preview
    from a data source. It also uses a delegate to obtain the source view from which
    the Quick Look preview should animate. This flow applies to all kinds of files
    that you can preview using Quick Look.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 快速查看使用委托从数据源对象中预览一个或多个项目。它还使用委托来获取快速查看预览应该动画的源视图。这种流程适用于所有可以使用快速查看预览的文件类型。
- en: 'To begin implementing Quick Look, you must import the `QuickLook` framework.
    Add the following `import` statement to the top of `ViewController.swift`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始实现快速查看，你必须导入`QuickLook`框架。将以下`import`语句添加到`ViewController.swift`的顶部：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, set up the tap-gesture recognizer for the image by adding the following
    code to `viewDidLoad()`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过在`viewDidLoad()`中添加以下代码来为图像设置轻点手势识别器：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The next step is to implement `presentQuicklook()`. This method will create
    a Quick Look view controller, set the delegate and data source, and then present
    the Quick Look view controller to the user. Add the following implementation for
    this method to the `ViewController` class:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是实现`presentQuicklook()`。这个方法将创建一个快速查看视图控制器，设置委托和数据源，然后将快速查看视图控制器呈现给用户。将以下实现添加到`ViewController`类中：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This implementation should not contain any surprises for you. `QLPreviewController`
    is a `UIViewController` subclass that is responsible for displaying the content
    it receives from its data source. It is presented in the same way you would present
    any other view controller, by calling `present(_:animated:completion:)`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现应该不会给你带来任何惊喜。`QLPreviewController`是`UIViewController`的子类，负责显示从其数据源接收到的内容。它以与其他视图控制器相同的方式呈现，通过调用`present(_:animated:completion:)`。
- en: 'The final step is to implement the data source and delegates. Add the following
    extensions to `ViewController.swift`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是实现数据源和委托。将以下扩展添加到`ViewController.swift`中：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first extension you added makes `ViewController` conform to `QLPreviewControllerDelegate`.
    When the preview controller is about to present the 3D model, it wants to know
    which view is the source for the transition that is about to happen. It's recommended
    to return the view that acts as a preview for the Quick Look action from this
    method. In this case, the preview is the image of the 3D model.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你添加的第一个扩展使`ViewController`遵守`QLPreviewControllerDelegate`协议。当预览控制器即将展示3D模型时，它想知道即将发生的转换的源视图是哪个。建议从这个方法返回充当快速查看操作的预览视图。在这种情况下，预览是3D模型的图像。
- en: The second extension acts as the Quick Look data source. When you implement
    Quick Look for ARKit, you can only return a single item. So, when the preview
    controller asks for the number of items in the preview, you should always return
    `1`. The second method in the data source provides the item that should be previewed
    in the preview controller. All you need to do here is obtain the file URL for
    the item you wish to preview. In the sample app, the Stratocaster model from Apple's
    gallery is used. If your model has a different name, make sure to use the correct
    filename.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个扩展充当快速查看数据源。当你为ARKit实现快速查看时，你只能返回一个项目。所以，当预览控制器询问预览中的项目数量时，你应该始终返回`1`。数据源中的第二个方法提供了预览控制器中应该预览的项目。你在这里需要做的就是获取你希望预览的项目文件URL。在示例应用中，使用了苹果画廊中的Stratocaster模型。如果你的模型有不同的名称，请确保使用正确的文件名。
- en: After obtaining the URL that points to the image in the app bundle, it should
    be returned to the preview controller as a `QLPreviewItem` instance. Luckily,
    URL instances can be converted to `QLPreviewItem` instances automatically.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取指向应用包中图像的URL后，应将其作为`QLPreviewItem`实例返回给预览控制器。幸运的是，URL实例可以自动转换为`QLPreviewItem`实例。
- en: If you run your app now, you can tap on your image of the 3D model to begin
    previewing it. You can preview the image on its own, or you can choose to preview
    it in AR. If you tap this option, the preview controller will tell you to move
    your device around.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行你的应用，你可以点击3D模型的图像来开始预览它。你可以单独预览图像，或者选择在AR中预览它。如果你点击这个选项，预览控制器会告诉你移动你的设备。
- en: To make a mapping of the world around you, ARKit requires some samples of the
    environment. When you move your device around, make sure to not just tilt it,
    but physically move it. Doing this will help ARKit discover trackable features
    in your surroundings.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将你周围的世界进行映射，ARKit需要一些环境样本。当你移动你的设备时，确保不要只是倾斜它，而是要物理移动它。这样做将帮助ARKit发现你周围可追踪的特征。
- en: 'Once ARKit has enough data about your surroundings, you can place the 3D model
    in the environment, scale it by pinching, rotate it, and move it around in the
    space. Note that the model is placed on a flat surface such as a table or the
    floor automatically rather than awkwardly floating around:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦ARKit收集了你周围足够的数据，你就可以将3D模型放置在环境中，通过捏合来缩放它，旋转它，并在空间中移动它。请注意，模型会自动放置在平坦的表面，如桌子或地板上，而不是尴尬地漂浮在空中：
- en: '![Figure 17.3 – Move the device around the scene'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图17.3 – 在场景周围移动设备'
- en: '](img/Figure_17.03_B14717.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_17.03_B14717.jpg]'
- en: Figure 17.3 – Move the device around the scene
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.3 – 在场景周围移动设备
- en: 'Also note that ARKit applies very realistic lighting to your object. The visual
    data that ARKit gathers about the environment is used to create a lighting map
    that is applied to the 3D model to make it properly blend in with the context
    in which the object was placed:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，ARKit对你的物体应用了非常逼真的光照。ARKit收集的环境视觉数据被用来创建一个光照图，并将其应用于3D模型，使其能够正确地融入物体放置的上下文中：
- en: '![Figure 17.4 – AR model placed in the real world'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图17.4 – 放置在现实世界中的AR模型'
- en: '](img/Figure_17.04_B14717.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_17.04_B14717.jpg]'
- en: Figure 17.4 – AR model placed in the real world
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.4 – 放置在现实世界中的AR模型
- en: While playing around with ARKit like this is a lot of fun, it's even more fun
    to create your own AR experiences. Since ARKit supports several rendering techniques,
    such as SpriteKit and SceneKit, the next two sections will spend a little bit
    of time explaining the very basics of SpriteKit and SceneKit. You won't learn
    how to build complete games or worlds with these frameworks. Instead, you will
    learn just enough to get you started with implementing either rendering engine
    in an ARKit app.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样玩ARKit很有趣，但创建自己的AR体验更有趣。由于ARKit支持多种渲染技术，如SpriteKit和SceneKit，接下来的两个部分将花一点时间解释SpriteKit和SceneKit的基础知识。你不会学习如何使用这些框架构建完整的游戏或世界。相反，你将学习足够的内容，以便在ARKit应用中开始实现任一渲染引擎。
- en: Exploring SpriteKit
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索SpriteKit
- en: In this section, we are going to explore **SpriteKit**. SpriteKit is mostly
    used by developers to build two-dimensional games. SpriteKit has been around for
    quite some time already, and it has helped developers to create many successful
    games over the years. SpriteKit contains a full-blown physics simulation engine,
    and it can render many sprites at a time. A **sprite** represents a graphic in
    a game. A sprite could be an image for the player, but also a coin, an enemy,
    or even the floor that the player walks on. When sprites are mentioned in the
    context of SpriteKit, it is meant to refer to one of the nodes that are visible
    on the screen.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨**SpriteKit**。SpriteKit主要被开发者用来构建二维游戏。SpriteKit已经存在一段时间了，并且它帮助开发者多年来创建了许多成功的游戏。SpriteKit包含一个完整的物理仿真引擎，并且可以同时渲染许多精灵。**精灵**代表游戏中的一个图形。精灵可以是玩家的图像，也可以是硬币、敌人，甚至是玩家行走的地面。当在SpriteKit的上下文中提到精灵时，指的是屏幕上可见的节点之一。
- en: Because SpriteKit has a built-in physics engine, it can detect collisions between
    objects, apply forces to them, and more. This is pretty similar to what UIKit
    Dynamics is capable of.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SpriteKit内置了物理引擎，它可以检测物体之间的碰撞，对它们施加力，等等。这和UIKit Dynamics的功能非常相似。
- en: To render content, SpriteKit uses scenes. These scenes can be considered levels
    or major building parts of a game. In the context of AR, you will find that you
    typically only need a single scene. A SpriteKit scene is responsible for updating
    the position and state of the scene. As a developer, you can hook into the rendering
    of frames through the `update(_:)` method of `SKScene`. This method is called
    every time SpriteKit is about to render a new frame for your game or ARKit scene.
    It is essential that this method's execution time is as short as possible, as
    slow implementation of the `update(_:)` method will cause frames to drop, which
    is considered bad. You should always aim to maintain a steady 60 frames per second.
    This means that the `update(_:)` method should always perform its work in less
    than 1/60th of a second.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了渲染内容，SpriteKit 使用场景。这些场景可以被认为是游戏的水平或主要构建部分。在 AR 的上下文中，你会发现你通常只需要一个场景。SpriteKit
    场景负责更新场景的位置和状态。作为开发者，你可以通过 `SKScene` 的 `update(_:)` 方法挂钩到帧的渲染。每当 SpriteKit 即将为你或
    ARKit 场景渲染新帧时，都会调用此方法。确保此方法的执行时间尽可能短是很重要的，因为 `update(_:)` 方法的慢速实现会导致帧率下降，这是被认为不好的。你应该始终努力保持每秒
    60 帧的稳定帧率。这意味着 `update(_:)` 方法应该始终在不到 1/60 秒的时间内完成其工作。
- en: 'To begin exploring SpriteKit, create a new project in Xcode and choose the
    `SpriteKitDefault`, as shown in the following screenshot:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始探索 SpriteKit，请在 Xcode 中创建一个新项目，并选择 `SpriteKitDefault`，如下截图所示：
- en: '![Figure 17.5 – Creating a SpriteKit project'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 17.5 – 创建 SpriteKit 项目]'
- en: '](img/Figure_17.05_B14717.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 17.5 – 创建 SpriteKit 项目](img/Figure_17.05_B14717.jpg)'
- en: Figure 17.5 – Creating a SpriteKit project
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.5 – 创建 SpriteKit 项目
- en: 'When Xcode generates this project for you, you should notice some new files
    that you haven''t seen before:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Xcode 为你生成此项目时，你应该会注意到一些之前没有见过的文件：
- en: '`GameScene.sks`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameScene.sks`'
- en: '`Actions.sks`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Actions.sks`'
- en: These two files are to SpriteKit games what storyboards are to regular apps.
    You can use these to set up all the nodes for your game scene or to set up reusable
    actions that you can attach to your nodes. We will not get into these files now
    as they are pretty specific to game development.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个文件对于 SpriteKit 游戏来说就像故事板对于常规应用一样。你可以使用这些文件来设置游戏场景的所有节点，或者设置可重用的动作，这些动作可以附加到你的节点上。我们现在不会深入这些文件，因为它们非常具体于游戏开发。
- en: If you build and run the sample project that Xcode provides, you can tap the
    screen to make new sprite nodes appear on the screen. Each node performs a little
    animation before it disappears. This isn't very special in itself, but it does
    contain a lot of valuable information. For instance, it shows you how to add something
    to a scene and how to animate it. Let's see exactly how this project is set up
    so you can apply this knowledge if you wish to build an AR experience with SpriteKit
    at some point.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你构建并运行 Xcode 提供的示例项目，你可以轻触屏幕来在屏幕上创建新的精灵节点。每个节点在消失前都会执行一点动画。这本身并不特别，但它包含了很多有价值的信息。例如，它展示了如何向场景中添加内容以及如何对其进行动画处理。让我们看看这个项目是如何设置的，这样你就可以在将来想要使用
    SpriteKit 构建AR体验时应用这些知识。
- en: Creating a SpriteKit scene
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 SpriteKit 场景
- en: SpriteKit games use a special type of view to render their contents. This special
    view is always an instance or subclass of `SKView`. If you want to use SpriteKit
    with ARKit, you should use `ARSKView` instead because that view implements some
    special AR-related behavior, such as rendering the camera feed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit 游戏使用一种特殊的视图来渲染其内容。这个特殊视图始终是 `SKView` 的一个实例或子类。如果你想在 SpriteKit 中使用
    ARKit，你应该使用 `ARSKView`，因为这个视图实现了某些特殊的 AR 相关行为，例如渲染相机视频流。
- en: The view itself usually doesn't do much work regarding managing the games or
    its child views. Instead, the `SKScene` that contains the view is responsible
    for doing this work. This is similar to how you usually work with view controllers
    in other apps.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 视图本身通常不会在管理游戏或其子视图方面做太多工作。相反，包含视图的 `SKScene` 负责执行这项工作。这与其他应用中通常使用视图控制器的方式类似。
- en: 'When you have created a scene, you can tell an `SKView` to present the scene.
    From this moment on, your game is running. In the sample code for the game project
    you created earlier, the following lines take care of loading and presenting the
    scene:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建了一个场景后，你可以告诉 `SKView` 显示这个场景。从这一刻起，你的游戏就开始运行了。在之前创建的游戏项目示例代码中，以下行负责加载和显示场景：
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When you create your scenes, you can choose whether you want to use `.sks` files
    or create scenes programmatically.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建场景时，你可以选择是否想要使用 `.sks` 文件或以编程方式创建场景。
- en: 'When you open the `GameScene.swift` file that Xcode created for you, most of
    the code should be pretty self-explanatory. When the scene is added to a view,
    a couple of `SKNode` instances are created and configured. The most interesting
    lines of code in this file are the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开 Xcode 为你创建的 `GameScene.swift` 文件时，大部分代码应该是相当容易理解的。当场景被添加到视图中时，会创建并配置几个
    `SKNode` 实例。这个文件中最有趣的代码行如下：
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These lines set up an animation sequence for the spinning squares that get added
    when you tap the screen. In SpriteKit, actions are the preferred way to set up
    animations. You can group, chain, and combine actions to achieve pretty complicated
    effects. This is one of the many powerful tools that SpriteKit has to offer.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行设置了当你点击屏幕时添加的旋转方块的动画序列。在 SpriteKit 中，动作是设置动画的首选方式。你可以分组、链式组合动作以实现相当复杂的效果。这是
    SpriteKit 提供的许多强大工具之一。
- en: If you examine the code a little bit more, you'll find that copies of `spinnyNode`
    are created every time the user taps on the screen, moves their finger, or lifts
    their finger. Each interaction produces a slightly different copy of `spinnyNode`,
    so you can determine why `spinnyNode` was added to the scene by looking at its
    appearance.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细检查一下代码，你会发现每次用户在屏幕上点击、移动手指或抬起手指时，都会创建 `spinnyNode` 的副本。每次交互都会产生一个略微不同的
    `spinnyNode` 副本，因此你可以通过观察其外观来确定为什么将 `spinnyNode` 添加到场景中。
- en: Study this code, play around with it, and try to make sure that you grasp what
    it does. You don't have to become a SpriteKit expert by any means, but in this
    section, we have reviewed the basics of it so you can start using it. Let's have
    a look at how SceneKit works to prepare and implement your AR gallery.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 研究这段代码，尝试操作它，并确保你理解它的工作原理。你不必成为 SpriteKit 专家，但在这个部分，我们已经回顾了它的基础知识，以便你可以开始使用它。让我们看看
    SceneKit 是如何准备和实现你的 AR 画廊的。
- en: Exploring SceneKit
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 SceneKit
- en: If you're looking for a game framework that has excellent support for 3D games,
    SceneKit is a great candidate. SceneKit is Apple's framework for creating 3D games,
    and it is structured very similarly to how SpriteKit is set up.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找一个对 3D 游戏有出色支持的游戏框架，SceneKit 是一个很好的选择。SceneKit 是苹果公司用于创建 3D 游戏的框架，其结构设置与
    SpriteKit 非常相似。
- en: Of course, SceneKit is entirely different from SpriteKit because it's used for
    3D games rather than 2D games. Because of this, SceneKit also has very different
    ways of creating views and positioning them onscreen. For instance, when you want
    to create a simple object and place it on the screen, you will see terms such
    as geometry and materials. These terms should be familiar to game programmers,
    but if you're an AR enthusiast, you will probably have to get used to the terminology.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，SceneKit 与 SpriteKit 完全不同，因为它用于 3D 游戏，而不是 2D 游戏。因此，SceneKit 在创建视图和将它们定位在屏幕上的方式上也非常不同。例如，当你想要创建一个简单的对象并将其放置在屏幕上时，你会看到诸如几何和材质之类的术语。这些术语应该对游戏程序员来说很熟悉，但如果你是
    AR 爱好者，你可能需要习惯这些术语。
- en: This section will walk you through setting up a straightforward SceneKit scene
    that closely resembles a part of the AR gallery you will implement later. This
    should provide you with enough information to begin experimenting with SceneKit.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将指导你设置一个简单的 SceneKit 场景，它将非常类似于你稍后将要实现的 AR 画廊的一部分。这应该为你提供足够的信息，以便开始尝试使用 SceneKit。
- en: Creating a basic SceneKit scene
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建基本的 SceneKit 场景
- en: To practice your SceneKit knowledge, create a new project and instead of choosing
    the **Game** template, pick the **Single View Application** template. Of course,
    you are free to explore the default project Xcode creates for you when you choose
    the **Game** template with SceneKit, but it's not terribly useful for the AR gallery.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习你的 SceneKit 知识，创建一个新的项目，而不是选择 **Game** 模板，而是选择 **Single View Application**
    模板。当然，你可以自由探索当你选择带有 SceneKit 的 **Game** 模板时 Xcode 为你创建的默认项目，但这对于 AR 画廊来说并不特别有用。
- en: After creating your project, open the main storyboard and look for a SceneKit
    view. Drag this view into the view controller. You should notice that the view
    you just added to the view controller has replaced the default view entirely.
    Because of this, the `view` property on `ViewController` will not be a regular
    `UIView`; it will be an instance of `SCNView` instead. This is the view that will
    be used to render the SceneKit scene in.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 创建你的项目后，打开主故事板并查找 SceneKit 视图。将此视图拖到视图控制器中。你应该注意到你刚刚添加到视图控制器的视图已经完全替换了默认视图。因此，`ViewController`
    上的 `view` 属性将不是一个普通的 `UIView`；它将是一个 `SCNView` 的实例。这是将用于渲染 SceneKit 场景的视图。
- en: 'Add the following code to `viewDidLoad()` in `ViewController.swift` to cast
    the `view` property from `UIView` to `SCNView`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ViewController.swift` 的 `viewDidLoad()` 中添加以下代码，将 `view` 属性从 `UIView` 转换为
    `SCNView`：
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, remember to add `import SceneKit` to the top so that `SCNView` compiles.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，记得在顶部添加 `import SceneKit`，以便 `SCNView` 能够编译。
- en: 'Similar to how SpriteKit works, SceneKit uses a scene to render its nodes in.
    Create an instance of `SCNScene` right after `guard` in `viewDidLoad()`, as shown:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与 SpriteKit 的工作方式类似，SceneKit 使用场景来渲染其节点。在 `viewDidLoad()` 中的 `guard` 之后立即创建一个
    `SCNScene` 实例，如下所示：
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code creates a simple scene that will be used to render all elements
    in. In addition to creating the scene, several debugging features are enabled
    to monitor the performance of the scene. Also, note that the `allowsCameraControl`
    property on the scene view is set to `true`. This will allow users to move a virtual
    camera around so they can explore the scene by swiping around in it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一个简单的场景，将用于渲染所有元素。除了创建场景外，还启用了几个调试功能来监控场景的性能。此外，请注意，场景视图上的 `allowsCameraControl`
    属性被设置为 `true`。这将允许用户在场景中移动虚拟相机，通过在场景中滑动来探索场景。
- en: Every SceneKit scene is viewed as if you're looking at it through a camera.
    You will need to add this camera to the scene yourself, and you must set it up
    appropriately for your purpose. The fact that SceneKit uses a camera is very convenient
    because the camera that you are going to set up in a second is replaced by the
    actual camera of a device when the scene is run with ARKit.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 每个SceneKit场景都像通过相机看一样。你必须自己添加这个相机，并且必须根据你的目的适当地设置它。SceneKit 使用相机的事实非常方便，因为当你使用
    ARKit 运行场景时，你即将设置的相机将被设备的实际相机所取代。
- en: 'Add the following lines of code to `viewDidLoad()` to create and configure
    the camera:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `viewDidLoad()` 中添加以下代码行以创建和配置相机：
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Setting up a basic camera isn't very complicated. All you need is an `SCNNode`
    to add the camera to and an `SCNCamera` that will be used to view your scene through.
    Note that the camera is positioned using an `SCNVector3` object. All nodes in
    a SceneKit scene use this object to express their positions in 3D space.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 设置基本相机并不复杂。你只需要一个 `SCNNode` 来添加相机，以及一个 `SCNCamera`，它将用于通过它查看你的场景。请注意，相机是通过 `SCNVector3`
    对象定位的。SceneKit 场景中的所有节点都使用此对象来表示它们在三维空间中的位置。
- en: 'In addition to using a simulated camera, SceneKit also simulates real lighting
    conditions. When you run your scene with ARKit, the lighting conditions will be
    automatically managed by ARKit, making your objects look as if they truly are
    part of the environment. When you create a plain scene, however, you will need
    to add the lights yourself. Add the following lines of code to implement some
    ambient lighting:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用模拟相机外，SceneKit 还模拟真实的光照条件。当你使用 ARKit 运行场景时，光照条件将由 ARKit 自动管理，使你的物体看起来就像真正是环境的一部分。然而，当你创建一个普通场景时，你需要自己添加灯光。添加以下代码行以实现一些环境光照：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can add different types of lights to a SceneKit scene. You can use ambient
    light as this sample does, but you can also add directional lights that focus
    on a particular direction, spotlight, or light points that light in all directions.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向 SceneKit 场景添加不同类型的灯光。你可以像这个示例一样使用环境光，但也可以添加定向光，它聚焦于特定方向，聚光灯，或者照亮所有方向的点光源。
- en: Now that you have lighting and a camera in place, you can add an object to the
    scene. You can use several pre-made shapes, also known as geometries, in your
    scene. Alternatively, you could import an entire 3D model in your scene. If you
    take a look at the default SceneKit app that Xcode generates if you create a new
    project with the **Game** template, you can see that it imports a 3D model of
    an airplane.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置了光照和相机，你可以在场景中添加一个对象。你可以在场景中使用几个预制的形状，也称为几何体。或者，你也可以将整个3D模型导入到场景中。如果你查看Xcode生成的默认SceneKit应用，如果你使用**Game**模板创建一个新项目，你可以看到一个飞机的3D模型被导入。
- en: In the AR gallery you will build later, the artwork is augmented with digital
    information signs that are attached to the piece of art they belong to. To practice
    building such a sign, you will add a rectangular shape, or plane, to your SceneKit
    scene and place some text on top of it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在你稍后将要构建的AR画廊中，艺术品将通过附加到它们所属的艺术品上的数字信息标签进行增强。为了练习构建这样的标签，你将在你的SceneKit场景中添加一个矩形形状，或者平面，并在其上方放置一些文本。
- en: 'Add the following code to create a simple white plane, a node that renders
    the plane, and add it to the scene:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码以创建一个简单的白色平面、渲染平面的节点，并将其添加到场景中：
- en: '[PRE10]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you were to build and run your app now, you would see a white square that
    is positioned in front of the camera. By swiping on the scene, you can make the
    camera move around the plane to view it from all possible sides. Note that the
    plane appears to be quite large even though it was only set to be 15 wide and
    10 high. You might have guessed that these numbers represent points on the screen,
    just like in other apps. In SceneKit, there is no concept of points. All values
    for size and distance must be specified in meters. This means that everything
    you do is done relative to other objects or their real-world sizes. Using real
    sizes is essential when you take your SceneKit knowledge to ARKit.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在构建并运行你的应用，你会看到一个位于相机前面的白色方块。通过在场景上滑动，你可以使相机在平面上移动，从所有可能的角度查看它。请注意，尽管只设置了15宽和10高，但平面看起来相当大。你可能已经猜到这些数字代表屏幕上的点，就像在其他应用中一样。在SceneKit中，没有点的概念。所有的大小和距离值都必须以米为单位指定。这意味着你做的所有事情都是相对于其他对象或它们的真实世界大小进行的。当你将SceneKit知识应用到ARKit时，使用真实大小是至关重要的。
- en: 'To add some text to the plane you just created, use the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的新创建的平面上添加一些文本，请使用以下代码：
- en: '[PRE11]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code creates a text geometry. Since all values in SceneKit are
    in meters, the text size will be a lot smaller than you would probably expect.
    To make sure the text is positioned properly in the plane, text wrapping is enabled,
    and a `containerFrame` is used to specify the bounds for the text. Since the origin
    for the text field will be in the center of the plane it is displayed on, the
    *x* and *y* positions are offset negatively from the center to make sure the text
    appears in the correct place. You can try to play around with this frame to see
    what happens. After configuring the text, it is added to a node, and the node
    is added to the plane node.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一个文本几何体。由于SceneKit中的所有值都是以米为单位，文本的大小将比你可能预期的要小得多。为了确保文本在平面上正确定位，启用了文本换行，并使用`containerFrame`来指定文本的边界。由于文本字段的起点将位于显示的平面的中心，因此*x*和*y*位置从中心向负方向偏移，以确保文本出现在正确的位置。你可以尝试调整这个框架来看看会发生什么。配置好文本后，将其添加到一个节点中，然后将该节点添加到平面节点中。
- en: If you run your app now, you can see the **Hello, World!** text rendered on
    the white plane you created before. This sample is an excellent taste of what
    you're going to create next. Let's dive straight into building your AR gallery!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行你的应用，你将能看到在之前创建的白色平面上渲染的**Hello, World!**文本。这个示例很好地展示了你接下来将要创建的内容。让我们直接开始构建你的AR画廊！
- en: Implementing an Augmented Reality gallery
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现增强现实画廊
- en: Creating an excellent AR experience has been made a lot simpler with the great
    features that exist in ARKit. However, there are still several things to keep
    in mind if you want to build an AR experience that users will love.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于ARKit中存在的一些优秀功能，创建一个出色的AR体验已经变得简单得多。然而，如果你想要构建用户会喜欢的AR体验，还有一些事情需要牢记。
- en: Certain conditions, such as lighting, the environment, and even what the user
    is doing, can have an impact on the AR experience. In this section, you will implement
    an AR gallery, and you will discover firsthand how ARKit is both amazingly awesome
    and sometimes a little bit fragile.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 某些条件，如光照、环境，甚至用户正在做什么，都可能影响 AR 体验。在本节中，你将实现一个 AR 画廊，你将亲身体验 ARKit 既是惊人的神奇，有时又有点脆弱。
- en: First, you'll set up a session in ARKit so you can implement image tracking
    to discover certain predefined images in the world, and you'll show some text
    above the found picture. Then, you'll implement another feature that allows users
    to place art from a gallery in the app in their own room.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要在 ARKit 中设置一个会话，以便你可以实现图像跟踪来在世界中找到某些预定义的图像，你将在找到的图片上方显示一些文本。然后，你将实现另一个功能，允许用户将应用中的画廊艺术作品放置在自己的房间里。
- en: If you want to follow along with the steps to implement the ARKit gallery, make
    sure to grab the `ARGallery_start` project from the book's code bundle. Before
    you move on to implementing the AR gallery, explore the starter project for a
    little bit. The user interface that is prepared contains an instance of `ARSCNView`;
    this is the view that will be used to render the AR experience. A collection view
    has been added in preparation for the user adding their own images to the gallery,
    and a view for error messages has been added to inform the user about certain
    things that might be wrong.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想跟随步骤实现 ARKit 画廊，请确保从书籍的代码包中获取 `ARGallery_start` 项目。在您开始实现 AR 画廊之前，先探索一下起始项目。准备好的用户界面包含一个
    `ARSCNView` 实例；这是将用于渲染 AR 体验的视图。为了准备用户添加自己的图像到画廊，已添加了一个集合视图，并添加了一个用于错误信息的视图，以通知用户某些可能出错的事情。
- en: You'll find that the project is quite basic so far. All the existing code does
    is set up the collection view, and some code was added to handle errors during
    the AR session. Let's implement image tracking, shall we?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现到目前为止项目相当基础。现有的所有代码只是设置了集合视图，并添加了一些代码来处理 AR 会话期间的错误。让我们来实现图像跟踪，好吗？
- en: Adding image tracking
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加图像跟踪
- en: When you add image tracking to your ARKit app, it will continuously scan the
    environment for images that match the ones you added to your app. This feature
    is great if you want users to look for specific images in their environment so
    you can provide more information about them or as part of a scavenger hunt. But
    more elaborate implementations might exist as part of a textbook or magazine where
    scanning a particular page would cause the whole page to come alive as part of
    a unique experience.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将图像跟踪添加到你的 ARKit 应用中时，它将不断扫描环境以寻找与你在应用中添加的图像相匹配的图像。如果你想让用户在他们的环境中寻找特定的图像，以便你可以提供更多关于它们的信息，或者作为寻宝游戏的一部分，这个功能非常棒。但更复杂的实现可能存在于教科书或杂志中，扫描特定页面会使整个页面作为独特体验的一部分活跃起来。
- en: Before you can implement the image tracking experience, you must prepare some
    images for your users to find in the app. Once the content is ready, you're ready
    to build the AR experience itself.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在您能够实现图像跟踪体验之前，您必须为您的用户提供一些图像以便在应用中找到。一旦内容准备就绪，您就可以构建 AR 体验本身了。
- en: Preparing images for tracking
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备图像进行跟踪
- en: Adding images to your app that are eligible for image tracking is relatively
    straightforward. The most important part is that you pay close attention to the
    images you add to your app. It's up to you to make sure that the images you add
    are high-quality and well-saturated. ARKit will scan for special features in an
    image to try to match it, so it's important that your image has enough details,
    contrast, and colors. An image of a smooth gradient might look like a recognizable
    image to you, but it could be tough for ARKit to detect.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 将图像添加到您的应用中进行图像跟踪相对简单。最重要的是，你需要仔细关注你添加到应用中的图像。确保你添加的图像是高质量的并且色彩饱和。ARKit 将扫描图像中的特殊特征以尝试匹配，因此你的图像需要有足够的细节、对比度和颜色。一个平滑渐变的图像可能在你看来是一个可识别的图像，但对于
    ARKit 来说可能很难检测。
- en: 'To add images to your project, go to the `Assets.xcassets` folder, click the
    **+** icon in the bottom-left corner, and select **New AR Resource Group**, as
    shown in the following screenshot:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像添加到您的项目中，请转到 `Assets.xcassets` 文件夹，点击左下角的 **+** 图标，并选择 **New AR Resource
    Group**，如图下截图所示：
- en: '![Figure 17.6 – Adding an AR resource'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 17.6 – 添加 AR 资源'
- en: '](img/Figure_17.06_B14717.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_17.06_B14717.jpg]'
- en: Figure 17.6 – Adding an AR resource
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 17.6 – 添加 AR 资源
- en: After adding a new resource group, you can drag images into the folder that
    was created. Each resource group will be loaded and monitored by ARKit all at
    once, so make sure you don't add too many images to a single resource group because
    that could negatively impact the performance of your app. Apple recommends you
    add up to about 25 images to a single resource group.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加新的资源组后，你可以将图片拖入创建的文件夹中。ARKit 会一次性加载和监控每个资源组，所以请确保不要将太多图片添加到单个资源组中，因为这可能会对你的应用性能产生负面影响。苹果建议你将大约
    25 张图片添加到单个资源组中。
- en: After you add an image to a resource group, Xcode will analyze the images and
    warn you if it thinks something is wrong with your image. Usually, Xcode will
    inform you as soon as you add a new image because ARKit requires the physical
    size of the image you want to detect to be known. So, if you're going to detect
    a specific painting or a page in a magazine, you must add the dimensions for these
    resources in centimeters as they exist in the real world.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在你将图片添加到资源组后，Xcode 将分析图片，并在它认为你的图片有问题时发出警告。通常，Xcode 会在你添加新图片时立即通知你，因为 ARKit
    需要知道你想要检测的图像的物理尺寸。所以，如果你要检测特定的画作或杂志中的一页，你必须以厘米为单位添加这些资源的尺寸，就像它们在现实世界中存在的那样。
- en: The start project from the code bundle comes with a couple of prepared images
    that you can explore to see some examples of the kinds of images that you could
    use in your own apps.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码包中开始的项目包含了一些准备好的图片，你可以探索这些图片来查看你可以在自己的应用中使用的一些图片类型示例。
- en: Tip
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want to have some content of your own, take photos of artwork or pictures
    that you have around the house or office. You can use the Measure app in iOS to
    measure the physical dimensions of the pictures and add them to your AR gallery
    project. Make sure that your pictures are well-saturated and free of any glare
    or reflections.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要添加一些自己的内容，可以拍摄家中或办公室的艺术品或图片。你可以使用 iOS 中的 Measure 应用来测量图片的物理尺寸，并将它们添加到你的
    AR 相册项目中。确保你的图片色彩饱和，没有任何眩光或反射。
- en: Once you have found and added some excellent content to use in your AR gallery,
    it's time to build the experience itself.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你找到了一些优秀的内容用于你的 AR 相册，就到了构建体验本身的时候了。
- en: Building the image tracking experience
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建图像跟踪体验
- en: To implement image tracking, you will set up an `ARSession` that uses `ARWorldTrackingConfiguration`
    to detect images and track a user's movement through the environment. When one
    of the images you have prepared is discovered in the scene, an `SCNPlane` will
    be added above the picture with a short description of the picture itself.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现图像跟踪，你需要设置一个使用 `ARWorldTrackingConfiguration` 的 `ARSession` 来检测图像并跟踪用户在环境中的移动。当场景中发现你准备好的其中一个图像时，会在图片上方添加一个
    `SCNPlane`，并附上对图片本身的简短描述。
- en: Because ARKit uses the camera, your app must explicitly provide a reason for
    accessing the camera, so the user understands why your app needs permission to
    use their camera. Add the `NSCameraUsageDescription` key to the `Info.plist` file
    and add a short bit of text about why the gallery needs access to the camera.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 ARKit 使用摄像头，所以你的应用必须明确提供访问摄像头的原因，以便用户理解为什么你的应用需要使用他们的摄像头权限。将 `NSCameraUsageDescription`
    键添加到 `Info.plist` 文件中，并添加一段简短的文字说明为什么相册需要访问摄像头。
- en: If you open `ViewController.swift`, you will find a property called `artDescriptions`.
    Make sure to update this dictionary with the names of the images you added to
    the resource group and add a short description for each image.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开 `ViewController.swift`，你会找到一个名为 `artDescriptions` 的属性。确保更新这个字典，包含你添加到资源组的图片名称，并为每张图片添加一个简短描述。
- en: 'Next, update `viewDidLoad()` so `ViewController` is set as the delegate for
    both `ARSCNView` and `ARSession`. Add the following lines of code to do this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更新 `viewDidLoad()`，以便将 `ViewController` 设置为 `ARSCNView` 和 `ARSession` 的代理。添加以下代码行来完成此操作：
- en: '[PRE12]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The scene delegate and session delegate are very similar. The session delegate
    provides very fine-grained control of the content that is displayed in the scene,
    and you'll usually use this protocol extensively if you build your own rendering.
    Since the AR gallery is rendered using SceneKit, the only reason to adopt `ARSessionDelegate`
    is to respond to changes in the session's tracking state.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 场景代理和会话代理非常相似。会话代理提供了对场景中显示的内容的非常细粒度的控制，如果你自己构建渲染，你通常会广泛使用此协议。由于 AR 相册使用 SceneKit
    渲染，采用 `ARSessionDelegate` 的唯一原因是为了响应会话跟踪状态的变化。
- en: All of the interesting methods that you should adopt are part of `ARSCNViewDelegate`.
    This delegate is used to respond to specific events, for instance, when new features
    are discovered in the scene or when new content has been added.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该采用的所有有趣的方法都是 `ARSCNViewDelegate` 的一部分。这个代理用于响应特定事件，例如，当场景中发现了新功能或添加了新内容时。
- en: 'Currently, your AR gallery doesn''t do much. You must configure the `ARSession`
    that is part of the scene to begin using ARKit. The best moment to set this all
    up is right before the view controller becomes visible. Therefore, you should
    do all of the remaining setup in `viewWillAppear(_:)`. Add the following implementation
    for this method to `ViewController`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你的 AR 画廊并没有做什么。你必须配置场景中的一部分 `ARSession` 来开始使用 ARKit。设置这一切的最佳时机是在视图控制器变得可见之前。因此，你应该在
    `viewWillAppear(_:)` 中完成所有剩余的设置。将以下实现添加到 `ViewController` 中：
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The code is explained as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 代码解释如下：
- en: The first step in this method is to read the reference image from the app bundle.
    These are the images you added to `Assets.xcassets`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个方法的第一步是从应用程序包中读取参考图像。这些是你添加到 `Assets.xcassets` 中的图像。
- en: Next, `ARWorldTrackingConfiguration` is created, and it's configured to track
    both horizontal and vertical planes, as well as the reference images.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建 `ARWorldTrackingConfiguration`，并配置它来跟踪水平和垂直平面，以及参考图像。
- en: Lastly, the configuration is passed to the session's `run(_:options:)` method.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，配置被传递到会话的 `run(_:options:)` 方法中。
- en: If you run your app now, you should already be prompted for camera usage, and
    you should see the error-handling working. Try covering the camera with your hand,
    which should make an error message appear.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行你的应用程序，你应该已经提示了相机使用，你应该看到错误处理正在工作。尝试用手遮住相机，这应该会显示一个错误消息。
- en: 'Keeping an AR session alive if a view isn''t visible anymore is quite wasteful,
    so it''s a good idea to pause the session if the app is closed or if the view
    controller that contains the AR scene becomes invisible. Add the following method
    to `ViewController` to achieve this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个视图不再可见，保持 AR 会话活跃是非常浪费的，所以如果应用程序关闭或包含 AR 场景的视图控制器变得不可见，暂停会话是一个好主意。将以下方法添加到
    `ViewController` 中以实现这一点：
- en: '[PRE14]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the current setup, the AR session detects your images, but it does nothing
    to visualize this. When one of the images you added is identified, `ARSCNViewDelegate`
    is notified of this. To be specific, the `renderer(_:didAdd:for:)` method is called
    on the scene delegate when a new `SCNNode` is added to the view. For instance,
    when the AR session discovers a flat surface, it adds a node for `ARPlaneAnchor`,
    or when it detects one of the images you're tracking, a node for `ARImageAnchor`
    is added. Since this method can be called for different reasons, it's essential
    that you add logic to differentiate between the various reasons that could cause
    a new `SCNNode` to be added to the scene.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前设置中，AR 会话检测你的图像，但没有做任何事情来可视化这一点。当你添加的图像之一被识别时，`ARSCNViewDelegate` 会收到通知。具体来说，当在场景代理上添加一个新的
    `SCNNode` 时，会调用 `renderer(_:didAdd:for:)` 方法。例如，当 AR 会话发现一个平坦的表面时，它会为 `ARPlaneAnchor`
    添加一个节点，或者当它检测到你正在跟踪的图像之一时，会添加一个 `ARImageAnchor` 的节点。由于这个方法可能因不同原因而被调用，因此添加逻辑来区分可能导致在场景中添加新的
    `SCNNode` 的各种原因是非常重要的。
- en: 'Because the AR gallery will implement several other features that could trigger
    the addition of a new node, you should separate the different actions you want
    to take for each different type of anchor into specialized methods. Add the following
    method to `ARSCNViewDelegate` to add the information plane next to a detected
    image:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 AR 画廊将实现其他几个可能触发添加新节点的功能，你应该将针对每种不同类型的锚点想要采取的不同操作分离到专门的方法中。将以下方法添加到 `ARSCNViewDelegate`
    中以在检测到的图像旁边添加信息平面：
- en: '[PRE15]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code should look somewhat familiar to you. First, an instance
    of `SCNPlane` is created. Then, this plane is added to `SCNNode`. This node is
    translated slightly to position it above the detected image. This translation
    uses `SCNVector3` so it can be translated into three dimensions. The node is also
    rotated a little bit to create a nice-looking effect.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码应该对你来说有些熟悉。首先，创建一个 `SCNPlane` 实例。然后，将这个平面添加到 `SCNNode`。这个节点稍微移动以定位在检测到的图像上方。这个平移使用
    `SCNVector3` 以便可以转换到三维。节点也稍微旋转以创建一个看起来不错的效果。
- en: 'Next, add the following implementation for `renderer(_:didAdd:for:)`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为 `renderer(_:didAdd:for:)` 添加以下实现：
- en: '[PRE16]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This method checks whether the anchor that was discovered is an image anchor;
    if it is, `placeImageInfo(withNode:for:)` is called to display the information
    sign.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法检查发现的锚点是否为图像锚点；如果是，则调用 `placeImageInfo(withNode:for:)` 来显示信息标志。
- en: 'Go ahead and run your app now! When you find one of the images that you added
    to your resource group, an information box should appear on top of it, as shown
    in the following screenshot:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行您的应用！当您找到您添加到资源组中的图像之一时，应该会在其上方出现一个信息框，如下面的截图所示：
- en: '![Figure 17.7 – AR box on top of the image'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 17.7 – 图像上方的 AR 盒'
- en: '](img/Figure_17.07_B14717.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.07_B14717.jpg)'
- en: Figure 17.7 – AR box on top of the image
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.7 – 图像上方的 AR 盒
- en: Pretty awesome, right? Let's take it one step further and allow users to position
    some of the pictures from the collection view wherever they want in the scene.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 真的很棒，对吧？让我们更进一步，允许用户将收藏视图中的某些图片放置在场景中的任何位置。
- en: Placing your own content in 3D space
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 3D 空间中放置您自己的内容
- en: To spice up the AR gallery a little bit, it would be great to be able to add
    some new artwork to the environment. Using ARKit, doing this becomes relatively
    simple. There are a couple of gotchas to take into account when implementing a
    feature such as this, but overall, Apple did a great job making ARKit an accessible
    platform to work with for developers.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 AR 画廊更加生动，能够将一些新的艺术品添加到环境中会很好。使用 ARKit，这样做变得相对简单。在实现此类功能时，需要考虑一些注意事项，但总体而言，苹果公司让
    ARKit 成为一个对开发者来说易于使用的平台。
- en: When a user taps on one of the images in the collection view at the bottom of
    the screen, the image they tapped should be added to the environment. If possible,
    the image should be attached to one of the walls surrounding the user. If this
    isn't possible, the image should still be added, except it will float in the middle
    of the space.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在屏幕底部的收藏视图中点击其中一个图像时，他们点击的图像应该被添加到环境中。如果可能，图像应该附着在用户周围的墙壁之一上。如果这不可能，图像仍然会被添加，但会漂浮在空间的中间。
- en: To build this feature, you should implement `collectionView(_:didSelectItemAt:)`
    since this method is called when a user taps on one of the items in a collection
    view. When this method is called, the code should take the current position of
    the user in the environment and then insert a new `ARAnchor` that corresponds
    to the location where the new item should be added.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建此功能，您应该实现 `collectionView(_:didSelectItemAt:)`，因为当用户在收藏视图中点击其中一个项目时，会调用此方法。当此方法被调用时，代码应获取用户在环境中的当前位置，然后插入一个新的
    `ARAnchor`，该锚点对应于新项目应添加的位置。
- en: 'Also, to detect nearby vertical planes, such as walls, some hit testing should
    be done to see whether a vertical plane exists in front of the user. Add the following
    implementation of `collectionView(_:didSelectItemAt:)`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了检测附近的垂直平面，例如墙壁，需要进行一些碰撞测试以查看是否存在垂直平面位于用户前方。添加以下 `collectionView(_:didSelectItemAt:)`
    的实现：
- en: '[PRE17]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Even though there are only four steps in this snippet, a lot is going on. Let''s
    review it:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个片段中只有四个步骤，但发生了很多事情。让我们回顾一下：
- en: First, the camera is grabbed from the current frame in the AR session so it
    can be used later to determine the user's location in the scene.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从 AR 会话的当前帧中获取相机，以便稍后用于确定用户在场景中的位置。
- en: Next, a hit test is performed to see whether any planes were already detected
    in the scene. Since this hit test will return both vertical and horizontal planes,
    the results are filtered to find the very first vertical plane that was found
    in the hit test.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，执行碰撞测试以查看场景中是否已经检测到任何平面。由于此碰撞测试将返回垂直和水平平面，因此结果被过滤以找到碰撞测试中发现的第一个垂直平面。
- en: Since the location of every `ARAnchor` is represented as a transformation from
    the world origin, the third step is to determine the transformation that should
    be applied to position the new artwork in the correct place. The world origin
    is the place where the AR session first became active. After creating a default
    translation, the *z* value for the translation is adjusted, so the object is added
    either in front of the user or against the nearest vertical plane. Next, the current
    position of the user is retrieved through the camera. The rotation for the camera
    will have to be adjusted in the next steps because the camera does not follow
    the device's orientation. This means that the camera will always assume that the
    *x* axis runs across the length of the device, starting at the top and moving
    downward toward the home indicator area. A computed property to determine how
    the rotation should be adjusted is already added to the AR gallery starter project.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于每个`ARAnchor`的位置都表示为从世界原点开始的变换，因此第三步是确定应用于将新艺术品放置在正确位置的变换。世界原点是AR会话首次变得活跃的地方。在创建默认平移后，调整平移的*z*值，以便对象被添加到用户前面或最近的垂直平面上。接下来，通过摄像头检索用户的当前位置。在下一步中，需要调整摄像头的旋转，因为摄像头不跟随设备的方向。这意味着摄像头将始终假设*x*轴沿着设备的长度运行，从顶部开始向下移动到主指示器区域。一个计算属性已经添加到AR画廊入门项目中，以确定如何调整旋转。
- en: After setting up the correct transformation properties for the anchor, an instance
    of `ARAnchor` is created. The unique identifier and image that the user tapped
    are then stored in the `imageNodes` dictionary so the image can be added to the
    scene after the new anchor is registered on the scene.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在为锚点设置正确的变换属性后，创建一个`ARAnchor`实例。然后将用户点击的唯一标识符和图像存储在`imageNodes`字典中，以便在新的锚点在场景中注册后添加图像到场景。
- en: 'To add the image to the scene, you should implement a helper method that will
    be called from `rendered(_:didAdd:for:)`, similar to the helper method you added
    to show the information card for the image tracking feature. Add the following
    code to `ViewController` to implement this helper:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像添加到场景中，你应该实现一个辅助方法，该方法将从`rendered(_:didAdd:for:)`中调用，类似于你为显示图像跟踪功能的信息卡添加的辅助方法。将以下代码添加到`ViewController`中来实现此辅助方法：
- en: '[PRE18]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To make it easier to see whether an appropriate vertical plane exists, you
    can implement a helper method that visualizes the planes that the AR session discovers.
    Add the following code to the `ViewController` class to implement this helper:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易地看到是否存在合适的垂直平面，你可以实现一个辅助方法来可视化AR会话发现的平面。将以下代码添加到`ViewController`类中来实现此辅助方法：
- en: '[PRE19]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The previous method takes a node and anchor to create a new `SCNPlane`, which
    is added to the exact position where the new plane anchor was discovered.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的方法接受一个节点和锚点来创建一个新的`SCNPlane`，并将其添加到新平面锚点被发现的确切位置。
- en: 'The final step in implementing this feature is to call the helper methods when
    needed. Update the implementation for `renderer(_:didAdd:for:)` as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此功能的最后一步是在需要时调用辅助方法。更新`renderer(_:didAdd:for:)`的实现如下：
- en: '[PRE20]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you run your app now, you should see orange squares appear in areas where
    ARKit detected a flat surface. Note that ARKit needs textures and visual markers
    to work well. If you try to detect a solid white wall, it's unlikely that ARKit
    will properly recognize the wall due to a lack of textures. However, a brick wall
    or a wall that has wallpaper with some graphics on it should work well for this
    purpose.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行你的应用，你应该会看到在ARKit检测到的平坦区域出现橙色方块。请注意，ARKit需要纹理和视觉标记才能正常工作。如果你尝试检测一个实心白色墙面，由于缺乏纹理，ARKit可能无法正确识别墙面。然而，砖墙或带有一些图形的壁纸墙面应该适用于此目的。
- en: 'The following screenshot shows an example where an image is attached to a wall,
    together with the plane indicator:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了一个示例，其中图像被附加到墙上，同时显示平面指示器：
- en: '![Figure 17.8 – Adding an image to an AR plane'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![图17.8 – 向AR平面上添加图像'
- en: '](img/Figure_17.08_B14717.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.08_B14717.jpg)'
- en: Figure 17.8 – Adding an image to an AR plane
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.8 – 向AR平面上添加图像
- en: This wraps up the implementation of your own personal AR gallery. There is still
    much to learn about the things you can do with AR, so make sure to keep on experimenting
    and learning so you can create amazing experiences for your users.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了你个人AR画廊的实现。关于你可以用AR做什么，还有很多东西要学习，所以请确保继续实验和学习，以便为你的用户提供令人惊叹的体验。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned a lot. You gained some insight into what AR is,
    the basic workings of AR, and what you can do with it. Then you learned about
    the components that make up an excellent AR experience, and you implemented your
    first small AR experience by adopting Quick Look in an app to preview AR content
    in a real AR session.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学到了很多。你对AR是什么，AR的基本工作原理以及你可以用它做什么有了更深的了解。然后你学习了构成优秀AR体验的组件，并通过在应用程序中采用Quick
    Look来预览真实AR会话中的AR内容，实现了你的第一个小型AR体验。
- en: Then you explored different ways to render content in an AR scene. You took
    a quick look at SpriteKit and SceneKit and learned that SpriteKit is Apple's 2D
    game development framework. You also learned that SceneKit is Apple's 3D game
    framework, which makes it extremely well-suited for usage in an AR app.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你探索了在AR场景中渲染内容的不同方法。你快速浏览了SpriteKit和SceneKit，并了解到SpriteKit是苹果的2D游戏开发框架。你还了解到SceneKit是苹果的3D游戏框架，这使得它在AR应用程序中使用极为合适。
- en: Then you implemented an AR gallery that uses image tracking and plane detection
    and allows users to add their own content to their gallery. In the process of
    doing this, you saw that it's not always easy to get ARKit to work well. Bad lighting
    and other factors can make AR experiences less than ideal.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你实现了一个使用图像跟踪和平面检测的AR画廊，允许用户将他们自己的内容添加到他们的画廊中。在这个过程中，你发现要让ARKit工作良好并不总是容易。不良的照明和其他因素可能会使AR体验远低于理想状态。
- en: In the next chapter, you will create a macOS app with Catalyst.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将使用Catalyst创建一个macOS应用程序。
