<html><head></head><body>
		<div><h1 id="_idParaDest-57"><em class="italic"><a id="_idTextAnchor062"/>Chapter 5</em>: Using Kotlin Flows</h1>
			<p>In the previous three chapters, we dove into Kotlin coroutines and learned how we can use them for asynchronous programming in Android. We learned about coroutine builders, scopes, dispatchers, contexts, and jobs. We then learned how to handle coroutine cancelations, timeouts, and exceptions. We also learned how to create tests for coroutines in your code. </p>
			<p>In the next three chapters, we will focus on Kotlin Flow, a new asynchronous stream library built on top of Kotlin coroutines. A flow can emit multiple values over a length of time instead of just a single value. You can use Flows for streams of data, such as real-time location, sensor readings, and live database values.</p>
			<p>In this chapter, we will explore Kotlin Flows. We will start by building Kotlin Flows. Then, we will look into the various operators you can use for transforming, combining, buffering, and doing more with Flows. Finally, we will learn about StateFlows and SharedFlows.</p>
			<p>This chapter covers the following main topics:</p>
			<ul>
				<li>Using Flows in Android</li>
				<li>Creating Flows with Flow builders</li>
				<li>Using operators with Flows</li>
				<li>Buffering and combining Flows</li>
				<li>Exploring StateFlow and SharedFlow</li>
			</ul>
			<p>By the end of this chapter, you will have a deeper understanding of using Kotlin Flows. You will be able to use Flows for various cases in your Android apps. You will also learn about flow builders, operators, combining flows, StateFlow, and SharedFlow.</p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor063"/>Technical requirements</h1>
			<p>You will need to download and install the latest version of Android Studio. You can find the latest version at <a href="https://developer.android.com/studio">https://developer.android.com/studio</a>. For an optimal learning experience, a computer with the following specifications is recommended: </p>
			<ul>
				<li>Intel Core i5 or equivalent or higher </li>
				<li>4 GB RAM minimum </li>
				<li>4 GB available space</li>
			</ul>
			<p>The code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows/tree/main/Chapter05">https://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows/tree/main/Chapter05</a>.</p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor064"/>Using Flows in Android</h1>
			<p>In this section, we will start<a id="_idIndexMarker199"/> by using flows in Android<a id="_idIndexMarker200"/> for asynchronous programming. Flows are ideal for the parts of your application that involve live data updates.</p>
			<p>A Flow of data is represented by the <code>Flow&lt;String&gt;</code> is a flow that emits string values.</p>
			<p>Android Jetpack libraries such as Room, Paging, DataStore, WorkManager, and Jetpack Compose include built-in support for Flow.</p>
			<p>The Room database library added support for Flows, starting with version 2.2. This allows you to be notified of changes in the database values by using Flows.</p>
			<p>If your Android application uses a <strong class="bold">Data Access Object</strong> (<strong class="bold">DAO</strong>) to display a list of movies, your project<a id="_idIndexMarker202"/> can have a DAO such as the following:</p>
			<pre class="source-code">@Dao</pre>
			<pre class="source-code">interface MovieDao {</pre>
			<pre class="source-code">    @Query("SELECT * FROM movies")</pre>
			<pre class="source-code">    fun getMovies(): List&lt;Movie&gt;</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>By calling the <code>getMovies</code> function from <code>MovieDao</code>, you can get the list of movies from the database.</p>
			<p>The preceding code will only<a id="_idIndexMarker203"/> fetch the list of movies once, after calling <code>getMovies</code>. You may want<a id="_idIndexMarker204"/> your application to automatically update the list of movies whenever a movie in the database has been added, removed, or updated. You can do that by using Room-KTX and changing your <code>MovieDao</code> to use Flow for <code>getMovies</code>:</p>
			<pre class="source-code">@Dao</pre>
			<pre class="source-code">interface MovieDao {</pre>
			<pre class="source-code">    @Query("SELECT * FROM movies")</pre>
			<pre class="source-code">    fun getMovies(): Flow&lt;List&lt;Movie&gt;&gt;</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>With this code, every time the <code>movies</code> table has a change, <code>getMovies</code> will emit a new list containing the list of movies from the database. Your application can then use that to automatically update the movies displayed in your List or <code>RecyclerView</code>.</p>
			<p>If you are using <code>LiveData</code> and want to convert <code>LiveData</code> to <code>Flow</code>, or <code>Flow</code> to <code>LiveData</code>, you can use the LiveData KTX. </p>
			<p>To convert <code>LiveData</code> to <code>Flow</code>, you can use the <code>LiveData.asFlow()</code> extension function. With the <code>Flow.asLiveData()</code> extension function to convert <code>Flow</code> to <code>LiveData</code>. You can add LiveData KTX to your project by including the following to your <code>app/build.gradle</code> dependencies:</p>
			<pre class="source-code">dependencies {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code">    implementation ‘androidx.lifecycle:lifecycle-livedata-</pre>
			<pre class="source-code">      ktx:2.2.0'</pre>
			<pre class="source-code">}</pre>
			<p>This adds the LiveData KTX to your project, allowing you to use the <code>asFlow()</code> and <code>asLiveData()</code> extension functions to convert <code>LiveData</code> to <code>Flow</code> and <code>Flow</code> to <code>LiveData</code>.</p>
			<p>Third-party Android libraries<a id="_idIndexMarker205"/> now also support Flows; some functions can return Flow<a id="_idIndexMarker206"/> objects. If you are using RxJava 3 in<a id="_idIndexMarker207"/> your project, you can use the <code>Flow</code> to <code>Flowable</code> or <code>Observable</code> and vice versa.</p>
			<p>A flow will only start emitting values when you call the <code>collect</code> function. The <code>collect</code> function is a suspending function, so you should call it from a coroutine or another suspending function. </p>
			<p>In the following example, the <code>collect()</code> function was called from the coroutine created using the <code>launch</code> coroutine builder from <code>lifecycleScope</code>:</p>
			<pre class="source-code">class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        lifecycleScope.launch {</pre>
			<pre class="source-code">            viewModel.fetchMovies().collect { movie -&gt;</pre>
			<pre class="source-code">                Log.d("movies", "${movie.title}")</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">class MovieViewModel : ViewModel() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    fun fetchMovies(): Flow&lt;Movie&gt; {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this example, the <code>collect{}</code> function was<a id="_idIndexMarker208"/> called on <code>Flow&lt;Movie&gt;</code> and returned<a id="_idIndexMarker209"/> by calling <code>viewModel.fetchMovies()</code>. This will cause the Flow to start emitting values, and you can then process each value.</p>
			<p>The collection of the flow occurs in <code>CoroutineContext</code> of the parent coroutine. In the previous example, the coroutine context is from <code>viewModelScope</code>.</p>
			<p>To change <code>CoroutineContext</code> where the Flow is run, you can use the <code>flowOn()</code> function. If you want to change <code>Dispatcher</code> on the Flow in the previous example to <code>Dispatchers.IO)</code>, you can use <code>flowOn(Dispatchers.IO)</code>, as shown in the following example:</p>
			<pre class="source-code">class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        lifecycleScope.launch {</pre>
			<pre class="source-code">            viewModel.fetchMovies()</pre>
			<pre class="source-code">                .flowOn(Dispatchers.IO)</pre>
			<pre class="source-code">                .collect { movie -&gt;</pre>
			<pre class="source-code">                    Log.d("movies", "${movie.title}")</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Here, before collecting<a id="_idIndexMarker210"/> the Flow, the dispatcher where the Flow is run<a id="_idIndexMarker211"/> was changed to <code>Dispatchers.IO</code> by calling <code>flowOn</code> with <code>Dispatchers.IO</code>.</p>
			<p>When you call <code>flowOn</code>, it will only change the preceding functions or operators and not the ones after you called it. In the following example, a <code>map</code> operator was called after the <code>flowOn</code> call to change the dispatcher, so its context won’t be changed:</p>
			<pre class="source-code">class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        lifecycleScope.launch {</pre>
			<pre class="source-code">            viewModel.fetchMovies()</pre>
			<pre class="source-code">                .flowOn(Dispatchers.IO)</pre>
			<pre class="source-code">                .map { ... }</pre>
			<pre class="source-code">                .collect { movie -&gt;</pre>
			<pre class="source-code">                    Log.d("movies", "${movie.title}")</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this example, <code>flowOn</code> will only change<a id="_idIndexMarker212"/> the context of the ones preceding<a id="_idIndexMarker213"/> the call, so the <code>map</code> call will not be changed. It will still use the original context (which is the one from <code>lifecycleScope</code>).</p>
			<p>In Android, you can collect Flow in the Fragment or Activity classes to display the data in the UI. If the UI goes to the background, your Flow will keep on collecting the data. Your app must not continue collecting the Flow and updating the screen to prevent memory leaks and avoid wasting resources.</p>
			<p>To safely collect flows in the Android UI layer, you would need to handle the lifecycle changes yourself. You can also use <code>Lifecycle.repeatOnLifecycle</code> and <code>Flow.flowWithLifecycle</code>, which are available in the <code>app/build.gradle</code> dependencies:</p>
			<pre class="source-code">dependencies {</pre>
			<pre class="source-code">    ...    </pre>
			<pre class="source-code">    implementation ‘androidx.lifecycle:lifecycle-runtime-</pre>
			<pre class="source-code">      ktx:2.4.1</pre>
			<pre class="source-code">}</pre>
			<p>This adds the <code>Lifecycle.repeatOnLifecycle</code> and <code>Flow.flowWithLifecycle</code>.</p>
			<p><code>Lifecycle.repeatOnLifecycle(state, block)</code> suspends the parent coroutine until the lifecycle is destroyed and executes the suspending <code>block</code> of code when the lifecycle is at least in <code>state</code> you set. When the lifecycle moves out of the state, <code>repeatOnLifecycle</code> will stop the Flow and restart it when the lifecycle moves back to the said state.</p>
			<p>If you used <code>repeatOnLifecycle</code> will start collecting<a id="_idIndexMarker216"/> the Flow whenever the lifecycle is started. It will stop when the lifecycle is stopped, when the <code>onStop()</code> of the lifecycle is called. </p>
			<p>When you use <code>repeatOnLifecycle</code> will start collecting<a id="_idIndexMarker217"/> the Flow every<a id="_idIndexMarker218"/> time the lifecycle is resumed<a id="_idIndexMarker219"/> and will stop when the lifecycle is paused or when <code>onPause()</code> is called.</p>
			<p>It is recommended to call <code>Lifecycle.repeatOnLifecycle</code> on the activity’s <code>onCreate</code> or on the fragment’s <code>onViewCreated</code> functions.</p>
			<p>The following shows how you can use <code>Lifecycle.repeatOnLifecycle</code> in your Android project:</p>
			<pre class="source-code">class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        lifecycleScope.launch {</pre>
			<pre class="source-code">            repeatOnLifecycle(Lifecycle.State.STARTED) {</pre>
			<pre class="source-code">                viewModel.fetchMovies()</pre>
			<pre class="source-code">                    .collect { movie -&gt;</pre>
			<pre class="source-code">                        Log.d("movies", "${movie.title}")</pre>
			<pre class="source-code">                    }   </pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Here, we used <code>repeatOnLifecycle</code> with <strong class="bold">Lifecycle.State.STARTED</strong> to start collecting the Flow of movies<a id="_idIndexMarker220"/> when the lifecycle<a id="_idIndexMarker221"/> is started and stop when <a id="_idIndexMarker222"/>the lifecycle is stopped.</p>
			<p>You can use <code>Lifecycle.repeatOnLifecycle</code> to collect more than one Flow. To do so, you must collect them in parallel in different coroutines:</p>
			<pre class="source-code">class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">  override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">      ...</pre>
			<pre class="source-code">      lifecycleScope.launch {</pre>
			<pre class="source-code">          repeatOnLifecycle(Lifecycle.State.STARTED) {</pre>
			<pre class="source-code">              launch {</pre>
			<pre class="source-code">                 viewModel.fetchMovies().collect { movie -&gt;</pre>
			<pre class="source-code">                      Log.d("movies", "${movie.title}")</pre>
			<pre class="source-code">                    }</pre>
			<pre class="source-code">                }</pre>
			<pre class="source-code">              launch {</pre>
			<pre class="source-code">                  viewModel.fetchTVShows.collect { show -&gt;</pre>
			<pre class="source-code">                      Log.d("tv shows", "${show.title}")</pre>
			<pre class="source-code">                    }</pre>
			<pre class="source-code">                }</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Here, there are two Flows: one<a id="_idIndexMarker223"/> to collect the movies and the other to collect <a id="_idIndexMarker224"/>the TV shows. The collections of the Flow are started from separate <code>launch</code> coroutine builders.</p>
			<p>If you only have one Flow to collect, you can also use <code>Flow.flowWithLifecycle</code>. This emits values from the<a id="_idIndexMarker225"/> upstream Flow (the Flow and operators preceding the call) when the lifecycle is at least in <code>Lifecycle.repeatOnLifecycle</code> internally. You can use <code>Flow.flowWithLifecycle</code> as shown in the following code:</p>
			<pre class="source-code">class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        lifecycleScope.launch {</pre>
			<pre class="source-code">            viewModel.fetchMovies()          </pre>
			<pre class="source-code">                .flowWithLifecycle(lifecycle,</pre>
			<pre class="source-code">                  Lifecycle.State.STARTED)</pre>
			<pre class="source-code">                .collect { movie -&gt;</pre>
			<pre class="source-code">                    Log.d("movies", "${movie.title}")</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this example, you used <code>flowWithLifecycle</code> with <strong class="bold">Lifecycle.State.STARTED</strong> to start collecting the Flow of movies<a id="_idIndexMarker226"/> when the lifecycle is started and stop if the lifecycle is stopped.</p>
			<p>In this section, you have learned about using Kotlin Flows in your Android app. You can use Flow in Android Jetpack libraries such as Room and even in third-party libraries. To safely collect flows in the UI layer and prevent<a id="_idIndexMarker227"/> memory leaks and avoid wasting<a id="_idIndexMarker228"/> resources, you can use <code>Lifecycle.repeatOnLifecycle</code> and <code>Flow.flowWithLifecycle</code>.</p>
			<p>In the next section, we will be looking into the different Flow builders you can use to create Flows for your application.</p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor065"/>Creating Flows with Flow builders</h1>
			<p>In this section, we will start<a id="_idIndexMarker229"/> by looking at creating Flows. To create<a id="_idIndexMarker230"/> a Flow, you can use a Flow builder.</p>
			<p>The Kotlin Flow API has flow builders that you can use to create Flows. The following are the Kotlin Flow builders you can use:</p>
			<ul>
				<li><code>flow {}</code></li>
				<li><code>flowOf()</code></li>
				<li><code>asFlow() </code></li>
			</ul>
			<p>The <code>flow</code> builder function creates a new Flow from a suspendable lambda block. Inside the block, you can send values using the <code>emit</code> function. For example, this  <code>fetchMovieTitles</code> function of <code>MovieViewModel</code> returns <code>Flow&lt;String&gt;</code>:</p>
			<pre class="source-code">class MovieViewModel : ViewModel() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    fun fetchMovieTitles(): Flow&lt;String&gt; = flow {</pre>
			<pre class="source-code">        val movies = fetchMoviesFromNetwork()</pre>
			<pre class="source-code">        movies.forEach { movie -&gt; </pre>
			<pre class="source-code">            emit(movie.title)</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    private fun fetchMoviesFromNetwork(): List&lt;Movie&gt; {</pre>
			<pre class="source-code">         …</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this example, <code>fetchMovieTitles</code> created a Flow<a id="_idIndexMarker231"/> with the movie titles. It iterated<a id="_idIndexMarker232"/> over the list of movies from <code>fetchMoviesFromNetwork</code> and, for each movie, emitted the movie’s title with the <code>emit</code> function.</p>
			<p>With the <code>flowOf</code> function, you can create a Flow that produces the specified value or <code>vararg</code> values. In the following example, the <code>flowOf</code> function is used to create a Flow of the titles of the top three movies:</p>
			<pre class="source-code">class MovieViewModel : ViewModel() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    fun fetchTop3Titles(): Flow&lt;List&lt;Movie&gt;&gt; {</pre>
			<pre class="source-code">        val movies = fetchMoviesFromNetwork().sortedBy {</pre>
			<pre class="source-code">            it.popularity }</pre>
			<pre class="source-code">        return flowOf(movies[0].title, </pre>
			<pre class="source-code">            movies[1].title, </pre>
			<pre class="source-code">            movies[2].title)</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    private fun fetchMoviesFromNetwork(): List&lt;Movie&gt; {</pre>
			<pre class="source-code">        …</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Here, <code>fetchTop3Titles</code> uses <code>flowOf</code> to create a Flow containing the titles of the first three movies.</p>
			<p>The <code>asFlow()</code> extension function <a id="_idIndexMarker233"/>allows you to convert a type<a id="_idIndexMarker234"/> into a Flow. You can use this on sequences, arrays, ranges, collections, and functional types. For example, this <code>MovieViewModel</code> has <code>fetchMovieIds</code> that returns <code>Flow&lt;Int&gt;</code>, containing the movie IDs:</p>
			<pre class="source-code">class MovieViewModel : ViewModel() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    private fun fetchMovieIds(): Flow&lt;Int&gt; {</pre>
			<pre class="source-code">        val movies: List&lt;Movie&gt; = fetchMoviesFromNetwork()</pre>
			<pre class="source-code">        return movies.map { it.id }.asFlow()</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    private fun fetchMoviesFromNetwork(): List&lt;Movie&gt; {</pre>
			<pre class="source-code">        …</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this example, we used a <code>map</code> function on the list of movies to create a list of the movie IDs. The list of movie IDs was then converted to <code>Flow&lt;String&gt;</code> by using the <code>asFlow()</code> extension function on it.</p>
			<p>In this section, we learned <a id="_idIndexMarker235"/>how you can create Flows with Flow Builders. In the next<a id="_idIndexMarker236"/> section, we will check out the various Kotlin Flow operators you can use to transform, combine, and do more with Flows.</p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor066"/>Using operators with Flows </h1>
			<p>In this section, we will focus<a id="_idIndexMarker237"/> on the various Flow operators. Kotlin Flow has built-in<a id="_idIndexMarker238"/> operators that you can use with Flows. We can collect flows with terminal operators and transform Flows with Intermediate operators.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor067"/>Collecting Flows with terminal operators</h2>
			<p>In this section, we will explore the terminal operators<a id="_idIndexMarker239"/> you can use on Flows<a id="_idIndexMarker240"/> to start the collection of a Flow. The <code>collect</code> function we used in the previous examples is the most used terminal operator. However, there are other built-in terminal Flow operators.</p>
			<p>The following are the built-in terminal Flow operators you can use to start the collection of the Flow:</p>
			<ul>
				<li><code>toList</code>: Collects the Flow and converts it into a list</li>
				<li><code>toSet</code>: Collects the Flow and converts it into a set</li>
				<li><code>toCollection</code>: Collects the Flow and converts it into a collection</li>
				<li><code>count</code>: Returns the number of elements in the Flow</li>
				<li><code>first</code>: Returns the Flow’s first<a id="_idIndexMarker241"/> element or throws a <strong class="bold">NoSuchElementException</strong> if the Flow was empty</li>
				<li><code>firstOrNull</code>: Returns the Flow’s first element or null if the Flow was empty</li>
				<li><code>last</code>: Returns the Flow’s last element<a id="_idIndexMarker242"/> or throws a <strong class="bold">NoSuchElementException</strong> if the Flow was empty</li>
				<li><code>lastOrNull</code>: Returns the Flow’s last element or null if the Flow was empty</li>
				<li><code>single</code>: Returns the single element emitted or throws an exception if the Flow was empty or had more than one value</li>
				<li><code>singleOrNull</code>: Returns the single element emitted or null if the Flow was empty or had more than one value</li>
				<li><code>reduce</code>: Applies a function to each item emitted, starting from the first element, and returns the accumulated result</li>
				<li><code>fold</code>: Applies a function to each item emitted, starting from the initial value set, and returns the accumulated result</li>
			</ul>
			<p>These terminal Flow operators<a id="_idIndexMarker243"/> work like the Kotlin collection functions<a id="_idIndexMarker244"/> with the same name in the standard Kotlin library.</p>
			<p>In the following example, the <code>firstOrNull</code> terminal operator is used instead of the <code>collect</code> operator to collect the Flow from <code>ViewModel</code>:</p>
			<pre class="source-code">class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        lifecycleScope.launch {</pre>
			<pre class="source-code">            repeatOnLifecycle(Lifecycle.State.STARTED) {</pre>
			<pre class="source-code">                val topMovie =</pre>
			<pre class="source-code">                  viewModel.fetchMovies().firstOrNull()</pre>
			<pre class="source-code">                displayMovie(topMovie)</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Here, <code>firstOrNull</code> was used on the Flow to get the first item (or null if the Flow was empty), which represents the top movie. It will then be displayed on the screen.</p>
			<p>In this section, you learned<a id="_idIndexMarker245"/> about the Flow terminal operators<a id="_idIndexMarker246"/> you can use to start collecting from a Flow. In the next section, we will learn how to transform Flows with Intermediate operators.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor068"/>Transforming Flows with Intermediate operators</h2>
			<p>In this section, we will focus<a id="_idIndexMarker247"/> on Intermediate flow operators that you can<a id="_idIndexMarker248"/> use to transform Flows. With Intermediate operators, you can return a new Flow based on the original one.</p>
			<p>Intermediate operators allow you to modify a Flow and return a new one. You can chain various operators, and they will be applied sequentially.</p>
			<p>You can transform the Flow by applying operators on them, as you can do with Kotlin collections. The following Intermediate operators work similarly to the Kotlin collection functions with the same name:</p>
			<ul>
				<li><code>filter</code>: Returns a Flow that selects only the values from the Flow that meet the condition you passed</li>
				<li><code>filterNot</code>: Returns a Flow that selects only the values from the Flow that do not meet the condition you passed</li>
				<li><code>filterNotNull</code>: Returns a Flow that only includes values from the original Flow that are not null</li>
				<li><code>filterIsInstance</code>: Returns a Flow that only includes values from the Flow that are instances of the type you specified</li>
				<li><code>map</code>: Returns a Flow that includes values from the Flow transformed with the operation you specified</li>
				<li><code>mapNotNull</code>: Like <code>map</code> (transforms the Flow using the operation specified) but only includes values that are not null</li>
				<li><code>withIndex</code>: Returns a Flow that<a id="_idIndexMarker249"/> converts each value to an <strong class="bold">IndexedValue</strong> containing the index of the value and the value itself</li>
				<li><code>onEach</code>: Returns a Flow that performs the specified action on each value before they are emitted</li>
				<li><code>runningReduce</code>: Returns a Flow containing the accumulated values resulting from running the operation specified sequentially, starting with the first element</li>
				<li><code>runningFold</code>: Returns a Flow containing accumulated values resulting from running the operation specified sequentially, starting with the initial value set</li>
				<li><code>scan</code>: Like the <code>runningFold</code> operator</li>
			</ul>
			<p>There is also a <code>transform</code> operator<a id="_idIndexMarker250"/> that you can use to apply custom<a id="_idIndexMarker251"/> or complex operations. With the <code>transform</code> operator, you can emit values into the new Flow by calling the <code>emit</code> function with the value to send.</p>
			<p>For example, this <code>MovieViewModel</code> has a <code>fetchTopMovieTitles</code> function that uses <code>transform</code> to return a Flow with the top movies:</p>
			<pre class="source-code">class MovieViewModel : ViewModel() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    fun fetchTopMovies(): Flow&lt;Movie&gt; {</pre>
			<pre class="source-code">        return fetchMoviesFlow()</pre>
			<pre class="source-code">            .transform {</pre>
			<pre class="source-code">                if (it.popularity &gt; 0.5f) emit(it)</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this example, the <code>transform</code> operator was used in the Flow of movies to return a new Flow. The <code>transform</code> operator was used to emit only the list of movies whose popularity is higher than <code>0.5</code>, which means a popularity of more than 50%.</p>
			<p>There are also size-limiting operators that you can use with Flow. The following are some of these operators:</p>
			<ul>
				<li><code>drop(x)</code>: Returns a Flow that ignores the first <em class="italic">x</em> elements</li>
				<li><code>dropWhile</code>: Returns a Flow that ignores the first elements that meet the condition specified</li>
				<li><code>take(x)</code>: Returns a Flow containing the first <em class="italic">x</em> elements of the Flow</li>
				<li><code>takeWhile</code>: Returns a Flow that includes the first elements that meet the condition specified</li>
			</ul>
			<p>These size-limiting operators also function similarly to the Kotlin collection functions with the same name.</p>
			<p>In this section, we learned <a id="_idIndexMarker252"/>about Intermediate flow<a id="_idIndexMarker253"/> operators. Intermediate operators transform a Flow into a new Flow. In the next section, we will learn how to buffer and combine Kotlin Flows.</p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor069"/>Buffering and combining flows</h1>
			<p>In this section, we will learn about buffering<a id="_idIndexMarker254"/> and combining Kotlin Flows. You can buffer and combine<a id="_idIndexMarker255"/> Flows with Flow operators. Buffering allows Flow with long-running tasks to run independently and avoid race conditions. Combining allows you to join different sources of Flows before processing or displaying them on the screen.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor070"/>Buffering Kotlin Flows</h2>
			<p>In this section, we will learn<a id="_idIndexMarker256"/> about buffering Kotlin Flows. Buffering allows you to run data emission in parallel to the collection.</p>
			<p>Emitting and collecting data with Flow run sequentially. When a new value is emitted, it will be collected. Emission of a new value can only happen once the previous data has been collected. If the emission or the collection of data from the Flow takes a while to complete, the whole process will take a longer time. </p>
			<p>With buffering, you can make a Flow’s emission and collection of data run in parallel. There are three operators you can use to buffer Flows: </p>
			<ul>
				<li><code>buffer</code></li>
				<li><code>conflate</code></li>
				<li><code>collectLatest</code></li>
			</ul>
			<p><code>buffer()</code> allows the Flow to emit values while the data is still being collected. The emission and collection of data are run in separate coroutines, so it runs in parallel. The following is an example of how to use <code>buffer</code> with Flows:</p>
			<pre class="source-code">class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        lifecycleScope.launch {</pre>
			<pre class="source-code">            repeatOnLifecycle(Lifecycle.State.STARTED) {</pre>
			<pre class="source-code">                viewModel.fetchMovies()</pre>
			<pre class="source-code">                    .buffer()</pre>
			<pre class="source-code">                    .collect { movie -&gt;</pre>
			<pre class="source-code">                        processMovie(movie)</pre>
			<pre class="source-code">                    }   </pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Here, the <code>buffer</code> operator was added<a id="_idIndexMarker257"/> before calling <code>collect</code>. If the <code>processMovie(movie)</code> function in the collection takes longer, the Flow will emit and buffer the values before they are collected and processed.</p>
			<p><code>conflate()</code> is similar to the <code>buffer()</code> operator, except with <code>conflate</code>, the collector will only process the latest value emitted after the previous value has been processed. It will ignore the other values previously emitted. Here is an example of using <code>conflate</code> in a Flow:</p>
			<pre class="source-code">class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        lifecycleScope.launch {</pre>
			<pre class="source-code">            repeatOnLifecycle(Lifecycle.State.STARTED) {</pre>
			<pre class="source-code">                viewModel.getTopMovie()</pre>
			<pre class="source-code">                    .conflate()</pre>
			<pre class="source-code">                    .collect { movie -&gt;</pre>
			<pre class="source-code">                        processMovie(movie)</pre>
			<pre class="source-code">                    }   </pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this example, adding the <code>conflate</code> operator will allow us to only process the latest value from the Flow and call <code>processMovie</code> with that value.</p>
			<p><code>collectLatest(action)</code> is a terminal operator that will collect the Flow the same way as <code>collect</code>, but whenever a new value is emitted, it will restart the action and use this new value. Here is an example of using <code>collectLatest</code> in a Flow:</p>
			<pre class="source-code">class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        lifecycleScope.launch {</pre>
			<pre class="source-code">            repeatOnLifecycle(Lifecycle.State.STARTED) {</pre>
			<pre class="source-code">                viewModel.getTopMovie()</pre>
			<pre class="source-code">                    .collectLatest { movie -&gt;</pre>
			<pre class="source-code">                        displayMovie(movie)</pre>
			<pre class="source-code">                    }   </pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Here, <code>collectLatest</code> was used instead of the <code>collect</code> terminal operator to collect the flow from <code>viewModel.getTopMovie()</code>. Whenever a new value is emitted by this Flow, it will restart and call <code>displayMovie</code> with the new value.</p>
			<p>In this section, you learned<a id="_idIndexMarker258"/> how to buffer Kotlin Flows with <code>buffer</code>, <code>conflate</code>, and <code>collectLatest</code>. In the next section, you will learn about combining multiple Flows into a single Flow.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor071"/>Combining Flows</h2>
			<p>In this section, we will learn<a id="_idIndexMarker259"/> how we can combine Flows. The Kotlin Flow API has available operators that you can use to combine multiple flows.</p>
			<p>If you have multiple flows and you want to combine them into one, you can use the following Flow operators:</p>
			<ul>
				<li><code>zip</code></li>
				<li><code>merge</code></li>
				<li><code>combine</code></li>
			</ul>
			<p><code>merge</code> is a top-level function that combines the elements from multiple Flows of the same type into one. You can pass a <code>vararg</code> number of Flows to combine. This is useful when you have two or more sources of data that you want to merge first before collecting.</p>
			<p>In the following example, there are two Flows from <code>viewModel.fetchMoviesFromDb</code> and <code>viewModel.fetchMoviesFromNetwork</code> combined using <code>merge</code>:</p>
			<pre class="source-code">class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        lifecycleScope.launch {</pre>
			<pre class="source-code">            repeatOnLifecycle(Lifecycle.State.STARTED) {</pre>
			<pre class="source-code">                merge(viewModel.fetchMoviesFromDb(),</pre>
			<pre class="source-code">                  viewModel.fetchMoviesFromNetwork())</pre>
			<pre class="source-code">                    .collect { movie -&gt;</pre>
			<pre class="source-code">                        processMovie(movie)</pre>
			<pre class="source-code">                    }   </pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this example, <code>merge</code> was used to combine<a id="_idIndexMarker260"/> the Flows from <code>viewModel.fetchMoviesFromDb</code> and <code>viewModel.fetchMoviesFromNetwork</code> before they are collected.</p>
			<p>The <code>zip</code> operator pairs data from the first Flow to the second Flow into a new value using the function you specified. If one Flow has fewer values than the other, <code>zip</code> will end when the values of this Flow have all been processed.</p>
			<p>The following shows how you can use the <code>zip</code> operator to combine two Flows, <code>userFlow</code> and <code>taskFlow</code>:</p>
			<pre class="source-code">class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        lifecycleScope.launch {</pre>
			<pre class="source-code">            repeatOnLifecycle(Lifecycle.State.STARTED) {</pre>
			<pre class="source-code">                val userFlow = viewModel.getUsers()</pre>
			<pre class="source-code">                val taskFlow = viewModel.getTasks()</pre>
			<pre class="source-code">                userFlow.zip(taskFlow) { user, task -&gt;</pre>
			<pre class="source-code">                    AssignedTask(user, task)</pre>
			<pre class="source-code">                }.collect { assignedTask -&gt;</pre>
			<pre class="source-code">                    displayAssignedTask(assignedTask)</pre>
			<pre class="source-code">                }  </pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this example, you used <code>zip</code> to pair each value of <code>userFlow</code> to <code>taskFlow</code> and return a Flow of <code>AssignedTask</code> using the <code>user</code> and <code>task</code> values. This new Flow will be collected and then displayed with the <code>displayAssignedTask</code> function.</p>
			<p><code>combine</code> pairs data from the first<a id="_idIndexMarker261"/> flow to the second flow like <code>zip</code> but uses the most recent value emitted by each flow. It will continue to run as long as a Flow emits a value. There is also a top-level <code>combine</code> function that you can use for multiple flows.</p>
			<p>The following example shows how you can use the <code>combine</code> operator to join two Flows in your application:</p>
			<pre class="source-code">class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        lifecycleScope.launch {</pre>
			<pre class="source-code">            repeatOnLifecycle(Lifecycle.State.STARTED) {</pre>
			<pre class="source-code">                val yourMesssage =</pre>
			<pre class="source-code">                  viewModel.getLastMessageSent()</pre>
			<pre class="source-code">                val friendMessage =</pre>
			<pre class="source-code">                  viewModel.getLastMessageReceived()</pre>
			<pre class="source-code">                userFlow.combine(taskFlow) { yourMesssage,</pre>
			<pre class="source-code">                  friendMessage -&gt;</pre>
			<pre class="source-code">                    Conversation(yourMessage,</pre>
			<pre class="source-code">                      friendMessage)</pre>
			<pre class="source-code">                }.collect { conversation -&gt;</pre>
			<pre class="source-code">                    displayConversation(conversation)</pre>
			<pre class="source-code">                }  </pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Here, you have two Flows, <code>yourMessage</code> and <code>friendMessage</code>. The <code>combine</code> function pairs the most recent value of <code>yourMessage</code> and <code>friendMessage</code> to create a <code>Conversation</code> object. Whenever a new value is emitted by either Flow, <code>combine</code> will pair the latest values and add that to the resulting Flow for collection.</p>
			<p>In this section, we have explored how to combine<a id="_idIndexMarker262"/> Flows. In the next section, we will focus on <code>StateFlow</code> and <code>SharedFlow</code> and how we can use them in your Android applications.</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor072"/>Exploring StateFlow and SharedFlow</h1>
			<p>In this section, we will dive<a id="_idIndexMarker263"/> into <code>StateFlow</code> and <code>SharedFlow</code>. <code>SharedFlow</code> and <code>StateFlow</code> are Flows<a id="_idIndexMarker264"/> that are hot streams, unlike a normal Kotlin Flow, which are cold streams by default.</p>
			<p>A Flow is a cold stream of data. Flows only emit values when the values are collected. With <code>SharedFlow</code> and <code>StateFlow</code> hot streams, you can run and emit values the moment they are called and even when they have no listeners. <code>SharedFlow</code> and <code>StateFlow</code> are Flows, so you can also use operators on them.</p>
			<p>A <code>SharedFlow</code> allows you to emit values to multiple listeners. <code>SharedFlow</code> can be used for one-time events. The tasks that will be done by the <code>SharedFlow</code> will only be run once and will be shared by the listeners.</p>
			<p>You can use <code>MutableSharedFlow</code> and then use the <code>emit</code> function to send values to all the collectors.</p>
			<p>In the following example, <code>SharedFlow</code> is used in <code>MovieViewModel</code> for the list of movies fetched:</p>
			<pre class="source-code">class MovieViewModel : ViewModel() {</pre>
			<pre class="source-code">    private val _message = MutableSharedFlow&lt;String&gt;()</pre>
			<pre class="source-code">    val movies: SharedFlow&lt;String&gt; =</pre>
			<pre class="source-code">      _message.asSharedFlow()</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    fun onError(): Flow&lt;List&lt;Movie&gt;&gt; {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        _message.emit("An error was encountered")</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this example, we<a id="_idIndexMarker265"/> used <code>SharedFlow</code> for the message. We used the <code>emit</code> function to send the error<a id="_idIndexMarker266"/> message to the Flow’s listeners.</p>
			<p><code>StateFlow</code> is <code>SharedFlow</code>, but it only emits the latest value to its listeners. <code>StateFlow</code> is initialized with a value (an initial state) and keeps this state. You can change the value of <code>StateFlow</code> using the mutable version of <code>StateFlow</code>, <code>MutableStateFlow</code>. Updating the value sends the new value to the Flow.</p>
			<p>In Android, <code>StateFlow</code> can be an alternative to <code>LiveData</code>. You can use <code>StateFlow</code> for <code>ViewModel</code>, and your activity or fragment can then collect the value. For example, in the following <code>ViewModel</code>, <code>StateFlow</code> is used for the list of movies:</p>
			<pre class="source-code">class MovieViewModel : ViewModel() {</pre>
			<pre class="source-code">    private val _movies =</pre>
			<pre class="source-code">      MutableStateFlow(emptyList&lt;Movie&gt;())</pre>
			<pre class="source-code">    val movies: StateFlow&lt;List&lt;Movie&gt;&gt; = _movies</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    fun fetchMovies(): Flow&lt;List&lt;Movie&gt;&gt; {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        _movies.value = movieRepository.fetchMovies()</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In the preceding code, the list of movies<a id="_idIndexMarker267"/> fetched from the repository<a id="_idIndexMarker268"/> will be set to <code>MutableStateFlow</code> of <code>_movies</code>, which will also change <code>StateFlow</code> of <code>movies</code>. You can then collect <code>StateFlow</code> of <code>movies</code> in an activity or fragment, as shown in the following:</p>
			<pre class="source-code">class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        lifecycleScope.launch {</pre>
			<pre class="source-code">            repeatOnLifecycle(Lifecycle.State.STARTED) {</pre>
			<pre class="source-code">                viewModel.movies.collect { movies -&gt;</pre>
			<pre class="source-code">                    displayMovies(movies)</pre>
			<pre class="source-code">                }   </pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Here, <code>StateFlow</code> of <code>viewModel.movies</code> will be collected, and then the list of movies will be displayed on the screen with the <code>displayMovies</code> function.</p>
			<p>In this section, we have learned about <code>StateFlow</code> and <code>SharedFlow</code> and how<a id="_idIndexMarker269"/> we can use them in our <a id="_idIndexMarker270"/>Android projects.</p>
			<p>Let’s try what we have learned so far by adding Kotlin Flow to an Android project.</p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor073"/>Exercise 5.01 – Using Kotlin Flow in an Android app</h1>
			<p>For this exercise, you will be continuing<a id="_idIndexMarker271"/> the movie app you worked <a id="_idIndexMarker272"/>on in <em class="italic">Exercise 4.01 – Adding tests to coroutines in an Android app</em>. This application displays the movies that are currently playing in cinemas. You will be adding Kotlin Flow to the project by following these steps:</p>
			<ol>
				<li>Open the movie app you worked on in <em class="italic">Exercise 4.01 – Adding tests to coroutines in an Android app</em> in Android Studio.</li>
				<li>Go to the <code>MovieRepository</code> class and add a new <code>fetchMoviesFlow()</code> function that uses a <code>flow</code> builder to return a Flow and emits the list of movies from <code>MovieService</code>, as shown in the following snippet:<pre>fun fetchMoviesFlow(): Flow&lt;List&lt;Movie&gt;&gt; {
    return flow {
        emit(movieService.getMovies(apiKey).results)
    }.flowOn(Dispatchers.IO)
}</pre></li>
			</ol>
			<p>This is the same as the <code>fetchMovies()</code> function, but this function uses Kotlin Flow and will return <code>Flow&lt;List&lt;Movie&gt;&gt;</code> to the function or class that will collect it. The Flow will emit the list of movies from <code>movieService.getMovies</code>, and it will flow on the <code>Dispatchers.IO</code> dispatcher. </p>
			<ol>
				<li value="3">Open the <code>MovieViewModel</code> class, and replace the initialization of the <code>movies</code> <code>LiveData</code> that gets the value from <code>movieRepository</code> with the following lines:<pre>private val _movies =
  MutableStateFlow(emptyList&lt;Movie&gt;())
val movies: StateFlow&lt;List&lt;Movie&gt;&gt; = _movies</pre></li>
			</ol>
			<p>This will allow you to use the value of the <code>_movies</code> <code>MutableStateFlow</code> as the value of the <code>movies</code> <code>StateFlow</code>, which you will change later when you have fetched the list of movies from the Flow in <code>movieRepository</code>.</p>
			<ol>
				<li value="4">Do the same for the <code>error</code> <code>LiveData</code>, and replace<a id="_idIndexMarker273"/> its initialization with the value<a id="_idIndexMarker274"/> from <code>movieRepository</code> with the following lines:<pre>private val _error = MutableStateFlow("")
val error: StateFlow&lt;String&gt; = _error</pre></li>
			</ol>
			<p>This will use the value of the <code>_error</code> <code>MutableStateFlow</code> for the <code>error</code> <code>StateFlow</code>. You will be able to change the value of this <code>StateFlow</code> later for handling the cases when the Flow encountered an exception.</p>
			<ol>
				<li value="5">Replace the <code>loading</code> and <code>_loading</code> variables with the following lines:<pre>private val _loading = MutableStateFlow(true)
val loading: StateFlow&lt;String&gt; = _loading</pre></li>
			</ol>
			<p>This will use the value of the <code>_loading</code> <code>MutableStateFlow</code> for the <code>loading</code> <code>StateFlow</code>. You will update this later to indicate that the loading of movies is ongoing.</p>
			<ol>
				<li value="6">Remove the <code>fetchMovies()</code> function and its content. You will be replacing this in the next step.</li>
				<li>Add a new <code>fetchMovies()</code> function that will collect the Flow from the <code>movieRepository.fetchMoviesFlow</code>, as shown in the following code block:<pre>fun fetchMovies() {
    _loading.value = true
    viewModelScope.launch (dispatcher) {
        MovieRepository.fetchMoviesFlow()
            .collect {
                _movies.value = it
                _loading.value = false
            }
    }
}</pre></li>
			</ol>
			<p>This will collect the list of movies from <code>movieRepository.fetchMoviesFlow</code> and set it to the <code>_movies</code> <code>MutableStateFlow</code> and the <code>movies</code> <code>StateFlow</code>. This list of movies will then be displayed in <code>MainActivity</code>.</p>
			<ol>
				<li value="8">Open the <code>app/build.gradle</code> <a id="_idIndexMarker275"/>file. Add the following lines in the <a id="_idIndexMarker276"/>dependencies:<pre>implementation 'androidx.lifecycle:lifecycle-runtime-ktx:2.4.1'</pre></li>
			</ol>
			<p>This will allow us to use <code>lifecycleScope</code> for collecting the flows in <code>MainActivity</code> later.</p>
			<ol>
				<li value="9">Open <code>MainActivity</code> and remove the lines of code that observe for the <code>movies</code>, <code>error</code>, and <code>loading</code> <code>LiveData</code>. Replace them with the following:<pre>lifecycleScope.launch {
   repeatOnLifecycle(Lifecycle.State.STARTED) {
       launch {
           movieViewModel.movies.collect { movies -&gt;
               movieAdapter.addMovies(movies)
           }
       }
       launch {
           movieViewModel.error.collect { error -&gt;
               if (error.isNotEmpty())
                 Snackbar.make(recyclerView, error, 
                 Snackbar.LENGTH_LONG).show()
           }
       }
       launch {
           movieViewModel.loading.collect { loading -&gt;
               progressBar.isVisible = loading
           }
       }
   }
}</pre></li>
			</ol>
			<p>This will collect <code>movies</code> and add them<a id="_idIndexMarker277"/> to the list, collect the <code>error</code> and display<a id="_idIndexMarker278"/> a <code>SnackBar</code> message if <code>error</code> is not empty, and collect <code>loading</code> and update <code>progressBar</code> based on its value.</p>
			<ol>
				<li value="10">Run the application. The app should still display a list of movies (with a poster and a title), as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_5.1_B17773.jpg" alt="Figure 5.1 – The movie app with the list of movies&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – The movie app with the list of movies</p>
			<p>In this exercise, we have added Kotlin Flow<a id="_idIndexMarker279"/> in an Android app by creating a <code>MovieRepository</code> function that<a id="_idIndexMarker280"/> returns the list of movies as a Flow. This Flow was then collected by <code>MovieViewModel</code>.</p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor074"/>Summary</h1>
			<p>This chapter focused on using Kotlin Flows for asynchronous programming in Android. Flows are built on top of Kotlin coroutines. A flow can emit multiple values sequentially, instead of just a single value.</p>
			<p>We started with learning about how to use Kotlin Flows in your Android app. Jetpack libraries such as Room and some third-party libraries support Flow. To safely collect flows in the UI layer and prevent memory leaks and avoid wasting resources, you can use <code>Lifecycle.repeatOnLifecycle</code> and <code>Flow.flowWithLifecycle</code>.</p>
			<p>We then moved on to creating Flows with Flow builders. The <code>flowOf</code> function creates a Flow that emits the value or <code>vararg</code> values you provided. You can convert collections and functional types to Flow with the <code>asFlow()</code> extension function. The <code>flow</code> builder function creates a new Flow from a suspending lambda block, inside which you can send values with <code>emit()</code>.  </p>
			<p>Then, we explored Flow operators and learned how you can use them with Kotlin Flows. With terminal operators, you can start the collection of the Flow. Intermediate operators allow you to transform a Flow into another Flow. </p>
			<p>We then learned about buffering and combining Flows. With the <code>buffer</code>, <code>conflate</code>, and <code>collectLatest</code> operators, you can buffer Flows. You can combine Flows with the <code>merge</code>, <code>zip</code>, and <code>combine</code> Flow operators.</p>
			<p>We then explored <code>SharedFlow</code> and <code>StateFlow</code>. These can be used in your Android projects. With <code>SharedFlow</code>, you can emit values to multiple listeners. <code>StateFlow</code> is <code>SharedFlow</code> that only emits the latest value to its listeners.</p>
			<p>Finally, we worked on an exercise to add Kotlin Flows to an Android application. We used a Flow in <code>MovieRepository</code>, which was then collected in <code>MovieViewModel</code>.</p>
			<p>In the next chapter, we will focus on how to handle Kotlin Flows cancelations and exceptions in your application.</p>
		</div>
	</body></html>