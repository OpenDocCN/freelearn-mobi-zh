<html><head></head><body>
		<div id="_idContainer034">
			<h1 id="_idParaDest-57"><em class="italic"><a id="_idTextAnchor062"/>Chapter 5</em>: Using Kotlin Flows</h1>
			<p>In the previous three chapters, we dove into Kotlin coroutines and learned how we can use them for asynchronous programming in Android. We learned about coroutine builders, scopes, dispatchers, contexts, and jobs. We then learned how to handle coroutine cancelations, timeouts, and exceptions. We also learned how to create tests for coroutines in your code. </p>
			<p>In the next three chapters, we will focus on Kotlin Flow, a new asynchronous stream library built on top of Kotlin coroutines. A flow can emit multiple values over a length of time instead of just a single value. You can use Flows for streams of data, such as real-time location, sensor readings, and live database values.</p>
			<p>In this chapter, we will explore Kotlin Flows. We will start by building Kotlin Flows. Then, we will look into the various operators you can use for transforming, combining, buffering, and doing more with Flows. Finally, we will learn about StateFlows and SharedFlows.</p>
			<p>This chapter covers the following main topics:</p>
			<ul>
				<li>Using Flows in Android</li>
				<li>Creating Flows with Flow builders</li>
				<li>Using operators with Flows</li>
				<li>Buffering and combining Flows</li>
				<li>Exploring StateFlow and SharedFlow</li>
			</ul>
			<p>By the end of this chapter, you will have a deeper understanding of using Kotlin Flows. You will be able to use Flows for various cases in your Android apps. You will also learn about flow builders, operators, combining flows, StateFlow, and SharedFlow.</p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor063"/>Technical requirements</h1>
			<p>You will need to download and install the latest version of Android Studio. You can find the latest version at <a href="https://developer.android.com/studio">https://developer.android.com/studio</a>. For an optimal learning experience, a computer with the following specifications is recommended: </p>
			<ul>
				<li>Intel Core i5 or equivalent or higher </li>
				<li>4 GB RAM minimum </li>
				<li>4 GB available space</li>
			</ul>
			<p>The code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows/tree/main/Chapter05">https://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows/tree/main/Chapter05</a>.</p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor064"/>Using Flows in Android</h1>
			<p>In this section, we will start<a id="_idIndexMarker199"/> by using flows in Android<a id="_idIndexMarker200"/> for asynchronous programming. Flows are ideal for the parts of your application that involve live data updates.</p>
			<p>A Flow of data is represented by the <strong class="bold">kotlinx.coroutines.flow.Flow</strong> interface. Flows emit multiple values of the same<a id="_idIndexMarker201"/> type one at a time. For example, <strong class="source-inline">Flow&lt;String&gt;</strong> is a flow that emits string values.</p>
			<p>Android Jetpack libraries such as Room, Paging, DataStore, WorkManager, and Jetpack Compose include built-in support for Flow.</p>
			<p>The Room database library added support for Flows, starting with version 2.2. This allows you to be notified of changes in the database values by using Flows.</p>
			<p>If your Android application uses a <strong class="bold">Data Access Object</strong> (<strong class="bold">DAO</strong>) to display a list of movies, your project<a id="_idIndexMarker202"/> can have a DAO such as the following:</p>
			<pre class="source-code">@Dao</pre>
			<pre class="source-code">interface MovieDao {</pre>
			<pre class="source-code">    @Query("SELECT * FROM movies")</pre>
			<pre class="source-code">    fun getMovies(): List&lt;Movie&gt;</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>By calling the <strong class="source-inline">getMovies</strong> function from <strong class="source-inline">MovieDao</strong>, you can get the list of movies from the database.</p>
			<p>The preceding code will only<a id="_idIndexMarker203"/> fetch the list of movies once, after calling <strong class="source-inline">getMovies</strong>. You may want<a id="_idIndexMarker204"/> your application to automatically update the list of movies whenever a movie in the database has been added, removed, or updated. You can do that by using Room-KTX and changing your <strong class="source-inline">MovieDao</strong> to use Flow for <strong class="source-inline">getMovies</strong>:</p>
			<pre class="source-code">@Dao</pre>
			<pre class="source-code">interface MovieDao {</pre>
			<pre class="source-code">    @Query("SELECT * FROM movies")</pre>
			<pre class="source-code">    fun getMovies(): Flow&lt;List&lt;Movie&gt;&gt;</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>With this code, every time the <strong class="source-inline">movies</strong> table has a change, <strong class="source-inline">getMovies</strong> will emit a new list containing the list of movies from the database. Your application can then use that to automatically update the movies displayed in your List or <strong class="source-inline">RecyclerView</strong>.</p>
			<p>If you are using <strong class="source-inline">LiveData</strong> and want to convert <strong class="source-inline">LiveData</strong> to <strong class="source-inline">Flow</strong>, or <strong class="source-inline">Flow</strong> to <strong class="source-inline">LiveData</strong>, you can use the LiveData KTX. </p>
			<p>To convert <strong class="source-inline">LiveData</strong> to <strong class="source-inline">Flow</strong>, you can use the <strong class="source-inline">LiveData.asFlow()</strong> extension function. With the <strong class="source-inline">Flow.asLiveData()</strong> extension function to convert <strong class="source-inline">Flow</strong> to <strong class="source-inline">LiveData</strong>. You can add LiveData KTX to your project by including the following to your <strong class="source-inline">app/build.gradle</strong> dependencies:</p>
			<pre class="source-code">dependencies {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code">    implementation ‘androidx.lifecycle:lifecycle-livedata-</pre>
			<pre class="source-code">      ktx:2.2.0'</pre>
			<pre class="source-code">}</pre>
			<p>This adds the LiveData KTX to your project, allowing you to use the <strong class="source-inline">asFlow()</strong> and <strong class="source-inline">asLiveData()</strong> extension functions to convert <strong class="source-inline">LiveData</strong> to <strong class="source-inline">Flow</strong> and <strong class="source-inline">Flow</strong> to <strong class="source-inline">LiveData</strong>.</p>
			<p>Third-party Android libraries<a id="_idIndexMarker205"/> now also support Flows; some functions can return Flow<a id="_idIndexMarker206"/> objects. If you are using RxJava 3 in<a id="_idIndexMarker207"/> your project, you can use the <strong class="bold">kotlinx-coroutines-rx3</strong> library to convert <strong class="source-inline">Flow</strong> to <strong class="source-inline">Flowable</strong> or <strong class="source-inline">Observable</strong> and vice versa.</p>
			<p>A flow will only start emitting values when you call the <strong class="source-inline">collect</strong> function. The <strong class="source-inline">collect</strong> function is a suspending function, so you should call it from a coroutine or another suspending function. </p>
			<p>In the following example, the <strong class="source-inline">collect()</strong> function was called from the coroutine created using the <strong class="source-inline">launch</strong> coroutine builder from <strong class="source-inline">lifecycleScope</strong>:</p>
			<pre class="source-code">class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        lifecycleScope.launch {</pre>
			<pre class="source-code">            viewModel.fetchMovies().collect { movie -&gt;</pre>
			<pre class="source-code">                Log.d("movies", "${movie.title}")</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">class MovieViewModel : ViewModel() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    fun fetchMovies(): Flow&lt;Movie&gt; {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this example, the <strong class="source-inline">collect{}</strong> function was<a id="_idIndexMarker208"/> called on <strong class="source-inline">Flow&lt;Movie&gt;</strong> and returned<a id="_idIndexMarker209"/> by calling <strong class="source-inline">viewModel.fetchMovies()</strong>. This will cause the Flow to start emitting values, and you can then process each value.</p>
			<p>The collection of the flow occurs in <strong class="source-inline">CoroutineContext</strong> of the parent coroutine. In the previous example, the coroutine context is from <strong class="source-inline">viewModelScope</strong>.</p>
			<p>To change <strong class="source-inline">CoroutineContext</strong> where the Flow is run, you can use the <strong class="source-inline">flowOn()</strong> function. If you want to change <strong class="source-inline">Dispatcher</strong> on the Flow in the previous example to <strong class="source-inline">Dispatchers.IO)</strong>, you can use <strong class="source-inline">flowOn(Dispatchers.IO)</strong>, as shown in the following example:</p>
			<pre class="source-code">class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        lifecycleScope.launch {</pre>
			<pre class="source-code">            viewModel.fetchMovies()</pre>
			<pre class="source-code">                .flowOn(Dispatchers.IO)</pre>
			<pre class="source-code">                .collect { movie -&gt;</pre>
			<pre class="source-code">                    Log.d("movies", "${movie.title}")</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Here, before collecting<a id="_idIndexMarker210"/> the Flow, the dispatcher where the Flow is run<a id="_idIndexMarker211"/> was changed to <strong class="source-inline">Dispatchers.IO</strong> by calling <strong class="source-inline">flowOn</strong> with <strong class="source-inline">Dispatchers.IO</strong>.</p>
			<p>When you call <strong class="source-inline">flowOn</strong>, it will only change the preceding functions or operators and not the ones after you called it. In the following example, a <strong class="source-inline">map</strong> operator was called after the <strong class="source-inline">flowOn</strong> call to change the dispatcher, so its context won’t be changed:</p>
			<pre class="source-code">class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        lifecycleScope.launch {</pre>
			<pre class="source-code">            viewModel.fetchMovies()</pre>
			<pre class="source-code">                .flowOn(Dispatchers.IO)</pre>
			<pre class="source-code">                .map { ... }</pre>
			<pre class="source-code">                .collect { movie -&gt;</pre>
			<pre class="source-code">                    Log.d("movies", "${movie.title}")</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this example, <strong class="source-inline">flowOn</strong> will only change<a id="_idIndexMarker212"/> the context of the ones preceding<a id="_idIndexMarker213"/> the call, so the <strong class="source-inline">map</strong> call will not be changed. It will still use the original context (which is the one from <strong class="source-inline">lifecycleScope</strong>).</p>
			<p>In Android, you can collect Flow in the Fragment or Activity classes to display the data in the UI. If the UI goes to the background, your Flow will keep on collecting the data. Your app must not continue collecting the Flow and updating the screen to prevent memory leaks and avoid wasting resources.</p>
			<p>To safely collect flows in the Android UI layer, you would need to handle the lifecycle changes yourself. You can also use <strong class="source-inline">Lifecycle.repeatOnLifecycle</strong> and <strong class="source-inline">Flow.flowWithLifecycle</strong>, which are available in the <strong class="bold">lifecycle-runtime-ktx</strong> library, starting with version 2.4.0. To add<a id="_idIndexMarker214"/> it to your project, you can add the following to your <strong class="source-inline">app/build.gradle</strong> dependencies:</p>
			<pre class="source-code">dependencies {</pre>
			<pre class="source-code">    ...    </pre>
			<pre class="source-code">    implementation ‘androidx.lifecycle:lifecycle-runtime-</pre>
			<pre class="source-code">      ktx:2.4.1</pre>
			<pre class="source-code">}</pre>
			<p>This adds the <strong class="bold">lifecycle-runtime-ktx</strong> library to your project, allowing<a id="_idIndexMarker215"/> you to use <strong class="source-inline">Lifecycle.repeatOnLifecycle</strong> and <strong class="source-inline">Flow.flowWithLifecycle</strong>.</p>
			<p><strong class="source-inline">Lifecycle.repeatOnLifecycle(state, block)</strong> suspends the parent coroutine until the lifecycle is destroyed and executes the suspending <strong class="source-inline">block</strong> of code when the lifecycle is at least in <strong class="source-inline">state</strong> you set. When the lifecycle moves out of the state, <strong class="source-inline">repeatOnLifecycle</strong> will stop the Flow and restart it when the lifecycle moves back to the said state.</p>
			<p>If you used <strong class="bold">Lifecycle.State.STARTED</strong> for the state, your <strong class="source-inline">repeatOnLifecycle</strong> will start collecting<a id="_idIndexMarker216"/> the Flow whenever the lifecycle is started. It will stop when the lifecycle is stopped, when the <strong class="source-inline">onStop()</strong> of the lifecycle is called. </p>
			<p>When you use <strong class="bold">Lifecycle.State.RESUMED</strong> for the state, your <strong class="source-inline">repeatOnLifecycle</strong> will start collecting<a id="_idIndexMarker217"/> the Flow every<a id="_idIndexMarker218"/> time the lifecycle is resumed<a id="_idIndexMarker219"/> and will stop when the lifecycle is paused or when <strong class="source-inline">onPause()</strong> is called.</p>
			<p>It is recommended to call <strong class="source-inline">Lifecycle.repeatOnLifecycle</strong> on the activity’s <strong class="source-inline">onCreate</strong> or on the fragment’s <strong class="source-inline">onViewCreated</strong> functions.</p>
			<p>The following shows how you can use <strong class="source-inline">Lifecycle.repeatOnLifecycle</strong> in your Android project:</p>
			<pre class="source-code">class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        lifecycleScope.launch {</pre>
			<pre class="source-code">            repeatOnLifecycle(Lifecycle.State.STARTED) {</pre>
			<pre class="source-code">                viewModel.fetchMovies()</pre>
			<pre class="source-code">                    .collect { movie -&gt;</pre>
			<pre class="source-code">                        Log.d("movies", "${movie.title}")</pre>
			<pre class="source-code">                    }   </pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Here, we used <strong class="source-inline">repeatOnLifecycle</strong> with <strong class="bold">Lifecycle.State.STARTED</strong> to start collecting the Flow of movies<a id="_idIndexMarker220"/> when the lifecycle<a id="_idIndexMarker221"/> is started and stop when <a id="_idIndexMarker222"/>the lifecycle is stopped.</p>
			<p>You can use <strong class="source-inline">Lifecycle.repeatOnLifecycle</strong> to collect more than one Flow. To do so, you must collect them in parallel in different coroutines:</p>
			<pre class="source-code">class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">  override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">      ...</pre>
			<pre class="source-code">      lifecycleScope.launch {</pre>
			<pre class="source-code">          repeatOnLifecycle(Lifecycle.State.STARTED) {</pre>
			<pre class="source-code">              launch {</pre>
			<pre class="source-code">                 viewModel.fetchMovies().collect { movie -&gt;</pre>
			<pre class="source-code">                      Log.d("movies", "${movie.title}")</pre>
			<pre class="source-code">                    }</pre>
			<pre class="source-code">                }</pre>
			<pre class="source-code">              launch {</pre>
			<pre class="source-code">                  viewModel.fetchTVShows.collect { show -&gt;</pre>
			<pre class="source-code">                      Log.d("tv shows", "${show.title}")</pre>
			<pre class="source-code">                    }</pre>
			<pre class="source-code">                }</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Here, there are two Flows: one<a id="_idIndexMarker223"/> to collect the movies and the other to collect <a id="_idIndexMarker224"/>the TV shows. The collections of the Flow are started from separate <strong class="source-inline">launch</strong> coroutine builders.</p>
			<p>If you only have one Flow to collect, you can also use <strong class="source-inline">Flow.flowWithLifecycle</strong>. This emits values from the<a id="_idIndexMarker225"/> upstream Flow (the Flow and operators preceding the call) when the lifecycle is at least in <strong class="bold">Lifecycle.State.STARTED</strong> or the state you set. It uses <strong class="source-inline">Lifecycle.repeatOnLifecycle</strong> internally. You can use <strong class="source-inline">Flow.flowWithLifecycle</strong> as shown in the following code:</p>
			<pre class="source-code">class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        lifecycleScope.launch {</pre>
			<pre class="source-code">            viewModel.fetchMovies()          </pre>
			<pre class="source-code">                .flowWithLifecycle(lifecycle,</pre>
			<pre class="source-code">                  Lifecycle.State.STARTED)</pre>
			<pre class="source-code">                .collect { movie -&gt;</pre>
			<pre class="source-code">                    Log.d("movies", "${movie.title}")</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this example, you used <strong class="source-inline">flowWithLifecycle</strong> with <strong class="bold">Lifecycle.State.STARTED</strong> to start collecting the Flow of movies<a id="_idIndexMarker226"/> when the lifecycle is started and stop if the lifecycle is stopped.</p>
			<p>In this section, you have learned about using Kotlin Flows in your Android app. You can use Flow in Android Jetpack libraries such as Room and even in third-party libraries. To safely collect flows in the UI layer and prevent<a id="_idIndexMarker227"/> memory leaks and avoid wasting<a id="_idIndexMarker228"/> resources, you can use <strong class="source-inline">Lifecycle.repeatOnLifecycle</strong> and <strong class="source-inline">Flow.flowWithLifecycle</strong>.</p>
			<p>In the next section, we will be looking into the different Flow builders you can use to create Flows for your application.</p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor065"/>Creating Flows with Flow builders</h1>
			<p>In this section, we will start<a id="_idIndexMarker229"/> by looking at creating Flows. To create<a id="_idIndexMarker230"/> a Flow, you can use a Flow builder.</p>
			<p>The Kotlin Flow API has flow builders that you can use to create Flows. The following are the Kotlin Flow builders you can use:</p>
			<ul>
				<li><strong class="source-inline">flow {}</strong></li>
				<li><strong class="source-inline">flowOf()</strong></li>
				<li><strong class="source-inline">asFlow() </strong></li>
			</ul>
			<p>The <strong class="source-inline">flow</strong> builder function creates a new Flow from a suspendable lambda block. Inside the block, you can send values using the <strong class="source-inline">emit</strong> function. For example, this  <strong class="source-inline">fetchMovieTitles</strong> function of <strong class="source-inline">MovieViewModel</strong> returns <strong class="source-inline">Flow&lt;String&gt;</strong>:</p>
			<pre class="source-code">class MovieViewModel : ViewModel() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    fun fetchMovieTitles(): Flow&lt;String&gt; = flow {</pre>
			<pre class="source-code">        val movies = fetchMoviesFromNetwork()</pre>
			<pre class="source-code">        movies.forEach { movie -&gt; </pre>
			<pre class="source-code">            emit(movie.title)</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    private fun fetchMoviesFromNetwork(): List&lt;Movie&gt; {</pre>
			<pre class="source-code">         …</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this example, <strong class="source-inline">fetchMovieTitles</strong> created a Flow<a id="_idIndexMarker231"/> with the movie titles. It iterated<a id="_idIndexMarker232"/> over the list of movies from <strong class="source-inline">fetchMoviesFromNetwork</strong> and, for each movie, emitted the movie’s title with the <strong class="source-inline">emit</strong> function.</p>
			<p>With the <strong class="source-inline">flowOf</strong> function, you can create a Flow that produces the specified value or <strong class="source-inline">vararg</strong> values. In the following example, the <strong class="source-inline">flowOf</strong> function is used to create a Flow of the titles of the top three movies:</p>
			<pre class="source-code">class MovieViewModel : ViewModel() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    fun fetchTop3Titles(): Flow&lt;List&lt;Movie&gt;&gt; {</pre>
			<pre class="source-code">        val movies = fetchMoviesFromNetwork().sortedBy {</pre>
			<pre class="source-code">            it.popularity }</pre>
			<pre class="source-code">        return flowOf(movies[0].title, </pre>
			<pre class="source-code">            movies[1].title, </pre>
			<pre class="source-code">            movies[2].title)</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    private fun fetchMoviesFromNetwork(): List&lt;Movie&gt; {</pre>
			<pre class="source-code">        …</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Here, <strong class="source-inline">fetchTop3Titles</strong> uses <strong class="source-inline">flowOf</strong> to create a Flow containing the titles of the first three movies.</p>
			<p>The <strong class="source-inline">asFlow()</strong> extension function <a id="_idIndexMarker233"/>allows you to convert a type<a id="_idIndexMarker234"/> into a Flow. You can use this on sequences, arrays, ranges, collections, and functional types. For example, this <strong class="source-inline">MovieViewModel</strong> has <strong class="source-inline">fetchMovieIds</strong> that returns <strong class="source-inline">Flow&lt;Int&gt;</strong>, containing the movie IDs:</p>
			<pre class="source-code">class MovieViewModel : ViewModel() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    private fun fetchMovieIds(): Flow&lt;Int&gt; {</pre>
			<pre class="source-code">        val movies: List&lt;Movie&gt; = fetchMoviesFromNetwork()</pre>
			<pre class="source-code">        return movies.map { it.id }.asFlow()</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    private fun fetchMoviesFromNetwork(): List&lt;Movie&gt; {</pre>
			<pre class="source-code">        …</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this example, we used a <strong class="source-inline">map</strong> function on the list of movies to create a list of the movie IDs. The list of movie IDs was then converted to <strong class="source-inline">Flow&lt;String&gt;</strong> by using the <strong class="source-inline">asFlow()</strong> extension function on it.</p>
			<p>In this section, we learned <a id="_idIndexMarker235"/>how you can create Flows with Flow Builders. In the next<a id="_idIndexMarker236"/> section, we will check out the various Kotlin Flow operators you can use to transform, combine, and do more with Flows.</p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor066"/>Using operators with Flows </h1>
			<p>In this section, we will focus<a id="_idIndexMarker237"/> on the various Flow operators. Kotlin Flow has built-in<a id="_idIndexMarker238"/> operators that you can use with Flows. We can collect flows with terminal operators and transform Flows with Intermediate operators.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor067"/>Collecting Flows with terminal operators</h2>
			<p>In this section, we will explore the terminal operators<a id="_idIndexMarker239"/> you can use on Flows<a id="_idIndexMarker240"/> to start the collection of a Flow. The <strong class="source-inline">collect</strong> function we used in the previous examples is the most used terminal operator. However, there are other built-in terminal Flow operators.</p>
			<p>The following are the built-in terminal Flow operators you can use to start the collection of the Flow:</p>
			<ul>
				<li><strong class="source-inline">toList</strong>: Collects the Flow and converts it into a list</li>
				<li><strong class="source-inline">toSet</strong>: Collects the Flow and converts it into a set</li>
				<li><strong class="source-inline">toCollection</strong>: Collects the Flow and converts it into a collection</li>
				<li><strong class="source-inline">count</strong>: Returns the number of elements in the Flow</li>
				<li><strong class="source-inline">first</strong>: Returns the Flow’s first<a id="_idIndexMarker241"/> element or throws a <strong class="bold">NoSuchElementException</strong> if the Flow was empty</li>
				<li><strong class="source-inline">firstOrNull</strong>: Returns the Flow’s first element or null if the Flow was empty</li>
				<li><strong class="source-inline">last</strong>: Returns the Flow’s last element<a id="_idIndexMarker242"/> or throws a <strong class="bold">NoSuchElementException</strong> if the Flow was empty</li>
				<li><strong class="source-inline">lastOrNull</strong>: Returns the Flow’s last element or null if the Flow was empty</li>
				<li><strong class="source-inline">single</strong>: Returns the single element emitted or throws an exception if the Flow was empty or had more than one value</li>
				<li><strong class="source-inline">singleOrNull</strong>: Returns the single element emitted or null if the Flow was empty or had more than one value</li>
				<li><strong class="source-inline">reduce</strong>: Applies a function to each item emitted, starting from the first element, and returns the accumulated result</li>
				<li><strong class="source-inline">fold</strong>: Applies a function to each item emitted, starting from the initial value set, and returns the accumulated result</li>
			</ul>
			<p>These terminal Flow operators<a id="_idIndexMarker243"/> work like the Kotlin collection functions<a id="_idIndexMarker244"/> with the same name in the standard Kotlin library.</p>
			<p>In the following example, the <strong class="source-inline">firstOrNull</strong> terminal operator is used instead of the <strong class="source-inline">collect</strong> operator to collect the Flow from <strong class="source-inline">ViewModel</strong>:</p>
			<pre class="source-code">class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        lifecycleScope.launch {</pre>
			<pre class="source-code">            repeatOnLifecycle(Lifecycle.State.STARTED) {</pre>
			<pre class="source-code">                val topMovie =</pre>
			<pre class="source-code">                  viewModel.fetchMovies().firstOrNull()</pre>
			<pre class="source-code">                displayMovie(topMovie)</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Here, <strong class="source-inline">firstOrNull</strong> was used on the Flow to get the first item (or null if the Flow was empty), which represents the top movie. It will then be displayed on the screen.</p>
			<p>In this section, you learned<a id="_idIndexMarker245"/> about the Flow terminal operators<a id="_idIndexMarker246"/> you can use to start collecting from a Flow. In the next section, we will learn how to transform Flows with Intermediate operators.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor068"/>Transforming Flows with Intermediate operators</h2>
			<p>In this section, we will focus<a id="_idIndexMarker247"/> on Intermediate flow operators that you can<a id="_idIndexMarker248"/> use to transform Flows. With Intermediate operators, you can return a new Flow based on the original one.</p>
			<p>Intermediate operators allow you to modify a Flow and return a new one. You can chain various operators, and they will be applied sequentially.</p>
			<p>You can transform the Flow by applying operators on them, as you can do with Kotlin collections. The following Intermediate operators work similarly to the Kotlin collection functions with the same name:</p>
			<ul>
				<li><strong class="source-inline">filter</strong>: Returns a Flow that selects only the values from the Flow that meet the condition you passed</li>
				<li><strong class="source-inline">filterNot</strong>: Returns a Flow that selects only the values from the Flow that do not meet the condition you passed</li>
				<li><strong class="source-inline">filterNotNull</strong>: Returns a Flow that only includes values from the original Flow that are not null</li>
				<li><strong class="source-inline">filterIsInstance</strong>: Returns a Flow that only includes values from the Flow that are instances of the type you specified</li>
				<li><strong class="source-inline">map</strong>: Returns a Flow that includes values from the Flow transformed with the operation you specified</li>
				<li><strong class="source-inline">mapNotNull</strong>: Like <strong class="source-inline">map</strong> (transforms the Flow using the operation specified) but only includes values that are not null</li>
				<li><strong class="source-inline">withIndex</strong>: Returns a Flow that<a id="_idIndexMarker249"/> converts each value to an <strong class="bold">IndexedValue</strong> containing the index of the value and the value itself</li>
				<li><strong class="source-inline">onEach</strong>: Returns a Flow that performs the specified action on each value before they are emitted</li>
				<li><strong class="source-inline">runningReduce</strong>: Returns a Flow containing the accumulated values resulting from running the operation specified sequentially, starting with the first element</li>
				<li><strong class="source-inline">runningFold</strong>: Returns a Flow containing accumulated values resulting from running the operation specified sequentially, starting with the initial value set</li>
				<li><strong class="source-inline">scan</strong>: Like the <strong class="source-inline">runningFold</strong> operator</li>
			</ul>
			<p>There is also a <strong class="source-inline">transform</strong> operator<a id="_idIndexMarker250"/> that you can use to apply custom<a id="_idIndexMarker251"/> or complex operations. With the <strong class="source-inline">transform</strong> operator, you can emit values into the new Flow by calling the <strong class="source-inline">emit</strong> function with the value to send.</p>
			<p>For example, this <strong class="source-inline">MovieViewModel</strong> has a <strong class="source-inline">fetchTopMovieTitles</strong> function that uses <strong class="source-inline">transform</strong> to return a Flow with the top movies:</p>
			<pre class="source-code">class MovieViewModel : ViewModel() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    fun fetchTopMovies(): Flow&lt;Movie&gt; {</pre>
			<pre class="source-code">        return fetchMoviesFlow()</pre>
			<pre class="source-code">            .transform {</pre>
			<pre class="source-code">                if (it.popularity &gt; 0.5f) emit(it)</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this example, the <strong class="source-inline">transform</strong> operator was used in the Flow of movies to return a new Flow. The <strong class="source-inline">transform</strong> operator was used to emit only the list of movies whose popularity is higher than <strong class="source-inline">0.5</strong>, which means a popularity of more than 50%.</p>
			<p>There are also size-limiting operators that you can use with Flow. The following are some of these operators:</p>
			<ul>
				<li><strong class="source-inline">drop(x)</strong>: Returns a Flow that ignores the first <em class="italic">x</em> elements</li>
				<li><strong class="source-inline">dropWhile</strong>: Returns a Flow that ignores the first elements that meet the condition specified</li>
				<li><strong class="source-inline">take(x)</strong>: Returns a Flow containing the first <em class="italic">x</em> elements of the Flow</li>
				<li><strong class="source-inline">takeWhile</strong>: Returns a Flow that includes the first elements that meet the condition specified</li>
			</ul>
			<p>These size-limiting operators also function similarly to the Kotlin collection functions with the same name.</p>
			<p>In this section, we learned <a id="_idIndexMarker252"/>about Intermediate flow<a id="_idIndexMarker253"/> operators. Intermediate operators transform a Flow into a new Flow. In the next section, we will learn how to buffer and combine Kotlin Flows.</p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor069"/>Buffering and combining flows</h1>
			<p>In this section, we will learn about buffering<a id="_idIndexMarker254"/> and combining Kotlin Flows. You can buffer and combine<a id="_idIndexMarker255"/> Flows with Flow operators. Buffering allows Flow with long-running tasks to run independently and avoid race conditions. Combining allows you to join different sources of Flows before processing or displaying them on the screen.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor070"/>Buffering Kotlin Flows</h2>
			<p>In this section, we will learn<a id="_idIndexMarker256"/> about buffering Kotlin Flows. Buffering allows you to run data emission in parallel to the collection.</p>
			<p>Emitting and collecting data with Flow run sequentially. When a new value is emitted, it will be collected. Emission of a new value can only happen once the previous data has been collected. If the emission or the collection of data from the Flow takes a while to complete, the whole process will take a longer time. </p>
			<p>With buffering, you can make a Flow’s emission and collection of data run in parallel. There are three operators you can use to buffer Flows: </p>
			<ul>
				<li><strong class="source-inline">buffer</strong></li>
				<li><strong class="source-inline">conflate</strong></li>
				<li><strong class="source-inline">collectLatest</strong></li>
			</ul>
			<p><strong class="source-inline">buffer()</strong> allows the Flow to emit values while the data is still being collected. The emission and collection of data are run in separate coroutines, so it runs in parallel. The following is an example of how to use <strong class="source-inline">buffer</strong> with Flows:</p>
			<pre class="source-code">class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        lifecycleScope.launch {</pre>
			<pre class="source-code">            repeatOnLifecycle(Lifecycle.State.STARTED) {</pre>
			<pre class="source-code">                viewModel.fetchMovies()</pre>
			<pre class="source-code">                    .buffer()</pre>
			<pre class="source-code">                    .collect { movie -&gt;</pre>
			<pre class="source-code">                        processMovie(movie)</pre>
			<pre class="source-code">                    }   </pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Here, the <strong class="source-inline">buffer</strong> operator was added<a id="_idIndexMarker257"/> before calling <strong class="source-inline">collect</strong>. If the <strong class="source-inline">processMovie(movie)</strong> function in the collection takes longer, the Flow will emit and buffer the values before they are collected and processed.</p>
			<p><strong class="source-inline">conflate()</strong> is similar to the <strong class="source-inline">buffer()</strong> operator, except with <strong class="source-inline">conflate</strong>, the collector will only process the latest value emitted after the previous value has been processed. It will ignore the other values previously emitted. Here is an example of using <strong class="source-inline">conflate</strong> in a Flow:</p>
			<pre class="source-code">class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        lifecycleScope.launch {</pre>
			<pre class="source-code">            repeatOnLifecycle(Lifecycle.State.STARTED) {</pre>
			<pre class="source-code">                viewModel.getTopMovie()</pre>
			<pre class="source-code">                    .conflate()</pre>
			<pre class="source-code">                    .collect { movie -&gt;</pre>
			<pre class="source-code">                        processMovie(movie)</pre>
			<pre class="source-code">                    }   </pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this example, adding the <strong class="source-inline">conflate</strong> operator will allow us to only process the latest value from the Flow and call <strong class="source-inline">processMovie</strong> with that value.</p>
			<p><strong class="source-inline">collectLatest(action)</strong> is a terminal operator that will collect the Flow the same way as <strong class="source-inline">collect</strong>, but whenever a new value is emitted, it will restart the action and use this new value. Here is an example of using <strong class="source-inline">collectLatest</strong> in a Flow:</p>
			<pre class="source-code">class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        lifecycleScope.launch {</pre>
			<pre class="source-code">            repeatOnLifecycle(Lifecycle.State.STARTED) {</pre>
			<pre class="source-code">                viewModel.getTopMovie()</pre>
			<pre class="source-code">                    .collectLatest { movie -&gt;</pre>
			<pre class="source-code">                        displayMovie(movie)</pre>
			<pre class="source-code">                    }   </pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Here, <strong class="source-inline">collectLatest</strong> was used instead of the <strong class="source-inline">collect</strong> terminal operator to collect the flow from <strong class="source-inline">viewModel.getTopMovie()</strong>. Whenever a new value is emitted by this Flow, it will restart and call <strong class="source-inline">displayMovie</strong> with the new value.</p>
			<p>In this section, you learned<a id="_idIndexMarker258"/> how to buffer Kotlin Flows with <strong class="source-inline">buffer</strong>, <strong class="source-inline">conflate</strong>, and <strong class="source-inline">collectLatest</strong>. In the next section, you will learn about combining multiple Flows into a single Flow.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor071"/>Combining Flows</h2>
			<p>In this section, we will learn<a id="_idIndexMarker259"/> how we can combine Flows. The Kotlin Flow API has available operators that you can use to combine multiple flows.</p>
			<p>If you have multiple flows and you want to combine them into one, you can use the following Flow operators:</p>
			<ul>
				<li><strong class="source-inline">zip</strong></li>
				<li><strong class="source-inline">merge</strong></li>
				<li><strong class="source-inline">combine</strong></li>
			</ul>
			<p><strong class="source-inline">merge</strong> is a top-level function that combines the elements from multiple Flows of the same type into one. You can pass a <strong class="source-inline">vararg</strong> number of Flows to combine. This is useful when you have two or more sources of data that you want to merge first before collecting.</p>
			<p>In the following example, there are two Flows from <strong class="source-inline">viewModel.fetchMoviesFromDb</strong> and <strong class="source-inline">viewModel.fetchMoviesFromNetwork</strong> combined using <strong class="source-inline">merge</strong>:</p>
			<pre class="source-code">class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        lifecycleScope.launch {</pre>
			<pre class="source-code">            repeatOnLifecycle(Lifecycle.State.STARTED) {</pre>
			<pre class="source-code">                merge(viewModel.fetchMoviesFromDb(),</pre>
			<pre class="source-code">                  viewModel.fetchMoviesFromNetwork())</pre>
			<pre class="source-code">                    .collect { movie -&gt;</pre>
			<pre class="source-code">                        processMovie(movie)</pre>
			<pre class="source-code">                    }   </pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this example, <strong class="source-inline">merge</strong> was used to combine<a id="_idIndexMarker260"/> the Flows from <strong class="source-inline">viewModel.fetchMoviesFromDb</strong> and <strong class="source-inline">viewModel.fetchMoviesFromNetwork</strong> before they are collected.</p>
			<p>The <strong class="source-inline">zip</strong> operator pairs data from the first Flow to the second Flow into a new value using the function you specified. If one Flow has fewer values than the other, <strong class="source-inline">zip</strong> will end when the values of this Flow have all been processed.</p>
			<p>The following shows how you can use the <strong class="source-inline">zip</strong> operator to combine two Flows, <strong class="source-inline">userFlow</strong> and <strong class="source-inline">taskFlow</strong>:</p>
			<pre class="source-code">class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        lifecycleScope.launch {</pre>
			<pre class="source-code">            repeatOnLifecycle(Lifecycle.State.STARTED) {</pre>
			<pre class="source-code">                val userFlow = viewModel.getUsers()</pre>
			<pre class="source-code">                val taskFlow = viewModel.getTasks()</pre>
			<pre class="source-code">                userFlow.zip(taskFlow) { user, task -&gt;</pre>
			<pre class="source-code">                    AssignedTask(user, task)</pre>
			<pre class="source-code">                }.collect { assignedTask -&gt;</pre>
			<pre class="source-code">                    displayAssignedTask(assignedTask)</pre>
			<pre class="source-code">                }  </pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this example, you used <strong class="source-inline">zip</strong> to pair each value of <strong class="source-inline">userFlow</strong> to <strong class="source-inline">taskFlow</strong> and return a Flow of <strong class="source-inline">AssignedTask</strong> using the <strong class="source-inline">user</strong> and <strong class="source-inline">task</strong> values. This new Flow will be collected and then displayed with the <strong class="source-inline">displayAssignedTask</strong> function.</p>
			<p><strong class="source-inline">combine</strong> pairs data from the first<a id="_idIndexMarker261"/> flow to the second flow like <strong class="source-inline">zip</strong> but uses the most recent value emitted by each flow. It will continue to run as long as a Flow emits a value. There is also a top-level <strong class="source-inline">combine</strong> function that you can use for multiple flows.</p>
			<p>The following example shows how you can use the <strong class="source-inline">combine</strong> operator to join two Flows in your application:</p>
			<pre class="source-code">class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        lifecycleScope.launch {</pre>
			<pre class="source-code">            repeatOnLifecycle(Lifecycle.State.STARTED) {</pre>
			<pre class="source-code">                val yourMesssage =</pre>
			<pre class="source-code">                  viewModel.getLastMessageSent()</pre>
			<pre class="source-code">                val friendMessage =</pre>
			<pre class="source-code">                  viewModel.getLastMessageReceived()</pre>
			<pre class="source-code">                userFlow.combine(taskFlow) { yourMesssage,</pre>
			<pre class="source-code">                  friendMessage -&gt;</pre>
			<pre class="source-code">                    Conversation(yourMessage,</pre>
			<pre class="source-code">                      friendMessage)</pre>
			<pre class="source-code">                }.collect { conversation -&gt;</pre>
			<pre class="source-code">                    displayConversation(conversation)</pre>
			<pre class="source-code">                }  </pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Here, you have two Flows, <strong class="source-inline">yourMessage</strong> and <strong class="source-inline">friendMessage</strong>. The <strong class="source-inline">combine</strong> function pairs the most recent value of <strong class="source-inline">yourMessage</strong> and <strong class="source-inline">friendMessage</strong> to create a <strong class="source-inline">Conversation</strong> object. Whenever a new value is emitted by either Flow, <strong class="source-inline">combine</strong> will pair the latest values and add that to the resulting Flow for collection.</p>
			<p>In this section, we have explored how to combine<a id="_idIndexMarker262"/> Flows. In the next section, we will focus on <strong class="source-inline">StateFlow</strong> and <strong class="source-inline">SharedFlow</strong> and how we can use them in your Android applications.</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor072"/>Exploring StateFlow and SharedFlow</h1>
			<p>In this section, we will dive<a id="_idIndexMarker263"/> into <strong class="source-inline">StateFlow</strong> and <strong class="source-inline">SharedFlow</strong>. <strong class="source-inline">SharedFlow</strong> and <strong class="source-inline">StateFlow</strong> are Flows<a id="_idIndexMarker264"/> that are hot streams, unlike a normal Kotlin Flow, which are cold streams by default.</p>
			<p>A Flow is a cold stream of data. Flows only emit values when the values are collected. With <strong class="source-inline">SharedFlow</strong> and <strong class="source-inline">StateFlow</strong> hot streams, you can run and emit values the moment they are called and even when they have no listeners. <strong class="source-inline">SharedFlow</strong> and <strong class="source-inline">StateFlow</strong> are Flows, so you can also use operators on them.</p>
			<p>A <strong class="source-inline">SharedFlow</strong> allows you to emit values to multiple listeners. <strong class="source-inline">SharedFlow</strong> can be used for one-time events. The tasks that will be done by the <strong class="source-inline">SharedFlow</strong> will only be run once and will be shared by the listeners.</p>
			<p>You can use <strong class="source-inline">MutableSharedFlow</strong> and then use the <strong class="source-inline">emit</strong> function to send values to all the collectors.</p>
			<p>In the following example, <strong class="source-inline">SharedFlow</strong> is used in <strong class="source-inline">MovieViewModel</strong> for the list of movies fetched:</p>
			<pre class="source-code">class MovieViewModel : ViewModel() {</pre>
			<pre class="source-code">    private val _message = MutableSharedFlow&lt;String&gt;()</pre>
			<pre class="source-code">    val movies: SharedFlow&lt;String&gt; =</pre>
			<pre class="source-code">      _message.asSharedFlow()</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    fun onError(): Flow&lt;List&lt;Movie&gt;&gt; {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        _message.emit("An error was encountered")</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this example, we<a id="_idIndexMarker265"/> used <strong class="source-inline">SharedFlow</strong> for the message. We used the <strong class="source-inline">emit</strong> function to send the error<a id="_idIndexMarker266"/> message to the Flow’s listeners.</p>
			<p><strong class="source-inline">StateFlow</strong> is <strong class="source-inline">SharedFlow</strong>, but it only emits the latest value to its listeners. <strong class="source-inline">StateFlow</strong> is initialized with a value (an initial state) and keeps this state. You can change the value of <strong class="source-inline">StateFlow</strong> using the mutable version of <strong class="source-inline">StateFlow</strong>, <strong class="source-inline">MutableStateFlow</strong>. Updating the value sends the new value to the Flow.</p>
			<p>In Android, <strong class="source-inline">StateFlow</strong> can be an alternative to <strong class="source-inline">LiveData</strong>. You can use <strong class="source-inline">StateFlow</strong> for <strong class="source-inline">ViewModel</strong>, and your activity or fragment can then collect the value. For example, in the following <strong class="source-inline">ViewModel</strong>, <strong class="source-inline">StateFlow</strong> is used for the list of movies:</p>
			<pre class="source-code">class MovieViewModel : ViewModel() {</pre>
			<pre class="source-code">    private val _movies =</pre>
			<pre class="source-code">      MutableStateFlow(emptyList&lt;Movie&gt;())</pre>
			<pre class="source-code">    val movies: StateFlow&lt;List&lt;Movie&gt;&gt; = _movies</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    fun fetchMovies(): Flow&lt;List&lt;Movie&gt;&gt; {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        _movies.value = movieRepository.fetchMovies()</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In the preceding code, the list of movies<a id="_idIndexMarker267"/> fetched from the repository<a id="_idIndexMarker268"/> will be set to <strong class="source-inline">MutableStateFlow</strong> of <strong class="source-inline">_movies</strong>, which will also change <strong class="source-inline">StateFlow</strong> of <strong class="source-inline">movies</strong>. You can then collect <strong class="source-inline">StateFlow</strong> of <strong class="source-inline">movies</strong> in an activity or fragment, as shown in the following:</p>
			<pre class="source-code">class MainActivity : AppCompatActivity() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        lifecycleScope.launch {</pre>
			<pre class="source-code">            repeatOnLifecycle(Lifecycle.State.STARTED) {</pre>
			<pre class="source-code">                viewModel.movies.collect { movies -&gt;</pre>
			<pre class="source-code">                    displayMovies(movies)</pre>
			<pre class="source-code">                }   </pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Here, <strong class="source-inline">StateFlow</strong> of <strong class="source-inline">viewModel.movies</strong> will be collected, and then the list of movies will be displayed on the screen with the <strong class="source-inline">displayMovies</strong> function.</p>
			<p>In this section, we have learned about <strong class="source-inline">StateFlow</strong> and <strong class="source-inline">SharedFlow</strong> and how<a id="_idIndexMarker269"/> we can use them in our <a id="_idIndexMarker270"/>Android projects.</p>
			<p>Let’s try what we have learned so far by adding Kotlin Flow to an Android project.</p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor073"/>Exercise 5.01 – Using Kotlin Flow in an Android app</h1>
			<p>For this exercise, you will be continuing<a id="_idIndexMarker271"/> the movie app you worked <a id="_idIndexMarker272"/>on in <em class="italic">Exercise 4.01 – Adding tests to coroutines in an Android app</em>. This application displays the movies that are currently playing in cinemas. You will be adding Kotlin Flow to the project by following these steps:</p>
			<ol>
				<li>Open the movie app you worked on in <em class="italic">Exercise 4.01 – Adding tests to coroutines in an Android app</em> in Android Studio.</li>
				<li>Go to the <strong class="source-inline">MovieRepository</strong> class and add a new <strong class="source-inline">fetchMoviesFlow()</strong> function that uses a <strong class="source-inline">flow</strong> builder to return a Flow and emits the list of movies from <strong class="source-inline">MovieService</strong>, as shown in the following snippet:<p class="source-code">fun fetchMoviesFlow(): Flow&lt;List&lt;Movie&gt;&gt; {</p><p class="source-code">    return flow {</p><p class="source-code">        emit(movieService.getMovies(apiKey).results)</p><p class="source-code">    }.flowOn(Dispatchers.IO)</p><p class="source-code">}</p></li>
			</ol>
			<p>This is the same as the <strong class="source-inline">fetchMovies()</strong> function, but this function uses Kotlin Flow and will return <strong class="source-inline">Flow&lt;List&lt;Movie&gt;&gt;</strong> to the function or class that will collect it. The Flow will emit the list of movies from <strong class="source-inline">movieService.getMovies</strong>, and it will flow on the <strong class="source-inline">Dispatchers.IO</strong> dispatcher. </p>
			<ol>
				<li value="3">Open the <strong class="source-inline">MovieViewModel</strong> class, and replace the initialization of the <strong class="source-inline">movies</strong> <strong class="source-inline">LiveData</strong> that gets the value from <strong class="source-inline">movieRepository</strong> with the following lines:<p class="source-code">private val _movies =</p><p class="source-code">  MutableStateFlow(emptyList&lt;Movie&gt;())</p><p class="source-code">val movies: StateFlow&lt;List&lt;Movie&gt;&gt; = _movies</p></li>
			</ol>
			<p>This will allow you to use the value of the <strong class="source-inline">_movies</strong> <strong class="source-inline">MutableStateFlow</strong> as the value of the <strong class="source-inline">movies</strong> <strong class="source-inline">StateFlow</strong>, which you will change later when you have fetched the list of movies from the Flow in <strong class="source-inline">movieRepository</strong>.</p>
			<ol>
				<li value="4">Do the same for the <strong class="source-inline">error</strong> <strong class="source-inline">LiveData</strong>, and replace<a id="_idIndexMarker273"/> its initialization with the value<a id="_idIndexMarker274"/> from <strong class="source-inline">movieRepository</strong> with the following lines:<p class="source-code">private val _error = MutableStateFlow("")</p><p class="source-code">val error: StateFlow&lt;String&gt; = _error</p></li>
			</ol>
			<p>This will use the value of the <strong class="source-inline">_error</strong> <strong class="source-inline">MutableStateFlow</strong> for the <strong class="source-inline">error</strong> <strong class="source-inline">StateFlow</strong>. You will be able to change the value of this <strong class="source-inline">StateFlow</strong> later for handling the cases when the Flow encountered an exception.</p>
			<ol>
				<li value="5">Replace the <strong class="source-inline">loading</strong> and <strong class="source-inline">_loading</strong> variables with the following lines:<p class="source-code">private val _loading = MutableStateFlow(true)</p><p class="source-code">val loading: StateFlow&lt;String&gt; = _loading</p></li>
			</ol>
			<p>This will use the value of the <strong class="source-inline">_loading</strong> <strong class="source-inline">MutableStateFlow</strong> for the <strong class="source-inline">loading</strong> <strong class="source-inline">StateFlow</strong>. You will update this later to indicate that the loading of movies is ongoing.</p>
			<ol>
				<li value="6">Remove the <strong class="source-inline">fetchMovies()</strong> function and its content. You will be replacing this in the next step.</li>
				<li>Add a new <strong class="source-inline">fetchMovies()</strong> function that will collect the Flow from the <strong class="source-inline">movieRepository.fetchMoviesFlow</strong>, as shown in the following code block:<p class="source-code">fun fetchMovies() {</p><p class="source-code">    _loading.value = true</p><p class="source-code">    viewModelScope.launch (dispatcher) {</p><p class="source-code">        MovieRepository.fetchMoviesFlow()</p><p class="source-code">            .collect {</p><p class="source-code">                _movies.value = it</p><p class="source-code">                _loading.value = false</p><p class="source-code">            }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>This will collect the list of movies from <strong class="source-inline">movieRepository.fetchMoviesFlow</strong> and set it to the <strong class="source-inline">_movies</strong> <strong class="source-inline">MutableStateFlow</strong> and the <strong class="source-inline">movies</strong> <strong class="source-inline">StateFlow</strong>. This list of movies will then be displayed in <strong class="source-inline">MainActivity</strong>.</p>
			<ol>
				<li value="8">Open the <strong class="source-inline">app/build.gradle</strong> <a id="_idIndexMarker275"/>file. Add the following lines in the <a id="_idIndexMarker276"/>dependencies:<p class="source-code">implementation 'androidx.lifecycle:lifecycle-runtime-ktx:2.4.1'</p></li>
			</ol>
			<p>This will allow us to use <strong class="source-inline">lifecycleScope</strong> for collecting the flows in <strong class="source-inline">MainActivity</strong> later.</p>
			<ol>
				<li value="9">Open <strong class="source-inline">MainActivity</strong> and remove the lines of code that observe for the <strong class="source-inline">movies</strong>, <strong class="source-inline">error</strong>, and <strong class="source-inline">loading</strong> <strong class="source-inline">LiveData</strong>. Replace them with the following:<p class="source-code">lifecycleScope.launch {</p><p class="source-code">   repeatOnLifecycle(Lifecycle.State.STARTED) {</p><p class="source-code">       launch {</p><p class="source-code">           movieViewModel.movies.collect { movies -&gt;</p><p class="source-code">               movieAdapter.addMovies(movies)</p><p class="source-code">           }</p><p class="source-code">       }</p><p class="source-code">       launch {</p><p class="source-code">           movieViewModel.error.collect { error -&gt;</p><p class="source-code">               if (error.isNotEmpty())</p><p class="source-code">                 Snackbar.make(recyclerView, error, </p><p class="source-code">                 Snackbar.LENGTH_LONG).show()</p><p class="source-code">           }</p><p class="source-code">       }</p><p class="source-code">       launch {</p><p class="source-code">           movieViewModel.loading.collect { loading -&gt;</p><p class="source-code">               progressBar.isVisible = loading</p><p class="source-code">           }</p><p class="source-code">       }</p><p class="source-code">   }</p><p class="source-code">}</p></li>
			</ol>
			<p>This will collect <strong class="source-inline">movies</strong> and add them<a id="_idIndexMarker277"/> to the list, collect the <strong class="source-inline">error</strong> and display<a id="_idIndexMarker278"/> a <strong class="source-inline">SnackBar</strong> message if <strong class="source-inline">error</strong> is not empty, and collect <strong class="source-inline">loading</strong> and update <strong class="source-inline">progressBar</strong> based on its value.</p>
			<ol>
				<li value="10">Run the application. The app should still display a list of movies (with a poster and a title), as shown in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/Figure_5.1_B17773.jpg" alt="Figure 5.1 – The movie app with the list of movies&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – The movie app with the list of movies</p>
			<p>In this exercise, we have added Kotlin Flow<a id="_idIndexMarker279"/> in an Android app by creating a <strong class="source-inline">MovieRepository</strong> function that<a id="_idIndexMarker280"/> returns the list of movies as a Flow. This Flow was then collected by <strong class="source-inline">MovieViewModel</strong>.</p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor074"/>Summary</h1>
			<p>This chapter focused on using Kotlin Flows for asynchronous programming in Android. Flows are built on top of Kotlin coroutines. A flow can emit multiple values sequentially, instead of just a single value.</p>
			<p>We started with learning about how to use Kotlin Flows in your Android app. Jetpack libraries such as Room and some third-party libraries support Flow. To safely collect flows in the UI layer and prevent memory leaks and avoid wasting resources, you can use <strong class="source-inline">Lifecycle.repeatOnLifecycle</strong> and <strong class="source-inline">Flow.flowWithLifecycle</strong>.</p>
			<p>We then moved on to creating Flows with Flow builders. The <strong class="source-inline">flowOf</strong> function creates a Flow that emits the value or <strong class="source-inline">vararg</strong> values you provided. You can convert collections and functional types to Flow with the <strong class="source-inline">asFlow()</strong> extension function. The <strong class="source-inline">flow</strong> builder function creates a new Flow from a suspending lambda block, inside which you can send values with <strong class="source-inline">emit()</strong>.  </p>
			<p>Then, we explored Flow operators and learned how you can use them with Kotlin Flows. With terminal operators, you can start the collection of the Flow. Intermediate operators allow you to transform a Flow into another Flow. </p>
			<p>We then learned about buffering and combining Flows. With the <strong class="source-inline">buffer</strong>, <strong class="source-inline">conflate</strong>, and <strong class="source-inline">collectLatest</strong> operators, you can buffer Flows. You can combine Flows with the <strong class="source-inline">merge</strong>, <strong class="source-inline">zip</strong>, and <strong class="source-inline">combine</strong> Flow operators.</p>
			<p>We then explored <strong class="source-inline">SharedFlow</strong> and <strong class="source-inline">StateFlow</strong>. These can be used in your Android projects. With <strong class="source-inline">SharedFlow</strong>, you can emit values to multiple listeners. <strong class="source-inline">StateFlow</strong> is <strong class="source-inline">SharedFlow</strong> that only emits the latest value to its listeners.</p>
			<p>Finally, we worked on an exercise to add Kotlin Flows to an Android application. We used a Flow in <strong class="source-inline">MovieRepository</strong>, which was then collected in <strong class="source-inline">MovieViewModel</strong>.</p>
			<p>In the next chapter, we will focus on how to handle Kotlin Flows cancelations and exceptions in your application.</p>
		</div>
	</body></html>