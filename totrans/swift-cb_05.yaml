- en: Beyond the Standard Library
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 超越标准库
- en: Apple's intention when open-sourcing Swift was to provide a cross-platform,
    general-purpose programming language that is ready to use. The Swift standard
    library provides core language features and common collection types. However,
    this does not provide everything needed to get up and running.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果开源 Swift 的意图是提供一个跨平台、通用编程语言，它已经准备好使用。Swift 标准库提供了核心语言特性和常见集合类型。然而，这并不提供启动所需的所有内容。
- en: Therefore, Apple provides a framework called **Foundation** to help you perform
    common programming tasks that aren't covered by the core Swift language and the
    standard library.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，苹果提供了一个名为 **Foundation** 的框架，以帮助您执行核心 Swift 语言和标准库未涵盖的常见编程任务。
- en: 'The Foundation framework that you will use when developing for Apple platforms
    is *closed-sourced*, which means the underlying code is not accessible and only
    the API is visible. However, when Apple open-sourced Swift and made it available
    for Linux, it became necessary to provide the Foundation framework as well. To
    this end, Apple has released an open source, Swift-based version of Foundation
    as a core library, available here: [https://github.com/apple/swift-corelibs-foundation](https://github.com/apple/swift-corelibs-foundation).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在苹果平台上开发时，你将使用的 Foundation 框架是 *封闭源代码*，这意味着底层代码不可访问，只有 API 是可见的。然而，当苹果开源 Swift
    并使其对 Linux 可用时，提供 Foundation 框架变得必要。为此，苹果发布了一个开源的、基于 Swift 的 Foundation 版本，作为一个核心库，可在以下位置找到：[https://github.com/apple/swift-corelibs-foundation](https://github.com/apple/swift-corelibs-foundation)。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Comparing dates with Foundation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Foundation 比较日期
- en: Fetching data with `URLSession`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `URLSession` 获取数据
- en: Working with JSON
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 JSON
- en: Working with XML
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 XML
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code for this chapter can be found in this book's GitHub repository
    at [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter05](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter05)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码都可以在这本书的 GitHub 仓库中找到：[https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter05](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter05)
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3cIcNUK](https://bit.ly/3cIcNUK)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：[https://bit.ly/3cIcNUK](https://bit.ly/3cIcNUK)
- en: Comparing dates with Foundation
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Foundation 比较日期
- en: This recipe will focus on one area of Foundation that is very widely used, that
    is, date and time manipulation and formatting.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将专注于 Foundation 中一个非常广泛使用的领域，即日期和时间的操作和格式化。
- en: We will create a function that determines how long there is until Christmas
    and returns this information as a string that can be displayed to a user.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个函数，该函数确定离圣诞节还有多长时间，并将此信息作为字符串返回，以便向用户显示。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a new iOS playground and import the Foundation framework at the top
    of the playground:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的 iOS playground 中创建一个新的 playground，并在 playground 的顶部导入 Foundation 框架：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s create a function that will return a string telling us how long there
    is until Christmas that we can then print:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个函数，它会返回一个字符串，告诉我们离圣诞节还有多长时间，然后我们可以打印出来：
- en: 'Define the function:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义函数：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Within the function, get the current calendar and time zone:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数内部，获取当前的日历和时间区域：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Get the current date and time and use the calendar to get the current year:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取当前日期和时间，并使用日历获取当前年份：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Define date components that correspond to midnight on Christmas Day:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义与圣诞节午夜对应的日期组件：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Get a `Date` object from those components:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这些组件获取一个 `Date` 对象：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we have already passed Christmas for this year, we need to adjust the component
    to refer to Christmas of the next year:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们已经过了今年的圣诞节，我们需要调整组件以指向下一年的圣诞节：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create `DateComponentsFormatter` to format how the time until Christmas is
    displayed:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `DateComponentsFormatter` 来格式化显示到圣诞节的剩余时间：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Use `DateComponentFormatter` to return a string for the time between now and
    next Christmas:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `DateComponentFormatter` 返回从现在到下一个圣诞节的字符串：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Below the `howLongUntilChristmas` function, use this function to create a string,
    and print the outcome:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `howLongUntilChristmas` 函数下方，使用此函数创建一个字符串，并打印结果：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In *Step 1*, we create our `howLongUntilChristmas` function, then in *Step
    2*, we get the currently set calendar and time zone as they will be needed for
    the date calculations to come:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤1**中，我们创建了`howLongUntilChristmas`函数，然后在**步骤2**中，我们获取当前设置的日历和时间区域，因为它们将用于后续的日期计算：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: While retrieving the current time zone is self-explanatory, it is not immediately
    obvious what the `Calendar` type represents and why we need to retrieve it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 获取当前时区是显而易见的，但`Calendar`类型代表什么以及为什么需要检索它并不立即明显。
- en: How dates are represented is not as universally agreed as you might believe.
    Certain time components are mostly universal, such as the length of years and
    days, as they are connected to astronomical events, such as the time it takes
    for the Earth to perform one revolution of the Sun, and for the Earth to complete
    one rotation around its own axis, respectively. However, other time components,
    such as months and weeks and how the years are numbered, are rooted in the culture
    that created them.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 日期的表示方式并不像你想象的那样具有普遍性。某些时间组件大多是通用的，例如年份和天数的长度，因为它们与天文事件有关，例如地球围绕太阳公转一周所需的时间，以及地球围绕自身轴旋转一周所需的时间。然而，其他时间组件，如月份、周以及年份的编号，根植于创建它们的文明。
- en: The calendar used throughout Europe and most of the world is known as the **Gregorian
    calendar**, introduced in 1582 by Pope Gregory XIII, replacing the Julian calendar.
    There are about 40 different calendars currently in use around the world, including
    Gregorian, Chinese, Hebrew, Islamic, Persian, Ethiopian, and Balinese Pawukon.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 欧洲以及世界上大多数地区使用的日历被称为**格里高利日历**，由教皇格列高利十三世于1582年引入，取代了儒略日历。目前全球大约有40种不同的日历在使用中，包括格里高利日历、中国日历、希伯来日历、伊斯兰日历、波斯日历、埃塞俄比亚日历和巴厘岛Pawukon日历。
- en: The way in which we present how long there is until Christmas will depend on
    the calendar that is relevant to the user. This is why we ask for the current
    calendar, which the user can change if they want a different representation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示距离圣诞节还有多长时间的方式将取决于与用户相关的日历。这就是为什么我们要求用户提供当前日历，如果他们想要不同的表示方式，他们可以更改它。
- en: 'Our next task is to get the current date and time:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务是获取当前的日期和时间：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In *Step 3*, the default initializer for the `Date` value type uses the current
    date and time as its value. Note that this date value is set at the point of creation;
    it does not continually update with the current date and time.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤3**中，`Date`值类型的默认初始化器使用当前日期和时间作为其值。请注意，这个日期值是在创建时设置的；它不会随着当前日期和时间的更新而持续更新。
- en: 'In this step, we get a date and time for the next Christmas. We know the time,
    day, and month of Christmas, so to construct a date for Christmas, we just need
    to know the year. There is a method on `Calendar` called `component` that allows
    us to retrieve specific components from a `Date` value:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步，我们获取下一个圣诞节的日期和时间。我们知道圣诞节的时、日、月，因此要构建圣诞节的日期，我们只需要知道年份。`Calendar`类中有一个名为`component`的方法，允许我们从`Date`值中检索特定组件：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We now have the current year, within the user's current calendar; we can use
    it to create the Christmas date.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了用户当前日历中的当前年份；我们可以用它来创建圣诞节的日期。
- en: 'In *Step 4*, we create an instance of `DateComponents`, passing in the calendar,
    time zone, and the fact that we are defining December 25 at midnight, for the
    current year:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤4**中，我们创建了一个`DateComponents`实例，传递了日历、时区和我们将定义当前年份午夜12点的12月25日：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In *Step 5*, we create a `Date` object from `DateComponents`. This is of an
    optional type as we may not have provided enough information to the components
    to generate a date; however, since we know that we have, we can force-unwrap this
    optional:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤5**中，我们从`DateComponents`创建一个`Date`对象。这是一个可选类型，因为我们可能没有向组件提供足够的信息来生成日期；然而，由于我们知道我们已经提供了，我们可以强制展开这个可选类型：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we need to handle an edge case; what if we have already had Christmas
    this year? For example, let''s imagine that the current date is December 27, 2020;
    we are trying to find the date of the next Christmas, but if we use the current
    year, we will get December 25, 2020, which is the Christmas just gone. So, in
    *Step 6*, we add 1 to the current year to get next Christmas, December 25, 2021:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要处理一个边缘情况；如果我们今年已经过了圣诞节怎么办？例如，让我们想象当前日期是2020年12月27日；我们正在尝试找到下一个圣诞节的日期，但如果我们使用当前年份，我们将得到2020年12月25日，这是刚刚过去的圣诞节。因此，在**步骤6**中，我们将当前年份加1，得到下一个圣诞节，即2021年12月25日：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To account for this, we check whether the Christmas for this year is before
    `now`; if it is, we bump the year component to next year and recreate the Christmas
    date from `DateComponent`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们检查今年的圣诞节是否在 `now` 之前；如果是，我们将年份组件提升到下一年，并从 `DateComponent` 重新创建圣诞节日期。
- en: We now have the current `Date` and the next Christmas `Date`, and Foundation
    provides functionality to calculate the time difference between two dates and
    format it to display to a user, through the use of `DateComponentsFormatter`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了当前的 `Date` 和下一个圣诞节的 `Date`，Foundation 提供了通过使用 `DateComponentsFormatter`
    来计算两个日期之间时间差并将其格式化为用户显示的功能。
- en: 'In *Step 7*, we create `DateComponentsFormatter`, and set `unitStyle` to `full`,
    which will provide a string using the full unit name, without abbreviation. We
    configure how we want the date and time divided for display, using `allowedUnits`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 7* 中，我们创建 `DateComponentsFormatter`，并将 `unitStyle` 设置为 `full`，这将使用完整的单位名称提供字符串，而不使用缩写。我们配置我们想要如何将日期和时间分割以供显示，使用
    `allowedUnits`：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In *Step 8*, we can retrieve a string from the formatter that describes the
    time between the two dates given, with the settings provided to the formatter.
    Since `DateComponentsFormatter` returns an optional string, we unwrap and return
    it:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 8* 中，我们可以从格式化器中检索一个字符串，描述两个给定日期之间的时间，并使用提供给格式化器的设置。由于 `DateComponentsFormatter`
    返回一个可选字符串，我们解包并返回它：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Our `howLongUntilChristmas` method will provide a string describing how long
    until Christmas, which we can then print out.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `howLongUntilChristmas` 方法将提供一个描述距离圣诞节还有多久的字符串，然后我们可以将其打印出来。
- en: See also
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'There is a lot more to discover in Foundation, so check out the documentation
    for further functionality:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Foundation 中还有更多内容可以探索，因此请查看文档以了解更多功能：
- en: 'Swift 3 documentation for Foundation: [http://swiftbook.link/docs/foundation](http://swiftbook.link/docs/foundation)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift 3 对 Foundation 的文档：[http://swiftbook.link/docs/foundation](http://swiftbook.link/docs/foundation)
- en: 'Open source repository for Foundation: [https://github.com/apple/swift-corelibs-foundation](https://github.com/apple/swift-corelibs-foundation)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Foundation 的开源仓库：[https://github.com/apple/swift-corelibs-foundation](https://github.com/apple/swift-corelibs-foundation)
- en: Fetching data with URLSession
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 URLSession 获取数据
- en: Every app worth building will need to send or receive information from the internet
    at some point and therefore, networking support is a critical part of any development
    platform. In Swift, this support for networking is provided by the Foundation
    framework.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 每个值得构建的应用在某个时候都需要从互联网发送或接收信息，因此，网络支持是任何开发平台的关键部分。在 Swift 中，这种网络支持由 Foundation
    框架提供。
- en: When we need to retrieve information from the internet, we send out a request
    to a server on the internet, and that server sends a response that hopefully contains
    the information we requested.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要从互联网检索信息时，我们会向互联网上的一个服务器发送请求，然后该服务器发送一个响应，希望其中包含我们请求的信息。
- en: In this recipe, we will learn how to send network requests and receive a response
    using the Foundation framework.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用 Foundation 框架发送网络请求并接收响应。
- en: Getting ready
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'It is helpful to know of the different components that Foundation provides
    that deal with networking and what they do:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 了解 Foundation 提供的与网络相关的不同组件以及它们的功能是有帮助的：
- en: '`URL`: The address of a resource on a remote server. It contains information
    about the server and where the resource can be found on the server.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URL`：远程服务器上资源的地址。它包含有关服务器和资源在服务器上位置的信息。'
- en: '`URLRequest`: Represents the request that will be made to the remote server.
    Defines the URL of the resource, how the request should be sent, metadata in the
    form of headers, and data that should be sent with it.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URLRequest`：表示将要发送到远程服务器的请求。定义了资源的 URL、请求的发送方式、以头信息形式存在的元数据，以及应与之一起发送的数据。'
- en: '`URLSession`: Manages the communication with remote servers, holds the configuration
    for that communication, and creates and optimizes the underlying connections.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URLSession`：管理与远程服务器的通信，保存该通信的配置，并创建和优化底层连接。'
- en: '`URLSessionDataTask`: An object that manages the state of the request and delivers
    the response.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URLSessionDataTask`：一个管理请求状态并传递响应的对象。'
- en: '`URLResponse`: Holds the metadata of the response from the remote server.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URLResponse`：保存远程服务器响应的元数据。'
- en: How to do it...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s use these networking tools to retrieve an image from a remote server:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这些网络工具从远程服务器检索一个图像：
- en: 'Import `PlaygroundSupport` and set up indefinite execution for this playground:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `PlaygroundSupport` 并为这个游乐场设置无限执行：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Import Foundation and create an instance of `URLSession`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入Foundation并创建一个`URLSession`实例：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we will construct a request for a remote image:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将构造一个请求远程图像的请求：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now that we have our `URLRequest`, we can create a data task to retrieve the
    image from the remote server:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了`URLRequest`，我们可以创建一个数据任务来从远程服务器检索图像：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We will take the image data and put it in a `UIImage` object to display it.
    So, we need to import the `UIKit` framework, which provides `UIImage`. So, let''s
    import `UIKit` at the top of the playground:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将图像数据放入一个`UIImage`对象中以显示它。因此，我们需要导入`UIKit`框架，它提供了`UIImage`。所以，让我们在playground的顶部导入`UIKit`：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Check for image data in the completion handler and create a `UIImage` object:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在完成处理程序中检查图像数据并创建一个`UIImage`对象：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Call `resume` on the task to start it:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任务上调用`resume`以启动它：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s walk through the previously mentioned steps to understand what we are
    doing:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下之前提到的步骤，以了解我们在做什么：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Playgrounds** execute the code they contain from top to bottom. When the
    end of the playground page is reached, the playground stops executing. In our
    example, the task is created and started, but then the playground reaches the
    end of the page before the image has been fully retrieved, because this happens
    asynchronously. If the playground were to stop execution here, the completion
    handler would never be executed, and we wouldn''t see the image. This isn''t a
    problem in a normal app that is continually running while it is in use; it is
    just specific to how Swift playgrounds work.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**Playgrounds** 从顶部到底部执行它们包含的代码。当达到playground页面的末尾时，playground停止执行。在我们的例子中，任务被创建并启动，但然后playground在图像完全检索之前就到达了页面的末尾，因为这是异步发生的。如果playground在这里停止执行，完成处理程序将永远不会执行，我们就看不到图像。在正常应用程序中这不是问题，因为应用程序在使用时持续运行；这仅仅是Swift
    playgrounds的工作方式。'
- en: To solve this, we need to tell the playground that we don't want it to stop
    executing when it reaches the end of the page and instead, it should run indefinitely
    while we wait for the response to be received. This is done by importing the `PlaygroundSupport`
    framework in *Step 1* and setting `needsIndefiniteExecution` to be `true` on the
    current `PlaygroundPage`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要告诉playground我们不想它在到达页面末尾时停止执行，而应该在我们等待响应接收时无限期地运行。这是通过在*步骤1*中导入`PlaygroundSupport`框架并将当前`PlaygroundPage`的`needsIndefiniteExecution`设置为`true`来实现的。
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In *Step 2*, when creating `URLSession`, we pass in a `URLSessionConfiguration`
    object, which allows configuring the time it takes for a request to time out and
    cache responses, among other things. For our purposes, we will just use the default
    configuration.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，当创建`URLSession`时，我们传入一个`URLSessionConfiguration`对象，它允许配置请求超时时间和缓存响应等。对于我们的目的，我们将只使用默认配置。
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In *Step 3*, we will be requesting the image from the excellent webcomic *XKCD*
    ([http://xkcd.com](https://xkcd.com/)). We can create the URL from a string, and
    then create a `URLRequest` request from the URL.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们将从优秀的网络漫画*XKCD*（[http://xkcd.com](https://xkcd.com/)）请求图像。我们可以从一个字符串创建URL，然后从URL创建一个`URLRequest`请求。
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In *Step 4*, we do not create a data task directly; instead, we ask our `URLSession`
    instance to create the data task, and we pass in `URLRequest` and a completion
    handler. The completion handler will be fired once a response has been received
    from the remote server or some error has occurred.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，我们不是直接创建数据任务；相反，我们要求我们的`URLSession`实例创建数据任务，并传入`URLRequest`和一个完成处理程序。一旦从远程服务器收到响应或发生某些错误，完成处理程序将被触发。
- en: 'The completion handler has three inputs, all optional:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 完成处理程序有三个输入，都是可选的：
- en: '`data: Data`: The data returned in the body of the response; if our request
    was successful, this will contain our image data.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data: 数据`: 响应体中返回的数据；如果我们的请求成功，这将包含我们的图像数据。'
- en: '`response: URLResponse`: The response metadata, including response headers.
    If the request was over HTTP/HTTPS, then this will be `HTTPURLResponse`, which
    will contain the HTTP status code.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`response: URLResponse`: 响应元数据，包括响应头。如果请求是通过HTTP/HTTPS进行的，那么这将是一个`HTTPURLResponse`，它将包含HTTP状态码。'
- en: '`error: Error`: If the request was unsuccessful, due to a network issue, for
    example, this value will have the error, and the data and response value will
    be `nil`. If the request was successful, this error value will be `nil`.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error: 错误`: 如果请求由于网络问题等失败，此值将包含错误，数据和响应值将为`nil`。如果请求成功，此错误值将为`nil`。'
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In *Step 6*, we check for response data and turn it into an image. To do this,
    we will need to construct a `UIImage` object from the data. `UIImage` is a class
    that represents an image on iOS and can be found in the `UIKit` framework. So,
    we also needed to import `UIKit` at the top of the playground, as we have done
    in *Step 5*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤6**中，我们检查响应数据并将其转换为图像。为此，我们需要从数据中构建一个`UIImage`对象。`UIImage`是一个表示iOS上图像的类，可以在`UIKit`框架中找到。因此，我们也在沙盒的顶部导入了`UIKit`，就像我们在**步骤5**中所做的那样。
- en: Since we don't plan on doing anything with the image in this example, we are
    just going to view it in a playground preview; the compiler will complain if we
    assign it to a value that is never used. Therefore, we replace a normal value
    assignment with `_`, which allows the `UIImage` object to be generated without
    it being assigned to anything.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这个示例中不打算对图像做任何处理，我们只是将其在沙盒预览中查看；如果将其分配给一个永远不会使用的值，编译器将会报错。因此，我们用下划线`_`替换正常的值赋值，这样就可以生成`UIImage`对象，而无需将其分配给任何东西。
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In *Step 7*, we have created the data task to retrieve the image, but we need
    to actually start the task to make the request. To do that, we call `resume` on
    the task.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤7**中，我们已经创建了数据任务来检索图像，但我们需要实际启动任务来发出请求。为此，我们在任务上调用`resume`方法。
- en: 'When we run the playground, you will eventually see that the image value has
    been populated in the playground''s right sidebar, and you can click on the preview
    icon to see the image that has been downloaded:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行沙盒时，你最终会看到图像值已经在沙盒的右侧侧栏中填充，你可以点击预览图标来查看已下载的图像：
- en: '![](img/9a63cd3c-f4ae-46ec-a564-9bbcbcbc458f.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9a63cd3c-f4ae-46ec-a564-9bbcbcbc458f.png)'
- en: Figure 5.1 – Retrieved image displayed in the playground timeline
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 在沙盒时间轴中显示检索到的图像
- en: See also
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'Further information about networking can be found in Apple''s networking overview:
    [http://swiftbook.link/docs/networking](http://swiftbook.link/docs/networking)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于网络的信息可以在Apple的网络概述中找到：[http://swiftbook.link/docs/networking](http://swiftbook.link/docs/networking)
- en: 'More information can also be found in Apple''s URL Session programming guide:
    [http://swiftbook.link/docs/urlsession-guide](http://swiftbook.link/docs/urlsession-guide)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多信息也可以在Apple的URL Session编程指南中找到：[http://swiftbook.link/docs/urlsession-guide](http://swiftbook.link/docs/urlsession-guide)
- en: Working with JSON
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理JSON
- en: As discussed in the last recipe, almost every app will need to exchange information
    with the internet at some point, and in that recipe, we retrieved an image from
    a remote server. Very often, your app will need to retrieve more varied data,
    perhaps relating to the result of a search, or information about a shared state
    held on the server.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如上一次教程中所述，几乎每个应用程序在某个时候都需要与互联网交换信息，在上一次教程中，我们从远程服务器检索了一个图像。通常，你的应用程序需要检索更多样化的数据，可能涉及搜索结果或服务器上存储的共享状态信息。
- en: This information can be represented in any number of ways, but one of the most
    common ways is as **JavaScript Object Notation** (**JSON**), which is a text-based
    structure for representing information. A JSON object contains key-value pairs,
    where the keys are strings and the values can be strings, numbers, Booleans, null,
    other objects, or arrays.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这种信息可以用多种方式表示，但最常见的方式之一是**JavaScript对象表示法**（**JSON**），它是一种基于文本的结构，用于表示信息。一个JSON对象包含键值对，其中键是字符串，值可以是字符串、数字、布尔值、null、其他对象或数组。
- en: 'For example, information about a person could be expressed with this JSON object:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，关于一个人的信息可以用这个JSON对象来表示：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following is an example of an array of JSON objects:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的例子是一个JSON对象的数组：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Foundation provides tools for reading information from and writing information
    as JSON data. In this recipe, we will interact with a JSON-based **Application
    Programming Interface** (**API**), to both send and receive information.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 基础库提供了从JSON数据中读取信息和将信息写入JSON数据的工具。在本教程中，我们将与一个基于JSON的**应用程序编程接口**（**API**）进行交互，以发送和接收信息。
- en: Getting ready
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Our goal is to interact with the GitHub API and create an issue for this book's
    repository. A full explanation of Git and GitHub is beyond the scope of this book;
    suffice to say that it's a service that stores versioned copies of your source
    code. Resources relevant to this book are stored in repositories on GitHub, and
    a GitHub user can create *issues* that serve as bug reports or feature requests.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是与 GitHub API 交互，并为这本书的仓库创建一个 issue。Git 和 GitHub 的完整解释超出了本书的范围；简单来说，它是一个存储你源代码版本副本的服务。与本书相关的资源存储在
    GitHub 上的仓库中，GitHub 用户可以创建 *issue*，这些 issue 可以作为错误报告或功能请求。
- en: 'If you don''t already have one, then you will need to sign up for a GitHub
    account:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有一个账户，那么你需要注册一个 GitHub 账户：
- en: Go to [https://github.com](https://github.com).
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 [https://github.com](https://github.com)。
- en: Fill in your details and press Sign up for GitHub.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写你的详细信息并点击“注册 GitHub”。
- en: 'Once you have created a GitHub account, you will need to create a personal
    access token, which we will use to authenticate some of the requests to the GitHub
    API. To create a personal access token, use the following steps:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了 GitHub 账户，你需要创建一个个人访问令牌，我们将使用它来验证对 GitHub API 的一些请求。要创建个人访问令牌，请按照以下步骤操作：
- en: Go to the settings page ([https://github.com/settings/tokens](https://github.com/settings/tokens))
    and click on Generate new token.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往设置页面 ([https://github.com/settings/tokens](https://github.com/settings/tokens))
    并点击“生成新令牌”。
- en: 'Give the token a name and check the box next to repo:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给令牌起一个名字，并勾选旁边的 repo：
- en: '![](img/3e4a5de2-cf58-4ddb-9e9d-8a7b33dcdeb8.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3e4a5de2-cf58-4ddb-9e9d-8a7b33dcdeb8.png)'
- en: Figure 5.2 – Creating a personal access token
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 创建个人访问令牌
- en: Click on Generate token at the bottom of the page. You will now see your newly
    generated personal access token.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击页面底部的“生成令牌”。现在你将看到你新创建的个人访问令牌。
- en: 'Copy this token and paste it somewhere, as we will need it later:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制这个令牌并将其粘贴到某个地方，因为我们稍后会需要它：
- en: '![](img/cf6a82d4-b33c-4222-b7aa-e722f882dccf.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cf6a82d4-b33c-4222-b7aa-e722f882dccf.png)'
- en: Figure 5.3 – The generated personal access token
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 生成的个人访问令牌
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: To create our issue, we will first retrieve all of Packt Publishing's public
    repositories, and then find the relevant repository for this book. We will then
    create a new issue in this repository.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的 issue，我们首先将检索 Packt Publishing 的所有公共仓库，然后找到这本书的相关仓库。然后我们将在该仓库中创建一个新的
    issue。
- en: 'As in the preceding recipe, we will need a `URLSession` object to perform our
    requests, and we need to tell the playground not to finish executing when it reaches
    the end of the playground:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的配方中所述，我们需要一个 `URLSession` 对象来执行我们的请求，并且我们需要告诉游乐场在执行到游乐场的末尾时不要结束执行：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Our first step is to fetch all the public repositories for a given user:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是获取给定用户的所有公共仓库：
- en: 'Let''s create a function to do that:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个函数来做这件事：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You will note that after creating `URLRequest`, we set an HTTP header; this
    particular header ensures that we will always get back version 3 of the GitHub
    API.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在创建 `URLRequest` 之后，我们设置了一个 HTTP 头部；这个特定的头部确保我们总是能够获取到 GitHub API 的第 3
    版。
- en: We know from the GitHub API documentation ([https://developer.github.com/v3/](https://developer.github.com/v3/))
    that this response data is in JSON format. We need to parse the JSON data to turn
    it into something that we can use; enter `JSONSerialization`. `JSONSerialization`
    is part of the Foundation framework and provides class methods for turning Swift
    dictionaries and arrays into JSON data (known as **serialization**) and back again
    (known as **deserialization**).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 GitHub API 文档 ([https://developer.github.com/v3/](https://developer.github.com/v3/))
    中知道，这个响应数据是 JSON 格式。我们需要解析 JSON 数据，将其转换成我们可以使用的东西；输入 `JSONSerialization`。`JSONSerialization`
    是 Foundation 框架的一部分，它提供了将 Swift 字典和数组转换为 JSON 数据（称为 **序列化**）以及将其转换回（称为 **反序列化**）的方法。
- en: 'Let''s use `JSONSerialization` to turn our JSON response data into something
    more useful:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用 `JSONSerialization` 将我们的 JSON 响应数据转换成更有用的东西：
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, let''s fetch the public Packt repositories by executing our function and
    passing `PacktPublishing` in as the GitHub username:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过执行我们的函数并传递 `PacktPublishing` 作为 GitHub 用户名来获取公共 Packt 仓库：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Once executed, the print output should look like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，打印输出应该看起来像这样：
- en: '![](img/444dcf8e-5bf3-4543-86fb-3b16f86ca331.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/444dcf8e-5bf3-4543-86fb-3b16f86ca331.png)'
- en: Figure 5.4 – Public GitHub repositories API response
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 公共 GitHub 仓库 API 响应
- en: '`JSONSerializer` has turned our JSON data into familiar arrays and dictionaries
    that can be used to retrieve the information we need in the normal way. The JSON
    data is deserialized with the `Any` type, as the JSON can have a JSON object or
    an array at its root.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSONSerializer`已将我们的JSON数据转换为熟悉的数组和字典，我们可以用正常方式检索所需的信息。JSON数据以`Any`类型反序列化，因为JSON的根可以是JSON对象或数组。'
- en: 'Since, from the preceding output, we know that the response has an array of
    JSON objects at its root, we need to turn the value from type `Any` to an array
    of dictionaries of the `[String: Any]` type. This is referred to as **casting**
    from one type to another, which we can do by using the `as` keyword and then specifying
    the new type. This keyword can be used in three different ways:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '由于从前面的输出中我们知道响应的根是一个JSON对象的数组，我们需要将值从`Any`类型转换为`[String: Any]`类型的字典数组。这被称为从一种类型到另一种类型的**类型转换**，我们可以通过使用`as`关键字并指定新类型来实现。此关键字可以用三种不同的方式使用：'
- en: '`as` will perform a trivial cast. This is possible if the existing type is
    synonymous with the intended type, for instance, casting from a subclass to a
    superclass.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`as`将执行平凡的类型转换。如果现有类型与预期类型同义，则这是可能的，例如，从子类到超类的类型转换。'
- en: '`as?` will conditionally perform a cast, returning an optional value. If it
    is not possible to represent the value as the intended type, the value will be
    `nil`.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`as?`将条件执行类型转换，返回一个可选值。如果无法将值表示为预期类型，则该值将为`nil`。'
- en: '`as!` will perform a forced cast. If it is not possible to represent the value
    as the intended type, you will get a crash.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`as!`将执行强制类型转换。如果无法将值表示为预期类型，您将遇到崩溃。'
- en: 'So, let''s cast the deserialized data to an array of dictionaries with string
    keys, with the `[[String: Any]]` type:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，让我们将反序列化数据转换为具有字符串键的字典数组，类型为`[[String: Any]]`：'
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, we have an array of dictionaries for the repositories in the API response,
    which we need to provide as input for this function. A common pattern for providing
    results for asynchronous work is to provide a completion handler as a parameter.
    A completion handler is a closure that can be executed once the asynchronous work
    is completed.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了API响应中存储库的字典数组，我们需要将其作为输入提供给此函数。提供异步工作结果的一个常见模式是提供一个完成处理程序作为参数。完成处理程序是一个闭包，可以在异步工作完成后执行。
- en: 'Since the output we want to provide is the array of repository dictionaries,
    we will define this as an input for the closure if the request was successful,
    and an error if it wasn''t:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要提供的输出是存储库字典的数组，因此如果请求成功，我们将将其定义为闭包的输入，如果不成功，则为错误：
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, whenever an error is generated, we execute `completionHandler`, passing
    in the error and `nil` for the results value. Also, when we have the repository
    results, we execute the completion handler, passing in the parsed JSON and `nil`
    for the error.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当生成错误时，我们执行`completionHandler`，传入错误和`nil`作为结果值。此外，当我们有存储库结果时，我们执行完成处理程序，传入解析后的JSON和`nil`作为错误。
- en: 'We passed in a few new errors in the preceding code, so let''s define those
    errors:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们传递了一些新的错误，因此让我们定义这些错误：
- en: '[PRE39]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This changes how we call this `fetchRepos` function:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这改变了我们调用此`fetchRepos`函数的方式：
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now that we have retrieved the details of the public repositories, we will submit
    an issue to the repository for this chapter. This issue can be any feedback you
    would like to give about this book; it can be a review, a suggestion for new content,
    or you can tell me about a Swift project you are currently working on.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经检索了公共存储库的详细信息，我们将为此章节的存储库提交一个问题。这个问题可以是您对本书的任何反馈；它可以是评论、对新内容的建议，或者您可以告诉我您目前正在进行的Swift项目。
- en: This request to the GitHub API will be authenticated against your user account
    and therefore, we will need to include details of the personal access token that
    we created at the beginning of this recipe. There are a number of ways to authenticate
    requests to the GitHub API, but the simplest is basic authentication, which involves
    adding an authorization string to the request header.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此对GitHub API的请求将针对您的用户账户进行身份验证，因此我们需要包括我们在本食谱开头创建的个人访问令牌的详细信息。有几种方式可以验证对GitHub
    API的请求，但最简单的是基本身份验证，这涉及到在请求头中添加一个授权字符串。
- en: 'Let''s create a method to format the personal access token correctly for authentication:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个方法来正确格式化个人访问令牌以进行身份验证：
- en: '[PRE41]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, let''s create our function to submit our issue. From the API documentation
    at [https://developer.github.com/v3/issues/#create-an-issue](https://developer.github.com/v3/issues/#create-an-issue),
    we can see that unless you have push access, you can only create an issue with
    the following components:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个提交问题的函数。从[https://developer.github.com/v3/issues/#create-an-issue](https://developer.github.com/v3/issues/#create-an-issue)的API文档中，我们可以看到，除非你有推送权限，否则你只能使用以下组件创建一个问题：
- en: '`title` (required)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`（必需）'
- en: '`body` (optional)'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`body`（可选）'
- en: 'So, our function will take this information as input, along with the repository
    name and username:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的函数将接受这些信息作为输入，包括仓库名和用户名：
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Creating an issue is achieved by sending a `POST` request, and information
    about the issue is provided as JSON data in the request body. To create our request,
    we can use `JSONSerialization`, but we will take our intended JSON structure and
    serialize it into `Data` this time:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 创建问题是通过发送一个`POST`请求来实现的，问题信息作为JSON数据在请求体中提供。为了创建我们的请求，我们可以使用`JSONSerialization`，但这次我们将我们的预期JSON结构序列化为`Data`：
- en: '[PRE43]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'As with the previous API request, we need a way to provide the result of creating
    the issue, so let''s provide a completion handler, try to deserialize the response,
    and provide it to the completion handler:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的API请求一样，我们需要一种方式来提供创建问题的结果，所以让我们提供一个完成处理程序，尝试反序列化响应，并将其提供给完成处理程序：
- en: '[PRE44]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The API response to a successfully created issue provides a JSON representation
    of that issue. Our function will return this representation if it was successful,
    or an error if it was not.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 成功创建问题的API响应提供了一个该问题的JSON表示。如果成功，我们的函数将返回这个表示，如果不成功，则返回一个错误。
- en: 'Now that we have a function to create issues in a repository, it''s time to
    use it to create an issue:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个在仓库中创建问题的函数，是时候使用它来创建一个问题了：
- en: '[PRE45]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: I will check these created issues, so please provide genuine feedback on this
    book. How have you found the content? Too detailed? Not detailed enough? Anything
    I've missed or not fully explained? Any questions that you have? This is your
    opportunity to let me know.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我将检查这些创建的问题，所以请就这本书提供真实的反馈。你发现内容如何？太详细了吗？不够详细？我遗漏了什么或没有完全解释清楚的地方？你有什么问题吗？这是你让我知道的机会。
- en: There's more...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'When we created our completion handlers, we gave them two inputs: the successful
    result (either the repository information or the created issue) or an error if
    there is a failure. Both these values are optional; one will be `nil`, and the
    other has a value. However, this convention is not enforced by the language, and
    a user of this function will have to consider the possibility that it may not
    be the case. What should the user of this function do if the `fetchRepos` function
    fires the completion handler with non-`nil` values for both the repository and
    the error? What if both are `nil`?'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建我们的完成处理程序时，我们给了它们两个输入：成功的结果（要么是仓库信息，要么是创建的问题）或者如果有失败，则是一个错误。这两个值都是可选的；一个将是`nil`，另一个有值。然而，这种约定并不是由语言强制执行的，使用这个函数的用户必须考虑它可能不是这种情况的可能性。如果`fetchRepos`函数在仓库和错误都带有非`nil`值时触发完成处理程序，函数的使用者应该怎么做？如果两者都是`nil`呢？
- en: The user of this function, without viewing the function's internal code, can't
    be sure that this won't happen, which means they may need to write functionality
    and tests to account for this possibility, even though it may never happen.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数的用户，即使没有查看函数的内部代码，也不能确定这种情况不会发生，这意味着他们可能需要编写功能性和测试来处理这种可能性，即使这种情况可能永远不会发生。
- en: 'It would be better if we could more accurately represent the intended behavior
    of our function, providing the user with a clear indication of the possible outcomes
    and leaving no room for ambiguity. We know that there are two possible outcomes
    from calling the function: it will either succeed and return the relevant value,
    or it will fail and return an error to indicate the reason for the failure.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能更准确地表示我们函数的预期行为，为用户提供清晰的可能的输出指示，不留任何歧义，那就更好了。我们知道从调用函数中会有两种可能的输出：它要么成功并返回相关值，要么失败并返回一个错误来指示失败的原因。
- en: Instead of optional values, we can use an enum to represent these possibilities,
    and the Foundation framework provides a generic enum for this purpose, called
    `Result`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用可选值，我们可以使用枚举来表示这些可能性，Foundation框架提供了一个通用的枚举用于此目的，称为`Result`。
- en: The `Result` enum has a `success` case, which has an associated type for a successful
    result, and a `failure` case with an associated type for the relevant error. Both
    associated types are defined as generic constraints, with the failure type needing
    to conform to the `Error` protocol.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`Result`枚举有一个`success`情况，它有一个关联类型用于成功的结果，以及一个`failure`情况，它有一个关联类型用于相关的错误。这两个关联类型都被定义为泛型约束，其中失败类型需要遵守`Error`协议。'
- en: We can now define the success and failure states and use associated values to
    hold the value that is relevant for each state, which is the repository information
    for the success state and the error for the failure state.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以定义成功和失败状态，并使用关联值来保存每个状态相关的值，对于成功状态是仓库信息，对于失败状态是错误。
- en: 'Now, let''s amend our `fetchRepos` function to provide a `Result` enum in `completionHandler`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修改`fetchRepos`函数，使其在`completionHandler`中提供`Result`枚举：
- en: '[PRE46]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We need to update how we call the `fetchRepos` function:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更新调用`fetchRepos`函数的方式：
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We now use a `switch` statement instead of `if/else`, and we get the added benefit
    that the compiler will ensure that we have covered all possible outcomes.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在使用`switch`语句而不是`if/else`，并且我们得到一个额外的好处，编译器将确保我们已经覆盖了所有可能的结果。
- en: 'Having made this improvement to the `fetchRepos` function, we can similarly
    improve the `createIssue` function:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在对`fetchRepos`函数进行了这次改进之后，我们可以类似地改进`createIssue`函数：
- en: '[PRE48]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Lastly, we need to update the contents of the completion handler that we provide
    to the `createIssue` function:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更新提供给`createIssue`函数的完成处理器的内容：
- en: '[PRE49]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Working with JSON data and extracting relevant information from it can be frustrating.
    Consider the JSON response for our `fetchRepos` function:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 处理JSON数据和从中提取相关信息可能会令人沮丧。考虑我们`fetchRepos`函数的JSON响应：
- en: '[PRE50]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If we want to get the username for the owner of the first repository, we need
    to deserialize the JSON and then conditionally unwrap multiple nested layers to
    get the username string:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要获取第一个仓库所有者的用户名，我们需要反序列化JSON，然后有条件地解包多层嵌套以获取用户名字符串：
- en: '[PRE51]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: That's a lot of optional unwrapping and casting just to get one value! Swift's
    strongly typed nature doesn't work well with JSON's loosely defined schema, which
    is why you have to do a lot of work to turn loosely typed information into strongly
    typed values.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 只为了获取一个值，就需要进行大量的可选解包和类型转换！Swift的强类型特性与JSON的松散定义模式不太兼容，这就是为什么你需要做很多工作才能将松散类型的信息转换为强类型值。
- en: To help with these problems, a number of open source frameworks are available,
    which make working with JSON in Swift easier. `SwiftyJSON` is a popular framework
    that can be found on GitHub at [https://github.com/SwiftyJSON/SwiftyJSON](https://github.com/SwiftyJSON/SwiftyJSON).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助解决这些问题，有一些开源框架可供使用，这些框架使得在Swift中使用JSON变得更加容易。`SwiftyJSON`是一个流行的框架，可以在GitHub上找到，网址为[https://github.com/SwiftyJSON/SwiftyJSON](https://github.com/SwiftyJSON/SwiftyJSON)。
- en: I have also built a lightweight JSON helper called `JSONNode`, which can also
    be found on GitHub at [https://github.com/keefmoon/JSONnode](https://github.com/keefmoon/JSONnode).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我还构建了一个轻量级的JSON辅助工具，名为`JSONNode`，也可以在GitHub上找到，网址为[https://github.com/keefmoon/JSONnode](https://github.com/keefmoon/JSONnode)。
- en: 'With `JSONNode`, you can perform the same task of retrieving the owner''s username
    for the first repository with the following code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`JSONNode`，你可以用以下代码执行相同的任务，即检索第一个仓库的所有者的用户名：
- en: '[PRE52]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Information within JSON, of any depth, can be retrieved in one line using subscripts.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: JSON中的信息，无论深度如何，都可以使用子脚本来在一行中检索。
- en: Working with XML
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理XML
- en: '**XML** stands for **eXtensible Markup Language** and is a popular way of representing
    data for storage and transfer across a network. XML is a very flexible format
    and is used to represent many types of data. The current specification of HTML,
    which powers most of the web, is an implementation of XML.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**XML**代表**可扩展标记语言**，是一种在网络上存储和传输数据时表示数据的方式。XML是一个非常灵活的格式，用于表示许多类型的数据。当前HTML的规范，它驱动着大部分的网页，是XML的一个实现。'
- en: The version of XML that we will concern ourselves with in this recipe is **RSS**,
    which stands for **Really Simple Syndication**. RSS is used to define a collection
    of time-ordered pieces of digestible content; these RSS feeds can then be used
    to aggregate content from a number of different sources. RSS is typically used
    as a distribution mechanism for news articles and podcasts.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将关注的XML版本是**RSS**，代表**Really Simple Syndication**。RSS用于定义一组按时间顺序排列的可消化的内容；然后可以使用这些RSS源从多个不同的来源聚合内容。RSS通常用作新闻文章和播客的发布机制。
- en: In this recipe, we will learn how to read and write XML data by fetching and
    parsing the BBC News RSS feed.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何通过获取和解析BBC新闻RSS源来读取和写入XML数据。
- en: Getting ready
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The functionality to deal with XML data is provided by the Foundation framework.
    However, while the classes that help with reading XML data are available on all
    of Apple's platforms, the classes that assist with writing XML data are only available
    on the macOS platform.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 处理XML数据的功能由Foundation框架提供。然而，尽管帮助读取XML数据的类在苹果的所有平台上都可用，但帮助写入XML数据的类仅在macOS平台上可用。
- en: This is an unfortunate oversight and means that if you need to write XML data
    within an iOS app, you will likely need to look for a third-party helper or build
    your own. We will investigate third-party helpers at the end of this recipe.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不幸的疏忽，这意味着如果你需要在iOS应用中写入XML数据，你可能会需要寻找第三方助手或自己构建。我们将在本食谱的末尾调查第三方助手。
- en: To investigate both reading and writing XML using the Foundation framework,
    we need to create a new macOS-based playground instead of an iOS-based playground,
    which we have been using so far in this book.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Foundation框架调查读取和写入XML，我们需要创建一个新的基于macOS的游乐场，而不是像本书中迄今为止所使用的那样基于iOS的游乐场。
- en: 'Create a new Swift playground as usual, but choose a Blank template from the
    macOS tab:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 按照常规创建一个新的Swift游乐场，但请从macOS选项卡中选择空白模板：
- en: '![](img/a958f28d-123d-464f-9a57-0a9754f2b163.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a958f28d-123d-464f-9a57-0a9754f2b163.png)'
- en: Figure 5.5 – Choosing a template
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 选择模板
- en: The RSS feed that we will retrieve and parse is from the front page of the BBC
    News website, which is [http://feeds.bbci.co.uk/news/rss.xml](http://feeds.bbci.co.uk/news/rss.xml).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要检索和解析的RSS源来自BBC新闻网站首页，其网址为[http://feeds.bbci.co.uk/news/rss.xml](http://feeds.bbci.co.uk/news/rss.xml)。
- en: 'Our first step is to retrieve the data at this URL so that we can start making
    sense of it. Since we previously covered retrieving information over the network,
    I''ll add the code without further comment; check out the *Fetching data with
    URLSession* recipe in this chapter for more information:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是从这个URL检索数据，这样我们就可以开始理解它了。由于我们之前已经介绍了通过网络检索信息，我将添加代码而不做进一步说明；查看本章中的*使用URLSession获取数据*食谱以获取更多信息：
- en: '[PRE53]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'When you run the playground, you will get an output that looks like the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行游乐场时，你会得到一个如下所示的输出：
- en: '[PRE54]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How to do it...
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The overall structure should be familiar to anyone who has seen HTML. Apart
    from the first two lines, which define the version and formatting of the XML,
    the information is structured with opening and closing tags. Consider the following
    example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 整体结构对于看过HTML的人来说应该是熟悉的。除了定义XML版本和格式的第一行和第二行之外，信息都是通过开标签和关闭标签来结构的。考虑以下示例：
- en: '[PRE55]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The name of the opening tag defines the content of this element of XML; in this
    case, it is a link. Then follows the content of the element, and the end of the
    content is defined by a closing tag that has a `/` character before its name.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 开标签的名称定义了该XML元素的内容；在这种情况下，它是一个链接。然后是元素的内容，内容结束由一个带有其名称之前`/`字符的关闭标签定义。
- en: 'In addition to this simple example, an XML element can have attributes that
    describe extra information about the content of the element:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个简单的例子之外，XML元素还可以有属性，这些属性描述了关于元素内容的额外信息：
- en: '[PRE56]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: These are defined as key-value pairs within the opening tag.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这些在开标签内定义为键值对。
- en: 'The content of the XML element may be a string, as in the preceding examples,
    or it can be nested child XML elements:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: XML元素的内容可能是一个字符串，就像前面的例子一样，或者它可以是嵌套的子XML元素：
- en: '[PRE57]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Lastly, the content of an XML element can be data. This data might be represented
    as a string, especially if the string is likely to be longer, and may include
    line breaks, special characters, and other components that may be confused for
    being part of the enclosing XML formatting:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，XML元素的内容可以是数据。这些数据可能以字符串的形式表示，尤其是如果字符串可能很长，并且可能包括换行符、特殊字符和其他可能被误认为是XML格式化部分组成部分的组件：
- en: '[PRE58]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now that we have retrieved the XML, we want to parse it into something useful.
    The parser we will be using is provided by the Foundation framework and is available
    on iOS and macOS. It is called `XMLParser`. `XMLParser` is a **SAX** parser, which
    stands for **Simple API for XML**. The features of a SAX parser are as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经检索到了XML，我们希望将其解析成有用的东西。我们将使用的解析器是由Foundation框架提供的，在iOS和macOS上可用。它被称为`XMLParser`。`XMLParser`是一个**SAX**解析器，代表**简单XML
    API**。SAX解析器的特点如下：
- en: Event-driven
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件驱动
- en: Low memory overhead
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低内存开销
- en: Only retains relevant information
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只保留相关信息
- en: One pass
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次遍历
- en: The parser takes a delegate object that it will deliver event information to
    as it parses the document. It is the delegate object's responsibility to take
    and retain the relevant information from these delegate callbacks as the XML data
    is parsed, as the parser will not retain the parsed data.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器接受一个代理对象，在解析文档时将事件信息传递给它。代理对象的责任是在XML数据解析时从这些代理回调中获取并保留相关信息，因为解析器不会保留解析后的数据。
- en: 'We will step through a simple example to see how the parser reports events
    to the delegate. Here''s the simple XML that we intend to parse:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个简单的示例来逐步了解解析器如何向代理报告事件。以下是我们要解析的简单XML：
- en: '[PRE59]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The parser will start parsing the XML, character by character, and as an event
    is triggered, the delegate will be informed:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器将逐字符解析XML，每当触发一个事件时，代理都会被告知：
- en: 'The first event will be the start of the document, where the parser will call
    this:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个事件将是文档的开始，此时解析器将调用以下内容：
- en: '[PRE60]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, we can do any setup or resetting of the state that is required.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以进行任何所需的设置或状态重置。
- en: 'Then, the parser will move through the document until it reaches this point:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，解析器将遍历文档，直到它到达这个点：
- en: '[PRE61]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The parser has finished parsing the opening tag for the first element and so
    it fires the delegate callback:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析器已经完成了第一个元素的开标签的解析，因此它触发了代理回调：
- en: '[PRE62]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The parser then continues until it reaches this point:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析器继续进行，直到它到达这个点：
- en: '[PRE63]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Since the parser has seen another starting tag, it fires the same delegate
    callback with information about this new element:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于解析器已经看到了另一个起始标签，它将触发相同的代理回调，并提供有关这个新元素的信息：
- en: '[PRE64]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This time, as the element has attribute information, it is provided by the delegate
    callback in the `attributeDict` dictionary.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，由于元素具有属性信息，这些信息由代理回调在`attributeDict`字典中提供。
- en: 'The parser now moves through the content of the first `quote` element. At some
    point, it fires the delegate callback with the content it has collected up to
    that point:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析器现在开始解析第一个`quote`元素的内容。在某个时刻，它将使用收集到的内容触发代理回调：
- en: '[PRE65]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'It then provides this content collected so far to the delegate:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它将收集到的内容提供给了代理：
- en: '[PRE66]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The reason the parser stops halfway through the content to fire the delegate
    callback is to make the most efficient use of memory. All the data that the parser
    processes must be kept in memory by the parser until it can be delivered to the
    delegate. Therefore, if the parser determines that memory usage is getting high,
    it will take the content it has collected so far and deliver it to the delegate.
    Once it has done this, it can free up the memory and start collecting further
    content afresh.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器在内容中间停止并触发代理回调的原因是为了最大限度地利用内存。解析器必须将处理的所有数据保留在内存中，直到它可以传递给代理。因此，如果解析器确定内存使用量很高，它将收集到目前为止的内容并将其传递给代理。一旦完成，它就可以释放内存并重新收集进一步的内容。
- en: In this simple example, it is very unlikely that the parser will not provide
    all the content of the element in one delegate callback. It is, however, useful
    to see an example of this, as we have to account for the possibility, and it will
    affect how we implement the delegate later.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的示例中，解析器不会在单个代理回调中提供元素的所有内容是非常不可能的。然而，看到这样的例子是有用的，因为我们必须考虑到这种可能性，并且它将影响我们稍后实现代理的方式。
- en: 'The parser will fire the same `foundCharacters` delegate callback until all
    of the content of an element has been delivered to the delegate:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析器将触发相同的`foundCharacters`代理回调，直到将一个元素的所有内容都传递给代理：
- en: '[PRE67]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'It then provides the new content since the last call to the delegate:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它提供自上次调用代理以来的新内容：
- en: '[PRE68]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The parser now processes the closing tag for the first `quote` element:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析器现在处理第一个`quote`元素的关闭标签：
- en: '[PRE69]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Then, it fires the delegate callback, signaling the end of the element:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它触发代理回调，表示元素的结束：
- en: '[PRE70]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The parser will then continue to process the next `quote` element in the same
    way, firing the same sequence of `didStartElement`, followed by a number of `foundCharacters`
    callbacks, and finishing with a call to `didEndElement`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器将继续以相同的方式处理下一个`quote`元素，触发相同的`didStartElement`序列，然后是一系列`foundCharacters`回调，最后以对`didEndElement`的调用结束。
- en: 'Having finished processing the last `quote` element, the parser will process
    the closing tag of the `quotes` element:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成处理最后一个`quote`元素后，解析器将处理`quotes`元素的关闭标签：
- en: '[PRE71]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'It will fire another `didEndElement` callback for the `quotes` element:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 它将为`quotes`元素触发另一个`didEndElement`回调：
- en: '[PRE72]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Finally, the parser will fire a delegate callback to indicate that the parsing
    of the document is complete:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，解析器将触发一个代理回调，以指示文档解析完成：
- en: '[PRE73]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Now that you understand how the parser passes information to the delegate, we
    can return to our RSS example.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了解析器如何向代理传递信息，我们可以回到我们的RSS示例。
- en: How it works...
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'You will remember that we retrieved XML data that looks like this:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你会记得我们检索到的XML数据如下所示：
- en: '[PRE74]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'From this, we want to extract the news articles in a usable form, so let''s
    define a `NewsArticle` model containing some useful information and place it near
    the top of the playground:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个中，我们想要提取可用的新闻文章，因此让我们定义一个包含一些有用信息的`NewsArticle`模型，并将其放置在游乐场的顶部：
- en: '[PRE75]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Since the information we require will be spread over multiple delegate callbacks,
    our delegate will need to keep track of the information it has received, so it
    can be pieced together at the appropriate time.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所需的信息将分布在多个代理回调中，我们的代理需要跟踪它已接收到的信息，以便可以在适当的时间将其拼接在一起。
- en: 'Let''s create a class object to be the delegate for the parser and have it
    conform to `XMLParserDelegate`:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个类对象作为解析器的代理，并使其符合`XMLParserDelegate`：
- en: '[PRE76]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'In the preceding XML, each news article is contained in an `item` element,
    so our delegate will need to keep track of when the parser is delivering content
    for the `item` element so that it can ignore content from other elements:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的XML中，每篇新闻文章都包含在一个`item`元素中，因此我们的代理需要跟踪解析器何时为`item`元素提供内容，以便它可以忽略来自其他元素的内容：
- en: '[PRE77]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The two parts we want to extract from the `item` element to create our `NewsArticle`
    are the title and the URL. As we can see from the XML, the title is contained
    in a `CDATA` wrapper within a `title` element, and the URL is within a `link`
    element:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要从`item`元素中提取的两个部分是标题和URL。正如我们从XML中可以看到的，标题包含在`title`元素内的`CDATA`包装器中，而URL包含在`link`元素中：
- en: '[PRE78]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We will, therefore, also need to keep track of when the parser is in the `link`
    element, and while it is within the link element, append the received content
    to a `String` property. Similarly, we need to keep track of when the parser is
    in the `title` element, and when it is, append the received content to a `Data`
    property.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们还需要跟踪解析器何时处于`link`元素中，并且当它处于链接元素内时，将接收到的内容附加到一个`String`属性中。同样，我们需要跟踪解析器何时处于`title`元素中，并且当它处于该元素时，将接收到的内容附加到一个`Data`属性中。
- en: 'Let''s add the extra properties we need to our `RSSNewsArticleBuilder` object:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`RSSNewsArticleBuilder`对象中添加所需的额外属性：
- en: '[PRE79]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'In the `didStartElement` method, we can check for these new element names we
    need to track. We must also remember to reset the link and title properties as
    we start the relevant element. This way, we don''t continue to append content
    meant for the next item element onto content from the previous one:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在`didStartElement`方法中，我们可以检查需要跟踪的新元素名称。我们还必须记得在开始相关元素时重置链接和标题属性。这样，我们就不会继续将针对下一个项目元素的文本内容附加到上一个元素的文本内容上：
- en: '[PRE80]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now that we know when we are in the right elements, we can implement two of
    the `XMLParserDelegate` methods to receive the relevant content and store it:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们处于正确的元素中，我们可以实现两个`XMLParserDelegate`方法来接收相关内容并将其存储：
- en: '[PRE81]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'In the `didEndElement` method, we need to update our new properties and we
    can print out the values we have retrieved from the XML:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在`didEndElement`方法中，我们需要更新我们的新属性，并且我们可以打印出我们从XML中检索到的值：
- en: '[PRE82]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now that we have extracted the title and URL of the news article, we can use
    this to create a `NewsArticle` model object. First, let''s create an array to
    hold the `NewsArticle` objects we will be creating:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经提取了新闻文章的标题和URL，我们可以使用这些信息来创建一个`NewsArticle`模型对象。首先，让我们创建一个数组来保存我们将创建的`NewsArticle`对象：
- en: '[PRE83]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We can create the `NewsArticle` object at the end of the `item` element as
    this is when we will have all the relevant content:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`item`元素的末尾创建`NewsArticle`对象，因为那时我们将拥有所有相关内容：
- en: '[PRE84]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Lastly, when the document starts, we should ensure that all the properties
    are reset:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当文档开始时，我们应该确保所有属性都已重置：
- en: '[PRE85]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now that we have completed the parser delegate, let''s go back to our `fetchBBCNewsRSSFeed`
    function:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了解析器代理，让我们回到我们的`fetchBBCNewsRSSFeed`函数：
- en: '[PRE86]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Once the XML data has been retrieved, we''ll pass it to `XMLParser`, set up
    the delegate, and tell the parser to parse the data:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦检索到XML数据，我们将将其传递给`XMLParser`，设置代理，并告诉解析器解析数据：
- en: '[PRE87]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We want to provide the articles as an output from this function, so we can
    add a completion handler to provide an array of news articles or an error:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望从这个函数提供文章作为输出，因此我们可以添加一个完成处理程序来提供新闻文章数组或错误：
- en: '[PRE88]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Finally, we can call this function, which will retrieve the RSS feed, parse
    it, and return an array of news articles:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以调用此函数，它将检索RSS源，解析它，并返回一个新闻文章数组：
- en: '[PRE89]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: There's more...
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Foundation also provides the ability to write XML data, although currently,
    this functionality is only available on macOS.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Foundation还提供了写入XML数据的能力，尽管目前此功能仅在macOS上可用。
- en: 'Having retrieved the RSS feed and created our news articles, let''s write this
    information to an XML data structure and save it to disk. This XML will take the
    following form:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在检索到RSS源并创建我们的新闻文章后，让我们将此信息写入XML数据结构，并将其保存到磁盘。此XML将采用以下形式：
- en: '[PRE90]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: At the root of the XML structure is an `articles` element, which contains multiple
    `article` elements, which in turn contain a `title` element and a `url` element.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在XML结构的根处是一个`articles`元素，它包含多个`article`元素，这些元素又包含一个`title`元素和一个`url`元素。
- en: To write the XML data, we will recreate the preceding structure using the `XMLDocument`
    and `XMLElement` objects. Once constructed, the `xmlData` property of the `XMLDocument`
    object provides the document as data.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 要写入XML数据，我们将使用`XMLDocument`和`XMLElement`对象重新创建前面的结构。一旦构建完成，`XMLDocument`对象的`xmlData`属性提供了文档作为数据。
- en: 'Let''s create a function to produce XML data from an array of `NewsArticle`:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个函数，从`NewsArticle`数组生成XML数据：
- en: '[PRE91]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: We create each `XMLElement` and add it as a child to the element that we want
    to nest it within.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建每个`XMLElement`并将其作为子元素添加到我们想要嵌套的元素中。
- en: If you are building this in a storyboard, ensure that you place this function
    after `RSSNewsArticleBuilder`, and before the code that calls `fetchBBCNewsRSSFeed`,
    as this function will need to be available to the completion handler soon.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个故事板中构建它，请确保将此函数放在`RSSNewsArticleBuilder`之后，并在调用`fetchBBCNewsRSSFeed`的代码之前，因为这个函数很快就需要可用。
- en: 'Our call to `fetchBBCNewsRSSFeed` will provide an array of `NewsArticle`, so
    we can pass this to our new function to write this information to XML data:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`fetchBBCNewsRSSFeed`的调用将提供一个`NewsArticle`数组，因此我们可以将此传递给我们的新函数，以将此信息写入XML数据：
- en: '[PRE92]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Now that we have the data, we can obtain a URL for the `documents` directory,
    append the name of the file we will create, and write it to disk:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了数据，我们可以获取`documents`目录的URL，附加我们将创建的文件名，并将其写入磁盘：
- en: '[PRE93]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: We have now retrieved an RSS feed, extracted useful information from it, written
    that information to a custom XML format, and saved that data to disk. Give yourself
    a pat on the back!
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已检索到RSS源，从中提取了有用的信息，将这些信息写入自定义XML格式，并将其保存到磁盘。给自己鼓掌吧！
- en: See also
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Further information about `XMLParser` can be found in Apple's Foundation reference
    at [http://swiftbook.link/docs/xmlparser](http://swiftbook.link/docs/xmlparser).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于`XMLParser`的信息可以在Apple的Foundation参考文档中找到，网址为[http://swiftbook.link/docs/xmlparser](http://swiftbook.link/docs/xmlparser)。
- en: 'Other XML parsers are available, which may have advantages over Apple''s, including
    being able to write XML on iOS. They are as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 其他XML解析器也可用，它们可能比Apple的解析器有优势，包括能够在iOS上写入XML。它们如下所示：
- en: 'RaptureXML: [https://github.com/ZaBlanc/RaptureXML](https://github.com/ZaBlanc/RaptureXML)'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RaptureXML: [https://github.com/ZaBlanc/RaptureXML](https://github.com/ZaBlanc/RaptureXML)'
- en: 'TBXML: [https://github.com/71squared/TBXML](https://github.com/71squared/TBXML)'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'TBXML: [https://github.com/71squared/TBXML](https://github.com/71squared/TBXML)'
