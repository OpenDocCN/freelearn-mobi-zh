- en: Beyond the Standard Library
  prefs: []
  type: TYPE_NORMAL
- en: Apple's intention when open-sourcing Swift was to provide a cross-platform,
    general-purpose programming language that is ready to use. The Swift standard
    library provides core language features and common collection types. However,
    this does not provide everything needed to get up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, Apple provides a framework called **Foundation** to help you perform
    common programming tasks that aren't covered by the core Swift language and the
    standard library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Foundation framework that you will use when developing for Apple platforms
    is *closed-sourced*, which means the underlying code is not accessible and only
    the API is visible. However, when Apple open-sourced Swift and made it available
    for Linux, it became necessary to provide the Foundation framework as well. To
    this end, Apple has released an open source, Swift-based version of Foundation
    as a core library, available here: [https://github.com/apple/swift-corelibs-foundation](https://github.com/apple/swift-corelibs-foundation).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing dates with Foundation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching data with `URLSession`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with XML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code for this chapter can be found in this book's GitHub repository
    at [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter05](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter05)
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3cIcNUK](https://bit.ly/3cIcNUK)'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing dates with Foundation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will focus on one area of Foundation that is very widely used, that
    is, date and time manipulation and formatting.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a function that determines how long there is until Christmas
    and returns this information as a string that can be displayed to a user.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new iOS playground and import the Foundation framework at the top
    of the playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a function that will return a string telling us how long there
    is until Christmas that we can then print:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the function, get the current calendar and time zone:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the current date and time and use the calendar to get the current year:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Define date components that correspond to midnight on Christmas Day:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Get a `Date` object from those components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have already passed Christmas for this year, we need to adjust the component
    to refer to Christmas of the next year:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `DateComponentsFormatter` to format how the time until Christmas is
    displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `DateComponentFormatter` to return a string for the time between now and
    next Christmas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Below the `howLongUntilChristmas` function, use this function to create a string,
    and print the outcome:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *Step 1*, we create our `howLongUntilChristmas` function, then in *Step
    2*, we get the currently set calendar and time zone as they will be needed for
    the date calculations to come:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: While retrieving the current time zone is self-explanatory, it is not immediately
    obvious what the `Calendar` type represents and why we need to retrieve it.
  prefs: []
  type: TYPE_NORMAL
- en: How dates are represented is not as universally agreed as you might believe.
    Certain time components are mostly universal, such as the length of years and
    days, as they are connected to astronomical events, such as the time it takes
    for the Earth to perform one revolution of the Sun, and for the Earth to complete
    one rotation around its own axis, respectively. However, other time components,
    such as months and weeks and how the years are numbered, are rooted in the culture
    that created them.
  prefs: []
  type: TYPE_NORMAL
- en: The calendar used throughout Europe and most of the world is known as the **Gregorian
    calendar**, introduced in 1582 by Pope Gregory XIII, replacing the Julian calendar.
    There are about 40 different calendars currently in use around the world, including
    Gregorian, Chinese, Hebrew, Islamic, Persian, Ethiopian, and Balinese Pawukon.
  prefs: []
  type: TYPE_NORMAL
- en: The way in which we present how long there is until Christmas will depend on
    the calendar that is relevant to the user. This is why we ask for the current
    calendar, which the user can change if they want a different representation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next task is to get the current date and time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In *Step 3*, the default initializer for the `Date` value type uses the current
    date and time as its value. Note that this date value is set at the point of creation;
    it does not continually update with the current date and time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this step, we get a date and time for the next Christmas. We know the time,
    day, and month of Christmas, so to construct a date for Christmas, we just need
    to know the year. There is a method on `Calendar` called `component` that allows
    us to retrieve specific components from a `Date` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We now have the current year, within the user's current calendar; we can use
    it to create the Christmas date.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Step 4*, we create an instance of `DateComponents`, passing in the calendar,
    time zone, and the fact that we are defining December 25 at midnight, for the
    current year:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In *Step 5*, we create a `Date` object from `DateComponents`. This is of an
    optional type as we may not have provided enough information to the components
    to generate a date; however, since we know that we have, we can force-unwrap this
    optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to handle an edge case; what if we have already had Christmas
    this year? For example, let''s imagine that the current date is December 27, 2020;
    we are trying to find the date of the next Christmas, but if we use the current
    year, we will get December 25, 2020, which is the Christmas just gone. So, in
    *Step 6*, we add 1 to the current year to get next Christmas, December 25, 2021:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To account for this, we check whether the Christmas for this year is before
    `now`; if it is, we bump the year component to next year and recreate the Christmas
    date from `DateComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: We now have the current `Date` and the next Christmas `Date`, and Foundation
    provides functionality to calculate the time difference between two dates and
    format it to display to a user, through the use of `DateComponentsFormatter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Step 7*, we create `DateComponentsFormatter`, and set `unitStyle` to `full`,
    which will provide a string using the full unit name, without abbreviation. We
    configure how we want the date and time divided for display, using `allowedUnits`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In *Step 8*, we can retrieve a string from the formatter that describes the
    time between the two dates given, with the settings provided to the formatter.
    Since `DateComponentsFormatter` returns an optional string, we unwrap and return
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Our `howLongUntilChristmas` method will provide a string describing how long
    until Christmas, which we can then print out.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a lot more to discover in Foundation, so check out the documentation
    for further functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift 3 documentation for Foundation: [http://swiftbook.link/docs/foundation](http://swiftbook.link/docs/foundation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open source repository for Foundation: [https://github.com/apple/swift-corelibs-foundation](https://github.com/apple/swift-corelibs-foundation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching data with URLSession
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every app worth building will need to send or receive information from the internet
    at some point and therefore, networking support is a critical part of any development
    platform. In Swift, this support for networking is provided by the Foundation
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: When we need to retrieve information from the internet, we send out a request
    to a server on the internet, and that server sends a response that hopefully contains
    the information we requested.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to send network requests and receive a response
    using the Foundation framework.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is helpful to know of the different components that Foundation provides
    that deal with networking and what they do:'
  prefs: []
  type: TYPE_NORMAL
- en: '`URL`: The address of a resource on a remote server. It contains information
    about the server and where the resource can be found on the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`URLRequest`: Represents the request that will be made to the remote server.
    Defines the URL of the resource, how the request should be sent, metadata in the
    form of headers, and data that should be sent with it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`URLSession`: Manages the communication with remote servers, holds the configuration
    for that communication, and creates and optimizes the underlying connections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`URLSessionDataTask`: An object that manages the state of the request and delivers
    the response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`URLResponse`: Holds the metadata of the response from the remote server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s use these networking tools to retrieve an image from a remote server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import `PlaygroundSupport` and set up indefinite execution for this playground:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Import Foundation and create an instance of `URLSession`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will construct a request for a remote image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our `URLRequest`, we can create a data task to retrieve the
    image from the remote server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We will take the image data and put it in a `UIImage` object to display it.
    So, we need to import the `UIKit` framework, which provides `UIImage`. So, let''s
    import `UIKit` at the top of the playground:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Check for image data in the completion handler and create a `UIImage` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Call `resume` on the task to start it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s walk through the previously mentioned steps to understand what we are
    doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**Playgrounds** execute the code they contain from top to bottom. When the
    end of the playground page is reached, the playground stops executing. In our
    example, the task is created and started, but then the playground reaches the
    end of the page before the image has been fully retrieved, because this happens
    asynchronously. If the playground were to stop execution here, the completion
    handler would never be executed, and we wouldn''t see the image. This isn''t a
    problem in a normal app that is continually running while it is in use; it is
    just specific to how Swift playgrounds work.'
  prefs: []
  type: TYPE_NORMAL
- en: To solve this, we need to tell the playground that we don't want it to stop
    executing when it reaches the end of the page and instead, it should run indefinitely
    while we wait for the response to be received. This is done by importing the `PlaygroundSupport`
    framework in *Step 1* and setting `needsIndefiniteExecution` to be `true` on the
    current `PlaygroundPage`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In *Step 2*, when creating `URLSession`, we pass in a `URLSessionConfiguration`
    object, which allows configuring the time it takes for a request to time out and
    cache responses, among other things. For our purposes, we will just use the default
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In *Step 3*, we will be requesting the image from the excellent webcomic *XKCD*
    ([http://xkcd.com](https://xkcd.com/)). We can create the URL from a string, and
    then create a `URLRequest` request from the URL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In *Step 4*, we do not create a data task directly; instead, we ask our `URLSession`
    instance to create the data task, and we pass in `URLRequest` and a completion
    handler. The completion handler will be fired once a response has been received
    from the remote server or some error has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'The completion handler has three inputs, all optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '`data: Data`: The data returned in the body of the response; if our request
    was successful, this will contain our image data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`response: URLResponse`: The response metadata, including response headers.
    If the request was over HTTP/HTTPS, then this will be `HTTPURLResponse`, which
    will contain the HTTP status code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error: Error`: If the request was unsuccessful, due to a network issue, for
    example, this value will have the error, and the data and response value will
    be `nil`. If the request was successful, this error value will be `nil`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In *Step 6*, we check for response data and turn it into an image. To do this,
    we will need to construct a `UIImage` object from the data. `UIImage` is a class
    that represents an image on iOS and can be found in the `UIKit` framework. So,
    we also needed to import `UIKit` at the top of the playground, as we have done
    in *Step 5*.
  prefs: []
  type: TYPE_NORMAL
- en: Since we don't plan on doing anything with the image in this example, we are
    just going to view it in a playground preview; the compiler will complain if we
    assign it to a value that is never used. Therefore, we replace a normal value
    assignment with `_`, which allows the `UIImage` object to be generated without
    it being assigned to anything.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In *Step 7*, we have created the data task to retrieve the image, but we need
    to actually start the task to make the request. To do that, we call `resume` on
    the task.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the playground, you will eventually see that the image value has
    been populated in the playground''s right sidebar, and you can click on the preview
    icon to see the image that has been downloaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a63cd3c-f4ae-46ec-a564-9bbcbcbc458f.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Retrieved image displayed in the playground timeline
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Further information about networking can be found in Apple''s networking overview:
    [http://swiftbook.link/docs/networking](http://swiftbook.link/docs/networking)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information can also be found in Apple''s URL Session programming guide:
    [http://swiftbook.link/docs/urlsession-guide](http://swiftbook.link/docs/urlsession-guide)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in the last recipe, almost every app will need to exchange information
    with the internet at some point, and in that recipe, we retrieved an image from
    a remote server. Very often, your app will need to retrieve more varied data,
    perhaps relating to the result of a search, or information about a shared state
    held on the server.
  prefs: []
  type: TYPE_NORMAL
- en: This information can be represented in any number of ways, but one of the most
    common ways is as **JavaScript Object Notation** (**JSON**), which is a text-based
    structure for representing information. A JSON object contains key-value pairs,
    where the keys are strings and the values can be strings, numbers, Booleans, null,
    other objects, or arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, information about a person could be expressed with this JSON object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of an array of JSON objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Foundation provides tools for reading information from and writing information
    as JSON data. In this recipe, we will interact with a JSON-based **Application
    Programming Interface** (**API**), to both send and receive information.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our goal is to interact with the GitHub API and create an issue for this book's
    repository. A full explanation of Git and GitHub is beyond the scope of this book;
    suffice to say that it's a service that stores versioned copies of your source
    code. Resources relevant to this book are stored in repositories on GitHub, and
    a GitHub user can create *issues* that serve as bug reports or feature requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t already have one, then you will need to sign up for a GitHub
    account:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://github.com](https://github.com).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in your details and press Sign up for GitHub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have created a GitHub account, you will need to create a personal
    access token, which we will use to authenticate some of the requests to the GitHub
    API. To create a personal access token, use the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the settings page ([https://github.com/settings/tokens](https://github.com/settings/tokens))
    and click on Generate new token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Give the token a name and check the box next to repo:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3e4a5de2-cf58-4ddb-9e9d-8a7b33dcdeb8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Creating a personal access token
  prefs: []
  type: TYPE_NORMAL
- en: Click on Generate token at the bottom of the page. You will now see your newly
    generated personal access token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy this token and paste it somewhere, as we will need it later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cf6a82d4-b33c-4222-b7aa-e722f882dccf.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – The generated personal access token
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create our issue, we will first retrieve all of Packt Publishing's public
    repositories, and then find the relevant repository for this book. We will then
    create a new issue in this repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'As in the preceding recipe, we will need a `URLSession` object to perform our
    requests, and we need to tell the playground not to finish executing when it reaches
    the end of the playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Our first step is to fetch all the public repositories for a given user:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a function to do that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You will note that after creating `URLRequest`, we set an HTTP header; this
    particular header ensures that we will always get back version 3 of the GitHub
    API.
  prefs: []
  type: TYPE_NORMAL
- en: We know from the GitHub API documentation ([https://developer.github.com/v3/](https://developer.github.com/v3/))
    that this response data is in JSON format. We need to parse the JSON data to turn
    it into something that we can use; enter `JSONSerialization`. `JSONSerialization`
    is part of the Foundation framework and provides class methods for turning Swift
    dictionaries and arrays into JSON data (known as **serialization**) and back again
    (known as **deserialization**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use `JSONSerialization` to turn our JSON response data into something
    more useful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s fetch the public Packt repositories by executing our function and
    passing `PacktPublishing` in as the GitHub username:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Once executed, the print output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/444dcf8e-5bf3-4543-86fb-3b16f86ca331.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Public GitHub repositories API response
  prefs: []
  type: TYPE_NORMAL
- en: '`JSONSerializer` has turned our JSON data into familiar arrays and dictionaries
    that can be used to retrieve the information we need in the normal way. The JSON
    data is deserialized with the `Any` type, as the JSON can have a JSON object or
    an array at its root.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since, from the preceding output, we know that the response has an array of
    JSON objects at its root, we need to turn the value from type `Any` to an array
    of dictionaries of the `[String: Any]` type. This is referred to as **casting**
    from one type to another, which we can do by using the `as` keyword and then specifying
    the new type. This keyword can be used in three different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`as` will perform a trivial cast. This is possible if the existing type is
    synonymous with the intended type, for instance, casting from a subclass to a
    superclass.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`as?` will conditionally perform a cast, returning an optional value. If it
    is not possible to represent the value as the intended type, the value will be
    `nil`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`as!` will perform a forced cast. If it is not possible to represent the value
    as the intended type, you will get a crash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, let''s cast the deserialized data to an array of dictionaries with string
    keys, with the `[[String: Any]]` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have an array of dictionaries for the repositories in the API response,
    which we need to provide as input for this function. A common pattern for providing
    results for asynchronous work is to provide a completion handler as a parameter.
    A completion handler is a closure that can be executed once the asynchronous work
    is completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the output we want to provide is the array of repository dictionaries,
    we will define this as an input for the closure if the request was successful,
    and an error if it wasn''t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now, whenever an error is generated, we execute `completionHandler`, passing
    in the error and `nil` for the results value. Also, when we have the repository
    results, we execute the completion handler, passing in the parsed JSON and `nil`
    for the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'We passed in a few new errors in the preceding code, so let''s define those
    errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This changes how we call this `fetchRepos` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have retrieved the details of the public repositories, we will submit
    an issue to the repository for this chapter. This issue can be any feedback you
    would like to give about this book; it can be a review, a suggestion for new content,
    or you can tell me about a Swift project you are currently working on.
  prefs: []
  type: TYPE_NORMAL
- en: This request to the GitHub API will be authenticated against your user account
    and therefore, we will need to include details of the personal access token that
    we created at the beginning of this recipe. There are a number of ways to authenticate
    requests to the GitHub API, but the simplest is basic authentication, which involves
    adding an authorization string to the request header.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a method to format the personal access token correctly for authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s create our function to submit our issue. From the API documentation
    at [https://developer.github.com/v3/issues/#create-an-issue](https://developer.github.com/v3/issues/#create-an-issue),
    we can see that unless you have push access, you can only create an issue with
    the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`title` (required)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`body` (optional)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, our function will take this information as input, along with the repository
    name and username:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating an issue is achieved by sending a `POST` request, and information
    about the issue is provided as JSON data in the request body. To create our request,
    we can use `JSONSerialization`, but we will take our intended JSON structure and
    serialize it into `Data` this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the previous API request, we need a way to provide the result of creating
    the issue, so let''s provide a completion handler, try to deserialize the response,
    and provide it to the completion handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The API response to a successfully created issue provides a JSON representation
    of that issue. Our function will return this representation if it was successful,
    or an error if it was not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a function to create issues in a repository, it''s time to
    use it to create an issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: I will check these created issues, so please provide genuine feedback on this
    book. How have you found the content? Too detailed? Not detailed enough? Anything
    I've missed or not fully explained? Any questions that you have? This is your
    opportunity to let me know.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we created our completion handlers, we gave them two inputs: the successful
    result (either the repository information or the created issue) or an error if
    there is a failure. Both these values are optional; one will be `nil`, and the
    other has a value. However, this convention is not enforced by the language, and
    a user of this function will have to consider the possibility that it may not
    be the case. What should the user of this function do if the `fetchRepos` function
    fires the completion handler with non-`nil` values for both the repository and
    the error? What if both are `nil`?'
  prefs: []
  type: TYPE_NORMAL
- en: The user of this function, without viewing the function's internal code, can't
    be sure that this won't happen, which means they may need to write functionality
    and tests to account for this possibility, even though it may never happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be better if we could more accurately represent the intended behavior
    of our function, providing the user with a clear indication of the possible outcomes
    and leaving no room for ambiguity. We know that there are two possible outcomes
    from calling the function: it will either succeed and return the relevant value,
    or it will fail and return an error to indicate the reason for the failure.'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of optional values, we can use an enum to represent these possibilities,
    and the Foundation framework provides a generic enum for this purpose, called
    `Result`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Result` enum has a `success` case, which has an associated type for a successful
    result, and a `failure` case with an associated type for the relevant error. Both
    associated types are defined as generic constraints, with the failure type needing
    to conform to the `Error` protocol.
  prefs: []
  type: TYPE_NORMAL
- en: We can now define the success and failure states and use associated values to
    hold the value that is relevant for each state, which is the repository information
    for the success state and the error for the failure state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s amend our `fetchRepos` function to provide a `Result` enum in `completionHandler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to update how we call the `fetchRepos` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We now use a `switch` statement instead of `if/else`, and we get the added benefit
    that the compiler will ensure that we have covered all possible outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having made this improvement to the `fetchRepos` function, we can similarly
    improve the `createIssue` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we need to update the contents of the completion handler that we provide
    to the `createIssue` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Working with JSON data and extracting relevant information from it can be frustrating.
    Consider the JSON response for our `fetchRepos` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to get the username for the owner of the first repository, we need
    to deserialize the JSON and then conditionally unwrap multiple nested layers to
    get the username string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: That's a lot of optional unwrapping and casting just to get one value! Swift's
    strongly typed nature doesn't work well with JSON's loosely defined schema, which
    is why you have to do a lot of work to turn loosely typed information into strongly
    typed values.
  prefs: []
  type: TYPE_NORMAL
- en: To help with these problems, a number of open source frameworks are available,
    which make working with JSON in Swift easier. `SwiftyJSON` is a popular framework
    that can be found on GitHub at [https://github.com/SwiftyJSON/SwiftyJSON](https://github.com/SwiftyJSON/SwiftyJSON).
  prefs: []
  type: TYPE_NORMAL
- en: I have also built a lightweight JSON helper called `JSONNode`, which can also
    be found on GitHub at [https://github.com/keefmoon/JSONnode](https://github.com/keefmoon/JSONnode).
  prefs: []
  type: TYPE_NORMAL
- en: 'With `JSONNode`, you can perform the same task of retrieving the owner''s username
    for the first repository with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Information within JSON, of any depth, can be retrieved in one line using subscripts.
  prefs: []
  type: TYPE_NORMAL
- en: Working with XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**XML** stands for **eXtensible Markup Language** and is a popular way of representing
    data for storage and transfer across a network. XML is a very flexible format
    and is used to represent many types of data. The current specification of HTML,
    which powers most of the web, is an implementation of XML.'
  prefs: []
  type: TYPE_NORMAL
- en: The version of XML that we will concern ourselves with in this recipe is **RSS**,
    which stands for **Really Simple Syndication**. RSS is used to define a collection
    of time-ordered pieces of digestible content; these RSS feeds can then be used
    to aggregate content from a number of different sources. RSS is typically used
    as a distribution mechanism for news articles and podcasts.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to read and write XML data by fetching and
    parsing the BBC News RSS feed.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The functionality to deal with XML data is provided by the Foundation framework.
    However, while the classes that help with reading XML data are available on all
    of Apple's platforms, the classes that assist with writing XML data are only available
    on the macOS platform.
  prefs: []
  type: TYPE_NORMAL
- en: This is an unfortunate oversight and means that if you need to write XML data
    within an iOS app, you will likely need to look for a third-party helper or build
    your own. We will investigate third-party helpers at the end of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: To investigate both reading and writing XML using the Foundation framework,
    we need to create a new macOS-based playground instead of an iOS-based playground,
    which we have been using so far in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Swift playground as usual, but choose a Blank template from the
    macOS tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a958f28d-123d-464f-9a57-0a9754f2b163.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Choosing a template
  prefs: []
  type: TYPE_NORMAL
- en: The RSS feed that we will retrieve and parse is from the front page of the BBC
    News website, which is [http://feeds.bbci.co.uk/news/rss.xml](http://feeds.bbci.co.uk/news/rss.xml).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first step is to retrieve the data at this URL so that we can start making
    sense of it. Since we previously covered retrieving information over the network,
    I''ll add the code without further comment; check out the *Fetching data with
    URLSession* recipe in this chapter for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the playground, you will get an output that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The overall structure should be familiar to anyone who has seen HTML. Apart
    from the first two lines, which define the version and formatting of the XML,
    the information is structured with opening and closing tags. Consider the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The name of the opening tag defines the content of this element of XML; in this
    case, it is a link. Then follows the content of the element, and the end of the
    content is defined by a closing tag that has a `/` character before its name.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to this simple example, an XML element can have attributes that
    describe extra information about the content of the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: These are defined as key-value pairs within the opening tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of the XML element may be a string, as in the preceding examples,
    or it can be nested child XML elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, the content of an XML element can be data. This data might be represented
    as a string, especially if the string is likely to be longer, and may include
    line breaks, special characters, and other components that may be confused for
    being part of the enclosing XML formatting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have retrieved the XML, we want to parse it into something useful.
    The parser we will be using is provided by the Foundation framework and is available
    on iOS and macOS. It is called `XMLParser`. `XMLParser` is a **SAX** parser, which
    stands for **Simple API for XML**. The features of a SAX parser are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Event-driven
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Low memory overhead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only retains relevant information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One pass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parser takes a delegate object that it will deliver event information to
    as it parses the document. It is the delegate object's responsibility to take
    and retain the relevant information from these delegate callbacks as the XML data
    is parsed, as the parser will not retain the parsed data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will step through a simple example to see how the parser reports events
    to the delegate. Here''s the simple XML that we intend to parse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The parser will start parsing the XML, character by character, and as an event
    is triggered, the delegate will be informed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first event will be the start of the document, where the parser will call
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can do any setup or resetting of the state that is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the parser will move through the document until it reaches this point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The parser has finished parsing the opening tag for the first element and so
    it fires the delegate callback:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The parser then continues until it reaches this point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the parser has seen another starting tag, it fires the same delegate
    callback with information about this new element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This time, as the element has attribute information, it is provided by the delegate
    callback in the `attributeDict` dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parser now moves through the content of the first `quote` element. At some
    point, it fires the delegate callback with the content it has collected up to
    that point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'It then provides this content collected so far to the delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The reason the parser stops halfway through the content to fire the delegate
    callback is to make the most efficient use of memory. All the data that the parser
    processes must be kept in memory by the parser until it can be delivered to the
    delegate. Therefore, if the parser determines that memory usage is getting high,
    it will take the content it has collected so far and deliver it to the delegate.
    Once it has done this, it can free up the memory and start collecting further
    content afresh.
  prefs: []
  type: TYPE_NORMAL
- en: In this simple example, it is very unlikely that the parser will not provide
    all the content of the element in one delegate callback. It is, however, useful
    to see an example of this, as we have to account for the possibility, and it will
    affect how we implement the delegate later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parser will fire the same `foundCharacters` delegate callback until all
    of the content of an element has been delivered to the delegate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'It then provides the new content since the last call to the delegate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The parser now processes the closing tag for the first `quote` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, it fires the delegate callback, signaling the end of the element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The parser will then continue to process the next `quote` element in the same
    way, firing the same sequence of `didStartElement`, followed by a number of `foundCharacters`
    callbacks, and finishing with a call to `didEndElement`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having finished processing the last `quote` element, the parser will process
    the closing tag of the `quotes` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'It will fire another `didEndElement` callback for the `quotes` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the parser will fire a delegate callback to indicate that the parsing
    of the document is complete:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Now that you understand how the parser passes information to the delegate, we
    can return to our RSS example.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will remember that we retrieved XML data that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'From this, we want to extract the news articles in a usable form, so let''s
    define a `NewsArticle` model containing some useful information and place it near
    the top of the playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Since the information we require will be spread over multiple delegate callbacks,
    our delegate will need to keep track of the information it has received, so it
    can be pieced together at the appropriate time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a class object to be the delegate for the parser and have it
    conform to `XMLParserDelegate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding XML, each news article is contained in an `item` element,
    so our delegate will need to keep track of when the parser is delivering content
    for the `item` element so that it can ignore content from other elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The two parts we want to extract from the `item` element to create our `NewsArticle`
    are the title and the URL. As we can see from the XML, the title is contained
    in a `CDATA` wrapper within a `title` element, and the URL is within a `link`
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: We will, therefore, also need to keep track of when the parser is in the `link`
    element, and while it is within the link element, append the received content
    to a `String` property. Similarly, we need to keep track of when the parser is
    in the `title` element, and when it is, append the received content to a `Data`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the extra properties we need to our `RSSNewsArticleBuilder` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `didStartElement` method, we can check for these new element names we
    need to track. We must also remember to reset the link and title properties as
    we start the relevant element. This way, we don''t continue to append content
    meant for the next item element onto content from the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know when we are in the right elements, we can implement two of
    the `XMLParserDelegate` methods to receive the relevant content and store it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `didEndElement` method, we need to update our new properties and we
    can print out the values we have retrieved from the XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have extracted the title and URL of the news article, we can use
    this to create a `NewsArticle` model object. First, let''s create an array to
    hold the `NewsArticle` objects we will be creating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create the `NewsArticle` object at the end of the `item` element as
    this is when we will have all the relevant content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, when the document starts, we should ensure that all the properties
    are reset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have completed the parser delegate, let''s go back to our `fetchBBCNewsRSSFeed`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the XML data has been retrieved, we''ll pass it to `XMLParser`, set up
    the delegate, and tell the parser to parse the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to provide the articles as an output from this function, so we can
    add a completion handler to provide an array of news articles or an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can call this function, which will retrieve the RSS feed, parse
    it, and return an array of news articles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Foundation also provides the ability to write XML data, although currently,
    this functionality is only available on macOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having retrieved the RSS feed and created our news articles, let''s write this
    information to an XML data structure and save it to disk. This XML will take the
    following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: At the root of the XML structure is an `articles` element, which contains multiple
    `article` elements, which in turn contain a `title` element and a `url` element.
  prefs: []
  type: TYPE_NORMAL
- en: To write the XML data, we will recreate the preceding structure using the `XMLDocument`
    and `XMLElement` objects. Once constructed, the `xmlData` property of the `XMLDocument`
    object provides the document as data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a function to produce XML data from an array of `NewsArticle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: We create each `XMLElement` and add it as a child to the element that we want
    to nest it within.
  prefs: []
  type: TYPE_NORMAL
- en: If you are building this in a storyboard, ensure that you place this function
    after `RSSNewsArticleBuilder`, and before the code that calls `fetchBBCNewsRSSFeed`,
    as this function will need to be available to the completion handler soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our call to `fetchBBCNewsRSSFeed` will provide an array of `NewsArticle`, so
    we can pass this to our new function to write this information to XML data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the data, we can obtain a URL for the `documents` directory,
    append the name of the file we will create, and write it to disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: We have now retrieved an RSS feed, extracted useful information from it, written
    that information to a custom XML format, and saved that data to disk. Give yourself
    a pat on the back!
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about `XMLParser` can be found in Apple's Foundation reference
    at [http://swiftbook.link/docs/xmlparser](http://swiftbook.link/docs/xmlparser).
  prefs: []
  type: TYPE_NORMAL
- en: 'Other XML parsers are available, which may have advantages over Apple''s, including
    being able to write XML on iOS. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'RaptureXML: [https://github.com/ZaBlanc/RaptureXML](https://github.com/ZaBlanc/RaptureXML)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TBXML: [https://github.com/71squared/TBXML](https://github.com/71squared/TBXML)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
