- en: Introduction to Web Programming with Spring for Kotlin Developers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin is a powerful language, and its power increases, even more, when the
    Spring Framework is used with it. Up until this point, you've learned the concepts
    of reactive programming and how to apply these concepts to Kotlin. So far, we
    developed and wrote code that interacts with the console, but that's not what
    we will do while developing professional apps. We will either build apps that
    will run on mobile devices or we will build web applications or REST APIs. At
    least those are the most commonly built professional software solutions.
  prefs: []
  type: TYPE_NORMAL
- en: So, how to build them? How to create RESTful web APIs and Android apps? Let's
    discover. The last three chapters of this book are dedicated to building REST
    APIs and Android apps and, most importantly, making them reactive. Spring is such
    a vast topic that covering it in a single chapter is simply not possible, so we
    will have two chapters on Spring.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will start by introducing you to Spring, and, by the end of this
    chapter, you should be proficient enough to write REST APIs in Kotlin with Spring.
    We will not add reactive features in this chapter because we don't want to distract
    you from the concepts and ideas of Spring. We want you to grasp the concepts and
    knowledge of Spring itself well enough before moving ahead with making them reactive.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Spring, history, and origin of Spring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring IoC and dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aspect-oriented programming in Spring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Spring Boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building REST APIs with Spring Boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, what are we waiting for? Let's get started and get familiar with Spring.
  prefs: []
  type: TYPE_NORMAL
- en: Spring, history, and origin of Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is Spring? We cannot give a short answer. It's really tough to define Spring
    in a sentence or two. Many people may say Spring is a framework, but this would
    be also an understatement for Spring, as it may also be called a **framework of
    frameworks**. Spring provides you with a lot of tools, such as **DI** (**dependency
    injection**), **IoC** (**Inversion of Control**), and **AOP** (**Aspect-oriented
    programming**). While we can use Spring in almost any type of Java or Kotlin JVM
    application, it is most useful while developing web applications on top of the
    Java EE platform. Before moving into the details of Spring, we should first understand
    from where and why Spring originated and how it has evolved.
  prefs: []
  type: TYPE_NORMAL
- en: The origin and history of Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It has been more than two decades (around 22 years) since Java has been around.
    For enterprise application development, Java introduced a few technologies that
    were heavyweight and were very complex enough.
  prefs: []
  type: TYPE_NORMAL
- en: In 2003, Rod Johnson created Spring as an alternative to the heavyweight and
    complex Enterprise Java Technologies and EJB to make it easy to develop enterprise
    applications in Java. Being lightweight, flexible, and easy to use, Spring gained
    popularity soon. Over time, EJB and Java Enterprise Edition (then J2EE) evolved
    to support POJO-oriented programming models such as Spring. Not only that, arguably
    inspired by Spring, EJB also started offering AOP, DI, and IoC.
  prefs: []
  type: TYPE_NORMAL
- en: However, Spring never looked back. As EJB and Java EE started including ideas
    inspired by Spring, Spring started exploring more unconventional and unexplored
    technology areas, such as Big Data, Cloud Computing, Mobile App Development, and
    even reactive programming, leaving EJB and Java EE far behind.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the start of the year, on the month of January 2017, Spring surprised
    everyone by announcing its support for Kotlin (yes, they announced Kotlin support
    even before Google) and released a few Kotlin APIs. And, when the power of Kotlin
    was combined with an already powerful Spring Framework, both got even more powerful.
    As a reason behind adding Kotlin support, they stated:'
  prefs: []
  type: TYPE_NORMAL
- en: One of the key strengths of Kotlin is that it provides a very good interoperability
    with libraries written in Java. But there are ways to go even further and allow
    writing fully idiomatic Kotlin code when developing your next Spring application.
    In addition to Spring Framework support for Java 8 that Kotlin applications can
    leverage like functional web or bean registration APIs, there are additional Kotlin
    dedicated features that should allow you to reach a new level of productivity.
  prefs: []
  type: TYPE_NORMAL
- en: That's why we are introducing a dedicated Kotlin support in Spring Framework
    5.0.
  prefs: []
  type: TYPE_NORMAL
- en: By Pivotal Spring Team [https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0](https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0).
  prefs: []
  type: TYPE_NORMAL
- en: So, let's start by creating and setting up our Spring project.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection and IoC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Inversion of Control** (**IoC**) is a programming technique in which object
    coupling is bound at runtime by an assembler object and is typically not known
    at compile time using static analysis. IoC can be achieved using dependency injection.
    We can say that IoC is the idea and dependency injection is its implementation.
    Now, what is dependency injection? Let''s find out.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dependency injection is a technique where one component supplies dependencies
    for another component during the instantiation time. The definition sounds confusing,
    right? Let''s explain it with an example. Consider the following interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A common implementation of the preceding program will be as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Employee` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And the `Task` interface is implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will create and use the instance of the `RandomEmployee` class in
    the `main` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `RandomTask` class is a simple class implementing an interface `Task`, which
    has a function named `execute`. The `RandomEmployee` class on the other hand depends
    on the `Task` class. Now, what do we mean by depends? By depends, we mean that
    the output of an instance of `Employee` class is dependent on the `Task` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2d67e5c-78c5-46bb-b82c-5e6c33cfb86f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding program would work fine, and actually, it is a text book program.
    In colleges/institutes, when we learned coding for the first time, we learned
    the way to initialize variables and/or properties inside constructors or during
    construction time.
  prefs: []
  type: TYPE_NORMAL
- en: Now, just try to remember what you learned a few chapters earlier. We should
    test everything we write. Now, take a look at the code again—is this piece of
    code testable? Or even maintainable? How would you assure that the right *Employee*
    is given the right *Task*? It's a tightly coupled code.
  prefs: []
  type: TYPE_NORMAL
- en: You should always use coupling concisely. It's true that we cannot achieve much
    without coupling. Tightly coupled code, on the other hand, makes it difficult
    to test and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than letting the objects create their dependencies at the construction
    time, dependency injection provides objects with their dependencies at creation
    time with some third-party class. That third-party class will also coordinate
    with each object in the system. The following diagram shows the general idea behind
    dependency injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d639a1d5-8324-4935-ad92-01867c099882.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This image clearly depicts the flow of dependency injection. There will be a
    Config class (in Spring, there can be an XML Config file or there can be a Config
    class as well) that will create and drive a Bean Container. That Bean Container
    will control the creation of beans or POJOs and will pass them where required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Confused? Let''s get our hands-on code and implement the preceding concept.
    Let''s get started with a brand new implementation of the `Employee` interface
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A `SoftwareDeveloper` class  can only execute `ProgrammingTask`. Now, take
    a look at the XML `config` file shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ProgrammingTask` class, a new implementation of the `Task` interface,
    looks like as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This file should be located at `\src\main\resources\META-INF\employee.xml`.
    Now, let's try to understand the `config` file. We declared each bean using the
    `bean` tag. Then, we used the `constructor-arg` tag to indicate a constructor
    argument in that bean.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to pass another object as a `constructor-argref` in a bean, you
    have to declare that reference object as a bean as well. Alternatively, you can
    pass `constructor-arg value`, as discussed later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The updated `main` function will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Before moving into the details of the preceding program, let''s take a look
    at its output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d986c93d-2532-4879-87d2-80aeff45e8b8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Cropped output of DI with XML Configuration program
  prefs: []
  type: TYPE_NORMAL
- en: The first few red-lined outputs are logs of the Spring Framework. Then, we can
    spot the output as Writing Programms.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's try to understand the program. The `ClassPathXmlApplicationContext`
    is the Bean Container we mentioned in the figure. It creates and keeps record
    of all the beans mentioned in the XML file and provides them to us when asked
    for. The `String` passed in the constructor of `ClassPathXmlApplicationContext`
    is the relative path to the XML configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: On comment `(2)`, we used `context.getBean()` to get the `Employee` instance.
    This function takes a class name as a parameter and creates an instance of that
    class based on the XML configuration.
  prefs: []
  type: TYPE_NORMAL
- en: On comment `(3)`, we closed the `context`. The `context`, as a Bean Container,
    always carries the configuration for you, which keeps the memory blocked. In order
    to clean the memory, we should close the `context`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, as we have some idea about dependency injection via XML configuration file,
    we should move toward the annotation-based configuration class and take a look
    at how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Annotation configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Other than XML, we can also define Spring configuration through annotations
    in a POJO class, which will not be used as a bean. In the previous section, we
    took `Employee` task example; let's now take the `Student`-`Assignment` example,
    a similar one. However, this time, we will not use interfaces; instead, we will
    directly use classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here is the `Assignment` class that takes a lambda as a constructor parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This class takes a lambda as `task`, to execute it later, inside the `performAssignment()`
    method. Here is the `Student` class that takes `Assignment` as a property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'So, `Student` would depend on its `Assignment` and an `Assignment` would depend
    on its task definition (Lambda). The following diagram describes the dependency
    flow for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d938d44-b837-40cc-b715-ee0d9190c556.png)'
  prefs: []
  type: TYPE_IMG
- en: 'How to depict this dependency flow in code? It''s easy with Annotation Config.
    Here is the `Configuration` class that we used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Simple and straightforward, isn't it? The class is annotated with `@Configuration`,
    and the function to return the `Student` and `Assignment` beans is annotated with
    `@Bean`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, how to use this class? Simple, like the previous one, take a look at the
    `main` function here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Instead of `ClassPathXmlApplicationContext`, we used `AnnotationConfigApplicationContext`
    and passed the `Configuration` class. The rest of the program is the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the output of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c62a0eb0-8c8e-46fc-8bd2-93ccd9dce3ae.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Cropped output of DI with Annotation Configuration program
  prefs: []
  type: TYPE_NORMAL
- en: So, we learned dependency injection with Spring. It's really easy, isn't it?
    Actually, the Spring Framework makes everything easy; whatever feature they offer,
    they make it as easy as calling a method from a POJO class. Spring truly utilizes
    the power of a POJO.
  prefs: []
  type: TYPE_NORMAL
- en: So, as we got our hands on dependency injection, let's move forward with Aspect-oriented
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: Spring – AOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before learning how to implement Aspect-oriented programming with Spring, we
    should first learn what Aspect-oriented programming is. The definition of Aspect-oriented
    programming says it is a programming paradigm that aims to increase modularity
    by allowing the separation of cross-cutting concerns. It does so by adding additional
    behavior to existing code (an advice) without modifying the code itself.
  prefs: []
  type: TYPE_NORMAL
- en: Now, what did we mean by cross-cutting concerns? Let's explore.
  prefs: []
  type: TYPE_NORMAL
- en: In a real-life project, multiple components play their own role. For example,
    if we take our previous scenario into account, the `Student` class itself is a
    component, similarly there could be a faculty component who would evaluate the
    student based on his/her performance. So, let's add a faculty to our program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Faculty` class should be simple enough, with just a method to evaluate
    a student. Just as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, how should the faculty grade a student? He/she must somehow know that
    the student has completed an assignment. A common implementation of this business
    logic would be by modifying the `Student` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `Faculty` instance will be passed to a `Student` instance, and, once the
    student is done with performing the assignment, it will call the `Faculty` instance
    and instruct it to evaluate the assignment. However, think again. Is this a proper
    implementation? Why should a student instruct his/her faculty? It's the faculty's
    job to evaluate assignments of a student; it just needs to get notified somehow.
  prefs: []
  type: TYPE_NORMAL
- en: That very thing is known as a cross-cutting concern. `Faculty` and `Student`
    are different components of the program. They shouldn't have direct interaction
    at the time of the assignment review.
  prefs: []
  type: TYPE_NORMAL
- en: 'AOP let''s implement the same. So, here, the `Student` class will be back to
    almost its original state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Did you notice the differences in the actual code for the `Student` class in
    the previous section? Yes, here we added `open` keyword to the class declaration
    and all the properties and functions of the class. The reason is that, to implement
    AOP, Spring sub-classes our beans and overrides methods (including getters of
    our properties). However, with Kotlin, everything is final unless you specify
    it as open, and that will block Spring AOP to accomplish its purpose. So, in order
    to make Spring work, we have to mention each property and method as open.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main` method will be similar, except that we are back to XML-based configuration.
    Take a look at the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The only file with new things is the configuration file. Take a look at the
    configuration file here before we explain it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: So, let's explain the configuration. On comment `(1)`, we declared a new bean
    named `faculty`, although it really isn't a new thing to you and you may have
    already expected it. I mentioned it in order to prepare you for the next few lines.
  prefs: []
  type: TYPE_NORMAL
- en: On comment `(2)`, we indicated that the AOP configuration begins. On comment
    `(3)`, we indicated that this AOP is regarding the `Faculty` class, as the `Faculty`
    class is the class that should be notified.
  prefs: []
  type: TYPE_NORMAL
- en: On comment `(4)`, we declared `pointcut`. A `pointcut` is like a bookmark on
    a method, so whenever that method is called, your class should get notified. The
    `id` field denotes the `id` for that `pointcut`, so that you can refer to it in
    your code. The expression field denotes the expression for which we should create
    the `pointcut`. Here, with the execution expression, we stated that the `pointcut`
    should be on execution of the `completeAssignment` method.
  prefs: []
  type: TYPE_NORMAL
- en: On comment `(5)`, we declared the method in `Faculty` class that should get
    called after the `pointcut` expression is executed. We can also declare a method
    to execute before `pointcut` by using `aop:before`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now, let''s take a look at the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a19345db-f043-4316-ad37-e7c8f6ee1d73.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Cropped output of DI with Spring AOP program
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `evaluateAssignment` method is called from the `Faculty`
    class every time we call the `completeAssignment` method, apparently, with no
    code, but only with configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we are now familiar with Spring, especially with Spring DI and AOP. Spring
    Boot makes a developer's life easier. So far, we've seen how to perform various
    operations just by using POJO classes and Spring configurations. What would be
    your reaction if I tell you that we can even minimize this configuration? Will
    you be shocked? Then brace yourself, because it's true. With Spring Boot, you
    can get your code ready with minimal configuration and in just a few steps.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is Spring Boot? It is a Spring module that provides **RAD** (**Rapid
    application development**) features to the Spring Framework. It is designed to
    simplify the bootstrapping and development of new Spring applications. The framework
    takes an opinionated approach to configuration, freeing developers from the requirement
    to define boilerplate configurations, further reducing your development time.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s get started. If you are using the IntelliJ IDEA Ultimate edition,
    you can follow these steps to create a Spring Boot application:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a New Project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the New Project dialog, select Spring Initializr, define Project SDK,
    and click on Next, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1e14e69a-b5a2-45d1-87d7-487f052952ab.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'On the next screen, define the Group, Artifact, Type (Gradle or Maven), Language
    (Java/Kotlin), Packaging (Jar/War), Java Version, Name, and root package for the
    project, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a5e6b338-6453-455e-ae70-13b215a68658.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next screen lets you select multiple Spring dependencies. Make sure to
    set the Spring Boot version to 2.0.0 M6 and above in this screen. For AOP and
    DI, you need to select Aspects under Core, as shown in the screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c0a487cd-5222-446e-ad38-0f2c3ec482f3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Provide Project name and location and click on Finish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Wasn''t it quite easy? Don''t get upset if you don''t have IntelliJ IDEA Ultimate.
    Spring Boot is for everyone. Follow these steps to create a new Spring Boot project
    for whatever IDE you have:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [http://start.spring.io/](http://start.spring.io/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Provide the following details, which are similar to IntelliJ IDEA:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ef1f3344-e47a-4e47-857b-51e2d305ffb7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click on Generate Project. The project will get downloaded to your machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wasn't it simple enough? Let's try our hands at creating APIs with Spring.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Rest API with Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen the power of Spring and Spring Boot. So, let's use it without any
    further delay. We will build a RESTful web service that will return a `Todo` object.
    We will further enhance this project in the next chapter, where we will add `Todo`
    and fetch a list of `Todo` from the database. We will use JPA and Hibernate along
    with Spring for that purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we are done with this example, we should get the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d225d4c-79ae-4b5e-9211-07c844f9b455.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Cropped screenshot of browser output
  prefs: []
  type: TYPE_NORMAL
- en: So, let's start by creating a new project. You can use [http://start.spring.io/](http://start.spring.io/)
    or you can use IntelliJ IDEA as well to create a new project.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you have created the new project, you will see that there''s an `Application`
    class; don''t give much focus to it, it''s there in almost all Spring Boot applications.
    We need to create a new class for `Todo`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'A REST API requires us to create `RestController`, which would be the endpoint
    for API requests, so here''s our `RestController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Study this small class carefully. First, we annotated our class with `@RestController`
    and `@RequestMapping`. The purpose of them is simple `@RestController` denotes
    that this class will act as a `Controller`, that is, all API requests should pass
    through this class, `@RequestMapping("/api")` denotes that the URL of this class
    will have an `/api` suffix after your base URL (note that the URL in the screenshot
    is `http://127.0.0.1:8080/api/get_todo`). We can skip the second annotation if
    we want for this class.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have the `getTodo()` function; the `@RequestMapping` annotation is
    required for this method as it will define the endpoint. This method is also simple—it
    just returns a new object of `Todo`, statically created.
  prefs: []
  type: TYPE_NORMAL
- en: 'What? Are you expecting anything more? Sorry to disappoint you, but we are
    done with the API. You can just run the project and hit `http://127.0.0.1:8080/api/get_todo`
    to get the following JSON response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Isn't it simple enough?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you were introduced to Spring with Kotlin. We learned about
    dependency injection and Aspect-oriented programming. We learned how a simple
    POJO class can show great power with the help of the Spring Framework. In this
    chapter, we also learned to create a simple API with Spring.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on enhancing our API to a fully functional
    one with the help of JPA and Hibernate to work with MySQL database. We will also
    learn to implement reactive programming with Spring.
  prefs: []
  type: TYPE_NORMAL
- en: So, don't wait! Head over to the next chapter right now. Our API is still incomplete.
  prefs: []
  type: TYPE_NORMAL
