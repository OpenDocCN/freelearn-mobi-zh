<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;Exploring Bus-based Communications"><div class="titlepage"><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Exploring Bus-based Communications</h1></div></div></div><p>In previous chapters, we have been using different techniques to disseminate data/events/notifications between several Android application components (<code class="literal">Activity</code>, <code class="literal">Fragment</code>, <code class="literal">Service</code>, <code class="literal">BroadcastReceiver, …</code>):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Intents were sent through the system carrying communication messages or notifications to notify a <code class="literal">Service</code> or <code class="literal">Activity</code> to start</li><li class="listitem" style="list-style-type: disc">Broadcast Intents were used to report a result back from background processes</li><li class="listitem" style="list-style-type: disc">Handlers were used to communicate between different processes and thread executions</li></ul></div><p>These techniques usually involved a tight coupling between the component that sends the message and the component that receives it. Typically, the sender dispatches a message to a certain receiver and deals with the receiver lifecycle in order to detect any receiver unavailability.</p><p>In this chapter, we are going to present to the reader a new construct and pattern, delivered by the <code class="literal">EventBus</code> library, that most of the time simplifies communication between the different application components by decoupling the event producer and event consumer component.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Introducing bus-based communication</li><li class="listitem" style="list-style-type: disc">Setting up an <code class="literal">EventBus</code> library in your project</li><li class="listitem" style="list-style-type: disc">Defining and dispatching events in the Bus</li><li class="listitem" style="list-style-type: disc">Registering subscribers</li><li class="listitem" style="list-style-type: disc">Processing events asynchronously with <code class="literal">threadMode</code></li><li class="listitem" style="list-style-type: disc">Posting and removing sticking events</li></ul></div><div class="section" title="Introduction to bus-based communication"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec83"/>Introduction to bus-based communication</h1></div></div></div><p>The Bus based <a id="id622" class="indexterm"/>communication software pattern, also known as Publish/Subscribe, is a pattern that allows sender and receiver entities to communicate without requiring them to explicitly know each other. This communication model suppresses the tight coupling between components and allows the delivery of messages from one receiver to more than one final recipient. There are five different entities involved in the communication pattern: publisher, subscriber, event, bus, and broker.</p><p>The <span class="strong"><strong>publisher</strong></span> submits <a id="id623" class="indexterm"/>events to a shared messaging pipeline, named <span class="strong"><strong>bus</strong></span>, controlled by an entity called <a id="id624" class="indexterm"/><span class="strong"><strong>broker</strong></span>, that governs the stream of events submitted and forwards them to a list of interested entities, called <span class="strong"><strong>subscribers</strong></span>, that previously registered in the <a id="id625" class="indexterm"/>broker to receive certain kinds of event.</p><p>In order to receive certain kinds of event, the subscriber should express interest in these events by creating a subscription in the broker and the broker should keep a list of enabled subscriptions and forward the events to all of the subscribers.</p><p>If a consumer loses interest in one kind of event, it terminates the subscription, and as a consequence, the broker will stop forwarding the unsubscribed events related to the subscriber.</p><div class="mediaobject"><img src="graphics/Image_B05062_11_01.jpg" alt="Introduction to bus-based communication"/></div><p>In this loosely coupled communication model, the publisher submits event A in the shared bus without knowing the exact subscriber that will consume the event. In the same way, the subscriber does not know about the sender entity that submitted the event unless something is sent in event A to identify the event's origin.</p><p>On Android <a id="id626" class="indexterm"/>specifically, it could simplify the communication between <code class="literal">Fragments</code>, <code class="literal">Activities</code>, <code class="literal">Services</code>, or any other business logic object, such as persistence service, that manages your application or UI state. In our examples, we will use the library to send notifications between activies and fragments. However, the same kind of construct could be applied to communicate between services and broadcast receivers.</p></div></div>
<div class="section" title="EventBus library"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec84"/>EventBus library</h1></div></div></div><p>Although there are <a id="id627" class="indexterm"/>several open source libraries that are able to deliver this kind of pattern in Android, we will base our code examples on the popular event bus <a id="id628" class="indexterm"/>library (<a class="ulink" href="http://greenrobot.org/eventbus/">http://greenrobot.org/eventbus/</a>) since it offers advanced features and high performance.</p><p>The high performance library is optimized for the Android OS and it has been used by many popular applications on Google Play.</p><p>These are the advanced features delivered by the <code class="literal">EventBus</code> library that you should be aware of:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Annotation-based subscription – You can define an subscription method by annotating an Android <code class="literal">Activity</code>, <code class="literal">Service</code>, or <code class="literal">Fragment</code> instance method</li><li class="listitem" style="list-style-type: disc">Background and main thread event delivery – The subscriber could define in which thread the event will be delivered regardless of whether it was generated in a background or main thread</li><li class="listitem" style="list-style-type: disc">Event and subscriber inheritance – We can construct events or subscribers by extending (Java subclass) other events or subscribers:<div class="informalexample"><pre class="programlisting">class OtherEvent extends MyEvent</pre></div></li><li class="listitem" style="list-style-type: disc">No configuration required – The library, by default, allows us to use a ready-to-use default <code class="literal">Bus</code> that does not require explicit instantiation, and can be used to submit events from anywhere in the application:<div class="informalexample"><pre class="programlisting">EventBus.getDefault().post(new MyEvent());</pre></div></li></ul></div><p>Before we start using it, we will add the GreenRobot <code class="literal">Eventbus</code> dependency to our module or application <code class="literal">build.gradle</code> file:</p><div class="informalexample"><pre class="programlisting">dependencies {
   compile 'org.greenrobot:eventbus:3.0.0'
}</pre></div><p>Before we go deeper, we will present a simple example in which we use the library to publish a simple event from a <code class="literal">BroadcastReceiver</code> to an <code class="literal">Activity</code>. Thus, the <code class="literal">Activity</code> receiver method will deliver a notification on the screen.</p><p>First, we will create a <a id="id629" class="indexterm"/><code class="literal">BroadcastListener</code> that listens for network changes and submits an event in the <code class="literal">Bus</code> when the mobile network is not available and an event with a detailed network state when the device mobile network is available. The events will be propagated in the <code class="literal">Bus</code> and delivered to all the subscribers interested in them, which in our case, will be an <code class="literal">Activity</code> that will display a message on the screen that shows the mobile network state.</p></div>
<div class="section" title="Defining events"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec85"/>Defining events</h1></div></div></div><p>First, we will <a id="id630" class="indexterm"/>define the POJO classes that would be submitted in the <code class="literal">Bus</code> by the publisher to notify the interested entities whether the mobile network connectivity is available or not:</p><div class="informalexample"><pre class="programlisting">public class MobileNetConnectedEvent{
  public final String detailedState;
  public MobileAvailableEvent(String detailedState) {
    this.detailedState = detailedState;
  }
}
public class MobileNetDisconnectedEvent {}</pre></div><p>The <code class="literal">MobileNetConnectedEvent</code> event is a POJO class that will be sent when the mobile network is available and will carry a string message with the detailed network state.</p><p>The <code class="literal">MobileNetDisconnectedEvent</code> is an event that does not carry any information but it will notify the event subscriber that connection with the network was lost.</p></div>
<div class="section" title="Submitting events"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec86"/>Submitting events</h1></div></div></div><p>Now with events <a id="id631" class="indexterm"/>defined, we will create the <code class="literal">BroadcastListener</code> that is going to receive Intents from the Android OS when any network connectivity changes (Wi-Fi, Mobile, …) occur on the device, and submits the events in the Bus when the mobile connectivity has changed:</p><div class="informalexample"><pre class="programlisting">public class MobileNetworkListener extends BroadcastReceiver {

  @Override
  public void onReceive(Context context, Intent intent) {
	 // Retrieve the NetworkInfo from the received Intent
    NetworkInfo info =(NetworkInfo)intent.
      getExtras().get(ConnectivityManager.EXTRA_NETWORK_INFO);
    if ( isMobileNetwork(context, info) &amp;&amp; !info.isConnected()) {
	   // Publish an mobile network disconnected Event
      EventBus.getDefault().post(
        new MobileNetDisconnectedEvent());
    } else if ( isMobileNetwork(context, info) &amp;&amp; 
                info.isConnected()) {
      // Publish an mobile network connected Event
      EventBus.getDefault().post(
        new MobileNetConnectedEvent(info.getState().toString()));
    }
  }
  public boolean isMobileNetwork(Context context, 
                             NetworkInfo info) {
    return info != null &amp;&amp; 
           (info.getType() == ConnectivityManager.TYPE_MOBILE);
  }
}</pre></div><p>As we described <a id="id632" class="indexterm"/>before, the default and ready-to-use <code class="literal">EventBus</code> could be retrieved from anywhere in our application, so, when a network change event is received regarding the mobile network, we just get the default Bus by invoking <code class="literal">EventBus.getDefault()</code> and we submit an event to it by calling the <code class="literal">Bus.post(Object event)</code> function.</p><p>Note that we will identify a network based on the <code class="literal">NetworkInfo</code> received in the <code class="literal">ConnectivityManager.EXTRA_NETWORK_INFO</code> Intent extra.</p><p>When a network change related to the mobile network is detected, we submit either <code class="literal">MobileNetConnectedEvent</code> or a <code class="literal">MobileNetDisconnectedEvent</code> in the default <code class="literal">Bus</code>.</p></div>
<div class="section" title="Registering sbscribers"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec87"/>Registering sbscribers</h1></div></div></div><p>With the <code class="literal">Publisher</code>/<code class="literal">Sender</code> <a id="id633" class="indexterm"/>class and event class already specified, all that remains is to register our <code class="literal">Activity</code> class to receive both events and print the event sent on the screen.</p><p>Like we stated before, to receive any event from the <code class="literal">Bus</code>, the <code class="literal">Subscriber</code> entity, which could be any Java class on your code, will have to register on the Bus and subscribe to the event that it is interested in.</p><p>Any object will have to register on the Bus by calling the register function and provide a single on<code class="literal">&lt;EventName&gt;(EventType)</code> method annotated with <code class="literal">org.greenrobot.eventbus.Subscribe</code> for all the kind of event that it is interested in:</p><div class="informalexample"><pre class="programlisting">@Subscribe
void on&lt;EventClassname&gt;(EventClassname event) {
 ...
}</pre></div><p>Let's implement the functions that are going to handle the <code class="literal">MobileNetDisconnectedEvent</code> and the <code class="literal">MobileNetConnectedEvent</code> event in our Activity:</p><div class="informalexample"><pre class="programlisting">@Subscribe
public void 
onMobileNetDisconnectedEvent(MobileNetDisconnectedEvent event){

  String message = String.format(
    "Mobile connection is not available \n");
  appendToConsole(message);
}

@Subscribe
public void 
onMobileNetConnectedEvent(MobileNetConnectedEvent event){

  String message = String.format(
    "Mobile connection is available State - %s\n",
    event.getDetailedState());
  appendToConsole(message);
}</pre></div><p>Both public callbacks have the @Subscribe annotation and an <code class="literal">MobileNetDisconnectedEvent</code>/<code class="literal">MobileNetConnectedEvent</code> object as the only method argument. Hence, whenever any of these events are posted on the Bus by our <code class="literal">BroadcastReceiver</code> sender and the <code class="literal">Activity</code> has already subscribed to them, our callbacks are notified, appending a new message on the UI console screen.</p><p>Finally, to register our <code class="literal">Activity</code> on the default Bus, we will override the <code class="literal">onStart</code> and <code class="literal">onStop Activity</code> functions to register and unregister, respectively:</p><div class="informalexample"><pre class="programlisting">    @Override
    public void onStart() {
        super.onStart();
        EventBus.getDefault().register(this);
    }

    @Override
    protected void onStop() {
        EventBus.getDefault().unregister(this);
        super.onStop();
    }</pre></div><p>Once we register our <a id="id634" class="indexterm"/>class object, the Bus will transverse the <code class="literal">Activity</code> methods using the reflection API and check for any methods that are annotated with the <code class="literal">Subscribe</code> annotation. Once it finds any <code class="literal">@Subscribe</code> annotated methods with a POJO Event as an argument, it will register the instance method to be invoked when the event is published on the <code class="literal">Bus</code>.</p><p>As soon as our <code class="literal">Activity</code> is destroyed, we terminate the bus subscription and the <code class="literal">Bus</code> will stop sending the events. In any Android component, such as <code class="literal">Activity</code>, Fragment, and <code class="literal">Service</code>, we should register and unregister on the Bus according to the component lifecycle. It is really important to unregister the components from the Bus, otherwise the Bus will maintain a reference to the registered component and prevent it from being garbage collected. As a result, it will generate a memory leak in the application.</p></div>
<div class="section" title="Thread mode"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec88"/>Thread mode</h1></div></div></div><p>
<code class="literal">EventBus</code>, by <a id="id635" class="indexterm"/>default, delivers the event in the subscriber in the same thread where the sender posted the event. Although this delivery scheme might work for most use cases, such as events that perform Android UI changes, when a long operation is executed in the event callback, the subscriber might block the main thread and prevent the system from running the UI rendering in time and drop some UI frames as a result.</p><p>To cope with time-consuming operations that might happen during the event delivery, the <code class="literal">EventBus</code> library allows us to define the Thread in which the <code class="literal">Bus</code> will call to deliver the event to the subscriber (<code class="literal">ThreadMode</code>).</p><p>There are four modes supported by <code class="literal">EventBus</code> that we can use to control the event delivering behavior:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ThreadMode.POSTING</code> – The subscribers callback will be invoked in the same thread where the sender posted the event. This is default behavior and the events will be delivery synchronously to all the entities that subscribed to the dispatched event.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ThreadMode.MAIN</code> - The Bus will invoke the subscriber's callback in the main UI thread. Thus, if the sender is running in the background thread when it posts the event <a id="id636" class="indexterm"/>to the <code class="literal">Bus</code>, the bus will queue the message in the main <code class="literal">Looper</code> and the event will get delivered in the main thread. For more details about how <code class="literal">Looper</code> and Handlers work, see <a class="link" href="ch02.html" title="Chapter 2. Performing Work with Looper, Handler, and HandlerThread">Chapter 2</a>, <span class="emphasis"><em>Performing Work with Looper, Handler, and HandlerThread</em></span>. When the event is produced in the main thread it behaves as the <code class="literal">ThreadMode.POSTING </code>mode.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ThreadMode.BACKGROUND</code> – The bus will invoke the subscriber's callback in a background thread that prevents the event handling from blocking the UI thread. Notice that <code class="literal">EventBus</code> uses only one background thread to invoke all the callbacks, so, any long-running component could defer the delivery of subsequent events. When the event is produced in the background thread it is in the <code class="literal">ThreadMode.POSTING</code> mode.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ThreadMode.ASYNC</code>- The Bus will invoke the subscriber's callback using a group of threads managed by the Bus. The thread pool of worker threads, created from <code class="literal">Executors.newCachedThreadPool</code>, is going to be recycled and might be used to execute blocking operations, such as network or long computing operations.</li></ul></div><p>You should set the thread mode required for your example based on the kind of processing required to consume the Event. For example, when the consumer updates the UI a <code class="literal">ThreadMode.MAIN</code> should be explicitly specified if the producer could post an event from the background thread. In other use cases, if the consumer does blocking or intensive operations you should use the <code class="literal">ThreadMode.ASYNC</code> mode to span the events over a group of threads.</p><p>To explicitly determine in which thread the method is to be called by <code class="literal">EventBus</code>, we must specify the <code class="literal">threadMode</code> property in the <code class="literal">Subscribe</code> annotation:</p><div class="informalexample"><pre class="programlisting">// Execute the callback on a  Background Thread 
// managed by EventBus
@Subscribe(threadMode = ThreadMode.BACKGROUND )
public void onMyEvent(MyEvent event) {...}</pre></div><p>Typically, an Android application requires tasks to run background work to obtain dynamic data from the network service or from a content service. The data retrieved is then dispatched to the main thread to be presented in the UI main thread. In previous chapters, we used different techniques (AsyncTask, Loader, and HTTP Async client) to accomplish this. In our next example, we are going to use <code class="literal">ThreadMode.BACKGROUND</code> mode to perform an IO blocking operation that retrieves product information using an <code class="literal">EventBus</code> asynchronous background thread pool.</p><p>With the results from the previous operation, we will build an event with product details that will be reported back to the main UI thread to update the product on the screen.</p><p>Our <code class="literal">Activity</code> will <a id="id637" class="indexterm"/>present a <code class="literal">Fragment</code> with the product details and <span class="strong"><strong>Next</strong></span> and <span class="strong"><strong>Previous</strong></span> buttons to browse between the product list. As explained before, we will use the <code class="literal">EventBus</code> to dispatch an event details request to a background thread and we will use an event to publish the results back from the Activity background method to the <code class="literal">DetailsFragment </code>fragment.</p><p>First, we will define the <code class="literal">RetrieveProductEvent</code> and <code class="literal">ProductDetailEvent</code> POJOs used to model a product details request and to model the product details:</p><div class="informalexample"><pre class="programlisting">public class RetrieveProductEvent {

    // Product Identifier
    final long identifier;
    ...
}

public class ProductDetailEvent {

    final long identifier;
    final String brand;
    final String name;
    final float price;

    ...
}</pre></div><p>Then, we will create the <code class="literal">Fragment</code> that is going to register on the <code class="literal">Bus</code> and subscribe to receive the <code class="literal">ProductDetailEvent</code> events with the product data. As you know, it's essential to register and unregister the <code class="literal">Fragment</code> on the bus in order to prevent leaked memory resources, so, we <a id="id638" class="indexterm"/>will use the <code class="literal">Fragement</code> <code class="literal">onResume</code> and the <code class="literal">onPause</code> lifecycle callbacks to <code class="literal">accomplish</code> that:</p><div class="informalexample"><pre class="programlisting">public static class DetailFragment extends Fragment {

  @Override
  public void onResume() {
    EventBus.getDefault().register(this);
    super.onResume();
  }

  @Override
  public void onPause() {
    EventBus.getDefault().unregister(this);
    super.onPause();
  } 
  ...
}</pre></div><p>Given that we want to update the UI when we receive the <code class="literal">ProductDetailEvent</code>, we will create a subscriber that runs on <code class="literal">ThreadMode.MAIN</code> thread mode, and therefore, receives the event callback in the main <code class="literal">Thread</code>:</p><div class="informalexample"><pre class="programlisting">public static class DetailFragment extends Fragment {
  ...
  @Subscribe(threadMode = ThreadMode.MAIN)
  public void onProductDetailEvent(ProductDetailEvent event) {
    Log.i(TAG,"Product details received for identifier"
               +event.identifier+" on" +   
               Thread.currentThread().getName());       
    // Update the Product Details on the UI
    brandTv.setText(event.brand);
    nameTv.setText(event.name);
    priceTv.setText(Float.toString(event.price));
  }

  @Override
  public View onCreateView(LayoutInflater inflater,
                           ViewGroup container,
                           Bundle savedInstanceState) {
    // Inflate the layout for this fragment
    return inflater.inflate(R.layout.detail_fragment, 
                            container, false);
  }

  @Override
  public void onViewCreated(View view, 
    Bundle savedInstanceState) {
    // Initialize the UI widgets
    ...
   }
}</pre></div><p>Following that, we will create the Activity that loads the <code class="literal">DetailsFragment</code> and will request to load the first <a id="id639" class="indexterm"/>product (<code class="literal">productId=0</code>) from the product catalogue:</p><div class="informalexample"><pre class="programlisting">public class PaginatedActivity extends FragmentActivity {

  int productId = 0;

  @Override
  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.paginated_layout);

    // Loads the Details Fragment
    FragmentManager fragmentManager = getSupportFragmentManager();
    FragmentTransaction fragmentTransaction = fragmentManager.
                                              beginTransaction();
    DetailFragment fragment = new DetailFragment();
    fragmentTransaction.add(R.id.detail_fragment, fragment);
    fragmentTransaction.commit();

    // Request to load the first product
    EventBus.getDefault().post(
       new RetrieveProductEvent(productId));
    ...
  }
  @Override
  public void onStart() {
    super.onStart();
    EventBus.getDefault().register(this);
  }
  @Override
  protected void onStop() {
    EventBus.getDefault().unregister(this);
    super.onStop();
  }
}</pre></div><p>The <code class="literal">Activity</code> will create a <code class="literal">FragmentTransaction</code> to the <code class="literal">DetailsFragment</code> and commit it to the <code class="literal">FragmentManager</code>. To conclude, it will post an event on the bus to load the first new product <a id="id640" class="indexterm"/><code class="literal">RetrieveProductEvent(productId)</code>.</p><p>Next, we are going to implement the subscriber method that is going to process the <code class="literal">RetrieveProductEvent</code>, obtain the product details for the specified identifier in the background, and dispatch the new product details event to all the interested entities:</p><div class="informalexample"><pre class="programlisting">@Subscribe(threadMode = ThreadMode.ASYNC)
public void onRetrieveProductEvent(RetrieveProductEvent event) {
  Log.i(TAG, "Retrieving the product " + event.identifier 
              + " on " + Thread.currentThread().getName());

  // Retrieve on background the product details 
  // for the product with the event.identifier id
  ProductDetailEvent pde = ...;

  // Post an EventDetailsEvent on the Bus to 
  // publish the event details for the product requested
  EventBus.getDefault().post(pde);
}</pre></div><p>Using <code class="literal">ThreadMode.ASYNC</code>, we will force the <code class="literal">EventBus</code> to invoke the callback on one of the Threads available in the <code class="literal">EventBus</code> asynchronous thread pool. This thread mode is used to perform asynchronous operations that might block for some time or take some time to execute, such as long computation calculations or network operations.</p><p>Based on the thread mode defined by you, <code class="literal">EventBus</code> will manage all the thread switching required to deliver to events in the right group of threads or thread, regardless of whether the event is dispatched from the main thread or a background thread.</p><p>When the details of the product requested are loaded, the returned <code class="literal">ProductDetailEvent</code> object is posted on the Bus for further processing.</p><p>Given that the <code class="literal">DetailsFragment</code> has the function onProductDetailEvent subscribed to receive the <code class="literal">ProductDetailEvent</code> in the main thread, the bus broker will call the function in the UI thread updating the <code class="literal">brandTv</code>, <code class="literal">nameTv</code>, <code class="literal">priceTv</code>, and <code class="literal">TextView</code> widgets with the product details.</p><p>With the <code class="literal">EventBus threadMode</code> feature, we could submit events to the main thread from any thread in the application and we can even hand over work to background lines of execution using a clean and simple interface.</p><p>Just to conclude the <a id="id641" class="indexterm"/>example, we will add two buttons to browse between the product list sequence. The <span class="strong"><strong>Next</strong></span> button will submit a <code class="literal">RetrieveProductEvent</code> request to get the next product on the list and the <span class="strong"><strong>Previous</strong></span> button will submit a <code class="literal">RetrieveProductEvent</code> to get the previous product on the list:</p><div class="informalexample"><pre class="programlisting">@Override
public void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);
  setContentView(R.layout.paginated_layout);
  ...
  // Submit an event to load the next Product
  Button next = (Button)findViewById(R.id.next);
  next.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
      EventBus.getDefault().post(
        new RetrieveProductEvent(++productId));
    }
  });  
  // Submit an event to load the previous Product
  Button prev = (Button)findViewById(R.id.previous);
  prev.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
      if ( productId &gt; 0 ) {
        EventBus.getDefault().post(
       new RetrieveProductEvent( --productId ));
      }
    }
  });
}</pre></div><p>Using the <code class="literal">Publish</code>/<code class="literal">Subscribe</code> pattern delivered by EventBus, we were able to update the <code class="literal">DetailFragment</code> without sharing a strict interface with the <code class="literal">Activity</code>. Moreover, the event might have come from any other Android component and the result would have been dispatched in the main thread by Event Bus.</p></div>
<div class="section" title="Posting sticking events"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec89"/>Posting sticking events</h1></div></div></div><p>Whenever we <a id="id642" class="indexterm"/>publish an event on the bus, the EventBus broker automatically delivers the event to all the current subscribers, and by default, will immediately clear the transient event. The new subscribers that register after the event is delivered to the current subscribers will not get the event.</p><p>There are situations when a new subscriber registers on the bus and no new event is produced or submitted on the Bus for a long period of time. As such, the subscriber will wait until the next event appears on the bus to produce any output from it.</p><p>Furthermore, when the new subscriber is responsible for updating an Android UI component like an <code class="literal">Activity</code> or a <code class="literal">Fragment</code>, the subscribers have to wait for a new event to occur, hence, it might delay the UI update for a significant amount of time.</p><p>To solve this problem, the <code class="literal">EventBus</code> allows us to create <code class="literal">Sticky</code> events that are kept in the memory and delivered to subscribers once they register on the Bus. <code class="literal">EventBus</code> will keep the latest event of certain types in the memory and deliver it during the registration whenever the subscriber creates a subscription with sticky delivered on.</p><p>To deliver a sticky event on the bus, the only thing that we need to do is invoke the <code class="literal">Bus.postSticky</code> function rather than the post function:</p><div class="informalexample"><pre class="programlisting">void postSticky(new MyEvent())</pre></div><p>And create a <code class="literal">Subscriber</code> method with the <code class="literal">sticky</code> property enabled:</p><div class="informalexample"><pre class="programlisting">  @Subscribe(sticky = true)
  public void onMyEvent(MyEvent event)</pre></div><p>As an example, the <code class="literal">LocationManager</code> service allows us to create a <code class="literal">LocationListener</code> that receives the current geographical location when the device's location changes by a certain <code class="literal">minDistance</code>:</p><div class="informalexample"><pre class="programlisting">LocationManager.
requestLocationUpdates(String provider,  // GPS or NETWORK
                       long minTime, float minDistance, 
                       LocationListener listener)</pre></div><p>If we use <code class="literal">LocationListener</code> to publish non-sticky <code class="literal">LocationEvent</code>s on the Bus and the device's location does not change for a long period of time, new subscribers will have to wait until the device position changes to receive the current position from the Bus:</p><div class="informalexample"><pre class="programlisting">public class LocationEvent {

    final double latitude; // location latitude in degrees.
    final double longitude; // location longitude in degrees.

    LocationEvent(double latitude, double longitude) {
        this.latitude = latitude;
        this.longitude = longitude;
    }
}</pre></div><p>Moreover, to reduce the device's energy consumption, the minimum time between location updates (<code class="literal">minTime</code>) should be significant enough to be noticeable by the application user in order to remove the waiting time for the next event the will have the sticky event technique.</p><p>If we register our <a id="id643" class="indexterm"/><code class="literal">Subscriber</code> method with sticky delivery enabled, the new sticky registration will immediately get the latest position from the bus, stopping the subscriber from waiting for the next location update posted by the <code class="literal">LocationListener</code>.</p><p>To demonstrate this, first we will create an <code class="literal">Activity</code> that manages its own <code class="literal">LocationListener</code>, receives location updates, and posts sticky <code class="literal">LocationEvent</code> events on the Bus:</p><div class="informalexample"><pre class="programlisting">public class LocationActivity extends Activity {
     
  @Override
  public void onResume() {
    super.onResume();

    LocationManager manager = (LocationManager)
      getSystemService(Context.LOCATION_SERVICE);
	Location location = manager.getLastKnownLocation(
     LocationManager.GPS_PROVIDER);

   // Post the latest known position if available 
   if ( location != null ){
    EventBus.getDefault().postSticky(
            new LocationEvent(location.getLatitude(),
                              location.getLongitude()));
    }
    // Request a location update only if device location changed
    // Minimum time between updates: 5000ms 
    // Minimum distance between location updates: 100 meters
    manager.requestLocationUpdates(
LocationManager.GPS_PROVIDER, 5000, 100, listener);
  }

  @Override
  public void onPause() {
    super.onPause();
    LocationManager manager= (LocationManager)
      getSystemService(Context.LOCATION_SERVICE);
    manager.removeUpdates(listener);
  }

  //Handle location callback events
  private LocationListener listener = new LocationListener() {
    @Override
    public void onLocationChanged(Location location) {
      EventBus.getDefault().postSticky(
        new LocationEvent(location.getLatitude(),
                          location.getLongitude()));
    }
    @Override
    public void onProviderDisabled(String provider) { }
    @Override
    public void onProviderEnabled(String provider) { }
    @Override
    public void onStatusChanged(String provider, 
                                int status, Bundle extras) {}
  };
}</pre></div><p>In the preceding code, we register our anonymous listener to receive location updates when the <code class="literal">Activity</code> enters the foreground and we unregister the listener when the <code class="literal">Activity</code> is paused, to either be destroyed or moved away from the foreground. We register our listener to receive updates almost every five seconds and when the position changes by 100 meters.</p><p>In the meantime, when the <a id="id644" class="indexterm"/>last known position is available from the GPS Location Provider, we post a sticky event on the Bus to deliver the last known position for future subscribers.</p><p>Our <code class="literal">LocationListener</code>, once again, will convert a Location object received by an <code class="literal">onLocationChanged</code> callback to a <code class="literal">LocationEvent</code> object and submit a sticky event on the bus with the callback. This sticky event will update the <code class="literal">EventBus</code> cached <code class="literal">LocationEvent</code> and all sticky <code class="literal">Subscriber</code> methods will immediately get this event once they subscribe.</p><p>Note that we start from the assumption that the GPS Provider is enabled on the device. For a more complete example, before you try to use the <code class="literal">LocationManager</code>, verify whether the GPS Location is available or not and ask the user to enable it on the device settings when the provider is not available.</p><p>Beyond that, in order to <a id="id645" class="indexterm"/>receive location updates, the <code class="literal">android.permission.ACCESS_COARSE_LOCATION</code> or <code class="literal">android.permission.ACCESS_FINE_LOCATION</code> permissions must be declared in the application permissions or requested at the runtime for API Levels greater than 23 (Marshmallow). The full source code is available from the Packt Publishing website. Take a look at the complete source code to appreciate how to request the required Android OS permissions.</p><p>Next, we will create a button that launches new <code class="literal">LocationEvent</code> subscribers that register and unregister on the <code class="literal">Bus</code> immediately:</p><div class="informalexample"><pre class="programlisting">Button newSubs = (Button)findViewById(R.id.launch);
newSubs.setOnClickListener(new View.OnClickListener() {
  @Override
  public void onClick(View v) {

    new Runnable() {
      @Subscribe(sticky = true)
      public void onLocationEvent(LocationEvent event) {
        String locTxt = String.format(
             "Lat[%f] Long[%f]", event.latitude, event.longitude);
        Log.i(TAG, "Last known Location is "+ locTxt);
        // Update the UI with the last position  
        // retrieved from the new Subscriber
        TextView locationTv = (TextView) 
                              findViewById(R.id.location);
        locationTv.setText(locTxt);
   }
      @Override
      public void run() {
        EventBus.getDefault().register(this);
        //...
        EventBus.getDefault().unregister(this);
      }
    }.run();
  }
});</pre></div><p>The code in the button's <code class="literal">OnClickListener</code> will register a new <code class="literal">Runnable</code> object instance on the Bus and unregister after that. During registration, the sticky <code class="literal">Subscriber</code> method, <code class="literal">onLocationEvent</code>, will <a id="id646" class="indexterm"/>immediately get invoked with the previously posted Location sticky object dispatched on the bus by our <code class="literal">LocationListener</code>.</p><p>As soon as it receives a <code class="literal">LocationEvent</code>, the <code class="literal">onLocationEvent</code> method will update the UI with the last position longitute and latitude and print the position on the Android Log. With this approach, a sticky <code class="literal">Subscriber</code> method will not have to wait until the position changes to receive a device position and update the UI.</p></div>
<div class="section" title="Removing sticky events"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec90"/>Removing sticky events</h1></div></div></div><p>In some use cases, it <a id="id647" class="indexterm"/>could be convienient to invalidate a sticky event from the Bus and prevent a cached event from getting delivered to the following Subscribers. EventBus allows us to clear the sticky events by calling the following functions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">removeStickyEvent(&lt;MyEventClass&gt;)</code> – Removes and gets the recent sticky event for the given event type</li><li class="listitem" style="list-style-type: disc"><code class="literal">removeStickyEvent(Object event)</code> - Removes the sticky event if it equals the passed event</li><li class="listitem" style="list-style-type: disc"><code class="literal">removeAllStickyEvents()</code>  - Removes the sticky events for all types</li></ul></div><p>Let's use one <code class="literal">removeStickyEvent</code> function to remove the latest sticky <code class="literal">LocationEvent</code> from the bus:</p><div class="informalexample"><pre class="programlisting">// Check if the sticky event exist on the Bus  
LocationEvent evt = EventBus.getDefault().
                        getStickyEvent(LocationEvent.class);
// Check if the event is null
if ( evt != null) {
  EventBus.getDefault().removeStickyEvent(stickyEvent);
}</pre></div><p>After we remove the sticky event from the bus, the latest <code class="literal">LocationEvent</code> will be removed from the bus and no event is delivered during the registration to new <code class="literal">LocationEvent</code> subscribers.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec91"/>Summary</h1></div></div></div><p>In this chapter, we learned about the publish/subscribe messaging pattern used to communicate between decoupled entities on an Android application. This pattern must be applied to send event notifications or data to one or more Android component recipients.</p><p>Next, we introduced to the reader the <code class="literal">EventBus</code>, an optimized open source library that delivers the publish-subscribe pattern for the Android platform and provides advanced features such as sticky events and asynchronous event delivery.</p><p>Following that, we learned how set up the library, how to model events, and how to dispatch events on the default <code class="literal">Bus</code>. The Bus, a shared entity that receives the events, will act as a broker and proxy for the events to the final recipients that previously subscribed to them.</p><p>We took a detailed look at <code class="literal">Eventbus</code> <code class="literal">threadMode</code> feature of EventBus that allows us to define the thread in which the <code class="literal">Bus</code> delivers the event to the subscriber. Hence, we were able to consume events in different threads (background, main thread, and asynchronous threads) from the posting thread.</p><p>To finish our journey, we learned about sticky events, events that are cached on the Bus and delivered to new sticky subscribers during the registration and prevent such methods from waiting for the next event, in case of the absence of new data.</p></div></body></html>