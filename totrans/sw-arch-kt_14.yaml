- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers the fundamental principles and practices associated with
    system security, with a focus on the aspects that affect software architecture
    and the everyday life of engineers.
  prefs: []
  type: TYPE_NORMAL
- en: It begins by defining key concepts such as **confidentiality**, **integrity**,
    and **availability** (the **CIA** triad), which form the backbone of security
    strategies. The chapter outlines several types of threats, including malware,
    phishing, and insider attacks, highlighting the need for comprehensive risk assessment
    and management.
  prefs: []
  type: TYPE_NORMAL
- en: Next, it explores various aspects of authentication and how it affects the engineering
    design of software features, such as **multi-factor authentication** (**MFA**).
    Then, we will discuss how to use access control to ensure that only authorized
    users can access certain resources.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the chapter addresses compliance with legal and regulatory requirements,
    such as the **General Data Protection Regulation** (**GDPR**) and the **Health
    Insurance Portability and Accountability Act** (**HIPAA**), and it shapes security
    practices. Moreover, we will explore some ways we can handle confidential data
    in the system.
  prefs: []
  type: TYPE_NORMAL
- en: We will delve into how network security shapes software architecture, such as
    security layers, encryption, and secure API designs that protect the system from
    malicious attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will run an exercise of threat modeling with a real-life example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling sensitive data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DevSecOps and threat modeling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find all the code files used in this chapter on GitHub: [https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-14](https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-14)'
  prefs: []
  type: TYPE_NORMAL
- en: The importance of security in software architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**System security** refers to the processes, measures, and practices implemented
    to protect information systems from unauthorized access, misuse, damage, or disruption.
    It includes a wide range of mechanisms aimed at safeguarding the confidentiality,
    integrity, and availability of data and resources within a system.'
  prefs: []
  type: TYPE_NORMAL
- en: System security consists of multiple dimensions, including hardware, software,
    policies, and human factors, to create resistance against malicious threats and
    vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Software systems often handle sensitive information. Sensitive data can be
    grouped into several categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Personally identifiable information (PII)**: Full names, dates of birth,
    addresses, telephone numbers, and personal email addresses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Personal information**: Health insurance policies, medical test results,
    treatment records, prescriptions, education certificates, transcripts, university
    grades, and student identification numbers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authentication credentials**: Passwords, PINs, security questions and answers,
    and fingerprints'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Financial information**: Bank account details, credit card numbers, tax returns,
    financial statements, and income information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Confidential business information**: Client lists, business plans, trade
    secrets, and internal communications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Legal documents**: Contracts, litigation documents, and settlement agreements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intellectual property**: Copyrights, patents, trademarks, source code, user
    activity history, system data, and proprietary algorithms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Government and national security information**: Government contracts, intelligence
    reports, and classified documents'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring security in software architecture shields sensitive data from unauthorized
    access, breaches, and leaks, maintaining confidentiality and privacy.
  prefs: []
  type: TYPE_NORMAL
- en: Security measures protect the integrity of data throughout its life cycle, free
    from unauthorized modifications. This can guarantee that users receive accurate
    and reliable information, which is important for decision-making and trust.
  prefs: []
  type: TYPE_NORMAL
- en: A secure software architecture is designed to withstand vicious attacks and
    ensure that services are available to legitimate users. This is critical for maintaining
    business continuity, building a positive reputation, fostering satisfaction and
    trust among users, and providing competitive advantages.
  prefs: []
  type: TYPE_NORMAL
- en: Many industries are subject to regulations regarding data protection and privacy,
    such as GDPR in the European Union and HIPAA in the United States. Software architecture
    compliant with these regulations protects organizations from legal penalties and
    reputational damage.
  prefs: []
  type: TYPE_NORMAL
- en: Security should be part of the early phase of software architecture design.
    The design process involves identifying potential threats and vulnerabilities.
    Proactively addressing security risks reduces the chance of security incidents
    from day one. It is also more cost-effective to implement security measures early
    than after a breach happens. The financial losses related to legal fees, remediations,
    and loss of business can be massive.
  prefs: []
  type: TYPE_NORMAL
- en: Security threats are constantly evolving, and a well-designed software architecture
    is flexible to incorporate new security technologies and practices. This adaptability
    and extensibility are essential for staying ahead of potential vulnerabilities
    and maintaining a robust security posture.
  prefs: []
  type: TYPE_NORMAL
- en: Security-focused architecture encourages the integration of secure coding practices
    into the software development cycle, such as **DevSecOps**. This cultural shift
    enhances overall security awareness within development teams.
  prefs: []
  type: TYPE_NORMAL
- en: A secure system is supported by logging, monitoring, and alerting mechanisms
    that facilitate quick detection and response to security incidents, as discussed
    in [*Chapter 11*](B21737_11.xhtml#_idTextAnchor358). This is essential for reducing
    damage and recovering from breaches effectively.
  prefs: []
  type: TYPE_NORMAL
- en: By prioritizing security from the beginning, organizations can build resilient
    systems that not only defend against current threats but also adapt to future
    challenges, fostering trust and enhancing their overall business success. One
    of the most discussed foundations of security is the CIA triad, which we are going
    to cover next.
  prefs: []
  type: TYPE_NORMAL
- en: The CIA triad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **CIA triad** is a foundational model in information security that outlines
    the three core principles of information security: **confidentiality**, **integrity**,
    and **availability**. It was initially mentioned in *Computer Security Technology
    Planning Study*, known as *The Anderson Report*, in 1972, authored by a team led
    by William Anderson. The concept was then discussed in the book, *Computer Security
    A Practitioner’s Approach* in the 1980s by Frederick Cohen. The term *CIA triad*
    was coined later by Steve Lipner around 1986\. The CIA triad was popularized by
    Willis Ware in 1993 from his study distributed by the US think tank, **Research
    and Development Corporation** (**RAND**). Since then, it has gained popularity
    in the cybersecurity landscape.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CIA triad is shown in *Figure 14**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1 – The CIA triad](img/B21737_14_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 – The CIA triad
  prefs: []
  type: TYPE_NORMAL
- en: We will briefly introduce each principle in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Confidentiality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Confidentiality** ensures that sensitive information is only accessible to
    authorized individuals or systems. This includes keeping data away from bad actors
    with malicious intent. Individuals within an organization are also subject to
    limits on data access.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Common methods to maintain confidentiality include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication**: Confirm the identity of a user, device, or system. The
    primary goal is to ensure that an entity trying to access a system is who they
    claim to be.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization**: Grant or deny an authenticated identity to specific resources,
    actions, or data within a system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encryption**: Convert readable data into encoded data to prevent unauthorized
    access. Even if unauthorized individuals have obtained encrypted data, they need
    to also have the keys and know the decryption algorithm to unlock the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Redaction**: Retain functionality and usability without exposing sensitive
    information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of these methods will be used and discussed in the sections ahead.
  prefs: []
  type: TYPE_NORMAL
- en: Integrity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Integrity** refers to the accuracy and consistency of data throughout its
    life cycle. This principle ensures that information is not altered or tampered
    with by unauthorized users and that it remains accurate, trustworthy, and reliable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Common techniques to ensure integrity include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Checksums and hash functions**: A fixed-length string calculated from the
    data by an algorithm. Checksums or hash values usually come with the data itself.
    Any tampering with the data would produce a checksum (or hash value) different
    from the original checksum, so it is detected by the system as corrupted data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Digital signatures**: A document is signed by a hash value generated by a
    private key from the sender. The recipient receives the document together with
    the digital signature. The recipient computes the hash value of the document using
    the same algorithm. The recipient decrypts the digital signature using the sender’s
    public key and retrieves the original hash value. Two hash values being identical
    confirms that the document has not been modified. The sender’s private and public
    keys form a pair, whereas the private key is only known to the sender and the
    public key is available to anyone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Versioning control**: Version control systems maintain a complete audit trail
    and history of changes made to a document. If errors or corruptions are detected,
    the document can be reverted to a previous version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Availability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Availability** ensures that information and resources are accessible to authorized
    users when needed. This principle focuses on maintaining system functionality
    and minimizing downtime due to attacks, failures, or other disruptions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Strategies to enhance availability include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Redundancy**: Avoid a single point of failure by having extra components
    and alternative paths to ensure continued operations and data integrity in the
    event of failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load balancing**: Distribute incoming traffic across multiple servers to
    ensure incoming requests are served.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regular backups**: Maintain copies of the database, file storage, and messaging
    store across multiple servers or locations to ensure data availability and to
    recover from data issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disaster recovery planning and drills**: Outline specific steps to take during
    a disaster to bring the system back up and make it operational. Periodically run
    disaster recovery drills to verify the plan and identify gaps. Establish clear
    communication channels to keep engineers and stakeholders informed during a disaster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importance of the CIA triad
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The CIA triad serves as a guiding framework for organizations to develop and
    implement effective security policies and practices. These three principles help
    organizations create a comprehensive approach to information security and protect
    the business from various threats and vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to go deeper into selected subjects that are based on the CIA triad.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Authentication** is the process of verifying the identity of a user or a
    device before granting access to resources. This is the first step of establishing
    trust between two parties. An oversimplified authentication process looks like
    *Figure 14**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2 – Oversimplified interaction of authentication](img/B21737_14_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.2 – Oversimplified interaction of authentication
  prefs: []
  type: TYPE_NORMAL
- en: The client (a user, a device, or a system) initiates the authentication with
    the target system, and it provides credentials to claim who it is. The system
    receives the credentials and starts the verification process. The system acknowledges
    a positive result if it can identify the client, otherwise, a rejection is sent
    back to the entity.
  prefs: []
  type: TYPE_NORMAL
- en: This interaction is merely conceptual as actual authentication has a lot of
    aspects to consider. Firstly, the transport layer needs to be secured to ensure
    there is no eavesdropping, also known as **man-in-the-middle** (**MitM**) attacks.
  prefs: []
  type: TYPE_NORMAL
- en: MitM attack
  prefs: []
  type: TYPE_NORMAL
- en: A MitM attack is a cyberattack where an attacker secretly intercepts and relays
    communication between two parties. The attacker eavesdrops and captures communication
    potentially containing sensitive information. The attack might alter the messages
    exchanged or record them for further malicious intents, such as identity theft
    and financial fraud. MitM attacks can occur in various forms, such as intercepting
    unencrypted Wi-Fi traffic, exploiting vulnerabilities in secure communications,
    or tricking users into connecting to malicious networks. The attack threatens
    the confidentiality and integrity of communication among individuals and organizations.
  prefs: []
  type: TYPE_NORMAL
- en: Transport Layer Security (TLS)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Transport Layer Security** (**TLS**) plays a significant role in securing
    communications over networks, as a defense against threats, such as MitM, we have
    just mentioned.'
  prefs: []
  type: TYPE_NORMAL
- en: TLS evolved from its predecessor, **Secure Sockets Layer** (**SSL**). SSL was
    first developed by Netscape in 1994, as a protocol aimed to provide secure communications
    over the internet. It was never published due to security flaws. Subsequently,
    SSL 2.0 and SSL 3.0 were released, but they still faced vulnerabilities that led
    to the need for further development.
  prefs: []
  type: TYPE_NORMAL
- en: TLS was first released in 1999\. It was based on SSL 3.0 but it addressed the
    weaknesses of SSL and it provided better support for modern cryptographic algorithms.
    Subsequent versions of TLS have brought significant improvements in security and
    performance. TLS is widely used in various ways to secure communications on the
    internet, such as secure web browsing, email content encryption, secure messaging,
    **virtual private networks** (**VPNs**), and secure inter-system communications.
  prefs: []
  type: TYPE_NORMAL
- en: 'TLS requires the client and server to exchange a few rounds of messages to
    establish a secure transport communication. TLS is built on top of **Transmission
    Control Protocol** (**TCP**). The first few steps are the messages exchanged to
    establish a TCP connection. Afterward, there are a few exchanges of messages to
    establish a TLS communication:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client hello**: The client initiates TLS by sending to the server a message
    specifying supported TLS versions, cipher suites (known as encryption algorithms),
    and a random number generated by the client.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Server hello**: The server responds with its chosen TLS version and cipher
    suite, and a random number generated by the server.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Server certificate**: The server sends its TLS certificate containing the
    server’s public key and is signed by a trusted **certificate authority** (**CA**).
    Certain cipher suites require the server to include additional key exchange parameters.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CA
  prefs: []
  type: TYPE_NORMAL
- en: A CA is a trusted entity that issues digital certificates to verify the identity
    of individuals, organizations, or devices within a secure communication framework.
    CAs play a crucial role in **public key infrastructure** (**PKI**) by binding
    public keys to the identities of their owners, enabling secure protocols, such
    as TLS/SSL, for encrypted communication. They conduct identity verification before
    issuing certificates, maintain a chain of trust through root and intermediate
    certificates, and manage certificate revocation to ensure ongoing security. By
    providing this trust foundation, CAs enable users to confidently communicate and
    transact over the internet.
  prefs: []
  type: TYPE_NORMAL
- en: '**Server hello done**: The server acknowledges finishing its part of the handshake.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Client key exchange**: The client generates a pre-master secret, which is
    a random string without meaningful data, encrypts it with the server’s public
    key received from the server certificate, and sends it to the server.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Session keys creation**: Both the client and server use the pre-master secret
    along with the previously exchanged random numbers to generate session keys. These
    keys will be used for encrypting the data during the session.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Finished` messages, indicating that the handshake is complete and that they
    will now start using the session keys for secure communication.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The interaction is shown in *Figure 14**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3 – TLS handshaking](img/B21737_14_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.3 – TLS handshaking
  prefs: []
  type: TYPE_NORMAL
- en: During the TLS handshake, both the client and server independently generate
    session keys that are unique to that session only. Any replay of messages outside
    the session is not valid and will be detected. The session key never exists in
    messages exchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if a MitM attacker wants to decrypt the content of application data, it
    needs the symmetric session key. The session key is formed by random numbers generated
    by both sides and the pre-master secret. The pre-master secret can only be decrypted
    by the server’s private key, which is never exposed in any message exchanged.
    In other words, the MitM attackers cannot read the encrypted application data.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, each message exchanged contains a sequence number. Any out-of-order
    message will be detected and not processed further. Each message also contains
    a **Message Authentication Code** (**MAC**) that acts like a checksum to confirm
    whether the data has been altered in transit.
  prefs: []
  type: TYPE_NORMAL
- en: TLS uses digital certificates issued by trusted CAs to authenticate the server’s
    identity. This prevents MitM attacks, where an attacker impersonates the server.
    In the case of mutual TLS, the client can also present a certificate to prove
    its identity, further enhancing security.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have confidence that we have secure transport between the
    clients and the server. However, we still need to verify the identity of the client
    to authorize resources and actions allowed. We are going to discuss further how
    to authenticate the client in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-factor authentication (MFA)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Simple authentication requires only one such piece of evidence (known as a
    factor), typically a password. This approach has several weaknesses that make
    it inadequate for securing sensitive information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Weak passwords**: Easily guessed by attackers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phishing**: Attackers trick users into revealing their passwords (e.g., fake
    landing page)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Password reuse**: If one password is compromised, attackers can access other
    services using the same password'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Brute force**: Automated tools can keep guessing the one password'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Social engineering**: Manipulate users into sharing passwords'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No user verification**: Password verification only checks whether the provided
    credentials are the same as the ones in the record, instead of verifying that
    the person attempting to gain access is the actual user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MFA aims to harden the authentication process by verifying multiple factors,
    further validating that the user is who they claim to be. These factors are categorized
    into three groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Knowledge factor**: Passwords, security questions and answers, PINs, or IDs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Possession factor**: Smartphones, hardware tokens, authentication applications,
    and one-time passcodes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Biometric factor**: Fingerprints, faces, and voices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At a minimum, MFA requires at least two factors from distinct categories. It
    is less likely for attackers to get a hold of multiple factors from a target user,
    and thus it reduces the risk of unauthorized access. Moreover, some industries,
    such as banking, have regulatory requirements to enforce the use of MFA to protect
    sensitive data.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth pointing out that MFA does not necessarily require TLS, but using
    TLS for MFA is strongly recommended to ensure there is no eavesdropping and interception
    during the MFA process, especially when transmitting sensitive information, such
    as biometric data and passwords.
  prefs: []
  type: TYPE_NORMAL
- en: Implications of MFA to software architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The prevalence of MFA in everyday life, such as online banking and e-commerce,
    has influenced modern software architecture. There is a strong need for dedicated
    services to focus on authentication and decouple from business logic. This is
    due to the high complexity of the authentication process and the sensitivity of
    the data it handles. It is better to have a service specialized in authentication
    that keeps sensitive data within its bounded context to reduce risks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Together with the rise of serverless cloud computing, as discussed in [*Chapter
    6*](B21737_06.xhtml#_idTextAnchor212), every organization that runs its services
    in the cloud must choose one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The **identity providers** (**IdPs**) native to the cloud providers (e.g., Active
    Directory for Azure, Google Identity for GCP, Cognito for AWS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Platform independent IdPs, such as Okta, Auth0, and Duo Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write its own **identity and access management** (**IAM**) service, optionally
    as a proxy to other IdPs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No authentication required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is exceedingly rare these days to see systems skipping authentication. There
    are a few cases, such as public websites, anonymous surveys, and low-risk functions,
    such as calculators, that may not require authentication.
  prefs: []
  type: TYPE_NORMAL
- en: It may be justified to build an IAM service tailored to an organization’s needs.
    Unless the organization itself specializes in security solutions, IAM services
    belong to the generic subdomain, as discussed in [*Chapter 8*](B21737_08.xhtml#_idTextAnchor289).
    Most third-party IdPs provide the sufficient authentication capabilities required
    by an organization. If there is any organization-specific justification, it is
    recommended to build an IAM service to act as a proxy for a third-party IdP. If
    the third-party IdPs provide new features that are currently custom-built, this
    approach minimizes the impact of feature migration.
  prefs: []
  type: TYPE_NORMAL
- en: A sample interaction of MFA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Given a user wants to log on to a system to request an operation from an application
    on a smart device, the messages exchange may look like *Figure 14**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.4 – A sample business request with MFA](img/B21737_14_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.4 – A sample business request with MFA
  prefs: []
  type: TYPE_NORMAL
- en: This is just a sample interaction because the communication varies with different
    IdPs and different factors involved in authentication. In this sample, the IdPs
    provide a white-label page themed for the organization.
  prefs: []
  type: TYPE_NORMAL
- en: White label page
  prefs: []
  type: TYPE_NORMAL
- en: A **white label page** is a customizable web page or application that can be
    re-branded and used by different organizations. The screen is themed for the target
    organization and the original organization’s branding is hidden. It is a common
    feature for a SaaS product to allow seamless integration with any organization
    while maintaining a consistent user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'The user signs in and provides the username and password, using HTTPS over
    TLS. The username and password are joined by a colon as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The string is then encoded in Base64 and is passed to the HTTP header as a
    part of the **HTTP basic authentication**. Since it is HTTPS, the header is also
    encrypted. The sign-in request is equivalent to the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This data forms the knowledge factor of the authentication.
  prefs: []
  type: TYPE_NORMAL
- en: The IdP confirms that the username and password do exist and match, but then
    it issues a challenge to the client to enter a **one-time passcode** (**OTP**).
    The OTP is then sent to the user’s phone number via **Short Message Service**
    (**SMS**). The user who possesses the phone receives the OTP and enters the passcode.
    The passcode is sent from the client to the IdP to solve the challenge. This is
    the possession factor of the authentication.
  prefs: []
  type: TYPE_NORMAL
- en: The IdP verifies whether the OTP is correct or not. If it is incorrect, the
    IdP responds to the client and reveals that the authentication has failed. If
    it is correct, the IdP generates a **JSON Web Token** (**JWT**) as an access token
    and sends it to the client as a response. Soon after, the IdP also informs the
    server that a user is successfully authenticated via a webhook.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **JWT** is an encrypted JSON string used to carry claims about the roles
    and permissions of the user. It consists of three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Header**: The type of the token as “JWT” and the algorithm used to encrypt
    the token.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Payload**: Registered claims, such as issuer, audience, expiration time,
    and ID. Also contains public claims, such as application user roles, and private
    claims for information to be shared only between parties using the token.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Signature**: The proof that the sender is who it claims to be and the whole
    JSON string has not been modified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The authentication success response also triggers a screen redirect to the landing
    screen for the user to start making business requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The authenticated user makes a business request. The client sends the request
    to the server with the access token attached to the HTTP header as a `Bearer`
    token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The server receives from the client the request along with the `Bearer` token.
    The server verifies with the IdP whether the token is valid. The IdP confirms
    that the token is valid, so the server processes the request and responds to the
    client.
  prefs: []
  type: TYPE_NORMAL
- en: The client can continue to use the `Bearer` token for other operations, without
    further authentication, until the session ends. The IdP is in control of the validity
    of the token throughout the session. The token can also be refreshed upon request
    to the IdP.
  prefs: []
  type: TYPE_NORMAL
- en: The token exchange and refresh flows are a part of the industry standard protocol
    for authorization, **OAuth** ([https://oauth.net/2/](https://oauth.net/2/)).
  prefs: []
  type: TYPE_NORMAL
- en: OAuth
  prefs: []
  type: TYPE_NORMAL
- en: '**OAuth** is an authorization framework that enables third-party applications
    to obtain limited access to resources without exposing credentials. Users are
    granted access to their data from one service to another service through various
    grant types, such as authorization code, implicit, and client credentials. The
    user submits authentication requests to an authorization server, which then issues
    access tokens for accessing protected resources on a resource server. OAuth emphasizes
    flexibility and is widely adopted for secure delegated access in modern applications.'
  prefs: []
  type: TYPE_NORMAL
- en: This sample interaction also allows the `Bearer` token to be used for authentication
    of other systems that use the same IdP. As the user has already been authenticated
    by the IdP, other systems using the same IdP can verify the identity of the user
    in the same way. This mechanism enables the **single-sign-on** (**SSO**) experience
    where a user only needs to be authenticated once to access a basket of applications
    and systems that share the same IdP.
  prefs: []
  type: TYPE_NORMAL
- en: Step-up authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, the authenticated user is asked to perform additional verification
    beyond their initial authentication. This additional step is called **step-up
    authentication**.
  prefs: []
  type: TYPE_NORMAL
- en: Step-up authentication typically applies to deliberately chosen situations when
    they involve accessing sensitive information or high-risk actions, such as updating
    passwords, making a bank transfer, or moving the account data to an unfamiliar
    device.
  prefs: []
  type: TYPE_NORMAL
- en: Step-up authentication can also be dynamically applied based on the context
    of the access requests, such as a new geographic location, new device, new bank
    account, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest approach to step-up authentication is to repeat the same MFA process
    under TLS communication. Some companies would deliberately add more challenges,
    such as CAPTCHA or biometric verifications.
  prefs: []
  type: TYPE_NORMAL
- en: By implementing step-up authentication, organizations can significantly reduce
    the risk of unauthorized access while maintaining a seamless user experience for
    lower-risk activities.
  prefs: []
  type: TYPE_NORMAL
- en: 'We go to great lengths to get to the point where the system has verified the
    identity of an entity entering the system. Now that the entity has signed in the
    system the next question is this: What can the entity access and execute in the
    system? We are going to explore this in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Authorization** determines what resources a user or entity is allowed to
    access and what actions they can perform. After a user is authenticated, it is
    authorized to only interact with data and features explicitly granted rights.
    This restricts sensitive information to only individuals the system knows and
    maintains the integrity of systems.'
  prefs: []
  type: TYPE_NORMAL
- en: Authorization conforms to the **principle of least privilege** (**PoLP**), known
    as the **principle of minimal privilege** (**PoMP**) or the **principle of least
    authority** (**PoLA**). PoLP states that a user, entity, or system should have
    only the essential permissions to operate its functions. This minimizes risks
    and limits potential damage from accidents or malicious actions that we might
    not have anticipated or known.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, knowingly granting permissions for specific resources and actions
    improves accountability and compliance with security policies. Staying with the
    knowns promotes a safer sense of security.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have briefly mentioned, authorization has two elements: data and actions.
    They are different concepts in authorization and can be managed differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data entitlement**: Whether the user is entitled to access specific data
    or resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Permission**: Which actions the user is allowed to perform on a resource
    or data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, a user is entitled to see their own user account. A user in the
    Administrator role is entitled to see other users’ accounts. However, the user
    must be granted permission to read user accounts to start with. A user is granted
    write permission to update their own user account. A user in the Administrator
    role, however, may not have the write permission to update other users’ accounts.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four typical approaches to implementing authorization:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Role-based access** **control** (**RBAC**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attribute-based access** **control** (**ABAC**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access control** **lists** (**ACLs**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Policy-based access** **control** (**PBAC**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to perform a deep dive into them.
  prefs: []
  type: TYPE_NORMAL
- en: Role-based access control (RBAC)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An RBAC approach has users assigned to roles, and each role has specific permissions
    assigned to it. Users are granted permissions based on the assigned roles within
    the organization. This is illustrated in *Figure 14**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.5 – An example of RBAC](img/B21737_14_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.5 – An example of RBAC
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding RBAC configuration, Alex and Taylor are assigned the role of
    *Customer service support*, which is granted permissions to perform basic-level
    actions, such as updating a customer’s order. More advanced actions, such as refunding
    an order, can only be executed by a person such as Sam with the *Customer service*
    *supervisor* role.
  prefs: []
  type: TYPE_NORMAL
- en: RBAC is commonly used in companies in which different job functions require
    various levels of access. It is more efficient than assigning permissions to users
    individually. It is also efficient in situations such as when an employee takes
    a holiday and another employee temporarily takes over the duty, or a new employee
    requires the same level of access as their teammates.
  prefs: []
  type: TYPE_NORMAL
- en: Access control lists (ACLs)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An ACL grants a list of users or groups of users to have access to a specific
    resource and defines which actions are allowed. This approach is suitable for
    granting permissions to resources that can be precisely specified, such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filesystems**: Folders, read/write actions, and filenames'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP paths**: **Uniform Resource Identifiers** (**URIs**) and HTTP methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Networking**: IP addresses, ports, and transport layer protocols'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database**: Schemas, tables, and actions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the ACLs also support wildcard matches for more flexible configuration.
    This approach is suitable for managing the entitlement of resources at a fine-grained
    level.
  prefs: []
  type: TYPE_NORMAL
- en: Policy-based access control (PBAC)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PBAC grants permissions based on pre-defined policies that consider various
    criteria, such as user roles, attributes, and context.
  prefs: []
  type: TYPE_NORMAL
- en: These policies are pre-defined, but they support parameters. They are usually
    managed by GUI tools or set up as declarative configurations. The authorization
    tool itself may be custom-built, but the maintenance of policies does not require
    code change.
  prefs: []
  type: TYPE_NORMAL
- en: The policies can be fine-grained and highly configurable. They can also be changed
    at runtime without deployment or restart. They are useful in dynamic environments
    where access needs to adapt based on real-time conditions or compliance requirements.
  prefs: []
  type: TYPE_NORMAL
- en: PBAC is effective for compliance regulatory requirements because well-defined
    policies can be treated as a technical implementation of compliance policies.
  prefs: []
  type: TYPE_NORMAL
- en: Attribute-based access control (ABAC)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ABAC grants permissions to attributes associated with users, resources, and
    the environment. It provides the most flexible way to control permissions that
    can be sensitive to the context such as time and geographic locations.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a completed customer order can only be updated by a customer service
    supervisor, but an open order can be updated by both customer service support
    and supervisor.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is suitable for complex environments where access decisions depend
    on multiple, often dynamic, factors, such as user attributes (e.g., department,
    clearance level), resource attributes (e.g., sensitivity), time of access request,
    environment configurations, and so on. The control can be as granular as it needs
    to be.
  prefs: []
  type: TYPE_NORMAL
- en: Due to its high flexibility, ABAC is often written as code instead of configuration.
    Some of these ABAC policies may even involve the concept of permission inheritance,
    at either the user level or resource level. The implementation can easily become
    complex.
  prefs: []
  type: TYPE_NORMAL
- en: Writing ABAC in code also brings the challenges of testing and maintenance.
    It is possible that a bug in ABAC code leads to leaks of resources to unauthorized
    persons.
  prefs: []
  type: TYPE_NORMAL
- en: Impacts of authorization on software architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several dimensions of how authorization impacts software architecture.
    Microservices, nanoservices, and FaaS (as discussed in [*Chapter 6*](B21737_06.xhtml#_idTextAnchor212))
    themselves require access to infrastructure resources, such as databases and filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: If they are often run under cloud providers, RBAC and ALCs can be used in defining
    and restricting what resources which component is allowed to access, and which
    actions are allowed. More than often, organizations would use the cloud-native
    IdP to manage infrastructure permissions and data entitlements used by applications.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned when discussing PoLP, an application should be granted exactly
    sufficient permissions and data entitlements to perform its operations, but no
    more.
  prefs: []
  type: TYPE_NORMAL
- en: If there is a need to grant write access to a specific resource (e.g., database
    schema) to more than one bounded context, then it can be a smell of unclear or
    leaky bounded context. An architecture review of the involved bounded context
    will be useful in understanding the needs and examining whether the boundary of
    applications can be improved.
  prefs: []
  type: TYPE_NORMAL
- en: End users, external systems, and other devices require access to both infrastructure
    and application data. There are a few use cases where they need access to the
    infrastructure resources.
  prefs: []
  type: TYPE_NORMAL
- en: Use case – submit expense reimbursement request and approval
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In an organization, all users are permitted to submit requests to reimburse
    expenses for business authorization:expense reimbursement request and approval”
    purposes. The financial operation team is responsible for reviewing these requests
    and deciding if the request should be approved or rejected.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this setup, all users have the User role. The role is granted permissions
    to access these endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '`POST /expense`: This is to submit a new expense reimbursement request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /expense/{id}`: This is to see the expense reimbursement request of the
    given ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some users are assigned to the financial operations role. This role is granted
    permissions to access these endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET /expense/{id}`: This is to see the expense reimbursement request of the
    given ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH /expense/{id}/result`: This is to either approve or reject the expense
    reimbursement request of the given ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The corresponding permission control can be configured using RBAC and ACLs.
    Most IdPs, including cloud-native middleware, can support this setting.
  prefs: []
  type: TYPE_NORMAL
- en: Centralized or distributed authorization logic?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is often a question among engineers whether the authorization logic should
    be centralized or distributed when it is related to application data.
  prefs: []
  type: TYPE_NORMAL
- en: This is not a simple yes or no question. It depends on the nature of the authorization
    logic. At the basic level, the user requesting a record of application data should
    have permission granted to read the data of the given type. If it is RBAC or ACL,
    it is reasonable to have a centralized service to confirm that u*ser X can read
    application data of* *type Y*.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, permissions or roles can be encoded as part of the JWT custom
    claims. This approach reduces the time spent in resolving permissions. However,
    it implies the granted permissions can linger until the JWT expires, making dynamic
    authorization more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: However, it gets complicated when deciding whether a user is entitled to see
    a given application’s data, which is the data entitlement question of whether
    *user X can read application data of type Y and of ID 123*. Answering this question
    often requires domain-specific knowledge that should stay within the bounded context,
    in other words, distributed.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, other actions on application data imply that the user can read the
    data to begin with. The interweaving logic of permissions, data entitlement, and
    business logic has significantly increased the complexity of the operations. This
    is even more complicated with third-party API integration where data being authorized
    are distributed among services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the same example of expense reimbursement request and approval from the
    previous section, a sample interaction of permissions and data entitlements business
    flow looks like the diagram in *Figure 14**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.6 – A sample interaction of permission and data entitlements business
    flow](img/B21737_14_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.6 – A sample interaction of permission and data entitlements business
    flow
  prefs: []
  type: TYPE_NORMAL
- en: A user with a financial operations role needs to see the expense reimbursement
    request to decide whether to approve or reject it. So, the first request from
    the client is the get the expense reimbursement request by the given ID.
  prefs: []
  type: TYPE_NORMAL
- en: The corresponding service, the expense service, makes a synchronous call to
    the authorization service, which is dedicated to user permissions, to check whether
    the given user has the permissions to read an expense reimbursement request.
  prefs: []
  type: TYPE_NORMAL
- en: The authorization service resolves the user’s permissions by its roles and returns
    a list of actions granted to the user. The expense service receives the list of
    granted actions, and on top of that, checks whether the user can see this particular
    expense reimbursement request.
  prefs: []
  type: TYPE_NORMAL
- en: There could be domain-specific business rules, such as expense reimbursement
    requests can only be approved by a user of the same geographic jurisdiction. The
    expense service also further filters which actions can be performed on this expense
    reimbursement request. For example, if it is already approved, then the action
    to approve or reject is no longer available due to business logic, not due to
    permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Combined with the result of permissions and data entitlements, if the user is
    not allowed to see the expense reimbursement request, an HTTP status 403 (Forbidden)
    is returned to the client. Otherwise, an HTTP status 200 (OK) is returned with
    the payload of a list of actions available to the user on this expense reimbursement
    request.
  prefs: []
  type: TYPE_NORMAL
- en: Both services could have just returned a binary answer if the user could read
    the expense reimbursement request or not. However, returning a list of granted
    actions allows the list to be populated to the frontend application. The frontend
    application can enable and disable buttons to give the user clear expectations.
  prefs: []
  type: TYPE_NORMAL
- en: The expense reimbursement request is presented to the user on a screen, and
    the user has decided on the approval. The client sends a `PATCH` request to update
    the result of the expense reimbursement request.
  prefs: []
  type: TYPE_NORMAL
- en: The expense service makes a synchronous call to the authorization service to
    check whether the given user has permissions to approve or reject an expense reimbursement
    request. The authorization service returns a list of actions granted to the user.
    The expense service checks further if it is possible to approve or reject this
    given expense reimbursement request.
  prefs: []
  type: TYPE_NORMAL
- en: If the expense reimbursement request is already approved or rejected, then an
    HTTP status 403 (Forbidden) is returned to the client. Otherwise, the expense
    service updates the result of the expense reimbursement request and returns an
    HTTP status 200 (OK) together with the payload of the updated expense reimbursement
    request.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability concerns for authorization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From this sample interaction, we can foresee that the authorization service
    is frequently synchronously called. It raises concerns about scalability. All
    business requests would need to be authorized, so the authorization service would
    be under the load of all other business-facing services combined.
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, caching permissions locally may not be desirable, and even risky
    to do so. It is recommended to keep requests to the authorization service lean
    by designing efficient and non-chatty APIs. It is also worth considering a smaller
    size payload, such as a binary format.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling out any business-facing service that uses the authorization service
    would imply scaling out the authorization service considerably too. It is advised
    to set up metrics and monitoring to understand the usage of the authorization
    service per API client, so we understand if a service scales out to handle a greater
    number of requests, the authorization service needs to scale out proportionately.
  prefs: []
  type: TYPE_NORMAL
- en: At this point of the chapter, we can authenticate users and authorize them with
    a list of allowed actions and accessible resources. Business operations on top
    of them would result in the system keeping sensitive data. We are going to explore
    the topic of handling sensitive data in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Handling sensitive data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling sensitive data requires careful consideration and implementation of
    best practices to ensure its confidentiality, integrity, availability, and compliance
    with regulatory requirements. In this section, we’ll look at the key strategies
    for managing sensitive data.
  prefs: []
  type: TYPE_NORMAL
- en: Data classification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have discussed what data can be identified as sensitive at the beginning
    of the chapter. It is important for an organization to explicitly classify and
    document which field is sensitive. There are at least three categories of data
    sensitivity:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Confidential**: Only designated persons or roles can access'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internal use**: Only members of the organization can access'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Public**: Accessible to all'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The documentation should serve as a guideline for everyone, including engineers,
    in the organization to handle them with care and caution.
  prefs: []
  type: TYPE_NORMAL
- en: Data in transit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data in transit under TLS communication is encrypted with session keys. This
    ensures that even if data is intercepted or accessed without authorization, it
    remains unreadable.
  prefs: []
  type: TYPE_NORMAL
- en: How to prevent accidentally logging sensitive information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'However, it is not safe and secure yet. It is not unusual to encounter sensitive
    information leaked by logging unknowingly:'
  prefs: []
  type: TYPE_NORMAL
- en: The full decrypted payload of requests, responses, or messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An aggregate Kotlin object that transitively contains a sensitive field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object of a generated class that contains a sensitive field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting or debugging information that contains sensitive information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sensitive fields themselves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is quite dangerous because the related code looks innocuous and the leak
    is often found after the fact. There are a few techniques to prevent this from
    happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common technique adopted by engineers is to override the `toString` function
    of a Kotlin data class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach works, but it is not scalable because there are a lot of override
    functions to write. Alternatively, a value wrapper can work efficiently, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `Secret` wrapper class works on a class or a field. The `toString` override
    function is simple as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also open source libraries that aim to solve this issue with minimal
    code. For example, the Redacted compiler plugin ([https://github.com/ZacSweers/redacted-compiler-plugin](https://github.com/ZacSweers/redacted-compiler-plugin))
    enables engineers to annotate a field or a class to be redacted, and therefore,
    the values are masked when `toString` is invoked. The setup is quite simple as
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step of the setup is its Gradle plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Secondly, define a custom `Redacted` annotation class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, configure the plugin to use this annotation and configure the mask character
    in `build.gradle.kts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have the following data classes annotated with `Redacted`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We create one object per class and print them to the console in the main function:'
  prefs: []
  type: TYPE_NORMAL
- en: fun main() {
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We have the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: So, the sensitive information is masked as part of the `toString` function result.
    However, the values are not masked if the program is run from the IDE with this
    compiler plugin. The masked values are shown if the program is executed from the
    command line or Gradle tasks.
  prefs: []
  type: TYPE_NORMAL
- en: There are alternative approaches that use reflection as a means to redact or
    hide sensitive fields. They are not recommended due to the overhead of using reflection.
    Compile-time redaction is the most effective method.
  prefs: []
  type: TYPE_NORMAL
- en: As for the payload and objects of a generated class, a sensible way to prevent
    sensitive information leaks is to avoid logging them in a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Data at rest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data at rest refers to the data stored on devices, filesystems, databases, and
    cloud environments. Data sitting in infrastructure is usually protected by MFA,
    RBAC, and ALCs, as discussed in previous sections. However, for sensitive information,
    additional steps need to be taken.
  prefs: []
  type: TYPE_NORMAL
- en: Encryption
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sensitive data needs to be stored in an encrypted state; the variations are
    in the *how*. Here are the common techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encrypted databases**: All data stored in a database is stored in an encrypted
    and unreadable format. The data is automatically decrypted upon retrieval without
    the application code. These databases usually support authorization to ensure
    that only authorized users can interact with encrypted data. They also innately
    support encryption key generation, storage, and rotation for extra security. Some
    databases also support encryption when data is being transmitted in and out of
    the database. However, encrypting and decrypting all data, sensitive or not, increases
    latency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encrypted fields**: Only fields identified as sensitive data are encrypted.
    This approach works with all types of storage, such as database columns, events
    in messaging infrastructure, and files. It has less performance overhead compared
    to encrypted databases, However, doing it at a field level implies that applications
    need to handle aspects that are automatically by encrypted databases, such as
    the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encryption and decryption algorithms
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Symmetric or asymmetric encryption key
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Key generation and secret management
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Key rotation and re-encryption
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hybrid**: Due to the performance overhead of encrypted databases and the
    additional work to handle encryption in application code, it may be justified
    to use a hybrid approach, in which only sensitive data are stored in encrypted
    databases, and the rest are kept in any type of storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encrypted backups**: Sensitive data should be regularly backed up in encrypted
    format to ensure data can be restored security in case of data loss or breaches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data retention and anonymization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Local authorities and regulations have clear guidelines on how long data should
    be maintained, including sensitive data. During the retention period, it is the
    organization’s responsibility to keep them secure and safe. After the retention
    period, sensitive data may be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: There are also regulations (e.g., GDPR) that individuals have the right to request
    for privacy data to be erased from the system.
  prefs: []
  type: TYPE_NORMAL
- en: However, there may be complications for deleting sensitive data on its own.
    Some of the data have referential constraints and contain useful business insights,
    which need not identify individuals.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several techniques that allow sensitive data to be anonymized and
    become not sensitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '`anonymized@data.com`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generalization**: Reduce the precision of sensitive values so they cannot
    identify a specific person or record (e.g., dates of birth reduced to months of
    birth, addresses trimmed to cities, etc.).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aggregation**: Summarize data into statistics so there is no reference to
    a person or a record.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lost decryption keys**: Delete the decryption keys so the data cannot be
    traced back to the individuals.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Periodic anonymization**: Aggressively scan data that has passed the retention
    period and anonymize it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Broken link**: An upfront database schema design that separates sensitive
    data and non-sensitive into different tables, and no tables have reference to
    the sensitive data table. This sensitive data record can be deleted anytime without
    issues (see an example in *Figure* *14**.7*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 14.7 – Separation of sensitive and non-sensitive data for anonymization](img/B21737_14_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.7 – Separation of sensitive and non-sensitive data for anonymization
  prefs: []
  type: TYPE_NORMAL
- en: The user record table has a primary key user ID and this field can be used by
    other tables for reference. The sensitive personal record table is merely a complimentary
    table to keep only PII fields.
  prefs: []
  type: TYPE_NORMAL
- en: Proactively using these techniques helps organizations manage sensitive data
    and protect it from unauthorized access and potential breaches. They help maintain
    trust with customers and compliance with regulatory requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Coming next, we are going to briefly cover some practices for ensuring network
    security.
  prefs: []
  type: TYPE_NORMAL
- en: Network security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this chapter, we discussed how TLS works and how it prevents eavesdropping
    on network communications. However, there are other malicious attacks that do
    not require infiltrating the authentication and authorization processes.
  prefs: []
  type: TYPE_NORMAL
- en: For example, **distributed denial of service** (**DDoS**) is a type of cyberattack
    in which a system is overwhelmed by multiple source systems, usually as bots and
    automated scripts, so that legitimate users cannot access the system. Attacks
    generative massive volume of traffic to saturate and exhaust the system’s resources,
    such as CPU, memory, and network.
  prefs: []
  type: TYPE_NORMAL
- en: The following are the key strategies to protect the system from these network-level
    attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Web application firewalls (WAFs)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **web application firewall** (**WAF**) is a security solution specialized
    in protecting systems on the internet. A WAF can run in the cloud, in a data center,
    or a mixture of both, as a front-runner before traffic from the internet reaches
    deeper inside the system. It provides a few key functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Geo-blocking and IP blacklisting**: Block traffic coming from and going to
    the list of IP addresses linked to malicious activity and block traffic from certain
    geographic regions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rate limiting**: Prevent the number of requests to the server from reaching
    the threshold in duration as per configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prevention of foreign script executions**: Prevent attackers from executing
    scripts that are not part of the system, such as unauthorized database commands,
    **cross-site scripting** (**XSS**) from web pages, and trojans.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Policy-based or rule-based access policies**: Highly configurable and customizable
    rules to set up the needs of each application at a fine-grained level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Frequent updates**: WAFs are updated frequently to adapt to the ever-changing
    landscape of security threats. WAFs address vulnerabilities outlined in the **Open
    Web Application Security Project** (**OWASP**) Top 10, which is updated periodically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open Web Application Security Project (OWASP)
  prefs: []
  type: TYPE_NORMAL
- en: OWASP is an open source project with the mission to make software security visible
    and accessible to engineers and organizations. It is a global community of engineers,
    security experts, and organizations dedicated to providing free tools and knowledge
    to enhance the security of the digital environment. The OWASP Top 10 is a globally
    recognized list of the top 10 most crucial security risks. The list is updated
    regularly to reflect the evolution of security threats.
  prefs: []
  type: TYPE_NORMAL
- en: A WAF is a critical part of a comprehensive web security strategy, providing
    essential protection for web applications against a variety of attacks. An organization
    with ongoing concerns should have a WAF. A cloud-based system can choose a WAF
    from the native cloud provider, or from a WAF that can run in the cloud. A WAF
    helps organizations safeguard their applications, protect sensitive data, and
    maintain compliance with security standards.
  prefs: []
  type: TYPE_NORMAL
- en: Traffic routing and network segmentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In contrast to traffic blacklisting and blocking, there should be explicit traffic
    routing that serves as an API gateway or proxy to applications. The explicit configuration
    serves as a whitelist of permitted traffic routes from the external world and
    helps conform to the PoLP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Explicitly configured traffic routes allow applying features such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Distributed tracing**: Link requests that pass through multiple components
    as a holistic flow'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Metrics**: Collect metrics such as packet loss, response time, connection
    time, and error rate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Retrying**: Allow applications to retry an operation in the face of intermittent
    failures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Circuit breaking**: Disallow applications to repeat operations that have
    been failing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rate limiting**: Overlapped with the feature of WAF, limit the number of
    requests over a period'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, the traffic routing we covered here is all for ingress, that is, traffic
    from the external world to internal applications. Traffic egress, from internal
    applications to external worlds, is equally important. For example, attackers
    may have installed trojans that quietly export sensitive data to an unidentified
    destination. This can be configured by routers, network switches, network ACLs,
    and WAF configurations. Cloud providers also have services that manage ingress
    and egress routes by rules and policies.
  prefs: []
  type: TYPE_NORMAL
- en: A **service mesh** is another approach to configure and control network communications,
    but it focuses on service-to-service communication. It provides a dedicated infrastructure
    layer that defines how one service communicates with another, ensuring all routes
    among services are explicitly defined. Apart from HTTP request routing, service
    mesh can be extended to other types of transports, such as messaging, files, and
    databases. It automatically detects and registers new instances of the service,
    so engineers can focus on business logic instead of network communication. Service
    mesh often uses the **Sidecar pattern** in which there is a proxy deployed alongside
    a backend service, and the proxy intercepts all inbound and outbound traffic for
    the service.
  prefs: []
  type: TYPE_NORMAL
- en: Sidecar pattern
  prefs: []
  type: TYPE_NORMAL
- en: The **Sidecar pattern** is an architectural design approach where a secondary
    service, known as a sidecar, is deployed alongside a primary service to extend
    its functions but to decouple from its code base. This sidecar typically runs
    in the same container or VM. The sidecar handles cross-cutting concerns, such
    as logging, monitoring, security, and communication. This pattern enhances the
    resilience and maintainability of services, but without coupling with them, and
    thus facilitates more efficient management of complex applications.
  prefs: []
  type: TYPE_NORMAL
- en: '**Network segmentation** is another technique that divides a network into smaller,
    manageable segments to limit access and reduce the risk of being attacked. This
    helps contain breaches and enhances overall security. It can be implemented by
    setting up **virtual local area networks** (**VLANs**) or sub-networks.'
  prefs: []
  type: TYPE_NORMAL
- en: Antivirus and anti-malware solutions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, antivirus and anti-malware solutions should be running in the infrastructure
    to scan, detect, and remove malicious software. They monitor running processes,
    scan stored files, and discover suspicious behaviors without manual intervention.
    These solutions are also automatically updated to stay with the latest threat
    definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the network security strategies involve infrastructure solutions that
    involve application-specific configurations. In the next section, we will cover
    DevSecOps in which application engineers are proactively involved.
  prefs: []
  type: TYPE_NORMAL
- en: DevSecOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**DevSecOps** is a software development approach that integrates security best
    practices in the development process. It emphasizes that the responsibility of
    software security is shared among all members of the team, and security is an
    inseparable element in the development process.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There will still be security experts and potential security teams in an organization.
    They provide expertise, knowledge, tools, and guidance to development. DevSecOps
    embraces the following principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shift left**: Security considerations are integrated early in the development
    process, as a part of the requirements. This enables the discovery, identification,
    and remediation of vulnerabilities before the application reaches production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compliance as code**: Include regulatory requirements in the code with automated
    tests to validate compliance continuously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collaboration and communication**: This encourages collaboration between
    development, security, and operations teams, fostering a culture of shared responsibility
    for software security.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automation**: Automate security processes, such as code vulnerability scanning,
    as a part of the **continuous integration / continuous deployment** (**CI/CD**)
    pipeline to provide quick feedback on security issues, and to allow the team to
    address these issues early in the development process. For example, **OWASP Dependency-Check**
    is a static analysis tool that identifies known vulnerabilities in project dependencies.
    This tool integrates with build tools such as Maven, Gradle, and Jenkins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous monitoring**: Continuously monitor security threats, vulnerabilities,
    and unusual behaviors in applications and infrastructure while running in all
    environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Threat modeling**: Discover and identify potential threats and vulnerabilities
    during the early stage of development, enabling teams to proactively address security
    concerns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benefits of DevSecOps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By integrating security throughout the whole software development cycle, organizations
    can identify and mitigate vulnerabilities early. It reduces the risk of security
    breaches, the cost of fixing security issues, and the cost of remediation.
  prefs: []
  type: TYPE_NORMAL
- en: Automation integrated within a CI/CD pipeline and collaboration helps find vulnerabilities
    early in the process. It saves time in delivering secure applications and reduces
    the time to market.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous monitoring and automated compliance checks help organizations meet
    regulatory requirements proactively and more effectively.
  prefs: []
  type: TYPE_NORMAL
- en: DevSecOps is a cultural and technical shift in how an organization approaches
    software development and security. The practices in the DevSecOps process foster
    a culture of delivering resilient applications and responding to threats effectively,
    leading to a more secure technical ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: A threat modeling exercise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to run through an exercise of threat modeling ([https://owasp.org/www-project-threat-model/](https://owasp.org/www-project-threat-model/))
    to demonstrate how everyone in the team is involved in this activity. Product
    managers, the security team, and the development team should be involved in all
    the steps.
  prefs: []
  type: TYPE_NORMAL
- en: Threat modeling starts with a business scenario. We are going to use the same
    real-life example throughout the book. This is a software system that allows households
    to exchange services with each other via an agreed contract. The goal of this
    threat modeling exercise is to identify potential security threats and vulnerabilities
    in the system.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – visualize architecture and identify assets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first step of threat modeling is to define the scope where threat modeling
    takes place. This includes architecture diagrams to demonstrate the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Components inside the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boundary of the system, entry points, and exit points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assets that require protection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a few choices of diagram format for this purpose, such as the **data
    flow diagram** (**DFD**) from structural analysis or container diagram (level
    2) from the **C4 model**, as covered in [*Chapter 1*](B21737_01.xhtml#_idTextAnchor013).
    The container diagram for the system is shown in *Figure 14**.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.8 – Container diagram of the system from a real-life example for
    threat modeling](img/B21737_14_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.8 – Container diagram of the system from a real-life example for threat
    modeling
  prefs: []
  type: TYPE_NORMAL
- en: 'The dash-lined rectangle defines the boundary of the system and its internal
    network. We can assume the system runs in a cloud environment and it intends to
    use cloud-native services for cross-cutting functions. There are several components
    in this diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mobile application**: A user interface on mobile devices for households.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WAF**: A cloud-based firewall middleware that blocks malicious IP addresses,
    limits the number of incoming requests, and prevents **XSS**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API gateway/router**: A cloud-based middleware that routes requests from
    mobile applications to the appropriate services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Household service**: A backend service responsible for CRUD operations of
    household records.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contract service**: A backend service responsible for managing the life cycle
    of a contract from drafted to exercised.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Notification service**: A backend service responsible for sending notifications
    to external users via emails.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Email service**: A cloud-based middleware that delivers email content to
    given addresses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IdP**: A cloud-based middleware that verifies a user’s identity using MFA
    from the mobile application and confirms if a bearer token is valid. Used by the
    household service and contract service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database**: A cloud-based database to allow applications to read data from
    and write data to. Used by the household service and contract service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Messaging broker**: A cloud-based middleware that receives household updates,
    contract updates, and notification requests. It allows interested services to
    consume the messages for further processing. For instance, the notification service
    consumes notification messages and converts them to email requests to the email
    service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the architecture diagram, we have identified the entry points in the system.
    Requests come in from the mobile application, they pass through the WAF, and then
    they are routed to the corresponding services.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have also identified two exit points in the system:'
  prefs: []
  type: TYPE_NORMAL
- en: Backend services request the IdP to verify an access token
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The notification service requests the email service to send an email
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, we have identified the following assets:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Household data**: Contain PIIs such as addresses and names'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contract data**: Private information only available between two involved
    households'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Notification request**: Contain email content and email addresses (PIIs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application code**: Source code of all backend services and the mobile application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Infrastructure**: Servers, databases, network components, infrastructure
    configurations as code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the architecture diagrams, entry points, exit points, and identified assets,
    the team can now examine the information and discover threats and vulnerabilities
    in the system.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – identify threats
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The team applies the **STRIDE** framework to categorize potential threats based
    on the identified assets. STRIDE is a combination of the first letters of the
    following six aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Spoofing**: Unauthorized users may impersonate legitimate users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tampering**: Malicious modification of household or contract data in transit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repudiation**: Household users may deny agreeing to a contract with another
    household'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Information disclosure**: PII, such as names, addresses, and email addresses,
    are exposed through vulnerabilities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Denial of service**: Attackers may overwhelm and exhaust the system with
    traffic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elevation of privilege**: Users gaining access to unauthorized functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After threats are identified, the team needs to assess the risks and determine
    how to respond to them.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – assess risks and determine responses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Risks can be assessed by two factors: likelihood and impact. These two factors
    are multiplied to derive the risk level and thus the priority of the responses.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple approach is to have three levels for each factor, and each level is
    associated with an integer. The multiplication of the integers is the risk level.
    An organization can customize the levels and integers as it sees fit. In this
    example, the integers are assigned to each level as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Likelihood**: 1 – Unlikely, 2 – Possibly, 3 – Likely'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Impact**: 1 – Low, 2 – Medium, 3 – High'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The numeric values of these two factors constitute the risk assessment table,
    as shown in *Table 14.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Threat** | **Likelihood** | **Impact** | **Risk level** |'
  prefs: []
  type: TYPE_TB
- en: '| **Spoofing**: User impersonation | 2 | 3 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| **Tampering**: Malicious data modifications | 2 | 3 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| **Repudiation**: Household denying actions | 1 | 2 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| **Information**: PII disclosure | 2 | 3 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| Denial of service | 2 | 2 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| **Elevation of privilege**: Unauthorized user actions | 1 | 3 | 3 |'
  prefs: []
  type: TYPE_TB
- en: Table 14.1 – Example of risk assessment table
  prefs: []
  type: TYPE_NORMAL
- en: The risk levels are effectively the priority of security threats that the team
    needs to respond to and address, with the highest number being the highest priority,
    and the lowest number the lowest priority.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four general responses to a risk, and the team must choose one response
    for each security risk:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mitigation**: Reduce the negative impact of the threat'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transfer**: Shift the risk to another party, typically by using third-party
    software'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoidance**: Eliminate the risk by developing a new strategy or solution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Acceptance**: Accept and acknowledge the risk, but no further actions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For each threat identified by the STRIDE framework, a response should be outlined,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Spoofing – transfer**: Use the cloud-based IdP to implement MFA and to secure
    passwords'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tampering – avoidance**: Use HTTPS over TLS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repudiation – mitigation**: Ensure sufficient audit trails and logging of
    all user actions related to household and contract records'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Information disclosure – avoidance**: Use encrypted databases, encrypt sensitive
    data in messaging payload, integrate code vulnerability scanning in CI/CD pipelines,
    and conduct regular security audits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Denial of service – transfer**: Configure WAF to protect the network from
    DDoS attacks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elevation of privilege – mitigation**: Periodically review access control
    settings and conduct security training with internal users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, the architecture has been discussed from a security perspective.
    Threats are identified and their risk levels are determined. Each risk has been
    responded to. There are only a few steps to complete one round of threat modeling,
    which are covered in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 – document, review, and update
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After conducting all the activities in the previous steps, it is paramount to
    have them all documented, preferably as a single page with rough dates when the
    threat was modeled. The documentation serves as a record of learning as a team
    and as a checklist of follow-up actions.
  prefs: []
  type: TYPE_NORMAL
- en: The security team should review the documentation and advise if there are any
    additional topics to discuss. Otherwise, the security team should sign off on
    the threat modeling document as a reviewer.
  prefs: []
  type: TYPE_NORMAL
- en: The team should convert the risk responses into work items in the backlog to
    ensure that the decided actions are executed.
  prefs: []
  type: TYPE_NORMAL
- en: The team should also periodically review this document and decide whether there
    should be another round of threat modeling. Alternatively, if there is an important
    feature change or an architecture change, then the team should consider whether
    there is a need to update the threat model.
  prefs: []
  type: TYPE_NORMAL
- en: Threat modeling is a tool and process used to help the team deliver secure software
    at the beginning of development. It benefits engineers, security team, product
    managers, and customers by having secure software products that are developed
    efficiently by addressing security issues early.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed the importance of security in software architecture, and how sensitive
    information is categorized. Afterward, we covered the CIA triad for the security
    principles of confidentiality, integrity, and availability.
  prefs: []
  type: TYPE_NORMAL
- en: We covered authentication with the spotlight on how TLS works and how it prevents
    cyberattacks such as MitM eavesdropping. We delved into the details of how MFA
    works and its implications for software architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we moved on to the topic of authorization, and we covered the four major
    access control methods (role-based, policy-based, attribute-based, and ACLs).
    We discussed how authorization has impacted software architecture.
  prefs: []
  type: TYPE_NORMAL
- en: We mentioned the basic practices in handling sensitive data, including data
    classification, and protecting data in transit and in rest. A few approaches are
    highlighted on how Kotlin engineers can avoid accidentally logging sensitive data.
    A couple of strategies for anonymizing data are included in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We briefly mentioned the principles of DevSecOps and its benefits to the software
    development cycle by having security integrated into the development process.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we ran through a threat modeling exercise with the real-life example
    system. We visited the details of each step, emphasized how to conclude a cycle,
    and when the threat model should be re-visited.
  prefs: []
  type: TYPE_NORMAL
- en: There are still some aspects of engineering that go beyond just architecture.
    We will cover a few miscellaneous topics that are specific to Kotlin engineers
    in the next and last chapters. We hope you will find them useful in supporting
    better software architecture.
  prefs: []
  type: TYPE_NORMAL
