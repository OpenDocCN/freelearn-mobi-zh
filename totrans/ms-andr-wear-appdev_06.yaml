- en: Chapter 6.  Contextual Notifications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章. 上下文通知
- en: '|   | *"Life is about timing."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|    | *"生活就是关于时机。" |    |'
- en: '|   | --*Carl Lewis* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|    | --*卡尔·刘易斯* |'
- en: In this chapter, we will discuss notifications in Android Wear. After a quick
    comparison between notifications in wearable and handheld devices, we will continue
    extending the `Today` app from the previous chapter to demonstrate the Android
    Wear notifications API.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论 Android Wear 中的通知。在快速比较可穿戴设备和手持设备中的通知之后，我们将继续扩展上一章中的“今日”应用，以演示 Android
    Wear 通知 API。
- en: Note
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The code accompanying this chapter is available for reference on GitHub ([https://github.com/siddii/mastering-android-wear/tree/master/Chapter_6](https://github.com/siddii/mastering-android-wear/tree/master/Chapter_6)).
    For the sake of brevity, only code snippets are included as needed. The reader
    is encouraged to download the referenced code from GitHub and follow along as
    they progress through the chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在 GitHub 上参考（[https://github.com/siddii/mastering-android-wear/tree/master/Chapter_6](https://github.com/siddii/mastering-android-wear/tree/master/Chapter_6)）。为了简洁起见，仅包含所需的代码片段。鼓励读者从
    GitHub 下载引用的代码，并在阅读章节时跟随。
- en: Getting notified
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接收通知
- en: It should come as no surprise that wearable devices are naturally superior to
    handheld devices in their capacity to deliver notifications to the user. With
    a handheld device, you hear a beep, and you need to draw your device out from
    your purse or pocket or whatever choice holster you snagged at that recent eBay
    auction.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，可穿戴设备在向用户发送通知方面自然优于手持设备。使用手持设备时，你会听到蜂鸣声，你需要从钱包、口袋或你在最近一次 eBay 拍卖中抓到的任何选择皮套中取出你的设备。
- en: But with a smartwatch, things are quite different. When you hear that beep,
    you simply glance at your wrist. This ease is a hallmark feature of wearable device
    technology.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在智能手表上，事情相当不同。当你听到那个蜂鸣声时，你只需瞥一眼你的手腕。这种便利性是可穿戴设备技术的标志性特征。
- en: And it doesn't end there. With the help of voice interactions, the user can
    act on that notification by issuing a recognizable voice command. The voice interactions
    API, of course, predates the Wear API and has been in use on handheld devices
    for some time. But there is no denying the immense value it brings to wearable
    devices, fitting in perfectly with that ease of access. We'll deal with voice
    interactions in the next chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 而且不仅如此。借助语音交互，用户可以通过发出可识别的语音命令来对通知采取行动。当然，语音交互 API 早于 Wear API，并且在手持设备上已经使用了一段时间。但不可否认的是，它为可穿戴设备带来的巨大价值，与这种易于访问的特性完美契合。我们将在下一章中处理语音交互。
- en: So central is the notification model to wearable devices that most tutorials
    often introduce notifications as the core use case of Android Wear; the other
    features come later. We, obviously, chose a different treatment in this book.
    Here we are, spanning the halfway point in our book as we encounter the first
    serious discussion on notifications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通知模型对可穿戴设备来说如此核心，以至于大多数教程通常将通知作为 Android Wear 的核心用例介绍；其他功能随后介绍。显然，我们在本书中选择了不同的处理方式。现在，我们来到了本书的一半，我们遇到了关于通知的第一次严肃讨论。
- en: We did that, because notification, no matter how important or central they may
    be, are still an application feature, and thus secondary to the core functionality
    of an app. Delving into notifications without the benefit of being exposed to
    the nuts and bolts of an Android Wear app, in our opinion, would be putting the
    cart before the horse.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以这样做，是因为通知，无论它们多么重要或核心，仍然是应用程序的功能，因此是应用程序核心功能的次要部分。我们认为，在没有接触到 Android Wear
    应用“筋骨”的情况下深入研究通知，是不切实际的。
- en: You've seen the barebones `Today` app, and you've augmented it to work with
    a companion handheld app. That's some good exposure to the Wear API. Now, you're
    ready to build upon that knowledge. Rest assured, if you've followed along so
    far, you will not find the notifications API intimidating by any means.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了“今日”应用的骨架，你已经增强了它以与配套手持应用一起工作。这是对 Wear API 的一些良好了解。现在，你准备好在此基础上构建知识。放心，如果你一直跟随着，你会发现通知
    API 并不令人畏惧。
- en: Enough talk; let's begin by introducing the core classes in the API before we
    get to see them in action in our sample application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 谈话到此为止；在我们看到示例应用中的实际操作之前，让我们先介绍 API 中的核心类。
- en: Core classes of the notifications API
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通知 API 的核心类
- en: Here are the core classes of the notifications API that we will be using in
    our application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们将在应用程序中使用的通知 API 的核心类。
- en: NotificationCompat.Builder
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`NotificationCompat.Builder`'
- en: One thing you want when working with notifications on wearable devices is some
    sort of assurance that your notifications appear acceptable on the significantly
    reduced scale of a smart watch. That is where the notification builder class comes
    in. This class takes care of displaying notifications properly, whether they appear
    on a handheld or wearable device.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在可穿戴设备上处理通知时，您希望得到某种保证，即您的通知在智能手表显著缩小的比例上看起来是可接受的。这就是通知构建器类发挥作用的地方。这个类负责正确显示通知，无论它们出现在手持设备还是可穿戴设备上。
- en: 'To use the notification builder, you will have to add the following line to
    your `build.gradle` file:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用通知构建器，您必须在您的`build.gradle`文件中添加以下行：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then you''ll need to import the following core classes from the support library:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要从支持库中导入以下核心类：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Creating a notification then becomes a matter of instantiating the `NotificationCompat.Builder`
    class and issuing the notification, as we will see in our sample application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 创建通知变成实例化`NotificationCompat.Builder`类并发布通知的问题，正如我们将在我们的示例应用程序中看到的那样。
- en: Action buttons in your notification
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通知中的操作按钮
- en: The `addAction` method lets you add an action to the notification. Simply pass
    in a `PendingIntent` instance to the `addAction` method. While this action appears
    on a handheld as an additional button attached to the notification, on a wearable
    device it appears as a large button when the user swipes the notification to the
    left. Tapping the action invokes the associated intent on the handheld.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`addAction`方法允许您向通知添加一个操作。只需将`PendingIntent`实例传递给`addAction`方法。虽然这个操作在手持设备上作为附加到通知的按钮出现，但在可穿戴设备上，当用户将通知向左滑动时，它将显示为一个大的按钮。点击操作将在手持设备上调用相关的意图。'
- en: Wearable-only actions
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅适用于可穿戴设备的行为
- en: If you want the actions available on the wearable to be different than those
    on the handheld, use the `addAction` method on the `NotificationCompat.WearableExtender`
    class. Doing so ensures that the wearable does not display actions added to the
    `NotificationCompat.Builder.addAction` class.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望可穿戴设备上的操作与手持设备上的操作不同，请使用`NotificationCompat.WearableExtender`类上的`addAction`方法。这样做可以确保可穿戴设备不会显示添加到`NotificationCompat.Builder.addAction`类的操作。
- en: Delivery
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交付
- en: 'Use the `NotificationManagerCompat` API instead of `NotificationManager` to
    deliver your notification, shown as follows. This ensures compatibility with older
    platforms:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`NotificationManagerCompat` API而不是`NotificationManager`来发送您的通知，如下所示。这确保了与旧平台的兼容性：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Today app with to-do notifications
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有待办事项通知的Today应用程序
- en: We are going to augment our `Today` app with a to-do activity that lets the
    user add to-do items and associate them with specific locations, such as home,
    or work. The locations then provide the context, which drives the notifications.
    This, in effect, makes our notifications *context-aware*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将增强我们的`Today`应用程序，添加一个允许用户添加待办事项并将它们与特定位置关联的活动，例如家或工作。这些位置提供了上下文，从而驱动通知。实际上，这使得我们的通知*具有上下文感知性*。
- en: For example, if the system detects that the user is in close proximity to the
    Home location, then to-do items associated with the `Home` category are presented
    to the user via the notifications API.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果系统检测到用户接近家位置，那么与`Home`类别关联的待办事项将通过通知API呈现给用户。
- en: Geofencing
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地理围栏
- en: We'll be using the `Geofencing` API to figure out the location, that is, the
    context. In essence, this API lets us draw a circle of some agreed-upon radius
    around a coordinate. In effect, the latitude, longitude, and radius together define
    a *geofence*, a circular region around the coordinates of interest. Entrance and
    exit events signal when the device enters or exits the geofence location. An optional
    duration attribute delays the triggering of an event for that time interval once
    the device has entered and remained within the geofence.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`Geofencing` API来确定位置，即上下文。本质上，这个API允许我们在一个坐标周围绘制一个半径已定的圆圈。实际上，纬度、经度和半径共同定义了一个*地理围栏*，即感兴趣坐标周围的圆形区域。进入和退出事件表示设备进入或退出地理围栏位置。可选的持续时间属性在设备进入并保持在地理围栏内时延迟触发该时间间隔的事件。
- en: You can study the `Geofencing` API in detail by visiting [https://developer.android.com/training/location/geofencing.html](https://developer.android.com/training/location/geofencing.html).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问[https://developer.android.com/training/location/geofencing.html](https://developer.android.com/training/location/geofencing.html)来详细了解`Geofencing`
    API。
- en: Mocking a GPS
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟GPS
- en: It is important to mention at the outset that it is not easy to simulate the
    location/GPS sensor behavior on a wearable device emulator, which all our sample
    code uses. A physical device equipped with GPS is needed for that. Furthermore,
    even if we did have access to a fully functional GPS, we could potentially run
    into frustrating scenarios testing our app—consider having to move physically
    to a different location in order to trigger the GPS sensors.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要说明的是，在可穿戴设备模拟器上模拟位置/GPS 传感器行为并不容易，我们所有的示例代码都是这样做的。需要配备 GPS 的物理设备才能做到这一点。此外，即使我们能够访问一个完全功能的
    GPS，我们也可能会遇到令人沮丧的场景来测试我们的应用程序——考虑需要物理移动到不同的位置以触发 GPS 传感器。
- en: Hence, for the purposes of demonstrating context-aware notifications, we need
    a GPS mocking service that lets us use our wearable device emulator along with
    the physical handheld device, yet simulate different locations on demand.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了演示上下文感知通知，我们需要一个 GPS 模拟服务，它允许我们使用我们的可穿戴设备模拟器以及物理手持设备，并且可以按需模拟不同的位置。
- en: This is where ByteRev's **FakeGPS** application comes into play ([https://play.google.com/store/apps/details?id=com.lexa.fakegps&hl=en](https://play.google.com/store/apps/details?id=com.lexa.fakegps&hl=en)).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 ByteRev 的 **FakeGPS** 应用程序发挥作用的地方 ([https://play.google.com/store/apps/details?id=com.lexa.fakegps&hl=en](https://play.google.com/store/apps/details?id=com.lexa.fakegps&hl=en))。
- en: This free app lets us mock different locations and effectively gives us the
    equivalent experience of working with a fully functional GPS unit on a physical
    device. The downside is that the user may need to rerun the app in order to simulate
    the intended behavior. But that is an acceptable trade-off for flexibility.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个免费应用程序让我们能够模拟不同的位置，并有效地提供在物理设备上使用完全功能的 GPS 单元的等效体验。缺点是用户可能需要重新运行应用程序以模拟预期的行为。但这是为了灵活性而可以接受的权衡。
- en: The build.gradle file on wear and mobile apps
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可穿戴和移动应用程序的 build.gradle 文件
- en: 'The `build.gradle` file of the mobile handheld app should contain the following
    line for location services:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 移动手持应用程序的 build.gradle 文件应包含以下行以支持位置服务：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Both wear and mobile apps should contain the following compile dependencies
    for notification support:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 可穿戴和移动应用程序都应包含以下编译依赖项以支持通知：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![The build.gradle file on wear and mobile apps](img/image00185.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![可穿戴和移动应用程序的 build.gradle 文件](img/image00185.jpeg)'
- en: Handheld app's Android manifest file
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手持应用程序的 Android 替换文件
- en: 'Note the permission grant that allows the app to access a precise location,
    that is, a latitude and longitude coordinate:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意权限授予允许应用程序访问精确位置，即纬度和经度坐标：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We added new activity called `TodoMobileActivity` to let us add to-do items.
    Since we will need to access the GPS sensor, the `ACCESS_FINE_LOCATION` permission
    becomes necessary to this new activity.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个名为 `TodoMobileActivity` 的新活动，以便我们添加待办事项。由于我们需要访问 GPS 传感器，`ACCESS_FINE_LOCATION`
    权限对于这个新活动是必要的。
- en: The `GeofenceTransitionsIntentService` service will react to the changes in
    location.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`GeofenceTransitionsIntentService` 服务将响应位置的变化。'
- en: The TodoMobileActivity class
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`TodoMobileActivity` 类'
- en: 'The `TodoMobileActivity` class is a simple activity that presents the user
    with a list view and capability to add to-do items. Each item added might be associated
    with a known set of locations (home or work), each of which is hardwired to a
    GPS coordinate:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`TodoMobileActivity` 类是一个简单的活动，向用户展示一个列表视图并允许添加待办事项。每个添加的项目可能与一组已知的地点（家庭或工作）相关联，每个地点都硬编码到一个
    GPS 坐标：'
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that the `SimpleGeofence` class we use takes three arguments; it internally
    sets the radius to 50 meters. See the sample code on GitHub for more implementation
    details.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用的 `SimpleGeofence` 类需要三个参数；它内部将半径设置为 50 米。有关更多实现细节，请参阅 GitHub 上的示例代码。
- en: To-do list view
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 待办事项列表视图
- en: 'The following figure depicts what the to-do list view looks like. Users can
    add to-do items, and delete existing ones. Each item in the list is displayed,
    along with its location:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了待办事项列表视图的外观。用户可以添加待办事项，并删除现有的项目。列表中的每个项目都会显示，包括其位置：
- en: '![To-do list view](img/image00186.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![待办事项列表视图](img/image00186.jpeg)'
- en: Adding to-do items
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加待办事项
- en: 'The following image shows sample input for adding a new to-do item to the `Today-Todo`
    app:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了向 `Today-Todo` 应用程序添加新待办事项的示例输入：
- en: '![Adding to-do items](img/image00187.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![添加待办事项](img/image00187.jpeg)'
- en: Mock locations
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟位置
- en: 'You may have noticed that we chose to define two locations—home and work. Now,
    because we have high aspirations, we have ventured to build this app with the
    most deserving individual in mind, namely the President of the United States.
    So, that is why the home coordinates correspond to that of the White House, and
    the work coordinates correspond to that of Capitol Hill (Okay, bad example, we
    know. The President works in the Oval office in the west wing of the White House
    complex. But then, imagine how pointless our sample code would be if `Work` and
    `Home` had the same coordinates?). The `Constants` file with these values is shown
    in the following figure:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到我们选择定义了两个位置——家和办公室。现在，因为我们有很高的抱负，我们冒险为最有资格的个人构建这个应用，即美国总统。所以，这就是为什么家庭坐标对应于白宫，工作坐标对应于国会山（好吧，我们知道这是一个糟糕的例子。总统在白宫西翼的椭圆形办公室工作。但是，想象一下，如果“工作”和“家”有相同的坐标，我们的示例代码将有多么无意义？）。包含这些值的“Constants”文件如下所示：
- en: '![Mock locations](img/image00188.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![模拟位置](img/image00188.jpeg)'
- en: Mocking locations using FakeGPS app
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模拟GPS应用模拟位置
- en: 'Launch the FakeGPS app and search for the location `White House` as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 启动模拟GPS应用，并按如下方式搜索位置“白宫”：
- en: '![Mocking locations using FakeGPS app](img/image00189.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![使用模拟GPS应用模拟位置](img/image00189.jpeg)'
- en: 'After you tap the **Set location** button, FakeGPS will proceed to simulate
    the location we set. Take note of the latitude and longitude in the preceding
    figure. See how close they are to what we defined in `Constants.HOME_LATITUDE`
    and `Constants.HOME_LONGITUDE` in the `Constant` file:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在您点击“设置位置”按钮后，模拟GPS将开始模拟我们设置的位置。注意前图中纬度和经度。看看它们与我们定义在“Constant”文件中的`Constants.HOME_LATITUDE`和`Constants.HOME_LONGITUDE`有多接近：
- en: '![Mocking locations using FakeGPS app](img/image00190.jpeg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![使用模拟GPS应用模拟位置](img/image00190.jpeg)'
- en: The GeofenceTransitionIntentService class
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地理围栏转换IntentService类
- en: 'You may recall from the `TodoMobileActivity` activity, which we covered previously,
    that the `GeofenceIntentService` class will be called anytime there are changes
    in location. The `onHandleIntent` method is where we place code that will notify
    the user about any to-do items based on the `geofence` location that the user
    may have entered:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得我们之前提到的`TodoMobileActivity`活动，其中`GeofenceIntentService`类将在位置发生变化时被调用。`onHandleIntent`方法是我们放置代码以根据用户可能输入的`geofence`位置通知用户任何待办事项的地方：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Handheld app notification
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手持应用通知
- en: 'The following figure shows a run of the application with FakeGPS app set to
    `Home`. See the notification display on the handheld device showing three to-do
    items tied to the Home location:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了将模拟GPS应用设置为“Home”时的应用程序运行情况。请看手持设备上显示的与家庭位置相关的三个待办事项的通知：
- en: '![Handheld app notification](img/image00191.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![手持应用通知](img/image00191.jpeg)'
- en: Wearable app notifications
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可穿戴应用通知
- en: 'The following figure shows the same notification on the wearable device:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了在可穿戴设备上显示的相同通知：
- en: '![Wearable app notifications](img/image00192.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![可穿戴应用通知](img/image00192.jpeg)'
- en: 'Now, if we change the location in the FakeGPS app to `Capitol Hill` and relaunch
    the `Today-Todo` app, we get a different notification, as expected, in the wearable
    device, as shown in the following screenshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们更改模拟GPS应用中的位置为“国会山”并重新启动“今日-待办”应用，正如预期的那样，在可穿戴设备上我们得到了不同的通知，如下面的截图所示：
- en: '![Wearable app notifications](img/image00193.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![可穿戴应用通知](img/image00193.jpeg)'
- en: Summary
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we extended the `Today` app to have a to-do activity. We use
    that extension to demonstrate context-aware notifications using the `Notifications`
    API. The notifications were displayed on the mobile device as well as the wearable
    device emulator. We introduced the concept of geofencing and used the `Geofencing`
    API along with a FakeGPS app to simulate our location.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将“今日”应用扩展以包含待办活动。我们使用这个扩展来演示使用“通知”API实现的环境感知通知。通知在移动设备和可穿戴设备模拟器上显示。我们介绍了地理围栏的概念，并使用“地理围栏”API以及一个模拟GPS应用来模拟我们的位置。
