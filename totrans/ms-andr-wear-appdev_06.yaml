- en: Chapter 6.  Contextual Notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"Life is about timing."* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Carl Lewis* |'
  prefs: []
  type: TYPE_TB
- en: In this chapter, we will discuss notifications in Android Wear. After a quick
    comparison between notifications in wearable and handheld devices, we will continue
    extending the `Today` app from the previous chapter to demonstrate the Android
    Wear notifications API.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code accompanying this chapter is available for reference on GitHub ([https://github.com/siddii/mastering-android-wear/tree/master/Chapter_6](https://github.com/siddii/mastering-android-wear/tree/master/Chapter_6)).
    For the sake of brevity, only code snippets are included as needed. The reader
    is encouraged to download the referenced code from GitHub and follow along as
    they progress through the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting notified
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It should come as no surprise that wearable devices are naturally superior to
    handheld devices in their capacity to deliver notifications to the user. With
    a handheld device, you hear a beep, and you need to draw your device out from
    your purse or pocket or whatever choice holster you snagged at that recent eBay
    auction.
  prefs: []
  type: TYPE_NORMAL
- en: But with a smartwatch, things are quite different. When you hear that beep,
    you simply glance at your wrist. This ease is a hallmark feature of wearable device
    technology.
  prefs: []
  type: TYPE_NORMAL
- en: And it doesn't end there. With the help of voice interactions, the user can
    act on that notification by issuing a recognizable voice command. The voice interactions
    API, of course, predates the Wear API and has been in use on handheld devices
    for some time. But there is no denying the immense value it brings to wearable
    devices, fitting in perfectly with that ease of access. We'll deal with voice
    interactions in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: So central is the notification model to wearable devices that most tutorials
    often introduce notifications as the core use case of Android Wear; the other
    features come later. We, obviously, chose a different treatment in this book.
    Here we are, spanning the halfway point in our book as we encounter the first
    serious discussion on notifications.
  prefs: []
  type: TYPE_NORMAL
- en: We did that, because notification, no matter how important or central they may
    be, are still an application feature, and thus secondary to the core functionality
    of an app. Delving into notifications without the benefit of being exposed to
    the nuts and bolts of an Android Wear app, in our opinion, would be putting the
    cart before the horse.
  prefs: []
  type: TYPE_NORMAL
- en: You've seen the barebones `Today` app, and you've augmented it to work with
    a companion handheld app. That's some good exposure to the Wear API. Now, you're
    ready to build upon that knowledge. Rest assured, if you've followed along so
    far, you will not find the notifications API intimidating by any means.
  prefs: []
  type: TYPE_NORMAL
- en: Enough talk; let's begin by introducing the core classes in the API before we
    get to see them in action in our sample application.
  prefs: []
  type: TYPE_NORMAL
- en: Core classes of the notifications API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are the core classes of the notifications API that we will be using in
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: NotificationCompat.Builder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One thing you want when working with notifications on wearable devices is some
    sort of assurance that your notifications appear acceptable on the significantly
    reduced scale of a smart watch. That is where the notification builder class comes
    in. This class takes care of displaying notifications properly, whether they appear
    on a handheld or wearable device.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the notification builder, you will have to add the following line to
    your `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you''ll need to import the following core classes from the support library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Creating a notification then becomes a matter of instantiating the `NotificationCompat.Builder`
    class and issuing the notification, as we will see in our sample application.
  prefs: []
  type: TYPE_NORMAL
- en: Action buttons in your notification
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `addAction` method lets you add an action to the notification. Simply pass
    in a `PendingIntent` instance to the `addAction` method. While this action appears
    on a handheld as an additional button attached to the notification, on a wearable
    device it appears as a large button when the user swipes the notification to the
    left. Tapping the action invokes the associated intent on the handheld.
  prefs: []
  type: TYPE_NORMAL
- en: Wearable-only actions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want the actions available on the wearable to be different than those
    on the handheld, use the `addAction` method on the `NotificationCompat.WearableExtender`
    class. Doing so ensures that the wearable does not display actions added to the
    `NotificationCompat.Builder.addAction` class.
  prefs: []
  type: TYPE_NORMAL
- en: Delivery
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use the `NotificationManagerCompat` API instead of `NotificationManager` to
    deliver your notification, shown as follows. This ensures compatibility with older
    platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Today app with to-do notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to augment our `Today` app with a to-do activity that lets the
    user add to-do items and associate them with specific locations, such as home,
    or work. The locations then provide the context, which drives the notifications.
    This, in effect, makes our notifications *context-aware*.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the system detects that the user is in close proximity to the
    Home location, then to-do items associated with the `Home` category are presented
    to the user via the notifications API.
  prefs: []
  type: TYPE_NORMAL
- en: Geofencing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll be using the `Geofencing` API to figure out the location, that is, the
    context. In essence, this API lets us draw a circle of some agreed-upon radius
    around a coordinate. In effect, the latitude, longitude, and radius together define
    a *geofence*, a circular region around the coordinates of interest. Entrance and
    exit events signal when the device enters or exits the geofence location. An optional
    duration attribute delays the triggering of an event for that time interval once
    the device has entered and remained within the geofence.
  prefs: []
  type: TYPE_NORMAL
- en: You can study the `Geofencing` API in detail by visiting [https://developer.android.com/training/location/geofencing.html](https://developer.android.com/training/location/geofencing.html).
  prefs: []
  type: TYPE_NORMAL
- en: Mocking a GPS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to mention at the outset that it is not easy to simulate the
    location/GPS sensor behavior on a wearable device emulator, which all our sample
    code uses. A physical device equipped with GPS is needed for that. Furthermore,
    even if we did have access to a fully functional GPS, we could potentially run
    into frustrating scenarios testing our app—consider having to move physically
    to a different location in order to trigger the GPS sensors.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, for the purposes of demonstrating context-aware notifications, we need
    a GPS mocking service that lets us use our wearable device emulator along with
    the physical handheld device, yet simulate different locations on demand.
  prefs: []
  type: TYPE_NORMAL
- en: This is where ByteRev's **FakeGPS** application comes into play ([https://play.google.com/store/apps/details?id=com.lexa.fakegps&hl=en](https://play.google.com/store/apps/details?id=com.lexa.fakegps&hl=en)).
  prefs: []
  type: TYPE_NORMAL
- en: This free app lets us mock different locations and effectively gives us the
    equivalent experience of working with a fully functional GPS unit on a physical
    device. The downside is that the user may need to rerun the app in order to simulate
    the intended behavior. But that is an acceptable trade-off for flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: The build.gradle file on wear and mobile apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `build.gradle` file of the mobile handheld app should contain the following
    line for location services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Both wear and mobile apps should contain the following compile dependencies
    for notification support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![The build.gradle file on wear and mobile apps](img/image00185.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Handheld app's Android manifest file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Note the permission grant that allows the app to access a precise location,
    that is, a latitude and longitude coordinate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We added new activity called `TodoMobileActivity` to let us add to-do items.
    Since we will need to access the GPS sensor, the `ACCESS_FINE_LOCATION` permission
    becomes necessary to this new activity.
  prefs: []
  type: TYPE_NORMAL
- en: The `GeofenceTransitionsIntentService` service will react to the changes in
    location.
  prefs: []
  type: TYPE_NORMAL
- en: The TodoMobileActivity class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `TodoMobileActivity` class is a simple activity that presents the user
    with a list view and capability to add to-do items. Each item added might be associated
    with a known set of locations (home or work), each of which is hardwired to a
    GPS coordinate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `SimpleGeofence` class we use takes three arguments; it internally
    sets the radius to 50 meters. See the sample code on GitHub for more implementation
    details.
  prefs: []
  type: TYPE_NORMAL
- en: To-do list view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following figure depicts what the to-do list view looks like. Users can
    add to-do items, and delete existing ones. Each item in the list is displayed,
    along with its location:'
  prefs: []
  type: TYPE_NORMAL
- en: '![To-do list view](img/image00186.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Adding to-do items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following image shows sample input for adding a new to-do item to the `Today-Todo`
    app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding to-do items](img/image00187.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Mock locations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may have noticed that we chose to define two locations—home and work. Now,
    because we have high aspirations, we have ventured to build this app with the
    most deserving individual in mind, namely the President of the United States.
    So, that is why the home coordinates correspond to that of the White House, and
    the work coordinates correspond to that of Capitol Hill (Okay, bad example, we
    know. The President works in the Oval office in the west wing of the White House
    complex. But then, imagine how pointless our sample code would be if `Work` and
    `Home` had the same coordinates?). The `Constants` file with these values is shown
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mock locations](img/image00188.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Mocking locations using FakeGPS app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Launch the FakeGPS app and search for the location `White House` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mocking locations using FakeGPS app](img/image00189.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After you tap the **Set location** button, FakeGPS will proceed to simulate
    the location we set. Take note of the latitude and longitude in the preceding
    figure. See how close they are to what we defined in `Constants.HOME_LATITUDE`
    and `Constants.HOME_LONGITUDE` in the `Constant` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mocking locations using FakeGPS app](img/image00190.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The GeofenceTransitionIntentService class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may recall from the `TodoMobileActivity` activity, which we covered previously,
    that the `GeofenceIntentService` class will be called anytime there are changes
    in location. The `onHandleIntent` method is where we place code that will notify
    the user about any to-do items based on the `geofence` location that the user
    may have entered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Handheld app notification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following figure shows a run of the application with FakeGPS app set to
    `Home`. See the notification display on the handheld device showing three to-do
    items tied to the Home location:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handheld app notification](img/image00191.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Wearable app notifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following figure shows the same notification on the wearable device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wearable app notifications](img/image00192.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if we change the location in the FakeGPS app to `Capitol Hill` and relaunch
    the `Today-Todo` app, we get a different notification, as expected, in the wearable
    device, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wearable app notifications](img/image00193.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we extended the `Today` app to have a to-do activity. We use
    that extension to demonstrate context-aware notifications using the `Notifications`
    API. The notifications were displayed on the mobile device as well as the wearable
    device emulator. We introduced the concept of geofencing and used the `Geofencing`
    API along with a FakeGPS app to simulate our location.
  prefs: []
  type: TYPE_NORMAL
