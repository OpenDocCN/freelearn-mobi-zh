- en: Chapter 2. Basic Build Customization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started out by looking at the uses of Gradle, and creating and converting
    Android projects. Now it is time to get a better understanding of the build files,
    to look at some useful tasks, and to explore the possibilities of both Gradle
    and the Android plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Gradle files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with build tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing the build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Gradle files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When creating a new project with Android Studio, three Gradle files are generated
    by default. Two of those files, `settings.gradle` and `build.gradle`, end up on
    the top level of the project. Another `build.gradle` file is created in the Android
    app module. This is how the Gradle files are placed in the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: These three files each serve their own purpose, which we will further look into
    in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: The settings file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For a new project containing only an Android app, `settings.gradle` looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The settings file is executed during the initialization phase, and defines which
    modules should be included in the build. In this example, the `app` module is
    included. Single module projects do not necessarily require a settings file, but
    multimodule projects do; otherwise, Gradle does not know which modules to include.
  prefs: []
  type: TYPE_NORMAL
- en: Behind the scenes, Gradle creates a `Settings` object for every settings file,
    and invokes the necessary methods from that object. You do not need to know the
    details of the `Settings` class, but it is good to be aware of this.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A full explanation of the `Settings` class is out of the scope of this book.
    If you would like to know more, you can find a lot of information in the Gradle
    documentation ([https://gradle.org/docs/current/dsl/org.gradle.api.initialization.Settings.html](https://gradle.org/docs/current/dsl/org.gradle.api.initialization.Settings.html)).
  prefs: []
  type: TYPE_NORMAL
- en: The top-level build file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The top-level `build.gradle` file is where you can configure options that need
    to be applied to all the modules in the project. It contains two blocks by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `buildscript` block is where the actual build is configured. We looked at
    this briefly in [Chapter 1](ch01.html "Chapter 1. Getting Started with Gradle
    and Android Studio"), *Getting Started with Gradle and Android Studio*. The `repositories`
    block configures JCenter as a repository. In this case, a repository means a source
    of dependencies or, in other words, a list of downloadable libraries that we can
    use in our apps and libraries. JCenter is a well-known Maven repository.
  prefs: []
  type: TYPE_NORMAL
- en: The `dependencies` block is used to configure dependencies for the build process
    itself. This means that you should not include dependencies that you need for
    your applications or libraries in the top-level build file. The only dependency
    that is defined by default is the Android plugin for Gradle. This is required
    for every Android module, because it is this plugin that makes it possible to
    execute Android-related tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The `allprojects` block can be used to define properties that need to be applied
    to all modules. You can take it even further and create tasks in the `allprojects`
    block. Those tasks will then be available in all modules.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As soon as you use `allprojects`, the modules are coupled to the project. This
    means that it will likely be impossible to build the modules separately, without
    the main project's build file. It might not seem like an issue at first, but later
    you might decide to separate an internal library into its own project, and then
    you will need to refactor your build files.
  prefs: []
  type: TYPE_NORMAL
- en: The module build file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The module-level `build.gradle` file contains options that only apply to the
    Android app module. It can also override any options from the top-level `build.gradle`
    file. The module build file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We will take a detailed look at the three main blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Plugin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first line applies the Android application plugin, which is configured as
    a dependency in the top-level build file, which we discussed earlier. The Android
    plugin is written and maintained by the Android Tools team at Google, and provides
    all tasks needed to build, test, and package Android applications and libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Android
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The biggest part of the build file is the `android` block. This block contains
    the entire Android-specific configuration, which is available through the Android
    plugin we applied earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only properties that are required are `compileSdkVersion` and `buildToolsVersion`:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one, `compileSdkVersion`, is the API version of Android that you want
    to use to compile your app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second one, `buildToolsVersion`, is the version of build tools and compilers
    to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The build tools contain command-line utilities, such as aapt, zipalign, dx,
    and renderscript; which are used to produce the various intermediate artifacts
    that make up your application. You can download the build tools through the SDK
    Manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `defaultConfig` block configures core properties for the app. The properties
    in this block override the corresponding entries in the `AndroidManifest.xml`
    manifest file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The first property in this block is `applicationId`. This overrides the package
    name from the manifest file, but there are some differences between `applicationId`
    and the package name. Before Gradle was used as the default Android build system,
    the package name in `AndroidManifest.xml` had two purposes: it served as the unique
    identifier of an app, and it was used as the name for the package in the R resource
    class. Gradle makes it easier to create different versions of your app, using
    build variants. For example, it is very easy to make a free version and a paid
    version. These two versions need to have separate identifiers, so they appear
    as different apps on the Google Play Store, and can both be installed at the same
    time. The source code and generated R class, however, must retain the same package
    name at all times. Otherwise, all your source files would need to change, depending
    on the version you are building. That is why the Android Tools team has decoupled
    these two different usages of package name. The package, as defined in the manifest
    file, continues to be used in your source code and your R class, while the package
    name that is used by the device and Google Play as the unique identifier is now
    referred to as *application id*. This application ID will become a lot more interesting
    as we start experimenting with build types.'
  prefs: []
  type: TYPE_NORMAL
- en: The next two properties in `defaultConfig` are `minSdkVersion` and `targetSdkVersion`.
    Both of these should look familiar because they have always been defined in the
    manifest as part of the `<uses-sdk>` element. The `minSdkVersion` setting is used
    to configure the minimum API level required to run the app. The `targetSdkVersion`
    setting informs the system that the app is tested on a specific version of Android,
    and that the operating system does not need to enable any forward-compatibility
    behavior. This has nothing to do with `compileSdkVersion` that we saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The `versionCode` and `versionName` also have the same function as in the manifest
    file, and define a version number and a user-friendly version name for your app.
  prefs: []
  type: TYPE_NORMAL
- en: All values in the build file will override the values in the manifest file.
    It is therefore not required to define them in the manifest file if you define
    them in `build.gradle`. In case the build file does not contain a value, the manifest
    values will be used as a fallback.
  prefs: []
  type: TYPE_NORMAL
- en: The `buildTypes` block is where you define how to build and package the different
    build types of your app. We will take a detailed look at build types in [Chapter
    4](ch04.html "Chapter 4. Creating Build Variants"), *Creating Build Variants*.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `dependencies` block is a part of the standard Gradle configuration (that
    is why it is placed outside of the `android` block) and defines all dependencies
    for an app or library. By default, a new Android app has a dependency on all the
    JAR files in the `libs` directory. Depending on the options you select in the
    new project wizard, it might also depend on the `AppCompat` library. We will discuss
    dependencies in [Chapter 3](ch03.html "Chapter 3. Managing Dependencies"), *Managing
    Dependencies*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To know which tasks are available on a project, you can run `gradlew tasks`,
    which prints out a list of all the available tasks. In a newly created Android
    project, this includes Android tasks, build tasks, build setup tasks, help tasks,
    install tasks, verification tasks and other tasks. If you want to see not only
    the tasks, but also their dependencies, you can run `gradlew tasks --all`. It
    is possible to do a dry run of tasks, which prints out all the steps that are
    executed when running a specific task. This dry run will not actually perform
    any of these steps, so it is a safe way to see what you can expect to happen when
    running a certain task. You can do a dry run by adding the parameters `-m` or
    `--dry-run`.
  prefs: []
  type: TYPE_NORMAL
- en: Base tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Android plugin for Gradle makes use of the Java base plugin, which in turn
    makes use of the base plugin. These add the standard lifecycle tasks and some
    common convention properties. The base plugin defines the tasks `assemble` and
    `clean`, and the Java base plugin defines the tasks `check` and `build`. These
    tasks are not implemented in the base plugin and do not perform any actions; they
    are used to define a convention for plugins that add the actual tasks that do
    the work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The conventions for these tasks are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assemble` assembles the output(s) of the project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clean` cleans the output of the project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`check` runs all the checks, usually unit tests and instrumentation tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`build` runs both `assemble` and `check`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Java base plugin also adds the concept of source sets. The Android plugin
    builds on these conventions, and thus exposes tasks that experienced Gradle users
    are used to seeing. On top of those base tasks, the Android plugin also adds a
    lot of Android-specific tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Android tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Android plugin extends the base tasks and implements their behavior. This
    is what the tasks do in an Android environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assemble` creates an APK for every build type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clean` removes all the build artifacts, such as the APK files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`check` performs Lint checks and can abort the build if Lint detects an issue'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`build` runs both `assemble` and `check`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `assemble` task depends on `assembleDebug` and `assembleRelease` by default,
    and more tasks if you add more build types. This means running `assemble` will
    trigger a build for every build type you have.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides extending these tasks, the Android plugin also adds a few new ones.
    These are the most significant new tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`connectedCheck` runs tests on a connected device or emulator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deviceCheck` is a placeholder task for other plugins to run tests on remote
    devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`installDebug` and `installRelease` install a specific version to a connected
    device or emulator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All `install` tasks also have `uninstall` counterparts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `build` task depends on `check`, but not on `connectedCheck` or `deviceCheck`.
    This is to make sure that regular checks do not require a connected device or
    running emulator. Running the check tasks generates a Lint report with a list
    of all warnings and errors, with a detailed explanation and a link to the related
    documentation. This report can be found in `app/build/outputs` and is called `lint-results.html`.
    It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Android tasks](img/B01061_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you assemble a release, Lint will check for fatal issues that could cause
    the app to crash. If it finds any issues, it will abort the build and print the
    errors to the command-line interface. Lint will also generate a report in `app/build/outputs`
    in a file called `lint-results-release-fatal.html`. If you have multiple issues,
    going through the HTML report is more pleasant than scrolling back and forth in
    the command-line interface. The provided links are also extremely useful, because
    they take you to detailed explanations of the issues.
  prefs: []
  type: TYPE_NORMAL
- en: Inside Android Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You do not always have to run Gradle tasks from the command-line interface.
    Android Studio has a tool window that contains a list of all the available tasks.
    This tool window is called **Gradle** and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inside Android Studio](img/B01061_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From this tool window, you can run a task simply by double-clicking on its
    name. You can follow the progress of any running task in the **Gradle Console**
    tool window. If you cannot find these tool windows, you can open them in the **View**
    menu, under **Tool Window**. This is what the Gradle Console tool window looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inside Android Studio](img/B01061_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can also run tasks from a command-line interface inside Android Studio,
    so you can do all app-related work inside the IDE if you like. To run the command,
    you need to open the **Terminal** tool window. This is a full-blown terminal,
    so it is possible to run any command from it. You might need to navigate to the
    top level of the project first, in order to work with the Gradle wrapper.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Changing the Android Studio terminal**'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to configure the terminal inside Android Studio to use a different
    shell. On Microsoft Windows, for example, the terminal defaults to Command Prompt.
    If you prefer to use the Git Bash (or any other shell) instead, open the Android
    Studio settings (under `File` and `Settings`) and look for **Terminal**. There
    you can change the shell path. For Git Bash on Microsoft Windows, it looks like
    this: `C:\Program Files (x86)\Git\bin\sh.exe --login -i`.'
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a lot of ways to customize the build process, and when you are editing
    the build files in Android Studio, it is recommended to always sync the project
    with the Gradle files, no matter what you are customizing. This becomes especially
    important when you start adding dependencies or `BuildConfig` fields, which we
    will talk about soon.
  prefs: []
  type: TYPE_NORMAL
- en: Android Studio will show a message in the editor as soon as you edit `settings.gradle`
    or `build.gradle`, and it is possible to trigger the sync at all times by navigating
    to **Tools** | **Android** | **Sync Project with Gradle Files** or the corresponding
    button in the toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing the build](img/B01061_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Under the hood, the Android Studio Sync actually runs the `generateDebugSources`
    task to generate all the necessary classes, based on the configuration in the
    build files.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating manifest entries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already saw that it is possible to configure `applicationId`, `minSdkVersion`,
    `targetSdkVersion`, `versionCode`, and `versionName` directly from the build files,
    instead of in the manifest file. There are a few more properties that you can
    manipulate:'
  prefs: []
  type: TYPE_NORMAL
- en: '`testApplicationId` is the application ID for the instrument test APK'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`testInstrumentationRunner` is the name of the JUnit test runner to be used
    for running your test (see [Chapter 6](ch06.html "Chapter 6. Running Tests"),
    *Running Tests*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`signingConfig` (see [Chapter 4](ch04.html "Chapter 4. Creating Build Variants"),
    *Creating Build Variants*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`proguardFile` and `proguardFiles` (see [Chapter 9](ch09.html "Chapter 9. Advanced
    Build Customization"), *Advanced Build Customization*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside Android Studio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Instead of manually making changes in the build files, you can also change
    the basic settings in the **Project Structure** dialog in Android Studio. You
    can open the dialog from the **File** menu, and it enables you to edit project-wide
    settings and settings per module. For every Android module, you can change the
    standard Android plugin properties and all the manifest properties. In the following
    screenshot, you can see the properties for the release version of the app module
    in the **Project Structure** dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inside Android Studio](img/B01061_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Be aware that if you make any changes in the **Project Structure** dialog, Android
    Studio will write the changes to the Gradle build configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: BuildConfig and resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ever since SDK tools revision 17, the build tools generate a class called `BuildConfig`,
    which contains a `DEBUG` constant that is set according to the build type. This
    is useful if you have code that you only want to run when debugging, such as logging.
    It is possible through Gradle to extend that file so that you can have constants
    that contain different values in debug and release.
  prefs: []
  type: TYPE_NORMAL
- en: 'These constants are useful for toggling features or setting server URLs, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The escaped double quotes around the string value are necessary for it to be
    generated as an actual string. After adding the `buildConfigField` lines, it is
    possible to use `BuildConfig.API_URL` and `BuildConfig.LOG_HTTP` in your actual
    Java code.
  prefs: []
  type: TYPE_NORMAL
- en: 'More recently, the Android Tools team has also added the possibility to configure
    resources in a similar manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The escaped double quotes are not necessary here, because resource values are
    always wrapped with `value=""` by default.
  prefs: []
  type: TYPE_NORMAL
- en: Project-wide settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have multiple Android modules in one project, it can be useful to apply
    settings to all of them without manually changing the build file for every module.
    We already saw how the `allprojects` block is used in the generated top-level
    build file to define repositories, and you can use the same strategy to apply
    Android-specific settings as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will only work if all your modules are Android app projects though, because
    you need to apply the Android plugin to get access to the Android-specific settings.
    A better way to achieve this behavior is to define the values in the top-level
    build file, and then apply them in the modules. It is possible in Gradle to add
    extra ad hoc properties on the `Project` object. This means that any `build.gradle`
    file can define extra properties, and this happens in an `ext` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add an `ext` block with custom properties to the top-level build file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes it possible to use the properties in module-level build files using
    `rootProject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Project properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ext` block in the previous example is a way of defining extra properties.
    You can use properties to customize a build process on the fly, and we will make
    use of them when we start writing custom tasks in [Chapter 7](ch07.html "Chapter 7. Creating
    Tasks and Plugins"), *Creating Tasks and Plugins*. There are several ways to define
    properties, but we will only look at the three most used ones:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ext` block
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `gradle.properties` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-P` command-line parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example `build.gradle` file that incorporates those three ways of
    adding extra properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the accompanying `gradle.properties` file (in the same folder):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the example, we create a new task. We will look at tasks and explain the
    syntax in [Chapter 7](ch07.html "Chapter 7. Creating Tasks and Plugins"), *Creating
    Tasks and Plugins*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the `printProperties` task with a command-line parameter, the output
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to custom properties, changing the configuration of a build is as easy
    as changing a single property, or even just adding a command-line parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to define properties, both in the top-level build file and in
    the module build files. If a module defines a property that already exists in
    the top-level file, it will simply override it.
  prefs: []
  type: TYPE_NORMAL
- en: Default tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you run Gradle without specifying a task, it runs the `help` task, which
    prints some information on how to work with Gradle. This happens because the help
    task is set as the default task. It is possible to override the default task and
    have a very common task, or even multiple tasks, run every time you execute Gradle
    without explicitly specifying the task.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify default tasks, add this line to the top-level `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, when you run the Gradle wrapper without any parameters, it will run `clean`
    and `assembleDebug`. It is easy to see which tasks are set as default by running
    the `tasks` task and filtering the output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a detailed look at the different Gradle files that
    are automatically generated by Android Studio. You are now able to create build
    files yourself, and add all the required fields and configure the key properties.
  prefs: []
  type: TYPE_NORMAL
- en: We got started with the basic build tasks, and learned how the Android plugin
    builds on the base plugin, and extends it with new Android-specific tasks. We
    also saw how to run build tasks both from the command-line interface, and from
    inside Android Studio.
  prefs: []
  type: TYPE_NORMAL
- en: In the final part of the chapter, we looked at several ways to influence the
    output of the build, and ways to configure parts of the build process itself.
  prefs: []
  type: TYPE_NORMAL
- en: In the last few years, the Android developer ecosystem has grown immensely,
    and a lot of interesting libraries have become available for everyone to use.
    In the next chapter, we will look at several ways to add dependencies to a project,
    so we can take advantage of this abundance of resources.
  prefs: []
  type: TYPE_NORMAL
