- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Architect Your App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of developing apps needs to be scalable in such a way that you can
    maintain the app over a long time and easily hand over the development of it to
    other developers or teams. To be able to do this, we need to properly think about
    the architecture of our apps. We will be looking at how to build our apps in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will build on what we’ve learned from the previous chapters.
    We are going to look at the different architectures available for Android projects.
    We’ll dive deep into **MVVM architecture** and its different layers and how to
    use some of the Jetpack libraries within their architecture. Additionally, we’ll
    learn how to use advanced architecture features, such as dependency injection
    and Kotlin Gradle DSL, as well as version catalogs to define dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to app architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MVVM deep dive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jetpack libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Migrating to Kotlin Gradle DSL and using version catalogs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the instructions in this chapter, you will need to have Android Studio
    Hedgehog or later ([https://developer.android.com/studio](https://developer.android.com/studio))
    downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code for this chapter at [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfive](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfive).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to app architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have learned how to create apps and designed beautiful UIs with
    Material 3 and Jetpack Compose. We haven’t yet started adopting any architecture
    for our apps. In this section, we will look at some of the app architectures that
    we can use to build our apps. We will also look at some of the best practices
    that we can follow when building our apps. First, let’s see some of the benefits
    of using an app architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Separation of concerns**: Using an architecture allows us to separate our
    code into different layers. Each layer only does one thing. This makes it easy
    to separate and group our code into different layers. Each layer has its responsibility.
    This prevents things from being mixed up and makes it easier to maintain our code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy testing**: Using an architecture makes it easy to test our code. We
    can easily test each layer of our code in isolation since things are not tightly
    coupled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy to maintain**: Using an architecture makes it easy to maintain our code.
    We can easily make changes to our code without affecting other parts of our code.
    This makes it easy to maintain our code over the long term. We can also swap in
    and out different parts of the code, and since we have tests, we can test the
    different implementations and ensure that nothing breaks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy to scale**: Using an architecture makes it easy to scale our code. We
    can easily add new features to our code without affecting other parts of our code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy to work in teams**: Using an architecture makes it easy to work in teams.
    Each team member or team can work on a different layer of the code. It makes it
    possible to work concurrently on different parts of the codebase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Promotes reusability**: Over time, we can place some of the commonly used
    code across the projects in common packages or modules, which can then be re-used
    across the project without having to repeat the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When it comes to choosing an architecture for our apps, there are a lot of
    options that we can choose from. There isn’t a particular architecture that fits
    all the use cases, so it’s always recommended that we discuss things with our
    teams and see which architecture fits the use case. Each architecture has its
    pros and cons, and we or the whole team have to evaluate which one has more pros
    than cons. We can architect our app either by feature or by layers. When we architect
    by feature, we have layers that represent a feature. When we architect by layers,
    we have layers that represent a layer of our app. An example of architecting by
    feature is shown in the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Home feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profile feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Settings feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding example shows how we can architect our app by feature. We have
    the **Home**, **Profile**, and **Settings** features. Each feature has its layers
    and all the code related to that feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the architectures that we can use to build our apps are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model, View, and ViewModel** (**MVVM**): This is the most commonly used architecture
    and is even recommended by Google to use with our apps. The app has the **Model**
    **View** and **ViewModel** layers. The Model layer is responsible for holding
    the data. The View layer is responsible for displaying the data. The ViewModel
    layer is responsible for holding the state of the data. It is also responsible
    for communicating with the Model and View layers. MMVM promotes the clear separation
    of concerns between the different layers. It also supports **data binding**, which
    makes it easy to update the UI when the data change. It also supports testing
    since the different layers are not tightly coupled. It also has less boilerplate
    code when compared to other architectures. However, it has its downsides, one
    of them being a large learning curve at times and this can become complex very
    easily, especially with lots of features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model View Intent** (**MVI**): This has three key layers. The **Model** layer
    is responsible for holding the data. The **View** layer is responsible for displaying
    the data. The **Intent** layer represents user actions or events that are dispatched
    to the model to update a state. MVI promotes unidirectional **data flow**, where
    data flow in the same direction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model View Controller** (**MVC**): This architecture has three layers. The
    **Model** layer represents the business logic and holds the data. The **View**
    layer is responsible for displaying the data. The **Controller** layer is responsible
    for and acts as an intermediary between the model and the view. It takes care
    of the user input and updates the view and the model. MVC is very straightforward,
    especially when starting out, and enables quick iterations and a showcase of app
    architecture. Its only problem is that it has a tight coupling between the layers,
    making it hard to test and scale.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model View Presenter** (**MVP**): This architecture has three layers. The
    **Model** layer represents the business logic and holds the data. The **View**
    layer displays the data and UI components and observes user interactions. The
    views delegate all UI-related logic to the presenters. The **Presenter** layer
    contains presentation logic and acts as an intermediary between the model and
    the view. It processes the user input and updates the view and the model. MVP
    has a good separation of concerns, and the code is easily testable. However, it
    has a lot of boilerplate code since every view must have its own presenter. It
    also has a large learning curve and can become complex very easily.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we understand the different architectures, let us look at MVVM and
    how we can use it in our apps.
  prefs: []
  type: TYPE_NORMAL
- en: Deep Diving into MVVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen the MVVM layers and their pros and cons. In this section,
    we are going to implement the MMVM architecture in our app step by step. We will
    start with the model layer, going upwards. Since we all love to have the company
    of our pets, we are going to use different types of pets as our data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us start by creating a `com.packt.chapterfive` package; then, we select
    `data`. Inside this `data` package, let us create a `Pet` data class that will
    represent our pets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Pet` data class holds all the data for our pets. Next, we will create
    a repository interface and its implementation that allows us to get these pets.
    Create a new file named `PetsRepository` inside the `data` package with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an interface with one method that returns `List<Pet>`. Next, let us
    create the implementation class for our interface. While still inside the `data`
    package, create a new file named `PetsRepositoryImpl` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To explain what the preceding code does, please see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We created a class named **PetsRepositoryImpl**, which implements the **PetsRepository**
    interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We override the **getPets()** method and return a list of pets. Our list has
    10 pets with **ID**, **name**, and **species**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have used a pattern called the **repository pattern** to get our pets. The
    repository pattern is a pattern that allows us to abstract the data layer from
    the rest of the app. It allows us to get data from different sources without affecting
    the rest of the app. For example, we can get data from a local database or a remote
    server. The class is responsible for merging the data from the two sources and
    maintaining the source of truth for our data. The repository pattern also allows
    us to easily test our code since we can easily mock the repository and test the
    different layers of our app in isolation. Since our app is very simple at the
    moment, we have already completed the data/model layer of our architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now create a `ViewModel` class for our `ViewModel` layer. Start by creating
    a `ViewModel` package inside the `com.packt.chapterfive` package. Inside this
    `ViewModel` package, create a new file named `PetsViewModel` with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To explain what the preceding code does, please see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We created a class named **PetsViewModel** that extends the **ViewModel** class.
    This is a class from the **Jetpack libraries**. It helps data persist across configuration
    changes. It also acts as the intermediary between the View and the Model layers.
    We use it to expose data to our views, act on user interactions, and update the
    data in the Model layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created a private property named **petsRepository** of type **PetsRepository**
    and initialized it with an instance of **PetsRepositoryImpl**. This is the repository
    we created earlier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created a method named **getPets()** that returns a list of pets. We called
    the **getPets()** method from the **petsRepository** property and returned the
    result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this, our `ViewModel` layer is ready to expose data to our views. Our `getPets()`
    method returns a list of pets. To display the list in `LazyColumn` composable.
    `LazyColumn` follows a lazy-loading approach, meaning that only the items currently
    visible on the screen are actively composed, reducing resource usage and improving
    performance. Let us see how a `LazyColumn` works under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: How LazyColumn works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is how a `LazyColumn` works:'
  prefs: []
  type: TYPE_NORMAL
- en: '**On-demand composing**: **LazyColumn** composes only the visible items on
    the screen. As the user scrolls, it dynamically composes and recomposes items,
    ensuring that only the necessary elements are rendered at any given time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recycling items**: Similar to the recycling mechanism in **RecyclerView**,
    **LazyColumn** reuses composables that move in and out of the viewport, minimizing
    memory usage and preventing unnecessary recomposition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimized for performance**: By lazily loading and recycling items, **LazyColumn**
    optimizes the rendering process, making it well-suited for displaying large datasets
    without consuming excessive resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know how `LazyColumn` works, let’s see the benefits of using `LazyColumn`.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of LazyColumn
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some of the benefits of `LazyColumn` are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Efficient memory usage**: **LazyColumn** efficiently manages memory by composing
    only the visible items, ensuring that the app does not unnecessarily store and
    render all items in a list at once. This is particularly beneficial for long lists
    or lists with complex UI elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved rendering performance**: The lazy-loading mechanism significantly
    improves rendering performance, especially when dealing with extensive datasets.
    It avoids the overhead of rendering and managing all items simultaneously, resulting
    in smoother scrolling and reduced lag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplified UI code**: The declarative nature of Jetpack Compose, coupled
    with **LazyColumn**, allows us to express UI logic concisely. The code to create
    and manage large lists becomes more straightforward and readable compared to traditional
    Android View approaches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automatic recomposition**: As the data source changes, **LazyColumn** automatically
    recomposes only the affected items, reducing the need for manual interventions
    to update the UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adaptable for various screen sizes**: **LazyColumn** adapts well to different
    screen sizes and resolutions, offering a consistent and responsive user experience
    across various devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we’re going to create a composable that displays pets.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a composable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a composable:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new package named **views** inside the **com.packt.chapterfive** package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside this **views** package, create a new file named **PetsList** with the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have created a composable named `PetList` that takes a modifier as
    a parameter. We then create an instance of `PetsViewModel` using the `viewModel()`
    function from the lifecycle utility library for `ViewModel` in compose. It helps
    us easily create an instance of our `PetsViewModel`. We then use the `LazyColumn`
    composable to display the pets. We pass the list of pets from the `ViewModel`
    to the `items` parameter of the `LazyColumn`. We then use the `Row` composable
    to display the name and species of each pet. We have now completed the view layer
    of our architecture.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To finally display our pets, we need to call our **PetList** composable inside
    the **setContent** block of our **MainActivity** class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are using the `Scaffold` composable, which we are already familiar with.
    In our `Scaffold`, we are passing in a `TopAppBar` and our `PetList` composable.
    We are also passing in `paddingValues` to our `PetList` composable. This is because
    we are using `paddingValues` to add padding to our `PetList` composable. We have
    now completed the MVVM architecture in our app. Let’s run the app and see the
    result:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Pet list](img/B19779_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Pet list
  prefs: []
  type: TYPE_NORMAL
- en: As seen from the preceding image, we have our list of pets with their name and
    species displayed in a list.
  prefs: []
  type: TYPE_NORMAL
- en: We have mentioned **Jetpack libraries** a lot in this section but have not explained
    what they are. In the next section, we are going to look at Jetpack libraries
    in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Jetpack libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Jetpack Libraries are a collection of libraries and APIs from Google that help
    us developers create better apps using less code. They are normally created to
    address some pain points we, as developers, face while creating our apps. Let’s
    look at some of these pain points and some of the Jetpack libraries that were
    created to address them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Storing data locally and observing changes to the data**: We had to use **SQLite**
    to store data locally. Even for simple **Create**, **Read**, **Update**, and **Delete**
    (**CRUD**) operations, we had to write a lot of boilerplate code. We also had
    to write a lot of code to observe changes to the data. This is a lot of work for
    a simple task. Jetpack libraries, such as **Room** and **LiveData**, were created
    to address this pain point. Room is a library that allows us to easily store data
    locally. It also allows us to easily observe changes to the data. LiveData is
    a library that allows us to observe changes to data easily. It is also lifecycle-aware.
    This means it automatically stops observing data changes when the lifecycle of
    the component observing the data ends. This helps us avoid memory leaks in our
    apps. Room also has support for **Kotlin Coroutines**, which we will be looking
    at deeply in [*Chapter 6*](B19779_06.xhtml#_idTextAnchor084). This makes it easy
    to store and access data locally with less boilerplate code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Navigation was a challenging thing to achieve perfectly in our apps**: Lots
    of open-source libraries were created to solve this pain point. It also required
    a lot of boilerplate code to navigate between activities and fragments and maintain
    consistent and predictable back behavior. **Jetpack Navigation** was created to
    address this pain point. It allows us to navigate between screens in our app easily.
    It also allows us to easily maintain consistent and predictable back behavior.
    It also allows us to pass data between screens in our app. It also has support
    for Jetpack Compose and functions, such as deep links, which are supposed to open
    a specific screen in our app when a user clicks on a link.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handling lifecycle in activities and fragments**: In Android, both activities
    and fragments have their own lifecycle, and it is particularly important for us
    to be aware of these lifecycles so that we can be able to do operations in the
    right lifecycle. For example, we should be observing data in our views when the
    lifecycle is in the started state and free up resources when the lifecycle is
    either in the stopped or destroyed state. Doing this was harder and required a
    lot of code, which could be bug-prone. The team at Google came up with the **lifecycle**
    library to help us manage lifecycles in our activities and fragments. Additionally,
    we have classes, such as the **ViewModel**, which we created earlier on, that
    allow your data to persist across configuration changes. Most of the Jetpack libraries
    are also lifecycle-aware, which makes it easy to use them in our apps. Taking
    the ViewModel as an example, it survives beyond the lifecycle of the activity
    or fragment that created it. This makes it easy for data to persist across configuration
    changes. It also makes it easy to share data between fragments and activities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Loading infinite lists**: Most apps that we developers work on have a list
    of items that we want to show to our users. Often, this list of items can be large,
    and we cannot display all of them at once. We are supposed to display them in
    batches, which is called **pagination**. To achieve this by ourselves, we had
    to do several workarounds, such as observing the scroll position and fetching
    the next or previous batch of items when a user reaches the top or bottom of the
    list. Again, this was quite a bit of work, and the team at Google introduced the
    **Paging** library to help us achieve this. It allows us to load data in batches
    easily and display it to our users. It also has support for Jetpack Compose and
    Kotlin Coroutines. It makes it easy to display infinite lists in our apps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handling background jobs**: Performing lengthy background tasks for apps
    proved to be somewhat challenging. The common issue was that some of the background
    jobs did not run due to the different restrictions that phone manufacturers add
    to the phones to improve their performance of the phone. The team at Google introduced
    the **WorkManager** library to help us achieve this. It allows us to schedule
    background jobs in our apps easily. It also supports periodic background jobs
    and ensures that our jobs run irrespective of the phone brand that the user is
    using.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: There was no clear guidance on how best we developers can
    improve the performance of our apps. That is not the case anymore; we have several
    Jetpack libraries to help us detect performance issues and improve the performance
    of our apps. A good example of this is the **baseline profiles**, which help improve
    app start-up time and make app interactions much smoother.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a lot of Jetpack libraries. You can explore all the available Jetpack
    libraries here: [https://developer.android.com/jetpack/androidx/explorer](https://developer.android.com/jetpack/androidx/explorer).
    The following are some of the benefits of using Jetpack libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: We can follow the best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can write less boilerplate code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We reduce fragmentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The APIs work well together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have already seen how to use a `ViewModel` class in this chapter. We will
    also be using other Jetpack libraries in the later chapters of this book.
  prefs: []
  type: TYPE_NORMAL
- en: We have looked at how the Jetpack Libraries fit in with the different layers
    of our architecture. In the next section, we are looking at an important topic
    in architecture, which is **dependency injection**.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependency injection is a way for us to manage and provide dependencies that
    a class needs to do its work without the class having to create the dependencies
    itself. In this book, we will be using Koin ([https://insert-koin.io/](https://insert-koin.io/))
    as our dependency injection library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `PetsViewModel` class creates the `PetsRepository` class by itself. This
    is a suitable candidate for dependency injection. We will be refactoring this
    to use dependency injection. Let’s start by adding the Koin dependency to our
    app. Open the `build.gradle` file for the app module and add the following dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We are adding the Koin `core`, `android,` and `compose` dependencies as well,
    which will be used in our project to provide the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding this to our project and syncing the project, we need to create
    Koin `PetsRepository` class. Create a new package named `di` inside the `com.packt.chapterfive`
    package. Inside this `di` package, create a new file named `Modules` and add the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code above, we are creating a new variable named `appModules`
    of the type module. We are using the `module` function from the Koin library to
    create a module. We are using the `single` function to create a single instance
    of the `PetsRepository` class. Koin has dependency injection scopes, such as `single`,
    `factory`, and `scoped`, that govern the lifecycle and visibility of dependency
    instances within the container. The `single` scope creates singleton instances
    that persist throughout the entire application, making it suitable for objects
    requiring a globally shared state, such as database instances. `Factory` scope
    generates new instances each time they are requested, fitting stateless utility
    classes or objects that don’t need to maintain a persistent state. The `scoped`
    scope ties instances to specific contexts, such as activity or fragment lifecycles,
    allowing them to be shared within a designated scope but recreated for different
    contexts. The `single` scope is particularly useful for managing global or long-lived
    dependencies efficiently, ensuring a single instance is shared consistently across
    various components of the application, thereby optimizing resource usage and maintaining
    a unified state. This is why we are using `single` to create an instance of our
    `PetsRepository` class. We are using the `PetsRepositoryImpl` class as the implementation
    of the `PetsRepository` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will refactor our `PetsViewModel` class to use dependency injection.
    Open the `PetsViewModel` class and update it as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have removed the instantiation of the `PetsRepository`
    class from the `PetsViewModel` class. We have, instead, added a `constructor`
    that takes a `PetsRepository` parameter. We also need to create a new dependency
    for `ViewModel`, just below the `PetsRepository` dependency in our `appModules`
    variable. Let us add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are creating a `single` instance of the `PetsViewModel` class. We
    are using the `get()` function to get the `PetsRepository` dependency. We are
    passing it to the constructor of the `PetsViewModel` class. With this, our app
    is ready to use these dependencies. We will also change the way we create the
    `PetsViewModel` instance in our `PetList` composable. Open the `PetList` composable
    and update the initialization of `PetsViewModel`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Instead of using the `ViewModel()` function from the lifecycle library, we are
    using the `koinViewModel()` function from the Koin library. This function helps
    us create an instance of the `PetsViewModel` class. This now returns an instance
    of `PetsViewModel` that has the `PetsRepository` dependency injected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step in ensuring our app has dependency injection setup is to initialize
    Koin in our app. We will create a class that extends the `Application` class and
    initialize Koin in the `onCreate()` method. Create a new file named `ChapterFiveApplication`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `ChapterFiveApplication` class extends the `Application` class. We are
    overriding the `onCreate()` method and calling the `startKoin()` function. We
    are using the `modules` parameter to pass in the `appModules` variable that we
    created earlier on. This initializes Koin in our app. We also need to update the
    `AndroidManifest.xml` file to use our `ChapterFiveApplication` class. Open the
    `AndroidManifest.xml` file and update the application tag with the name attribute,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We are passing the name of our `ChapterFiveApplication` class to the name attribute.
    Now, if you run the app, it still runs as before, but this time, it uses dependency
    injection.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand what dependency injection is and how to use it in our
    apps, let us look at **Kotlin Gradle DSL** and how we can use **version catalogs**
    to manage our dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating to Kotlin Gradle DSL and using version catalogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B19779_01.xhtml#_idTextAnchor015), one of the advantages of
    using Kotlin that we listed is that we can also write our Gradle files in Kotlin.
    In this section, we will look at how we can migrate our Gradle files to Kotlin
    Gradle DSL. We will also look at how we can use a version catalog to manage our
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we migrate, let’s see some of the benefits we get from using Kotlin
    Gradle DSL:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code autocompletion**: We get hints about the completion of our code in Gradle
    files as we are using Kotlin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type safety**: We get compile time errors when we make mistakes in our Gradle
    files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Function calls and variable assignments**: We can use functions and variables
    in our Gradle files the same way we use them in our Kotlin code. It makes it even
    easier for us to write and understand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compile time errors**: We get errors at compile time when we make mistakes
    in our Gradle files. This helps us avoid runtime errors when building our apps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Official Android Studio Support**: From Android Studio Giraffe onwards, Kotlin
    Gradle DSL is the recommended way of creating our Gradle files. It is also the
    default way of creating our Gradle files in Android Studio Giraffe onwards.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So many benefits, right? Let’s now migrate our app so as to use Kotlin Gradle
    DSL.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating our app to Kotlin Gradle DSL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If your apps already use Kotlin Gradle DSL, you can skip this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to migrate your app to Kotlin Gradle DSL:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have to rename all our Gradle files to have a **.kts** extension,
    which allows our IDE to recognize them as Kotlin Gradle files. Rename the **build.gradle(Project
    : chapterfive)**, **build.gradle(Module: app)**, and **settings.gradle** files
    to **build.gradle.kts(Project: chapterfive)**, **build.gradle.kts(Module: app)**,
    and **settings.gradle.kts**, respectively. This allows us to use Kotlin in our
    Gradle files now.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After renaming the files, we have to update their content to use Kotlin Gradle
    DSL. Let’s start with the **settings.gradle.kts** file. Open the **settings.gradle.kts**
    file and update it, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, update the **build.gradle.kts(Module: app)** file, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, update the **build.gradle.kts(Project: chapterfive)** file, as shown
    in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After updating the files, we have to sync the project. We can do this by clicking
    on the Sync prompt that appears in the top right corner of the IDE. After syncing
    the project, we can now run the app, and it should run as before. We have now
    successfully migrated our app to use Kotlin Gradle DSL. You can also see that
    the syntax highlighting and the colors of the functions, methods, and variables
    change to reflect the Kotlin syntax. Some key changes about this migration to
    highlight are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: To assign values to properties, we have to use the **=** operator specifically.
    For example, **minSdk 24** changes to **minSdk =** **24**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our **android** config block, **namespace 'com.packt.chapterfive'** changes
    to **namespace = "com.packt.chapterfive"**. In Kotlin, we define strings using
    double quotes; that’s why we have to change the single quotes to double quotes
    in all the places we have strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In defining our dependencies, we have to use double quotes too. For example,
    **implementation 'androidx.activity:activity-compose:1.7.2'** changes to **implementation("androidx.activity:activity-compose:1.7.2")**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, defining our plugins in the **plugins** block changes. For example,
    **id 'org.jetbrains.kotlin.android'** changes to **id("org.jetbrains.kotlin.android")**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our project had minimal Gradle configurations, so if you have a complex project,
    you might need to do more migration; you can have a look at the Migrate to Kotlin
    DSL official documentation ([https://developer.android.com/build/migrate-to-kotlin-dsl](https://developer.android.com/build/migrate-to-kotlin-dsl))
    for more examples.
  prefs: []
  type: TYPE_NORMAL
- en: We have now migrated our app to use Kotlin Gradle DSL. In the next subsection,
    let’s look at how we can use a **versions catalog** to manage our dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Using a versions catalog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Quoting from the official documentation ([https://docs.gradle.org/current/userguide/platforms.html](https://docs.gradle.org/current/userguide/platforms.html)),
    a version catalog is a list of dependencies, represented as dependency co-ordinates,
    that a user can pick from when declaring dependencies in a build script. It helps
    us easily manage our dependencies and their versions in one central place. Currently,
    you can see that we define all our dependencies and their versions in our app-level
    `build.gradle.kts` file. Over time, and as you add more modules to your app, it
    becomes hard to share these dependencies, and we can find ourselves in situations
    where different modules have different versions of a similar dependency. This
    is where version catalogs come in to help us. Let’s see all the benefits that
    they offer:'
  prefs: []
  type: TYPE_NORMAL
- en: They provide a central place to manage all our dependencies and their versions.
    They make it easier to share the dependencies across the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have a simple and easy-to-use syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They show hints for dependencies that need to be updated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They make it easier to make changes, and these changes do not recompile the
    whole project, meaning the builds are faster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can bundle dependencies together and share them across the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have official support and are recommended by Google to be used from Android
    Studio Giraffe going forward
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s now see how we can use a version catalog in our app. In the `gradle`
    folder, create a new file named `libs.versions.toml`. In this file, here are some
    basic rules that we will follow:'
  prefs: []
  type: TYPE_NORMAL
- en: We can use separators, such as -, _v, and . , that will be normalized by Gradle
    to “.” in the Catalog, allowing us to create subsections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We define variables using **CamelCase**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For libraries, we normally check if we can add them to any existing bundles.
    For new libraries that are normally used together, we can create a new bundle
    for them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will start by defining the versions for our dependencies as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are defining all the versions for the libraries that are in our app.
    We use the **versions** keyword to define the versions. We then define the versions
    for each library. As we edit this file, you will notice that the IDE prompts you
    to do a Gradle sync for our changes to be added to the project. For now, we can
    ignore this and continue editing the file. Next, we will define the bundles for
    our dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have defined all the dependencies in our project using the **libraries**
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s use the **bundles** keyword to create a bundle for Koin and compose
    dependencies as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `bundles` keyword allows us to group dependencies and use them as one.
    Now, we can sync the project. The last step is to update our app-level `build.gradle.kts`
    file to use the version catalog. Open the app-level `build.gradle.kts` file and
    update the dependencies block as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We can now access the dependencies from our versions catalog file. Notice we
    must start with the **libs** keyword, and the next part is the names of the bundles
    or the dependencies, as per our version catalog. After adding these changes, we
    can now do Gradle sync. Build and run the app. The app displays a list of pets,
    as before, and nothing changes since we were only refactoring the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have built on what we learned from the previous chapters.
    We looked at the different architectures available for Android projects. We dived
    deep into MVVM architecture and its different layers and how to use some of the
    Jetpack libraries in this architecture. Additionally, we learned how to use advanced
    architecture features such as dependency injection and Kotlin Gradle DSL, as well
    as using Gradle version catalogs to define our dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: As we were creating the MVVM architecture, we used dummy pet data for our data
    layer. In the next chapter, we are going to learn how to make network calls to
    fetch data and display it in our app.
  prefs: []
  type: TYPE_NORMAL
