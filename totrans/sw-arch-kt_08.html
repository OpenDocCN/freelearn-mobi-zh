<html><head></head><body><div><div><div><h1 id="_idParaDest-195" class="chapter-number"><a id="_idTextAnchor289"/>8</h1>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor290"/>Domain-Driven Design (DDD)</h1>
			<p>Engineers are often not the experts in business domains. Yet, they’re responsible for building complex applications that represent real-world domains. Traditionally, software architectures often struggle to express the intricacies and subtlety of business domains effectively, leading to systems that are challenging to understand, maintain, and evolve. This is where <strong class="bold">domain-driven design</strong> (<strong class="bold">DDD</strong>) is <a id="_idIndexMarker665"/>brought into play.</p>
			<p>In <a href="B21737_07.xhtml#_idTextAnchor255"><em class="italic">Chapter 7</em></a>, we covered three architectural styles around the concept of having a dedicated layer to host business logic within an application. DDD aims to help engineers identify business behaviors that belong to the corresponding domain and the boundaries around it so that they can be implemented in the Core, Domain, or Use Case layer of an application.</p>
			<p>This chapter explores the powerful software design approach of DDD, which centers around the business domain in the software design process. It focuses on capturing and expressing the core business concepts, rules, and behaviors.</p>
			<p>First, we’ll dive deep into the theoretical principles and practical implementation strategies of DDD, illustrated by real-life examples. Then, we’ll explore how this approach can be used to build maintainable, scalable, and flexible software systems that align closely with business requirements.</p>
			<p>By applying DDD, we can gain a better understanding of the domain and create a common language between domain experts and software developers.</p>
			<p>We’re going to cover the following topics in this chapter:</p>
			<ul>
				<li>Fundamentals of DDD</li>
				<li>Strategic and tactical designs in DDD</li>
				<li>Modeling activities in DDD</li>
			</ul>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor291"/>Technical requirements</h1>
			<p>You can find the code files used in this chapter on GitHub: <a href="https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-8%0D">https://github.com/Packt
Publishing/Software-Architecture-with-Kotlin/tree/main/chapter-8</a></p>
			<h1 id="_idParaDest-198"><a id="_idTextAnchor292"/>Fundamentals of DDD</h1>
			<p>The goal of DDD is to close<a id="_idIndexMarker666"/> the gap between the technical implementation of software and the business domain it serves. DDD heavily focuses on building software that accurately models the core concepts, business rules, and behaviors of the domain so that the software system is closely aligned with the needs of the business. This results in it being valuable, maintainable, flexible, and sustainable for the future.</p>
			<p>DDD highlights the distinction between the problem space and the solution space:</p>
			<ul>
				<li><strong class="bold">Problem space</strong>: The problem space is the reality of the business – that is, the current circumstances of the business operations</li>
				<li><strong class="bold">Solution space</strong>: The solution space is the software system we have or will build to solve specific business cases in the problem space</li>
			</ul>
			<p>The dominant part of the problem space is the <strong class="bold">domain</strong>, which represents specific business use cases and operations. The solution space provides a way to model the domain to solve the given business cases, hence the name <strong class="bold">domain model</strong>. This relationship is illustrated in <em class="italic">Figure 8</em><em class="italic">.1</em>:</p>
			<div><div><img src="img/B21737_08_1.jpg" alt="Figure 8.1 – Problem space and solution space" width="916" height="517"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Problem space and solution space</p>
			<p>A domain model abstracts and selects certain elements in the domain so that a software system can be built upon it. The abstraction and selection result in the domain model is never 100% correct and complete. It is exactly what statistician <em class="italic">George Box</em> wrote in 1976 in a paper published in the <em class="italic">Journal of the American </em><em class="italic">Statistical Association</em>:</p>
			<p>“<em class="italic">All models are wrong, but some </em><em class="italic">are useful.</em>”</p>
			<p>In DDD, domain models don’t aim to be complete and accurate; instead, they aim to be useful in specific business contexts.</p>
			<p>DDD encourages engineers to gain a deep understanding of the domain for which they’re building <a id="_idIndexMarker667"/>software. There are domain experts who understand what software they need to get the job done. This is particularly true for the domains that originally used manual processes or paperwork to operate the business. Software systems are often seen as automation tools for business operations. Having a domain expert who operates the business brings a lot of value to engineers in building the corresponding software.</p>
			<p>DDD comprises two design methodologies:</p>
			<ul>
				<li><strong class="bold">Strategic design</strong>: This focuses<a id="_idIndexMarker668"/> on the overall structure and organization among multiple cohesive areas, named bounded contexts, within a larger business domain. It works toward a flexible and loose coupling system among bounded contexts by defining their collaborations.</li>
				<li><strong class="bold">Tactical design</strong>: This refers to patterns, tools, and practices that make it simpler to build helpful domain models. We use tactical design when we have complex business logic <a id="_idIndexMarker669"/>to model or when complexity may be introduced in the future.</li>
			</ul>
			<p>It’s important to point out that DDD has nothing to do with what technology and frameworks are <a id="_idIndexMarker670"/>chosen. Modeling a business domain is purely the way a software system should be built, not which tools are used.</p>
			<h1 id="_idParaDest-199"><a id="_idTextAnchor293"/>DDD – strategic design</h1>
			<p>It’s recommended to<a id="_idIndexMarker671"/> start DDD with strategic design to establish the big picture before drilling down into the more granular tactical design. The very first step is known as <strong class="bold">ubiquitous language</strong>.</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor294"/>Ubiquitous language</h2>
			<p>Using a common language <a id="_idIndexMarker672"/>between<a id="_idIndexMarker673"/> engineers and domain experts is crucial to the success of software systems. Business domains often involve a lot of industry terms, specialized concepts, and subtle rules. However, not all of them can be applied to the scope of a software system. On the other hand, engineering involves a lot of technical terms, methodologies, and best practices, all of which are needed for the given software system.</p>
			<p><strong class="bold">Ubiquitous language</strong> is a term that was introduced by <em class="italic">Eric Evans</em> in his book <em class="italic">Domain-Driven Design: Tackling Complexity in the Heart of Software</em>, published in 2004. It serves as a common understanding and mental model of the domain that’s shared between engineers and domain experts. It aims for a consistent, well-defined, and precise language to eliminate misunderstandings and ambiguities. It’s a continuous, collaborative effort to build a common ground for effective and meaningful communication. Ubiquitous language is the common tongue between the domain and the domain model.</p>
			<p>Ubiquitous language is also a form of documentation and the knowledge base of systems. Once established, new team members can understand the domain and the existing code base quickly. It also facilitates knowledge transfer among teams and stakeholders, thus promoting better collaboration and reducing the risk of information loss.</p>
			<p>Ubiquitous language is the overlapping part between domain expert language and engineering <a id="_idIndexMarker674"/>language and <a id="_idIndexMarker675"/>implies a mutual understanding, as shown in <em class="italic">Figure 8</em><em class="italic">.2</em>:</p>
			<div><div><img src="img/B21737_08_2.jpg" alt="Figure 8.2 – Ubiquitous language in DDD" width="768" height="797"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Ubiquitous language in DDD</p>
			<p>The benefits of ubiquitous <a id="_idIndexMarker676"/>language manifest themselves in various forms:</p>
			<ul>
				<li><strong class="bold">Glossary</strong>: A glossary of terms and concepts and their definitions, available for everyone to read and learn about the business domain. Each term is reviewed and agreed upon by everyone involved in the development process. Ideally, there should be a process where changes can be submitted, reviewed, approved, and tracked in an auditable repository<a id="_idIndexMarker677"/> such as <strong class="bold">GitHub</strong>.</li>
				<li><strong class="bold">Documentation</strong>: All documents related to the business domain should use the same terms and concepts that are defined in the glossary. These documents include user manuals, operation instructions, project plans, architectural design documents, diagrams, user stories, screen mockups, presentations, API documentation, and more. Any new term and concept should be added to the glossary.</li>
				<li><strong class="bold">Private large language modules (LLMs)</strong>: The business domain knowledge, including terms, concepts, rules, and processes, can be used to train an LLM so that it can answer questions, complete text, generate dialog, and even become a part of the customer service bot. It does, however, require carefully crafting the input that’s given to the model to generate the desired outputs or responses. This process is <a id="_idIndexMarker678"/>called <strong class="bold">prompt engineering</strong>, but it’s beyond the scope of this book. OpenAI’s documentation has a section on prompt engineering that provides practical guidance: https://platform.openai.com/docs/guides/prompt-engineering.</li>
				<li><strong class="bold">Source code</strong>: The names of source files, functions, interfaces, classes, and even variables should use the same terms that have been defined in the glossary. Message payloads, database tables and fields, log messages, and error messages should also use these terms and concepts whenever applicable. These terms are used in every element in the code base. Seeing the same language everywhere related to<a id="_idIndexMarker679"/> the business domain for a software system is what we define as <a id="_idIndexMarker680"/>ubiquitous language.</li>
			</ul>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor295"/>Subdomains</h2>
			<p>A <strong class="bold">subdomain</strong> is a distinct <a id="_idIndexMarker681"/>area<a id="_idIndexMarker682"/> of the business domain that has its own set of concepts and business rules. The language that’s used in a subdomain is part of ubiquitous language, and the corresponding concepts within the subdomain naturally form their own group.</p>
			<p>Subdomains help break down the complexity of large domains into smaller, more manageable parts, allowing teams to focus on understanding and addressing the unique requirements and challenges of each subdomain. Subdomains belong to the problem space, and they may not alway<a id="_idIndexMarker683"/>s have a one-to-one mapping with a part of the system in the solution space.</p>
			<p>Subdomains can be categorized into three groups:</p>
			<ul>
				<li><strong class="bold">Core domains</strong>: Core domains<a id="_idIndexMarker684"/> are at the heart of business operations. Without them, there’s no problem to solve, and there’s no reason to build software systems. Core subdomains are the most critical part of an organization to differentiate them from competitors. They also have the most complex business cases.</li>
				<li><strong class="bold">Supporting subdomains</strong>: Supporting subdomains provide peripheral tools and functionalities that complement and accelerate the core subdomains, but they aren’t the primary area of expertise for the business. They’re typically well-known capabilities where corresponding solutions can be found in the market or outsourced. They’re still relevant to the business but don’t provide significant competitive advantages.</li>
				<li><strong class="bold">Generic subdomains</strong>: Generic subdomains refer to common problems that aren’t specific to the business. Their corresponding solutions are off-the-shelf commercial products. They’re essential for running business operations, but they don’t directly contribute to the core value proposition of the business.</li>
			</ul>
			<p>By identifying and modeling subdomains, DDD enables the development of cohesive, modular, and loosely<a id="_idIndexMarker685"/> coupled software systems. This leads us to an important concept in the solution space known as bounded contexts.</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor296"/>Bounded contexts</h2>
			<p>In <a href="B21737_06.xhtml#_idTextAnchor212"><em class="italic">Chapter 6</em></a>, we <a id="_idIndexMarker686"/>mentioned<a id="_idIndexMarker687"/> the importance of identifying highly cohesive functions and grouping them as individual deployable artifacts so that we don’t end up building a large monolithic application that’s expensive to maintain, difficult to understand, and almost impossible to optimize. The system can be broken down into bounded contexts.</p>
			<p>A <strong class="bold">bounded context</strong> is a<a id="_idIndexMarker688"/> concept in the solution space. It represents a cohesive area of the business domain. It has its own scope, responsibilities, and rules that don’t overlap with other bounded contexts. A bounded context should have a clear purpose and a clear boundary. A well-defined bounded context gives a straightforward answer to whether a term or a rule belongs to the within or outside of the context. Within a bounded context, each building block has a specific semantic and purpose.</p>
			<p>It takes away some parts of the complex business domain and turns them into a smaller and more manageable unit. Eventually, the sum of a sufficient collection of bound contexts is the overall domain model and thus eliminates the chance of it becoming a monolithic application.</p>
			<p>A bounded context should represent one subdomain only, but a subdomain model might need a small portion of another subdomain model to function properly.</p>
			<p>Also, a bounded context should have its own source code repository. It has its own data schema and data that are only shared with other bounded contexts via external representations defined in API documentation. It should also have dedicated deployable artifacts. They can be released independently without dependency on or affecting other bounded contexts. They should have their own release cadence.</p>
			<p>A bounded context should be owned by one team only. The team has full autonomy in the choice of frameworks and development methodologies. In <a href="B21737_01.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a>, we mentioned <strong class="bold">Conway’s law</strong>, which <a id="_idIndexMarker689"/>states that an organization often produces software systems that mirror the internal structures of the organization. Instead of being constrained by the organization structure, teams should be re-structured based on the bounded contexts<a id="_idIndexMarker690"/> that <a id="_idIndexMarker691"/>are discovered during the DDD process.</p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor297"/>Context mapping</h2>
			<p>Because bounded contexts <a id="_idIndexMarker692"/>break<a id="_idIndexMarker693"/> down a system, they need to collaborate for the system to function and achieve the overall goals. <strong class="bold">Context mapping</strong> is a technique that can be used to identify the relationships and interactions among bounded contexts.</p>
			<p>Here are the common patterns in this relationship:</p>
			<ul>
				<li><strong class="bold">Partnership</strong>: Two or more bounded contexts establish a collaborative relationship. This involves establishing close collaboration, shared understanding, and joint decision-making to address a specific business need. Even bounded contexts have their own goals, but their goals are connected to help solve a particular problem. So, they succeed and fail together:</li>
			</ul>
			<div><div><img src="img/B21737_08_3.jpg" alt="Figure 8.3 – Partnership" width="656" height="428"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Partnership</p>
			<ul>
				<li><strong class="bold">Shared kernel</strong>: Two bounded contexts share a subset of their model or code. They might share the same data schema, a source code module, or compiled code as an artifact. However, it’s <a id="_idIndexMarker694"/>considered an anti-pattern to share a data schema or raw source code between two bounded contexts. However, it’s acceptable for two bounded contexts to depend on the same artifact that’s treated as a shared library:</li>
			</ul>
			<div><div><img src="img/B21737_08_4.jpg" alt="Figure 8.4 – Shared kernel" width="383" height="654"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – Shared kernel</p>
			<ul>
				<li><strong class="bold">Customer-supplier</strong>: The upstream bounded context supplies data, while the downstream bounded context consumes that data. The customer and the supplier collaborate and agree on the protocol of the data:</li>
			</ul>
			<div><div><img src="img/B21737_08_5.jpg" alt="Figure 8.5 – Customer-supplier" width="709" height="418"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – Customer-supplier</p>
			<ul>
				<li><strong class="bold">Conformist</strong>: The<a id="_idIndexMarker695"/> upstream bounded context supplies data and dictates the protocol of the data. The downstream bounded context conforms to the protocol and consumes that data. The upstream bounded context can be an external system <a id="_idIndexMarker696"/>or use an industry-standard protocol, making it unable to accommodate the downstream bounded context:</li>
			</ul>
			<div><div><img src="img/B21737_08_6.jpg" alt="Figure 8.6 – Conformist" width="1023" height="454"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – Conformist</p>
			<ul>
				<li><strong class="bold">Anti-corruption layer</strong>: The upstream bounded context supplies data and dominates the protocol of the data. The downstream bounded context, however, isn’t willing to conform to the protocol. Instead, the downstream bounded context builds an anti-corruption layer to consume the data and translate it into the structure that it desires:</li>
			</ul>
			<div><div><img src="img/B21737_08_7.jpg" alt="Figure 8.7 – Anti-corruption layer" width="920" height="461"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 – Anti-corruption layer</p>
			<p class="list-inset">There are <a id="_idIndexMarker697"/>several<a id="_idIndexMarker698"/> scenarios where the downstream bounded context decides not to conform:</p>
			<ul>
				<li>The upstream bounded context uses an inconvenient data protocol, making it difficult to integrate and consume the data</li>
				<li>The upstream bounded context is unreliable, changes often, or occasionally brings breaking changes that the downstream bounded context intends to minimize so that the impact of any issue brought by the upstream bounded context is diminished</li>
				<li>The data protocol used in the upstream bounded context brings conflicting or irrelevant data to the downstream bounded context</li>
				<li>The downstream bounded context reflects the core domain, which warrants reasons not to depend on a foreign data protocol</li>
			</ul>
			<ul>
				<li><strong class="bold">Separate ways</strong>: There are no interactions between bounded contexts as they’ve decided to go separate ways. This can be due to integration being too expensive, unsustainable, or impossible. The following are some example scenarios where this has occurred:<ul><li>The teams for each bounded context have a tough time collaborating and agreeing. This can be due to legacy systems being involved or just organizational politics. Instead of dragging on the long negotiation process, the bounded context finds it easier and quicker to replicate the logic in its own spaces.</li><li>The models between bounded contexts are too different for the conformist pattern to be used or too expensive for the anti-corruption layer pattern to be used compared to implementing tailored logic in its own bounded context. The upstream bounded context may only supply part of the data required by the downstream bounded context, while the downstream bounded context can replicate a part of the logic but create a complete model that’s suitable for its specific purpose.</li><li>Often, it’s in the <a id="_idIndexMarker699"/>generic subdomain where collaboration has little value compared to replicating the logic in the respective bounded contexts. It could be that <a id="_idIndexMarker700"/>certain libraries are used to generate data, hence why the cost of integration isn’t justified.</li></ul></li>
				<li><strong class="bold">Open-host service</strong>: A bounded context defines and exposes a public API that other bounded contexts can use to extend its functionality. The public API is intentionally decoupled from the internal model so that both can be evolved independently. The internal model of the bounded context also remains private:</li>
			</ul>
			<div><div><img src="img/B21737_08_8.jpg" alt="Figure 8.8 – Open-host service" width="905" height="457"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.8 – Open-host service</p>
			<ul>
				<li><strong class="bold">Published language</strong>: The published language focuses on establishing a shared language and glossary among bounded contexts. The published language doesn’t intend to<a id="_idIndexMarker701"/> conform to its ubiquitous language, though there’s no need to re-invent vocabulary if an appropriate term already exists in ubiquitous language.<p class="list-inset">Published language intends to expose a protocol that’s convenient for consuming bounded contexts. It’s expressed in an integration-oriented language that’s usually not related to any programming language. Also, each bounded context should be able to translate between published language and corresponding internal models.</p><p class="list-inset">Published language ensures a consistent understanding of domain concepts and facilitates communication among bounded contexts.</p><p class="list-inset">Published language <a id="_idIndexMarker702"/>can be defined in many well-known<a id="_idIndexMarker703"/> formats, such as <strong class="bold">OpenAPI</strong>, <strong class="bold">Avro</strong>, <strong class="bold">Protobuf</strong>, fixed-length <a id="_idIndexMarker704"/>values, and<a id="_idIndexMarker705"/> comma-separated <a id="_idIndexMarker706"/>values.</p></li>
			</ul>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor298"/>Applying strategic design to a real-life example</h2>
			<p>So far, we’ve<a id="_idIndexMarker707"/> outlined the techniques and methods that are used in strategic design in DDD. Now, we’re going to apply them to the same real-life example we’ve been using throughout this book.</p>
			<h3>Step 1 – synopsis of the business problem</h3>
			<p>Let’s revisit the real-life example <a id="_idIndexMarker708"/>of households exchanging services. The team managed to find a senior lady who started to exchange services in the village. The team interviewed her, and their notes were captured. Here’s the synopsis that was validated and clarified with her as the domain expert:</p>
			<p class="author-quote">“We’re a tight-knit community where villagers frequently exchange services to support each other. The village consists of various households, each with its unique skills, talents, and needs. The households recognized that by offering their services, they could help one another and create a stronger community.</p>
			<p class="author-quote">In this village, there were households specializing in different areas, such as carpentry, farming, cooking, and childcare. For instance, Mr. Whittington was a skilled carpenter who built and repaired furniture. When Mrs. Barker needed a new dining table, she approached Mr. Whittington to request his services.</p>
			<p class="author-quote">In return for Mr. Whittington’s carpentry work, Mrs. Barker offered fresh produce from her farm to Mr. Carpenter’s household throughout the year.</p>
			<p class="author-quote">Mrs. Barker drafted a contract to capture the details of the exchange, such as materials and dimensions of the table, what and how much fresh produce to provide, and a timeline. Mr. Whittington reviewed the contract and made a few adjustments. In the end, both Mr. Whittington and Mrs. Barker signed the contract.</p>
			<p class="author-quote">This arrangement helped Mr. Whittington and his family have a steady supply of nutritious food while allowing Mrs. Barker to enjoy beautifully crafted furniture in her home.</p>
			<p class="author-quote">These exchanges created the fabric of the village’s social and economic ecosystem. They fostered trust, cooperation, and mutual support among households, creating a harmonious and resilient community.”</p>
			<p>Through this interview, the team captured the essence of the household service exchanges in the village. The team now understands the motivations, interactions, and benefits involved in the process.</p>
			<h3>Step 2 – ubiquitous language</h3>
			<p>At this point, the domain expert and the team can start to develop a shared understanding of the domain by identifying the following concepts mentioned in domain storytelling:</p>
			<ul>
				<li><strong class="bold">Household</strong>: A group of villagers who live together in the same place of residence.</li>
				<li><strong class="bold">Services</strong>: The skills that a household specializes in and can be offered to another household.</li>
				<li><strong class="bold">Contract</strong>: An agreement of the details of the services that have been exchanged between two households.</li>
				<li><strong class="bold">Draft contract</strong>: A contract initiated by a household for another household to review.</li>
				<li><strong class="bold">Agreed contract</strong>: A contract has its details mutually agreed upon and signed by the two households involved. An agreed contract is ready to be exercised.</li>
				<li><strong class="bold">Exercised contract</strong>: A contract in which services performed by both households are completed, as per the details of each service.</li>
			</ul>
			<p>This is the basis<a id="_idIndexMarker709"/> of the <strong class="bold">ubiquitous language</strong> in the form of a <strong class="bold">glossary</strong>. It’s developed by both the domain expert and the team.</p>
			<h3>Step 3 – subdomains</h3>
			<p>Identifying subdomains is the next step of the DDD process. With the help of the glossary, the team has identified <strong class="bold">Contract</strong> as the core domain and <strong class="bold">Household</strong> as a supporting subdomain.</p>
			<ul>
				<li><strong class="bold">Contract</strong> is the core domain as it’s the heart of the business domain. Without it, there’s no need to build a system. Household is an essential supporting subdomain so that the households involved in each contract can be identified.</li>
				<li><strong class="bold">Household</strong> itself can’t be a core domain because it’s technically possible to solve the business problem with a Household subdomain. If households are merely names in each contract without capabilities to verify and identify them, there could be a cutdown version of the system that has no Household subdomain.</li>
			</ul>
			<p>The team also recognized the need to notify households at several stages of a contract, such as when a contract is mutually agreed upon and ready to be exercised. Here, <strong class="bold">notification</strong> is also identified as a generic subdomain.</p>
			<p>The core domain and the <a id="_idIndexMarker710"/>subdomains that have been identified are illustrated in <em class="italic">Figure 8</em><em class="italic">.9</em>:</p>
			<div><div><img src="img/B21737_08_9.jpg" alt="Figure 8.9 – Core domain and subdomains" width="1270" height="861"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.9 – Core domain and subdomains</p>
			<h3>Step 4 – bounded contexts</h3>
			<p>With the core domain and subdomains defined in the problem space, it’s time to identify bounded contexts in the solution space. As mentioned previously, bounded contexts are defined by their scopes, responsibilities, and purposes.</p>
			<p>The team understands that Contract is the core domain, and there are two workflows with contracts. The first one starts from a contract drafted until agreed. The second one starts from agreed until exercised. The team also understands that the only connecting point of these two workflows is an agreed contract.</p>
			<p>There are team members who suggest one bounded context for the whole Contract core domain. There are also others suggesting one bounded context for the first journey and another one for the second.</p>
			<p>The team decides that the first journey of a contract from drafted to exercised is a bounded context and names it <strong class="bold">Contract Service</strong>. This bounded context maintains the workflow of contract from drafted to agreed, and then to exercised. However, a contract must involve two different households and services provided by each household. As a<a id="_idIndexMarker711"/> result, <strong class="bold">Contract Service</strong> covers the major portion of the Contract domain and a small portion of the Household subdomain to validate a contract.</p>
			<p>The supporting subdomain, Household, also needs a bounded context to support the classic <strong class="bold">Create, Read, Update, and Delete</strong> (<strong class="bold">CRUD</strong>) operations of households. The corresponding<a id="_idIndexMarker712"/> bounded context is named <strong class="bold">Household Service</strong>.</p>
			<p>The solution intends to notify households involved in a contract when it’s upon agreed or exercised. This generic subdomain, Notification, is covered by a bounded context named <strong class="bold">Notification Service</strong>.</p>
			<p><em class="italic">Figure 8</em><em class="italic">.10</em> demonstrates how the bounded contexts overlay the core domain and subdomains:</p>
			<div><div><img src="img/B21737_08_10.jpg" alt="Figure 8.10 – Bounded contexts, core domain, and subdomains" width="1301" height="863"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.10 – Bounded contexts, core domain, and subdomains</p>
			<p><strong class="bold">Household Service</strong> is the only bounded context that’s dedicated to its subdomain. Other bounded contexts <a id="_idIndexMarker713"/>have a major subdomain or core domain while also covering small portions of other subdomains so that they can function.</p>
			<h3>Step 5 – context mapping</h3>
			<p>The relationships among bounded contexts need to be defined via context mapping.</p>
			<p><strong class="bold">Household Service</strong> has no upstream dependencies, but <strong class="bold">Contract Service</strong> needs to receive household information to carry out their operations.</p>
			<p>A household under Household Service contains information such as the household’s name, contact email address, list of member names, residential address, and more. <strong class="bold">Contract Service</strong> only cares about the household name to validate a contract and the contact email address to be able to request a notification to be sent to a given household.</p>
			<p>Since <strong class="bold">Contract Service</strong> represents the core domain, it’s beneficial to avoid bringing in elements from other bounded contexts using an anti-corruption layer when communicating with <strong class="bold">Household Service</strong>.</p>
			<p><strong class="bold">Notification Service</strong>, as a generic bounded context, only needs to receive notification requests from a household and integrate with an email service provider to achieve its goal. It has a small portion of concepts that are supported by <strong class="bold">Household Service</strong> and <strong class="bold">Contract Service</strong>, but they dissolve into an email address, a title, and a body text. This is a customer-supplier relationship where <strong class="bold">Notification Service</strong> is the customer and other bounded contexts are suppliers.</p>
			<p>The overall <strong class="bold">context map</strong> is <a id="_idIndexMarker714"/>shown <a id="_idIndexMarker715"/>in <em class="italic">Figure 8</em><em class="italic">.11</em>:</p>
			<div><div><img src="img/B21737_08_11.jpg" alt="Figure 8.11 – Context mapping" width="1269" height="863"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.11 – Context mapping</p>
			<p>The team and the domain expert have established ubiquitous language with a glossary as the output. They’ve also identified the core domain and subdomains. Finally, they’ve identified bounded contexts and the mapping among them.</p>
			<p>The team now has a big picture of the whole household exchange service business model with strategic design in DDD. From now on, the team can focus on each of the bounded Contexts <a id="_idIndexMarker716"/>and their internal models.</p>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor299"/>DDD – tactical design</h1>
			<p>Tactical design focuses <a id="_idIndexMarker717"/>on the internal model and relationships within a bounded context. It aims to create a highly cohesive domain model that expresses the essential business concepts and aligns with the ubiquitous language that’s used within the context.</p>
			<p>Tactical design consists of several building blocks that provide a foundation for designing and building a bounded context within complex business domains:</p>
			<ul>
				<li><code>Address</code> class is a value object as it has no identity but encapsulates multiple fields that form an address:<pre class="source-code">
data class Address(
    val line1: String,
    val line2: String? = null,
    val line3: String? = null,
    val postalCode: String,
    val city: String,
    val country: String
)</pre></li>				<li><code>Household</code> class is an entity that’s been identified by <code>name</code>:<pre class="source-code">
data class Household(
    val name: String,
    val emailAddress: String
)</pre></li>				<li><code>Party</code> class is an aggregate because it contains the <code>Household</code> entity class:</p><pre class="source-code">
data class Party(
    val household: Household,
    val serviceProvided: String,
    val agreedAt: Instant? = null,
    val completedAt: Instant? = null,
)</pre><p class="list-inset">The <code>Contract</code> class is an aggregate root as it’s a top-level entrance to other aggregates, such as <code>Party</code>, and other entities, such as <code>Household</code>:</p><pre class="source-code">data class Contract(
    val partyA: Party,
    val partyB: Party,
    val contractState: ContractState,
)</pre><p class="list-inset">The entry point to read<a id="_idIndexMarker719"/> and modify the state of an aggregate is called an <strong class="bold">aggregate root</strong>. Aggregates take part in maintaining the integrity of the domain model and ensuring all related entities are linked together sensibly.</p></li>				<li><strong class="bold">Domain services</strong>: Domain services encapsulate domain behaviors that aren’t tied to a specific entity or value object. They enforce collaboration among multiple objects. Domain services help maintain the cohesion and integrity of the domain model.</li>
				<li><strong class="bold">Repositories</strong>: A repository stores and retrieves domain objects. It defines the possible storage and retrieval options for domain objects but abstracts away the actual storage implementation. A repository can be persistent, similar to databases or files. It can also be transient, similar to an in-memory cache. Persistence, availability, isolation levels, and underlying storage methods are the only implementation details. In other words, the <strong class="bold">domain service</strong> doesn’t need to make technology choices for data storage.</li>
				<li><strong class="bold">Domain events</strong>: Domain events represent things that have happened within a bounded context. They’re all named in the past tense and are immutable.</li>
			</ul>
			<p>Putting these building blocks <a id="_idIndexMarker720"/>together, the scope of tactical design in DDD can be illustrated like so:</p>
			<div><div><img src="img/B21737_08_12.jpg" alt="Figure 8.12 – Tactical design in DDD" width="1461" height="1148"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.12 – Tactical design in DDD</p>
			<p>Here, <strong class="bold">Bounded Context</strong> is the core of the application. Then, we have <strong class="bold">Core</strong>, which is the same concept that we covered in <a href="B21737_07.xhtml#_idTextAnchor255"><em class="italic">Chapter 7</em></a> when we talked about layered architectures – it’s a pure business concern area free of technology choices. This is also where all elements of tactical design are located.</p>
			<p>The application transforms an external request into an internal request that <strong class="bold">Domain Service</strong> handles. The request is validated and handled by a set of business rules that are in <strong class="bold">Domain Service</strong> or the corresponding <strong class="bold">Aggregate</strong>. Then, <strong class="bold">Domain Service</strong> accesses <strong class="bold">Aggregate</strong> from the root <strong class="bold">Entity</strong> to access the underlying entities and other value objects. After, <strong class="bold">Domain Service</strong> uses <strong class="bold">Repository</strong> to persist and retrieve entities as part of the handling process.</p>
			<p>Finally, <strong class="bold">Domain Service</strong> returns a response to the originator of the request. The application transforms the internal response into an external response. Meanwhile, domain events <a id="_idIndexMarker721"/>are produced due to request handling. These events are picked up by the application, transformed into external events, and published.</p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor300"/>Applying tactical design to a real-life example</h2>
			<p>Previously, the team<a id="_idIndexMarker722"/> defined three bounded contexts during strategic design for the real-life example of households exchanging services. Here, the team will pick one bounded context and go through the tactical design exercise.</p>
			<h3>Step 1 – identify aggregates, entities, and value objects</h3>
			<p>The bounded context that’s <a id="_idIndexMarker723"/>been chosen here is <strong class="bold">Contract Service</strong>, which represents the core domain of <strong class="bold">Contract</strong>. The goal of this bounded context is to maintain the life cycle of a contract from when it was first drafted to when it’s mutually exercised. The team has identified an aggregate with the following structure:</p>
			<pre class="source-code">
data class Contract(
    val partyA: Party,
    val partyB: Party,
    val contractState: ContractState,
)
data class Party(
    val household: Household,
    val serviceProvided: String,
    val agreedAt: Instant? = null,
    val completedAt: Instant? = null,
)
enum class ContractState {
    DRAFTED,
    UNDER_REVIEW,
    AGREED,
    REJECTED,
    PARTIALLY_EXERCISED,
    FULLY_EXERCISED,
    WITHDRAWN,
}
data class Household(
    val name: String,
    val emailAddress: String
)</pre>			<p>The <strong class="bold">Contract</strong> aggregate starts with the root <strong class="bold">Contract</strong> entity. The <strong class="bold">Contract</strong> entity is identified by an ID. The Contract entity contains two value objects of the same type: <strong class="bold">Party</strong>. The <strong class="bold">Party</strong> value object <a id="_idIndexMarker724"/>only holds the necessary fields to represent a party of a contract. The <strong class="bold">Party</strong> value object holds a <strong class="bold">Household</strong> entity.</p>
			<p>The <strong class="bold">Household</strong> entity is local to <strong class="bold">Contract Service</strong> as it only contains a name and email address that are relevant to the bounded context. Here, <strong class="bold">Household Service</strong> supplies a full <strong class="bold">Household</strong> entity from the bounded context of <strong class="bold">Household Service</strong>. The foreign entity contains other fields such as residential address; these are ignored when the anti-corruption layer in <strong class="bold">Contract Service</strong> transforms the foreign entity into the local <strong class="bold">Household</strong> entity.</p>
			<p>As a result, the local <strong class="bold">Household</strong> entity only contains a name and a contact email address. The local <strong class="bold">Household</strong> entity is identified by its name.</p>
			<h3>Step 2 – identify domain services, repositories, and domain events</h3>
			<p>Having defined the aggregate with the root, entities, and value objects underneath it, the team can identify the operations required by the bounded context to achieve its goal.</p>
			<p>There are three major operations in this bounded context:</p>
			<ul>
				<li>A contract is drafted by a household</li>
				<li>A contract is agreed upon by all households involved</li>
				<li>A contract is exercised by all households involved</li>
			</ul>
			<p>The corresponding timestamp should be set on the contract when these operations take place. The service should also notify the downstream bounded context using events.</p>
			<p><strong class="bold">Contract Service</strong> validates incoming requests such as whether the contract and the household exist, and whether the contract should change. If everything goes well, a timestamp is set against the corresponding service in the contract. If a contract has been drafted, agreed <a id="_idIndexMarker725"/>upon, or exercised, a corresponding domain event is published.</p>
			<p>To support this operation, <strong class="bold">Contract Service</strong> needs to know both households. They are supplied by domain events published by upstream bounded contexts.</p>
			<p>This bounded context consumes <strong class="bold">Household Updated Event</strong> published by <strong class="bold">Household Service</strong>. The <strong class="bold">Household</strong> entity is converted from this event and is stored in <strong class="bold">Household Repository</strong>.</p>
			<p>The <strong class="bold">Household</strong> entity local to <strong class="bold">Contract Service</strong> is a trimmed down of the original <strong class="bold">Household</strong> entity in <strong class="bold">Household Service</strong>. <strong class="bold">Contract Service</strong> should only take the fields from <strong class="bold">Household</strong> that are relevant to the operations within its bounded context. Meanwhile, <strong class="bold">Household Service</strong> contains the full set of fields of <strong class="bold">Household</strong> relevant to the whole business domain.</p>
			<p>These repositories serve as local caches, so <strong class="bold">Contract Service</strong> remains if other bounded contexts are unavailable.</p>
			<p>The inside of the bounded context can be seen in <em class="italic">Figure 8</em><em class="italic">.13</em>:</p>
			<div><div><img src="img/B21737_08_13.jpg" alt="Figure 8.13 – Inside the bounded context – Contract Service" width="1288" height="930"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.13 – Inside the bounded context – Contract Service</p>
			<p>The domain expert and the team have run through both strategic and tactical designs for the real-life example. They’ve<a id="_idIndexMarker726"/> covered ubiquitous language, subdomains, bounded contexts, context mapping, aggregates, entities, value objects, domain services, domain events, and repositories. Through these exercises, the domain expert and the team have established a shared understanding of the business problems, and they now have a useful model that they can use as a foundation for building a software system.</p>
			<p>There are a few<a id="_idIndexMarker727"/> formats of DDD workshops that any organization can consider bringing in to improve communication and collaboration among stakeholders and engineers. The next section will briefly introduce them and their formats.</p>
			<h1 id="_idParaDest-207"><a id="_idTextAnchor301"/>Modeling activities for DDD</h1>
			<p>In our real-life example, we<a id="_idIndexMarker728"/> covered how the solution evolves and emerges from the input of the team and the domain expert. It’s important to understand the actual modeling activities that are involved in DDD so that we can put them into practice.</p>
			<p>There are a few popular modeling activities that drive the direction of the design from both the team and the domain expert.</p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor302"/>Domain expert interview</h2>
			<p>The concept of a<a id="_idIndexMarker729"/> domain expert interview was made popular by <em class="italic">Eric Evans</em> in his book <em class="italic">Domain-Driven Design: Tackling Complexity in the Heart of Software</em>, published in 2003.</p>
			<p>Performing a domain expert interview is an approach that you can use to gain deep insights into the business domain and understand its intricacies. It is particularly applicable in the following scenarios:</p>
			<ul>
				<li>The domain expert is external to the organization</li>
				<li>The domain expert has only limited time to be involved</li>
				<li>The organization starts a new line of business and brings in domain experts</li>
				<li>The team is new and doesn’t have much prior knowledge of the domain</li>
			</ul>
			<p>Here are some guidelines for conducting effective domain expert interviews in DDD:</p>
			<ul>
				<li><strong class="bold">Identify the right experts</strong>: Identify individuals, both internally and externally, who possess in-depth knowledge and expertise in the specific domain. Look for subject matter experts, experienced practitioners, or individuals who have a deep understanding of the business processes and rules involved.</li>
				<li><strong class="bold">Prepare an interview plan</strong>: State clear objectives of the interview. Develop an outline of each topic. Prepare a list of questions, preferably open-ended ones, to ask. Pay attention to potential pain points and areas of uncertainty.</li>
				<li><strong class="bold">Establish a comfortable environment</strong>: Establish a collaborative atmosphere with the domain expert during the interview. Make them feel comfortable and valued. Clearly explain the interview’s purpose and outline the topics to be covered. Emphasize that their opinions are critical for your project’s success. Create an atmosphere where they feel free to share their knowledge and experiences.</li>
				<li><strong class="bold">Active listening</strong>: During the interview, practice active listening. Pay close attention to the expert’s verbal responses and non-verbal communication. Clarify their answers whenever necessary and ask follow-up questions to delve deeper into specific areas of interest. Show genuine interest in their insights and validate their contributions.</li>
				<li><strong class="bold">Capture notes</strong>: Take thorough and detailed notes during the interview. Document important concepts, terms, processes, and examples that the expert shares. Record <a id="_idIndexMarker730"/>key details, such as business rules, decision-making criteria, and exceptions. Use visual aids, such as diagrams or sketches, to capture their explanations and mental models.</li>
				<li><strong class="bold">Validate and clarify information</strong>: After the interview, review the notes that were taken and validate the information that’s been gathered. Clarify with the domain expert or have follow-up discussions on ambiguity or uncertainty. It’s important to ensure that the team has a clear and accurate understanding of the domain.</li>
				<li><strong class="bold">Share and validate your findings</strong>: After the interview, share your findings with the domain expert and other stakeholders to validate your understanding. Actively seek their feedback and incorporate any corrections or additional insights they may provide. By incorporating their input, the domain model can be refined and improved, ensuring that the software system accurately reflects the intricacies and requirements of the business domain.</li>
			</ul>
			<p>The domain expert interview is an iterative process. As the team understands more of the domain, new <a id="_idIndexMarker731"/>questions arise. Continuous collaboration and feedback with domain experts throughout the project can significantly contribute to the success of your DDD implementation.</p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor303"/>Event storming</h2>
			<p>Event storming is a<a id="_idIndexMarker732"/> domain modeling<a id="_idIndexMarker733"/> technique that was developed by <em class="italic">Alberto Brandolini</em> in 2013. Event storming requires the team, domain experts, and other stakeholders to gather in the same place, ideally in person, and garner a mix of perspectives and knowledge about the domain.</p>
			<p>An in-person event storming session requires a large whiteboard, many marker pens of assorted colors, and many stickies of many colors. Alternatively, online collaboration drawing tools that have the same elements can suffice.</p>
			<p>Participants are expected to actively engage in every activity of the process. They’re expected to move some stickies, erase lines, and draw some lines on the board simultaneously.</p>
			<p>The session starts with outlining the scope of the session. It should focus on a specific business process or domain participants want to explore. This could also be a specific feature, a user journey, or a critical aspect of the domain.</p>
			<p>Afterward, the session can be run in the following sequence. If necessary, participants can go back and correct any sticky notes as they learn more in later steps:</p>
			<ol>
				<li><code>Contract Agreed</code> or <code>Household Updated</code>.</li>
				<li><strong class="bold">Arrange the events</strong>: Once there’s a collection of domain events, work on the domain events on the whiteboard. Group duplicated events, remove irrelevant events, or correct ambiguous events. Place the events in chronological order, creating a timeline from left to right. This helps visualize the flow of events and their sequence.</li>
				<li><strong class="bold">Add actors and commands</strong>: Identify the actors or entities involved in the events. These could be system components or human users. Capture actors as sticky notes but use a different color (for example, yellow). Place them above or below the relevant events.<p class="list-inset">Identify any commands or actions that trigger the events and associate them with the respective events. Commands are the user’s intent to do certain things. Commands or actions should use a new color (for example, blue) for stickies.</p><p class="list-inset">Identify external systems that trigger the events. Use a dedicated color (for example, red) for the stickies.</p></li>
				<li><strong class="bold">Explore policies and business rules</strong>: Pay attention to policies, constraints, and business rules associated with the events. Capture them as separate sticky notes of a new color (for example, purple) and link them to the relevant events, commands, or actors. These rules help shape the behavior and interactions within the domain.</li>
				<li><strong class="bold">Discuss and refine the model</strong>: Facilitate discussions among the participants alongside the stickies for events, actors, commands, external systems, and policies. Encourage them to share their knowledge, insights, and questions related to events and their relationships. Refine the model by rearranging, adding, or removing stickies during the discussions.</li>
				<li><strong class="bold">Identify aggregates and bounded contexts</strong>: Look for patterns and events that often go together. This cluster of events may indicate potential aggregates. Identify bounded contexts, which are cohesive areas of the domain with well-defined purposes, boundaries, and language.</li>
				<li><strong class="bold">Capture insights and next steps</strong>: Capture any valuable insights, questions, or areas of <a id="_idIndexMarker734"/>uncertainty that arise. Make note of any follow-up actions or further investigations needed to refine the domain model.</li>
			</ol>
			<p>Event storming is also an iterative process. Sometimes, it takes multiple sessions to fully explore and refine the domain model. Encourage collaboration, active participation, and idea sharing among the participants to gain a common understanding and drive the software system aligned with the business objectives.</p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor304"/>Domain storytelling</h2>
			<p><strong class="bold">Domain storytelling</strong> was <a id="_idIndexMarker735"/>introduced in 2019 by <em class="italic">Stefan Hofer</em> and <em class="italic">Henning Schwentner</em> in their book <em class="italic">Domain Storytelling: A Collaborative Approach to </em><em class="italic">Domain-Driven Design.</em></p>
			<p>Domain storytelling<a id="_idIndexMarker736"/> is a collaborative and interactive approach to gaining a deeper understanding of a complex business domain. The team, domain experts, and other stakeholders come together, ideally in person, to develop stories that depict various aspects of the business domain.</p>
			<p>Like event storming, an in-person domain storytelling session requires a large whiteboard, many marker pens, and many stickies. Again, online whiteboard collaboration tools that have the same elements can suffice.</p>
			<p>Domain experts and stakeholders draw out a real-life business scenario by putting stickies on the whiteboard and connecting them with marker pens.</p>
			<p>The domain story about drafting a contract may look like this:</p>
			<div><div><img src="img/B21737_08_14.jpg" alt="Figure 8.14 – A domain story about drafting a contract" width="1374" height="752"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.14 – A domain story about drafting a contract</p>
			<p>These stories capture the context, challenges, interactions, and relationships within the domain. As the story is being told, everyone actively listens, asks questions, provides background information such as business rules, motivation, and pain points, or even picks up a pen and draws.</p>
			<p>Participants may want to adopt a certain format, such as the <strong class="bold">Business Process Modeling Notation</strong> (<strong class="bold">BPMN</strong>) mentioned in <a href="B21737_02.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, but this isn’t mandatory. The essence of the exercise<a id="_idIndexMarker737"/> is communication and collaboration to align everyone on a shared understanding. Also, domain experts may not be familiar with the standard visual notions. Instead of having them struggle to get the right notions, participants should focus on getting the right information instead.</p>
			<p>Participants should use this opportunity to clear up any ambiguous, unclear, and misused languages to aim for ubiquitous language.</p>
			<p>The visual representation serves as a shared artifact that can be referred to and refined throughout the development process.</p>
			<p>Domain storytelling helps bridge the gap between the team and domain experts by collaboratively working toward a shared language and understanding of the domain. It helps uncover hidden requirements, edge cases, and exceptional scenarios that may often be found in the middle or late stage of development. As a result, it reduces the cost of design modifications and lowers the risks of scope creep.</p>
			<p>Additionally, domain storytelling provides a user-centric perspective to software systems by emphasizing the needs, goals, and experiences of the users within the stories. It aids the team and domain experts in identifying bounded contexts, aggregate roots, and domain entities, promoting a robust and accurate domain model.</p>
			<p>Overall, domain storytelling serves as a powerful tool for domain exploration, analysis, and communication. It helps build a shared understanding of the domain, facilitates collaboration between <a id="_idIndexMarker738"/>stakeholders and the team, and supports building software systems that accurately reflect the intricacy and requirements of the business domain.</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor305"/>Comparing modeling activities</h2>
			<p>All modeling activities in <a id="_idIndexMarker739"/>DDD are iterative. They continuously refine and shape the software systems as participants understand more the subject matters, and as business evolves.</p>
			<p>However, the dynamics of these three activities are different. In a domain expert interview, the team drives the interview by preparing the topics and questions. The domain experts primarily react to these materials, and the team actively listens and responds. In event storming, everyone works on all stickies on the board, guided by the knowledge shared among domain experts and stakeholders. Finally, in domain storytelling, it’s the narrative of the domain experts and stakeholders but on a whiteboard, with the teams actively listening, reacting, and asking questions.</p>
			<p>They’re all good tools to use. Domain expert interviews are particularly useful if it’s difficult to have the domain experts available. Event storming is useful if everyone has some knowledge and experience about the domain. It focuses on visualizing the flow of events in a timeline from left to right. Domain storytelling focuses on capturing domain knowledge with a narrative story. It doesn’t require a timeline to be created from left to right and doesn’t <a id="_idIndexMarker740"/>require all labels that event storming uses to be used.</p>
			<h1 id="_idParaDest-212"><a id="_idTextAnchor306"/>Summary</h1>
			<p>In this chapter, we delved into two major design approaches in DDD. We covered the fundamental concepts of strategic design to get the bigger picture of the domain while providing a real-life example. Here, we covered concepts such as ubiquitous language, subdomains, bounded contexts, and context mapping.</p>
			<p>Afterward, we explored tactical design by using a bounded context from the strategic design example. We showcased how to identify aggregates, entities, value objects, domain services, repositories, and domain events.</p>
			<p>We also covered three popular modeling activities in DDD and discussed their agendas: the domain expert interview, event storming, and domain storytelling.</p>
			<p>At this point, you should be able to plan and design an architecture with the DDD approach, using at least one of the modeling activities outlined.</p>
			<p>In the next chapter, we’re going to deep dive into some of the architectural patterns based on DDD, namely <strong class="bold">Command and Query Responsibility Segregation</strong> (<strong class="bold">CQRS</strong>) and <strong class="bold">event sourcing</strong>.</p>
		</div>
	</div></div></body></html>