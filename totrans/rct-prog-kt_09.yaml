- en: Resource Management and Extending RxKotlin
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源管理和扩展 RxKotlin
- en: So far, you've learned about Observables, Flowables, Subjects, processors, operators,
    combining producers, testing, and many more things. We have gained most of the
    necessary knowledge to start coding our applications. The only remaining topic
    to look at is resource management—the technique of creating, accessing, and cleaning
    up resources. Also if you're one of the developers who is hungry for a challenge,
    then you'll always look for ways to customize everything. So far in this book,
    we've seen how to use operators in their prescribed way. We did nothing innovative
    and didn't try to customize the operators. So, this chapter is dedicated to resource
    management and extending RxKotlin through custom operators.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学习了关于 Observables、Flowables、Subjects、处理器、操作符、组合生产者、测试以及许多其他内容。我们已经获得了开始编码应用程序所需的大部分必要知识。唯一剩下要关注的话题是资源管理——创建、访问和清理资源的技术。此外，如果你是那些渴望挑战的开发者之一，那么你总会寻找定制一切的方法。到目前为止，在这本书中，我们已经看到了如何按照规定的方式使用操作符。我们没有做任何创新，也没有尝试自定义操作符。因此，本章致力于资源管理和通过自定义操作符扩展
    RxKotlin。
- en: 'The following list contains the topics we will cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表包含本章我们将要讨论的主题：
- en: Resource management with the `using` method
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `using` 方法进行资源管理
- en: Creating custom operators with the `lift` operator
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `lift` 操作符创建自定义操作符
- en: Creating custom transformers (transforming operators) with the `compose` operator
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `compose` 操作符创建自定义转换器（转换操作符）
- en: So, first things first, let's get started with resource management.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，让我们从资源管理开始。
- en: Resource management
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源管理
- en: Resource management, what does it mean? Why should we care about it? If you've
    a little experience in application development with Java,Kotlin,JavaScript, or
    any other language, then you're probably familiar with the fact that while developing
    applications, we often need to access resources, and we must close them when we
    are done.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 资源管理，这是什么意思？为什么我们应该关心它？如果你在 Java、Kotlin、JavaScript 或任何其他语言的 应用程序开发中有一点经验，那么你可能熟悉这样一个事实：在开发应用程序时，我们经常需要访问资源，并且在完成时必须关闭它们。
- en: If you're not experienced with that phrase, resource management, then let's
    break things down. We will be starting from the ground by exploring the definition
    of a resource.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这个短语不熟悉，那么资源管理，让我们来分解一下。我们将从探索资源的定义开始。
- en: So, what is resource? When developing applications, you may often need to access
    an API (through an HTTP connection), access a database, read from/write to a file,
    or you may even need to access any I/O ports/sockets/devices. All these things
    are considered **resources** in general.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是资源？在开发应用程序时，你可能经常需要访问 API（通过 HTTP 连接）、访问数据库、从文件中读取/写入，或者你可能甚至需要访问任何 I/O
    端口/套接字/设备。所有这些事情在一般情况下都被认为是 **资源**。
- en: Why do we need to manage/close them? Whenever we are accessing a resource, especially
    to write, the system often locks it for us, and blocks its access to any other
    program. If you don't release or close a resource when you're done, system performance
    may degrade and there may even be a deadlock. Even if the system doesn't lock
    the resource for us, it will keep it open for us until we release or close it,
    resulting in poor performance.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要管理/关闭它们？每当我们在访问资源时，尤其是写入时，系统通常会为我们锁定它，并阻止其他程序访问它。如果你在完成时没有释放或关闭资源，系统性能可能会下降，甚至可能出现死锁。即使系统没有为我们锁定资源，它也会保持打开状态，直到我们释放或关闭它，从而导致性能下降。
- en: So, we must close or release a resource whenever we are done working with it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每当我们在使用完资源后，我们必须关闭或释放它。
- en: Generally, on the JVM, we access resources through a class. Often, that class
    implements the `Closable` interface, making releasing a resource easy for us by
    calling its `close` method. It's quite easy in imperative programming, but you're
    probably wondering how to do it in reactive programming.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在 JVM 上，我们通过一个类来访问资源。通常，这个类实现了 `Closable` 接口，通过调用其 `close` 方法，使我们能够轻松地释放资源。在命令式编程中这相当简单，但你可能想知道如何在响应式编程中做到这一点。
- en: You're probably thinking of mixing imperative programming with reactive programming
    and making the resources global properties, and then, inside the `subscribe` method,
    you'll dispose them after using. This is basically what we did in [Chapter 5](e395e42a-afc0-4424-9d0f-2de06e19989d.xhtml),
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能正在考虑将命令式编程与响应式编程混合，并将资源作为全局属性，然后在 `subscribe` 方法中使用后将其丢弃。这基本上就是我们[第 5 章](e395e42a-afc0-4424-9d0f-2de06e19989d.xhtml)中所做的。
- en: '*Asynchronous Data Operators and Transformations* HTTP Request.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*异步数据运算符和转换* HTTP请求。'
- en: Sorry to break your heart, but that is the wrong procedure; in [Chapter 5](e395e42a-afc0-4424-9d0f-2de06e19989d.xhtml),
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 很抱歉让你失望，但这确实是错误的过程；在[第五章](e395e42a-afc0-4424-9d0f-2de06e19989d.xhtml)，
- en: '*Asynchronous Data Operators and Transformations*, we did it to avoid further
    complexities in order to make you understand the code better, but we should learn
    the correct approach now.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*异步数据运算符和转换*，我们这样做是为了避免进一步的复杂性，以便你更好地理解代码，但现在我们应该学习正确的方法。'
- en: 'To make things less complex, we will create a dummy resource with a custom
    implementation of the `Closable` interface. So, no more suspense; take a look
    at the following code snippet:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情不那么复杂，我们将创建一个具有自定义`Closable`接口实现的虚拟资源。所以，不再有悬念；看看下面的代码片段：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, we created a `Resource` class and implemented `Closeable`
    in this class (just to mock a typical Java resource class). We also created a
    `val` property named `data` inside that class, which will be used to mock data
    fetching from `Resource`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个`Resource`类，并在该类中实现了`Closeable`接口（只是为了模拟一个典型的Java资源类）。我们还在该类内部创建了一个名为`data`的`val`属性，它将被用来模拟从`Resource`中获取数据。
- en: Now, how do we use it in a reactive chain? RxKotlin provides a very convenient
    way to deal with disposable resources. To save your life with disposable resources,
    RxKotlin has a gift for you—the `using` operator.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们如何在响应式链中使用它呢？RxKotlin提供了一个非常方便的方式来处理可丢弃的资源。为了用可丢弃的资源拯救你的生命，RxKotlin为你准备了一个礼物——`using`运算符。
- en: The `using` operator lets you create a resource that'll exist only during the
    life span of the `Observable`, and it will be closed as soon as the `Observable`
    completes.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`using`运算符允许你创建一个仅在`Observable`的生命周期内存在的资源，并且一旦`Observable`完成，该资源就会被关闭。'
- en: 'The following diagram describes the relation of lifespans of `Observable` created
    with the `using` operator and the resource attached to it, which has been taken
    from ReactiveX documentation ([http://reactivex.io/documentation/operators/using.html](http://reactivex.io/documentation/operators/using.html)):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了使用`using`运算符创建的`Observable`的生命周期与附加的资源之间的关系，该图表取自ReactiveX文档([http://reactivex.io/documentation/operators/using.html](http://reactivex.io/documentation/operators/using.html))：
- en: '![](img/4d3cbc5c-51f8-4262-acc1-774c6ff94963.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d3cbc5c-51f8-4262-acc1-774c6ff94963.jpg)'
- en: The preceding image clearly displays that the resource will live during the
    lifespan of the `Observable` only—a perfect life partner, wouldn't you say?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图像清楚地显示，资源仅在`Observable`的生命周期内存在——一个完美的伴侣，不是吗？
- en: 'Here is the definition of the `using` operator:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`using`运算符的定义：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It looks confusing, but it's easy when we break it down. The `using` method
    accepts a `Callable` instance, which will create a resource and return it (`out
    D` is for that purpose). And, the last one is to release/close the resource. The
    `using` operator will call the first lambda before creating the `Resource` instance.
    Then, it'll pass the `Resource` instance to the second lambda for you to create `Observable`
    and return it so that you can subscribe. Finally, when the `Observable` calls
    its `onComplete` event, it will call the third lambda to close the `resource`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很复杂，但当我们分解它时，就很容易了。`using`方法接受一个`Callable`实例，该实例将创建一个资源并将其返回（`out D`就是为了这个目的）。然后，最后一个是释放/关闭资源。`using`运算符将在创建`Resource`实例之前调用第一个lambda。然后，它将`Resource`实例传递给第二个lambda，以便你创建`Observable`并返回它，这样你就可以订阅了。最后，当`Observable`调用其`onComplete`事件时，它将调用第三个lambda来关闭`resource`。
- en: 'You''re now dying to see the example, right? The following is the example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在迫不及待地想看到示例，对吧？以下是一个示例：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding program, we passed three lambdas to the `using` operator. In
    the first lambda (comment one), we created an instance of `Resource` and returned
    it (in a lambda, the last statement works as return, you don't have to write it).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，我们向`using`运算符传递了三个lambda。在第一个lambda（注释一）中，我们创建了一个`Resource`实例并将其返回（在lambda中，最后一个语句充当返回，你不需要写它）。
- en: The second lambda will take `resource` as parameter and will create the `Observable`
    from it to return.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个lambda将接受`resource`作为参数，并从它创建`Observable`以返回。
- en: The third lambda will again take `resource` as a parameter and close it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个lambda将再次以`resource`作为参数，并关闭它。
- en: The `using` operator will return the `Observable` you created in the second
    lambda for you to apply the RxKotlin chain to it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`using`运算符会返回你在第二个lambda中创建的`Observable`，以便你可以将其应用于RxKotlin链。'
- en: 'So, here is a screenshot of the output, if you''re curious:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这里有一个输出截图，如果你好奇的话：
- en: '![](img/0b49b1e1-6b76-4526-8040-4f4c838a6f24.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b49b1e1-6b76-4526-8040-4f4c838a6f24.jpg)'
- en: So, that is resource management made easy. Also note that you can create and
    pass as many resources as you want to the `using` operator. We implemented the
    `Closable` interface for ease of understanding, but it's not mandatory; you can
    easily create and pass an array of resources.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就是资源管理变得简单。同时请注意，你可以创建并传递任意数量的资源到`using`操作符。我们为了便于理解实现了`Closable`接口，但这不是强制的；你可以轻松地创建并传递一个资源数组。
- en: Creating your own operators
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自己的操作符
- en: So far, we have used lots of operators, but are we sure they will meet all our
    needs? Or, can we always find a fitting operator for each requirement we face?
    No, that's not possible. Sometimes, we may have to create our own operators for
    our own needs, but how?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了大量的操作符，但我们能确定它们能满足所有我们的需求吗？或者，我们是否总能找到适合每个我们面对的需求的操作符？不，这是不可能的。有时，我们可能必须为我们的需求创建自己的操作符，但如何做呢？
- en: RxKotlin is always there to make your life easier. It has an operator just for
    this purpose—the `lift` operator. The `lift` operator receives an instance of
    `ObservableOperator`; so, to create your own operator, you have to implement that
    interface.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: RxKotlin始终致力于让你的生活更轻松。它有一个专门为此目的的操作符——`lift`操作符。`lift`操作符接收一个`ObservableOperator`的实例；因此，要创建自己的操作符，你必须实现该接口。
- en: 'In my opinion, the best way to learn something is by doing it. What about creating
    a custom operator that would add a sequential number to every emission? Let''s
    create it as per the following list of requirements:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，学习某样东西的最佳方式是通过实践。那么，创建一个自定义操作符，为每个排放添加一个序列号，怎么样？让我们根据以下要求列表来创建它：
- en: The operator should emit a pair, with an added sequential number as the first
    element. The second element of the pair should be the actual emission.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该操作符应该发射一个对，其中添加的序列号作为第一个元素。对中的第二个元素应该是实际的排放。
- en: The operator should be generic and should work with any type of Observable.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该操作符应该是泛型的，并且应该与任何类型的Observable一起工作。
- en: As with other operators, the operator should work concurrently with other operators.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他操作符一样，该操作符应该与其他操作符并发工作。
- en: The preceding points are our basic requirements; and, as per the preceding requirement,
    we must use `AtomicInteger` for the counter (which will count the emissions, and
    we will pass that count as a sequential number) so that the operator will work
    seamlessly with any `Scheduler`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的点是我们的基本要求；根据前面的要求，我们必须使用`AtomicInteger`作为计数器（它将计算排放量，我们将这个计数作为序列号传递），这样操作符才能与任何`Scheduler`无缝工作。
- en: 'Every custom operator should implement the `ObservableOperator` interface,
    which looks like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每个自定义操作符都应该实现`ObservableOperator`接口，其外观如下：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`Downstream` and `Upstream` are two generic types here. `Downstream` specifies
    the type that will be passed to the Downstream of the operator, and `Upstream`
    specifies the type that the operator will receive from `upstream`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`Downstream`和`Upstream`是这里的两个泛型类型。`Downstream`指定了将传递给操作符的`Downstream`的类型，而`Upstream`指定了操作符将从`upstream`接收的类型。'
- en: The `apply` function has a parameter called the `Observer` that should be used
    to pass the emission to the `Downstream`, and the function should return another
    `Observer` that will be used to listen to the `upstream` emissions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply`函数有一个名为`Observer`的参数，应该用来将排放传递给`Downstream`，并且函数应该返回另一个`Observer`，它将用于监听`upstream`的排放。'
- en: 'Enough theory. The following is the definition of our `AddSerialNumber` operator.
    Take a careful look at it here:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 足够的理论了。以下是我们`AddSerialNumber`操作符的定义。请在这里仔细看看：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let's start describing this from the very first feature—the definition of the
    `AddSerialNumber` class. This implements the `ObservableOperator` interface. As
    per our requirement, we kept the class generic, that is, we specified the `Upstream`
    type to be generic `T`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个特性开始描述——`AddSerialNumber`类的定义。这个类实现了`ObservableOperator`接口。根据我们的要求，我们保持了类的泛型性，即我们指定了`Upstream`类型为泛型`T`。
- en: We used an `AtomicInteger` as a `val` property of the class, which should be
    initialized within the `init` block (as we are declaring and defining the property
    within the class, it would be automatically initialized within `init` while creating
    instances of the class). That `AtomicInteger`, `counter` should increment on each
    emission and should return the emitted value as the serial number of the emission.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个`AtomicInteger`作为类的`val`属性，它应该在`init`块中初始化（因为我们是在类内部声明和定义属性，所以它会在创建类的实例时自动在`init`中初始化）。这个`AtomicInteger`，即`counter`，应该在每次发射时增加，并返回发射值的序列号。
- en: Inside the `apply` method, I created and returned an `Observer` instance, which
    would be used to listen to the `upstream` as described earlier. Basically, every
    operator passes an `Observer` to `upstream` by which it should receive the events.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在`apply`方法中，我创建并返回了一个`Observer`实例，它将被用来监听前面描述的`upstream`。基本上，每个操作符都会通过传递一个`Observer`给`upstream`来接收事件。
- en: Inside that `observer`, whenever we receive any event, we echoed that to the
    `Observer` downstream (where it is received as a parameter).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个`observer`内部，每当收到任何事件，我们都会将其回声到下游的`Observer`（在那里它作为一个参数被接收）。
- en: Inside the `onNext` event of the `Upstream` `Observer`, we incremented the `counter`,
    added it as the `first` element to a `Pair` instance, added the item we received
    (as a parameter in `onNext`) as the `second` value, and, finally, passed it to
    the `onNext`—`observer.onNext(Pair(counter.incrementAndGet(),t))` downstream.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Upstream` `Observer`的`onNext`事件中，我们增加了`counter`的值，将其作为`Pair`实例的第一个元素，将接收到的项目（作为`onNext`中的参数）作为第二个值添加，最后将其传递给下游的`onNext`——`observer.onNext(Pair(counter.incrementAndGet(),t))`。
- en: 'So, what now? We created a class that can be used as an operator, but how do
    we use it? It''s easy, take a look at this piece of code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，接下来是什么？我们创建了一个可以用作操作符的类，但我们如何使用它？很简单，看看这段代码：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You just have to create an instance of your operator and pass it to the `lift`
    operator; that's all you need, we have now created our first operator.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要创建你操作符的一个实例，并将其传递给`lift`操作符；这就是你所需要的一切，我们现在已经创建了我们的第一个操作符。
- en: 'Look at the following output:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的输出：
- en: '![](img/18f26427-7539-420e-abc8-cc68dbfb6c64.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18f26427-7539-420e-abc8-cc68dbfb6c64.jpg)'
- en: We have created our first operator, and, frankly, that was super easy. Yes,
    it seemed a bit confusing at the start, but as we moved forward, it became easier.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了我们的第一个操作符，坦白说，这非常简单。是的，一开始可能有点令人困惑，但随着我们继续前进，它变得更容易了。
- en: 'As you may have noticed, the `ObservableOperator` interface has only one method,
    so we can obviously replace the class declaration and everything with just a lambda,
    as shown here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，`ObservableOperator`接口只有一个方法，因此我们可以显然用lambda替换类声明以及一切，如下所示：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, we used a list of `String` to create `Observable` instead of
    an `Int` range.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了一个`String`列表来创建`Observable`，而不是使用`Int`范围。
- en: 'The following is the output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的就是输出：
- en: '![](img/6c36b770-b159-4877-b008-1f1e8d7a921a.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c36b770-b159-4877-b008-1f1e8d7a921a.jpg)'
- en: The program is almost similar to the previous one, except that we used a lambda
    and used `Pair<Int,String>` as the type of downstream `Observer`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 程序几乎与上一个类似，只是我们使用了一个lambda，并使用`Pair<Int,String>`作为下游`Observer`的类型。
- en: As we have gained our grip in creating our custom operators, let's move forward
    by learning how to create transformers—no, not the autobot like the movie series;
    they are just RxKotlin transformers. What are they? Let's see.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经掌握了创建自定义操作符的技巧，让我们继续学习如何创建转换器——不，不是像电影系列中的机器人；它们只是RxKotlin转换器。它们是什么？让我们看看。
- en: Composing operators with transformer
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用转换器组合操作符
- en: So, you have learned how to create custom operators, but think of a situation
    when you want to create a new operator by combining multiple operators. For instance,
    I often wanted to combine the functionality of the `subscribeOn` and `observeOn`
    operators so that all the computations can be pushed to computation threads, and,
    when the results are ready, we can receive them on the main thread.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你已经学会了如何创建自定义操作符，但想想当你想要通过组合多个操作符来创建一个新操作符的情况。例如，我经常想要组合`subscribeOn`和`observeOn`操作符的功能，以便将所有计算推送到计算线程，当结果准备好时，我们可以在主线程上接收它们。
- en: 'Yes, it''s possible to get the benefits of both operators by adding both operators
    one after the other to the chain, as shown here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，可以通过将两个操作符一个接一个地添加到链中，来获得两个操作符的好处，如下所示：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Though you''re already aware of the output, the following is the screenshot
    if you need a refresher:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你已经知道了输出结果，以下截图如果你需要刷新记忆的话：
- en: '![](img/1fcf1da2-b3cf-4995-8144-ed50a5d6107e.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1fcf1da2-b3cf-4995-8144-ed50a5d6107e.jpg)'
- en: Now, say we have this combination of the `subscribeOn` and `observeOn` operator
    throughout our project, so we want a shortcut. We want to create our own operator
    where we would pass the two `Scheduler`'s where we want `subscribeOn` and `observeOn`,
    and everything should work perfectly.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们项目中有`subscribeOn`和`observeOn`操作符的组合，所以我们想要一个快捷方式。我们想要创建自己的操作符，其中我们将传递两个`Scheduler`，我们想要`subscribeOn`和`observeOn`，并且一切都应该完美工作。
- en: RxKotlin provides the `Transformer` interfaces (`ObservableTransformer` and
    `FlowableTransformer` are two `Transformer` interfaces) for that purpose. Just
    like the `operator` interfaces, it has only one method—`apply`. The only difference
    is that here, instead of `Observers`, you have the `Observable`. So, instead of
    operating on individual emits and their items, here, you work directly on the
    source.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: RxKotlin提供了`Transformer`接口（`ObservableTransformer`和`FlowableTransformer`是两个`Transformer`接口）用于此目的。就像`operator`接口一样，它只有一个方法——`apply`。唯一的区别是，在这里，你处理的是`Observable`而不是`Observers`。所以，在这里，你直接在源上操作，而不是操作单个发射和它们的项。
- en: 'Here is the signature of the `ObservableTransformer` interface:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`ObservableTransformer`接口的签名：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The interface signature is almost the same. Unlike the `apply` method of `ObservableOperator`,
    here, the `apply` method receives `Upstream` `Observable` and should return the
    `Observable` that should be passed to the `Downstream`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接口签名几乎相同。与`ObservableOperator`的`apply`方法不同，这里的`apply`方法接收`Upstream` `Observable`并应返回应传递给`Downstream`的`Observable`。
- en: 'So, back to our topic, the following code block should fulfill our requirements:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，回到我们的主题，以下代码块应该满足我们的要求：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, we created a class for our requirement—`SchedulerManager`—that
    would take two `Scheduler` as parameters. The first one is to be passed to the
    `subscribeOn` operator and the second one is for the `observeOn` operator.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个用于我们需求的类——`SchedulerManager`——它将接受两个`Scheduler`作为参数。第一个是要传递给`subscribeOn`操作符的，第二个是要传递给`observeOn`操作符的。
- en: Inside the `apply` method, we returned the `Observable` `Upstream`, after applying
    two operators to it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在`apply`方法内部，我们在对其应用两个操作符之后返回了`Observable` `Upstream`。
- en: We are omitting the screenshot of the output, as it is the same as the previous
    one.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了输出截图，因为它与上一个截图相同。
- en: 'Like the `lift` operator, the `compose` operator can also be implemented using
    a lambda. Let''s have another example where we will transform an `Observable<Int>`
    to an `Observable<List>`. Here is the code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`lift`操作符一样，`compose`操作符也可以使用lambda函数实现。让我们再举一个例子，我们将把`Observable<Int>`转换成`Observable<List>`。以下是代码：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code, we used `upstream.toList().toObservable()` as the `Observable$toList()`
    operator converts an `Observable<T>` to `Single<List<T>>`, so we need the `toObservable()`
    operator to convert it back to `Observable`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了`upstream.toList().toObservable()`作为`Observable$toList()`操作符，因为它将`Observable<T>`转换为`Single<List<T>>`，所以我们需要`toObservable()`操作符将其转换回`Observable`。
- en: 'Here is the screenshot of the output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出截图：
- en: '![](img/8c25986e-9fd2-4eac-81d8-d9f5f2c4fb38.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c25986e-9fd2-4eac-81d8-d9f5f2c4fb38.jpg)'
- en: Composing multiple operators to create a new one is also super easy in RxKotlin;
    just add a bit extension function to it to see how things become more delightful.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在RxKotlin中，组合多个操作符以创建一个新的操作符也非常简单；只需给它添加一个扩展函数，就可以看到事情变得更加愉快。
- en: Summary
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This was a short chapter about resource management and custom operators in RxKotlin.
    You learned how you can (or should) create, use, and dispose resources. You learned
    to create custom operators. You also learned how to compose multiple operators
    to create your desired one.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一章关于RxKotlin中资源管理和自定义操作符的简短章节。你学习了如何（或应该）创建、使用和销毁资源。你学习了如何创建自定义操作符。你还学习了如何组合多个操作符以创建你想要的操作符。
- en: This was the last chapter on the fundamentals of RxKotlin. From the next chapter
    onward, we will start applying our gained knowledge to real-life scenarios and
    projects.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是关于RxKotlin基础知识的最后一章。从下一章开始，我们将开始将我们获得的知识应用到实际场景和项目中。
- en: In today's app-driven era, writing APIs is a primary requirement; in the next
    chapter, you will start learning Spring in Kotlin so that you can develop your
    own API for your projects.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天以应用驱动时代，编写API是一个基本要求；在下一章，你将开始学习Kotlin中的Spring，这样你就可以为你的项目开发自己的API。
