- en: Resource Management and Extending RxKotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you've learned about Observables, Flowables, Subjects, processors, operators,
    combining producers, testing, and many more things. We have gained most of the
    necessary knowledge to start coding our applications. The only remaining topic
    to look at is resource management—the technique of creating, accessing, and cleaning
    up resources. Also if you're one of the developers who is hungry for a challenge,
    then you'll always look for ways to customize everything. So far in this book,
    we've seen how to use operators in their prescribed way. We did nothing innovative
    and didn't try to customize the operators. So, this chapter is dedicated to resource
    management and extending RxKotlin through custom operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list contains the topics we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Resource management with the `using` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom operators with the `lift` operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom transformers (transforming operators) with the `compose` operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, first things first, let's get started with resource management.
  prefs: []
  type: TYPE_NORMAL
- en: Resource management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Resource management, what does it mean? Why should we care about it? If you've
    a little experience in application development with Java,Kotlin,JavaScript, or
    any other language, then you're probably familiar with the fact that while developing
    applications, we often need to access resources, and we must close them when we
    are done.
  prefs: []
  type: TYPE_NORMAL
- en: If you're not experienced with that phrase, resource management, then let's
    break things down. We will be starting from the ground by exploring the definition
    of a resource.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is resource? When developing applications, you may often need to access
    an API (through an HTTP connection), access a database, read from/write to a file,
    or you may even need to access any I/O ports/sockets/devices. All these things
    are considered **resources** in general.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need to manage/close them? Whenever we are accessing a resource, especially
    to write, the system often locks it for us, and blocks its access to any other
    program. If you don't release or close a resource when you're done, system performance
    may degrade and there may even be a deadlock. Even if the system doesn't lock
    the resource for us, it will keep it open for us until we release or close it,
    resulting in poor performance.
  prefs: []
  type: TYPE_NORMAL
- en: So, we must close or release a resource whenever we are done working with it.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, on the JVM, we access resources through a class. Often, that class
    implements the `Closable` interface, making releasing a resource easy for us by
    calling its `close` method. It's quite easy in imperative programming, but you're
    probably wondering how to do it in reactive programming.
  prefs: []
  type: TYPE_NORMAL
- en: You're probably thinking of mixing imperative programming with reactive programming
    and making the resources global properties, and then, inside the `subscribe` method,
    you'll dispose them after using. This is basically what we did in [Chapter 5](e395e42a-afc0-4424-9d0f-2de06e19989d.xhtml),
  prefs: []
  type: TYPE_NORMAL
- en: '*Asynchronous Data Operators and Transformations* HTTP Request.'
  prefs: []
  type: TYPE_NORMAL
- en: Sorry to break your heart, but that is the wrong procedure; in [Chapter 5](e395e42a-afc0-4424-9d0f-2de06e19989d.xhtml),
  prefs: []
  type: TYPE_NORMAL
- en: '*Asynchronous Data Operators and Transformations*, we did it to avoid further
    complexities in order to make you understand the code better, but we should learn
    the correct approach now.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things less complex, we will create a dummy resource with a custom
    implementation of the `Closable` interface. So, no more suspense; take a look
    at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we created a `Resource` class and implemented `Closeable`
    in this class (just to mock a typical Java resource class). We also created a
    `val` property named `data` inside that class, which will be used to mock data
    fetching from `Resource`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, how do we use it in a reactive chain? RxKotlin provides a very convenient
    way to deal with disposable resources. To save your life with disposable resources,
    RxKotlin has a gift for you—the `using` operator.
  prefs: []
  type: TYPE_NORMAL
- en: The `using` operator lets you create a resource that'll exist only during the
    life span of the `Observable`, and it will be closed as soon as the `Observable`
    completes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram describes the relation of lifespans of `Observable` created
    with the `using` operator and the resource attached to it, which has been taken
    from ReactiveX documentation ([http://reactivex.io/documentation/operators/using.html](http://reactivex.io/documentation/operators/using.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d3cbc5c-51f8-4262-acc1-774c6ff94963.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding image clearly displays that the resource will live during the
    lifespan of the `Observable` only—a perfect life partner, wouldn't you say?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the definition of the `using` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It looks confusing, but it's easy when we break it down. The `using` method
    accepts a `Callable` instance, which will create a resource and return it (`out
    D` is for that purpose). And, the last one is to release/close the resource. The
    `using` operator will call the first lambda before creating the `Resource` instance.
    Then, it'll pass the `Resource` instance to the second lambda for you to create `Observable`
    and return it so that you can subscribe. Finally, when the `Observable` calls
    its `onComplete` event, it will call the third lambda to close the `resource`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''re now dying to see the example, right? The following is the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding program, we passed three lambdas to the `using` operator. In
    the first lambda (comment one), we created an instance of `Resource` and returned
    it (in a lambda, the last statement works as return, you don't have to write it).
  prefs: []
  type: TYPE_NORMAL
- en: The second lambda will take `resource` as parameter and will create the `Observable`
    from it to return.
  prefs: []
  type: TYPE_NORMAL
- en: The third lambda will again take `resource` as a parameter and close it.
  prefs: []
  type: TYPE_NORMAL
- en: The `using` operator will return the `Observable` you created in the second
    lambda for you to apply the RxKotlin chain to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here is a screenshot of the output, if you''re curious:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b49b1e1-6b76-4526-8040-4f4c838a6f24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, that is resource management made easy. Also note that you can create and
    pass as many resources as you want to the `using` operator. We implemented the
    `Closable` interface for ease of understanding, but it's not mandatory; you can
    easily create and pass an array of resources.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have used lots of operators, but are we sure they will meet all our
    needs? Or, can we always find a fitting operator for each requirement we face?
    No, that's not possible. Sometimes, we may have to create our own operators for
    our own needs, but how?
  prefs: []
  type: TYPE_NORMAL
- en: RxKotlin is always there to make your life easier. It has an operator just for
    this purpose—the `lift` operator. The `lift` operator receives an instance of
    `ObservableOperator`; so, to create your own operator, you have to implement that
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In my opinion, the best way to learn something is by doing it. What about creating
    a custom operator that would add a sequential number to every emission? Let''s
    create it as per the following list of requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: The operator should emit a pair, with an added sequential number as the first
    element. The second element of the pair should be the actual emission.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The operator should be generic and should work with any type of Observable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with other operators, the operator should work concurrently with other operators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding points are our basic requirements; and, as per the preceding requirement,
    we must use `AtomicInteger` for the counter (which will count the emissions, and
    we will pass that count as a sequential number) so that the operator will work
    seamlessly with any `Scheduler`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every custom operator should implement the `ObservableOperator` interface,
    which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`Downstream` and `Upstream` are two generic types here. `Downstream` specifies
    the type that will be passed to the Downstream of the operator, and `Upstream`
    specifies the type that the operator will receive from `upstream`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `apply` function has a parameter called the `Observer` that should be used
    to pass the emission to the `Downstream`, and the function should return another
    `Observer` that will be used to listen to the `upstream` emissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enough theory. The following is the definition of our `AddSerialNumber` operator.
    Take a careful look at it here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Let's start describing this from the very first feature—the definition of the
    `AddSerialNumber` class. This implements the `ObservableOperator` interface. As
    per our requirement, we kept the class generic, that is, we specified the `Upstream`
    type to be generic `T`.
  prefs: []
  type: TYPE_NORMAL
- en: We used an `AtomicInteger` as a `val` property of the class, which should be
    initialized within the `init` block (as we are declaring and defining the property
    within the class, it would be automatically initialized within `init` while creating
    instances of the class). That `AtomicInteger`, `counter` should increment on each
    emission and should return the emitted value as the serial number of the emission.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `apply` method, I created and returned an `Observer` instance, which
    would be used to listen to the `upstream` as described earlier. Basically, every
    operator passes an `Observer` to `upstream` by which it should receive the events.
  prefs: []
  type: TYPE_NORMAL
- en: Inside that `observer`, whenever we receive any event, we echoed that to the
    `Observer` downstream (where it is received as a parameter).
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `onNext` event of the `Upstream` `Observer`, we incremented the `counter`,
    added it as the `first` element to a `Pair` instance, added the item we received
    (as a parameter in `onNext`) as the `second` value, and, finally, passed it to
    the `onNext`—`observer.onNext(Pair(counter.incrementAndGet(),t))` downstream.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what now? We created a class that can be used as an operator, but how do
    we use it? It''s easy, take a look at this piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You just have to create an instance of your operator and pass it to the `lift`
    operator; that's all you need, we have now created our first operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18f26427-7539-420e-abc8-cc68dbfb6c64.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have created our first operator, and, frankly, that was super easy. Yes,
    it seemed a bit confusing at the start, but as we moved forward, it became easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may have noticed, the `ObservableOperator` interface has only one method,
    so we can obviously replace the class declaration and everything with just a lambda,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we used a list of `String` to create `Observable` instead of
    an `Int` range.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c36b770-b159-4877-b008-1f1e8d7a921a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The program is almost similar to the previous one, except that we used a lambda
    and used `Pair<Int,String>` as the type of downstream `Observer`.
  prefs: []
  type: TYPE_NORMAL
- en: As we have gained our grip in creating our custom operators, let's move forward
    by learning how to create transformers—no, not the autobot like the movie series;
    they are just RxKotlin transformers. What are they? Let's see.
  prefs: []
  type: TYPE_NORMAL
- en: Composing operators with transformer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, you have learned how to create custom operators, but think of a situation
    when you want to create a new operator by combining multiple operators. For instance,
    I often wanted to combine the functionality of the `subscribeOn` and `observeOn`
    operators so that all the computations can be pushed to computation threads, and,
    when the results are ready, we can receive them on the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes, it''s possible to get the benefits of both operators by adding both operators
    one after the other to the chain, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Though you''re already aware of the output, the following is the screenshot
    if you need a refresher:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1fcf1da2-b3cf-4995-8144-ed50a5d6107e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, say we have this combination of the `subscribeOn` and `observeOn` operator
    throughout our project, so we want a shortcut. We want to create our own operator
    where we would pass the two `Scheduler`'s where we want `subscribeOn` and `observeOn`,
    and everything should work perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: RxKotlin provides the `Transformer` interfaces (`ObservableTransformer` and
    `FlowableTransformer` are two `Transformer` interfaces) for that purpose. Just
    like the `operator` interfaces, it has only one method—`apply`. The only difference
    is that here, instead of `Observers`, you have the `Observable`. So, instead of
    operating on individual emits and their items, here, you work directly on the
    source.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the signature of the `ObservableTransformer` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The interface signature is almost the same. Unlike the `apply` method of `ObservableOperator`,
    here, the `apply` method receives `Upstream` `Observable` and should return the
    `Observable` that should be passed to the `Downstream`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, back to our topic, the following code block should fulfill our requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we created a class for our requirement—`SchedulerManager`—that
    would take two `Scheduler` as parameters. The first one is to be passed to the
    `subscribeOn` operator and the second one is for the `observeOn` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `apply` method, we returned the `Observable` `Upstream`, after applying
    two operators to it.
  prefs: []
  type: TYPE_NORMAL
- en: We are omitting the screenshot of the output, as it is the same as the previous
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the `lift` operator, the `compose` operator can also be implemented using
    a lambda. Let''s have another example where we will transform an `Observable<Int>`
    to an `Observable<List>`. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we used `upstream.toList().toObservable()` as the `Observable$toList()`
    operator converts an `Observable<T>` to `Single<List<T>>`, so we need the `toObservable()`
    operator to convert it back to `Observable`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the screenshot of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c25986e-9fd2-4eac-81d8-d9f5f2c4fb38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Composing multiple operators to create a new one is also super easy in RxKotlin;
    just add a bit extension function to it to see how things become more delightful.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was a short chapter about resource management and custom operators in RxKotlin.
    You learned how you can (or should) create, use, and dispose resources. You learned
    to create custom operators. You also learned how to compose multiple operators
    to create your desired one.
  prefs: []
  type: TYPE_NORMAL
- en: This was the last chapter on the fundamentals of RxKotlin. From the next chapter
    onward, we will start applying our gained knowledge to real-life scenarios and
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: In today's app-driven era, writing APIs is a primary requirement; in the next
    chapter, you will start learning Spring in Kotlin so that you can develop your
    own API for your projects.
  prefs: []
  type: TYPE_NORMAL
