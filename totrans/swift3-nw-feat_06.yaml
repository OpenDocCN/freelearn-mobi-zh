- en: Chapter 6. Extra, Extra Collection and Closure Changes That Rock!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are focusing on collection and closure changes in Swift
    3\. Collections are important to all programming languages because they allow
    you hold groups of related items. Closures are also important to Swift because
    they give you the ability to pass around functionality to be used in a different
    location of your code. There are several nice additions that will make working
    with collections even more fun. We will also explore some of the confusing side
    effects of creating closures in Swift 2.2 and how those have been fixed in Swift
    3.
  prefs: []
  type: TYPE_NORMAL
- en: Collection and sequence type changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin our discussion with Swift 3 changes to Collection and Sequence
    types. Some of the changes are subtle and others are bound to require a decent
    amount of refactoring to your custom implementations. Swift provides three main
    collection types for warehousing your values: arrays, dictionaries, and sets.
    Arrays allow you to store values in an ordered list. Dictionaries provide unordered
    key-value storage for your data. Finally, sets provide an unordered list of unique
    values (that is, no duplicates allowed).'
  prefs: []
  type: TYPE_NORMAL
- en: Lazy FlatMap for sequence of optional [SE-0008]
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays, dictionaries, and sets are implemented as generic types in Swift. They
    each implement the new Collection protocol, which implements the Sequence protocol.
    Along this path from top-level type to Sequence protocol, you will find various
    other protocols that are also implemented in this inheritance chain. For our discussion
    on `flatMap` and lazy `flatMap` changes, I want to focus on Sequences.
  prefs: []
  type: TYPE_NORMAL
- en: Sequences contain a group of values that allow the user to visit each value
    one at a time. In Swift, you might consider using a for-in loop to iterate through
    your collection. The Sequence protocol provides implementations of many operations
    that you might want to perform on a list using sequential access; all of which
    you can override when you adopt the protocol in your custom collections. One such
    operation is the `flatMap` function, which returns an array containing the flattened,
    or rather concatenated, values resulting from a transforming operation applied
    to each element of the sequence. Let's consider how we could use the `flatMap`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In our example above, we take a list of scores and call `flatMap` with our transforming
    closure. Each value is converted into a sequence containing the original value
    and a doubled value. Once the transforming operations complete, the `flatMap`
    method flattens the intermediate sequences into a single sequence.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use the `flatMap` method with *Sequences* that contain optional
    values to accomplish a similar outcome. This time we are omitting values from
    the Sequence we flatten by return nil on the transformation. In the next example,
    we use the `flatMap` method to remove all nil values from our collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The previous two examples were fairly basic transformations on small sets of
    values. In a more complex situation, the collections that you need to work with
    might be very large with expensive transformation operations. Under those parameters,
    you would not want to perform the `flatMap` operation or any other costly operation
    until it was absolutely needed. Luckily, in Swift we have lazy operations for
    this use case. Sequences contain a `lazy` property that returns a `LazySequence`
    that can perform lazy operations on Sequence methods. Using our first example
    above, we can obtain a lazy sequence and call `flatMap` to get a lazy implementation.
    Only in the lazy scenario, the operation isn't completed until scores is used
    sometime later in code. To demonstrate lazy operations, we define a collection
    that uses the `lazy` property with our `flatMap` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `lazy` operation works as we would expect in our test above. However, when
    we use the `lazy` form of `flatMap` with our second example that contains optionals,
    our `flatMap` executes immediately in Swift 2\. Using the lazy version of `oddSquared`
    should delay execution of our `flatMap` operation until we use the variable. However,
    the `flatMap` method executes immediately, as if the lazy form didn't exist..
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, this was a feature in Swift that has been changed in Swift 3 to
    behave similar to other lazy implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read the proposal at the following link [https://github.com/apple/swift-evolution/blob/master/proposals/0008-lazy-flatmap-for-optionals.md](https://github.com/apple/swift-evolution/blob/master/proposals/0008-lazy-flatmap-for-optionals.md)
  prefs: []
  type: TYPE_NORMAL
- en: Adding a first(where:) method to Sequence [SE-0032]
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common task for working with collections is to find the first element that
    matches a condition. An example would be to ask for the first student in an array
    of students whose test scores contain  100\. You could accomplish this by using
    a predicate to return the filtered sequence that matched the criteria and then
    just give back the first student in the sequence. However, it would be much easier
    to just call a single method that could return the item without the two-step approach.
    This functionality was missing in Swift 2, but was voted in by the community and
    has been added for this release. In Swift 3 there is now a method on the Sequence
    protocol to implement `first(where:).`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This `first(where:)` extension is a nice addition to the language because it
    ensures that a simple and common task is actually easy to perform in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read the proposal at the following link [https://github.com/apple/swift-evolution/blob/master/proposals/0032-sequencetype-find.md](https://github.com/apple/swift-evolution/blob/master/proposals/0032-sequencetype-find.md)
  prefs: []
  type: TYPE_NORMAL
- en: 'Add sequence(first: next:) and sequence(state: next:) [SE-0094]'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Swift 3 introduces two new global functions that operate on sequences: `sequence(first:next:)`'
  prefs: []
  type: TYPE_NORMAL
- en: and `(state:next:)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the full definitions below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'These two functions were added as replacements to the C-style for loops that
    were removed in Swift 3 and to serve as a compliment to the global reduce function
    that already exists in Swift 2\. What''s interesting about the additions is that
    each function has the capability of generating and working with infinite sized
    sequences. Let''s examine the first sequence function to get a better understanding
    of how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The first sequence method returns a sequence that is created from repeated
    invocations of the *next* parameter, which holds a closure that will be lazily
    executed. The return value is an `UnfoldSequence` that contains the `first` parameter
    passed to the sequence method plus the result of applying the *next* closure on
    the previous value. The sequence is finite if `next` eventually returns `nil`
    and is infinite if `next` never returns *nil*. In the example that follows, we
    create and assign our sequence using the trailing closure form of `sequence(first:
    next:)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Our finite sequence will begin with 1.1 and will call `next` repeatedly until
    our next result is greater than 2 at which case `next` will return `nil`. We could
    easily convert this to an infinite sequence by removing our condition that our
    previous value must not be greater than 2\. The second sequence function maintains
    mutable state that is passed to all lazy calls of `next` to create and return
    a sequence. Let''s consider an example using the second method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This version of the sequence function uses a passed in closure that allows you
    to update the mutable state each time `next` is called. As was the case with our
    first sequence function, a finite sequence ends when `next` returns a `nil`. You
    can turn a finite sequence into an infinite one by never returning `nil` when
    `next` is called.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create an example of how this version of the sequence method might be
    used. Traversing a hierarchy of views with nested views or any list of nested
    types is a perfect task for using the second version of the sequence function.
    Let's create a an Item class that has two properties. A name property and an optional
    parent property to keep track of the item's owner. The ultimate owner will not
    have a parent, meaning the parent property will be `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's define an Item class to use in our example to demonstrate usage of these
    new concepts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Next, we create a parent and two nested children items. Parent of `child1` will
    be the parent item and parent of `child2`  will be `child1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to create our sequence. The sequence needs two parameters from
    us: a `state` parameter and a `next` closure. I made the state an `Item` with
    an initial value of `child2`. The reason for this is because I want to start at
    the lowest leaf of my tree and traverse to the ultimate parent. Our example only
    has three levels, but you could have lots of levels in a more complex example.
    As for the *next* parameter, I''m using a closure expression that expects a mutable
    Item as its state. My closure will also return an optional Item. In the body of
    our closure, I use our current Item (mutable state parameter) to access the Item''s
    parent. I update the state and return the parent.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: There are some gotchas here that I want to address so that you will better understand
    how to define your own next closure for this sequence method.
  prefs: []
  type: TYPE_NORMAL
- en: The state parameter could really be anything you want it to be. It's for your
    benefit in helping you determine the next element of the sequence and to give
    you relevant information about where you are in the sequence. One idea to improve
    our example above would be to track how many levels of nesting we have. We could
    have made our state a tuple that contained an integer counter for the nesting
    level along with the current item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next closure needs to be expanded to show the signature. Because of Swift's
    expressiveness and conciseness when it comes to closures, you might be tempted
    to convert the *next* closure into a shorter form and omit the signature. Do not
    do this unless your *next* closure is extremely simple and you are positive that
    the compiler will be able to infer your types. Your code will be harder to maintain
    when you use the short closure format and you won't get extra points for style
    when someone else inherits it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't forget to update your state parameter in the body of your closure. This
    really is your best chance to know where you are in your sequence. Forgetting
    to update the state will probably cause you to get unexpected results when you
    try to step through your sequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make a clear decision ahead of time about whether you are creating a finite
    or infinite sequence. This decision is evident in how you return from your next
    closure. An infinite sequence is not bad to have when you are expecting it, however,
    if you iterate over this sequence using a `for…in` loop, you could get more than
    you bargained for, provided you were assuming this loop would end.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new model for collections and indices [SE-0065]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Swift 3 introduces a new model for collections that moves the responsibility
    of the index traversal from the index to the collection itself. To make this a
    reality for collections, the Swift team introduced four areas of change:'
  prefs: []
  type: TYPE_NORMAL
- en: The Index property of a collection can be any type that implements the *Comparable*
    protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swift removes any distinction between intervals and ranges; leaving just ranges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private index traversal methods are now public
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes to ranges make closed ranges work without the potential for errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read the proposal at the following link [https://github.com/apple/swift-evolution/blob/master/proposals/0065-collections-move-indices.md](https://github.com/apple/swift-evolution/blob/master/proposals/0065-collections-move-indices.md)
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Collection protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Swift 3, Foundation collection types such as Arrays, Dictionaries, and Sets
    are generic types that implement the newly created Collection protocol. This change
    was needed in order to support traversal on the collection. If you want to create
    custom collections of your own, you will need to understand the Collection protocol
    and where it lives in the Collection protocol hierarchy. We are going to cover
    the important aspects to the new collection model to ease you transition and to
    get your ready to create custom collection types of your own.
  prefs: []
  type: TYPE_NORMAL
- en: The Collection protocol builds on the Sequence protocol to provide methods for
    accessing specific elements when using a collection. For example, you can use
    a collection's `index(_:offsetBy:)` method to return an index that is a specified
    distance away from the reference index.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In our example above, we create the `twoAheadIndex` constant to hold the position
    in our numbers collection that is two positions away from our starting index.
    We simply use this index to retrieve the value from our collection using subscript
    notation.
  prefs: []
  type: TYPE_NORMAL
- en: Conforming to the Collection protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you would like to create your own custom collections, you need to adopt
    the Collection protocol by declaring `startIndex` and `endIndex` properties, a
    subscript to support access to your elements, and the `index(after: )` method
    to facilitate traversing your collection''s indices.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we are migrating existing types over to Swift 3, the migrator has some
    known issues with converting custom collections. It's likely that you can easily
    resolve the compiler issues by checking the imported types for conformance to
    the Collection protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you need to conform to the Sequence and IndexableBase protocols
    as the Collection protocol adopts them both.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'A simple custom collection could look like the following example. Notice that
    I have defined my `Index` type to be an `Int.` In Swift 3, you define the index
    to be any type that implements the Comparable protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The Collection protocol has default implementations for most of its methods,
    the Sequence protocols methods, and the IndexableBase protocols methods. This
    means you are only required to provide a few things of your own. You can, however,
    implement as many of the other methods that make sense for your collection.
  prefs: []
  type: TYPE_NORMAL
- en: New Range and associated indices types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Swift 2''s `Range<T>`, `ClosedInterval<T>`, and `OpenInterval<T>` are going
    away in Swift 3\. These types are being replaced with four new types. Two of the
    new range types support general ranges with bounds that implement the Comparable
    protocol: `Range<T>` and `ClosedRange<T>`. The other two range types conform to
    `RandomAccessCollection`. These types support ranges whose bounds implement the
    Strideable protocol.'
  prefs: []
  type: TYPE_NORMAL
- en: Last, ranges are no longer iterable since ranges are now represented as a pair
    of indices. To keep legacy code working, the Swift team introduced an associated
    Indices type, which is iterable. In addition, three generic types were created
    to provide a default *Indices* type for each type of collection traversal category.
    The generics are `DefaultIndices<C>`, `DefaultBidirectionalIndices<C>`, and `DefaultRandomAccessIndices<C>`;
    each stores its underlying collection for traversal.
  prefs: []
  type: TYPE_NORMAL
- en: Quick takeaways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I covered a lot of stuff in a just a few pages on collection types in Swift
    3\. Here are the highlights to keep in mind about the collections and indices.
  prefs: []
  type: TYPE_NORMAL
- en: Collection types (built-in and custom) implement the Collection protocol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating over collections has moved to the Collection - the index no longer
    has that ability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can create your own collections by adopting the Collection protocol. You
    need to implement:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`startIndex` and `endIndex` properties,'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The subscript method to support access to your elements
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And the `index(after: )` method to facilitate traversing your collection''s
    indices.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Closure changes for Swift 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A closure in Swift is a block of code that can be used in a function call as
    a parameter or assigned to a variable to execute their functionality at a later
    time. Closures are a core feature to Swift and are familiar to developers that
    are new to Swift as they may remind them of lambda functions in other programming
    languages. For Swift 3, there were two notable changes that I will highlight in
    this section. The first change deals with inout captures. The second is a change
    that makes non-escaping closures the default.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting inout Capture of @noescape Closures [SE-0035]
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Swift 2, capturing `inout` parameters in an escaping closure is difficult
    for developers to understand. Some closures are assigned to variables and then
    passed to functions as arguments. If the function that contains the closure parameter
    returns from its call and the passed in closure is used later, then you have an
    escaping closure. On the other hand, if the closure is only used within the function
    to which it is passed and not used later, then you have a non-escaping closure.
    The distinction is important here because of the mutating nature of `inout` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: When we pass an `inout` parameter to a closure, there is a possibility that
    we will not get the result we expect due to how the `inout` parameter is stored.
    The `inout` parameter is captured as a shadow copy and is only written back to
    the original if the value changes. This works fine most of the time. However,
    when the closure is called at a later time (that is, when it escapes), we don't
    get the result we expect. Our shadow copy can't write back to the original. Let's
    look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the example above, we get what we expect. We have created a closure to increment
    our passed in `inout` parameter and then return the new parameter multiplied by
    10\. When we check the value of *seed* after the closure is called, we see that
    the value has increased to `11`.
  prefs: []
  type: TYPE_NORMAL
- en: In our second example, we modify our closure to return a function instead of
    just an `Int` value. We move our logic to the closure that we are defining as
    our return value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This time when we execute the `modifiedClosure` with our `seed` value we get
    a function as the result. After executing this intermediate function, we check
    our *seed* value and see that the value is unchanged; even though we are still
    incrementing the `seed` value.
  prefs: []
  type: TYPE_NORMAL
- en: These two slight differences in syntax when using `inout` parameters generate
    different results. Without knowledge of how shadow copy works, it would be hard
    to understand the difference in results. Ultimately, this is just another situation
    where you receive more harm than good by allowing this feature to remain in the
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read the proposal at the following link [https://github.com/apple/swift-evolution/blob/master/proposals/0035-limit-inout-capture.md](https://github.com/apple/swift-evolution/blob/master/proposals/0035-limit-inout-capture.md)
  prefs: []
  type: TYPE_NORMAL
- en: Resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Swift 3, the compiler now limits `inout` parameter usage with closures to
    non-escaping (`@noescape`). You will receive an error if the compiler detects
    that your closure escapes when it contains `inout` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Making non-escaping closures the default [SE-0103]
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In previous versions of Swift, the default behavior of function parameters whose
    type was a closure was to allow escaping. This made sense as most of the Objective-C
    blocks (closures in Swift) imported into Swift were escaping. The delegation pattern
    in Objective-C, as implemented as blocks, was composed of delegate blocks that
    escaped. So why would the Swift team want to change the default to non-escaping
    as the default? Let's look at examples in Swift 2.2 and Swift 3 to get a better
    understanding of why this change makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift 2.2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In Swift 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The Swift team believes you can write better functional algorithms with non-escaping
    closures. An additional supporting factor is the change to require non-escaping
    closures when using `inout` parameters with the closure *[SE-0035]*. All things
    considered, this change will likely have little impact on your code. When the
    compiler detects that you are attempting to create an escaping closure, you will
    get a warning that you are possibly creating an escaping closure. You can easily
    correct the error by adding `@escaping` or via the `fixit` that accompanies the
    error.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read the proposal at the following link [https://github.com/apple/swift-evolution/blob/master/proposals/0103-make-noescape-default.md](https://github.com/apple/swift-evolution/blob/master/proposals/0103-make-noescape-default.md)
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we covered changes to collections and closures. We learned about
    the new Collection protocol that forms the base of the new collection model and
    how to adopt the protocol in our own custom collections. The new collection model
    made a significant change in moving collection traversal from the index to the
    collection itself. The new collection model changes are necessary in order to
    support Objective-C interactivity and to provide a mechanism to iterate over the
    collections items using the collections itself. As for closures, we also explored
    the motivation for the language moving to non-escaping closures as the default.
    We also learned how to properly use `inout` parameters with closures in Swift
    3\. In the next chapter, we are will cover more type changes and type aliases
    within protocols and protocol extensions.
  prefs: []
  type: TYPE_NORMAL
