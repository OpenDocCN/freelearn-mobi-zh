<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Working with XML and JSON Data</h1></div></div></div><p>For years, I used <strong>Extensible Markup Language</strong> (<strong>XML</strong>) as the format of choice to exchange data between systems. Its simplicity, readability, and ease of use made it an easy choice. The only real drawback with XML, in my opinion, is the large size of XML documents. Mobile devices, such as iOS devices, rely on exchanging data over mobile networks when they are not connected to a Wi-Fi network. These mobile networks are generally slower than a standard Wi-Fi or cabled networks. Most mobile devices also have data plans that limit the amount of data a user can use in a given month. That was when I really started looking at using <strong>JavaScript Object Notation</strong> (<strong>JSON</strong>) to exchange data between systems. Now, I almost exclusively use JSON to exchange data, especially with mobile devices. Even though, for mobile development, JSON seems to be becoming the format of choice, XML is still very widely used because it is generally easier to read and use than JSON. As a developer, it is a good idea to have a working knowledge of both formats.</p><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Parsing XML documents</li><li class="listitem" style="list-style-type: disc">Building XML documents</li><li class="listitem" style="list-style-type: disc">Parsing JSON documents</li><li class="listitem" style="list-style-type: disc">Building JSON documents</li></ul></div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec48"/>XML and JSON</h1></div></div></div><p>It was <a class="indexterm" id="id385"/>not that long ago that most consumer-based applications were self-contained and did not need to exchange data with external services. However, in <a class="indexterm" id="id386"/>today's age of smartphones and data-driven applications, it is now rare to develop applications that do not need to exchange data with external services. This makes it essential for application developers to know how to exchange data in standard formats.</p><p>These <a class="indexterm" id="id387"/>days, API designers tend to favor one of the two formats to exchange data—XML or JSON. There have been a number of other data exchange formats that have been promoted over the years, but XML and JSON are, by far, the current leaders. The primary reason for this is that the openness and interoperability of XML and JSON are unmatched by the other data exchange formats. It would be hard to find a public web API that does not offer XML and/or JSON to exchange data.</p><p>Apple has <a class="indexterm" id="id388"/>provided simple and efficient APIs to work with both XML and JSON data. While there are a number of third-party libraries and frameworks that offer certain advantages and disadvantages over Apple's APIs, in this chapter we will stick with Apple's APIs. Let's look at how we will parse XML and JSON documents with Swift, but first let's create some common files that we will use for the XML and JSON examples in the chapter.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec49"/>Common files</h1></div></div></div><p>Let's start <a class="indexterm" id="id389"/>by creating a structure that will be used to define the tags that are valid for our XML and JSON documents. These tags will be:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">books</code>: This is the root element that encloses all the other elements</li><li class="listitem" style="list-style-type: disc"><code class="literal">book</code>: This element encloses all the information about a particular book</li><li class="listitem" style="list-style-type: disc"><code class="literal">author</code>: This element contains the author's name</li><li class="listitem" style="list-style-type: disc"><code class="literal">publisher</code>: This element contains the publisher's name</li><li class="listitem" style="list-style-type: disc"><code class="literal">category</code>: This element contains the category of the book</li><li class="listitem" style="list-style-type: disc"><code class="literal">description</code>: This element contains the description of the book</li><li class="listitem" style="list-style-type: disc"><code class="literal">name</code>: This is an attribute of the book element in the XML example and a standard element in the JSON example. This element contains the name of the book</li></ul></div><p>The <code class="literal">DocTags</code> structure will define the seven static properties that will contain the names of these seven tags. This following code shows how to define this structure:</p><div><pre class="programlisting">struct DocTags {
  static let BOOKS_TAG = "books"
  static let BOOK_TAG = "book"
  
  static let AUTHOR_TAG = "author"
  static let PUBLISHER_TAG = "publisher"
  static let NAME_TAG = "name"
  static let CATEGORY_TAG = "category"
  static let DESCRIPTION_TAG = "description"
}</pre></div><div><div><h3 class="title"><a id="note17"/>Note</h3><p>Rather than using a structure, we could define our document tags in an enum instead. Which one we use is really a matter of preference.</p></div></div><p>Each of <a class="indexterm" id="id390"/>the seven properties defined in the <code class="literal">DocTags</code> structure is defined with the <code class="literal">static</code> and <code class="literal">let</code> keywords. The <code class="literal">static</code> keyword defines the properties as <code class="literal">static</code> properties. A <code class="literal">static</code> property is one that is not associated with any given instances of the structure, and any changes to a <code class="literal">static</code> property are reflected in all the instances of the structure. The advantage a <code class="literal">static</code> property has over an <code class="literal">instance</code> property is that we do not need to create an instance of the structure to use it.</p><p>Next, we will need to create a class that will contain the information about each book. We will name this class <code class="literal">Book</code>:</p><div><pre class="programlisting">class Book {
  var name = ""
  var author = ""
  var publisher = ""
  var category = ""
  var description = ""
}</pre></div><div><div><h3 class="title"><a id="note18"/>Note</h3><p>While Apple recommends that we use value types (structs and enums) over reference types (classes), in the examples for this chapter a reference type is preferred so we can pass the actual instance of our book type as we build it rather than the value.</p></div></div><p>As we can see, the <code class="literal">Book</code> class contains five properties. These properties will contain information about each book.</p><p>While we are parsing the XML and JSON documents, we will be able to retrieve each element of the document and the value stored within the element; therefore, we will need a way to take that information and set the values of the <code class="literal">Book</code> properties. With this in mind, let's create a helper function that will take the name of the element and the value associated with it as parameters. We will then set the appropriate property, based on the name of the element. Let's name this function <code class="literal">addValue</code> and add it to our <code class="literal">Book</code> class:</p><div><pre class="programlisting">func addValue(tagName: String, withValue value: String) {
  switch tagName {
  case DocTags.NAME_TAG:
    self.name = value
  case DocTags.AUTHOR_TAG:
    self.author = value
  case DocTags.PUBLISHER_TAG:
    self.publisher = value
  case DocTags.CATEGORY_TAG:
    self.category = value
  case DocTags.DESCRIPTION_TAG:
    self.description = value
  default:
    break
  }
}</pre></div><p>The <code class="literal">addValue</code> function<a class="indexterm" id="id391"/> will use a <code class="literal">switch</code> statement to compare the element name to each of the tags defined in the <code class="literal">DocTags</code> structure. If a match is found, it will set the value of the appropriate property. If no match is found, it will skip that element; normally, we should be able to simply ignore the extra tags.</p><div><div><h3 class="title"><a id="note19"/>Note</h3><p>Generally, the parser code, which we will see next, is not too bad when we are dealing with one class as in this example. When you start to work with more complex XML and JSON documents, which might require multiple classes, having helper methods such as the <code class="literal">addValue</code> method can significantly clean up the parsing code and make it much easier to read. These helper functions can be in their own class or part of the data storage class (as shown in the preceding example), depending on what works best for your particular application. Usually, I prefer the helper functions separated from the data storage class.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec50"/>XML and the NSXMLParser class</h1></div></div></div><p>To parse<a class="indexterm" id="id392"/> XML documents in Swift, we will use Apple's <code class="literal">NSXMLParser</code> class. While there are several alternatives to <code class="literal">NSXMLParser</code>, each with its own advantages and disadvantages, I have always found <code class="literal">NSXMLParser</code> to be simple to understand and use. It is also designed in a way that is consistent with Apple's other APIs, which means if we are familiar with Apple's other APIs, <code class="literal">NSXMLParser</code> will seem pretty straightforward.</p><p>The<a class="indexterm" id="id393"/> <code class="literal">NSXMLParser</code> class is a <a class="indexterm" id="id394"/>
<strong>Simple API for XML</strong> (<strong>SAX</strong>) parser. SAX parsers provide a mechanism to parse XML documents sequentially. Unlike <a class="indexterm" id="id395"/>
<strong>Document Object Model</strong> (<strong>DOM</strong>) parsers, which read the entire document into the memory <a class="indexterm" id="id396"/>and then parse it, a SAX parser reports on each parsing event as it happens. This allows for a much smaller memory footprint while parsing. It also means that we need to have code to handle each parsing event that is needed to parse the XML document.</p><p>The <code class="literal">NSXMLParser</code> class<a class="indexterm" id="id397"/> can parse XML documents from a URL, an <code class="literal">NSData</code> object, or through a stream. To parse XML documents from various sources, we initiate the <code class="literal">NSXMLParser</code> class with the appropriate initializer:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Init(contentsOfURL:)</code>: This initiates the <code class="literal">NSXMLParser</code> class with the content referenced by the provided URL</li><li class="listitem" style="list-style-type: disc"><code class="literal">Init(data:)</code>: This initiates the <code class="literal">NSXMLParser</code> class with the content of the <code class="literal">NSData</code> object</li><li class="listitem" style="list-style-type: disc"><code class="literal">Init(stream:)</code>: This initiates the <code class="literal">NSXMLParser</code> class with the content from the supplied stream</li></ul></div><p>For this<a class="indexterm" id="id398"/> chapter's XML example, we will be using the <code class="literal">init(data:)</code> initializer to parse a string representation of an XML document. The <code class="literal">NSData</code> class is designed to work with binary data. The initializer can be easily replaced by any of the other initializers to parse an XML document from a URL or stream. The XML parsing example will be designed to parse the following XML document:</p><div><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;books&gt;
  &lt;book name="iOS and OS X Network Development Cookbook"&gt;
    &lt;author&gt;Jon Hoffman&lt;/author&gt;
    &lt;publisher&gt;PacktPub&lt;/publisher&gt;
    &lt;category&gt;Programming&lt;/category&gt;
    &lt;description&gt;Network development for iOS and OS X&lt;/description&gt;
  &lt;/book&gt;
  &lt;book name="Mastering Swift"&gt;
    &lt;author&gt;Jon Hoffman&lt;/author&gt;
    &lt;publisher&gt;PacktPub&lt;/publisher&gt;
    &lt;category&gt;Programming&lt;/category&gt;
    &lt;description&gt;Learning Swift&lt;/description&gt;
  &lt;/book&gt;
&lt;/books&gt;</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec51"/>Using the NSXMLParserDelegate protocol</h1></div></div></div><p>The <code class="literal">NSXMLParserDelegate</code> protocol <a class="indexterm" id="id399"/>defines several optional methods that can be defined by the <code class="literal">NSXMLParser</code> delegate. These methods are called when certain parsing events occur while <code class="literal">NSXMLParser</code> is parsing XML documents. The <code class="literal">NSXMLParserDelegate</code> method may also define several optional methods that are used to handle the <a class="indexterm" id="id400"/>
<strong>Document Type Definition</strong> (<strong>DTD</strong>) markup. The DTD markup defines the legal document structure of an XML document by defining a list of valid elements and attributes.</p><p>We will be <a class="indexterm" id="id401"/>implementing the following delegate methods for the XML example in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">parserDidStartDocument(_:)</code>: This method is called when the parser begins parsing the XML document</li><li class="listitem" style="list-style-type: disc"><code class="literal">parserDidEndDocument(_:)</code>: This method is called after the parser has successfully parsed the entire XML document</li><li class="listitem" style="list-style-type: disc"><code class="literal">parser(_: didStartElement: namespaceURI: qualifiedName: attributes:)</code>: This method is called when the parser encounters a start tag for an element</li><li class="listitem" style="list-style-type: disc"><code class="literal">parser(_: didEndElement: namespaceURI: qualifiedName:)</code>: This method is called when the parser encounters an end tag for an element</li><li class="listitem" style="list-style-type: disc"><code class="literal">parser(_:parseErrorOccurred:)</code>: This method is called when the parser encounters a critical error and is unable to parse the document</li><li class="listitem" style="list-style-type: disc"><code class="literal">parser(_:foundCharacters:)</code>: This method is called to provide a string representation of all or part of the characters of the data for thecurrent element</li></ul></div><p>Let's take a look at how we will parse XML documents with <code class="literal">NSXMLParser</code> and <code class="literal">NSXMLParserDelegate</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec52"/>Parsing XML documents</h1></div></div></div><p>To parse an <a class="indexterm" id="id402"/>XML document we begin by creating a class or struct that conforms to the <code class="literal">NSXMLParaseDelegate</code> protocol. In our example, we will name the class <code class="literal">MyXMLParser</code>. Our <code class="literal">MyXMLParser</code> class definition will look like this:</p><div><pre class="programlisting">class MyXMLParser: NSObject, NSXMLParserDelegate {

  }</pre></div><p>Within the <code class="literal">MyXMLParser</code> class, we will add three properties that will be used by the parser while it is parsing the document. These three properties are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">books</code>: This property will be an optional array that will contain the list of books defined in the XML document</li><li class="listitem" style="list-style-type: disc"><code class="literal">book</code>: This will be an optional instance of the <code class="literal">Book</code> class that represents the current book being parsed within the XML document</li><li class="listitem" style="list-style-type: disc"><code class="literal">elementData</code>: This will be an instance of the string class that contains the value of the current element that is being parsed</li></ul></div><p>These <a class="indexterm" id="id403"/>properties will be defined like this:</p><div><pre class="programlisting">var books: [Book]?
var book: Book?
var elementData = ""</pre></div><p>Now we need to add the <code class="literal">NSXMLParserDelegate</code> methods. The first one we add will be the <code class="literal">parseXmlString</code> method, which will be used to start the <code class="literal">NSXMLParser</code> class:</p><div><pre class="programlisting">func parseXmlString(xmlString: String) {
   let xmlData = xmlString.dataUsingEncoding(NSUTF8StringEncoding)
   let parser = NSXMLParser(data: xmlData!)
   parser.delegate = self
   parser.parse()
}</pre></div><p>We begin the <code class="literal">parseXmlString()</code> method by converting the <code class="literal">xmlString</code> variable to an <code class="literal">NSData</code> object using the <code class="literal">dataUsingEncoding()</code> method. The <code class="literal">dataUsingEncoding()</code> method comes from the <code class="literal">NSString</code> class, but we can use it with our Swift string type because Swift automatically bridges Swift string types to the <code class="literal">NSString</code> classes.</p><p>We then use the <code class="literal">init(data:)</code> initializer to initialize <code class="literal">NSXMLParser</code>. This initializer is called like this:</p><p>
<code class="literal">NSXMLParser(data: xmlData!)</code>
</p><p>We then set the <code class="literal">NSXMLParser</code> delegate to the current instance of the <code class="literal">MyXmlParser</code> class. We can do this because the <code class="literal">MyXmlParser</code> class conforms to the <code class="literal">NSXMLParserDelegate</code> protocol. This allows the current instance of the class to receive alerts as the document is being parsed.</p><p>Finally, the <code class="literal">parse()</code> method is called to begin parsing the XML document.</p><p>Now let's add the <code class="literal">parserDidStartDocument()</code> method. This method will be called when <code class="literal">NSXMLParser</code> begins parsing the XML document:</p><div><pre class="programlisting">func parserDidStartDocument(parser: NSXMLParser!) {
  println("Started XML parser")
}</pre></div><p>In our example, we do not need to perform any setup prior to parsing the document; therefore, the <code class="literal">parserDidStartDocument()</code> method just prints the <code class="literal">Started XML Parser</code> message to the console.</p><p>Now, let's look at the <code class="literal">parser(_: didStartElement: namespaceURI: qualifiedName: attributes:)</code> delegate method. Before we implement this delegate method, we need to figure out which elements require us to perform tasks when we encounter their start tags. In our example, we will need to check for the starting tags of two elements—<code class="literal">books</code> and <code class="literal">book</code>.</p><p>The <code class="literal">books</code> element is the root element that encloses all the items in the XML document. When we encounter the <code class="literal">books</code> element start tag, we will need to initialize the <code class="literal">books</code> array. This <code class="literal">books</code> array will contain a list of book instances that are generated as we parse the XML document.</p><p>When we <a class="indexterm" id="id404"/>encounter the start tag for the <code class="literal">book</code> element, we will need to create a new instance of the <code class="literal">Book</code> class because the start tag means we are starting a new book. We might think that we should also save the current instance of the <code class="literal">book</code> property to the <code class="literal">books</code> array prior to creating a new instance, but we will do that when we encounter the <code class="literal">book</code> end tag rather than the start tag. The implementation always seems to be much cleaner when we save information based on an end tag rather than a start tag.</p><p>Here is the code for the <code class="literal">parser(_: didStartElement: namespaceURI: qualifiedName: attributes:)</code> delegate method:</p><div><pre class="programlisting">func parser(parser: NSXMLParser, didStartElement elementName: String, namespaceURI: String?, qualifiedName qName: String?, attributes attributeDict: [String : String]) {
    if elementName == DocTags.BOOKS_TAG {
        books = []
    } else if elementName == DocTags.BOOK_TAG {
        book = Book()
        if let name = attributeDict[DocTags.NAME_TAG] {
            book!.addValue(DocTags.NAME_TAG, withValue: name as!)
        }

    }
}</pre></div><p>We begin this method by seeing whether the <code class="literal">elementName</code> parameter is equal to the <code class="literal">books</code> tag and, if so, we create a new array that will contain the books defined in the XML document. If the <code class="literal">elementName</code> parameter is not equal to the <code class="literal">books</code> tag, we check to see whether it is equal to the <code class="literal">Book</code> tag. If it is equal to the <code class="literal">book</code> tag, we set the <code class="literal">book</code> property to a new instance of the <code class="literal">book</code> class, clearing any previous saved information. We then check whether the element has an attribute with the <code class="literal">name</code> key (<code class="literal">name</code>) and, if so, we set the <code class="literal">name</code> property of the <code class="literal">book</code> instance to the value of that attribute. This instance of the <code class="literal">Book</code> class will contain the information about the book.</p><p>The next delegate method that we will implement is the <code class="literal">parser(_:foundCharacters:)</code> delegate method. This method receives the value or partial value of the element that is being parsed.</p><div><pre class="programlisting">func parser(parser: NSXMLParser, foundCharacters string: String) {
  elementData += string
}</pre></div><p>Since the value of any given element may be quite large, we may receive the value in pieces rather <a class="indexterm" id="id405"/>than in one chunk. This means that the <code class="literal">parser(_:foundCharacters:)</code> method may be called multiple times for the same element. In our example, we use the <code class="literal">elementData</code> property to keep track of the value of the current element; thus, in the <code class="literal">parser(_:foundCharacters:)</code> method, we simply append the value of the string parameter to the <code class="literal">elementData</code> property. We will clear the <code class="literal">elementData</code> property when we encounter an end tag for an element.</p><p>Next, let's see how to use the <code class="literal">parser(_: didEndElement: namespaceURI: qualifiedName:)</code> delegate method when the parser encounters the end tag of an element. Before we implement this method, we need to figure out what elements we require to perform a task when we encounter their end tag. In our example, we will need to check whether we encountered the end tag of a <code class="literal">book</code> element. If we encountered any other tag besides the end of the <code class="literal">book</code> element, we will use the <code class="literal">addValue()</code> method of the <code class="literal">book</code> instance to determine what to do with the value.</p><p>When we encounter the end tag for the <code class="literal">book</code> element, we will need to add the current instance of the <code class="literal">book</code> property to the <code class="literal">books</code> array. If this is an end tag for any other element, we will call the <code class="literal">addValue()</code> method of the current book instance, remembering that the <code class="literal">addValue()</code> method will ignore any element if it does not recognize the element's name.</p><p>We will also need to clear the <code class="literal">elementData</code> property each time we encounter the end of an element so that the information from the previous element does not corrupt the next element.</p><p>The following example shows how we will implement the <code class="literal">parser(_: didEndElement: namespaceURI: qualifiedName:)</code> delegate method:</p><div><pre class="programlisting">func parser(parser: NSXMLParser, didEndElement elementName: String, namespaceURI: String?, qualifiedName qName: String?) {
    if elementName == DocTags.BOOK_TAG {
        if let myBook = book {
            if var _ = books {
                books!.append(myBook)
            }
        }
        book = Book()
    } else if let myBook = book {
        myBook.addValue(elementName, withValue: elementData)
    }
    elementData = ""
}</pre></div><p>When the parser has completed parsing the document, it will call the <code class="literal">parser(_:parseErrorOccurred:)</code> delegate method. In our example, we will use this method to simply print <a class="indexterm" id="id406"/>the name of the book and author to the screen for each book in the <code class="literal">books</code> array, as shown in the following code:</p><div><pre class="programlisting">func parserDidEndDocument(parser: NSXMLParser) {
  if let myBooks = books {
    for myBook in myBooks {
      println("Found - \(myBook.name) \(myBook.author)")
    }
  }
}</pre></div><p>If an error is encountered while parsing the document, the <code class="literal">parser:parseErrorOccurred:</code> delegate method is called to handle the error. In our example, we will print the error to the console, but normally we would need to properly handle the error:</p><div><pre class="programlisting">func parser(parser: NSXMLParser parseErrorOccurred parseError: NSError {
  print"Parse Error occurred (parseError)")
}</pre></div><p>To parse an XML document, we will use the <code class="literal">MyXmlParser</code> class like this:</p><div><pre class="programlisting">var xmlParser = MyXMLParser()
xmlParser.parseXmlString(xmlString)</pre></div><p>Now that we have seen how to parse an XML document, let's take a look at how we create one.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec112"/>XML and NSXMLDocument</h2></div></div></div><p>The <a class="indexterm" id="id407"/>
<code class="literal">NSXMLDocument</code> class and its related classes make it very easy to create XML documents from our custom object; however, they are only available to OS X-based projects at the time of writing this book. Hopefully, someone at Apple will realize that we need a good way to build XML documents for iOS projects without using third-party frameworks or manually creating the document.</p><p>To build an XML document with Swift for OS X-based applications, we will need to use three foundation classes. These classes are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">NSNode</code>: This class is the superclass of the <code class="literal">NSXMLDocument</code> and <code class="literal">NSXMLElement</code> classes. This will be used to add attributes to an instance of the <code class="literal">NSXMLElement</code> class.</li><li class="listitem" style="list-style-type: disc"><code class="literal">NSXMLDocument</code>: This class is the top-level object for the XML document.</li><li class="listitem" style="list-style-type: disc"><code class="literal">NSXMLElement</code>: All the elements in the XML document are instances of the <code class="literal">NSXMLElement</code> class.</li></ul></div><p>Let's see <a class="indexterm" id="id408"/>how to use these three classes to build an XML document. For this, we will create a function named <code class="literal">buildXMLString(books:)</code>, which takes an array of the <code class="literal">Book</code> objects as its only parameter:</p><div><pre class="programlisting">func buildXMLString(books: [Book]?)] -&gt; String {
  if let myBooks = books {
    let xmlRoot = NSXMLElement(name: DocTags.BOOKS_TAG)
    let xmlData = NSXMLDocument(rootElement: xmlRoot)
    for book in myBooks {
      let bookElement = NSXMLElement(name: DocTags.BOOK_TAG)
      xmlRoot.addChild(bookElement)
      let nameAttribute = NSXMLNode.attributeWithName(DocTags.NAME_TAG, stringValue:book.name) as NSXMLNode
      bookElement.addAttribute(nameAttribute)
      bookElement.addChild(NSXMLElement(name: DocTags.AUTHOR_TAG, stringValue: book.author))
      bookElement.addChild(NSXMLElement(name: DocTags.CATEGORY_TAG, stringValue: book.category))
      bookElement.addChild(NSXMLElement(name: DocTags.DESCRIPTION_TAG, stringValue: book.description))
      bookElement.addChild(NSXMLElement(name: DocTags.PUBLISHER_TAG, stringValue: book.publisher))
    }
    return xmlData.XMLString
  }
  else {
    return ""
  }
}</pre></div><p>Since the <code class="literal">books</code> parameter is defined as optional, we begin the <code class="literal">buildXMLString()</code> function by verifying it is not null using the <code class="literal">if let myBooks = books</code> line. If it is null, we return an empty string; otherwise, we begin building the XML document.</p><p>The initializer that we are using for the <code class="literal">NSXMLDocument</code> class requires the root element for the XML document; therefore, we will begin by creating the <code class="literal">xmlRoot</code> constant using the <code class="literal">BOOKS_TAG</code> constant and then using it to create an instance of the <code class="literal">NSXMLDocument</code> class. Next, we loop through each instance of the <code class="literal">Book</code> class in the <code class="literal">books</code> array.</p><p>For each instance of the <code class="literal">Book</code> class, we create a new instance of the <code class="literal">NSXMLElement</code> class with the book name, which will contain the information about the book. This element will be the <code class="literal">&lt;Book&gt;&lt;/Book&gt;</code> element in our XML document. All the information about the book will either be an attribute of this element or a child element of this element.</p><p>The name of the book is an attribute of the <code class="literal">book</code> element; therefore, we need to create an instance of the <code class="literal">NSXMLNode</code> class that contains the attribute's name and value. We do this with the <code class="literal">NXMLNode.attributeWithName()</code> function. We then add that attribute to the <code class="literal">book</code> element using the <code class="literal">addAttribute()</code> function.</p><p>Next, we add the <a class="indexterm" id="id409"/>remaining information about the book (<code class="literal">author</code>, <code class="literal">category</code>, <code class="literal">description</code>, and <code class="literal">publisher</code>) as child nodes to the <code class="literal">book</code> element using the <code class="literal">addChild()</code> function.</p><p>Finally, we convert the <code class="literal">NSXMLDocument</code> class to a string using the <code class="literal">XMLString</code> property and return that string to the code that called the function.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec53"/>XML and manually building XML documents</h1></div></div></div><p>Since we are <a class="indexterm" id="id410"/>unable to use the <code class="literal">NSXMLNode</code>, <code class="literal">NSXMLDocument</code>, and <code class="literal">NSXMLElement</code> classes in iOS projects, we generally need to manually build the XML string or use third-party libraries. This method is error-prone and it requires us to have a very good knowledge of how XML documents are built but, if we are careful, we can create simple XML documents this way.</p><p>Let's see how to manually create an XML document. For this, we will create a function named <code class="literal">builXMLString()</code>, which takes an array of <code class="literal">Book</code> objects as its only parameter. We will also create a helper class named <code class="literal">getElementString()</code> that will create a string representation of an XML element. The <code class="literal">getElementString()</code> function will accept two elements: the element name and value. Let's have a look at the following code:</p><div><pre class="programlisting">func buildXMLString(books: [Book]?) -&gt; String {
  var xmlString = ""
  if let myBooks = books {
    xmlString = "&lt;\(DocTags.BOOKS_TAG)&gt;"
    for book in myBooks {
      xmlString += "&lt;\(DocTags.BOOK_TAG) \(DocTags.NAME_TAG)=\"\(book.name)\"&gt;"
      xmlString += getElementString(DocTags.AUTHOR_TAG, elementValue: book.author)
      xmlString += getElementString(DocTags.CATEGORY_TAG, elementValue: book.category)
      xmlString += getElementString(DocTags.DESCRIPTION_TAG, elementValue: book.description)
      xmlString += getElementString(DocTags.PUBLISHER_TAG, elementValue: book.publisher)
      xmlString += "&lt;\\\(DocTags.BOOK_TAG)&gt;"
    }
    xmlString += "&lt;\\\(DocTags.BOOKS_TAG)&gt;"
  }
  return xmlString
}
func getElementString(elementName: String, elementValue: String) -&gt;String {
  return "&lt;\(elementName)&gt;\"\(elementValue)\"&lt;\\\(elementName)&gt;"
}</pre></div><p>Since the <a class="indexterm" id="id411"/>
<code class="literal">books</code> parameter is defined as optional, we begin the <code class="literal">buildXMLString()</code> function by verifying it is not null with the <code class="literal">if let myBooks = books</code> line. If it is null, the function will return an empty string; otherwise, we begin building the XML document.</p><p>In this class, we simply create strings that represent the XML tags and append them to the <code class="literal">xmlString</code> variable. The <code class="literal">xmlString</code> variable will contain the XML document at the end of the function.</p><p>The <code class="literal">getElementString()</code> function creates a string that contains the start tag for the element, followed by the value of the element and the end tag for the element. This function is used to add most of the XML elements in this example.</p><p>As we can see, without an intimate knowledge of the syntax of XML documents, it would be virtually impossible to build complex documents with this method. We also need to be very careful to not to forget the closing tags at the end of an element.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec54"/>JSON and NSJSONSerialization</h1></div></div></div><p>To<a class="indexterm" id="id412"/> serialize and deserialize JSON documents, we will use the <code class="literal">NSJSONSerialization</code> class. As we will see, it is much easier to use the <code class="literal">NSJSONSerialization</code> class with JSON documents than it is to use the <code class="literal">NSXMLParser</code> class with XML documents; however, it can be more error-prone when we try to access the information. Just remember to always check values that are defined as optional for null prior to accessing them.</p><p>The<a class="indexterm" id="id413"/> <code class="literal">NSJSONSerialization</code> class, unlike the <code class="literal">NSXMLParser</code> class, will parse the entire JSON document memory and then return a JSON object; therefore, there is a lot less code to write but it is more memory-intensive, however.</p><p>The <code class="literal">NSJSONSerialization</code> class can parse JSON documents from an <code class="literal">NSData</code> object or through a stream. To parse JSON documents from the various sources, we use the <code class="literal">NSJSONSerialization</code> class with the appropriate static method:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">JSONObjectWithData(_: options: error:)</code>: This initializer will parse a JSON document stored as an <code class="literal">NSData</code> object</li><li class="listitem" style="list-style-type: disc"><code class="literal">JSONObjectWithStream(_: options: error:)</code>: This initializer will parse a JSON document from a stream</li></ul></div><p>The documentation for these two methods says that they return an optional of the <code class="literal">AnyObject</code> type. Generally, the<a class="indexterm" id="id414"/> results of these methods are in an instance <a class="indexterm" id="id415"/>of the <code class="literal">NSDictionary</code> or an <code class="literal">NSArray</code> class, depending on the JSON document. If you are unsure what type of object is being created, you can insert the following code, where the <code class="literal">jsonResponse</code> variable is the result returned from the two static methods:</p><div><pre class="programlisting">switch jsonResponse {
case is NSDictionary:
  // Code to parse a NSDictionary
case is NSArray:
  // Code to parse an NSArray
default:
  // Code to handle unknown type
}</pre></div><p>In the preceding code, we use the <code class="literal">is</code> operator to check whether the response is of the <code class="literal">NSDictionary</code> or <code class="literal">NSArray</code> type.</p><p>Unlike the <code class="literal">NSXMLParser</code> class, the <code class="literal">NSJSONSerialization</code> class can be used to also create JSON documents from a collection object. To do this, we will use the <code class="literal">dataWithJSONObject(_: options: error:)</code> initializer, which will serialize a JSON document from a collection object. While it is possible to use other objects besides collection objects to create the JSON document, a proper JSON document is usually in the format of a dictionary or an array.</p><p>In the JSON examples in this chapter, we will show you how to parse the following JSON document. This document contains the same information that was in the XML example, but it is stored as a JSON document now, as shown in the following code:</p><div><pre class="programlisting">{
  "books": [
    {
      "name": "iOS and OS X Network Development Cookbook",
      "author": "Jon Hoffman",
      "publisher": "PacktPub",
      "category": "Programming",
      "description": "Network development for iOS and OS X"
    },
    {
      "name": "Mastering Swift",
      "author": "Jon Hoffman",
      "publisher": "PacktPub",
      "category": "Programming",
      "description": "Learning Swift"
    }
  ]
}</pre></div><p>Let's see how to parse a JSON document that is stored as a string.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec113"/>Parsing a JSON document</h2></div></div></div><p>In this<a class="indexterm" id="id416"/> section, we will use the <code class="literal">NSJSONSerialization</code> class to parse the previously shown JSON documents. The <code class="literal">jsonString</code> variable in this function represents the JSON document that was previously shown. This function will create an array of <code class="literal">Book</code> objects based on the information in the JSON document. At the end of the function, we will print out the information about the books to show that they were correctly parsed from the document, as well as return the array of books, as shown in the following code:</p><div><pre class="programlisting">func parseJson() throws {
    var myBooks: [Book] = []
    let jsonData = jsonString.dataUsingEncoding(NSUTF8StringEncoding)
    if let data = jsonData {
    
        let jsonDoc : AnyObject = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.AllowFragments)
        
        if let books = jsonDoc.objectForKey(DocTags.BOOKS_TAG) as? NSArray {           
            for var i=0; i &lt; books.count; i++ {
                if let dict = books.objectAtIndex(i) as? NSDictionary {
                    let book = Book()
                    addValueToBook(book, elementName: DocTags.AUTHOR_TAG, elementValue: (dict.objectForKey(DocTags.AUTHOR_TAG) as? String))
                    addValueToBook(book, elementName: DocTags.CATEGORY_TAG, elementValue: (dict.objectForKey(DocTags.CATEGORY_TAG) as? String))
                    addValueToBook(book, elementName: DocTags.DESCRIPTION_TAG, elementValue: (dict.objectForKey(DocTags.DESCRIPTION_TAG) as? String))
                    addValueToBook(book, elementName: DocTags.NAME_TAG, elementValue: (dict.objectForKey(DocTags.NAME_TAG) as? String))
                    addValueToBook(book, elementName: DocTags.PUBLISHER_TAG, elementValue: (dict.objectForKey(DocTags.PUBLISHER_TAG) as? String))
                    myBooks.append(book)
                }
            }
            
            for book in myBooks {
                print("Found - \(book.name) \(book.author)")
            }
        }
    }
}</pre></div><p>The <code class="literal">parseJson()</code> function <a class="indexterm" id="id417"/>starts off by converting the <code class="literal">jsonString</code> variable that contains the JSON document to an <code class="literal">NSData</code> object so that we can parse it with the <code class="literal">NSJSONSerialization</code> object. Since the conversion results in an optional value, we need to verify that it is not null. We do this with the following line of code:</p><div><pre class="programlisting">if let data = jsonData</pre></div><p>If the conversion was successful, we can then use the <code class="literal">JSONObjectWithData()</code> method of the <code class="literal">NSJSONSerialization</code> class to create the JSON object from the <code class="literal">NSData</code> object we just created.</p><p>Knowing that in our JSON document, the root tag of <code class="literal">books</code> contains an array of books, we use the following line to attempt to retrieve the array from the JSON object we just created:</p><div><pre class="programlisting">if let books = jsonDoc.objectForKey(DocTags.BOOKS_TAG) as? NSArray</pre></div><p>This line of code checks that the object is not null and is also an instance of the <code class="literal">NSArray</code> class. If the JSON object is supposed to contain an <code class="literal">NSDictionary</code> object, we would simply replace the <code class="literal">as? NSArray</code> with <code class="literal">as? NSDictionary</code>.</p><p>If we were able to successfully retrieve the <code class="literal">NSArray</code> class from the JSON object, then we loop through each item of the <code class="literal">NSArray</code> class. In our example, each item of the <code class="literal">NSArray</code> class is in an instance of the <code class="literal">NSDictionary</code> class; however, it is always a good idea to verify this. To verify that each item is an instance of the <code class="literal">NSDictionary</code> class, we use the following code:</p><div><pre class="programlisting">if let dict = books[i] as? NSDictionary </pre></div><p>Once we have the <code class="literal">NSDictionary</code> object, we use the <code class="literal">addValueToBook()</code> function (that we will see in just a minute) to populate the properties of the <code class="literal">Book</code> class.</p><p>Finally, we end the function by printing out the name and author of each book that we extracted from the JSON document. Let's take a look at the <code class="literal">addValueToBook()</code> function that we use to populate the properties of the <code class="literal">Book</code> class:</p><div><pre class="programlisting">func addValueToBook(book: Book, elementName: String, elementValue: String?) {
    if let value = elementValue {
      book.addValue(elementName, withValue: value)
    }
}</pre></div><p>If we attempt to extract a value from an <code class="literal">NSDictionary</code> object where the key does not exist, the <code class="literal">NSDictionary</code> object will return a null object. In this case, we need to verify that the value is <a class="indexterm" id="id418"/>not null prior to assigning it to a property that does not accept a null value. The <code class="literal">addValueToBook()</code> function verifies that the values are not null prior to adding them to the instance of the <code class="literal">Book</code> class.</p><div><div><h3 class="title"><a id="note20"/>Note</h3><p>When using the <code class="literal">NSJSONSerialization</code> class, it is better to have too many checks rather than not enough. Just remember if we try to set a non-optional variable to nil or use an object that is nil, our application will crash. JSON documents are not type-safe; therefore, it is also advisable to check the types of the values returned to make sure they are of the expected type.</p></div></div><p>Now, let's see how to create a JSON document with the <code class="literal">NSJSONSerialization</code> class.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec114"/>Creating a JSON document</h2></div></div></div><p>Creating a<a class="indexterm" id="id419"/> JSON document using the <code class="literal">NSJSONSerialization</code> class is incredibly easy but, once again, we need to do several checks to make sure nothing goes wrong. The following code will create a valid JSON document from any object that can be converted to JSON data, such as dictionaries and/or arrays:</p><div><pre class="programlisting">func buildJSON(value: AnyObject) throws -&gt; String {
    if NSJSONSerialization.isValidJSONObject(value) {
        let data = try NSJSONSerialization.dataWithJSONObject(value, options: [])
        if let string = NSString(data: data, encoding: NSUTF8StringEncoding) {
           return string as String
        }
    }
    return ""
}</pre></div><p>The first thing we do in the <code class="literal">buildJSON()</code> function is to verify that the <code class="literal">value</code> parameter is of a type that can be converted to a JSON object. We do this using the <code class="literal">isValidJSONObject()</code> function of the <code class="literal">NSJSONSerialization</code> class. This function will return a Boolean <code class="literal">true</code> value if the <code class="literal">value</code> parameter can be converted; otherwise, it will return a Boolean <code class="literal">false</code> value.</p><p>If the <code class="literal">value</code> parameter can be converted to a JSON object, then we use the <code class="literal">dataWithJSONObject()</code> function of the <code class="literal">NSJSONSerialization</code> class to convert the value parameter to JSON data. If there is an issue with the conversion, the <code class="literal">dataWithJSONObject()</code> function throws an error, which is thrown back to the code that called the <code class="literal">buildJSON()</code> function..</p><p>Finally, we convert the <a class="indexterm" id="id420"/>JSON data to a <code class="literal">String</code> object and return it to the code that called the function. If anything goes wrong, we return an empty string.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec55"/>Summary</h1></div></div></div><p>In this chapter, we saw that it takes a lot less code to parse/build JSON objects with the <code class="literal">NSJSONSerialization</code> class as compared to parsing/building XML objects. However, we do have a lot more control on how the document is parsed using the <code class="literal">NSXMLParser</code> class. The key thing to keep in mind with both the <code class="literal">NSJSONSerialization</code> class and the <code class="literal">NSXMLParser</code> class is that we need to remember to check that optional variables do not contain a nil value, before attempting to use them.</p><p>While it seems that the majority of newer services are using the JSON format over XML, it is good to have a working knowledge of both formats because there is still a large percentage of services that use XML.</p></div></body></html>