- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing Your Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B18653_05.xhtml#_idTextAnchor163), we covered the essential
    aspects of the Swift language. In this chapter, we will cover more topics related
    to iOS development, such as UIKit and various frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for iOS interviews is mostly around Swift, UIKit, and coding. It is
    obvious why – these are the bread and butter of iOS development. But being an
    iOS developer is much more than that.
  prefs: []
  type: TYPE_NORMAL
- en: In my experience, developers who know how to plan their tasks, solve/test complex
    bugs, and document their work are true professionals, regardless of their code
    quality. I think that this is what separates a good developer from a true pro-iOS
    developer.
  prefs: []
  type: TYPE_NORMAL
- en: In a good and effective hiring process, these skills are tested as part of the
    manager interview or the home assessment stage, and we should be ready for them.
    Unlike most other topics, the *principles* for good quality work are vital to
    remember here.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following four main topics in managing our project:'
  prefs: []
  type: TYPE_NORMAL
- en: We will ensure that we have the capability to *plan* our projects and features
    and gain knowledge on how to develop a technical document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will cover *testing*, not only unit testing but also integration and performance
    tests. We will also learn what it means to write testable code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will go over *debug* techniques for different types of issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will answer some questions about *documentation* – how to comment correctly
    and handle documentation as part of a bigger team.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s start with the essential part of this chapter, in my opinion: planning.'
  prefs: []
  type: TYPE_NORMAL
- en: Planning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Planning and design are both critical aspects of being a developer, certainly
    a senior one. Many think of “planning” as a way to estimate delivery dates, but
    the delivery date is really only a tiny part of the story.
  prefs: []
  type: TYPE_NORMAL
- en: 'The real story behind planning is going down to the details. In my perspective,
    planning is equal to learning. When we plan, we perform research about our task,
    trying to understand the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Can we *understand the product requirements* and translate them into tasks?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are our *dependencies* with other teams/developers?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What things do we need to perform *additional research*? Do we need a **Proof
    of** **Concept** (**POC**)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What tasks will be complicated, and what tasks will be simple?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are we handling *edge cases*? Can we define them?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we plan, we consider different aspects and challenges we may encounter.
    Therefore, “planning” is much more than estimation; it is really a learning session.
  prefs: []
  type: TYPE_NORMAL
- en: Being a professional means learning our task before we start it. From my experience,
    not all interviews emphasize that point. In many hiring processes, planning is
    not even a part of the interview.
  prefs: []
  type: TYPE_NORMAL
- en: I advise bringing it up even if we are not explicitly asked for it. We are interested
    in leading the conversation with our interviewer to the places where we want to
    show our strengths.
  prefs: []
  type: TYPE_NORMAL
- en: “How do you create a project timeline and plan for the iOS app’s development
    process?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to many questions we’ll find in this book, this one also doesn’t have
    a clear right or wrong answer. But the interviewer doesn’t care about the answer’s
    details. Their main goal is to assess our experience, organization skills, and
    our development process point of view.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B18653_02.xhtml#_idTextAnchor041), we talked about “soft skills.”
    Planning and time management are indeed essential soft skills our interviewer
    wants to see. An iOS developer who understands how to plan, challenges and dependencies,
    manage time, and prioritize tasks is a great addition to the team.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless of the details we are required to provide, there are three points
    we need to ensure to highlight in our answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Demonstrate our experience**: Providing examples, approaches, and lessons
    learned is a great way to show we understand and have handled challenges in the
    past.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Show we understand the development process**: Task management, estimation,
    resources, and priority are all good examples of tools that can help us to provide
    a good plan.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Show we can collaborate**: Working on a development project involves heavy
    collaboration. We need to highlight the fact that we are not working alone. Collaboration
    means task ownership, collaborative tech design, reviews, dependencies, and working
    with designers, QA teams, product managers, and backend developers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why are these steps crucial to highlight? Because, in most cases, we are joining
    an existing team and project. Understanding what a good and healthy process looks
    like is essential.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s dive into a standard framework for a project planning process:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand the *project’s requirements*, purpose, and audience.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Break the project down* into small, manageable tasks: design, coding, and
    testing.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Provide a development *estimation for each task* and a result: a timeline.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign *resources* between the different team members.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Monitor* progress to ensure we are on time.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Testing* and deployment.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to look at this question as a chance to bring our point of view and
    experience to the table while taking a standard process and breaking it down into
    the three key points I mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: “How do you estimate development time for a task?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: Time estimation is one of the most challenging tasks for developers, and how
    we approach task estimation shows our experience.
  prefs: []
  type: TYPE_NORMAL
- en: Development time estimation is both a soft and hard skill.
  prefs: []
  type: TYPE_NORMAL
- en: On the one hand, it requires a broad technical knowledge of the development
    challenges and risks, breaking them into smaller tasks and managing them.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, we need good communication skills to work with other teammates,
    excellent time management skills, and the ability to analyze dependencies that
    can affect our schedule.
  prefs: []
  type: TYPE_NORMAL
- en: After all, we chose to develop professional iOS applications, and that’s a complex
    job to do…
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: The answer is similar to the previous answer about the project timeline. The
    difference is that in task estimation, it is simpler to get into the small details
    and understand the risks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go over the list of the stages we need to go through:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand the *requirements*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Break* them down into small sub-tasks.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Assess the complexity* of each sub-task, and consider any potential risks
    and challenges. If needed, research such risks or even create a POC to understand.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Consider dependencies* to make sure we are not blocked from moving forward
    with our development process.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add more time for *reviewing and refining* the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I think that point number three is perhaps the most important. When a development
    task doesn’t meet its estimation goals, it is primarily because of risks we didn’t
    consider. It is hard to go wrong when setting up a standard **user interface**
    (**UI**) screen, but the unknown issues are what make our task overdue.
  prefs: []
  type: TYPE_NORMAL
- en: “How do you create a technical design document for an iOS task?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: This is a question that continues from the previous two. We started with project
    planning and task time estimation, and now we are trying to understand how to
    design a single development task.
  prefs: []
  type: TYPE_NORMAL
- en: Technical document creation encapsulates our expertise in approaching a technical
    task. Even if we don’t usually write technical documents, the process of designing
    a feature from a technical point of view is crucial for developers.
  prefs: []
  type: TYPE_NORMAL
- en: Put aside the suggested answer – try to go over technical documents you’ve used
    in the past and retrieve what the process that led to this output was. Bringing
    your own experience to the table is the best answer because it will be easier
    to explain.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'A technical document contains the following topics: introduction, requirements,
    architecture, flows, data model, testing, and deployment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the following steps to create it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Plan and research**: Collect information about the project, including requirements
    and constraints.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Outline the document**: Write the sections and sub-sections to ensure we
    are not missing any important topic.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Describe the requirements**: Specify requirements in detail.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Discuss the system architecture**: Describe the system architecture in detail.
    Write down the different layers involved in the feature.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Define the data model**: Describe the entities and the different API calls.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Specify the user interface**: Include screens, UI components, and navigation
    flows.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Outline the testing strategy**: Include types of testing, tools, and goals.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Discuss the deployment process**: Include beta rollout, A/B testing, and
    app versions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s important to say that most, if not all, of the steps I detailed are not
    explicitly related to Swift – this is one of the good things about this question.
    Planning is a language and platform-agnostic task, and you can find plenty of
    people that can help you understand how to approach a technical document design
    even if you haven’t done one before.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is a crucial part of being an iOS developer. It ensures our codebase’s
    quality and reliability and improves levels of confidence in our projects.
  prefs: []
  type: TYPE_NORMAL
- en: Questions about testing in interviews are much more than just technical. Writing
    a unit test is an easy task and can be learned quickly. But experience in testing
    shows a different side of us as iOS developers. It offers our approach to managing
    a reliable and healthy code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Do we write tests after a bug fix?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How simple is it to test our code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the test role in the deployment process?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Being a professional doesn’t mean just writing good code but also maintaining
    it well.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike most topics in this book, it is difficult to gain knowledge of testing
    without having some experience. I advise you to take one of your projects and
    write some tests. You need to feel it with your fingers before you approach the
    interview.
  prefs: []
  type: TYPE_NORMAL
- en: “What is the meaning of unit and integration testing in the context of iOS development?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: The testing world is full of different terms and approaches. Defining unit tests
    and integration tests is essential because they represent different use cases
    and coverage.
  prefs: []
  type: TYPE_NORMAL
- en: This question aims to see whether we have enough experience understanding the
    different use cases.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: A **unit test** checks the behavior of an individual component, while an **integration
    test** checks how different components work together.
  prefs: []
  type: TYPE_NORMAL
- en: It’s crucial to consider the app’s context when investing more time in unit
    or integration testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example – unit tests mainly check logic functions such as the following
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the preceding code block tests a specific logic function. It
    doesn’t care about other app components such as the network, core data, or the
    app state, but rather isolates the scope to the function itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, an integration test checks a use case that involves multiple
    layers and functions, such as a network request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows how we can test how two layers of our project work
    together. The network layer can work well, as can the local function of `apiClient`.
    But when working together, we may encounter a problem, and that’s an integration
    test.
  prefs: []
  type: TYPE_NORMAL
- en: Most iOS apps need integration tests over unit tests because most functions
    handle user interaction and different app layers versus logic code. This is an
    essential insight into the balance between integration and unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: “How do you perform performance testing in iOS applications?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance testing** is less common in iOS development than unit or integration
    testing and is considered a more advanced topic. This question aims to gauge your
    depth of knowledge and experience in testing. It is a good idea to set up one
    performance test to understand how it works, but there is no need to have significant
    experience with it.'
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a performance test is much simpler than it sounds. The first thing
    we need to do is to choose the function or code block we want to measure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, we need to write a test function that performs that code block, usually
    multiple times. Why do we need to run it multiple times? Because it is simpler
    for us to measure a test run with big numbers. If one test run takes around 3–4
    milliseconds, it will be hard to measure the change over time. But if we run it
    100 times, it will be much easier to measure any small tweaks we can make in the
    function’s code. Let’s see what a performance test looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `XCTest` framework uses the average running time as a baseline, and every
    time the test is run, `XCTest` compares the results to that baseline.
  prefs: []
  type: TYPE_NORMAL
- en: One disadvantage of performance tests is that their results depend on the device
    they run on. It is best practice to ensure performance tests run *on the same
    device*, preferably an actual device and not a simulator.
  prefs: []
  type: TYPE_NORMAL
- en: “Can you explain what it means to write a testable code?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: Sure, we are now talking about tests, but **testable code** is much more than
    preparing our codebase for tests – it is about writing code that we can easily
    maintain and decouple.
  prefs: []
  type: TYPE_NORMAL
- en: In this question, interviewers like to see that we understand what makes code
    testable, ensuring our code can be maintained easily.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: Writing testable code means writing code designed to make it easy to write unit,
    integration, and performance tests for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, testable code means the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Keep the principle of separation of concerns**: When each part of our code
    base has a single, clear responsibility, it is easier to test a use case without
    requiring several layers or classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ensure loose coupling**: High coupling makes it hard to test one component
    independently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Design our objects for easy mocking**: A clean, well-defined interface can
    help our objects to be easily mocked. One great example is the usage of **Protocol
    Oriented** **Programming** (**POP**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use more pure functions**: Pure functions are functions that don’t have a
    shared state or side effects. They are isolated in a way that makes them very
    easy to test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an example of testable versus non-testable code. I’ll start with the
    testable version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And now the non-testable code version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, we can see that the `add()` method takes two parameters
    and use them solely to return a result.
  prefs: []
  type: TYPE_NORMAL
- en: However, in the second example, we see a function dependent on two `UserDefaults`
    keys that may return different results each time we run it. In testable code,
    we should get the same results each time we run the test, so that’s not an excellent
    example of testable code.
  prefs: []
  type: TYPE_NORMAL
- en: That’s a great example of testable versus non-testable code snippets.
  prefs: []
  type: TYPE_NORMAL
- en: Tests are a crucial part of interviews, much more than they used to be several
    years ago. The reason is that tests are not a topic of their own – they represent
    a whole approach to development, code design, and maintenance. Tests are a clear
    win in terms of our striving for perfection.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A famous quote says:'
  prefs: []
  type: TYPE_NORMAL
- en: “Programming is not about being the best at writing code, it’s about being the
    best at debugging code.”
  prefs: []
  type: TYPE_NORMAL
- en: This quote sounds weird, right? But, when we think about it, we spend many coding
    hours debugging our (or others') code.
  prefs: []
  type: TYPE_NORMAL
- en: Our debugging skills can sometimes determine whether a phase lasts a few days
    or weeks.
  prefs: []
  type: TYPE_NORMAL
- en: One of the mistakes developers make when practicing for job interviews is focusing
    only on code writing and forgetting about debugging. But debugging is one of the
    most important tools we have as developers, and we can expect at least one or
    two debug questions in our interview.
  prefs: []
  type: TYPE_NORMAL
- en: “Can you explain how to debug memory leaks in iOS applications?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s be aligned on what a memory leak is. A memory leak doesn’t mean
    an app with high memory usage – that’s a widespread misconception.
  prefs: []
  type: TYPE_NORMAL
- en: A memory leak means an app was allocated memory for something and then stopped
    using it, but the memory space wasn’t released.
  prefs: []
  type: TYPE_NORMAL
- en: The result might be high memory usage, but increased memory usage does not indicate
    a memory leak.
  prefs: []
  type: TYPE_NORMAL
- en: Memory leaks are hard to debug but point to inefficient resource consumption
    and can lead to app termination. That’s why memory leak debugging is an important
    topic in iOS development.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Having said that, memory leaks are hard to debug. Fortunately, there are many
    ways to solve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Instruments**: Instruments is a powerful tool that comes with Xcode that
    can help us profile different aspects of our app, including memory allocations
    and leaks. It’s an advanced tool that can profile a specific object, log its retains/release
    operations, and even direct us to a particular location in our code base.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory graph debugging**: It’s a relatively new feature, and not many are
    aware of it yet. Using memory graph debugging, it is possible to stop the run
    at any point and look at the live objects list and the relationships between them.
    It can also highlight what it identifies as a memory leak and points to the reason.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NSZombie**: NSZombie is a tool that lets us detect and track elements before
    they are deallocated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **deinit** function: In certain cases, we can put a print statement or
    a breakpoint in the object’s **deinit()** function. The **deinit()** function
    gets called just before the object is deallocated. That’s a nice and simple way
    to see whether an object leaks without launching external and heavy tools.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory gauge**: We can use Xcode’s memory gauge regularly to see whether
    memory is being deallocated and doesn’t grow constantly. It’s a great sign we
    should investigate the issue further using the other tools on the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see, there are plenty of methods and tools to debug memory leaks in
    iOS. Some are there to *monitor our memory* consumption, and some are very advanced
    and *help detect* precisely where and when the leak occurs. The combination of
    the tools provides us with the perfect toolset to track and fix memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: “Can you explain how to debug UI-related issues in iOS applications?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: Up until now, most of the questions dealt with Swift only, without the context
    of the relevant layer of the framework. But moving forward with our book, we’ll
    find there is much more than Swift in iOS development. The UI is another main
    topic for iOS developers, and as part of it, debugging it is considered to be
    a very challenging task. If you have worked with UIKit, you have probably investigated
    issues with the UI throughout your career. The following answer organizes things
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: “UI-related” is an extensive definition of a problem. Some issues are related
    to the UI life cycle, some to user interaction, and others to layout and animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the answer can be divided into three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inspect the layout**: We have four primary ways to debug our UI layout:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Debug View Hierarchy**: Debug View Hierarchy is a built-in tool in Xcode
    that lets us debug our layout in runtime with a nice 3D view showing up the different
    layers of the screen, allowing us to inspect each layer for its properties, including
    color and layout. That’s a great way to understand how the UI is organized, how
    the Auto Layout equations mechanism works, and what the hierarchy is.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open Accessibility Inspector**: This tool is part of the Xcode development
    suite and can help us debug our views from an accessibility point of view. **Accessibility
    Inspector** is a less widely recognized tool that assists us in examining our
    application’s handling of accessibility issues.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Color our views**: This is a primitive yet helpful way to debug our UI. We
    can just set our views’ background or border colors in the code and then rerun
    the app to examine the results. Other tools are more advanced, but coloring our
    views can sometimes be a very fast and efficient way to debug, for example, in
    animations and sophisticated layouts.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simulator debug tools**: The iOS Simulator has built-in debug tools for our
    UI, including color views and slow animations. These are great for a quick look
    at our layout during runtime.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Life cycle debug**: Life cycle debug means debugging our screen’s various
    stages – when it is created, appears, pushed, and more. The way to do that is
    mainly around breakpoints and print statements. We can set breakpoints in life
    cycle methods such as **viewDidLoad** and **viewDidAppear**. Another great tip
    is to use **logs** to track UI flows. Following those logs can help us debug during
    development and also debug QA issues. We can also inspect life cycle events using
    the **Instruments Time Profiler** to track calls during screen launch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User interaction debugging**: We can also use the Accessibility Inspector,
    print to console, add breakpoints, and use **View Debugger** to understand the
    different hierarchies and properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many ways to debug a UI! And there’s a reason – UI debugging requires
    experience and many “hit and miss” tries, so we will need every possible tool.
  prefs: []
  type: TYPE_NORMAL
- en: “How do you debug performance issues in iOS applications?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: In today’s mobile development world, performance is not as big a topic as it
    used to be. We are now handling powerful devices, and most chances are that our
    product requirements are not even close to challenging the least powerful machine
    out there.
  prefs: []
  type: TYPE_NORMAL
- en: Bad coding and design can lead to annoying lags and long waited for operations.
    These are the cases where performance debugging can help us nail problems quickly.
  prefs: []
  type: TYPE_NORMAL
- en: This question tests a crucial skill set for an iOS developer, as users expect
    apps to be fast and responsive. It also checks the understanding of the iOS platform
    and the different debugging tools available.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ideal steps to take when debugging performance issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reproduce the performance issues**: Rerun the app and ensure we can quickly
    reproduce the problem. It’s not an obvious task at all – because we don’t know
    the issue’s root cause yet, we can’t tell for sure that the problem will be reproduced.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Profile the app**: Use the Instruments time profile and/or **Core Animation
    Instrument** to inspect the app and collect information about the problem.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Analyze the information**: Try to make an assumption about the cause of the
    issue.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Perform a fix or a change**: Implement some sort of solution. It doesn’t
    have to be the final solution; it can be some temporary code modification to isolate
    the issue.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Test and verify**: Rerun the app to see whether there’s a change. Restart
    the process if needed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that these steps are only an outline for a recommended debug procedure,
    and it is great for an interview answer. However, we should note that performance
    issues are more complex and may require additional or different steps.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Documentation questions are typically not included in technical job interviews,
    but they may be part of interviews whose purpose is to gain insight into us as
    developers.
  prefs: []
  type: TYPE_NORMAL
- en: However, documentation is an essential part of being an iOS developer, and that
    part gets a special place when we are part of a team.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some reasons why documentation is crucial:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Better collaboration**: Documentation makes it easier for multiple developers
    to work on the same code base, where they need to explain smaller parts of the
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improve code understanding**: Do you know what it’s like to write code and
    one week later look back and not understand why you did what you did? It is a
    common thing among developers. Documentation doesn’t eliminate that but can improve
    it dramatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Onboarding new members**: That’s a critical point. Explaining something to
    an old-timer developer is straightforward, but doing the same for a new team member
    is much more complex. That’s another reason why documentation plays a significant
    role here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improving code reviews**: A “code review” is an event where someone who didn’t
    write the code tries to read and understand it. It goes without saying why documenting
    it is a crucial thing to do.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at the list, we can understand why documentation is a powerful tool,
    especially in teams, and why it is not a part of the technical interview but rather
    part of the “personality” review. But documentation is an integral part of being
    a professional developer, so it is better to be prepared with examples and point-of-view
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: “Can you explain how you document your iOS code?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: We already went through why documentation is essential as an iOS developer.
    Now, the interviewer wants to see our techniques and approach to comments and
    documents.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: The basis of iOS code documentation is done using comments throughout the code
    base.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several types of comments we can use to document our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A “Why” comment**: This doesn’t need us to explain *what* we did, but rather
    *why* we did it (that’s a typical mistake developers make). These comments should
    be in places where there is a reason for our decision, but it is not reflected
    in the code. This comment can help other developers, but also we can benefit from
    that. Here’s an example of such a comment:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’re adding a comment that explains why we used `hashValue` and not the fact
    that we used it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Code organization**: One good use of comments is to organize code; a common
    practice is using a “pragma mark.” A pragma mark helps us separate our code into
    sections to be more readable and easier to navigate. Let’s see how to organize
    our code with pragma marks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Xcode knows how to read these types of comments and provides an easy way to
    jump between the different sections.
  prefs: []
  type: TYPE_NORMAL
- en: '**Method documentation**: We can document methods, properties, and classes
    using code-generation comments. These comments can be generated automatically
    by Xcode or other third-party tools and be a part of our project documentation.
    This can be done easily using the **/** **/** marks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The results of adding `@params` and `@return` information to our function declaration
    comment provide Xcode (or other relevant tools) the ability to automatically generate
    documentation similar to what we can find on Xcode Developer Documentation.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, it is important to understand the different types of comments to
    structure a good answer. A short answer such as “Explain what I do” is not a “pro”
    answer and doesn’t reflect our expertise.
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth saying that good naming conventions for methods, classes, and
    variables can make our code much more readable and self-explanatory and, by that,
    reduce the need for documentation.
  prefs: []
  type: TYPE_NORMAL
- en: “Can you explain how to document design patterns and best practices in iOS development?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: Technical design documents are not something junior or even mid-level developers
    do, but instead, senior developers and tech leads.
  prefs: []
  type: TYPE_NORMAL
- en: So, this question’s relevance depends on our interviewing role.
  prefs: []
  type: TYPE_NORMAL
- en: Also, our expertise in technical design documents is probably based on our current
    and previous workplaces. Small start-ups are not always strict about technical
    documents, and that’s something we can mention when receiving this question.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'A technical design document is not there just to create one. It is there to
    answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the *purpose* of the feature?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What were the *alternative* solutions?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why did we *choose* the selected solution?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the *preferred solution* in detail?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have these questions in mind, we understand that a technical document
    reflects the thinking process behind our solution and not just describes it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To document a feature, we need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Choose a format**: Choose a suitable format for the document that will be
    consistent across different features.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Include an introduction**: Explain the feature’s goal and what it includes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Discuss alternatives**: Explain the different ways to solve that feature
    and their tradeoffs.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Describe the selected option**: Describe the choice among the alternatives.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Describe the selected option in detail**: Provide code examples, diagrams,
    and flow charts to explain what we did.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is important to note that technical document formats and processes differ
    from place to place, but the idea stays the same. As long as we provide a detailed
    answer with confidence and understanding, it will be good enough to pass that
    question.
  prefs: []
  type: TYPE_NORMAL
- en: “How do you handle the documentation of code that multiple team members are
    developing?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: Writing documentation for ourselves is straightforward. Most likely, we can
    communicate with ourselves easily…
  prefs: []
  type: TYPE_NORMAL
- en: The real challenge starts when our code documentation needs to serve our teammates.
  prefs: []
  type: TYPE_NORMAL
- en: This question tests how we see code documentation as part of a team when we
    need to read and write such documentation and maintain it over time.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: There isn’t a magic answer for that, as it depends on culture, project, and
    team size.
  prefs: []
  type: TYPE_NORMAL
- en: 'But some best practices are helpful to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Establish a documentation standard**: The team must agree on some comments
    and document format guidelines. For example – what methods to comment? What types
    of comments to emphasize? How to explain design decisions? Guidelines are a great
    start to managing documentation in a team.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use a collaboration tool to manage documentation**: Plenty of collaboration
    tools can help us work on the same document with our teammates, including comments
    and discussions. We should take advantage of these tools to ensure the whole team
    participates in the documentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encourage collaboration**: This is not just using a collaboration tool. If
    we want everyone on the team to take part, we should encourage the team to review
    each other’s documentation and comment on their code as part of the code review.
    Remember – reviews are also part of the collaboration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Provide training**: Onboard new team members on how to comment and write
    documents. Training doesn’t have to be overhead – it can be short or as part of
    a weekly meeting. Cross-team alignment is essential to make sure our documentation
    is effective for everyone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following these guidelines is a great start to ensure the whole team is responsible
    for documentation *together* with high standards and motivation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed topics that are not directly related to coding,
    but as iOS developers, they are crucial. Remember that most mobile teams are small
    – sometimes, a team includes only one developer, so being a mature and professional
    developer is crucial.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is unique – instead of talking about coding, it examined quality
    and communication. These skills are harder to test and even harder to show in
    an interview. But in good workplaces with an effective process, these topics will
    pop up in one way or another.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will discuss perhaps the most crucial framework of
    iOS development: UIKit. No iOS interview can conclude without questions being
    asked about that framework.'
  prefs: []
  type: TYPE_NORMAL
