- en: Chapter 3. New Features of OpenGL ES 3.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing variable attributes with qualifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping uniforms and creating buffer objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing VBO with Vertex Array Objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and writing buffer objects with mapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering multiple objects with geometry instancing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering multiple primitives with primitive restart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenGL ES 3.0 was publicly released in August 2012\. It brings the mobile 3D
    graphics to the next level. This release was focused to provide 3D-enriched features
    and enhanced the portability across diverse mobiles, embedded operating systems,
    and platforms. OpenGL ES 3.0 is fully backward compatible with OpenGL ES 2.0\.
    This enables the applications to grow the graphics capabilities and visual features
    incrementally. OpenGL ES 3.0 also introduces a new version of **GL Shading Language**
    (**GLSL**) 3.0\. The GLSL is used for programing shaders. The new shading language
    has also extended the capabilities in many directions, which you will learn in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will be helpful in understanding the new features introduced in
    OpenGL ES 3.0 and GL shading language 3.0\. This book uses OpenGL ES 3.0 in conjunction
    with GLSL 3.0 for all its recipes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new features of OpenGL ES 3.0 can be broadly divided into the following
    five categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Geometry**: These features focus on the vertex attributes specifications,
    such as data storage, data transfer, attribute states, primitive assembly, and
    so on. They are explained as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transform feedback**: This feature allows us to capture the vertex shader
    output to provide feedback to the GPU for next frame rendering. This way, it avoids
    CPU intervention and makes the rendering efficient.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Occlusion query**: This enables fast hardware testing to check whether a
    pixel is going to appear on screen or whether it is occluded by another pixel.
    This kind of check is helpful in deciding whether to skip certain operations such
    as geometry processing because it''s occluded.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Geometry instancing**: This allows efficient rendering of an object multiple
    times without calling multiple render API''s. This is very helpful in situations
    such as crowd simulation, trees rendering, and so on.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Primitive restart**: This new feature allows us to render multiple disconnected
    primitives using a single drawing API call. The index array is used to pack multiple
    primitives (of the same type) in a single bundle. This array contains multiple
    disconnected primitives with a special marker that helps the GPU o render disconnected
    primitives in one go.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Textures**: There are many new features added into OpenGL ES 3.0 for textures.
    The features are described here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Depth textures and shadow comparison**: Depth textures allow the storing
    of the depth buffer information into a texture. This is helpful in rendering shadows
    using the **percentile closest filtering** (**PCF**) technique in which depth
    information is explicitly stored from the depth buffer to a texture using the
    render-to-texture technique. Later, this information is used to test incoming
    fragments for whether they are a part of shadow or not. OpenGL ES 3.0 allows this
    comparison test implicitly.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Seamless cube maps**: The cubemap rendering is improved to remove artifacts
    from the boundary edges of the images. Now, the filtering techniques take adjacent
    faces texture data into account to produce seamless texture boundaries on the
    face edges. You can refer to the *Implementing Skybox with seamless cube mapping*
    recipe in [Chapter 7](ch07.html "Chapter 7. Textures and Mapping Techniques"),
    *Textures and Mapping Techniques*.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ETC2/EAC texture-compression formats**: Before OpenGL ES 3.0, there was no
    standard compression format officially supported by OpenGL ES. Developers relied
    on the specific compression formats provided by different vendors, such as PVRTC
    by Imagination Technologies, **Ericsson Texture Compression** (**ETC**) by Sony
    Ericsson, ATC by Qualcomm, and so on. Now, ETC2 and EAC texture-compression formats
    are integrally supported in OpenGL ES 3.0\. Refer to the *Efficient rendering
    with ETC2 compressed texture* recipe in [Chapter 7](ch07.html "Chapter 7. Textures
    and Mapping Techniques"), *Textures and Mapping Techniques*.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nonpower of two** (**NPOT**) texture: Now, textures with pixel dimensions
    of the nonpower of two texture are supported with full wrap mode and mipmapping.
    In earlier specifications of OpenGL ES, the textures had to be in the form of
    power of two (POT) dimensions. Therefore, external imaging tools were required
    to convert NPOT to POT format.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Texture swizzles**: The GLSL provides a level of abstraction in accessing
    the components of texture, R, G, B, and A, irrespective of the order in which
    they are stored physically.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increased 2D texture dimension**: The dimension of 2D texture in OpenGL ES
    3.0 is 2048, which is much more compared to OpenGL ES 2.0.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3D texture**: OpenGL ES 3.0 supports 3D texture targets. 3D textures are
    widely used in medical imaging.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Arrays of 2D texture**: This new features allows us to store multiple 2D
    textures in the form of an array. This is useful for animation purpose. Prior
    to this, texture sprites were used.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shaders**: These are the special small programs that are used in modern computer
    graphics programming to control geometry and pixel color shading. The features
    on shaders are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Program binaries**: The vertex and fragment shaders are compiled and stored
    in a binary format. This binary format needs to be linked to the program at run
    time in OpenGL ES 2.0\. OpenGL ES 3.0 allows an optimization by storing this binary
    into an offline binary format that does not require linking at run time. This
    optimization helps load the application faster by avoiding runtime linking.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flat/smooth interpolators**: In OpenGL ES 2.0, all the interpolators perform
    linear interpolation across the primitives. With the help of GLSL 3.0, in OpenGL
    ES 3.0, the interpolation can be explicitly declared to have flat and smooth shading.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Buffer objects**: These allow us to store vertex data on the GPU memory.
    The new features have extended the capabilities of buffer objects to make them
    more efficient. Here are the new features:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uniform blocks**: This allows to group related uniform values into a single
    manageable group. This increases the readability of the shader program.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layout qualifiers**: The attributes defined in the vertex and fragment shaders
    can be directly bound to the user-defined locations. This way, the on-fly binding
    API calls are not required.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vertex Array Objects**: This feature provides an efficient way to bind vertex
    array data and respective attributes. **Vertex Array Objects** (**VAO**) are used
    to encapsulate the VBO. When a VAO API is called, it efficiently switches the
    states stored in VBO without calling several APIs. This reduces the overhead in
    the switching of vertex array states.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uniform buffer object**: This feature stores the uniform block in an efficient
    way as a buffer object. This uniform block object can be bound on fly time. This
    gives an opportunity to share the uniform data among multiple programs at once.
    Additionally, it allows us to set multiple uniform variables in one go.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subrange buffer mapping**: Unlike mapping the complete buffer from the GPU
    to the CPU side, this mechanism provides an efficient way to access a range of
    memory contents from the GPU memory space. Sometimes, the intention is to update
    only a small section of the buffer. Therefore, mapping the complete buffer is
    inefficient. In such situations, subrange buffer mapping reduces the time of marshaling
    from GPU to CPU to GPU.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Buffer object copies**: This mechanism transfers the data of one buffer object
    to the other one without intervening the CPU.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sync object**: This provides a synchronized mechanism between the applications
    and GPU. In this way, the application can assure completion of OpenGL ES operations
    on the GPU side.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fencing**: This feature informs the GPU to wait for queuing up new OpenGL
    ES operations until the old operations are completely executed on the GPU.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Framebuffer**: The new features also include enhancements related to off-screen
    rendering for the framebuffer. Here are the new features:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiple render target (MRT)**: This feature allows us to perform off-screen
    rendering simultaneously to several color buffers or textures at the same time.
    These textures can be used as input to other shaders or can be used on 3D models.
    MRTs are most commonly used to achieve deferred shading.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multisample render buffer**: This feature enables the application to perform
    off-screen framebuffer rendering with multisample anti-aliasing. This improves
    the visual quality of the generated image and reduces the jagged-line effect that
    appears in the lines or sharp geometry edges drawn diagonally to the screen.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will focus on the new features of geometry and buffer objects.
    As we progress with the upcoming chapters, we will also introduce the new features
    of shaders, textures, and framebuffers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can explore more about OpenGL ES 3.0 specifications and documentation on
    [http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.3.pdf](http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.3.pdf)
    and [http://www.khronos.org/opengles/sdk/docs/man3/](http://www.khronos.org/opengles/sdk/docs/man3/).
  prefs: []
  type: TYPE_NORMAL
- en: Managing variable attributes with qualifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GLSL 3.0 has introduced two new qualifiers: storage and layout. Let''s take
    a look at them in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Storage qualifier**: This is a special keyword that specifies the storage
    or the behavior of a global or local variable. It is used in shader programming.
    It enables the communication bridge between the application and shaders. It is
    also used to share information from one shader stage to another. For example,
    a 3D light illumination technique requires an object''s geometry information in
    order to create realistic light shading. This geometry information is calculated
    in the vertex shader and passed to the fragment shader, where this input is used
    to color the fragments of the geometric primitives.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are six types of storage qualifiers available in GL SL 3.0\. They are
    described in the following table:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| Qualifier | Meaning |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `const` | This is the value of variable does not alter compile time. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `in` | This is the copied input variable from the previous stage, which is
    linked to the current shader. If specified in a function argument, this is an
    input variable. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `centroid in` | This is the input type variable linked to the centroid interpolator.
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `out` | This is the copied input variable from the previous stage, which
    is linked to the current shader. If specified in a function argument, this is
    an output variable. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `centroid out` | This is the output type variable that is linked to the centroid
    interpolator. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `uniform` | This is the value of the variables does not change across the
    primitives during the processing. The uniforms are shared across the shaders.
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '**Layout qualifier**: This influences the properties of a variable, such as
    storage, location, memory alignment, and so on. This qualifier is widely used
    in declaring the location of the variable(s) in shaders. Each variable or generic
    attribute declared in the shader is stored in an allocated memory location on
    the GPU. This memory location is used to store data in the variables as a result
    of runtime calculation or input data from the previous stage of the shader. Unlike
    C/C++ pointers, the shading language uses a location ID to access the variable.
    A location is an ID (numeric value(s)) of a variable that is used to connect the
    variable present in the shading language to the application program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next table specifies the syntax for the storage and layout qualifiers. The
    storage qualifiers are mentioned before the data type of the variable. The most
    commonly used qualifiers are in and out. These storage qualifiers tell us whether
    the vertex attribute is an incoming or outgoing variable.
  prefs: []
  type: TYPE_NORMAL
- en: The layout qualifier assigns an ID or location to the vertex attribute so that
    run the binding and querying of the location can be avoided. The layout qualifier
    is always mentioned before the storage qualifier.
  prefs: []
  type: TYPE_NORMAL
- en: '| Qualifier | Syntax |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Storage | `(storage qualifier) [Data type] [Variable Name]` |'
  prefs: []
  type: TYPE_TB
- en: '| Layout | `layout (qualfier1, qualifier2 = value, . . .) [Storage qualifier]`
    |'
  prefs: []
  type: TYPE_TB
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The variables in a shader are abstracted in the form of location IDs. Each variable
    or generic attribute is recognized using its location ID and used to bind the
    data in the OpenGL ES program. These location IDs/indexes can be defined using
    the `location` keyword in the layout qualifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our first recipe, we will demonstrate the use of storage and layout qualifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a vertex shader `LayoutVertex.glsl`, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the fragment shader `LayoutFragment.glsl` and modify it, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Reuse the *Efficient rendering with Vertex Buffer Object* recipe [Chapter 2](ch02.html
    "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES 3.0 Essentials* and define
    the location index according to your choice in the application program, `Cube.cpp`.
    Make sure that the same index is specified in the shader program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the VBO and IBO in the constructor and enable the following attributes
    like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Attach the VBO geometry data to the location ID. This will be used to send
    data from application to the GPU shader processor. Clearly, with the layout qualifier,
    the location query (`glGetAttribLocation`) for the vertex attribute can be avoided:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OpenGL ES program defines two index ID's in `Cube.cpp`, `VERTEX_LOCATION`
    and `COLOR_LOCATION` for vertex and color data, respectively. These indices will
    be used to define the attribute location in the shader program. The programmer
    must ensure that the layout location ID used in the shader program for the attribute
    must be same as the one used in the OpenGL ES program. This can be achieved by
    declaring the variable attributes using the layout qualifier. Prefixing the `layout`
    keyword in conjunction with the `location` qualifier allows the user-defined locations
    to attach with attribute variables. If some attribute variables are not specified
    by user-defined location indices, then the compiler would automatically generate
    and assign them.
  prefs: []
  type: TYPE_NORMAL
- en: In the shader program, `VertexPosition` and `VertexColor` are assigned to the
    same location indices, `0` and `1`, respectively, what was defined in the OpenGL
    ES program. These two variable declarations are of the `vec4` type, which is prefixed
    with the storage qualifier `in`. This gives information that these two variables
    are input to the vertex shader from the OpenGL ES program. The geometry data (vertex
    and color) is sent to the vertex shader by attaching the data to the location
    indexes of `VertexPosition` and `VertexColor` using the `glVertexAttribPointer`
    API in the `RenderCube` function. It should be noted that the generic attribute
    variables must be enabled before they are attached using the `glEnableVertexAttribArray`
    API. This recipe enables them in the `Cube` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: When the vertex shader receives an input data for vertices in `VertexPosition`
    and transformation coordinates in the uniform `MODELVIEWPROJECTIONMATRIX`, it
    uses these two variables as an input argument to the `calculatePosition` function
    to calculate the transformed position of the incoming vertex. This calculated
    position returns to the main function as an output storage qualifier in the variable
    called position. The `calculatePosition` function is introduced in this recipe
    to demonstrate another possible use of storage qualifiers in the local scope of
    the shader program.
  prefs: []
  type: TYPE_NORMAL
- en: The `Color` variable uses the incoming value of `VertexColor` and passes it
    to the next stage in which the fragment shader consumes this value to assign the
    color to the fragments. In order to send data from the vertex shader to fragment
    shader, both shaders should use the same attribute variable name. The storage
    qualifier for the vertex shader must be defined as `out` since it is producing
    an output data for fragment shader. In contrast, the fragment shader must be specified
    with the `in` storage qualifier, as this receives the data from the previous stage.
    The fragment shader demonstrates another way of using return values from the shader
    programming functions.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the current recipe, you learned how to bind the location indices of the generic
    attribute variables in OpenGL ES from the shader program using layout qualifiers.
    As an alternative, the `glBindAttribLocation` API can also be used to explicitly
    bind the location index.
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `program` | This is the program object handle |'
  prefs: []
  type: TYPE_TB
- en: '| `index` | This is the index of the generic vertex attribute or variable |'
  prefs: []
  type: TYPE_TB
- en: '| `name` | This is the vertex shader attribute variable that the index is to
    be bound |'
  prefs: []
  type: TYPE_TB
- en: However, it is advisable to encourage layout qualifier as it does not produce
    the overhead of an API call for attaching the location index to shader program.
    The use of a layout location qualifier in the shader programing avoids the binding
    of attribute location at runtime in the OpenGL ES program.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Using the per-vertex attribute to send data to a shader* recipe
    in [Chapter 1](ch01.html "Chapter 1. OpenGL ES 3.0 on Android/iOS"), *OpenGL ES
    3.0 on Android/iOS*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the *Efficient rendering with Vertex Buffer Object* recipe in [Chapter
    2](ch02.html "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES 3.0 Essentials*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping uniforms and creating buffer objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The interface block helps in grouping the uniform variables into one logical
    bunch. This is very useful in grouping the related variables in the shader programing.
    The interface block gives an opportunity to share the uniform data among multiple
    programs at once. This allows us to set multiple uniform variables in one go,
    which can be used many times.
  prefs: []
  type: TYPE_NORMAL
- en: A **Uniform Buffer Object** (**UBO**) is a buffer object for the interface blocks
    (containing uniform) similar to VBO, IBO, and so on. It stores the contents of
    the interface block in the GPU memory for quick data access at runtime. The UBO
    uses bind points that act as a mediator between the uniform block and uniform
    buffer. In this recipe, we will create a uniform block and learn how to program
    uniform buffer objects.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe demonstrates the concept of interface block. In this recipe, we
    created an interface block to store transformation matrices. This block contain
    three uniforms. The interface block is stored as a buffer object using the UBO
    feature. This allows us to store the interface block as an OpenGL ES buffer object.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The syntax to create the uniform block is very simple. The following table
    shows the syntax and use test cases of the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Syntax | Individual uniforms | Uniform blocks |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the step-by-step description that demonstrates the interface block
    and helps in programming the uniform block object:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reuse the previous recipe, *Managing variable attributes with qualifiers*,
    and create the vertex shader (`UniformBlockVertex.glsl`) as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the fragment shader, (`UniformBlockFragment.glsl`), as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `Cube::InitModel()` function, compile the given shader(s) and create
    the program object. Make sure that the program is in use (`glUseProgram`) before
    the UBO creation is attempted. In this recipe, we created the UBO in a separate
    class member function `CreateUniformBufferObject`. Follow these steps to understand
    this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Query the index of the uniform block that is defined in the vertex shader using
    the `glGetUniformBlockIndex` API into `blockIdx`. This API accepts the program
    ID and the name of the uniform block whose block index needs to be queried.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `blockIdx` and query the block data size in the `blockSize` variable with
    the help of the `glGetActiveUniformBlockiv` API. Bind the uniform block index
    to binding point `bindingPoint` with `glUniformBlockBinding`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the object handle for uniform buffer block and bind it to the symbolic
    constant `GL_UNIFORM_BUFFER`, and allocate the required memory specified by `blockSize`.
    Finally, bind the UBO with binding point by using `glBindBufferBase`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the render function, make use of buffer object memory mapping to modify
    the content of UBO:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The uniform block declaration in the vertex shader groups the model, view,
    and projection matrices into one logical block called **transformation**. When
    the shader program gets compiled, it assigns a unique ID/index to the block called
    block index. The user-defined location indexes are not permitted in uniform blocks.
    The following five steps are required to create a UBO:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `glGetUniformBlockIndex` API to query the `Transformation` ID in the
    `blockIdx` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to allocate the memory for the UBO, use the `glGetActiveUniformBlockiv`
    API to query the size of the `Transformation` uniform block in the `blockSize`
    variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind `blockIdx` (block index) to `bindingPoint` (binding point) using the `glUniformBlockBinding`
    API. UBO uses the concept of binding points to create a connection between the
    block index and the buffer object. Both must be bound to the binding point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unlike the buffer objects (VBO and IBO) are created in OpenGL ES, similarly
    create the uniform buffer object. The `glBindBuffer` and `glBufferData` APIs must
    use the `GL_UNIFORM_BUFFER` symbolic constant to ensure UBO buffer to the OpenGL
    ES state machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As mentioned in step 3, we need to attach the UBO with the respective binding
    point that is already attached to the block index. Use the `glBindBufferBase`
    API to bind UBO and `bindingPoint`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The UBO can be used to set several values with the single UBO binding call.
    `RenderCube()` binds the UBO to set the uniform values for model, view, and projection
    matrices. The buffer object allows modifications to buffer elements using buffer-mapping
    techniques.
  prefs: []
  type: TYPE_NORMAL
- en: The OpenGL ES 3.0 release has introduced a new feature for range buffer mapping.
    This feature allows us to modify a subset of the buffer object. Unlike the old
    buffer-mapping technique, where the complete buffer needs to be mapped onto the
    CPU side, this technique appears to be much more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Use the `glMapBufferRange` API to map the UBO on the client side to modify the
    model, view, and projection matrices with updated values. Make sure that you unmap
    the buffer object after modification is completed by sing the `glUnmapBufferAPI`.
    Use the existing code for VBO rendering.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following figure describes the concept of binding point in UBOs. Each uniform
    block is identified with a unique index within the shader program. This index
    is attached to a binding point. Similarly, the UBO is also attached to the binding
    point and provides a mechanism to share the same data among different programs.
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/5527OT_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding figure, **P1_2** and **P2_1** are pointing to the same binding
    point. Therefore, both share the same data.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Efficient rendering with Vertex Buffer Object* recipe in [Chapter
    2](ch02.html "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES 3.0 Essentials*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Reading and writing buffer objects with mapping*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing VBO with Vertex Array Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 2](ch02.html "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES
    3.0 Essentials*, we introduced two features to load the vertex attributes using
    vertex arrays and **Vertex Buffer Object** (**VBO**). Both these features allow
    us to load the vertex attribute in the OpenGL ES rendering pipeline. The VBO are
    considered efficient compared to vertex arrays because they store the vertex data
    in the GPU memory. This reduces the cost of data copy between CPU and GPU. In
    this recipe, we will understand a new feature: **Vertex Array Objects** (**VAO**)
    of OpenGL ES 3.0\. This feature is more efficient compared to VBO.'
  prefs: []
  type: TYPE_NORMAL
- en: When a vertex attribute is loaded, it requires some additional calls to set
    the attribute states in the OpenGL ES rendering pipeline. For example, prior to
    rendering, the buffer object is bound using the `glBindBuffer` API, the data array
    is assigned using the `glVertexAttributePointer` API, and the vertex attribute
    is enabled using the `glEnableVertexAttribArray` API. The VAO stores all such
    states into a single object in order to remove the overhead caused by these calls.
  prefs: []
  type: TYPE_NORMAL
- en: This allows the application to quickly switch among available vertex array buffers
    and set their respective states. This makes the rendering efficient and also helps
    keep the programming code compact and clean.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe demonstrates a simple grid geometry rendering using VAO in conjunction
    with VBO. There is no change required in shaders for programming VAO. Perhaps
    previous recipes from this chapter can be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps to create VAO are very straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Grid` class and define the geometry in the `CreateGrid` function.
    This function takes the dimension and division of the grid. Inside this function,
    create a VBO, IBO, and VAO, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a VBO, generate the buffer, and fill in the buffer object with the vertex
    information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, create an IBO and fill in the buffer with the element indexes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Generate the VAO ID using the `glGenVertexArrays` API. Bind this generated
    `Vertex_VAO_Id` using `glBindVertexArray`. The code written after the creation
    of the VAO is recorded in the state vector of the VAO object. Therefore, use the
    VBO and bind the data to the required vertex attribute for rendering purposes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Unbind the VAO, VBO, and IBO, once the vertex states and attributes are set
    properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Render the geometry with VAO using the `Render()` function, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The VAO stores the vertex array client states and the buffer binding in a state
    vector. When the VAO ID is bound, the subsequent operation calls, such as calls
    to bind with VBO, enable client states, and attach data buffer to generic attributes,
    are stored in the state vector of the VAO. This way, when the VAO is bound, the
    state vector provides the full state of current settings, configurations, and
    client states of the vertex array. Instead of making several calls, this one binding
    call will be sufficient to enable vertex array configurations and states.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/5527OT_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Rendering primitives with vertex arrays* recipe in [Chapter 2](ch02.html
    "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES 3.0 Essentials*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and writing buffer objects with mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipe introduced a new feature to access vertex arrays using VAO.
    This object minimizes the overhead of switch among vertex arrays and their respective
    states. This recipe will go one step ahead in order to teach you how to update
    the data of the buffer objects using buffer mapping. The VBO can be updated using
    `glBufferData` and `glBufferSubData` as demonstrated in many recipes. These APIs
    can be used to upload or download data to the device. In contrast, the buffer
    mapping is an efficient way to update the buffer objects that are residing in
    the GPU memory.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will demonstrate buffer object range mapping. In this recipe, we
    will reuse the cube geometry and render each vertex of the cube as a point primitive,
    instead of a triangle primitive. Each vertex of the cube is programmed to change
    its colors randomly using the buffer object range mapping feature after a fixed
    interval of time.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start with a step-by-step description, here is the overview of buffer
    object range mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: Bind the buffer that needs to be mapped using `glBindBuffer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the pointer to the memory location from driver memory space using the `glMapBufferRange`
    API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use this pointer to perform any read/write operations on the acquired memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invalidate the acquire pointer using the `glUnmapBuffer` API. This API allows
    us to send updated memory contents to the GPU memory space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe does not require any special change in the vertex and fragment
    shaders. For this recipe, we used a new GL shading language API called `gl_PointSize`.
    This API is used to specify the size of the `GL_POINTS` primitives. Make use of
    the *Efficient rendering with* *Vertex Buffer Object* recipe in [Chapter 2](ch02.html
    "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES 3.0 Essentials*, and proceed
    with the following steps to program range mapping onto a buffer object:'
  prefs: []
  type: TYPE_NORMAL
- en: First, create the VAO of the cube geometry using the previous VAO recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Program the map range buffer inside the `Render()` function as shown here.
    The following steps will describe this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, bind the VBO in order to map the color buffer data using the `glBindBuffer`
    API. Map the pointer to the color data memory. The color data in the VBO starts
    from the size index and is also size bytes long:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On successful mapping of the buffer object, it returns a valid pointer to the
    memory mapped location. If an error occurs, the API would return the `NULL` pointer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `target` | This specifies the type of buffer, which is expected to bind for
    memory mapping, for example, `GL_MAP_READ_BIT` and `GL_MAP_WRITE_BIT` |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `offset` | This specifies the starting offset within the buffer object that
    is the subject of interest for mapping |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `length` | This specifies the range of the buffer that needs to be mapped
    |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `access` | This is the symbol constant flag combination that indicates the
    desired access to the buffer range |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: 'Copy the new color values in this mapped memory buffer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Unmap the memory mapped buffer to indicate the OpenGL ES rendering pipeline
    to transfer this data to the GPU memory space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `UnmapBuffer` API returns the Boolean `TRUE` if it successfully unmaps the
    current mapped buffer. If some error occurs, it returns `FALSE`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `target` | This specifies the type of the buffer that needs to unbound |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: 'Bind the VAO and render the geometry using the `GL_POINTS` primitive. The `GL_POINTS`
    primitive renders small dots on the screen. In order to increase the dimension
    of these dots, the `gl_PointSize` API can be used in the vertex shader, as shown
    in the next step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create `BufferMappingVertex.glsl` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the VBO, `glBufferData` and `glBufferSubData` use the user data and copy
    it into a hooked/pinned location in the device memory location. This hooked location
    can be accessed by the GPU. The user data is copied to this memory location like
    `memcpy` internally. As the data copying process gets completed, the driver starts
    **direct memory allocation** (**DMA**) without intervening the CPU cycles.
  prefs: []
  type: TYPE_NORMAL
- en: The target destination of the DMA depends upon the usage hints from the (`GL_STREAM_DRAW`,
    `GL_STREAM_READ`, `GL_STREAM_COPY`, `GL_STATIC_DRAW`, `GL_STATIC_READ`, `GL_STATIC_COPY`,
    `GL_DYNAMIC_DRAW`, `GL_DYNAMIC_READ`, or `GL_DYNAMIC_COPY`) APIs.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, the `glMapBufferRange` method is considered much more efficient.
    The API first hooks a memory location directly into the driver memory space. This
    pinned memory location is available through a pointer to the application. This
    pointer can be directly used to update the location for the uploading or downloading
    of data for read/write purposes. Once the operation on the mapped location for
    read/write is completed, the pointer can be made invalid by calling `glUnMapBuffer`.
    This API call hints the OpenGL ES pipeline to push the updated data to the GPU
    memory using DMA calls.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/5527OT_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Swizzling* recipe in [Appendix](apa.html "Appendix A. Supplementary
    Information on OpenGL ES 3.0"), *Supplementary Information on OpenGL ES 3.0*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the *Transform feedback particle system with sync objects and fences*
    recipe in [Chapter 12](ch12.html "Chapter 12. Real-time Shadows and Particle System"),
    *Real-time Shadows and Particle System*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Render multiple objects with geometry instancing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The geometry instancing allows us to render multiple instances of the same object
    in a single rendering API call. These multiple instances differ in their generic
    attributes, such as transformation matrices, color, scale, and so on. This feature
    is very useful to implement particle systems, crowd simulation, rendering of jungle
    trees, and so on. Compared to the traditional way of rendering multiple objects
    that use multiple rendering calls, this technique is very efficient as it requires
    a single API call. This reduces the overhead of CPU processing in sending multiple
    rendering calls to the OpenGL ES rendering engine.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe demonstrates the rendering of 1000 cubes using geometric instancing.
    For this, we will use 1000 matrices in a VBO. Each matrix contains a transformation
    to place a cube in the 3D space. The information of the matrices are updated using
    the range map buffer feature as discussed in the previous recipe. This allows
    us to pass new transformation data on the fly at run time. The transformed data
    contains new rotation and translated positions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Render multiple objects with geometry instancing](img/5527OT_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, in our recipes, the model-view-projection matrix is always treated as
    uniform in the vertex shader. For this recipe, we will make use of the VAO and
    declare the model-view-projection matrix as a generic attribute instead of a uniform.
    Since the matrix is an attribute, a new VBO is required. This VBO is stored in
    the `matrixId` variable. `RenderCube()` uses the map buffer to update transformation
    matrix data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to implement geometric instancing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the vertex shader and add the following code. There is no change required
    for the fragment shader. It can be reused:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Cube::InitModel()`, use the existing code and add a new VBO for matrix
    transformation. Get the ID of the generated buffer object in `matrixId`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Allocate the memory to the VBO for matrix transformation. The dimension variable
    is initialized with 10\. It gives the number of cubes along an axis. Therefore,
    along *x*, *y*, and *z* axes, *10 x 10 x1 0 = 1000 cubes*. The total size of the
    buffer would be size of *(GLfloat) * 16 (16 float elements in mat4) * 1000 (cubes)*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `glBufferData` uses `GL_DYNAMIC_DRAW`. This symbolic constant specifies
    that the buffer is going to contain some data that is dynamic in nature. In other
    words, the data will require updates in the buffer. This symbolic constant helps
    the graphics driver to manage buffer memory in the best possible way to achieve
    high-performance graphics rendering.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the same function, after creating the VAO (`Vertex_VAO_Id`), define the
    generic attribute states and configuration of the transformation matrix buffer
    object. This helps in saving the vertex array client states and the buffer binding
    in the VAO (`Vertex_VAO_Id`). The `glVertexAttribDivisor` calculates the instance
    ID from the total number of instances given. For more information, refer to the
    *There''s more…* section in this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Cube::RenderCube()`, use range buffer mapping to map the transformation
    buffer on the client-side memory. Update the data in the memory and unmap it.
    Use VAO and render the cube of cubes using the geometric instance API called `glDrawElementsInstanced`.
    This API''s last argument specifies the number of instances the given primitive
    will be rendered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The application first compiles the shader programs. This makes us aware of all
    the generic attribute locations used in the shader program. Create a VBO of 1000
    matrix elements. Each element represents a transformation matrix. This matrix
    element is updated with new values of the transformation of every frame in the
    `RenderCube` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generic attributes are first enabled using `glEnableVertexAttribArray`.
    The data array is attached to the generic location with `glVertexAttribPointer`.
    The following figure shows how the OpenGL ES program API is attached to the layout
    location of the vertex shader to send data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/5527OT_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that the generic attributes are sent as a group of four. Therefore, for
    a 4 x 4 matrix, we will need four attribute locations. The start location of the
    attribute should be mentioned into the vertex shader using a layout qualifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows how the attribute locations are managed by the compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/5527OT_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Similar to the other locations such as `VERTEX_LOCATION (0)` and `COLOR_LOCATION
    (1)`, the transformation matrix locations (`2`, `3`, `4`, `5`) also need to be
    enabled and attached to the array data.
  prefs: []
  type: TYPE_NORMAL
- en: The `glVertexAttribDivisor` API is responsible for controlling the rate at which
    OpenGL ES advances the data from an instanced array. The first parameter of this
    API specifies the generic attribute that needs to be treated as an instanced array.
    This tells the OpenGL ES pipeline to use this attribute per instance rendering.
    For example, in this example, the generic attributes, `2`, `3`, `4`, `5`, are
    instanced attributes. Therefore, OpenGL ES consumes the data from the transformation
    matrix array as an instance ID. We will see how this instance ID is calculated
    in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default value of the divisor is `0` when it is not specified in the program
    explicitly. If the divisor is `0`, the attribute index is advanced once per-vertex.
    If the divisor is not `0`, the attribute advances once per divisor instance of
    the set(s) of the vertices being rendered.
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `index` | This specifies generic attribute layout location |'
  prefs: []
  type: TYPE_TB
- en: '| `divisor` | This specifies the number of instances that will pass between
    updates of the generic attribute at the index slot |'
  prefs: []
  type: TYPE_TB
- en: The rendering of the geometric instancing requires special instanced-based drawing
    APIs from OpenGL ES 3.0, as mentioned here for array- and index-based geometric
    data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `mode` | This specifies the type of the primitive that needs to be rendered
    |'
  prefs: []
  type: TYPE_TB
- en: '| `count` | This specifies the number of indices considered in the drawing
    |'
  prefs: []
  type: TYPE_TB
- en: '| `type` | This is used by `glDrawElementsInstanced`, this specifies the data
    type of the indices stored |'
  prefs: []
  type: TYPE_TB
- en: '| `indices` | This specifies the arrays containing the order of the indices
    |'
  prefs: []
  type: TYPE_TB
- en: '| `primcount` | This specifies the number of copies to be rendered |'
  prefs: []
  type: TYPE_TB
- en: In the present recipe, the `glDrawElementsInstanced` API is used to render multiple
    instances of the same object. This API works in conjunction with another API called
    `glVertexAttribDivisor`. In order to update the VBO matrix elements, buffer mapping
    is used, which is an efficient way to update the buffer elements. If the geometric
    data is not index based but array based, then `glDrawArraysInstanced` can be used.
    This API accepts almost the same parameters. Refer to the online *OpenGL ES 3.0
    Reference Manual* for more information.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second attribute of `glVertexAttribDivisor` specifies the divisor. This
    divisor helps in calculating the instance ID from the total number of instances.
    The following figure shows a simple example of the working logic of this API.
    In this figure, we assumed that there are total five instances to be rendered,
    and the figure contains five matrices. When the divisor is `5`, it produces `5`
    instance ID of the (`0`, `1`, `2`, `3`, `4`). This instance ID will be used as
    an index to the transformation matrix array. Similarly, when the divisor is `2`,
    it generates three instances (`0`, `1`, `2`). It generates two instances (`0`,
    `1`) when the divisor is `3`.
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/5527OT_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Managing VBO with Vertex Array Objects*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the *Efficient rendering with ETC2 compressed texture* and *Implementing
    Skybox with seamless cube mapping* recipes in [Chapter 7](ch07.html "Chapter 7. Textures
    and Mapping Techniques"), *Texture and Mapping Techniques*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering multiple primitives with primitive restart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenGL ES 3.0 introduced a new feature called primitive restart, where multiple
    disconnected geometry primitives can be rendered using a single API. This feature
    uses a special marker in the vertex data or the index data to concatenate different
    geometries of the same drawing type into a single batch. The restart primitive
    feature executes on the GPU. Therefore, it eliminates the communication overhead
    per drawing call. This provides high-performance graphics by avoiding multiple
    drawing calls from CPU to GPU.
  prefs: []
  type: TYPE_NORMAL
- en: The recipe shows us how to use the primitive restart technique to render a cube
    using two sets of geometries, which are separated by a special marker.
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering multiple primitives with primitive restart](img/5527OT_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The marker used by the restart primitive feature to separate geometries is the
    highest value of the data type with which the element index or vertex data array
    is specified. For instance, an index value of `GLushort` and `GLint` should be
    *0 x FFFF* (*65535*) and *0 x FFFFFFFF* (4*294967295*), respectively.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To render multiple primitives, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the cube vertices and indices, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| Cube vertices | Indices |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '|'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '|'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In order to render the cube with primitive restart, it must first of all be
    enabled, using `glEnable(GL_PRIMITIVE_RESTART_FIXED_INDEX)`. Specify the total
    size of the indice and include the number of markers that are used in the geometry
    indices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The other way in which the disconnected geometry primitives can be rendered
    is called triangle degeneration. Triangle degeneration is the capability of the
    GPU to recognize disconnected primitives in the triangle strip or triangle fan
    index information on the basis of some special pattern.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the following figure shows the special index pattern data that
    can be used to render degenerated triangles using the `glDrawElement` or `glDrawElementsInstanced`
    API.
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/5527OT_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The degeneration between the two geometries is achieved by repeating the last
    index of the previous geometry and the first index of the next primitive. This
    rule of degeneration is only applicable when the previous geometry contains an
    odd number of triangles. Behind the curtains, the triangle would be drawn in the
    following order: (0, 1, 2), (2, 1, 3), (2, 3, 3), (3, 3, 6), (3, 6, 6), (6, 6,
    7), (6, 7, 8), (8, 7, 10). The repeated indices form an area equivalent to zero,
    allowing the GPU to discard the triangles. These zero area triangles are mentioned
    using the bold font.'
  prefs: []
  type: TYPE_NORMAL
- en: The second type of degeneration case is where the first geometry contains an
    odd number of triangles. For instance, the following image demonstrates the first
    geometry with three (odd) triangles. As per this case rule, the last index of
    the first geometry is repeated twice, followed by the first index of the second
    geometry.
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/5527OT_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For instance, the indices specified for degenerate triangles (0, 1, 2, 3, 4,
    4, 4, 8, 8, 9, 10, 11) generate the following triangles: (0, 1, 2), (2, 1, 3),
    (2, 3, 4), (4, 3, 4), (4, 4, 4), (4, 4, 6), (4, 6, 6), (6, 6, 9), (6, 7, 8), (8,
    7, 9), (9, 8, 10).'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Using the per-vertex attribute to send data to a shader* recipe
    in [Chapter 1](ch01.html "Chapter 1. OpenGL ES 3.0 on Android/iOS"), *OpenGL ES
    3.0 on Android/iOS*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the *Efficient rendering with Vertex Buffer Object* recipe in [Chapter
    2](ch02.html "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES 3.0 Essentials*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
