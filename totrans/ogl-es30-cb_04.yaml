- en: Chapter 4. Working with Meshes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating polygon meshes with Blender
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering the wavefront OBJ mesh model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering the 3Ds mesh model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, you learned the essentials of OpenGL ES to create 3D geometrical
    objects and place them in the 3D space and also understood and programmed new
    features in OpenGL ES 3.0\. We also programmed a simple 3D cube model using various
    attributes, such as vertex positions and colors. A procedural geometry modeling
    (geometry built using only code without any aid of an external data-file reference
    or tools) in OpenGL ES is not only time consuming, but it can also be very complex
    to program if the geometry is very complicated. For example, rendering a 3D car
    model is much more difficult compared to a simple 3D cube. If the user is not
    careful enough, it becomes very cumbersome to program the geometry.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to deal with such complicated geometry shapes is to create them
    using computer aided design tools; such tools not only saves time, but also the
    created model to visualize. The main advantage of using these tools is that you
    can create extremely complex geometrical shapes without having to worry about
    the mathematical concepts involved behind it. After the model is created, you
    can export them in a variety of 3D file formats in your program. These 3D geometry
    models are also called meshes.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to create simple meshes using Blender, which
    is an open source 3D modeling tool. We will discuss and understand two very famous
    3D mesh model types, OBJ and 3Ds, and try to understand their specifications.
    You will also learn how to write a parser for these models in your OpenGL ES recipes.
    In addition, this chapter will cover various aspects of the 3D mesh model that
    will be helpful to render them to 3D graphics.
  prefs: []
  type: TYPE_NORMAL
- en: Creating polygon meshes with Blender
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A polygon mesh is a collection of vertices, faces, normal, colors, or textures
    that collectively define a 3D model. This 3D model can be directly used in various
    3D applications, such as computer graphics, simulator, animation movies, and CAD/CAM.
    In this section, you will learn how to create mesh models in Blender, which we
    will use throughout the course of this book to demonstrate our recipes.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will use Blender 2.68 to develop our 3D model meshes. Blender
    is a free and open source 3D computer graphics tool. You may use other similar
    software of your choice, such as 3Ds Max, Maya, Google Sketch, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can download the latest version of Blender from [http://www.blender.org/download](http://www.blender.org/download)
    and install it as per the instructions given on the website.
  prefs: []
  type: TYPE_NORMAL
- en: 'Blender is cross-platform and runs on several popular computing platforms.
    Blender allows a number of geometric primitives, including various polygon meshes,
    subdivision surface modeling, and smart geometric editing tools. It also allows
    various texture techniques to be implemented to geometry surfaces. When Blender
    is launched for the first time, you will find the tool interface, as given in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/5527OT_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section will provide a step-by-step procedure to create mesh models in
    Blender 2.68\. We will understand the simple steps to create these meshes and
    export them to `wavefront.obj` and 3Ds formats so that they can be used for demonstration
    purposes in later recipes.
  prefs: []
  type: TYPE_NORMAL
- en: When Blender is launched for the first time, a cube-shaped object will be displayed
    in the middle of the canvas grid. If you are not interested to use this cube,
    you can delete this. In order to delete an object from the canvas grid, select
    it (by placing the cursor on it and right-clicking on it) and click on the delete
    key on the keyboard. Alternatively, you can select an object and click on the
    **X** and *Enter* key to delete the selected object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, there are 10 basic mesh models available in Blender, which can be
    collectively used to create more complex shapes. Depending on the Blender version
    type, the UI interface may appear different. However, the basic functionality
    is the same. In order to add a new mesh model, navigate to menu, click on **Add**
    | **Mesh**, and select the desired model (for example, UV sphere). In the newer
    Blender versions (such as 2.7.0 and later versions), you may find this option
    on the left-hand side panel under the **Create** tab, as shown in the following
    screenshot:![How to do it...](img/5527OT_04_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can change the model properties for each model from the left-hand side pane,
    as shown in the following screenshot:![How to do it...](img/5527OT_04_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each mesh, you can change the location and apply rotations as well. For
    all our recipes, we will use Location as (0.0, 0.0, and 0.0) so that the mesh
    always appears on the origin of the canvas grid.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The model can be edited in the edit mode by selecting the mesh object and clicking
    on the *Tab* button. In the edit model, the geometry of the mesh can be enhanced.
    For example, the surface of the mesh object can be subdivided into many smaller
    surfaces in order to enhance the smoothness of surfaces. In the edit mode, you
    can select the subdivide menu option to subdivide the selected objects surface.
    The following image shows how subdivision works:![How to do it...](img/5527OT_04_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Export the created model using the **File** | **Export** menu option. We will
    export the created model in the wavefront and the 3Ds mesh formats. In the following
    sections, we will see how of these mesh formats are used in our recipes:![How
    to do it...](img/5527OT_04_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While exporting in the wavefront (`.obj`) format, you may need to select the
    following options, depending on your requirements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Include edges**: This exports edges as two-sided faces.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Triangulate faces**: Instead of writing faces as a quad, each quad is represented
    using three triangles. We must select this option for our mesh models.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Include UVs (optional)**: This writes the texture coordinate information
    about the geometry surface'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Include normals (optional)**: This writes the face and vertex normal depending
    on the face smooth settings:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![How to do it...](img/5527OT_04_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Include Normals** is optional; it calculates the face normal and writes
    to the file-exported file format. Additionally, calculating normal at runtime
    will incur some extra processing cost. This feature is useful to minimize runtime
    calculations at the expense of a large file and the memory utilized while reading
    this file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Alternatively, you can calculate the normal with the face information provided
    within the mesh model. Later in this recipe, you will learn how the normal is
    calculated using the face information.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To export the 3Ds format, use all the default export options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The meshes (created in this chapter) do not contain any texture-based information.
    We will use texture-based models in our later chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: While using Blender, the settings can be restored to default factory settings
    at any time by selecting **File** | **Load Factory Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The exported models from Blender and other sample models in the wavefront and
    3Ds format can be found in the `GLPIFramework` folder under `Models`. Feel free
    to explore them. [Chapter 5](ch05.html "Chapter 5. Light and Materials"), *Light
    and Materials*, makes extensive use of wavefronts models to demonstrate various
    types of lights.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Rendering the wavefront OBJ mesh model*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Rendering the 3Ds mesh model*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering the wavefront OBJ mesh model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The wave file format is a famous 3D mesh model format developed by wavefront
    technologies. It contains the mesh geometry information in a readable text format.
  prefs: []
  type: TYPE_NORMAL
- en: 'The wavefront format mainly consists of two types of files: `.obj` and `.mtl`.
    The `.obj` file is responsible for describing the geometrical information of the
    3D model, such as vertex position, normal, texture coordinates faces, and so on.
    The `.mtl` file is optional and contains material information for individual mesh
    parts, such as the texture and shading (diffuse, specular, and so on) information.
    Also, the `.mtl` file is exported automatically if it contains the texture information;
    otherwise, you must set **Write Materials**. The term material here refers to
    the color or texture of an object. The models that we have exported do not contain
    any texture information. Therefore, these models only consist of `.obj` files.'
  prefs: []
  type: TYPE_NORMAL
- en: '**File format**: As the wave front format is readable, you can open it in any
    text editor and read it. It uses special keywords to recognize specific types
    of information. The following table will help you to understand the keywords used
    for the wavefront file format:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Keyword | Meaning | Sample |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `#` | Anything starting with `#` is considered as a comment. | This file
    is created using Blender 2.65 |'
  prefs: []
  type: TYPE_TB
- en: '| `v` | This is the vertex position that specifies x, y, and z coordinates.
    |'
  prefs: []
  type: TYPE_TB
- en: v 1.000000 -1.000000 -1.000000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: v 1.000000 -1.000000 1.000000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: v -1.000000 -1.000000 1.000000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `vt` | This specifies texture coordinates in the range of 0.0 to 1.0. |'
  prefs: []
  type: TYPE_TB
- en: vt 0.0 0.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: vt 1.0 0.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: vt 1.0 1.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: vt 0.0 1.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `vn` | This represents Normals at each vertex position. |'
  prefs: []
  type: TYPE_TB
- en: vn 0.0 1.0 0.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: vn 0.0 0.0 1.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `f` | This contains the face information. Each face is defined with vertex
    (v) followed by texture coordinates (u) and vertex normal (n). The syntax for
    the face information is [v]/[u]/[n]. | Face information various formats:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Vertex coordinates: f 1 2 3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Vertex and texture coords: f 1/1 3/2 4/3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Vertex and texture normal: f 1/1/2 3/2/1 4/3/2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Vertex and normal coords: f 1//2 3//1 4//2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows a sample wavefront (`.obj`) file when it''s opened
    in a text editor. This sample only contains the vertex and face information, which
    is a minimal requirement of a mesh model to render to any 3D graphics visualization
    tool. Depending on the chosen export options, more mesh attributes can be seen
    with new keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering the wavefront OBJ mesh model](img/5527OT_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The actual capabilities of the wavefront OBJ model are way beyond what we have
    specified in the file format. Covering all the specifications of `.obj` is beyond
    the scope of this book. You can refer to [http://paulbourke.net/dataformats/obj](http://paulbourke.net/dataformats/obj)
    for the full set of specifications. This recipe essentially covers the most important
    and critical parts of the specification, in which you will learn how to parse
    the geometrical information. Our tiny parser and renderer will help you to understand
    the concept of meshes in-depth and allow you to program any other kind of mesh
    file formats.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can explore more about wavefront OBJ file format specifications at [http://paulbourke.net/dataformats/obj/](http://paulbourke.net/dataformats/obj/).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The 3D models we created in Blender need to be imported into the project. Android
    and iOS have different ways to access their resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Android**: On Android, 3D mesh models need to copy from `GLPIFramework/Models`
    and store it in the memory card under the `sdcard/Models` folder'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iOS**: Add the `GLPIFramework/Models` folder to the project using **File**
    | **Add Files to [Project Name]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class and data structure**: The `OBJMesh` class is responsible for parsing
    wavefront OBJ mesh models; it uses necessary data structures to store the parsed
    wavefront OBJ information. This class is defined in `WaveFrontObj.h`/`.cpp` under
    our `GLPIframework/WaveFrontOBJ` folder. Here are the necessary data structure
    that are used by this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vertex**: This structure will store the information of each vertex, which
    exists in the 3D geometry. It contains position coordinates of each vertex along
    the *x*, *y*, and *z* axis in the position variable. Texture coordinates are stored
    in the *uv* variable. Normal coordinates are stored in the normal variable. The
    tangential information at each vertex is stored in the tangent:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Face index**: This structure is responsible for storing the face-related
    information. For example, it stores all indexes of the vertices, texture coordinates,
    and normals that are helpful in defining the face:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Mesh**: The mesh data structure is responsible for storing the Mesh geometry
    information. It contains the complete path of the OBJ file in the `fileName` variable
    that needs to be parsed. The class contains the information on vertex, texture,
    and normal in the form of a vector array. This is stored in the positions, UVs,
    and normals vector list variables respectively. The `vecFaceIndex` stores the
    information of each face in the form of an index for each vertex making the face.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The indices stores the vertex index for each face and is used to calculate
    normals if the normal information is not available in the `.obj` mesh file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section will provide a step-by-step procedure to parse and render the
    wavefront OBJ mesh model in OpenGL ES 3.0\. Let''s start the recipe using the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `ObjLoader` class derived from the `Model` class. It will inherit all
    the member functions of `Model` necessary for the life cycle of `ObjLoader`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This class contains member variables to store the wavefront model mesh information.
    The mesh model is parsed using `ObjMesh` function''s `waveFrontObjectModel` object.
    This object calls the `parseObjMesh` function, which accepts the path for the
    3D wavefront OBJ model as an argument that we are interested to load on:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `ParseObjModel` function further calls a set of helper functions to store
    and process the mesh information from the `.obj` file. This function returns the
    `Mesh` object pointer. This function accepts the path of the file to be loaded
    and another argument that specifies whether the normal needs to be calculated
    as flat or smooth:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `ParseFileInfo` reads the path of the mesh model to validate its existence.
    This function parses the file by reading each line in it. Each line contains a
    keyword at the beginning that specifies the type of information it contains. The
    `#`, `u`, `s`, or `g` keywords are ignored as they are not used in the parser.
    The `#` keyword is used to write comments in the wavefront file. The parsed information
    from this function is collected in the mesh''s object pointer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The line starting with the `v` keyword represents vertex attributes, which
    could be of three types of information: vertex position (`v`), vertex texture
    coordinate (`vt`), and vertex normal (`vn`). This information is read using the
    `ScanVertexNormalAndUV` function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This function parses each line and stores the information of vertex position,
    texture coordinate, and vertex normal in `objMeshModel.positions`, `objMeshModel.uvs`,
    and `objMeshModel.normals` respectively:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, the line starting with the `f` keyword and followed by a " " space
    represents faces. A face is made up of three vertices and each vertex may consist
    of three attributes: vertex position, texture coordinates, and vertex normal.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each face stores information in the form of an index. An index here refers to
    the index of an actual element in the stored arrays (calculated in step five).
    For example, an index of two for the vertex position in a given face means a third
    vertex element in the `objMeshModel.positions` vector array.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Gather the face index information in the `objMeshModel.vecFaceIndex` vector
    list. This list contains all faces that have the indices of vertex attributes
    belonging to each vertex of the face. For more information, refer to the `ObjMesh::ScanFaceIndex`
    function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using the face index information gathered in `objMeshModel.vecFace`, populate
    the `objMeshModel.vertices` vector list. This list contains vertex attributes
    to be used to create the Vertex Buffer Object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the normal attribute is missing in the OBJ file, it can be calculated using
    `OBJMesh::CalculateNormal()`. For more information, refer to the *There's more...*
    section in this recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, the tangent information at each vertex is calculated using `OBJMesh::CalculateTangents()`.
    You can refer to bump mapping in [Chapter 5](ch05.html "Chapter 5. Light and Materials"),
    *Light and Materials*, to understand the working of this function thoroughly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the OBJ mesh information is parsed and stored in mesh''s object, clear
    all the temporary data structure using the `ClearMesh` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After parsing the OBJ file, create the VBO within the `ObjLoader` constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ParseObjMesh` function in the `OBJMesh` class is responsible for parsing
    the wavefront OBJ file and storing the information in the mesh's `objMeshModel`
    object variable. This function parses the file and recognizes vertex attributes,
    such as vertex position, texture coordinates, and vertex normals. It stores these
    attributes in the `objMeshModel.positions`, `objMeshModel.uvs`, and `objMeshModel.normals`
    respective vector arrays. These vector arrays are contiguous in nature. Therefore,
    these arrays can be used directly to pick elements using the index information.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The vertex texture and vertex normal are optional attributes. Without these,
    the geometry can still be produced. Texture coordinates only get stored if the
    model contains any texture. The normal can be saved in the OBJ file by selecting
    **Include Normals** in export options. For more information on .OBJ mesh model
    export options, refer to, the *How to do it...* section under the *Creating polygon
    meshes with Blender* recipe in this chapter for more information on OBJ mesh model
    export options.
  prefs: []
  type: TYPE_NORMAL
- en: After parsing the vertex attribute information, the face information needs to
    be parsed. Each face is made up of three vertices. These vertices can contain
    the position, texture, and normal information. The information for each vertex
    attribute in the face is stored in the form of an index. The face information
    in the `objMeshModel.vecFaceIndex` must be stored in the vector array list.
  prefs: []
  type: TYPE_NORMAL
- en: The `objMeshModel.vertices` is another vector-based array that is contiguous
    in nature and in the interleaved form. Each record in array represents a vertex
    element, which contains vertex positions, texture coordinates, and normal attributes.
    The `OBJMesh::CreateInterleavedArray` function is responsible for generating this
    array. The Interleaved fashion array is highly recommended as it contains different
    attribute data in a single array, thereby sufficient to store a single VBO. However,
    if the data is not stored interleaved, each attribute will be stored in a separate
    array. For each data array, a separate VBO is required. Use of too many VBOs is
    performance killing because the rendering pipeline spends more time binding and
    switching VBOs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The OBJ model data are to be drawn using `GL_TRIANGLES`. The fragment shader
    used will provide different effects based on the information passed (for example,
    texture coordinates, lighting information, and so on) in the upcoming chapters.
    We will apply various vertex and fragment shaders to OBJ meshes in order to produce
    mind-blowing real-time rendering effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/5527OT_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Normal's information plays an important role in the light shading of 3D objects.
    Our wavefront exported models do not contain any normal information. This section
    will help us in calculating normals using the face information.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways in which the normal can be calculated:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Face normal**: This is calculated using a single face information. This type
    of normal results in flat shading. It''s calculated using a cross product of any
    two edges formed by the triangle face. In other words, it''s perpendicular to
    the surface generated by coplanar vertices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vertex normal**: This is calculated by taking the average of the face normal
    created by faces that share common vertices:![There''s more...](img/5527OT_04_09.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding image shows the face and vertex normal. Each face normal is calculated
    using four vertices, which form a plane surface. Out of these four vertices, any
    of the three vertices can be used to form two edges. The cross product of these
    two edges results a perpendicular vector to plane. Normalizing this vector produces
    a face normal.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, each vertex shows the vertex normal in the blue colored line, which
    is formed by four planes or four faces surrounded around each vertex. The average
    of these four planes face normal results a vertex normal. Vertex normal is extremely
    important to generate highly detailed and smooth geometrical appearance without
    requiring too many vertices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The flat shade or smooth shade normal can be calculated using `ParseObjMesh`
    with the second parameter as Boolean `true` for flat shading and Boolean `false`
    for smooth shading. Internally, this function calls `OBJMesh::CalculateNormal`,
    which is responsible for the mathematical calculation of normal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The face normal points to the direction where polygons face. However, vertex
    normal changes the gradient of the polygon. If we change the direction of the
    vertex normal, the shading around that vertex will `http://change.at/" \t "_blank`,
    this gradient is as same as a flat polygon that's rotated in the same direction.
    The computer fakes a gradient over the polygon.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows how a simple sphere on the left-hand side appears
    without a light shading technique. In fact, it''s difficult to believe that it''s
    a sphere mesh model. The middle and rightmost mesh models are demonstrated using
    light shades. The prior mesh model uses the flat light shading, which is achieved
    using face normals, whereas the latter mesh model renders the same mesh model
    with vertex normals:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/5527OT_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Efficient rendering with Vertex Buffer Object* recipe [Chapter
    2](ch02.html "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES 3.0 Essentials*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the *Phong shading – per-fragment shading technique* recipe in [Chapter
    5](ch05.html "Chapter 5. Light and Materials"), *Light and Materials*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the *Gouraud shading – the per-fragment shading technique and Phong
    shading – the per-fragment shading technique recipes* recipes in [Chapter 5](ch05.html
    "Chapter 5. Light and Materials"), *Light and Materials*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the *Implementing bump mapping* recipe in [Chapter 7](ch07.html "Chapter 7. Textures
    and Mapping Techniques"), *Texture and Mapping Techniques*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the *Managing VBO with Vertex Array Objects* recipe in [Chapter 3](ch03.html
    "Chapter 3. New Features of OpenGL ES 3.0"), *New Features of OpenGL ES 3.0*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering the 3Ds mesh model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The 3Ds mesh format is a well-known 3D mesh file format used in computer graphics.
    Unlike wavefront, it's not text-based and stores the mesh information in a binary
    form. This is used widely in Autodesk 3D Studio Max and is a professional 3D graphics
    program software to create 3D animation and models.
  prefs: []
  type: TYPE_NORMAL
- en: '**File format**: This section will provide an overview of the 3Ds file format.
    This mesh format contains information in the form of a hierarchy of chunks. A
    chunk is a structured piece of information in the memory. Its unique ID recognizes
    each chunk, which contains the size information (in bytes) that can be used to
    read or skip chunks. The size information of the current chunk is always relative
    to its start memory position; skipping this much size will point to the next chunk.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows that each chunk is represented with the **Start**
    field, which contains the memory location within the 3Ds file. The **Size** field
    tells us how big is the chunk in bytes, whereas the **End** field specifies the
    memory location where the chunk finishes. The **End** field can be calculated
    with the help of the *Size – Start + 1* formula. The next chunk information is
    always relative to the current chunk position:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Start | End | Size | Name |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 2 | Chunk ID |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 5 | 4 | Next chunk |'
  prefs: []
  type: TYPE_TB
- en: 'Each chunks ID in the 3Ds file has a predefined meaning associated with it.
    For example, the first chunk ID of this file format is always `0x4d4d`. This chunk
    is called the primary or main chunk ID. The other important chunks exist under
    this primary chunk as child nodes, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering the 3Ds mesh model](img/5527OT_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The detailed specification of 3Ds is beyond the scope of this book. You can
    find more information about this specification at [http://www.martinreddy.net/gfx/3d/3DS.spec](http://www.martinreddy.net/gfx/3d/3DS.spec).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will parse the 3Ds file format using a third-party library
    called `lib3ds`. This is an open source library that helps us to parse the file
    and provide us the file data in the form of a data structure. This library is
    written in ANCI-C. Therefore, it's portable across platforms. The lib3ds is available
    for commercial application under GNU **Lesser General Public** **License** (**LGPL**).
    The library can be download from [https://code.google.com/p/lib3ds/](https://code.google.com/p/lib3ds/).
  prefs: []
  type: TYPE_NORMAL
- en: In our GLPI framework, this library is present under the `GLPIFramework/3DSParser/lib3ds`
    folder. We have used the 1.30 version for this library. Rendering 3DS mesh models
    to the application requires these to be stored at some appropriate location on
    the device or simulator.
  prefs: []
  type: TYPE_NORMAL
- en: On the Android device, you can store 3DS mesh model files under the `sdcard/GLPIFramework/Model`
    folder. For iOS, these models can be added to the project using **File** | **Add
    Files to [Project Name]**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Android**: On the Android platform, we need the makefile to build the `lib3ds`
    library. Add the `Android.mk` makefile under `GLPIFramework/3DSParser/lib3ds`.
    Edit this makefile, as shown in the following code. This library will be compiled
    as a shared library, which is named as `mylib3ds`. You can also directly add the
    source code in the main project makefile, instead of compiling a shared library:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Android.mk`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `Android.mk` makefile present in the project directory under the `JNI`
    folder and include the path of the `lib3ds` library `Android.mk` file that we
    have created in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In `GLESNativeLib.java`, edit the `GLESNativeLib` class and add the reference
    of our shared library, so that it will be linked at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**iOS**: On the iOS platform, you need to add `lib3ds` library source files
    to your project using **File** | **Add Files to [Project Name]**.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the steps to create a 3Ds mesh renderer class. This class will be
    responsible for loading and rendering 3Ds mesh models:'
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we have derived a new class called `Loader3DS` from the `Scene`.
    This class contains a `load3dsModel` function, which will be used to load the
    3Ds mesh model file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the `load3dsModel` function, as described in the following code snippet.
    This function parses the 3Ds model file using the `lib3ds` library''s function
    called `lib3ds_file_load` and returns the `Lib3dsFile` pointer. The `Lib3dsFile`
    structure contains the parsed information of the 3Ds mesh file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When a 3Ds mesh file is parsed successfully, it loads the mesh data (geometry
    attributes and material information) of the mesh model in the file object type
    called `Lib3dsFile`. This object contains all the necessary information to read
    nodes. A node in the 3Ds specification is a special data structure called `Lib3dsNode`
    that corresponds to a subpart or submodel of the complete 3D mesh model. For example,
    a `car` model is made up of many different subparts, such as body frame, tires,
    doors, engine, and so on. Each of these individual parts correspond to a child
    node of the parent node that represents the 3D car model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Depending on the complexity of the model, there may be more than one node.
    These nodes are arranged in a hierarchical fashion. The nodes are created using
    `lib3ds_node_new_object()` and are arranged in a hierarchal order with `lib3ds_file_insert_node()`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Render the 3Ds mesh model by recursively iterating through all the nodes. Call
    `RenderNodes()` to render each node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`RenderNodes()` is a recursive function that creates VBO for each node and
    renders them. Each node contains a pointer to `Lib3dsMesh`; the `Lib3dsMesh` is
    a data structure that contains the geometrical information for each node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Lib3ds` library contains a structure called `Lib3dsUserData`. It allows
    you to add custom variables to `lib3ds`. We will use this structure to store vertex
    buffer object variables like vertex:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the VAO for each mesh using the `BuildMesh()` function. Cache the VAO,
    VBO, and IBO information in the `MyLib3dsUserData` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `RenderNodes()`, use the VAO information to render the 3Ds mesh model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The 3Ds mesh file is parsed with lib3ds library's `lib3ds_file_load`. This function
    successfully populates the `Lib3dsFile` file pointer that contains all the parsed
    information from the 3Ds file. Using this data variable, we create nodes that
    are populated and assembled in a hierarchical order using `lib3ds_file_insert_node`.
    Each node represents a mesh, which is read from the node structure and cached
    in the form of a **Vertex Array Objects** (**VAO**). Each VAO stores the **Vertex
    Buffer Object** (**VBO**), states, and attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RenderNodes` is a recursive function that creates the VAO and VBO for
    each node and renders them. Each node contains a pointer to `Lib3dsMesh`, which
    further contains a `Lib3dsUserData` that we will use to check whether the corresponding
    node contains the VAO. The VAO is recognized with a vertex array ID. These IDs
    are bound to runtime and used to render the geometry. Once the VAO IDs are generated,
    these are stored with each node in the `Lib3dsUserData` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/5527OT_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far in this recipe, you learned how to render 3Ds mesh models. We rendered
    these using a single color. The 3Ds file format also has the provision to render
    faces with colors. This information is stored in `Lib3dsMaterial` of `Lib3dsMesh`.
    The following code shows how the material information is read from the material
    data structure and sends it as a uniform variable to the `3dsFragmentShader.glsl`
    to apply as face colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The color information is stored in the form of material colors. For more information
    on light and material, refer to the [Chapter 5](ch05.html "Chapter 5. Light and
    Materials"), *Light and Materials*. The following image illustrates a car model
    with colored faces, where the mesh model is rendered with triangle, line, and
    point primitives:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/5527OT_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Pivot position**: The pivot position renders mesh models to the translation
    information. This helps the mesh to render with correct positioning. Without pivot
    positioning, each node renders at the origin. This behavior causes all node meshes
    to cluster at the origin because each model does not know its position relative
    to other models.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Managing VBO with Vertex Array Objects* recipe in [Chapter 3](ch03.html
    "Chapter 3. New Features of OpenGL ES 3.0"), *New Features of OpenGL ES 3.0*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
