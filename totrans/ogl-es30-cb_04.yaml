- en: Chapter 4. Working with Meshes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 处理网格
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Creating polygon meshes with Blender
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Blender创建多边形网格
- en: Rendering the wavefront OBJ mesh model
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染wavefront OBJ网格模型
- en: Rendering the 3Ds mesh model
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染3Ds网格模型
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In previous chapters, you learned the essentials of OpenGL ES to create 3D geometrical
    objects and place them in the 3D space and also understood and programmed new
    features in OpenGL ES 3.0\. We also programmed a simple 3D cube model using various
    attributes, such as vertex positions and colors. A procedural geometry modeling
    (geometry built using only code without any aid of an external data-file reference
    or tools) in OpenGL ES is not only time consuming, but it can also be very complex
    to program if the geometry is very complicated. For example, rendering a 3D car
    model is much more difficult compared to a simple 3D cube. If the user is not
    careful enough, it becomes very cumbersome to program the geometry.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，您学习了OpenGL ES的基础知识，以创建3D几何对象并将它们放置在3D空间中，并且还了解和编程了OpenGL ES 3.0的新特性。我们还使用各种属性，如顶点位置和颜色，编程了一个简单的3D立方体模型。在OpenGL
    ES中进行过程式几何建模（仅使用代码构建，没有任何外部数据文件参考或工具的帮助）不仅耗时，而且如果几何形状非常复杂，编程起来也可能非常复杂。例如，渲染3D汽车模型比简单的3D立方体要困难得多。如果用户不够小心，编程几何形状会变得非常繁琐。
- en: The best way to deal with such complicated geometry shapes is to create them
    using computer aided design tools; such tools not only saves time, but also the
    created model to visualize. The main advantage of using these tools is that you
    can create extremely complex geometrical shapes without having to worry about
    the mathematical concepts involved behind it. After the model is created, you
    can export them in a variety of 3D file formats in your program. These 3D geometry
    models are also called meshes.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这种复杂的几何形状的最佳方式是使用计算机辅助设计工具来创建它们；这些工具不仅节省时间，而且可以创建用于可视化的模型。使用这些工具的主要优势是，您可以在不担心背后涉及的数学概念的情况下创建极其复杂的几何形状。模型创建后，您可以在程序中以各种3D文件格式导出它们。这些3D几何模型也称为网格。
- en: In this chapter, you will learn how to create simple meshes using Blender, which
    is an open source 3D modeling tool. We will discuss and understand two very famous
    3D mesh model types, OBJ and 3Ds, and try to understand their specifications.
    You will also learn how to write a parser for these models in your OpenGL ES recipes.
    In addition, this chapter will cover various aspects of the 3D mesh model that
    will be helpful to render them to 3D graphics.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用Blender创建简单的网格，Blender是一个开源的3D建模工具。我们将讨论并理解两种非常著名的3D网格模型类型，OBJ和3Ds，并尝试理解它们的规格。您还将学习如何在您的OpenGL
    ES食谱中编写这些模型的解析器。此外，本章还将涵盖3D网格模型的各个方面，这将有助于将它们渲染为3D图形。
- en: Creating polygon meshes with Blender
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Blender创建多边形网格
- en: A polygon mesh is a collection of vertices, faces, normal, colors, or textures
    that collectively define a 3D model. This 3D model can be directly used in various
    3D applications, such as computer graphics, simulator, animation movies, and CAD/CAM.
    In this section, you will learn how to create mesh models in Blender, which we
    will use throughout the course of this book to demonstrate our recipes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 多边形网格是由顶点、面、法线、颜色或纹理组成的集合，共同定义了一个3D模型。这个3D模型可以直接用于各种3D应用程序，如计算机图形、模拟器、动画电影和CAD/CAM。在本节中，您将学习如何在Blender中创建网格模型，我们将在整个书籍的教程中使用这些模型来演示我们的食谱。
- en: In this chapter, we will use Blender 2.68 to develop our 3D model meshes. Blender
    is a free and open source 3D computer graphics tool. You may use other similar
    software of your choice, such as 3Ds Max, Maya, Google Sketch, and so on.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Blender 2.68来开发我们的3D模型网格。Blender是一个免费且开源的3D计算机图形工具。您可以使用其他类似软件，如3Ds
    Max、Maya、Google Sketch等。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You can download the latest version of Blender from [http://www.blender.org/download](http://www.blender.org/download)
    and install it as per the instructions given on the website.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.blender.org/download](http://www.blender.org/download)下载Blender的最新版本，并按照网站上的说明进行安装。
- en: 'Blender is cross-platform and runs on several popular computing platforms.
    Blender allows a number of geometric primitives, including various polygon meshes,
    subdivision surface modeling, and smart geometric editing tools. It also allows
    various texture techniques to be implemented to geometry surfaces. When Blender
    is launched for the first time, you will find the tool interface, as given in
    the following screenshot:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Blender是跨平台的，可以在多个流行的计算平台上运行。Blender允许使用多种几何原语，包括各种多边形网格、细分曲面建模和智能几何编辑工具。它还允许在几何表面上实现各种纹理技术。当Blender首次启动时，你将找到如图所示的工具界面：
- en: '![Getting ready](img/5527OT_04_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/5527OT_04_01.jpg)'
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: This section will provide a step-by-step procedure to create mesh models in
    Blender 2.68\. We will understand the simple steps to create these meshes and
    export them to `wavefront.obj` and 3Ds formats so that they can be used for demonstration
    purposes in later recipes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将提供一个逐步过程，介绍如何在Blender 2.68中创建网格模型。我们将了解创建这些网格的简单步骤，并将它们导出为`wavefront.obj`和3Ds格式，以便在后面的食谱中用于演示目的。
- en: When Blender is launched for the first time, a cube-shaped object will be displayed
    in the middle of the canvas grid. If you are not interested to use this cube,
    you can delete this. In order to delete an object from the canvas grid, select
    it (by placing the cursor on it and right-clicking on it) and click on the delete
    key on the keyboard. Alternatively, you can select an object and click on the
    **X** and *Enter* key to delete the selected object.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当Blender首次启动时，画布网格中间将显示一个立方体对象。如果你不打算使用这个立方体，你可以删除它。为了从画布网格中删除一个对象，选择它（通过将光标放在它上面并右键单击它）然后在键盘上点击删除键。或者，你可以选择一个对象并点击**X**和*Enter*键来删除选定的对象。
- en: By default, there are 10 basic mesh models available in Blender, which can be
    collectively used to create more complex shapes. Depending on the Blender version
    type, the UI interface may appear different. However, the basic functionality
    is the same. In order to add a new mesh model, navigate to menu, click on **Add**
    | **Mesh**, and select the desired model (for example, UV sphere). In the newer
    Blender versions (such as 2.7.0 and later versions), you may find this option
    on the left-hand side panel under the **Create** tab, as shown in the following
    screenshot:![How to do it...](img/5527OT_04_02.jpg)
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，Blender中有10种基本网格模型可用，可以一起使用来创建更复杂的形状。根据Blender版本类型，UI界面可能有所不同。然而，基本功能是相同的。为了添加新的网格模型，导航到菜单，点击**添加**
    | **网格**，并选择所需的模型（例如，UV球体）。在新版本的Blender（如2.7.0及以后版本）中，你可能会在左侧面板的**创建**选项卡下找到此选项，如下面的截图所示：![如何操作...](img/5527OT_04_02.jpg)
- en: You can change the model properties for each model from the left-hand side pane,
    as shown in the following screenshot:![How to do it...](img/5527OT_04_03.jpg)
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以从左侧面板更改每个模型的模型属性，如下面的截图所示：![如何操作...](img/5527OT_04_03.jpg)
- en: For each mesh, you can change the location and apply rotations as well. For
    all our recipes, we will use Location as (0.0, 0.0, and 0.0) so that the mesh
    always appears on the origin of the canvas grid.
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于每个网格，你可以更改位置并应用旋转。在我们的所有食谱中，我们将使用位置为（0.0，0.0，0.0），这样网格总是出现在画布网格的原点上。
- en: The model can be edited in the edit mode by selecting the mesh object and clicking
    on the *Tab* button. In the edit model, the geometry of the mesh can be enhanced.
    For example, the surface of the mesh object can be subdivided into many smaller
    surfaces in order to enhance the smoothness of surfaces. In the edit mode, you
    can select the subdivide menu option to subdivide the selected objects surface.
    The following image shows how subdivision works:![How to do it...](img/5527OT_04_04.jpg)
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过选择网格对象并点击*Tab*按钮在编辑模式中编辑模型。在编辑模式中，可以增强网格的几何形状。例如，网格对象的表面可以被细分成许多更小的表面，以增强表面的平滑度。在编辑模式中，你可以选择细分菜单选项来细分选定的对象表面。以下图像显示了细分的工作原理：![如何操作...](img/5527OT_04_04.jpg)
- en: Export the created model using the **File** | **Export** menu option. We will
    export the created model in the wavefront and the 3Ds mesh formats. In the following
    sections, we will see how of these mesh formats are used in our recipes:![How
    to do it...](img/5527OT_04_05.jpg)
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**文件** | **导出**菜单选项导出创建的模型。我们将以wavefront和3Ds网格格式导出创建的模型。在接下来的章节中，我们将看到这些网格格式在我们的食谱中的应用：![如何操作...](img/5527OT_04_05.jpg)
- en: 'While exporting in the wavefront (`.obj`) format, you may need to select the
    following options, depending on your requirements:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以Wavefront（`.obj`）格式导出时，您可能需要根据您的需求选择以下选项：
- en: '**Include edges**: This exports edges as two-sided faces.'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包含边**：这将边导出为双面面。'
- en: '**Triangulate faces**: Instead of writing faces as a quad, each quad is represented
    using three triangles. We must select this option for our mesh models.'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**三角化面**：不是将面作为四边形来写，每个四边形都使用三个三角形来表示。我们必须为我们的网格模型选择此选项。'
- en: '**Include UVs (optional)**: This writes the texture coordinate information
    about the geometry surface'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包含UVs（可选）**：写入关于几何表面的纹理坐标信息'
- en: '**Include normals (optional)**: This writes the face and vertex normal depending
    on the face smooth settings:'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包含法线（可选）**：根据面的平滑设置写入面和顶点法线：'
- en: '![How to do it...](img/5527OT_04_06.jpg)'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/5527OT_04_06.jpg)'
- en: Note
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The **Include Normals** is optional; it calculates the face normal and writes
    to the file-exported file format. Additionally, calculating normal at runtime
    will incur some extra processing cost. This feature is useful to minimize runtime
    calculations at the expense of a large file and the memory utilized while reading
    this file.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**包含法线**是可选的；它计算面法线并将其写入文件导出的文件格式。此外，在运行时计算法线将产生一些额外的处理成本。此功能可以通过牺牲大文件和读取此文件时使用的内存来最小化运行时计算。'
- en: Alternatively, you can calculate the normal with the face information provided
    within the mesh model. Later in this recipe, you will learn how the normal is
    calculated using the face information.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，您可以使用网格模型内提供的面信息来计算法线。在本食谱的后面部分，您将学习如何使用面信息来计算法线。
- en: To export the 3Ds format, use all the default export options.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要导出3Ds格式，请使用所有默认导出选项。
- en: Note
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The meshes (created in this chapter) do not contain any texture-based information.
    We will use texture-based models in our later chapter.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本章创建的网格不包含任何基于纹理的信息。我们将在后面的章节中使用基于纹理的模型。
- en: While using Blender, the settings can be restored to default factory settings
    at any time by selecting **File** | **Load Factory Settings**.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用Blender时，可以通过选择**文件** | **加载工厂设置**在任何时候将设置恢复到默认工厂设置。
- en: There's more...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: The exported models from Blender and other sample models in the wavefront and
    3Ds format can be found in the `GLPIFramework` folder under `Models`. Feel free
    to explore them. [Chapter 5](ch05.html "Chapter 5. Light and Materials"), *Light
    and Materials*, makes extensive use of wavefronts models to demonstrate various
    types of lights.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GLPIFramework`文件夹下的`Models`中可以找到从Blender和其他示例模型导出的Wavefront和3Ds格式的模型。您可以自由探索它们。[第5章](ch05.html
    "第5章。光与材质")，*光与材质*，广泛使用了Wavefront模型来演示各种类型的光。
- en: See also
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Rendering the wavefront OBJ mesh model*'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*渲染Wavefront OBJ网格模型*'
- en: '*Rendering the 3Ds mesh model*'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*渲染3Ds网格模型*'
- en: Rendering the wavefront OBJ mesh model
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染Wavefront OBJ网格模型
- en: The wave file format is a famous 3D mesh model format developed by wavefront
    technologies. It contains the mesh geometry information in a readable text format.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 波文件格式是由Wavefront技术公司开发的一种著名的3D网格模型格式。它以可读的文本格式包含网格几何信息。
- en: 'The wavefront format mainly consists of two types of files: `.obj` and `.mtl`.
    The `.obj` file is responsible for describing the geometrical information of the
    3D model, such as vertex position, normal, texture coordinates faces, and so on.
    The `.mtl` file is optional and contains material information for individual mesh
    parts, such as the texture and shading (diffuse, specular, and so on) information.
    Also, the `.mtl` file is exported automatically if it contains the texture information;
    otherwise, you must set **Write Materials**. The term material here refers to
    the color or texture of an object. The models that we have exported do not contain
    any texture information. Therefore, these models only consist of `.obj` files.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Wavefront格式主要包含两种类型的文件：`.obj`和`.mtl`。`.obj`文件负责描述3D模型的几何信息，如顶点位置、法线、纹理坐标和面等。`.mtl`文件是可选的，包含单个网格部分的材质信息，如纹理和着色（漫反射、镜面等）信息。此外，如果`.mtl`文件包含纹理信息，它将自动导出；否则，您必须设置**写入材质**。这里的材质指的是物体的颜色或纹理。我们导出的模型不包含任何纹理信息。因此，这些模型只包含`.obj`文件。
- en: '**File format**: As the wave front format is readable, you can open it in any
    text editor and read it. It uses special keywords to recognize specific types
    of information. The following table will help you to understand the keywords used
    for the wavefront file format:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '| Keyword | Meaning | Sample |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
- en: '| `#` | Anything starting with `#` is considered as a comment. | This file
    is created using Blender 2.65 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
- en: '| `v` | This is the vertex position that specifies x, y, and z coordinates.
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
- en: v 1.000000 -1.000000 -1.000000
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: v 1.000000 -1.000000 1.000000
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: v -1.000000 -1.000000 1.000000
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '| `vt` | This specifies texture coordinates in the range of 0.0 to 1.0. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
- en: vt 0.0 0.0
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: vt 1.0 0.0
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: vt 1.0 1.0
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: vt 0.0 1.0
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '| `vn` | This represents Normals at each vertex position. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
- en: vn 0.0 1.0 0.0
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: vn 0.0 0.0 1.0
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '| `f` | This contains the face information. Each face is defined with vertex
    (v) followed by texture coordinates (u) and vertex normal (n). The syntax for
    the face information is [v]/[u]/[n]. | Face information various formats:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Vertex coordinates: f 1 2 3'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Vertex and texture coords: f 1/1 3/2 4/3'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Vertex and texture normal: f 1/1/2 3/2/1 4/3/2'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Vertex and normal coords: f 1//2 3//1 4//2'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows a sample wavefront (`.obj`) file when it''s opened
    in a text editor. This sample only contains the vertex and face information, which
    is a minimal requirement of a mesh model to render to any 3D graphics visualization
    tool. Depending on the chosen export options, more mesh attributes can be seen
    with new keywords:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering the wavefront OBJ mesh model](img/5527OT_04_07.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: The actual capabilities of the wavefront OBJ model are way beyond what we have
    specified in the file format. Covering all the specifications of `.obj` is beyond
    the scope of this book. You can refer to [http://paulbourke.net/dataformats/obj](http://paulbourke.net/dataformats/obj)
    for the full set of specifications. This recipe essentially covers the most important
    and critical parts of the specification, in which you will learn how to parse
    the geometrical information. Our tiny parser and renderer will help you to understand
    the concept of meshes in-depth and allow you to program any other kind of mesh
    file formats.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can explore more about wavefront OBJ file format specifications at [http://paulbourke.net/dataformats/obj/](http://paulbourke.net/dataformats/obj/).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The 3D models we created in Blender need to be imported into the project. Android
    and iOS have different ways to access their resources:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '**Android**: On Android, 3D mesh models need to copy from `GLPIFramework/Models`
    and store it in the memory card under the `sdcard/Models` folder'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iOS**: Add the `GLPIFramework/Models` folder to the project using **File**
    | **Add Files to [Project Name]**'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class and data structure**: The `OBJMesh` class is responsible for parsing
    wavefront OBJ mesh models; it uses necessary data structures to store the parsed
    wavefront OBJ information. This class is defined in `WaveFrontObj.h`/`.cpp` under
    our `GLPIframework/WaveFrontOBJ` folder. Here are the necessary data structure
    that are used by this class:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**类和数据结构**：`OBJMesh`类负责解析波前OBJ网格模型；它使用必要的数据结构来存储解析的波前OBJ信息。此类定义在`GLPIframework/WaveFrontOBJ`文件夹下的`WaveFrontObj.h`/`.cpp`中。以下是此类使用的必要数据结构：'
- en: '**Vertex**: This structure will store the information of each vertex, which
    exists in the 3D geometry. It contains position coordinates of each vertex along
    the *x*, *y*, and *z* axis in the position variable. Texture coordinates are stored
    in the *uv* variable. Normal coordinates are stored in the normal variable. The
    tangential information at each vertex is stored in the tangent:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点**：此结构将存储3D几何中每个顶点的信息。它包含每个顶点沿*x*、*y*和*z*轴的位置坐标，存储在位置变量中。纹理坐标存储在*uv*变量中。法线坐标存储在法线变量中。每个顶点的切向信息存储在切线中：'
- en: '[PRE0]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Face index**: This structure is responsible for storing the face-related
    information. For example, it stores all indexes of the vertices, texture coordinates,
    and normals that are helpful in defining the face:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面索引**：此结构负责存储与面相关的信息。例如，它存储了所有有助于定义面的顶点、纹理坐标和法线的索引：'
- en: '[PRE1]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Mesh**: The mesh data structure is responsible for storing the Mesh geometry
    information. It contains the complete path of the OBJ file in the `fileName` variable
    that needs to be parsed. The class contains the information on vertex, texture,
    and normal in the form of a vector array. This is stored in the positions, UVs,
    and normals vector list variables respectively. The `vecFaceIndex` stores the
    information of each face in the form of an index for each vertex making the face.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网格**：网格数据结构负责存储网格几何信息。它包含需要解析的OBJ文件的完整路径，存储在`fileName`变量中。该类以向量数组的形式包含顶点、纹理和法线信息。这些信息分别存储在位置、UV和法线向量列表变量中。`vecFaceIndex`以每个顶点形成面的索引形式存储每个面的信息。'
- en: 'The indices stores the vertex index for each face and is used to calculate
    normals if the normal information is not available in the `.obj` mesh file:'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 索引存储每个面的顶点索引，并在`.obj`网格文件中没有法线信息时用于计算法线：
- en: '[PRE2]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How to do it...
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'This section will provide a step-by-step procedure to parse and render the
    wavefront OBJ mesh model in OpenGL ES 3.0\. Let''s start the recipe using the
    following steps:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将提供逐步解析和渲染OpenGL ES 3.0中的波前OBJ网格模型的过程。让我们按照以下步骤开始：
- en: Create a `ObjLoader` class derived from the `Model` class. It will inherit all
    the member functions of `Model` necessary for the life cycle of `ObjLoader`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个从`Model`类派生的`ObjLoader`类。它将继承`ObjLoader`生命周期所需的`Model`类的所有成员函数。
- en: 'This class contains member variables to store the wavefront model mesh information.
    The mesh model is parsed using `ObjMesh` function''s `waveFrontObjectModel` object.
    This object calls the `parseObjMesh` function, which accepts the path for the
    3D wavefront OBJ model as an argument that we are interested to load on:'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个类包含成员变量以存储波前模型网格信息。网格模型使用`ObjMesh`函数的`waveFrontObjectModel`对象进行解析。此对象调用`parseObjMesh`函数，该函数接受3D波前OBJ模型的路径作为参数，这是我们想要加载的：
- en: '[PRE3]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `ParseObjModel` function further calls a set of helper functions to store
    and process the mesh information from the `.obj` file. This function returns the
    `Mesh` object pointer. This function accepts the path of the file to be loaded
    and another argument that specifies whether the normal needs to be calculated
    as flat or smooth:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ParseObjModel`函数进一步调用一系列辅助函数来存储和处理`.obj`文件中的网格信息。此函数返回`Mesh`对象指针。此函数接受要加载的文件路径以及另一个参数，指定是否需要计算法线为平面或平滑：'
- en: '[PRE4]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `ParseFileInfo` reads the path of the mesh model to validate its existence.
    This function parses the file by reading each line in it. Each line contains a
    keyword at the beginning that specifies the type of information it contains. The
    `#`, `u`, `s`, or `g` keywords are ignored as they are not used in the parser.
    The `#` keyword is used to write comments in the wavefront file. The parsed information
    from this function is collected in the mesh''s object pointer:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ParseFileInfo`函数读取网格模型的路径以验证其存在。此函数通过读取文件中的每一行来解析文件。每一行开头都有一个关键字，指定它包含的信息类型。`#`、`u`、`s`或`g`关键字被忽略，因为它们在解析器中未使用。`#`关键字用于在wavefront文件中写入注释。从该函数解析的信息收集在网格的对象指针中：'
- en: '[PRE5]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The line starting with the `v` keyword represents vertex attributes, which
    could be of three types of information: vertex position (`v`), vertex texture
    coordinate (`vt`), and vertex normal (`vn`). This information is read using the
    `ScanVertexNormalAndUV` function.'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以`v`关键字开头的行表示顶点属性，这些属性可能包含三种类型的信息：顶点位置（`v`）、顶点纹理坐标（`vt`）和顶点法线（`vn`）。此信息是通过使用`ScanVertexNormalAndUV`函数读取的。
- en: 'This function parses each line and stores the information of vertex position,
    texture coordinate, and vertex normal in `objMeshModel.positions`, `objMeshModel.uvs`,
    and `objMeshModel.normals` respectively:'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数解析每一行，并将顶点位置、纹理坐标和顶点法线的信息分别存储在`objMeshModel.positions`、`objMeshModel.uvs`和`objMeshModel.normals`中：
- en: '[PRE6]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Similarly, the line starting with the `f` keyword and followed by a " " space
    represents faces. A face is made up of three vertices and each vertex may consist
    of three attributes: vertex position, texture coordinates, and vertex normal.'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，以`f`关键字开头并跟有一个空格的行表示面。一个面由三个顶点组成，每个顶点可能包含三个属性：顶点位置、纹理坐标和顶点法线。
- en: Each face stores information in the form of an index. An index here refers to
    the index of an actual element in the stored arrays (calculated in step five).
    For example, an index of two for the vertex position in a given face means a third
    vertex element in the `objMeshModel.positions` vector array.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个面以索引的形式存储信息。这里的索引指的是存储数组中实际元素的索引（在第5步中计算）。例如，给定面中顶点位置的索引为二表示`objMeshModel.positions`向量数组中的第三个顶点元素。
- en: Gather the face index information in the `objMeshModel.vecFaceIndex` vector
    list. This list contains all faces that have the indices of vertex attributes
    belonging to each vertex of the face. For more information, refer to the `ObjMesh::ScanFaceIndex`
    function.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`objMeshModel.vecFaceIndex`向量列表中收集面索引信息。此列表包含属于每个面的顶点属性索引的所有面。有关更多信息，请参阅`ObjMesh::ScanFaceIndex`函数。
- en: 'Using the face index information gathered in `objMeshModel.vecFace`, populate
    the `objMeshModel.vertices` vector list. This list contains vertex attributes
    to be used to create the Vertex Buffer Object:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用在`objMeshModel.vecFace`中收集到的面索引信息，填充`objMeshModel.vertices`向量列表。此列表包含用于创建顶点缓冲对象的顶点属性：
- en: '[PRE7]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If the normal attribute is missing in the OBJ file, it can be calculated using
    `OBJMesh::CalculateNormal()`. For more information, refer to the *There's more...*
    section in this recipe.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果OBJ文件中缺少法线属性，可以使用`OBJMesh::CalculateNormal()`来计算。有关更多信息，请参阅本食谱中的*更多内容...*部分。
- en: Similarly, the tangent information at each vertex is calculated using `OBJMesh::CalculateTangents()`.
    You can refer to bump mapping in [Chapter 5](ch05.html "Chapter 5. Light and Materials"),
    *Light and Materials*, to understand the working of this function thoroughly.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，每个顶点的切线信息是通过使用`OBJMesh::CalculateTangents()`计算的。你可以参考[第5章](ch05.html "第5章。光与材料")中的凹凸贴图，以深入了解此函数的工作原理。
- en: 'Once the OBJ mesh information is parsed and stored in mesh''s object, clear
    all the temporary data structure using the `ClearMesh` function:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦OBJ网格信息被解析并存储在网格对象中，使用`ClearMesh`函数清除所有临时数据结构：
- en: '[PRE8]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After parsing the OBJ file, create the VBO within the `ObjLoader` constructor:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析完OBJ文件后，在`ObjLoader`构造函数内创建VBO：
- en: '[PRE9]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `ParseObjMesh` function in the `OBJMesh` class is responsible for parsing
    the wavefront OBJ file and storing the information in the mesh's `objMeshModel`
    object variable. This function parses the file and recognizes vertex attributes,
    such as vertex position, texture coordinates, and vertex normals. It stores these
    attributes in the `objMeshModel.positions`, `objMeshModel.uvs`, and `objMeshModel.normals`
    respective vector arrays. These vector arrays are contiguous in nature. Therefore,
    these arrays can be used directly to pick elements using the index information.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`OBJMesh`类中的`ParseObjMesh`函数负责解析波前OBJ文件并将信息存储在网格的`objMeshModel`对象变量中。此函数解析文件并识别顶点属性，如顶点位置、纹理坐标和顶点法线。它将这些属性存储在`objMeshModel.positions`、`objMeshModel.uvs`和`objMeshModel.normals`相应的向量数组中。这些向量数组在本质上连续。因此，可以直接使用索引信息来选择元素。'
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The vertex texture and vertex normal are optional attributes. Without these,
    the geometry can still be produced. Texture coordinates only get stored if the
    model contains any texture. The normal can be saved in the OBJ file by selecting
    **Include Normals** in export options. For more information on .OBJ mesh model
    export options, refer to, the *How to do it...* section under the *Creating polygon
    meshes with Blender* recipe in this chapter for more information on OBJ mesh model
    export options.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点纹理和顶点法线是可选属性。没有这些属性，几何形状仍然可以生成。只有当模型包含任何纹理时，纹理坐标才会被存储。可以通过在导出选项中选择**包含法线**来在OBJ文件中保存法线。有关.OBJ网格模型导出选项的更多信息，请参阅本章“使用Blender创建多边形网格”配方下的*如何做...*部分，以获取有关OBJ网格模型导出选项的更多信息。
- en: After parsing the vertex attribute information, the face information needs to
    be parsed. Each face is made up of three vertices. These vertices can contain
    the position, texture, and normal information. The information for each vertex
    attribute in the face is stored in the form of an index. The face information
    in the `objMeshModel.vecFaceIndex` must be stored in the vector array list.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 解析顶点属性信息后，需要解析面信息。每个面由三个顶点组成。这些顶点可以包含位置、纹理和法线信息。面中每个顶点属性的信息以索引的形式存储。`objMeshModel.vecFaceIndex`中的面信息必须存储在向量数组列表中。
- en: The `objMeshModel.vertices` is another vector-based array that is contiguous
    in nature and in the interleaved form. Each record in array represents a vertex
    element, which contains vertex positions, texture coordinates, and normal attributes.
    The `OBJMesh::CreateInterleavedArray` function is responsible for generating this
    array. The Interleaved fashion array is highly recommended as it contains different
    attribute data in a single array, thereby sufficient to store a single VBO. However,
    if the data is not stored interleaved, each attribute will be stored in a separate
    array. For each data array, a separate VBO is required. Use of too many VBOs is
    performance killing because the rendering pipeline spends more time binding and
    switching VBOs.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`objMeshModel.vertices`是另一个本质上连续且交错形式的基于向量的数组。数组中的每个记录代表一个顶点元素，它包含顶点位置、纹理坐标和法线属性。`OBJMesh::CreateInterleavedArray`函数负责生成此数组。交错数组非常推荐，因为它在单个数组中包含不同的属性数据，因此足以存储单个VBO。然而，如果数据不是交错存储的，每个属性将存储在单独的数组中。对于每个数据数组，都需要单独的VBO。使用过多的VBO会严重影响性能，因为渲染管线会花费更多时间绑定和切换VBO。'
- en: 'The OBJ model data are to be drawn using `GL_TRIANGLES`. The fragment shader
    used will provide different effects based on the information passed (for example,
    texture coordinates, lighting information, and so on) in the upcoming chapters.
    We will apply various vertex and fragment shaders to OBJ meshes in order to produce
    mind-blowing real-time rendering effects:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: OBJ模型数据应使用`GL_TRIANGLES`绘制。所使用的片段着色器将根据传递的信息（例如，纹理坐标、光照信息等）在接下来的章节中提供不同的效果。我们将应用各种顶点和片段着色器到OBJ网格上，以产生令人惊叹的实时渲染效果：
- en: '![How it works...](img/5527OT_04_08.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/5527OT_04_08.jpg)'
- en: There's more...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Normal's information plays an important role in the light shading of 3D objects.
    Our wavefront exported models do not contain any normal information. This section
    will help us in calculating normals using the face information.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 法线信息在3D对象的光照着色中起着重要作用。我们导出的波前模型不包含任何法线信息。本节将帮助我们使用面信息计算法线。
- en: 'There are two ways in which the normal can be calculated:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 法线可以通过两种方式计算：
- en: '**Face normal**: This is calculated using a single face information. This type
    of normal results in flat shading. It''s calculated using a cross product of any
    two edges formed by the triangle face. In other words, it''s perpendicular to
    the surface generated by coplanar vertices.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面法线**: 这是通过单一的面信息计算得出的。这种类型的法线会导致平面着色。它是通过三角面形成的任意两个边的叉积来计算的。换句话说，它是垂直于由共面顶点生成的表面的。'
- en: '**Vertex normal**: This is calculated by taking the average of the face normal
    created by faces that share common vertices:![There''s more...](img/5527OT_04_09.jpg)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点法线**: 这是通过取共享公共顶点的面创建的法线的平均值来计算的：![还有更多...](img/5527OT_04_09.jpg)'
- en: The preceding image shows the face and vertex normal. Each face normal is calculated
    using four vertices, which form a plane surface. Out of these four vertices, any
    of the three vertices can be used to form two edges. The cross product of these
    two edges results a perpendicular vector to plane. Normalizing this vector produces
    a face normal.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图像显示了面和顶点法线。每个面法线都是使用四个顶点计算得出的，这些顶点形成一个平面表面。在这四个顶点中，可以使用任意三个顶点形成两条边。这两条边的叉积产生一个垂直于平面的向量。归一化这个向量产生一个面法线。
- en: In contrast, each vertex shows the vertex normal in the blue colored line, which
    is formed by four planes or four faces surrounded around each vertex. The average
    of these four planes face normal results a vertex normal. Vertex normal is extremely
    important to generate highly detailed and smooth geometrical appearance without
    requiring too many vertices.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，每个顶点都显示由围绕每个顶点的四个平面或四个面形成的蓝色线条表示的顶点法线。这四个平面法线的平均值产生一个顶点法线。顶点法线对于生成高度详细且平滑的几何外观非常重要，而无需太多顶点。
- en: 'The flat shade or smooth shade normal can be calculated using `ParseObjMesh`
    with the second parameter as Boolean `true` for flat shading and Boolean `false`
    for smooth shading. Internally, this function calls `OBJMesh::CalculateNormal`,
    which is responsible for the mathematical calculation of normal:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 平滑着色或平滑着色法线可以使用 `ParseObjMesh` 计算，第二个参数作为布尔值 `true` 用于平面着色，布尔值 `false` 用于平滑着色。内部，这个函数调用
    `OBJMesh::CalculateNormal`，它负责法线的数学计算：
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The face normal points to the direction where polygons face. However, vertex
    normal changes the gradient of the polygon. If we change the direction of the
    vertex normal, the shading around that vertex will `http://change.at/" \t "_blank`,
    this gradient is as same as a flat polygon that's rotated in the same direction.
    The computer fakes a gradient over the polygon.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 面法线指向多边形面向的方向。然而，顶点法线改变了多边形的梯度。如果我们改变顶点法线的方向，该顶点周围的着色将 `http://change.at/" \t
    "_blank`，这个梯度与旋转相同方向的一个平面多边形相同。计算机在多边形上伪造了一个梯度。
- en: 'The following image shows how a simple sphere on the left-hand side appears
    without a light shading technique. In fact, it''s difficult to believe that it''s
    a sphere mesh model. The middle and rightmost mesh models are demonstrated using
    light shades. The prior mesh model uses the flat light shading, which is achieved
    using face normals, whereas the latter mesh model renders the same mesh model
    with vertex normals:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了左侧的简单球体在没有光照着色技术的情况下看起来如何。实际上，很难相信它是一个球体网格模型。中间和最右侧的网格模型使用光照着色进行演示。前面的网格模型使用平面光照着色，这是通过面法线实现的，而后面的网格模型以顶点法线渲染相同的网格模型：
- en: '![There''s more...](img/5527OT_04_10.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/5527OT_04_10.jpg)'
- en: See also
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Efficient rendering with Vertex Buffer Object* recipe [Chapter
    2](ch02.html "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES 3.0 Essentials*
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅 *使用顶点缓冲对象进行高效渲染* 菜谱 [第2章](ch02.html "第2章. OpenGL ES 3.0 基础"), *OpenGL ES
    3.0 基础*
- en: Refer to the *Phong shading – per-fragment shading technique* recipe in [Chapter
    5](ch05.html "Chapter 5. Light and Materials"), *Light and Materials*
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅 [第5章](ch05.html "第5章. 光照和材质") 中的 *Phong 着色 – 每片段着色技术* 菜谱，*光照和材质*
- en: Refer to the *Gouraud shading – the per-fragment shading technique and Phong
    shading – the per-fragment shading technique recipes* recipes in [Chapter 5](ch05.html
    "Chapter 5. Light and Materials"), *Light and Materials*
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅 [第5章](ch05.html "第5章. 光照和材质") 中的 *Gouraud 着色 – 每片段着色技术和 Phong 着色 – 每片段着色技术*
    菜谱，*光照和材质*
- en: Refer to the *Implementing bump mapping* recipe in [Chapter 7](ch07.html "Chapter 7. Textures
    and Mapping Techniques"), *Texture and Mapping Techniques*
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅 [第7章](ch07.html "第7章. 纹理和映射技术") 中的 *实现凹凸映射* 菜谱，*纹理和映射技术*
- en: Refer to the *Managing VBO with Vertex Array Objects* recipe in [Chapter 3](ch03.html
    "Chapter 3. New Features of OpenGL ES 3.0"), *New Features of OpenGL ES 3.0*
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第3章中的*使用顶点数组对象管理VBO*配方，*OpenGL ES 3.0的新特性*。
- en: Rendering the 3Ds mesh model
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染3Ds网格模型
- en: The 3Ds mesh format is a well-known 3D mesh file format used in computer graphics.
    Unlike wavefront, it's not text-based and stores the mesh information in a binary
    form. This is used widely in Autodesk 3D Studio Max and is a professional 3D graphics
    program software to create 3D animation and models.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 3Ds网格格式是计算机图形中广泛使用的知名3D网格文件格式。与wavefront不同，它不是基于文本的，并以二进制形式存储网格信息。这被广泛用于Autodesk
    3D Studio Max，是一款专业的3D图形程序软件，用于创建3D动画和模型。
- en: '**File format**: This section will provide an overview of the 3Ds file format.
    This mesh format contains information in the form of a hierarchy of chunks. A
    chunk is a structured piece of information in the memory. Its unique ID recognizes
    each chunk, which contains the size information (in bytes) that can be used to
    read or skip chunks. The size information of the current chunk is always relative
    to its start memory position; skipping this much size will point to the next chunk.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件格式**：本节将概述3Ds文件格式。这种网格格式包含以块层次结构形式的信息。块是内存中结构化信息的一部分。其唯一的ID识别每个块，其中包含可用于读取或跳过块的大小信息（以字节为单位）。当前块的大小信息始终相对于其起始内存位置；跳过这么多大小将指向下一个块。'
- en: 'The following table shows that each chunk is represented with the **Start**
    field, which contains the memory location within the 3Ds file. The **Size** field
    tells us how big is the chunk in bytes, whereas the **End** field specifies the
    memory location where the chunk finishes. The **End** field can be calculated
    with the help of the *Size – Start + 1* formula. The next chunk information is
    always relative to the current chunk position:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示，每个块都由**开始**字段表示，该字段包含3Ds文件中的内存位置。**大小**字段告诉我们块的大小（以字节为单位），而**结束**字段指定了块结束的内存位置。**结束**字段可以通过*大小
    - 开始 + 1*公式计算得出。下一个块信息始终相对于当前块位置：
- en: '| Start | End | Size | Name |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 开始 | 结束 | 大小 | 名称 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | 1 | 2 | Chunk ID |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 2 | 块ID |'
- en: '| 2 | 5 | 4 | Next chunk |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 5 | 4 | 下一个块 |'
- en: 'Each chunks ID in the 3Ds file has a predefined meaning associated with it.
    For example, the first chunk ID of this file format is always `0x4d4d`. This chunk
    is called the primary or main chunk ID. The other important chunks exist under
    this primary chunk as child nodes, as shown in the following screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 3Ds文件中的每个块ID都与它相关的预定义意义。例如，此文件格式的第一个块ID始终是`0x4d4d`。这个块被称为主要或主块ID。其他重要的块作为子节点存在于这个主要块下，如下面的截图所示：
- en: '![Rendering the 3Ds mesh model](img/5527OT_04_11.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![渲染3Ds网格模型](img/5527OT_04_11.jpg)'
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The detailed specification of 3Ds is beyond the scope of this book. You can
    find more information about this specification at [http://www.martinreddy.net/gfx/3d/3DS.spec](http://www.martinreddy.net/gfx/3d/3DS.spec).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 3Ds的详细规范超出了本书的范围。您可以在[http://www.martinreddy.net/gfx/3d/3DS.spec](http://www.martinreddy.net/gfx/3d/3DS.spec)找到有关此规范更多信息。
- en: Getting ready
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will parse the 3Ds file format using a third-party library
    called `lib3ds`. This is an open source library that helps us to parse the file
    and provide us the file data in the form of a data structure. This library is
    written in ANCI-C. Therefore, it's portable across platforms. The lib3ds is available
    for commercial application under GNU **Lesser General Public** **License** (**LGPL**).
    The library can be download from [https://code.google.com/p/lib3ds/](https://code.google.com/p/lib3ds/).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将使用名为`lib3ds`的第三方库解析3Ds文件格式。这是一个开源库，帮助我们解析文件，并以数据结构的形式提供文件数据。这个库是用ANCI-C编写的。因此，它可以在各个平台上移植。lib3ds可以在GNU
    **较小通用公共** **许可证**（**LGPL**）下用于商业应用。可以从[https://code.google.com/p/lib3ds/](https://code.google.com/p/lib3ds/)下载这个库。
- en: In our GLPI framework, this library is present under the `GLPIFramework/3DSParser/lib3ds`
    folder. We have used the 1.30 version for this library. Rendering 3DS mesh models
    to the application requires these to be stored at some appropriate location on
    the device or simulator.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的GLPI框架中，这个库位于`GLPIFramework/3DSParser/lib3ds`文件夹下。我们为这个库使用了1.30版本。将3DS网格模型渲染到应用程序中需要将这些模型存储在设备或模拟器上的某个适当位置。
- en: On the Android device, you can store 3DS mesh model files under the `sdcard/GLPIFramework/Model`
    folder. For iOS, these models can be added to the project using **File** | **Add
    Files to [Project Name]**.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 设备上，您可以将 3DS 网格模型文件存储在 `sdcard/GLPIFramework/Model` 文件夹下。对于 iOS，可以使用
    **文件** | **将文件添加到 [项目名称]** 来将这些模型添加到项目中。
- en: '**Android**: On the Android platform, we need the makefile to build the `lib3ds`
    library. Add the `Android.mk` makefile under `GLPIFramework/3DSParser/lib3ds`.
    Edit this makefile, as shown in the following code. This library will be compiled
    as a shared library, which is named as `mylib3ds`. You can also directly add the
    source code in the main project makefile, instead of compiling a shared library:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**Android**：在 Android 平台上，我们需要 makefile 来构建 `lib3ds` 库。在 `GLPIFramework/3DSParser/lib3ds`
    下添加 `Android.mk` makefile。编辑此 makefile，如下所示。此库将被编译为共享库，命名为 `mylib3ds`。您也可以直接在主项目
    makefile 中添加源代码，而不是编译共享库：'
- en: '`Android.mk`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`Android.mk`:'
- en: '[PRE11]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Open the `Android.mk` makefile present in the project directory under the `JNI`
    folder and include the path of the `lib3ds` library `Android.mk` file that we
    have created in the preceding code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 打开位于 `JNI` 文件夹下项目目录中的 `Android.mk` makefile，并包含我们之前代码中创建的 `lib3ds` 库 `Android.mk`
    文件路径：
- en: '[PRE12]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In `GLESNativeLib.java`, edit the `GLESNativeLib` class and add the reference
    of our shared library, so that it will be linked at runtime:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GLESNativeLib.java` 文件中，编辑 `GLESNativeLib` 类并添加我们共享库的引用，以便在运行时进行链接：
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**iOS**: On the iOS platform, you need to add `lib3ds` library source files
    to your project using **File** | **Add Files to [Project Name]**.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**iOS**：在 iOS 平台上，您需要使用 **文件** | **将文件添加到 [项目名称]** 将 `lib3ds` 库源文件添加到您的项目中。'
- en: How to do it...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Here are the steps to create a 3Ds mesh renderer class. This class will be
    responsible for loading and rendering 3Ds mesh models:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是创建 3Ds 网格渲染器类的步骤。此类将负责加载和渲染 3Ds 网格模型：
- en: For this recipe, we have derived a new class called `Loader3DS` from the `Scene`.
    This class contains a `load3dsModel` function, which will be used to load the
    3Ds mesh model file.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个配方，我们从 `Scene` 类派生了一个新的类，名为 `Loader3DS`。这个类包含一个 `load3dsModel` 函数，该函数将用于加载
    3Ds 网格模型文件。
- en: 'Implement the `load3dsModel` function, as described in the following code snippet.
    This function parses the 3Ds model file using the `lib3ds` library''s function
    called `lib3ds_file_load` and returns the `Lib3dsFile` pointer. The `Lib3dsFile`
    structure contains the parsed information of the 3Ds mesh file:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现如以下代码片段中描述的 `load3dsModel` 函数。此函数使用 `lib3ds` 库的 `lib3ds_file_load` 函数解析 3Ds
    模型文件，并返回 `Lib3dsFile` 指针。`Lib3dsFile` 结构体包含解析后的 3Ds 网格文件信息：
- en: '[PRE14]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When a 3Ds mesh file is parsed successfully, it loads the mesh data (geometry
    attributes and material information) of the mesh model in the file object type
    called `Lib3dsFile`. This object contains all the necessary information to read
    nodes. A node in the 3Ds specification is a special data structure called `Lib3dsNode`
    that corresponds to a subpart or submodel of the complete 3D mesh model. For example,
    a `car` model is made up of many different subparts, such as body frame, tires,
    doors, engine, and so on. Each of these individual parts correspond to a child
    node of the parent node that represents the 3D car model.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 3Ds 网格文件解析成功后，它将加载文件对象类型 `Lib3dsFile` 中的网格模型的数据（几何属性和材质信息）。此对象包含读取节点所需的所有必要信息。在
    3Ds 规范中，节点是一个称为 `Lib3dsNode` 的特殊数据结构，对应于完整 3D 网格模型的子部分或子模型。例如，一个 `car` 模型由许多不同的子部分组成，如车身框架、轮胎、车门、引擎等。这些各个部分对应于代表
    3D 汽车模型的父节点的子节点。
- en: 'Depending on the complexity of the model, there may be more than one node.
    These nodes are arranged in a hierarchical fashion. The nodes are created using
    `lib3ds_node_new_object()` and are arranged in a hierarchal order with `lib3ds_file_insert_node()`:'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据模型的复杂度，可能会有多个节点。这些节点以层次结构排列。节点使用 `lib3ds_node_new_object()` 创建，并使用 `lib3ds_file_insert_node()`
    以层次顺序排列：
- en: '[PRE15]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Render the 3Ds mesh model by recursively iterating through all the nodes. Call
    `RenderNodes()` to render each node:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过递归遍历所有节点来渲染 3Ds 网格模型。调用 `RenderNodes()` 来渲染每个节点：
- en: '[PRE16]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`RenderNodes()` is a recursive function that creates VBO for each node and
    renders them. Each node contains a pointer to `Lib3dsMesh`; the `Lib3dsMesh` is
    a data structure that contains the geometrical information for each node:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RenderNodes()` 是一个递归函数，为每个节点创建 VBO 并渲染它们。每个节点都包含一个指向 `Lib3dsMesh` 的指针；`Lib3dsMesh`
    是一个包含每个节点几何信息的数据结构：'
- en: '[PRE17]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `Lib3ds` library contains a structure called `Lib3dsUserData`. It allows
    you to add custom variables to `lib3ds`. We will use this structure to store vertex
    buffer object variables like vertex:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Lib3ds`库包含一个名为`Lib3dsUserData`的结构。它允许你向`lib3ds`添加自定义变量。我们将使用这个结构来存储顶点缓冲对象变量，如顶点：'
- en: '[PRE18]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Build the VAO for each mesh using the `BuildMesh()` function. Cache the VAO,
    VBO, and IBO information in the `MyLib3dsUserData` object:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`BuildMesh()`函数为每个网格构建VAO。将VAO、VBO和IBO信息缓存到`MyLib3dsUserData`对象中：
- en: '[PRE19]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In `RenderNodes()`, use the VAO information to render the 3Ds mesh model:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RenderNodes()`中，使用VAO信息渲染3Ds网格模型：
- en: '[PRE20]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The 3Ds mesh file is parsed with lib3ds library's `lib3ds_file_load`. This function
    successfully populates the `Lib3dsFile` file pointer that contains all the parsed
    information from the 3Ds file. Using this data variable, we create nodes that
    are populated and assembled in a hierarchical order using `lib3ds_file_insert_node`.
    Each node represents a mesh, which is read from the node structure and cached
    in the form of a **Vertex Array Objects** (**VAO**). Each VAO stores the **Vertex
    Buffer Object** (**VBO**), states, and attributes.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用lib3ds库的`lib3ds_file_load`函数解析3Ds网格文件。此函数成功填充了包含从3Ds文件中解析的所有信息的`Lib3dsFile`文件指针。使用这个数据变量，我们创建节点，并使用`lib3ds_file_insert_node`按层次顺序填充和组装这些节点。每个节点代表一个网格，它从节点结构中读取并缓存为**顶点数组对象**（**VAO**）。每个VAO存储**顶点缓冲对象**（**VBO**）、状态和属性。
- en: 'The `RenderNodes` is a recursive function that creates the VAO and VBO for
    each node and renders them. Each node contains a pointer to `Lib3dsMesh`, which
    further contains a `Lib3dsUserData` that we will use to check whether the corresponding
    node contains the VAO. The VAO is recognized with a vertex array ID. These IDs
    are bound to runtime and used to render the geometry. Once the VAO IDs are generated,
    these are stored with each node in the `Lib3dsUserData` structure:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderNodes`是一个递归函数，它为每个节点创建VAO和VBO并渲染它们。每个节点包含一个指向`Lib3dsMesh`的指针，它进一步包含一个`Lib3dsUserData`，我们将使用它来检查相应的节点是否包含VAO。VAO通过顶点数组ID识别。这些ID绑定到运行时并用于渲染几何形状。一旦生成VAO
    ID，这些ID就存储在每个节点的`Lib3dsUserData`结构中：'
- en: '![How it works...](img/5527OT_04_12.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/5527OT_04_12.jpg)'
- en: There's more...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'So far in this recipe, you learned how to render 3Ds mesh models. We rendered
    these using a single color. The 3Ds file format also has the provision to render
    faces with colors. This information is stored in `Lib3dsMaterial` of `Lib3dsMesh`.
    The following code shows how the material information is read from the material
    data structure and sends it as a uniform variable to the `3dsFragmentShader.glsl`
    to apply as face colors:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这个菜谱中，你学习了如何渲染3Ds网格模型。我们使用单色进行了渲染。3Ds文件格式还提供了渲染带有颜色的面的功能。这些信息存储在`Lib3dsMesh`的`Lib3dsMaterial`中。以下代码展示了如何从材质数据结构中读取材质信息，并将其作为统一变量发送到`3dsFragmentShader.glsl`以应用于面颜色：
- en: '[PRE21]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The color information is stored in the form of material colors. For more information
    on light and material, refer to the [Chapter 5](ch05.html "Chapter 5. Light and
    Materials"), *Light and Materials*. The following image illustrates a car model
    with colored faces, where the mesh model is rendered with triangle, line, and
    point primitives:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色信息以材质颜色的形式存储。有关光和材质的更多信息，请参阅[第5章](ch05.html "第5章。光和材质")，*光和材质*。以下图像展示了一个带有彩色面的汽车模型，其中网格模型使用三角形、线和点原语进行渲染：
- en: '![There''s more...](img/5527OT_04_13.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/5527OT_04_13.jpg)'
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Pivot position**: The pivot position renders mesh models to the translation
    information. This helps the mesh to render with correct positioning. Without pivot
    positioning, each node renders at the origin. This behavior causes all node meshes
    to cluster at the origin because each model does not know its position relative
    to other models.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**枢轴位置**：枢轴位置将网格模型渲染到平移信息中。这有助于网格以正确的位置渲染。没有枢轴定位，每个节点都在原点渲染。这种行为导致所有节点网格都聚集在原点，因为每个模型不知道其相对于其他模型的位置。'
- en: See also
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Managing VBO with Vertex Array Objects* recipe in [Chapter 3](ch03.html
    "Chapter 3. New Features of OpenGL ES 3.0"), *New Features of OpenGL ES 3.0*
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[第3章](ch03.html "第3章。OpenGL ES 3.0的新特性")中的*使用顶点数组对象管理VBO*菜谱，*OpenGL ES 3.0的新特性*
