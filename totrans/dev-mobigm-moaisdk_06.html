<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Resource Manager"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Resource Manager</h1></div></div></div><p>If we start developing our game, we’ll eventually need to create an entity that handles all of our assets. We’ll call it<a id="id94" class="indexterm"/> <code class="literal">ResourceManager</code>. We’ll see how to create one that allows you to add images, fonts, and sounds to your games.</p><p>The main idea behind the resource manager is to cache assets that we’ll use more than once and to have a centralized and abstracted way to create assets.</p><div class="section" title="Resource definitions"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec34"/>Resource definitions</h1></div></div></div><p>In order to be able to<a id="id95" class="indexterm"/> define resources, we need to create a module that will be in charge of handling this. The main idea is that before calling a certain asset through <code class="literal">ResourceManager</code>, it has to be defined in<a id="id96" class="indexterm"/> <code class="literal">ResourceDefinitions</code>. In this way, <code class="literal">ResourceManager</code> will always have access to some metadata it needs to create the asset (filenames, sizes, volumes, and so on).</p><p>In order to identify the asset types (sounds, images, tiles, and fonts), we will define some constants (note that the number values of these constants are arbitrary; you could use whatever you want here). Let’s call them <code class="literal">RESOURCE_TYPE_[type]</code> (feel free to use another convention if you want to). To make things easier, just follow this convention for now since it’s the one we’ll use in the rest of the book. You should enter them in <code class="literal">main.lua</code> as follows:</p><div class="informalexample"><pre class="programlisting">RESOURCE_TYPE_IMAGE = 0
RESOURCE_TYPE_TILED_IMAGE = 1
RESOURCE_TYPE_FONT = 2
RESOURCE_TYPE_SOUND = 3</pre></div><p>If you want to understand the actual reason behind these resource type constants, take a look at the <code class="literal">load</code> function of our <code class="literal">ResourceManager</code> entity in the next section.</p><p>We need to create a file named <code class="literal">resource_definitions.lua</code> and add some simple methods that will handle it.</p><p>Add the following line to it:</p><div class="informalexample"><pre class="programlisting">module ( “ResourceDefinitions”, package.seeall )</pre></div><p>The preceding line indicates that all of the code in the file should be treated as a <code class="literal">module</code> function, being accessed through <code class="literal">ResourceDefinitions</code> in the code. This is one of many Lua patterns used to create modules. </p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>If you’re not used to the Lua’s <code class="literal">module </code>function, you can read about it in the modules tutorial at <a class="ulink" href="http://lua-users.org/wiki/ModulesTutorial">http://lua-users.org/wiki/ModulesTutorial</a>.</p></div></div><p>Next, we will create a table that contains these definitions:</p><div class="informalexample"><pre class="programlisting">local definitions = {}</pre></div><p>This will be used internally and is not accessible through the module API, so we create it using the keyword <code class="literal">local</code>.</p><p>Now, we need to <a id="id97" class="indexterm"/>create the <code class="literal">setter</code>, <code class="literal">getter</code>, and <code class="literal">unload</code> methods for the definitions.</p><p>The<a id="id98" class="indexterm"/> <code class="literal">setter</code> method (called <code class="literal">set</code>) <a id="id99" class="indexterm"/>stores the <code class="literal">definition</code> parameter (a table) in the <code class="literal">definitions</code> table, using the <code class="literal">name</code> parameter (a string) as the key, as follows:</p><div class="informalexample"><pre class="programlisting">function ResourceDefinitions:set(name, definition)
    definitions[name] = definition
end</pre></div><p>The <code class="literal">getter</code> method<a id="id100" class="indexterm"/> (called <code class="literal">get</code>, duh!) <a id="id101" class="indexterm"/>retrieves the definition that was previously stored (by use of <code class="literal">ResourceDefinitions:set ()</code>) using the <code class="literal">name</code> parameter as the key of the <code class="literal">definitions</code> table, as follows:</p><div class="informalexample"><pre class="programlisting">function ResourceDefinitions:get(name)
    return definitions[name]
end</pre></div><p>The <code class="literal">final</code> method<a id="id102" class="indexterm"/> that <a id="id103" class="indexterm"/>we’re creating is <code class="literal">remove</code>. We use it to clear the memory space used by the definition. In order to achieve this we assign <code class="literal">nil</code> to an entry in the <code class="literal">definitions</code> table indexed by the <code class="literal">name</code> parameter as follows:</p><div class="informalexample"><pre class="programlisting">function ResourceDefinitions:remove (name)
  definitions[name] = nil
end</pre></div><p>In this way, we remove the reference to the object, allowing the memory to be released by the garbage collector. This may seem useless here, but it’s a good example of how you should manage your objects to be removed from memory by the garbage collector. And besides this, we don’t know information comes in a resource definition; it may be huge, we just don’t know.</p><p>This is all we need for the resource definitions. We’re making use of the dynamism that Lua<a id="id104" class="indexterm"/> provides. See how easy it was to create a repository for definitions that is abstracted from the content of each definition. We’ll define different fields for each asset type, and we don’t need to define them beforehand as we probably would have needed to do in C++.</p></div></div>
<div class="section" title="Resource manager"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec35"/>Resource manager</h1></div></div></div><p>We will now create our <a id="id105" class="indexterm"/>resource manager. This module will be in charge of creating and storing our decks and assets in general. We’ll retrieve the assets with one single command, and they’ll come from the cache or get created using the definition.</p><p>We need to create a file named <code class="literal">resource_manager.lua</code> and add the following line to it:</p><div class="informalexample"><pre class="programlisting">module ( “ResourceManager”, package.seeall )</pre></div><p>This is the same as in the resource definitions; we’re creating a module that will be accessed using <code class="literal">ResourceManager</code>.</p><div class="informalexample"><pre class="programlisting">ASSETS_PATH = ‘assets/’</pre></div><p>We now create the<a id="id106" class="indexterm"/> <code class="literal">ASSETS_PATH</code> constant. This is the path where we will store our assets. You could have many paths for different kinds of assets, but in order to keep things simple, we’ll keep all of them in one single directory in this example. Using this constant will allow us to use just the filename instead of having to write the whole path when creating the actual resource definitions, saving us some phalanx injuries!</p><div class="informalexample"><pre class="programlisting">local cache = {}</pre></div><p>Again, we’re creating a <code class="literal">cache</code> table as a local variable. This will be the variable that will store our initialized assets.</p><p>Now we should take care of implementing the important functionality. In order to make this more readable, I’ll be using methods that we define in the following pages. So, I recommend that you read the whole section before trying to run what we code now. The full source code can be downloaded from the book’s website, featuring inline comments. In the book, we removed the comments for brevity’s sake.</p><div class="section" title="Getter"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec17"/>Getter</h2></div></div></div><p>The first thing we will<a id="id107" class="indexterm"/> implement is our <code class="literal">getter</code> method<a id="id108" class="indexterm"/> since it’s simple enough:</p><div class="informalexample"><pre class="programlisting">function ResourceManager:get ( name )
    if (not self:loaded ( name )) then
        self:load ( name )
    end
    
    return cache[name]
end</pre></div><p>This method receives a <code class="literal">name</code> parameter that is the identifier of the resource we’re working with. On the first line, we call <code class="literal">loaded</code> (a method that we will define soon) to see if the resource identified by <code class="literal">name</code> was already loaded. If it was, we just need to return the cached value, but if it was not we need to load it, and that’s what we do in the <code class="literal">if</code> statement. We use the internal<a id="id109" class="indexterm"/> <code class="literal">load</code> method (which we will define later as well) to take care of the loading. We will make this <code class="literal">load</code> method store the loaded object in the <code class="literal">cache</code> table. So after loading it, the only thing we have to do is return the object contained in the <code class="literal">cache</code> table indexed by <code class="literal">name</code>.</p><p>One of the auxiliary functions that we use here is <code class="literal">loaded</code>. Let’s implement it since it’s really easy to do so:</p><div class="informalexample"><pre class="programlisting">function ResourceManager:loaded ( name )
  return cache[name] ~= nil
end</pre></div><p>What we do here is check whether the <code class="literal">cache</code> table indexed by the <code class="literal">name</code> parameter is not equal to <code class="literal">nil</code>. If <code class="literal">cache</code> has an object under that key, this will return <code class="literal">true</code>, and that’s what we were looking for to decide whether the object represented by the <code class="literal">name</code> parameter was already loaded.</p></div><div class="section" title="Loader"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec18"/>Loader</h2></div></div></div><p>
<code class="literal">load</code> and its auxiliary <a id="id110" class="indexterm"/>functions are the most important methods of this module. They’ll be <a id="id111" class="indexterm"/>slightly more complex than what we’ve done so far since they make the magic happen. Pay special attention to this section. It’s not particularly hard, but it might get confusing. Like the previous methods, this one receives just the <code class="literal">name</code> parameter that represents the asset we’re loading as follows:</p><div class="informalexample"><pre class="programlisting">function ResourceManager:load ( name )</pre></div><p>First of all, we retrieve the definition for the resource associated to <code class="literal">name</code>. We make a call to the <code class="literal">get</code> method from <code class="literal">ResourceDefinitions</code>, which we defined earlier as follows:</p><div class="informalexample"><pre class="programlisting">    local resourceDefinition = ResourceDefinitions:get( name )</pre></div><p>If the resource definition does not exist (because we forgot to define it before), we print an error to the screen, as follows:</p><div class="informalexample"><pre class="programlisting">    if not resourceDefinition then
        print(“ERROR: Missing resource definition for “ .. name )</pre></div><p>If the resource definition was retrieved successfully, we create a variable that will hold the resource and (pay attention) we call the correct <code class="literal">load</code> auxiliary function, depending on the asset type.</p><div class="informalexample"><pre class="programlisting">    else
        local resource</pre></div><p>Remember the <code class="literal">RESOURCE_TYPE_[type]</code> constants <a id="id112" class="indexterm"/>that we created in the <code class="literal">ResourceDefinitions</code> module? This is the reason for their existence. Thanks to the creation of the <code class="literal">RESOURCE_TYPE_[type]</code> constants, we now know how to load the resources correctly. When <a id="id113" class="indexterm"/>we define a resource, we must include a <code class="literal">type</code> key with one of the resource types. We’ll insist on this soon. What we do now is call the correct <code class="literal">load</code> method for images, tiled images, fonts, and sounds, using the value stored in <code class="literal">resourceDefinition.type</code> as follows:</p><div class="informalexample"><pre class="programlisting">    if (resourceDefinition.type == RESOURCE_TYPE_IMAGE) then
        resource = self:loadImage ( resourceDefinition )
    elseif (resourceDefinition.type == RESOURCE_TYPE_TILED_IMAGE) then
        resource = self:loadTiledImage ( resourceDefinition )
    elseif (resourceDefinition.type == RESOURCE_TYPE_FONT) then
        resource = self:loadFont ( resourceDefinition )
    elseif (resourceDefinition.type == RESOURCE_TYPE_SOUND) then
        resource = self:loadSound ( resourceDefinition )
    end</pre></div><p>After loading the current resource, we store it in the <code class="literal">cache</code> table, in an entry specified by the <code class="literal">name</code> parameter, as follows:</p><div class="informalexample"><pre class="programlisting">    -- store the resource under the name on cache
    cache[name] = resource
    end
end</pre></div><p>Now, let’s take a look at all of the different load methods. The expected definitions are explained before the actual functions so you have a reference when reading them.</p><div class="section" title="Images"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec01"/>Images</h3></div></div></div><p>Loading images is <a id="id114" class="indexterm"/>something<a id="id115" class="indexterm"/> that we’ve already done, so this is going to look somewhat familiar.</p><p>In this book, we’ll have two ways of defining images. Let’s take a look at them:</p><div class="informalexample"><pre class="programlisting">{
    type = RESOURCE_TYPE_IMAGE
    fileName = “tile_back.png”,
    width = 62, 
    height = 62,
}</pre></div><p>As you may have guessed, the <code class="literal">type</code> key is the one used in the <code class="literal">load</code> function. In this case, we need to make it of type <code class="literal">RESOURCE_TYPE_IMAGE</code>.</p><p>Here we are defining an image that has specific <code class="literal">width</code> and <code class="literal">height</code> values, and that is located at <code class="literal">assets/title_back.png</code>. Remember that we will use <code class="literal">ASSET_PATH</code> in order to avoid writing <code class="literal">assets/</code> a zillion times. That’s why we’re not writing it on the definition.</p><p>Another useful definition is:</p><div class="informalexample"><pre class="programlisting">{
    type = RESOURCE_TYPE_IMAGE
    fileName = “tile_back.png”,
    coords = { -10, -10, 10, 10 }
}</pre></div><p>This is handy when you want a specific rectangle inside a bigger image. You can use the <code class="literal">cords</code> attribute to define this rectangle. For example, we get a square with 20 pixel long sides centered in the image by specifying <code class="literal">coords = { -10, -10, 10, 10 }</code>.</p><p>Now, let’s take a look at the actual <code class="literal">loadImage</code> method<a id="id116" class="indexterm"/> to see how this all falls into place:</p><div class="informalexample"><pre class="programlisting">function ResourceManager:loadImage ( definition )
    local image</pre></div><p>First of all, we use the same technique of defining an empty variable that will hold our image:</p><div class="informalexample"><pre class="programlisting">    local filePath = ASSETS_PATH .. definition.fileName</pre></div><p>We create the actual full path by appending the value of <code class="literal">fileName</code> in the definition to the value of the <code class="literal">ASSETS_PATH</code> constant. <code class="literal">if</code> checks whether the <code class="literal">coords</code> attribute is defined:</p><div class="informalexample"><pre class="programlisting">    if definition.coords then
    image = self:loadGfxQuad2D ( filePath, definition.coords )</pre></div><p>Then, we use another auxiliary function called <code class="literal">loadGfxQuad2D</code>. This will be in charge of creating the actual image. The reason why we’re using another auxiliary function is that the code used to create the image is the same for both definition styles, but the data in the definition needs to be processed differently. In this case, we just pass the coordinates of the rectangle.</p><div class="informalexample"><pre class="programlisting">  else 
    local halfWidth = definition.width / 2
    local halfHeight = definition.height / 2
    image = self:loadGfxQuad2D(filePath, {-halfWidth, -halfHeight, halfWidth, halfHeight} ) </pre></div><p>If there were no <code class="literal">coords</code> attribute, we’d assume the image is defined using <code class="literal">width</code> and <code class="literal">height</code>. So <a id="id117" class="indexterm"/>what we do is to define a rectangle that covers the whole width <a id="id118" class="indexterm"/>and height for the image. We do this by calculating <code class="literal">halfWidth</code> and <code class="literal">halfHeight</code> and then passing these values to the<a id="id119" class="indexterm"/> <code class="literal">loadGfxQuad2D</code> method. Remember the discussion about the texture coordinates in Moai SDK; this is the reason why we need to divide the dimensions by 2 and pass them as negative and positive parameters for the rectangle. This allows it to be centered on (0, 0). After loading the image, we return it so it can be stored in the cache by the <code class="literal">load</code> method:</p><div class="informalexample"><pre class="programlisting">    end
    return image
end</pre></div><p>Now the last method we need to write is <code class="literal">loadGfxQuad2D</code>. This method is basically doing the same as what we did in the previous chapter to display an image as follows:</p><div class="informalexample"><pre class="programlisting">function ResourceManager:loadGfxQuad2D ( filePath, coords )
    local image = MOAIGfxQuad2D.new ()
    
    image:setTexture ( filePath )
    image:setRect ( unpack(cords) )
    
    return image
end</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>Lua’s <code class="literal">unpack</code> method is a nice tool that allows you to pass a table as separate parameters. You can use it to split a table into multiple variables as well:</p><div class="informalexample"><pre class="programlisting">x, y = unpack ( position_table )</pre></div></div></div><p>What we do here is instantiate the <code class="literal">MOAIGfxQuad2D</code> class, set the texture we defined in the previous function, and use the coordinates we constructed to set the rectangle this image will use from the original texture. Then we return it so <code class="literal">loadImage</code> can use it.</p><p>Well! That was it for images. It may look complicated at first, but it’s not that complex.</p><p>The rest of the assets will be simpler than this, so if you understood this one, the rest will be a piece of cake.</p></div><div class="section" title="Tiled images"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec02"/>Tiled images</h3></div></div></div><p>Another useful type of asset is <a id="id120" class="indexterm"/>tiled images. In gaming, we usually use tiled images <a id="id121" class="indexterm"/>to load a single texture and use fragments of it for specific purposes (for example, animations can be achieved using this technique). This will be handy in our game <span class="emphasis"><em>Concentration</em></span>, to define which tiles should be placed in the matrix.</p><p>The tiled image definition is as follows:</p><div class="informalexample"><pre class="programlisting">{
    type = RESOURCE_TYPE_TILED_IMAGE, 
    fileName = ‘tiles.png’, 
    tileMapSize = {3, 2}
}</pre></div><p>This is basically the same as the normal image, but we need to add <code class="literal">tileMapSize</code> and remove <code class="literal">width</code> and <code class="literal">height</code>. This table will be unpacked as the parameters for <code class="literal">MOAITileDeck2D:setRect</code> (check it out at <a class="ulink" href="http://getmoai.com/docs/class_m_o_a_i_tile_deck2_d.html#a504da8814f74038af9d453ebbc7fd5ae">http://getmoai.com/docs/class_m_o_a_i_tile_deck2_d.html#a504da8814f74038af9d453ebbc7fd5ae</a>). In this case, it says that the tile map has three columns and two rows, giving a total of six tiles.</p><p>
<code class="literal">loadTiledImage</code> is as follows:</p><div class="informalexample"><pre class="programlisting">function ResourceManager:loadTiledImage ( definition )
    
    local tiledImage = MOAITileDeck2D.new ()
    
    local filePath = ASSETS_PATH .. definition.fileName

    tiledImage:setTexture ( filePath )</pre></div><p>This is essentially the same as what we did with the image. We append <code class="literal">fileName</code> to <code class="literal">ASSETS_PATH</code> to get the final texture <code class="literal">filePath</code>.</p><div class="informalexample"><pre class="programlisting">    tiledImage:setSize ( unpack (definition.tileMapSize) )</pre></div><p>The only real difference is that we unpack the <code class="literal">tileMapSize</code> attribute to pass it to <code class="literal">setSize</code>. You may use all of the possible parameters that can be passed to <code class="literal">setSize</code>; these are explained in the Moai SDK API documentation.</p><div class="informalexample"><pre class="programlisting">    -- return the final image
    return tiledImage
    
end</pre></div><p>And this is pretty much the same as for the normal image. We return <code class="literal">tiledImage</code> to be used later.</p></div><div class="section" title="Fonts"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec03"/>Fonts</h3></div></div></div><p>Fonts <a id="id122" class="indexterm"/>are <a id="id123" class="indexterm"/>easier, and the definition is as follows:</p><div class="informalexample"><pre class="programlisting">{
    type = RESOURCE_TYPE_FONT,
    fileName = ‘myfont.ttf’,
    glyphs = “0123456789”,
    fontSize = 26,
    dpi = 160
}</pre></div><p>The specific attributes that we have here, besides the type and the filename, are <code class="literal">glyphs</code> (these are the characters that we will use; in this example, we only use the numbers from 0 to 9), <code class="literal">fontSize</code>, and <code class="literal">dpi</code> for font.</p><p>The <code class="literal">loadFont</code> method<a id="id124" class="indexterm"/> is as follows:</p><div class="informalexample"><pre class="programlisting">function ResourceManager:loadFont ( definition )
    local font = MOAIFont.new ()
    local filePath = ASSETS_PATH .. definition.fileName
    font:loadFromTTF ( filePath, definition.glyphs, 
    definition.fontSize, definition.dpi )
    return font
end</pre></div><p>The whole method is basically the same as the other loaders; the differences are that we use <code class="literal">MOAIFont</code> as the class, and we use <code class="literal">loadFromTTF</code> with the necessary parameters to initialize it.</p></div><div class="section" title="Sounds"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec04"/>Sounds</h3></div></div></div><p>The definition for<a id="id125" class="indexterm"/> sounds<a id="id126" class="indexterm"/> is as follows:</p><div class="informalexample"><pre class="programlisting">{
  type = RESOURCE_TYPE_SOUND, 
  fileName = ‘sugarfree.mp3’, 
  loop = true,
  volume = 0.6
}</pre></div><p>The specific attributes for sounds are <code class="literal">loop</code> (whether the sound should loop constantly or not) and <code class="literal">volume</code> (the initial volume for it).</p><p>Moai SDK <a id="id127" class="indexterm"/>comes with support for two different sound engines, <a id="id128" class="indexterm"/>
<span class="strong"><strong>Untz</strong></span>, an open source engine created specifically for Moai SDK, and <a id="id129" class="indexterm"/>
<span class="strong"><strong>FMOD</strong></span>, an industry standard sound library. It’s worth mentioning that FMOD costs money, while Untz is free.</p><p>We’re going to show you how to use <a id="id130" class="indexterm"/>Untz in this book, but you can safely code <code class="literal">loadSound</code> to use FMOD instead (take a look at <code class="literal">MOAIFmodExSound</code> and <code class="literal">MOAIFmodExChannel</code> in the Moai SDK API documentation).</p><div class="informalexample"><pre class="programlisting">function ResourceManager:loadSound ( definition )
    local sound = MOAIUntzSound.new ()

    local filePath = ASSETS_PATH .. definition.fileName
    sound:load ( filePath )

    sound:setVolume ( definition.volume )
    sound:setLooping ( definition.loop )
    
    return sound
end</pre></div><p>This is basically the same logic as for the previous loaders, but we’re using <code class="literal">setVolume</code> and <code class="literal">setLooping</code> to use the attributes we chose on our resource definition. We’ve not initialized Untz yet; this will be done later, but this code has been explained here for the completeness of <code class="literal">ResourceManager</code>.</p></div></div></div>
<div class="section" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec36"/>Exercises</h1></div></div></div><p>Putting this together should be something you can achieve now. So, take the source code of the <code class="literal">main.lua</code> file we created previously and modify it in order to make use of our <code class="literal">ResourceManager</code> and <code class="literal">ResourceDefinitions</code> entities. You’ll need to include <code class="literal">resource_definition.lua</code> and <code class="literal">resource_manager.lua</code> in <code class="literal">main.lua</code> and then make good use of them. If you download the source code for this chapter from the website, <code class="literal">main.lua</code> has already been modified to work with <code class="literal">ResourceManager</code>.</p><p>Another exercise is to code a way to unload assets from <code class="literal">ResourceManager</code>. This has also been done in the code for this chapter, which you can download from the website.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>The <code class="literal">unload</code> method is pretty important since it will be needed in order to actually free the memory reserved for assets.</p></div></div><p>Another interesting topic to enhance our <code class="literal">ResourceManager</code> entity is the use of serialized fonts so font loading is faster at runtime.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec37"/>Summary</h1></div></div></div><p>In this chapter we created a simple framework to work with assets. We created ways to define images, sounds, and fonts and coded the <code class="literal">ResourceDefinitions</code> class to store this data. We wrote our <code class="literal">ResourceManager</code> class, which is in charge of loading the different assets and caching them. We also went through the creation of loading functions for these different assets and explained a way to define them. Now we’re ready to start developing the gameplay for our game; how awesome is that!</p></div></body></html>