<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02" class="calibre1"/>Chapter 2. Automatic Reference Counting</h1></div></div></div><p class="calibre8">Good ideas live a long life and bad ones die fast. In Objective-C, reference counting's long life was seen as a very good idea. The next step of evolution in this is that it became automatic, so we call it <strong class="calibre2">Automatic Reference Counting</strong> (<strong class="calibre2">ARC</strong>), which was introduced by Apple Inc. in 2011 for application development on its desktop and mobile OS, Mac OS X Lion, and iOS 5. It changed the name of the initial referencing counting to <a id="id26" class="calibre1"/><strong class="calibre2">Manual Reference Counting</strong>.</p><p class="calibre8">We will cover the following topics in this chapter:</p><div><ul class="itemizedlist"><li class="listitem">ARC and how it works</li><li class="listitem">Advantages and disadvantages of ARC</li><li class="listitem">Project settings for ARC</li><li class="listitem">Mixing code that doesn't support ARC with your project</li><li class="listitem">Memory model in Objective C</li><li class="listitem">ARC in UI kit</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch02lvl1sec15" class="calibre1"/>What is ARC and how does it work?</h1></div></div></div><p class="calibre8">If you <a id="id27" class="calibre1"/>remember, the idea of reference counting covers the actual deletion of objects from the memory. With reference counting, Objective-C takes care of the actual object destruction. Owner objects are only responsible for releasing their claim of ownership on the object. So, logically the idea that appeared next was to make everything completely automatic as it was done in languages such as Java and C#. This idea was developed in the Garbage collection branch and Automatic Reference Counting.</p><p class="calibre8">Garbage collection is <a id="id28" class="calibre1"/>only available for Mac OS X, starting with version 10.5. Also, note that iOS applications can't use Garbage collection; since it relies on the power of the device, it will take some time to process, forcing the user to wait the process end, thus producing a bad user experience. It is also deprecated since OS X Version 10.8 is in favor of ARC and is scheduled to be removed in the forthcoming versions of OS X.</p><p class="calibre8">ARC is a new and<a id="id29" class="calibre1"/> innovative way that contains many of the Garbage <a id="id30" class="calibre1"/>collection's advantages, yet different from Garbage collection. ARC does not have any process in the background to make the object's deallocation, which gives ARC a big advantage against Garbage collection when comparing their performance.</p><p class="calibre8">However, before explaining how ARC<a id="id31" class="calibre1"/> does this, it's important to understand what ARC does not do:</p><div><ul class="itemizedlist"><li class="listitem">ARC does not impose a runtime memory model as Garbage collection does. Code compiled under ARC uses the same memory model as plain C or non-ARC Objective-C code, and can be linked to the same libraries.</li><li class="listitem">ARC only makes automatic memory management possible for Objective-C objects, inherited from <code class="email">NSObject</code> (note that in Objective-C, blocks also happen to be objects under the covers though).</li><li class="listitem">Memory allocated in any other way is not touched and must still be managed manually. The same goes for other resources such as file handles and sockets, such as streams.</li></ul></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec16" class="calibre1"/>How ARC looks</h1></div></div></div><p class="calibre8">Start by picturing a traditional Objective-C source code file written by an expert Cocoa programmer. The <code class="email">retain</code>, <code class="email">release</code>, and <code class="email">autorelease</code> messages are sent in all the right places and are in perfect balance.</p><p class="calibre8">Now, imagine <a id="id32" class="calibre1"/>editing the source code file, removing every instance of the <code class="email">retain</code>, <code class="email">release</code>, and <code class="email">autorelease</code> messages, and changing a single build setting in Xcode that instructs the compiler to put all the suitable memory management calls back into your program when the source code is compiled. That's ARC. It's just what the name suggests—traditional Cocoa reference counting, being automatically done.</p><p class="calibre8">At its core, ARC is not a runtime service; it doesn't work on program execution, as Garbage collection does. On the other hand, the new Clang, the compiler frontend for C, C++, Objective-C, and Objective-C++, provides it as a two-part phase (we will call these phases "cycles"). In the following diagram, you can see these two phases. At the cycle named <strong class="calibre2">frontend</strong> as shown in the following diagram, <strong class="calibre2">Clang</strong> will analyze every preprocessed file for properties and objects. And then, relying on a few fixed rules, it will insert the correct statements—<code class="email">retain</code>, <code class="email">release</code>, and <code class="email">autorelease</code>.</p><div><img src="img/00003.jpeg" alt="How ARC looks" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">For instance, if <a id="id33" class="calibre1"/>an object is allocated and locally corresponds to a method, this object will have a <code class="email">release</code> statement close to that method's endpoint. This <code class="email">release</code> statement, if it is a class property, comes into the <code class="email">dealloc</code> method in a class, which can be your custom class or any Objective-C class. If it's a collection object or a return value, it will get an <code class="email">autorelease</code> statement. However, if it was referenced as weak, it will be left in peace.</p><p class="calibre8">The frontend also inserts <code class="email">retain</code> statements for disowned objects locally. It goes to every declared accessor and updates them with the directive <code class="email">@property</code>. It includes calls to the <code class="email">dealloc</code> routine of their superclasses such as <code class="email">NSObject</code> or <code class="email">UIViewController</code> or even your own <code class="email">customer</code> superclass. It will also report any explicit management call and double ownership.</p><p class="calibre8">In the optimize<a id="id34" class="calibre1"/> cycle, the modified sources are sent to load balancing by Clang. So, it calculates the retain and release calls created for each object, and reduces all to the optimal minimum. This action avoids excessive <code class="email">retain</code> and <code class="email">release</code> messages with the possibility to impact with full performance:</p><div><pre class="programlisting">To see how it works, take a look at the following code:
@class MyBar;
@interface MyFoo
{
@private
    NSString *myOwnString;
}
@property(readonly) NSString *myOwnString; 

- (MyBar *)getMyBarWithString:(NSString *)myString;
- (MyBar *)getMyBar;

@end


@implementation MyFoo;
@dynamic myOwnString;

– (MyBar *)getMyBarWithString:(NSString *)myString
{
    MyBar *yBar;

    if (![self.myString isEqualToString:myString]) 
    {
        myOwnString = myString;
    } 
    return [self getMyBar];
}

- (MyBar *)getMyBar
{
    MyBar *yBar

    return yBar;
}
@end</pre></div><p class="calibre8">Now, it's an Objective-C class with no <code class="email">retain</code> or <code class="email">release</code>. There is one private property named <code class="email">myOwnString</code>, which <a id="id35" class="calibre1"/>is an instance of <code class="email">NSString</code>. This class imports the header of the <code class="email">MyBar</code> class (line 1) and declares a read-only getter with the same name, <code class="email">myOwnString</code>. There is a modifier called <code class="email">getMyBarWithString</code> and an internal function named <code class="email">getMyBar</code>.</p><p class="calibre8">The following code is the same piece of code using<a id="id36" class="calibre1"/> <strong class="calibre2">Manual Reference Counting</strong> (<strong class="calibre2">MRC</strong>):</p><div><pre class="programlisting">@class MyBar;
@interface MyFoo
{
@private
    NSString *myOwnString;
}
@property (readonly) NSString *myOwnString; 

- (MyBar *)getMyBarWithString:(NSString *)myString;
- (MyBar *)getMyBar;

@end


@implementation MyFoo;
@dynamic myOwnString;

– (MyBar *)getMyBarWithString:(NSString *)myString
{
    MyBar *yBar;

    if (![self.myString isEqualToString:myString]) 
    {
        [myString retain];
        [myOwnString release];
        myOwnString = myString;
    }
    return [self getMyBar];
}

- (MyBar *)getMyBar
{
    MyBar *yBar

    [yBar autorelease];
    return yBar;
}

- (void)dealloc
{
    [myOwnString release];
    [super dealloc];
}
@end</pre></div><p class="calibre8">Note that the class<a id="id37" class="calibre1"/> interface is still the same. However, now, the <code class="email">getMyBarWithString</code> modifier has some new statements; more specifically, two:</p><div><pre class="programlisting">[myString retain];
[myOwnString release];</pre></div><p class="calibre8">Sending a release statement to the <code class="email">myOwnString</code> property (line 24) is the responsibility of one of them. The other sends a <code class="email">retain</code> message to the <code class="email">myString</code> argument (line 25). Before returning the last one as its result, the <code class="email">getMyBar</code> function sends locally a <code class="email">autorelease</code> statement to the <code class="email">yBar</code> local. Lastly, MRC supersedes the <code class="email">dealloc</code> method of that class. MRC also releases the <code class="email">myOwnString</code> property (line 44) and invokes the <code class="email">dealloc</code> method of its superclass (line 45); still in that method, if there is already a <code class="email">dealloc</code> method, MRC properly updates its code.</p><p class="calibre8">When using ARC, you don't need to explicitly insert <code class="email">retain</code> and <code class="email">release</code> messages, as ARC will automatically insert them during compilation. Since ARC decides by itself how an Objective-C object will be better managed, the time that will be required to develop the class code is not required anymore. So, ARC avoids any empty pointers. ARC can also be excluded on a per-file basis where you select your target, go to <strong class="calibre2">Build Phases,</strong> and add the <strong class="calibre2">-fno-objc-arc</strong> flag in <strong class="calibre2">Compiler Flags</strong>.</p><p class="calibre8">However, the Clang compiler is built into LLVM 3.0, only available on Xcode since version 4.2. There has been optimized runtime support for ARC ever since Mac OS X Version 10.7 and iOS Version 5.0. It is not challenging to use ARC with binaries from Mac OS X 10.6 and iOS 4.3, but for iOS 4.3, it's only achievable through blue code; and for OS X 10.6, the newest version does not make use of weak pointers at all.</p><p class="calibre8">Some points about ARC are as follows:</p><div><ul class="itemizedlist"><li class="listitem">It does not work with <code class="email">AppleScriptObjC</code> or even <code class="email">PyObjC</code> sources; it works exclusively with Objective-C sources.</li><li class="listitem">However, more or less, when there are <code class="email">PyObjC</code> and <code class="email">AppleScriptObjC</code> classes being connected to Cocoa by Objective-C code, ARC will affect that underlying code.</li><li class="listitem">Note that for some third-party frameworks, if ARC is enabled, they might crash while compiling. Ensure that the developer of such a framework can and will update it.</li></ul></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec17" class="calibre1"/>Project settings for ARC</h1></div></div></div><p class="calibre8">When a<a id="id38" class="calibre1"/> project is set to utilize ARC, the compiler flag <code class="email">-fobjc-arc</code> is by default set for every Objective-C source file. ARC can be disabled for particular classes<a id="id39" class="calibre1"/> through the compiler flag, <code class="email">-fno-obj-arc</code>. In Xcode, go to the target <strong class="calibre2">Build Phases</strong> tab, open the <strong class="calibre2">Compile Sources</strong> group, and you will be able to see the source file list. When you double-click on the file where you want to set it, a pop-up panel will appear. In that panel, get in the <code class="email">-fno-obj-arc</code> flag and click on <strong class="calibre2">Done</strong> to finish.</p><p class="calibre8">If ARC was not enabled when the project was created, then to enable it, follow this process:</p><div><ol class="orderedlist"><li class="listitem" value="1">Open the project.</li><li class="listitem" value="2">Go to <strong class="calibre2">Edit</strong> | <strong class="calibre2">Refactor</strong> | <strong class="calibre2">Convert to Objective-C ARC</strong>.</li><li class="listitem" value="3">If there is no problem and it's ready to convert, it will check your code.</li></ol><div></div><p class="calibre8">By default, all newly created Objective-C projects in Xcode 5 are enabled with ARC. However, if you need to disable it, follow these steps: </p><div><ol class="orderedlist"><li class="listitem" value="1">Select <strong class="calibre2">Project</strong>.</li><li class="listitem" value="2">Select <strong class="calibre2">Targets</strong>.</li><li class="listitem" value="3">From the right panel, go to <strong class="calibre2">Build Settings</strong>.</li><li class="listitem" value="4">Select <strong class="calibre2">Automatic Reference Counting</strong>.</li><li class="listitem" value="5">Select <strong class="calibre2">Apple LLVM compiler 3.0 – Language</strong>.</li><li class="listitem" value="6">Locate <strong class="calibre2">Objective-C++ Automatic Reference Counting</strong> and, in all three sections, select <strong class="calibre2">NO</strong>.<div><img src="img/00004.jpeg" alt="Project settings for ARC" class="calibre10"/></div><p class="calibre23"> </p></li></ol><div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec18" class="calibre1"/>A memory model in Objective-C</h1></div></div></div><p class="calibre8">A very<a id="id40" class="calibre1"/> significant improvement in Objective C 2.0 is its memory model. The <a id="id41" class="calibre1"/>countless remnants of problems from the first Objective-C implementations as a preprocessor that induced C were cleaned up. In older versions, Objective-C objects were simply C structures, containing a pointer to their classes in their first fields, and its pointers were just able to receive messages when you wanted to send them.</p><p class="calibre8">Now every object <a id="id42" class="calibre1"/>pointer comes into one of the following categories: <code class="email">weak</code>, <code class="email">strong</code>, <code class="email">autoreleasing</code>, and <code class="email">unsafe unretained</code>. When ARC is disabled, the programmer is responsible to take care of them all, being sure that they are all safe, for the reason that all those pointers just fit the last category.</p><p class="calibre8">The default category (type qualifier) is a <code class="email">strong</code> pointer; they are largely correspondent to the consequences of writing flawless defensive retain/release code. Assigning to a <code class="email">strong</code> pointer is relative to retain the new value and release the old value, because owning references are stored in those pointers.</p><p class="calibre8">You need to<a id="id43" class="calibre1"/> use <code class="email">autoreleasing</code> pointers in order to store values that are autoreleased. In Objective-C, such pointers are the most habitual form of non-owning reference pointers; they are variables on the heap storing autoreleased values. An owning reference pointer, also known as an instance variable, will only be autoreleased when it is stored to a non-owning reference pointer, known as an autoreleasing variable. If you simply store an autoreleased reference pointer, you will have a simple attribution.</p><p class="calibre8">In order to decrease the quantity of release and retain statements in a crucial piece of code, it's possible to make use of <code class="email">_autoreleasing</code>, one of the four ARC type qualifiers. However, since the objects will be included in the autoreleasing pool and ARC can commonly eliminate this, it's usually not required to use this type qualifier, besides the fact that is can make things slower.</p><p class="calibre8">Weak is the last category (type qualifier) of pointer. If you used the garbage-collector mode in Objective-C, you probably already met <code class="email">weak</code> pointers by storing an object in such a pointer. It's not seen as an owning reference pointer (for instance, a variable), and when the object is deallocated, this point is immediately set to nil.</p><p class="calibre8">We can count many differences between GC and ARC mode, but the very important one is about ARC being deterministic. It's possible to see it through <code class="email">weak</code> pointers. See the following code for an example:</p><div><pre class="programlisting">    id strong = [NSObject new];
    __weak id weak = strong;
    strong = nil;
    NSLog(@"%@", weak);</pre></div><p class="calibre8">Firstly, since in the garbage collection mode<code class="email">__weak</code> is not granted for on-stack variables, the preceding code won't even pass through compilation. However, what would happen if the weak declaration is moved to somewhere it's valid? We presume that at this point, the object's last reference is already gone. However, the log statement will show you that the object is still there, alive. Relying on the optimizations that the compiler is running, the collector can possibly see its references on the heap if you run the collector by force.</p><p class="calibre8">This piece of code will be compiled in the ARC mode—now, weak variables are allowed on the heap.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec19" class="calibre1"/>What you need to know about ARC and weak references</h1></div></div></div><p class="calibre8">Weak references<a id="id44" class="calibre1"/> have been supported on GNUstep Objective-C runtime since version 1.5, since version 5 of iOS, and version 10.7 of OS X. ARC works through the compatibility library as well, but it requires modifications of many classes in order to work with weak references.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec20" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we focused our attention on Automatic Reference Counter, its advantages, how it works, and how to properly set up and integrate it into current projects.</p><p class="calibre8">In the next chapter, we will talk about the autorelease pool mechanism and its classes, blocks, and threads. We will also understand the memory model in Objective-C. I hope this chapter has provided you with a good understanding of ARC.</p></div></body></html>