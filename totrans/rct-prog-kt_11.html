<html><head></head><body>
        

                            
                    <h1 class="header-title">REST APIs with Spring JPA and Hibernate</h1>
                
            
            
                
<p>In the previous chapter, we learned how to create REST APIs with ease. We learned how to leverage the power of Spring, Hibernate, and JPA to create REST APIs with lines of code that can be counted on one hand. Those were powerful REST APIs, but they weren't reactive. This book's primary concern is to teach you how to make everything reactive and to teach you how to create non-blocking apps and APIs.</p>
<p>So, let's move on. Let's make our REST API reactive. Due to the power of Spring, this chapter will be short. We will cover the following topics:</p>
<ul>
<li>Spring Boot with JPA and Hibernate</li>
<li>Reactive programming with Reactor</li>
</ul>
<p>So, lets get started with the Reactor Framework.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">REST API with Spring Boot, Hibernate, and JPA</h1>
                
            
            
                
<p>In the previous chapter, we saw how to create a static RESTful API. We will now learn how to manipulate database records as response to an API request. I've used MySQL as a database in this project.</p>
<p>We will use JPA in this project. You can start a new project and add JPA as one of the dependencies. Alternatively, you can add this to your Gradle dependencies list:</p>
<pre>    compile('org.springframework.boot:spring-boot-starter-data-jpa') </pre>
<p>Note: You don't need to put version and artifacts here, it is automatically managed by a Spring Gradle plugin and Spring Boot.</p>
<p>Now, as you added the dependency, you have to add <kbd>application.properties</kbd>. Go to resources and add a file named <kbd>application.properties</kbd> with the following content:</p>
<pre>    ## Spring DATASOURCE (DataSourceAutoConfiguration &amp;    <br/>    DataSourceProperties) 
    spring.datasource.url = jdbc:mysql://localhost:3306/tododb 
    spring.datasource.username = root 
    spring.datasource.password = password 
 
 
    ## Hibernate Properties 
 
    # The SQL dialect makes Hibernate generate better<br/>    SQL for the chosen database 
    spring.jpa.properties.hibernate.dialect =    <br/>    org.hibernate.dialect.MySQL5Dialect 
 
    # Hibernate ddl auto (create, create-drop, validate, update) 
    spring.jpa.hibernate.ddl-auto = update </pre>
<p>Replace <kbd>tododb</kbd> with your database name, <kbd>root</kbd> with your database username, and <kbd>password</kbd> with your database password. Please note, that you have to create a blank database with the provided database name (in this case, <kbd>tododb</kbd>) prior to running this app.</p>
<p>We've added a little modification to the <kbd>Todo</kbd> class. Take a look at the following piece of code:</p>
<pre>    @Entity 
    data class Todo ( 
      @Id @GeneratedValue(strategy = GenerationType.AUTO) 
      var id:Int = 0, 
 
      @get: NotBlank 
      var todoDescription:String, 
 
      @get: NotBlank 
      var todoTargetDate:String, 
 
      @get: NotBlank 
      var status:String 
    ) { 
        constructor():this( 
        0,"","","" 
        ) 
       } </pre>
<p>Yes, we have just added the annotations and a blank constructor, which is required by Spring Data. So, let's take a look at the annotations and their purposes:</p>
<p><kbd>@Entity</kbd>: This defines a new entity in the database, that is, for every class annotated with <kbd>@Entity</kbd>, a table in the database will be created.</p>
<p><kbd>@Id</kbd>: This annotation defines the primary key (or composite primary key, if multiple) for a table. The <kbd>@GeneratedValue</kbd> annotation denotes that the field value should be autogenerated. JPA has three strategies for ID generation, as described here:</p>
<ul>
<li><kbd>GenerationType.TABLE</kbd>: This denotes that the primary keys should be generated with an underlying table to ensure uniqueness, that is, a table with a single column and a single row will be created, which will hold the next primary key value with the column name <kbd>next_val</kbd>, and every time a row is inserted in the target table (the table created with our entity), the primary key will be assigned the value of <kbd>next_val</kbd> and <kbd>next_val</kbd> will be incremented.</li>
<li><kbd>GenerationType.SEQUENCE</kbd>: This denotes that the primary keys should be generated with an underlying database sequence.</li>
<li><kbd>GenerationType.IDENTITY</kbd>: This denotes that the primary keys should be generated with an underlying database identity.</li>
<li><kbd>GenerationTypeenum</kbd>: This also provides an additional option—<kbd>GenerationType.AUTO</kbd>, one which denotes that a proper autogeneration strategy should be automatically selected.</li>
</ul>
<p>The next annotation is <kbd>@get: NotBlank</kbd>, which denotes that the field in the table should be not-null.</p>
<p>So, we are done with the changes in our <kbd>Todo</kbd> class. We also have to create a <kbd>Repository</kbd> interface. Take a look at the following interface:</p>
<pre>    @Repository 
    interface TodoRepository: JpaRepository&lt;Todo,Int&gt; </pre>
<p>Yes, that short. The <kbd>@Repository</kbd> annotation denotes that this interface should be used as a repository (a <kbd>DAO</kbd> class) for the project. We implemented <kbd>JpaRepository</kbd> in this interface, which declares methods to manipulate the table. The first generic parameter for this interface is the <kbd>Entity</kbd> and the second one is for the type of the <kbd>ID</kbd> field.</p>
<p>We have also created a new class, <kbd>ResponseModel</kbd>, to structure our response JSON. Find the class definition here:</p>
<pre>    data class ResponseModel ( 
      val error_code:String, 
      val error_message:String, 
      val data:List&lt;Todo&gt; = listOf() 
    ) { 
        constructor(error_code: String,error_message:<br/>        String,todo: Todo) 
        :this(error_code,error_message, listOf(todo)) 
      } </pre>
<p>This response model contains the <kbd>error_code</kbd> and <kbd>error_message</kbd> properties. Let's describe them; if there's an error while processing the API request, <kbd>error_code</kbd> will hold a non-zero value and <kbd>error_message</kbd> will hold a message describing that error. The <kbd>error_message</kbd> property can also hold a generic message.</p>
<p>The <kbd>data</kbd> property will hold a list of <kbd>Todo</kbd>, which will be converted to a JSON array in the response JSON. The <kbd>data</kbd> property is optional, as this response model will be used for all APIs in this project and all APIs may not return a list of <kbd>Todo</kbd> or even a single <kbd>Todo</kbd> object (for example the  edit, add, and delete Todo APIs do not require to send a <kbd>Todo</kbd>).</p>
<p>The final part of this API is the <kbd>controller</kbd> class. Here is the definition:</p>
<pre>    @RestController 
    @RequestMapping("/api") 
    class TodoController(private val todoRepository: TodoRepository) { 
 
      @RequestMapping("/get_todo", method = <br/>     arrayOf(RequestMethod.POST)) 
      fun getTodos() = ResponseModel("0","", todoRepository.findAll()) 
 
      @RequestMapping("/add_todo", method = <br/>      arrayOf(RequestMethod.POST)) 
      fun addTodo(@Valid @RequestBody todo:Todo) = 
      ResponseEntity.ok().body(ResponseModel<br/>      ("0","",todoRepository.save(todo))) 
 
      @RequestMapping("/edit_todo", method = <br/>      arrayOf(RequestMethod.POST)) 
      fun editTodo(@Valid @RequestBody todo:Todo):ResponseModel { 
        val optionalTodo = todoRepository.findById(todo.id) 
        if(optionalTodo.isPresent) { 
            return ResponseModel("0", "Edit <br/>            Successful",todoRepository.save(todo)) 
        } else { 
            return ResponseModel("1", "Invalid Todo ID" ) 
        } 
      } 
   
      @RequestMapping("/add_todos", method = <br/>      arrayOf(RequestMethod.POST)) 
      fun addTodos(@Valid @RequestBody todos:List&lt;Todo&gt;) 
            = ResponseEntity.ok().body(ResponseModel<br/>            ("0","",todoRepository.saveAll(todos))) 
 
     @RequestMapping("/delete_todo/{id}", method = <br/>     arrayOf(RequestMethod.DELETE)) 
     fun deleteTodo(@PathVariable("id") id:Int):ResponseModel { 
        val optionalTodo = todoRepository.findById(id) 
        if(optionalTodo.isPresent) { 
            todoRepository.delete(optionalTodo.get()) 
            return ResponseModel("0", "Successfully Deleted") 
        } else { 
            return ResponseModel("1", "Invalid Todo" ) 
        } 
     } 
 
    } </pre>
<p>So, apart from the <kbd>get_todo</kbd> endpoint, we have added endpoints for <kbd>add_todo</kbd>, <kbd>edit_todo</kbd>, <kbd>delete_todo</kbd>, and <kbd>add_todos</kbd>. We will take a closer look at each of them. However, the first focus on the constructor of the <kbd>TodoController</kbd> class. It takes a parameter for <kbd>TodoRepository</kbd>, which will be injected by the Spring Annotation. We are using that <kbd>todoRepository</kbd> property in all our APIs to read/write to and from the database.</p>
<p>Now, take a closer look at the <kbd>get_todo</kbd> API. It uses the <kbd>findAll</kbd> method of <kbd>TodoRepository</kbd> to get all todos from the DB. Here is the JSON response of that API (note this response will vary as per the state of the database and <kbd>Todo</kbd> table):</p>
<pre>    { 
      "error_code": "0", 
      "error_message": "", 
      "data": [ 
        { 
            "id": 1, 
            "todoDescription": "Trial Edit", 
            "todoTargetDate": "2018/02/28", 
            "status": "due" 
        }, 
        { 
            "id": 2, 
            "todoDescription": "Added 2", 
            "todoTargetDate": "2018/02/28", 
            "status": "due" 
        }, 
        { 
            "id": 3, 
            "todoDescription": "Edited 3", 
            "todoTargetDate": "2018/02/28", 
            "status": "due" 
        }, 
        { 
            "id": 4, 
            "todoDescription": "Added 4", 
            "todoTargetDate": "2018/02/28", 
            "status": "due" 
        }, 
        { 
            "id": 5, 
            "todoDescription": "Added 5", 
            "todoTargetDate": "2018/02/28", 
            "status": "due" 
        }, 
        { 
            "id": 7, 
            "todoDescription": "Added 7", 
            "todoTargetDate": "2018/02/28", 
            "status": "due" 
        } 
      ] 
    } </pre>
<p>The next API is the <kbd>add_todo</kbd> API:</p>
<pre>    @RequestMapping("/add_todo", method = arrayOf(RequestMethod.POST)) 
    fun addTodo(@Valid @RequestBody todo:Todo) = 
       <br/>      ResponseEntity.ok().body(ResponseModel<br/>      ("0","",todoRepository.save(todo))) </pre>
<p>This API takes a <kbd>Todo</kbd> from the body of a <kbd>POST</kbd> request, stores it, and returns a success <kbd>ResponseModel</kbd>. The following Postman screenshot shows the request sent to the API:</p>
<div><img src="img/c784a31d-0f92-4559-97b8-eba51427ad4c.jpg"/></div>
<p>In the JSON request, we are sending all details of <kbd>Todo</kbd> except the ID, as the <kbd>id</kbd> field will be autogenerated.</p>
<p>The response of the API is as follows:</p>
<pre>    { 
      "error_code": "0", 
      "error_message": "", 
      "data": [ 
        { 
          "id": 8, 
          "todoDescription": "Added 8", 
          "todoTargetDate": "2018/02/28", 
          "status": "due" 
        } 
      ] 
    } </pre>
<p>The <kbd>add_todos</kbd> API is almost similar to the <kbd>add_todo</kbd> API, except that here it takes an arbitrary number of <kbd>Todos</kbd> to be added to the database.</p>
<p>The <kbd>delete_todo</kbd> API is different than all other APIs in this project. Take a closer look at this API here:</p>
<pre>    @RequestMapping("/delete_todo/{id}", method =    <br/>    arrayOf(RequestMethod.DELETE)) 
    fun deleteTodo(@PathVariable("id") id:Int):ResponseModel { 
      val optionalTodo = todoRepository.findById(id) 
      if(optionalTodo.isPresent) { 
         todoRepository.delete(optionalTodo.get()) 
         return ResponseModel("0", "Successfully Deleted") 
      } else { 
         return ResponseModel("1", "Invalid Todo" ) 
      } 
    } </pre>
<p>This API takes a <kbd>DELETE</kbd> request in all other APIs other than the <kbd>POST</kbd> request (reason is simple, it just deletes <kbd>Todo</kbd>).</p>
<p>It also takes the ID of <kbd>todo</kbd> in the path variable instead of <kbd>RequestBody</kbd>; again, simple reason, we just need one field in this API, that is, ID of the <kbd>Todo</kbd>, to be deleted. So, no need to take an entire JSON as a request body here. Instead, a path variable will be a perfect fit for this API.</p>
<p>An example request to this API will be this URL—<kbd>http://localhost:8080/api/delete_todo/7</kbd>. The API will check if <kbd>Todo</kbd> with the specified ID exists, it will delete <kbd>Todo</kbd> if it exists; otherwise, it will just return an error.</p>
<p>Here are two ideal responses of this API:</p>
<pre>    { 
      "error_code": "0", 
      "error_message": "Successfully Deleted", 
      "data": [] 
    } </pre>
<p>If <kbd>Todo</kbd> was found and deleted, you'll get this response:</p>
<pre>    { 
      "error_code": "1", 
      "error_message": "Invalid Todo", 
      "data": [] 
    } </pre>
<p>If <kbd>Todo</kbd> with the specified ID is not found.</p>
<p>Now, as we gained some knowledge on Spring, let's get started with <strong>Reactor</strong>, a fourth-generation reactive programming library by <strong>Pivotal</strong>—the custodian for Spring.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Reactive programming with Reactor</h1>
                
            
            
                
<p>Just like the <strong>ReactiveX</strong> Framework, <strong>Reactor</strong> is also a fourth-generation reactive programming library. It allows you to write non-blocking reactive apps. However, it has some significant differences as compared to <strong>ReactiveX</strong>, as listed here:</p>
<ul>
<li>Unlike ReactiveX, which supports several platforms and languages (for example, RxSwift for Swift, RxJava for JVM, RxKotlin for Kotlin, RxJS for JavaScript, RxCpp for C++, and so on), Reactor supports only JVM.</li>
<li>You can use RxJava and RxKotlin, if you have Java 6+. However, to use Reactor, you need Java 8 and above.</li>
<li>RxJava and RxKotlin doesn't provide any direct integration with Java 8 functional APIs, such as CompletableFuture, Stream, and Duration, which Reactor does.</li>
<li>If you're planning to implement reactive programming in Android, you have to use RxAndroid, RxJava, and/or RxKotlin (collectively, ReactiveX) or Vert.X, unless you have minimum SDK as Android SDK 26 and above, that too without official support. As reactor project doesn't have official support on Android and it works only on Android SDK 26 and above.</li>
</ul>
<p>Other than these differences, Reactor and ReactiveX APIs are quite similar, so get started by adding Reactor to your Kotlin project.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Add Reactor to your project</h1>
                
            
            
                
<p>If you're using Gradle, add the following dependency:</p>
<pre>    compile 'io.projectreactor:reactor-core:3.1.1.RELEASE' </pre>
<p>If you're using Maven, add the following dependency to the <kbd>POM.xml</kbd> file:</p>
<pre>    &lt;dependency&gt; 
      &lt;groupId&gt;io.projectreactor&lt;/groupId&gt; 
      &lt;artifactId&gt;reactor-core&lt;/artifactId&gt; 
      &lt;version&gt;3.1.1.RELEASE&lt;/version&gt; 
    &lt;/dependency&gt;</pre>
<p>You can also download the JAR file from <a href="http://central.maven.org/maven2/io/projectreactor/reactor-core/3.1.1.RELEASE/reactor-core-3.1.1.RELEASE.jar">http://central.maven.org/maven2/io/projectreactor/reactor-core/3.1.1.RELEASE/reactor-core-3.1.1.RELEASE.jar</a>.<br/>
<br/>
For more options, check out <a href="https://mvnrepository.com/artifact/io.projectreactor/reactor-core/3.1.1.RELEASE">https://mvnrepository.com/artifact/io.projectreactor/reactor-core/3.1.1.RELEASE</a>.</p>
<p>So, as we're done with adding Reactor Core to our project, let's get started with <kbd>Flux</kbd> and <kbd>Mono</kbd>, producers in Reactor.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding Flux and Mono</h1>
                
            
            
                
<p>As I said, Reactor is another fourth-generation Reactive library like ReactiveX. It originally started as a lightweight version of Rx; however, with time, it grew, and today it's almost of the same weight as ReactiveX.</p>
<p>It also has a producer and consumer module, just like Rx. It has <kbd>Flux</kbd>, similar to <kbd>Flowable</kbd> and <kbd>Mono</kbd> as a combination of <kbd>Single</kbd> and <kbd>Maybe</kbd>.</p>
<p>Note that when describing <kbd>Flux</kbd>, I said Flowable, not Observable. You can probably guess the reason. Yes, all Reactor types are backpressure enabled. Basically, all the Reactor types are a direct implementation of the Reactive Streams <kbd>Publisher</kbd> API.</p>
<p>Flux is a Reactor producer that can emit <em>N</em> number of emissions and can terminate successfully or with an error. Similarly, with <kbd>Mono</kbd>, it may or may not emit single items. So, what are we waiting for? Let's get started with <kbd>Flux</kbd> and <kbd>Mono</kbd>.</p>
<p>Consider the following code example:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val flux = Flux.just("Item 1","Item 2","Item 3") 
      flux.subscribe(object:Consumer&lt;String&gt;{ 
        override fun accept(item: String) { 
            println("Got Next $item") 
        } 
     }) 
    } </pre>
<p>The output is as follows:</p>
<div><img height="129" width="406" src="img/17fd2d06-c2c3-4eea-b9bc-17385d04b36f.jpg"/></div>
<p>The output, as well as the program, is quite similar to RxKotlin, isn't it? The only difference is that we are using <kbd>Flux</kbd> instead of <kbd>Flowable</kbd>.</p>
<p>So, let's take a Mono example. Take a look at the following example:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
 
      val consumer = object : Consumer&lt;String&gt; {//(1) 
        override fun accept(item: String) { 
            println("Got $item") 
        } 
      } 
 
 
      val emptyMono = Mono.empty&lt;String&gt;()//(2) 
      emptyMono 
        .log() 
        .subscribe(consumer) 
 
      val emptyMono2 = Mono.justOrEmpty&lt;String&gt;(null)//(3) 
      emptyMono2 
        .log() 
        .subscribe(consumer) 
 
      val monoWithData = Mono.justOrEmpty&lt;String&gt;("A String")//(4) 
      monoWithData 
        .log() 
        .subscribe(consumer) 
 
      val monoByExtension = "Another String".toMono()//(5) 
      monoByExtension 
        .log() 
        .subscribe(consumer) 
     } </pre>
<p>Before we describe the program line by line, let's first focus on the <kbd>log</kbd> operator in each of the subscriptions. The Reactor Framework understands a developer's need to log things, that's why they provided an operator so that we can have a log of every event within a Flux or Mono.</p>
<p>On comment <kbd>(1)</kbd>, in this program, we created a <kbd>Consumer</kbd> instance to use in all the Subscriptions. On comment <kbd>(2)</kbd>, we created an empty Mono with the <kbd>Mono.empty()</kbd> factory method. As the name depicts, this factory method creates an empty Mono.</p>
<p>On comment <kbd>(3)</kbd>, we created another empty <kbd>Mono</kbd> with <kbd>Mono.justOrEmpty()</kbd>; this method creates <kbd>Mono</kbd> with the value passed or creates an empty <kbd>Mono</kbd> if null is passed as a value.</p>
<p>On comment <kbd>(4)</kbd>, we created <kbd>Mono</kbd> with the same factory method, but this time with a <kbd>String</kbd> value passed.</p>
<p>On comment <kbd>(5)</kbd>, we created <kbd>Mono</kbd> with the help of the <kbd>toMono</kbd> extension function.</p>
<p>Here is the output of the program:</p>
<div><img src="img/0fcd8bb8-c716-4244-961c-f6f0283bd884.jpg"/></div>
<p>So, as you have learned about Spring and you also learned about reactive programming with Reactor; would you like to do some research yourself and make our API reactive? As a helping gesture, I would like to suggest that you study a little bit about WebFlux. You can also read through <em>Reactive Programming in Spring 5.0</em> by <em>Oleh Dokuka</em> and <em>Igor Lozynskyi</em> (<a href="https://www.packtpub.com/application-development/reactive-programming-spring-50">https://www.packtpub.com/application-development/reactive-programming-spring-50</a>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we learned about creating a REST API quickly with Spring JPA, Hibernate, and Spring Boot. We also learned about Reactor and its use. We created the RESTful API for our project, which we will use in the next chapter while creating the Android app.</p>
<p>The next chapter, which is the last chapter of this book, is about creating an Android App with Kotlin and reactive programming.</p>
<p>You're about to complete this book—complete learning <em>Reactive Programming in Kotlin</em>. Just another chapter is ahead. So, turn the page fast.</p>


            

            
        
    </body></html>