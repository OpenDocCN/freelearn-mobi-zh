<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;User Interface &#x2013; Views"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. User Interface – Views</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Adding and customizing views</li><li class="listitem" style="list-style-type: disc">Receiving user input with buttons</li><li class="listitem" style="list-style-type: disc">Displaying images</li><li class="listitem" style="list-style-type: disc">Displaying and editing text</li><li class="listitem" style="list-style-type: disc">Using the keyboard</li><li class="listitem" style="list-style-type: disc">Displaying progress</li><li class="listitem" style="list-style-type: disc">Displaying content larger than the screen</li><li class="listitem" style="list-style-type: disc">Navigating through the content divided into pages</li><li class="listitem" style="list-style-type: disc">Displaying alerts</li><li class="listitem" style="list-style-type: disc">Creating a custom view</li><li class="listitem" style="list-style-type: disc">Styling views</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Introduction</h1></div></div></div><p>An application's <span class="strong"><strong>User Interface</strong></span> (<span class="strong"><strong>UI</strong></span>) is essential for providing the user with an easy way of communicating with a device, be it a computer, a mobile phone, or a tablet. On a mobile <a id="id108" class="indexterm"/>device, the user interface is not only essential but the only way to interact with the user. Developers have to cope with various limitations and restrictions when developing applications for mobile devices. The processing power of mobile devices does not match that of desktop CPUs, and the screens are smaller, making the process of choosing what sort of information will be displayed each time somewhat more difficult.</p><p>In this chapter, we will discuss the key components of an iOS application's UI. We will see how to use and customize these components to create rich application user interfaces and discuss the similarities and differences they have with their desktop equivalents. The following is a list of these components:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>UIView</strong></span>: This<a id="id109" class="indexterm"/> is a customizable container that is <a id="id110" class="indexterm"/>the base object of most iOS user interface controls</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>UIButton</strong></span>: This<a id="id111" class="indexterm"/> is the equivalent of a Button<a id="id112" class="indexterm"/> in the .NET world</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>UILabel</strong></span>: This<a id="id113" class="indexterm"/> is the equivalent of a Label in<a id="id114" class="indexterm"/> the .NET world</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>UIImageView</strong></span>: This <a id="id115" class="indexterm"/>is a view that allows<a id="id116" class="indexterm"/> us to display and create basic animations with images</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>UITextView</strong></span>: This<a id="id117" class="indexterm"/> is a view that allows<a id="id118" class="indexterm"/> us to display editable text</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>UITextField</strong></span>: This <a id="id119" class="indexterm"/>is similar to .NET's TextBox <a id="id120" class="indexterm"/>control</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>UIProgressView</strong></span>: This <a id="id121" class="indexterm"/>displays the <a id="id122" class="indexterm"/>known length progress</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>UIScrollView</strong></span>: This <a id="id123" class="indexterm"/>provides the ability <a id="id124" class="indexterm"/>to display scrollable content</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>UIPageControl</strong></span>: This<a id="id125" class="indexterm"/> provides navigation <a id="id126" class="indexterm"/>functionality to the content that is divided into different pages or screens</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>UIAlertView</strong></span>: This<a id="id127" class="indexterm"/> is the default iOS control for <a id="id128" class="indexterm"/>displaying a message box to the user</li></ul></div><p>We will also talk about how to programmatically create instances of these components and how to style and use them efficiently.</p></div></div>
<div class="section" title="Adding and customizing views"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Adding and customizing views</h1></div></div></div><p>In this recipe, we <a id="id129" class="indexterm"/>will discuss how to add and customize <code class="literal">UIView</code> with Xcode's Interface Builder.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec46"/>Getting ready</h2></div></div></div><p>Adding views with Interface Builder is a simple task. Let's start by creating a new<span class="strong"><strong> </strong></span>
<code class="literal">iPhone Single View Application</code> project in Xamarin Studio. Name the project <code class="literal">FirstViewApp</code> and open the <code class="literal">FirstViewAppViewController.xib</code> file with Interface Builder.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec47"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To add a view to the project, drag-and-drop a <code class="literal">UIView</code> object from the <span class="strong"><strong>Library</strong></span> pad onto the main view. Make sure that it fits the entire window area. To <a id="id130" class="indexterm"/>make <code class="literal">UIView</code> accessible, create an outlet for it and name it <code class="literal">subView</code>.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>The concept of outlets and how to use them is discussed in detail in <a class="link" href="ch01.html" title="Chapter 1. Development Tools">Chapter 1</a>, <span class="emphasis"><em>Development Tools</em></span>.</p></div></div></li><li class="listitem">Select the view that we have just added and go to the <span class="strong"><strong>Inspector</strong></span> pad. Select the <span class="strong"><strong>Attributes</strong></span> tab, and select <span class="strong"><strong>Dark Gray Color</strong></span> in the <span class="strong"><strong>Background</strong></span> drop-down list. Now, select the <span class="strong"><strong>Size</strong></span> tab and reduce the view's height by 60 points. Save the document.</li><li class="listitem">Compile and run the app on the simulator. The result should look like the one shown in the following screenshot:<div class="mediaobject"><img src="graphics/8924OT_02_01.jpg" alt="How to do it..."/></div><p>The dark gray portion of the simulator's screen is the view that we have just added.</p></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec48"/>How it works...</h2></div></div></div><p>We have <a id="id131" class="indexterm"/>successfully created an app that contains one view. Of course, this app does not provide any functionality. It is only meant to show how to add a view and display it.</p><p>Views are the essential components of an iOS app interface. Every visual user interface object inherits from the <code class="literal">UIView</code> class. The concept is somewhat different from a form in .NET. A view manages content drawing, accepts other views as subviews, provides autosizing features, can accept touch events for itself and its subviews, and many of its properties can even be animated. Even <code class="literal">UIWindow</code> inherits from <code class="literal">UIView</code>. It is this class or its inheritors that iOS developers will use most frequently.</p><p>When a <a id="id132" class="indexterm"/>view that is added with Interface Builder is first instantiated at runtime, it sets its <code class="literal">Frame</code> property with values that are set through the <span class="strong"><strong>Inspector</strong></span> pad's <span class="strong"><strong>Size</strong></span> tab. The <code class="literal">Frame</code> property is of the <code class="literal">RectangleF</code> type, and it defines the location of the view in its superview's coordinate system (in our case, the main window) and its size in points.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>In Objective-C, the <code class="literal">frame</code> property of UIView is of the <code class="literal">CGRect</code> type. This type has not been bound in Xamarin.iOS, and the more familiar <code class="literal">System.Drawing.RectangleF</code> was used instead.</p><p>A superview is a view's parent view, while subviews are its child views. Views that have the same superview are described as siblings.</p></div></div><p>The default coordinate system in iOS originates from the top-left corner and extends towards the bottom and the right. The coordinate origin is always the same and cannot be changed programmatically.</p><p>The coordinate system of iOS is displayed in the following diagram:</p><div class="mediaobject"><img src="graphics/Image1.jpg" alt="How it works..."/></div><p>When <a id="id133" class="indexterm"/>the <code class="literal">Frame</code> property is set, it adjusts the <code class="literal">Bounds</code> property. The <code class="literal">Bounds</code> property defines the location of the view in its own coordinate system and its size in points. It is also of the <code class="literal">RectangleF</code> type. The default location for the <code class="literal">Bounds</code> property is (0,0), and its size is always the same as the view's <code class="literal">Frame</code> value. Both these properties' sizes are connected to each other, so when you change the size of <code class="literal">Frame</code>, the size of <code class="literal">Bounds</code> changes accordingly and vice versa. You can change the <code class="literal">Bounds</code> property to display different parts of the view. </p><p>A view's frame can exceed the screen in both location and position. That is, a view's frame with values <span class="emphasis"><em>(x = -50, y = -50, width = 1500, height = 1500)</em></span> is perfectly acceptable, although it will not be completely visible on the screen of an iPhone.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec49"/>There's more...</h2></div></div></div><p>Another <a id="id134" class="indexterm"/>thing to note is that the <code class="literal">UIView</code> class inherits from the <code class="literal">UIResponder</code> class. The <code class="literal">UIResponder</code> class is responsible for responding to and handling events. When a view is added to a superview, it becomes part of its responder chain. The <code class="literal">UIView</code> class exposes the properties and methods of <code class="literal">UIResponder</code>, and the ones we are interested in describing for now are the following two:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>IsFirstResponder property</strong></span>: This returns a Boolean value indicating whether the view is the first responder. Basically, it indicates if the view has focus.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>ResignFirstResponder():</strong></span> This causes the view to lose focus.</li></ul></div><div class="section" title="Adding views programmatically"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec22"/>Adding views programmatically</h3></div></div></div><p>If we <a id="id135" class="indexterm"/>would like to add a view on our main view programmatically, we would use the following <code class="literal">UIView.AddSubview(UIView)</code> method:</p><div class="informalexample"><pre class="programlisting">this.View.AddSubview(this.subView);</pre></div><p>The <code class="literal">AddSubview</code> method adds its parameter, which is of the <code class="literal">UIView</code> type, to the list of the caller's subviews and sets its <code class="literal">Superview</code> parameter to the caller. A view will not be displayed unless it is added to a parent view with the <code class="literal">AddSubview</code> method. Also, if a view already has a superview and it is added to another view with its <code class="literal">AddSubview</code> method, its <code class="literal">Superview</code> is changed to that of the new caller. What this means is that a view can have only one superview at a time.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>When adding a view as a subview with Interface Builder, it is not required to use the <code class="literal">AddSubview</code> method to display the subview. However, it is required to call the <code class="literal">AddSubview</code> method when adding views programmatically.</p></div></div><p>For removing a view from its superview programmatically, call its <code class="literal">RemoveFromSuperview</code> method. Calling this method on a view that has no superview does nothing. Care must be taken when we want to reuse the view we want to remove. We must keep a reference to it, or it might be released.</p></div><div class="section" title="View content layout"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec23"/>View content layout</h3></div></div></div><p>Another<a id="id136" class="indexterm"/> important property of <code class="literal">UIView</code> is <code class="literal">ContentMode</code>. <code class="literal">ContentMode</code> accepts values of the <code class="literal">UIViewContentMode</code> enumeration type. This property sets how the <code class="literal">UIView</code> will display its content, usually an image. The default value of this property is <code class="literal">UIViewContentMode.ScaleToFill</code>. This scales the content to <a id="id137" class="indexterm"/>fit the exact view's size, stretching it if necessary. The available values of <code class="literal">UIViewContentMode</code> are explained in detail in the <span class="emphasis"><em>Displaying Images</em></span> recipe later in this chapter.</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec50"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a custom view</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating the UI</em></span> recipe in <a class="link" href="ch01.html" title="Chapter 1. Development Tools">Chapter 1</a>, <span class="emphasis"><em>Development Tools</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Accessing the UI with Outlets</em></span> recipe in <a class="link" href="ch01.html" title="Chapter 1. Development Tools">Chapter 1</a>, <span class="emphasis"><em>Development Tools</em></span></li></ul></div></div></div>
<div class="section" title="Receiving user input with buttons"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Receiving user input with buttons</h1></div></div></div><p>In this recipe, we will learn how to use buttons to receive and respond to user input.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec51"/>Getting ready</h2></div></div></div><p>We used <a id="id138" class="indexterm"/>buttons in <a class="link" href="ch01.html" title="Chapter 1. Development Tools">Chapter 1</a>, <span class="emphasis"><em>Development</em></span> <span class="emphasis"><em>Tools</em></span>,<a id="id139" class="indexterm"/> to discuss how to use Interface Builder to add controls to the user interface. In this recipe, we will describe the <code class="literal">UIButton</code> class in more detail. Open the <code class="literal">FirstViewApp</code> project, which we created in the previous recipe, in Xamarin Studio. Increase the height of the view, which we added, to cover the whole device screen in Interface Builder and save the document.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec52"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We will programmatically add a button in our interface. This button will change our view's background color when tapped. Open the <code class="literal">FirstViewAppViewController.cs</code> file and enter the following code in the class:<div class="informalexample"><pre class="programlisting">UIButton buttonChangeColor;
private void CreateButton ()
{
  RectangleF viewFrame = this.subView.Frame;
  RectangleF buttonFrame = new RectangleF (10f, viewFrame.Bottom - 200f, viewFrame.Width - 20f, 50f);
  this.buttonChangeColor = UIButton.FromType (UIButtonType.System);
  this.buttonChangeColor.Frame = buttonFrame;
  this.buttonChangeColor.SetTitle ("Tap to change view color", UIControlState.Normal);
  this.buttonChangeColor.SetTitle ("Changing color...", UIControlState.Highlighted);
  this.buttonChangeColor.TouchUpInside += this.ButtonChangeColor_TouchUpInside;
  this.subView.AddSubview (this.buttonChangeColor);
}
bool isYellow;
private void ButtonChangeColor_TouchUpInside (object sender, EventArgs e)
{
  if (this.isYellow) {
    this.subView.BackgroundColor = UIColor.LightGray;
    this.isYellow = false;
  }  else {
    this.subView.BackgroundColor = UIColor.Yellow;
    this.isYellow = true;
  }
}</pre></div></li><li class="listitem">In<a id="id140" class="indexterm"/> the <code class="literal">ViewDidLoad</code> method, add the<a id="id141" class="indexterm"/> following line:<div class="informalexample"><pre class="programlisting">this.CreateButton ();</pre></div></li><li class="listitem">Compile and run the app on the simulator. When the button is tapped, the result should be similar to the following screenshot:<div class="mediaobject"><img src="graphics/8924OT_02_03.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec53"/>How it works...</h2></div></div></div><p>In this<a id="id142" class="indexterm"/> recipe, we have added a button to the user interface. This button changes the background color of its superview. Furthermore, we have <a id="id143" class="indexterm"/>accomplished this without using Interface Builder at all.</p><p>Let's see now what the code does. We create the following field that will hold the button object:</p><div class="informalexample"><pre class="programlisting">// A button to change the view's background color
UIButton buttonChangeColor;</pre></div><p>In the <code class="literal">CreateButton</code> method, we create the button and set some properties. The method is shown in the following code:</p><div class="informalexample"><pre class="programlisting">// Create the appropriate rectangles for the button's frame
RectangleF viewFrame = this.subView.Frame;
RectangleF buttonFrame = new RectangleF (10f, viewFrame.Bottom - 200f, viewFrame.Width - 20f, 50f);</pre></div><p>First, we assign the view's frame to a new variable named <code class="literal">viewFrame</code>. Then, we create a new <code class="literal">RectangleF</code> object named <code class="literal">buttonFrame</code>. This object will be assigned to the button's <code class="literal">Frame</code> property. Now that we have a frame for our button, we can initialize it as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">// Create the button.
this.buttonChangeColor = UIButton.FromType (UIButtonType.System);
this.buttonChangeColor.Frame = buttonFrame;</pre></div><p>The<a id="id144" class="indexterm"/> button is initialized with the <code class="literal">UIButton.FromType(UIButtonType)</code> static method. This method takes one parameter of the <code class="literal">UIButtonType</code> type and returns predefined types of buttons that are included in iOS SDK. The <code class="literal">UIButtonType.System</code> button enumeration value used here is the default type of<a id="id145" class="indexterm"/> button without any borders or background. After the <code class="literal">buttonChangeColor</code> object is initialized, we set its frame to the <code class="literal">RectangleF</code> value we created earlier.</p><p>Now that we have provided an initialization code for the button, we will set its titles (that's right, more than one) as shown in the following code:</p><div class="informalexample"><pre class="programlisting">// Set the button's titles
this.buttonChangeColor.SetTitle ("Tap to change view color", UIControlState.Normal);
this.buttonChangeColor.SetTitle ("Changing color...", UIControlState.Highlighted);</pre></div><p>We call the <code class="literal">UIButton.SetTitle(string, UIControlState)</code> method twice. This method is responsible for setting the button's title for each given button state. The string parameter is the actual title that will be shown. The second parameter is an enumeration of the <code class="literal">UIControlState</code> type. This parameter indicates the different control states that apply to controls. These control states are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Normal</strong></span>: This is the default idle state of an enabled control.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Highlighted</strong></span>: This is the state of the control when a touch-up event occurs.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Disabled</strong></span>: This is the state when the control is disabled and does not accept any events.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Selected</strong></span>: This is the state when the control is selected. In most cases, this state does not apply. However, it is useful when a selection state is required, like in a <code class="literal">UISegmentedControl</code> object.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Application</strong></span>: This is the additional control state value for an application's use.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Reserved</strong></span>: This is for internal framework use.</li></ul></div><p>So, with the <code class="literal">UIButton.SetTitle(string, UIControlState)</code> method, we have set the title that will be displayed when the button is in its default state and the title that will be displayed while the button is being tapped.</p><p>After this, we set the button's handler for the <code class="literal">TouchUpInside</code> event and add it as a subview to <code class="literal">subView</code> using the following code:</p><div class="informalexample"><pre class="programlisting">this.buttonChangeColor.TouchUpInside += this.ButtonChangeColor_TouchUpInside;
// Display the button
this.subView.AddSubview (this.buttonChangeColor);</pre></div><p>Inside <a id="id146" class="indexterm"/>the <code class="literal">buttonChangeColor_TouchUpInside</code> event, we change the background color of the view <a id="id147" class="indexterm"/>according to the Boolean field that we have declared, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">if (this.isYellow) {
  this.subView.BackgroundColor = UIColor.DarkGray;
  this.isYellow = false;
} else {
  this.subView.BackgroundColor = UIColor.Yellow;
  this.isYellow = true;
}</pre></div><p>This is done by setting the view's <code class="literal">BackgroundColor</code> property to the appropriate <code class="literal">UIColor</code> class instance we want, as shown in the preceding highlighted code. The <code class="literal">UIColor</code> object is a class with many different static methods and properties that allow us to create different colored objects.</p><p>When you compile and run the app on the simulator, notice the view's color change when you tap the button. Also notice how the button's title changes while the mouse cursor (or a finger on the device) is "touching" the button.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec54"/>There's more...</h2></div></div></div><p>In this recipe, we used the <code class="literal">UIButton.FromType(UIButtonType)</code> static method to initialize the button. A brief description of each of the enumeration flags of <code class="literal">UIButtonType</code> are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>System</strong></span>: This is the default type of button.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Custom</strong></span>: This is a borderless transparent button. Use this flag when creating custom buttons with images as backgrounds. The button's title is not transparent.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>RoundedRect</strong></span>: This is the default type of button with rounded corners. As of iOS 7, this type of <code class="literal">UIButton</code> is deprecated. Use <code class="literal">UIButtonType.System</code> instead.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>DetailDisclosure</strong></span>: This is a round blue button that reveals additional information related to an item.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>InfoLight</strong></span>: This is a light-colored button with the letter (<span class="strong"><strong>i</strong></span>) that represents information display.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>InfoDark</strong></span>: This is the same as InfoLight; it is shown with a dark color.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>ContactAdd</strong></span>: This is a round blue button with a white plus sign (<span class="strong"><strong>+</strong></span>). Usually, this button is displayed to present contact information to add to an item.</li></ul></div><div class="section" title="Changing the appearance of buttons"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec24"/>Changing the appearance of buttons</h3></div></div></div><p>For creating custom buttons with the <code class="literal">UIButtonType.Custom</code> type, use the <code class="literal">UIButton</code> class' <code class="literal">SetBackgroundImage</code> and <code class="literal">SetImage</code> methods. They both accept one <code class="literal">UIImage</code> and one <code class="literal">UIControlState</code> parameter so that different images for different control states can be <a id="id148" class="indexterm"/>set. When setting images for buttons, be sure to set the <code class="literal">UIButton.ContentMode</code> property accordingly, irrespective of whether creating a custom button or not.</p><p>The functionality provided by the <code class="literal">SetImage</code> and <code class="literal">SetBackgroundImage</code> methods can also be accomplished in the corresponding <span class="strong"><strong>Image</strong></span> and <span class="strong"><strong>Background</strong></span> fields in the <span class="strong"><strong>Attributes</strong></span> tab of the <span class="strong"><strong>Inspector</strong></span> pad in Interface Builder. Select the state for which to set the desired image(s) from the drop-down list box and set the path to the image file, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/8924OT_02_04.jpg" alt="Changing the appearance of buttons"/></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec55"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Adding and customizing views</em></span> recipe </li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Displaying images</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a custom view</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Styling views</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating the UI</em></span> recipe in <a class="link" href="ch01.html" title="Chapter 1. Development Tools">Chapter 1</a>, <span class="emphasis"><em>Development Tools</em></span></li></ul></div></div></div>
<div class="section" title="Displaying images"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Displaying images</h1></div></div></div><p>In this recipe, we will learn how to use the <code class="literal">UIImageView</code> class to display images on screen.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec56"/>Getting ready</h2></div></div></div><p>In this <a id="id149" class="indexterm"/>recipe, we will see how to bundle and display images in a project. An image file will be needed for display. The image file used here is named <code class="literal">Toroni.jpg</code>. Create a new iPhone <span class="strong"><strong>Single View Application</strong></span> project in Xamarin Studio and name it <code class="literal">ImageViewerApp</code>. </p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec57"/>How to do it...</h2></div></div></div><p>The following are the steps for this recipe:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">ImageViewerAppViewController.xib</code> file in Interface Builder.</li><li class="listitem">Add a <code class="literal">UIImageView</code> object on its view. Connect the <code class="literal">UIImageView</code> object with an outlet named <code class="literal">imageDisplay</code>.</li><li class="listitem">Save the document.</li><li class="listitem">Back in Xamarin Studio, in the <code class="literal">ImageViewerAppViewController</code> class, enter the following code:<div class="informalexample"><pre class="programlisting">public override ViewDidLoad()
{
  base.ViewDidLoad();
  this.imageDisplay.ContentMode = UIViewContentMode.ScaleAspectFit;
  this.imageDisplay.Image = UIImage.FromFile("Toroni.jpg");
}</pre></div></li><li class="listitem">Right-click on the project in the <span class="strong"><strong>Solution</strong></span> pad and navigate to <span class="strong"><strong>Add</strong></span> | <span class="strong"><strong>Add Files…</strong></span>. Select the image file you want to display and click on <span class="strong"><strong>Open</strong></span>.</li><li class="listitem">Right-click on the image file you have just added and navigate to <span class="strong"><strong>Build Action</strong></span> | <span class="strong"><strong>BundleResource</strong></span>.</li><li class="listitem">Finally, compile and run the app on the simulator. The image you added to the <a id="id150" class="indexterm"/>project should be displayed on the screen, like in the following screenshot:<div class="mediaobject"><img src="graphics/8924OT_02_05.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec58"/>How it works...</h2></div></div></div><p>The <code class="literal">UIImageView</code> class is basically a view customized for displaying images. When you add an image in a project, its <span class="strong"><strong>Build Action</strong></span> must be set to <span class="strong"><strong>BundleResource</strong></span> in the <span class="strong"><strong>Solution</strong></span> pad; otherwise, the image will not be copied into the app bundle. Fortunately, Xamarin Studio is smart enough to handle this setting automatically for images.</p><p>The <code class="literal">ContentMode</code> property is very important when displaying images. It sets the way the <code class="literal">UIView</code> (<code class="literal">UIImageView</code> in this case) object will display the image. We have set it to <code class="literal">UIViewContentMode.ScaleAspectFit</code> so that it will be resized to fit the area of <code class="literal">UIImageView</code>, keeping the aspect ratio intact at the same time. If the <code class="literal">ContentMode</code> property <a id="id151" class="indexterm"/>was left at its default <code class="literal">ScaleToFill</code> value, the output would be something like the one shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/8924OT_02_06.jpg" alt="How it works..."/></div><p>To set the image that <code class="literal">UIImageView</code> should display, we set its <code class="literal">Image</code> property with a <code class="literal">UIImage</code> object, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">this.imageDisplay.Image = UIImage.FromFile("Toroni.jpg");</pre></div><p>The <code class="literal">ContentMode</code> property accepts an enumeration type named <code class="literal">UIViewContentMode</code>. The values<a id="id152" class="indexterm"/> provided are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ScaleToFill</code>: This is the default value of the base <code class="literal">UIView</code> object. It scales the content to fit the size of the view, changing the aspect ratio as necessary.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ScaleAspectFit</code>: This scales the content to fit the size of the view, maintaining its aspect ratio. The remaining area of the view's content becomes transparent.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ScaleAspectFill</code>: This scales the content to fill the size of the view, maintaining its aspect ratio. Some part of the content may be left out.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Redraw</code>: When a view's bounds are changed, its content is not redrawn. This value causes the content to be redrawn. Drawing content is an expensive operation in terms of CPU cycles, so think twice before using this value with large content.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Center</code>: This places the content at the center of the view, keeping its aspect ratio.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Top</code>, <code class="literal">Bottom</code>, <code class="literal">Left</code>, <code class="literal">Right</code>, <code class="literal">TopLeft</code>, <code class="literal">TopRight</code>, <code class="literal">BottomLeft</code>, and <code class="literal">BottomRight</code>: These align the content in the view with the corresponding value.</li></ul></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec59"/>There's more...</h2></div></div></div><p>The <code class="literal">UIImage</code> class is the object that represents image information. The file formats it supports are listed in the following table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>File Format</p>
</th><th style="text-align: left" valign="bottom">
<p>File extension</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Portable Network Graphics (PNG)</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">.png</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Joint Photographic Experts Group (JPEG)</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">.jpg</code>, <code class="literal">.jpeg</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Tagged Image File Format (TIFF)</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">.tiff</code>, <code class="literal">.tif</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Graphic Interchange Format</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">.gif</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Windows Bitmap Format</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">.bmp</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Windows Icon Format</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">.ico</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Windows Cursor</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">.cur</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>XWindow bitmap</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">.xbm</code>
</p>
</td></tr></tbody></table></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>Animated GIF image files are not supported by the <code class="literal">UIImageView</code> class. When an<a id="id153" class="indexterm"/> animated GIF is set to the <code class="literal">Image</code> property of <code class="literal">UIImageView</code>, only its first frame will be displayed as a static image.</p></div></div><div class="section" title="Using images for different screen sizes"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec25"/>Using images for different screen sizes</h3></div></div></div><p>Creating images for backgrounds provides developers with the ability to produce rich and elegant <a id="id154" class="indexterm"/>user interfaces for their apps. The preferred image file format for creating backgrounds for views is PNG. However, since iPhone 4 was released, the screen resolution was increased. To support both screen resolutions in an app, the iOS SDK provides an easy solution. Just save the image in the higher resolution and add a <code class="literal">@2x</code> suffix to the file name just before the extension. For example, the name of a higher resolution version of a file named <code class="literal">Default.png</code> would be <code class="literal">Default@2x.png</code>. Also, no extra code is required to use both files. Just use the <code class="literal">UIImage.FromBundle(string)</code> static method, passing the file name without an extension. The following line of code would load the appropriate file, depending on the screen resolution:</p><div class="informalexample"><pre class="programlisting">this.imageDisplay = UIImage.FromBundle("Default");</pre></div><p>iOS takes care of loading the appropriate file, depending on the device the app is running on.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>The preceding case only applies to PNG image files.</p></div></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec60"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Adding and customizing views</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Selecting images and videos</em></span> recipe in <a class="link" href="ch07.html" title="Chapter 7. Multimedia Resources">Chapter 7</a>, <span class="emphasis"><em>Multimedia Resources</em></span></li></ul></div></div></div>
<div class="section" title="Displaying and editing text"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Displaying and editing text</h1></div></div></div><p>In this recipe, we will learn how to display simple text blocks with editing functionality.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec61"/>Getting ready</h2></div></div></div><p>In this<a id="id155" class="indexterm"/> recipe, we will discuss the usage of <code class="literal">UITextView</code> and how to display <a id="id156" class="indexterm"/>editable text with it. Create a new iPhone<span class="strong"><strong> Single View Application </strong></span>project in Xamarin Studio and name it <code class="literal">TextViewApp</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec62"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open <code class="literal">TextViewAppViewController.xib</code> in Interface Builder.</li><li class="listitem">Add a <code class="literal">UIButton</code> near the top of its view and a <code class="literal">UITextView</code> below it. Connect both objects to their outlets.</li><li class="listitem">Save the document.</li><li class="listitem">Back <a id="id157" class="indexterm"/>in Xamarin Studio, enter the following <code class="literal">ViewDidLoad</code> method <a id="id158" class="indexterm"/>in the <code class="literal">TextViewAppViewController</code> class:<div class="informalexample"><pre class="programlisting">public override void ViewDidLoad ()
{
  base.ViewDidLoad ();
  this.buttonFinished.Enabled = false;
  this.buttonFinished.TouchUpInside += (sender, e) =&gt; {

    this.myTextView.ResignFirstResponder();

  } ;
  this.myTextView.Delegate = new MyTextViewDelegate(this);
}</pre></div></li><li class="listitem">Add the following nested class:<div class="informalexample"><pre class="programlisting">private class MyTextViewDelegate : UITextViewDelegate
{

  public MyTextViewDelegate (TextViewAppViewController parentController)
  {
    this.parentController = parentController;
  }
  private TextViewAppViewController parentController;

  public override void EditingStarted (UITextView textView)
  {
    this.parentController.buttonFinished.Enabled = true;
  }

  public override void EditingEnded (UITextView textView)
  {
    this.parentController.buttonFinished.Enabled = false;
  }

  public override void Changed (UITextView textView)
  {
    Console.WriteLine ("Text changed!");
  }

}</pre></div></li><li class="listitem">Compile and run the app on the simulator. Tap somewhere in the text view and the keyboard will appear. Type some text and then tap on the <span class="strong"><strong>Finished</strong></span> button to hide the keyboard.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec63"/>How it works...</h2></div></div></div><p>The <code class="literal">UITextView</code> class provides an object that displays editable blocks of text. To respond to the events of our text view, we have implemented a class (shown in the following code) that<a id="id159" class="indexterm"/> inherits from <code class="literal">UITextViewDelegate</code>, which will act <a id="id160" class="indexterm"/>as the text view's delegate:</p><div class="informalexample"><pre class="programlisting">private class MyTextViewDelegate : UITextViewDelegate
{
  public MyTextViewDelegate (TextViewAppViewController parentController)
  {this.parentController = parentController;}
  private TextViewAppViewController parentController;</pre></div><p>We declared a constructor that accepts a <code class="literal">TextViewAppViewController</code> object so that we can have the instance of our controller available to access our controls.</p><p>Then, we override three methods of the <code class="literal">UITextViewDelegate</code> class, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public override void EditingStarted (UITextView textView)
{
  this.parentController.buttonFinished.Enabled = true;
}

public override void EditingEnded (UITextView textView)
{
  this.parentController.buttonFinished.Enabled = false;
}

public override void Changed (UITextViewtextViewUITextView textView)
{
  Console.WriteLine ("Text changed!");
}</pre></div><p>These methods are the handlers that will get called whenever a corresponding event is triggered. When tapping on the text view, the <code class="literal">EditingStarted</code> method gets called. We enable the <span class="strong"><strong>Finished</strong></span> button in it. When we type some text in the text view, the <code class="literal">Changed</code> method gets called, and we can see the output of the <code class="literal">Console.WriteLine</code> method in Xamarin Studio's <span class="strong"><strong>Application Output</strong></span> pad. Finally, when we tap on the <span class="strong"><strong>Finished</strong></span> button, the keyboard hides, and the <code class="literal">EditingEnded</code> method gets called. This method allows us to disable<a id="id161" class="indexterm"/> the button.</p><p>In <a id="id162" class="indexterm"/>the <code class="literal">ViewDidLoad</code> method, we assign a handler to the <code class="literal">TouchUpInside</code> event of the button, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">this.buttonFinished.TouchUpInside += (sender, e) =&gt; {
  this.myTextView.ResignFirstResponder ();
};</pre></div><p>We call the text view's <code class="literal">ResignFirstResponder()</code> method in it so that when the button is tapped, the text view will lose focus, causing the keyboard to hide. Then, we assign a new instance of the delegate we created to the text view's <code class="literal">Delegate</code> property, passing the instance of the <code class="literal">TextViewAppViewController</code> object, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">this.myTextView.Delegate = new MyTextViewDelegate (this);</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec64"/>There's more...</h2></div></div></div><p>Delegates in Objective-C are somewhat different than those in C#. Although in both worlds, their most common usage is to provide access to some form of event notification mechanism, in Objective-C, this mechanism is a bit more complex. A C# delegate is much like a function pointer in C or C++ programming languages. It is an object that holds a reference to a method of a specific signature. On the other hand, an Objective-C delegate is a certain type of object that conforms to a specific <code class="literal">protocol</code>. It is basically an object that wraps one or more methods (and/or other members) that act as event handlers.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>An Objective-C protocol is similar to an interface in C#.</p></div></div><p>The concept of delegate objects might seem confusing at first, but it is not difficult to comprehend. Regarding the event notification mechanism, Xamarin.iOS simplifies things for .NET developers by providing events for most objects, including <code class="literal">UITextView</code> described here.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec65"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Using the keyboard</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Using the keyboard"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Using the keyboard</h1></div></div></div><p>In this recipe, we will discuss some important aspects of the device's virtual keyboard usage.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec66"/>Getting ready</h2></div></div></div><p>In the <a id="id163" class="indexterm"/>previous recipe, we discussed how to edit text. In this recipe, we will discuss some of the things we can or even must do to use the keyboard effectively. Create a new iPhone<span class="strong"><strong> Single View Application</strong></span> project in Xamarin Studio and name it <code class="literal">KeyboardApp</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec67"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">KeyboardAppViewController.xib</code> file in Interface Builder.</li><li class="listitem">Add a <code class="literal">UITextField</code> object in the bottom-half portion of the view and connect it to an outlet.</li><li class="listitem">Save the document.</li><li class="listitem">Back in Xamarin Studio, enter the following code in the <code class="literal">KeyboardAppViewController</code> class:<div class="informalexample"><pre class="programlisting">private NSObject kbdWillShow, kbdDidHide;
public override void ViewDidLoad()
{

  base.ViewDidLoad();

  this.emailField.KeyboardType = UIKeyboardType.EmailAddress;
  this.emailField.ReturnKeyType = UIReturnKeyType.Done;

  this.kbdWillShow = UIKeyboard.Notifications.ObserveWillShow((s, e) =&gt; {RectangleF kbdBounds = e.FrameEnd;
    RectangleF textFrame = this.emailField.Frame;
      textFrame.Y -= kbdBounds.Height;
  this.emailField.Frame = textFrame;
  } );
  this.kbdDidHide = UIKeyboard.Notifications.ObserveDidHide((s, e) =&gt; {
    RectangleF kbdBounds = e.FrameEnd;
    RectangleF textFrame = this.emailField.Frame;
    textFrame.Y += kbdBounds.Height;
    this.emailField.Frame = textFrame;
  } );

  this.emailField.ShouldReturn = delegate(UITextField textField) {
    return textField.ResignFirstResponder ();
  } ;

}</pre></div></li><li class="listitem">Compile and run the app on the simulator. Tap on the text field and watch it moving <a id="id164" class="indexterm"/>upwards to avoid being hidden from the keyboard. Tap the <span class="strong"><strong>Done</strong></span> button on the keyboard and watch the text field returning to its original position when the keyboard hides.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec68"/>How it works...</h2></div></div></div><p>There are various types of keyboards in iOS. Since not all keys can be displayed at once due to the restricted screen size, it is a good practice to set the appropriate type of keyboard according to the text input we need the user to provide. In this project, we have set the keyboard to the <span class="strong"><strong>Email Address</strong></span> type. We have also customized the type of <span class="strong"><strong>Return key</strong></span> by setting it to <span class="strong"><strong>Done</strong></span> in the following code:</p><div class="informalexample"><pre class="programlisting">this.emailField.KeyboardType = UIKeyboardType.EmailAddress;
this.emailField.ReturnKeyType = UIReturnKeyType.Done;</pre></div><p>When the keyboard is displayed, it is the developer's responsibility to make sure it does not obstruct the essential UI elements. In this case, since we provide the user with the ability to enter some text input, we have to make sure that the text field is shown, so the user will be able to see what is being typed. For this, we add two observers in the default notification center using the following code:</p><div class="informalexample"><pre class="programlisting">// Add observers for the keyboard
this.kbdWillShow = UIKeyboard.Notifications.ObserveWillShow((s, e) =&gt; {</pre></div><p>The notification center is iOS' mechanism for providing system-wide notifications. Normally, it can be accessed through the <code class="literal">NSNotificationCenter.DefaultCenter</code> static property. However, Xamarin.iOS provides some APIs that simplify things for us. In the example project for this recipe, you will find the usage of both APIs. In this recipe, we are using Xamarin's APIs.</p><p>By calling <code class="literal">UIKeyboard.Notifications.ObserveWillShow</code> and passing a handler to it, we subscribe to the notification center so that we get notified whenever the keyboard is about to be displayed. This handler is of the <code class="literal">EventHandler&lt;UIKeyboardEventArgs&gt;</code> type, and the <code class="literal">UIKeyboardEventArgs</code> parameter provides us with, among others, the frame of the keyboard after it has been shown (as shown in the following code):</p><div class="informalexample"><pre class="programlisting">// Get the keyboard's bounds
RectangleF kbdBounds = e.FrameEnd;</pre></div><p>Then, we store the text field's frame in a variable using the following code:</p><div class="informalexample"><pre class="programlisting">// Get the text field's frame
RectangleF textFrame = this.emailField.Frame;</pre></div><p>We<a id="id165" class="indexterm"/> reduce the frame's <code class="literal">Y</code> position using the following code value so that the text field will move upwards:</p><div class="informalexample"><pre class="programlisting">// Change the y position of the text field frame
textFrame.Y -= kbdBounds.Height;</pre></div><p>When the new frame is set to <code class="literal">emailField</code> (as shown in the following code), it will move to the new position:</p><div class="informalexample"><pre class="programlisting">this.emailField.Frame = textFrame;</pre></div><p>The second handler is needed for moving the text field back to its original position after the keyboard is closed. It is almost the same as the first handler, except for two differences. The <code class="literal">UIKeyboard.Notifications.ObserveDidHide</code> method is used. This method will trigger our handler after the keyboard is hidden. In this handler, we just make sure that we readjust the text field's position back to where it was.</p><p>The last few lines of code in the <code class="literal">ViewDidLoad</code> method set the <code class="literal">ShouldReturn</code> property of the <code class="literal">UITextField</code> class. This property accepts a delegate of the <code class="literal">UITextFieldCondition</code> type, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">this.emailField.ShouldReturn = delegate(UITextField textField) {
  return textField.ResignFirstResponder ();
} ;</pre></div><p>The handler we have added is called whenever the user taps the return key on the virtual keyboard. Here, we call the <code class="literal">ResignFirstResponder</code> method of <code class="literal">UITextField</code>, which will hide our keyboard.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec69"/>There's more...</h2></div></div></div><p>The two fields of the <code class="literal">NSObject</code> type in the class, which are assigned to the return values of the <code class="literal">UIKeyboard.Notifications</code> methods we used, hold information about the observers we added. For removing the two observers we have added here, add the following code:</p><div class="informalexample"><pre class="programlisting">NSNotificationCenter.DefaultCenter.RemoveObserver (this.kbdWillShow);
NSNotificationCenter.DefaultCenter.RemoveObserver (this.kbdDidHide);</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>Care must be taken when developing an app that uses the keyboard and supports multiple<a id="id166" class="indexterm"/> interface orientations. If, for example, the keyboard appears in portrait orientation and the user changes to landscape orientation, both the keyboard's bounds and the text field's frame will be different and must be adjusted accordingly.</p></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec70"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Displaying and editing text</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Adjusting the UI orientation</em></span> recipe in <a class="link" href="ch09.html" title="Chapter 9. Interacting with Device Hardware">Chapter 9</a>, <span class="emphasis"><em>Interacting with Device Hardware</em></span></li></ul></div></div></div>
<div class="section" title="Displaying progress"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Displaying progress</h1></div></div></div><p>In this recipe, we will discuss how to display the progress of known length.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec71"/>Getting ready</h2></div></div></div><p>In this<a id="id167" class="indexterm"/> recipe, we will talk about the <code class="literal">UIProgressView</code> control. This control provides a similar functionality to the ProgressBar control in .NET. Create a new iPhone <span class="strong"><strong>Single View Application</strong></span> project in Xamarin Studio and name it <code class="literal">ProgressApp</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec72"/>How to do it...</h2></div></div></div><p>The following are the steps for using the <code class="literal">UIProgressView</code> class. Note that in this recipe, we will add all the controls programmatically without the use of Interface Builder.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add the following <code class="literal">using</code> directives in the <code class="literal">ProgressAppViewController</code> class file:<div class="informalexample"><pre class="programlisting">using System.Drawing;
using System.Threading;
using System.Threading.Tasks;</pre></div></li><li class="listitem">Add the following fields in the class:<div class="informalexample"><pre class="programlisting">UILabel labelStatus;
UIButton buttonStartProgress;
UIProgressView progressView;
float incrementBy = 0f;</pre></div></li><li class="listitem">Enter<a id="id168" class="indexterm"/> the following code in the <code class="literal">ViewDidLoad</code> override:<div class="informalexample"><pre class="programlisting">// Initialize the label
this.labelStatus = new UILabel (new RectangleF (60f, 60f, 200f, 50f));
this.labelStatus.AdjustsFontSizeToFitWidth = true;
// Initialize the button
this.buttonStartProgress = UIButton.FromType (UIButtonType.System);
this.buttonStartProgress.Frame = new RectangleF (60f, 400f, 200f, 40f);

this.buttonStartProgress.SetTitle ("Tap to start progress!", UIControlState.Normal);
this.buttonStartProgress.TouchUpInside += delegate {
  // Disable the button
  this.buttonStartProgress.Enabled = false;
  this.progressView.Progress = 0f;
  // Start a progress
  Task.Factory.StartNew(this.StartProgress);
} ;

// Initialize the progress view
this.progressView = new UIProgressView (new RectangleF (60f, 200f, 200f, 50f));

// Set the progress view's initial value
this.progressView.Progress = 0f;

// Set the progress increment value
// for 10 items
this.incrementBy = 1f / 10f;

this.View.AddSubview(this.labelStatus);
this.View.AddSubview(this.buttonStartProgress);
this.View.AddSubview(this.progressView);</pre></div></li><li class="listitem">Add the following method in the class:<div class="informalexample"><pre class="programlisting">private void StartProgress ()
{
  float currentProgress = 0f;
  while (currentProgress &lt; 1f)
  {
    Thread.Sleep(1000);
    this.InvokeOnMainThread(delegate {
      // Advance the progress
      this.progressView.Progress += this.incrementBy;
      currentProgress = this.progressView.Progress;
      // Set the label text
      this.labelStatus.Text = string.Format("Current value: { 0}", Math.Round((double)this.progressView.Progress, 2));
      if (currentProgress &gt;= 1f)
      {
        this.labelStatus.Text = "Progress completed!";
        this.buttonStartProgress.Enabled = true;
      }//end if
    } );
  }//end while
}</pre></div></li><li class="listitem">Compile<a id="id169" class="indexterm"/> and run the app on the simulator. Tap on the button and watch the progress bar fill.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec73"/>How it works...</h2></div></div></div><p>The current value of <code class="literal">UIProgressView</code> is represented by its <code class="literal">Progress</code> property. Its acceptable value range is always from <code class="literal">0</code> to <code class="literal">1</code>. So, when we initialize it, we set it to <code class="literal">0</code> to make sure that the bar is not filled at all. This can be done using the following code:</p><div class="informalexample"><pre class="programlisting">this.progressView.Progress = 0f;</pre></div><p>Since <code class="literal">UIProgressView</code> has a specific range, we need to assign the value we want it to be incremented by, depending on the number of items we need to process (in this case, 10) using the following code:</p><div class="informalexample"><pre class="programlisting">this.incrementBy = 1f / 10f;</pre></div><p>In the button's <code class="literal">TouchUpInside</code> handler, we disable the button and start our progress through <code class="literal">Task</code> from <code class="literal">System.Threading.Tasks</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">this.buttonStartProgress.TouchUpInside += delegate {
  // Disable the button
  this.buttonStartProgress.Enabled = false;
  this.progressView.Progress = 0;
  // Start a progress
  Task.Factory.StartNew(this.StartProgress);
};</pre></div><p>In the <code class="literal">StartProgress()</code> method, we start a loop that will process the work, which needs to be done. Since the work executes on a separate thread, when we want to make changes to the controls, it must be done on the main UI thread by calling the <code class="literal">InvokeOnMainThread</code> method, which accepts a parameter of the <code class="literal">NSAction</code> type. An <code class="literal">NSAction</code> type parameter can accept anonymous methods as well, as seen in the following code:</p><div class="informalexample"><pre class="programlisting">this.InvokeOnMainThread(delegate {
  // Advance the progress
  this.progressView.Progress += this.incrementBy;
  currentProgress = this.progressView.Progress;
  // Set the label text
  this.labelStatus.Text = string.Format("Current value: { 0}", Math.Round((double)this.progressView.Progress, 2));
  if (currentProgress &gt;= 1f)
  {
    this.labelStatus.Text = "Progress completed!";
    this.buttonStartProgress.Enabled = true;
  }//end if
});</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec74"/>There's more...</h2></div></div></div><p>The <a id="id170" class="indexterm"/>progress view supports two styles. <code class="literal">UIProgressViewStyle.Default</code> (the one that was used in this recipe) and <code class="literal">UIProgressViewStyle.Bar</code>. There is absolutely no functionality difference between the two styles, except for appearance. To change the style of the progress view, set its <code class="literal">Style</code> property to one of the previously mentioned values.</p><div class="section" title="UIProgressView height"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec26"/>UIProgressView height</h3></div></div></div><p>Setting the<a id="id171" class="indexterm"/> height of the progress view has no effect, as it is constant for the control. For creating a variable-height progress bar, the <code class="literal">UIProgressView</code> class must be subclassed.</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec75"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Receiving user input with buttons</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Displaying content larger than the screen"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Displaying content larger than the screen</h1></div></div></div><p>In this recipe, we <a id="id172" class="indexterm"/>will learn how to display content that extends beyond the screen's bounds.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec76"/>Getting ready</h2></div></div></div><p>In this recipe, we will discuss the <code class="literal">UIScrollView</code> control. Create a new iPhone <span class="strong"><strong>Single View Application</strong></span> project and name it <code class="literal">ScrollApp</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec77"/>How to do it...</h2></div></div></div><p>The following are the steps to create the project:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">ScrollAppViewController.xib</code> file in Interface Builder.</li><li class="listitem">Add a <code class="literal">UIScrollView</code> object on its view and connect it to an outlet. Save the document.</li><li class="listitem">Back <a id="id173" class="indexterm"/>in Xamarin Studio, add the following code in the <code class="literal">ScrollAppViewController</code> class:<div class="informalexample"><pre class="programlisting">// Image view
UIImageView imgView;
public override void ViewDidLoad()
{
  base.ViewDidLoad();

  this.imgView = new UIImageView (UIImage.FromFile ("Kastoria.jpg"));
  this.scrollView.ContentSize = this.imgView.Image.Size;
  this.scrollView.ContentOffset = new PointF (200f, 50f);
  this.scrollView.PagingEnabled = true;
  this.scrollView.MinimumZoomScale = 0.25f;
  this.scrollView.MaximumZoomScale = 2f;
  this.scrollView.ViewForZoomingInScrollView = delegate(UIScrollView scroll) {
    return this.imgView;
  } ;
  this.scrollView.ZoomScale = 1f;

  this.scrollView.IndicatorStyle = UIScrollViewIndicatorStyle.White;
  this.scrollView.AddSubview (this.imgView);

}</pre></div></li><li class="listitem">Finally, add an image to the project and set its <span class="strong"><strong>Build Action</strong></span> to <span class="strong"><strong>BundleResource</strong></span>. An image larger than the screen size of 640 x 1136 pixels of iPhone 5S is preferable.</li><li class="listitem">Compile and run the app on the simulator. Tap and drag the image to display different portions. By pressing <span class="emphasis"><em>Alt</em></span> + left-mouse click, you can simulate the pinch zooming function.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec78"/>How it works...</h2></div></div></div><p>The <code class="literal">UIScrollView</code> is capable of managing content that expands beyond the screen size. The size of the content that the scroll view will display must be set in its <code class="literal">ContentSize</code> property, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">this.scrollView.ContentSize = this.imgView.Image.Size;</pre></div><p>The <code class="literal">ContentOffset</code> property shown in the following code defines the position of the content <a id="id174" class="indexterm"/>inside the scroll view's bounds:</p><div class="informalexample"><pre class="programlisting">this.scrollView.ContentOffset = new PointF (200f, 50f);</pre></div><p>What this means is that the image's (x=200, y=50) point will be displayed at the origin (x=0, y=0) of <code class="literal">UIScrollView</code>. To provide a zooming functionality for the content, we first set the <code class="literal">MinimumZoomScale</code> and <code class="literal">MaximumZoomScale</code> properties, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">this.scrollView.MinimumZoomScale = 0.25f;
this.scrollView.MaximumZoomScale = 2f;</pre></div><p>The preceding code set the minimum and maximum zoom scale for the content. A value of <code class="literal">2</code> means that the content will be displayed double in size, while a value of <code class="literal">0.5</code> means that the content will be displayed at half its size.</p><p>For the actual zooming operation, we need to set the <code class="literal">ViewForZoomingInScrollView</code> property, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">this.scrollView.ViewForZoomingInScrollView = delegate(UIScrollView scroll) {
  return this.imgView;
};</pre></div><p>The <code class="literal">ViewForZoomingInScrollView</code> property accepts a <code class="literal">delegate</code> variable of the <code class="literal">UIScrollViewGetZoomView</code> type and returns <code class="literal">UIView</code>. Here, the image view that we created is returned, but another image view of a higher resolution can be used instead to provide better image quality when zooming. After the <code class="literal">delegate</code> variable is assigned, the initial zoom scale is set using the following code:</p><div class="informalexample"><pre class="programlisting">this.scrollView.ZoomScale = 1f;</pre></div><p>Finally, the scroll view's indicator style is set, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">this.scrollView.IndicatorStyle = UIScrollViewIndicatorStyle.White;</pre></div><p>Indicators are the two lines that appear when scrolling or zooming: one vertical line on the right side and one horizontal line on the bottom side of the scroll view. These lines inform the user of the position of the content.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec79"/>There's more...</h2></div></div></div><p>To provide a more pleasing scrolling and zooming effect to the user, the <code class="literal">UIScrollView</code> exposes the <code class="literal">Bounce</code> property. By default, it is set to <code class="literal">true</code>, but we have the option to disable it by setting it to <code class="literal">false</code>. Bouncing the content gives immediate feedback to the user that the bounds of the content have been reached, in either a horizontal or vertical direction. Furthermore, the <code class="literal">AlwaysBounceHorizontal</code> and <code class="literal">AlwaysBounceVertical</code> properties <a id="id175" class="indexterm"/>can be set individually. Setting one or both of these properties will make the scroll view bounce the content in the respective direction always, even if the content is equal to or smaller than the scroll view's bounds. Hence, no actual scrolling is needed.</p><div class="section" title="UIScrollView events"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec27"/>UIScrollView events</h3></div></div></div><p>The <code class="literal">UIScrollView</code> class exposes some of the following very useful events:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Scrolled</code>: This<a id="id176" class="indexterm"/> occurs while the content is being scrolled</li><li class="listitem" style="list-style-type: disc"><code class="literal">DecelerationStarted</code>: This <a id="id177" class="indexterm"/>occurs when the user has started scrolling the content</li><li class="listitem" style="list-style-type: disc"><code class="literal">DecelerationEnded</code>: This occurs when the user has finished scrolling, and the <a id="id178" class="indexterm"/>content has stopped moving</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>If a handler has been assigned to the <code class="literal">Scrolled</code> event, it will be triggered whenever the <code class="literal">ContentOffset</code> property is set.</p></div></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec80"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Displaying images</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Displaying and editing text</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Navigating through the content divided into pages</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Navigating through the content divided into pages"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Navigating through the content divided into pages</h1></div></div></div><p>In this<a id="id179" class="indexterm"/> recipe, we will learn how to use the <code class="literal">UIPageControl</code> class <a id="id180" class="indexterm"/>to provide page navigation.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec81"/>Getting ready</h2></div></div></div><p>The <code class="literal">UIPageControl</code> provides a simple visual representation of multiple pages or screens in an iOS app, which is indicated by dots. The following screenshot shows an example of the page control indicating that content is divided into three pages:</p><div class="mediaobject"><img src="graphics/8924OT_02_09.jpg" alt="Getting ready"/></div><p>The dot<a id="id181" class="indexterm"/> that corresponds to the current page is <a id="id182" class="indexterm"/>highlighted. It is usually combined with <code class="literal">UIScrollView</code>. Create a new iPhone<span class="strong"><strong> Single View Application</strong></span> project in Xamarin Studio and name it <code class="literal">PageNavApp</code>. Add three image files in the project and set their <span class="strong"><strong>Build Action</strong></span> to <span class="strong"><strong>BundleResource</strong></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec82"/>How to do it...</h2></div></div></div><p>The following are the steps to create this project:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">PageNavAppViewController.xib</code> file in Interface Builder.</li><li class="listitem">Add <code class="literal">UIPageControl</code> to the bottom of the view and <code class="literal">UIScrollView</code> above it. Resize the scroll view to take up all the remaining space of the view and save the document.</li><li class="listitem">Back in Xamarin Studio, enter the following code in the <code class="literal">PageNavAppViewController</code> class:<div class="informalexample"><pre class="programlisting">UIImageView page1;
UIImageView page2;
UIImageView page3;
public override void ViewDidLoad()
{
  base.ViewDidLoad();
  this.scrollView.DecelerationEnded += this.ScrollView_DecelerationEnded;
  this.pageControl.ValueChanged += this.PageControl_ValueChanged;
  this.scrollView.Scrolled += delegate {
    Console.WriteLine ("Scrolled!");
  } ;

  this.scrollView.PagingEnabled = true;

  RectangleF pageFrame = this.scrollView.Frame;
  this.scrollView.ContentSize = new SizeF (pageFrame.Width * 3, pageFrame.Height);

  this.page1 = new UIImageView (pageFrame);
 this.page1.ContentMode = UIViewContentMode.ScaleAspectFit;
  this.page1.Image = UIImage.FromFile ("Parga01.jpg");

  pageFrame.X += this.scrollView.Frame.Width;
  this.page2 = new UIImageView (pageFrame);
  this.page2.ContentMode = UIViewContentMode.ScaleAspectFit;
  this.page2.Image = UIImage.FromFile ("Parga02.jpg");

  pageFrame.X += this.scrollView.Frame.Width;
  this.page3 = new UIImageView (pageFrame);
  this.page3.ContentMode = UIViewContentMode.ScaleAspectFit;
  this.page3.Image = UIImage.FromFile ("Parga03.jpg");

  this.scrollView.AddSubview (this.page1);
  this.scrollView.AddSubview (this.page2);
  this.scrollView.AddSubview (this.page3);

}</pre></div></li><li class="listitem">Add the<a id="id183" class="indexterm"/> following methods in the <a id="id184" class="indexterm"/>class:<div class="informalexample"><pre class="programlisting">private void scrollView_DecelerationEnded (object sender, EventArgs e)
{
  float x1 = this.page1.Frame.X;
  float x2 = this.page2.Frame.X;

  float x = this.scrollView.ContentOffset.X;

  if (x == x1)
  {
    this.pageControl.CurrentPage = 0;
  }  else if (x == x2)
  {
    this.pageControl.CurrentPage = 1;
  }  else
  {
    this.pageControl.CurrentPage = 2;

  }

}

private void pageControl_ValueChanged (object sender, EventArgs e)
{

  PointF contentOffset = this.scrollView.ContentOffset;

  switch (this.pageControl.CurrentPage)
  {

    case 0:
    contentOffset.X = this.page1.Frame.X;
    this.scrollView.SetContentOffset (contentOffset, true);
    break;

    case 1:
    contentOffset.X = this.page2.Frame.X;
    this.scrollView.SetContentOffset (contentOffset, true);
    break;

    case 2:
    contentOffset.X = this.page3.Frame.X;
    this.scrollView.SetContentOffset (contentOffset, true);
    break;

    default:
    // do nothing
    break;
  }

}</pre></div></li><li class="listitem">Compile <a id="id185" class="indexterm"/>and run the app on the <a id="id186" class="indexterm"/>simulator. Scroll sideways on the scroll view to change the page. Likewise, tap or scroll on the page control to change the page.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec83"/>How it works...</h2></div></div></div><p>The first thing that we need to do is set the <code class="literal">UIScrollView.PagingEnabled</code> property to true, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">this.scrollView.PagingEnabled = true;</pre></div><p>This property instructs the scroll view to stop scrolling at multiples of the scroll view's bounds, hence providing paging functionality. After this, the image views that will be displayed on different pages are prepared. Here, we take care of adjusting each image view's<a id="id187" class="indexterm"/> frame so that they will be positioned<a id="id188" class="indexterm"/> next to each other, using the following code:</p><div class="informalexample"><pre class="programlisting">this.page1 = new UIImageView (pageFrame);

// Frame for 2nd page
pageFrame.X += this.scrollView.Frame.Width;

// Frame for 3rd page
pageFrame.X += this.scrollView.Frame.Width;</pre></div><p>We have attached handlers for two events. The first one is the <code class="literal">UIScrollView.DecelerationEnded</code> event, which will adjust the page control's current page when the user scrolls the scroll view. The current page is determined by the scroll view's <code class="literal">ContentOffset</code> property, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">float x = this.scrollView.ContentOffset.X;
if (x == x1) {
  // First page
  this.pageControl.CurrentPage = 0;
// etc.</pre></div><p>The second event to which we attach a handler is the <code class="literal">UIPageControl.ValueChanged</code> event. In this handler, we make sure that the content is scrolled when the user taps or drags on the page control. The scrolling action is performed when the <code class="literal">ContentOffset</code> property is set to the desired image view's <code class="literal">Frame.X</code> property using the <code class="literal">UIScrollView.SetContentOffset(PointF, bool)</code> method, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">case 0:
  // Scroll to first page
  contentOffset.X = this.page1.Frame.X;
    this.scrollView.SetContentOffset (contentOffset, true);
  break;
// etc.</pre></div><p>The second parameter of the <code class="literal">SetContentOffset</code> method instructs the scroll view to animate while scrolling.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec84"/>There's more...</h2></div></div></div><p>In this recipe, different <code class="literal">UIImageView</code> objects have been used. Any kind of <code class="literal">UIView</code> object can be used according to the type of content we want to display.</p><div class="section" title="Proper usage of UIPageControl"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec28"/>Proper usage of UIPageControl</h3></div></div></div><p>Users <a id="id189" class="indexterm"/>expect that scrolling to other pages will occur when tapping or dragging on the page control. It is not a good practice to use it for displaying page indexing only.</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec85"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Displaying images</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Displaying content larger than the screen</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Displaying alerts"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec26"/>Displaying alerts</h1></div></div></div><p>The <code class="literal">UIAlertView</code> class provides us with the ability to display alert messages to the user. In this recipe, we <a id="id190" class="indexterm"/>will discuss how to use this class and respond to user input.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec86"/>Getting ready</h2></div></div></div><p>For this recipe, create an iPhone<span class="strong"><strong> Single View Application</strong></span> project in Xamarin Studio and name it <code class="literal">AlertViewApp</code>. Open the <code class="literal">AlertViewAppViewController.xib</code> file in Xcode and add a button on its view. Don't forget to connect it to an outlet.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec87"/>How to do it…</h2></div></div></div><p>Perform the following steps to implement the <code class="literal">UIAlertView</code> in the app:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In Xamarin Studio, open the <code class="literal">AlertViewAppViewController.cs</code> file and add the following method:<div class="informalexample"><pre class="programlisting">private void ShowAlert(string title, string message)
{
  // Create the alert
  UIAlertView alertView = new UIAlertView();
  alertView.Title = title;
  alertView.Message = message;
  // Add buttons
  alertView.AddButton("OK");
  alertView.AddButton("Cancel");
  // Add event handler
  alertView.Dismissed += (sender, e) =&gt; {
    if (e.ButtonIndex == 0)
    {
      this.btnShowAlert.SetTitle("OK!", UIControlState.Normal);
    }  else
    {  
      this.btnShowAlert.SetTitle("Cancelled!", UIControlState.Normal);
    }//end if else
  };
  // Display it
  alertView.Show();
}//end void ShowAlert</pre></div></li><li class="listitem">In the <code class="literal">ViewDidLoad</code> method, add the following line of code:<div class="informalexample"><pre class="programlisting">this.btnShowAlert.TouchUpInside += (sender, e) =&gt; this.ShowAlert("Alert Message", "Tap OK or Cancel");</pre></div></li><li class="listitem">Compile <a id="id191" class="indexterm"/>and run the app in the simulator.</li><li class="listitem">Tap the button on the view. The alert should be displayed, as shown in the following screenshot:<div class="mediaobject"><img src="graphics/8924OT_02_07.jpg" alt="How to do it…"/></div></li><li class="listitem">Tap <a id="id192" class="indexterm"/>either <span class="strong"><strong>OK</strong></span> or <span class="strong"><strong>Cancel</strong></span>. The <span class="strong"><strong>Show alert</strong></span> button's title will change according to the alert button that was tapped.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec88"/>How it works...</h2></div></div></div><p>The <code class="literal">UIAlertView</code> is a modal control. This means that once it is presented, the user is required to take an action for it to disappear. After creating the instance, we assign the title and the message that will be displayed through the <code class="literal">Title</code> and <code class="literal">Message</code> properties, respectively, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">alertView.Title = title;
alertView.Message = message;</pre></div><p>We then add the buttons we want to display through the <code class="literal">AddButton</code> method, which accepts a <code class="literal">string</code> parameter for the button's title, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">// Add buttons
alertView.AddButton("OK");
alertView.AddButton("Cancel");</pre></div><p>We can practically add as many buttons as we want; however, it would be good to avoid adding more than three or four buttons. If there is a need for more options, it would be best to show a new view to the user with these options, instead of using an alert view.</p><p>After adding<a id="id193" class="indexterm"/> the buttons, we need an event handler (as shown in the following code) that will inform us of the user's action on the alert view:</p><div class="informalexample"><pre class="programlisting">// Add event handler
alertView.Dismissed += (sender, e) =&gt; {
  if (e.ButtonIndex == 0)
  {
    this.btnShowAlert.SetTitle("OK!", UIControlState.Normal);
  }  else
  {  
    this.btnShowAlert.SetTitle("Cancelled!", UIControlState.Normal);
  }
};</pre></div><p>For this functionality, we use the <code class="literal">Dismissed</code> event that is triggered whenever the alert view is hidden. This occurs when any of its buttons are tapped. In the event handler, we can determine which button was tapped through the passed <code class="literal">ButtonIndex</code> property of <code class="literal">UIButtonEventArgs</code>. It is pretty clear which index corresponds to which button. The first button we added will have an index of <code class="literal">0</code>, the second button will have an index of <code class="literal">1</code>, and so on.</p><p>Finally, to display the alert view, we call its <code class="literal">Show</code> method using the following code:</p><div class="informalexample"><pre class="programlisting">// Display it
alertView.Show();</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec89"/>There's more...</h2></div></div></div><p>
<code class="literal">UIAlertView</code> also supports text input. We can implement it by setting its <code class="literal">AlertViewStyle</code> property before displaying it. The <code class="literal">AlertViewStyle</code> property accepts the following values:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">UIAlertViewStyle.Default</code>: This alert view will not contain text input</li><li class="listitem" style="list-style-type: disc"><code class="literal">UIAlertViewStyle.SecureTextInput</code>: This alert view will contain a text field for password input, which obscures the typed text</li><li class="listitem" style="list-style-type: disc"><code class="literal">UIAlertViewStyle.PlainTextInput</code>: In this, only one simple text field will be included</li><li class="listitem" style="list-style-type: disc"><code class="literal">UIAlertViewStyle.LoginAndPasswordInput</code>: Using this property, two text fields will be displayed, one plain and one secure, for entering the login credentials</li></ul></div><p>To access<a id="id194" class="indexterm"/> any of the mentioned text fields, we call the <code class="literal">GetTextField</code> method, passing the appropriate index, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">// Get the text that was entered in the second text field
string password = alertView.GetTextField(1).Text;</pre></div><p>Of course, we can also modify the text fields themselves. For example, if we want to disable obscuring the characters of the password text field, we can add the following line of code:</p><div class="informalexample"><pre class="programlisting">alertView.GetTextField(1).SecureTextEntry = false;</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec90"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Receiving user input with buttons</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Displaying and editing text</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Creating a custom view"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec27"/>Creating a custom view</h1></div></div></div><p>In this recipe, we will learn how to override the <code class="literal">UIView</code> class and/or classes that derive from it to create<a id="id195" class="indexterm"/> custom views.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec91"/>Getting ready</h2></div></div></div><p>So far, we have discussed many of the available views to create iOS apps. There will be many cases, however, we will need to implement our own custom views. In this recipe, we will see how to create a custom view and use it.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>Creating custom views is very useful when we want to capture touches or implement other custom behavior such as drawing.</p></div></div><p>Create a new iPhone<span class="strong"><strong> Single View Application</strong></span> project in Xamarin Studio and name it <code class="literal">CustomViewApp</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec92"/>How to do it...</h2></div></div></div><p>The following are the steps to complete this recipe:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add a new C# class file in the project and name it <code class="literal">MyView</code>.</li><li class="listitem">Implement it with the following code:<div class="informalexample"><pre class="programlisting">using System;
using MonoTouch.UIKit;
using MonoTouch.Foundation;
using System.Drawing;

namespace CustomViewApp
{
  [Register("MyView")]
  public class MyView : UIView
  {

    private UILabel labelStatus;

    public MyView (IntPtr handle) : base(handle)
    {
      this.Initialize ();
    }

    public MyView (RectangleF frame) : base(frame)
    {
      this.Initialize ();
    }

    private void Initialize ()
    {

      this.BackgroundColor = UIColor.LightGray;

      this.labelStatus = new UILabel (new RectangleF (0f, 400f, this.Frame.Width, 60f));
      this.labelStatus.TextAlignment = UITextAlignment.Center;
      this.labelStatus.BackgroundColor = UIColor.DarkGray;
      this.AddSubview (this.labelStatus);

    }

    public override void TouchesMoved (NSSet touches, UIEventevtUIEvent evt)
    {
      base.TouchesMoved (touches, evt);

      UITouch touch = (UITouch)touches.AnyObject;

      PointF touchLocation = touch.LocationInView (this);

      this.labelStatus.Text = String.Format ("X: {0} - Y: {1}", touchLocation.X, touchLocation.Y);

    }
  }
}</pre></div></li><li class="listitem">Open the <code class="literal">CustomViewAppViewController.xib</code> file in Interface Builder and add a <code class="literal">UIView</code> object on the main view.</li><li class="listitem">Set its <span class="strong"><strong>Class</strong></span> field in the <span class="strong"><strong>Identity Inspector</strong></span> to <code class="literal">MyView</code>.</li><li class="listitem">Save<a id="id196" class="indexterm"/> the document.</li><li class="listitem">Compile and run the app on the simulator. Tap and drag the view and watch the touch coordinates being displayed in the label at the bottom of the screen.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec93"/>How it works...</h2></div></div></div><p>The first thing to note when creating custom views is to derive them from the <code class="literal">UIView</code> class and decorate them with the <code class="literal">RegisterAttribute</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">[Register("MyView")]
public class MyView : UIView</pre></div><p>The <code class="literal">RegisterAttribute</code> basically exposes our class to the Objective-C world. Note that the name we pass as its parameter must be the same name we enter in the <span class="strong"><strong>Class</strong></span> field in the <span class="strong"><strong>Identity Inspector</strong></span>. It is important to create the following constructor:</p><div class="informalexample"><pre class="programlisting">public MyView (IntPtr handle) : base(handle) {}</pre></div><p>This constructor overrides the base class' <code class="literal">UIView(IntPtr)</code>. This constructor is always being called when a view is initialized through the native code. If we do not override it, an exception will occur upon the initialization of the object. The other constructor that is used in this example is just provided as guidance on what might be used if the view was initialized programmatically:</p><div class="informalexample"><pre class="programlisting">public MyView (RectangleF frame) : base(frame) {}</pre></div><p>Both these constructors call the <code class="literal">Initialize()</code> method that performs the initialization we need, such as creating the label that will be used and setting the background colors.</p><p>Then, the <code class="literal">TouchesMoved</code> method is overridden. This is the method that is executed when the user drags a finger on the view. Inside the method, we retrieve the <code class="literal">UITouch</code> object from the method's NSSet parameter, using the following code:</p><div class="informalexample"><pre class="programlisting">UITouch touch = (UITouch)touches.AnyObject;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>An <code class="literal">NSSet</code> object is a collection of data that are not in particular order. It is similar to an array. Its <code class="literal">AnyObject</code> parameter returns an object from the collection.</p></div></div><p>The <code class="literal">UITouch</code> object contains information about user touches. We retrieve the touch's current location from the <code class="literal">UITouch</code> object, using the following code:</p><div class="informalexample"><pre class="programlisting">PointF touchLocation = touch.LocationInView (this);</pre></div><p>The <code class="literal">UITouch</code> object's <code class="literal">LocationInView</code> method accepts a parameter of the <code class="literal">UIView</code> type, which <a id="id197" class="indexterm"/>declares in which view's coordinate system will the location be calculated. In this case, we are interested in the coordinates of <code class="literal">MyView</code>.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec94"/>There's more...</h2></div></div></div><p>If we would like to initialize the custom view we created programmatically, we would enter the following code:</p><div class="informalexample"><pre class="programlisting">MyView myView = new MyView(new RectangleF(0f, 0f, 320f, 480f));</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec95"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Adding and customizing views</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Loading a view with a view controller</em></span> recipe in <a class="link" href="ch03.html" title="Chapter 3. User Interface – View Controllers">Chapter 3</a>, <span class="emphasis"><em>User Interface – View Controllers</em></span></li></ul></div></div></div>
<div class="section" title="Styling views"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec28"/>Styling views</h1></div></div></div><p>iOS provides a set of APIs through the <span class="strong"><strong>UIAppearance</strong></span> protocol that allows us to adjust the appearance of the views once, without having to explicitly modify the styling properties on every instance of each view. This is particularly useful if, say, we want a specific view to have the same appearance throughout the app.</p><p>Apart from <a id="id198" class="indexterm"/>setting the styling properties of a view globally, we can also define the appearance of this view to be different under certain circumstances. Read on to find out how to accomplish this.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec96"/>Getting ready</h2></div></div></div><p>We will work on the existing <code class="literal">CustomViewApp</code> project we created in the preceding recipe. Open the project in Xamarin Studio.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>The downloadable code contains a separate project for this recipe. It is named <code class="literal">CustomViewApp2</code>.</p></div></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec97"/>How to do it…</h2></div></div></div><p>Perform the<a id="id199" class="indexterm"/> following steps to complete this recipe:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">CustomViewAppViewController.xib</code> file in Xcode.</li><li class="listitem">Resize the <code class="literal">MyView</code> object, which we created earlier, to make some room at the top.</li><li class="listitem">Add a <code class="literal">UILabel</code> above the <code class="literal">MyView</code> object. Make sure that the label is added on the main view and not on <code class="literal">MyView</code>.</li><li class="listitem">Connect both objects to their respective outlets.</li><li class="listitem">Back in Xamarin Studio, add the following code in the <code class="literal">ViewDidLoad</code> method of <code class="literal">CustomViewAppViewController</code>:<div class="informalexample"><pre class="programlisting">UILabel.Appearance.BackgroundColor = UIColor.Blue;
var labelStyle = UILabel.AppearanceWhenContainedIn(typeof(MyView));
labelStyle.BackgroundColor = UIColor.Green;</pre></div></li><li class="listitem">Compile and run the app on the simulator. The output should be similar to the one shown in the following screenshot:<div class="mediaobject"><img src="graphics/8924OT_02_08.jpg" alt="How to do it…"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec98"/>How it works…</h2></div></div></div><p>The <code class="literal">UIAppearance</code> class is basically a proxy to the specific properties of each control. In Xamarin.iOS, we can access each control's proxy through its static <code class="literal">Appearance</code> property. The changes <a id="id200" class="indexterm"/>we make to this object's properties will reflect on the instances of the object throughout the app. In this case, we set the <code class="literal">BackgroundColor</code> attribute of all <code class="literal">UILabel</code> instances to blue using the following code:</p><div class="informalexample"><pre class="programlisting">UILabel.Appearance.BackgroundColor = UIColor.Blue;</pre></div><p>However, we can provide different behavior for specific instances of <code class="literal">UILabel</code>. For example, we want the labels that are contained in <code class="literal">MyView</code> objects to have a green background. We accomplish this by calling the static <code class="literal">AppearanceWhenContainedIn</code> method, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var labelStyle = UILabel.AppearanceWhenContainedIn(typeof(MyView));</pre></div><p>We pass the types of objects for which we want to set the specific style. In this case, passing <code class="literal">typeof(MyView)</code> instructs the appearance proxy to make sure that we are referring to objects that are only contained in <code class="literal">MyView</code> objects. We then set the value we want to the object that was returned from this method, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">labelStyle.BackgroundColor = UIColor.Green;</pre></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec99"/>There's more…</h2></div></div></div><p>Through <a id="id201" class="indexterm"/>the <code class="literal">AppearanceWhenContainedIn</code> method, we can target a more specific set of styling. For example, consider the following line of code:</p><div class="informalexample"><pre class="programlisting">var labelStyle = UILabel.AppearanceWhenContainedIn(typeof(AnotherView), typeof(MyView));</pre></div><p>This would return a styling object that acts as a proxy for all instances of <code class="literal">UILabel</code>, which are part of <code class="literal">MyView</code>, only when <code class="literal">MyView</code> is included in <code class="literal">AnotherView</code> objects.</p><div class="section" title="Limitations of UIAppearance"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec29"/>Limitations of UIAppearance</h3></div></div></div><p>The <code class="literal">UIAppearance</code> protocol<a id="id202" class="indexterm"/> has some limitations, which are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Only specific properties can be set. For example, we cannot set the <code class="literal">Frame</code> of a view globally. Each set of properties that can be changed for a control can be accessed through its appearance proxy. If a control property is not in the appearance proxy, we cannot modify it for all instances of that particular control.</li><li class="listitem" style="list-style-type: disc">For modifying the appearance of a custom view (in this case, <code class="literal">MyView</code>), using the following line of code will yield an unwanted result:<div class="informalexample"><pre class="programlisting">MyView.Appearance.BackgroundColor = UIColor.Yellow;</pre></div></li></ul></div><p>That is, all instances of <code class="literal">UIView</code> will have a yellow background. This is because C# cannot override the static methods in derived classes. To overcome this issue, we use the <code class="literal">GetAppearance&lt;T&gt;</code> static method on the derived class instead, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">MyView.GetAppearance&lt;MyView&gt;().BackgroundColor = UIColor.Yellow;
// We can also call GetAppearance on the base class:
//UIView.GetAppearance&lt;MyView&gt;().BackgroundColor = UIColor.Yellow;</pre></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec100"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a custom view recipe</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a custom view controller</em></span> recipe in <a class="link" href="ch03.html" title="Chapter 3. User Interface – View Controllers">Chapter 3</a>, <span class="emphasis"><em>User Interface – View Controllers</em></span></li></ul></div></div></div></body></html>