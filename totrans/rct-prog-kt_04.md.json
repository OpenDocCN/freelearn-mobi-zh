["```kt\n    fun main(args: Array<String>) { \n      val observable = Observable.just(1,2,3,4,5,6,7,8,9)//(1) \n      val subject = BehaviorSubject.create<Int>() \n      subject.observeOn(Schedulers.computation())//(2) \n            .subscribe({//(3) \n                println(\"Subs 1 Received $it\") \n                runBlocking { delay(200) }//(4) \n            }) \n\n            subject.observeOn(Schedulers.computation())//(5) \n            .subscribe({//(6) \n                println(\"Subs 2 Received $it\") \n             }) \n             observable.subscribe(subject)//(7) \n            runBlocking { delay(2000) }//(8) \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      val observable = Observable.just(1,2,3,4,5,6,7,8,9)//(1) \n      observable \n         .map { MyItem(it) }//(2) \n         .observeOn(Schedulers.computation())//(3) \n         .subscribe({//(4) \n           println(\"Received $it\") \n           runBlocking { delay(200) }//(5) \n          }) \n          runBlocking { delay(2000) }//(6) \n    } \n\n    data class MyItem (val id:Int) { \n      init { \n        println(\"MyItem Created $id\")//(7) \n      } \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      Observable.range(1,1000)//(1) \n        .map { MyItem3(it) }//(2) \n        .observeOn(Schedulers.computation()) \n        .subscribe({//(3) \n          print(\"Received $it;\\t\") \n          runBlocking { delay(50) }//(4) \n         },{it.printStackTrace()}) \n         runBlocking { delay(60000) }//(5) \n     } \n     data class MyItem3 (val id:Int) { \n     init { \n       print(\"MyItem Created $id;\\t\") \n     } \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      Flowable.range(1,1000)//(1) \n        .map { MyItem4(it) }//(2) \n        .observeOn(Schedulers.io()) \n        .subscribe({//(3) \n          println(\"Received $it\") \n          runBlocking { delay(50) }//(4) \n        },{it.printStackTrace()}) \n        runBlocking { delay(60000) }//(5) \n    } \n    data class MyItem4 (val id:Int) { \n      init { \n        println(\"MyItem Created $id\") \n      }  \n   } \n```", "```kt\n    fun main(args: Array<String>) { \n      Flowable.range(1, 1000)//(1) \n        .map { MyItem5(it) }//(2) \n        .observeOn(Schedulers.io()) \n        .subscribe(object : Subscriber<MyItem5> {//(3) \n          override fun onSubscribe(subscription: Subscription) { \n            subscription.request(Long.MAX_VALUE)//(4) \n           } \n\n           override fun onNext(s: MyItem5?) { \n             runBlocking { delay(50) } \n             println(\"Subscriber received \" + s!!) \n           } \n\n           override fun onError(e: Throwable) { \n             e.printStackTrace() \n           } \n\n           override fun onComplete() { \n             println(\"Done!\") \n           } \n          }) \n          runBlocking { delay(60000) } \n       } \n\n       data class MyItem5 (val id:Int) { \n       init { \n         println(\"MyItem Created $id\") \n       } \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      Flowable.range(1, 15) \n        .map { MyItem6(it) } \n        .observeOn(Schedulers.io()) \n        .subscribe(object : Subscriber<MyItem6> { \n           lateinit var subscription: Subscription//(1) \n           override fun onSubscribe(subscription: Subscription) { \n              this.subscription = subscription \n              subscription.request(5)//(2) \n           } \n\n           override fun onNext(s: MyItem6?) { \n             runBlocking { delay(50) } \n             println(\"Subscriber received \" + s!!) \n               if(s.id == 5) {//(3) \n                  println(\"Requesting two more\") \n                  subscription.request(2)//(4) \n                } \n            } \n\n            override fun onError(e: Throwable) { \n               e.printStackTrace() \n            } \n\n            override fun onComplete() { \n               println(\"Done!\") \n            } \n           }) \n           runBlocking { delay(10000) } \n     } \n\n    data class MyItem6 (val id:Int) { \n      init { \n        println(\"MyItem Created $id\") \n      } \n     } \n```", "```kt\n    fun main(args: Array<String>) { \n      val observer: Observer<Int> = object : Observer<Int> { \n        override fun onComplete() { \n            println(\"All Completed\") \n        } \n\n        override fun onNext(item: Int) { \n            println(\"Next $item\") \n        } \n\n        override fun onError(e: Throwable) { \n            println(\"Error Occured ${e.message}\") \n        } \n\n        override fun onSubscribe(d: Disposable) { \n            println(\"New Subscription \") \n        } \n       }//Create Observer \n\n       val observable: Observable<Int> = Observable.create<Int> {//1 \n         for(i in 1..10) { \n            it.onNext(i) \n         } \n         it.onComplete() \n       } \n\n       observable.subscribe(observer) \n\n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      val subscriber: Subscriber<Int> = object : Subscriber<Int> { \n        override fun onComplete() { \n          println(\"All Completed\") \n        } \n\n        override fun onNext(item: Int) { \n          println(\"Next $item\") \n        } \n\n        override fun onError(e: Throwable) { \n          println(\"Error Occured ${e.message}\") \n        } \n\n        override fun onSubscribe(subscription: Subscription) { \n          println(\"New Subscription \") \n          subscription.request(10) \n        } \n      }//(1) \n\n      val flowable: Flowable<Int> = Flowable.create<Int> ({ \n        for(i in 1..10) { \n          it.onNext(i) \n        } \n        it.onComplete() \n      },BackpressureStrategy.BUFFER)//(2) \n\n      flowable \n        .observeOn(Schedulers.io()) \n        .subscribe(subscriber)//(3) \n\n      runBlocking { delay(10000) } \n\n    } \n```", "```kt\n    fun <T> create(source:FlowableOnSubscribe<T>, \n    mode:BackpressureStrategy):Flowable<T> { \n      //... \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      val source = Observable.range(1, 1000)//(1) \n      source.toFlowable(BackpressureStrategy.BUFFER)//(2) \n        .map { MyItem7(it) } \n        .observeOn(Schedulers.io()) \n        .subscribe{//(3) \n          print(\"Rec. $it;\\t\") \n          runBlocking { delay(1000) } \n        } \n        runBlocking { delay(100000) } \n    } \n\n    data class MyItem7 (val id:Int) { \n      init { \n        print(\"MyItem init $id\") \n      } \n   } \n```", "```kt\n    fun main(args: Array<String>) { \n      val source = Observable.range(1, 1000) \n      source.toFlowable(BackpressureStrategy.ERROR) \n        .map { MyItem8(it) } \n        .observeOn(Schedulers.io()) \n        .subscribe{ \n           println(it) \n           runBlocking { delay(600) } \n        } \n        runBlocking { delay(700000) } \n      } \n\n      data class MyItem8 (val id:Int) { \n      init { \n        println(\"MyItem Created $id\") \n      } \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      val source = Observable.range(1, 1000) \n      source.toFlowable(BackpressureStrategy.DROP) \n        .map { MyItem9(it) } \n        .observeOn(Schedulers.computation()) \n        .subscribe{ \n           println(it) \n           runBlocking { delay(1000) } \n        } \n        runBlocking { delay(700000) } \n     } \n\n     data class MyItem9 (val id:Int) { \n     init { \n        println(\"MyItem Created $id\") \n     } \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      val source = Observable.range(1, 1000) \n      source.toFlowable(BackpressureStrategy.MISSING)//(1) \n        .onBackpressureBuffer()//(2) \n        .map { MyItem11(it) } \n        .observeOn(Schedulers.io()) \n        .subscribe{ \n           println(it) \n           runBlocking { delay(1000) } \n         } \n         runBlocking { delay(600000) } \n     } \n\n     data class MyItem11 (val id:Int) { \n     init { \n        println(\"MyItem Created $id\") \n     } \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      val source = Observable.range(1, 1000) \n      source.toFlowable(BackpressureStrategy.MISSING)//(1) \n        .onBackpressureDrop{ print(\"Dropped $it;\\t\") }//(2) \n        .map { MyItem12(it) } \n        .observeOn(Schedulers.io()) \n        .subscribe{ \n           print(\"Rec. $it;\\t\") \n           runBlocking { delay(1000) } \n        } \n        runBlocking { delay(600000) } \n    } \n\n    data class MyItem12 (val id:Int) { \n    init { \n        print(\"MyItem init $id;\\t\") \n    } \n   } \n```", "```kt\n    fun main(args: Array<String>) { \n      val source = Observable.range(1, 1000) \n      source.toFlowable(BackpressureStrategy.MISSING)//(1) \n        .onBackpressureLatest()//(2) \n        .map { MyItem13(it) } \n        .observeOn(Schedulers.io()) \n        .subscribe{ \n          print(\"-> $it;\\t\") \n          runBlocking { delay(100) } \n        } \n        runBlocking { delay(600000) } \n    }  \n    data class MyItem13 (val id:Int) { \n    init { \n      print(\"init $id;\\t\") \n    } \n   } \n```", "```kt\n    fun main(args: Array<String>) { \n      val flowable = Flowable.generate<Int> { \n        it.onNext(GenerateFlowableItem.item) \n      }//(1) \n\n      flowable \n        .map { MyItemFlowable(it) } \n        .observeOn(Schedulers.io()) \n        .subscribe { \n          runBlocking { delay(100) } \n          println(\"Next $it\") \n         }//(2) \n\n         runBlocking { delay(700000) } \n     } \n\n     data class MyItemFlowable(val id:Int) { \n       init { \n        println(\"MyItemFlowable Created $id\") \n       } \n     } \n\n     object GenerateFlowableItem {//(3) \n       var item:Int = 0//(4) \n        get() { \n            field+=1 \n            return field//(5) \n        } \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      val connectableFlowable = listOf\n      (\"String 1\",\"String 2\",\"String   3\",\"String 4\",\n      \"String  5\").toFlowable()//(1) \n      .publish()//(2) \n      connectableFlowable. \n       subscribe({ \n         println(\"Subscription 1: $it\") \n         runBlocking { delay(1000) } \n         println(\"Subscription 1 delay\") \n       }) \n       connectableFlowable \n       .subscribe({ println(\"Subscription 2 $it\")}) \n       connectableFlowable.connect() \n     } \n```", "```kt\n    fun main(args: Array<String>) { \n      val flowable = listOf(\"String 1\",\"String 2\",\"String 3\",\n      \"String 4\",\"String 5\").toFlowable()//(1) \n\n      val processor = PublishProcessor.create<String>()//(2) \n\n      processor.//(3) \n         subscribe({ \n           println(\"Subscription 1: $it\") \n           runBlocking { delay(1000) } \n           println(\"Subscription 1 delay\") \n         }) \n      processor//(4) \n      .subscribe({ println(\"Subscription 2 $it\")}) \n\n      flowable.subscribe(processor)//(5) \n\n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      val flowable = Flowable.range(1,111)//(1) \n      flowable.buffer(10)//(2) \n        .subscribe { println(it) } \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      val flowable = Flowable.range(1,111) \n      flowable.buffer(10,15)//(1) \n       .subscribe { println(\"Subscription 1 $it\") } \n\n      flowable.buffer(15,7)//(2) \n       .subscribe { println(\"Subscription 2 $it\") } \n   } \n```", "```kt\n    fun main(args: Array<String>) { \n      val flowable = Flowable.interval(100, TimeUnit.MILLISECONDS)//(1) \n      flowable.buffer(1,TimeUnit.SECONDS)//(2) \n       .subscribe { println(it) } \n\n      runBlocking { delay(5, TimeUnit.SECONDS) }//(3) \n   } \n```", "```kt\n    fun main(args: Array<String>) { \n      val boundaryFlowable = Flowable.interval(350, TimeUnit.MILLISECONDS) \n\n      val flowable = Flowable.interval(100, TimeUnit.MILLISECONDS)//(1) \n      flowable.buffer(boundaryFlowable)//(2) \n       .subscribe { println(it) } \n\n      runBlocking { delay(5, TimeUnit.SECONDS) }//(3) \n\n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      val flowable = Flowable.range(1,111)//(1) \n      flowable.window(10) \n        .subscribe { \n          flo->flo.subscribe {//(2) \n            print(\"$it, \") \n          } \n          println() \n       } \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      val flowable = Flowable.interval(100, TimeUnit.MILLISECONDS)//(1) \n      flowable.throttleFirst(200,TimeUnit.MILLISECONDS)//(2) \n        .subscribe { println(it) } \n\n      runBlocking { delay(1,TimeUnit.SECONDS) } \n    } \n```"]