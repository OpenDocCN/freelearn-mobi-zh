<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Metal"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Metal</h1></div></div></div><p>Before we start creating a game, you should understand how to display things on the screen. This is always taken for granted, as all frameworks have a class called <code class="literal">sprite</code>, in which we just give a <code class="literal">.png</code> or <code class="literal">.jpg</code> file and say <code class="literal">addChild</code> and <code class="literal">tada</code>; we then have an image appearing on the screen. Moreover, with just a few simple functions such as move, scale, and rotate, we can even transform the sprite's position, size, and rotation. In reality, this <code class="literal">sprite</code> class does a whole lot of work just to display the image on the screen.</p><p>In this chapter, we will look at Metal—a new graphics library from the people at Apple. This graphics library will help us to display objects on the screen. It is a communication tool that talks to the processor, the memory, the <a id="id684" class="indexterm"/>
<span class="strong"><strong>graphics processing unit</strong></span> (<span class="strong"><strong>GPU</strong></span>), and the screen.</p><p>If you are coming from a DirectX or OpenGL background, you will see that the process to display stuff on the screen, otherwise known as a graphics pipeline, is very similar to that in Metal. Metal's graphics pipeline is programmable with the use of a shader language, which uses C++11 as the base. We will go through it in detail in this chapter. Let's get rocking with Metal!</p><p>We'll cover the following topics in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Overview</li><li class="listitem" style="list-style-type: disc">Graphics pipeline and shaders</li><li class="listitem" style="list-style-type: disc">The basic Metal project</li><li class="listitem" style="list-style-type: disc">The colored quad project</li><li class="listitem" style="list-style-type: disc">The textured quad project</li></ul></div><div class="section" title="Overview"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec83"/>Overview</h1></div></div></div><p>Metal is <a id="id685" class="indexterm"/>a graphics API that is used to display anything on the screen. Metal is very specific to iOS 8 and above; moreover, it will only work on a device with an A7 chip and above. It is said that it will run ten times faster than OpenGLES. OpenGLES<a id="id686" class="indexterm"/> is another graphics library. Unlike Metal, OpenGLES is open source and works cross-platform. The trade-off here is that you can make it ten times faster, meaning that you can add mode particles and objects in the screen, however, you can't run your games on other operating systems such as Android and Windows Phone. Games developed with OpenGLES can be run on other devices with minor changes to the code. In fact, SpriteKit and SceneKit are developed by using OpenGLES. So, do you want to make a game with more objects on the screen or would you rather make your game available on other platforms? The choice is up to you.</p><p>In Metal, for <a id="id687" class="indexterm"/>rendering anything on the screen, you have to do it in two stages. The first stage is the preparation or initialization stage, and the next one is the drawing stage. In the preparation stage, we first get access to the GPU, ready the resources such as vertices and buffers, and prepare the render pipeline and the view in which you want to the object to be rendered into. After the preparation stage, we can get into actually drawing the image in the "draw" stage.</p></div></div>
<div class="section" title="The graphics pipeline and shaders"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec84"/>The graphics pipeline and shaders</h1></div></div></div><p>Let's look at <a id="id688" class="indexterm"/>these stages in detail. We'll look at the preparation stage first.</p><div class="section" title="The preparation/initialization stage"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec81"/>The preparation/initialization stage</h2></div></div></div><p>The following <a id="id689" class="indexterm"/>steps are included in <a id="id690" class="indexterm"/>this stage:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Get device.</li><li class="listitem">Command queue.</li><li class="listitem">Resources.</li><li class="listitem">Render pipeline.</li><li class="listitem">View.</li></ol></div><p>We'll look at each step, one by one.</p><div class="section" title="Get device"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec32"/>Get device</h3></div></div></div><p>First, we have to get<a id="id691" class="indexterm"/> the device that will be responsible for rendering our object. This will let us know the capabilities of the GPU in terms on how powerful it is and what its features are. In Metal, it will basically tell us what device we are running the game on, that is, whether it is running on an iPhone, iPad, or OS X. It will also tell us which version of the device it is <a id="id692" class="indexterm"/>and whether it is an iPhone 6, 5, 4, or any other device.</p></div><div class="section" title="Command queue"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec33"/>Command queue</h3></div></div></div><p>Once we know<a id="id693" class="indexterm"/> which device we are working on, we get the next command in the queue. Information is sent from the CPU to the GPU in an asynchronous manner. This means that both the CPU and the GPU don't work on the same items at a particular time. When the CPU is done with the calculations, the information is fed to the GPU. If the GPU is busy, the information has to wait while the CPU works on the next process. For this, we need a queue. So basically, the command to the GPU waits in a queue before it can be executed. Therefore, in this step, we get the next free slot in the queue so that information can be fed from the CPU to the GPU.</p></div><div class="section" title="Resources"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec34"/>Resources</h3></div></div></div><p>In this step, we ready <a id="id694" class="indexterm"/>the vertex, which is the information that we want to pass to the GPU. We will declare the properties that each vertex has (for example, the coordinates of each vertex at a basic level). We can also provide other information, such as color for each of the coordinates. We also need to store this data in the memory so that when the command executes, the GPU will retrieve the information. Information is stored in buffers. For each property of the vertex, a buffer is created. A buffer, as we saw in the first chapter, is nothing but a location in the memory.</p><p>In the following screenshot, we see that there are four coordinates specified <span class="strong"><strong>a</strong></span>, <span class="strong"><strong>b</strong></span>, <span class="strong"><strong>c</strong></span>, and <span class="strong"><strong>d</strong></span>, each having their own vertex and color property:</p><div class="mediaobject"><img src="graphics/B04014_09_01.jpg" alt="Resources"/></div></div><div class="section" title="Render pipeline"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec35"/>Render pipeline</h3></div></div></div><p>This step is<a id="id695" class="indexterm"/> broken down into two steps. In the first step, you'll have to create a descriptor. A descriptor is where you initialize the pipeline. We will tell the pixel which format to use while rasterizing the image. We will also be passing in our vertex shaders and pixel shader function here. Once the descriptor is ready, we can pass it to the <span class="emphasis"><em>render pipeline</em></span> state. The state now contains all the information for the pipeline to be easily passed around. We will look at shaders in a later section, as it is better understood in action.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>Recap the following from <a class="link" href="ch01.html" title="Chapter 1. Getting Started">Chapter 1</a>, <span class="emphasis"><em>Getting Started</em></span>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Vertex/Geometry Shader</strong></span>: The information<a id="id696" class="indexterm"/> is then passed into the vertex shader. Vertex shaders are programmable by using shader language. The language is similar to C. Using this language, we can change the position, causing the object to move, scale, or rotate like how you can do in your <code class="literal">update</code> function within the game loop.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Pixel/Fragment Shader</strong></span>: As in the<a id="id697" class="indexterm"/> vertex shader, in which you were able to do vertex modification, pixel shaders will enable you to make pixel-based operations. As this a shader, you know that this is also programmable. Using pixel shaders, you can create effects such as changing the color and transparency of the texture provided.</li></ul></div></div></div></div><div class="section" title="View"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec36"/>View</h3></div></div></div><p>The last step is to<a id="id698" class="indexterm"/> set up and ready the view. In the view stage, we will actually need access to the layer attached to the view on which the object will be drawn. The layer is like a blank canvas that is ready to be drawn on. We get the layer of the view so that we can keep drawing and erasing on it.</p><p>We are done with the initialization stage; next, we will see the steps to actually start drawing something on the screen.</p></div></div><div class="section" title="The draw stage"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec82"/>The draw stage</h2></div></div></div><p>Here, we will finally <a id="id699" class="indexterm"/>draw the vertices that we sent in <a id="id700" class="indexterm"/>the first stage. This stage also has a few steps that need to be followed:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start render pass.</li><li class="listitem">Get command buffer.</li><li class="listitem">Draw.</li><li class="listitem">Commit the command buffer.</li></ol></div><div class="section" title="Start render pass"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec37"/>Start render pass</h3></div></div></div><p>We prepare the layer for <a id="id701" class="indexterm"/>drawing the object. We assign the layer to be drawn onto and clear the surface with the default color.</p></div><div class="section" title="Get command buffer"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec38"/>Get command buffer</h3></div></div></div><p>The Command buffer is the <a id="id702" class="indexterm"/>place where the command for rendering is stored. We need to get access to the command buffer in order to execute the commands.</p></div><div class="section" title="Draw"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec39"/>Draw</h3></div></div></div><p>Finally, the drawing takes<a id="id703" class="indexterm"/> place on the layer. This is done by a render command encoder, which takes the code from the command buffer and encodes it into machine language in order to render the image. We pass the pipeline state and the vertex buffer and then draw the image. This whole step is done off screen.</p></div><div class="section" title="Commit the command buffer"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec40"/>Commit the command buffer</h3></div></div></div><p>This is the final stage, in which<a id="id704" class="indexterm"/> image rendering has been done, and the image is ready to be displayed onto the screen. </p><p>With all of this theoretical knowledge with us now, let's put it all to practice to see how we can display something to look at on the screen.</p></div></div></div>
<div class="section" title="The basic Metal project"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec85"/>The basic Metal project</h1></div></div></div><p>In this first project, we<a id="id705" class="indexterm"/> will create a basic triangle and display it on the device.</p><p>Create a new Xcode project. Select <span class="strong"><strong>Metal</strong></span> as the technology and <span class="strong"><strong>Swift</strong></span> as the language for the project:</p><div class="mediaobject"><img src="graphics/B04014_09_02.jpg" alt="The basic Metal project"/></div><p>Select a location to save the project in. In the <code class="literal">GameViewController.swift</code> file, we delete all the contents of the <code class="literal">viewDidLoad</code> functions, so that we can start from the absolute basics.</p><p>As discussed in the overview, the first thing that we have to do is get the device that the application will work on. Add the following line:</p><div class="informalexample"><pre class="programlisting">//get device
let device: MTLDevice = MTLCreateSystemDefaultDevice()</pre></div><p>We create a new constant called <code class="literal">device</code> of the <code class="literal">MTLDevice</code> type and assign <code class="literal">MTLCreateSytemDefaultDevice</code> to it. So now, we have direct access to the device.</p><p>Next, we have to create <code class="literal">commandQueue</code> for the device:</p><div class="informalexample"><pre class="programlisting">//Create Command Queue
var commandQueue: MTLCommandQueue = device.newCommandQueue()</pre></div><p>We get the command from<a id="id706" class="indexterm"/> the device and assign it to a new variable called <code class="literal">commandQueue</code>.</p><p>In the next step, we prepare resources such as the vertex information and vertex buffers. To create vertex definitions, create an array at the top of the file called <code class="literal">vertexArray</code>, as shown in the following lines of code:</p><div class="informalexample"><pre class="programlisting">let vertexArray:[Float] = [
 
    0.0, 0.75, 

    -0.75, -0.75, 

    0.75, -0.75] </pre></div><p>Imagine the shape of a screen to be a rectangle, with its width and height being 2 pixels each and the center of the screen being the origin. So, in the preceding array, the 0th, 2nd, and 4th values are <span class="emphasis"><em>x</em></span> coordinates, and the 1st, 3rd, and 5th items are the corresponding <span class="emphasis"><em>y</em></span> coordinates.</p><p>Here, we are passing in three pairs of <code class="literal">x</code> and <code class="literal">y</code> values to draw a triangle. For the first value, <code class="literal">x</code> is at the origin and <code class="literal">y</code> is at <code class="literal">.75</code> in the <span class="emphasis"><em>y</em></span> direction from the center of the screen. The next two coordinates are to the bottom left and bottom right of the origin.</p><p>So now, we have our vertices ready. Next, we have to create a vertex buffer so that we can store these vertices in it. Create a new variable called <code class="literal">vertexBuffer</code> of type <code class="literal">MTLBuffer</code>, as shown in the following diagram, and assign the <code class="literal">vertexArray</code> variable we created along with the size of the array and <code class="literal">nil</code> for <code class="literal">options</code>.</p><div class="mediaobject"><img src="graphics/B04014_09_03.jpg" alt="The basic Metal project"/></div><div class="informalexample"><pre class="programlisting">var vertexBuffer: MTLBuffer! = device.newBufferWithBytes(vertexArray,
length: vertexArray.count * sizeofValue(vertexArray[0]),
                       options: nil)</pre></div><p>Next, we have to create our<a id="id707" class="indexterm"/> vertex and fragment shader.</p><p>Shaders are small pieces of code that are compiled at runtime. There are two types of shaders: <span class="strong"><strong>vertex</strong></span> and <span class="strong"><strong>fragment</strong></span>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Vertex shaders</strong></span>: This lets us perform <a id="id708" class="indexterm"/>vertex manipulation if we want an outside the game code. By vertex manipulation, we mean moving, rotating, and translating the each of the vertices, and therefore, the whole object. This is at the basic level; we can perform more complex operations by using vertex shaders. The vertex shader gets called as many times as the number of coordinates we pass in. So in this case, it will be called three times.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Fragment shaders</strong></span>: These<a id="id709" class="indexterm"/> can be used to perform manipulations at the pixel level. They can be used to make various effects such as blur, pixelate, cel shading, and so on. Unlike Vertex shaders, pixel or fragment shaders can be called as many times as required to fill the space within the triangle with a color or texture.</li></ul></div><p>Let's see how to write our first shader files. First, we will write a vertex shader. In the project file, you will already have a new file called <code class="literal">Shaders.metal</code>. This is the shader file for Metal, in which you will write both your vertex shader and pixel shader.</p><p>People with an OpenGL or DirectX background may be wondering where the other file is. That is one of the differences between Metal and other shader languages. Metal uses just one file, and in this file, you can write both the shaders. Each shader is not a file but a function. So later, when we pass the shader in the pipeline descriptor, we won't be giving the file name of the shader but the name of the function.</p><p>You can create more than <a id="id710" class="indexterm"/>one shader file and write your vertex shader in one file and pixel shader in the other, or vice versa. Metal really doesn't care which file you put what in, as long as you make sure that you are calling the right functions.</p><p>To create additional metal shader files, you can go to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Source</strong></span> and select <span class="strong"><strong>Metal File</strong></span>:</p><div class="mediaobject"><img src="graphics/B04014_09_04.jpg" alt="The basic Metal project"/></div><p>In the <code class="literal">Shaders.metal</code> file, remove everything and add the following code, as we will start from the basics:</p><div class="informalexample"><pre class="programlisting">#include &lt;metal_stdlib&gt;
using namespace metal;

vertex float4 myVertexShader(const device float2 * vertex_array [[ buffer(0) ]],
                             uint vid [[ vertex_id ]]) {
    
    
    return float4(vertex_array[vid],0,1);
}


fragment float4 myFragmentShader() {

    return float4(1.0, 0.0, 1.0, 1.0);
}</pre></div><p>At the top, we include<a id="id711" class="indexterm"/> the metal standard library and use namespace metal. People with C++ will feel at home as the metal shader language is written in a modified version of C++11.</p><p>The first function right after that is the vertex shader function. Shader functions start with the keyword vertex or fragment to denote whether the function is a vertex shader or a fragment shader.</p><p>So, in the vertex shader, the function has the keyword <code class="literal">vertex</code> and it returns a <code class="literal">float4</code>. A float 4 is like a struct with four float values: <code class="literal">x</code>, <code class="literal">y</code>, <code class="literal">z</code>, and <code class="literal">w</code>; or <code class="literal">r</code>, <code class="literal">g</code>, <code class="literal">b</code>, and <code class="literal">a</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>Shaders also have their own data types, such as <code class="literal">float</code>, <code class="literal">float2</code>, <code class="literal">float3</code>, and <code class="literal">float4</code> or <code class="literal">int</code>, <code class="literal">int2</code>, <code class="literal">int3</code>, and <code class="literal">int4</code>. Since shaders usually deal with vertices or colors which are a <code class="literal">float3</code> with <code class="literal">x</code>, <code class="literal">y</code>, and <code class="literal">z</code> values and <code class="literal">float4</code> with <code class="literal">r</code>, <code class="literal">g</code>, <code class="literal">b</code>, and <code class="literal">a</code> values.</p><p>You can also perform mathematical operations on these values. For example, if you have two <code class="literal">float3</code> variables called <code class="literal">vert1</code> and <code class="literal">vert2</code> and you multiply <code class="literal">vert1</code> and <code class="literal">vert2</code>, then the resultant <code class="literal">vert3</code> will be created with the <code class="literal">x</code> values multiplied to create a new <code class="literal">x</code> value. And similarly, <code class="literal">y</code> and <code class="literal">z</code> values will be multiplied with <code class="literal">vert1</code> and <code class="literal">vert2</code> to create <code class="literal">vert3</code> with the new <code class="literal">x</code>, <code class="literal">y</code>, and <code class="literal">z</code> values.</p></div></div><p>After the return type, we specify the name of the function.</p><p>The function takes in two attributes. The double rectangle bracket signifies that it is an attribute. Attributes are like properties. Here, we pass the <code class="literal">vertexArray</code> through the buffer we created. In the attribute, we pass the vertex array through the buffer at index <code class="literal">0</code>. Later, you will see that we assign our <code class="literal">vertexBuffer</code> an index value, which refers to the <code class="literal">0</code> position here, so that the shaders knows which buffer is the vertex buffer.</p><p>The next attribute that<a id="id712" class="indexterm"/> the function takes in is the vertex ID. This is generated automatically, depending upon how many vertices we pass in. We pass in three pairs of <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> coordinates, so three vertex IDs will be generated for this.</p><p>Next, in the function it returns a <code class="literal">float4</code> vertex for each of the vertex IDs. As we have to return a float 4, we add the extra <code class="literal">0</code> and <code class="literal">1</code> at the end. You might be wondering how we are returning four values when there are only returning three values: <code class="literal">vertex_array[vid]</code>,<code class="literal">0</code>, and <code class="literal">1</code>. In shader languages, you can club <code class="literal">x</code> and <code class="literal">y</code> in a single variable. Here <code class="literal">vertex_array[vid]</code> is one variable, but it actually holds two objects in it, that is, the <code class="literal">x</code> and <code class="literal">y</code> values for that coordinate.</p><p>We then create the function for the fragment shader. In a similar way to the vertex shader, we start with the shader type followed by return type and then provide the name of the function. We are not passing anything into the function yet. It does return a <code class="literal">float4</code> value. As it is a fragment shader and fragment shaders are used for making pixel manipulation, the four values here are the RGBA values of color. So here, the triangle that we will be drawing will be purple in color. If you want all four colors to be of the same value, we can perform the following operation:</p><div class="informalexample"><pre class="programlisting">return float4(0.56);</pre></div><p>This will return all RGBA values as equal to <code class="literal">0.56</code>. So the triangle will be gray in color and will be transparent as the value of alpha <code class="literal">a</code> is also at <code class="literal">0.56</code>. This way of writing values looks very odd as we don't follow this practice in regular mathematics, but with constant use, you will get used to it and, in fact, appreciate it, as it is more convenient for programming shaders.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>Fragment shaders can also be called pixel shaders as they are the same for the most part, but make sure that while creating a pixel shader function, you use the <code class="literal">fragment</code> keyword, otherwise Metal won't understand what you are talking about.</p></div></div><p>So, we are done with our shader file; let's now continue with our regular code in <code class="literal">GameViewController.swift</code> file.</p><p>We have added the shader function to our shader library. Once the shader is compiled, it is added to the <code class="literal">shader</code> library so that it can be retrieved later to save effort in compiling the shader again.</p><p>Get the library from the<a id="id713" class="indexterm"/> device and add the shader functions to it. We also create new constants for getting the vertex and shader functions from the device, which will be required to pass in the render descriptor, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">//library - collection of functions that can be retrieved by name
let defaultLibrary = device.newDefaultLibrary()
let newVertexFunction = defaultLibrary!.newFunctionWithName("myVertexShader")
let newFragmentFunction = defaultLibrary!.newFunctionWithName("myFragmentShader")</pre></div><p>Next, we create the render pipeline descriptor. First, we have to create a descriptor to assign to a state, later on. So, let's create a new pipeline descriptor, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">//Render Pipeline
let pipelineStateDescriptor = MTLRenderPipelineDescriptor()</pre></div><p>In the descriptor, we provide the vertex and shader function and the pixel format to be used, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">pipelineStateDescriptor.vertexFunction = newVertexFunction
pipelineStateDescriptor.fragmentFunction = newFragmentFunction
pipelineStateDescriptor.colorAttachments[0].pixelFormat = .BGRA8Unorm</pre></div><p>Pixel formats specify the order of the color components, bit depth per component, and data type. There are more than two dozen formats. To know more about the different types of <a id="id714" class="indexterm"/>pixel formats, you can visit Apple's documentation at <a class="ulink" href="https://developer.apple.com/library/ios/documentation/Metal/Reference/MetalConstants_Ref/#//apple_ref/c/tdef/MTLPixelFormat">https://developer.apple.com/library/ios/documentation/Metal/Reference/MetalConstants_Ref/#//apple_ref/c/tdef/MTLPixelFormat</a>.</p><p>We then create a <code class="literal">RenderPipeline</code> state from the descriptor, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">//Render pipeline state from descriptor
var pipelineState: MTLRenderPipelineState!
pipelineState = device.newRenderPipelineStateWithDescriptor(
pipelineStateDescriptor,
error: nil)</pre></div><p>A new variable, <code class="literal">pipelineState</code>, of the <code class="literal">MTLRenderPipeLineState</code> type is created, and the <code class="literal">pipeLibeStateDescriptor</code> constant is passed to it.</p><p>Next, we create a layer <a id="id715" class="indexterm"/>of type <code class="literal">CAMetalLayer</code> and add it to the current view, so that we can draw the object on it. So, add the following code to prepare the view and add the layer to it:</p><div class="informalexample"><pre class="programlisting">//prepare view with layer
let  metalLayer = CAMetalLayer()
metalLayer.device = device //set the device
metalLayer.pixelFormat = .BGRA8Unorm 
metalLayer.frame = view.layer.frame 
view.layer.addSublayer(metalLayer) </pre></div><p>To the <code class="literal">metalLayer</code> constant, we assign the device, pixel format of layer (the same as what we assigned in the pipeline descriptor), and the frame size, which is equal to the size of the frame of the view (frame size is the same as the screen size). Finally, add <code class="literal">metalLayer</code> as a sublayer to the current view layer.</p><p>This is all that is required for setting up everything. We can move on to the next stage, that is, actually drawing the triangle.</p><p>In the next step, we create a render pass descriptor. Before we can create it, however, we need to get a reference to the next drawable texture from the layer as it will be required to pass it to the render descriptor:</p><div class="informalexample"><pre class="programlisting">//get next drawable texture
var drawable = metalLayer.nextDrawable() </pre></div><p>Next, we create the render descriptor:</p><div class="informalexample"><pre class="programlisting">//create a render descriptor
let renderPassDescriptor = MTLRenderPassDescriptor()

renderPassDescriptor.colorAttachments[0].texture = drawable.texture //assign drawable texture

renderPassDescriptor.colorAttachments[0].loadAction = .Clear //clear with color on load

renderPassDescriptor.colorAttachments[0].clearColor = MTLClearColor(red: 1.0,
            green: 1.0,
            blue: 0.0,
            alpha: 1.0) // specify color to clear it with</pre></div><p>Now, we create a new constant called <code class="literal">renderPassDescriptor</code>, of type <code class="literal">MTLRenderPassDescriptor</code>. First, we assign the texture of the drawable layer so that whatever it renders gets drawn in the texture. So, the texture of the drawable layer is passed in.</p><p>Next, the load action is called. Once loaded, the layer is first cleared with a color. Then, we pass a color with which the layer will be cleared. Here, we pass a purple color.</p><p>With that, our descriptor is <a id="id716" class="indexterm"/>ready. Next, we have to render the layer and the triangle. So first, we get the command buffer from the command queue. These are the commands that are stored in the memory:</p><div class="informalexample"><pre class="programlisting">//Command Buffer - get next available command buffer
let commandBuffer = commandQueue.commandBuffer()</pre></div><p>All these commands need to be encoded in the machine language through <code class="literal">MTLRenderCommandEncoder</code>. We pass the <code class="literal">renderPassDescriptor</code> variable here to encode the render code:</p><div class="informalexample"><pre class="programlisting">//create Encoder - converts code to machine language
let renderEncoder:MTLRenderCommandEncoder = commandBuffer.renderCommandEncoderWithDescriptor(renderPassDescriptor)!</pre></div><p>Next, we have to set the pipeline and vertex buffer state in the encoder. While passing in <code class="literal">vertexBuffer</code>, we have to pass in the offset and index buffer values. As we created a new buffer, the offset value is <code class="literal">0</code> and for index, we pass <code class="literal">0</code>. This index value is what the vertex shader referred and passed in <code class="literal">[[buffer(0)]]</code> to the value:</p><div class="informalexample"><pre class="programlisting">//provide pipelineState and vertexBuffer
renderEncoder.setRenderPipelineState(pipelineState)
renderEncoder.setVertexBuffer(vertexBuffer, offset: 0, atIndex: 0)</pre></div><p>Finally, we can draw the triangle by creating a primitive type. Eventually, all shapes are made of triangles, as we saw in the example of the ship in the first chapter. The number of vertices and their positions define the shape of the object. Here, we are creating a single triangle shape, so we are passing three vertices to create a triangle. This same triangle primitive is used to make squares, cubes, teapots, spheres, and so on:</p><div class="informalexample"><pre class="programlisting">//drawing begin
renderEncoder.drawPrimitives(.Triangle, vertexStart: 0, vertexCount: 3, instanceCount: 1) //drawin</pre></div><p>We have finally drawn, so we can end the encoding:</p><div class="informalexample"><pre class="programlisting">//End drawing
renderEncoder.endEncoding() </pre></div><p>Although we have drawn the triangle, we still need to present it on the screen. In the next step, we will provide the texture and commit it to the view:</p><div class="informalexample"><pre class="programlisting">//commit to view
commandBuffer.presentDrawable(drawable)
commandBuffer.commit()</pre></div><p>That is all. Finally, you<a id="id717" class="indexterm"/> will be able to see the purple triangle with the yellow background on the screen, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B04014_09_05.jpg" alt="The basic Metal project"/></div><p>Congrats! You've successfully completed it.</p><p>All of this is just for drawing the triangle, but I hope you are now able to appreciate the effort. The problem is that if you do any of the steps incorrectly, the chances are that the triangle won't get displayed.</p><p>The code is also kept very basic. We can definitely optimize the code by adding a renderer class and creating the vertex array as a separate class.</p><p>In the next example, we will <a id="id718" class="indexterm"/>create a square. This time, we will pass colors for each of the coordinates instead of typing the color value in the fragment shader function.</p></div>
<div class="section" title="The colored quad project"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec86"/>The colored quad project</h1></div></div></div><p>To create a<a id="id719" class="indexterm"/> colored square, we need to make some changes to <code class="literal">vertexArray</code>, as we will need to pass six vertices instead of three. We have to pass six vertices because, as you saw earlier, we can draw only in triangles. So, we need three points for the triangle to form the top part of the square and three more points to form its bottom part:</p><div class="informalexample"><pre class="programlisting">let vertexArray:[Float] = [

    -1.0, 1.0, 0, 1,  //a
    -1.0, -1.0, 0, 1, //b
    1.0, -1.0, 0, 1,  //c    
    -1.0, 1.0, 0, 1,  //a
    1.0, -1.0, 0, 1,  //c
    1.0, 1.0, 0, 1,   //d
]</pre></div><p>You will see that the <code class="literal">a</code> and <code class="literal">c</code> points are repeated to form the second triangle, because the diagonal of the square are the same points for the first triangle.</p><div class="mediaobject"><img src="graphics/B04014_09_06.jpg" alt="The colored quad project"/></div><p>Notice that in the <a id="id720" class="indexterm"/>vertex array, we are now passing four values per vertex instead of two, as we did in the case of the triangle. This will simplify matters while modifying the shader function.</p><p>The values of the coordinates provided are the <code class="literal">x</code>, <code class="literal">y</code>, and <code class="literal">z</code> values, and an additional fourth parameter <code class="literal">w</code> is also passed in. Like the <code class="literal">z</code> value in two-dimensional space, it doesn't have much significance yet. Later, when you create a three-dimensional object, the <code class="literal">w</code> parameter plays a major role. But, as of now, let the value remain <code class="literal">1</code>.</p><p>Additionally, as we saw while creating the triangle, the view is a 2 x 2 rectangle with the origin in the center. As we are passing in coordinates between <code class="literal">1</code> and <code class="literal">-1</code> in the <span class="emphasis"><em>x</em></span>-<span class="emphasis"><em>y</em></span> direction, the rectangle will actually cover the whole screen. If you still want to see the yellow background, change the value <code class="literal">1</code> to a smaller value, as we did in the case of the triangle. Do not change the values corresponding to <code class="literal">0</code>.</p><p>Similar to passing vertices, we will also pass color values for each of these coordinates as a buffer in the code to create a new array called <code class="literal">colorArray</code>, as shown in the following lines:</p><div class="informalexample"><pre class="programlisting">let colorArray:[Float] = [
    
    1, 0, 0, 1, //a
    0, 1, 0, 1, //b
    0, 0, 1, 1, //c
    
    1, 0, 0, 1, //a
    0, 0, 1, 1, //c
    1, 0, 1, 1, //d
]</pre></div><p>These are simple <a id="id721" class="indexterm"/>RGBA values for the respective coordinates. Here, a means that <span class="emphasis"><em>red</em></span> = <code class="literal">1</code>, <span class="emphasis"><em>green</em></span> = <code class="literal">0</code>, <span class="emphasis"><em>blue</em></span> = <code class="literal">0</code>, and <span class="emphasis"><em>alpha</em></span> = <code class="literal">1</code>. The values of each of these lie between <code class="literal">0</code> and <code class="literal">1</code>. So here, <code class="literal">a</code> will be all red in color. We can create custom colors by keeping red as <code class="literal">1</code> and adding more green or blue to the mix, as in the case of <code class="literal">c</code> and <code class="literal">d</code>.</p><p>Next, in a similar way to how we created a <code class="literal">vertexBuffer</code>, we have to create a <code class="literal">colorBuffer</code> of type <code class="literal">MTLBuffer</code>:</p><div class="informalexample"><pre class="programlisting">let colorBuffer = device.newBufferWithBytes(colorArray,
                length: colorArray.count * sizeofValue(colorArray[0]), //sizeof(colorArray)
                options: nil)</pre></div><p>We pass in the <code class="literal">colorArray</code> that we created and the size of the whole array.</p><p>We don't have to make any changes to the device, layer, or the render pipeline in the code. But we do need to change the vertex and shader functions, as we are going to be passing information on the color.</p><p>In any shader language, we can also create our own data types. A new data type called <code class="literal">VertexInOut</code> is created by using a struct in the shader file. So type the following code in the <code class="literal">Shader.metal</code> file:</p><div class="informalexample"><pre class="programlisting">struct VertexInOut{
    float4  position [[position]];
    float4  color;
};</pre></div><p>We create a struct with two <code class="literal">float4</code> values, of which one is for position and the other is for the color. The position with double square brackets is used to indicate that we will be passing and retrieving the position attribute through the position property.</p><p>The <code class="literal">vertex</code> function is changed, as shown in the following lines of code:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>A packed variable means that you cannot access each of the components individually, unlike a regular <code class="literal">float4</code>. For example, in a regular <code class="literal">float4</code> that has position data, we can access the <code class="literal">x</code>, <code class="literal">y</code>, <code class="literal">z</code>, and <code class="literal">w</code> values, but in a packed <code class="literal">float</code>, we cannot do that.</p></div></div><div class="informalexample"><pre class="programlisting">vertex VertexInOut vertexShader(uint vid [[ vertex_id ]],
                constant packed_float4* position  [[ buffer(0) ]],
                constant packed_float4* color    [[ buffer(1) ]]){

    VertexInOut outVertex;
    
    outVertex.position = position[vid];
    outVertex.color    = color[vid];
    
    return outVertex;
};</pre></div><p>Here, we first tell <a id="id722" class="indexterm"/>the <code class="literal">vertex</code> function type with the <code class="literal">vertex</code> keyword; we return a type called <code class="literal">VertexInOut</code> that we created earlier and provide the name of the function name. We provide the vertex ID, the position buffer with index <code class="literal">0</code>, and the color buffer with index <code class="literal">1</code> to the function.</p><p>In the function, we create a new variable called <code class="literal">outVertex</code> of type <code class="literal">VertexInOut</code>, assign the position and color values for each of the vertex IDs, and then return the <code class="literal">outVertex</code> variable.</p><p>We also need to make changes to the fragment shader function, as the color that is passed in through the buffer needs to be applied to the cube:</p><div class="informalexample"><pre class="programlisting">fragment half4 fragmentShader(VertexInOut inFrag [[stage_in]]){
    
    return half4(inFrag.color);
}; </pre></div><p>In the fragment shader, we use a <code class="literal">fragment</code> keyword to specify that it is a fragment shader, to return a <code class="literal">half4</code> (which is like a <code class="literal">float4</code> but consumes less memory), and to provide a name for the <code class="literal">shader</code> function. The function takes in the <code class="literal">VertexInOut</code> variable. The <code class="literal">[[stage_in]]</code> part is used to signify that the operation will have to be done on a per pixel basis. In the function, we ask it to return the typecast color value.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>More information about <code class="literal">stage_in</code> can be<a id="id723" class="indexterm"/> found at <a class="ulink" href="https://developer.apple.com/library/ios/documentation/Metal/Reference/MetalShadingLanguageGuide/func-var-qual/func-var-qual.html#//apple_ref/doc/uid/TP40014364-CH4-SW13">https://developer.apple.com/library/ios/documentation/Metal/Reference/MetalShadingLanguageGuide/func-var-qual/func-var-qual.html#//apple_ref/doc/uid/TP40014364-CH4-SW13</a>.</p></div></div><p>As we added a new<a id="id724" class="indexterm"/> color buffer and increased the number of vertices, we have to make changes to the <code class="literal">renderEncoder</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">//draw - prep drawing

renderEncoder.setRenderPipelineState(pipelineState)

renderEncoder.setVertexBuffer(vertexBuffer, offset: 0, atIndex: 0)

<span class="strong"><strong>renderEncoder.setVertexBuffer(colorBuffer, offset: 0, atIndex: 1)</strong></span>

<span class="strong"><strong>renderEncoder.drawPrimitives(.Triangle, vertexStart: 0, vertexCount: 6, instanceCount: 1)</strong></span>

renderEncoder.endEncoding()</pre></div><p>We set a new vertex buffer and pass the color buffer and the index value of <code class="literal">1</code>. In <code class="literal">drawPrimitives</code>, we are still creating a primitive of type triangle, but this time it's with six vertices.</p><p>Finally, as we have changed the shader functions, we need to update the names in the pipeline, as highlighted in the following code:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>pipelineStateDescriptor.vertexFunction = defaultLibrary!.newFunctionWithName("vertexShader")</strong></span>

<span class="strong"><strong>pipelineStateDescriptor.fragmentFunction = defaultLibrary!.newFunctionWithName("fragmentShader")</strong></span>

pipelineStateDescriptor.colorAttachments[0].pixelFormat = .BGRA8Unorm</pre></div><p>Now that it is all built, we can see the colored square, or quad, as it is generally known:</p><div class="mediaobject"><img src="graphics/B04014_09_07.jpg" alt="The colored quad project"/></div><p>You might be wondering that when you passed in four colors for only the four vertices, how come the whole screen is colored and the colors are also merging.</p><p>The vertex shader<a id="id725" class="indexterm"/> function gets called depending upon the number of vertices passed in. So the vertex shader function got called six times. On the other hand, the fragment shader function is actually called as many times as is required to fill the area generated by each triangle primitive. The colors are interpolated between the points, depending upon the distance from a coordinate. For this example, the bottom left coordinate was passed the color value of green. As it moves away from the bottom-left corner, the color slowly merges with other colors, thus reducing the value of green. So at the center, we have a mix of all the colors. This is a general feature of any fragment shader.</p></div>
<div class="section" title="The texture quad project"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec87"/>The texture quad project</h1></div></div></div><p>For the next project, we will create a <a id="id726" class="indexterm"/>textured quad object. This is the basic building block of a sprite class. Here, we will be taking an image and pasting it on top of the quad or square that we created in the earlier project.</p><p>The reason why I said that it is a basic building block for a sprite class is that we won't be able to move, rotate, or scale the sprite; we will just be displaying the sprite on the screen.</p><p>Going back to referring to the process of adding a sprite to any quad in a similar way to adding wallpaper to wall, we can add the wallpaper right-side up or upside down on the wall. Similarly, while adding images to quads, we have to specify which way is up, otherwise the sprite will be pasted upside down or sideways on the quad.</p><p>For this, we have to pass in one more array of coordinates, which are called texture coordinates. The texture coordinates are different than vertex coordinates such that the vertex coordinates are with reference to the screen coordinates system, with the center of the screen being the origin. Refer to the image provided.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>We are working in 2D, so we can call it the screen coordinates system, which is the same as the world coordinate system for convenience for now, but in 3D it is actually the world coordinate system. </p></div></div><p>The texture coordinate system is with respect to each quad or rectangle. Moreover, the top left of the quad is the origin for the texture coordinate system. So, for moving the quad around the screen, you will change the values in the vertex array. The texture coordinates will be changed to actually move the image around within the quad.</p><p>So, with all that theory out of the way, let's create a new array called <code class="literal">textureCoordsArray</code>, as shown here. But before that, change <code class="literal">vertexArray</code> and reduce the size of the quad that we created earlier, so that we can have a better understanding of what is happening with the texture coordinate:</p><div class="informalexample"><pre class="programlisting">let vertexArray:[Float] = [

    -0.75, 0.75, 0, 1,  //a

    -0.75, -0.75, 0, 1, //b

    0.75, -0.75, 0, 1,  //c

    
    -0.75, 0.75, 0, 1,  //a

    0.75, -0.75, 0, 1,  //c

    0.75, 0.75, 0, 1,   //d
]</pre></div><p>Next, add the texture coordinate array:</p><div class="informalexample"><pre class="programlisting">let textureCoordsArray:[Float] = [

    0.0, 0.0, //a

    0.0, 1.0, //b

    1.0, 1.0, //c

    
    0.0, 0.0, //a

    1.0, 1.0, //c

    1.0, 0.0  //d
]</pre></div><p>While creating a textured<a id="id727" class="indexterm"/> quad, there are two things that we need to pay close attention to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">vertex</code> array provided for each triangle set needs to be in the anti-clockwise direction. So, for the first three position vertices in the vertex array, the order needs to be <code class="literal">abc</code> and <code class="literal">acd</code> respectively for both triangles, otherwise the texture will not be displayed properly.</li><li class="listitem" style="list-style-type: disc">The order of the <code class="literal">vertex</code> array and texture coordinate needs to be the same; if the vertex array order is <code class="literal">abc</code> and <code class="literal">acd</code>, then the texture coordinate order needs to be specified in the same order.</li></ul></div><div class="mediaobject"><img src="graphics/B04014_09_08.jpg" alt="The texture quad project"/></div><p>In the preceding image, the <a id="id728" class="indexterm"/>red letters <span class="strong"><strong>a</strong></span>, <span class="strong"><strong>b</strong></span>, <span class="strong"><strong>c</strong></span>, and <span class="strong"><strong>d</strong></span> denote the vertex coordinates, and the green coordinates denote the texture coordinates. The red origin is the origin of the vertex coordinate, and the green origin is the origin of the texture coordinate.</p><p>With the texture coordinates ready, we have to create a texture buffer of the type <code class="literal">MTLBuffer</code> and pass in the texture coordinate array into it, along with the size of the array. This is similar to how we created buffers earlier for the respective arrays:</p><div class="informalexample"><pre class="programlisting">//initialize textureCoordBuffer
let textureCoordBuffer: MTLBuffer = device.newBufferWithBytes(textureCoordsArray,
length: textureCoordsArray.count * sizeofValue(textureCoordsArray[0]),
options: nil)</pre></div><p>Next, we have to load the texture that we want to paste onto the quad. For this, we import the <code class="literal">Bg2.png</code> files that we used in the SpriteKit project. Add the following lines of code at the end of the initialization stage.</p><p>First, we get the file from the local bundle location. We get the path to the file by passing the name of the file along with the extension. The data has to be then retrieved using the <code class="literal">NSData</code> method, in which we pass the path, as shown here:</p><div class="informalexample"><pre class="programlisting">        //get texture
        let path =  NSBundle.mainBundle().URLForResource("Bg2", withExtension: "png")
        let data = NSData(contentsOfURL: path!)</pre></div><p>Next, we get the image from the data and store it in a constant of type <code class="literal">UIImage</code>:</p><div class="informalexample"><pre class="programlisting">        let image = UIImage(data: data!)</pre></div><p>Then, we get the width and height and specify the color space for the image. A color space decides how the colors are to be interpreted. There are other ways in which colors can be stored, apart from the RGBA values; for example, we can provide colors in the CMYK format. As the color values in the image are specified in RGB, we have to specify it here.</p><p>The width and height are obtained using the <code class="literal">CGImage</code> class, so we convert the image from the <code class="literal">UIImage</code> type to the <code class="literal">CGImage</code> type in this step:</p><div class="informalexample"><pre class="programlisting">        let width = CGImageGetWidth(image?.CGImage)
        let height = CGImageGetHeight(image?.CGImage)
        let colorSpace = CGColorSpaceCreateDeviceRGB();</pre></div><p>To store each pixel <a id="id729" class="indexterm"/>of the image, we need to specify the size of the data of the whole image, so memory is created for the data to be written into. Each pixel takes up 4 bytes of memory space. So to get the memory occupied by the whole image, we have multiply the width with the height and then multiply these values by four, which will give the data value for the bitmap image. This value is stored in a <code class="literal">bitmapData</code> constant as shown here:</p><div class="informalexample"><pre class="programlisting">        let bitmapData = calloc(height * width * 4, UInt(sizeof(UInt8)))</pre></div><p>As mentioned earlier, we assign the number of bytes per pixel in a constant called <code class="literal">bytesPerPixel</code>. Also, we create a <code class="literal">bytesPerRow</code> constant to get the number of bytes per row:</p><div class="informalexample"><pre class="programlisting">        let bytesPerPixel: UInt = 4
        let bytesPerRow: UInt = bytesPerPixel * width</pre></div><p>We also need to specify how many bits does each component in a pixel take. A pixel is made up of <code class="literal">R</code>, <code class="literal">G</code>, <code class="literal">B</code>, and <code class="literal">A</code> values. For storing each value, we require 8 bits each. So for storing each RGBA value, we need 32 bits in total. As we'll be requiring the value of bits per pixel component later on, we store the value in a constant called <code class="literal">bitsPerComponent</code> here:</p><div class="informalexample"><pre class="programlisting">        let bitsPerComponent: UInt = 8</pre></div><p>Next, we create <a id="id730" class="indexterm"/>a context that creates the environment by storing all the required data of the image. To the context we have to provide <code class="literal">bitmapData</code>, width and height of the image, bits per component, bytes per row, and <code class="literal">colorSpace</code> and <code class="literal">bitmapInfo</code> at the end.</p><p>In the bitmap information, we specify if there is an alpha channel in the image, the location of the alpha channel, and if the values are integers or float values:</p><div class="informalexample"><pre class="programlisting">        let context = CGBitmapContextCreate(bitmapData,
            width,
            height,
            bitsPerComponent,
            bytesPerRow,
            colorSpace,
            CGBitmapInfo(CGImageAlphaInfo.PremultipliedLast.rawValue))</pre></div><p>Next, we get the rectangular size of the image. We create a <code class="literal">rect</code> variable of type <code class="literal">CGRect</code> and pass in the origin and the width and height of the image, as shown in the following lines of code:</p><div class="informalexample"><pre class="programlisting">        let rect = CGRectMake(0.0,
    0.0,
                                CGFloat(width),
                                CGFloat(height));</pre></div><p>Next, we get the image and store the RGBA data into <code class="literal">bitmapData</code> through the context. We first clear the context and then pass in the context, the rectangle, and the image:</p><div class="informalexample"><pre class="programlisting">        CGContextClearRect(context, rect);
        CGContextDrawImage(context, rect, image?.CGImage);</pre></div><p>For loading the texture into Metal, we need a texture descriptor, which stores all the relevant information. We create a new constant called <code class="literal">textureDescriptor</code> and a texture descriptor with the pixel format of RGBA8 uniform normal and pass in the width, height, and the data if we want the image to be <a id="id731" class="indexterm"/>
<span class="strong"><strong>mipmapped</strong></span>.</p><p>Mipmap, as we saw in SceneKit, will create a lower resolution of the image and display it if the camera is far away from the texture to reduce the workload on the system, as shown here:</p><div class="informalexample"><pre class="programlisting">        let textureDescriptor  = MTLTextureDescriptor.texture2DDescriptorWithPixelFormat(.RGBA8Unorm,
            width: Int(width),
            height: Int(height),
            mipmapped: false)</pre></div><p>We create a texture of type <code class="literal">MTLTexture</code> and pass in the texture descriptor:</p><div class="informalexample"><pre class="programlisting">        let texture: MTLTexture = device.newTextureWithDescriptor(textureDescriptor)</pre></div><p>Finally, we use the<a id="id732" class="indexterm"/> replace region function of type <code class="literal">MTLTexture</code> to replace the pixels with the image data that is stored in <code class="literal">bitmapData</code>. We pass in the region that is basically a rect and then we specify <code class="literal">mipmapLevel</code>, which is kept at <code class="literal">0</code> and sliced to determine which surface of the quad we will paste the image onto, as we just have one quad we specified as <code class="literal">0</code>. If we had more quads, such as a cube, we would have to specify values other than <code class="literal">0</code> for other faces. Next, we pass the <code class="literal">bitmapData</code>, which has the RGBA of the image stored in it; next, we pass in the <code class="literal">bytesPerRow</code> and <code class="literal">bytesPerImage</code> values in, as shown in the following lines of code:</p><div class="informalexample"><pre class="programlisting">        let region = MTLRegionMake2D(0, 0, Int(width), Int(height))
        
        texture.replaceRegion(region,
            mipmapLevel: 0,
            slice: 0,
            withBytes: bitmapData,
            bytesPerRow: Int(bytesPerRow),
            bytesPerImage: Int(bytesPerRow * height))</pre></div><p>As we are passing in a texture coordinate buffer and we need a texture to be drawn, we have to make some changes to the shader file. So, go to the shader file.</p><p>First, change the <code class="literal">VertexInOut</code> struct, as shown here:</p><div class="informalexample"><pre class="programlisting">struct VertexInOut
{
    float4  position [[position]];
    float4  color;
    <span class="strong"><strong>float2 m_TexCoord [[user(texturecoord)]];</strong></span>
};</pre></div><p>In the highlighted code, the user keyword is used in shaders while specifying attributes that are user-defined:</p><div class="informalexample"><pre class="programlisting">vertex VertexInOut vertexShader(uint vid [[ vertex_id ]],
                       constant float4* position  [[ buffer(0) ]],
                 constant packed_float4* color    [[ buffer(1) ]], 
         <span class="strong"><strong>constant packed_float2* pTexCoords  [[ buffer(2) ]])</strong></span>

{
    VertexInOut outVertex;
    
    outVertex.position =  position[vid];
    outVertex.color    =  color[vid];
    <span class="strong"><strong>outVertex.m_TexCoord = pTexCoords[vid];</strong></span>
    
    return outVertex;
};</pre></div><p>As the <code class="literal">textureCoordinate</code> buffer needs to be passed in, along with the position and color information, we pass it with the buffer index <code class="literal">2</code>. Also, while returning <code class="literal">outVertex</code>, we will assign the texture coordinate for that vertex ID in the function.</p><p>Next, we also need to<a id="id733" class="indexterm"/> make changes to the <code class="literal">fragment</code> shader function, as we will be passing the texture into the fragment shader. So draw it on the quad, as shown in the following lines of code:</p><div class="informalexample"><pre class="programlisting">fragment half4 texturedQuadFragmentShader(
  VertexInOut inFrag [[ stage_in ]],
                      texture2d&lt;half&gt;  tex2D     [[ texture(0) ]])
{
    constexpr sampler quad_sampler;
    
    half4 color = tex2D.sample(quad_sampler, inFrag.m_TexCoord);
    
    return color;
} </pre></div><p>Along with the <code class="literal">stage_in</code> parameter, which we passed last time, we are also going to be passing the texture into the fragment shader with an index value of <code class="literal">0</code>.</p><p>In the function to actually pick the color, a sampler is used. The sampler will decide how to pick the color from the texture that is passed in. The sampler is set as a <code class="literal">constexpr</code>, or a constant expression that is similar to a <code class="literal">const</code> type.</p><p>The sampler picks the colors, depending on the texture coordinates from the texture 2D that were provided using the <code class="literal">text2D.sample</code> function. The resultant color is stored and returned by the fragment shader.</p><p>Next, in <code class="literal">renderEncoder</code>, add the following highlighted lines:</p><div class="informalexample"><pre class="programlisting">renderEncoder.setVertexBuffer(colorBuffer, offset: 0, atIndex: 1) 
        
<span class="strong"><strong>renderEncoder.setVertexBuffer(textureCoordBuffer, offset: 0, atIndex: 2)</strong></span>
<span class="strong"><strong>renderEncoder.setFragmentTexture(texture, atIndex: 0)</strong></span>
         renderEncoder.drawPrimitives(.Triangle, vertexStart: 0, vertexCount: 6, instanceCount: 1)</pre></div><p>Notice that although<a id="id734" class="indexterm"/> <code class="literal">vertexBuffer</code> and texture have the same index, they are treated differently, as <code class="literal">vertexBuffer</code> is one type of buffer that is separate from a texture. As the <code class="literal">textureCoordinate</code> buffer is a type buffer, we have to pass in an index value of <code class="literal">2</code> as we are already passing <code class="literal">0</code> and <code class="literal">1</code> for the vertex and the color buffer respectively.</p><p>Finally, make changes to the pipeline descriptor to use the newly created fragment shader, as shown here:</p><div class="informalexample"><pre class="programlisting">pipelineStateDescriptor.vertexFunction = defaultLibrary!.newFunctionWithName("vertexShader")

<span class="strong"><strong>pipelineStateDescriptor.fragmentFunction = defaultLibrary!.newFunctionWithName("texturedQuadFragmentShader")</strong></span>

pipelineStateDescriptor.colorAttachments[0].pixelFormat = .BGRA8Unorm</pre></div><p>And finally, there is one more thing to do, which is to build it and run!</p><div class="mediaobject"><img src="graphics/B04014_09_09.jpg" alt="The texture quad project"/></div><p>With this, we have gone full circle in this book. The first thing that you learned in 2D SpriteKit game development was how to add an image to the scene. We typed in three lines of code and the image appeared on the screen.</p><p>In reality, we have to do all this to get a simple image onto the screen. But, as I said earlier, this is just the beginning; we still haven't seen how to move, rotate, or scale the quad.</p><p>We haven't yet looked <a id="id735" class="indexterm"/>at the depth buffer, which decides whether a portion of the image needs to be drawn on screen or not, depending on any other object that is in front of the current object.</p><p>Also, we have only looked at 2D. We haven't yet created a cube, for which additional vertices will be required. Deeper knowledge of algebra, trigonometry, and matrices will be required. Additional understanding of projections and model space, world space, view space, and screen space will be required, all of which are integral parts of graphics programming.</p><p>It's needless to say that these topics are way beyond the scope of this book. In fact, a whole book could be dedicated to graphics programming using Metal, while another book could be dedicated to using Metal Shader language to create cool effects.</p><p>For learning Metal, I recommend learning OpenGLES first as it has been there for so many years. Once you have a good understanding of that, you can put the knowledge into experimentation with <a id="id736" class="indexterm"/>Metal.</p><p>For learning OpenGLES, I recommend <span class="emphasis"><em>Building Android Games with OpenGLES</em></span>. Although it teaches development for Android as OpenGLES is cross-platform, you can use the same concepts for iOS game development. The link to the video can be found at <a class="ulink" href="https://www.packtpub.com/game-development/building-android-games-opengl-es-video">https://www.packtpub.com/game-development/building-android-games-opengl-es-video</a>.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec88"/>Summary</h1></div></div></div><p>In this chapter, you saw how to create a simple triangle, quad, and a texture quad, and how to display these to the screen. You scratched the surface of graphics programming and learned the meaning of terms such as vertices, buffers, textures, and shaders.</p><p>This is merely the start of the learning process; there is still a lot to learn as graphics programming is a vast and deep subject, with courses specifically designed for it.</p><p>I hope this chapter has generated some interest for the subject in you; if nothing more, I think you will at least have some appreciation for the people who sit for hours and develop frameworks and engines for you so that you can make the game of your dreams, without having any knowledge of the subject.</p><p>Talking about dreams, in the next chapter, you'll see how to finally publish a game on the iOS App Store.</p></div></body></html>