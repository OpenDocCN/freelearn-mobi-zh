<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer051">
			<h1 id="_idParaDest-35" class="chapter-number"><a id="_idTextAnchor041"/>3</h1>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor042"/>Jetpack Compose Layout Basics</h1>
			<p>A good UI and user experience are core to our apps. As Android developers, we must be keenly aware of these two areas and learn how to use the different tools provided for us to create UIs. Google introduced <strong class="bold">Jetpack Compose</strong>, a modern UI toolkit to help<a id="_idIndexMarker075"/><a id="_idIndexMarker076"/> developers create intuitive UIs <span class="No-Break">with ease.</span></p>
			<p>In this chapter, we’ll look at Jetpack Compose, a declarative way of creating UIs for our apps. We will learn the basics of Jetpack Compose and layouts in <span class="No-Break">Jetpack Compose.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Introduction to <span class="No-Break">Jetpack Compose</span></li>
				<li>Jetpack <span class="No-Break">Compose layouts</span></li>
			</ul>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor043"/>Technical requirements</h1>
			<p>To follow the instructions in this chapter, you will need to have Android Studio Hedgehog or later (<a href="https://developer.android.com/studio"><span class="No-Break">https://developer.android.com/studio</span></a><span class="No-Break">) downloaded.</span></p>
			<p>You can find the code for this chapter <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterthree"><span class="No-Break">https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterthree</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor044"/>Introduction to Jetpack Compose</h1>
			<p>Over the years, Android UI development <a id="_idIndexMarker077"/><a id="_idIndexMarker078"/>has undergone significant transformations with various frameworks and libraries emerging to simplify <span class="No-Break">the process.</span></p>
			<p>Before Jetpack Compose, this is <a id="_idIndexMarker079"/><a id="_idIndexMarker080"/>how we used to write UIs for <span class="No-Break">our apps:</span></p>
			<ul>
				<li>Views were inflated from XML layout files. XML-based views are still supported alongside Jetpack Compose for backward compatibility and mixed use cases where apps have both XML layouts and <span class="No-Break">Jetpack Compose.</span></li>
				<li>Themes, styles, and value resources were also defined in <span class="No-Break">XML files.</span></li>
				<li>For us to be able to access the views from XML files, we used view binding or <span class="No-Break">data binding.</span></li>
				<li>This method of writing a UI required huge effort, requiring more boilerplate code and being <span class="No-Break">error prone.</span></li>
			</ul>
			<p>Google developed Jetpack Compose as a modern <strong class="bold">declarative</strong> UI toolkit. It allows us to <a id="_idIndexMarker081"/><a id="_idIndexMarker082"/><a id="_idIndexMarker083"/>create UIs with less code. Layouts created in Jetpack Compose are responsive to different screen sizes and orientations. It is also easier and more productive to write UIs in Compose. With Jetpack Compose, we can reuse components across our code bases. Jetpack Compose also allows us to use code from XML components in <span class="No-Break">our composables.</span></p>
			<p>Jetpack Compose is entirely in Kotlin, meaning it takes advantage of the powerful language features that Kotlin offers. The <strong class="bold">view system</strong>, which was<a id="_idIndexMarker084"/><a id="_idIndexMarker085"/> used to create UIs before Compose, was more procedural. We had to manage complex life cycles and handle any changes in state manually. Jetpack Compose is a whole other paradigm that uses declarative programming. We describe what the UI should be like based on a state. This enables us to have dynamic content and less boilerplate code and develop our <span class="No-Break">UIs faster.</span></p>
			<p>To understand Jetpack Compose, let us first dive deep into the differences between the declarative and imperative approaches to <span class="No-Break">writing UIs.</span></p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor045"/>Declarative versus imperative UIs</h2>
			<p>In imperative UIs, we specify step by step<a id="_idIndexMarker086"/><a id="_idIndexMarker087"/> the instructions describing how the UI should be built and updated. We explicitly define the sequence of operations to create and modify UI elements. We rely on mutable state variables to represent the current state of the UI. We manually update these state variables as the UI changes and respond to<a id="_idIndexMarker088"/><a id="_idIndexMarker089"/> <span class="No-Break">user interactions.</span></p>
			<p>In declarative UIs, we focus on describing the desired outcome rather than specifying the step-by-step instructions. We define what the UI should look like based on the current state, and the framework handles the rest. We define the UI using declarative markup or code. We express the desired UI structure, layout, and behavior by describing the relationships between UI elements and <span class="No-Break">their properties.</span></p>
			<p>The declarative approach puts more emphasis on the immutable state, where the UI state is represented by immutable data objects. Instead of directly mutating the state, we create new instances of the data objects to reflect the desired changes in <span class="No-Break">the UI.</span></p>
			<p>In a declarative UI, the framework takes care of updating the UI based on changes in the application state. We specify the relationships between the UI and the underlying state, and the framework automatically updates the UI to reflect <span class="No-Break">those changes.</span></p>
			<p>Now that we understand both imperative and declarative approaches, let’s look at an example of each. Let’s create a simple UI for a counter using <a id="_idIndexMarker090"/><a id="_idIndexMarker091"/>both the declarative UI in Jetpack Compose (Kotlin) and the imperative UI in XML (Android XML layout). The example will showcase the differences in syntax and the approach between the two. The Jetpack Compose<a id="_idIndexMarker092"/><a id="_idIndexMarker093"/> version looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
class MainActivity : ComponentActivity() {
  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContent {
        MyApp()
    }
  }
}
@Composable
fun MyApp() {
  var count by remember { mutableStateOf(0) }
  Column(
    modifier = Modifier.padding(16.dp)
  ) {
      Text(text = "Counter: $count", style = MaterialTheme.typography.bodyLarge)
      Spacer(modifier = Modifier.height(16.dp))
      Button(onClick = { count++ }) {
        Text("Increment")
      }
    }
}</pre>			<p>In the preceding example, we have a <strong class="source-inline">MyApp</strong> composable function that defines the UI for the app. The UI is defined in a declarative manner, by using composables to define the UI and handling state changes using the remember composable. The UI is defined using a functional approach. Also, we can see that the UI is defined in a more <span class="No-Break">concise manner.</span></p>
			<p>With the imperative approach, we <a id="_idIndexMarker094"/><a id="_idIndexMarker095"/>must first create the<a id="_idIndexMarker096"/><a id="_idIndexMarker097"/> XML UI, as shown in the following <span class="No-Break">code block:</span></p>
			<pre class="source-code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;RelativeLayout 
  
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  android:padding="16dp"&gt;
  &lt;TextView
    android:id="@+id/counterTextView"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_centerHorizontal="true"
    android:text="Counter: 0"
    android:textSize="20sp" /&gt;
  &lt;Button
    android:id="@+id/incrementButton"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_below="@id/counterTextView"
    android:layout_centerHorizontal="true"
    android:layout_marginTop="16dp"
    android:text="Increment" /&gt;
&lt;/RelativeLayout&gt;</pre>			<p>With the layout file created, we can now create the activity class, which will inflate the layout file and handle the <span class="No-Break">button click:</span></p>
			<pre class="source-code">
import android.os.Bundle
import android.widget.Button
import android.widget.TextView
import androidx.appcompat.app.AppCompatActivity
class MainActivity : AppCompatActivity() {
  private var count = 0
  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)
    val counterTextView: TextView = findViewById(R.id.counterTextView)
    val incrementButton: Button = findViewById(R.id.incrementButton)
    incrementButton.setOnClickListener {
      count++
      counterTextView.text = "Counter: $count"
    }
  }
}</pre>			<p>In this example, the XML layout is inflated in the <strong class="source-inline">onCreate</strong> method of the <strong class="source-inline">MainActivity</strong> class, and UI elements are accessed and <span class="No-Break">manipulated programmatically.</span></p>
			<p>In the preceding examples, the Jetpack Compose code is written in Kotlin and provides a more declarative approach, defining the UI in<a id="_idIndexMarker098"/><a id="_idIndexMarker099"/> a functional manner. The XML layout, on the other hand, is written imperatively in XML, specifying the <a id="_idIndexMarker100"/><a id="_idIndexMarker101"/>UI structure and properties in a more step-by-step manner using XML and interacting with them imperatively in Kotlin code. Jetpack Compose allows for a more concise and expressive representation of the UI using a <span class="No-Break">declarative syntax.</span></p>
			<p>Now that we have a clear understanding of the imperative and declarative ways of writing UIs, in the next section, we will be diving deep into the building blocks of <span class="No-Break">Jetpack Compose.</span></p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor046"/>Composable functions</h2>
			<p>As shown in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.1</em>, composable functions are<a id="_idIndexMarker102"/><a id="_idIndexMarker103"/> the main building<a id="_idIndexMarker104"/><a id="_idIndexMarker105"/> blocks of <span class="No-Break">Jetpack Compose:</span></p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/B19779_03_01.jpg" alt="Figure 3.1 – Compose UI" width="929" height="1101"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Compose UI</p>
			<p>A composable function describes how to render a UI. This function must be annotated with the <strong class="source-inline">@Composable</strong> function. When you annotate a function with this annotation, it means that the function describes how to compose a specific part of the UI. Composable functions are meant to be <strong class="bold">reusable</strong>. They can be called multiple times while the UI is <a id="_idIndexMarker106"/><a id="_idIndexMarker107"/>active. Whenever the state of the composable changes, it goes through a process of <a id="_idIndexMarker108"/><a id="_idIndexMarker109"/>recomposition, which enables the UI to display the <span class="No-Break">latest state.</span></p>
			<p>Composable functions are <strong class="bold">pure functions</strong>, meaning they <a id="_idIndexMarker110"/><a id="_idIndexMarker111"/>don’t have any side effects. They produce the same output when called several times with the same input. This ensures the functions are predictable and efficient in dispatching updates to the UI. However, there are exceptions, for example, launching a coroutine within a composable of calling external methods that do have side-effects, which should be avoided or <span class="No-Break">handled carefully.</span></p>
			<p>Smaller composable functions can be combined to build complex UIs. You can reuse and nest composables inside <span class="No-Break">other composables.</span></p>
			<p>Let’s look at an example of a <span class="No-Break">composable function:</span></p>
			<pre class="source-code">
@Composable
fun PacktPublishing(bookName: String) {
    Text(text = "Title of the book is: $bookName")
}</pre>			<p>In the preceding code snippet, the <strong class="source-inline">PacktPublishing</strong> function is annotated with the <strong class="source-inline">@Composable</strong> annotation. The function takes a parameter, <strong class="source-inline">bookName</strong>, which is a <strong class="source-inline">String</strong>. Inside the function, we have another composable from the Material <a id="_idIndexMarker112"/><a id="_idIndexMarker113"/>Design library. The composable renders some text to <span class="No-Break">our UI.</span></p>
			<p>When designing our UIs, we usually want to see<a id="_idIndexMarker114"/><a id="_idIndexMarker115"/> how the UIs look without running our app. Luckily, we have <strong class="bold">previews</strong>, which visualize our composable functions. We will be learning about them in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor047"/>Previews</h2>
			<p>In Jetpack Compose, we have the <strong class="source-inline">@Preview</strong> annotation, which generates a preview of our composable function or a group of Compose components<a id="_idIndexMarker116"/><a id="_idIndexMarker117"/> inside Android Studio. It has an interactive mode to allow us to interact with our <a id="_idIndexMarker118"/><a id="_idIndexMarker119"/>Compose functions. This gives us a way to quickly visualize our designs and easily make changes <span class="No-Break">when needed.</span></p>
			<p>This is how our <strong class="source-inline">PacktPublishing</strong> composable function would look like with <span class="No-Break">a preview:</span></p>
			<pre class="source-code">
@Preview(showBackground = true)
@Composable
fun PacktPublishingPreview() {
    PacktPublishing("Android Development with Kotlin")
}</pre>			<p>We have used the <strong class="source-inline">@Preview</strong> annotation to indicate that we want to build a preview for this function. Additionally, we have set the <strong class="source-inline">showBackground</strong> parameter to <strong class="source-inline">true</strong>, which adds a white background to our preview. We have named the function with the <strong class="source-inline">Preview</strong> suffix. The preview is also a <span class="No-Break">composable function.</span></p>
			<p>To be able to see the preview, you need to be in the <strong class="bold">split or design mode</strong> in your<a id="_idIndexMarker120"/><a id="_idIndexMarker121"/> editor. These options are normally at the top right of Android Studio. We also need to do a build for Android Studio to generate a preview, which will look <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/B19779_03_02.jpg" alt="Figure 3.2 – Text preview" width="1083" height="113"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Text preview</p>
			<p>As seen in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.2</em>, we have a text that displays the string that we passed to the function. The preview also has a white background and its name at the <span class="No-Break">top left.</span></p>
			<p>We can show previews for both dark and light color schemes. We can also configure properties such as the devices and preview windows to <span class="No-Break">be applied.</span></p>
			<p>Previews are great for quick iterations while designing UIs. However, they are not a replacement for actual device/emulator testing, particularly<a id="_idIndexMarker122"/><a id="_idIndexMarker123"/> for things such <a id="_idIndexMarker124"/><a id="_idIndexMarker125"/>as animations, interactions, or <span class="No-Break">dynamic data.</span></p>
			<p>With an understanding of what previews are and how to create them, let us look into one more Compose feature, <strong class="bold">modifiers</strong>, in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor048"/>Modifiers</h2>
			<p>Modifiers allow us to decorate our<a id="_idIndexMarker126"/><a id="_idIndexMarker127"/> composable functions by enabling <span class="No-Break">the following:</span></p>
			<ul>
				<li>Change composables’ size, behavior, <span class="No-Break">and appearance</span></li>
				<li>Add <span class="No-Break">more information</span></li>
				<li>Process <span class="No-Break">user input</span></li>
				<li>Add interactions such as clicks and <span class="No-Break">ripple effects</span></li>
			</ul>
			<p>With modifiers, we can change various aspects of our composable, such as size, padding, color, and shape. Most Jetpack Compose components from the library allow us to provide a modifier as a parameter. For example, if we need to provide padding to our preview text, we will have <span class="No-Break">the following:</span></p>
			<pre class="source-code">
Text(
    modifier = Modifier.padding(16.dp),
    text = "Title of the book is: $bookName"
)</pre>			<p>We have added the padding modifier to the <strong class="source-inline">Text</strong> composable. This will add <strong class="source-inline">16.dp</strong><strong class="bold"> </strong>padding to the <strong class="source-inline">Text</strong> composable. <strong class="source-inline">16.dp</strong> is a <strong class="bold">density-independent</strong> pixel unit in Jetpack <a id="_idIndexMarker128"/><a id="_idIndexMarker129"/>Compose. This means it will remain consistent and adjust properly to different <span class="No-Break">screen densities.</span></p>
			<p>We can chain the different modifier functions in one composable. When chaining modifiers, the order of application is crucial. If we don’t achieve the desired result, we need to double-check the order. Let’s observe this concept <span class="No-Break">in practice:</span></p>
			<pre class="source-code">
Text(
    modifier = Modifier
        .fillMaxWidth()
        .padding(16.dp)
        .background(Color.Green),
    text = "Title of the book is: $bookName"
)</pre>			<p>We have added two more modifiers. The first is the <strong class="source-inline">fillMaxWidth</strong> modifier, which is added to the text composable. This will make the text <a id="_idIndexMarker130"/><a id="_idIndexMarker131"/>composable take the full width of the parent. The other one is the background modifier to the <strong class="source-inline">Text</strong> composable. This will<a id="_idIndexMarker132"/><a id="_idIndexMarker133"/> add a background color to the text composable. The preview for our text will look <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/B19779_03_03.jpg" alt="Figure 3.3 – Text modifier preview" width="1104" height="208"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Text modifier preview</p>
			<p>As seen in the preceding screenshot, the text now occupies the whole width of the device and has a green background. It also has a padding of <strong class="source-inline">16dp</strong> <span class="No-Break">all around.</span></p>
			<p>Modifiers do not modify the original composable. They return a new, modified instance. This ensures our composable remains unchanged and immutable. Immutability, a fundamental principle in functional programming, ensures that the state remains unchanged, simplifying state management and reducing side effects. This approach enhances predictability and readability by adhering to the principles of referential transparency. The ability to compose functions, exemplified by chaining modifier functions, facilitates a concise and readable expression of complex UI behavior without altering the original composable. In addition to using the existing modifiers, we can also create our own modifiers <span class="No-Break">when needed.</span></p>
			<p>Now that you have an understanding of what modifiers are, we are going to build on that knowledge by learning about Jetpack Compose layouts in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor049"/>Jetpack Compose layouts</h1>
			<p>Jetpack Compose has a variety of pre-built layouts <a id="_idIndexMarker134"/><a id="_idIndexMarker135"/>for us to use. Before looking at the different layouts present, let us first understand how Jetpack Compose transforms<a id="_idIndexMarker136"/><a id="_idIndexMarker137"/> state <span class="No-Break">into UI.</span></p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/B19779_03_04.jpg" alt="Figure 3.4 – How Compose transforms state into UI" width="806" height="96"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – How Compose transforms state into UI</p>
			<p>From the preceding diagram, we can see that our state is transformed into a UI in the <span class="No-Break">following steps:</span></p>
			<ol>
				<li><span class="No-Break"><strong class="bold">Composition</strong></span><p class="list-inset">This is the initial phase. The Compose compiler creates a tree of UI elements. Each element is a function that represents a UI element. Compose then calls the functions to create the UI tree. The composition step is responsible for determining <a id="_idIndexMarker138"/>which composables need updates and which ones can be reused. This happens by comparing a previous tree of composables with the new tree and only updating the ones that have changed. This makes this step very efficient as only elements with updates <span class="No-Break">are updated.</span></p></li>
				<li><span class="No-Break"><strong class="bold">Layout</strong></span><p class="list-inset">This step happens after the composition phase. Here, the Compose compiler takes the tree generated in the composition phase and determines its size, position, and layout. Each composable is measured and positioned within the layout based on its parent and any constraints set. This phase is responsible for determining the final position and size of each UI element on the screen. It is also responsible for creating the final layout tree used in the <span class="No-Break">drawing phase.</span></p></li>
				<li><span class="No-Break"><strong class="bold">Drawing</strong></span><p class="list-inset">This is the last phase of transforming our UI to state. In this phase, the Compose compiler takes the final layout tree created in the layout phase and uses it to draw the elements on the screen. This is done by walking through the tree and issuing draw commands to the underlying graphics system. This phase is responsible for rendering the final UI on <span class="No-Break">the screen.</span></p></li>
			</ol>
			<p>These three phases<a id="_idIndexMarker139"/> work together to create our UI in Jetpack Compose. The composition phase builds a tree of composables, the layout phase positions and sizes them, and the drawing phase renders them on the screen. This entire process is optimized, performant, and efficient, allowing for fast and smooth UI rendering in even <span class="No-Break">complex UIs.</span></p>
			<p>Now that we understand how the Compose compiler renders our UI, let us see the layouts that are <span class="No-Break">in Compose.</span></p>
			<p>Jetpack Compose offers the following layouts out of <span class="No-Break">the box:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">Column</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">Row</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">Box</strong></span></li>
				<li><span class="No-Break">Lists</span></li>
			</ul>
			<p>We are going to look at each of these layouts in detail in the next subsections. To begin with, let us look the <span class="No-Break"><strong class="source-inline">Column</strong></span><span class="No-Break"> layout.</span></p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor050"/>Column</h2>
			<p>We use <strong class="source-inline">Column</strong> when we <a id="_idIndexMarker140"/>want to organize items vertically. An example of the use of <strong class="source-inline">Column</strong> is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
Column {
    Text(text = "Android")
    Text(text = "Kotlin")
    Text(text = "Compose")
}</pre>			<p>In the preceding code, we have created <strong class="source-inline">Column</strong> with three text elements. Adding a preview for this <a id="_idIndexMarker141"/>generates the following UI <span class="No-Break">for us:</span></p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/B19779_03_05.jpg" alt="Figure 3.5 – Column preview" width="676" height="686"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Column preview</p>
			<p>As seen from the preceding screenshot, the design is basic. We are going to polish it up a bit by using modifiers since Jetpack Compose also provides support for modifiers in these layouts. Let us add these changes to <span class="No-Break">our column:</span></p>
			<pre class="source-code">
Column(
    modifier = Modifier
        .fillMaxSize()
        .padding(16.dp),
    verticalArrangement = Arrangement.Center,
    horizontalAlignment = Alignment.CenterHorizontally
) {
    Text(text = "Android")
    Text(text = "Kotlin")
    Text(text = "Compose")
}</pre>			<p>Here, we have added a <strong class="source-inline">Modifier</strong> to our <strong class="source-inline">Column</strong>. In the modifier parameter, we specify the <strong class="source-inline">fillMaxSize</strong> modifier, which makes our column fill the available space within the parent. This is helpful for <a id="_idIndexMarker142"/>building full-view screens for our UIs. We have also added padding of <strong class="source-inline">16.dp</strong> to <span class="No-Break">our column.</span></p>
			<p>Additionally, we have specified two more parameters for our column. One is <strong class="source-inline">verticalArrangement</strong>, which we use to specify the vertical arrangement of the children of this view. In this case, we specify <strong class="source-inline">Arrangement.Center</strong>, which places all the children of our <strong class="source-inline">Column</strong> vertically at the center. The other parameter is <strong class="source-inline">horizontalAlignment</strong>, which is the horizontal alignment of the children of the layout. In this case, we specify the value to be <strong class="source-inline">Alignment.CenterHorizontally</strong>, which will align all the children at the center horizontally. Our preview with the preceding changes will look <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/B19779_03_06.jpg" alt="Figure 3.6 – Column modifiers preview" width="507" height="1091"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Column modifiers preview</p>
			<p>From the preceding screenshot, we can now see our column occupies the whole screen and all the text elements are<a id="_idIndexMarker143"/> centered vertically and horizontally within <span class="No-Break">the parent.</span></p>
			<p>Let us now learn about the <strong class="source-inline">Row</strong> composable in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor051"/>Row</h2>
			<p>We use <strong class="source-inline">Row</strong> when we<a id="_idIndexMarker144"/> want to organize items horizontally. An example of the use of <strong class="source-inline">Row</strong> is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
Row {
    Text(text = "Android")
    Text(text = "Kotlin")
    Text(text = "Compose")
}</pre>			<p>In the preceding code, the <strong class="source-inline">Row</strong> composable<a id="_idIndexMarker145"/> is used to display three text elements horizontally in a row. The preview for this will look <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/B19779_03_07.jpg" alt="Figure 3.7 – Row preview" width="1029" height="203"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – Row preview</p>
			<p>The text elements are all arranged next to each other in a horizontal row. <strong class="source-inline">Row</strong>, like the composable, supports the addition of modifiers. Let us modify our <strong class="source-inline">Row</strong> to look <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
Row(
    modifier = Modifier
        .fillMaxSize()
        .padding(16.dp),
    verticalAlignment = Alignment.CenterVertically,
    horizontalArrangement = Arrangement.SpaceEvenly
) {
    Text(text = "Android")
    Text(text = "Kotlin")
    Text(text = "Compose")
}</pre>			<p>In the preceding code, we have added modifiers to the <strong class="source-inline">Row</strong> composable. The <strong class="source-inline">fillMaxSize</strong> modifier makes the row fill the entire available space. The padding modifier adds padding to the <strong class="source-inline">Row</strong>. The <strong class="source-inline">verticalAlignment</strong> and <strong class="source-inline">horizontalArrangement</strong> modifiers are used to align the children of the <strong class="source-inline">Row</strong> vertically and horizontally, respectively. Notice <a id="_idIndexMarker146"/>that for the <strong class="source-inline">horizontalArrangement</strong> modifier, we use the <strong class="source-inline">Arrangement.SpaceEvenly</strong> option. This makes sure each of the children occupies equal space in the parent. The preview for this looks <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/B19779_03_08.jpg" alt="Figure 3.8 – Row modifiers preview" width="500" height="1096"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – Row modifiers preview</p>
			<p>As seen in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.8</em>, the row occupies the whole screen, and the text elements are evenly spaced within the<a id="_idIndexMarker147"/> <span class="No-Break">screen width.</span></p>
			<p>In the next section, we will be learning about the <span class="No-Break"><strong class="source-inline">Box</strong></span><span class="No-Break"> layout.</span></p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor052"/>Box</h2>
			<p>The <strong class="source-inline">Box</strong> layout allows us<a id="_idIndexMarker148"/> to position child elements in a flexible way using the X and Y coordinates. Let us see a <span class="No-Break">code example:</span></p>
			<pre class="source-code">
Box(
    modifier = Modifier
        .size(100.dp),
    contentAlignment = Alignment.Center
) {
    Icon(
        modifier = Modifier
            .size(80.dp),
        imageVector = Icons.Outlined.Notifications,
        contentDescription = null,
        tint = Color.Green
    )
    Text(text = "9")
}</pre>			<p>In the preceding code, we have a <strong class="source-inline">Box</strong> composable that has an <strong class="source-inline">Icon</strong> and <strong class="source-inline">Text</strong> composable as its children. We have <a id="_idIndexMarker149"/>set the size of the <strong class="source-inline">Box</strong> composable to <strong class="source-inline">100.dp</strong> and the <strong class="source-inline">Icon</strong> composable to <strong class="source-inline">80.dp</strong>. The text and icon composables are placed in the center of the <strong class="source-inline">Box</strong> composable using the <strong class="source-inline">contentAlignment</strong> parameter. They are placed in the center of the <strong class="source-inline">Box</strong> composable because we have specified the <strong class="source-inline">contentAlignment</strong> parameter as <strong class="source-inline">Alignment.Center</strong>. They are also stacked on top of each other because the <strong class="source-inline">Box</strong> composable is a layout composable that stacks its children on top of each other. The preview for our <strong class="source-inline">Box</strong> composable looks <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/B19779_03_09.jpg" alt="Figure 3.9 – Box preview" width="567" height="613"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – Box preview</p>
			<p>As we can see from <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.9</em>, the notification icon and the text are stacked together. The <strong class="source-inline">Box</strong> composable enables us to<a id="_idIndexMarker150"/> achieve this and <span class="No-Break">much more.</span></p>
			<p>Now let us look at how to display lists in Jetpack Compose in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor053"/>Lists</h2>
			<p>As Android developers, we<a id="_idIndexMarker151"/> need to make apps that display lists of items. It can be a list of movies, orders, songs, or books. So, how do we do that in Compose? The good news for us is that Jetpack Compose makes it easier for us to do so. Compose provides the <strong class="source-inline">LazyColumn</strong> and <strong class="source-inline">LazyRow</strong> components, which can be used to display a list of items. These components are very efficient and performant. They only render the items that are visible on the screen, rather than rendering all the items at once. <strong class="source-inline">LazyColumn</strong> displays items vertically, while <strong class="source-inline">LazyRow</strong> displays items horizontally. <strong class="source-inline">LazyColumn</strong> and <strong class="source-inline">LazyRow</strong> are normally optimized for large datasets and at times are not suitable for all use cases. These composable functions allow you to define<a id="_idIndexMarker152"/> the contents of the list as a function that returns a single item, and then Compose will automatically generate and render the UI elements for each item in the list as they become visible on <span class="No-Break">the screen.</span></p>
			<p>Let’s see an example <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">LazyColumn</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
LazyColumn(
    modifier = Modifier
        .fillMaxSize()
        .background(Color.LightGray)
) {
    items(100) {
        Text(
            modifier = Modifier
                .padding(8.dp),
            text = "Item number $it"
        )
    }
}</pre>			<p>We have <strong class="source-inline">LazyColumn</strong> with 100 items. Each item is a <strong class="source-inline">Text</strong> composable. The preview for this looks <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/B19779_03_10.jpg" alt="Figure 3.10 – LazyColumn preview" width="495" height="1090"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10 – LazyColumn preview</p>
			<p>We can see from <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.10</em> that we now have a list of items that scroll vertically. As mentioned, it only shows the items that can fit on the screen. If we use interactive mode on our preview, we will be<a id="_idIndexMarker153"/> able to scroll through to the bottom of <span class="No-Break">the list.</span></p>
			<p>Let us see the <strong class="source-inline">LazyRow</strong> equivalent <span class="No-Break">as well:</span></p>
			<pre class="source-code">
LazyRow(
    modifier = Modifier
        .fillMaxWidth()
        .background(Color.LightGray)
        .padding(8.dp)
) {
    items(100) {
        Text(
            modifier = Modifier
                .padding(8.dp),
            text = "Item number $it"
        )
    }
}</pre>			<p>We have <strong class="source-inline">LazyRow</strong> with 100 items. Each<a id="_idIndexMarker154"/> item is a <strong class="source-inline">Text</strong> composable. The preview for this looks <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/B19779_03_11.jpg" alt="Figure 3.11 – LazyRow preview" width="995" height="190"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11 – LazyRow preview</p>
			<p>We can see from <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.11</em> that we now have a list of items that scroll horizontally. Similar to <strong class="source-inline">LazyColumn</strong>, it only shows the items that can fit on the screen. If we use interactive mode on our preview, we can scroll through to the end of <span class="No-Break">the list.</span></p>
			<p>We also have two more types of list layouts, <strong class="source-inline">LazyVerticalGrid</strong> and <strong class="source-inline">LazyHorizontalGrid</strong>. The two layouts are part of the lazy grids and help us to arrange our content in grids. They’re commonly used in applications such as galleries, movies, and spreadsheets. <strong class="source-inline">LazyVerticalGrid</strong> creates a vertical list of items in a grid. Let us look at the sample code <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">LazyVerticalGrid</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
LazyVerticalGrid(
    modifier = Modifier
        .fillMaxSize()
        .background(Color.LightGray)
        .padding(8.dp),
    columns = GridCells.Fixed(3)
) {
    items(100) {
        Text(
            modifier = Modifier
                .padding(8.dp),
            text = "Item number $it"
        )
    }
}</pre>			<p>We have used the <strong class="source-inline">LazyVerticalGrid</strong> composable. We pass our modifiers as before. Notice we also have the <strong class="source-inline">columns</strong> parameter. This parameter allows us to specify the number of columns and how items are arranged within the columns. In this case, we specified <strong class="source-inline">GridCells</strong> to be <strong class="source-inline">Fixed</strong>. This means the grid will have a fixed number of columns or rows in it is a <strong class="source-inline">LazyHorizontalGrid</strong>. We also have the <strong class="source-inline">Adaptive</strong> type, which <a id="_idIndexMarker155"/>defines a grid with as many rows or columns as possible with the condition that every cell has a minimum size and all extra space is distributed evenly. Our preview will look <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/B19779_03_12.jpg" alt="Figure 3.12 – LazyVerticalGrid preview" width="498" height="1093"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.12 – LazyVerticalGrid preview</p>
			<p>We have our text elements in a grid of three columns. We are now able to scroll through the items vertically. Let us<a id="_idIndexMarker156"/> now look at the code <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">LazyHorizontalGrid</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
LazyHorizontalGrid(
    modifier = Modifier
        .fillMaxSize()
        .background(Color.LightGray)
        .padding(8.dp),
    rows = GridCells.Fixed(3)
) {
    items(100) {
        Text(
            modifier = Modifier
                .padding(8.dp),
            text = "Item number $it"
        )
    }
}</pre>			<p>The code is similar to that for <strong class="source-inline">LazyVerticalGrid</strong>. The only difference is that we are using <strong class="source-inline">LazyHorizontalGrid</strong> and<a id="_idIndexMarker157"/> instead of columns, we are now passing <strong class="source-inline">rows</strong> to describe how the cells will form the rows. The preview will look <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/B19779_03_13.jpg" alt="Figure 3.13 – LazyHorizontalGrid preview" width="499" height="1096"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.13 – LazyHorizontalGrid preview</p>
			<p>As seen in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.13</em>, we now have three rows on the entire screen, and we can also scroll through <span class="No-Break">them</span><span class="No-Break"><a id="_idIndexMarker158"/></span><span class="No-Break"> horizontally.</span></p>
			<p>In addition to <strong class="source-inline">LazyVerticalGrid</strong> and <strong class="source-inline">LazyHorizontalGrid</strong>, we also have <strong class="source-inline">LazyVerticalStaggeredGrid</strong> and <strong class="source-inline">LazyHorizontalStaggeredGrid</strong>, which are remarkably similar; the only difference is that they adapt to the children’s height and width, respectively, meaning they all do not have uniform height <span class="No-Break">or width.</span></p>
			<p>Let us now have a<a id="_idIndexMarker159"/> look at <strong class="source-inline">ConstraintLayout</strong> in the <span class="No-Break">next section.</span></p>
			<h3>ConstraintLayout</h3>
			<p>This layout enables us to create responsive layouts. We can create complex layouts with relative positioning. <strong class="source-inline">ConstraintLayout</strong> uses chains, barriers, and guidelines to position child elements<a id="_idIndexMarker160"/> relative to <span class="No-Break">each other.</span></p>
			<p>It comes as a separate dependency, and we need to add it to our project. To add it, let us add this dependency to our app <span class="No-Break"><strong class="source-inline">build.gradle</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
 implementation 'androidx.constraintlayout:constraintlayout-compose:1.0.1'</pre>			<p>This adds the Jetpack Compose dependency to our project. The layout code for the constraint layout is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
ConstraintLayout(
  modifier = Modifier
    .padding(16.dp)
) {
    val (icon, text) = createRefs()
      Icon(
          modifier = Modifier
            .size(80.dp)
            .constrainAs(icon) {
                top.linkTo(parent.top)
                bottom.linkTo(parent.bottom)
                start.linkTo(parent.start)
            },
          imageVector = Icons.Outlined.Notifications,
          contentDescription = null,
          tint = Color.Green
      )
    Text(
        modifier = Modifier
          .constrainAs(text) {
              top.linkTo(parent.top)
              bottom.linkTo(parent.bottom)
              start.linkTo(icon.end) },
        text = "9",
        style = MaterialTheme.typography.titleLarge
    )
}</pre>			<p>In the preceding code, we used the <strong class="source-inline">ConstraintLayout</strong> composable function to create <strong class="source-inline">ConstraintLayout</strong>. Inside <strong class="source-inline">ConstraintLayout</strong>, we used the <strong class="source-inline">createRefs()</strong> function to create two references, one for the icon and one for the text. We then used the <strong class="source-inline">constrainAs()</strong> function to constrain the icon and the text to the parent. We used the <strong class="source-inline">linkTo()</strong> function to link the icon and the text to the parent. In this case, we have linked <a id="_idIndexMarker161"/>the icon to the start, top, and bottom of the parent. For the text, we have linked it to the top and bottom of the parent. We have additionally linked the start of the text to the end of the icon. Our preview will look <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/B19779_03_14.jpg" alt="Figure 3.14 – ConstraintLayout preview" width="452" height="448"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.14 – ConstraintLayout preview</p>
			<p>From the preceding<a id="_idIndexMarker162"/> screenshot, we can see that we have an icon and text to the right of the icon. <strong class="source-inline">ConstraintLayout</strong> helps in positioning items relative to the parent or <span class="No-Break">each other.</span></p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor054"/>Summary</h1>
			<p>In this chapter, we have introduced ourselves to Jetpack Compose, a declarative way of creating UIs for apps. We have also learned about the different layouts that are in Compose and how the Jetpack Compose compiler renders state into <span class="No-Break">a UI.</span></p>
			<p>In the next chapter, we will be building on top of what we have learned and look at how to design beautiful and intuitive apps with <strong class="bold">Material Design 3</strong>. We’re going to learn about Material Design 3, its features, and how to add dynamic color to <span class="No-Break">our app.</span></p>
		</div>
	</div></div></body></html>