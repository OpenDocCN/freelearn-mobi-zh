- en: <st c="0">10</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="3">Swift Macros</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="16">Developers frequently encounter various challenges with their IDEs,
    often related to missing functionalities, mostly about missing functionalities.</st>
    <st c="165">With each new Xcode or Swift version, Apple introduces additional
    features that enhance productivity and simplify tasks.</st> <st c="286">However,
    even Apple has a hard time fulfilling our needs and demands.</st> <st c="356">Fortunately,
    this time, we can create customized functionalities using</st> <st c="427">Swift
    Macros.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="440">Swift Macros</st>** <st c="453">is an</st> <st c="459">exciting
    new feature added to Xcode 15 and iOS 17, and this chapter will help us increase
    our productivity by achieving more from</st> <st c="590">our IDE.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="598">In this chapter, we will cover the</st> <st c="634">following topics:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="651">Learning about</st> <st c="667">Swift Macros</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="679">Exploring the</st> `<st c="694">SwiftSyntax</st>` <st c="705">library,
    which stands behind</st> <st c="735">Swift Macros</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="747">Creating our first</st> <st c="767">Swift macro</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="778">Handling errors and providing more clarity when something</st> <st
    c="837">goes wrong</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="847">Testing our macro, making sure it runs as expected</st> <st c="899">over
    time</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="908">But now, let’s start with the basics and discover</st> <st c="959">Swift
    Macros.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="972">Technical requirements</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="995">You must download Xcode version 16.0 or above for this chapter from
    Apple’s</st> <st c="1072">App Store.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1082">You’ll also need to run the latest version of macOS (Ventura or
    above).</st> <st c="1155">Search for Xcode in the App Store and select and download
    the latest version.</st> <st c="1233">Launch Xcode and follow any additional installation
    instructions that your system may prompt you with.</st> <st c="1336">Once Xcode
    has fully launched, you’re ready</st> <st c="1380">to go.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1386">What is a Swift macro?</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1409">You probably heard the term “macro” before in the context of programming.</st>
    <st c="1484">That’s perhaps because programming languages such as C/C++ have macros</st>
    <st c="1555">as well.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1563">A</st> **<st c="1566">macro</st>** <st c="1571">is a</st> <st c="1576">structure
    that lets us define a code pattern that is being replaced by the compiler with
    a specific set</st> <st c="1681">of instructions.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1697">Let’s see a short</st> <st c="1716">C example:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: <st c="1795">In our preceding code, we declare a macro called</st> `<st c="1845">SQUARE</st>`
    <st c="1851">that receives one parameter named</st> `<st c="1886">X</st>`<st c="1887">,
    and our compiler replaces it with</st> `<st c="1923">(</st>``<st c="1924">x) *(x)</st>`<st
    c="1931">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="1932">The initial question that comes to mind is this: why?</st> <st
    c="1987">Can’t we just define</st> <st c="2008">a function?</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2019">So, in this case, a simple function that calculates a number’s
    square can be</st> <st c="2097">helpful here.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2110">But a macro’s primary goal is not to</st> <st c="2147">replace
    functions, as they are great for</st> <st c="2189">several reasons:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="2205">Code reuse</st>**<st c="2216">: Notice that code reuse is not
    “functionality reuse.” Code reuse is where we take an actual code snippet and
    reuse it in different places.</st> <st c="2357">For example, if we constantly
    repeat the same line sequence when declaring a class, a macro can help us avoid</st>
    <st c="2467">repeating ourselves.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="2487">Improve abstraction</st>**<st c="2507">: Macros can help us
    add another abstraction layer to our code.</st> <st c="2572">Imagine writing a
    macro that generates functions declaration.</st> <st c="2634">That’s another level
    we can construct</st> <st c="2672">our code.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="2681">Performance</st>**<st c="2693">: In some cases, macros can help
    us optimize our code.</st> <st c="2749">Sometimes, the trade-off between optimization
    and readability/simplicity can be solved using a macro.</st> <st c="2851">A macro
    can generate a piece of harder-to-read code and yet be optimized.</st> <st c="2925">One
    feature that macro can optimize code for is</st> **<st c="2973">loop unrolling</st>**
    <st c="2987">– a way to</st> <st c="2999">iterate a loop faster with instruction-level
    parallelism.</st> <st c="3057">Loop unrolling</st> <st c="3072">produces less</st>
    <st c="3086">readable code but is</st> <st c="3107">much quicker.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="3120">In the bottom line, a macro</st> <st c="3148">is just a tool that
    replaces one code with another and inserts a specific code snippet before the
    compile time.</st> <st c="3261">But C macros</st> <st c="3273">are full of issues.</st>
    <st c="3294">They are difficult to test, not type-safety, their errors are not
    clear enough, and sharing them with other developers is not trivial.</st> <st
    c="3429">As part of Xcode 15, the Swift team released a new tool called</st> **<st
    c="3492">Swift Macros</st>** <st c="3504">– the</st> <st c="3511">Swift version
    of macros that lets us create macros more efficiently</st> <st c="3579">and elegantly.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3593">Let’s go over a simple</st> <st c="3617">example of</st> <st c="3628">macro
    usage.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3640">In our project, we want to add a macro that adds a function named</st>
    `<st c="3706">log(issue:String)</st>` <st c="3724">to classes and structs.</st>
    <st c="3749">That function prints an issue to our log and adds the class or the
    struct name.</st> <st c="3829">We can call that macro</st> `<st c="3852">@AddDebugLogger</st>`<st
    c="3867">, and we can use it</st> <st c="3887">as follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: <st c="3934">In the preceding code, we declared a class named</st> `<st c="3984">MyClass</st>`
    <st c="3991">and attached a macro named</st> `<st c="4019">@AddDebugerLogger</st>`<st
    c="4036">, which expands to the</st> <st c="4059">following code:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: <st c="4185">The macro adds a function named</st> `<st c="4218">printLog()</st>`<st
    c="4228">, which prints an issue to the console while mentioning the class name
    as part of the log message.</st> <st c="4327">This serves as an example of primary
    macro usage, illustrating the capabilities of</st> <st c="4410">this tool.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4420">But how is the macro familiar with the class name?</st> <st c="4472">How
    does it generate a new function in the right place inside the class?</st> <st
    c="4545">To answer these questions, we first need to meet</st> `<st c="4594">SwiftSyntax</st>`<st
    c="4605">, a</st> <st c="4609">library that stands in the heart of</st> <st c="4645">Swift
    Macros.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4658">Exploring SwiftSyntax</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`<st c="4680">SwiftSyntax</st>` <st c="4692">is not a</st> <st c="4702">new
    library, and it’s part of Swift’s code base from its early beginnings.</st> <st
    c="4777">In fact, Swift Macros is part of</st> `<st c="4810">SwiftSyntax</st>`<st
    c="4821">, and it uses</st> <st c="4835">its capabilities.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4852">Before we dive into</st> `<st c="4873">SwiftSyntax</st>` <st c="4884">(and
    there’s enough to dive into it), let’s learn about how the Swift compiler works
    (</st>*<st c="4971">Figure 10</st>**<st c="4981">.1</st>*<st c="4983">):</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1: The Swift compiler process](img/B21795_figure_10.01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="4988">Figure 10.1: The Swift compiler process</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5027">Don’t fear the different expressions you see in</st> *<st c="5076">Figure
    10</st>**<st c="5085">.1</st>*<st c="5087">. This figure is a high-level overview
    of how the compiler takes our source code and generates machine code our device
    can run (the</st> `<st c="5219">*.o</st>` <st c="5222">files).</st> <st c="5231">We
    don’t have to understand every step in that flow, but knowing how it works is
    essential, especially where</st> `<st c="5340">SwiftSyntax</st>` <st c="5351">fits
    in</st> <st c="5360">the process.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5372">Let’s go over the</st> <st c="5391">steps together:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="5406">Parse and abstract syntax tree (AST)</st>**<st c="5443">: The</st>
    <st c="5449">compiler takes our source code and builds an AST.</st> <st c="5500">The
    AST represents our code hierarchical structure, including classes, structs, variables,</st>
    <st c="5591">and expressions.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="5607">Semantic analysis (sema)</st>**<st c="5632">: In this</st> <st
    c="5643">phase, the compiler takes our generated AST and performs semantic analysis.</st>
    <st c="5719">The analysis looks out for semantic issues in our code and goes over
    issues such as type-checking name resolutions and more (when we see “semantic”
    issues in our build phase; that’s the result of</st> <st c="5915">this phase).</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="5927">Swift Intermediate Language Generation (SILGen)</st>**<st c="5975">:
    In this phase, the compiler</st> <st c="6005">generates a representation that
    captures the semantic structure of</st> <st c="6073">the code.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="6082">Intermediate Representation Generation (IRGen)</st>**<st c="6129">:
    In IRGen, the</st> <st c="6145">compiler takes the SILGen result and</st> <st
    c="6183">converts it to a binary close to machine-level code.</st> <st c="6236">This
    process is done with the help</st> <st c="6270">of</st> **<st c="6274">Low-Level
    Virtual Machine</st>** <st c="6299">(</st>**<st c="6301">LLVM</st>**<st c="6305">),
    and the code goes through</st> <st c="6335">several optimizations.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="6357">LLVM linking</st>**<st c="6370">: The LLVM</st> <st c="6382">links
    everything together and prepares our code for the final</st> <st c="6444">binary
    creation.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="6460">The process may look scary and complex, but remember that this
    is a significant enrichment for us as iOS developers and is not required for Swift
    Macros understanding.</st> <st c="6629">I demonstrated it because of the first
    two steps – parse and AST.</st> <st c="6695">Let’s talk about them for</st> <st
    c="6721">a second.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6730">Parsing and AST</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="6746">Parsing Swift code</st> <st c="6765">is not an easy task.</st>
    <st c="6787">In addition, building the AST is even</st> <st c="6825">more complex.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6838">In the building process, we just saw the parsing, and the AST is
    handled by the</st> `<st c="6919">SwiftSyntax</st>` <st c="6930">library.</st>
    <st c="6940">So, when</st> <st c="6949">we work with the</st> `<st c="6966">SwiftSyntax</st>`
    <st c="6977">library, we have the full compiler capabilities.</st> <st c="7027">This
    means we can parse code, analyze it, and even generate new code like the compiler.</st>
    <st c="7115">The</st> `<st c="7119">SwiftSyntax</st>` <st c="7130">library is
    a powerful and essential tool when working with Swift macros because when we think
    of it, it is what Swift macros are all about – understanding the given code and
    generating a</st> <st c="7318">new one.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7326">We understand that learning SwiftSyntax is a prerequisite for writing
    Swift macros, so let’s</st> <st c="7420">dive in.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7428">Setting up SwiftSyntax</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`<st c="7451">SwiftSyntax</st>` <st c="7463">is a</st> **<st c="7469">Swift
    package</st>**<st c="7482">, meaning</st> <st c="7492">it can be linked easily
    to an existing iOS or</st> <st c="7538">macOS project.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7552">What is a Swift package?</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7577">A Swift package</st> <st c="7593">is a unit of code distribution
    in Swift.</st> <st c="7635">It’s a way to organize, share, and manage Swift code
    across</st> <st c="7695">different projects.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7714">To play with and</st> <st c="7731">learn</st> `<st c="7738">SwiftSyntax</st>`<st
    c="7749">, we will create a new project and add</st> `<st c="7788">SwiftSyntax</st>`
    <st c="7799">as a Swift package to that project, including a playground.</st>
    <st c="7860">To do so, follow</st> <st c="7877">these steps:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7889">Let’s start with opening Xcode and adding a</st> <st c="7934">new
    project.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="7946">Then, we’ll add our</st> `<st c="7967">SwiftSyntax</st>` <st c="7978">Swift
    package by selecting</st> **<st c="8006">File</st>** <st c="8010">|</st> **<st
    c="8013">Add</st>** **<st c="8017">Package Dependencies…</st>**<st c="8038">.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="8039">Now, we are in the adding dependencies window of Xcode (</st>*<st
    c="8096">Figure 10</st>**<st c="8106">.2</st>*<st c="8108">):</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.2: The adding dependencies Xcode window](img/B21795_figure_10.02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="9048">Figure 10.2: The adding dependencies Xcode window</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9097">Dependencies window?</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9118">If that’s the first time you’ve seen that window, then this is
    an excellent chance to perform a short introduction.</st> <st c="9235">When Swift
    Package Manager had just started, its management was completely manual, using</st>
    <st c="9324">the Terminal.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9337">Over the years, Swift Package Manager</st> <st c="9375">has become
    an integral part of Xcode, and now, it is even possible to manage collections
    and search for packages right</st> <st c="9495">from Xcode.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9506">You can learn</st> <st c="9520">more</st> <st c="9526">at</st>
    [<st c="9529">https://www.swift.org/documentation/package-manager/</st>](https://www.swift.org/documentation/package-manager/)<st
    c="9581">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9582">Back to</st> <st c="9591">Xcode – in the top-right corner of the
    adding dependencies window, we can fill the</st> `<st c="9674">SwiftSyntax</st>`
    <st c="9685">GitHub repository:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="9742">We will choose the</st> `<st c="9762">swift-syntax</st>` <st c="9774">package
    from the left column and click the</st> **<st c="9818">Add</st>** **<st c="9822">Package</st>**
    <st c="9829">button.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="9837">Xcode will now resolve the Swift package and present its libraries
    so we can choose what we want to import to our project (</st>*<st c="9961">Figure
    10</st>**<st c="9971">.3</st>*<st c="9973">):</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.3: Choosing the SwiftSyntax package products](img/B21795_figure_10.03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="10391">Figure 10.3: Choosing the SwiftSyntax package products</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10445">We will choose the</st> `<st c="10465">SwiftSyntax</st>` <st c="10476">library
    and click on the</st> `<st c="10542">SwiftSyntax</st>` <st c="10553">to</st> <st
    c="10557">our project!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10569">Now, let’s add a playground file (anywhere we like) and explore
    what</st> `<st c="10639">SwiftSyntax</st>` <st c="10650">is.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10654">Building our Abstract Syntax Tree</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="10688">To try and analyze a piece of</st> <st c="10719">Swift code using
    the</st> `<st c="10740">SwiftSyntax</st>` <st c="10751">library, we need to generate
    some Swift code and work</st> <st c="10806">on it.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10812">We open the playground file we created in the previous section,
    and add the</st> <st c="10889">following code:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: <st c="11011">Our code starts with importing two important libraries –</st>
    `<st c="11069">SwiftSyntax</st>` <st c="11080">and</st> `<st c="11085">SwiftSyntaxParser</st>`<st
    c="11102">. The</st> `<st c="11108">SwiftSyntaxParser</st>` <st c="11125">library
    contains the</st> `<st c="11147">SwiftParser</st>` <st c="11158">class, which
    helps convert a source code to a tree we can traverse</st> <st c="11226">and analyze.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11238">We added a string</st> <st c="11257">constant named</st> `<st
    c="11272">sourceCode</st>` <st c="11282">with a simple</st> *<st c="11297">“Hello
    World”</st>* <st c="11310">function to see how it works.</st> <st c="11341">Imagine
    that</st> `<st c="11354">sourceCode</st>` <st c="11364">represents the content
    of a</st> <st c="11393">Swift file.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11404">To parse the “Hello World” code, we’ll</st> <st c="11444">use</st>
    `<st c="11448">SwiftParser</st>`<st c="11459">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: <st c="11572">The parsing code is straightforward.</st> `<st c="11610">SyntaxParser</st>`
    <st c="11622">calls the parse method with our</st> `<st c="11655">sourceCode</st>`
    <st c="11665">constant from earlier and returns a syntax.</st> <st c="11710">But
    what is this syntax?</st> <st c="11735">Well, that’s our full code tree!</st>
    <st c="11768">The syntax variable is from the type</st> `<st c="11805">SourceFileSyntex</st>`<st
    c="11821">, and that type represents the syntax structure of our code.</st> <st
    c="11882">It’s the most high-level syntax node, encapsulating all our source code’s
    imports, classes,</st> <st c="11974">and functions.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11988">Now, it’s time to understand what this syntax tree</st> <st c="12040">looks
    like.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12051">Investigating the tree</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="12074">One of</st> <st c="12081">the best things about working with</st>
    **<st c="12117">Swift Playgrounds</st>** <st c="12134">is that it’s not only great
    for playing with code</st> <st c="12185">snippets but also for examining their
    results without having to place breakpoints in</st> <st c="12270">our code.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12279">After we run our</st> <st c="12297">Playground code, we can see
    the type</st> `<st c="12334">SourceFileSyntax</st>` <st c="12350">in the window’s
    right column.</st> <st c="12381">When we tap the small square next to it, we can
    see how the syntax constant is built (see</st> *<st c="12471">Figure 10</st>**<st
    c="12480">.4</st>*<st c="12482">):</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4: The syntax object structure](img/B21795_figure_10.04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="13432">Figure 10.4: The syntax object structure</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13472">It’s an excellent time to take a moment, run it for yourself,
    and try to understand what we see in</st> *<st c="13572">Figure 10</st>**<st c="13581">.4</st>*<st
    c="13583">. Notice that I marked all the</st> <st c="13614">juicy parts.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13626">The</st> <st c="13630">syntax instance contains a list of statements.</st>
    <st c="13678">A</st> **<st c="13680">statement</st>** <st c="13689">is</st> <st
    c="13693">everything we can work with – an import, a class declaration, or even
    an expression.</st> <st c="13778">A statement can contain its</st> <st c="13806">own
    statements.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13821">The base statement class is</st> `<st c="13850">CodeBlockItemListSyntax</st>`<st
    c="13873">, and each statement type comes with a different subclass</st> <st c="13931">of</st>
    `<st c="13934">CodeBlockItemListSyntax</st>`<st c="13957">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13958">In our case, we have one statement from the type of</st> `<st
    c="14011">FunctionDeclSyntax</st>`<st c="14029">, which indicates a</st> <st c="14049">function
    declaration.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14070">Expanding</st> `<st c="14081">FunctionDeclSyntax</st>` <st c="14099">reveals
    additional information about the function.</st> <st c="14151">For example, its
    name is represented by the</st> `<st c="14195">identifier</st>` <st c="14205">property
    (highlighted with a box in</st> *<st c="14242">Figure 10</st>**<st c="14251">.4</st>*<st
    c="14253">).</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="14256">FunctionDeclSyntax</st>` <st c="14275">has a</st> `<st c="14282">body</st>`
    <st c="14286">property, which contains the property of a statement with all the
    function statements, including the call for the</st> `<st c="14401">print</st>`
    <st c="14406">function.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14416">So, we can see that</st> `<st c="14437">SwiftParser</st>` <st
    c="14448">has done all the dirty work for us!</st> <st c="14485">Now that we have
    a tree, we can traverse it.</st> <st c="14530">Let’s extract the</st> <st c="14548">function
    statement:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: <st c="14677">In the preceding code, we are taking the first statement item
    and trying to convert it to a function</st> <st c="14779">declaration type.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14796">There are various declaration types, each providing specific tools
    to help us traverse and extract more information.</st> <st c="14914">Here are
    some of the most common types we can try</st> <st c="14964">to extract:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="14975">VariableDeclSyntax</st>`<st c="14994">: This is</st> <st c="15005">for
    variables</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="15018">EnumDeclSyntax</st>`<st c="15033">: This is for</st> <st c="15048">enum
    declaration</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="15064">ClassDeclSyntax</st>`<st c="15080">: This is for</st> <st c="15095">class
    declaration</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="15112">ProtocolDeclSyntax</st>`<st c="15131">: This is for</st> <st
    c="15146">protocol declaration</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="15166">TypealiasDeclSyntax</st>`<st c="15186">: This is for type</st>
    <st c="15206">alias declaration</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="15223">InitialzerDeclSyntax</st>`<st c="15244">: This is for</st> <st
    c="15259">construct declaration</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="15280">OperatorDeclSyntax</st>`<st c="15299">: This is for</st> <st
    c="15314">operator declaration</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="15334">These are just some</st> <st c="15354">syntax node types available
    in</st> `<st c="15386">SwiftSyntax</st>`<st c="15397">, and converting existing
    statement items to their corresponding types can provide us with the</st> <st
    c="15492">needed functionality.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15513">Let’s continue our code example and see what we can get</st> <st
    c="15570">from</st> `<st c="15575">FunctionDeclSyntax</st>`<st c="15593">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: <st c="15729">Let’s dissect the preceding code snippet to understand what it
    accomplishes.</st> <st c="15807">With a function declaration, we can dig in and
    try to analyze the different statements that it contains.</st> <st c="15912">In
    this instance, we can find a statement from the type of</st> `<st c="15971">FunctionCallExprSyntax</st>`<st
    c="15993">. This type represents a function call, specifically, a call</st> <st
    c="16054">to</st> `<st c="16057">print()</st>`<st c="16064">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16065">Now that we converted the statement to the right type, we can
    get more information</st> <st c="16149">about it:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`<st c="16395">funcCallExpression</st>` <st c="16414">has a</st> `<st c="16421">calledExpression</st>`
    <st c="16437">property that encapsulates the information about actual</st> <st
    c="16494">expression components.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="16516">firstToken</st>` <st c="16527">contains the</st> <st c="16540">function
    name itself.</st> <st c="16563">But what does “token” mean?</st> <st c="16591">Well,</st>
    `<st c="16736">text</st>` <st c="16740">property returns the</st> <st c="16762">function
    name.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16776">Next, we check if the function name is indeed</st> `<st c="16823">print</st>`<st
    c="16828">, and now we can check the value being printed by examining the function
    arguments list.</st> <st c="16917">Once we convert the first expression to</st>
    `<st c="16957">StringLiteralExprSyntax</st>`<st c="16980">, we can extract its
    first segment token and store it in the</st> `<st c="17041">value</st>` <st c="17046">constant.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17056">Does it sound confusing and a little bit cumbersome?</st> <st
    c="17110">Well, we should remember that the</st> `<st c="17144">SwiftSyntax</st>`
    <st c="17155">library is not considered easy to work with.</st> <st c="17201">It
    has a steep learning curve with many options</st> <st c="17249">and features.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17262">But this complexity is not a coincidence – parsing and analyzing
    programming language, especially an advanced and full-featured language such as
    Swift, is not simple.</st> <st c="17430">Just like we have</st> `<st c="17448">funcCallExpression</st>`<st
    c="17466">,</st> `<st c="17468">calledExpression</st>` <st c="17484">or</st> `<st
    c="17488">StringLiteralExprSyntax</st>`<st c="17511">, we have dozens of different
    types for different expressions.</st> <st c="17574">Looking at the</st> `<st c="17589">SwiftSyntax</st>`
    <st c="17600">documentation is the best way to learn to traverse and analyze more
    of</st> <st c="17672">the language.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17685">Now that we understand Swift code analysis using</st> `<st c="17735">SwiftSyntax</st>`<st
    c="17746">, let’s explore how we can leverage</st> `<st c="17782">SwiftSyntax</st>`
    <st c="17793">in the reverse direction – how to generate</st> <st c="17837">Swift
    code.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17848">Generating Swift Code</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="17870">Generating</st> <st c="17881">code in</st> `<st c="17890">SwiftSyntax</st>`
    <st c="17901">is based on the built-in types and string literals.</st> <st c="17954">We
    can try and structure Swift code just by creating</st> <st c="18007">strings instances:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'let initSyntax = try <st c="18190">InitializerDeclSyntax</st>("init(title:
    String)") { <st c="18238">ExprSyntax</st>("self.title = title")'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '@freestanding(expression)'
  prefs: []
  type: TYPE_NORMAL
- en: 'public macro stringify<T>(_ value: T) -> (T, String) = #externalMacro(module:
    "StructInitMacros",'
  prefs: []
  type: TYPE_NORMAL
- en: 'type: "StringifyMacro")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '#URL("https://swift.org/")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="23020">@StructInit</st> struct Book {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'var id: Int'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'var title: String'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'var subtitle: String'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'var description: String'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'var author: String'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '@attached(member)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '@attached(member, names: named(init))'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '@attached(member, names: named(rawValue))'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '@attached(member, names: arbitrary)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '@attached(member, names: named(init))'
  prefs: []
  type: TYPE_NORMAL
- en: 'public macro <st c="25373">StructInit</st>() = #externalMacro(module:'
  prefs: []
  type: TYPE_NORMAL
- en: '"<st c="25541">StructInit</st>.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="25552">The macro is short but tells a lot about its goal and behavior.</st>
    <st c="25617">Here comes the important part – the</st> <st c="25653">macro implementation.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="25674">Implementing the macro</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="25697">Unlike other Swift types, in</st> <st c="25727">macros, we separate
    our declaration and implementation into different files.</st> <st c="25804">In
    a way, it resembles Objective-C or C++, when the header and the implementation
    were</st> <st c="25891">other parts.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="25903">We will open our</st> `<st c="25921">StructInitMacros</st>` <st
    c="25937">file and clear its content for a clean start.</st> <st c="25984">Afterward,
    we can proceed to import the</st> <st c="26024">relevant libraries:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: <st c="26140">These are the standard libraries in most macros we will write.</st>
    <st c="26204">Notice that we have</st> `<st c="26224">SwiftSyntax</st>` <st c="26235">and</st>
    `<st c="26240">SwiftSyntaxBuilder</st>` <st c="26258">as part of what we’ve learned
    in the</st> *<st c="26296">Exploring</st>* *<st c="26306">SwiftSyntax</st>* <st
    c="26317">section.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="26326">Now, let’s move on to the main dish – the</st> `<st c="26369">StructInit</st>`
    <st c="26379">struct.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="26387">Declaring the StructInit struct</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="26419">In Swift Macros, Apple</st> <st c="26443">continues its trend
    of working mainly with structs and protocols instead of classes</st> <st c="26527">and
    inheritance.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="26543">To implement a new macro, we will add a new struct with the macro
    name that conforms to a protocol</st> <st c="26643">named</st> `<st c="26649">MemberMacro</st>`<st
    c="26660">:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: <st c="26796">The compiler looks for a struct with an identical name to the
    macro name we declared earlier under the</st> *<st c="26900">Adding a new Swift
    macro</st>* <st c="26924">section.</st> <st c="26934">We also declared the</st>
    `<st c="26955">StructInit</st>` <st c="26965">as</st> `<st c="26969">public</st>`
    <st c="26975">– remember that a macro is part of a Swift package, so we need to
    have it accessible from other modules</st> <st c="27080">as well.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="27088">So, what is the</st> `<st c="27105">MemberMacro</st>` <st c="27116">protocol?</st>
    <st c="27127">The</st> `<st c="27131">MemberMacro</st>` <st c="27142">protocol
    contains one crucial function that performs the expansion operation, with the
    non-surprising name</st> <st c="27250">of</st> `<st c="27253">expansion()</st>`<st
    c="27264">.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="27265">However, we won’t use</st> `<st c="27288">MemberMacro</st>` <st
    c="27299">every time we create a macro, as it is relevant only to the macro’s</st>
    `<st c="27368">attached(member)</st>` <st c="27384">role.</st> <st c="27391">Each
    role has a different protocol we need to</st> <st c="27437">conform to.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="27448">Here is the list of the different roles and their</st> <st c="27499">corresponding
    protocol:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<st c="27522">@freestanding(expression) -></st>` `<st c="27552">ExpressionMacro</st>`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="27567">@freestanding(declaration) -></st>` `<st c="27598">DeclarationMacro</st>`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="27614">@attached(peer) -></st>` `<st c="27634">PeerMacro</st>`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="27643">@attached(accessor) -></st>` `<st c="27667">AccessorMacro</st>`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="27680">@attached(memberAttribute) -></st>` `<st c="27711">MemberAttributeMacro</st>`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="27731">@attached(member) -></st>` `<st c="27753">MemberMacro</st>`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="27764">@attached(conformance) -></st>` `<st c="27791">ConformanceMacro</st>`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="27807">Since we are building a</st> <st c="27831">Swift macro with the</st>
    `<st c="27853">@attached(member)</st>` <st c="27870">role, we will focus only
    on</st> `<st c="27899">MemberMacro</st>`<st c="27910">, even though the concept
    is similar to the</st> <st c="27954">other protocols.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="27970">Let’s go over</st> <st c="27985">it together!</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="27997">Implementing the expansion function</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="28033">I’ll start by</st> <st c="28048">showing you the</st> `<st c="28064">expansion</st>`
    <st c="28073">function:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: <st c="28269">While the function may look a little bit complex, we need to remember</st>
    <st c="28340">two things:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="28351">Most types mentioned in the function signature should already
    be recognizable to us, as they are components of the</st> `<st c="28467">SwiftSyntax</st>`
    <st c="28478">library.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="28487">There’s only one function in this protocol.</st> <st c="28532">No
    need to implement</st> <st c="28553">another one!</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="28565">The</st> `<st c="28570">expansion</st>` <st c="28579">function
    aims to receive information about the attached object or the macro parameters
    and return a piece of Swift code, represented by an array of</st> `<st c="28728">SwiftSyntax</st>`
    <st c="28739">expressions (</st>`<st c="28753">DeclSyntax</st>`<st c="28764">).</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="28767">The expansion function has</st> <st c="28795">three parameters:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<st c="28812">node: AtributeSyntax</st>`<st c="28833">: This node represents
    that actual macro in the original piece of</st> <st c="28900">Swift code.</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`<st c="28911">declaration: some DeclGroupSyntax</st>`<st c="28945">: The declaration
    struct that describes the struct/class the macro is</st> <st c="29016">attached
    to.</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`<st c="29028">context: some MacroExpansionContext</st>`<st c="29064">: The
    context provides us with more information about the compiler.</st> <st c="29133">Remember
    that the compiler serves as the “environment” in which the</st> <st c="29201">macro
    functions.</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="29217">Now, we can start creating our struct</st> `<st c="29256">init</st>`
    <st c="29260">method.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="29268">First, we need to have a list of all the struct properties, including
    names and types.</st> <st c="29356">To do that, we need to analyze the code using</st>
    `<st c="29402">SwiftSyntax</st>`<st c="29413">, which we just learned in this
    chapter ( in the</st> *<st c="29462">Exploring</st>* *<st c="29472">SwiftSyntax</st>*
    <st c="29483">section).</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="29493">So, let’s get</st> <st c="29507">all the struct information that</st>
    <st c="29540">we need:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: <st c="29855">Let’s explain the preceding code, line</st> <st c="29895">by line:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="29903">We use the declaration parameter to get all the</st> <st c="29952">struct
    members.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="29967">All the struct members also include their functions, so we filter
    it only</st> <st c="30042">to variables.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="30055">We create an array of all the variable’s names using their</st>
    `<st c="30115">pattern</st>` <st c="30122">attribute.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="30133">We create another variety with all the variable types, using their</st>
    `<st c="30201">typeAnnotation</st>` <st c="30215">attribute.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="30226">Now that we have all the information we need, we can generate
    our Swift code for the</st> `<st c="30312">init</st>` <st c="30316">function.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="30326">First, we generate the</st> `<st c="30350">init</st>` <st c="30354">function
    signature based on the list of variable names</st> <st c="30410">and types:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: <st c="30573">The preceding code starts by creating a mutable string, looping
    all the variable names and types, and adding them to the function signature.</st>
    <st c="30714">Once the code adds all the function parameters, it closes with a</st>
    <st c="30779">closing parenthesis.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="30799">Next, it’s time to</st> <st c="30819">add the function body.</st>
    <st c="30842">We can do that using a special</st> `<st c="30873">SwiftSyntax</st>`
    <st c="30884">struct that represents an initializer declaration</st> <st c="30935">called</st>
    `<st c="30942">InitializerDeclSyntax</st>`<st c="30963">:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: <st c="31121">The</st> `<st c="31126">InitializerDeclSyntax</st>` <st c="31147">“init”
    function receives two parameters – the function signature and a closure with the
    “init” body represented</st> <st c="31260">by</st> `<st c="31263">ExprSyntax</st>`<st
    c="31273">.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="31274">Now that we have</st> `<st c="31292">initializer</st>`<st c="31303">,
    we can return an array</st> <st c="31328">of</st> `<st c="31331">DeclSyntax</st>`<st
    c="31341">:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: <st c="31376">Let’s see the</st> <st c="31391">full code:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: <st c="32030">The code takes the struct list of variables and generates its
    own</st> `<st c="32097">init</st>` <st c="32101">function.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="32111">How does it look?</st> <st c="32130">Let’s</st> <st c="32135">demonstrate
    that with a</st> <st c="32160">small struct:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: <st c="32219">The</st> `<st c="32224">expansion</st>` <st c="32233">method</st>
    <st c="32241">creates the following</st> `<st c="32263">init</st>` <st c="32267">function:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: <st c="32342">But the fact that we just defined the macro behavior doesn’t mean
    we can use it.</st> <st c="32424">Remember that the macro runs as a compiler plugin.</st>
    <st c="32475">That’s our</st> <st c="32486">next step.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="32496">Adding the compiler plugin</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="32523">The compiler plugin is our</st> <st c="32551">macro “product,”
    or, in other words, the macro</st> <st c="32598">entry point.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '<st c="32610">In iOS, macros are invoked in a sandbox without network access
    and system file changes.</st> <st c="32699">The question is this: How does the
    compiler instantiate and store Swift macros to be used as</st> <st c="32792">a
    plugin?</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="32801">The answer is that it doesn’t.</st> <st c="32833">If we have another
    look at our code, we’ll notice that Swift Macros functions are all static, and
    that’s an important issue when creating a</st> <st c="32973">new macro.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="32983">So, to create a compiler plugin, we need to define a new struct
    that conforms to the</st> `<st c="33069">CompilerPlugin</st>` <st c="33083">protocol
    and has the</st> `<st c="33105">@main</st>` <st c="33110">attribute mark:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: <st c="33243">The preceding code shows that</st> `<st c="33274">struct_initial_macroPlugin</st>`
    <st c="33300">implements one variable</st> `<st c="33325">get</st>` <st c="33328">method
    –</st> `<st c="33338">providingMacros</st>` <st c="33353">– and returns an array
    of macro types instead</st> <st c="33400">of instances.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="33413">Another essential thing to notice here is the struct name (</st>`<st
    c="33473">struct_initial_macroPlugin</st>`<st c="33500">).</st> <st c="33504">It
    doesn’t matter what name we give it as long as it conforms</st> <st c="33566">to
    the</st> `<st c="33573">CompilerPlugin</st>` <st c="33587">protocol and has the</st>
    `<st c="33609">@</st>``<st c="33610">main</st>` <st c="33614">attribute.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="33625">Now that we have a compiler plugin, our compiler is ready to</st>
    <st c="33687">run it.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="33694">Running our macro using a client</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="33727">Macro executables are</st> <st c="33749">different than apps or
    libraries since they run in a compiler environment.</st> <st c="33825">If we go
    back in our chapter to the section where we create the Swift Macros Swift package
    (</st>*<st c="33917">Examining our Swift Macros package structure</st>* <st c="33962">section),
    we see that the Swift macro has another folder</st> <st c="34020">called</st>
    `<st c="34027">StructInitClient</st>`<st c="34043">.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<st c="34044">StructInitClient</st>` <st c="34061">is our Swift macro executable,
    also defined in the macro’s</st> `<st c="34121">package.swift</st>` <st c="34134">manifest
    file:</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: <st c="34220">Now, we can change the code we have in the</st> `<st c="34264">main.swift</st>`
    <st c="34274">file to</st> <st c="34283">the following:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: <st c="34455">In the preceding</st> <st c="34473">code, we have a simple struct
    named</st> `<st c="34509">Book</st>`<st c="34513">, but now, we have also attached
    the</st> `<st c="34550">@StructInit</st>` <st c="34561">macro we</st> <st c="34571">just
    created.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="34584">Right-click on the macro itself and choose</st> **<st c="34628">Expand
    Macro</st>**<st c="34640">, which reveals the generated code (</st>*<st c="34676">Figure
    10</st>**<st c="34686">.8</st>*<st c="34688">):</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.8: Swift macro expansion](img/B21795_figure_10.08.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: '<st c="35057">Figure 10.8: Swift macro expansion</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="35091">Using our macro executable is a great way to see our macro in
    action!</st> <st c="35162">At this point, everything should work as expected.</st>
    <st c="35213">It’s time to level up our macro implementation with some</st> <st
    c="35270">error handling.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="35285">Handling macros errors</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="35308">When we create a</st> <st c="35326">Swift macro, things obvious
    to us, as the macro developers, are not obvious to our</st> <st c="35409">macro
    users.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="35421">Our</st> `<st c="35426">StructInit</st>` <st c="35436">macro is
    designed to function exclusively with structs, not classes.</st> <st c="35506">Therefore,
    we need to check whether the attached element is indeed</st> <st c="35573">a struct.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="35582">Inside the</st> `<st c="35594">expansion()</st>` <st c="35605">function,
    we can perform a simple</st> `<st c="35640">guard</st>` <st c="35645">statement
    and throw an error in case the attached declaration is not</st> <st c="35715">a
    struct:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: <st c="35828">In the preceding code,</st> `<st c="35852">StructInitError</st>`
    <st c="35867">is an enum that conforms</st> <st c="35893">to</st> `<st c="35896">Error</st>`<st
    c="35901">:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: <st c="36097">Having an enum</st> <st c="36113">with different error types and
    messages can make a developer’s life much easier.</st> <st c="36194">Remember
    that this error appears in compile time (</st>*<st c="36244">Figure 10</st>**<st
    c="36254">.9</st>*<st c="36256">):</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.9: An error message is thrown when implementing a Swift macro](img/B21795_figure_10.09.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: '<st c="36309">Figure 10.9: An error message is thrown when implementing a Swift
    macro</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="36380">But sometimes, we want to handle more complex errors.</st> <st
    c="36435">For example, sometimes we want to show a warning, not just an error.</st>
    <st c="36504">Or, in other cases, we even want to offer our developer a fix for</st>
    <st c="36570">their problem.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="36584">In these cases, we can</st> <st c="36608">add something called
    a</st> `<st c="36631">Diagnostic</st>` <st c="36641">struct.</st> <st c="36650">A</st>
    `<st c="36652">Diagnostic</st>` <st c="36662">struct is more suitable for showing
    errors in a compiler environment and has more capabilities than just</st> <st
    c="36768">throwing errors.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="36784">Let’s create a</st> `<st c="36800">DiagnosticMessage</st>` <st
    c="36817">enum and a</st> `<st c="36829">Diagnostic</st>` <st c="36839">struct:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: context.diagnose(diagnostic)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: guard let structDecl = declaration.as(StructDeclSyntax.self) else {
  prefs: []
  type: TYPE_NORMAL
- en: 'let diagnostic = Diagnostic(node: node,'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'message: MyLibDiagnostic.notAStruct) <st c="37870">context.diagnose(diagnostic)</st>
    throw StructInitError.onlyAStruct'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'let testMacros: [String: Macro.Type] = ['
  prefs: []
  type: TYPE_NORMAL
- en: '"StructInit": StructInit.self,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: 'final class StructInitTests: XCTestCase {'
  prefs: []
  type: TYPE_NORMAL
- en: func testMacro() {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assertMacroExpansion(
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"""'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '@StructInit'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: struct Book {
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'var id: Int'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'var title: String'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'var subtitle: String'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '""",'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'expandedSource:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"""'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: struct Book {
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'var id: Int'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'var title: String'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'var subtitle: String'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'init(id: Int, title: String,'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'subtitle: String) {'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: self.id = id
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: self.title = title
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: self.subtitle = subtitle
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '""",'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'macros: testMacros'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
