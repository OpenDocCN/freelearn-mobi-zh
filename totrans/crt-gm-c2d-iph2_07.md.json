["```swift\n// Audio definitions\n#define SND_BUTTON @\"button.caf\"\n\n// Box2D definition\n#define PTM_RATIO 32\n\n// Define the pocket's tag\n#define kPocket 500\n\ntypedef enum {\n    kBallNone = -1,\n    kBallCue = 0,\n    kBallOne,\n    kBallTwo,\n    kBallThree,\n    kBallFour,\n    kBallFive,\n    kBallSix,\n    kBallSeven,\n    kBallEight,\n    kBallNine,\n    kBallTen,\n    kBallEleven,\n    kBallTwelve,\n    kBallThirteen,\n    kBallFourteen,\n    kBallFifteen\n} BallID;\n\ntypedef enum {\n    kRackTriangle = 50,\n    kRackDiamond,\n    kRackFailed\n} RackLayoutType;\n\ntypedef enum {\n    kStripes = 100,\n    kSolids,\n    kOrdered,\n    kStripesVsSolids,\n    kNone\n} GameMode;\n```", "```swift\n-(void) initWorld\n{\n  b2Vec2 gravity;\n  gravity.Set(0.0f, 0.0f);\n  world = new b2World(gravity);\n\n  // Do we want to let bodies sleep?\n  world->SetAllowSleeping(true);\n  world->SetContinuousPhysics(true);\n\n    // Create contact listener\n    contactListener = new OPContactListener();\n    world->SetContactListener(contactListener);\n}\n```", "```swift\n-(void) createRailWithImage:(NSString*)img atPos:(CGPoint)pos withVerts:(b2Vec2*)verts {\n    // Create the rail\n    PhysicsSprite *rail = [PhysicsSprite\n                 spriteWithSpriteFrameName:img];\n    [rail setPosition:pos];\n    [poolsheet addChild: rail];\n\n    // Create rail body\n    b2BodyDef railBodyDef;\n    railBodyDef.type = b2_staticBody;\n    railBodyDef.position.Set(pos.x/PTM_RATIO, \n                             pos.y/PTM_RATIO);\n    railBodyDef.userData = rail;\n    b2Body *railBody = world->CreateBody(&railBodyDef);\n\n    // Store the body in the sprite\n    [rail setPhysicsBody:railBody];\n\n    // Build the fixture\n    b2PolygonShape railShape;\n    int num = 4;\n\n    railShape.Set(verts, num);\n\n    // Create the shape definition and add it to the body\n    b2FixtureDef railShapeDef;\n    railShapeDef.shape = &railShape;\n    railShapeDef.density = 50.0f;\n    railShapeDef.friction = 0.3f;\n    railShapeDef.restitution = 0.5f;\n    railBody->CreateFixture(&railShapeDef);  \n}\n```", "```swift\n-(void) createRails {\n    // Top left rail\n    CGPoint railPos1 = ccp(58,338);\n    b2Vec2 vert1[] = {\n        b2Vec2(5.5f / PTM_RATIO, -84.0f / PTM_RATIO),\n        b2Vec2(4.5f / PTM_RATIO, 80.0f / PTM_RATIO),\n        b2Vec2(-5.5f / PTM_RATIO, 87.0f / PTM_RATIO),\n        b2Vec2(-5.5f / PTM_RATIO, -87.0f / PTM_RATIO)\n    };\n    [self createRailWithImage:@\"rail1.png\" atPos:railPos1 withVerts:vert1];\n\n    // Bottom left rail\n    CGPoint railPos2 = ccp(58,142);\n    b2Vec2 vert2[] = {\n        b2Vec2(5.5f / PTM_RATIO, 84.5f / PTM_RATIO),\n        b2Vec2(-5.5f / PTM_RATIO, 86.5f / PTM_RATIO),\n        b2Vec2(-5.5f / PTM_RATIO, -86.5f / PTM_RATIO),\n        b2Vec2(5.5f / PTM_RATIO, -78.5f / PTM_RATIO)\n    };\n    [self createRailWithImage:@\"rail2.png\" atPos:railPos2 withVerts:vert2];\n\n    // Bottom rail\n    CGPoint railPos3 = ccp(160,44);\n    b2Vec2 vert3[] = {\n        b2Vec2(-88.5f / PTM_RATIO, -5.5f / PTM_RATIO),\n        b2Vec2(88.5f / PTM_RATIO, -5.5f / PTM_RATIO),\n        b2Vec2(81.5f / PTM_RATIO, 5.5f / PTM_RATIO),\n        b2Vec2(-81.5f / PTM_RATIO, 5.5f / PTM_RATIO)\n    };    \n    [self createRailWithImage:@\"rail3.png\" atPos:railPos3 withVerts:vert3];\n\n    // Bottom right rail\n    CGPoint railPos4 = ccp(262,142);\n    b2Vec2 vert4[] = {\n        b2Vec2(5.5f / PTM_RATIO, -86.0f / PTM_RATIO),\n        b2Vec2(5.5f / PTM_RATIO, 86.0f / PTM_RATIO),\n        b2Vec2(-5.5f / PTM_RATIO, 85.0f / PTM_RATIO),\n        b2Vec2(-5.5f / PTM_RATIO, -78.0f / PTM_RATIO)\n    };    \n    [self createRailWithImage:@\"rail4.png\" atPos:railPos4 withVerts:vert4];\n\n    // Top right rail\n    CGPoint railPos5 = ccp(262,338);\n    b2Vec2 vert5[] = {\n        b2Vec2(5.5f / PTM_RATIO, 86.5f / PTM_RATIO),\n        b2Vec2(-5.5f / PTM_RATIO, 78.5f / PTM_RATIO),\n        b2Vec2(-5.5f / PTM_RATIO, -85.5f / PTM_RATIO),\n        b2Vec2(5.5f / PTM_RATIO, -86.5f / PTM_RATIO)\n    };    \n    [self createRailWithImage:@\"rail5.png\" atPos:railPos5 withVerts:vert5];\n\n    // Top rail\n    CGPoint railPos6 = ccp(160,436);\n    b2Vec2 vert6[] = {\n        b2Vec2(89.0f / PTM_RATIO, 6.0f / PTM_RATIO),\n        b2Vec2(-89.0f / PTM_RATIO, 6.0f / PTM_RATIO),\n        b2Vec2(-82.0f / PTM_RATIO, -5.0f / PTM_RATIO),\n        b2Vec2(81.0f / PTM_RATIO, -5.0f / PTM_RATIO)\n    };    \n    [self createRailWithImage:@\"rail6.png\" atPos:railPos6 withVerts:vert6];\n}\n```", "```swift\n-(void) createPocketAtPos:(CGPoint)pos {\n    // Create sprite and add it to layer\n    CCSprite *pocket = [CCSprite\n           spriteWithSpriteFrameName:@\"whitespeck.png\"];\n    pocket.position = pos;\n    pocket.tag = kPocket;\n    [pocket setColor:ccBLACK];\n    [self addChild:pocket z:0];\n\n    // Create a pocket body\n    b2BodyDef pocketBodyDef;\n    pocketBodyDef.type = b2_dynamicBody;\n    pocketBodyDef.position.Set(pos.x/PTM_RATIO, \n                             pos.y/PTM_RATIO);\n    pocketBodyDef.userData = pocket;\n    b2Body *pocketBody = world->CreateBody(&pocketBodyDef);\n\n    //Create a circle shape\n    b2CircleShape circle;\n    circle.m_radius = 7.0/PTM_RATIO;\n\n    //Create fixture definition and add to body\n    b2FixtureDef pocketFixtureDef;\n    pocketFixtureDef.shape = &circle;\n    pocketFixtureDef.isSensor = YES;\n\n    pocketBody->CreateFixture(&pocketFixtureDef);\n}\n```", "```swift\n-(void) createPockets {\n    // Left top pocket\n    [self createPocketAtPos:ccp(57,437)];\n\n    // Left middle pocket\n    [self createPocketAtPos:ccp(52,240)];\n\n    // Left bottom pocket\n    [self createPocketAtPos:ccp(57,43)];\n\n    // Right top pocket\n    [self createPocketAtPos:ccp(265,437)];\n\n    // Right middle pocket\n    [self createPocketAtPos:ccp(272,240)];\n\n    // Right bottom pocket\n    [self createPocketAtPos:ccp(265,43)];\n}\n```", "```swift\n-(void) createPoolCue {\n    poolcue = [CCSprite\n         spriteWithSpriteFrameName:@\"cue_stick.png\"];\n    [poolcue setAnchorPoint:ccp(0.5,1)];\n    [poolcue setVisible:NO];\n    [poolsheet addChild:poolcue z:50];\n}\n```", "```swift\n#import <Foundation/Foundation.h>\n#import \"cocos2d.h\"\n#import \"OPDefinitions.h\"\n\n@interface OPRulesBase : CCNode {\n    RackLayoutType rackStyle;\n    BallID lastBall;\n    BOOL orderedBalls;\n    GameMode gameMode;\n    BOOL replaceBalls;\n    BOOL isBreak;\n    GameMode player1Goal;\n    GameMode player2Goal;\n    BallID nextOrderedBall; // Number of next ball\n    NSInteger currentPlayer;\n    BOOL isTableScratch;\n}\n\n@property (nonatomic, assign) RackLayoutType rackStyle;\n@property (nonatomic, assign) BallID lastBall;\n@property (nonatomic, assign) BOOL orderedBalls;\n@property (nonatomic, assign) GameMode gameMode;\n@property (nonatomic, assign) BOOL replaceBalls;\n@property (nonatomic, assign) NSInteger currentPlayer;\n@property (nonatomic, assign) BOOL isTableScratch;\n@property (nonatomic, assign) GameMode player1Goal;\n@property (nonatomic, assign) GameMode player2Goal;\n@property (nonatomic, assign) BallID nextOrderedBall;\n\n-(id) initWithRulesForGame:(NSString*)gameName;\n-(BOOL) isLegalFirstHit:(BallID)firstBall;\n-(BOOL) didSinkValidBall:(NSArray*)ballArray;\n-(BOOL) didSinkLastBall:(NSArray*)ballArray;\n-(BOOL) didSinkCueBall:(NSArray*)ballArray;\n-(BOOL) isValidLastBall:(NSArray*)ballsSunk\n           withBallsOnTable:(NSArray*)ballsOnTable;\n-(void) findNextOrderedBall:(NSArray*)tableBalls;\n\n@end\n```", "```swift\n-(id) initWithRulesForGame:(NSString*)gameName {\n    if(self = [super init]) {\n        // Load the rules for the game chosen\n        [self loadRulesWith:gameName];\n\n        isTableScratch = NO;\n        isBreak = YES;\n    }\n    return self;\n}\n```", "```swift\n-(id) readPlist:(NSString*) fileName {\n  NSData *plistData;\n  NSString *error;\n  NSPropertyListFormat format;\n  id plist;\n\n    // Assumes filename is part of the main bundle\n  NSString *localizedPath = [[NSBundle mainBundle]\n            pathForResource:fileName ofType:@\"plist\"];\n  plistData = [NSData dataWithContentsOfFile:localizedPath];\n  plist = [NSPropertyListSerialization\n            propertyListFromData:plistData\n            mutabilityOption:NSPropertyListImmutable\n            format:&format errorDescription:&error];\n\n  if (!plist) {\n    NSLog(@\"Error reading plist from file '%s', error '%s'\",\n            [localizedPath UTF8String], [error UTF8String]);\n  }\n  return plist;\n}\n\n-(NSDictionary*)getDictionaryFromPlist:(NSString*)fileName {\n    return (NSDictionary*)[self readPlist:fileName];\n}\n```", "```swift\n-(void) loadRulesWith:(NSString*)listKey {\n    // Load the rules plist\n    NSDictionary *ruleBook = [NSDictionary\n                dictionaryWithDictionary:\n                [self getDictionaryFromPlist:@\"rules\"]];\n    NSDictionary *theseRules = [NSDictionary\n                dictionaryWithDictionary:\n                [ruleBook objectForKey:listKey]];\n    self.rackStyle = [self convertRackType:\n                [theseRules objectForKey:@\"RackStyle\"]];\n    self.lastBall = (BallID)[[theseRules\n                objectForKey:@\"LastBall\"] integerValue];\n    self.orderedBalls = [[theseRules\n                objectForKey:@\"OrderedBalls\"] boolValue];\n    self.gameMode = [self convertGameMode:[theseRules\n                objectForKey:@\"GameMode\"]];\n    self.replaceBalls = [[theseRules\n                objectForKey:@\"ReplaceBalls\"] boolValue];\n\n    player1Goal = gameMode;\n    player2Goal = gameMode;\n\n    if (self.gameMode == kOrdered) {\n        nextOrderedBall = kBallOne;\n    }\n\n    currentPlayer = 1;\n}\n```", "```swift\n-(RackLayoutType) convertRackType:(NSString*)rackStr {\n    if ([rackStr isEqualToString:@\"kRackDiamond\"]) {\n        return kRackDiamond;\n    } else if ([rackStr isEqualToString:@\"kRackTriangle\"]) {\n        return kRackTriangle;\n    } else {\n        NSLog(@\"unknown rack type %@ in the plist.\", rackStr);\n    }\n    return kRackFailed;\n}\n\n-(GameMode) convertGameMode:(NSString*)gameStr {\n    if ([gameStr isEqualToString:@\"Ordered\"]) {\n        return kOrdered;\n    }\n    else if ([gameStr isEqualToString:@\"StripesVsSolids\"]) {\n        return kStripesVsSolids;\n    }\n    return kNone;\n}\n```", "```swift\n-(void) createBall:(BallID)ballID AtPos:(CGPoint)startPos {\n    // Create the filename\n    NSString *ballImg = [NSString\n                      stringWithFormat:@\"ball_%i.png\",ballID];\n\n    // Create sprite and add it to layer\n    OPBall *ball = [OPBall spriteWithSpriteFrameName:ballImg];\n    ball.position = startPos;\n    ball.tag = ballID;\n    [self addChild:ball z:10];\n\n    // Create ball body\n    b2BodyDef ballBodyDef;\n    ballBodyDef.type = b2_dynamicBody;\n    ballBodyDef.position.Set(startPos.x/PTM_RATIO,\n                             startPos.y/PTM_RATIO);\n    ballBodyDef.userData = ball;\n    b2Body *ballBody = world->CreateBody(&ballBodyDef);\n\n    // Store the body in the sprite\n    [ball setPhysicsBody:ballBody];\n\n    //Create a circle shape\n    b2CircleShape circle;\n    circle.m_radius = 7.5/PTM_RATIO;  // 7.5 point radius\n\n    //Create fixture definition and add to body\n    b2FixtureDef ballFixtureDef;\n    ballFixtureDef.shape = &circle;\n    ballFixtureDef.density = 1.0f;\n    ballFixtureDef.friction = 0.5f;\n    ballFixtureDef.restitution = 0.9f;\n\n    ballBody->CreateFixture(&ballFixtureDef);\n    ballBody->SetFixedRotation(false);\n    ballBody->SetLinearDamping(0.7f);\n    ballBody->SetAngularDamping(0.5f);\n    ballBody->SetBullet(TRUE);\n\n    if (ballID == kBallCue) {\n        cueBallBody = ballBody;\n    }\n}\n```", "```swift\n-(void) createRackWithLayout:(RackLayoutType)rack {\n    // Define the standard ball positions\n    CGPoint footSpot = ccp(160,335);\n    CGPoint r1b1 = ccp(153,348);\n    CGPoint r1b2 = ccp(167,348);\n    CGPoint r2b1 = ccp(146,361);\n    CGPoint r2b2 = ccp(160,361);\n    CGPoint r2b3 = ccp(174,361);\n    CGPoint r3b1 = ccp(139,374);\n    CGPoint r3b2 = ccp(153,374);\n    CGPoint r3b3 = ccp(167,374);\n    CGPoint r3b4 = ccp(181,374);\n    CGPoint r4b1 = ccp(132,388);\n    CGPoint r4b2 = ccp(146,388);\n    CGPoint r4b3 = ccp(160,388);\n    CGPoint r4b4 = ccp(174,388);\n    CGPoint r4b5 = ccp(188,388);\n\n    switch (rack) {\n        case kRackTriangle:\n            // Build a standard triangle rack\n            [self createBall:kBallNine AtPos:footSpot];\n            [self createBall:kBallSeven AtPos:r1b1];\n            [self createBall:kBallTwelve AtPos:r1b2];\n            [self createBall:kBallFifteen AtPos:r2b1];\n            [self createBall:kBallEight AtPos:r2b2];\n            [self createBall:kBallOne AtPos:r2b3];\n            [self createBall:kBallSix AtPos:r3b1];\n            [self createBall:kBallTen AtPos:r3b2];\n            [self createBall:kBallThree AtPos:r3b3];\n            [self createBall:kBallFourteen AtPos:r3b4];\n            [self createBall:kBallEleven AtPos:r4b1];\n            [self createBall:kBallTwo AtPos:r4b2];\n            [self createBall:kBallThirteen AtPos:r4b3];\n            [self createBall:kBallFour AtPos:r4b4];\n            [self createBall:kBallFive AtPos:r4b5];\n            break;\n        case kRackDiamond:\n            // Build a diamond rack\n            [self createBall:kBallOne AtPos:footSpot];\n            [self createBall:kBallFive AtPos:r1b1];\n            [self createBall:kBallSeven AtPos:r1b2];\n            [self createBall:kBallEight AtPos:r2b1];\n            [self createBall:kBallNine AtPos:r2b2];\n            [self createBall:kBallThree AtPos:r2b3];\n            [self createBall:kBallTwo AtPos:r3b2];\n            [self createBall:kBallSix AtPos:r3b3];\n            [self createBall:kBallFour AtPos:r4b3];\n            break;\n        default:\n            break;\n    }\n}\n```", "```swift\n-(void) createPlayerScores {\n    CCLabelTTF *player1 = [CCLabelTTF\n                           labelWithString:@\"P1\"\n                           fontName:@\"Verdana\"\n                           fontSize:14];\n    [player1 setPosition:ccp(20,460)];\n    [self addChild:player1];\n\n    CCLabelTTF *player2 = [CCLabelTTF\n                           labelWithString:@\"P2\"\n                           fontName:@\"Verdana\"\n                           fontSize:14];\n    [player2 setPosition:ccp(300,460)];\n    [self addChild:player2];\n\n    player1TargetLbl = [CCLabelTTF\n                        labelWithString:@\" \"\n                        fontName:@\"Verdana\" fontSize:8];\n    [player1TargetLbl setPosition:ccp(20,440)];\n    [self addChild:player1TargetLbl z:2];\n\n    player2TargetLbl = [CCLabelTTF\n                        labelWithString:@\" \"\n                        fontName:@\"Verdana\" fontSize:8];\n    [player2TargetLbl setPosition:ccp(300,440)];\n    [self addChild:player2TargetLbl z:2];\n    markPlayer = [CCSprite spriteWithSpriteFrameName:\n                  @\"whitespeck.png\"];\n    [markPlayer setColor:ccGREEN];\n    [markPlayer setPosition:ccp(20,450)];\n    [markPlayer setScaleX:10 * CC_CONTENT_SCALE_FACTOR()];\n    [self addChild:markPlayer z:2];\n\n    // Update the display\n    if ([rules orderedBalls]) {\n        CCLabelTTF *nextBallLbl = [CCLabelTTF\n                            labelWithString:@\"Next Ball\"\n                            fontName:@\"Verdana\"\n                            fontSize:12];\n        [nextBallLbl setPosition:ccp(122,470)];\n        [self addChild:nextBallLbl z:100];\n    }\n}\n```", "```swift\n-(void) updatePlayerGoals {\n    // Update the stripes/solids display for the players\n    if ([rules player1Goal] == kStripes) {\n        [player1TargetLbl setString:@\"Stripes\"];\n        [player2TargetLbl setString:@\"Solids\"];\n    } else if ([rules player1Goal] == kSolids) {\n        [player1TargetLbl setString:@\"Solids\"];\n        [player2TargetLbl setString:@\"Stripes\"];\n    }\n\n    // Update the display\n    if ([rules orderedBalls]) {\n        // Update the ordered ball goals, if applicable\n        [rules findNextOrderedBall:\n                    [self ballSpritesOnTable]];\n        if (nextGoal != nil) {\n            [nextGoal removeFromParentAndCleanup:YES];\n        }\n        // Create the filename\n        NSString *ballImg = [NSString stringWithFormat:\n                        @\"ball_%i.png\",\n                        (BallID)[rules nextOrderedBall]];\n        // Create sprite and add it to layer\n        nextGoal = [CCSprite spriteWithSpriteFrameName:\n                    ballImg];\n        [nextGoal setPosition:ccp(160,470)];\n        [self addChild:nextGoal]; \n    }\n}\n```", "```swift\n-(NSArray*) ballSpritesOnTable {\n    // Returns an array of all ball sprites on the table\n    NSMutableArray *currentBalls = [[[NSMutableArray alloc]\n                          initWithCapacity:16] autorelease];\n\n    for(b2Body *b = world->GetBodyList(); b;b=b->GetNext()) {\n        if (b->GetUserData() != nil) {\n            OPBall *aBall = (OPBall*)b->GetUserData();\n            if (aBall.tag < 100) {\n                [currentBalls addObject:aBall];\n            }\n        }\n    }\n    return currentBalls;\n}\n```", "```swift\n-(void) playerChange {\n    if ([rules currentPlayer] == 1) {\n        [self displayMessage:@\"Player 2's turn\" userDismiss:NO];\n        [rules setCurrentPlayer:2];\n        [markPlayer setPosition:ccp(300,450)];\n    } else {\n        [self displayMessage:@\"Player 1's turn\" userDismiss:NO];\n        [rules setCurrentPlayer:1];\n        [markPlayer setPosition:ccp(20,450)];\n    }\n}\n```", "```swift\n-(void) displayMessage:(NSString*)msg\n             userDismiss:(BOOL)userDismiss {\n    // If there is a current message, wait for it\n    if (isDisplayingMsg) {\n        CCDelayTime *del = [CCDelayTime\n                            actionWithDuration:0.1];\n        CCCallBlock *retry = [CCCallBlock\n                              actionWithBlock:^{\n          [self displayMessage:msg\n                   userDismiss:userDismiss];\n        }];\n        [self runAction:[CCSequence actions:del,\n                         retry, nil]];\n        return;\n    }\n    isDisplayingMsg = YES;\n    isUserDismissMsg = userDismiss;\n\n    // Create the message label & display it\n    message = [CCLabelTTF labelWithString:msg\n                                 fontName:@\"Verdana\"\n                                 fontSize:20];\n    [message setPosition:ccp(size.width/2,\n                             size.height/2)];\n    [self addChild:message z:20];\n\n    // If userDismiss is NO, set a 2 second destruct\n    if (userDismiss == NO) {\n        CCDelayTime *wait = [CCDelayTime\n                             actionWithDuration:2.0f];\n        CCCallFunc *dismiss = [CCCallFunc\n                    actionWithTarget:self\n                    selector:@selector(dismissMessage)];\n        [self runAction:[CCSequence actions:wait,\n                         dismiss, nil]];\n    }\n}\n```", "```swift\n-(void) dismissMessage {\n    isDisplayingMsg = NO;\n    [message removeFromParentAndCleanup:YES];\n}\n```", "```swift\n-(void) update: (ccTime) dt\n{\n  int32 velocityIterations = 30;\n  int32 positionIterations = 30;\n\n  // Instruct the world to perform a single step\n  world->Step(dt, velocityIterations, positionIterations);\t\n\n    // Evaluate all contacts\n    std::vector<b2Body *>toDestroy;\n  std::vector<OPContact>::iterator pos;\n  for (pos = contactListener->_contacts.begin();\n     pos != contactListener->_contacts.end(); pos++) {\n    OPContact contact = *pos;\n\n        // Get the bodies involved in this contact\n    b2Body *bodyA = contact.fixtureA->GetBody();\n    b2Body *bodyB = contact.fixtureB->GetBody();\n\n        // Get the sprites attached to these bodies\n        CCSprite *spriteA = (CCSprite*)bodyA->GetUserData();\n        CCSprite *spriteB = (CCSprite*)bodyB->GetUserData();\n```", "```swift\n        // Look for balls touching the pocket sensor\n        if ([spriteA isMemberOfClass:[OPBall class]] &&\n            spriteB.tag == kPocket) {\n            if (std::find(toDestroy.begin(),\n                          toDestroy.end(),\n                          bodyA) == toDestroy.end()) {\n                toDestroy.push_back(bodyA);\n            }\n        }\n        // Check the same collision with opposite A/B\n        else if (spriteA.tag == kPocket && [spriteB\n                    isMemberOfClass:[OPBall class]]) {\n            if (std::find(toDestroy.begin(),\n                          toDestroy.end(),\n                          bodyB) == toDestroy.end()) {\n                toDestroy.push_back(bodyB);\n            }\n        }\n        if ([spriteA isMemberOfClass:[OPBall class]] &&\n            [spriteB isMemberOfClass:[OPBall class]]) {\n            // Two balls collided\n            // Let's store the FIRST collision\n            if ((spriteA.tag == kBallCue ||\n                 spriteB.tag == kBallCue) &&\n                firstHit == kBallNone) {\n                if (spriteA.tag == kBallCue) {\n                    firstHit = (BallID)spriteB.tag;\n                } else {\n                    firstHit = (BallID)spriteA.tag;\n                }\n            }\n        }\n  }    \n```", "```swift\n    // Destroy any bodies & sprites we need to get rid of\n    std::vector<b2Body *>::iterator pos2;\n    for(pos2 = toDestroy.begin(); pos2 != toDestroy.end();\n                                                  ++pos2) {\n        b2Body *body = *pos2;\n        if (body->GetUserData() != NULL) {\n            OPBall *sprite = (OPBall *) body->GetUserData();\n            [self sinkBall:sprite];\n        }        \n        world->DestroyBody(body);\n    }\n\n    if ([self isTableMoving]) {\n        self.isTouchBlocked = YES;\n    } else {\n        self.isTouchBlocked = NO;\n\n        // Table is done.  Let's resolve the action.\n        if (pendingTable) {\n            [self checkTable];\n            pendingTable = NO;\n        }\n    }\n}\n```", "```swift\n-(void) sinkBall:(OPBall*)thisBall {\n\n    // Keep the ball in the temp array\n    [ballsSunk addObject:thisBall];\n\n    // Destroy The Sprite\n    [thisBall removeFromParentAndCleanup:YES];\n}\n```", "```swift\n-(BOOL) isTableMoving {\n    for(b2Body *b = world->GetBodyList(); b;b=b->GetNext()) {\n        // See if the body is still noticeably moving\n        b2Vec2 vel = b->GetLinearVelocity();\n\n        if (vel.Length() > 0.005f) {\n            return YES;\n        }\n    }\n    return NO;\n}\n```", "```swift\n@class OPPlayfieldLayer;\n\n@interface OPControlBase : CCLayer {\n    OPPlayfieldLayer *mp; // Main playfield\n    float shotLength; // Length of the stroke\n    CGPoint plannedHit; // Where the cue will hit\n    CCLabelTTF *shootButton; // Only used by 2 touch\n    CGPoint aimAtPoint; // Point the cue will aim at\n    CCSprite *cueBallInHand; // For placing the cue ball\n}\n\n@property (nonatomic, assign) OPPlayfieldLayer *mp;\n@property (nonatomic, assign) float shotLength;\n@property (nonatomic, assign) CGPoint plannedHit;\n@property (nonatomic, assign) CGPoint aimAtPoint;\n\n-(void) updateCueAimFromLoc:(CGPoint)convLoc;\n-(void) hideCue;\n\n@end\n```", "```swift\n-(void) updateCueAimFromLoc:(CGPoint)convLoc {\n    // Position the cue at the cue ball\n    CGPoint offset = ccpSub(aimAtPoint,convLoc);\n    CGPoint approach = ccpNormalize(offset);\n\n    // Move the cue into the right angle\n    [mp.poolcue setPosition:ccpSub(aimAtPoint, offset)];\n    [mp.poolcue setVisible:YES];\n    [mp.poolcue setRotation:\n     (-1 * CC_RADIANS_TO_DEGREES(\n                            ccpToAngle(approach))) + 90];\n\n    // Calculate the power of the hit\n    shotLength = sqrtf((offset.x* offset.x) +\n                       (offset.y*offset.y)) - 4.5;\n\n    // We limit how far away the cue can be\n    if (shotLength > 75 || shotLength < 4) {\n        // We reject this hit\n        [self hideCue];\n        return;\n    } else {\n        // Calculate the planned hit\n        float hitPower = shotLength / 6;\n        plannedHit = ccp(hitPower * approach.x,\n                         hitPower * approach.y);\n        mp.isHitReady = YES;\n        shootButton.visible = YES;\n    }\n}\n```", "```swift\n-(void) hideCue {\n    // Hide the pool cue\n    [mp.poolcue setPosition:CGPointZero];\n    [mp.poolcue setVisible:NO];\n    [mp.poolcue setOpacity:255];\n\n    // There is not a valid hit\n    // Reset all hit vars\n    mp.isHitReady = NO;\n    plannedHit = CGPointZero;\n    shotLength = 0;\n\n    // Hide the shoot button\n    shootButton.visible = NO;\n}\n```", "```swift\n-(BOOL) ccTouchBegan:(UITouch *)touch withEvent:(UIEvent *)event {\n    // Reject touches for now\n    if (mp.isTouchBlocked) {\n        return NO;\n    }\n    if (mp.isUserDismissMsg) {\n        [mp dismissMessage];\n        [mp setIsUserDismissMsg:NO];\n        return NO;\n    }\n    // The next touch returns to the menu\n    if (mp.isGameOver) {\n        [mp returnToMainMenu];\n        return YES;\n    }\n    // Determine touch position\n    CGPoint loc = [touch locationInView:[touch view]];\n    CGPoint convLoc = [[CCDirector sharedDirector]\n                       convertToGL:loc];\n    // If there was a scratch, the cue is in hand\n    if (mp.isBallInHand) {\n        cueBallInHand = [CCSprite\n             spriteWithSpriteFrameName:@\"ball_0.png\"];\n        [cueBallInHand setPosition:convLoc];\n        [mp addChild:cueBallInHand z:10];\n        return YES;\n    }\n    // Check if the touch is on the table\n    if (CGRectContainsPoint([[mp table] boundingBox],\n             convLoc)) {\n        // Store the point we are aiming at\n        aimAtPoint = [mp getCueBallPos];\n\n        // Update the cue position\n        [self updateCueAimFromLoc:convLoc];\n        return YES;\n    }\n    return NO;\n}\n```", "```swift\n-(void)ccTouchMoved:(UITouch *)touch withEvent:(UIEvent *)event {\n    // Determine touch position\n    CGPoint loc = [touch locationInView:[touch view]];\n    CGPoint convLoc = [[CCDirector sharedDirector]\n                       convertToGL:loc];\n    // If there was a scratch, the cue is in hand\n    if (mp.isBallInHand) {\n        [cueBallInHand setPosition:convLoc];\n        return;\n    }\n    [self updateCueAimFromLoc:convLoc];\n}\n```", "```swift\n-(void) ccTouchEnded:(UITouch *)touch withEvent:(UIEvent *)event {\n    // If there was a scratch, the cue is in hand\n    if (mp.isBallInHand) {\n        [mp createBall:kBallCue AtPos:[cueBallInHand\n                                            position]];\n        [cueBallInHand removeFromParentAndCleanup:YES];\n        mp.isBallInHand = NO;\n    }\n    // Only make the shot if it is in the legal range\n    if (shotLength > 75 || shotLength < 4) {\n        // Reject the shot\n    }\n    else {\n        // Take the shot\n        [mp makeTheShot];\n    }\n}\n```", "```swift\n-(void) makeTheShot {\n    // Reset the \"first hit\" var\n    firstHit = kBallNone;\n\n    // The controller tells us where to aim\n    CGPoint aimPoint = [contr aimAtPoint];\n\n    // Set up the pool cue animation\n    CCMoveTo *move = [CCMoveTo actionWithDuration:0.05\n                                         position:aimPoint];\n    CCCallBlock *hitIt = [CCCallBlock actionWithBlock:^{\n        // Get ready to hit the ball\n        b2Vec2 impulse = b2Vec2(contr.plannedHit.x,\n                                contr.plannedHit.y);\n        b2Vec2 aim = b2Vec2(aimPoint.x / PTM_RATIO,\n                            aimPoint.y / PTM_RATIO);\n        // Hit it\n        cueBallBody->ApplyLinearImpulse(impulse, aim);\n    }];\n    CCDelayTime *wait = [CCDelayTime actionWithDuration:0.1];\n    CCFadeOut *fadeCue = [CCFadeOut actionWithDuration:0.4];\n    CCCallBlock *checkTbl = [CCCallBlock actionWithBlock:^{\n        pendingTable = YES;\n    }];\n    CCCallFunc *hideCue = [CCCallFunc actionWithTarget:contr\n                            selector:@selector(hideCue)];\n    [poolcue runAction:[CCSequence actions:move, hitIt,\n                     wait, fadeCue, hideCue, checkTbl,  nil]];\n}\n```", "```swift\n-(id) init {\n    if(self = [super init]) {\n        shootButton = [CCLabelTTF labelWithString:@\"Shoot!\"\n                 fontName:@\"Verdana\" fontSize:20];\n        [shootButton setAnchorPoint:ccp(0.5,0)];\n        [shootButton setPosition:ccp(160,0)];\n        [shootButton setVisible:NO];\n        [self addChild:shootButton z:10];\n    }\n    return self;\n}\n```", "```swift\n-(BOOL) ccTouchBegan:(UITouch *)touch withEvent:(UIEvent *)event {\n    // Reject touches for now\n    if (mp.isTouchBlocked) {\n        return NO;\n    }\n    if (mp.isUserDismissMsg) {\n        [mp dismissMessage];\n        [mp setIsUserDismissMsg:NO];\n        return YES;\n    }\n    // If game over splash is finished, next touch\n    // returns to the menu\n    if (mp.isGameOver) {\n        [mp returnToMainMenu];\n        return YES;\n    }\n    // Determine touch position\n    CGPoint loc = [touch locationInView:[touch view]];\n    CGPoint convLoc = [[CCDirector sharedDirector]\n                       convertToGL:loc];\n    // If there was a scratch, the cue is in hand\n    if (mp.isBallInHand) {\n        cueBallInHand = [CCSprite\n           spriteWithSpriteFrameName:@\"ball_0.png\"];\n        [cueBallInHand setPosition:convLoc];\n        [mp addChild:cueBallInHand z:10];\n        return YES;\n    }\n    // If we are tracking the aim\n    aimAtPoint = [mp getCueBallPos];\n    // Check if the Shoot Button was touched\n    if (CGRectContainsPoint([shootButton boundingBox],\n                   convLoc)) {\n        [mp makeTheShot];\n        return YES;\n    }\n    // Check if the touch is on the table\n    if (CGRectContainsPoint([[mp table] boundingBox],\n                   convLoc)) {\n        // Update the cue position\n        [self updateCueAimFromLoc:convLoc];\n        return YES;\n    }\n    return NO;\n}\n```", "```swift\n-(void)ccTouchMoved:(UITouch *)touch withEvent:(UIEvent *)event {\n    // Determine touch position\n    CGPoint loc = [touch locationInView:[touch view]];\n    CGPoint convLoc = [[CCDirector sharedDirector]\n                       convertToGL:loc];\n\n    // If there was a scratch, the cue is in hand\n    if (mp.isBallInHand) {\n        [cueBallInHand setPosition:convLoc];\n        return;\n    }\n\n    // If not ball in hand, control the cue\n    [self updateCueAimFromLoc:convLoc];\n}\n```", "```swift\n-(void)ccTouchEnded:(UITouch *)touch withEvent:(UIEvent *)event {\n    // If there was a scratch, the cue is in hand\n    if (mp.isBallInHand) {\n        [mp createBall:kBallCue AtPos:[cueBallInHand position]];\n        [cueBallInHand removeFromParentAndCleanup:YES];\n        mp.isBallInHand = NO;\n    }\n}\n```", "```swift\n-(GameMode) getCurrentPlayerGoal {\n    if (currentPlayer == 1) {\n        return player1Goal;\n    } else {\n        return player2Goal;\n    }\n}\n```", "```swift\n-(BOOL) didSinkLastBall:(NSArray*)ballArray {\n    for (OPBall *aBall in ballArray) {\n        if (aBall.tag == lastBall) {\n            return YES;\n        }\n    }\n    // Last ball not sunk\n    return NO;\n}\n```", "```swift\n-(BOOL) didSinkCueBall:(NSArray*)ballArray {\n    for (OPBall *aBall in ballArray) {\n        if (aBall.tag == kBallCue) {\n            return YES;\n        }\n    }\n    // Cue ball not sunk\n    return NO;\n}\n```", "```swift\n-(BOOL) isLegalFirstHit:(BallID)firstBall {\n    // Reset the value\n    isTableScratch = NO;\n\n    if (firstBall == kBallNone) {\n        // Table scratch if nothing touched\n        isTableScratch = YES;\n        return NO;\n    }\n    GameMode currGoal = [self getCurrentPlayerGoal];\n\n    switch (currGoal) {\n        case kStripesVsSolids:\n            // lastBall cannot be hit first\n            return firstBall != kBallEight;\n        case kStripes:\n            // Striped ball hit first to be legal.\n            return firstBall > kBallEight;\n        case kSolids:\n            // Solid ball hit first to be legal.\n            return firstBall < kBallEight;\n        case kOrdered:\n            if (firstBall == nextOrderedBall || isBreak) {\n                // The correct next number was hit first,\n                // Or this was the break shot\n                isBreak = NO;\n                return YES;\n            }\n            break;\n        default:\n            // No goal set, all balls are legal\n            return NO;\n            break;\n    }\n    return NO;\n}\n```", "```swift\n-(BOOL) didSinkValidBall:(NSArray*)ballArray {\n    GameMode currGoal = [self getCurrentPlayerGoal];\n\n    for (OPBall *aBall in ballArray) {\n        switch (currGoal) {\n            case kStripes:\n                // Striped ball dropped to be legal.\n                return aBall.tag > kBallEight;\n            case kSolids:\n                // Solid ball dropped to be legal.\n                return aBall.tag < kBallEight;\n            case kOrdered:\n                // The correct next number must be sunk.\n                return aBall.tag == nextOrderedBall;\n            case kStripesVsSolids:\n                // lastBall cannot be hit first\n                // everything else is valid\n                if (aBall.tag == lastBall) {\n                    return NO;\n                } else {\n                    return YES;\n                }\n                break;\n            default:\n                // No goal set, all balls are legal\n                return NO;\n                break;\n        }\n    }\n    return NO;\n}\n```", "```swift\n-(BOOL) isValidLastBall:(NSArray*)ballsSunk\n           withBallsOnTable:(NSArray*)ballsOnTable {\n    // Are all other balls for this player sunk already?\n    GameMode currGoal = [self getCurrentPlayerGoal];\n\n    switch (currGoal) {\n        case kSolids:\n            for (OPBall *aBall in ballsOnTable) {\n                if (aBall.tag < lastBall) {\n                    // Solids left on table.  Illegal.\n                    return NO;\n                }\n            }\n            return YES;\n            break;\n        case kStripes:\n            for (OPBall *aBall in ballsOnTable) {\n                if (aBall.tag > lastBall && aBall.tag < 100) {\n                    // Solids left on table.  Illegal.\n                    return NO;\n                }\n            }\n            return YES;\n            break;\n        case kOrdered:\n            for (OPBall *aBall in ballsOnTable) {\n               if (aBall.tag != lastBall && aBall.tag < 100) {\n                    // Balls left on table.  Illegal.\n                    return NO;\n               }\n            }\n            return YES;\n            break;\n        default:\n            return NO;\n            break;\n    }\n    return NO;\n}\n```", "```swift\n-(void) findNextOrderedBall:(NSArray*)tableBalls {\n    // Look for each ball, from lowest to highest\n    for (int i = 1; i < 16; i++) {\n        for (OPBall *aBall in tableBalls) {\n            if (aBall.tag == i) {\n                nextOrderedBall = (BallID)i;\n                return;\n            }\n        }\n    }\n}\n```", "```swift\n-(void)putBallsBackOnTable:(NSMutableArray*)ballArray {\n    // We put the balls we need back on the table,\n    // following racking positions, if the rules specify\n    if ([rules replaceBalls]) {\n        NSMutableArray *deleteArray = \n                 [[NSMutableArray alloc] init];\n\n        // First we make sure the cue is NOT in the array\n        for (OPBall *aBall in ballArray) {\n            // If it is, we add it to the delete array\n            if (aBall.tag == kBallCue) {\n                [deleteArray addObject:aBall];\n            }\n        }\n\n        // Delete any flagged balls from the array\n        [ballArray removeObjectsInArray:deleteArray];\n        [deleteArray release];\n        CGPoint footSpot = ccp(160,335);\n\n        CGPoint r1b1 = ccp(153,348);\n        CGPoint r1b2 = ccp(167,348);\n\n        CGPoint r2b1 = ccp(146,361);\n        CGPoint r2b2 = ccp(160,361);\n        CGPoint r2b3 = ccp(174,361);\n\n        for (int i = 0; i < [ballArray count]; i++) {\n            OPBall *thisBall = [ballArray objectAtIndex:i];\n            BallID newBall = (BallID)thisBall.tag;\n\n            switch (i) {\n                case 0:\n                    // foot spot\n                    [self createBall:newBall AtPos:footSpot];\n                    break;\n                case 1:\n                    // r1b1\n                    [self createBall:newBall AtPos:r1b1];\n                    break;\n                case 2:\n                    // r1b2\n                    [self createBall:newBall AtPos:r1b2];\n                    break;\n                case 3:\n                    // r2b1\n                    [self createBall:newBall AtPos:r2b1];\n                    break;\n                case 4:\n                    // r2b2\n                    [self createBall:newBall AtPos:r2b2];\n                    break;\n                case 5:\n                    // r2b3\n                    [self createBall:newBall AtPos:r2b3];\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n}\n```", "```swift\n-(void) checkTable {\n    NSInteger currPlayer = [rules currentPlayer];\n\n    BOOL isValidFirst = NO;\n    BOOL isValidSink = NO;\n    BOOL isLastBall = NO;\n    BOOL isTableScratch = NO;\n    BOOL isScratch = NO;\n    BOOL replaceBalls = NO;\n    BOOL isPlayerChange = NO;\n    BOOL isValidLastBall = NO;\n    BOOL playerLoses = NO;\n\n    isValidFirst = [rules isLegalFirstHit:firstHit];\n    isValidSink = [rules didSinkValidBall:ballsSunk];\n    isTableScratch = [rules isTableScratch];\n    isLastBall = [rules didSinkLastBall:ballsSunk];\n    isScratch = [rules didSinkCueBall:ballsSunk];\n    isValidLastBall = [rules isValidLastBall:ballsSunk\n           withBallsOnTable:[self ballSpritesOnTable]];\n```", "```swift\n    if (isLastBall) {\n        if (isValidLastBall) {\n            if (isScratch) {\n                // Player loses\n                playerLoses = YES;\n            } else {\n                // Player wins\n                isGameOver = YES;\n                [self gameOverWithWinner:\n                    [rules currentPlayer]];\n                return;\n            }\n        } else {\n            // player loses\n            playerLoses = YES;\n        }\n    }\n    if (playerLoses) {\n        isGameOver = YES;\n        [self displayMessage:@\"Fail!\" userDismiss:NO];\n        [self gameOverWithLoser:[rules currentPlayer]];\n        return;\n    }\n```", "```swift\n    if (isScratch) {\n        [self displayMessage:@\"Scratched\" userDismiss:NO];\n        [self displayMessage:@\"Place the cue ball\"\n                   userDismiss:NO];\n        replaceBalls = YES;\n        isBallInHand = YES;\n        isPlayerChange = YES;\n    }\n    else if (isTableScratch) {\n        replaceBalls = YES;\n        [self displayMessage:@\"table scratch\" userDismiss:NO];\n        isPlayerChange = YES;\n    }\n    else if (isValidFirst == NO) {\n        replaceBalls = YES;\n        [self displayMessage:@\"wrong first ball hit\"\n                 userDismiss:NO];\n        isPlayerChange = YES;\n    }\n```", "```swift\n    else if (isValidSink) {\n        if (currPlayer == 1) {\n            [p1BallsSunk addObjectsFromArray:ballsSunk];\n\n            // If there is nothing set, choose\n            if ([rules player1Goal] == kStripesVsSolids) {\n                OPBall *aBall = [p1BallsSunk objectAtIndex:0];\n                if (aBall.tag < 8) {\n                    [rules setPlayer1Goal:kSolids];\n                    [rules setPlayer2Goal:kStripes];\n                } else {\n                    [rules setPlayer1Goal:kStripes];\n                    [rules setPlayer2Goal:kSolids];\n                }\n            }\n        }\n        else {\n            [p2BallsSunk addObjectsFromArray:ballsSunk];\n\n            // If there is nothing set, choose\n            if ([rules player2Goal] == kStripesVsSolids) {\n                OPBall *aBall = [p2BallsSunk objectAtIndex:0];\n                if (aBall.tag < 8) {\n                    [rules setPlayer2Goal:kSolids];\n                    [rules setPlayer1Goal:kStripes];\n                } else {\n                    [rules setPlayer2Goal:kStripes];\n                    [rules setPlayer1Goal:kSolids];\n                }\n            }\n        }\n    } else {\n        // Nothing dropped, but the hit was OK.\n        // Change players\n        isPlayerChange = YES;\n    }\n\n    // If we need to put balls back on the table\n    if (replaceBalls) {\n        [self putBallsBackOnTable:ballsSunk];\n    }\n\n    if (isPlayerChange) {\n        [self playerChange];\n    }\n\n    // Clear the array for the next turn\n    [ballsSunk removeAllObjects];\n\n    // Update goal displays as needed\n    [self updatePlayerGoals];\n}\n```", "```swift\n-(id) initWithControl:(NSString*)controls andRules:(NSString*)gameRules {\n    if(self = [super init]) {\n        size = [[CCDirector sharedDirector] winSize];\n\n        // Load the spritesheet\n        [[CCSpriteFrameCache sharedSpriteFrameCache]\n             addSpriteFramesWithFile:@\"poolsheet.plist\"];\n        poolsheet = [CCSpriteBatchNode\n             batchNodeWithFile:@\"poolsheet.png\"];\n\n        // Add the batch node to the layer\n        [self addChild:poolsheet z:1];\n\n        table = [CCSprite\n           spriteWithSpriteFrameName:@\"table.png\"];\n        [table setPosition:ccp(size.width/2, size.height/2)];\n        [poolsheet addChild:table];\n\n        isGameOver = NO;\n        isTouchBlocked = NO;\n        isHitReady = NO;\n        firstHit = kBallNone;\n\n        ballsSunk = [[NSMutableArray alloc] init];\n        p1BallsSunk = [[NSMutableArray alloc] init];\n        p2BallsSunk = [[NSMutableArray alloc] init];\n        // Start up the interface control structure\n        if ([controls isEqualToString:@\"One Touch\"]) {\n            // Add the controls\n            contr = [[OPControlOneTouch alloc] init];\n        } else if ([controls isEqualToString:@\"Two Touch\"])  {\n            // Add the controls\n            contr = [[OPControlTwoTouch alloc] init];\n        } else {\n            [self displayMessage:@\"Failed To Find Controls\"\n                        userDismiss:YES];\n        }\n        contr.mp = self;\n        [self addChild:contr z:20];\n\n        // Load the rules\n        rules = [[OPRulesBase alloc]\n                 initWithRulesForGame:gameRules];\n\n        // Set up the Box2D world\n        [self initWorld];\n\n        // Build the table features\n        [self createRails];\n        [self createPockets];\n\n        [self createPoolCue];\n        [self createPlayerScores];\n\n        // Cue ball setup\n        [self displayMessage:@\"Place the cue ball\"\n                     userDismiss:NO];\n        isBallInHand = YES;\n\n        // Build the variable elements\n        [self createRackWithLayout:rules.rackStyle];\n\n        // Update goal displays\n        [self updatePlayerGoals];\n\n        // Schedule the update method\n        [self scheduleUpdate];\n    }\n    return self;\n}\n```"]