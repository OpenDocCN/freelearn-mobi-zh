<html><head></head><body><p>&#13;
&#13;
                            &#13;
                    Building iOS Apps with Swift&#13;
                &#13;
            &#13;
            &#13;
                &#13;
<p>In this chapter, we'll be building our very own iOS app using Swift and the Xcode IDE. Once we've built our app, we'll look at how we can incorporate unit tests and <strong>user interface</strong> (<strong>UI</strong>) tests. Finally, we'll take a look at backward compatibility in Swift and iOS development.</p>&#13;
<p>In this chapter, we will cover the following recipes:</p>&#13;
<ul>&#13;
<li>Building an iOS App using Cocoa Touch</li>&#13;
<li>Unit and integration testing with XCTest</li>&#13;
<li>User interface testing with XCUITest</li>&#13;
<li>Backward compatibility</li>&#13;
</ul>&#13;
<p>Let's get started!</p>&#13;
<h1 id="uuid-a3c96c09-1352-42a5-8f01-95af134b996f">Technical requirements</h1>&#13;
<p>For this chapter, you'll need the latest version of Xcode from the Mac App Store.</p>&#13;
<p>All the code for this chapter can be found in this book's GitHub repository at <a href="https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter06" target="_blank">https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter06</a></p>&#13;
<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3pMG44r" target="_blank">https://bit.ly/3pMG44r</a></p>&#13;
<h1 id="uuid-4617c720-64ca-441f-bc76-64ba6ee103c8" class="p3">Building an iOS App using Cocoa Touch</h1>&#13;
<p class="p1">The focus of this book is ultimately on the Swift programming language itself, as opposed to the use of the language to produce apps for Apple platforms or to build server-side services. That being said, it can't be ignored that the vast majority of the Swift code being written is to build, or build upon, iOS and iPadOS apps.</p>&#13;
<p class="p1">In this recipe, we will take a brief look at how we can interact with Apple's Cocoa Touch frameworks using Swift and begin to build and create our very own iOS app.</p>&#13;
<p class="p1"><strong>Cocoa Touch</strong> is a name given to the collection of UI frameworks available as part of the iOS SDK. Its name derives from the Cocoa framework on macOS, which provides UI elements for macOS apps. While Cocoa on macOS is a framework in its own right, Cocoa Touch is a collection of frameworks that provide UI elements for iOS apps and handle the app's life cycle; the core of these frameworks is <strong>UIKit</strong>.</p>&#13;
<h2 id="uuid-26da8a25-25fa-4942-be82-6878aa4a9a76" class="p1">Getting ready</h2>&#13;
<p class="p1">First, we'll need to create a new iOS app project:</p>&#13;
<ol>&#13;
<li class="p1">From the Xcode menu, choose File, then New.</li>&#13;
<li class="p1">From the dialog box that opens, choose App from the iOS tab:</li>&#13;
</ol>&#13;
<div><img src="img/9d0443fb-bcc3-4271-8a5b-f29776d14047.png" style="" width="629" height="480"/></p>&#13;
<p>Figure 6.1 – Choosing a template </p>&#13;
<ol start="3">&#13;
<li class="p1">The next dialog box asks you to enter details about your app, pick a product name and organization name, and add an organization identifier in reverse DNS style.</li>&#13;
</ol>&#13;
<p style="padding-left: 60px" class="p1">Reverse DNS style means to take a website that you or your company owns and reverse the order of the domain name components. So, for example, <a href="http://maps.google.com">http://maps.google.com</a> becomes <kbd>com.google.maps</kbd>:</p>&#13;
<div><img src="img/e9408b6c-f725-42c2-819e-38505ba39b10.png" width="509" height="429"/></div>&#13;
<p>Figure 6.2 – Options for a new project</p>&#13;
<p style="padding-left: 60px" class="p1">Pay attention to the preceding choices as not all of them may be selected by default. For this recipe, the ones that are important to us are <strong>Interface</strong> and <strong>Include Tests</strong>, both of which we'll cover later on this in the chapter when we look at unit testing with XCTest and user interface testing with XCUITest.</p>&#13;
<ol start="4">&#13;
<li class="p1">Once you've chosen a save location on your Mac, you will be presented with the following Xcode layout:</li>&#13;
</ol>&#13;
<div><img src="img/5faac001-b8c2-4ba1-8e15-2c701e61a944.png" width="1146" height="743"/></div>&#13;
<p>Figure 6.3 – New project template</p>&#13;
<p class="p1">Here, we have the start of our project – it's not much, but it's where all new iOS apps begin.</p>&#13;
<p class="p1">From this menu, press <strong>Product</strong> | <strong>Run</strong>. Xcode will now compile and run your app in a simulator.</p>&#13;
<h2 id="uuid-06066d2b-67b2-459c-8bd3-4a645e4cdfb2" class="p1">How to do it...</h2>&#13;
<p class="p1">Continuing from a previous recipe, we'll build our app based on data that is returned from the Public GitHub API:</p>&#13;
<ol>&#13;
<li class="p1">In the File Explorer, click on Main.storyboard; this view is a representation of what the app will look like and is called Interface Builder. At the moment, there is only one blank screen visible, which matches what the app looked like when we ran it earlier. This screen represents a <kbd>View Controller</kbd> object; as the name suggests, this is an object that controls views.</li>&#13;
<li class="p1">We will display our list of repositories in a table. We actually want to create a view controller class that is a subclass of <kbd>UITableViewController</kbd>. So, from the menu, choose File, then New, and select a Cocoa Touch Class template:</li>&#13;
</ol>&#13;
<div><img src="img/d3b6cd05-c7f8-45d7-84dc-41449151fb0f.png" style="" width="711" height="509"/></div>&#13;
<p>Figure 6.4 – New file template</p>&#13;
<ol start="3">&#13;
<li class="p1">We will be displaying repositories in this view controller, so let's call it <kbd>ReposTableViewController</kbd>. Specify that it's a subclass of <kbd>UITableViewController</kbd> and ensure that the language is Swift:</li>&#13;
</ol>&#13;
<div><img src="img/5f93a8a2-25f9-4865-9869-05a4e38af8b6.png" style="" width="439" height="262"/></div>&#13;
<p>Figure 6.5 – New filename and subclass</p>&#13;
<p style="padding-left: 60px" class="p1">Now that we have created our view controller class, let's switch back to <kbd>Main.storyboard</kbd> and delete the blank view controller that was created for us.</p>&#13;
<ol start="4">&#13;
<li class="p1">From the object library, find the Table View Controller option and drag it into the Interface Builder editor:</li>&#13;
</ol>&#13;
<div><img src="img/a7c67a2b-ea93-4e2a-ab48-86624c08414d.png" style="" width="630" height="248"/></div>&#13;
<p>Figure 6.6 – Object library</p>&#13;
<ol start="5">&#13;
<li class="p1">Now that we have a table view controller, we want this controller to be part of our custom subclass. To do this, select the controller, go into the class inspector, enter <kbd>ReposTableViewController</kbd> as the Class type, and press <em>Enter</em>:</li>&#13;
</ol>&#13;
<div><img src="img/e95442cb-b8d9-4c44-966f-872d167a4451.png" style="" width="260" height="236"/></div>&#13;
<p>Figure 6.7: Custom class inspector</p>&#13;
<p class="p1">Although we have the view controller that will be displaying the repository names, when a user selects a repository, we want to present a new view controller that will show details about that particular repo. We will cover what type of view controller that is and how we present it shortly, but first, we need a mechanism for navigating between view controllers.</p>&#13;
<p>If you have ever used an iOS app, you will be familiar with the standard <em><strong>push</strong></em> and <em><strong>pop</strong></em> way of navigating between views. The following screenshot shows an app in the middle of that transition:</p>&#13;
<div><img src="img/5200aebe-b4c3-4185-85a2-be040038a1a7.png" style="" width="750" height="1334"/></div>&#13;
<p>Figure 6.8 – Push and pop view controller</p>&#13;
<p class="p1">The management of these view controllers, as well as their presentation and dismissal transitions, are handled by a navigation controller, which is provided by Cocoa Touch in the form of <kbd>UINavigationController</kbd>. Let's take a look:</p>&#13;
<ol>&#13;
<li class="p1">To place our view controller inside a navigation controller, select <kbd>ReposTableViewController</kbd> in Interface Builder. Then, from the Xcode menu, go to Editor and then Embed In and choose Navigation Controller.</li>&#13;
</ol>&#13;
<p style="padding-left: 60px" class="p1">This will add a navigation controller to the storyboard and set the selected view controller as its root view controller (<em>if there is an existing v</em><em>iew con</em><em>troller</em> <em>already inside the storyboard from the initial project we created, this can be highlighted and deleted</em>).</p>&#13;
<ol start="2">&#13;
<li class="p1">Next, we need to define which view controller is initially on the screen when the app starts. Select Navigation Controller on the left-hand side of the screen and within the property inspector, select Is Initial View Controller. You will see that an entry arrow will point toward the navigation controller on the left, indicating that it will be shown initially.</li>&#13;
<li class="p1">With this set up, we can start working on our <kbd>ReposTableViewController</kbd> by selecting it from the File navigator menu.</li>&#13;
</ol>&#13;
<p style="padding-left: 60px" class="p1">When we created our view controller, the template gave us a bunch of code, with some of it commented out. The first method that the template provides is <kbd>viewDidLoad</kbd>. This is part of a set of methods that cover the life cycle of the root view that the view controller is managing. Full details about the view life cycle and its relevant method calls can be found at <a href="http://swiftbook.link/docs/vc-lifecycle">http://swiftbook.link/docs/vc-lifecycle</a>.</p>&#13;
<p style="padding-left: 60px" class="p1"><kbd>viewDidLoad</kbd> is fired quite early on in the view controller's life cycle but before the view controller is visible to the user. Due to this, it is a good place to configure the view and retrieve any information that you want to present to the user.</p>&#13;
<ol start="4">&#13;
<li class="p1">Let's give the view controller a title:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">class ReposTableViewController: UITableViewController {<br/>    <br/>    override func viewDidLoad() {<br/>        super.viewDidLoad()<br/>        <br/>        self.title = "Repos"<br/>    }<br/>    <br/>    //...<br/>}</pre>&#13;
<p style="padding-left: 60px" class="p1">Now, if you Build and Run the app, you'll see a navigation bar with the title we just added programmatically.</p>&#13;
<ol start="5">&#13;
<li class="p1">Next, we'll fetch and display a list of GitHub repositories. Implement the following snippet of code in order to fetch a list of repos for a specific user:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">@discardableResult   <br/> internal func fetchRepos(forUsername username: String,<br/>      completionHandler: @escaping (FetchReposResult) -&gt; Void) <br/>        -&gt; URLSessionDataTask? {<br/>        <br/>        let urlString = "https://api.github.com/users/\<br/>          (username)/repos"<br/>        guard let url = URL(string: urlString) else {<br/>            return nil<br/>        }<br/>        var request = URLRequest(url: url)<br/>        request.setValue("application/vnd.github.v3+json", <br/>          forHTTPHeaderField: "Accept")<br/>        let task = session.dataTask(with: request) { (data,<br/>          response, error) in<br/>            <br/>            // First unwrap the optional data<br/>            guard let data = data else {<br/>                completionHandler(.failure(ResponseError.<br/>                  requestUnsuccessful))<br/>                return<br/>            }<br/>            <br/>            do {<br/>                let decoder = JSONDecoder()<br/>                let responseObject = try decoder.<br/>                  decode([Repo].self, from: data)<br/>                <br/>                completionHandler(.success(responseObject))<br/>            } catch {<br/>                completionHandler(.failure(error))<br/>            }<br/>        }<br/>        task.resume()<br/><br/>        return task<br/>    }</pre>&#13;
<ol start="6">&#13;
<li class="p1">Let's add the following highlighted code to the top of the file, before the start of the class definition. We will also add a session property to the view controller, which is needed for the network request:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">import UIKit<br/><br/><strong>struct Repo: Codable {<br/>    let name: String?<br/>    let url: URL?<br/>    <br/>    enum CodingKeys: String, CodingKey {<br/>        case name = "name"<br/>        case url = "html_url"<br/>    }<br/>    <br/>}<br/><br/>enum FetchReposResult {<br/>    case success([Repo])<br/>    case failure(Error)<br/>}<br/><br/>enum ResponseError: Error {<br/>    case requestUnsuccessful<br/>    case unexpectedResponseStructure<br/></strong><strong>}</strong><br/><br/>class ReposTableViewController: UITableViewController {<br/>    <br/><strong>    internal var</strong><strong> session = URLSession.shared</strong><br/>    <br/>    //...<br/>}</pre>&#13;
<p style="padding-left: 60px">You may notice something a little different about the preceding functions since we're now making full use of Swift's <strong>Codable</strong> protocol. With Codable, we can map the JSON response from our API straight to our struct models, without the need to convert this into a dictionary and then iterate each key-value pair to a property.</p>&#13;
<ol start="7">&#13;
<li class="p1">Next, in our table view, each row of the table view will display the name of one of the repositories that we retrieve from the GitHub API. We need a place to store the repositories that we retrieve from the API:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">class ReposTableViewController: UITableViewController {<br/>    <br/>   internal var session = URLSession.shared<br/>    <br/><strong>   internal</strong> <strong>var</strong><strong> repos = [Repo]()</strong><br/>    <br/>    //...<br/>}</pre>&#13;
<p style="padding-left: 60px" class="p1">The <kbd>repos</kbd> array has an initially empty array value, but we will use this property to hold the fetched results from the API.</p>&#13;
<p>We don't need to fetch the repository data right now. So, instead, we'll learn how to provide data to be used in the table view. Let's get started:</p>&#13;
<ol>&#13;
<li>Let's create a couple of fake repositories so that we can temporarily populate our table view:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">class ReposTableViewController: UITableViewController {<br/>    <br/>    let session = URLSession.shared<br/>    <br/>    var repos = [Repo]()<br/>    <br/>    override func viewDidLoad() {<br/>        super.viewDidLoad()<br/>        <br/><strong> let repo1 = Repo(name: "Test repo 1", <br/>   url: URL(string: "http://example.com/repo1")!)<br/> let repo2 = Repo(name: "Test repo 2", <br/>   url: URL(string: "http://example.com/repo2")!)<br/> repos.append(contentsOf: [repo1, repo2])</strong><br/>    }<br/>    <br/>    //...<br/>}</pre>&#13;
<p style="padding-left: 60px" class="p1">The information in a table view is populated from the table view's data source, which can be any object that conforms to the <kbd>UITableViewDataSource</kbd><br/>&#13;
protocol. </p>&#13;
<p style="padding-left: 60px" class="p1">When the table view is displayed and the user interacts with it, the table view will ask the data source for the information it needs to populate the table view. For simple table view implementations, it is often the view controller that controls the table view that acts as the data source. In fact, when you create a subclass of <kbd>UITableViewController</kbd>, as we have, the view controller already conforms to <kbd>UITableViewDataSource</kbd> and is assigned as the table view's data source.</p>&#13;
<ol start="2">&#13;
<li class="p1">Some of the methods defined in <kbd>UITableViewDataSource</kbd> were created as part of the <kbd>UITableViewController</kbd> template; the three we will take a look at are as follows:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">// MARK: - Table view data source<br/>override func numberOfSections(in tableView: UITableView) -&gt; Int {<br/>    // #warning Incomplete implementation, return the number of <br/>     // sections<br/>    return 0<br/>}<br/><br/>override func tableView(_ tableView: UITableView, <br/>                        numberOfRowsInSection section: Int) -&gt; Int {<br/> // #warning Incomplete implementation, return the number of rows<br/>    return 0<br/>}<br/><br/>/*<br/>override func tableView(_ tableView: UITableView, <br/>   cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {<br/>     let cell = tableView.dequeueReusableCell(withIdentifier: <br/>       "RepoCell", for: indexPath)<br/>     // Configure the cell...<br/>     return cell<br/>}<br/>*/</pre>&#13;
<p style="padding-left: 60px" class="p1">Data in a table view can be divided into sections, and information is presented in rows within those sections; information is referenced through an <kbd>IndexPath</kbd> that consists of a section integer value and a row integer value.</p>&#13;
<ol start="3">&#13;
<li class="p1">The first thing that the data source methods ask us to provide is the number of sections that the table view will have. Our app will only be displaying a simple list of repositories, and as such, we only need one section, so we will return <kbd>1</kbd> from this method:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">override func numberOfSections(in tableView: UITableView) -&gt; Int {<br/>   1<br/>}</pre>&#13;
<ol start="4">&#13;
<li class="p1">The next thing we have to provide is the number of rows the table view should have for a given section. If we had multiple sections, we could examine the provided section index and return the right number of rows, but since we only have one section, we can return the same number in all scenarios.</li>&#13;
</ol>&#13;
<p style="padding-left: 60px" class="p1">We are displaying all the repositories we have retrieved, so the number of rows is simply the number of repositories in the <kbd>repos</kbd> array:</p>&#13;
<pre style="padding-left: 60px">override func tableView(_ tableView: UITableView, <br/>  numberOfRowsInSection section: Int) -&gt; Int {<br/>   repos.count<br/>}</pre>&#13;
<p>Notice that in the preceding two functions, we no longer use the <kbd>return</kbd> keyword. This is because, starting with Swift 5.1, you can now use <em><strong>implicit returns</strong></em> in functions. As long as your function doesn't carry ambiguity about what should and should not be returned, the compiler can work this out for you. This allows for more streamlined syntax.</p>&#13;
<p class="p1">Now that we have told the table view how many pieces of information to display, we must be able to display that information. A table view displays information in a type of view called <kbd>UITableViewCell</kbd>, and this cell is what we have to provide next.</p>&#13;
<p>For each index path within the section and row bounds that we have provided, we will be asked to provide a cell that will be displayed by the table view. A table view can be very large in size as it may need to represent a large amount of data. However, there are only a handful of cells that can be displayed to the user at any one time. This is because only a portion of the table view can be visible at any one time:</p>&#13;
<div><img src="img/380b9e3e-deeb-4714-8450-b1c62318e33c.png" style="" width="728" height="1206"/></div>&#13;
<p>Figure 6.9 – Table view cell overview</p>&#13;
<p class="p1">In order to be efficient and prevent your app from slowing down as the user scrolls, the table view can reuse cells that have already been created but have since moved off-screen. Implementing cell reuse happens in two stages:</p>&#13;
<ul>&#13;
<li class="p1">Registering the cell's type with the table view with a reuse identifier.</li>&#13;
<li class="p1">Dequeuing a cell for a given reuse identifier. This will return a cell that has moved off-screen or create a new cell if none are available for reuse.</li>&#13;
</ul>&#13;
<p class="p1">How a cell is registered will depend on how it has been created. If the cell has been created and its subviews have also been laid out in the code, then the cell's class is registered with the table view through this method on <kbd>UITableView</kbd>:</p>&#13;
<pre>func register(_ cellClass: AnyClass?, <br/>              forCellReuseIdentifier identifier: String)</pre>&#13;
<p class="p1">If the cell has been laid out in <kbd>.xib</kbd> (usually called a "nib" for historical reasons), which is a visual layout file for views that's similar to a storyboard, then the cell's nib is registered with the table view through this method on <kbd>UITableView</kbd>:</p>&#13;
<pre>func register(_ nib: UINib?, forCellReuseIdentifier identifier: String)</pre>&#13;
<p class="p1">Lastly, cells can be defined and laid out within the table view in a storyboard. One advantage of this approach is that there is no need to manually register the cell, as with the previous two approaches; registering with the table view is free. However, one disadvantage of this approach is that the cell layout is tied to the table view, so it can't be reused in other table views, unlike the previous two implementations.</p>&#13;
<p class="p1">Let's layout our cell in the Storyboard since we will only be using it with one table view:</p>&#13;
<ol>&#13;
<li class="p1">Switch to our Main.storyboard file and select the table view in our <kbd>ReposTableViewController</kbd>.</li>&#13;
<li class="p1">In the attributes inspector, change the number of prototype cells to <kbd>1</kbd>; this will add a cell to the table view in the main window. This cell will define the layout of all the cells that will be displayed in our table view. You should create a prototype cell for each type of cell layout you will need; we are only displaying one piece of information in our table view, so all our cells will be of the same type.</li>&#13;
<li class="p1">Select a cell in the storyboard. The attributes inspector will switch to showing the attributes for the cell. The cell style will be set to custom, and often, this will be what you want it to be. When you are displaying multiple pieces of information in a cell, you will usually want to create a subclass of <kbd>UITableViewCell</kbd>, set this to be the cell's class in the class inspector, and then lay out subviews in this custom cell type. However, for this example, we just want to show the name of the repository. Due to this, we can use a basic cell style that just has one text label, without a custom subclass, so choose basic from the style dropdown.</li>&#13;
</ol>&#13;
<ol start="4">&#13;
<li class="p1">We need to set the reuse identifier that we will use to dequeue the cell later, so type an appropriate string, such as <kbd>RepoCell</kbd>, into the reuse identifier box of the attributes inspector:</li>&#13;
</ol>&#13;
<div><img src="img/55156d4f-12b9-418f-806a-243ffe8ef104.png" width="258" height="302"/></div>&#13;
<p>Figure 6.10 – Table view cell identifier</p>&#13;
<ol start="5">&#13;
<li class="p1">Now that we have a cell that is registered for reuse with the table view, we can go back to our view controller and complete our conformance with <kbd>UITableViewDataSource</kbd>.</li>&#13;
<li class="p1">Our <kbd>ReposTableViewController</kbd> contains some commented code that was created as part of the template:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">/*<br/>override func tableView(_ tableView: UITableView, <br/>   cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {<br/><strong> let cell = tableView.dequeueReusableCell(withIdentifier:  <br/>   "RepoCell", for: indexPath)<br/> // Configure the cell...<br/></strong><strong> return cell</strong><br/>}<br/>*/</pre>&#13;
<ol start="7">&#13;
<li class="p1">At this point, you can remove the <kbd>/* */</kbd> comment signifiers as we are ready to implement this method.</li>&#13;
</ol>&#13;
<p style="padding-left: 60px" class="p1">This data source method will be called every time the table view needs to place a cell on-screen; this will happen the first time the table is displayed as it needs cells to fill the visible part of the table view. It will also be called when the user scrolls the table view in a way that will reveal a new cell so that it becomes visible.</p>&#13;
<ol start="8">&#13;
<li class="p1">Regarding the method's definition, we can see that we are provided with the table view in question and the index path of the cell that is needed, and we are expected to return a <kbd>UITableViewCell</kbd>. The code provided by the template actually does most of the work for us; we just need to provide the reuse identifier that we set in the storyboard and set the title label of the cell so that we have the name of the correct repository:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">override func tableView(_ tableView: UITableView, <br/>  cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {<br/>    let cell = tableView.dequeueReusableCell(withIdentifier: <br/>      "RepoCell", for: indexPath)<br/>    <br/>    // Configure the cell...<br/>    let repo = repos[indexPath.row]<br/>    cell.textLabel?.text = repo.name<br/>    <br/>    return cell<br/>}</pre>&#13;
<p style="padding-left: 60px" class="p1">The cell's <kbd>textLabel</kbd> property is optional because it only exists when the cell's style is not custom.</p>&#13;
<ol start="9">&#13;
<li class="p1">Since we've now provided everything the table view needs to display our repository information, let's click on Build and Run and take a look:</li>&#13;
</ol>&#13;
<div><img src="img/5b43b056-b1b4-4e3f-a5d1-f10e2c7be73a.png" style="" width="630" height="983"/></div>&#13;
<p>Figure 6.11 – Our app's first run</p>&#13;
<p class="p1">Great! Now that we have our two test repositories displayed in our table view, let's replace our test data with real repositories from the GitHub API.</p>&#13;
<p>We added our <kbd>fetchRepos</kbd> method earlier, so all we need to do is call this method, set the results to our <kbd>repos</kbd> property, and tell our table view that it needs to reload since the data has changed:</p>&#13;
<pre>class ReposTableViewController: UITableViewController {<br/>    <br/>    internal var session = URLSession.shared<br/>    internal var repos = [Repo]()<br/>    <br/>    override func viewDidLoad() {<br/>        super.viewDidLoad()<br/>        <br/>        title = "Repos"<br/>        <br/>        fetchRepos(forUsername:"SwiftProgrammingCookbook"){ [weak self]<br/>          result in<br/>            <br/>            switch result {<br/>            case .success(let repos):<br/>                self?.repos = repos<br/>                <br/>            case .failure(let error):<br/>                self?.repos = []<br/>                print("There was an error: \(error)")<br/>            }<br/>            self?.tableView.reloadData()<br/>        }<br/>    }<br/>    //...<br/>}</pre>&#13;
<p class="p1">As we did in the previous recipes, we fetched the repositories from the GitHub API and received a result enum informing us of whether this was a success or a failure. If it was successful, we store the resulting repository array in our <kbd>repos</kbd> property. Once we have handled the response, we call the <kbd>reloadData</kbd> method on <kbd>UITableView</kbd>, which instructs the table view to requery its source for cells to display.</p>&#13;
<p class="p1">We also provided a weak reference to <kbd>self</kbd> in our closure's capture list to prevent a retain cycle. You can find out more about why this is important in the <em>Closures</em> recipe of <a href="f9d48715-ffca-464f-95bf-722958f02e72.xhtml">Chapter 1</a>, <em>Swift Building Blocks</em>.</p>&#13;
<p class="p1">At this point, there is an important consideration that needs to be addressed. The iOS platform is a multithreaded environment, which means that it can do more than one thing at once. This is critical to being able to maintain a responsive user interface, while also being able to process data and perform long-running tasks. The iOS system uses queues to manage this work and reserves the "main" queue for any work involving the user interface. Therefore, any time you need to interact with the user interface, it is important that this work is done from the main queue.</p>&#13;
<p class="p1">Our <kbd>fetchRepos</kbd> method presents a situation where this might not be true. Our <kbd>fetchRepos</kbd> method performs networking, and we provide closure to <kbd>URLSession</kbd> as part of creating a <kbd>URLSessionDataTask</kbd>, but there is no guarantee that this closure will be executed on the main thread. Therefore, when we receive a response from <kbd>fetchRepos</kbd>, we need to "dispatch" the work of handling that response to the main queue to ensure that our updates to the UI happen on the main queue. We can do this using the <kbd>Dispatch</kbd> framework, so we need to import that at the top of the file:</p>&#13;
<pre>class ReposTableViewController: UITableViewController {<br/>    <br/>    let session = URLSession.shared<br/>    var repos = [Repo]()<br/>    <br/>    override func viewDidLoad() {<br/>        super.viewDidLoad()<br/>        <br/>        title = "Repos"<br/>        <br/>        fetchRepos(forUsername:"SwiftProgrammingCookbook"){ [weak self] <br/>          result in<br/>            <br/>            DispatchQueue.main.async {<br/>                <br/>                switch result {<br/>                case .success(let repos):<br/>                    self?.repos = repos<br/>                    <br/>                case .failure(let error):<br/>                    self?.repos = []<br/>                    print("There was an error: \(error)")<br/>                }<br/>                self?.tableView.reloadData()<br/>            }<br/>        }<br/>    }<br/>}</pre>&#13;
<p class="p1">We will be discussing multithreading and the <kbd>Dispatch</kbd> framework in greater depth in <a href="f9e2c873-c2b2-4d40-9b02-5d884006d1a5.xhtml">Chapter 9</a>, <em>Performance and Responsiveness in Swift</em>.</p>&#13;
<ol>&#13;
<li class="p1">Click on Build and Run. After a few seconds, the table view will be filled with the names of various repositories from the GitHub API.</li>&#13;
</ol>&#13;
<p style="padding-left: 60px" class="p1">Now that we have repositories being displayed to the user, the next piece of functionality we'll implement for our app is the ability to tap on a cell and have it display the repository's GitHub page in a WebView.</p>&#13;
<p style="padding-left: 60px" class="p1">Actions triggered by the table view, such as when a user taps on a cell, are provided to the table view's delegate, which can be anything that conforms to <kbd>UITableViewDelegate</kbd>. As was the case with the table view's data source, our <kbd>ReposTableViewController</kbd> already conforms to <kbd>UITableViewDelegate</kbd> because it is a subclass of <kbd>UITableViewController</kbd>.</p>&#13;
<ol start="2">&#13;
<li class="p1">If you take a look at the documentation for the <kbd>UITableViewDelegate</kbd> protocol, you will see a lot of optional methods; this documentation can be found at <a href="https://developer.apple.com/reference/uikit/uitableviewdelegate">https://developer.apple.com/reference/uikit/uitableviewdelegate</a>. The one that's relevant for our purposes is as follows:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px"> func tableView(_ tableView: UITableView, didSelectRowAt indexPath: <br/>   IndexPath)</pre>&#13;
<ol start="3">&#13;
<li class="p1">This will be called on the table view's delegate whenever a cell is selected by the user, so let's implement this in our view controller:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">override func tableView(_ tableView: UITableView, didSelectRowAt <br/>  indexPath: IndexPath) {<br/>    <br/>    let repo = repos[indexPath.row]<br/>    let repoURL = repo.url<br/>    <br/>    // TODO: Present the repo's URL in a webview<br/>}</pre>&#13;
<ol start="4">&#13;
<li class="p1">For the functionality it provides, we will use <kbd>SFSafariViewController</kbd>, passing it the repository's URL. Then, we will pass that view controller to the <kbd>show</kbd> method, which will present the view controller in the most appropriate way:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">override func tableView(_ tableView: UITableView, <br/>                        didSelectRowAt indexPath: IndexPath) {<br/>    <br/>    let repo = repos[indexPath.row]<br/>    guard let repoURL = repo.url else { return }    <br/><br/>    let webViewController = SFSafariViewController(url: repoURL)<br/>    show(webViewController, sender: nil)<br/>}</pre>&#13;
<ol start="5">&#13;
<li class="p1">Don't forget to <kbd>import SafariServices</kbd> at the top of the file.</li>&#13;
<li class="p1">Click on Build and Run, and once the repositories are loaded, tap on one of the cells. A new view controller will be pushed onto the screen, and the relevant repository web page will load.</li>&#13;
</ol>&#13;
<p class="p1">Congratulations – you've just built your first app and it looks great!</p>&#13;
<h2 id="uuid-5f337dd8-bfcc-4df6-99e5-2ca0b95ffbba" class="p1">How it works...</h2>&#13;
<p class="p1">Currently, our app fetches repositories from a specific, hardcoded GitHub username. It would be great if, rather than hardcoding the username, the user of the app could enter the GitHub username that the repositories will be retrieved for. So, let's add this functionality:</p>&#13;
<ol>&#13;
<li class="p1">First, we need a way for the user to enter their GitHub username; the most appropriate way to allow a user to enter a small amount of text is through the use of <kbd>UITextField</kbd>.</li>&#13;
<li class="p1">In the main storyboard, find Text Field in the object library, drag it over to the main window, and drop it on the navigation bar of our <kbd>ReposTableViewController</kbd>. Now, you need to increase the width of the Text Field. For now, just hard code this to around 300px by highlighting the respective Text Field and selecting the Size Inspector option:</li>&#13;
</ol>&#13;
<div><img src="img/c8836cdf-8f9e-4a45-8790-756f56c5b899.png" width="1008" height="241"/></div>&#13;
<p>Figure 6.12 – Adding a UITextField</p>&#13;
<p style="padding-left: 60px" class="p1">Like a table view, <kbd>UITextField</kbd> communicates user events through a delegate, which needs to conform to <kbd>UITextFieldDelegate</kbd>.</p>&#13;
<ol start="3">&#13;
<li class="p1">Let's switch back to <kbd>ReposTableViewController</kbd> and add conformance to <kbd>UITextFieldDelegate</kbd>; it is a common practice to add protocol conformance to an extension, so add the following at the bottom of <kbd>ReposTableViewController</kbd>:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px"><strong>extension ReposTableViewController: UITextFieldDelegate {<br/> <br/>}</strong></pre>&#13;
<ol start="4">&#13;
<li class="p1">With this conformance in place, we need to set our view controller to be the delegate of <kbd>UITextField</kbd>. Head back over to the main storyboard and select the text field, and then open the Connections Inspector. You will see that the text field has an outlet for its delegate property. Now, click, hold, and drag from the circle next to our delegate over to the symbol representing our Repos Table View Controller:</li>&#13;
</ol>&#13;
<div><img src="img/75b53f88-549f-4969-a485-95fbee819449.png" width="1392" height="843"/></div>&#13;
<p>Figure 6.13 – UITextField with IBOutlet</p>&#13;
<p style="padding-left: 60px" class="p1">The delegate outlet should now have a value:</p>&#13;
<div><img src="img/8f9c8af2-5e15-471b-89ba-69cdbc7ee805.png" style="" width="258" height="166"/></div>&#13;
<p>Figure 6.14 – UITextField delegate outlet</p>&#13;
<p style="padding-left: 60px">By taking a look at the documentation for <kbd>UITextFieldDelegate</kbd>, we can see that the <kbd>textFieldShouldReturn</kbd> method is called when the user presses the <em>Return</em> button on their keyboard after entering text, so this is the method we will implement.</p>&#13;
<ol start="5">&#13;
<li class="p1">Let's switch back to our <kbd>ReposViewController</kbd> and implement this method in our extension:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">extension ReposTableViewController: UITextFieldDelegate {<br/>    <br/>    public func textFieldShouldReturn(_ textField: UITextField) <br/>      -&gt; Bool {<br/>        <br/>    // TODO: Fetch repositories from username entered into text<br/>    // field<br/> // TODO: Dismiss keyboard<br/> <br/> // Returning true as we want the system to have the default <br/>   // behaviour<br/> return true<br/>    }<br/>}</pre>&#13;
<ol start="6">&#13;
<li class="p1">Since repositories will be fetched here instead of when the view is loaded, let's move the code from <kbd>viewDidLoad</kbd> to this method:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">extension ReposTableViewController: UITextFieldDelegate {<br/>    <br/>    public func textFieldShouldReturn(_ textField: UITextField) <br/>     -&gt; Bool {<br/>        <br/>        // If no username, clear the data<br/>         guard let enteredUsername = textField.text else {<br/>             repos.removeAll()<br/>             tableView.reloadData()<br/>             return true<br/>         }<br/>        <br/>        // Fetch repositories from username entered into text field<br/>        fetchRepos(forUsername: enteredUsername) { [weak self] <br/>          result in<br/>                <br/>                switch result {<br/>                case .success(let repos):<br/>                    self?.repos = repos<br/>                    <br/>                case .failure(let error):<br/>                    self?.repos = []<br/>                    print("There was an error: \(error)")<br/>                }<br/>                DispatchQueue.main.async {<br/>                   self?.tableView.reloadData()<br/>            }<br/>        }<br/>        <br/>        // TODO: Dismiss keyboard<br/>        <br/>        // Returning true as we want the system to have the default <br/>          // behaviour<br/>        return true<br/>    }<br/>}</pre>&#13;
<p class="p1">Cocoa Touch implements the programming design pattern <strong>MVC</strong>, which stands for <strong>Model View Controller</strong>; it is a way of structuring your code to keep its elements reusable, with well-defined responsibilities. In the MVC pattern, all code related to displaying information falls broadly into three areas of responsibility:</p>&#13;
<ul>&#13;
<li class="p1"><strong>Model</strong> objects hold the data that will eventually be displayed on the screen; this might be data that was retrieved from the network or device, or that was generated when the app was running. These objects may be used in multiple places in the app, where different view representations of the same data may be required.</li>&#13;
</ul>&#13;
<ul>&#13;
<li class="p1"><strong>View</strong> objects represent the UI elements that are displayed on the screen; these may just display information that they are provided, or capture input from the user. View objects can be used in multiple places where the same visual element is needed, even if it is showing different data.</li>&#13;
<li class="p1"><strong>Controller</strong> objects act as bridges between the models and the views; they are responsible for obtaining the relevant model objects and for providing the data to be displayed to the right view objects at the right time. Controller objects are also responsible for handling user input from the views and updating the model objects as needed:</li>&#13;
</ul>&#13;
<div><img src="img/c2ca3f73-1840-4f2a-b193-94407bbf5319.jpg" style="" width="665" height="334"/></div>&#13;
<p>Figure 6.15 – MVC overview</p>&#13;
<p class="p1">With regards to displaying web content, our app provides us with a number of options for presenting web content:</p>&#13;
<ul>&#13;
<li class="p1"><kbd>WKWebView</kbd>, provided by the WebKit framework, is a view that uses the latest rendering and JavaScript engine for loading and displaying web content. While it is newer, it is less mature in some respects and has issues with caching content.</li>&#13;
<li class="p1"><kbd>SFSafariViewController</kbd>, provided by the <kbd>SafariServices</kbd> framework, is a view controller that displays web content, and also provides many of the features that are available in Mobile Safari, including sharing and adding to reading lists and bookmarks. It also provides a convenient button for opening the current site in Mobile Safari.</li>&#13;
</ul>&#13;
<h2 id="uuid-da79d743-a6bd-4719-8fb6-fbb71a3a456e">There's more...</h2>&#13;
<p class="p1">The last thing we need to do is dismiss the keyboard. Cocoa Touch refers to the object that is currently receiving user events as the first responder. Currently, this is the text field.</p>&#13;
<p class="p1">It's the act of the text field becoming the first responder that caused the keyboard to appear on-screen. Therefore, to dismiss the keyboard, the text field just needs to resign its place as first responder:</p>&#13;
<pre>extension ReposTableViewController: UITextFieldDelegate {<br/>    <br/>    public func textFieldShouldReturn(_ textField: UITextField) <br/>      -&gt; Bool {<br/>        <br/>        //...<br/>        <br/>        // Dismiss keyboard<br/>        <strong>textField.resignFirstResponder()</strong><br/>        <br/>        // Returning true as we want the system to have the default <br/>           // behaviour<br/>        return true<br/>    }<br/>}</pre>&#13;
<p class="p1">Now, click on Build and Run. At this point, you can enter any GitHub account name in the text field to retrieve a list of its public repositories. Note that if your Xcode simulator doesn't have the "soft keyboard" enabled, you can just press <em>Enter</em> on your physical keyboard to search for the repo.</p>&#13;
<h2 id="uuid-ef1f32c5-f4b7-4d70-a34d-d1dd41527755">See also</h2>&#13;
<p>For more information regarding what was covered in this recipe, please refer to the following links:</p>&#13;
<ul>&#13;
<li><strong>Apple Documentation for GCD</strong>: <a href="https://developer.apple.com/documentation/dispatch">https://developer.apple.com/documentation/dispatch</a></li>&#13;
<li><strong>Apple Documentation UIKit</strong>: <a href="https://developer.apple.com/documentation/uikit">https://developer.apple.com/documentation/uikit</a></li>&#13;
</ul>&#13;
<h1 id="uuid-148d5c1a-03b5-4279-8510-a9d85065ce7e">Unit and integration testing with XCTest</h1>&#13;
<p>It goes without saying that testing plays a massive part of the software development life cycle. Primarily, a lot of the focus is on physical user testing – putting your piece of code in the hands of those using it day in day out. To a degree, this should be one of our main focuses, but what about testing what <strong>we</strong>, as software developers do? How do we test and check the integrity of our codebase?</p>&#13;
<p>This is where unit and integration testing comes in. In this recipe, we'll cook up a unit and integration test for our previously written Cocoa Touch app. This will be written entirely in Swift using the Xcode IDE.</p>&#13;
<h2 id="uuid-725011e2-1a69-4a2c-93f3-4a49c020940d">Getting ready</h2>&#13;
<p>Back in our existing CocoaTouch project, in the <strong>File inspector</strong>, look for a folder called <kbd>CocoaTouchTest</kbd>. Expand this and select the <kbd>CocoaTouchTests.swift</kbd> file.</p>&#13;
<p>Inside this file, you'll notice a class named <kbd>CocoaTouchTests</kbd>, which, in turn, inherits from the <kbd>XCTestCase</kbd> class. <kbd>XCTestCase</kbd> offers a suite of functions that we can use when writing out our unit tests. </p>&#13;
<p>So, what exactly is a unit test? Well, it's a test (or in our case, just a function) that checks that another function is doing what it's supposed to be doing. Writing tests or functions using XCTestCase allows us to not only use the previously mentioned suite of helpers but also allows Xcode to visualize and report on metrics such as test coverage.</p>&#13;
<p>With that, let's get stuck into cooking up our first unit test! In the <kbd>CocoaTouchTests.swift</kbd> file, you'll see some override functions that have already been generated by Xcode. Just ignore these for now; we'll work on them as/when we need to.</p>&#13;
<h2 id="uuid-2866f93c-0902-4b89-918b-c05522aa3748">How to do it...</h2>&#13;
<p>Let's start by creating the following function:</p>&#13;
<pre><strong>func testThatRepoIsNotNil() {</strong><br/><strong>    XCTAssertNotNil(viewControllerUnderTest?.repos)</strong><br/><strong>}</strong></pre>&#13;
<p>So, let's go through this one bit at a time. We'll start with the <kbd>testThatRepoIsNotNil</kbd> function. The common practice when naming a unit test is for the name to be as descriptive as possible. Depending on your coding standard, you can choose to either camel case these or snake case them (I much prefer camel case), but when writing tests with Xcode, you always have to prefix these with the word "test".</p>&#13;
<p>So, what are we testing? Here, we're checking that our repo array is not nil.</p>&#13;
<p>Looking back at our <kbd>ReposTableViewController</kbd>, you'll remember that we instantiated our "repo" model where the variable was declared, so this is a great test to start with. Let's say someone tries to change this to an optional, like this:</p>&#13;
<pre>internal var repos: [Repo]?</pre>&#13;
<p>If this happens, the code in our CocoaTouch App will compile, but the test will fail.</p>&#13;
<p>Let's take another look at our test. Note that the function we're calling to check our repo model is <kbd>viewControllerUnderTest</kbd>. This is how we access our <kbd>RepoTableViewContoller</kbd>. We can achieve this by adding the following class-level variable to our file:</p>&#13;
<pre>var viewControllerUnderTest: ReposTableViewController?</pre>&#13;
<p>Now, we need to instantiate this. Add the following override method from <kbd>XCTestCase</kbd> to your class:</p>&#13;
<pre>override func setUp() {<br/>    viewControllerUnderTest = ReposTableViewController()<br/>}</pre>&#13;
<p>When running your unit test for this particular class, <kbd>setUp()</kbd> will run prior to any of your test cases running, allowing you to prep anything you may need, such as instantiating a class. Once the tests are complete and you want to free anything up or close anything down, you can simply do this with the <kbd>tearDown()</kbd> function.</p>&#13;
<p>This was and is a very basic test, but the main purpose here was not necessarily to look at testing practice, but how we'd do that in Swift. However, before we go any further, let's take a look at the <kbd>Assert</kbd> options that are available to us.</p>&#13;
<p>Previously, we used <kbd>XCTAssertNotNil</kbd>, which worked perfectly for our scenario. However, the following options are also available:</p>&#13;
<pre>XCTAssert<br/>XCTAssertEqual<br/>XCTAssertTrue<br/>XCTAssertGreaterThan<br/>XCTAssertGreaterThanOrEqual<br/>XCTAssertLessThan<br/>XCTAssertLessThanOrEqual<br/>XCTAssertNil</pre>&#13;
<p>These are just a handful of the common ones and they are pretty self-explanatory – an added bonus is that each one has an optional parameter of "message", which allows you to add a custom string. This allows you to be more specific about the assertion that took place (ideal for reporting in a CI/CD world). </p>&#13;
<p>Now that we understand the basics of how to write tests in Swift, we need to learn how to run them. There are two ways we can achieve this:</p>&#13;
<ol>&#13;
<li>First, we can run all the tests in our class in one go. We can do this by simply clicking on the diamond to the left of the class's declaration:</li>&#13;
</ol>&#13;
<div><img src="img/dc143851-1a69-4c14-b320-93d3c37b6ef1.png" style="" width="630" height="46"/></div>&#13;
<p>Figure 6.16 – Class test case</p>&#13;
<ol start="2">&#13;
<li class="mce-root">If we want to run tests individually, then we can simply select the icon next to our individual test case, like this:</li>&#13;
</ol>&#13;
<div><img src="img/4ff0c578-0aab-4e37-b46e-94bb1a3c9b71.png" style="" width="853" height="54"/></div>&#13;
<p>Figure 6.17 – Method test case</p>&#13;
<p>If everything goes to plan and our tests pass, we'll see the icon turn green:</p>&#13;
<div><img src="img/eeda5573-4e31-4556-adf9-05c74b748c63.png" style="" width="866" height="50"/></div>&#13;
<p>Figure 6.18 – Method passed test case</p>&#13;
<p>However, if one or more of the tests in our class fail, we'll see the icon turn red:</p>&#13;
<div><img src="img/4fb7bb17-8232-46b9-b085-5a13e08034d4.png" style="" width="851" height="52"/></div>&#13;
<p>Figure 6.19 – Method failed test case</p>&#13;
<p>Alternatively, the keyboard shortcut of <em>CMD</em> + <em>U</em> will also get Xcode to run any tests associated with the main project. Remember, only functions that start with the word <kbd>test</kbd> will be treated as a test case (excluding the class name), so feel free to add a private function in your test case should you need to.</p>&#13;
<p>Next, let's take a look at how we would test networking logic in Swift using mock data to help us out:</p>&#13;
<ol>&#13;
<li class="mce-root">We'll start by creating the following test function:</li>&#13;
</ol>&#13;
<pre><strong>    func testThatFetchRepoParsesSuccessfulData() { </strong><strong>}</strong></pre>&#13;
<ol start="2">&#13;
<li>Let's start by figuring out how we are going to call this. Once again, we'll take advantage of our <kbd>viewControllerUnderTest</kbd> variable:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">    func testThatFetchRepoParsesSuccessfulData() {<br/>        viewControllerUnderTest?.fetchRepos(forUsername: "", completionHandler: { (response) in<br/>            print("\(response)")<br/>        })<br/>    }</pre>&#13;
<p style="padding-left: 60px">This works as expected, but unfortunately, it's not that simple – this will simply call the API just like our app would. If we were to add any XCAsserts inside our code, they wouldn't be executed as our test and function will have finished and been torn down before the API has a chance to respond.</p>&#13;
<ol start="3">&#13;
<li>To do this, we need to mock some objects in our <kbd>viewControllerUnderTest</kbd>, starting with <strong>URLSession </strong>and <strong>URLSessionDataTask</strong>. So, why do we need to mock these two? Let's start by taking a look at where we use them in our CocoaTouch app:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let task = session.dataTask(with: request) { (data, response, error) in</pre>&#13;
<p style="padding-left: 60px">Here, we are using <strong>URLSession</strong> and one of its functions, <strong>URLSessionDataTask</strong>, by mocking URLSession. We're creating our own local session here that we can then use to call our <kbd>MockURLSessionDataTask</kbd>. So, the real question here is, what is our <kbd>MockURLSessionDataTask</kbd> doing? We're using this to pass in some mock data – data that we should expect from the API – and then running this through our logic. This guarantees the integrity of our tests every time!</p>&#13;
<ol start="4">&#13;
<li>We could create the following input in our own files, but for now, we'll just append them to the bottom of our <kbd>CocoaTouchTests.swift</kbd> file. First, let's look at our <kbd>MockURLSession</kbd>:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">class MockURLSession: URLSession {<br/>    override func dataTask(with request: URLRequest, completionHandler: @escaping (Data?, URLResponse?, Error?) -&gt; Void) -&gt; URLSessionDataTask {<br/>        return MockURLSessionDataTask(completionHandler: completionHandler, request: request)<br/>    }<br/>}</pre>&#13;
<p style="padding-left: 60px">The preceding function is pretty self-explanatory – we simply override the <kbd>dataTask()</kbd> function with the following <kbd>MockURLSessionDataTask</kbd>:</p>&#13;
<pre style="padding-left: 60px">class MockURLSessionDataTask: URLSessionDataTask {<br/>    <br/>    var completionHandler: (Data?, URLResponse?, Error?) -&gt; Void<br/>    var request: URLRequest<br/>    <br/>    init(completionHandler: @escaping (Data?, URLResponse?, Error?) -&gt; Void, request: URLRequest) {<br/>        self.completionHandler = completionHandler<br/>        self.request = request<br/>        super.init()<br/>    }<br/>    <br/>    var calledResume = false<br/>    <br/>    override func resume() {<br/>        calledResume = true<br/>    }<br/>    <br/>}</pre>&#13;
<p style="padding-left: 60px">At first glance, this looks a little complex, but all we are really doing here is adding our own <kbd>completionHandler</kbd>. This will allow it to be called synchronously from our test (stopping our test from running away with us).</p>&#13;
<p>Let's put this all together and head back over to our new test:</p>&#13;
<ol>&#13;
<li>Let's start by setting our <kbd>MockURLSession</kbd> for our <kbd>viewControllerUnderTest</kbd>. This is nice and simple. Now, line by line, add the following:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func testThatFetchRepoParsesSuccessfulData() {<br/>        <br/>    viewControllerUnderTest?.session = MockURLSession()<br/><br/>    // ...<br/>                <br/>}</pre>&#13;
<ol start="2">&#13;
<li>Let's start by adding in our main <kbd>responseObject</kbd>. This is what we are going to perform our XCAsserts against. Declare this as an optional variable:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">var responseObject: FetchReposResult?</pre>&#13;
<ol start="3">&#13;
<li class="mce-root">Now, we can call our function, much like we tried to earlier in this section. However, this time, we'll assign the result to a variable and cast this as a <kbd>MockURLSessionDataTask</kbd>:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let <strong>result</strong> = viewControllerUnderTest?.fetchRepos(forUsername: "", completionHandler: { (response) in<br/>        responseObject = response<br/>    }) as? <strong>MockURLSessionDataTask</strong></pre>&#13;
<ol start="4">&#13;
<li>Remember that we can pass in anything we want for the <kbd>userName</kbd> variable as we're not going to be calling the API. Now, let's fire the completion handler we created and force through our <kbd>mockData</kbd>:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">result?.completionHandler(<strong>mockData</strong>, nil, nil)</pre>&#13;
<p style="padding-left: 60px">I've highlighted the <kbd>mockData</kbd> variable in the preceding code as we'll need to add this to the JSON response we want to test against. You can get this by simply visiting the GitHub URL and copying this into a new, <strong>empty</strong> file in the project. I did this for my username and created a file called <kbd>mock_Data.json</kbd>:</p>&#13;
<div><img src="img/b4c007ba-be6e-4948-8499-23dbba2adc0d.png" style="" width="1417" height="1012"/></div>&#13;
<p>Figure 6.20 – Adding an empty file</p>&#13;
<p style="padding-left: 60px">Remember to select the CocoaTouch target when you're saving the file to disk; otherwise, the following steps won't work.</p>&#13;
<ol start="5">&#13;
<li>Now, create a computed property in our <kbd>Test</kbd> class that simply reads in the file and spits out the <kbd>Data()</kbd> object:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">var mockData: Data {<br/>    if let path = Bundle.main.path(forResource: "mock_Data", ofType: "json"), let contents = FileManager.default.contents(atPath: path){<br/>        return contents<br/>    }<br/>    return Data()<br/>}</pre>&#13;
<ol start="6">&#13;
<li>At this point, we can successfully pass our mock data through our <kbd>fetchRepos</kbd> function without the need to call the API. All we need to do now is write some asserts:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">switch responseObject {<br/>    case .success(let repos):<br/>            <br/>    // Our test data had 3 repos, lets check that parsed okay<br/><strong>    XCTAssertEqual(repos.count, 9)</strong><br/>            <br/>    // We know the first repo has a specific name... let's check that<br/><strong>    XCTAssertEqual(repos.first?.name, "aerogear-ios-oauth2")</strong><br/>    default:<br/>    // Anything other than success - failure...<br/><strong>    XCTFail()</strong><br/>}</pre>&#13;
<p>What you test for here is really up to you – it's all based on the test cases you choose. Sometimes, thinking about what to test when you've already written a function can be a hard task. As a developer, it is easy for you to get "too close" to the project. This is where <strong>test-driven development</strong> (<strong>TDD</strong>) comes in, a methodology for writing tests prior to writing any code at all. Let's take a look at this and what we can achieve with it.</p>&#13;
<h2 id="uuid-ee3f43e0-f07b-4a7e-8810-b55f7441c827">How it works...</h2>&#13;
<p>Testing networking logic can be troublesome. I find that questions always arise, such as, what should you test? What exactly is being tested? However, if you can get your head around this, then you're well on your way to understanding the core fundamentals of unit testing.</p>&#13;
<p>Let's try and break this down. The logic we want to test is our <kbd>fetchRepos()</kbd> function. This is easy – we just call it with a repository username that we know and write some XCAsserts against the list of repos that come back.</p>&#13;
<p>While that will work for now, what happens when the user removes a repo? Your test will fail. This isn't good because your logic is not actually flawed – it's just the data that is wrong, much like if the API decided to return some malformed JSON due to an internal server error. This isn't your code's fault – it's the API's fault, and it's the API's job to make sure that it works.</p>&#13;
<p>All you want to do is check that if the server gives you a specific response, with a specific piece of data, your logic does what it says it should do. So, how can we guarantee the integrity of the data coming back from an API? We can't – that's why we mock the data ourselves and, in turn, don't actually call the service at all.</p>&#13;
<h2 id="uuid-a75569e2-ee68-4863-96cd-56dd752b720a">There's more...</h2>&#13;
<p>TDD is a methodology that includes writing your unit test first, prior to actually writing your desired function. Some believe this is the only way to write code, while others preach about its usage when – and only when – necessary. For the record, I do the latter, but we're not here to get into the theory – we'll here to learn how to achieve this in Swift using XCTest.</p>&#13;
<p>Going back to our CocoaTouch app, let's say we'd like to write a function that validates UITextField for whitespaces. Perform the following steps to achieve this:</p>&#13;
<ol>&#13;
<li>We'll start by writing out the stub function, which will look something like this:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func isUserInputValid(withText text: String) -&gt; Bool {<br/>    return false<br/>}</pre>&#13;
<p style="padding-left: 60px">Normally, here, I would litter my function with comments about what I'd like to achieve, but for TDD, we're going to do this the other way around.</p>&#13;
<ol start="2">&#13;
<li>Back inside the <kbd>CocoaTouchTests.swift</kbd> file, add the following test:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func testThatTextInputValidatesWithSingleWhitespace() {  <br/>}</pre>&#13;
<p style="padding-left: 60px">Again, taking the name of our test as a literal description, we're going to check that our function correctly detects whitespaces in the middle of a <kbd>String()</kbd>.</p>&#13;
<ol start="3">&#13;
<li>So, let's write a test against the current function:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func testThatTextInputValidatesWithSingleWhitespaces() {<br/>    let result = viewControllerUnderTest?.isUserInputValid(withText: "multiple white spaces")<br/>    XCTAssertFalse(result!)<br/>}</pre>&#13;
<ol start="4">&#13;
<li>With that, we're happy we've asserted everything we set out to do in our test cases. Now, we can go ahead and run our test.</li>&#13;
</ol>&#13;
<p>As expected, our test failed, which is obvious for two reasons. First, we didn't really write up our function, and second, we hardcoded the return type as <strong>false</strong>. </p>&#13;
<p>We actually hardcoded the return type as false on purpose – we did this as the TDD methodology is done in three stages:</p>&#13;
<ol>&#13;
<li><strong>Fail test</strong>: <em>Done, we did that.</em></li>&#13;
<li><strong>Pass test</strong>: <em>Can be as messy as you like.</em></li>&#13;
<li><strong>Refactor cod</strong>e: <em>We can do this with the utmost confidence.</em></li>&#13;
</ol>&#13;
<p>The idea is to write your unit test while covering all the scenarios and asserts that may be required for that test case and make it fail (like we did).</p>&#13;
<p>With the foundation set up, we can now confidently move over to our function and code away, safe in the knowledge that we'll be able to run our test to check if our function is broken or not:</p>&#13;
<pre>func isUserInputValid(withText text: String) -&gt; Bool {<br/>    return !text.contains(" ")<br/>}</pre>&#13;
<p>This is nothing special, but for the purpose of this section, it doesn't need to be. TDD with Swift doesn't have to be daunting. After all, it's just a methodology that works perfectly well with XCTest.</p>&#13;
<h2 id="uuid-23d3224e-cf84-4b74-b7d9-2a01e11a1ba4">See also</h2>&#13;
<p>You can find out more information about <strong>unit testing</strong> at <a href="https://developer.apple.com/documentation/xctest">https://developer.apple.com/documentation/xctest</a>.</p>&#13;
<h1 id="uuid-fbba4b9a-8a67-48d6-866c-b53d858dfd13">User interface testing with XCUITest</h1>&#13;
<p><strong>User interface</strong> (<strong>UI</strong>) testing has been around for a while. In theory, it's done every day by any one person who is using, testing, or checking an app, but in terms of automation, it's had its fair share of critics.</p>&#13;
<p>However, with Swift and XCTest, this has never been easier, and the beauty regarding how we will implement this has an amazing hidden benefit.</p>&#13;
<h2 id="uuid-45c619a0-b840-4392-97e2-9afa8c4b1dc1">Getting ready</h2>&#13;
<p>Unlike unit testing, when we are testing against a function, piece of logic, or algorithm, user interface tests are exactly what they say on the tin. They are a way for us to test the UI and UX of the app – things that might not have necessarily been generated programmatically.</p>&#13;
<p>Head on over to the <kbd>CocoaTouchUITests.swift</kbd> file that was automatically generated when we created our project. Again, much like the unit tests, you'll notice some placeholder functions in there. We'll start by taking a look at one called <kbd>testExample()</kbd>.</p>&#13;
<h2 id="uuid-e33377ff-3f92-4f56-acc3-9d70fc95af68">How to do it...</h2>&#13;
<p>With what we mentioned in the <em>Getting ready</em> section in mind, let's take a look at our app and see what we would like to test. The first thing that comes to my mind is the search bar:</p>&#13;
<div><img src="img/1926f57d-e978-4082-8a62-618bcb28b18a.png" style="" width="447" height="932"/></div>&#13;
<p>Figure 6.21 – Search bar selected</p>&#13;
<p>Now that we've made this mandatory to populate in order for our app to work, we want to make sure this is here all the time, so let's write a UI test for this:</p>&#13;
<pre>func testExample() throws {<br/>    // UI tests must launch the application that they test.<br/>    let app = XCUIApplication()<br/>    app.launch()<br/>}</pre>&#13;
<p>As the comment correctly states, in order for the tests to be successful, the app needs to be launched, which is taken care of by the <kbd>launch()</kbd> function. However, once our app has been launched, how do we tell it to check for a UITextField and, more importantly, a specific one (in the future, we could have multiple on our screen)?</p>&#13;
<p>To do this, we must start with the basics:</p>&#13;
<ol>&#13;
<li>I've edited the name of the function to make it more applicable to what we are testing here. As you can see from the following highlighted code, we've told our test to select the <kbd>textFields</kbd> element and tap it:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func testThatUsernameSearchBarIsAvailable() throws {<br/>    let app = XCUIApplication()<br/>    app.launch()<br/><strong>    app.textFields.element.tap()</strong><br/>}</pre>&#13;
<ol start="2">&#13;
<li class="mce-root">Go ahead and run the test by clicking on the diamond to the left to watch your app come to life in the simulator. If you're quick enough, you'll see the cursor enter the text box just before the app closes.</li>&#13;
</ol>&#13;
<p>Great work! The test passed, which means you've written your first UI test.</p>&#13;
<p>Regarding our previous test, we weren't specific about the element being identified. For now, this is okay, but building a much bigger and complex app may require that you test certain aspects of specific elements. Let's take a look at how we could achieve this:</p>&#13;
<ol>&#13;
<li>One way would be to set an accessibility identifier for our UITextField – a specific identifier that's required for accessibility purposes that, in turn, will allow our UI test to identify the control we want to test.</li>&#13;
<li>Back over in our <kbd>RepoTableViewController.swift</kbd> file, create an <kbd>IBOutlet</kbd> for the <kbd>UITextField</kbd> object in question and add the following code, remembering to hook up the outlet to your ViewController:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">@IBOutlet weak var usernameTextField: UITextField! {<br/>    didSet {<br/>        usernameTextField.accessibilityIdentifier = <br/>          "input.textfield.username"<br/>    }<br/>}</pre>&#13;
<ol start="3">&#13;
<li>With that in place, comment out or replace our generic <kbd>UTextField</kbd> tap test with the following:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">app.textFields.element(matching: .textField, identifier: <br/>  "input.textfield.username").tap()</pre>&#13;
<ol start="4">&#13;
<li>Now, run your test and watch it pass. Great stuff!</li>&#13;
</ol>&#13;
<p style="padding-left: 60px">Notice that we are identifying a <kbd>textField</kbd> and then matching a control type from <kbd>textField</kbd>. This approach will work wonders when we're testing for nested components in specific views of your app. For example, you might want to search and match for a specific UIButton that you know is embedded within a specific UIScrollView:</p>&#13;
<pre style="padding-left: 60px">app.scrollViews.element(matching: .button, identifier: <br/>  "action.button.stopscrolling").tap()</pre>&#13;
<ol start="5">&#13;
<li>With that done, let's take our test a little further. Notice the <strong><kbd>.tap()</kbd></strong> function we're calling at the end of our element identification. There's plenty more options to choose from, but we'll start by splitting the element into its own variable:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let textField = app.textFields.element(matching: .textField,<br/>  identifier: "input.textfield.username")</pre>&#13;
<ol start="6">&#13;
<li>Notice that's we've removed the <strong><kbd>.tap()</kbd></strong> function. Now, we can simply call this and any other available function via our <kbd>textField</kbd> variable:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">textField.tap()<br/>textField.typeText("MrChrisBarker")</pre>&#13;
<ol start="7">&#13;
<li class="mce-root">Run this to see it in action for yourself. Now, what if we go a little further? Add the following line and run the code once more:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">app.keyboards.buttons["return"].tap()</pre>&#13;
<p style="padding-left: 60px">Hopefully, at this point, you can see where we are going. One thing to bear in mind is that, since we are not mocking data here, we're making a live, asynchronous API call, which, depending on your connection speed or the API, could vary from test to test. </p>&#13;
<ol start="8">&#13;
<li>To check the results, we need our UI test to "wait" for a specific element to come into view. By design, we know that we are expecting a <kbd>UITableView</kbd> with populated cells, so let's write our test based on that:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let tableView = app.tables.staticTexts["XcodeValidateJson"]<br/>XCTAssertTrue(tableView.waitForExistence(timeout: 5))</pre>&#13;
<p style="padding-left: 60px">Line 1 of the preceding code should now be all but familiar to us – we're building an element based on cells within a UITableView (we're not being specific at the time) to look for a specific cell with a label of <kbd>XcodeValidateJson</kbd>.</p>&#13;
<p style="padding-left: 60px">Then, we're doing an XCAssert against this element. Allow for a timeout of 5 seconds for this to appear. If it appears beforehand, the test will pass; if not, it will fail.</p>&#13;
<h2 id="uuid-44b3e9a4-c485-4679-97f2-56fd8fabde27">There's more...</h2>&#13;
<p>So far, we've seen how functions such as <kbd>.tap()</kbd> and <strong><kbd>.typeText()</kbd></strong> can be used when we're interacting with our app. However, these are not standard functions of a <kbd>UIButton</kbd> to <kbd>UITextField</kbd>. When we're identifying our controls, the return type we get back is that of an <kbd>XCUIElement()</kbd>.</p>&#13;
<p>There are more options available that we can use to enhance our UI tests, thus allowing for an intricate yet worthy automated test. Let's take a look at some of the additional options available to us:</p>&#13;
<pre>tap()<br/>doubleTap()<br/>press()<br/>twoFingerTap()<br/>swipeUp()<br/>swipeDown()<br/>swipeLeft()<br/>swipeRight()<br/>pinch()<br/>rotate()</pre>&#13;
<p>Each comes with additional parameters that allow you to be specific and cover all the aspects of your user experience in the app (for example, <kbd>press()</kbd> has a duration parameter).</p>&#13;
<p>At the beginning of this section, I mentioned that UI tests come with a great additional benefit, and this is something we have seen already: accessibility. Accessibility is an important factor when building mobile apps, and Apple gives us the best possible tools to do this with Xcode and the Swift programming languages. However, from a theory perspective, if you take the time to build our accessibility into your app, you're indirectly making it much easier to build and shape the UI test around these identifiers – almost doing a good 50% of the work for you – while including an amazing feature.</p>&#13;
<p>Alternatively, writing a good UI test can lead to improved accessibility in your app, making it really easy to have one complement the other when building your app.</p>&#13;
<h2 id="uuid-2ee9a516-2a2c-4f19-a6ce-adc3371c0bae">See also</h2>&#13;
<p>You can find more information about <strong>XCUITest</strong> at <a href="https://developer.apple.com/documentation/xctest/xcuielement">https://developer.apple.com/documentation/xctest/xcuielement</a>.</p>&#13;
<h1 id="uuid-e4bd06a8-fbed-45bf-a057-afccdc5f92c9">Backward compatibility</h1>&#13;
<p>Backward compatibility is inevitable. Unless you build an app for the latest version of iOS and plan to support that – and only that – version of iOS, you're going to have to handle backward compatibility at some point. In this recipe, we'll take a look at what Apple offers in terms of building for APIs that have been built with older versions of Swift.</p>&#13;
<p>We'll also take a look at migration options from previous versions of Swift and if and how legacy projects can be updated to their latest versions.</p>&#13;
<h2 id="uuid-3e7b248a-f759-4e61-b588-8b93bdda73a3">How to do it...</h2>&#13;
<p>We all want to use the latest shiny features in our app. Luckily, Apple makes this relatively easy for us to handle with the use of the <strong>#available</strong> check. So, how does this work? Well, primarily, it can work in three ways: at the function level, at the class level, and at the inline API level.</p>&#13;
<p>Let's start with the latter and have a look at how we would do this at the API level:</p>&#13;
<ol>&#13;
<li>Here is an example of setting <kbd>maskedCorners</kbd> on a layer in <kbd>UIView()</kbd>:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">UIView().layer.maskedCorners = [.layerMinXMaxYCorner, <br/> .layerMaxXMaxYCorner]</pre>&#13;
<p style="padding-left: 60px">This is standard for APIs with iOS 11 and above, but what happens if your app supports iOS? In an ideal world, you only want to support two versions of iOS (including the current one), but that's not always possible. For example, in some retail apps, you may have an existing percentage of customers who you need to support. This also happens in the real world.</p>&#13;
<p style="padding-left: 60px">So, if your Xcode project has been set up to support iOS 10, you'll actually get a generated error, similar to the following:</p>&#13;
<div><img src="img/d93f73b2-3623-41bb-ac6c-7ada401eab53.png" style="" width="723" height="55"/></div>&#13;
<p>Figure 6.22 – Available API error</p>&#13;
<ol start="2">&#13;
<li>Click the red indicator to the left and you'll see the following options:</li>&#13;
</ol>&#13;
<div><img src="img/f0e79776-f5e0-4b63-9b2c-7958b90f4898.png" style="" width="837" height="182"/></div>&#13;
<p>Figure 6.23 – Available API error options</p>&#13;
<p style="padding-left: 60px" class="mce-root">As we mentioned previously we've got three options here: add a version check against the API itself, add a check against the method, or enclose the entire class.</p>&#13;
<ol start="3">&#13;
<li>Go ahead and click Fix for the first option. You'll see the following:</li>&#13;
</ol>&#13;
<pre>if #available(iOS 11.0, *) {<br/>    UIView().layer.maskedCorners = [.layerMinXMaxYCorner, <br/>      .layerMaxXMaxYCorner]<br/>} else {<br/>    // Fallback on earlier versions<br/>}</pre>&#13;
<p style="padding-left: 60px">Here, we're given the option to compile the API for a specific version of iOS, allowing us to make use of the API and use a fallback or contingency API, should we want to.</p>&#13;
<p style="padding-left: 60px">This is a great way to keep up to date with the latest changes that are being made to iOS and keep your code base fresh. However, this can come with some downsides. For example, if the API you've targeted is for a specific feature, you may find yourself struggling to find a suitable fallback (or worse, having to depend on a third-party library). You must also think about testing – you're potentially doubling your testing efforts when they may have only required a light regression test for earlier versions of iOS. Now, you'll have to make sure certain features are tested on multiple versions.</p>&#13;
<ol start="4">&#13;
<li>Next, let's take a look at the <strong>enclosing instance method</strong>, which allows us to wrap a whole function around a specific version check:</li>&#13;
</ol>&#13;
<pre><strong>@available(iOS 11.0, *)</strong><br/>func availableCheck() {<br/>    UIView().layer.maskedCorners = [.layerMinXMaxYCorner,<br/>      .layerMaxXMaxYCorner]<br/>}</pre>&#13;
<p style="padding-left: 60px">As we can see, our function and its contents stay intact – we just decorate the function with the highlighted change.</p>&#13;
<ol start="5">&#13;
<li>This is all well and good, but let's try calling this function from somewhere else:</li>&#13;
</ol>&#13;
<div><img src="img/75b04ffa-7b06-4ad0-96a5-b415a0e61feb.png" style="" width="1071" height="61"/></div>&#13;
<p>Figure 6.24 – Available method error options</p>&#13;
<p style="padding-left: 60px">That's right – we're met with the same problem that we came across earlier, but this does have some advantages. For example, if your function relies on a lot of code that has a higher API level – which would be a great way to maintain and manage your codebase – when the time comes to move up to higher SDK support, refactoring doesn't become a mammoth job.</p>&#13;
<ol start="6">&#13;
<li>The final "enclosing class" option follows a similar approach to the method approach, except this occurs at the class level. Your class is simply decorated like so:</li>&#13;
</ol>&#13;
<pre><strong>@available(iOS 11.0, *)</strong><br/>class ReposTableViewController: UITableViewController { }</pre>&#13;
<h2 id="uuid-8c13576d-5944-4d7e-8f53-dd6b6cc8bcf3">There's more...</h2>&#13;
<p>Swift has come in many shapes and sizes since its release in 2013, with each new version offering a wider range of APIs and stability. The move to open source has had a massive part to play in that too, but moving from one version to another with each release has often been aided with the help of Xcode's migration tool.</p>&#13;
<p class="mce-root">But be warned: you can't simply take an app build in Swift 1.1 and migrate this to Swift 5.3 with Xcode 12 (as nice as that would be...).</p>&#13;
<p>Each release, from Swift 3.0 onward, allows you to migrate via the migration tool. For example, Xcode 9 would let you go from <strong>Swift 2.2</strong> to <strong>Swift 3</strong>, Xcode 10 would let you go from <strong>Swift 3</strong> to <strong>Swift 4</strong>, and so on.</p>&#13;
<p>This doesn't mean you have to support the latest version of Swift with the latest version of Xcode – the upgrade options are backward compatible too.</p>&#13;
<p class="CDPAlignLeft CDPAlign">For example, our CocoaTouch project uses <strong>Swift 5</strong>, but options to use <strong>Swift 4.2</strong> and <strong>Swift 4</strong> are available via Xcode's Build Settings:</p>&#13;
<div><img src="img/39949859-68a5-4454-894a-1ce3fb79915e.png" style="" width="647" height="175"/></div>&#13;
<p>Figure 6.25 – Select Swift Language Version option</p>&#13;
<p>If you need to go back any further, you'll have to download a previous version of Xcode from the Apple Developer portal. More often than not, multiple versions of Xcode can play nicely together, although this was only really supported from Xcode 9 onward – you've been warned.</p>&#13;
<h2 id="uuid-ca7dd9b8-2ca1-4354-97c9-263965db3063" class="p1">See also</h2>&#13;
<p>You can find more information about <strong>Swift Version History</strong> at <a href="https://www.javatpoint.com/history-of-swift">https://www.javatpoint.com/history-of-swift</a>.</p>&#13;
&#13;
&#13;
            &#13;
&#13;
            &#13;
        &#13;
    </div></body></html>