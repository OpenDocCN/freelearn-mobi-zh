# 第4章。添加控件

玩家通过非常有限的操作来控制移动游戏。通常，游戏只包含一个机制：在屏幕上任何地方轻触以跳跃或飞行。与此相对的是拥有数十种按钮组合的家用游戏机控制器。在如此少的动作下，保持用户通过光滑、有趣的控件保持兴趣对于游戏的成功至关重要。

在本章中，你将学习实现从应用商店中出现的几种流行控制方案。首先，我们将尝试倾斜控制；设备的物理方向将决定玩家的飞行方向。然后，我们将连接我们的精灵节点上的 `onTap` 事件。最后，我们将实现并完善我们游戏中飞行的简单控制方案：在屏幕上任何地方轻触以飞得更高。你可以结合这些技术，在你的未来游戏中创建独特且有趣的控件。

本章包括以下主题：

+   为 `Player` 类进行飞行改造

+   使用 Core Motion 轮询设备移动

+   连接精灵 `onTap` 事件

+   教导我们的企鹅学会飞行

+   改进相机

+   当玩家向前移动时循环地面

# 为玩家类进行飞行改造

在我们可以对玩家输入做出反应之前，我们需要执行一些快速设置任务。我们将移除一些旧的测试代码，并为 `Player` 类添加一个物理体。

## 蜜蜂饲养者

首先，清理上一章中旧的蜜蜂物理测试。打开 `GameScene.swift`，找到 `didMoveToView`，找到底部两行；一行设置了 `bee2` 的质量，另一行对 `bee2` 应用了冲量。删除这些行。

## 更新玩家类

我们需要为 `Player` 类提供一个自己的 `update` 函数。我们希望在 `Player` 中存储与玩家相关的逻辑，并且我们需要它在每一帧之前运行。

1.  打开 `Player.swift` 并在 `Player` 中添加以下函数：

    [PRE0]

1.  在 `GameScene.swift` 中，在 `GameScene` 类的底部添加以下代码：

    [PRE1]

完美。`GameScene` 类将在每次更新时调用 `player class update` 函数。

## 移动地面

在上一章中，我们最初将地面设置得比必要的位置更高，以确保它在所有屏幕尺寸上都能显示。现在，由于玩家将很快开始移动，将相机带到他们想去的地方，我们可以将地面移动到其最终位置。

在 `GameScene.swift` 中，找到定义 `groundPosition` 常量的行，并将 `y` 值从 `100` 更改为 `30`：

[PRE2]

## 为玩家分配物理体

我们将使用物理力来移动屏幕上的玩家。要应用这些力，我们必须首先为玩家精灵添加一个物理体。

### 从纹理创建物理体形状

当游戏玩法允许时，您应该使用圆形来定义您的物理体 - 它是物理模拟中最有效的形状，并产生最高的帧率。然而，皮埃尔形状的准确性对我们游戏玩法非常重要，而圆形并不是他的形状的理想选择。相反，我们将根据他的纹理分配一种特殊的物理体类型。

苹果在Xcode 6中引入了使用不透明纹理像素定义物理体形状的能力。这是一个方便的补充，因为它允许我们轻松创建极其精确的精灵形状。使用这些由纹理驱动的物理体会有性能损失；使用这些纹理驱动的物理体计算成本很高。您应该谨慎使用，仅在对您最重要的精灵上使用。

要创建皮埃尔的物理体，在`Player.swift`的`spawn`函数底部添加以下代码：

[PRE3]

运行项目后，地面看起来会上升至皮埃尔处。因为我们已经给他一个物理体，所以他现在受到重力的作用。皮埃尔实际上正在下降网格，而摄像头正在调整以保持他居中。现在这很好；稍后我们将给他飞向天空的工具。接下来，让我们学习如何根据物理设备的倾斜移动一个角色。

# 使用核心运动轮询设备移动

苹果提供了**核心运动**框架，以暴露iOS设备在物理空间中的精确方向信息。我们可以使用这些数据，当用户将设备倾斜到他们想要移动的方向时，在屏幕上移动我们的玩家。这种独特的输入风格为移动游戏提供了新的游戏玩法机制。

### 注意

您需要一台物理iOS设备来完成这个核心运动部分。Xcode中的iOS模拟器无法模拟设备移动。然而，这部分只是一个学习练习，并不是完成我们正在构建的游戏所必需的。我们的最终游戏将不会使用核心运动。如果您无法使用物理设备进行测试，请随意跳过核心运动部分。

## 实现核心运动代码

检测设备方向非常简单。我们将在每次更新时检查设备位置，并给我们的玩家应用适当的力。按照以下步骤实现核心运动控制：

1.  在`GameScene.swift`中，靠近顶部，在`import SpriteKit`行下方添加一个新的`import`语句：

    [PRE4]

1.  在`GameScene`类中，添加一个名为`motionManager`的新常量，并实例化一个`CMMotionManager`对象：

    [PRE5]

1.  在`GameScene`函数`didMoveToView`中，在底部添加以下代码。这会让核心运动知道我们想要轮询方向数据，因此它需要开始报告数据：

    [PRE6]

1.  最后，在`update`函数的底部添加以下代码以轮询方向，构建适当的向量，并给玩家的角色应用物理力：

    [PRE7]

运行项目。你可以通过倾斜你的设备到你想要移动的方向来滑动 Pierre 横越冰面。干得好——我们成功实现了我们的第一个控制系统。

### 小贴士

注意，当你将 Pierre 向任何方向移动得太远时，他会穿过地面。在本章的后面部分，我们将改进地面，使其不断重新定位以覆盖玩家下方的区域。

这是一个使用 Core Motion 数据进行玩家移动的简单示例；我们不会在我们的最终游戏中使用这种方法。尽管如此，你仍然可以将这个示例扩展到你自己游戏中的高级控制方案。

# 检查点 4-A

要下载我的项目，包括 Core Motion 代码，请访问此地址：

[http://www.thinkingswiftly.com/game-development-with-swift/chapter-4](http://www.thinkingswiftly.com/game-development-with-swift/chapter-4)

# 连接精灵的 onTap 事件

你的游戏通常会需要当玩家点击特定精灵时运行代码的能力。我喜欢实现一个包含你游戏中所有精灵的系统，这样你就可以为每个精灵添加点击事件，而无需构建额外的结构。我们已经在所有采用 `GameSprite` 协议的类中实现了 `onTap` 方法；我们还需要将场景连接起来，以便在玩家点击精灵时调用这些方法。

### 注意

在我们继续之前，我们需要移除 Core Motion 代码，因为我们不会在最终游戏中使用它。一旦你完成对 Core Motion 示例的探索，请按照上一节中的项目符号反向操作将其从游戏中移除。

## 在 GameScene 中实现 touchesBegan

SpriteKit 每次屏幕被触摸时都会调用我们场景的 `touchesBegan` 函数。我们将读取触摸的位置并确定该位置的精灵节点。我们可以检查被触摸的节点是否采用我们的 `GameSprite` 协议。如果是，这意味着它必须有一个 `onTap` 函数，然后我们可以调用它。将以下 `touchesBegan` 函数添加到 `GameScene` 类中——我喜欢将其放置在 `didSimulatePhysics` 函数下方：

[PRE8]

这就是我们连接我们在制作的游戏对象类上实现的全部 `onTap` 函数所需做的。当然，所有这些 `onTap` 函数目前都是空的；我们现在将添加一些功能来展示效果。

## 超乎生活

打开你的 `Bee.swift` 文件并定位到 `onTap` 函数。暂时地，当点击时我们将蜜蜂扩展到巨大的尺寸，以演示我们已经正确地连接了 `onTap` 函数。在蜜蜂的 `onTap` 函数内添加以下代码：

[PRE9]

运行项目并点击蜜蜂。它们将扩展到原来的四倍大小，如下面的截图所示：

![超乎生活](img/Image_B04532_04_01.jpg)

哦不——巨大的蜜蜂！这个例子表明我们的 `onTap` 函数是工作的。你可以从 `Bee` 类中移除你添加的缩放代码。我们将保留 `GameScene` 中的 `onTap` 连接代码，这样我们就可以稍后使用点击事件。

# 教我们的企鹅飞翔

让我们实现企鹅的控制方案。玩家可以点击屏幕上的任何位置使皮埃尔飞得更高，松开手指让他落下。我们将进行相当多的更改——如果你需要帮助，请参考本章末尾的检查点。首先修改`Player`类；按照以下步骤为我们的`Player`准备飞行：

1.  在`Player.swift`中，直接向`Player`类添加一些新属性：

    [PRE10]

1.  到目前为止，皮埃尔默认一直在拍打翅膀。相反，我们想默认显示翱翔动画，只有在用户按下屏幕时才运行拍打动画。在`spawn`函数中，删除运行`flyAnimation`的行，而是运行`soarAnimation`：

    [PRE11]

1.  当玩家触摸屏幕时，我们在`Player`类的`update`函数中应用向上的力。记住`GameScene`每帧调用一次这个`update`函数。在`update`中添加以下代码：

    [PRE12]

1.  最后，我们将在`Player`类中提供两个函数，以便其他类可以开始和停止拍打行为。当`GameScene`类检测到触摸输入时，将调用这些函数。将以下函数添加到`Player`类中：

    [PRE13]

完美，我们的`Player`已经准备好飞翔了。现在我们将简单地从`GameScene`类中调用开始和停止函数。

## 在`GameScene`中监听触摸

`SKScene`类（`GameScene`从中继承）包含了一些方便的函数，我们可以使用这些函数来监控触摸输入。按照以下步骤连接`GameScene`类：

1.  在`GameScene.swift`的`touchesBegan`函数中，在底部添加以下代码以在用户触摸屏幕时开始`Player`拍打：

    [PRE14]

1.  在`touchesBegan`下方，在`GameScene`类中创建两个新函数。这些函数在用户从屏幕上抬起手指或iOS通知中断触摸时停止拍打：

    [PRE15]

## 微调重力

在测试我们新的飞行代码之前，我们需要进行一项调整。默认的重力设置为-9.8感觉太真实了。皮埃尔生活在卡通世界里；现实世界的重力有点拖沓。我们可以在`GameScene`类中调整重力；在`didMoveToView`函数的底部添加以下行：

[PRE16]

## 展开翅膀

运行项目。点击屏幕使皮埃尔飞得更高，松开手指让他落下。玩这个动作；皮埃尔旋转向他的矢量，并在你点击和松开时积累或失去动力。太棒了！你已经成功实现了我们游戏的核心机制。花一分钟时间享受上下飞翔的感觉，就像这个截图所示：

![展开翅膀](img/Image_B04532_04_02.jpg)

# 改进相机

我们相机的代码运行良好；它跟随玩家飞行的任何地方。然而，我们可以改进相机以增强飞行体验。在本节中，我们将添加两个新功能：

+   当皮埃尔企鹅飞得更高时，放大相机，增强增加高度的感觉。

+   当玩家下降到屏幕下半部分时，暂停垂直居中。这意味着地面永远不会占据屏幕太多，当皮埃尔飞得更高，相机开始再次跟踪他时，增加了向上切割空气的感觉。

按照以下步骤实现这两个改进：

1.  在 `GameScene.swift` 中，在 `GameScene` 类中创建一个新变量以存储屏幕的中心点：

    [PRE17]

1.  在 `didMoveToView` 函数中，使用计算出的屏幕高度的中间值设置这个新变量：

    [PRE18]

1.  我们需要显著重构 `didSimulatePhysics` 函数。删除现有的 `didSimulatePhysics` 函数，并用以下代码替换它：

    [PRE19]

运行项目，然后飞起。随着高度的增加，世界会缩小。当飞近地面时，相机现在也允许皮埃尔潜入屏幕中心以下。以下截图说明了两种极端情况。注意顶部屏幕中的小精灵，皮埃尔飞得更高，相机也拉远。在底部画面中，当皮埃尔接近地面时，相机停止垂直跟随：

![改进相机](img/Image_B04532_04_03.jpg)

这种综合效果为游戏增添了大量光泽，并增加了飞行的乐趣。我们的飞行机制感觉很好。下一步是将皮埃尔推进世界。

# 推进皮埃尔前进

这种游戏风格通常以恒定速度推进世界。而不是应用力或冲量，我们可以在每次 `update` 中手动为皮埃尔设置一个恒定速度。打开 `Player.swift` 文件，并在 `update` 函数中添加以下代码：

[PRE20]

运行项目。我们的主角企鹅会穿过蜜蜂群和世界向前移动。这很好，但你很快会发现，随着皮埃尔向前移动，地面会消失，如这个截图所示：

![推进皮埃尔前进](img/Image_B04532_04_04.jpg)

记得我们的地面宽度只有屏幕宽度的三倍。而不是扩展地面，我们将在适时的间隔移动地面的位置。由于地面由重复的瓷砖组成，有许多机会可以无缝地跳过其位置向前移动。我们只需要找出玩家移动了正确的距离。

## 跟踪玩家的进度

首先，我们需要跟踪玩家飞行的距离。我们稍后会用到这个数据，用于记录高分。这很容易实现。按照以下步骤跟踪玩家飞行的距离：

1.  在 `GameScene.swift` 文件中，向 `GameScene` 类添加两个新属性：

    [PRE21]

1.  在 `didMoveToView` 函数中，更新生成玩家的行，使用新的 `initialPlayerPosition` 常量而不是旧的硬编码值：

    [PRE22]

1.  在 `didSimulatePhysics` 函数中，更新新的 `playerProgress` 属性以包含玩家的新距离：

    [PRE23]

完美 – 现在我们可以在 `GameScene` 类中随时访问玩家的进度。我们可以使用行进距离在正确的时间重新定位地面。

## 地面循环

有许多可能的方法来创建无限地面循环。我们将实现一个简单的解决方案，在玩家行进到大约三分之一的宽度后，将地面向前跳跃。这种方法保证了如果我们的玩家从中间三分之一开始，地面总是覆盖屏幕。

我们将在 `Ground` 类上创建跳跃逻辑。按照以下步骤实现无限地面：

1.  打开 `Ground.swift` 文件，并为 `Ground` 类添加两个新属性：

    [PRE24]

1.  在 `createChildren` 函数中，我们找到从三分之一的孩子瓦片的总宽度，并将其作为我们的 `jumpWidth`。每次玩家行进这段距离时，我们都需要将地面向前跳跃。你只需要在函数底部附近添加一行：在展开纹理的条件下。以下示例中，我将展示整个函数，以提供上下文，新行将以粗体显示：

    [PRE25]

1.  在 `Ground` 类中添加一个名为 `checkForReposition` 的新函数，位于 `createChildren` 函数下方。场景将在每一帧调用此函数以检查我们是否应该将地面向前跳跃：

    [PRE26]

1.  打开 `GameScene.swift` 文件，并在 `didSimulatePhysics` 函数的底部添加以下行以调用 `Ground` 类的新逻辑：

    [PRE27]

运行项目。当皮埃尔向前飞行时，地面看起来会无限延伸。这种循环地面是最终游戏世界的一大步。这可能看起来是为一个简单的效果而做的大量工作，但循环地面很重要，我们的方法将在任何屏幕尺寸上表现良好。干得好！

# 检查点 4-B

要下载到这一点的项目，请访问此地址：

[http://www.thinkingswiftly.com/game-development-with-swift/chapter-4](http://www.thinkingswiftly.com/game-development-with-swift/chapter-4)

# 摘要

在本章中，我们将技术演示转变为真实游戏的开始。我们添加了大量新的代码。你学习了如何实现三种不同的移动游戏控制方法：物理设备运动、精灵点击事件以及当屏幕被触摸时飞得更高。我们为飞行机制进行了优化，让皮埃尔飞向世界的前方。

你还学习了如何实现两个常见的移动游戏需求：地面循环和更智能的摄像头系统。这两个功能对我们的游戏产生了重大影响。

接下来，我们将为我们关卡添加更多内容。飞行已经很有趣了，但穿过前几个蜜蜂时感觉有点孤单。我们将在 [第 5 章](ch05.html "第 5 章。生成敌人、金币和道具") *生成敌人、金币和道具* 中给皮埃尔企鹅一些同伴。
