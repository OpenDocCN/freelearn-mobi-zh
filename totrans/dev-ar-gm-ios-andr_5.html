<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Advanced Augmented Reality</h1></div></div></div><p>There are a lot of possibilities for delivering augmented reality experiences. In this chapter, we will discuss a lot of the advanced features that are available when using Vuforia with Unity. We will do that while developing a small arcade augmented reality game. The game is a classic arcade game, with an augmented reality twist that will make it feel fresh. We will be making an augmented reality whack a mole game.</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec29"/>Augmented reality games</h1></div></div></div><p>A lot of developers misunderstand the value of augmented reality games. Many view AR games as unprofitable and marginalized<a id="id167" class="indexterm"/> due to the fact that most, if not all, AR games cannot go viral and tend to not sell. This might be true due to the fact that AR games tend to require motion, a trackable, or both, like in the game we will now make. Those requirements make the game not playable at any time by the user, but what a lot of people tend to overlook is that it is ok for AR games not to go viral.</p><p>AR games, while not going to spawn the next Angry Birds, can deliver a unique experience for a specific purpose. For example, AR games can be used quite effectively for promotion games. The game can trigger on a promotion flyer or a page in the magazine and then a competitive game spawns up with a chance to win a real prize, for example. This insures that the user received a positive experience in the form of a fresh AR game, and at the same time, we are sure the user viewed the promotion and joined a competition. AR games can also be used in exhibitions or stores for many uses: promotional or pure entertainment.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec30"/>Unity as a game engine</h1></div></div></div><p>Surely Unity makes making AR <a id="id168" class="indexterm"/>apps easier and deployable to multiple platforms, but that is not where its true power comes from. Unity is first and foremost a <a id="id169" class="indexterm"/>very powerful modern game engine. It is used to power some of the industry's known games, both on mobile and PC. Not utilizing that kind of power to deliver very fresh AR experiences is inexcusable, because it is quite easy to understand how the engine works.</p><p>In this chapter, we will <a id="id170" class="indexterm"/>go over some of the elements in Unity that allow the making of simple games. We will go over how to add audio effects to the game, how to animate objects, how to set the world's physics, how to control particle effects, and how to factor in user interactions. Hopefully that will be enough to display how effective it is to build an AR game in Unity.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec17"/>Setting up the environment</h2></div></div></div><p>Now, we can start a new <a id="id171" class="indexterm"/>Unity project for the Whack-A-Mole game that we are creating. Like we did previously in the book, we set up Unity's environment for the AR app. The following are the steps again:</p><div><ol class="orderedlist arabic"><li class="listitem">Change the value of <strong>Platform</strong> to <strong>IOS</strong> from the <strong>Build Settings</strong> under the <strong>File</strong> menu.</li><li class="listitem">Import Vuforia Unity package by navigating to <strong>Import Package</strong> | <strong>Assets</strong>.</li><li class="listitem">Import the <code class="literal">exampleDataset.unitypackage</code> file that we used previously in <a class="link" href="ch03.html" title="Chapter 3. Understanding Vuforia">Chapter 3</a>, <em>Understanding Vuforia</em>, that contains the dataset for trackables. They are available in this chapter's assets too.</li><li class="listitem">Add <strong>ARCamera</strong> and <strong>ImageTarget</strong> prefabs from the <strong>Qualcomm Augmented reality</strong> prefab folder.</li><li class="listitem">Set the <strong>ImageTarget</strong> to use the dataset we have imported, and set it to use <strong>Chips</strong> target from the <strong>Inspector</strong>.</li><li class="listitem">Set <strong>ARCamera</strong> to load our dataset and activate it as well.</li><li class="listitem">Save the scene to the <strong>Assets</strong> folder, and name it <code class="literal">Level</code>.</li></ol></div><p>The following screenshot shows created the project for our Whack-A-Mole game:</p><div><img src="img/0032OS_05_01.jpg" alt="Setting up the environment"/></div><p>We should end up with similar settings for the environment, as shown in the preceding screenshot. Now it is <a id="id172" class="indexterm"/>ready for us to start adding the elements that will make up our game.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec31"/>The Whack-A-Mole game</h1></div></div></div><p>In this section, we will go over the design of the game we are making. It is a simple Whack-A-Mole game with a twist. Over our target, we want to render a ground filled with mole holes, where the moles will pop up and down randomly from them. The user will be able to shoot<a id="id173" class="indexterm"/> balls at the moles from the device to the target; if a ball hits a mole, we will make the mole disappear with a sound effect and spawn a particle effect.</p><p>There will be no score system or a way to actually clear the level. We will just have this game as a demonstration of how games are made for AR in a simple way. All assets used in this game are available in the <code class="literal">Assets</code> folder in the code bundle of this chapter.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec18"/>Creating the ground for moles</h2></div></div></div><p>The first thing we need to do is to create the <a id="id174" class="indexterm"/>ground level from which moles will pop up. We need to create a plane that will be layered right on top of the trackable with a ground texture attached to it.</p><div><ol class="orderedlist arabic"><li class="listitem">Let's create a plane from the <strong>GameObject</strong> menu. Choose <strong>Create other</strong> and click <strong>Plane</strong>. This will create a plane in the scene. Make sure the plane we created has the same position as the trackable; both should be at the global origin, which is at (0, 0, 0).</li><li class="listitem">Now, resize the plane like we have done before by clicking on the <strong>Resize</strong> button at the top-left toolbar. Resize the plane so that its width exactly covers the trackable. The height of the plane most likely will be bigger than the trackable, but that is all right as long as the trackable is completely covered in the scene. The following screenshot shows the Z-Buffer distortion:<div><img src="img/0032OS_05_02.jpg" alt="Creating the ground for moles"/></div></li></ol></div><p>We might have noticed that the distortion that is happening between the trackable and the plane we just added. This is because both the trackable and the plane have the exact same position in the y axis. The engine doesn't know which one to render on top of the other, and something called <a id="id175" class="indexterm"/>
<strong>Z-Buffer conflict</strong> happens, where the engine keeps on alternating between the components <a id="id176" class="indexterm"/>to be rendered on the top. The solution is to simply adjust the plane's y axis position to be slightly above that of the trackable.</p><div><ol class="orderedlist arabic"><li class="listitem">Name the plane <code class="literal">Ground</code>, and attach it to the trackable by dragging-and-dropping it from the <strong>Hierarchy</strong> list to <strong>ImageTarget</strong>.</li><li class="listitem">Now that the ground plane is in place, the first thing we will get the urge to do is to lose that plain white texture that is there by default on the plane. We would want it to look like an actual ground, so we will create a material for it. Materials for Unity are components that carry the information of what is the texture of the object and what shader is used to render it. It is very important and used extensively for almost every object in any scene.</li><li class="listitem">First, create two folders in the <strong>Assets</strong> folder of our project from Unity. Name one <code class="literal">Textures</code>; this is where we will keep the texture images of our materials, and the other <code class="literal">Materials</code>; this is where we are going to create our materials.</li><li class="listitem">Now drag-and-drop the file named <strong>Ground.jpg</strong> into the <strong>Textures</strong> folder we just created. We could also add the asset through the <strong>Assets</strong> menu, like we saw before. This just added the texture image for the ground to our project.</li><li class="listitem">Now, let's create the material; inside the <strong>Materials</strong> folder we just created, from the <strong>Assets</strong> menu, choose <strong>Material</strong>. This creates a new material that we will name as <code class="literal">Ground</code>. Now attach the <strong>Ground</strong> material we created to the ground plane. Do this by simply dragging the material and dropping it on <strong>Ground</strong> plane in the <strong>Hierarchy</strong> panel.</li></ol></div><p>Notice that the plane stays white as it was before; this is because we haven't attached the texture yet to the material. To do that, access the material we just added to the <strong>Ground</strong> plane by selecting the <strong>Ground</strong> plane and from the <strong>Inspector</strong>; here we will find the <strong>Material</strong> we assigned. <a id="id177" class="indexterm"/>There is a small <a id="id178" class="indexterm"/>
<strong>Texture</strong> property under <strong>Material</strong>, drag-and-drop the texture we added earlier to this box. The following screenshot shows the <strong>Ground</strong> material attached:</p><div><img src="img/0032OS_05_03.jpg" alt="Creating the ground for moles"/></div><p>Now we have an ok looking ground for our moles. Notice that the shader for the material is <strong>Diffuse</strong>. This type of shader is suitable for opaque materials and works perfectly fine for the ground texture. Later on, we can use different shaders for different materials to achieve different results, such as the transparency or particle shader.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec32"/>The Whack-A-Mole model</h1></div></div></div><p>Now that we have the ground to build on, it is time to add our mole model to the project. Simply create a folder<a id="id179" class="indexterm"/> in the <strong>Assets</strong> folder, and name it <code class="literal">Models</code>. Drag-and-drop the file from the chapter assets named <code class="literal">WhackAMoleModel.fbx</code>. Unity will automatically import the model into the project and will create a prefab for us.</p><div><ol class="orderedlist arabic"><li class="listitem">Like we have done before, drag-and-drop the prefab created for <code class="literal">WhackAMoleModel</code> into our scene. You might not automatically see where the model was added; this is mainly because the model is too small in comparison to the ground plane. If you focus on the model by holding the <em>F</em> key, you will see how small the model is.<div><div><h3 class="title"><a id="tip03"/>Tip</h3><p>To change that, we can scale the model using the same way we did before, which is to scale it from the editor, or we can change the FBX Converter settings. The FBX Converter settings handle how the model is inserted into our scene through many settings specific to the model. If we are to scale the model in the editor, it will naturally not have a 1:1 ratio between the model and the world. This is done in real time, takes up resources, and makes scripting more confusing and frustrating.<a id="id180" class="indexterm"/> It is recommend to scale objects from their model settings.</p></div></div></li><li class="listitem">Click on the model's prefab in the folder, and the <strong>Inspector</strong> will display the <strong>FBX Converter</strong> settings. There is a setting for <strong>Scale Factor</strong>, that is by default set to a very small value, which is <strong>0.01</strong>. This is how big the model is to be inserted to the scene compared to its original scale from the 3D modeling application. Change this setting to <strong>0.7</strong>, and click on <strong>Apply</strong>. The model will resize automatically in the scene without changing the scale transform in the scene itself. The following screenshot shows <code class="literal">WhackAMoleModel</code> scaled and positioned in the middle:<div><img src="img/0032OS_05_04.jpg" alt="The Whack-A-Mole model"/></div></li><li class="listitem">Position the model exactly at the center of the ground and to be on top of the ground correctly. After that, attach the <strong>WhackAMoleModel</strong> object to the <strong>ImageTarget</strong> in the <strong>Hierarchy</strong> to set the <strong>ImageTarget</strong> as its parent object.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec19"/>Adding colliders to the scene</h2></div></div></div><p>Unity simulates physics for the objects in the game, but only when we specify what is being simulated and how. The reason for this is that in most games, not every single object is simulated by physics. For example, not every wall in every game is breakable. There are static objects that are just<a id="id181" class="indexterm"/> there simply defying physics, but for games, that is quite all right.</p><p><strong>Collider</strong> is a component<a id="id182" class="indexterm"/> that we can attach to any object in the scene that makes this object "collidable" with any other collidable object. For example, if we are making a shooting game such as <em>Call of Duty</em> or the likes of it, if we do not attach a collider to all walls in our game, the game character will be able to simple "walk through" the wall. This is, of course, not desirable.</p><p>For our game, we need to be able to "whack" the mole; if there is no collider on the mole, we certainly won't be able to whack it. Also, the balls that we will be shooting at the moles need to be able to collide with the ground, not just pass through it. All of this is possible with colliders.</p><div><ol class="orderedlist arabic"><li class="listitem">First, select the <strong>WhackAMoleModel</strong> from the scene, and expand it to reveal the <strong>MoleHill</strong> and the character. Those are the two components to which we need to add the colliders. First, select the character from the scene, and select <strong>Box Collider</strong> by navigating to <strong>Component</strong> | <strong>Physics</strong>. This will add a collider with the shape of a box around the character. The box won't be exactly wrapping the character, but it is cheap on resources, and is enough in our case to simulate a good collision with the balls that we will fire at the moles.</li><li class="listitem">Next, select the <strong>MoleHill</strong>; the <strong>MoleHill</strong> is irregular in shape, and we need the ball collision with it to be simulated more effectively than what a box collider can do. This is why we need to use a Mesh collider. From the same previous menu, now choose <strong>Mesh Collider</strong> to be added to the <strong>MoleHill</strong> model. What the <strong>Mesh Collider</strong> does is that it adds a collider that is exactly the same shape as the model on top of it, so it simulates the collision exactly the same as the model.</li></ol></div><p>The following screenshot shows colliders added to the <strong>Mole</strong> model:</p><div><img src="img/0032OS_05_05.jpg" alt="Adding colliders to the scene"/></div><p>Notice that the ground already has a collider added to it. That is because, by default, any primitive object created <a id="id183" class="indexterm"/>in the editor has a collider attached to it.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec33"/>Creating the ball for the ball gun</h1></div></div></div><p>Now that we have the general feeling of the game being set, we need to create the gun's projectile. It is understandable that because it's a ball gun, it will just shoot spheres, which we can create <a id="id184" class="indexterm"/>through a script. But before we can do that, we need a role model for the script to clone and create in the scene. So, the next thing we will work on is creating the basis for the gun's projectile prefab.</p><div><ol class="orderedlist arabic"><li class="listitem">Select <strong>ARCamera</strong> from the <strong>Hierarchy</strong> panel, and then from the <strong>GameObject</strong> menu navigate to <strong>Create</strong> | <strong>Other</strong> | <strong>Sphere</strong>. This will create a sphere where <strong>ARCamera</strong> is; however, it will not parent it to the camera. It is particularly useful when creating objects at the position of other objects. Change the name of the sphere we just created to <code class="literal">Ball</code>.</li><li class="listitem">Now, the main idea is to have the projectile occupy at least half the camera's view and be at the center of it to give the user a sense of immersion while shooting the balls at the moles. This is easily achievable with everything we know. Simply position the ball directly in front of the camera and resize it till you feel its size is appropriate to the camera. We can check how big it will look like if we look at the <strong>Game</strong> panel in the editor or <strong>Camera Preview</strong> at the bottom-right corner of the <strong>Scene</strong> panel when selecting the camera.</li><li class="listitem">Once the position and scale is right, create a material in the <strong>Materials</strong> folder, and name it <code class="literal">ball</code>. When selecting this material, in the Inspector you will notice a color box that is by default set to <strong>white</strong>. For the ball, we do not need a texture like we did for the ground, but rather, just a color that will make it contrast over the environment. So, just set the color box to red, and then attach the material to the ball. The following screenshot shows the <strong>Ball</strong> projectile in the <a id="id185" class="indexterm"/><strong>Scene</strong> panel:<div><img src="img/0032OS_05_06.jpg" alt="Creating the ball for the ball gun"/></div></li></ol></div><p>Notice that the ball already has a collider by default, which will come in handy when we want the ball to actually collide with the moles and the ground.</p><p>There is one fundamental<a id="id186" class="indexterm"/> thing to point out; adding a collider to the object doesn't make it simulated by physics in the engine, it only makes it collidable with other colliders. But of course, we want the projectile to act like a real projectile and respond to gravity and forces. We want the projectile to bounce off of the floor and off of the moles in a natural way. This is easily simulated in Unity, but we need to tell Unity what to simulate and how.</p><p>Select the <strong>ball</strong> object from the <strong>Hierarchy</strong> panel, and from <strong>Components</strong> menu, go to <strong>Physics</strong>, and select <strong>Rigidbody</strong>. This adds a Rigidbody component to the ball. What the Rigidbody component does is that it simulates physics on the object it is attached to as if the object is a rigid body in the real world. It simulates gravity, bounce, external forces, and everything to which you would expect a real-world rigid body be subjected to, such as an air drag.</p><p>By default, the Rigidbody component is set to simulate gravity on the object. We do not need to change any settings in Rigidbody because they all suit us for now. Simply click the Play button, and we will immediately see the ball falling down in the game world under the effect of gravity.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec20"/>Setting global gravity settings</h2></div></div></div><p>We might have noticed that the ball was falling a little too slow for it to feel natural for the game. This is mainly because our scale is not 1:1 with the game. It is rather 1:1 with the real world. This is <a id="id187" class="indexterm"/>because it is an AR application, and the concern is for it to feel natural with the real-world interaction. This, however, makes us all giants in comparison to the game world when using the AR game. So, it's not that the ball that is falling too slow, a bit of Einstein's relativity coming, it's that the ball that is falling a great distance in relation to us.</p><p>To remedy that, we need to bring up the force of gravity to compensate for the giant status in which we are located. If the gravity is stronger, the ball will fall faster and will give us the feeling that it is natural for our own real world. Luckily, changing the gravity setting in a Unity project is quite simple.</p><div><ol class="orderedlist arabic"><li class="listitem">From the <strong>Edit</strong> menu, go to <strong>Project</strong> settings, and select <strong>Physics</strong>. In the <strong>Inspector</strong>, we will be presented with a number of settings all related to how physics works. We can change any of them, but we only need one changed for now. The first setting is related to gravity. Gravity in the real world acts on the y axis and is roughly -9.81 in magnitude. We need this to be 6 times stronger, so change it to <code class="literal">-60.81</code>.</li><li class="listitem">Click on the Run button, and watch the ball fall much faster and in a more natural manner. The following screenshot shows the gravity settings for the project:<div><img src="img/0032OS_05_07.jpg" alt="Setting global gravity settings"/></div></li></ol></div><p>This should take care<a id="id188" class="indexterm"/> of the physics compensation value and should work naturally in the real world in an AR environment.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec34"/>Adding audio sources</h1></div></div></div><p>We now need to create sound <a id="id189" class="indexterm"/>sources in the scene to handle sound effects for the game. <strong>Sound sources</strong> are audio sources that can be position in the world for 3D positional sound or simple 2D sounds. In order to hear sound effects in the game, audio sources are needed to produce the sound, but also we need a listener to actually capture the created sound to present to the user.</p><p>By default, <strong>ARCamera</strong> has a listener component added to it, so we only need to add the audio sources to it.</p><div><ol class="orderedlist arabic"><li class="listitem">Create a folder and name it <code class="literal">Audio</code> in the <strong>Assets</strong> folder. Drag-and-drop the two files inside the <strong>Audio</strong> folder in the chapter's assets. This will import the two audio files named <code class="literal">ballFire.wav</code> and <code class="literal">moleHit.wav</code>. We will use the first for the sound effect of firing the ball from the gun, and the second for when a ball hits a mole.<p>Because this is an arcade game, we do not need 3D sound positions; we mostly need all audio to be 2D and independent of how far or close we are to the sound source. We do this by changing the setting for the audio assets, which we just imported, in the Inspector.</p></li><li class="listitem">Select the audio file from the <strong>Audio</strong> folder, and from the <strong>Inspector</strong> uncheck the checkbox named <strong>3D Sound</strong>. Do the same for both files. The following screenshot shows the audio settings for the audio files:<div><img src="img/0032OS_05_08.jpg" alt="Adding audio sources"/></div></li><li class="listitem">Now, select <strong>ARCamera</strong>, and then from the <strong>GameObject</strong> menu, select <strong>Create Empty</strong>. What this does is it creates an empty object in the world and near <strong>ARCamera</strong>. Now, rename the object to <code class="literal">ballFireAudio</code>. Now, select the object we have just created, and from the <strong>Component</strong> menu, navigate to <strong>Audio</strong> | <strong>Audio source</strong>. Repeat the same steps to create <code class="literal">moleHitAudio</code>.</li><li class="listitem">Drag-and-drop<a id="id190" class="indexterm"/> the audio file from the <strong>Audio</strong> folder appropriately into the audio source component we have just created. This effectively creates sound sources in our scene. Just uncheck the checkbox named <strong>Play on Awake</strong>, because we need to control this audio source through code. It is a useful option to test how the sound source will play out in the game panel though. The following screenshot shows sound source settings for <a id="id191" class="indexterm"/><strong>ballFireAudio</strong>:<div><img src="img/0032OS_05_09.jpg" alt="Adding audio sources"/></div></li></ol></div><p>Now that the sound sources are in place, we can easily call on them from script to add to the immersion of the app.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec35"/>Scripting the ball gun</h1></div></div></div><p>We have already created the projectile <a id="id192" class="indexterm"/>for the gun, and we also created the sound source for it, but we are yet to make this act like a ball gun; this is when scripting comes in handy.</p><p>The first thing we need to do is to create a prefab for the projectile we created. This is to be able to clone the projectile through the script and fire it at the poor moles. To do that, simply create a folder in the <strong>Assets</strong> folder, and name it <code class="literal">Prefabs</code>. Drag-and-drop the <strong>Ball</strong> object from the <strong>Hierarchy</strong> panel to the folder you just created. Now we have a prefab that we can call upon through code and can create as many balls as we want.</p><p>The ball we have attached to the camera is meaningless, because we will be creating the projectiles through code. So, after we have already made a prefab of the ball, we no longer need it in the scene, but before we remove that, there is another step. We need to have a placeholder from which the projectiles spawn. That placeholder should be in the same position and with the same rotation as the ball we have in the scene right now.</p><p>First, we add an empty object<a id="id193" class="indexterm"/> to the scene from the <strong>GameObject</strong> menu. Now, attach that object to the <strong>ARCamera</strong> object by dragging-and-dropping it. Rename that object to <code class="literal">BallPlaceHolder</code>. We need the <code class="literal">BallPlaceHolder</code> object to have the exact same transformation as that of the <strong>Ball</strong> object. Unfortunately, there is no automatic function in Unity that copies the transformation for two objects, so we need to manually copy it. Click the <strong>Ball</strong> object and copy both the position and rotation of that object, and insert them into the <code class="literal">BallPlaceHolder</code> object. Then, delete the <strong>Ball</strong> object, because we no longer need it.</p><p>The following screenshot shows <strong>BallPlaceHolder</strong> added to the scene:</p><div><img src="img/0032OS_05_10.jpg" alt="Scripting the ball gun"/></div><p>Now, it is time to create a folder for our scripts. Create a new folder in <strong>Assets</strong>, and rename it <strong>Scripts</strong>. Inside the <strong>Scripts</strong> folder, from <strong>Assets</strong> menu, navigate to <strong>Create</strong> | <strong>C# Script</strong>. Name the created file <code class="literal">ballGun</code>. Now, double-click on it, and Unity will automatically open its MonoDevelop Editor for us.</p><p>The following screenshot shows the Unity MonoDevelop Editor:</p><div><img src="img/0032OS_05_11.jpg" alt="Scripting the ball gun"/></div><p>Unity automatically creates a number of things for us in the MonoDevelop Editor. First, it creates a class template <a id="id194" class="indexterm"/>with the name of the script file. This is why the script filename must be that of the class name, among other reasons. It adds two empty functions for us that are very crucial to game development on the platform.</p><p>The <code class="literal">Start()</code> function is a function that is called automatically by Unity engine when the scene starts. It is very useful for variable initialization, and can be thought of as the constructor for the class.</p><p>The <code class="literal">Update()</code> function is a very important function that Unity automatically calls on every frame that passes in the game. This is very important for keeping track of the game object state, maintaining game logic, and many other uses. It is strongly advised not to have intensive calculations inside the <code class="literal">Update()</code> function, because it will slow down the frame rates of the game, because Unity doesn't render the next frame till all <code class="literal">Update()</code> functions in the game are executed completely.</p><p>Now, let's look at the script after the code has been added to it and see what every function does. The following screenshot shows the <code class="literal">ballGun.cs</code> script:</p><div><img src="img/0032OS_05_12.jpg" alt="Scripting the ball gun"/></div><p>This is how the script that will control<a id="id195" class="indexterm"/> the behavior of the ball gun appears. We will be attaching this script to the <code class="literal">ARCamera</code> object, and it will respond to user's touch anywhere on the screen to fire a ball directly toward where the user is pointing the camera. Let's see what every function does in this script.</p><p>The first things we see are the declared variables for the script. They follow a similar syntax to what you would expect from a C# language:</p><div><pre class="programlisting">public GameObject projectile;
public Transform projectilePlaceHolder;
private GameObject ballFireAudio;
private Gameobject Trackable;</pre></div><p>The <code class="literal">public</code> or <code class="literal">private</code> status of the variable is very important in Unity. This is because <code class="literal">public</code> variables appear in the Editor, and their values can be set in the <strong>Inspector</strong>. This is particularly useful and should be kept in mind.</p><p>The <code class="literal">projectile</code> variable<a id="id196" class="indexterm"/> is what we will use from which to link to the <strong>Ball</strong> prefab. It is <code class="literal">public</code>, because we will set its value from the Editor, as we will see in a little while. <code class="literal">projectile</code> is of type <code class="literal">GameObject</code>, which is the general type for any object in the game. It contains a large number of relevant functions and variables that often come in handy. wer sadfas</p><p>The variable <code class="literal">projectilePlaceHolder</code> is of type <code class="literal">Transform</code>. It will hold the transform information of the <code class="literal">BallPlaceHolder</code> object we have in the scene on which to spawn projectiles.</p><p>For the variable <code class="literal">ballFireAudio</code>, as its name suggests, we will be using this to link to the audio source object we created earlier.</p><p>The <code class="literal">Trackable</code> variable will be used to link to the <code class="literal">ImageTarget</code> object. We will use it to parent the spawned projectiles to it. We will do that to allow the balls to disappear if <code class="literal">Trackable</code> is lost from sight:</p><div><pre class="programlisting">
void Start() {
   ballFireAudio = this.gameObject.transform.FindChild("
ballFireAudio").gameObject;
   Trackable = GameObject.Find("ImageTarget").gameObject;
}
</pre></div><p>This is how our <code class="literal">Start()</code> function<a id="id197" class="indexterm"/> looks like. In this function, we are initializing both <code class="literal">ballFireAudio</code> and <code class="literal">Trackable</code> variables. We do that by finding the <code class="literal">GameObject</code> from the scene and attaching it to the variable. Notice that we find the <code class="literal">GameObject</code> by its name; if the name is different, change it accordingly, or the variable will not be initialized correctly:</p><div><pre class="programlisting">void Update () {
   if(Input.GetMouseButtonDown(0))
   {
      ballFireAudio.audio.Play();
      GameObject obj = Instantiate(projectile,
         projectilePlaceHolder.position,
         this.gameObject.transform.rotation) as GameObject;
      obj.gameObject.rigidbody.AddRelativeForce(Vector3.forward * Time.deltaTime * 1100000);
      obj.transform.parent = Trackable.transform;
      Destroy(obj.gameObject,5f);
   }
}</pre></div><p>This is our <code class="literal">Update()</code> function<a id="id198" class="indexterm"/> that will be called with every frame. It mainly listens for user interaction; if the user touches the screen or clicks with the mouse, a <strong>Ball</strong> prefab is instantiated and a force is applied on it to propel it forward with a sound effect. Repeated clicks or touches will spawn more balls.</p><p>What <code class="literal">Input.GetMouseButtonDown(0)</code> does is that it returns <code class="literal">true</code> if the user clicks with the mouse or touches the screen. This is how we listen if the user interacted with the screen. If it is <code class="literal">true</code>, we proceed with our game logic.</p><p>We first play the audio attached to the game object <code class="literal">ballFireAudio</code> to play the sound effect for ball shooting.</p><p>Next, we instantiate a new clone from the prefab <strong>Ball</strong> attached to a projectile variable. We instantiate it into the variable <code class="literal">obj</code> with the transform of the <code class="literal">projectilePlaceHolder</code> position and the rotation of the camera so that it always fires forward.</p><p>We then apply the relative force to the instantiated object's <code class="literal">Rigidbody</code> component to fire forward. The direction is <code class="literal">Vector3.forward</code>, which is the object's forward direction. We multiply it by <code class="literal">Time.deltaTime</code>; we do this to make the force frame rate independent (<code class="literal">Time.deltaTime</code> is the time since the last frame). This avoids making the ball slower if the frame rate drops down for any reason. Then we multiply by the force's power. Notice that the force is really big; this is because we need the ball to fire forward quickly and to also compensate for the ratio <a id="id199" class="indexterm"/>between the game world and the real world as we saw with gravity.</p><p>We then parent the instantiated object to <code class="literal">ImageTarget</code> so that it behaves correctly with the image target.</p><p>Finally, we destroy the object with a delay of 5 seconds. We do that because we do not ever want projectiles to disappear, as this will really deteriorate the performance of the app.</p><div><ol class="orderedlist arabic"><li class="listitem">Now that our script is ready, we need to attach it to the <strong>ARCamera</strong> object. Do this by dragging the script and dropping it on the <strong>ARCamera</strong> object. The script component will appear in <strong>ARCamera</strong> and we will notice that the two public variables <strong>Projectile</strong> and <strong>Projectile Place Holder</strong> are visible in the <strong>Inspector</strong><code class="literal">.</code></li><li class="listitem">Now, we need to drag-and-drop the <strong>Ball</strong> prefab from the <strong>Prefabs</strong> folder to the <strong>Projectile</strong> variable in the <strong>Inspector</strong>. We also need to drag-and-drop the <strong>BallPlaceHolder</strong> object from the scene to the variable <strong>Projectile Place Holder</strong> variable in the <strong>Inspector</strong>. The following shows <strong>ARCamera</strong> with the <code class="literal">ballGun.cs</code> script attached:<div><img src="img/0032OS_05_13.jpg" alt="Scripting the ball gun"/></div></li><li class="listitem">Now that our script is attached correctly to our <strong>ARCamera</strong> object, we can now try it out in the <strong>Game</strong> view.<a id="id200" class="indexterm"/> Click on Run and the click over the panel. The camera will shoot out balls. The following screenshot shows the <code class="literal">ballGun.cs</code> script in action:<div><img src="img/0032OS_05_14.jpg" alt="Scripting the ball gun"/></div></li><li class="listitem">On testing the script, we might notice that the balls are a little too small in comparison to the <a id="id201" class="indexterm"/>mole. We can change that through the <strong>Ball</strong> prefab direction from the <strong>Prefabs</strong> folder. Select it, and then change the scale value for (x, y, z) to <code class="literal">20</code>. This is a prime example of how useful prefabs are when doing changes, because it automatically propagates it for the project.</li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec36"/>Vuforia trackable event handler</h1></div></div></div><p>More often than not, we need to <a id="id202" class="indexterm"/>attach a certain behavior that triggers when a trackable is found. To do this, we must understand how to keep a track of trackable events, such as trackable found or trackable lost. Vuforia makes this easy for us by providing a<a id="id203" class="indexterm"/> template script named <code class="literal">DefaultTrackableEventHandler</code>. This script is by default attached to any <strong>ImageTarget</strong> prefab. It should be there now in our <strong>ImageTarget</strong> object in the scene.</p><p>What the script does is it handles the event of a trackable found or a trackable lost. It is the script responsible for rendering the 3D content when the trackable is found, and making it disappear when it is lost as well. It is important to notice that it is however not responsible for the perspective or the <strong>ARCamera</strong> position on the trackable, this is handled by another script , which is beyond our scope.</p><p>Vuforia recommends that we create our own trackable event handler scripts using the <code class="literal">DefaultTrackableEventHandler</code> script as a template. This is exactly what we will do now by adding a very small function to the script.</p><p>Open the script named <code class="literal">DefaultTrackableEventHandler</code>, which can be found inside the <code class="literal">Scripts</code> folder under the <code class="literal">Qualcomm Augmented reality</code> folder. It should look similar to the following screenshot, where the <code class="literal">DefaultTrackableEventHandler.cs</code> script is shown:</p><div><img src="img/0032OS_05_15.jpg" alt="Vuforia trackable event handler"/></div><p>The following three<a id="id204" class="indexterm"/> functions are important to understand from this script:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">OnTrackableStateChanged</code>: This function<a id="id205" class="indexterm"/> is called every time the state of the trackable is changed, whether it is found or lost. It then determines if it is detected or lost, and appropriately calls on the event function.</li><li class="listitem" style="list-style-type: disc"><code class="literal">OnTrackingFound</code>: This is the function<a id="id206" class="indexterm"/> that is called when the trackable is found. It is responsible for rendering all the children of the <code class="literal">ImageTarget</code> object and switching on their colliders.</li><li class="listitem" style="list-style-type: disc"><code class="literal">OnTrackingLost</code>: This function is called when the trackable is lost. It is responsible for turning off the<a id="id207" class="indexterm"/> rendering for all the child objects of <code class="literal">ImageTarget</code>. It also turns off the collider for them.</li></ul></div><p>These are the three crucial functions<a id="id208" class="indexterm"/> in the script. We will leave them as they are for our app, but for one modification. We need to add a new function that returns the status of the trackable to tell us whether the trackable is detected or not. This will be useful for us when animating the mole character, as we will see in a little while.</p><p>Create a new C# script in the <code class="literal">Scripts</code> folder and name it <code class="literal">MoleTrackableEventHandler</code>. Now copy all the code from the script <code class="literal">DefaultTrackableEventHandler</code> and paste it inside the script we just created. It is important to change the class name from <code class="literal">DefaultTrackableEventHandler</code> to <code class="literal">MoleTrackableEventHandler</code>, else errors will<a id="id209" class="indexterm"/> appear in Unity due to the fact that the class name is not the same as the filename.</p><p>After modification, the script<a id="id210" class="indexterm"/> will look similar to the following screenshot, where the <code class="literal">MoleTrackableEventHandler.cs</code> script is shown:</p><div><img src="img/0032OS_05_16.jpg" alt="Vuforia trackable event handler"/></div><p>We added the variable <code class="literal">TrackableStatus</code>, which we want to hold the state of the trackable. It will be <code class="literal">true</code> if it is visible, and <code class="literal">false</code> if not. We then created a function and named it <code class="literal">trackableVisible</code>, which will return the variable <code class="literal">TrackableStatus</code>.</p><p>We then simply set the <code class="literal">TrackableStatus</code> to <code class="literal">true</code> when found and <code class="literal">false</code> when not found inside the function <code class="literal">OnTrackableStateChanged()</code>.</p><p>Now, if we call on the function <code class="literal">trackableVisible()</code>; it will effectively tell us if the trackable is visible or not.</p><p>Now, we need to attach the <code class="literal">MoleTrackableEventHandler</code> to the <code class="literal">ImageTarget</code> object in our scene. We now do not need <code class="literal">DefaultTrackableEventHandler</code> attached to <code class="literal">ImageTarget</code>, so we need to delete that component or simply disable it.</p><p><code class="literal">DefaultTrackabeEventHandler</code> can be customized later on for all sorts of effects such as playing a sound or video when the trackable is found, or controlling specific GUI objects to respond to the trackable. It gives us a lot of control over the behavior of the AR app, so it always pays off to keep it in mind.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec37"/>Adding a Particles prefab</h1></div></div></div><p><strong>Particles</strong> in Unity is <a id="id211" class="indexterm"/>a very useful tool that many developers use. With it, it is possible to create fog, dust, flames, explosions, <a id="id212" class="indexterm"/>and all sorts of effects. The effect on resources is usually minimal, as Particles uses small 2D images animated to give the effect needed, hence the name Particles.</p><p>For our app, it will be useful to add dust particles appear when we whack the mole with the balls fired at them. Although learning how to create particles is outside the scope of this book, we will see how we can add one to the scene that is already made, because there are a number of free particles available through the Unity store.</p><div><ol class="orderedlist arabic"><li class="listitem">Import the package named <code class="literal">DustParticles</code> to the project. Add the prefab we just imported to the scene. You will automatically notice the dust cloud being simulated in the Editor. Now, we only need to position it appropriately over the molehill and have it look as if the dust is rising from the hold, then parent it to the Mole object. In a little while, we will see how we can call on this particle system and activated it through code.</li><li class="listitem">Change the position of the <strong>Character</strong> object to be under the ground, because this is where they should be when the game starts. It will also give us a good idea how the dust will look like with character not present. Simply move the <code class="literal">Character</code> on the y axis till it is just below the ground and not visible. The following screenshot shows dust particles added to the scene:<div><img src="img/0032OS_05_17.jpg" alt="Adding a Particles prefab"/></div></li></ol></div><p>Unity is a great tool, but like everything else, it is not perfect. What it lacks, however, is usually remedied by a<a id="id213" class="indexterm"/> very active community that create add-ons and scripts for it. One of the most useful and free scripts available for Unity is iTween.</p><p><strong>iTween</strong> is <a id="id214" class="indexterm"/>a script that allows us to animate objects quite easily through script. It is very customizable, and fits most object animation needs for games. For example, iTween can easily be used to animate a missile in a game to home at the target in a fluid manner. In our case, we will use iTween to animate the mole coming out of the molehill and going back.</p><p>iTween can be easily added from the Unity's Asset store. It is for free; simply search for it in the Unity Asset store, which is accessible from the <strong>Window</strong> menu, then download and import into the project. Now, we can access iTween functions easily from code.</p><p>iTween's documentations can be found at <a class="ulink" href="http://itween.pixelplacement.com/documentation.php">http://itween.pixelplacement.com/documentation.php</a>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec38"/>Scripting the mole character</h1></div></div></div><p>Now that iTween is in place, let's see how we can script the mole character to make use of iTween and animate<a id="id215" class="indexterm"/> the character correctly. What we are aiming to achieve with the mole script at this stage is to have it animate up and down from the molehill. The animation should start at a random time between two ranges to avoid repetition and predictability of the behavior.</p><p>Let's take a look at how this script looks like. The following screenshot shows <code class="literal">moleAnimator.cs</code> script:</p><div><img src="img/0032OS_05_18.jpg" alt="Scripting the mole character"/></div><p>The first three lines in the <code class="literal">Start()</code> function are quite simple. We find and attach the mole hit sound source to <code class="literal">moleHitAudio</code> to be used by us in the script. We find and attach the dust particle system to use as a hit effect. We then find the <code class="literal">ImageTarget</code> object and only use the script component <code class="literal">MoleTrackableEventHandler</code>. We do this to be able to call on the<a id="id216" class="indexterm"/> function that added, which is <code class="literal">trackableVisible</code>, to check to see if the trackable is visible or not. This is one way of accessing other class' functions in Unity.</p><p>The last line in the <code class="literal">Start()</code> function starts the animation sequence; let's see how it does it:</p><div><pre class="programlisting">iTween.MoveBy(gameObject, iTween.Hash("y", 40, "easeType", "easeInOutQuad", "speed", 20, "delay", Random.Range(0.3f, 5f), "oncomplete", "animComplete_Up");</pre></div><p>This is the line of code that starts the whole animation sequence on the mole character. <code class="literal">MoveBy()</code><a id="id217" class="indexterm"/> is a function in the iTween class that allows animating objects in a given axis by moving them along it. We first give it the current game object to which the script is attached, which will be the mole character, and then we pass in the <code class="literal">iTween.Hash</code> parameters to set what kind of animation we want.</p><p>The parameters for <code class="literal">iTween.Hash</code> are very important, but easy to understand. It follows the syntax of <code class="literal">(parameter name string, parameter value)</code>. First, we give it the actual axis on which we want to animate, which is in our case y axis. Then, we set a value for <code class="literal">easyType</code>, which governs the slowing down and speeding up of the animation to make it not feel abrupt; <code class="literal">easeInOutQuad</code> is a perfect natural feel for our character. We set the speed of the animation to <code class="literal">20</code>. Now for the delay, which is the delay of the animation start, we add a random value to make moles animate at different times, and not all at the same time, because we will have more than one mole in our scene at a later stage. The <code class="literal">oncomplete</code> parameter is the name of the function to be called once the animation is complete. Because this line animates the character up and out of the hole, it calls on <code class="literal">animComplete_up</code>, which in turn will animate the character back down and into the hole, as we will see next.</p><p>If we look at the function <a id="id218" class="indexterm"/>
<code class="literal">animComplete_Up</code>, we will see that it only contains a single line of code that does something similar to what the <code class="literal">Start()</code> function<a id="id219" class="indexterm"/> did in its last code line, but reversed. It animates the character back down and into the hole, which makes sense, because we want the character to not pop up and down from the molehill. Notice that the <code class="literal">oncomplete</code> parameter calls on <code class="literal">animComplete_Down</code>, which we will take a look at next.</p><p>In function <code class="literal">animComplete_Down</code>, we do two things. First we check to see if the trackable is visible by calling the <code class="literal">trackableVisible()</code> function<a id="id220" class="indexterm"/>, which is a member of <code class="literal">MoleTrackableEventHandler</code>. If the target is visible, we turn on <code class="literal">renderer</code> and <code class="literal">collider</code> for the object. This makes the object visible and collidable. We do this because we will make the mole disappear when the ball hits it, but we should only make it reappear if the trackable is visible, otherwise it will interfere with how <code class="literal">ImageTarget</code> renders objects, and we will see floating objects on the camera when there is no tracked target. Next, it animates the object back up and then <code class="literal">oncomplete</code> in turn calls <code class="literal">animComplete_Up</code>, making a perfect recursive loop.</p><p>The last function, which is <code class="literal">OnCollisionEnter</code>, is a Unity event that fires up whenever two colliders collide with each other. It is sent to any object with a collider attached to it. We use this event to check if any ball hit the mole or not. If it does hit the mole, we then play the hit sound and the dust particles. We then turn off the renderer of the object to make it disappear and turn off the collider to not interfere with any more balls.</p><p>This is the script that will handle the mole behavior for us. Now all we have to do is attach it to the <code class="literal">Character</code> object inside the <code class="literal">WhackAMoleModel</code> object and hit Play. We can immediately see the mole is animating correctly and randomly. Also, if a ball hits it, sound effects and dust particles are played, indicating a correct whack.</p><p>Now as our mole object is complete, prefab the whole object into the <code class="literal">Prefabs</code> folder and then add multiple mole objects into the scene to have more than one mole. Add as many as you would want, but I believe four is a good enough number, considering how small the trackable is.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec39"/>Mask shader</h1></div></div></div><p>We are mostly done with the game. We have the behavior of all our objects in place and are ready for deployment; but we are missing one last thing. We might have noticed that when the moles go underground, they are still visible from the side angle. This will be apparent as well when deploying the app to<a id="id221" class="indexterm"/> the device in AR environment. There is an easy solution we can do to hide those moles when they go underground in an AR environment, which is using a depth mask shader.</p><div><ol class="orderedlist arabic"><li class="listitem">Add the shader asset named <code class="literal">DepthMask.shader</code>, which can be found in the chapter's assets. Then, we want to create a cube in our scene that will be as big as the ground plane and name it <code class="literal">mask</code>, and hide all the moles behind it, as shown in the following screenshot. The following screenshot also shows the <strong>Mask</strong> object added to scene:<div><img src="img/0032OS_05_19.jpg" alt="Mask shader"/></div></li><li class="listitem">Of course, this object is not acting as a mask yet, it is just an ordinary cube. To give it the mask properties, we need to create a material for it in the <strong>Materials</strong> folder and name it <code class="literal">Mask</code>. Because we added the <strong>DepthMask</strong> shader, it should be automatically available in the <strong>Shader</strong> dropdown list for the material. Simply choose the <a id="id222" class="indexterm"/><strong>DepthMask</strong> shader from there, and then attach the material to the <strong>Mask</strong> object. The following screenshot shows the <strong>DepthMask</strong> shader activated:<div><img src="img/0032OS_05_20.jpg" alt="Mask shader"/></div></li></ol></div><p>We immediately notice that the cube has disappeared, but further inspection reveals that not only the cube is not <a id="id223" class="indexterm"/>visible, but also the moles behind it. This effectively fixes our problem by hiding the moles underground.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec40"/>Summary</h1></div></div></div><p>In this chapter we covered a lot of ground on the advanced AR development in Unity. We created a perfectly functional and fun game that utilizes a lot of concepts in both Unity and Vuforia. All we need to do now is deploy the game to a device and play with it. Maybe add a score system, or maybe add a limited number of balls to hit the mole. The sky is your limit. Experiment with it, and create an experience that users will appreciate.</p></div></body></html>