<html><head></head><body>
        

            
                <h1 class="header-title">Working Further on 3D Game</h1>
            

            
                
<p>Now that we have defined our 3D shape, let's render it on our screen. However, before we begin this chapter, let's summarize everything we learned throughout the contents of this book since this is our last chapter.</p>
<p>We learned a lot of cool stuff about Android. We started from learning about the history of Android and quickly progressed toward the installation of software required to develop apps for Android. After that, we installed Android Studio and configured it with the latest components of Android-N.</p>
<p>Once our environment was set up, we learned how to create a basic app for Android and learned about various concepts of Android, such as package names, inputs, emulators, and more. After getting an air of familiarity with Android, we learned about how to make a transition from making apps to games wherein we learned how to create a surface and canvas, which would allow us to create graphics for our game, and then we moved on to learn various concepts about game development.</p>
<p>As we progressed further through our chapters, we started learning about the process of making games, and within a couple of chapters, we learned how to create a 2D game from scratch with a UI. We completed developing a fully-fledge 2D game with the same and then moved on to turning things into 3D.</p>
<p>In our previous chapter, we learned that we can create 3D games for native Android using OpenGL ES, and so we started with defining basic shapes.</p>
<p>In this last chapter for this book, we will learn the following topics:</p>
<ul>
<li>Rendering our object on screen</li>
<li>Adding color to our object</li>
<li>Rotating both of our 3D objects</li>
<li>Creating a pyramid</li>
</ul>
<p>So without further ado, let's begin with this final part of our book, which will set us up with the foundation needed to begin your journey in 3D game development.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Rendering our object on screen</h1>
            

            
                
<p>In our previous chapter, we created a class for our <kbd>Triangle</kbd> object; however, if you run your game, it will still show a blank screen since we have not used our render class to display it. We need to create an object for our newly defined class, and then using our GL reference, we will draw/render it on our screen. Open up your <kbd>MyGLRenderer.java</kbd> file and let's start by declaring a variable of our triangle. We won't be altering any of our code that we wrote in <kbd>onSurfaceCreated()</kbd> or <kbd>onSurfaceChanged()</kbd> methods.</p>
<p>In order to draw our object on screen, we will simply follow these steps:</p>
<ol>
<li>Define a variable of our <kbd>Triangle</kbd> class.</li>
<li>Assign a reference to it in our constructor.</li>
<li>Using gl, access the <kbd>draw()</kbd> method in our <kbd>Triangle</kbd> to display it on screen.</li>
</ol>
<p>Let's take a look at how we can do that; just type in the code marked in bold in your <kbd>MyGLRenderer.java</kbd> file:</p>
<pre>
//The import statements are same as our previous chapter<br/><br/>public class MyGLRenderer implements GLSurfaceView.Renderer {<br/><strong><br/>    Triangle triangle;</strong><br/><br/>    // Constructor<br/>    public MyGLRenderer(Context context) {<br/>        <strong>triangle = new Triangle();</strong><br/>    }<br/><br/>    //onSurfaceCreated and onSurfaceChanged methods remain same as previous chapter<br/><br/>    @Override<br/>    public void onDrawFrame(GL10 gles) {<br/>        gles.glClear(GL10.GL_COLOR_BUFFER_BIT | <br/>        GL10.GL_DEPTH_BUFFER_BIT);<br/><br/><strong>        gles.glLoadIdentity();<br/>        gles.glTranslatef(-1.5f, 0.0f, -6.0f);<br/>        triangle.draw(gles);</strong><br/>    }<br/>}
</pre>
<p>Pretty simple, right? That's it! Your triangle object is ready to be rendered on screen. Don't believe it? Go ahead; test and run it on your emulator/device, and you will get the following output:</p>
<div><img class="image-border" height="371" src="img/B05066_10_01.png" width="659"/></div>
<p>Our triangle rendered on screen, finally!</p>
<p>You might think that this object is still 2D, but wait till the part where we rotate it. However, before that, let's learn how to add color to this object. So let's add some colors.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Adding colors to our object</h1>
            

            
                
<p>In this part, we will demonstrate how we can use different colors to texture our object. We will use RGB values using a <kbd>colorBuffer</kbd> to fetch values from the colors of the vertices. After this, we will enable the color-array client state, and then these colors are rendered together with the vertices in <kbd>glDrawElements()</kbd>.</p>
<p>Here, we will again use nio's <kbd>FloatBuffer</kbd> to declare our <kbd>colorBuffer</kbd> variable. Here are the steps we would use to add color to our object:</p>
<ol>
<li>We declare our <kbd>colorBuffer</kbd> variable.</li>
<li>We declare our color array variable.</li>
<li>We copy our color vertices data to our buffer.</li>
<li>Enable our color array.</li>
<li>Define color array buffer.</li>
<li>Disable color array.</li>
</ol>
<p>Also, since this is a native property of the triangle, we will write this code in our <kbd>Triangle.java</kbd> class that we created and not in the <kbd>MyGLRenderer.java</kbd> class. Type in the code marked in bold keeping in mind the preceding steps:</p>
<pre>
//Import statements remain the same<br/>public class Triangle {<br/>private FloatBuffer vb;<br/><strong>    private FloatBuffer cb;</strong><br/>    private ByteBuffer ib;<br/><br/>    private float[] v = {  // Vertices of the triangle<br/>            0.0f,  1.0f, 0.0f, // 0. top vertices<br/>            -1.0f, -1.0f, 0.0f, // 1. left-bottom vertices<br/>            1.0f, -1.0f, 0.0f  // 2. right-bottom vertices<br/>    };<br/>    private byte[] ind = { 0, 1, 2 };<br/><strong>    private float[] colors = { <br/>            1.0f, 0.0f, 0.0f, 1.0f, //R<br/>            0.0f, 1.0f, 0.0f, 1.0f, //G<br/>            0.0f, 0.0f, 1.0f, 1.0f  //B<br/>    };</strong><br/><br/>    public Triangle() {<br/>        //start of code same as earlier<br/><strong><br/>        ByteBuffer cbb = ByteBuffer.allocateDirect(colors.length * 4);</strong><br/><strong>        cbb.order(ByteOrder.nativeOrder());<br/>        cb = cbb.asFloatBuffer();<br/>        cb.put(colors);<br/>        cb.position(0);</strong><br/><br/>        //index buffer code same as earlier<br/>    }<br/><br/>    public void draw(GL10 gles) {<br/>        //code as before<br/><strong>        gles.glDisableClientState(GL10.GL_COLOR_ARRAY);</strong><br/>    }<br/>}
</pre>
<p>Now, we have a colored triangle. You will get an output like this if you used the specified color values. Of course, you are free to change and tweak the colors as you please by changing the RGB values in our <kbd>colors</kbd> variable:</p>
<div><img class="image-border" src="img/B05066_10_02.png"/></div>
<p>Our colored triangle</p>
<p>Okay, now we will make our triangle rotate, which will clarify our doubts whether it is actually a 3D object or not.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Rotating our object</h1>
            

            
                
<p>By now, you must have understood that any changes in the rendering of an object have to be done in the <kbd>MyGLRenderer</kbd>, whereas any properties that are local to our object are to be done in the respective object's file. So, we will write our rotation code in our <kbd>MyGLRenderer.java</kbd> file because rotating an object is a part of the rendering process.</p>
<p>Here's our logic to rotate our triangle:</p>
<ul>
<li>We take our rotation angle</li>
<li>We rotate our object in a specified rotation angle</li>
<li>We increment our rotation angle</li>
</ul>
<p>Let's do it; we will simply declare two variables at the start for our rotational angle and speed; then in our <kbd>onDrawFrame()</kbd> method, implement our rotation logic, as follows:</p>
<pre>
//Import statements as before<br/>public class MyGLRenderer implements GLSurfaceView.Renderer {<br/><br/>    Triangle triangle;<br/><strong><br/>    private float angleTriangle = 0.0f;<br/>    private float speedTriangle = 0.5f;</strong><br/><br/>    public MyGLRenderer(Context context) {<br/>        triangle = new Triangle();<br/>    }<br/><br/>// No changes in our onSurfaceCreated and onSurfaceChanged methods so ignore this part<br/><br/>    @Override<br/>    public void onDrawFrame(GL10 gles) {<br/>        //Same as previous part<br/><strong><br/>        angleTriangle += speedTriangle;</strong><br/>    }<br/>}
</pre>
<p>After you compile this code, your triangle will start rotating. Cool, right? Build and run and see your rotating triangle in action!:</p>
<div><img class="image-border" height="392" src="img/B05066_10_03.png" width="697"/></div>
<p>Our rotating triangle</p>
<p>Fantastic! Now, let's use this knowledge to create a proper 3D object, our pyramid! We're pretty clear about the process for creating objects, so we will breeze through the pyramid part.</p>
<p>Let's repeat the same steps for our pyramid. This time our object will be purely 3D rather than just a 2D plane object; so, let's start!</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Creating a pyramid 3D object</h1>
            

            
                
<p>Now that you have understood how to define shapes and render objects on screen, it will be comparatively easier to create our 3D object. We will follow almost the same procedure as we did to create our triangle. We will create our pyramid right besides our triangle; let's begin.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Defining the shape</h1>
            

            
                
<p>As we've learned from the previous part, we will first create a class of our pyramid in order to define our shape. So create a file <kbd>Pyramid.java</kbd> to define the shape of our pyramid object.</p>
<p>Our pyramid has five faces, so we will require five vertices to draw our pyramid. So after you create your <kbd>Pyramid.java</kbd>, we will define our vertices, as follows:</p>
<pre>
//Package name of our game<br/><br/>public class Pyramid {<br/>    private float[] vp = { // 5 vertices of the pyramid in (x,y,z)<br/>            -1.0f, -1.0f, -1.0f,  //left-bottom-back<br/>            1.0f, -1.0f, -1.0f,  //right-bottom-back<br/>            1.0f, -1.0f,  1.0f,  //right-bottom-front<br/>            -1.0f, -1.0f,  1.0f,  //left-bottom-front<br/>            0.0f,  1.0f,  0.0f   //top<br/>    };<br/>}
</pre>
<p>Alright, now we have our vertices set, but just like our triangle, we still have our buffers and indices to take care of. We will quickly define our float and byte buffers for our shape and colors along with the indices that will make our pyramid faces:</p>
<pre>
private FloatBuffer vb;  // Buffer for vertex-array<br/>private FloatBuffer cb;   // Buffer for color-array<br/>private ByteBuffer ib;    // Buffer for index-array<br/><br/>private float[] colors = {  // Colors of the 5 vertices in RGBA<br/>        0.0f, 0.0f, 1.0f, 1.0f,  // blue<br/>        0.0f, 1.0f, 0.0f, 1.0f,  // green<br/>        0.0f, 0.0f, 1.0f, 1.0f,  // blue<br/>        0.0f, 1.0f, 0.0f, 1.0f,  // green<br/>        1.0f, 0.0f, 0.0f, 1.0f   // red<br/>};<br/><br/>private byte[] ind = { // Vertex indices<br/>        2, 4, 3,   // front face<br/>        1, 4, 2,   // right face<br/>        0, 4, 1,   // back face<br/>        4, 0, 3    // left face<br/>};
</pre>
<p>Now, we will write the constructor of our <kbd>Pyramid</kbd> based on the logic of our triangle:</p>
<pre>
public Pyramid() {<br/>    ByteBuffer vbb = ByteBuffer.allocateDirect(vp.length * 4);<br/>    vbb.order(ByteOrder.nativeOrder());<br/>    vb = vbb.asFloatBuffer();<br/>    vb.put(vp);<br/>    vb.position(0);<br/><br/>    ByteBuffer cbb = ByteBuffer.allocateDirect(colors.length * 4);<br/>    cbb.order(ByteOrder.nativeOrder());<br/>    cb = cbb.asFloatBuffer();<br/>    cb.put(colors);<br/>    cb.position(0);<br/><br/>    ib = ByteBuffer.allocateDirect(ind.length);<br/>    ib.put(ind);<br/>    ib.position(0);<br/>}
</pre>
<p>Finally, of course, our <kbd>draw()</kbd> method as shown in the following code:</p>
<pre>
   public void draw(GL10 gles) {<br/>      gles.glFrontFace(GL10.GL_CCW);<br/><br/>      gles.glEnableClientState(GL10.GL_VERTEX_ARRAY);<br/>      gles.glVertexPointer(3, GL10.GL_FLOAT, 0, vb);<br/>      gles.glEnableClientState(GL10.GL_COLOR_ARRAY);<br/>      gles.glColorPointer(4, GL10.GL_FLOAT, 0, cb);<br/><br/>      gles.glDrawElements(GL10.GL_TRIANGLES, ind.length, <br/>      GL10.GL_UNSIGNED_BYTE,ib);<br/><br/>      gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);<br/>      gl.glDisableClientState(GL10.GL_COLOR_ARRAY);<br/>   }
</pre>
<p>We're done defining the shape of our <kbd>Pyramid</kbd>. So, finally your entire code for <kbd>Pyramid</kbd> will be like this:</p>
<pre>
//Package name and our import statements<br/>public class Pyramid {<br/><br/>//Our 3 buffer variables<br/><br/>    private float[] vp = {<br/>            -1.0f, -1.0f, -1.0f,  //left-bottom-back<br/>            1.0f, -1.0f, -1.0f,  //right-bottom-back<br/>            1.0f, -1.0f,  1.0f,  //right-bottom-front<br/>            -1.0f, -1.0f,  1.0f,  //left-bottom-front<br/>            0.0f,  1.0f,  0.0f   //top<br/>    };<br/><br/>    private float[] colors = {<br/>            0.0f, 0.0f, 1.0f, 1.0f,  //blue<br/>            0.0f, 1.0f, 0.0f, 1.0f,  //green<br/>            0.0f, 0.0f, 1.0f, 1.0f,  //blue<br/>            0.0f, 1.0f, 0.0f, 1.0f,  //green<br/>            1.0f, 0.0f, 0.0f, 1.0f   //red<br/>    };<br/><br/>    private byte[] ind = { // Vertex indices<br/>            2, 4, 3,   // front face (CCW)<br/>            1, 4, 2,   // right face<br/>            0, 4, 1,   // back face<br/>            4, 0, 3    // left face<br/>    };<br/><br/>    public Pyramid() {<br/>        ByteBuffer vbb = ByteBuffer.allocateDirect(vp.length * 4);<br/>        vbb.order(ByteOrder.nativeOrder());<br/>        vb = vbb.asFloatBuffer();<br/>        vb.put(vp);<br/>        vb.position(0);<br/><br/>        ByteBuffer cbb = ByteBuffer.allocateDirect(colors.length * 4);<br/>        cbb.order(ByteOrder.nativeOrder());<br/>        cb = cbb.asFloatBuffer();<br/>        cb.put(colors);<br/>        cb.position(0);<br/><br/>        ib = ByteBuffer.allocateDirect(ind.length);<br/>        ib.put(ind);<br/>        ib.position(0);<br/>    }<br/><br/>// Draw the shape<br/>    public void draw(GL10 gles) {<br/>        gles.glFrontFace(GL10.GL_CCW);<br/><br/>        gles.glEnableClientState(GL10.GL_VERTEX_ARRAY);<br/>        gles.glVertexPointer(3, GL10.GL_FLOAT, 0, vb);<br/>        gles.glEnableClientState(GL10.GL_COLOR_ARRAY);<br/>        gles.glColorPointer(4, GL10.GL_FLOAT, 0, cb);<br/><br/>        gles.glDrawElements(GL10.GL_TRIANGLES, ind.length, <br/>        GL10.GL_UNSIGNED_BYTE,ib);<br/><br/>        gles.glDisableClientState(GL10.GL_VERTEX_ARRAY);<br/>        gles.glDisableClientState(GL10.GL_COLOR_ARRAY);<br/>    }<br/>}
</pre>
<p>Okay, that's set but we still won't be getting to see the Pyramid on our screen since we haven't rendered it yet; let's do that now to bring our pyramid on screen.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Rendering our 3D object</h1>
            

            
                
<p>Based on our understanding of our previous example working with the triangle, we are pretty clear that in order to render our objects, we have to use our <kbd>MyGLRenderer.java</kbd> class. Since we are pretty clear on how our 3D rendering works, we will also add in our rotation code in the same code.</p>
<p>Here's one crucial thing to take into account though, we will be drawing our pyramid beside our triangle, so we have to make sure that we don't overlap our pyramid over our triangle. To do so, we will use the code <kbd>gl.Translate()</kbd> that we will observe as a follow up inside our <kbd>onDrawFrame()</kbd> code block after we draw our triangle.</p>
<p>We will work on our <kbd>MyGLRenderer.java</kbd> file, so open that file and write in the code marked in bold; the rest of the part remains the same:</p>
<pre>
//Package name and import statements<br/><br/>public class MyGLRenderer implements GLSurfaceView.Renderer {<br/><br/>    //our triangle object variables<br/><strong>    private Pyramid pyramid;</strong><br/><br/><strong>    private static float anglePyramid = 0;<br/>    private static float speedPyramid = 2.0f;</strong><br/><br/>    public MyGLRenderer(Context context) {<br/>        //our triangle object reference remains same<br/><strong>        pyramid = new Pyramid();</strong><br/>    }<br/><br/>    //Again there's no change in onSurfaceCreated and onSurfaceChanged methods so type them as is in previous chapter<br/><br/>    @Override<br/>    public void onDrawFrame(GL10 gles) {<br/>        //Triangle code remains same<strong><br/>        gles.glLoadIdentity();<br/>        gles.glTranslatef(1.5f, 0.0f, -6.0f);<br/>        gles.glRotatef(anglePyramid, 0.1f, 1.0f, -0.1f);<br/>        pyramid.draw(gles);</strong><br/><br/>        //angleTriangle speed assign here<br/><strong>        anglePyramid += speedPyramid;</strong><br/>    }<br/>}
</pre>
<p>Alright, so everything looks set. Build and run your project, and you will get the following output:</p>
<div><img class="image-border" src="img/B05066_10_04.png"/></div>
<p>Both our objects are visible on screen now</p>
<p>Congratulations! You have successfully created a 3D object using OpenGL. In a similar way, you can create any kind of object based on the vertices.</p>
<p>This is just the foundation of creating a 3D basic shapes game with OpenGL. Creating a fully-fledged 3D game is a huge task of its own, and this is just a glimpse of what you can do.</p>
<p>We would recommend that you buy our other books on 3D game development to go ahead in more depth on creating games in 3D.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Summary</h1>
            

            
                
<p>In this chapter, we learned how to create 3D objects and render them on the screen. We also learned how to add colors to objects as well as rotate them in a 3D direction. With this chapter, we conclude this book.</p>
<p>We have learned how to create games in 2D and 3D using native Android. With the knowledge gained from this chapter, you can get started on your journey into game development and start creating your own games for Android.</p>
<p>This concludes this book for creating your games with Android. The knowledge gained through this book will serve as a foundation for the games you make ahead. The advantage of creating games in native Android is that primarily, the file size of games turns out to be quite small, which is what users generally look for. If you were to create any game using an engine, you would end up creating a game, which would have a comparatively larger file size by the end of the development process; you'd need to optimize it even further, but yet there's only so much you can do for that. So, developing native will not only allow you to make games with smaller file size, but will also enhance your knowledge and core understanding of the entire process.</p>
<p>As we conclude this book, it is now up to you and your imagination to start creating games with the help of the knowledge you learned through this book. Of course, creating games with an engine is definitely a faster process; if you want to skip through creating your own classes for each and everything, it is recommended that you get started with game engines. Packt has a wide variety of books to help you in the process. Perhaps, your best starting point to get started with a game engine is <em>Unity Game Engine</em>. If you're interested in learning more and giving your game development process a boost, then the best recommendation will be to go through Packt's book on <em>Unity Game Engine</em>.</p>
<p>Wishing you all the best for creating your next game!</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    </body></html>