<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Graphics and Hardware Acceleration"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Graphics and Hardware Acceleration</h1></div></div></div><p>In this chapter, we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Comparing vector and bitmap graphics</li><li class="listitem" style="list-style-type: disc">Understanding GPU-Blend mode</li><li class="listitem" style="list-style-type: disc">Understanding GPU-Vector mode</li><li class="listitem" style="list-style-type: disc">Using Cache as Bitmap</li><li class="listitem" style="list-style-type: disc">Using Cache as Bitmap Matrix</li><li class="listitem" style="list-style-type: disc">Accessing bitmaps with ActionScript</li><li class="listitem" style="list-style-type: disc">Loading bitmaps at runtime</li><li class="listitem" style="list-style-type: disc">Working with sprite sheets</li><li class="listitem" style="list-style-type: disc">Performing bitmap animation with ActionScript</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec01"/>Introduction</h1></div></div></div><p>The release of CS5 made it possible for Flash developers to create exciting content for iOS devices without changing their workflow. However, with only a fraction of the computing power of a modern day desktop or laptop, developing for devices such as the iPhone requires special design and coding considerations.<a id="id449" class="indexterm"/>
</p><p>One of the largest bottlenecks is graphics rendering and it has become an area of frustration for many. It is simply not realistic to build the same graphics-heavy FLAs that you normally would for desktop delivery and expect them to run well on mobile. Even seemingly simple graphical operations can perform badly on iOS devices if poorly implemented.</p><p>By making available the same powerful drawing and animation tools that you are already familiar with, the Flash IDE can actually lull you into a false sense of security. For example, complex vector artwork, masks, timeline animations, deeply-nested display lists, and alpha transparencies are all easy to create but can negatively impact the performance of your app. Targeting mobile requires careful planning, profiling, and an understanding of the hardware you are developing for.<a id="id451" class="indexterm"/>
</p><p>In this chapter, we will explore many techniques for optimizing render performance. We will cover both Flash's rendering pipeline and the hardware constraints that you will be working within. In addition, we will see how to take advantage of hardware acceleration, offloading much of the rendering workload from the CPU to the Graphics Processing Unit (GPU).<a id="id452" class="indexterm"/>
</p></div></div>
<div class="section" title="Comparing vector and bitmap graphics"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec02"/>Comparing vector and bitmap graphics</h1></div></div></div><p>Although Flash provides bitmap support, it is primarily thought of as a vector animation tool. Vector content can be created and edited directly within the IDE, making vectors an obvious choice above bitmaps, which must be edited externally.<a id="id453" class="indexterm"/>
</p><p>However, given the hardware constraints of mobile devices such as the iPhone, are vectors appropriate or should you consider using bitmaps in order to maximize performance?<a id="id454" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec01"/>Getting ready</h2></div></div></div><p>Two FLAs have been provided for this recipe and can be found within the book's accompanying code bundle at<code class="literal"> chapter6\recipe1\</code>.<a id="id455" class="indexterm"/>
</p><p>Both perform a simple render performance test. Each attempts to render ten instances of an animating movie clip. After five seconds, the test will end and the average number of frames per second (FPS) that was achieved will be shown. The higher that number, the faster the rendering performance of the test.</p><p>The first FLA<code class="literal">— recipe-vectors.fla —</code>uses vector artwork for each of the movie clip's animation frames. The second<code class="literal">—recipe-bitmaps.fla—</code>uses a bitmap representation for each.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec02"/>How to do it...</h2></div></div></div><p>Perform the following steps in order to run both tests on your device:<a id="id456" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Open<code class="literal"> recipe-vectors.fla</code> into Flash Professional.</li><li class="listitem">Within the library, you will find a symbol named<span class="strong"><strong> Monkey</strong></span>, which contains a four-frame vector animation. Double-click on the symbol and explore its display list. Its construction is typical for a Flash project, containing many nested clips of vector artwork.</li><li class="listitem">Publish the FLA and deploy<code class="literal"> c6-r1-v.ipa</code>. On your device's home screen, find the app named<span class="strong"><strong> c6 r1 v</strong></span> and launch it. Wait for five seconds and then take a note of the frame rate that was achieved.</li><li class="listitem">Now open<code class="literal"> recipe-bitmaps.fla</code>. Double-click on the<span class="strong"><strong> Monkey</strong></span> library symbol and explore its timeline. This FLA performs the same test as the first, except it uses a bitmap for each animation frame rather than vectors.</li><li class="listitem">Publish the FLA and deploy<code class="literal"> c6-r1-b.ipa</code> to your device. Launch<span class="strong"><strong> c6 r1 b</strong></span> and take a note of the frame rate.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec03"/>How it works...</h2></div></div></div><p>The rendering performance of each will vary across iOS devices but no matter what device you use, the bitmap-based animation will outperform the vector-based equivalent.<a id="id457" class="indexterm"/>
</p><p>To confirm this, let us take a look at the results of the two FLAs compiled from Flash Professional CS5 and run across a handful of devices. The following chart shows the average frame rate, measured in frames per second, that was achieved by each test:</p><div class="mediaobject"><img src="graphics/1383_06_01.jpg" alt="How it works..."/></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note37"/>Note</h3><p>The results shown in this chart are an average taken from five runs of each test. Each device was running iOS 5 with the exception of the first-generation iPod touch, which had iOS 3.1 installed.</p><p>Use these results as a rough guide as they may vary slightly across runs.</p></div><p>So why do bitmaps render to the screen faster than vectors?<a id="id458" class="indexterm"/>
</p><p>Vector graphics are represented by a combination of strokes, fills, colors, and gradients, with expensive mathematical calculations required in order to render them. Bitmaps on the other hand are simply a pixel-by-pixel representation of each color required by an image. With every single point of a bitmap already known, it can quickly be plotted to the screen.<a id="id459" class="indexterm"/>
</p><p>So does this mean you should exclusively use bitmaps in place of vectors when developing for iOS? Not necessarily. Unlike bitmaps, vector artwork can be scaled and translated without losing fidelity. This is due to the fact that vector graphics are represented mathematically. Another advantage of vectors is file size. In many cases, vectors consume significantly less space than their bitmap counterparts.</p><p>However, if frame rate is critical to the success of your application, then you should always attempt to select the fastest rendering option. Also, be aware that doing so may come at the expense of increased memory usage, larger file sizes, and extended development times.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec04"/>There's more...</h2></div></div></div><p>Whether you opt to use vectors or bitmaps, adjusting the rendering quality can aid performance.<a id="id460" class="indexterm"/>
</p><div class="section" title="Stage quality"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec01"/>Stage quality</h3></div></div></div><p>You can further increase performance by reducing the rendering quality used by your app. This is especially useful if you are attempting to maximize your frame rate while manipulating complex vector artwork.<a id="id461" class="indexterm"/>
</p><p>Using ActionScript, set the<code class="literal"> Stage.quality</code> property to one of the following constants:<a id="id462" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">StageQuality.HIGH:</code> Provides bitmap smoothing and anti-aliasing<a id="id463" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">StageQuality.MEDIUM:</code> Provides bitmap smoothing and uses lower quality anti-aliasing<a id="id464" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">StageQuality.LOW:</code> Does not smooth bitmaps or anti-alias graphics<a id="id465" class="indexterm"/></li></ul></div><p>All three quality settings are available from AIR 3.0 with only low and medium quality being supported by AIR 2.0-2.7. All versions of AIR for iOS use<code class="literal"> StageQuality.MEDIUM</code> as the default setting.</p><p>Render quality is applied globally to all content within your application. Bitmaps, however, remain relatively unaffected and, with the exception of smoothing, will look identical across all quality settings. This conveniently allows you to get the highest level of performance from your vector assets without compromising the quality of any bitmaps within your application. You can repeatedly change the quality setting throughout your app's lifetime to best suit its needs at any particular moment.</p><p>Try reducing the stage's render quality within this recipe's FLAs. Simply open the<code class="literal"> Main.as</code> document class shared by both and add the following line of code at the start of the constructor:</p><div class="informalexample"><pre class="programlisting">stage.quality = StageQuality.LOW;
</pre></div><p>Additionally, add the following import statement:</p><div class="informalexample"><pre class="programlisting">import flash.display.StageQuality;
</pre></div><p>Publish and re-deploy both<code class="literal"> .ipa</code> files.</p><p>Rendering should now be faster although the quality of the vector artwork will be noticeably reduced. For many situations, this sacrifice may be acceptable, especially on a compact mobile device screen where any reduction in quality may be hard to spot.<a id="id466" class="indexterm"/>
</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec05"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Converting vectors to bitmaps, <a class="link" href="ch04.html" title="Chapter 4. Porting Flash Projects to iOS">Chapter 4</a></em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Resizing bitmaps, <a class="link" href="ch04.html" title="Chapter 4. Porting Flash Projects to iOS">Chapter 4</a></em></span></li></ul></div></div></div>
<div class="section" title="Understanding GPU-Blend mode"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec03"/>Understanding GPU-Blend mode</h1></div></div></div><p>Unlike developing for the Flash desktop player, two rendering modes are available to those targeting AIR for iOS. Exactly the same software renderer that is present in the desktop player is provided as the first option and is handled by the device's CPU. The second allows you to take advantage of the device's GPU and can significantly improve rendering performance in certain circumstances.<a id="id467" class="indexterm"/>
</p><p>A rendering mode must be selected before compiling your FLA for iOS and cannot be changed at runtime. It is, therefore, important to understand the differences between both modes and make a decision early on regarding which one you would like to support. The choice of renderer can dictate how you architect your application.<a id="id468" class="indexterm"/>
</p><p>Although both Flash Professional CS5 and CS5.5 provide an option to perform rendering on the GPU, how that rendering mode is actually implemented is different.</p><p>In this recipe, we will publish and deploy some example FLAs to help you understand the differences between the two modes. In particular, we will focus on the GPU-rendering mode provided by Flash Professional CS5.<a id="id469" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec06"/>Getting ready</h2></div></div></div><p>Two FLAs have been provided with the book's accompanying code bundle<code class="literal">—render-test-cpu.fla </code> and<code class="literal"> render-test-gpu.fla—</code> and can be found at<code class="literal"> chapter6\recipe2\</code>.</p><p>Both FLAs are identical, with each randomly re-positioning ten movie-clip instances on every frame update. After five seconds, the test will end and the average number of frames per second (FPS) that was achieved will be shown. The higher that number, the faster the rendering performance of the test.</p><p>For this recipe, the FLAs should only be compiled using Flash Professional CS5. However, if you are using CS5.5, read through the material covered here before moving to the next recipe.<a id="id470" class="indexterm"/>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec07"/>How to do it...</h2></div></div></div><p>Let us select a rendering mode for each FLA and see how they perform on an actual device.<a id="id471" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Open<code class="literal"> render-test-cpu.fla</code> within Flash Professional CS5.</li><li class="listitem">Select<span class="strong"><strong> File</strong></span> |<span class="strong"><strong> iPhone OS Settings</strong></span>.</li><li class="listitem">From the<span class="strong"><strong> iPhone OS Settings</strong></span> panel, select<span class="strong"><strong> CPU</strong></span> from the<span class="strong"><strong> Rendering</strong></span> field's drop-down box. Click on<span class="strong"><strong> OK</strong></span> to confirm the change.<div class="mediaobject"><img src="graphics/1383_06_02.jpg" alt="How to do it..."/></div></li><li class="listitem">Save the FLA.</li><li class="listitem">Publish the FLA and deploy<code class="literal"> c6-r2-cpu.ipa</code> to your device. On your device's home screen, find the app named<span class="strong"><strong> c6 r2 cpu</strong></span> and launch it. Take a note of the frame rate that was achieved by the test and then close the app.</li><li class="listitem">Now, open<code class="literal"> render-test-gpu.fla</code>.</li><li class="listitem">Select<span class="strong"><strong> File</strong></span> |<span class="strong"><strong> iPhone OS Settings</strong></span>. This time, set the panel's<span class="strong"><strong> Rendering</strong></span> field to<span class="strong"><strong> GPU</strong></span>.</li><li class="listitem">Click on<span class="strong"><strong> OK</strong></span> to close the panel.</li><li class="listitem">Save the FLA.</li><li class="listitem">Publish and deploy<code class="literal"> c6-r2-gpu.ipa</code> to your device. Launch the app labeled<span class="strong"><strong> c6 r2 gpu</strong></span>. Take a note of the frame rate that was achieved.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec08"/>How it works...</h2></div></div></div><p>From the iPhone OS Settings panel, we set a different rendering mode for each of the FLAs. Both FLAs performed an identical test but used a different rendering path. The first used the CPU to render all graphical content, while we selected the GPU for the second.<a id="id472" class="indexterm"/>
</p><p>The following chart shows the results of running the tests on a selection of devices. The results show the frame rate, measured in frames per second, that was achieved by each test.</p><div class="mediaobject"><img src="graphics/1383_06_03.jpg" alt="How it works..."/></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note38"/>Note</h3><p>The results shown in this chart are an average taken from five runs of each test. Each device was running iOS 5 with the exception of the first-generation iPod touch, which had iOS 3.1 installed.</p><p>Use these results as a rough guide as they may vary slightly across runs.</p></div><p>As you can see, the actual results vary across device but surprisingly there is very little difference in performance between the two modes, with CPU being slightly faster. You likely expected GPU rendering to be significantly better than CPU but to understand why this was not the case, we need to examine the rendering process in a little more detail. In particular, we need to look at how GPU rendering is implemented by AIR 2.0 in Flash Professional CS5.<a id="id473" class="indexterm"/>
</p><div class="section" title="The rendering process"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec02"/>The rendering process</h3></div></div></div><p>Rendering is split into the following two distinct parts:<a id="id474" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Rasterization<a id="id475" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">Scene composition</li></ul></div><p>During<span class="strong"><strong> rasterization,</strong></span> every element within your display list is drawn to a separate off-screen pixel buffer.<a id="id476" class="indexterm"/>
</p><p>Once rasterization is complete, those pixel buffers are taken and are arranged to recreate the scene represented by the display list. This is known as<span class="strong"><strong> scene composition</strong></span>.<a id="id477" class="indexterm"/>
</p><p>Regardless of whether you are using Flash CS5 or CS5.5, both CPU and GPU modes will perform this rendering process. How each rendering mode achieves this, however, is different.</p></div><div class="section" title="CPU mode and GPU-Blend mode"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec03"/>CPU mode and GPU-Blend mode</h3></div></div></div><p>When using CPU mode, both rasterization and scene composition are performed entirely in software by the CPU.<a id="id478" class="indexterm"/>
</p><p>In Flash CS5, when GPU mode is selected, the device's GPU will be used to compose the scene. Rasterization, however, is still performed by the CPU, with each of the off-screen pixel buffers being uploaded to the GPU for composition. In other words, the rendering process is only partially performed on the GPU. This is shown in the following illustrations. This implementation is known as GPU Blend and differs from that used by CS5.5:</p><div class="mediaobject"><img src="graphics/1383_06_04.jpg" alt="CPU mode and GPU-Blend mode"/></div><p>The following table should help clarify the difference between CPU and GPU-Blend mode used by AIR 2.0 in Flash CS5:<a id="id479" class="indexterm"/>
</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Render mode</p>
</th><th style="text-align: left" valign="bottom">
<p>Rasterization</p>
</th><th style="text-align: left" valign="bottom">
<p>Scene composition</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>CPU</p>
</td><td style="text-align: left" valign="top">
<p>CPU</p>
</td><td style="text-align: left" valign="top">
<p>CPU</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>GPU Blend</p>
</td><td style="text-align: left" valign="top">
<p>CPU</p>
</td><td style="text-align: left" valign="top">
<p>GPU</p>
</td></tr></tbody></table></div><p>The GPU found on iOS devices can compose a scene much faster than the CPU. However, the process of uploading the pixel buffers from the CPU to the GPU can be expensive because of the amount of data that has to be sent. Therefore, to benefit from GPU acceleration when using Flash CS5, you must minimize the amount of bitmap traffic going from the CPU to the GPU. In other words, you need to reduce the frequency with which display objects are re-rasterized.</p></div><div class="section" title="Redrawing dirty regions"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec04"/>Redrawing dirty regions</h3></div></div></div><p>Re-rasterization takes place when content within a scene changes. Whenever changes occur, Flash takes a note of the rectangular regions within the scene that need to be redrawn. These are known as the dirty regions and are used as an alternative to simply rendering the entire screen again. This is illustrated in the following diagram where the star-shaped clip moves position:<a id="id480" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/1383_06_05.jpg" alt="Redrawing dirty regions"/></div><p>In this example, the star movie clip changes position between frames and by doing so creates a dirty region. The dirty region is represented as a rectangular area that encompasses the space consumed by the star's previous and current location. The circle, background image, and the star itself all touch this dirty region meaning all three need to be re-rasterized. Any display objects that intersect a dirty region need to be re-rasterized.<a id="id481" class="indexterm"/>
</p><p>When using GPU Blend, the bitmap data for each of the re-rasterized display objects needs to be uploaded to the GPU in order for compositing to take place. As stated, uploading to the GPU can be expensive.</p><p>For scenes that change frequently, the performance of your app may suffer when using GPU acceleration. This is why<code class="literal"> render-test-gpu.fla</code> doesn't perform as well as you might expect. There are so many changes per frame that the bandwidth penalty from transferring the re-drawn pixel buffers to the GPU actually negates much of the performance gained from utilizing the GPU.<a id="id482" class="indexterm"/>
</p><p>There are techniques that can be employed to cache bitmap data directly on the GPU rather than continuously re-rasterizing and uploading from the CPU. We will discuss these shortly, but it should be clear that taking full advantage of AIR 2.0's hardware acceleration isn't as simple as changing the rendering mode within the iPhone OS Settings panel.</p></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec09"/>There's more...</h2></div></div></div><p>One more thing, which you may have noticed when selecting a rendering mode is as follows:</p><div class="section" title="Auto rendering"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec05"/>Auto rendering</h3></div></div></div><p>As well as CPU and GPU, there is an additional rendering option named<span class="strong"><strong> Auto</strong></span> that is available. At this moment in time,<span class="strong"><strong> Auto</strong></span> actually defaults to the CPU renderer and is, therefore, no different to selecting<span class="strong"><strong> CPU</strong></span>. This is true for both Flash Professional CS5 and CS5.5.<a id="id483" class="indexterm"/>
</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec10"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Understanding GPU-Vector mode</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Using Cache as Bitmap</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Using Cache as Bitmap Matrix</em></span></li></ul></div></div></div>
<div class="section" title="Understanding GPU-Vector mode"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec04"/>Understanding GPU-Vector mode</h1></div></div></div><p>In the<span class="emphasis"><em> Understanding GPU-Blend mode</em></span> recipe, we spent time covering the intricacies of the GPU-rendering mode provided by Flash Professional CS5. Although GPU rendering is also supported for those using Flash Professional CS5.5, its implementation differs from CS5's.<a id="id484" class="indexterm"/>
</p><p>In this recipe, we will cover how to select a rendering mode using CS5.5 and also use the same tests from the<span class="emphasis"><em> Understanding GPU-Blend mode</em></span> recipe in order to see the performance difference between both GPU renderers.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec11"/>Getting ready</h2></div></div></div><p>Two FLAs have been provided<code class="literal">—render-test-cpu.fla</code> and<code class="literal"> render-test-gpu.fla—and</code> can be found in the book's accompanying code bundle at<code class="literal"> chapter6\recipe3\</code>.<a id="id485" class="indexterm"/>
</p><p>Both FLAs are identical, with each randomly re-positioning ten movie-clip instances on every frame update. After five seconds, the test will end and the average number of frames per second (FPS) that was achieved will be shown. The higher that number, the faster the rendering performance of the test.</p><p>The FLAs should only be compiled using Flash Professional CS5.5. However, it is recommended that those using CS5 read through the material covered here rather than skipping to the next recipe.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec12"/>How to do it...</h2></div></div></div><p>Let us select a different rendering mode for each FLA and see the performance differences between the two on an actual device.<a id="id486" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Open<code class="literal"> render-test-cpu.fla</code> within Flash Professional CS5.5.</li><li class="listitem">Select<span class="strong"><strong> File</strong></span> |<span class="strong"><strong> AIR for iOS Settings</strong></span> from Flash's drop-down menu.</li><li class="listitem">From the AIR for iOS Settings panel, select<span class="strong"><strong> CPU</strong></span> from the<span class="strong"><strong> Rendering</strong></span> field's drop-down box. Click on<span class="strong"><strong> OK</strong></span>.</li><li class="listitem">Save the FLA.</li><li class="listitem">Publish the FLA and deploy<code class="literal"> c6-r3-cpu.ipa</code> to your device. From the home screen, launch the app labeled<span class="strong"><strong> c6 r3 cpu</strong></span>. Let the app run for five seconds and then take a note of the frame rate.</li><li class="listitem">Now, open<code class="literal"> render-test-gpu.fla</code>.</li><li class="listitem">Move to the<span class="strong"><strong> AIR for iOS Settings</strong></span> panel and this time set the<span class="strong"><strong> Rendering</strong></span> field to<span class="strong"><strong> GPU</strong></span>.</li><li class="listitem">Save the FLA.</li><li class="listitem">Publish and deploy<code class="literal"> c6-r3-gpu.ipa</code> to your device. Launch<span class="strong"><strong> c6 r3 gpu</strong></span> and take a note of the app's frame rate.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec13"/>How it works...</h2></div></div></div><p>From the AIR for iOS Settings panel, we set a different rendering mode for each of the test FLAs. Both FLAs performed an identical test but used different rendering paths. The first used the CPU to render all graphics content, while we selected the GPU for the second.<a id="id487" class="indexterm"/>
</p><p>The following chart shows the results of running the tests on a selection of devices. Each result shows the average frame rate that was achieved by each test.</p><div class="mediaobject"><img src="graphics/1383_06_06.jpg" alt="How it works..."/></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note39"/>Note</h3><p>The results shown throughout this recipe are an average taken from five runs of each test. Each device was running iOS 5.</p><p>Use these results as a rough guide as they may vary slightly across runs.</p></div><p>It should be apparent that impressive performance gains can be made when setting GPU rendering within Flash Professional CS5.5. This is in stark contrast to the results from the<span class="emphasis"><em> Understanding GPU-Blend mode</em></span> recipe where Flash Professional CS5 was used. Take the<span class="strong"><strong> iPhone 4</strong></span> as an example. While there was no benefit from using the GPU when publishing from CS5, the same test published from CS5.5 exhibited a 252% increase in render performance—23 frames per second using the CPU compared to 58 using the GPU.<a id="id488" class="indexterm"/>
</p><p>The following chart lets you easily compare the GPU rendering results for<code class="literal"> render-test-gpu.fla</code> across both versions of Flash Professional:<a id="id489" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/1383_06_07.jpg" alt="How it works..."/></div><p>When published from CS5 and run on an iPhone 4, only an average of 17 frames per second were achieved over a five second period. Publishing the FLA using CS5.5 managed 58 frames per second on the same device. Quite an improvement!<a id="id490" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note40"/>Note</h3><p>You may have noticed in this chart that the GPU test compiled from Flash CS5.5 was not run on the first-generation iPod touch. Support for ARM v6 devices such as the first-generation iPod touch was dropped in AIR 2.6.</p></div><p>So why does GPU rendering produce such huge gains in CS5.5 compared to CS5? It is down to changes in how GPU rendering has been implemented since AIR 2.6, which we will now cover.<a id="id491" class="indexterm"/>
</p><div class="section" title="GPU-Vector mode"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec06"/>GPU-Vector mode</h3></div></div></div><p>GPU Blend, which is the GPU-render mode supported in Flash CS5, only actually performs scene composition on the GPU—rasterization takes place entirely on the CPU. The GPU-render mode supported by CS5.5, however, performs both rasterization and scene composition on the GPU, removing the need to transfer bitmap data from the CPU to the GPU. This implementation is known as GPU Vector and is many times faster than GPU Blend.<a id="id492" class="indexterm"/>
</p><p>When GPU rendering is selected, GPU Vector will be used by AIR for iOS apps published from Flash Professional CS5.5, while apps published from CS5 will use GPU Blend.</p><p>The following table summarizes the various rendering modes and from which version of Flash and AIR each is available:<a id="id493" class="indexterm"/>
</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Render mode</p>
</th><th style="text-align: left" valign="bottom">
<p>Rasterization</p>
</th><th style="text-align: left" valign="bottom">
<p>Scene composition</p>
</th><th style="text-align: left" valign="bottom">
<p>Flash</p>
</th><th style="text-align: left" valign="bottom">
<p>AIR</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>CPU</p>
</td><td style="text-align: left" valign="top">
<p>CPU</p>
</td><td style="text-align: left" valign="top">
<p>CPU</p>
</td><td style="text-align: left" valign="top">
<p>CS5 and CS5.5</p>
</td><td style="text-align: left" valign="top">
<p>2.0 - 3.x</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>GPU Blend</p>
</td><td style="text-align: left" valign="top">
<p>CPU</p>
</td><td style="text-align: left" valign="top">
<p>GPU</p>
</td><td style="text-align: left" valign="top">
<p>CS5</p>
</td><td style="text-align: left" valign="top">
<p>2.0</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>GPU Vector</p>
</td><td style="text-align: left" valign="top">
<p>GPU</p>
</td><td style="text-align: left" valign="top">
<p>GPU</p>
</td><td style="text-align: left" valign="top">
<p>CS5.5</p>
</td><td style="text-align: left" valign="top">
<p>2.6 - 3.x</p>
</td></tr></tbody></table></div><p>When working with Flash Professional CS5, obtaining a high frame rate from even a modest FLA can be difficult without an understanding of GPU Blend and knowing how to minimize bitmap traffic between the CPU and GPU. On the other hand, those working with Flash Professional CS5.5 need not worry so much. GPU-Vector mode removes much of the hardship, making the process of writing AIR for iOS apps closer to writing for the desktop.</p><p>Use GPU mode ahead of CPU as it yields better performance. This is true for both CS5 and CS5.5, although those using CS5 will need to work a little harder in order to take advantage of the hardware acceleration provided by the GPU.<a id="id494" class="indexterm"/>
</p><p>GPU Vector is a very strong reason for upgrading from Flash Professional CS5 to CS5.5. Of course, if you are targeting older iOS devices such as the second-generation iPod touch or iPhone 3G, then you will still need to rely upon CS5 and GPU Blend.</p></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec14"/>There's more...</h2></div></div></div><p>The blazing-fast performance of GPU-Vector mode does come at a cost.</p><div class="section" title="Rendering vectors using GPU-Vector mode"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec07"/>Rendering vectors using GPU-Vector mode</h3></div></div></div><p>Performance isn't the only noticeable difference between GPU-Blend and GPU-Vector modes. Whereas GPU Blend and CPU will produce identical renditions of vector artwork, GPU Vector won't always be so accurate.<a id="id495" class="indexterm"/>
</p><p>The GPU is optimized for rendering bitmaps and doesn't provide the same fidelity as the software renderer when recreating the complex vector shapes used by Flash. GPU-Vector mode requires that Flash's vector shapes be converted to simpler triangles that can be rendered quickly by the GPU. GPU Blend on the other hand, performs all rasterization on the CPU, allowing it to take advantage of the software renderer at the expense of performance.<a id="id496" class="indexterm"/>
</p><p>When using Flash Professional CS5.5, be aware that rendering vector artwork on the GPU won't be as precise as rendering on the CPU. CPU rendering is accurate but slow, whereas the GPU is faster but inaccurate. However, any differences between the two can be difficult to spot.<a id="id497" class="indexterm"/>
</p></div><div class="section" title="Using GPU-Vector mode with Flash Professional CS5"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec08"/>Using GPU-Vector mode with Flash Professional CS5</h3></div></div></div><p>Although Flash Professional CS5 only supports AIR 2.0, it is actually possible to take advantage of the GPU-Vector rendering mode supported by AIR 2.6 and above. To do this, you will need to first publish a SWF from Flash CS5, then package the SWF into a native iOS app from the command line using the AIR Development Tool (ADT). ADT is included with the latest AIR SDK and can be downloaded from<a class="ulink" href="http://www.adobe.com/products/air/sdk"> www.adobe.com/products/air/sdk</a>.<a id="id498" class="indexterm"/>
</p><p>Command line packaging is outside the scope of this book; however, Adobe does provide detailed documentation on the subject at:<a class="ulink" href="http://help.adobe.com/en_US/air/build/WS901d38e593cd1bac35eb7b4e12cddc5fbbb-8000.html"> http://help.adobe.com/en_US/air/build/WS901d38e593cd1bac35eb7b4e12cddc5fbbb-8000.html</a>.</p></div><div class="section" title="Stage 3D"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec09"/>Stage 3D</h3></div></div></div><p>In addition to AIR's existing rendering modes, Adobe has recently released a new rendering model named Stage 3D (previously codenamed Molehill), which leverages GPU hardware to provide advanced 2D and 3D capabilities.<a id="id499" class="indexterm"/>
</p><p>At the time of writing, Stage 3D is only available for Flash and AIR on the desktop. However, Adobe is actively working to bring it to mobile. When it arrives, Stage 3D's performance should far exceed what is currently possible with AIR for iOS's existing rendering pipelines.</p><p>You can find out more about Stage 3D from Adobe Developer Connection at<a class="ulink" href="http://www.adobe.com/devnet/flashplayer/stage3d.html"> www.adobe.com/devnet/flashplayer/stage3d.html</a>.</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec15"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Using Cache as Bitmap</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Using Cache as Bitmap Matrix</em></span></li></ul></div></div></div>
<div class="section" title="Using Cache as Bitmap"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec05"/>Using Cache as Bitmap</h1></div></div></div><p>Rasterization can be expensive and should be minimized. For display objects that only experience translation along the X and Y axes, there is a technique available that removes the need for that object to be re-rasterized. This technique is known as Cache as Bitmap and in most circumstances can accelerate the rendering performance of your application.</p><p>Cache as Bitmap takes a display object and generates a bitmap representation of it internally. The cached bitmap is then used for rendering rather than re-rasterizing the original display object. This can result in huge performance gains, particularly when working with complex vector artwork, which can be CPU-intensive to rasterize.<a id="id500" class="indexterm"/>
</p><p>Normally, when a display object changes position, it needs to be re-rasterized. When cached, however, any two-dimensional translations will no longer result in that object being redrawn. Instead, its cached bitmap will be used.</p><p>Let us see how to apply Cache as Bitmap using both ActionScript and the Flash IDE.<a id="id501" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec16"/>Getting ready</h2></div></div></div><p>Before continuing you should be aware of the difference between vector and bitmap graphics, and also have a firm understanding of the various rendering paths available when developing AIR for iOS apps. If you haven't already done so, complete the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Comparing vector and bitmap graphics</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Understanding GPU-Blend mode</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Understanding GPU-Vector mode</em></span></li></ul></div><p>An FLA has been provided for this recipe and can be found within the book's accompanying code bundle at<code class="literal"> chapter6\recipe4\recipe.fla</code>.<a id="id502" class="indexterm"/>
</p><p>Its document class positions ten instances of a<span class="strong"><strong> Monkey</strong></span> movie clip on top of a<span class="strong"><strong> Background</strong></span> movie clip. On every frame update, the ten monkeys are randomly repositioned. After a period of five seconds, the average frame rate that was achieved is displayed.</p><p>The movie clips used for this recipe are constructed from vector graphics as opposed to bitmaps. Also, this recipe's FLA has been set to use GPU rendering.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec17"/>How to do it...</h2></div></div></div><p>We will first see how the existing version of the FLA performs before taking advantage of bitmap caching.<a id="id503" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Open<code class="literal"> recipe.fla</code>.</li><li class="listitem">Publish the current version of the FLA and deploy it to your device.</li><li class="listitem">Launch the app from your device's home screen.</li><li class="listitem">Take a note of the frame rate; then delete the app from your device.</li><li class="listitem">Now, move back to<code class="literal"> recipe.fla</code> within Flash.<p>Let us apply Cache as Bitmap to the display objects used by the FLA. Using the <span class="strong"><strong>Selection Tool (V)</strong></span>, click on the <span class="strong"><strong>Background</strong></span> movie clip sitting on the stage. From the <span class="strong"><strong>Properties</strong></span> panel, expand the <span class="strong"><strong>DISPLAY</strong></span> section and enable Cache as Bitmap. If you are using Flash Professional CS5, then this is done by checking the <span class="strong"><strong>Cache as bitmap</strong></span> checkbox. For CS5.5, select <span class="strong"><strong>Cache as Bitmap</strong></span> from the <span class="strong"><strong>Render</strong></span> field's drop-down box.
</p></li><li class="listitem">Open the FLA's document class and add the following line of code within the constructor:<div class="informalexample"><pre class="programlisting">for(var i:uint = 0; i &lt; 10; i++)
{
var monkey:MovieClip = new Monkey();
monkey.x = Math.random() * stage.stageWidth;
monkey.y = Math.random() * stage.stageHeight;
monkey.cacheAsBitmap = true;
monkeys.push(monkey);
addChild(monkey);
}
</pre></div></li><li class="listitem">Save the class.</li><li class="listitem">Publish and deploy the new version to your device.</li><li class="listitem">Compare the frame rate against the previous version of the app. The app's performance should be noticeably improved.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec18"/>How it works...</h2></div></div></div><p>The<code class="literal"> DisplayObject</code> class provides the<code class="literal"> cacheAsBitmap</code> property, which is available from any class that extends<code class="literal"> DisplayObject</code>, such as<code class="literal"> Sprite</code> and<code class="literal"> MovieClip</code>.<a id="id504" class="indexterm"/>
</p><p>We used ActionScript to set the<code class="literal"> cacheAsBitmap</code> property for each of the<span class="strong"><strong> Monkey</strong></span> instances:</p><div class="informalexample"><pre class="programlisting">monkey.cacheAsBitmap = true;
</pre></div><p>For the<span class="strong"><strong> Background</strong></span> movie clip sitting on the stage, caching was activated through the<span class="strong"><strong> Properties</strong></span> panel.</p><p>To understand why bitmap caching can be beneficial, let us start by examining what happens within this recipe's example when Cache as Bitmap isn't set.</p><p>On each frame update, the position of the ten<span class="strong"><strong> Monkey</strong></span> movie-clip instances is changed, forcing a dirty region to be created for each of the ten clips. Although the<span class="strong"><strong> Background</strong></span> movie clip doesn't change position, it falls within the dirty regions. Therefore, on each frame update, the<span class="strong"><strong> Background</strong></span> and all ten<span class="strong"><strong> Monkey</strong></span> instances need to be re-rasterized before being composited into the scene.</p><p>By taking advantage of Cache as Bitmap, the rendering time for each frame can be reduced. After setting Cache as Bitmap, each clip is initially rasterized and an internal representation is stored. Now on each frame update, there will be no need to re-rasterize any of the<span class="strong"><strong> Monkey</strong></span> movie clips or the<span class="strong"><strong> Background</strong></span> movie clip, as a cached bitmap representation of each is available and can be used during scene composition.</p><p>On every frame update other than the first, we have managed to completely skip rasterization.</p><p>Whether using Flash Professional CS5 or CS5.5, you should have experienced a significant performance increase by using Cache as Bitmap. The following chart gives you the results from publishing this recipe's example using CS5 and testing it on a handful of devices:</p><div class="mediaobject"><img src="graphics/1383_06_08.jpg" alt="How it works..."/></div><p>And the following chart shows the same test published using CS5.5 and AIR 3.0:<a id="id505" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/1383_06_09.jpg" alt="How it works..."/></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note41"/>Note</h3><p>The results shown in these charts are an average taken from five runs of each test. Each device was running iOS 5 with the exception of the first-generation iPod touch, which had iOS 3.1 installed.</p><p>Use these results as a rough guide as they may vary slightly across runs.</p></div><p>As you can see from the charts, Cache as Bitmap can significantly increase your application's frame rate when using complex vector artwork. This does come at the expense of memory; however, as an additional bitmap for each display object must be stored.<a id="id506" class="indexterm"/>
</p><p>Although we utilized GPU rendering in this recipe, using Cache as Bitmap in conjunction with CPU rendering will also lead to performance increases when dealing with complex vector artwork. Caching directly on the GPU, however, produces the largest performance increase.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec19"/>There's more...</h2></div></div></div><p>Cache as Bitmap is extremely powerful and when used correctly can be hugely beneficial. However, it is not always apparent when to use it and there are several pitfalls that you should be aware of.<a id="id507" class="indexterm"/>
</p><div class="section" title="Other transformation changes"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec10"/>Other transformation changes</h3></div></div></div><p>Bitmap caching is only advantageous if the cached bitmap does not have to be frequently re-generated. While changes along the X or Y axes are fine, other changes will invalidate the cached bitmap, forcing the display object to be re-cached.<a id="id508" class="indexterm"/>
</p><p>For objects that don't change often, you may be willing to take the performance hit. However, frequent changes are likely to degrade the performance of your application, as each new change is rasterized and then copied back into the internal pixel buffer.</p><p>The following is a list of changes that will force a display object to be re-cached:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Visibility<a id="id509" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">Alpha transparency</li><li class="listitem" style="list-style-type: disc">Transformation—Scale and Rotation</li><li class="listitem" style="list-style-type: disc">Playhead movement within the object's timeline</li><li class="listitem" style="list-style-type: disc">Any change to a child object</li></ul></div><p>Constantly re-caching is very expensive and will slow your application. If you need to make frequent changes to an object, then either avoid using Cache as Bitmap, or deactivate it during such periods. Improper use of Cache as Bitmap will reduce the render performance of your application rather than improve it.<a id="id510" class="indexterm"/>
</p></div><div class="section" title="Caching display objects that contain children"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec11"/>Caching display objects that contain children</h3></div></div></div><p>Be careful when setting Cache as Bitmap on display objects that contain children.<a id="id511" class="indexterm"/>
</p><p>An internal bitmap will be created of the entire container including all of its child objects. If any of those children change relative to the container, then the whole container clip will need to be re-cached. This is true even if a child object only changes its<code class="literal"> x</code> or<code class="literal"> y</code> position. It is only the container clip that can be successfully translated without invalidating the cached bitmap.</p><p>For nested clips, apply Cache as Bitmap to the lowest leaf node that changes relative to its container. Don't apply Cache as Bitmap to the container itself.</p><p>This is a common mistake and can cripple the performance of your application.</p></div><div class="section" title="Taking advantage of GPU Blend"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec12"/>Taking advantage of GPU Blend</h3></div></div></div><p>If you are using Flash Professional CS5 and wish to take advantage of GPU rendering, then the use of Cache as Bitmap is essential for GPU Blend to be effective. It isn't just vectors that can benefit either—bitmap performance can be accelerated too.<a id="id512" class="indexterm"/>
</p><p>Where cached bitmaps are stored is important. When using GPU rendering, the cached bitmaps will be stored directly on the GPU as textures. This is of particular importance when using GPU Blend as it removes the bandwidth bottleneck experienced when bitmap data is repeatedly transferred from the CPU to the GPU.</p><p>By using bitmap caching in conjunction with GPU Blend, rendering performance will be vastly increased. The only time bitmap data will be transferred from the CPU to the GPU will be when each display object is initially cached, or when a cached bitmap needs to be regenerated.</p><p>For GPU Blend, Cache as Bitmap will accelerate both display objects that use vectors and those that use bitmaps. Where possible, try to take advantage of it.</p></div><div class="section" title="Bitmaps and GPU Vector"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec13"/>Bitmaps and GPU Vector</h3></div></div></div><p>While applying Cache as Bitmap to bitmaps provides acceleration for GPU Blend, the same isn't true for GPU Vector and will actually slightly degrade performance.<a id="id513" class="indexterm"/>
</p><p>When you cache a display object, you are essentially creating a pixel buffer. However, that is exactly what a bitmap is anyway. By caching bitmaps when using GPU Vector, you are simply creating a secondary copy of your bitmap, which will only consume more memory and take time to perform the second copy.</p><p>In GPU-Blend mode, Cache as Bitmap is used to copy the bitmaps to GPU memory. In GPU-Vector mode, the bitmaps are already in GPU memory, removing the need for Cache as Bitmap.</p></div><div class="section" title="Using vectors ahead of bitmaps"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec14"/>Using vectors ahead of bitmaps</h3></div></div></div><p>When working with vector artwork, Cache as Bitmap can be used to produce the performance benefits typically associated with bitmaps. Simply create your artwork using Flash's drawing tools and then set Cache as Bitmap for each movie clip that contains that vector artwork. The clips will be rasterized and the cached bitmap versions will be used from that point onwards.</p><p>This technique is almost as fast as simply using a bitmap representation of your artwork. The only difference being is that a vector version first has to be converted to a bitmap, which will result in a slight performance hit when the object first appears on screen. If the size of your IPA is a concern or you genuinely need to use vector artwork, then this option is ideal.<a id="id514" class="indexterm"/>
</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec20"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Adding content to the stage, <a class="link" href="ch02.html" title="Chapter 2. Building iOS Apps Using Flash">Chapter 2</a></em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Masking content, <a class="link" href="ch04.html" title="Chapter 4. Porting Flash Projects to iOS">Chapter 4</a></em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Using Cache as Bitmap Matrix</em></span></li></ul></div></div></div>
<div class="section" title="Using Cache as Bitmap Matrix"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec06"/>Using Cache as Bitmap Matrix</h1></div></div></div><p>Cache as Bitmap is extremely useful for display objects that are only affected by two-dimensional translation. However, it is also possible to benefit from bitmap caching when applying other changes to a display object such as scaling and rotation. This is achieved by using a transform matrix in conjunction with a cached bitmap and is known as Cache as Bitmap Matrix.<a id="id515" class="indexterm"/>
</p><p>Let us work through an example.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec21"/>Getting ready</h2></div></div></div><p>An FLA has been provided as a starting point. From the book's accompanying code bundle, open<code class="literal"> chapter6\recipe5\recipe.fla</code> into Flash Professional.<a id="id516" class="indexterm"/>
</p><p>Ten instances of a<span class="strong"><strong> Monkey</strong></span> movie clip are positioned on top of a<span class="strong"><strong> Background</strong></span> movie clip. All ten movie clips are continuously rotated and after five seconds, the average frame rate that was achieved is displayed.<a id="id517" class="indexterm"/>
</p><p>The movie clips used for this recipe are constructed from vector graphics and the FLA has been set to use GPU rendering.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec22"/>How to do it...</h2></div></div></div><p>Work through the following steps to see the performance benefit Cache as Bitmap Matrix provides for each of the rotating movie clips.<a id="id518" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Publish the current version of the FLA and deploy it to a device.</li><li class="listitem">Launch the app and take a note of the frame rate that is reported after five seconds.</li><li class="listitem">Delete the app from your device.</li><li class="listitem">Move back to<code class="literal"> recipe.fla</code> within Flash Professional.</li><li class="listitem">Open the FLA's<code class="literal"> Main.as</code> document class and add the following lines of code within the constructor:<div class="informalexample"><pre class="programlisting">var matrix:Matrix = new Matrix();
for(var i:uint = 0; i &lt; 10; i++)
{
<span class="strong"><strong>var monkey:MovieClip = new Monkey();
</strong></span>
monkey.x = Math.random() * stage.stageWidth;
monkey.y = Math.random() * stage.stageHeight;
monkey.rotation = Math.random() * 360;
monkey.cacheAsBitmap = true;
<span class="strong"><strong>monkey.cacheAsBitmapMatrix = matrix;
</strong></span>
monkeys.push(monkey);
addChild(monkey);
}
</pre></div></li><li class="listitem">Finally, add an import statement for the<code class="literal"> Matrix</code> class:<div class="informalexample"><pre class="programlisting">import flash.geom.Matrix;
</pre></div></li><li class="listitem">Save the document class.</li><li class="listitem">Publish and deploy to your device.</li><li class="listitem">Compare the number of frames rendered against the previous version of the app. It should be improved.<a id="id519" class="indexterm"/></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec23"/>How it works...</h2></div></div></div><p>Cache as Bitmap Matrix prevents a display object's cached bitmap from becoming invalid when any two-dimensional transformation is applied. The same is also true for a change in visibility or alpha transparency. Therefore, for any of these changes, the cached bitmap won't be regenerated; the changes will instead be applied directly to the cached bitmap's internal pixel buffer, which is advantageous as the display object won't need to be re-rasterized.<a id="id520" class="indexterm"/>
</p><p>Unlike Cache as Bitmap, Cache as Bitmap Matrix cannot be set from Flash's<span class="strong"><strong> Properties</strong></span> panel. Instead, use ActionScript to set the<code class="literal"> cacheAsBitmapMatrix</code> property provided by the<code class="literal"> DisplayObject</code> class.</p><p>The<code class="literal"> cacheAsBitmapMatrix</code> property is set by passing it a<code class="literal"> Matrix</code> object and is used to generate the cached bitmap. For this recipe, we passed the identity matrix, which forced the display objects to be rasterized without any change in appearance.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note42"/>Note</h3><p>In mathematics, a matrix is a rectangular array of numbers, which can be used to apply a transformation to points in 2D or 3D space. A matrix can be used to apply various graphical transformations to Flash display objects, such as translation, rotation, scaling, and skewing. An identity matrix is a special matrix that does not alter the appearance of any points that it is applied to.</p><p>The<code class="literal"> flash.geom.Matrix</code> class is provided by the Flash API, making it easy to create matrices that can be used to perform transformations upon your display objects. When instantiating a<code class="literal"> Matrix</code> object, an identity matrix is created if you do not provide any parameters to the constructor.</p></div><p>The<code class="literal"> cacheAsBitmapMatrix</code> property cannot be used on its own and must always be set in conjunction with the<code class="literal"> cacheAsBitmap</code> property. You can see this in the following code snippet taken from this recipe's example code:</p><div class="informalexample"><pre class="programlisting">monkey.cacheAsBitmap = true;
monkey.cacheAsBitmapMatrix = matrix;
</pre></div><p>If you have already applied Cache as Bitmap on a display object, then there is no penalty for also applying Cache as Bitmap Matrix. In fact, this is the recommended practice as it will prevent performance penalties if changes other than to an object's<code class="literal"> x</code> and<code class="literal"> y</code> properties are made.<a id="id521" class="indexterm"/>
</p><p>The following table shows the benefits of using Cache as Bitmap Matrix by highlighting changes that won't invalidate the cached bitmap.</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="bottom">
<p>Translate</p>
</td><td style="text-align: left" valign="bottom">
<p>Scale</p>
</td><td style="text-align: left" valign="bottom">
<p>Rotate</p>
</td><td style="text-align: left" valign="bottom">
<p>Skew</p>
</td><td style="text-align: left" valign="bottom">
<p>Alpha</p>
</td><td style="text-align: left" valign="bottom">
<p>Visibility</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">cacheAsBitmap</code>
</p>
</td><td style="text-align: left" valign="top">
<p><span class="inlinemediaobject"><img src="graphics/icon1.jpg" alt="How it works..."/></span></p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">cacheAsBitmap</code> and<code class="literal"> cacheAsBitmapMatrix</code>
</p>
</td><td style="text-align: left" valign="top">
<p><span class="inlinemediaobject"><img src="graphics/icon1.jpg" alt="How it works..."/></span></p>
</td><td style="text-align: left" valign="top">
<p><span class="inlinemediaobject"><img src="graphics/icon1.jpg" alt="How it works..."/></span></p>
</td><td style="text-align: left" valign="top">
<p><span class="inlinemediaobject"><img src="graphics/icon1.jpg" alt="How it works..."/></span></p>
</td><td style="text-align: left" valign="top">
<p><span class="inlinemediaobject"><img src="graphics/icon1.jpg" alt="How it works..."/></span></p>
</td><td style="text-align: left" valign="top">
<p><span class="inlinemediaobject"><img src="graphics/icon1.jpg" alt="How it works..."/></span></p>
</td><td style="text-align: left" valign="top">
<p><span class="inlinemediaobject"><img src="graphics/icon1.jpg" alt="How it works..."/></span></p>
</td></tr></tbody></table></div><p>When scaling or rotating a vector display object that has been cached, there may be a loss of fidelity as the transformations will be applied to the cached bitmap rather than to the original vector artwork. Therefore, the final rendition will exhibit the artifacts associated with scaling or rotating bitmap images.</p><p>Setting the<code class="literal"> cacheAsBitmapMatrix</code> property generates a cached bitmap even if the display object is off-screen or has its<code class="literal"> visible</code> property set to<code class="literal"> false</code>.</p><p>If you are curious about matrices, then perform a search for<code class="literal"> flash.geom.Matrix</code> within Adobe Community Help. For a better understanding of matrix mathematics, refer to Wikipedia:<a class="ulink" href="http://en.wikipedia.org/wiki/Matrix_(mathematics)"> http://en.wikipedia.org/wiki/Matrix_(mathematics)</a>.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec24"/>There's more...</h2></div></div></div><p>Now, let us explore Cache as Bitmap Matrix in more detail.</p><div class="section" title="Selecting a matrix transformation"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec15"/>Selecting a matrix transformation</h3></div></div></div><p>The matrix transformation you set the<code class="literal"> cacheAsBitmapMatrix</code> property to will be used to generate the cached bitmap.<a id="id522" class="indexterm"/>
</p><p>For example, you may choose to use a scale matrix to create a cached version of a vector movie clip that is actually twice the movie clip's original size. Although the cached bitmap would consume more memory, it would allow the movie clip to maintain its fidelity when being scaled to a maximum of twice its size. Alternatively, you could cache a version that is half the size of the original, reducing memory overheads at the expense of fidelity.</p><p>It is important to note that creating a cached bitmap that is different in size to the actual display object doesn't alter the size of the object on screen. In other words, if your display object is 100x100 pixels in size and its cached bitmap is 50x50 pixels, the object will remain 100x100 pixels in size on screen. AIR will take the 50x50 cached bitmap and actually double its dimensions to ensure it is shown at the correct size.</p><p>The following code example shows how to create a cached bitmap that is half the size of the actual display object:<a id="id523" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">var matrix:Matrix = new Matrix();
matrix.scale(0.5, 0.5);
displayObject.cacheAsBitmap = true;
displayObject.cacheAsBitmapMatrix = matrix;
</pre></div><p>However, generally the identity matrix will suffice:</p><div class="informalexample"><pre class="programlisting">displayObject.cacheAsBitmap = true;
displayObject.cacheAsBitmapMatrix = new Matrix();
</pre></div></div><div class="section" title="Changing the Matrix object"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec16"/>Changing the Matrix object</h3></div></div></div><p>A common pitfall is attempting to apply two-dimensional transformations to a display object by altering the<code class="literal"> cacheAsBitmapMatrix</code> transform. Making changes to this matrix will actually invalidate the cache, forcing a new bitmap to be generated.<a id="id524" class="indexterm"/>
</p><p>To apply transforms such as scaling and rotation to your display object, simply use its two-dimensional transformation properties such as<code class="literal"> scaleX, scaleY</code>, and<code class="literal"> rotation</code>.</p><p>For most use cases, the<code class="literal"> cacheAsBitmapMatrix</code> property should be set once for a display object, and then left untouched.</p></div><div class="section" title="Reusing the Matrix object"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec17"/>Reusing the Matrix object</h3></div></div></div><p>If you are applying the same transformation matrix to a series of display objects, then create a single instance of the<code class="literal"> Matrix</code> object and re-use it. It is a common mistake to recreate the<code class="literal"> Matrix</code> object each time:<a id="id525" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">for(var i:uint = 0; i &lt; 100; i++)
{
<span class="strong"><strong>displayObjects[i].cacheAsBitmap = true;
</strong></span>
<span class="strong"><strong>displayObjects[i].cacheAsBitmapMatrix = new Matrix();
</strong></span>
}
</pre></div><p>This code will compile and run but will create 100 copies of the identity matrix. This will unnecessarily consume memory and degrade performance due to the number of memory allocations and eventual garbage collection.<a id="id526" class="indexterm"/>
</p><p>Instead, create the matrix outside of your loop and re-use it as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>var matrix:Matrix = new Matrix();
</strong></span>
for(var i:uint = 0; i &lt; 100; i++)
{
displayObjects[i].cacheAsBitmap = true;
<span class="strong"><strong>displayObjects[i].cacheAsBitmapMatrix = matrix;
</strong></span>
}
</pre></div></div><div class="section" title="3D properties"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec18"/>3D properties</h3></div></div></div><p>When a display object has a 3D property applied to it, that object automatically becomes cached and you have no control over the transformation matrix that is used to generate the cached bitmap. The<code class="literal"> cacheAsBitmapMatrix</code> property can only be used with display objects that don't have any 3D properties set. If you set a 3D property, such as<code class="literal"> z</code> or<code class="literal"> rotationX</code>, on a display object that has bitmap caching applied, then your cached bitmap will be deactivated and a new bitmap will be generated.<a id="id527" class="indexterm"/>
</p><p>Using 3D properties provides most of the benefits of manually setting the<code class="literal"> cacheAsBitmapMatrix</code> property. The one exception is that setting a 3D object's<code class="literal"> visible</code> property to<code class="literal"> false</code> will invalidate its cached bitmap.<a id="id528" class="indexterm"/>
</p></div><div class="section" title="Working with GPU Blend"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec19"/>Working with GPU Blend</h3></div></div></div><p>Some of the largest performance gains are once again to be had when using AIR 2.0's GPU-Blend rendering mode.<a id="id529" class="indexterm"/>
</p><p>If you have been using Flash Professional CS5 and developing on an older iOS device, then the examples from the<span class="emphasis"><em> Rotating an object</em></span> and<span class="emphasis"><em> Zooming an object</em></span> recipes in<a class="link" href="ch05.html" title="Chapter 5. Multi-touch and Gesture Support"> Chapter 5</a> may have performed poorly. Setting the<code class="literal"> cacheAsBitmap</code> and<code class="literal"> cacheAsBitmapMatrix</code> properties will ensure the movie clip used in each example is stored and transformed directly on the GPU.</p><p>If performance was an issue, then revisit these recipes and add the following two lines of code to the constructor within each FLA's document class:</p><div class="informalexample"><pre class="programlisting">bubble.cacheAsBitmap = true;
bubble.cacheAsBitmapMatrix = new Matrix();
</pre></div><p>Also, remember to import the<code class="literal"> Matrix</code> class:</p><div class="informalexample"><pre class="programlisting">import flash.geom.Matrix;
</pre></div><p>It is also worth noting that it is not just vector graphics that benefit from Cache as Bitmap Matrix when using GPU Blend. Cache as Bitmap Matrix will also accelerate the rendering of bitmaps that have two-dimensional transformations applied to them. However, the opposite is true for GPU Vector, where Cache as Bitmap Matrix will actually harm performance when using bitmaps.<a id="id530" class="indexterm"/>
</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec25"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Rotating an object, <a class="link" href="ch05.html" title="Chapter 5. Multi-touch and Gesture Support">Chapter 5</a></em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Zooming an object, <a class="link" href="ch05.html" title="Chapter 5. Multi-touch and Gesture Support">Chapter 5</a></em></span></li></ul></div></div></div>
<div class="section" title="Accessing bitmaps with ActionScript"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec07"/>Accessing bitmaps with ActionScript</h1></div></div></div><p>The GPU found on iOS devices is optimized for rendering bitmaps rather than the complex vector shapes that can be produced using Flash. This makes bitmaps the preferred graphics option when building high performance apps. While bitmaps can be stored in the library and simply dragged to a timeline during development, they can also be directly manipulated at runtime using ActionScript.<a id="id531" class="indexterm"/>
</p><p>This recipe will show you how to add a bitmap to the display list at runtime.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec26"/>Getting ready</h2></div></div></div><p>From the book's accompanying code bundle, open<code class="literal"> chapter6\recipe6\recipe.fla</code> into Flash Professional.</p><p>Sitting in the library is a bitmap named<span class="strong"><strong> monkey.png</strong></span>. We will write code to add this bitmap to the display list.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec27"/>How to do it...</h2></div></div></div><p>We will split this recipe into two parts. First we will export the bitmap for ActionScript usage, before actually writing some ActionScript to display it at runtime.<a id="id532" class="indexterm"/>
</p><div class="section" title="Exporting the bitmap"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec20"/>Exporting the bitmap</h3></div></div></div><p>Let us start by exporting the bitmap's data for ActionScript usage.<a id="id533" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Within the library, right-click on<span class="strong"><strong> monkey.png</strong></span> and select<span class="strong"><strong> Properties</strong></span> from the context menu.</li><li class="listitem">From the<span class="strong"><strong> Bitmap Properties</strong></span> dialog box, set the<span class="strong"><strong> Compression</strong></span> field to<span class="strong"><strong> Lossless (PNG/GIF)</strong></span>. If you are using Flash Professional CS5.5, then ensure that the<span class="strong"><strong> Options</strong></span> tab is selected first.</li><li class="listitem">Now check the<span class="strong"><strong> Export for ActionScript</strong></span> checkbox and change the text within the<span class="strong"><strong> Class</strong></span> field to<code class="literal"> MonkeyBitmapData</code>. If you are using Flash Professional CS5.5, then this should be performed from the panel's<span class="strong"><strong> ActionScript</strong></span> tab.<a id="id534" class="indexterm"/><p>A warning panel will appear containing the following text:
</p><p><span class="strong"><strong>A definition for this class could not be found in the classpath, so one will be automatically generated in the SWF file upon export.</strong></span>
</p><p>This is the expected behavior. Click on <span class="strong"><strong>OK.</strong></span>
</p></li><li class="listitem">Save the FLA.</li></ol></div></div><div class="section" title="Displaying the bitmap using ActionScript"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec21"/>Displaying the bitmap using ActionScript</h3></div></div></div><p>With the bitmap's data now accessible to ActionScript, let us go ahead and write some code to display it.<a id="id535" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Create a document class and name it<code class="literal"> Main</code>.</li><li class="listitem">Add the following import statement:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>import flash.display.Bitmap;
</strong></span>
import flash.display.MovieClip;
</pre></div></li><li class="listitem">Within the constructor add a line of ActionScript to create an instance of the bitmap data sitting in the library:<div class="informalexample"><pre class="programlisting">public function Main() {
<span class="strong"><strong>var bitmapData:MonkeyBitmapData = new MonkeyBitmapData();
,</strong></span>
}
</pre></div></li><li class="listitem">Now, create a<code class="literal"> Bitmap</code> object that uses the bitmap data:<div class="informalexample"><pre class="programlisting">public function Main() {
var bitmapData:MonkeyBitmapData = new MonkeyBitmapData();
<span class="strong"><strong>var bitmap:Bitmap = new Bitmap(bitmapData);
</strong></span>
}
</pre></div></li><li class="listitem">Finally, position the bitmap and add it to the display list:<div class="informalexample"><pre class="programlisting">public function Main() {
var bitmapData:MonkeyBitmapData = new MonkeyBitmapData();
var bitmap:Bitmap = new Bitmap(bitmapData);
<span class="strong"><strong>
bitmap.x = 23;
bitmap.y = 57;
addChild(bitmap);
</strong></span>
}
</pre></div></li><li class="listitem">Save the class as<code class="literal"> Main.as</code>.</li><li class="listitem">Save your FLA and test using ADL. The bitmap image stored in the library will be displayed on screen.</li><li class="listitem">Publish the FLA and deploy it to your device.<a id="id536" class="indexterm"/></li></ol></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec28"/>How it works...</h2></div></div></div><p>In order to access an image within the library, you need to explicitly export the image's bitmap data for ActionScript usage. We did this by assigning the bitmap a unique class name of<code class="literal"> MonkeyBitmapData</code> from the<span class="strong"><strong> Bitmap Properties</strong></span> dialog box. By using this class name, it is then possible to create an instance of that bitmap data using ActionScript.<a id="id537" class="indexterm"/>
</p><p>Once the bitmap data was obtained, we simply created a<code class="literal"> Bitmap</code> display object and passed it a reference to the bitmap data. Displaying it was then a simple case of setting the bitmap's<code class="literal"> x</code> and<code class="literal"> y</code> properties before adding it to the display list.</p><p>It should be noted that the class you linked the bitmap to is automatically generated when the SWF is published—there is no need to write code as it is done for you. When generated, it will inherit from<code class="literal"> flash.display.BitmapData</code> allowing you to treat any instances of it as a<code class="literal"> BitmapData</code> object.</p><p>Every bitmap you export for ActionScript will be included directly within your app's binary, which will increase both its initial load time and memory footprint. Be careful as there is no way to free these bitmaps from memory once you are finished with them—an app that supports both standard and Retina graphics for example, could easily exhaust memory using this technique. However, with the bitmap data stored directly within the app's binary, access to that data will be fast.</p><p>For more information regarding bitmaps, perform a search for<code class="literal"> flash.display.Bitmap</code> and<code class="literal"> flash.display.BitmapData</code> within Adobe Community Help.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec29"/>There's more...</h2></div></div></div><p>There are performance gains to be had when using bitmaps. The following information will help you take full advantage of GPU acceleration when working directly with them.</p><div class="section" title="Managing image sizes"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec22"/>Managing image sizes</h3></div></div></div><p>If you are using GPU rendering and working with bitmap images, then there are some optimizations you can perform to maximize performance.<a id="id538" class="indexterm"/>
</p><p>The GPU allocates memory using powers of 2 for each of a bitmap's dimensions. For example, a 31x15 bitmap will be allocated the same amount of memory as a 32x16 bitmap, while a 33x17 bitmap will consume the same memory as a 64x32 bitmap. The size of each bitmap also impacts rendering performance, as memory copies take longer for larger bitmaps.</p><p>Use bitmaps with dimensions that are close to a power of 2 but not larger. The dimensions don't have to be exact powers of 2, as Flash will pad the bitmaps for you.</p></div><div class="section" title="Size restrictions"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec23"/>Size restrictions</h3></div></div></div><p>There is a size restriction imposed by the GPU. The actual size depends on the iOS hardware you are using. For older devices, your display objects cannot exceed 1024x1024 pixels in size. The more recent devices allow display objects with a maximum of 2048x2048 pixels in size. The following table summarizes this:<a id="id539" class="indexterm"/>
</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="bottom">
<p>iPhone</p>
</td><td style="text-align: left" valign="bottom">
<p>iPod touch</p>
</td><td style="text-align: left" valign="bottom">
<p>iPad</p>
</td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>original and 3G</p>
</td><td style="text-align: left" valign="top">
<p>3GS and 4/4S</p>
</td><td style="text-align: left" valign="top">
<p>1st and 2nd gen</p>
</td><td style="text-align: left" valign="top">
<p>3rd and 4th gen</p>
</td><td style="text-align: left" valign="top">
<p>1 and 2</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>1024x1024</p>
</td><td style="text-align: left" valign="top">
<p><span class="inlinemediaobject"><img src="graphics/icon1.jpg" alt="Size restrictions"/></span></p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p><span class="inlinemediaobject"><img src="graphics/icon1.jpg" alt="Size restrictions"/></span></p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>2048x2048</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p><span class="inlinemediaobject"><img src="graphics/icon1.jpg" alt="Size restrictions"/></span></p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p><span class="inlinemediaobject"><img src="graphics/icon1.jpg" alt="Size restrictions"/></span></p>
</td><td style="text-align: left" valign="top">
<p><span class="inlinemediaobject"><img src="graphics/icon1.jpg" alt="Size restrictions"/></span></p>
</td></tr></tbody></table></div><p>If you need to work with a display object that is larger than the size permitted by the GPU, then consider using Cache as Bitmap Matrix to cache a smaller representation of it.</p></div><div class="section" title="Storing bitmap data on the GPU"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec24"/>Storing bitmap data on the GPU</h3></div></div></div><p>When utilizing GPU rendering, any<code class="literal"> BitmapData</code> that you export for ActionScript will be stored directly in GPU memory as a texture when instantiated. This is the case for both Flash Professional CS5's GPU-Blend mode and CS5.5's GPU-Vector mode, providing the fastest possible rendering path for both.<a id="id540" class="indexterm"/>
</p><p>There is no need to explicitly set a<code class="literal"> Bitmap</code> object's<code class="literal"> cacheAsBitmap</code> and<code class="literal"> cacheAsBitmapMatrix</code> properties, as the bitmap data used by it will already be GPU-accelerated. In fact, doing so will only serve to create a duplicate copy of the data that is already on the GPU, which would be a waste of memory.</p><p>While display objects that have bitmap caching applied to them become textures,<code class="literal"> BitmapData</code> objects<span class="emphasis"><em> are</em></span> textures on the GPU. This distinction is important and has implications when managing memory. When working with multiple<code class="literal"> Bitmap</code> instances, each bitmap can be made to point to the exact same<code class="literal"> BitmapData</code> object, meaning only one texture is required on the GPU and shared by all. Applying bitmap caching to multiple instances of the same display object, however, uploads an individual texture for each, consuming more memory.<a id="id541" class="indexterm"/>
</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec30"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Linking classes to movie-clip symbols, <a class="link" href="ch03.html" title="Chapter 3. Writing your First App">Chapter 3</a></em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Using Cache as Bitmap Matrix</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Loading bitmaps at runtime</em></span></li></ul></div></div></div>
<div class="section" title="Loading bitmaps at runtime"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec08"/>Loading bitmaps at runtime</h1></div></div></div><p>It is a common practice to minimize an app's up-front load time and memory footprint by loading graphics resources on demand. When making use of bitmaps, it is possible to store them outside of your app's binary and use ActionScript to load them at runtime when required.<a id="id542" class="indexterm"/>
</p><p>Let us see how this is done.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec31"/>Getting ready</h2></div></div></div><p>An FLA has been provided as a starting point.<a id="id543" class="indexterm"/>
</p><p>From the book's accompanying code bundle, open<code class="literal"> chapter6\recipe7\recipe.fla</code> into Flash Professional. Its AIR for iOS settings have been applied and a dynamic text field has been added at the bottom of the stage.</p><p>Additionally,<code class="literal"> chapter6\recipe7\monkey.png</code> has been provided, which is the bitmap we will load at runtime.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec32"/>How to do it...</h2></div></div></div><p>This recipe is split into two parts. First, we will bundle the bitmap with the app, then we will write some ActionScript to load it.<a id="id544" class="indexterm"/>
</p><div class="section" title="Bundling the bitmap"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec25"/>Bundling the bitmap</h3></div></div></div><p>Perform the following steps to bundle the bitmap with the app.<a id="id545" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Open the<span class="strong"><strong> AIR for iOS Settings</strong></span> panel and ensure that the panel's<span class="strong"><strong> General</strong></span> tab is selected.</li><li class="listitem">At the bottom of the panel is the<span class="strong"><strong> Included files</strong></span> list. Click on the<span class="strong"><strong> +</strong></span> symbol above the list and select<span class="strong"><strong> monkey.png</strong></span> from your FLA's root folder. Click on<span class="strong"><strong> Open</strong></span> to select the file. You should now see<span class="strong"><strong> monkey.png</strong></span> in the<span class="strong"><strong> Included files</strong></span> list.</li><li class="listitem">Click on<span class="strong"><strong> OK</strong></span> to close the<span class="strong"><strong> AIR for iOS Settings</strong></span> panel.</li></ol></div></div><div class="section" title="Loading the bitmap at runtime"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec26"/>Loading the bitmap at runtime</h3></div></div></div><p>Now, let us write the ActionScript required to load the bitmap and display it.<a id="id546" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Create a document class and name it<code class="literal"> Main</code>.</li><li class="listitem">Add the following import statements:<div class="informalexample"><pre class="programlisting">import flash.display.MovieClip;
<span class="strong"><strong>
import flash.display.Bitmap;
import flash.display.Loader;
import flash.events.Event;
import flash.net.URLRequest;
</strong></span>
</pre></div></li><li class="listitem">Within the constructor, create an instance of the<code class="literal"> Loader</code> class; listen for<code class="literal"> Event.COMPLETE</code> being dispatched when the bitmap has loaded; and initiate the load:<div class="informalexample"><pre class="programlisting">public function Main() {
<span class="strong"><strong>var loader:Loader = new Loader();
loader.contentLoaderInfo.addEventListener(Event.COMPLETE,
bitmapLoaded);
loader.load(new URLRequest("monkey.png"));
</strong></span>
}
</pre></div></li><li class="listitem">Finally, add a handler for<code class="literal"> Event.COMPLETE</code>.<div class="informalexample"><pre class="programlisting">private function bitmapLoaded(e:Event):void {
var b:Bitmap = e.target.content as Bitmap;
b.x = 23;
b.y = 57;
addChild(b);
msgField.text = "loaded";
}
</pre></div></li><li class="listitem">The <code class="literal">bitmapLoaded()</code> handler will add the loaded bitmap to the stage. The bitmap is obtained from the handler's event parameter, positioned then added to the display list.<a id="id547" class="indexterm"/></li><li class="listitem">Save the class; when prompted name the file<code class="literal"> Main.as</code>.</li><li class="listitem">Save the FLA and test using ADL to ensure there are no compiler errors. The bitmap should load and be positioned on screen. Additionally, the text field should be populated with the word<span class="strong"><strong> loaded</strong></span> indicating success.<a id="id548" class="indexterm"/></li><li class="listitem">Finally, publish your app for iOS and deploy it to a device.</li></ol></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec33"/>How it works...</h2></div></div></div><p>Resources can be bundled with an app by adding them to the<span class="strong"><strong> Included files</strong></span> list from the AIR for iOS Settings panel. You can either add files individually or include the contents of a folder. For this recipe, we simply selected the<code class="literal"> monkey.png</code> file, ensuring it would be bundled with the IPA.</p><p>Your app's start-up time won't be affected by this as bundled resources aren't part of its binary. Instead, during installation, they will be copied to the same directory as the app, allowing the app to load them from the device's file system at runtime.</p><p>To actually load the bitmap, an instance of the<code class="literal"> Loader</code> class was used and a call to its<code class="literal"> load()</code> method was made. Load operations are asynchronous—loading from the device's file system can take time—meaning we had to listen for<code class="literal"> Event.COMPLETE</code> being dispatched before attempting to access the bitmap.<a id="id549" class="indexterm"/>
</p><p>With<code class="literal"> monkey.png</code> being bundled into the same folder as the app itself, a relative file path was passed to<code class="literal"> load()</code> rather than an absolute path:</p><div class="informalexample"><pre class="programlisting">loader.load(new URLRequest("monkey.png"));
</pre></div><p>Once the bitmap has loaded, the<code class="literal"> COMPLETE</code> event's handler is called and the bitmap is displayed on screen.<a id="id550" class="indexterm"/>
</p><p>To actually obtain the bitmap, simply extract the loaded content from the<code class="literal"> Event</code> object and cast it to a<code class="literal"> Bitmap</code>. The following line of code does that:</p><div class="informalexample"><pre class="programlisting">var b:Bitmap = e.target.content as Bitmap;
</pre></div><p>You are then free to manipulate the bitmap and add it to the display list.</p><p>Loading bitmaps at runtime rather than including them directly within your FLA's library will reduce the overall size of an app's binary, which will lead to improved start-up times. Additionally, in contrast to resources embedded directly within the app's binary, you will be able to manage your app's memory usage by freeing those bitmaps once you are done with them. While bitmaps directly included within the app will be immediately available, you will actually need to wait for bitmaps from the file system to load.<a id="id551" class="indexterm"/>
</p><p>The<code class="literal"> Loader</code> class loads content asynchronously. This is convenient as it prevents the execution of your application from being blocked while resources are being loaded.<a id="id552" class="indexterm"/>
</p><p>You can obtain more detail regarding the classes used in this recipe from Adobe Community Help. Specifically, take a look at<code class="literal"> flash.display.Loader, flash.display.Bitmap</code>, and<code class="literal"> flash.display.BitmapData</code>.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec34"/>There's more...</h2></div></div></div><p>Before moving on, let us cover a few more points related to bitmap data.</p><div class="section" title="Handling load errors"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec27"/>Handling load errors</h3></div></div></div><p>When loading bitmaps, you should also listen for<code class="literal"> IOErrorEvent.IO_ERROR</code>, which is dispatched when a load operation fails. This will most commonly happen when a file path is incorrect or the resource that you are trying to load is missing.<a id="id553" class="indexterm"/>
</p></div><div class="section" title="Accessing the bitmap's data"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec28"/>Accessing the bitmap's data</h3></div></div></div><p>You can easily access the bitmap's data through the<code class="literal"> Bitmap.bitmapData</code> property. The following code snippet illustrates this:<a id="id554" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">private function bitmapLoaded(e:Event):void {
var b:Bitmap = e.target.content as Bitmap;
<span class="strong"><strong>var bd:BitmapData = b.bitmapData;
</strong></span>
}
</pre></div><p>It is also possible to point the<code class="literal"> bitmapData</code> property to a different<code class="literal"> BitmapData</code> object, changing the bitmap's appearance. This is extremely useful for creating animations programmatically and can be used to fully utilize hardware acceleration on the GPU.</p></div><div class="section" title="Disposing of bitmap data"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec29"/>Disposing of bitmap data</h3></div></div></div><p>While you typically rely on the garbage collector to free memory, you can force AIR, at runtime, to immediately release the bitmap data memory occupied by a<code class="literal"> BitmapData</code> object. This is done by calling<code class="literal"> BitmapData.dispose()</code> and is shown in the following code snippet:<a id="id555" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">private function bitmapLoaded(e:Event):void {
var b:Bitmap = e.target.content as Bitmap;
var bd:BitmapData = b.bitmapData;
<span class="strong"><strong>bd.dispose();
</strong></span>
}
</pre></div><p>The<code class="literal"> BitmapData</code> object itself isn't released, just its bitmap data. The memory consumed by the actual<code class="literal"> BitmapData</code> object is eventually released by the garbage collector.<a id="id556" class="indexterm"/>
</p><p>When you no longer have a use for a bitmap, remember to dispose of its data. This will free memory, allowing you to load other bitmaps that couldn't otherwise be loaded and stored. You should, however, be careful when freeing bitmap data memory. Memory management can consume precious CPU cycles and hinder the performance of your application. You should attempt to free memory at convenient opportunities when the performance of your app isn't critical.</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec35"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Working with external SWFs, <a class="link" href="ch04.html" title="Chapter 4. Porting Flash Projects to iOS">Chapter 4</a></em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Accessing bitmaps with ActionScript</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Working with sprite sheets</em></span></li></ul></div></div></div>
<div class="section" title="Working with sprite sheets"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec09"/>Working with sprite sheets</h1></div></div></div><p>When working with multiple bitmap resources, you may want to consider using a sprite sheet. A<span class="strong"><strong> sprite sheet</strong></span> is a single bitmap that holds a collection of individual images. Typically, the sheet is separated into a grid with each image occupying identically sized slots.<a id="id557" class="indexterm"/>
</p><p>Once a sprite sheet is loaded into memory, the bitmap data for its individual images can be extracted and stored separately. This allows the data for each image to be accessed quickly by the application.</p><p>Let us see how this is done.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec36"/>Getting ready</h2></div></div></div><p>From the book's accompanying code bundle, open<code class="literal"> chapter6\recipe8\recipe.fla</code>. The majority of the FLA's AIR for iOS settings have been applied as a starting point.<a id="id558" class="indexterm"/>
</p><p>Additionally, a bitmap named<code class="literal"> sprite-sheet.png</code> has been provided within the same folder as the FLA. Take a look at the bitmap in an image editor such as Adobe Photoshop. It contains a collection of images that we will extract and store in memory.<a id="id559" class="indexterm"/>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec37"/>How to do it...</h2></div></div></div><p>Start by bundling the bitmap with your app.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">To do this, open the<span class="strong"><strong> AIR for iOS Settings</strong></span> panel and ensure that the panel's<span class="strong"><strong> General</strong></span> tab is selected. Click on the<span class="strong"><strong> +</strong></span> symbol above the<span class="strong"><strong> Included files</strong></span> list and select<code class="literal"> sprite-sheet.png</code> from the FLA's root folder. Finally, click on<span class="strong"><strong> OK</strong></span> to close the<span class="strong"><strong> AIR for iOS Settings</strong></span> panel.<p>Now, let us write some ActionScript to load the sprite sheet before cutting it into individual bitmaps.
</p></li><li class="listitem">Create a document class and name it<code class="literal"> Main</code>.</li><li class="listitem">Add the following import statements:<div class="informalexample"><pre class="programlisting">import flash.display.Bitmap;
<span class="strong"><strong>
import flash.display.BitmapData;
import flash.display.Loader;
</strong></span>
import flash.display.MovieClip;
<span class="strong"><strong>
import flash.events.Event;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.net.URLRequest;
</strong></span>
</pre></div></li><li class="listitem">The sprite sheet contains four images aligned in a 2x2 grid. Each image is 192x256 pixels in size. Store this information within your class by adding the following constants:<div class="informalexample"><pre class="programlisting">public class Main extends MovieClip {
<span class="strong"><strong>
static private const GRID_W:uint = 2;
static private const GRID_H:uint = 2;
static private const FRAME_W:uint = 192;
static private const FRAME_H:uint = 256;
</strong></span>
</pre></div></li><li class="listitem">Add a member variable of type<code class="literal"> Array</code> that will be used to store the bitmap data for each of the images once they have been extracted from the sprite sheet:<div class="informalexample"><pre class="programlisting">private var bitmaps:Array = [];
</pre></div></li><li class="listitem">Let us also add a member variable of type<code class="literal"> Bitmap</code>, which will be used to verify that the bitmaps have been extracted by displaying one of them on screen:<div class="informalexample"><pre class="programlisting">private var monkey:Bitmap = new Bitmap();
</pre></div></li><li class="listitem">Within the constructor, use the<code class="literal"> Loader</code> class to load the sprite sheet:<div class="informalexample"><pre class="programlisting">public function Main() {
<span class="strong"><strong>
var loader:Loader = new Loader();
loader.contentLoaderInfo.addEventListener(Event.COMPLETE, bitmapLoaded);
loader.load(new URLRequest("sprite-sheet.png"));
}</strong></span>
</pre></div></li><li class="listitem">Write the handler that will be called when the sprite sheet has loaded. The handler itself will call two methods<code class="literal">—sliceSpriteSheet()</code> and<code class="literal"> createMonkey()</code>. The first will extract the bitmap data from the sprite sheet, while the second will create and display a bitmap object that will use the bitmap data from one of the extracted images:<a id="id560" class="indexterm"/><div class="informalexample"><pre class="programlisting">private function bitmapLoaded(e:Event):void {
sliceSpriteSheet(e.target.content.bitmapData);
createMonkey();
}
</pre></div></li><li class="listitem">Now, add the method that actually extracts the bitmap data for each of the sprite sheet's images:<div class="informalexample"><pre class="programlisting">private function sliceSpriteSheet(sheet:BitmapData):void {
for(var y:uint = 0; y &lt; GRID_H; y++)
{
for(var x:uint = 0; x &lt; GRID_W; x++)
{
var bd:BitmapData = new BitmapData(
FRAME_W, FRAME_H, true);
var srcRect:Rectangle = new Rectangle(
(x * FRAME_W), (y * FRAME_H), FRAME_W, FRAME_H);
bd.copyPixels(sheet, srcRect, new Point(0,0));
bitmaps.push(bd);
}
}
sheet.dispose();
}
</pre></div></li><li class="listitem">Finally, add the method that creates a bitmap that uses the bitmap data from the first image cut from the sprite sheet:<div class="informalexample"><pre class="programlisting">private function createMonkey():void {
monkey = new Bitmap(bitmaps[0]);
monkey.x = 64;
monkey.y = 112;
addChild(monkey);
}
</pre></div></li><li class="listitem">Save your document class as<code class="literal"> Main.as</code>.</li><li class="listitem">Save your FLA and test it using ADL.<p>The SWF will load the sprite sheet, extract the data for all four images, then display the first of those images on screen.
</p></li><li class="listitem">Once satisfied, publish for iOS and deploy the app to a device for testing.<a id="id561" class="indexterm"/></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec38"/>How it works...</h2></div></div></div><p>The bulk of this recipe's work is performed within the<code class="literal"> sliceSpriteSheet()</code> method. Using a nested<code class="literal"> for</code> loop, it traverses the sheet's bitmap data, copying the data for each of the images into their own<code class="literal"> BitmapData</code> objects. Each of these<code class="literal"> BitmapData</code> objects is added to the<code class="literal"> bitmaps</code> array for use later.<a id="id562" class="indexterm"/>
</p><p>Once the data has been extracted, the sprite sheet's own bitmap data is released from memory. The sprite sheet itself is no longer required as the bitmap data for each of its images is now stored individually within the<code class="literal"> bitmaps</code> array and can be easily accessed from there.</p><p>Think of the<code class="literal"> bitmaps</code> array as a library, with each index position representing a different image. If you are using GPU-rendering mode, then the data for each image will be stored as a texture in video memory providing hardware acceleration when rendering.</p><p>Using any of these images is as easy as creating a<code class="literal"> Bitmap</code> object and pointing its<code class="literal"> bitmapData</code> property to one of the<code class="literal"> BitmapData</code> objects stored within the<code class="literal"> bitmaps</code> array. Alternatively, you can pass one of the<code class="literal"> BitmapData</code> references into the<code class="literal"> Bitmap</code> object's constructor. Within the<code class="literal"> createMonkey()</code> method, we simply created a<code class="literal"> Bitmap</code> object that used the first image (index position<code class="literal"> 0)</code> stored within the<code class="literal"> bitmaps</code> array. Although, we could just as easily have used the bitmap data from one of the other three images.</p><p>As with the sprite sheet, you can call<code class="literal"> dispose()</code> on any of the<code class="literal"> BitmapData</code> objects stored within the<code class="literal"> bitmaps</code> array in order to release them from memory. It is important that you do this when any of the<code class="literal"> BitmapData</code> objects are no longer required.<a id="id563" class="indexterm"/>
</p><p>Sprite sheets have many advantages. When working with multiple bitmap images that are loaded at runtime, a sprite sheet requires only a single load request. This is significantly faster than loading individual bitmaps from the file system. Also, in addition to using identically sized slots for each bitmap, it is possible to tightly pack arbitrary-sized bitmaps into a sprite sheet. Doing so can lead to savings when holding the sprite sheet in memory compared to storing each individual bitmap.</p><p>The use of sprite sheets is the de facto standard for working with bitmaps in many development environments and frameworks. For example, native iOS and Android frameworks such as Cocos2D, Sparrow, and Corona take advantage of sprite sheets. Both the Starling and ND2D ActionScript 3.0 frameworks, which are built on top of Stage 3D, also rely on sprite sheets when using their hardware-accelerated 2D graphics APIs.</p><p>Finally, don't confuse sprite sheets with Flash's<code class="literal"> Sprite</code> class. Any of Flash's display objects that support bitmaps can be used to render content from within a sprite sheet, not just the<code class="literal"> Sprite</code> class.<a id="id564" class="indexterm"/>
</p><p>You can obtain more detail regarding the classes used in this recipe from Adobe Community Help. Specifically, take a look at<code class="literal"> flash.display.Loader, flash.display.Bitmap</code>, and<code class="literal"> flash.display.BitmapData</code>. Spend some time looking at<code class="literal"> BitmapData.copyPixels()</code> which is used to copy data from the sprite sheet into each individual<code class="literal"> BitmapData</code> object.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec39"/>There's more...</h2></div></div></div><p>Following are a few more things to consider when working with sprite sheets.</p><div class="section" title="Creating sprite sheets"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec30"/>Creating sprite sheets</h3></div></div></div><p>There are many great tools for creating sprite sheets. Take a look at TexturePacker, which is freely available for both Mac OS X and Microsoft Windows at<a class="ulink" href="http://www.texturepacker.com"> www.texturepacker.com</a>.<a id="id565" class="indexterm"/>
</p></div><div class="section" title="Comparing performance and memory consumption"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec31"/>Comparing performance and memory consumption</h3></div></div></div><p>Extracting and storing the bitmap data for each individual image provides the fastest access to that data when it is eventually required by your app. However, cutting the sprite sheet into individual<code class="literal"> BitmapData</code> objects may come at the cost of memory, especially when rendering directly on the GPU.<a id="id566" class="indexterm"/>
</p><p>The GPU allocates memory using powers of 2 for each of a bitmap's dimensions. When creating a sprite sheet, you can use this knowledge to your advantage, packing and arranging images into the sheet until its dimensions are exact powers of 2. However, this may not be the case for the individual images contained within the sheet, and can lead to significant memory overheads once the bitmap data for all the images has been extracted.<a id="id567" class="indexterm"/>
</p><p>Consider carefully your artwork when creating bitmap images. If performance is of the utmost importance, then you may need to accept these memory overheads. Otherwise consider an alternative approach—perhaps keeping the sprite sheet in memory and extracting only the data that you need at a particular moment in time. This of course will be slower than extracting all the image data up-front but is a viable option, which is often used by professional developers.</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec40"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Working with external SWFs, <a class="link" href="ch04.html" title="Chapter 4. Porting Flash Projects to iOS">Chapter 4</a></em></span><a id="id568" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Accessing bitmaps with ActionScript</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Loading bitmaps at runtime</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Performing bitmap animation with ActionScript</em></span></li></ul></div></div></div>
<div class="section" title="Performing bitmap animation with ActionScript"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec11"/>Performing bitmap animation with ActionScript</h1></div></div></div><p>It might be the obvious choice for most situations, but the timeline isn't the only way to perform frame-by-frame animation. With a collection of<code class="literal"> BitmapData</code> objects stored in memory, it is perfectly possible to apply animations to<code class="literal"> Bitmap</code> objects using ActionScript.<a id="id569" class="indexterm"/>
</p><p>We will see how to do that in this recipe.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec41"/>Getting ready</h2></div></div></div><p>You can continue to work with the code you wrote during the<span class="emphasis"><em> Working with sprite sheets</em></span> recipe. Alternatively, open<code class="literal"> chapter6\recipe9\recipe.fla</code> from the book's accompanying code bundle and work from there. You will also find the FLA's document class and a sprite sheet in the same folder. The sprite sheet has already been added to the<span class="strong"><strong> Included files</strong></span> list in the FLA's<span class="strong"><strong> AIR for iOS Settings</strong></span> panel.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec42"/>How to do it...</h2></div></div></div><p>We will perform the animation by cycling through each of the bitmaps cut from the sprite sheet.<a id="id570" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Open the FLA's document class.</li><li class="listitem">Add a constant that stores the number of frames within the animation:<div class="informalexample"><pre class="programlisting">static private const MAX_FRAMES:uint = GRID_W * GRID_H;
</pre></div></li><li class="listitem">We will also need a member variable that keeps track of the current frame being shown:<div class="informalexample"><pre class="programlisting">private var frame:uint = 0;
</pre></div></li><li class="listitem">Within the<code class="literal"> bitmapLoaded()</code> method, listen for<code class="literal"> Event.ENTER_FRAME</code>. Its event handler will act as the app's main loop:<a id="id571" class="indexterm"/><div class="informalexample"><pre class="programlisting">private function bitmapLoaded(e:Event):void {
sliceSpriteSheet(e.target.content.bitmapData);
createMonkey();
<span class="strong"><strong>addEventListener(Event.ENTER_FRAME, update);</strong></span>
}
</pre></div></li><li class="listitem">Now, let us add the method for the main loop. On each call, it will point the<code class="literal"> monkey</code> bitmap to a different<code class="literal"> BitmapData</code> object, essentially causing the bitmap to animate:<div class="informalexample"><pre class="programlisting">private function update(e:Event):void {
monkey.bitmapData = bitmaps[frame];
if(++frame == MAX_FRAMES)
{
frame = 0;
}
}
</pre></div></li><li class="listitem">Save your document class and your FLA.</li><li class="listitem">Test the FLA in ADL. You should now see the<code class="literal"> monkey</code> bitmap animating by cycling through a series of images.<a id="id572" class="indexterm"/></li><li class="listitem">Publish your app and test it on a device.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec43"/>How it works...</h2></div></div></div><p>Once you have a collection of<code class="literal"> BitmapData</code> objects, it doesn't take too much effort to perform animation using them.<a id="id573" class="indexterm"/>
</p><p>The<code class="literal"> frame</code> member variable was used as an index position into the<code class="literal"> bitmaps</code> array in order to retrieve the next<code class="literal"> BitmapData</code> object for the animation. You can see this in the following code snippet, where the<code class="literal"> bitmapData</code> property is updated to point to a new<code class="literal"> BitmapData</code> object:<a id="id574" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">monkey.bitmapData = bitmaps[frame];
</pre></div><p>Some additional logic was also added to ensure that the animation looped back round to the first frame again. This was taken care of by comparing the value of<code class="literal"> frame</code> against the<code class="literal"> MAX_FRAMES</code> constant and setting<code class="literal"> frame</code> back to<code class="literal"> 0</code> when both values matched.</p><p>It may seem like a considerable amount of work for a task that can be performed relatively quickly using a timeline animation. However, even the simplest timeline animations struggle for performance on older iOS devices. This is especially true when using GPU Blend, where each frame needs to be copied from the CPU to the GPU whenever the playhead's position changes.</p><p>Programmatic animation using ActionScript, however, can be incredibly fast, with GPU Blend benefitting especially from it. Remember,<code class="literal"> BitmapData</code> objects are stored directly in video memory as textures and, therefore, don't suffer the same rendering bottlenecks experienced by timeline animations.<a id="id575" class="indexterm"/>
</p><p>If you are using Flash Professional CS5, then this may be the only real option if you want to maximize the performance of your animations. Utilizing GPU-Blend mode and performing bitmap animations using ActionScript can increase performance anywhere between five and ten times that of a timeline-based approach. For a comparison, publish<code class="literal"> recipe-bitmaps.fla</code> from the<span class="emphasis"><em> Comparing vector and bitmap graphics</em></span> recipe. The performance difference between it and this recipe's example FLA should be considerable when running on a device.<a id="id576" class="indexterm"/>
</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec44"/>There's more...</h2></div></div></div><p>Following are a few final points regarding sprite sheets and animation.</p><div class="section" title="Animation sequences"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec32"/>Animation sequences</h3></div></div></div><p>You may find that the existing animation runs too quickly and be tempted to reduce the FLA's frame rate to correct this. A better approach is to hold each bitmap for a few frames before moving to the next. This provides more control over your animations without reducing the SWF's frame rate.</p><p>We can achieve this by creating an array that holds a sequence of frame indexes for your animation. Each element within the array represents one frame of animation. Therefore, we can slow the animation by storing duplicate copies of each frame index. Take a look at the following sequence:<a id="id577" class="indexterm"/>
</p><p><code class="literal">[ 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3 ]</code>
</p><p>Each integer represents a frame index, with 0 being the first bitmap of the animation and 3 being the last. Therefore, this sequence holds the animation on each of the bitmaps for four screen redraws before moving to the next. Let us implement this in your code.</p><p>First, add a constant that holds the animation sequence:</p><div class="informalexample"><pre class="programlisting">static private const SEQUENCE:Array = [0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3];
</pre></div><p>Finally, replace the<code class="literal"> update()</code> method with this new version, which cycles through the frame indexes listed in the sequence:<a id="id578" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">private function update(e:Event):void {
monkey.bitmapData = bitmaps[SEQUENCE[frame]];
if(++frame == SEQUENCE.length)
{
frame = 0;
}
}
</pre></div><p>Save your document class and test the new version of your FLA.<a id="id579" class="indexterm"/>
</p><p>While this example uses a frame-based approach to animation, there is really nothing stopping you from writing your own ActionScript animation library that can be time-based.</p></div><div class="section" title="Loading resources at runtime"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec33"/>Loading resources at runtime</h3></div></div></div><p>Another reason for employing bitmap-based animation with ActionScript is for runtime loading of resources. If you can't fit all your resources into memory at once or simply want to reduce the initial load time of your app, then you should consider this above timeline-based animations.<a id="id580" class="indexterm"/>
</p><p>Remember, it is not currently possible to instantiate any library symbols within external SWFs that you have loaded into your AIR for iOS app. Therefore, as an alternative, you may want to load sprite sheets at runtime, extract the images from them, and then use ActionScript to perform the animations required by your app's display objects.</p></div><div class="section" title="Stage 3D"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec34"/>Stage 3D</h3></div></div></div><p>Perhaps the most compelling reason for using sprite sheets is Adobe's Stage 3D API. Stage 3D (previously codenamed Molehill) provides advanced 2D and 3D hardware acceleration on GPU hardware. Its API is intentionally low-level in order to maximize performance but you can use various ActionScript 3.0 frameworks built on top of Stage 3D that are still capable of results far exceeding Flash's traditional display list.<a id="id581" class="indexterm"/>
</p><p>Two such APIs aimed at 2D graphics are Starling and ND2D, which make heavy use of sprite sheets. Flash's traditional display list cannot be used with these frameworks. Instead, everything must be performed programmatically using ActionScript and the graphics elements provided by each.</p><p>At the time of writing, Stage 3D isn't yet available for mobile. However, Adobe is actively working to bring it to AIR for iOS. If you would like to take advantage of Stage 3D when it becomes available, then you should consider using sprite sheets in your current projects. This should make the process of porting them to Stage 3D relatively straightforward.<a id="id582" class="indexterm"/>
</p><p>You can find out more about Stage 3D from Adobe Developer Connection at<a class="ulink" href="http://www.adobe.com/devnet/flashplayer/stage3d.html"> www.adobe.com/devnet/flashplayer/stage3d.html</a>. Links to both Starling and ND2D can be found there too.</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec45"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Using an update loop, <a class="link" href="ch03.html" title="Chapter 3. Writing your First App">Chapter 3</a></em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Working with external SWFs, <a class="link" href="ch04.html" title="Chapter 4. Porting Flash Projects to iOS">Chapter 4</a></em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Working with sprite sheets</em></span></li></ul></div></div></div></body></html>