- en: Chapter 5. Interacting with Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。与服务交互
- en: In the previous chapters we focused our attention on the basic, high-level,
    Android-specific constructs to load data asynchronously on an independent line
    of execution (background thread); `android.os.AsyncTask` and `android.content.Loader`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们关注了基本的、高级的、Android特定的结构，用于在独立的执行线（后台线程）上异步加载数据；`android.os.AsyncTask`和`android.content.Loader`。
- en: What if we want to provide a common set of operations that implement any kind
    of business logic over a centralized single entity that could be re-used by different
    clients and has a lifecycle that is not bound to the client lifecycle? By clients,
    in Android, we mean any kind of UI entity, such as an `Activity` or `Fragment`
    object, a `BroadcastReceiver`, or any kind of object that wants to exercise business
    logic.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要提供一个通用的操作集，这些操作在集中化的单一实体上实现任何类型的业务逻辑，该实体可以被不同的客户端重用，并且其生命周期不绑定到客户端生命周期，那会怎样？在Android中，我们指的是任何类型的UI实体，如`Activity`或`Fragment`对象、`BroadcastReceiver`或任何想要执行业务逻辑的对象。
- en: The solution for this pattern in Android is available in the form of `android.app.Service`.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Android中这种模式的解决方案以`android.app.Service`的形式提供。
- en: In Android, the Service programming pattern, well-known in enterprise architectures,
    does not necessarily mean background work, so to avoid any kind of responsiveness
    degradation in the UI we should try keep the main Thread execution of the Service
    as lean as possible.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，Service编程模式，在企业架构中广为人知，并不一定意味着后台工作，因此为了避免任何类型的UI响应性下降，我们应该尽量保持Service的主线程执行尽可能简洁。
- en: Therefore, we have to use asynchronous techniques to coordinate the `Service`
    work between the main thread and other threads that help to accomplish the `Service`
    goal, to either keep the responsiveness at quite a decent level and provide results
    to the Service request.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须使用异步技术来协调主线程和其他线程之间的`Service`工作，这些线程有助于实现`Service`目标，以保持响应性在相当不错的水平并提供结果给Service请求。
- en: 'In this chapter we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing Service
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Service
- en: Started Service
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动服务
- en: Building responsive apps with IntentService
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用IntentService构建响应式应用
- en: Posting results with pending intents
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用待定意图发布结果
- en: Reporting progress on the notification drawer
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在通知抽屉中报告进度
- en: Applications of IntentService
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IntentService的应用
- en: Bound service
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定服务
- en: Communicating with a local service
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与本地服务通信
- en: Broadcasting results with intents
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用意图广播结果
- en: Applications of services
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务应用
- en: Introducing Service
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Service
- en: A `Service` in Android, as referred to before, is an entity that runs without
    a user interface that could be used to execute any kind of business logic which
    the application requires during the execution.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Android中的`Service`是一个没有用户界面、可以用来执行应用在执行期间所需的任何类型业务逻辑的实体。
- en: 'If the basic unit of a visible application is `Activity`, its equivalent unit
    for non-visible components is `Service`. Just like activities, services must be
    declared in the AndroidManifest file so that the system is aware of them and can
    manage them for us:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可见应用的基本单元是`Activity`，那么非可见组件的等效单元是`Service`。就像活动一样，服务必须在AndroidManifest文件中声明，以便系统了解它们并为我们管理它们：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Service has lifecycle callback methods, similar to those of Activity, that
    are always invoked on the application''s main thread. Here are the most important
    callbacks that the user must define when it creates a service by extending the
    Service base class:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Service具有与Activity类似的生命周期回调方法，这些方法始终在应用程序的主线程上调用。以下是用户在通过扩展Service基类创建服务时必须定义的最重要回调：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `onCreate()` is the lifecycle callback that is called once when the service
    is created that might be used to allocate Service resources.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`onCreate()`是在服务创建时调用的生命周期回调，可能用于分配Service资源。'
- en: The `onDestroy()` is the lifecycle callback called when the service is going
    to be destroyed and might be used to free Service resources.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`onDestroy()`是在服务即将被销毁时调用的生命周期回调，可能用于释放Service资源。'
- en: The `onStartCommand()` is the lifecycle callback invoked when a started Service
    is explicitly started with the `startService()` command.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`onStartCommand()`是在使用`startService()`命令显式启动已启动的服务时调用的生命周期回调。'
- en: '`onBind()` is the lifecycle callback called when the service is bound to a
    Service client – `bindService()`.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`onBind()`是在服务绑定到Service客户端时调用的生命周期回调，即`bindService()`。'
- en: 'The `onUnbind()` is the callback called when the service is unbound from a
    client - `unbindService()`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务从客户端取消绑定时，会调用`onUnbind()`回调 - `unbindService()`：
- en: '![Introducing Service](img/Image_B05062_05_03.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![介绍服务](img/Image_B05062_05_03.jpg)'
- en: Also, just like `Activity`, `Service` does not automatically entail a separate
    background thread or process, and as a result, performing intensive or blocking
    operations in a `Service` callback method can lead to the annoying ANR dialog.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，就像`Activity`一样，`Service`不会自动涉及单独的后台线程或进程，因此，在`Service`回调方法中执行密集型或阻塞操作可能会导致令人烦恼的ANR对话框。
- en: 'However, there are several ways in which services are different to activities,
    those ways are listed as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，服务与活动不同，以下列出了这些不同之处：
- en: A Service does not provide a user interface.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务不提供用户界面。
- en: There can be many services active at the same time within an application.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个应用程序中可以同时存在多个活动服务。
- en: A Service can remain active even if the application hosting it is not the current
    foreground application, which means that there can be many services of many apps
    are active at the same time.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使托管它的应用程序不是当前的前台应用程序，服务也可以保持活动状态，这意味着可以有多个应用程序的服务同时处于活动状态。
- en: Because the system is aware of services running within a process, it can avoid
    killing those processes unless absolutely necessary, allowing the background work
    to continue. Services have a higher priority than inactive or invisible activities.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为系统知道进程内运行的服务，它可以避免在绝对必要时杀死这些进程，从而允许后台工作继续。服务比非活动或不可见活动具有更高的优先级。
- en: 'Services in Android can be classified based on how the clients interact with
    it, taking the next forms:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 根据客户端如何与之交互，Android中的服务可以根据以下形式进行分类：
- en: '**Started Service**: This is a kind of service that is explicitly started when
    any object on the system invokes `startService()` and it will continue to run
    until it stops itself by calling `stopSelf()` or it is explicitly destroyed with
    `stopService()`.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已启动服务**：这是一种在系统上的任何对象调用`startService()`时明确启动的服务，它将一直运行，直到通过调用`stopSelf()`或通过`stopService()`显式销毁它而停止。'
- en: '**Bound Service**: This is a kind of service that is started when the first
    client binds to it and runs until it has clients are connected. Service clients
    attach to a Service by calling `bindService()`, and the service will be destroyed
    when all the clients unbind, calling `unbindService()`.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绑定服务**：这是一种在第一个客户端绑定到它时启动的服务，并且它将一直运行，直到所有客户端连接。服务客户端通过调用`bindService()`附加到服务，当所有客户端取消绑定并调用`unbindService()`时，服务将被销毁。'
- en: '**Hybrid Service**: This Service is started when an object on the system calls
    `startService()` and might have clients connected to it during its lifecycle,
    by calling `bindService()`. Like the started Service, it runs indefinitely until
    the service is stopped, stops itself, or is killed by the system.![Introducing
    Service](img/Image_B05062_05_01.jpg)'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合服务**：当系统上的对象调用`startService()`时启动此服务，在其生命周期内可能连接到它的一些客户端，通过调用`bindService()`。就像已启动的服务一样，它无限期地运行，直到服务停止，自行停止或被系统杀死。![介绍服务](img/Image_B05062_05_01.jpg)'
- en: 'The Service can be also classified by its boundaries, taking the following
    forms:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 服务也可以根据其边界进行分类，以下列出了这些形式：
- en: '**Local Service** (**LS**): The Service runs on the same process as the other
    Android components and therefore the shared memory could be used to send Java
    Objects between client and Server.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地服务**（**LS**）：服务与其他Android组件在同一个进程中运行，因此可以使用共享内存来在客户端和服务器之间发送Java对象。'
- en: '**Internal Remote Service** (**IRS**): The Service runs on a separate process
    but it can only be used by the components that belong to the application that
    defines it. To access it, an IPC technique (Messenger or AIDL) is required to
    interact with the remote process.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部远程服务**（**IRS**）：服务在单独的进程中运行，但它只能由定义它的应用程序的组件使用。要访问它，需要使用IPC技术（信使或AIDL）与远程进程交互。'
- en: '**Global Service** (**GS**): The Service runs on a separate process and could
    be accessed by other applications. For instance, with IRS, an IPC communication
    technique must be used by the client to access it.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局服务**（**GS**）：服务在单独的进程中运行，并且可以被其他应用程序访问。例如，使用IRS，客户端必须使用IPC通信技术来访问它。'
- en: Started service
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 已启动服务
- en: 'As described previously, a started Service is a service that is initiated when
    the `Context` method `startService()` is invoked by any entity on the system that
    has access to a Context object or is a Context itself, such as an Activity:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，启动的服务是在任何实体调用 `Context` 方法的 `startService()` 时启动的，这些实体可以访问上下文对象或本身就是上下文，例如
    Activity：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An Intent is a messaging object that can carry data (action, category, extras,
    and so on) and that you can use to request an action from another Android component.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 意图（Intent）是一个可以携带数据（动作、类别、额外信息等）的消息对象，你可以用它来请求另一个Android组件执行动作。
- en: The `startService()` function basically starts a service with an intent, and
    returns to the user a component name that can be used to verify that the correct
    service was resolved and invoked.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`startService()` 函数基本上是使用意图启动一个服务，并返回给用户一个组件名称，该名称可用于验证是否正确解析并调用了服务。'
- en: 'To simplify the Service resolution, we pass an Intent created from the current
    context with the Service class that needs to be started:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化服务解析，我们传递一个由当前上下文和需要启动的服务类创建的意图：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When the system receives the first `startService(intent`) request, it builds
    up the Service by calling `onCreate()` and forwards the intent from the first
    `startService` and the subsequent Intents to the `onStartCommand` function to
    be processed according to the order of `startService` calls:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统接收到第一个 `startService(intent)` 请求时，它会通过调用 `onCreate()` 来构建服务，并将第一个 `startService`
    和随后的意图转发到 `onStartCommand` 函数进行处理，按照 `startService` 调用的顺序：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `onStartCommand` should return an `int` that defines the Service restart
    behavior applied by the system in cases where the system kills it to release resources.
    Like explained before, the system maintains a list of Android running entities
    on the system ordered by rank, and once the available system resources are low
    it destroys the entities with lower rank first to free up resources.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`onStartCommand` 应返回一个 `int` 值，该值定义了系统在杀死服务以释放资源时应用的 Service 重新启动行为。如前所述，系统维护一个按等级排序的
    Android 运行实体列表，一旦可用系统资源低，它将首先销毁等级较低的实体以释放资源。'
- en: 'The most common restart `int` values are defined by the following Service static
    fields:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的重新启动 `int` 值由以下服务静态字段定义：
- en: '`START_STICKY`: If the Service process is terminated by the system, the Service
    is going to be restarted and no processed Intents will be delivered to the `onStartCommand`
    function. When no start Intents are pending for delivery, a null Intent is passed
    to the `onStartCommand` function. If a start request didn''t return before the
    system kills the Service, the start request is submitted again on the restarted
    Service passing `START_FLAG_RETRY` on the `onStartCommand` second argument.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`START_STICKY`：如果服务进程被系统终止，服务将被重新启动，并且不会将已处理的意图发送到 `onStartCommand` 函数。当没有待处理的启动意图要发送时，将一个空意图传递给
    `onStartCommand` 函数。如果启动请求在系统杀死服务之前没有返回，则将启动请求再次提交到重新启动的服务，并在 `onStartCommand`
    的第二个参数上传递 `START_FLAG_RETRY`。'
- en: '`START_NOT_STICKY`: If the Service is terminated by the system, the Service
    is only restarted when there is at least one pending start request to be delivered.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`START_NOT_STICKY`：如果服务被系统终止，服务只有在至少有一个待处理的启动请求要发送时才会重新启动。'
- en: '`START_REDELIVER_INTENT`: If the `Service` is terminated by the system, the
    `Service` will be restarted redelivering the last delivered start Intent and any
    pending requests. This kind of service is similar to `START_STICKY`, but instead
    of delivering a null Intent in the start command, the last successfully delivered
    Intent is dispatched. When the start request is redelivered, the flag `START_FLAG_REDELIVERY`
    is passed in on the `onStartCommand` second argument.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`START_REDELIVER_INTENT`：如果服务被系统终止，服务将被重新启动，并重新发送最后发送的启动意图和任何挂起的请求。这种服务类似于
    `START_STICKY`，但不是在启动命令中发送一个空意图，而是发送最后成功发送的意图。当启动请求被重新发送时，`onStartCommand` 的第二个参数会传递
    `START_FLAG_REDELIVERY` 标志。'
- en: The `onStartCommand`, which executes on the main `Thread`, is the entry point
    for your service, so in cases where you execute long running operations on your
    `Service`, the offload of your operation into a background thread is imperative
    for keeping your application responsiveness at bearable levels.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在主 `Thread` 上执行的 `onStartCommand` 是服务的入口点，因此在你需要在 `Service` 上执行长时间运行的操作时，将操作卸载到后台线程是强制性的，以保持应用程序的响应性在可忍受的水平。
- en: 'In the next code snippet, we are going to create a basic `Service` that offloads
    the `Intent` processing to a background thread. The `SaveMyLocationService` Service
    subclass is going to receive an address location in a String and consume it in
    an operation that could occupy the CPU for a long period. First, we are going
    to create the background thread, that will retrieve the locations from a queue
    and consume them until it receives a signal to stop:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个代码片段中，我们将创建一个基本的`Service`，将`Intent`处理卸载到后台线程。`SaveMyLocationService`服务子类将接收一个字符串形式的地址位置，并在可能占用CPU长时间的操作中消耗它。首先，我们将创建一个后台线程，该线程将从队列中检索位置并消耗它们，直到它收到停止信号：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the previous code, we basically constructed the foundations for our asynchronous
    processing. The single thread that is started when the Service's `onCreate()`
    callback is invoked on the main `Thread`, is going to monitor the jobs queue for
    new location requests. The Thread will wait in the background efficiently, using
    a Java monitor, until it gets notified with `notify()` when a new location is
    submitted.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们基本上构建了异步处理的基础。当在主`Thread`上调用服务的`onCreate()`回调时启动的单个线程，将监控作业队列以查找新的位置请求。线程将高效地在后台等待，使用Java监视器，直到它通过`notify()`被通知有新的位置提交。
- en: When our background thread finds new locations in the queue, the `takeLocation()`
    that is waiting on the Java monitor returns and forwards the new request to the
    `consumeLocation()` to execute the business logic requested. The jobs are going
    to be processed sequentially following the order of insertion.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的后台线程在队列中找到新的位置时，等待在Java监视器上的`takeLocation()`返回，并将新的请求转发到`consumeLocation()`以执行请求的业务逻辑。作业将按插入顺序顺序处理。
- en: Once the `shouldStop` is set to true, the `run()` function will return and the
    thread will be terminated.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将`shouldStop`设置为true，`run()`函数将返回，线程将被终止。
- en: 'We''ll need to register the Service in our AndroidManifest file, using a `<service>`
    element as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在AndroidManifest文件中注册服务，使用以下`<service>`元素：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the next step we are going to implement the `onStartCommand`, the function
    that will receive the request from the system in the first place and forward it
    to our thread to be processed in background:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们将实现`onStartCommand`，该函数将首先接收来自系统的请求并将其转发到我们的线程以在后台进行处理：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: On the `onStartCommand`, we received the intent object from the system and the
    location passed as a String on the Intent extras. Next, we push it to our queue
    of jobs used to store the jobs in sequence. Later, we return the `START_STICKY`
    flag, which means that we want the Service restarted after the system shuts down
    our application and the pending intents delivered in case the system shuts down
    the system to free up resources.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onStartCommand`中，我们从系统接收了intent对象和Intent附加信息中传递的字符串形式的地址。接下来，我们将其推送到我们的作业队列中，该队列用于按顺序存储作业。稍后，我们返回`START_STICKY`标志，这意味着我们希望在系统关闭我们的应用程序和传递挂起的intent后，系统关闭系统以释放资源时重新启动服务。
- en: 'Finally, we have to implement the callback function to stop our background
    processing infrastructure. This function is going to be called when the system
    forces the service to terminate or any component sends a `stop` command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须实现回调函数以停止我们的后台处理基础设施。当系统强制服务终止或任何组件发送`stop`命令时，将调用此函数：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the `onDestroy()` function, we mainly ask our thread to terminate, setting
    the `shouldStop` as true and by notifying the thread to finish the `run()` function.
    In case you allocated objects in your `onCreate()` function, this callback should
    be used to liberate any resources that you created during the Service lifecycle.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onDestroy()`函数中，我们主要要求我们的线程终止，将`shouldStop`设置为true，并通过通知线程完成`run()`函数。如果你在`onCreate()`函数中分配了对象，则应使用此回调来释放在服务生命周期中创建的任何资源。
- en: 'Now we are going to create a simple Activity that is able to start the service
    and stop the service:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个简单的Activity，该Activity能够启动服务并停止服务：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In our Activity, we created a start button that calls `onStartServiceClick()`,
    and a stop button that calls `onStopServiceClick()`, but for brevity we omitted
    the code.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Activity中，我们创建了一个启动按钮，该按钮调用`onStartServiceClick()`，以及一个停止按钮，该按钮调用`onStopServiceClick()`，但为了简洁，我们省略了代码。
- en: Once the **start** button is clicked, our Activity will submit a new save location
    request, with the current location retrieved from the `getCurrentLocation()` function,
    to our service calling `startService()`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦点击**开始**按钮，我们的Activity将通过调用`startService()`将一个新的保存位置请求提交给我们的服务，其中当前位置是通过`getCurrentLocation()`函数检索的。
- en: Clicking on the **stop** button will result in a `stopService()`, which sends
    a stop request to our Service that leads to a `onDestroy()` invocation on our
    Service.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**停止**按钮将导致`stopService()`，这会向我们的服务发送停止请求，导致我们的服务调用`onDestroy()`。
- en: It is essential to mention that if the service is stopped and started repeatedly,
    a new thread is created to replace the older one. As mentioned before, the thread
    creation is an expensive operation, so in order to reduce the burden of the thread
    creation, the developer should keep the Service running as long it may be needed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 必须提到的是，如果服务被停止和重复启动，将会创建一个新的线程来替换旧的线程。如前所述，线程创建是一个昂贵的操作，因此为了减少线程创建的负担，开发者应该让服务尽可能长时间地运行。
- en: Our custom service is able to handle the `onStartCommand()` asynchronously very
    well but in the next section, we will focus our attention on the `IntentService`
    class, a special-purpose subclass of `Service` that comes in the Android SDK that
    makes it very easy to implement a task queue to process work on a single background
    thread.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自定义服务能够很好地异步处理`onStartCommand()`，但在下一节中，我们将关注`IntentService`类，这是Android SDK中的一个特殊用途的`Service`子类，它使得实现任务队列以在单个后台线程上处理工作变得非常容易。
- en: Building responsive apps with IntentService
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用IntentService构建响应式应用
- en: 'The `IntentService` class is a specialized subclass of `Service` that implements
    a background work queue using a single `HandlerThread`. When work is submitted
    to an `IntentService`, it is queued for processing by a single `HandlerThread`,
    and processed in order of submission on the `onHandleIntent` function:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`IntentService`类是一个特殊的`Service`子类，它使用单个`HandlerThread`实现后台工作队列。当工作被提交给`IntentService`时，它将在单个`HandlerThread`上排队等待处理，并在`onHandleIntent`函数中按提交顺序处理。'
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If the user exits the app before the queued work is completely processed, the
    `IntentService` will continue working in the background. When the `IntentService`
    has no more work in its queue, it will stop itself to avoid consuming unnecessary
    resources.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在队列中的工作完全处理之前退出应用程序，`IntentService`将继续在后台工作。当`IntentService`的队列中没有更多工作可处理时，它将自行停止以避免消耗不必要的资源。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The system may still kill a background app with an active `IntentService`, if
    it really needs to (to reclaim enough memory to run the current foreground process),
    but it will kill lower priority processes first, for example, other non-foreground
    apps that do not have active services.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统确实需要（为了回收足够的内存来运行当前的前台进程），它仍然可以杀死具有活动`IntentService`的后台应用程序，但它将首先杀死优先级较低的进程，例如，没有活动服务的其他非前台应用程序。
- en: 'The `IntentService` class gets its name from the way in which we submit work
    to it by invoking `startService` with an Intent:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`IntentService`类的名称来源于我们通过调用带有Intent的`startService`来提交工作给它的方式：'
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we do with our previous example, we can call `startService` as often as we
    like, which will start the `IntentService` if it isn't already running, or simply
    enqueue work to an already running instance if there is one.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在先前的示例中所做的那样，我们可以像我们喜欢的那样多次调用`startService`，这将启动`IntentService`（如果它尚未运行），或者如果已经有一个正在运行的实例，则简单地将其工作入队。
- en: 'If we want to pass some data to a `Service`, we can do so by supplying a data
    URI or extra data fields via an Intent:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要向`Service`传递一些数据，我们可以通过提供数据URI或通过Intent提供额外的数据字段来实现：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can create an `IntentService` subclass by extending `android.app.IntentService`
    and implementing the abstract `onHandleIntent` method.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过扩展`android.app.IntentService`并实现抽象的`onHandleIntent`方法来创建`IntentService`的子类。
- en: We must invoke the single-argument constructor with a name for its background
    thread (naming the thread makes debugging and profiling much easier).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用一个名称来调用单参数构造函数，为它的后台线程命名（命名线程使得调试和性能分析变得容易得多）。
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We''ll need to register the `IntentService` in our AndroidManifest file, using
    a `<service>` element as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在AndroidManifest文件中注册`IntentService`，使用以下方式使用`<service>`元素：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we want our `IntentService` to only be used by the components of our own
    application, we can specify that it is not public with an extra attribute:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望我们的`IntentService`只被我们自己的应用程序的组件使用，我们可以通过一个额外的属性来指定它不是公开的：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s get started by implementing an `IntentService` to retrieve the number
    of SMSs in the inbox from a particular mobile number:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实现一个用于从特定手机号码检索收件箱中短信数量的 `IntentService` 开始：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Once the request is received on the `IntentService`, the request is pushed to
    the internal `Looper` queue and as soon as it get chance to process it, the `IntenService`
    invokes the `onHandleIntent` method with the Intent we passed in on the `startService()`
    method.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在 `IntentService` 上收到请求，该请求就会被推送到内部 `Looper` 队列，一旦有机会处理它，`IntenService` 就会调用
    `onHandleIntent` 方法，该方法带有我们在 `startService()` 方法中传递的 Intent。
- en: Next, we query the SMS Inbox Content Provider using the `phoneNumber` received,
    and after that we count the records retrieved.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用接收到的 `phoneNumber` 查询短信收件箱内容提供者，然后统计检索到的记录数。
- en: Notice that we're declaring a public static constant name for the argument parameter,
    just to make it easy to use the correct name from any client `Activity` that wants
    to invoke the Service.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在声明一个公共静态常量名称作为参数，只是为了使任何想要调用服务的客户端 `Activity` 能够轻松地使用正确的名称。
- en: 'We can now invoke this `IntentService` as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以按以下方式调用此 `IntentService`：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The code above receives the `phoneNumber` as an argument and submits a new start
    request to `IntentService` to be processed sequentially following the submission
    order.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码接收 `phoneNumber` 作为参数，并向 `IntentService` 提交一个新的启动请求，以便按提交顺序顺序处理。
- en: So far so good, but you've probably noticed that we haven't done anything with
    the result we retrieved. In the next section, we'll look at some of the ways in
    which we can send results from services to activities or fragments.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利，但你可能已经注意到我们没有对检索到的结果做任何事情。在下一节中，我们将探讨一些从服务向活动或片段发送结果的方法。
- en: Handling results
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理结果
- en: Any `Service`—including subclasses of `IntentService`—can be used to start background
    work from which the originating `Fragment` or `Activity` doesn't expect a response.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 `Service`（包括 `IntentService` 的子类）都可以用来启动后台工作，而原始的 `Fragment` 或 `Activity`
    不期望得到响应。
- en: 'However, it is very common to need to return a result or display the result
    of the background work to the user. We have several options for doing this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常需要返回结果或将后台工作的结果显示给用户。我们为此有几种选择：
- en: Send a `PendingIntent` to the `Service` from the originating `Activity`, allowing
    the `Service` to callback to the `Activity` via its `onActivityResult` method
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从原始 `Activity` 向 `Service` 发送 `PendingIntent`，允许 `Service` 通过其 `onActivityResult`
    方法回调到 `Activity`。
- en: Post a system notification allowing the user to be informed that the background
    work was completed, even if the application is no longer in the foreground
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布系统通知，让用户知道后台工作已完成，即使应用程序不再处于前台。
- en: Send a message to a `Handler` in the originating `Activity` using `Messenger`
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Messenger` 向原始 `Activity` 中的 `Handler` 发送消息。
- en: Broadcast the result as an `Intent`, allowing any `Fragment` or `Activity`—including
    the originator—to receive the result of background processing
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 `Intent` 的形式广播结果，允许任何 `Fragment` 或 `Activity`（包括原始调用者）接收后台处理的结果。
- en: We'll learn about `BroadcastReceiver`, long-running tasks with `Service`, later,
    but now we'll return results with `PendingIntent` and alert the user with system
    notifications.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后学习 `BroadcastReceiver` 和使用 `Service` 的长时间运行任务，但现在我们将使用 `PendingIntent`
    返回结果，并通过系统通知提醒用户。
- en: Posting results with PendingIntent
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `PendingIntent` 发布结果。
- en: When we invoke an `IntentService`, it does not automatically have any way to
    respond to the calling Activity; so if the `Activity` wants to receive a result,
    it must provide some means for the `IntentService` to reply.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `IntentService` 时，它并没有自动有任何方式来响应调用 `Activity`；因此，如果 `Activity` 想要接收结果，它必须为
    `IntentService` 提供一些回复的方式。
- en: Arguably the easiest way to do that is with `PendingIntent`, which will be familiar
    to any Android developer who has worked with multiple activities using the `startActivityForResult`
    and `onActivityResult` methods, as the pattern is essentially the same.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，最简单的方法是使用 `PendingIntent`，这对于任何使用过 `startActivityForResult` 和 `onActivityResult`
    方法的 Android 开发者来说都很熟悉，因为模式本质上是一样的。
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: A PendingIntent is a token that you give to a foreign application component
    (Service, BroacastReceiver, or other applications) that allows the foreign entity
    to use your application's permissions to execute a predefined piece of code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`PendingIntent` 是你提供给外部应用程序组件（服务、广播接收器或其他应用程序）的令牌，它允许外部实体使用你的应用程序的权限来执行预定义的代码。'
- en: 'First, we''ll add a few static members to `CountMsgsIntentService` to ensure
    that we use consistent values between it and the calling `Activity`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在`CountMsgsIntentService`中添加一些静态成员，以确保我们在它和调用`Activity`之间使用一致的价值：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We''ll also need to define a static member in our Activity for the `REQUEST_CODE`
    constant, which we can use to correctly identify the results returned to our `onActivityResult`
    method:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在我们的`Activity`中定义一个用于`REQUEST_CODE`常量的静态成员，我们可以使用它来正确地识别返回给我们的`onActivityResult`方法的结果：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, when we want to invoke `CountMsgsIntentService` from our `Activity`, we'll
    create a `PendingIntent` for the current `Activity`, which will act as a callback
    to invoke the Activity `onActivityResult` method.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们想要从我们的`Activity`调用`CountMsgsIntentService`时，我们将为当前的`Activity`创建一个`PendingIntent`，它将作为回调来调用Activity的`onActivityResult`方法。
- en: 'We can create a `PendingIntent` with the `createPendingResult` method of the
    Activity, which accepts three parameters: an `int` result code, an Intent to use
    as the default result, and an `int` that encodes some flags for how the `PendingIntent`
    can be used (for example, whether it may be used more than once):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Activity`的`createPendingResult`方法创建一个`PendingIntent`，它接受三个参数：一个`int`结果代码，一个用作默认结果的Intent，以及一个`int`，它编码了一些用于如何使用`PendingIntent`的标志（例如，是否可以多次使用）：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We pass the `PendingIntent` to the `IntentService` by adding it as an extra
    to the Intent we launch the `IntentService` with:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将`PendingIntent`添加为我们启动`IntentService`的Intent的额外内容来将其传递给`IntentService`：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To handle the result that will be returned when this `PendingIntent` is invoked,
    we need to implement `onActivityResult` in the `Activity`, and check for the result
    code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理在调用此`PendingIntent`时返回的结果，我们需要在`Activity`中实现`onActivityResult`，并检查结果代码：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `IntentService` can now reply to the calling `Activity` by invoking one
    of the `PendingIntent` send methods with the appropriate request code. Our updated
    `onHandleIntent` method looks as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`IntentService`现在可以通过调用适当的请求代码的`PendingIntent`发送方法之一来回复调用`Activity`。我们的更新后的`onHandleIntent`方法如下所示：'
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The additional code creates a new Intent object and populates it with our counter
    result retrieved from the cursor, and sends the result back to the calling Activity
    using the received `PendingIntent`. Additionally, we handle the `CanceledException`,
    in case the calling `Activity` decided that it wasn't interested in the result
    anymore and canceled the `PendingIntent`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 附加的代码创建了一个新的Intent对象，并用从游标中检索到的计数结果填充它，然后使用接收到的`PendingIntent`将结果发送回调用`Activity`。此外，我们还处理了`CanceledException`，以防调用`Activity`决定不再对结果感兴趣并取消了`PendingIntent`。
- en: That's all there is to it—our `Activity` will now be invoked via its `onActivityResult`
    method when the `IntentService` completes its work. As a bonus, we will even receive
    the result if the `Activity` has restarted, for example, due to configuration
    changes such as a device rotation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部内容——当`IntentService`完成其工作后，我们的`Activity`将通过其`onActivityResult`方法被调用。作为额外的好处，即使`Activity`已经重新启动，例如由于设备旋转等配置更改，我们也会收到结果。
- en: What if the user left the `Activity` (or even left the application) while the
    background work was in progress? In the next section, we'll use notifications
    to provide feedback without interrupting the user's new context.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在后台工作正在进行时离开了`Activity`（甚至离开了应用程序），会怎样呢？在下一节中，我们将使用通知来提供反馈，而不会打断用户的当前上下文。
- en: Posting results as system notifications
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布结果作为系统通知
- en: System notifications appear initially as an icon in the notification area, normally
    at the very top of the device screen. Once notified, the user can open the notification
    drawer to see more details.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 系统通知最初在通知区域以图标的形式出现，通常在设备屏幕的顶部。一旦通知，用户就可以打开通知抽屉来查看更多详细信息。
- en: Notifications are an ideal way to inform the user of results or status updates
    from services, particularly when the operation may take a long time to complete
    and the user is likely to be doing something else in the meantime.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通知是通知用户服务结果或状态更新的理想方式，尤其是当操作可能需要很长时间才能完成，并且用户在此期间可能在做其他事情时。
- en: 'Let''s post the result of our message counter as a notification, with a message
    containing the result that the user can read when they open the notification drawer.
    We''ll use the support library to ensure broad API level compatibility, and add
    one method to `CountMsgsIntentService`, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将消息计数器的结果作为通知发布，消息中包含用户打开通知抽屉时可以阅读的结果。我们将使用支持库来确保广泛的API级别兼容性，并在`CountMsgsIntentService`中添加一个方法，如下所示：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Each notification has an identifier that we can use to control whether a new
    notification is posted or an existing one is reused. The identifier is an `int`,
    and is the first parameter to the notify method. Since our `countMsgsFrom` value
    is an `int`, and we would like to be able to post multiple notifications, it makes
    sense to use `phoneNumber` as the ID for our notifications so that each different
    request can produce its own separate notification.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 每个通知都有一个标识符，我们可以用它来控制是否发布新的通知或重用现有通知。标识符是一个 `int`，是 `notify` 方法的第一个参数。由于我们的
    `countMsgsFrom` 值是一个 `int`，并且我们希望能够发布多个通知，因此使用 `phoneNumber` 作为我们通知的 ID 是有意义的，这样每个不同的请求都可以产生其自己的单独通知。
- en: 'To post a notification containing the result of our service request, we just
    need to update `onHandleIntent` to invoke the `notifyUser` method:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要发布包含我们的服务请求结果的提示，我们只需更新 `onHandleIntent` 以调用 `notifyUser` 方法：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now that we've learned the basics of using `IntentService`, let's consider some
    real- world applications.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了使用 `IntentService` 的基础知识，让我们考虑一些实际应用。
- en: Applications of IntentService
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IntentService 的应用
- en: Ideal applications for `IntentService` include just about any long-running task
    where the work is not especially tied to the behavior of a `Fragment` or `Activity`,
    and particularly when the task must complete its processing regardless of whether
    the user exits the application.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`IntentService` 的理想应用包括几乎所有长时间运行的任务，其中工作并不特别依赖于 `Fragment` 或 `Activity` 的行为，尤其是当任务必须完成其处理，无论用户是否退出应用程序时。'
- en: However, `IntentService` is only suitable for situations where a single worker
    thread is sufficient to handle the workload, since its work is processed by a
    single `HandlerThread` sequentially following the order of submission, and we
    cannot start more than one instance of the same `IntentService` subclass.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`IntentService` 只适合于只需要一个工作线程来处理工作负载的情况，因为其工作是由一个 `HandlerThread` 按提交顺序顺序处理的，并且我们不能启动同一
    `IntentService` 子类的多个实例。
- en: 'A use case that `Intent Service` is ideally suited for is one-shot, long–running
    tasks that could be processed in the background without user intervention:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常适合使用 `IntentService` 的用例是单次执行、长时间运行的任务，这些任务可以在后台处理而无需用户干预：
- en: Uploading data to remote servers
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据上传到远程服务器
- en: Database or data backups
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库或数据备份
- en: Time consuming file data processing
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 耗时的文件数据处理
- en: Communication with web service resources (WSDL or REST)
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Web 服务资源（WSDL 或 REST）的通信
- en: Periodic time operations such as alarm processing, calendar event processing,
    and so on
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期的时间操作，如闹钟处理、日历事件处理等
- en: 'A use case that `IntentService` is ideally suited for is uploading data to
    remote servers because:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`IntentService` 适合用于上传数据到远程服务器的用例，因为：'
- en: The upload usually must complete, even if the user leaves the application
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传通常必须完成，即使用户离开了应用程序
- en: A single upload at a time usually makes best use of the available connection,
    since bandwidth is often asymmetric (there is much smaller bandwidth for upload
    than download)
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次只上传一个文件通常能更好地利用可用连接，因为带宽往往是不对称的（上传的带宽比下载小得多）
- en: A single upload at a time gives us a better chance of completing each individual
    upload before losing our data connection
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次只上传一个文件，给我们更好的机会在丢失数据连接之前完成每个单独的上传
- en: Let's see how we might implement a very simple `IntentService` that uploads
    images to a simple web service via HTTP POST.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何实现一个非常简单的 `IntentService`，通过 HTTP POST 将图片上传到简单的 Web 服务。
- en: HTTP uploads with IntentService
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 IntentService 进行 HTTP 上传
- en: For this example, we'll create a new `Activity`, `UploadArtworkActivity`, to
    allow the user to pick an album artwork to upload. We'll start with the code for
    `AlbumListActivity` that we created in [Chapter 4](ch04.html "Chapter 4. Exploring
    the Loader"), *Exploring the Loader*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将创建一个新的 `Activity`，`UploadArtworkActivity`，允许用户选择要上传的专辑封面。我们将从 [第 4
    章](ch04.html "第 4 章。探索 Loader") 中创建的 `AlbumListActivity` 代码开始，*探索 Loader*。
- en: 'Our new `UploadArtworkActivity` only needs a small modification to add an `OnItemClickListener`
    interface to the `GridView` of images, so that tapping an image triggers its upload.
    We can add the listener as an anonymous inner class in `onCreate` as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新 `UploadArtworkActivity` 只需要稍作修改，为图像的 `GridView` 添加一个 `OnItemClickListener`
    接口，以便点击图像触发其上传。我们可以在 `onCreate` 中添加监听器，如下所示：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This looks like quite a dense chunk of code, but all it really does is use the
    position of the tapped thumbnail to move the `Cursor` to the correct row in its
    result set, extract the ID of the album that was tapped, create a `Uri` for its
    artwork file, and then start `UploadArtworkIntentService` with an Intent containing
    that Uri.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是一段相当密集的代码，但它实际上只是使用被点击的缩略图的当前位置将`Cursor`移动到其结果集的正确行，提取被点击的相册的ID，为其艺术作品文件创建一个`Uri`，然后使用包含该Uri的Intent启动`UploadArtworkIntentService`。
- en: 'We''ll extract the details of the upload into a separate class, so `UploadArtworkIntentService`
    itself is just a fairly sparse `IntentService` implementation. In `onCreate`,
    we''ll set up an instance of our `ImageUploader` class, which will be used to
    process all uploads added to the queue during this lifetime of the Service:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将上传的详细信息提取到一个单独的类中，因此`UploadArtworkIntentService`本身只是一个相当稀疏的`IntentService`实现。在`onCreate`中，我们将设置我们的`ImageUploader`类的一个实例，该实例将用于处理在此服务生命周期内添加到队列的所有上传：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The implementation of `ImageUploader` itself is not all that interesting—we
    just use Java''s `HTTPURLConnection` class to post the image data to the server.
    The complete source code is available on the Packt Publishing website, so we''ll
    just list two critical methods—upload and pump—and leave out the housekeeping:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageUploader`的实现本身并不那么有趣——我们只是使用Java的`HTTPURLConnection`类将图像数据发送到服务器。完整的源代码可在Packt
    Publishing网站上找到，所以我们只列出两个关键方法——上传和泵送——并省略其他维护工作：'
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `pump` method just copies 1 KB chunks of data from the `InputStream` to
    the `OutputStream`, pumping the data to the server, and invokes the progress callback
    function, as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`pump`方法只是将1 KB的数据块从`InputStream`复制到`OutputStream`，将数据泵送到服务器，并调用进度回调函数，如下所示：'
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Each time a 1 KB chunk of data is pushed to the `OutputStream`, we invoke the
    `ProgressCallback` method, which we'll use in the next section to report the progress
    to the user.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 每当1 KB的数据块被推送到`OutputStream`时，我们就会调用`ProgressCallback`方法，我们将在下一节中使用该方法向用户报告进度。
- en: Reporting progress
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 报告进度
- en: For long-running processes, it can be very useful to report progress so that
    the user can take comfort in knowing that something is actually happening.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于长时间运行的过程，报告进度非常有用，这样用户就可以安心地知道实际上有事情在进行。
- en: To report progress from an `IntentService`, we can use the same mechanisms that
    we use to send results—for example, sending `PendingIntents` containing progress
    information, or posting system notifications with progress updates.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要从`IntentService`报告进度，我们可以使用发送结果时使用的相同机制——例如，发送包含进度信息的`PendingIntents`，或者发布带有进度更新的系统通知。
- en: We can also use other techniques that we'll cover later in the chapter, broadcasting
    intents to registered receivers.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用本章后面将要介绍的其他技术，向已注册的接收器广播意图。
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Whichever approach we take to report progress, we should be careful not to report
    progress too frequently, otherwise we'll waste resources updating the progress
    bar at the expense of completing the work itself!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们采取何种方法来报告进度，我们都应该小心不要过于频繁地报告进度，否则我们会在完成工作本身的同时浪费资源更新进度条！
- en: 'Let''s look at an example that displays a progress bar on notifications in
    the drawer—a use case that the Android development team anticipated and therefore
    made easy for us with the `setProgress` method of `NotificationCompat.Builder`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，该例子在抽屉中的通知上显示进度条——这是Android开发团队预见到的情况，因此通过`NotificationCompat.Builder`的`setProgress`方法使我们能够轻松实现：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, max sets the target value at which our work will be completed, progress
    is where we have got to so far, and indeterminate controls which type of progress
    bar is shown. When indeterminate is true, the notification shows a progress bar
    that indicates something is in progress without specifying how far through the
    operation we are, while false shows the kind of progress bar that we need—one
    that shows how much work we have done, and how much is left to do.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，max设置我们的工作将完成的靶值，progress是我们已经到达的位置，而indeterminate控制显示哪种类型的进度条。当indeterminate为true时，通知显示一个进度条，指示有事情在进行，但没有指定操作进行到哪一步，而false显示我们需要的那种进度条——显示我们已经完成的工作量以及剩余的工作量。
- en: 'We''ll need to calculate progress and dispatch notifications at appropriate
    intervals, which we''ve facilitated through our `ProgressCallback` class. Now
    we need to implement the `ProgressCallback` and hook it up in `UploadArtworkIntentService`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要计算进度并在适当的时间间隔内发送通知，我们已经通过我们的 `ProgressCallback` 类实现了这一点。现在我们需要实现 `ProgressCallback`
    并将其连接到 `UploadArtworkIntentService`：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The constructor of `ProgressNotificationCallback` consists of familiar code
    to post a notification with a progress bar.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProgressNotificationCallback` 构造函数包含用于发布带有进度条的通知的熟悉代码。'
- en: The `onProgress` method throttles the rate at which notifications are dispatched,
    so that we only post an update as each additional 5 percent of the total data
    is uploaded, in order not to swamp the system with notification updates.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`onProgress` 方法限制了发送通知的速率，以确保我们只在总数据上传增加额外的 5% 时发布更新，以免系统被通知更新淹没。'
- en: The `onComplete` method posts a notification that sets both the integer progress
    parameters to zero, which removes the progress bar.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`onComplete` 方法发布一个通知，将整数进度参数设置为零，从而移除进度条。'
- en: 'To complete the code, we implement `onHandleIntent` to display the notification
    drawer and deliver the upload result:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成代码，我们实现 `onHandleIntent` 以显示通知抽屉并传递上传结果：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Tap an artwork image to start uploading and you'll see a notification appear.
    Slide open the notification drawer and watch the progress bar ticking up as your
    image uploads.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 点击艺术品图像开始上传，你会看到一个通知出现。滑动打开通知抽屉，并观察进度条随着你的图像上传而跳动。
- en: We are finished with started services, so now it is time to move to a different
    type of Service, the Bound Service.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了启动服务，现在应该转向另一种类型的服务，即绑定服务。
- en: Bound Service
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定服务
- en: A Bound Service is an Android Service that defines a client interface and allows
    several entities to bind it by invoking `bindService()` and creating a relation
    between each order that facilitates the interaction with a request-response model.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定服务是一个定义客户端接口的 Android 服务，它允许通过调用 `bindService()` 并创建与每个订单之间的联系，从而方便与请求-响应模型进行交互的多个实体绑定它：
- en: The `Service` instance will be created when the first client attempts to connect
    to it and will be alive until the last client disconnects from it using the `unbindService()`
    function.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一个客户端尝试连接到服务时，将创建 `Service` 实例，并且它将一直存活，直到最后一个客户端使用 `unbindService()` 函数断开连接。
- en: 'In order to create the connection between the client and the server, the service
    must implement the `onBind()` function and return an `IBinder` object that implements
    a lightweight remote procedure mechanism to perform in-process or cross-process
    calls:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在客户端和服务器之间建立连接，服务必须实现 `onBind()` 函数并返回一个实现轻量级远程过程调用机制的 `IBinder` 对象，以执行进程内或跨进程调用：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When all the clients disconnect from the Service, calling `unbindService()`,
    the service `onUnbind()` member method is called:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有客户端从服务断开连接并调用 `unbindService()` 时，将调用服务的 `onUnbind()` 成员方法：
- en: '[PRE34]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: A Bound Service might reside in the same process (LS), in a different process
    that belongs to the application (LIS), or in an another application process (GS),
    so the technique to communicate with the service and the `IBinder` type returned
    depends entirely on the service process location, as mentioned before.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定服务可能位于同一进程（LS）、属于应用程序的不同进程（LIS）或另一个应用程序进程（GS）中，因此与该服务通信的技术和返回的 `IBinder` 类型完全取决于服务进程的位置，如前所述。
- en: In the next section, we are going to explain how to interact and bind to a local
    Service to initiate an asynchronous action on the Service.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将解释如何与本地服务进行交互和绑定，以在服务上启动异步操作。
- en: The remote binding with AIDL or with Messenger are other techniques used in
    advanced use cases where inter-process communication is required, though in this
    book we are not going to cover it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AIDL 或使用信使进行远程绑定是其他在需要进程间通信的高级用例中使用的技巧，尽管在这本书中我们不会涉及它。
- en: For a smooth start, first we are going to cover a local `Service` binding.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了顺利启动，我们首先将介绍本地 `Service` 绑定：
- en: Communicating with a Local Service
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与本地服务通信
- en: A local bound service is the most common type of bound `service`, and given
    that the server and the client run on the same process, there is no need to use
    an **inter-process communication** (**IPC**) technique to send requests and receive
    responses between them. Moreover, both entities, the service client and server,
    share the same address memory space within the process, making the exchange of
    requests and responses quite easy using Java Objects.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 本地绑定的服务是最常见的绑定 `service` 类型，鉴于服务器和客户端在同一个进程中运行，因此不需要使用 **进程间通信** （**IPC**） 技术在它们之间发送请求和接收响应。此外，服务客户端和服务器在进程内部共享相同的地址内存空间，这使得使用Java对象交换请求和响应变得相当容易。
- en: Since we are within the same process, the `Binder` object returned by the `onBind()`
    `Service` method might define a method to return the `Service` class instance
    object. In this manner, we can use the public `Service` class functions to submit
    new requests to the `Service` in the same way as we invoke a regular object method.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们处于同一个进程中，`onBind()` `Service` 方法返回的 `Binder` 对象可能定义了一个方法来返回 `Service` 类实例对象。这样，我们可以使用公共的
    `Service` 类函数以与调用常规对象方法相同的方式向同一 `Service` 提交新请求。
- en: Let's demonstrate this with an example, creating a bound service that creates
    an SHA1 cryptographic digest from a string that we type in a UI `EditText`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来演示这一点，创建一个绑定的服务，该服务可以从我们在UI `EditText`中输入的字符串生成SHA1加密摘要。
- en: 'Primarily, we will start by implementing our own `Binder`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的，我们将从实现自己的 `Binder` 开始：
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Our binder, `LocalBinder`, extends from the `Binder` class, and provides a `getService()`
    method to retrieve the instance of our `Service`. Then, when any client connects
    to our `Service`, the `onBind()` function will return our `LocalBinder` instance
    object.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的绑定器 `LocalBinder` 从 `Binder` 类扩展，并提供一个 `getService()` 方法来检索我们的 `Service`
    实例。然后，当任何客户端连接到我们的 `Service` 时，`onBind()` 函数将返回我们的 `LocalBinder` 实例对象。
- en: An `Activity` or `Fragment` that wants to directly interact with this `Service`
    first needs to bind to it using the `bindService` method and secondly supply a
    `ServiceConnection` to handle the `onServiceConnected()`/`onServiceDisconnected()`
    callbacks.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 想要直接与这个 `Service` 交互的 `Activity` 或 `Fragment` 首先需要使用 `bindService` 方法将其绑定，然后提供
    `ServiceConnection` 来处理 `onServiceConnected()`/`onServiceDisconnected()` 回调。
- en: 'The `ServiceConnection` implementation simply casts the `IBinder` received
    to the concrete class defined by the `Service`, obtains a reference to the `Service`,
    and records it in a member variable of the `Activity`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServiceConnection` 实现简单地将接收到的 `IBinder` 强制转换为 `Service` 定义的具体系列类，获取 `Service`
    的引用，并将其记录在 `Activity` 的成员变量中：'
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When we lose the connection with Service unexpectedly, due to a service crash
    or an unexpected error in the Android system, `onServiceDisconnected` gets called
    to notify the client that the connection to the service is considered lost.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们意外地与服务失去连接，由于服务崩溃或Android系统中的意外错误时，`onServiceDisconnected` 被调用以通知客户端认为与服务的连接已丢失。
- en: 'We can make the `Activity` bind and unbind during its `onStart()` and `onStop()`
    lifecycle method, because we only need to interact with the service when the `Activity`
    is visible on the screen. We should try to avoid the bind and unbind `onResume()`
    and `onPause() Activity` callbacks to reduce the number of connect and disconnect
    transitions in your application''s lifecycle:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `Activity` 的 `onStart()` 和 `onStop()` 生命周期方法中绑定和解绑 `Activity`，因为我们只需要在
    `Activity` 在屏幕上可见时与服务交互。我们应该尽量避免在 `onResume()` 和 `onPause()` `Activity` 回调中进行绑定和解绑，以减少应用程序生命周期中的连接和断开连接转换次数：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Once the `Activity` starts, we call the `Context.bindService()`, passing an
    Intent that explicitly defines the `Service` class that we want to bind, our `ServiceConnection`
    instance, and the optional flag `Context.BIND_AUTO_CREATE` that means that the
    System will keep the Service running as long as this bind exists.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `Activity` 开始，我们调用 `Context.bindService()`，传递一个Intent，该Intent明确定义了我们想要绑定的
    `Service` 类，我们的 `ServiceConnection` 实例，以及可选的标志 `Context.BIND_AUTO_CREATE`，这意味着只要这个绑定存在，系统就会保持
    `Service` 运行。
- en: In Hybrid Services (Bound/Started), after we bind to a Service, we can access
    the Service by calling `startService(Intent)` and process Service calls over `onStartCommand(Intent,
    int, int)`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在混合服务（绑定/启动）中，在我们绑定到服务之后，我们可以通过调用 `startService(Intent)` 来访问服务，并在 `onStartCommand(Intent,
    int, int)` 中处理服务调用。
- en: This is great—once the binding is made, we have a direct reference to the `Service`
    instance and can call its methods! However, we didn't implement any methods in
    our `Service` yet, so it's currently useless.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这很棒——一旦建立了绑定，我们就有了对`Service`实例的直接引用，可以调用其方法！然而，我们还没有在我们的`Service`中实现任何方法，所以目前它是无用的。
- en: Let's create a method on `Sha1HashService` to calculate the digest in the background
    and return the result to the `Activity`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Sha1HashService`上创建一个方法，在后台计算摘要并将结果返回给`Activity`。
- en: 'First, to execute this task in background we need to setup the execution engine,
    so to achieve that we are going to set up our own `Executor` based on the `ThreadPool`
    class supplied in `java.util.concurrent`. The Executor will support concurrency,
    from two to four concurrent threads, and request queueing up to 32 queued jobs:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了在后台执行此任务，我们需要设置执行引擎，为此我们将基于`java.util.concurrent`中提供的`ThreadPool`类设置自己的`Executor`。执行器将支持从两个到四个并发线程的并发性，以及最多32个排队任务：
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When the Service is created, immediately after the first binding, the `ThreadPool`
    is started and the core threads (2) are started with `prestartAllCoreThreads`,
    ready to process the incoming requests as soon as they arrive in the Service.
    If the clients submit requests at such a pace that the core threads are not able
    handle them, the thread pool will increase the number of worker threads in the
    pool until it reaches four threads.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务创建后，在第一次绑定之后，立即启动`ThreadPool`，并使用`prestartAllCoreThreads`启动核心线程（2个），以便在服务中请求到达时立即处理。如果客户端以这样的速度提交请求，以至于核心线程无法处理，线程池将增加池中的工作线程数量，直到达到四个线程。
- en: 'Now that we have the executor in place, we will create the public method that
    receives the request to digest a `String`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了执行器，我们将创建一个公共方法来接收对摘要`String`的请求：
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Since `Sha1Activity` has a direct object reference to `Sha1HashService`, we
    can now go ahead and invoke its `getSha1Digest` method directly—taking care to
    check that the `Service` is actually bound first, of course:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Sha1Activity`对`Sha1HashService`有直接的对象引用，我们现在可以直接调用其`getSha1Digest`方法——当然要确保首先绑定`Service`：
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Taking the text retrieved from our `EditText` view, we call our Service `getSha1Digest`
    to calculate the typed text digest. This is a very convenient and efficient way
    of submitting work to a `Service`—there's no need to package up a request in an
    Intent, so there's no excess object creation or communication overhead.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的`EditText`视图中检索到的文本，我们调用我们的`Service`的`getSha1Digest`来计算输入文本的摘要。这是一种非常方便且高效地向`Service`提交工作的方式——不需要在Intent中打包请求，因此不需要额外的对象创建或通信开销。
- en: Since `getSha1Digest` is asynchronous, we can't return a result directly from
    the method invocation, and `Sha1HashService` itself has no user interface, so
    how can we present results to our user?
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`getSha1Digest`是异步的，我们不能直接从方法调用中返回结果，并且`Sha1HashService`本身没有用户界面，所以我们如何向用户展示结果？
- en: 'One possibility is to pass a callback to `Sha1HashService` so that we can invoke
    methods of our `Activity` when the background work completes. Let''s define a
    generic callback interface for the activity to implement:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能性是将回调传递给`Sha1HashService`，这样我们就可以在后台工作完成后调用我们的`Activity`的方法。让我们为活动定义一个通用的回调接口：
- en: '[PRE41]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There is a serious risk that by passing an `Activity` into the `Service`, we'll
    expose ourselves to memory leaks. The lifecycles of `Service` and `Activity` do
    not coincide, so strong references to an `Activity` from a `Service` can prevent
    it from being garbage collected in a timely fashion.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个严重风险，即通过传递`Activity`到`Service`，我们将暴露自己于内存泄漏。`Service`和`Activity`的生命周期不一致，因此`Service`对`Activity`的强引用可能会阻止它及时被垃圾回收。
- en: The simplest way to prevent such memory leaks is to make sure that `Sha1HashService`
    only keeps a weak reference to the calling `Activity` so that when its lifecycle
    is complete, the `Activity` can be garbage collected, even if there is an ongoing
    calculation in the Service.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 防止此类内存泄漏最简单的方法是确保`Sha1HashService`只保留对调用`Activity`的弱引用，这样当其生命周期结束时，`Activity`可以被垃圾回收，即使服务中正在进行计算。
- en: It is really important to remember that whenever we update the UI during the
    `ResultCallback.onResult`, we must do it in the UI Thread; therefore, it is essential
    to create a `Runnable` object with the result and post it on the main `Looper`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 真的非常重要，每次我们在`ResultCallback.onResult`期间更新UI时，我们必须在UI线程中执行；因此，创建一个带有结果的`Runnable`对象并将其发布在主`Looper`上是非常必要的。
- en: 'The modified `Sha1HashService` is shown in the following code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的 `Sha1HashService` 在以下代码中展示：
- en: '[PRE42]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We invoke the callback on the main thread using `postResultOnUI`, so that `Sha1Activity`
    can interact with the user interface directly in the callback method. We can implement
    the callback as a method of `Sha1Activity`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `postResultOnUI` 在主线程上调用回调，这样 `Sha1Activity` 就可以直接在回调方法中与用户界面交互。我们可以将回调实现为
    `Sha1Activity` 的一个方法：
- en: '[PRE43]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now we can directly invoke methods in `Sha1HashService` and return results
    via a callback method of `Sha1Activity` by passing the `Activity` itself as the
    callback:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以直接调用 `Sha1HashService` 中的方法，并通过传递 `Activity` 本身作为回调，通过 `Sha1Activity`
    的回调方法返回结果：
- en: '[PRE44]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Our service uses their local `ThreadPool` executor to handle the requests in
    an asynchronous way, although we might have used the `AsyncTask` public static
    executors: `SERIAL_EXECUTOR` to execute our digest calculation in a serialized
    way, or the `THREAD_POOL_EXECUTOR` to calculate the digest concurrently and independently:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务使用它们的本地 `ThreadPool` 执行者以异步方式处理请求，尽管我们可能已经使用了 `AsyncTask` 的公共静态执行者：`SERIAL_EXECUTOR`
    以序列化方式执行我们的摘要计算，或 `THREAD_POOL_EXECUTOR` 以并发和独立地计算摘要：
- en: '[PRE45]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Notice that the `AsyncTask` executors are a system-shared resource, a shared
    group of threads, used by all the `AsyncTasks` in the system; therefore, our processing
    might suffer a delay when all the executor threads are occupied doing work. In
    most use cases there is no need to create our own custom group of working threads
    and the `AsyncTask` executors should be used.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`AsyncTask` 执行者是系统共享资源，是一个共享的线程组，由系统中的所有 `AsyncTasks` 使用；因此，当所有执行者线程都忙于工作时，我们的处理可能会延迟。在大多数用例中，没有必要创建我们自己的自定义工作线程组，而应该使用
    `AsyncTask` 执行者。
- en: 'This direct communication between `Sha1Activity` and `Sha1HashService` is very
    efficient and easy to work with. However, there is a downside: if the `Activity`
    restarts because of a configuration change, such as a device rotation, the `WeakReference`
    to the callback will be garbage collected and `Sha1HashService` cannot send the
    result.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sha1Activity` 和 `Sha1HashService` 之间的这种直接通信非常高效且易于处理。然而，也存在一个缺点：如果 `Activity`
    由于配置更改（如设备旋转）而重新启动，回调的 `WeakReference` 将被垃圾回收，`Sha1HashService` 就无法发送结果。'
- en: In the next section we are going to explore a mechanism that sends the results
    back to an Activity, or an other part of the application, even after a configuration
    change – Broadcast Intents.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨一种机制，即使配置更改后，也能将结果发送回 Activity 或应用程序的其他部分——广播 Intent。
- en: Broadcasting results with intents
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用意图广播结果
- en: 'Broadcasting an `Intent` is a way of sending results to anyone who registers
    to receive them. This can even include other applications in separate processes
    if we choose, but if the `Activity` and `Service` are a part of the same process,
    broadcasting is best done using a local broadcast, as this is more efficient and
    secure:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 广播 `Intent` 是将结果发送给任何注册接收它们的人的一种方式。如果我们选择的话，这甚至可以包括在单独进程中的其他应用程序；但如果 `Activity`
    和 `Service` 是同一进程的一部分，广播最好使用本地广播来完成，因为这更高效且更安全：
- en: '![Broadcasting results with intents](img/Image_B05062_05_02.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![使用意图广播结果](img/Image_B05062_05_02.jpg)'
- en: 'We can update `Sha1HashService` to broadcast its results with just a few extra
    lines of code. First, let''s define two constants to make it easy to register
    a receiver for the broadcast and extract the result from the broadcast Intent
    object:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加几行额外的代码来更新 `Sha1HashService`，使其能够广播其结果。首先，让我们定义两个常量，以便轻松注册广播接收器并从广播
    Intent 对象中提取结果：
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now we can implement the method that does most of the work using the `LocalBroadcastManager`
    to send an Intent object containing the calculated result. We''re using the support
    library class `LocalBroadcastManager` here for efficiency and security—broadcasts
    sent locally don''t incur the overhead of interprocess communication and cannot
    be leaked outside of our application:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现一个方法，使用 `LocalBroadcastManager` 发送包含计算结果的 Intent 对象，来完成大部分工作。我们在这里使用支持库类
    `LocalBroadcastManager` 以提高效率和安全性——本地发送的广播不会产生进程间通信的开销，并且不能泄露到我们的应用程序之外：
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `sendBroadcast` method is asynchronous and will return immediately without
    waiting for the message to be broadcast and handled by receivers. Finally, we
    invoke our new `broadcastResult` method from `getSha1Digest`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendBroadcast` 方法是异步的，将立即返回，而无需等待消息被广播并由接收者处理。最后，我们从 `getSha1Digest` 中调用我们新的
    `broadcastResult` 方法：'
- en: '[PRE48]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Great! We''re broadcasting the result of our background calculation. Now we
    need to register a receiver in `Sha1Activity` to handle the result. Here''s how
    we might define our `BroadcastReceiver` subclass:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们正在广播后台计算的成果。现在我们需要在 `Sha1Activity` 中注册一个接收器来处理结果。以下是我们可能定义的 `BroadcastReceiver`
    子类：
- en: '[PRE49]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This `DigestReceiver` implementation is quite simple—all it does is extract
    and display the result from the Intent it receives—basically fulfilling the role
    of the Handler we used in the previous section.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `DigestReceiver` 实现相当简单——它只是从接收到的 Intent 中提取并显示结果——基本上完成了我们在上一节中使用的 Handler
    的角色。
- en: 'We only want this `BroadcastReceiver` to listen for results while our `Activity`
    is at the top of the stack and visible in the application, so we''ll register
    and unregister it in the `onStart()` and `onStop()` lifecycle methods. As with
    the `Handler` that we used previously, we''ll also apply the attach/detach pattern
    to make sure we don''t leak View objects:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只想在这个 `BroadcastReceiver` 监听结果，当我们的 `Activity` 在堆栈顶部并且可见时，因此我们将在 `onStart()`
    和 `onStop()` 生命周期方法中注册和注销它。与之前使用的 `Handler` 一样，我们还将应用 attach/detach 模式以确保不会泄漏
    View 对象：
- en: '[PRE50]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Of course, if the user moves to another part of the application that doesn't
    register a `BroadcastReceiver`, or if we exit the application altogether, they
    won't see the result of the calculation.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果用户移动到应用程序的另一个部分而没有注册 `BroadcastReceiver`，或者如果我们完全退出应用程序，他们将看不到计算的结果。
- en: If our Service could detect unhandled broadcasts, we could modify it to alert
    the user with a system notification instead. We'll see how to do that in the next
    section.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的服务能够检测到未处理的广播，我们可以修改它以通过系统通知来提醒用户。我们将在下一节中看到如何做到这一点。
- en: Detecting unhandled broadcasts
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测未处理的广播
- en: In the previous sections, we used system notifications to post results to the
    notification drawer—a nice solution for when the user has navigated away from
    our app before the background work has completed. However, we don't want to annoy
    the user by posting notifications when our app is still in the foreground and
    can display the results directly.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用系统通知将结果发布到通知抽屉——当用户在后台工作完成之前导航离开我们的应用程序时，这是一个很好的解决方案。然而，我们不想在应用程序仍在前台并且可以直接显示结果时通过发布通知来打扰用户。
- en: Ideally, we'll display the results in the app if it is still in the foreground
    and send a notification otherwise. If we're broadcasting results, the `Service`
    will need to know if anyone handled the broadcast and if not, send a notification.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，如果应用程序仍在前台，我们将显示结果，否则发送通知。如果我们正在广播结果，`Service` 需要知道是否有人处理了广播，如果没有，则发送通知。
- en: 'One way to do this is to use the `sendBroadcastSync` synchronous broadcast
    method and take advantage of the fact that the `Intent` object we''re broadcasting
    is mutable (any receiver can modify it). To begin with, we''ll add one more constant
    to `Sha1HashService`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的一种方法是通过使用 `sendBroadcastSync` 同步广播方法并利用我们正在广播的 `Intent` 对象是可变的事实（任何接收器都可以修改它）。首先，我们将在
    `Sha1HashService` 中添加一个额外的常量：
- en: '[PRE51]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, modify `broadcastResult` to use the synchronous broadcast method and
    return the value of a Boolean extra property; `HANDLED` from the Intent:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，修改 `broadcastResult` 以使用同步广播方法并返回 Intent 中布尔额外属性的值；从 Intent 中获取 `HANDLED`：
- en: '[PRE52]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Because `sendBroadcastSync` is synchronous, all registered `BroadcastReceivers`
    will have handled the broadcast by the time `sendBroadcastSync` returns. This
    means that if any receiver sets the Boolean extra property `HANDLED` to `true`,
    `broadcastResult` will return `true`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `sendBroadcastSync` 是同步的，所以所有注册的 `BroadcastReceivers` 都会在 `sendBroadcastSync`
    返回之前处理广播。这意味着如果任何接收器将布尔额外属性 `HANDLED` 设置为 `true`，则 `broadcastResult` 将返回 `true`。
- en: 'In our `BroadcastReceiver`, we''ll update the `Intent` object by adding a Boolean
    property to indicate that we''ve handled it:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `BroadcastReceiver` 中，我们将通过添加一个布尔属性来更新 `Intent` 对象，以指示我们已经处理了它：
- en: '[PRE53]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now if `Sha1Activity` is still running, its `BroadcastReceiver` is registered
    and receives the `Intent` object and will set the extra Boolean property `HANDLED`
    with the value `true`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果 `Sha1Activity` 仍在运行，它的 `BroadcastReceiver` 已注册并接收 `Intent` 对象，并将额外布尔属性
    `HANDLED` 设置为 `true`。
- en: However, if `Sha1Activity` has finished, the `BroadcastReceiver` will no longer
    be registered and `Sha1HashService` will return `false` from its `broadcastResult`
    method.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果 `Sha1Activity` 已经完成，`BroadcastReceiver` 将不再注册，`Sha1HashService` 将从其 `broadcastResult`
    方法返回 `false`。
- en: Note
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'There''s one final complication: unlike `sendBroadcast`, which always invokes
    `BroadcastReceivers` on the main thread, `sendBroadcastSync` uses the thread that
    it is called with.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个复杂问题是：与始终在主线程上调用`BroadcastReceivers`的`sendBroadcast`不同，`sendBroadcastSync`使用调用它的线程。
- en: 'Our `BroadcastReceiver` interacts directly with the user interface, so we must
    call it on the main thread. To broadcast the intent on the main thread synchronously,
    we create an anonymous Runnable to execute the broadcast:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`BroadcastReceiver`直接与用户界面交互，因此我们必须在主线程上调用它。为了在主线程上同步广播intent，我们创建一个匿名Runnable来执行广播：
- en: '[PRE54]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now that we have the broadcast function in place, we can call it from the `getSha1Digest`
    to generate an Android notification when the intent is not handled by a `Receiver`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了广播功能，我们可以在`getSha1Digest`中调用它，当intent没有被`Receiver`处理时，生成Android通知：
- en: '[PRE55]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This does just what we want—if our `BroadcastReceiver` handles the message,
    we don't post a notification; otherwise, we will do so to make sure the user gets
    their result.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们想要的——如果我们的`BroadcastReceiver`处理了消息，我们不会发布通知；否则，我们将这样做，以确保用户得到他们的结果。
- en: So far we have been binding to a Service that runs within the same process,
    where the client shares the memory address space with the Service. In the next
    section we are going to detail how to interact with Services that run in remote
    processes using the Android IPC-specific techniques.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直绑定在同一个进程内运行的Service，客户端与Service共享内存地址空间。在下一节中，我们将详细介绍如何使用Android IPC特定技术来与在远程进程中运行的Service进行交互。
- en: Applications of Services
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Service的应用
- en: With a little bit of work, `Services` give us the means to perform long-running
    background tasks, and free us from the tyranny of the `Activity` lifecycle. As
    opposed to `IntentService`, directly sub-classing a `Service` also gives us the
    ability to control the level of concurrency.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一点工作，`Services`为我们提供了执行长时间运行的后台任务的方法，并使我们摆脱了`Activity`生命周期的束缚。与`IntentService`不同，直接子类化`Service`也使我们能够控制并发级别。
- en: With the ability to run as many tasks as we need and to take as long as is necessary
    to complete those tasks, a world of new possibilities opens up.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 能够运行我们需要的任何数量的任务，并且可以花费必要的时间来完成这些任务，这打开了一个全新的可能性世界。
- en: The only real constraint on how and when we use `Services` comes from the need
    to communicate results to a user-interface component, such as a `Fragment` or
    `Activity`, and the complexity this entails.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对如何以及何时使用`Services`的唯一真正限制来自于需要将结果传达给用户界面组件，如`Fragment`或`Activity`，以及这所涉及到的复杂性。
- en: 'Ideal use cases for `Services` tend to have the following characteristics:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`Services`的理想用例通常具有以下特征：'
- en: 'Long-running (a few hundred milliseconds and upward):'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长时间运行（几百毫秒以上）：
- en: Not specific to a single Activity or Fragment class
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不特定于单个Activity或Fragment类
- en: Must complete, even if the user leaves the application
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使用户离开了应用程序也必须完成
- en: Does not require user intervention to complete
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成不需要用户干预
- en: Operations that require state between different calls
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要在不同调用之间保持状态的操作
- en: Requires more concurrency than `IntentService` provides, or needs control over
    the level of concurrency
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要的并发级别比`IntentService`提供的多，或者需要控制并发级别
- en: There are many applications that exhibit these characteristics, but the stand-out
    example is, of course, handling concurrent downloads from a web service.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多应用程序表现出这些特征，但最突出的例子当然是处理来自网络服务的并发下载。
- en: To make good use of the available download bandwidth and to limit the impact
    of network latency, we want to be able to run more than one download at a time
    (but not too many). We also don't want to use more bandwidth than necessary by
    failing to completely download a file and having to restart the download later.
    So ideally, once a download starts, it should run to completion even if the user
    leaves the application.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用可用的下载带宽并限制网络延迟的影响，我们希望能够同时运行多个下载（但不要太多）。我们也不想因为未能完全下载文件而需要稍后重新下载，从而浪费不必要的带宽。因此，理想情况下，一旦开始下载，就应该运行到完成，即使用户离开了应用程序。
- en: Summary
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the very powerful `Service` component, putting
    it to use to execute long-running background tasks with or without a configurable
    level of concurrency.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了非常强大的`Service`组件，将其用于执行带有或没有可配置并发级别的长时间运行的后台任务。
- en: We explored the incredibly useful `IntentService`—an ideal construct for performing
    long-running background tasks off the main thread, surviving well beyond the lifecycle
    of the initiating `Activity`, and even continuing to do useful work when the application
    is no longer in the foreground.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了极其有用的`IntentService`——这是一个理想的构造，用于在主线程之外执行长时间运行的后台任务，其生命周期远远超出启动它的`Activity`，甚至在应用不再处于前台时继续执行有用的工作。
- en: We learned how to send work to an `IntentService` with parameterized Intents,
    how to process that work in the background by implementing `onHandleIntent`, and
    how to send results back to the originating `Activity` using a `PendingIntent`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用参数化`Intent`将工作发送到`IntentService`，如何通过实现`onHandleIntent`在后台处理这项工作，以及如何使用`PendingIntent`将结果发送回原始的`Activity`。
- en: For cases where the application is no longer in the foreground or an operation
    is particularly long-running, we saw how to post notifications to the notification
    drawer, complete with progress updates.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 对于应用不再处于前台或操作特别耗时的情况，我们展示了如何向通知抽屉发送通知，包括进度更新。
- en: 'We also saw the wide range of communication mechanisms available for delivering
    results back to the user: direct invocation of local `Service` methods; broadcasting
    results to registered parties with `BroadcastReceiver`; and, if the user has already
    left the application, raising system notifications.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了广泛的可用于将结果发送回用户的通信机制：直接调用本地`Service`方法；使用`BroadcastReceiver`向已注册方广播结果；如果用户已经离开应用，则引发系统通知。
- en: 'In the next chapter, we''ll add one other weapon to our arsenal: the ability
    to run background tasks at specific times—even when the device is asleep—by scheduling
    alarms with `AlarmManager`.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将向我们的武器库中添加一项新能力：通过使用`AlarmManager`安排闹钟，在特定时间运行后台任务——即使设备处于睡眠状态。
