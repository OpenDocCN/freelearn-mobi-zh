- en: '*Chapter 8*: Adding Core Data to Your App'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 8 章*：将 Core Data 添加到您的应用程序中'
- en: '`UserDefaults`, but when you''re handling data that is more complex, has relationships,
    or needs some form of efficient searching, Core Data is much better suited to
    your needs.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserDefaults`，但是当你处理更复杂的数据时，具有关系或需要某种形式的快速搜索时，Core Data 更适合你的需求。'
- en: You don't need to build a very complex app or have vast amounts of data to make
    Core Data worth your while. Regardless of your app's size, even if it's tiny with
    only a couple of records, or if you're holding onto thousands of records, Core
    Data has your back.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要构建一个非常复杂的应用程序或拥有大量数据，才能使 Core Data 值得你投入。无论你的应用程序大小如何，即使它非常小，只有几条记录，或者如果你正在处理数千条记录，Core
    Data 都会支持你。
- en: In this chapter, you'll learn how to add Core Data to an existing app. The app
    you will build keeps track of a list of favorite movies for all members of a family.
    The main interface is a table view that shows a list of family members. If you
    tap on a family member's name, you'll see their favorite movies. Adding family
    members can be done through the overview screen and adding movies can be done
    through the detail screen.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何将 Core Data 添加到现有应用程序中。你将构建的应用程序将跟踪一个家庭的成员喜欢的电影列表。主要界面是一个表格视图，显示家庭成员列表。如果你点击家庭成员的姓名，你会看到他们的喜欢的电影。添加家庭成员可以通过概览屏幕完成，添加电影可以通过详细屏幕完成。
- en: 'In this chapter, the following topics are covered:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，以下主题被涵盖：
- en: Understanding the Core Data stack
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Core Data 堆栈
- en: Adding Core Data to an existing application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Core Data 添加到现有应用程序中
- en: Creating a Core Data model
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Core Data 模型
- en: Persisting data and reacting to data changes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久化数据和响应数据变化
- en: Understanding the use of multiple instances of `NSManagedObjectContext`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 `NSManagedObjectContext` 多实例的使用
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You won't build the screens in this app from scratch. The code bundle for this
    chapter includes a starter project called `MustC`. The starter project contains
    all of the screens, so you don't have to set up the user interface before you
    get around to implementing Core Data.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你不会从头开始构建这个应用程序的屏幕。本章的代码包包含一个名为 `MustC` 的起始项目。起始项目包含所有屏幕，因此在你开始实现 Core Data
    之前，你不需要设置用户界面。
- en: 'Download the sample code from the following GitHub link:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下 GitHub 链接下载示例代码：
- en: '[https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition)'
- en: Understanding the Core Data stack
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Core Data 堆栈
- en: Before you dive right into the project and add Core Data to it, let's take a
    look at how Core Data works, what it is, and what it isn't. In order to make efficient
    use of Core Data, you must know what you're working with.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在你直接进入项目并添加 Core Data 之前，让我们看看 Core Data 的工作原理，它是什么，它不是什么。为了有效地使用 Core Data，你必须了解你所工作的内容。
- en: 'When you work with Core Data, you''re utilizing a stack of layers that starts
    with managed objects and ends with a data store. This data store is often a SQLite
    database, but there are different storage options you can use with Core Data,
    depending on your application''s needs. Let''s take a quick look at the layers
    involved with Core Data and discuss their roles in an application briefly:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 Core Data 时，你正在利用一个从管理对象开始到数据存储结束的层堆栈。这个数据存储通常是 SQLite 数据库，但根据应用程序的需求，你可以使用不同的存储选项与
    Core Data 一起使用。让我们快速看一下与 Core Data 相关的层，并简要讨论它们在应用程序中的作用：
- en: '![Figure 8.1 – A Core Data stack'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.1 – 核心数据堆栈'
- en: '](img/Figure_8.01_B14717.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.01_B14717.jpg)'
- en: Figure 8.1 – A Core Data stack
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 核心数据堆栈
- en: At the top right of this diagram is the `NSManagedObject` class. When you use
    Core Data, this is the class you'll interact with most often since it's the base
    class for all the Core Data models that your app contains. For instance, in the
    app that you will build in this chapter, the family member and movie models are
    subclasses of `NSManagedObject`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在此图的右上角是 `NSManagedObject` 类。当你使用 Core Data 时，这是你最常与之交互的类，因为它是应用程序中所有 Core Data
    模型的基类。例如，在本章中你将构建的应用程序中，家庭成员和电影模型是 `NSManagedObject` 的子类。
- en: Each managed object belongs to an instance of `NSManagedObjectContext`. The
    managed object context is responsible for communicating with the **persistent
    store coordinator**. Often, you'll only need a single managed object context and
    a single persistent store coordinator. However, it is possible to use multiple
    persistent store coordinators and multiple managed object contexts. It's even
    possible to have multiple managed object contexts for the same persistent store
    coordinator.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每个托管对象都属于一个`NSManagedObjectContext`的实例。托管对象上下文负责与**持久化存储协调器**通信。通常，你可能只需要一个托管对象上下文和一个持久化存储协调器。然而，使用多个持久化存储协调器和多个托管对象上下文也是可能的。甚至可以为同一个持久化存储协调器拥有多个托管对象上下文。
- en: A setup with multiple managed object contexts can be particularly useful if
    you're performing costly operations on your managed objects; for example, if you're
    importing or synchronizing large amounts of data. Usually, you will stick to using
    a single managed object context and a single persistent store coordinator because
    most apps don't need more than one.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在托管对象上执行昂贵的操作，例如导入或同步大量数据，具有多个托管对象上下文的设置可能特别有用。通常，你将坚持使用单个托管对象上下文和单个持久化存储协调器，因为大多数应用不需要超过一个。
- en: The persistent store coordinator is responsible for communicating with the **persistent
    store**. In most scenarios, the persistent store uses SQLite as its underlying
    storage database. However, you can also use other types of storage, such as an
    in-memory database. An in-memory database is especially useful if you're writing
    unit tests or if your app does not need long-term storage.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化存储协调器负责与**持久化存储**通信。在大多数情况下，持久化存储使用SQLite作为其底层存储数据库。然而，你也可以使用其他类型的存储，例如内存数据库。内存数据库在编写单元测试或如果你的应用不需要长期存储时特别有用。
- en: If you've worked with MySQL, SQLite, or any other relational database, it is
    tempting to think of Core Data as a layer on top of a relational database. Although
    this isn't entirely false since Core Data can use SQLite as its underlying storage,
    Core Data does not work the same as using SQLite directly; it's an abstraction
    on top of it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过MySQL、SQLite或其他任何关系型数据库，可能会倾向于将Core Data视为关系型数据库之上的一层。尽管这并不完全错误，因为Core
    Data可以使用SQLite作为其底层存储，但Core Data并不像直接使用SQLite那样工作；它是在其之上的一种抽象。
- en: One example of a difference between SQLite and Core Data is the concept of primary
    keys. Core Data doesn't allow you to specify your own primary keys. Also, when
    you define relationships, you don't use foreign keys. Instead, you simply define
    the relationship and Core Data will figure out how to store this relationship
    in the underlying database. You will learn more about this later. It's important
    to know that you should not directly translate your SQL experiences to Core Data.
    If you do, you will run into issues, simply because Core Data is not SQL. It just
    so happens that SQLite is one of the ways that data can be stored, but the similarities
    end right there.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite和Core Data之间一个区别的例子是主键的概念。Core Data不允许你指定自己的主键。此外，当你定义关系时，你也不使用外键。相反，你只需定义关系，Core
    Data就会确定如何在底层数据库中存储这个关系。你将在稍后了解更多关于这一点。重要的是要知道，你不应该直接将你的SQL经验翻译到Core Data中。如果你这样做，你将遇到问题，仅仅是因为Core
    Data不是SQL。只是碰巧SQLite是数据存储的一种方式，但相似之处到此为止。
- en: To recap, all Core Data apps have a **persistent store**. This store is backed
    by an in-memory database or a SQLite database. A **persistent store coordinator**
    is responsible for communicating with the **persistent store**. The object communicating
    with the **persistent store coordinator** is the **managed object context**. An
    application can have multiple **managed object context** instances talking to
    the same **persistent store coordinator**. The objects that a **managed object
    context** retrieves from the **persistent store coordinator** are **managed objects**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，所有Core Data应用都有一个**持久化存储**。这个存储由一个内存数据库或SQLite数据库支持。**持久化存储协调器**负责与**持久化存储**通信。与**持久化存储协调器**通信的对象是**托管对象上下文**。一个应用可以有多个**托管对象上下文**实例与同一个**持久化存储协调器**通信。从**持久化存储协调器**检索的对象是**托管对象**。
- en: Now that you have an overview of the Core Data stack and where all the parts
    involved with its usage belong, let's add the Core Data stack to the **MustC**
    application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对Core Data堆栈及其使用中涉及的所有部分有了概述，让我们将Core Data堆栈添加到**MustC**应用中。
- en: Adding Core Data to an existing application
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Core Data 添加到现有应用程序
- en: When you create a new project in Xcode, Xcode asks whether you want to add Core
    Data to your application. If you check this checkbox, Xcode will automatically
    generate some boilerplate code that sets up the Core Data stack. For practicing
    purposes, `MustC` was set up without Core Data, so you'll have to add this to
    the project yourself.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Xcode 中创建一个新项目时，Xcode 会询问你是否想将 Core Data 添加到你的应用程序中。如果你勾选这个复选框，Xcode 将自动生成一些样板代码来设置
    Core Data 栈。为了练习目的，`MustC` 是没有使用 Core Data 设置的，所以你必须自己将其添加到项目中。
- en: 'Start by opening `AppDelegate.swift` and add the following `import` statement:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开 `AppDelegate.swift` 并添加以下 `import` 语句：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, add the following `lazy` variable to the implementation of `AppDelegate`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，将以下 `lazy` 变量添加到 `AppDelegate` 的实现中：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you declare a variable as lazy, it won't be initialized until it is accessed.
    This is particularly useful for variables that are expensive to initialize, rely
    on other objects, or are not always accessed. The fact that the variable is initialized
    just in time comes with a performance penalty since the variable needs to be set
    up the first time you access it. In some instances, this is fine, but in other
    cases, it might negatively impact the user experience. When used correctly, lazy
    variables can offer significant benefits.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将变量声明为 `lazy`，则它将在访问时才初始化。这对于初始化成本高昂、依赖于其他对象或不是总是访问的变量特别有用。变量仅在需要时初始化，这会带来性能惩罚，因为变量需要在第一次访问时设置。在某些情况下，这没问题，但在其他情况下，可能会对用户体验产生负面影响。当正确使用时，`lazy`
    变量可以提供显著的好处。
- en: The preceding code snippet creates an instance of `NSPersistentContainer`. The
    persistent container is a container for the persistent store coordinator, persistent
    store, and managed object context. This single object manages different parts
    of the Core Data stack, and it ensures that everything is set up and managed correctly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段创建了一个 `NSPersistentContainer` 实例。持久化容器是持久化存储协调器、持久化存储和管理对象上下文的容器。这个单一对象管理
    Core Data 栈的不同部分，并确保一切设置和管理正确。
- en: If you let Xcode generate the Core Data code for your app, it adds a similar
    property to create `NSPersistentContainer`. Xcode also adds a method called `saveContext()`
    to `AppDelegate`. This method is used in `applicationWillTerminate(_:)` to perform
    a last-minute save of any changes and updates when the application is about to
    terminate. Since you're setting up Core Data manually, this behavior isn't added
    by Xcode, so it must be added by you manually.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你让 Xcode 为你的应用程序生成 Core Data 代码，它将添加一个类似的属性来创建 `NSPersistentContainer`。Xcode
    还将一个名为 `saveContext()` 的方法添加到 `AppDelegate` 中。这个方法在 `applicationWillTerminate(_:)`
    中使用，以在应用程序即将终止时执行最后的保存和更新操作。由于你正在手动设置 Core Data，Xcode 不会添加这种行为，因此你必须手动添加。
- en: Instead of placing the `saveContext()` method in `AppDelegate`, you will add
    this method as an extension to `NSPersistentContainer`. This makes it easier for
    other parts of your code to use this method, without having to rely on `AppDelegate`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将 `saveContext()` 方法放在 `AppDelegate` 中，而是将其作为扩展添加到 `NSPersistentContainer`。这样做使得其他部分的代码能够更容易地使用这个方法，而无需依赖于
    `AppDelegate`。
- en: 'Next, create a new folder in the Project Navigator and name it `Extensions`.
    Also, create a new Swift file and name it `NSPersistentContainer.swift`. Add the
    following implementation to this file:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在项目导航器中创建一个新的文件夹，命名为 `Extensions`。同时，创建一个新的 Swift 文件，命名为 `NSPersistentContainer.swift`。将以下实现添加到该文件中：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code adds a new method to `NSPersistentContainer` instances by extending
    it. This is convenient because it decouples the save method from `AppDelegate`
    entirely. This is much nicer than the default save mechanism provided for Core
    Data apps by Xcode.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码通过扩展 `NSPersistentContainer` 实例来添加一个新的方法。这样做很方便，因为它完全解耦了保存方法与 `AppDelegate`。这比
    Xcode 为 Core Data 应用程序提供的默认保存机制要好得多。
- en: 'Add the following implementation of `applicationWillTerminate(_:)` to `AppDelegate`
    to save the context right before the app terminates:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下 `applicationWillTerminate(_:)` 的实现添加到 `AppDelegate` 中，以便在应用程序终止前保存上下文：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, whenever the application terminates, the persistent store will check whether
    there are any changes to the managed object context that the `viewContext` property
    points to. If there are any changes, an attempt to save them is made. If this
    attempt fails, the app will crash with `fatalError`. When creating your own app,
    you might want to handle this scenario a bit more gracefully. It could very well
    be that failing to save data before the app terminates might not be a reason that
    crashes your app. You can modify the error-handling implementation of `saveContextIfNeeded()`
    if you think a different behavior is more appropriate for your app. You can, for
    example, upload the error to your analytics or reporting tool to analyze it later,
    or avoid `fatalError` and just log the error without crashing the app.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当应用终止时，持久存储将检查 `viewContext` 属性指向的托管对象上下文是否有任何更改。如果有任何更改，将尝试保存它们。如果这个尝试失败，应用将崩溃并显示
    `fatalError`。在创建自己的应用时，你可能希望更优雅地处理这种情况。完全有可能在应用终止前未能保存数据并不是导致应用崩溃的原因。如果你认为你的应用更适合不同的行为，你可以修改
    `saveContextIfNeeded()` 的错误处理实现。例如，你可以将错误上传到你的分析或报告工具以供以后分析，或者避免使用 `fatalError`
    并仅记录错误而不使应用崩溃。
- en: Now that you have the Core Data stack set up, you need a way to provide this
    stack to the view controllers in the app. A common technique to achieve this is
    called `AppDelegate` will pass the persistent container to `FamilyMemberViewController`,
    which is the first view controller in the app. It then becomes the job of `FamilyMemberViewController`
    to pass the persistent container to the next view controller that depends on it,
    and so forth.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置了 Core Data 栈，你需要一种方法将这个栈提供给应用中的视图控制器。实现这一目标的一种常见技术是将 `AppDelegate` 传递给
    `FamilyMemberViewController`，这是应用中的第一个视图控制器。然后，`FamilyMemberViewController` 就负责将持久容器传递给下一个依赖于它的视图控制器，依此类推。
- en: 'In order to inject the persistent container, you need to add a property to
    `FamilyMembersViewController` that holds the persistent container. Don''t forget
    to add `import CoreData` at the top of the file and add the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了注入持久容器，你需要在 `FamilyMembersViewController` 中添加一个属性来持有持久容器。别忘了在文件顶部添加 `import
    CoreData` 并添加以下代码：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, in `AppDelegate`, modify the `application(_:didFinishLaunchingWith Options:)`
    method, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `AppDelegate` 中，修改 `application(_:didFinishLaunchingWith Options:)` 方法，如下所示：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This code is using dependency injection to inject `persistentContainer` into
    `FamilyMemberViewController`. But you can still make one major improvement: you
    know that there might be more view controllers that depend on a persistent container,
    so you will need a `persistentContainer` property in each of them. This will cause
    a lot of repeated code. We can improve our code if we define a protocol that we
    can reuse in order to reduce the duplicated code in each `UIViewController` instance
    that needs `persistentContainer`. As an exercise, attempt to improve the code
    by adding a protocol called `PersistentContainerRequiring`. This protocol should
    add a requirement for an implicitly unwrapped `persistentContainer` property.
    Make sure that `FamilyMembersViewController` conforms to this protocol, and fix
    the implementation of `application(_:didFinishLaunchingWithOptions:)` as well
    so that it uses your new protocol.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码正在使用依赖注入将 `persistentContainer` 注入到 `FamilyMemberViewController`。但你可以进行一个主要的改进：你知道可能有更多的视图控制器依赖于持久容器，因此你需要在它们中每个都添加一个
    `persistentContainer` 属性。这将导致大量的重复代码。如果我们定义一个可以重用的协议，以减少每个需要 `persistentContainer`
    的 `UIViewController` 实例中的重复代码，我们就可以改进我们的代码。作为一个练习，尝试通过添加一个名为 `PersistentContainerRequiring`
    的协议来改进代码。这个协议应该添加一个对隐式解包的 `persistentContainer` 属性的要求。确保 `FamilyMembersViewController`
    遵守这个协议，并修复 `application(_:didFinishLaunchingWithOptions:)` 的实现，以便它使用你的新协议。
- en: You have just put down the foundation that is required to use Core Data in your
    app. Before you can use Core Data and store data in it, you must define what data
    you would like to save by creating your data model. Let's go over how to do this
    next.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为在应用中使用 Core Data 奠定了基础。在你能够使用 Core Data 并在其中存储数据之前，你必须通过创建你的数据模型来定义你想要保存的数据。接下来，让我们看看如何做这件事。
- en: Creating a Core Data model
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Core Data 模型
- en: So far, you have worked on the persistence layer of your app. The next step
    is to create your models so that you can actually store and retrieve data from
    your Core Data database. All models in an application that uses Core Data are
    represented by `NSManagedObject` subclasses. When you retrieve data from your
    database, `NSManagedObjectContext` is responsible for creating instances of your
    managed objects and populating them with the relevant fetched data.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经完成了你应用的持久化层。下一步是创建你的模型，这样你就可以实际存储和检索 Core Data 数据库中的数据了。使用 Core Data
    的应用程序中的所有模型都由 `NSManagedObject` 子类表示。当你从数据库检索数据时，`NSManagedObjectContext` 负责创建你的管理对象实例，并用相关检索到的数据填充它们。
- en: 'The **MustC** application requires two models: a family-member model and a
    movie model. When you define models, you can also define relationships. For the
    models in **MustC**, you should define a relationship that links multiple movies
    to a single family member.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**MustC** 应用程序需要两个模型：一个家庭成员模型和一个电影模型。当你定义模型时，你还可以定义关系。对于 **MustC** 中的模型，你应该定义一个关系，将多个电影与单个家庭成员链接起来。'
- en: Creating the models
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建模型
- en: 'In order for Core Data to understand which models your application uses, you
    must define them in Xcode''s model editor. Let''s create a new model file so that
    you can add your own models to the **MustC** application. Create a new file, and
    from the file template selection screen, pick **Data Model**. First, you will
    set up the basic models, and then see how you can define a relationship between
    family members and their favorite movies:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 Core Data 理解你的应用程序使用哪些模型，你必须在使用 Xcode 的模型编辑器中定义它们。让我们创建一个新的模型文件，以便你可以在 **MustC**
    应用程序中添加自己的模型。创建一个新文件，并在文件模板选择屏幕上选择 **数据模型**。首先，你将设置基本模型，然后看看你如何定义家庭成员和他们的最爱电影之间的关系：
- en: '![Figure 8.2 – Creating a new Core Data model'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.2 – 创建新的 Core Data 模型'
- en: '](img/Figure_8.02_B14717.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.02_B14717.jpg)'
- en: Figure 8.2 – Creating a new Core Data model
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 创建新的 Core Data 模型
- en: Name your model file `MustC`. Your project now contains a file called `MustC.xcdatamodeld`.
    Open this file to go to the model editor. In the bottom-left corner of the editor,
    you'll find a button labeled `FamilyMember`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的模型文件命名为 `MustC`。你的项目现在包含一个名为 `MustC.xcdatamodeld` 的文件。打开此文件进入模型编辑器。在编辑器的左下角，你会找到一个标有
    `FamilyMember` 的按钮。
- en: 'When you select an entity by clicking it, you can see all of its attributes,
    relationships, and fetched properties. Let''s add a `name` property to the family
    member. Click on the plus (`name`. Make sure that you select **String** as the
    type for this attribute:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过点击选择一个实体时，你可以看到它的所有属性、关系和检索属性。让我们向家庭成员添加一个 `name` 属性。点击加号（`name`）。确保你选择此属性的类型为
    **String**：
- en: '![Figure 8.3 – Adding an attribute to a Core Data entity'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.3 – 向 Core Data 实体添加属性'
- en: '](img/Figure_8.03_B14717.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.03_B14717.jpg)'
- en: Figure 8.3 – Adding an attribute to a Core Data entity
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 向 Core Data 实体添加属性
- en: Click on this new property to select it. In the sidebar on the right, select
    the fourth tab to open the Data Model inspector. This is where you can see more
    detailed information on this attribute. For instance, you can configure a property
    to be indexed for faster lookups. You can also choose whether you want the attribute
    to be optional. For now, you shouldn't care too much about indexing since you're
    not performing lookups by family members' names, and, even if you were, a family
    doesn't tend to have hundreds or thousands of members. By default, the **Optional**
    checkbox is checked. Make sure that you uncheck this box because you don't want
    to store family members without a name.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 点击这个新属性以选择它。在右侧的侧边栏中，选择第四个选项卡以打开数据模型检查器。这里你可以看到关于此属性的更详细的信息。例如，你可以配置一个属性以便于快速查找。你还可以选择是否希望该属性为可选。现在，你不需要太关心索引，因为你不是通过家庭成员的姓名进行查找的，而且即使你这样做，一个家庭也不太可能有数百或数千个成员。默认情况下，**可选**复选框是勾选的。请确保取消勾选此框，因为你不想存储没有名字的家庭成员。
- en: 'Some other options you have for attributes are adding validation, adding a
    default value, and enabling indexing in Spotlight. For now, leave all those options
    at their default settings:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于属性，你还有一些其他选项，比如添加验证、添加默认值和在 Spotlight 中启用索引。现在，请保持所有这些选项在默认设置：
- en: '![Figure 8.4 – Attribute properties'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.4 – 属性属性'
- en: '](img/Figure_8.04_B14717.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.04_B14717.jpg)'
- en: Figure 8.4 – Attribute properties
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 属性属性
- en: 'In addition to a `FamilyMember` entity, `Movie` entity. Create this entity
    using the same steps as before and give it a single property: `title`. This property
    should be a string and it shouldn''t be optional. Once you''ve added this property,
    you can set up a relationship between family members and their favorite movies.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `FamilyMember` 实体外，还需要创建 `Movie` 实体。使用之前相同的步骤创建此实体，并给它一个单一的属性：`title`。这个属性应该是一个字符串，并且不应该为可选。一旦添加了这个属性，您就可以设置家庭成员和他们的最爱电影之间的关系。
- en: Defining relationships
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义关系
- en: A relationship in Core Data adds a reference as a property onto an entity. In
    this case, you want to define a relationship between `FamilyMember` and `Movie`.
    The best way to describe this relationship is a one-to-many relationship. This
    means that every movie will have only one family member associated with it and
    every family member can have multiple favorite movies.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Core Data 中，关系会将一个引用作为属性添加到实体上。在这种情况下，您想定义 `FamilyMember` 和 `Movie` 之间的关系。描述这种关系的最佳方式是一对多关系。这意味着每部电影将只有一个与之关联的家庭成员，而每个家庭成员可以有多个最喜欢的电影。
- en: Tip
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Configuring your data model with a one-to-many relationship from `Movie` to
    `FamilyMember` is not the most efficient way to define this relationship. A many-to-many
    relationship is likely a better fit because that would allow multiple family members
    to add the same movie instance as their favorite. A one-to-many relationship is
    used in this example to keep the setup simple and make it easy to follow along
    with the example.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用从 `Movie` 到 `FamilyMember` 的一对多关系配置您的数据模型并不是定义这种关系的最高效方式。多对多关系可能更适合，因为这将允许多个家庭成员将相同的电影实例添加为他们的最爱。在这个例子中，使用一对多关系是为了保持设置简单，并使跟随示例变得容易。
- en: Select the `Movie` as the destination. Don't select an `Movie` has a property
    that points back to `FamilyMember`. Make sure that you select `movies` property.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 `Movie` 作为目的地。不要选择一个 `Movie` 具有指向 `FamilyMember` 的属性。确保您选择了 `movies` 属性。
- en: 'Also, select **Cascade** as the value for **Delete Rule**:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，将 **删除规则** 的值设置为 **级联**：
- en: '![Figure 8.5 – Relationship properties'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.5 – 关系属性](img/Figure_8.05_B14717.jpg)'
- en: '](img/Figure_8.05_B14717.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.5 – 图像示例](img/Figure_8.05_B14717.jpg)'
- en: Figure 8.5 – Relationship properties
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – 关系属性
- en: '`nil`. This is the correct behavior when deleting a movie because deleting
    a movie shouldn''t delete the entire family member who added this movie as their
    favorite. It should simply be removed from the list of favorites.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`nil`。这是删除电影时的正确行为，因为删除电影不应该删除添加此电影作为他们最爱的整个家庭成员。它应该只是从最爱列表中移除。'
- en: However, if a family member is deleted and the relationship is `nullified`,
    you would end up with a bunch of movies that don't have a family member associated
    with them. In this application, these movies are worthless; they won't be used
    anymore because every movie only belongs to a single family member. For this app,
    it's desirable that when a family member gets deleted, Core Data also deletes
    their favorite movies. This is precisely what the **Cascade** option does; it
    cascades the deletion over to the relationship's inverse.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果一个家庭成员被删除并且关系被 `nullified`，您最终会有一堆没有与家庭成员关联的电影。在这个应用程序中，这些电影毫无价值；它们将不再被使用，因为每部电影只属于一个家庭成员。对于这个应用，当家庭成员被删除时，希望
    Core Data 也删除他们的最爱电影。这正是 **级联** 选项所做的；它将删除操作级联到关系的反向。
- en: 'After setting `familyMember`. The destination should be `FamilyMember` and
    the inverse for this relationship is `favoriteMovies`. After adding this relationship,
    the inverse will be automatically set on the `FamilyMember` entity:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置 `familyMember` 之后。目的地应该是 `FamilyMember`，而这个关系的反向是 `favoriteMovies`。添加这个关系后，反向将自动设置在
    `FamilyMember` 实体上：
- en: '![Figure 8.6 – Movie relationship with FamilyMember'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.6 – 电影与家庭成员的关系](img/Figure_8.06_B14717.jpg)'
- en: '](img/Figure_8.06_B14717.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.6 – 图像示例](img/Figure_8.06_B14717.jpg)'
- en: Figure 8.6 – Movie relationship with FamilyMember
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 电影与家庭成员的关系
- en: Now that we have learned how to create and establish relationships between entities
    in our model, let's start using the entities to store data in our app.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何在模型中创建和建立实体之间的关系，让我们开始使用这些实体在我们的应用中存储数据。
- en: Using your entities
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用您的实体
- en: As mentioned before, every model or entity in your Core Data database is represented
    by `NSManagedObject`. There are a couple of ways to create or generate `NSManagedObject`
    subclasses. In the simplest of setups, an `NSManagedObject` subclass contains
    just the properties for a certain managed object and nothing else. If this is
    the case, you can let Xcode generate your model classes for you.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你的 Core Data 数据库中的每个模型或实体都由 `NSManagedObject` 表示。有几种方法可以创建或生成 `NSManagedObject`
    子类。在最简单的设置中，`NSManagedObject` 子类只包含特定管理对象的属性，没有其他内容。如果情况是这样，你可以让 Xcode 为你生成模型类。
- en: 'This is actually what Xcode does by default. If you build your project now
    and add the following code to `viewDidLoad()` in `FamilyMembersViewController`,
    your project should compile just fine:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上就是 Xcode 默认所做的。如果你现在构建项目并在 `FamilyMembersViewController` 中的 `viewDidLoad()`
    中添加以下代码，你的项目应该可以顺利编译：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This works automatically; you don't have to write any code for your models yourself.
    Don't worry about what the preceding code does just yet; we'll get into that very
    soon. The point is that you see that a `FamilyMember` class exists in your project
    even though you didn't have to create one yourself.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这会自动完成；你不需要自己为模型编写任何代码。现在不必担心前面的代码做了什么；我们很快就会涉及到这一点。重点是，你看到在你的项目中存在一个 `FamilyMember`
    类，尽管你不必自己创建它。
- en: 'If the default behavior doesn''t suit the approach you want in your app – for
    instance, if you want to prevent your code from modifying your models by defining
    your variables as `private(set)` – you may want to create a custom subclass instead
    of making Xcode generate the classes for you. A custom `NSManagedObject` subclass
    for `FamilyMember` could look like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果默认行为不适合你应用程序中想要的方法——例如，如果你想通过将变量定义为 `private(set)` 来防止代码修改你的模型——你可能想创建一个自定义子类，而不是让
    Xcode 为你生成类。一个定制的 `NSManagedObject` 子类 `FamilyMember` 可能看起来像这样：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This custom `FamilyMember` subclass makes sure that any external code can't
    modify the instances by making the setters on `FamilyMember` private. Depending
    on your application, it might be a good idea to implement this since it will ensure
    that your models can't accidentally change.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定制的 `FamilyMember` 子类确保任何外部代码都不能通过将 `FamilyMember` 上的设置器设置为私有来修改实例。根据你的应用程序，这可能是一个好主意，因为它将确保你的模型不会意外更改。
- en: One final option you have is to let Xcode generate the properties for `NSManagedObject`
    as an extension on a class you define. This is particularly useful if you have
    some custom stored properties that you'd like to define on your model or if you
    have a customized `NSManagedObject` subclass that you can use as the base for
    all of your models.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你还有一个选择，就是让 Xcode 在你定义的类上扩展 `NSManagedObject` 来生成属性。如果你想在模型上定义一些自定义存储属性，或者如果你有一个定制的
    `NSManagedObject` 子类可以用作所有模型的基础，这特别有用。
- en: Tip
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: All code that Xcode generates for your Core Data models is added to the `Build`
    folder in Xcode's Derived Data. You shouldn't modify it or access it directly.
    These files will be automatically regenerated by Xcode whenever you perform a
    build, so any functionality you add inside the generated files will be overwritten.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 为你的 Core Data 模型生成的所有代码都添加到 Xcode Derived Data 的 `Build` 文件夹中。你不应该修改它或直接访问它。这些文件将在你执行构建时自动由
    Xcode 重新生成，所以你在生成的文件中添加的任何功能都将被覆盖。
- en: For the **MustC** app, it's okay if Xcode generates the model definition classes
    since there are no custom properties that you need to add. In the model editor,
    select each entity and make sure that the **Codegen** field is set to **Class
    Definition**; you can find this field in the Data Model inspector panel.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 **MustC** 应用，如果 Xcode 生成模型定义类是可以的，因为没有需要添加的自定义属性。在模型编辑器中，选择每个实体并确保 **Codegen**
    字段设置为 **类定义**；你可以在数据模型检查器面板中找到这个字段。
- en: 'At this point, you are all set up to store your first piece of data in the
    Core Data database:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经设置好了在 Core Data 数据库中存储第一条数据：
- en: '![Figure 8.7 – The Codegen attribute for entities'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.7 – 实体的 Codegen 属性'
- en: '](img/Figure_8.07_B14717.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.07_B14717.jpg)'
- en: Figure 8.7 – The Codegen attribute for entities
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – 实体的 Codegen 属性
- en: In the next section, we are going to persist data with the model and relationship
    that we just created.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用我们刚刚创建的模型和关系来持久化数据。
- en: Persisting data and reacting to data changes
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久化数据和响应数据变化
- en: "The first step to implement data persistence for your app is to make sure that\
    \ you can store data in the database. You have defined the models that you want\
    \ to store in your database, so the next step is to actually store your models.\
    \ Once you have implemented a rough version of your data persistence, you will\
    \ refine the code to make it more reusable. The final step will be to read data\
    \ from Core Data and dynamically respond to changes in \Lthe database."
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 实现你的应用数据持久化的第一步是确保你可以在数据库中存储数据。你已经定义了你想要存储在数据库中的模型，所以下一步就是实际存储你的模型。一旦你实现了数据持久化的初步版本，你将精炼代码使其更具可重用性。最后一步将是读取Core
    Data中的数据，并动态响应数据库中的变化。
- en: Understanding data persistence
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解数据持久化
- en: Whenever you want to persist a model with Core Data, you must insert a new `NSManagedObject`
    into `NSManagedObjectContext`. Doing this does not immediately persist the model.
    It merely stages the object for persistence in the current `NSManagedObjectContext`.
    If you don't properly manage your managed objects and contexts, this is a potential
    source of bugs. For example, not persisting your managed objects results in the
    loss of your data once you refresh the context. Even though this might sound obvious,
    it could lead to several hours of frustration if you aren't aware of this and
    have bugs in managing your managed object context.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你想要使用Core Data持久化一个模型时，你必须将一个新的`NSManagedObject`插入到`NSManagedObjectContext`中。这样做并不会立即持久化模型。它只是将对象放置在当前`NSManagedObjectContext`中的持久化阶段。如果你没有正确管理你的托管对象和上下文，这可能是潜在的错误来源。例如，不持久化你的托管对象会导致你在刷新上下文时丢失数据。尽管这听起来可能很显然，但如果你没有意识到这一点并且有管理托管对象上下文的错误，这可能会导致几个小时的不满。
- en: If you want to save managed objects correctly, you must tell the managed object
    context to persist its changes to the persistent store coordinator. The persistent
    store coordinator will take care of persisting the data in the underlying SQLite
    database.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要正确地保存托管对象，你必须告诉托管对象上下文将其更改持久化到持久化存储协调器。持久化存储协调器将负责在底层的SQLite数据库中持久化数据。
- en: Extra care is required when you use multiple managed object contexts. If you
    insert an object in one managed object context and persist it, you will manually
    need to synchronize the changes into the other managed object contexts. Also,
    managed objects are not thread-safe. This means that you must make sure that you
    create, access, and store a managed object on a single thread at all times. The
    managed object context has a helper method called `perform(_:)` to help you with
    this.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用多个托管对象上下文时，需要格外小心。如果你在一个托管对象上下文中插入一个对象并持久化它，你必须手动将这些更改同步到其他托管对象上下文中。此外，托管对象不是线程安全的。这意味着你必须确保始终在一个单独的线程上创建、访问和存储托管对象。托管对象上下文有一个名为`perform(_:)`的辅助方法，可以帮助你完成这项工作。
- en: Inserting new objects, updating them, or adding relationships between objects
    should always be done using the `perform(_:)` method. The reason is that the helper
    method makes sure that all the code in the closure you want to perform is executed
    on the same thread that the managed object context is on.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 插入新对象、更新它们或添加对象之间的关系时，应始终使用`perform(_:)`方法。原因是这个辅助方法确保你想要执行的闭包中的所有代码都在托管对象上下文所在的同一线程上执行。
- en: Now that you're aware of how data persistence works in Core Data, it's time
    to start implementing the code to store family members and their favorite movies.
    You will implement the family member persistence first. Then, you'll expand the
    app so that you can safely add movies to family members.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经了解了Core Data中数据持久化的工作原理，现在是时候开始编写代码来存储家庭成员及其最喜欢的电影了。你将首先实现家庭成员的持久化。然后，你将扩展应用，以便你可以安全地为家庭成员添加电影。
- en: Persisting your models
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久化你的模型
- en: The first model you will persist is the family member model. The app is already
    set up with a form that asks for a family member name and a delegate protocol
    that informs `FamilyMembersViewController` whenever the user wants to store a
    new family member.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要持久化的第一个模型是家庭成员模型。应用已经设置了一个表单，要求输入家庭成员的姓名，以及一个委托协议，每当用户想要存储一个新的家庭成员时，都会通知`FamilyMembersViewController`。
- en: Note that none of the input data is validated; usually, you'd want to add some
    checks that make sure that the user is not trying to insert an empty family member
    name, for instance. For now, we'll skip that because this type of validation isn't
    Core Data-specific.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，输入数据没有任何验证；通常，你希望添加一些检查以确保用户没有尝试插入一个空的家族成员名称，例如。目前，我们将跳过这一点，因为这种验证不是Core
    Data特有的。
- en: 'The code to persist new family members should be added to the `saveFamilyMember(withName:)`
    method. Add the following implementation to `FamilyMembersViewController`; we''ll
    go over it line by line after adding the code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将持久化新家族成员的代码添加到`saveFamilyMember(withName:)`方法中。向`FamilyMembersViewController`添加以下实现；在添加代码后，我们将逐行分析它：
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first comment in this code marks where the managed object context is extracted
    from `persistentContainer`. All `NSPersistentContainer` objects have a `viewContext`
    property. This property is used to obtain a managed object context that exists
    on the main thread.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中的第一条注释标记了从`persistentContainer`中提取托管对象上下文的位置。所有`NSPersistentContainer`对象都有一个`viewContext`属性。这个属性用于获取存在于主线程上的托管对象上下文。
- en: The second comment marks the call to `perform(_:)`. This ensures that the new
    `FamilyMember` instance is created and stored on the correct thread.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条注释标记了对`perform(_:)`的调用。这确保了新的`FamilyMember`实例被创建并存储在正确的线程上。
- en: The third comment marks where we create a `familyMember` instance inside our
    managed object context (`moc`) and we update its name. When you create an instance
    of a managed object, you must provide the managed object context where the instance
    will be temporarily stored.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第三条注释标记了我们在托管对象上下文（`moc`）内部创建一个`familyMember`实例并更新其名称的位置。当你创建一个托管对象实例时，你必须提供实例将临时存储的托管对象上下文。
- en: Lastly, saving the managed object context can fail, so you must wrap the `to
    save()` call in a `do {} catch {}` block, so it correctly handles potential errors.
    If the managed object context can't be saved, all unsaved changes are rolled back.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，保存托管对象上下文可能会失败，因此你必须将`to save()`调用包裹在`do {} catch {}`块中，以便它正确处理潜在的错误。如果托管对象上下文无法保存，所有未保存的更改都将回滚。
- en: This code is all you need to persist family members. Before you implement the
    required code to read existing family members and respond to the insertion of
    new family members, let's set up `MoviesViewController` so that it can store movies
    for a family member.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码就是你需要的所有代码来持久化家族成员。在你实现读取现有家族成员和响应新家族成员插入所需的代码之前，让我们设置`MoviesViewController`，使其能够为家族成员存储电影。
- en: 'The code to store movies for a family member is very similar to the code you
    wrote previously. Before you implement the following snippets, make sure that
    in the `MoviesViewController` file, you add `import CoreData`. Also, add a `persistentContainer`
    property to `MoviesViewController`, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 存储家族成员电影的代码与你之前编写的代码非常相似。在实现以下代码片段之前，请确保在`MoviesViewController`文件中添加`import
    CoreData`。此外，向`MoviesViewController`添加一个`persistentContainer`属性，如下所示：
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In order to connect a new movie to a family member, you also need a variable
    to hold the family member in `MoviesViewController`. Add the following declaration
    to `MoviesViewController`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将一部新电影与家族成员关联，你还需要一个变量在`MoviesViewController`中持有家族成员。向`MoviesViewController`添加以下声明：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After doing this, add the following implementation for `saveMovie(withName:)`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成此操作后，为`saveMovie(withName:)`添加以下实现：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The most important differences between adding the movie and the family member
    are highlighted with comments. Note that the `movies` property on a family member
    is `NSSet`. This is an immutable object, so you need to create a copy and add
    the movie to that copy. If no copy could be made because there is no set created
    yet, you can create a new set with the new movie in it. Next, this new, updated
    set is converted back to an `NSSet` instance so that it can be the new value for
    movies.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过注释突出显示了添加电影和家族成员之间最重要的差异。请注意，家族成员上的`movies`属性是`NSSet`。这是一个不可变对象，因此你需要创建一个副本并将电影添加到该副本中。如果无法创建副本，因为没有创建集合，你可以创建一个新的包含新电影的集合。接下来，将这个新的、更新的集合转换回`NSSet`实例，以便它可以成为`movies`的新值。
- en: As you can see, both save methods share about half of the implementation. You
    can make some clever use of extensions and generics in Swift to avoid writing
    this duplicated code. Let's refactor the app a bit.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这两个保存方法共享大约一半的实现。你可以巧妙地使用Swift中的扩展和泛型来避免编写重复的代码。让我们对应用程序进行一点重构。
- en: Important Note
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Notice how we have used `viewContext` for persisting data (in both the `saveFamilyMember`
    and `saveMovie` methods). For this example, it will work perfectly fine, because
    we are not doing any heavy tasks. But `viewContext` is associated with the main
    queue of the application, so it is not good practice to do any work with it that
    can block the UI (such as persisting a large amount of data). In the last section
    of this chapter, we will refactor this code by creating a private context that
    works in a background thread. We will persist data in the background and read
    changes from `viewContext` in the main thread. By using two different contexts,
    one in the background and one in the main thread, we will follow best practices
    and ensure we don't block the UI while persisting data.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何使用`viewContext`来持久化数据的（在`saveFamilyMember`和`saveMovie`方法中）。对于这个例子，它会非常完美，因为我们没有进行任何重任务。但是`viewContext`与应用程序的主队列相关联，因此不推荐使用它执行可能阻塞UI的工作（例如持久化大量数据）。在本章的最后部分，我们将通过创建一个在后台线程中工作的私有上下文来重构此代码。我们将在后台持久化数据，并在主线程中从`viewContext`读取更改。通过使用两个不同的上下文，一个在后台，一个在主线程，我们将遵循最佳实践，确保在持久化数据时不会阻塞UI。
- en: Refactoring the persistence code
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构持久化代码
- en: Many iOS developers dislike the amount of boilerplate code that is involved
    with using Core Data. Simply persisting an object requires you to repeat several
    lines of code, which can become quite a pain to write and maintain over time.
    The approach to refactoring the persistence code presented in the following examples
    is heavily inspired by the approach taken in the *Core Data* book written by *Florian
    Kugler* and *Daniel Eggert*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 许多iOS开发者不喜欢使用Core Data时涉及的样板代码量。简单地持久化一个对象就需要你重复编写几行代码，这可能会随着时间的推移变得相当痛苦，难以编写和维护。以下示例中展示的重构持久化代码的方法深受由Florian
    Kugler和Daniel Eggert合著的*Core Data*一书中采用的方法的启发。
- en: Tip
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you're interested in learning more about Core Data outside of what this book
    covers, and if you'd like to see more clever ways to reduce the amount of boilerplate
    code, you should pick up *Core Data* by *Kugler* and *Eggert*..
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解关于Core Data的更多内容，超出本书所涵盖的范围，并且想要看到更多减少样板代码的巧妙方法，你应该阅读由Kugler和Eggert合著的*Core
    Data*。
- en: 'After creating the code blocks to save `familyMember` and `familyMember.movies`
    instances into Core Data, use the following pattern:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建代码块以将`familyMember`和`familyMember.movies`实例保存到Core Data之后，使用以下模式：
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, it would be great if you could write the following code to persist data
    instead, reducing the duplicated code every time you save an object:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你能编写以下代码来持久化数据，将每次保存对象时重复的代码减少到最小，那将非常棒：
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This can be achieved by writing an extension for `NSManagedObjectContext`.
    Add a file called `NSManagedObjectContext` to the extensions folder, and add the
    following implementation:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过为`NSManagedObjectContext`编写一个扩展来实现。在扩展文件夹中添加一个名为`NSManagedObjectContext`的文件，并添加以下实现：
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding code allows you to reduce the amount of boilerplate code, which
    is something that you should always try to achieve. Reducing boilerplate code
    greatly improves your code's readability and maintainability. Update both the
    family overview and the movie list view controllers to make use of this new persistence
    method.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码允许你减少样板代码的数量，这是你应该始终努力实现的目标。减少样板代码极大地提高了代码的可读性和可维护性。更新家庭概览和电影列表视图控制器以利用这种新的持久化方法。
- en: After optimizing our code to save entities in Core Data with the preceding trick,
    now let's see how to read data, making use of `NSFetchRequest`, which allows us
    to query data in a simple and effective way.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用前面的技巧优化了使用Core Data保存实体后的代码后，现在让我们看看如何读取数据，利用`NSFetchRequest`，它允许我们以简单有效的方式查询数据。
- en: Reading data with a simple fetch request
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用简单的获取请求读取数据
- en: The simplest way to fetch data from your database is to use a fetch request.
    The managed object context forwards fetch requests to the persistent store coordinator.
    The persistent store coordinator will then forward the request to the persistent
    store, which will then convert the request into a SQLite query. Once the results
    are fetched, they are passed back up this chain and converted into `NSManagedObject`
    instances.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据库中获取数据的最简单方法是使用获取请求。管理对象上下文将获取请求转发给持久存储协调器。然后，持久存储协调器将请求转发给持久存储，持久存储将请求转换为SQLite查询。一旦获取到结果，它们将通过这个链路返回，并转换为`NSManagedObject`实例。
- en: By default, these objects are called faults. When an object is a fault, it means
    that the actual properties and values for the object are not fetched yet, but
    they will be fetched once you access them. This is an example of a good implementation
    of lazy variables because fetching the values is a pretty fast operation, and
    fetching everything upfront would greatly increase your app's memory footprint
    because all values would have to be loaded into the app's memory right away.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这些对象被称为故障。当一个对象是故障时，这意味着该对象的实际属性和值尚未获取，但一旦你访问它们，它们将会被获取。这是一个良好实现懒变量的例子，因为获取值是一个相当快速的操作，而一次性获取所有内容将大大增加你的应用程序的内存占用，因为所有值都必须立即加载到应用程序的内存中。
- en: 'Let''s take a look at an example of a simple fetch request that retrieves all
    `FamilyMember` instances that were saved to the database:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的获取请求的例子，该请求检索所有已保存到数据库中的 `FamilyMember` 实例：
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, it's not particularly hard to fetch all of your family members.
    Every `NSManagedObject` instance has a class method that configures a basic fetch
    request that can be used to retrieve data. If you have large amounts of data,
    you probably don't want to fetch all of the persisted objects at once. You can
    configure your fetch request to fetch data in batches by setting the `fetchBatchSize`
    property. It's recommended that you use this property whenever you want to use
    fetched data in a table view or collection view. You should set the `fetchBatchSize`
    property to a value that is just a bit higher than the number of cells you expect
    to display at a time. This makes sure that Core Data fetches plenty of items to
    display while avoiding loading everything at once.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，获取所有家庭成员并不特别困难。每个 `NSManagedObject` 实例都有一个类方法，可以配置一个基本的获取请求，用于检索数据。如果你有大量数据，你可能不想一次性获取所有持久化的对象。你可以通过设置
    `fetchBatchSize` 属性来配置你的获取请求以分批获取数据。建议你每次想在表格视图或集合视图中使用获取的数据时都使用这个属性。你应该将 `fetchBatchSize`
    属性设置为一个略高于你预期一次显示的单元格数量的值。这确保了 Core Data 获取足够多的项目来显示，同时避免了一次性加载所有内容。
- en: 'Now that you know how to fetch data, let''s display some data in the family
    members table view. Add a new variable called `familyMembers` to `FamilyMembersViewController`.
    Give this property an initial value of `[FamilyMember]()` so that you start off
    with an empty array of family members. Also, add the example fetch request you
    saw earlier to `viewDidLoad()`. Next, assign the result of the fetch request to
    `familyMembers`, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何获取数据，让我们在家庭成员表格视图中显示一些数据。在 `FamilyMembersViewController` 中添加一个名为 `familyMembers`
    的新变量。给这个属性一个初始值 `[FamilyMember]()`，这样你就可以从一个空的家庭成员数组开始。此外，将你之前看到的示例获取请求添加到 `viewDidLoad()`
    中。接下来，将获取请求的结果分配给 `familyMembers`，如下所示：
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, update the table view delegate methods so that `tableView(_:numberOfRowsInSection:)`
    returns the number of items in the `familyMembers` array:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新表格视图代理方法，以便 `tableView(_:numberOfRowsInSection:)` 返回 `familyMembers` 数组中的项目数：
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Also, update the `tableView(_:cellForRowAtIndexPath:)` method by adding the
    following two highlighted lines before returning the cell:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，更新 `tableView(_:cellForRowAtIndexPath:)` 方法，在返回单元格之前添加以下两个突出显示的行：
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you build and run your app now, you should see the family members you already
    saved. New family members won't show up right away. However, when you quit the
    app and run it again, new members will show up.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在构建并运行你的应用，你应该能看到你已经保存的家庭成员。新的家庭成员不会立即显示。然而，当你退出应用并再次运行它时，新的成员将会出现。
- en: 'You could manually reload the table view right after you insert a new family
    member so that it''s always up to date, but this isn''t the best approach. You
    will see a better way to react to the insertion of new data soon. Let''s finish
    the family member detail view first so that it shows a family member''s favorite
    movies. Add the following code to the end of the `prepare(for:sender:)` method
    in the `FamilyMembersViewController` view controller:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在插入新的家庭成员后手动重新加载表格视图，以确保它始终是最新的，但这不是最佳方法。你很快就会看到一种更好的方法来响应新数据的插入。首先让我们完成家庭成员详细视图，以便它显示家庭成员的最爱电影。将以下代码添加到
    `FamilyMembersViewController` 视图控制器中的 `prepare(for:sender:)` 方法的末尾：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The method should look like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 方法应该看起来像这样：
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding lines of code pass the selected family member and the persistent
    container to `MoviesViewController` so that it can display and store the current
    family member's favorite movies.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将选定的家庭成员和持久容器传递给 `MoviesViewController`，以便它可以显示和存储当前家庭成员的最爱电影。
- en: 'All you need to do to show the correct movies for a family member is to use
    the family member''s favorite movies in the `MovieViewController` table view data
    source methods, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你要做的只是使用家庭成员的最爱电影在 `MovieViewController` 表视图数据源方法中显示正确的电影，如下所示：
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You don't need to use a fetch request here because you can simply traverse the
    `movies` relationship on the family member to get their favorite movies. This
    isn't just convenient for you as a developer, it's also good for your app's performance.
    Every time you use a fetch request, you force a query to the database. If you
    traverse a relationship, Core Data will attempt to fetch the object from memory
    instead of asking the database.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里不需要使用获取请求，因为你可以直接遍历家庭成员上的 `movies` 关系来获取他们的最爱电影。这不仅对你作为开发者来说很方便，而且对你的应用程序性能也有好处。每次你使用获取请求时，你都会强制对数据库进行查询。如果你遍历一个关系，Core
    Data 将尝试从内存中获取对象而不是请求数据库。
- en: Again, adding new data won't immediately trigger the table view to update its
    contents. We'll get to that after we take a look at how to filter data. If you
    want to check whether your code works, build and rerun the app so that all the
    latest data is fetched from the database. Now that we know how to query from Core
    Data, let's perform smarter queries by filtering the retrieved data, with the
    help of the `NSPredicate` class.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，添加新数据不会立即触发表视图更新其内容。我们将在查看如何过滤数据之后讨论这个问题。如果你想检查你的代码是否工作，构建并重新运行应用程序，以便从数据库中获取所有最新的数据。现在我们知道了如何从
    Core Data 中查询，让我们通过使用 `NSPredicate` 类来过滤检索到的数据来执行更智能的查询。
- en: Filtering data with predicates
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用谓词过滤数据
- en: A typical operation you'll want to perform on your database is filtering. In
    Core Data, you use predicates to do this. A **predicate** describes a set of rules
    that any object that gets fetched has to match.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在数据库上执行的一个典型操作是过滤。在 Core Data 中，你使用谓词来做这件事。**谓词**描述了一组规则，任何被检索的对象都必须符合这些规则。
- en: When you model your data in the model editor, it's wise to think about the types
    of filtering you need to do. For instance, you may be building a birthday calendar
    where you'll often sort or filter by date. If this is the case, you should make
    sure that you have a Core Data index for this property. You can enable indexing
    with the checkbox you saw earlier in the model editor. If you ask Core Data to
    index a property, it will significantly improve performance when filtering and
    selecting data in large datasets.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在模型编辑器中建模你的数据时，考虑你需要进行的过滤类型是明智的。例如，你可能正在构建一个生日日历，你经常会按日期排序或过滤。如果是这种情况，你应该确保你有这个属性的
    Core Data 索引。你可以通过模型编辑器中之前看到的复选框来启用索引。如果你要求 Core Data 索引一个属性，它将显著提高在大数据集中过滤和选择数据时的性能。
- en: 'Writing predicates can be confusing, especially if you try to think of them
    as the `WHERE` clause from SQL. Predicates are very similar, but they''re not
    quite the same. A simple predicate looks as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 编写谓词可能会让人感到困惑，尤其是当你试图把它们想象成 SQL 中的 `WHERE` 子句时。谓词非常相似，但它们并不完全相同。一个简单的谓词看起来如下所示：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: A predicate has a format; this format always starts with a key. This key represents
    the property you want to match with. In this example, it would be the name of
    a family member. Then, you specify the condition – for instance, `==, >, <, or
    CONTAINS[n]`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 谓词有一个格式；这个格式总是从一个键开始。这个键代表你想要匹配的属性。在这个例子中，它将是家庭成员的名字。然后，你指定条件——例如，`==, >, <,
    或 CONTAINS[n]`。
- en: There are more conditions available, but the ones listed are some examples of
    conditions you'll commonly use. Finally, you will specify a placeholder that is
    substituted with the true value. This placeholder is `%@` in the preceding example.
    If you have written any Objective-C before you picked up this book, the `%@` placeholder
    might look familiar to you because it's used as a placeholder in format strings
    there.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有更多条件可用，但列出的这些是一些你将常用到的条件的例子。最后，你将指定一个占位符，该占位符将被真实值替换。在上一个例子中，这个占位符是 `%@`。如果你在拿起这本书之前写过任何
    Objective-C，`%@` 占位符可能对你来说很熟悉，因为它在格式字符串中用作占位符。
- en: The example predicate is very simple and bare; it could be the template for
    a search feature you're building. Usually, a simple search doesn't have to be
    much more complicated than this as long as there's an index added to the properties
    you search for.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 示例谓词非常简单且简洁；它可以成为你正在构建的搜索功能的模板。通常，只要在搜索的属性中添加索引，简单的搜索就不需要比这更复杂。
- en: If you have multiple predicates you want to match on, you can combine them using
    `NSCompoundPredicate`. This class combines different predicates using either an
    `and`, `or`, or `not` clause. A typical use case for this approach is when you
    build a complex filter in your app where the predicate is hard to express in a
    single statement.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要匹配多个谓词，你可以使用 `NSCompoundPredicate` 将它们组合起来。这个类使用 `and`、`or` 或 `not` 子句来组合不同的谓词。这种方法的典型用例是在你的应用中构建一个复杂的过滤器，其中谓词难以用单个语句表达。
- en: To use a predicate in a fetch request, you assign it to the `predicate` property
    of a fetch request. Every fetch request has a `predicate` property that you can
    set. It can handle both a single predicate and a compound predicate. If you set
    this property before executing the fetch request, the predicate is applied to
    the request, and you will receive a filtered dataset instead of the full dataset.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要在获取请求中使用谓词，你将其分配给获取请求的 `predicate` 属性。每个获取请求都有一个 `predicate` 属性，你可以设置它。它可以处理单个谓词和复合谓词。如果你在执行获取请求之前设置此属性，谓词将应用于请求，你将收到一个过滤后的数据集而不是完整的数据集。
- en: Predicates are powerful, and they have many options available.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 谓词非常强大，并且有很多可用的选项。
- en: Tip
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you're interested in an in-depth overview of predicates and all of the ways
    in which you can make use of format strings, I recommend that you read *Apple's
    Predicate Programming Guide* at [http://apple.co/2fF3qHc](http://apple.co/2fF3qHc).
    It provides a well-documented overview of predicates and their applications.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要深入了解谓词以及你可以使用格式字符串的所有方式，我建议你阅读 *Apple 的谓词编程指南*，网址为 [http://apple.co/2fF3qHc](http://apple.co/2fF3qHc)。它提供了对谓词及其应用的详细概述。
- en: Next up, you will learn how to respond to changes in the managed object context
    – for instance, when you add new family members and movies.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将学习如何响应托管对象上下文中的更改——例如，当你添加新的家庭成员和电影时。
- en: Reacting to database changes
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应数据库更改
- en: In its current state, the **MustC** app doesn't update its list when a new managed
    object is persisted. One possible solution for this is to manually reload the
    table right after a new family member is inserted. Although this might work well
    for some time, it's not the best solution to this problem. If the app grows, you
    might add functionality that imports new family members from the network. Manually
    refreshing the table view would be problematic because the networking logic should
    not be aware of the table view. Luckily, there is a better solution to react to
    changes in your data.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前状态下，**MustC** 应用在持久化新的托管对象时不会更新其列表。一个可能的解决方案是在插入新的家庭成员后手动重新加载表格。虽然这可能在一段时间内工作得很好，但这并不是解决这个问题的最佳方案。如果应用增长，你可能会添加从网络导入新家庭成员的功能。手动刷新表视图会有问题，因为网络逻辑不应该知道表视图。幸运的是，有一个更好的解决方案来响应数据更改。
- en: One way to respond to database changes is by using `NSFetchedResultsController`.
    This class is perfect for listening to the insertion of new family members. You
    will implement this approach in `FamilyMembersViewController`. A second way to
    respond to updates is through notifications. You will implement this approach
    in `MoviesViewController`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 响应数据库更改的一种方式是使用 `NSFetchedResultsController`。这个类非常适合监听新家庭成员的插入。你将在 `FamilyMembersViewController`
    中实现这种方法。响应更新的第二种方式是通过通知。你将在 `MoviesViewController` 中实现这种方法。
- en: Implementing NSFetchedResultsController
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现 NSFetchedResultsController
- en: '`NSFetchedResultsController` is a helper class that specializes in fetching
    data and managing this data. It listens to changes in its managed object context
    and notifies a delegate whenever the data it has fetched changes. This is incredibly
    helpful because it allows you to respond to specific changes in the dataset rather
    than reloading the table view entirely.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSFetchedResultsController` 是一个专门用于获取数据和管理工作数据的辅助类。它监听其托管对象上下文中的更改，并在获取的数据发生变化时通知代理。这非常有帮助，因为它允许你响应数据集中的特定更改，而不是完全重新加载表视图。'
- en: 'Being a delegate for the fetched results controller involves the following
    important methods:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 作为获取结果控制器的代理涉及以下重要方法：
- en: '`controllerWillChangeContent(_:)` is called right before the controller passes
    updates to the delegate. If you''re using a table view with a fetched-results
    controller, this is the perfect method to begin updating the table view.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`controllerWillChangeContent(_:)` 在控制器将更新传递给代理之前被调用。如果你使用带有获取结果控制器的表格视图，这是一个开始更新表格视图的完美方法。'
- en: '`controller(_:didChange:at:for:newIndexPath:)` and `controller(_:didChange:atSectionIndex:for:)`
    are called to inform the delegate about updates to the fetched items and sections,
    respectively. This is where you should handle updates in the fetched data. For
    instance, you could insert new rows in a table view if new items were inserted
    in the dataset.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`controller(_:didChange:at:for:newIndexPath:)` 和 `controller(_:didChange:atSectionIndex:for:)`
    被调用以通知代理关于获取项和部分的更新。这是处理获取数据更新的地方。例如，如果数据集中插入了新项，你可以在表格视图中插入新行。'
- en: '`controllerDidChangeContent(_:)` is called. This is the point where you should
    let the table view know that you''ve finished processing the updates so that all
    the updates can be applied to the table view''s interface.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`controllerDidChangeContent(_:)` 被调用。这是你应该让表格视图知道你已经完成处理更新的地方，以便所有更新都可以应用到表格视图的界面中。'
- en: For `MustC`, it doesn't make sense to implement all four methods because the
    table view that shows family members only has a single section. This means `controller(_:didChange:atSectionIndex:for:)`
    does not have to be implemented.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `MustC`，由于显示家庭成员的表格视图只有一个部分，因此实现所有四个方法没有意义。这意味着不需要实现 `controller(_:didChange:atSectionIndex:for:)`。
- en: 'To use a fetched-results controller to fetch the stored family members, you
    need to create an instance of `NSFetchedResultsController` and assign `FamilyMembersViewController`
    as its delegate so that it can respond to changes in the underlying data. You
    can then implement the delegate methods so that you can respond to changes in
    the fetched-results dataset. Remove the `familyMembers` array from the variable
    declarations in `FamilyMembersViewController` and add the following `fetchedResultsController`
    property:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用获取结果控制器获取存储的家庭成员，你需要创建一个 `NSFetchedResultsController` 实例，并将 `FamilyMembersViewController`
    作为其代理，以便它可以响应底层数据的变化。然后你可以实现代理方法，以便你可以响应获取结果数据集的变化。从 `FamilyMembersViewController`
    的变量声明中删除 `familyMembers` 数组，并添加以下 `fetchedResultsController` 属性：
- en: '[PRE23]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `viewDidLoad` method should be adjusted as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewDidLoad` 方法应该调整如下：'
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This implementation initializes `NSFetchedResultsController`, assigns its delegate,
    and tells it to execute the fetch request. Note that the `sortDescriptors` property
    of the fetch request is set to an array that contains `NSSortDescriptor`. A fetched-request
    controller requires this property to be set, and for the list of family members,
    it makes sense to order family members by name.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现初始化 `NSFetchedResultsController`，分配其代理，并告诉它执行获取请求。请注意，获取请求的 `sortDescriptors`
    属性设置为包含 `NSSortDescriptor` 的数组。获取请求控制器需要设置此属性，对于家庭成员列表，按姓名排序家庭成员是有意义的。
- en: 'Now that you have a fetched-results controller, you should implement the delegate
    methods on `FamilyMembersViewController` and make it conform to `NSFetchedResultsControllerDelegate`.
    Add the following extension to `FamilyMembersViewController.swift`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了获取结果控制器，你应该在 `FamilyMembersViewController` 上实现代理方法，并使其符合 `NSFetchedResultsControllerDelegate`。将以下扩展添加到
    `FamilyMembersViewController.swift`：
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The implementation of this extension is fairly straightforward. The table view
    gets notified when the fetched-result controller is about to process changes to
    its data and when the fetched-results controller is done processing changes. The
    bulk of the work needs to be done in `controller(_:didChange:at:for:newIndexPath)`.
    This method is called when an update has been processed by the fetched-result
    controller. In `MustC`, the goal is to update a table view, but you could also
    update a collection view or store all of the updates in a list and do something
    else with them.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此扩展的实现相当直接。当获取结果控制器即将处理其数据的更改时，表格视图会收到通知，当获取结果控制器完成处理更改时，表格视图也会收到通知。大部分工作需要在
    `controller(_:didChange:at:for:newIndexPath)` 中完成。此方法在获取结果控制器处理更新后被调用。在 `MustC`
    中，目标是更新表格视图，但你也可以更新集合视图或将所有更新存储在列表中并对其进行其他处理。
- en: 'Let''s take a look at how you can process changes to fetched data in the following
    method. Add it to the extension on `FamilyMembersViewController.swift`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你如何在以下方法中处理获取数据的更改。将其添加到 `FamilyMembersViewController.swift` 的扩展中：
- en: '[PRE26]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This method contains quite a lot of code, but it''s actually not that complex.
    The preceding method receives a type parameter. This parameter is an instance
    of `NSFetchedResultsChangeType`, which contains information about the kind of
    update that was received. The following are the four types of updates that can
    occur:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法包含了很多代码，但实际上并不复杂。前面的方法接收一个类型参数。这个参数是 `NSFetchedResultsChangeType` 的一个实例，它包含有关接收到的更新类型的信息。以下是可以发生的四种更新类型：
- en: Insert
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入
- en: Delete
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除
- en: Move
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动
- en: Update
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新
- en: Each of these change types corresponds to a database action. If an object was
    inserted, you will receive an insert change type. The proper way to handle these
    updates for `MustC` is to simply pass them on to the table view. Once all the
    updates are received, the table view will apply all of these updates at once.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改类型中的每一个都对应于一个数据库操作。如果一个对象被插入，你会收到一个插入更改类型。对于 `MustC` 来说，处理这些更新的正确方式是简单地将它们传递给表格视图。一旦收到所有更新，表格视图将一次性应用所有这些更新。
- en: 'If you had implemented `controller(_:didChange:atSectionIndex:for:)` as well,
    it would also have received a `change` type; however, the sections only deal with
    the following two types of changes:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你同时实现了 `controller(_:didChange:atSectionIndex:for:)`，它也会收到一个 `change` 类型的通知；然而，章节只处理以下两种类型的更改：
- en: Insert
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入
- en: Delete
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除
- en: Sections don't update or move, so if you implement this method, you don't have
    to account for all cases because you won't encounter any, other than the two listed
    types of changes.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 章节不会更新或移动，所以如果你实现这个方法，你不需要考虑所有情况，因为你不会遇到任何，除了列出的两种更改类型。
- en: If you take a close look at the implementation for `controller(_:didChange:at:for:newIndexPath)`,
    you'll notice that it receives two index paths. One is named `indexPath`, and
    the other is named `newIndexPath`. They're both optional, so you will need to
    make sure that you safely unwrap them if you use them. For new objects, only the
    `newIndexPath` property will be present. For delete and update, the `indexPath`
    property will be set. When an object is moved from one place in the dataset to
    another, both `newIndexPath` and `indexPath` will have a value.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细查看 `controller(_:didChange:at:for:newIndexPath)` 的实现，你会注意到它接收两个索引路径。一个是
    `indexPath`，另一个是 `newIndexPath`。它们都是可选的，所以如果你使用它们，你需要确保安全地解包它们。对于新对象，只有 `newIndexPath`
    属性将存在。对于删除和更新，`indexPath` 属性将被设置。当一个对象从数据集中的一个位置移动到另一个位置时，`newIndexPath` 和 `indexPath`
    都将有一个值。
- en: 'The last thing you need to do is update the code in `FamilyMembersViewController`
    so that it uses the fetched results controller instead of the `familyMembers`
    array that it used earlier. First, update the `prepare(for:sender:)` method, as
    follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的最后一件事是更新 `FamilyMembersViewController` 中的代码，使其使用获取结果控制器而不是它之前使用的 `familyMembers`
    数组。首先，更新 `prepare(for:sender:)` 方法，如下所示：
- en: '[PRE27]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This makes sure that a valid family member is passed to the `movies` view controller.
    Update the table view data source methods, as shown in the following code. A fetched-results
    controller can retrieve objects based on an index path. This makes it a great
    fit to use in combination with table views and collection views:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了一个有效的家族成员被传递给 `movies` 视图控制器。更新表格视图数据源方法，如下所示。一个获取结果的控制器可以根据索引路径检索对象。这使得它非常适合与表格视图和集合视图一起使用：
- en: '[PRE28]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you run your app now, the interface updates automatically when you add a
    new family member to the database. However, the list of favorite movies doesn't
    update yet. That page does not use a fetched-results controller, so it must listen
    to changes to the dataset directly.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行你的应用，当你向数据库中添加一个新的家族成员时，界面会自动更新。然而，最喜欢的电影列表还没有更新。那个页面没有使用获取结果的控制器，所以它必须直接监听数据集的变化。
- en: The reason `MoviesViewController` doesn't use a fetched-results controller for
    the movie list is that fetched-result controllers will always need to drop down
    all the way to your persistent store (SQLite in this app). As mentioned before,
    querying the database has a significant memory overhead compared to traversing
    the relationship between family members and their movies; it's much faster to
    read the `movies` property than fetching them from the database.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`MoviesViewController` 不使用获取结果控制器来处理电影列表的原因是，获取结果控制器始终需要下降到你的持久存储（在这个应用中是 SQLite）。如前所述，与遍历家族成员及其电影之间的关系相比，查询数据库有显著的内存开销；读取
    `movies` 属性比从数据库中获取它们要快得多。'
- en: Whenever a managed object context changes, a notification is posted to the default
    `NotificationCenter`. `NotificationCenter` is used to send events inside of an
    app so that other parts of the code can react to those events.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 每当托管对象上下文发生变化时，都会向默认的`NotificationCenter`发布一个通知。`NotificationCenter`用于在应用程序内部发送事件，以便其他部分的代码可以对这些事件做出反应。
- en: Information
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: It can be very tempting to use notifications instead of delegates, especially
    if you're coming from a background that makes heavy use of events, such as JavaScript.
    Don't do this; delegation is better suited to most cases, and it will make your
    code much more maintainable. Only use notifications if you don't care who's listening
    to your notifications or if setting up a delegate relationship between objects
    would mean you'd create very complex relationships between unrelated objects just
    to set up the delegation.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用通知而非委托可能会很有吸引力，尤其是如果你来自一个大量使用事件的环境，比如JavaScript。不要这样做；委托更适合大多数情况，并且会使你的代码更加易于维护。只有在你不在乎谁在监听你的通知，或者设置委托关系会意味着你只是为了设置委托而创建非常复杂的不相关对象之间的关系时，才使用通知。
- en: 'Let''s subscribe `MoviesViewController` to changes in the managed object context
    so that it can respond to data changes if needed. Before you implement this, add
    the following method, which should be called when changes in the managed object
    context occur:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们订阅`MoviesViewController`对托管对象上下文变化的更改，以便在需要时能够响应数据变化。在你实现这个功能之前，添加以下方法，该方法应在托管对象上下文发生变化时被调用：
- en: '[PRE29]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This method reads the notification's `userInfo` dictionary to access the information
    that's relevant to the current list. You're interested in changes to the current
    `familyMember` object because when this object changes, you can be pretty sure
    that a new movie was just inserted. The `userInfo` dictionary contains keys for
    the inserted, deleted, and updated objects. In this case, you should look for
    the updated objects because users can't delete or insert new family members in
    this view. If the family member was updated, the table view is reloaded so that
    it shows the new data.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法读取通知的`userInfo`字典以访问与当前列表相关的信息。你对当前`familyMember`对象的变化感兴趣，因为当这个对象发生变化时，你可以相当肯定地认为刚刚插入了一个新的电影。`userInfo`字典包含插入、删除和更新对象的键。在这种情况下，你应该寻找更新对象，因为用户不能在此视图中删除或插入新的家庭成员。如果家庭成员被更新，表格视图将被重新加载以显示新数据。
- en: 'The following code subscribes `MoviesViewController` to changes in the persistent
    container''s managed object context:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将`MoviesViewController`订阅到持久容器中托管对象上下文的变化：
- en: '[PRE30]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When the view loads, the current `MoviesViewController` instance is added as
    an observer to the `.NSManagedObjectContextObjectsDidChange` notification. Go
    ahead and build your app; you should now see the user interface update whenever
    you add new data to your database.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当视图加载时，当前的`MoviesViewController`实例被添加为`.NSManagedObjectContextObjectsDidChange`通知的观察者。继续构建你的应用程序；现在你应该看到每当你在数据库中添加新数据时，用户界面都会更新。
- en: 'In this section, we learned how to respond to database changes using two different
    methods: `NSFetchedResultsController` and notifications. In the next section,
    we are going to learn how to manage multiple instances of `NSManagedObjectContext`
    in order to improve the user interface response when dealing with heavy tasks.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用两种不同的方法来响应数据库变化：`NSFetchedResultsController`和通知。在下一节中，我们将学习如何管理多个`NSManagedObjectContext`实例，以提高处理重任务时的用户界面响应。
- en: Understanding the use of multiple instances of NSManagedObjectContext
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解使用多个NSManagedObjectContext实例
- en: It has been mentioned several times in this chapter that you can use multiple
    managed object contexts. In many cases, you will only need a single managed object
    context. Using a single managed object context means that all of the code related
    to the managed object context is executed on the main thread. If you're performing
    small operations, that's fine. However, imagine importing large amounts of data.
    An operation such as that could take a while. Executing code that runs for a while
    on the main thread will cause the user interface to become unresponsive. This
    is not good, because the user will think your app has crashed. So, how do you
    work around this? The answer is using multiple managed object contexts.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中多次提到，你可以使用多个托管对象上下文。在许多情况下，你可能只需要一个托管对象上下文。使用单个托管对象上下文意味着与托管对象上下文相关的所有代码都在主线程上执行。如果你执行的是小型操作，那没问题。然而，想象一下导入大量数据的情况。这样的操作可能需要一段时间。在主线程上执行长时间运行的代码会导致用户界面无响应。这不好，因为用户会认为你的应用已崩溃。那么，你该如何解决这个问题呢？答案是使用多个托管对象上下文。
- en: In the past, using several managed object contexts was not easy to manage; you
    had to create instances of `NSManagedObjectContext` using the correct queues yourself.
    Luckily, `NSPersistentContainer` helps to make complex setups a lot more manageable.
    If you want to import data on a background task, you can obtain a managed object
    context by calling `newBackgroundContext()` on the persistent container. Alternatively,
    you can call `performBackgroundTask` on the persistent container and pass it a
    closure with the processing you want to do in the background.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，使用多个托管对象上下文不容易管理；你必须自己使用正确的队列创建`NSManagedObjectContext`的实例。幸运的是，`NSPersistentContainer`有助于使复杂设置更容易管理。如果你想将数据导入后台任务，可以通过在持久容器上调用`newBackgroundContext()`来获取托管对象上下文。或者，你可以在持久容器上调用`performBackgroundTask`并传递一个闭包，该闭包包含你希望在后台执行的处理。
- en: 'One important thing to understand about Core Data, background tasks, and multithreading
    is that you must always use a managed object context on the same thread it was
    created on. Consider the following example:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Core Data、后台任务和多线程的一个重要理解是，你必须始终在创建托管对象上下文相同的线程上使用托管对象上下文。考虑以下示例：
- en: '[PRE31]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The behavior of this code can cause you a couple of headaches. The background
    context was created in a different queue than the one it's used it in. It's always
    best to make sure to use a managed object context in the same queue it was created
    in by using the `perform(_:)` method of `NSManagedObject`. More importantly, you
    must also make sure to use the managed objects you retrieve on the same queue
    that the managed object context belongs to.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的行为可能会让你头疼。后台上下文是在一个不同于它所使用的队列中创建的。始终确保使用`NSManagedObject`的`perform(_:)`方法在创建托管对象上下文相同的队列中使用托管对象上下文。更重要的是，你还必须确保在托管对象上下文所属的队列上使用你检索到的托管对象。
- en: Often, you'll find that it's best to fetch data on the main queue using the
    `viewContext` persistent containers. Storing data can be delegated to background
    contexts if needed. If you do this, you must make sure that the background context
    is a child context of the main context. When this relationship is defined between
    the two contexts, your main context will automatically receive updates when the
    background context is persisted. This is quite convenient because it removes a
    lot of manual maintenance, which keeps your contexts in sync. Luckily, the persistent
    container takes care of this for you.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会发现最好在主队列上使用`viewContext`持久容器来获取数据。如果需要，可以将存储数据委托给后台上下文。如果你这样做，你必须确保后台上下文是主上下文的子上下文。当在这两个上下文之间定义这种关系时，主上下文将自动在后台上下文持久化时接收更新。这非常方便，因为它减少了大量的手动维护，使你的上下文保持同步。幸运的是，持久容器为你处理了这一切。
- en: When you find that your app requires a setup with multiple managed object contexts,
    it's essential to keep the rules mentioned in this section in mind. Bugs related
    to using managed objects or managed object contexts in the wrong places are often
    tedious to debug and hard to discover. When implemented carefully, complex setups
    with multiple managed object contexts can increase your application's performance
    and flexibility.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当你发现你的应用需要配置多个托管对象上下文时，牢记本节中提到的规则至关重要。在错误位置使用托管对象或托管对象上下文导致的错误通常难以调试和发现。当谨慎实施时，具有多个托管对象上下文的复杂设置可以提高应用程序的性能和灵活性。
- en: In our project `saveFamily(…)` method inside the `FamilyMembersViewController`
    file was using the `viewContext` to persist data. Let's refactor this code to
    use different managed object contexts and improve the performance of the app.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目 `FamilyMembersViewController` 文件中的 `saveFamily(…)` 方法使用了 `viewContext`
    来持久化数据。让我们重构这段代码，使用不同的托管对象上下文，并提高应用程序的性能。
- en: Refactoring the persisting code
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新整理持久化代码
- en: In the `viewContext` (you can see this in the `FamilyMembersViewController`
    file, inside the `saveFamily` method). Remember that we said before that `viewContext`
    is associated with the main queue of the application. Therefore, we can block
    the UI if we do any heavy work with it (usually, persisting data can incur heavy
    work!). So, it is a good idea to use `viewContext` just to read changes in Core
    Data and use a different managed object context (in a background queue) to persist
    them. In this way, we will not block the UI while we persist large amounts of
    data. Let's do this refactor.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `viewContext`（你可以在 `FamilyMembersViewController` 文件中的 `saveFamily` 方法中看到这一点）。记住我们之前说过，`viewContext`
    与应用程序的主队列相关联。因此，如果我们用它做任何重工作（通常，持久化数据可能会引起重工作），我们可能会阻塞UI。所以，只使用 `viewContext`
    来读取 Core Data 的更改，并使用不同的托管对象上下文（在后台队列中）来持久化它们是个好主意。这样，我们在持久化大量数据时不会阻塞UI。让我们进行这个重构。
- en: 'In the code bundle of the chapter, open the project named `MustC_refactor_start`.
    Open the `FamilyMembersViewController` file and replace `saveFamilyMember(…)`
    with the following implementation:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的代码包中，打开名为 `MustC_refactor_start` 的项目。打开 `FamilyMembersViewController` 文件，并将
    `saveFamilyMember(…)` 替换为以下实现：
- en: '[PRE32]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s go through the comments (notice that we have the old method by the name
    of `saveFamilyMemberOld` for reference; you can compare both to see the differences):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行查看注释（注意我们有一个名为 `saveFamilyMemberOld` 的旧方法作为参考；你可以比较两者以查看差异）：
- en: First, we make use of the `performBackgroundTask` persistent container method.
    Each time this method is invoked, the persistent container creates a new `NSManagedObjectContext`
    with `concurrencyType` set to `.privateQueueConcurrencyType`. The persistent container
    then executes the passed-in block against that newly created context on the context's
    private queue. We can use this new `moc` object to persist data in a background
    queue, without the risk of blocking the user interface. Note how in our previous
    method (`saveFamilyMemberOld`), we were using the `viewContext` managed object
    context, which can block the user interface if the data to persist is large.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用了 `performBackgroundTask` 持久容器方法。每次调用此方法时，持久容器都会创建一个新的 `NSManagedObjectContext`，其
    `concurrencyType` 设置为 `.privateQueueConcurrencyType`。然后，持久容器在该上下文的私有队列上执行传入的块。我们可以使用这个新的
    `moc` 对象在后台队列中持久化数据，而不会阻塞用户界面。注意，在我们的上一个方法（`saveFamilyMemberOld`）中，我们使用的是 `viewContext`
    管理对象上下文，如果需要持久化的数据量较大，这可能会阻塞用户界面。
- en: Second, we create a `familyMember` instance inside our managed object context
    (`moc`) and we update its name. When you create an instance of a managed object,
    you must provide the managed object context where the instance will be temporarily
    stored.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二步，我们在我们的托管对象上下文（`moc`）内部创建一个 `familyMember` 实例，并更新其名称。当你创建一个托管对象实例时，你必须提供实例将临时存储的托管对象上下文。
- en: Last, in the third comment, we save. Saving the managed object context can fail,
    so you must wrap the `save()` call in a `do {} catch {}` block so that it correctly
    handles potential errors. If the managed object context can't be saved, all unsaved
    changes are rolled back.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在第三个注释中，我们进行保存。保存托管对象上下文可能会失败，因此你必须将 `save()` 调用包裹在 `do {} catch {}` 块中，以便正确处理潜在的错误。如果托管对象上下文无法保存，所有未保存的更改都将回滚。
- en: Now, let's run the app and add a family member. Oops! Nothing. You will see
    that when you add the member, the table that displays the existing members doesn't
    update. However, if you stop and relaunch the app, the new member is there. So,
    what is happening? Looks like we are saving the data, but the user interface doesn't
    know about it (until we relaunch and it is reloaded). Why is that? We are persisting
    the data with a private managed object context, and `viewContext` doesn't know
    about it. Let's fix this.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行应用程序并添加一个家庭成员。哎呀！什么都没有。你会看到当你添加成员时，显示现有成员的表格没有更新。然而，如果你停止并重新启动应用程序，新成员就会出现。那么，发生了什么？看起来我们正在保存数据，但用户界面并不知道（直到我们重新启动并重新加载）。为什么是这样？我们使用私有托管对象上下文来持久化数据，而
    `viewContext` 并不知道。让我们修复这个问题。
- en: 'In the `viewDidLoad` method, add this line, just after `let moc = persistentContainer.viewContext`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `viewDidLoad` 方法中，添加以下行，在 `let moc = persistentContainer.viewContext` 之后：
- en: '[PRE33]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Setting `automaticallyMergesChangesFromParent` to `true` basically makes `viewContext`
    aware of any changes that other contexts are performing in the persisting store.
    If you execute the app now and add a family member, you will see how the table
    reflects the changes immediately.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `automaticallyMergesChangesFromParent` 设置为 `true` 实际上使 `viewContext` 能够意识到其他上下文在持久化存储中执行的所有更改。如果你现在运行应用程序并添加一个家庭成员，你将看到表格如何立即反映这些更改。
- en: Now, as practice, you can do the same in the `MoviesViewController` file, modifying
    the `saveMovie` method and setting the `automaticallyMergesChangesFromParent`
    property of `viewContext` to `true`. Give it a try!
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，作为练习，你可以在 `MoviesViewController` 文件中做同样的事情，修改 `saveMovie` 方法并将 `viewContext`
    的 `automaticallyMergesChangesFromParent` 属性设置为 `true`。试试看！
- en: In this section, we have learned how to use multiple managed object contexts
    to improve the performance of your Core Data code. Let's wrap up the chapter now
    with a summary.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用多个托管对象上下文来提高你的 Core Data 代码的性能。现在让我们通过总结来结束这一章。
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter showed you how to implement a relatively simple Core Data database
    that stores family members and their favorite movies. You used the Core Data model
    editor in Xcode to configure the models you wanted to store and define the relationship
    between these models. Once the models were set up, you implemented code that created
    instances of your models so that they could be stored in the database and retrieved
    later.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向你展示了如何实现一个相对简单的 Core Data 数据库，用于存储家庭成员及其最喜欢的电影。你使用 Xcode 中的 Core Data 模型编辑器来配置你想要存储的模型并定义这些模型之间的关系。一旦模型设置好，你就实现了创建模型实例的代码，以便它们可以存储在数据库中并在以后检索。
- en: Next, you retrieved the data from the database and saw that your table views
    don't automatically update when the underlying data changes. You used an `NSFetchedResult`
    controller to fetch family members and listen to changes on the list of family
    members. You saw that this setup is very powerful because you can respond to changes
    in your data quite easily.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你从数据库中检索了数据，并发现当底层数据发生变化时，你的表格视图不会自动更新。你使用了一个 `NSFetchedResult` 控制器来获取家庭成员并监听家庭成员列表上的变化。你看到这个设置非常强大，因为你可以很容易地响应数据的变化。
- en: Finally, you improved the Core Data code by using different managed object contexts,
    using the background object context to persist data, and the main queue object
    context to react to the changes and refresh the user interface.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你通过使用不同的托管对象上下文改进了 Core Data 代码，使用后台对象上下文来持久化数据，以及主队列对象上下文来响应变化并刷新用户界面。
- en: In the next chapter, you will learn how to enrich the data your users add to
    the database by fetching and storing data from the web.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何通过从网络获取和存储数据来丰富用户添加到数据库中的数据。
- en: Further reading
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: The *Core Data* book, by Florian Kugler and Daniel Eggert
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*Core Data*》一书，由 Florian Kugler 和 Daniel Eggert 撰写
- en: 'Apple''s Predicate Programming Guide: [http://apple.co/2fF3qHc](http://apple.co/2fF3qHc)'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 苹果的谓词编程指南：[http://apple.co/2fF3qHc](http://apple.co/2fF3qHc)
