- en: '*Chapter 8*: Adding Core Data to Your App'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`UserDefaults`, but when you''re handling data that is more complex, has relationships,
    or needs some form of efficient searching, Core Data is much better suited to
    your needs.'
  prefs: []
  type: TYPE_NORMAL
- en: You don't need to build a very complex app or have vast amounts of data to make
    Core Data worth your while. Regardless of your app's size, even if it's tiny with
    only a couple of records, or if you're holding onto thousands of records, Core
    Data has your back.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you'll learn how to add Core Data to an existing app. The app
    you will build keeps track of a list of favorite movies for all members of a family.
    The main interface is a table view that shows a list of family members. If you
    tap on a family member's name, you'll see their favorite movies. Adding family
    members can be done through the overview screen and adding movies can be done
    through the detail screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the following topics are covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Core Data stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Core Data to an existing application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Core Data model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persisting data and reacting to data changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the use of multiple instances of `NSManagedObjectContext`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You won't build the screens in this app from scratch. The code bundle for this
    chapter includes a starter project called `MustC`. The starter project contains
    all of the screens, so you don't have to set up the user interface before you
    get around to implementing Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the sample code from the following GitHub link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Core Data stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you dive right into the project and add Core Data to it, let's take a
    look at how Core Data works, what it is, and what it isn't. In order to make efficient
    use of Core Data, you must know what you're working with.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you work with Core Data, you''re utilizing a stack of layers that starts
    with managed objects and ends with a data store. This data store is often a SQLite
    database, but there are different storage options you can use with Core Data,
    depending on your application''s needs. Let''s take a quick look at the layers
    involved with Core Data and discuss their roles in an application briefly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – A Core Data stack'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.01_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – A Core Data stack
  prefs: []
  type: TYPE_NORMAL
- en: At the top right of this diagram is the `NSManagedObject` class. When you use
    Core Data, this is the class you'll interact with most often since it's the base
    class for all the Core Data models that your app contains. For instance, in the
    app that you will build in this chapter, the family member and movie models are
    subclasses of `NSManagedObject`.
  prefs: []
  type: TYPE_NORMAL
- en: Each managed object belongs to an instance of `NSManagedObjectContext`. The
    managed object context is responsible for communicating with the **persistent
    store coordinator**. Often, you'll only need a single managed object context and
    a single persistent store coordinator. However, it is possible to use multiple
    persistent store coordinators and multiple managed object contexts. It's even
    possible to have multiple managed object contexts for the same persistent store
    coordinator.
  prefs: []
  type: TYPE_NORMAL
- en: A setup with multiple managed object contexts can be particularly useful if
    you're performing costly operations on your managed objects; for example, if you're
    importing or synchronizing large amounts of data. Usually, you will stick to using
    a single managed object context and a single persistent store coordinator because
    most apps don't need more than one.
  prefs: []
  type: TYPE_NORMAL
- en: The persistent store coordinator is responsible for communicating with the **persistent
    store**. In most scenarios, the persistent store uses SQLite as its underlying
    storage database. However, you can also use other types of storage, such as an
    in-memory database. An in-memory database is especially useful if you're writing
    unit tests or if your app does not need long-term storage.
  prefs: []
  type: TYPE_NORMAL
- en: If you've worked with MySQL, SQLite, or any other relational database, it is
    tempting to think of Core Data as a layer on top of a relational database. Although
    this isn't entirely false since Core Data can use SQLite as its underlying storage,
    Core Data does not work the same as using SQLite directly; it's an abstraction
    on top of it.
  prefs: []
  type: TYPE_NORMAL
- en: One example of a difference between SQLite and Core Data is the concept of primary
    keys. Core Data doesn't allow you to specify your own primary keys. Also, when
    you define relationships, you don't use foreign keys. Instead, you simply define
    the relationship and Core Data will figure out how to store this relationship
    in the underlying database. You will learn more about this later. It's important
    to know that you should not directly translate your SQL experiences to Core Data.
    If you do, you will run into issues, simply because Core Data is not SQL. It just
    so happens that SQLite is one of the ways that data can be stored, but the similarities
    end right there.
  prefs: []
  type: TYPE_NORMAL
- en: To recap, all Core Data apps have a **persistent store**. This store is backed
    by an in-memory database or a SQLite database. A **persistent store coordinator**
    is responsible for communicating with the **persistent store**. The object communicating
    with the **persistent store coordinator** is the **managed object context**. An
    application can have multiple **managed object context** instances talking to
    the same **persistent store coordinator**. The objects that a **managed object
    context** retrieves from the **persistent store coordinator** are **managed objects**.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an overview of the Core Data stack and where all the parts
    involved with its usage belong, let's add the Core Data stack to the **MustC**
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Core Data to an existing application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you create a new project in Xcode, Xcode asks whether you want to add Core
    Data to your application. If you check this checkbox, Xcode will automatically
    generate some boilerplate code that sets up the Core Data stack. For practicing
    purposes, `MustC` was set up without Core Data, so you'll have to add this to
    the project yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by opening `AppDelegate.swift` and add the following `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the following `lazy` variable to the implementation of `AppDelegate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you declare a variable as lazy, it won't be initialized until it is accessed.
    This is particularly useful for variables that are expensive to initialize, rely
    on other objects, or are not always accessed. The fact that the variable is initialized
    just in time comes with a performance penalty since the variable needs to be set
    up the first time you access it. In some instances, this is fine, but in other
    cases, it might negatively impact the user experience. When used correctly, lazy
    variables can offer significant benefits.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code snippet creates an instance of `NSPersistentContainer`. The
    persistent container is a container for the persistent store coordinator, persistent
    store, and managed object context. This single object manages different parts
    of the Core Data stack, and it ensures that everything is set up and managed correctly.
  prefs: []
  type: TYPE_NORMAL
- en: If you let Xcode generate the Core Data code for your app, it adds a similar
    property to create `NSPersistentContainer`. Xcode also adds a method called `saveContext()`
    to `AppDelegate`. This method is used in `applicationWillTerminate(_:)` to perform
    a last-minute save of any changes and updates when the application is about to
    terminate. Since you're setting up Core Data manually, this behavior isn't added
    by Xcode, so it must be added by you manually.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of placing the `saveContext()` method in `AppDelegate`, you will add
    this method as an extension to `NSPersistentContainer`. This makes it easier for
    other parts of your code to use this method, without having to rely on `AppDelegate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a new folder in the Project Navigator and name it `Extensions`.
    Also, create a new Swift file and name it `NSPersistentContainer.swift`. Add the
    following implementation to this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This code adds a new method to `NSPersistentContainer` instances by extending
    it. This is convenient because it decouples the save method from `AppDelegate`
    entirely. This is much nicer than the default save mechanism provided for Core
    Data apps by Xcode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following implementation of `applicationWillTerminate(_:)` to `AppDelegate`
    to save the context right before the app terminates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, whenever the application terminates, the persistent store will check whether
    there are any changes to the managed object context that the `viewContext` property
    points to. If there are any changes, an attempt to save them is made. If this
    attempt fails, the app will crash with `fatalError`. When creating your own app,
    you might want to handle this scenario a bit more gracefully. It could very well
    be that failing to save data before the app terminates might not be a reason that
    crashes your app. You can modify the error-handling implementation of `saveContextIfNeeded()`
    if you think a different behavior is more appropriate for your app. You can, for
    example, upload the error to your analytics or reporting tool to analyze it later,
    or avoid `fatalError` and just log the error without crashing the app.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the Core Data stack set up, you need a way to provide this
    stack to the view controllers in the app. A common technique to achieve this is
    called `AppDelegate` will pass the persistent container to `FamilyMemberViewController`,
    which is the first view controller in the app. It then becomes the job of `FamilyMemberViewController`
    to pass the persistent container to the next view controller that depends on it,
    and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to inject the persistent container, you need to add a property to
    `FamilyMembersViewController` that holds the persistent container. Don''t forget
    to add `import CoreData` at the top of the file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in `AppDelegate`, modify the `application(_:didFinishLaunchingWith Options:)`
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is using dependency injection to inject `persistentContainer` into
    `FamilyMemberViewController`. But you can still make one major improvement: you
    know that there might be more view controllers that depend on a persistent container,
    so you will need a `persistentContainer` property in each of them. This will cause
    a lot of repeated code. We can improve our code if we define a protocol that we
    can reuse in order to reduce the duplicated code in each `UIViewController` instance
    that needs `persistentContainer`. As an exercise, attempt to improve the code
    by adding a protocol called `PersistentContainerRequiring`. This protocol should
    add a requirement for an implicitly unwrapped `persistentContainer` property.
    Make sure that `FamilyMembersViewController` conforms to this protocol, and fix
    the implementation of `application(_:didFinishLaunchingWithOptions:)` as well
    so that it uses your new protocol.'
  prefs: []
  type: TYPE_NORMAL
- en: You have just put down the foundation that is required to use Core Data in your
    app. Before you can use Core Data and store data in it, you must define what data
    you would like to save by creating your data model. Let's go over how to do this
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Core Data model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you have worked on the persistence layer of your app. The next step
    is to create your models so that you can actually store and retrieve data from
    your Core Data database. All models in an application that uses Core Data are
    represented by `NSManagedObject` subclasses. When you retrieve data from your
    database, `NSManagedObjectContext` is responsible for creating instances of your
    managed objects and populating them with the relevant fetched data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **MustC** application requires two models: a family-member model and a
    movie model. When you define models, you can also define relationships. For the
    models in **MustC**, you should define a relationship that links multiple movies
    to a single family member.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order for Core Data to understand which models your application uses, you
    must define them in Xcode''s model editor. Let''s create a new model file so that
    you can add your own models to the **MustC** application. Create a new file, and
    from the file template selection screen, pick **Data Model**. First, you will
    set up the basic models, and then see how you can define a relationship between
    family members and their favorite movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Creating a new Core Data model'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.02_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – Creating a new Core Data model
  prefs: []
  type: TYPE_NORMAL
- en: Name your model file `MustC`. Your project now contains a file called `MustC.xcdatamodeld`.
    Open this file to go to the model editor. In the bottom-left corner of the editor,
    you'll find a button labeled `FamilyMember`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you select an entity by clicking it, you can see all of its attributes,
    relationships, and fetched properties. Let''s add a `name` property to the family
    member. Click on the plus (`name`. Make sure that you select **String** as the
    type for this attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Adding an attribute to a Core Data entity'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.03_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – Adding an attribute to a Core Data entity
  prefs: []
  type: TYPE_NORMAL
- en: Click on this new property to select it. In the sidebar on the right, select
    the fourth tab to open the Data Model inspector. This is where you can see more
    detailed information on this attribute. For instance, you can configure a property
    to be indexed for faster lookups. You can also choose whether you want the attribute
    to be optional. For now, you shouldn't care too much about indexing since you're
    not performing lookups by family members' names, and, even if you were, a family
    doesn't tend to have hundreds or thousands of members. By default, the **Optional**
    checkbox is checked. Make sure that you uncheck this box because you don't want
    to store family members without a name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some other options you have for attributes are adding validation, adding a
    default value, and enabling indexing in Spotlight. For now, leave all those options
    at their default settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Attribute properties'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.04_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – Attribute properties
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to a `FamilyMember` entity, `Movie` entity. Create this entity
    using the same steps as before and give it a single property: `title`. This property
    should be a string and it shouldn''t be optional. Once you''ve added this property,
    you can set up a relationship between family members and their favorite movies.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A relationship in Core Data adds a reference as a property onto an entity. In
    this case, you want to define a relationship between `FamilyMember` and `Movie`.
    The best way to describe this relationship is a one-to-many relationship. This
    means that every movie will have only one family member associated with it and
    every family member can have multiple favorite movies.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Configuring your data model with a one-to-many relationship from `Movie` to
    `FamilyMember` is not the most efficient way to define this relationship. A many-to-many
    relationship is likely a better fit because that would allow multiple family members
    to add the same movie instance as their favorite. A one-to-many relationship is
    used in this example to keep the setup simple and make it easy to follow along
    with the example.
  prefs: []
  type: TYPE_NORMAL
- en: Select the `Movie` as the destination. Don't select an `Movie` has a property
    that points back to `FamilyMember`. Make sure that you select `movies` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, select **Cascade** as the value for **Delete Rule**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Relationship properties'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.05_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5 – Relationship properties
  prefs: []
  type: TYPE_NORMAL
- en: '`nil`. This is the correct behavior when deleting a movie because deleting
    a movie shouldn''t delete the entire family member who added this movie as their
    favorite. It should simply be removed from the list of favorites.'
  prefs: []
  type: TYPE_NORMAL
- en: However, if a family member is deleted and the relationship is `nullified`,
    you would end up with a bunch of movies that don't have a family member associated
    with them. In this application, these movies are worthless; they won't be used
    anymore because every movie only belongs to a single family member. For this app,
    it's desirable that when a family member gets deleted, Core Data also deletes
    their favorite movies. This is precisely what the **Cascade** option does; it
    cascades the deletion over to the relationship's inverse.
  prefs: []
  type: TYPE_NORMAL
- en: 'After setting `familyMember`. The destination should be `FamilyMember` and
    the inverse for this relationship is `favoriteMovies`. After adding this relationship,
    the inverse will be automatically set on the `FamilyMember` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Movie relationship with FamilyMember'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.06_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.6 – Movie relationship with FamilyMember
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned how to create and establish relationships between entities
    in our model, let's start using the entities to store data in our app.
  prefs: []
  type: TYPE_NORMAL
- en: Using your entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned before, every model or entity in your Core Data database is represented
    by `NSManagedObject`. There are a couple of ways to create or generate `NSManagedObject`
    subclasses. In the simplest of setups, an `NSManagedObject` subclass contains
    just the properties for a certain managed object and nothing else. If this is
    the case, you can let Xcode generate your model classes for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is actually what Xcode does by default. If you build your project now
    and add the following code to `viewDidLoad()` in `FamilyMembersViewController`,
    your project should compile just fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This works automatically; you don't have to write any code for your models yourself.
    Don't worry about what the preceding code does just yet; we'll get into that very
    soon. The point is that you see that a `FamilyMember` class exists in your project
    even though you didn't have to create one yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the default behavior doesn''t suit the approach you want in your app – for
    instance, if you want to prevent your code from modifying your models by defining
    your variables as `private(set)` – you may want to create a custom subclass instead
    of making Xcode generate the classes for you. A custom `NSManagedObject` subclass
    for `FamilyMember` could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This custom `FamilyMember` subclass makes sure that any external code can't
    modify the instances by making the setters on `FamilyMember` private. Depending
    on your application, it might be a good idea to implement this since it will ensure
    that your models can't accidentally change.
  prefs: []
  type: TYPE_NORMAL
- en: One final option you have is to let Xcode generate the properties for `NSManagedObject`
    as an extension on a class you define. This is particularly useful if you have
    some custom stored properties that you'd like to define on your model or if you
    have a customized `NSManagedObject` subclass that you can use as the base for
    all of your models.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: All code that Xcode generates for your Core Data models is added to the `Build`
    folder in Xcode's Derived Data. You shouldn't modify it or access it directly.
    These files will be automatically regenerated by Xcode whenever you perform a
    build, so any functionality you add inside the generated files will be overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: For the **MustC** app, it's okay if Xcode generates the model definition classes
    since there are no custom properties that you need to add. In the model editor,
    select each entity and make sure that the **Codegen** field is set to **Class
    Definition**; you can find this field in the Data Model inspector panel.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you are all set up to store your first piece of data in the
    Core Data database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – The Codegen attribute for entities'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.07_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.7 – The Codegen attribute for entities
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to persist data with the model and relationship
    that we just created.
  prefs: []
  type: TYPE_NORMAL
- en: Persisting data and reacting to data changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: "The first step to implement data persistence for your app is to make sure that\
    \ you can store data in the database. You have defined the models that you want\
    \ to store in your database, so the next step is to actually store your models.\
    \ Once you have implemented a rough version of your data persistence, you will\
    \ refine the code to make it more reusable. The final step will be to read data\
    \ from Core Data and dynamically respond to changes in \Lthe database."
  prefs: []
  type: TYPE_NORMAL
- en: Understanding data persistence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever you want to persist a model with Core Data, you must insert a new `NSManagedObject`
    into `NSManagedObjectContext`. Doing this does not immediately persist the model.
    It merely stages the object for persistence in the current `NSManagedObjectContext`.
    If you don't properly manage your managed objects and contexts, this is a potential
    source of bugs. For example, not persisting your managed objects results in the
    loss of your data once you refresh the context. Even though this might sound obvious,
    it could lead to several hours of frustration if you aren't aware of this and
    have bugs in managing your managed object context.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to save managed objects correctly, you must tell the managed object
    context to persist its changes to the persistent store coordinator. The persistent
    store coordinator will take care of persisting the data in the underlying SQLite
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Extra care is required when you use multiple managed object contexts. If you
    insert an object in one managed object context and persist it, you will manually
    need to synchronize the changes into the other managed object contexts. Also,
    managed objects are not thread-safe. This means that you must make sure that you
    create, access, and store a managed object on a single thread at all times. The
    managed object context has a helper method called `perform(_:)` to help you with
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting new objects, updating them, or adding relationships between objects
    should always be done using the `perform(_:)` method. The reason is that the helper
    method makes sure that all the code in the closure you want to perform is executed
    on the same thread that the managed object context is on.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you're aware of how data persistence works in Core Data, it's time
    to start implementing the code to store family members and their favorite movies.
    You will implement the family member persistence first. Then, you'll expand the
    app so that you can safely add movies to family members.
  prefs: []
  type: TYPE_NORMAL
- en: Persisting your models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first model you will persist is the family member model. The app is already
    set up with a form that asks for a family member name and a delegate protocol
    that informs `FamilyMembersViewController` whenever the user wants to store a
    new family member.
  prefs: []
  type: TYPE_NORMAL
- en: Note that none of the input data is validated; usually, you'd want to add some
    checks that make sure that the user is not trying to insert an empty family member
    name, for instance. For now, we'll skip that because this type of validation isn't
    Core Data-specific.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to persist new family members should be added to the `saveFamilyMember(withName:)`
    method. Add the following implementation to `FamilyMembersViewController`; we''ll
    go over it line by line after adding the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first comment in this code marks where the managed object context is extracted
    from `persistentContainer`. All `NSPersistentContainer` objects have a `viewContext`
    property. This property is used to obtain a managed object context that exists
    on the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: The second comment marks the call to `perform(_:)`. This ensures that the new
    `FamilyMember` instance is created and stored on the correct thread.
  prefs: []
  type: TYPE_NORMAL
- en: The third comment marks where we create a `familyMember` instance inside our
    managed object context (`moc`) and we update its name. When you create an instance
    of a managed object, you must provide the managed object context where the instance
    will be temporarily stored.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, saving the managed object context can fail, so you must wrap the `to
    save()` call in a `do {} catch {}` block, so it correctly handles potential errors.
    If the managed object context can't be saved, all unsaved changes are rolled back.
  prefs: []
  type: TYPE_NORMAL
- en: This code is all you need to persist family members. Before you implement the
    required code to read existing family members and respond to the insertion of
    new family members, let's set up `MoviesViewController` so that it can store movies
    for a family member.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to store movies for a family member is very similar to the code you
    wrote previously. Before you implement the following snippets, make sure that
    in the `MoviesViewController` file, you add `import CoreData`. Also, add a `persistentContainer`
    property to `MoviesViewController`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to connect a new movie to a family member, you also need a variable
    to hold the family member in `MoviesViewController`. Add the following declaration
    to `MoviesViewController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After doing this, add the following implementation for `saveMovie(withName:)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The most important differences between adding the movie and the family member
    are highlighted with comments. Note that the `movies` property on a family member
    is `NSSet`. This is an immutable object, so you need to create a copy and add
    the movie to that copy. If no copy could be made because there is no set created
    yet, you can create a new set with the new movie in it. Next, this new, updated
    set is converted back to an `NSSet` instance so that it can be the new value for
    movies.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, both save methods share about half of the implementation. You
    can make some clever use of extensions and generics in Swift to avoid writing
    this duplicated code. Let's refactor the app a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Notice how we have used `viewContext` for persisting data (in both the `saveFamilyMember`
    and `saveMovie` methods). For this example, it will work perfectly fine, because
    we are not doing any heavy tasks. But `viewContext` is associated with the main
    queue of the application, so it is not good practice to do any work with it that
    can block the UI (such as persisting a large amount of data). In the last section
    of this chapter, we will refactor this code by creating a private context that
    works in a background thread. We will persist data in the background and read
    changes from `viewContext` in the main thread. By using two different contexts,
    one in the background and one in the main thread, we will follow best practices
    and ensure we don't block the UI while persisting data.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the persistence code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many iOS developers dislike the amount of boilerplate code that is involved
    with using Core Data. Simply persisting an object requires you to repeat several
    lines of code, which can become quite a pain to write and maintain over time.
    The approach to refactoring the persistence code presented in the following examples
    is heavily inspired by the approach taken in the *Core Data* book written by *Florian
    Kugler* and *Daniel Eggert*.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you're interested in learning more about Core Data outside of what this book
    covers, and if you'd like to see more clever ways to reduce the amount of boilerplate
    code, you should pick up *Core Data* by *Kugler* and *Eggert*..
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the code blocks to save `familyMember` and `familyMember.movies`
    instances into Core Data, use the following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it would be great if you could write the following code to persist data
    instead, reducing the duplicated code every time you save an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be achieved by writing an extension for `NSManagedObjectContext`.
    Add a file called `NSManagedObjectContext` to the extensions folder, and add the
    following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code allows you to reduce the amount of boilerplate code, which
    is something that you should always try to achieve. Reducing boilerplate code
    greatly improves your code's readability and maintainability. Update both the
    family overview and the movie list view controllers to make use of this new persistence
    method.
  prefs: []
  type: TYPE_NORMAL
- en: After optimizing our code to save entities in Core Data with the preceding trick,
    now let's see how to read data, making use of `NSFetchRequest`, which allows us
    to query data in a simple and effective way.
  prefs: []
  type: TYPE_NORMAL
- en: Reading data with a simple fetch request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest way to fetch data from your database is to use a fetch request.
    The managed object context forwards fetch requests to the persistent store coordinator.
    The persistent store coordinator will then forward the request to the persistent
    store, which will then convert the request into a SQLite query. Once the results
    are fetched, they are passed back up this chain and converted into `NSManagedObject`
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: By default, these objects are called faults. When an object is a fault, it means
    that the actual properties and values for the object are not fetched yet, but
    they will be fetched once you access them. This is an example of a good implementation
    of lazy variables because fetching the values is a pretty fast operation, and
    fetching everything upfront would greatly increase your app's memory footprint
    because all values would have to be loaded into the app's memory right away.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example of a simple fetch request that retrieves all
    `FamilyMember` instances that were saved to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it's not particularly hard to fetch all of your family members.
    Every `NSManagedObject` instance has a class method that configures a basic fetch
    request that can be used to retrieve data. If you have large amounts of data,
    you probably don't want to fetch all of the persisted objects at once. You can
    configure your fetch request to fetch data in batches by setting the `fetchBatchSize`
    property. It's recommended that you use this property whenever you want to use
    fetched data in a table view or collection view. You should set the `fetchBatchSize`
    property to a value that is just a bit higher than the number of cells you expect
    to display at a time. This makes sure that Core Data fetches plenty of items to
    display while avoiding loading everything at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fetch data, let''s display some data in the family
    members table view. Add a new variable called `familyMembers` to `FamilyMembersViewController`.
    Give this property an initial value of `[FamilyMember]()` so that you start off
    with an empty array of family members. Also, add the example fetch request you
    saw earlier to `viewDidLoad()`. Next, assign the result of the fetch request to
    `familyMembers`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, update the table view delegate methods so that `tableView(_:numberOfRowsInSection:)`
    returns the number of items in the `familyMembers` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, update the `tableView(_:cellForRowAtIndexPath:)` method by adding the
    following two highlighted lines before returning the cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If you build and run your app now, you should see the family members you already
    saved. New family members won't show up right away. However, when you quit the
    app and run it again, new members will show up.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could manually reload the table view right after you insert a new family
    member so that it''s always up to date, but this isn''t the best approach. You
    will see a better way to react to the insertion of new data soon. Let''s finish
    the family member detail view first so that it shows a family member''s favorite
    movies. Add the following code to the end of the `prepare(for:sender:)` method
    in the `FamilyMembersViewController` view controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The method should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding lines of code pass the selected family member and the persistent
    container to `MoviesViewController` so that it can display and store the current
    family member's favorite movies.
  prefs: []
  type: TYPE_NORMAL
- en: 'All you need to do to show the correct movies for a family member is to use
    the family member''s favorite movies in the `MovieViewController` table view data
    source methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You don't need to use a fetch request here because you can simply traverse the
    `movies` relationship on the family member to get their favorite movies. This
    isn't just convenient for you as a developer, it's also good for your app's performance.
    Every time you use a fetch request, you force a query to the database. If you
    traverse a relationship, Core Data will attempt to fetch the object from memory
    instead of asking the database.
  prefs: []
  type: TYPE_NORMAL
- en: Again, adding new data won't immediately trigger the table view to update its
    contents. We'll get to that after we take a look at how to filter data. If you
    want to check whether your code works, build and rerun the app so that all the
    latest data is fetched from the database. Now that we know how to query from Core
    Data, let's perform smarter queries by filtering the retrieved data, with the
    help of the `NSPredicate` class.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering data with predicates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A typical operation you'll want to perform on your database is filtering. In
    Core Data, you use predicates to do this. A **predicate** describes a set of rules
    that any object that gets fetched has to match.
  prefs: []
  type: TYPE_NORMAL
- en: When you model your data in the model editor, it's wise to think about the types
    of filtering you need to do. For instance, you may be building a birthday calendar
    where you'll often sort or filter by date. If this is the case, you should make
    sure that you have a Core Data index for this property. You can enable indexing
    with the checkbox you saw earlier in the model editor. If you ask Core Data to
    index a property, it will significantly improve performance when filtering and
    selecting data in large datasets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing predicates can be confusing, especially if you try to think of them
    as the `WHERE` clause from SQL. Predicates are very similar, but they''re not
    quite the same. A simple predicate looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: A predicate has a format; this format always starts with a key. This key represents
    the property you want to match with. In this example, it would be the name of
    a family member. Then, you specify the condition – for instance, `==, >, <, or
    CONTAINS[n]`.
  prefs: []
  type: TYPE_NORMAL
- en: There are more conditions available, but the ones listed are some examples of
    conditions you'll commonly use. Finally, you will specify a placeholder that is
    substituted with the true value. This placeholder is `%@` in the preceding example.
    If you have written any Objective-C before you picked up this book, the `%@` placeholder
    might look familiar to you because it's used as a placeholder in format strings
    there.
  prefs: []
  type: TYPE_NORMAL
- en: The example predicate is very simple and bare; it could be the template for
    a search feature you're building. Usually, a simple search doesn't have to be
    much more complicated than this as long as there's an index added to the properties
    you search for.
  prefs: []
  type: TYPE_NORMAL
- en: If you have multiple predicates you want to match on, you can combine them using
    `NSCompoundPredicate`. This class combines different predicates using either an
    `and`, `or`, or `not` clause. A typical use case for this approach is when you
    build a complex filter in your app where the predicate is hard to express in a
    single statement.
  prefs: []
  type: TYPE_NORMAL
- en: To use a predicate in a fetch request, you assign it to the `predicate` property
    of a fetch request. Every fetch request has a `predicate` property that you can
    set. It can handle both a single predicate and a compound predicate. If you set
    this property before executing the fetch request, the predicate is applied to
    the request, and you will receive a filtered dataset instead of the full dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Predicates are powerful, and they have many options available.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you're interested in an in-depth overview of predicates and all of the ways
    in which you can make use of format strings, I recommend that you read *Apple's
    Predicate Programming Guide* at [http://apple.co/2fF3qHc](http://apple.co/2fF3qHc).
    It provides a well-documented overview of predicates and their applications.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, you will learn how to respond to changes in the managed object context
    – for instance, when you add new family members and movies.
  prefs: []
  type: TYPE_NORMAL
- en: Reacting to database changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In its current state, the **MustC** app doesn't update its list when a new managed
    object is persisted. One possible solution for this is to manually reload the
    table right after a new family member is inserted. Although this might work well
    for some time, it's not the best solution to this problem. If the app grows, you
    might add functionality that imports new family members from the network. Manually
    refreshing the table view would be problematic because the networking logic should
    not be aware of the table view. Luckily, there is a better solution to react to
    changes in your data.
  prefs: []
  type: TYPE_NORMAL
- en: One way to respond to database changes is by using `NSFetchedResultsController`.
    This class is perfect for listening to the insertion of new family members. You
    will implement this approach in `FamilyMembersViewController`. A second way to
    respond to updates is through notifications. You will implement this approach
    in `MoviesViewController`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing NSFetchedResultsController
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`NSFetchedResultsController` is a helper class that specializes in fetching
    data and managing this data. It listens to changes in its managed object context
    and notifies a delegate whenever the data it has fetched changes. This is incredibly
    helpful because it allows you to respond to specific changes in the dataset rather
    than reloading the table view entirely.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Being a delegate for the fetched results controller involves the following
    important methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`controllerWillChangeContent(_:)` is called right before the controller passes
    updates to the delegate. If you''re using a table view with a fetched-results
    controller, this is the perfect method to begin updating the table view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`controller(_:didChange:at:for:newIndexPath:)` and `controller(_:didChange:atSectionIndex:for:)`
    are called to inform the delegate about updates to the fetched items and sections,
    respectively. This is where you should handle updates in the fetched data. For
    instance, you could insert new rows in a table view if new items were inserted
    in the dataset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`controllerDidChangeContent(_:)` is called. This is the point where you should
    let the table view know that you''ve finished processing the updates so that all
    the updates can be applied to the table view''s interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `MustC`, it doesn't make sense to implement all four methods because the
    table view that shows family members only has a single section. This means `controller(_:didChange:atSectionIndex:for:)`
    does not have to be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a fetched-results controller to fetch the stored family members, you
    need to create an instance of `NSFetchedResultsController` and assign `FamilyMembersViewController`
    as its delegate so that it can respond to changes in the underlying data. You
    can then implement the delegate methods so that you can respond to changes in
    the fetched-results dataset. Remove the `familyMembers` array from the variable
    declarations in `FamilyMembersViewController` and add the following `fetchedResultsController`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `viewDidLoad` method should be adjusted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This implementation initializes `NSFetchedResultsController`, assigns its delegate,
    and tells it to execute the fetch request. Note that the `sortDescriptors` property
    of the fetch request is set to an array that contains `NSSortDescriptor`. A fetched-request
    controller requires this property to be set, and for the list of family members,
    it makes sense to order family members by name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have a fetched-results controller, you should implement the delegate
    methods on `FamilyMembersViewController` and make it conform to `NSFetchedResultsControllerDelegate`.
    Add the following extension to `FamilyMembersViewController.swift`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of this extension is fairly straightforward. The table view
    gets notified when the fetched-result controller is about to process changes to
    its data and when the fetched-results controller is done processing changes. The
    bulk of the work needs to be done in `controller(_:didChange:at:for:newIndexPath)`.
    This method is called when an update has been processed by the fetched-result
    controller. In `MustC`, the goal is to update a table view, but you could also
    update a collection view or store all of the updates in a list and do something
    else with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how you can process changes to fetched data in the following
    method. Add it to the extension on `FamilyMembersViewController.swift`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This method contains quite a lot of code, but it''s actually not that complex.
    The preceding method receives a type parameter. This parameter is an instance
    of `NSFetchedResultsChangeType`, which contains information about the kind of
    update that was received. The following are the four types of updates that can
    occur:'
  prefs: []
  type: TYPE_NORMAL
- en: Insert
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these change types corresponds to a database action. If an object was
    inserted, you will receive an insert change type. The proper way to handle these
    updates for `MustC` is to simply pass them on to the table view. Once all the
    updates are received, the table view will apply all of these updates at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you had implemented `controller(_:didChange:atSectionIndex:for:)` as well,
    it would also have received a `change` type; however, the sections only deal with
    the following two types of changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Insert
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sections don't update or move, so if you implement this method, you don't have
    to account for all cases because you won't encounter any, other than the two listed
    types of changes.
  prefs: []
  type: TYPE_NORMAL
- en: If you take a close look at the implementation for `controller(_:didChange:at:for:newIndexPath)`,
    you'll notice that it receives two index paths. One is named `indexPath`, and
    the other is named `newIndexPath`. They're both optional, so you will need to
    make sure that you safely unwrap them if you use them. For new objects, only the
    `newIndexPath` property will be present. For delete and update, the `indexPath`
    property will be set. When an object is moved from one place in the dataset to
    another, both `newIndexPath` and `indexPath` will have a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing you need to do is update the code in `FamilyMembersViewController`
    so that it uses the fetched results controller instead of the `familyMembers`
    array that it used earlier. First, update the `prepare(for:sender:)` method, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes sure that a valid family member is passed to the `movies` view controller.
    Update the table view data source methods, as shown in the following code. A fetched-results
    controller can retrieve objects based on an index path. This makes it a great
    fit to use in combination with table views and collection views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If you run your app now, the interface updates automatically when you add a
    new family member to the database. However, the list of favorite movies doesn't
    update yet. That page does not use a fetched-results controller, so it must listen
    to changes to the dataset directly.
  prefs: []
  type: TYPE_NORMAL
- en: The reason `MoviesViewController` doesn't use a fetched-results controller for
    the movie list is that fetched-result controllers will always need to drop down
    all the way to your persistent store (SQLite in this app). As mentioned before,
    querying the database has a significant memory overhead compared to traversing
    the relationship between family members and their movies; it's much faster to
    read the `movies` property than fetching them from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a managed object context changes, a notification is posted to the default
    `NotificationCenter`. `NotificationCenter` is used to send events inside of an
    app so that other parts of the code can react to those events.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: It can be very tempting to use notifications instead of delegates, especially
    if you're coming from a background that makes heavy use of events, such as JavaScript.
    Don't do this; delegation is better suited to most cases, and it will make your
    code much more maintainable. Only use notifications if you don't care who's listening
    to your notifications or if setting up a delegate relationship between objects
    would mean you'd create very complex relationships between unrelated objects just
    to set up the delegation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s subscribe `MoviesViewController` to changes in the managed object context
    so that it can respond to data changes if needed. Before you implement this, add
    the following method, which should be called when changes in the managed object
    context occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This method reads the notification's `userInfo` dictionary to access the information
    that's relevant to the current list. You're interested in changes to the current
    `familyMember` object because when this object changes, you can be pretty sure
    that a new movie was just inserted. The `userInfo` dictionary contains keys for
    the inserted, deleted, and updated objects. In this case, you should look for
    the updated objects because users can't delete or insert new family members in
    this view. If the family member was updated, the table view is reloaded so that
    it shows the new data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code subscribes `MoviesViewController` to changes in the persistent
    container''s managed object context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When the view loads, the current `MoviesViewController` instance is added as
    an observer to the `.NSManagedObjectContextObjectsDidChange` notification. Go
    ahead and build your app; you should now see the user interface update whenever
    you add new data to your database.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we learned how to respond to database changes using two different
    methods: `NSFetchedResultsController` and notifications. In the next section,
    we are going to learn how to manage multiple instances of `NSManagedObjectContext`
    in order to improve the user interface response when dealing with heavy tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the use of multiple instances of NSManagedObjectContext
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It has been mentioned several times in this chapter that you can use multiple
    managed object contexts. In many cases, you will only need a single managed object
    context. Using a single managed object context means that all of the code related
    to the managed object context is executed on the main thread. If you're performing
    small operations, that's fine. However, imagine importing large amounts of data.
    An operation such as that could take a while. Executing code that runs for a while
    on the main thread will cause the user interface to become unresponsive. This
    is not good, because the user will think your app has crashed. So, how do you
    work around this? The answer is using multiple managed object contexts.
  prefs: []
  type: TYPE_NORMAL
- en: In the past, using several managed object contexts was not easy to manage; you
    had to create instances of `NSManagedObjectContext` using the correct queues yourself.
    Luckily, `NSPersistentContainer` helps to make complex setups a lot more manageable.
    If you want to import data on a background task, you can obtain a managed object
    context by calling `newBackgroundContext()` on the persistent container. Alternatively,
    you can call `performBackgroundTask` on the persistent container and pass it a
    closure with the processing you want to do in the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'One important thing to understand about Core Data, background tasks, and multithreading
    is that you must always use a managed object context on the same thread it was
    created on. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The behavior of this code can cause you a couple of headaches. The background
    context was created in a different queue than the one it's used it in. It's always
    best to make sure to use a managed object context in the same queue it was created
    in by using the `perform(_:)` method of `NSManagedObject`. More importantly, you
    must also make sure to use the managed objects you retrieve on the same queue
    that the managed object context belongs to.
  prefs: []
  type: TYPE_NORMAL
- en: Often, you'll find that it's best to fetch data on the main queue using the
    `viewContext` persistent containers. Storing data can be delegated to background
    contexts if needed. If you do this, you must make sure that the background context
    is a child context of the main context. When this relationship is defined between
    the two contexts, your main context will automatically receive updates when the
    background context is persisted. This is quite convenient because it removes a
    lot of manual maintenance, which keeps your contexts in sync. Luckily, the persistent
    container takes care of this for you.
  prefs: []
  type: TYPE_NORMAL
- en: When you find that your app requires a setup with multiple managed object contexts,
    it's essential to keep the rules mentioned in this section in mind. Bugs related
    to using managed objects or managed object contexts in the wrong places are often
    tedious to debug and hard to discover. When implemented carefully, complex setups
    with multiple managed object contexts can increase your application's performance
    and flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: In our project `saveFamily(…)` method inside the `FamilyMembersViewController`
    file was using the `viewContext` to persist data. Let's refactor this code to
    use different managed object contexts and improve the performance of the app.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the persisting code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `viewContext` (you can see this in the `FamilyMembersViewController`
    file, inside the `saveFamily` method). Remember that we said before that `viewContext`
    is associated with the main queue of the application. Therefore, we can block
    the UI if we do any heavy work with it (usually, persisting data can incur heavy
    work!). So, it is a good idea to use `viewContext` just to read changes in Core
    Data and use a different managed object context (in a background queue) to persist
    them. In this way, we will not block the UI while we persist large amounts of
    data. Let's do this refactor.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code bundle of the chapter, open the project named `MustC_refactor_start`.
    Open the `FamilyMembersViewController` file and replace `saveFamilyMember(…)`
    with the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go through the comments (notice that we have the old method by the name
    of `saveFamilyMemberOld` for reference; you can compare both to see the differences):'
  prefs: []
  type: TYPE_NORMAL
- en: First, we make use of the `performBackgroundTask` persistent container method.
    Each time this method is invoked, the persistent container creates a new `NSManagedObjectContext`
    with `concurrencyType` set to `.privateQueueConcurrencyType`. The persistent container
    then executes the passed-in block against that newly created context on the context's
    private queue. We can use this new `moc` object to persist data in a background
    queue, without the risk of blocking the user interface. Note how in our previous
    method (`saveFamilyMemberOld`), we were using the `viewContext` managed object
    context, which can block the user interface if the data to persist is large.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Second, we create a `familyMember` instance inside our managed object context
    (`moc`) and we update its name. When you create an instance of a managed object,
    you must provide the managed object context where the instance will be temporarily
    stored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Last, in the third comment, we save. Saving the managed object context can fail,
    so you must wrap the `save()` call in a `do {} catch {}` block so that it correctly
    handles potential errors. If the managed object context can't be saved, all unsaved
    changes are rolled back.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's run the app and add a family member. Oops! Nothing. You will see
    that when you add the member, the table that displays the existing members doesn't
    update. However, if you stop and relaunch the app, the new member is there. So,
    what is happening? Looks like we are saving the data, but the user interface doesn't
    know about it (until we relaunch and it is reloaded). Why is that? We are persisting
    the data with a private managed object context, and `viewContext` doesn't know
    about it. Let's fix this.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `viewDidLoad` method, add this line, just after `let moc = persistentContainer.viewContext`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Setting `automaticallyMergesChangesFromParent` to `true` basically makes `viewContext`
    aware of any changes that other contexts are performing in the persisting store.
    If you execute the app now and add a family member, you will see how the table
    reflects the changes immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Now, as practice, you can do the same in the `MoviesViewController` file, modifying
    the `saveMovie` method and setting the `automaticallyMergesChangesFromParent`
    property of `viewContext` to `true`. Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned how to use multiple managed object contexts
    to improve the performance of your Core Data code. Let's wrap up the chapter now
    with a summary.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter showed you how to implement a relatively simple Core Data database
    that stores family members and their favorite movies. You used the Core Data model
    editor in Xcode to configure the models you wanted to store and define the relationship
    between these models. Once the models were set up, you implemented code that created
    instances of your models so that they could be stored in the database and retrieved
    later.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you retrieved the data from the database and saw that your table views
    don't automatically update when the underlying data changes. You used an `NSFetchedResult`
    controller to fetch family members and listen to changes on the list of family
    members. You saw that this setup is very powerful because you can respond to changes
    in your data quite easily.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you improved the Core Data code by using different managed object contexts,
    using the background object context to persist data, and the main queue object
    context to react to the changes and refresh the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to enrich the data your users add to
    the database by fetching and storing data from the web.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Core Data* book, by Florian Kugler and Daniel Eggert
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apple''s Predicate Programming Guide: [http://apple.co/2fF3qHc](http://apple.co/2fF3qHc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
