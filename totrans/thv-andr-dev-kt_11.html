<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-159"><a id="_idTextAnchor160" class="calibre6 pcalibre1 pcalibre"/>8</h1>
<h1 id="_idParaDest-160" class="calibre5"><a id="_idTextAnchor161" class="calibre6 pcalibre1 pcalibre"/>Adding Media Playback to Packtflix with ExoPlayer</h1>
<p class="calibre3">In the journey of Android development, the ability to create rich, engaging multimedia applications is a crucial skill that sets apart great apps from the good ones. As we venture further into the creation of our Netflix-like app, we’ll transition from the foundational structures and user interfaces for browsing movie lists and details to the core of multimedia experiences: video playback. This chapter is dedicated to unlocking the potential of video content within our application, a feature that will significantly enhance user engagement and satisfaction. Here, we will travel into the world of media playback on Android, focusing on the powerful and versatile library known as ExoPlayer.</p>
<p class="calibre3">ExoPlayer stands out in the Android ecosystem as a robust, open-source library that provides an alternative to the standard Android MediaPlayer API. It offers extensive customization options and supports a wide range of media formats, including those not natively supported by Android. Our exploration will begin with an overview of media options in Android, setting the stage for why ExoPlayer is the library of choice for modern Android applications seeking to offer a superior media playback experience.</p>
<p class="calibre3">Following the introduction to media options, we will learn the basics of ExoPlayer, covering its architecture, key components, and how it integrates within an Android application. This foundational knowledge will prepare us to tackle the practical aspects of implementing video playback. This chapter will guide you through creating a responsive, intuitive video playback UI that meets the expectations of today’s users.</p>
<p class="calibre3">The journey will continue with hands-on examples and detailed guidance on playing videos using ExoPlayer. This includes managing playback controls, adjusting video quality, and handling various media sources. Additionally, while recognizing the importance of accessibility and global reach, you’ll learn how to add subtitles to your videos, ensuring your content is accessible to a wider audience.</p>
<p class="calibre3">By the end of this chapter, you will have mastered the essentials of video playback in Android, equipped with the skills to enrich your applications with high-quality video content, creating immersive experiences for your users.</p>
<p class="calibre3">In this chapter, we will cover the following topics:</p>
<ul class="calibre15">
<li class="calibre14">Reviewing media options in Android</li>
<li class="calibre14">Reviewing Android’s media options</li>
<li class="calibre14">Creating the video playback user interface</li>
<li class="calibre14">Playing video using ExoPlayer</li>
<li class="calibre14">Adding subtitles to the video player</li>
</ul>
<h1 id="_idParaDest-161" class="calibre5"><a id="_idTextAnchor162" class="calibre6 pcalibre1 pcalibre"/>Technical requirements</h1>
<p class="calibre3">As in the previous chapter, you will need to have Android Studio (or another editor of your preference) installed.</p>
<p class="calibre3">We will continue working on the same project we started in <a href="B19443_07.xhtml#_idTextAnchor142" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 7</em></a>. You can find the complete code that we are going to build throughout this chapter in this book’s GitHub repository: <a href="https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-8" class="calibre6 pcalibre1 pcalibre">https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-8</a>.</p>
<h1 id="_idParaDest-162" class="calibre5"><a id="_idTextAnchor163" class="calibre6 pcalibre1 pcalibre"/>Reviewing Android’s media options</h1>
<p class="calibre3">Android, as a versatile mobile operating system, offers comprehensive support for various types of media, including but not limited to audio files (such as MP3, WAV, and OGG) and video <a id="_idIndexMarker899" class="calibre6 pcalibre1 pcalibre"/>content (such as MP4, WebM, and MKV). This broad support empowers developers to incorporate a wide range of media types into their applications that can be used for diverse user preferences and use cases. From educational apps that leverage video tutorials for learning to entertainment platforms streaming movies and music, media playback is at the heart of modern mobile applications, driving user engagement and satisfaction.</p>
<p class="calibre3">To start our journey, let’s look at which options we have in the Android ecosystem so that we can choose the most appropriate option to build the playback functionality of our app. We will start with MediaPlayer API and VideoView before considering ExoPlayer.</p>
<h2 id="_idParaDest-163" class="calibre7"><a id="_idTextAnchor164" class="calibre6 pcalibre1 pcalibre"/>Learning about the MediaPlayer API</h2>
<p class="calibre3">The <strong class="bold">MediaPlayer</strong> API is a powerful and flexible class that allows Android developers to handle <a id="_idIndexMarker900" class="calibre6 pcalibre1 pcalibre"/>audio and video playback with a high degree <a id="_idIndexMarker901" class="calibre6 pcalibre1 pcalibre"/>of control. The API is designed to be easy to use yet capable of catering to complex media playback requirements.</p>
<p class="calibre3">Its main <a id="_idIndexMarker902" class="calibre6 pcalibre1 pcalibre"/>features are as follows:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">Versatile media source support</strong>: MediaPlayer can play media from various sources, including local files (such as device storage or SD cards), raw resources (which are bundled within the app), and network streams (HTTP/HTTPS).</li>
<li class="calibre14"><strong class="bold">Playback control</strong>: It offers comprehensive control over media playback, including play, pause, stop, rewind, and fast-forward options, as well as the ability to seek specific timestamps.</li>
<li class="calibre14"><strong class="bold">Volume control</strong>: The MediaPlayer API in Android allows developers to programmatically adjust the volume of audio playback. This is achieved through methods such as <strong class="source-inline1">setVolume(float leftVolume, float rightVolume)</strong>, which controls the volume level of the left and right speakers independently. This feature is essential for creating applications that can dynamically adjust the playback volume based on specific user settings, environmental conditions, or application scenarios. For instance, an app might automatically lower the volume during nighttime hours or increase it in a noisy environment to enhance user experience.</li>
<li class="calibre14"><strong class="bold">Event handling</strong>: MediaPlayer provides listeners that can be used to respond to media life cycle events, such as completion, preparation, error handling, and buffering updates.</li>
<li class="calibre14"><strong class="bold">Audio focus management</strong>: Essential for apps that play audio, MediaPlayer can handle audio focus to ensure a smooth user experience when multiple apps potentially play sounds simultaneously.</li>
</ul>
<p class="calibre3">As we can see, MediaPlayer provides the basic functionality we need for simple audio and video <a id="_idIndexMarker903" class="calibre6 pcalibre1 pcalibre"/>handling, so it could be a good solution for the following cases:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">Music players</strong>: MediaPlayer is well-suited for apps that play music or podcast files, whether it’s stored locally or streamed over the internet</li>
<li class="calibre14"><strong class="bold">Video players</strong>: Although MediaPlayer requires more setup for video playback compared to VideoView, it’s ideal for custom video player applications where developers need control over rendering and playback</li>
<li class="calibre14"><strong class="bold">Game sound effects</strong>: For games that need to play short sound effects, MediaPlayer can be used for its simplicity and ability to handle various audio formats</li>
</ul>
<p class="calibre3">Here’s an <a id="_idIndexMarker904" class="calibre6 pcalibre1 pcalibre"/>example of how to reproduce <a id="_idIndexMarker905" class="calibre6 pcalibre1 pcalibre"/>an audio file using MediaPlayer:</p>
<pre class="source-code">
@Composable
fun AudioPlayerComposable() {
    val context = LocalContext.current
    val mediaPlayer = remember { MediaPlayer.create(
        context, R.raw.my_audio_file) }
    // Observe lifecycle to release MediaPlayer
    ObserveLifecycle(owner = ProcessLifecycleOwner.get()) {
        onExit = {
            mediaPlayer.release()
        }
    }
    Column(modifier = Modifier.padding(16.dp)) {
        Button(onClick = {
            if (!mediaPlayer.isPlaying) {
                mediaPlayer.start()
            }
        }) {
            Text("Play")
        }
        Button(onClick = {
            if (mediaPlayer.isPlaying) {
                mediaPlayer.pause() // Use pause or stop
                                       based on your need
            }
        }) {
            Text("Stop")
        }
    }
}
@Composable
fun ObserveLifecycle(owner: LifecycleOwner, onExit: () -&gt;
Unit) {
    // Use DisposableEffect to manage lifecycle
    DisposableEffect(owner) {
        val observer = LifecycleEventObserver { _, event -&gt;
            if (event == Lifecycle.Event.ON_DESTROY) {
                onExit()
            }
        }
        owner.lifecycle.addObserver(observer)
        onDispose {
            owner.lifecycle.removeObserver(observer)
        }
    }
}</pre> <p class="calibre3">In this example, <code>MediaPlayer.create()</code> is used within the <code>remember</code> block to ensure that the media player is only instantiated once, maintaining this instance across recompositions <a id="_idIndexMarker906" class="calibre6 pcalibre1 pcalibre"/>of the composable. Then, the <code>ObserveLifecycle</code> composable function is used to observe the life cycle of the entire application (using <code>ProcessLifecycleOwner</code> here for simplicity). This function <a id="_idIndexMarker907" class="calibre6 pcalibre1 pcalibre"/>ensures that <code>mediaPlayer.release()</code> is called to free up resources when the app is destroyed, although you might adapt this to more specific life cycle events as needed.</p>
<p class="calibre3">The UI consists of two buttons for play and stop functionalities. The play button’s <code>onClick</code> logic checks if the media is not currently playing before starting playback. This is done to avoid restarting the audio and video if the button is pressed during playback. Similarly, the stop button pauses the playback.</p>
<p class="calibre3">This example demonstrates how to integrate MediaPlayer with Jetpack Compose while managing the media player life cycle and providing a simple UI for controlling playback. You can find more examples in the official documentation: <a href="https://developer.android.com/media/platform/mediaplayer" class="calibre6 pcalibre1 pcalibre">https://developer.android.com/media/platform/mediaplayer</a>.</p>
<p class="calibre3">Although our example illustrates how to provide the playback control UI, we still need to show the video so that our users can watch it. This is where VideoView comes in.</p>
<h2 id="_idParaDest-164" class="calibre7"><a id="_idTextAnchor165" class="calibre6 pcalibre1 pcalibre"/>Learning about VideoView</h2>
<p class="calibre3"><strong class="bold">VideoView</strong> is a higher-level UI component in Android that encapsulates the functionality <a id="_idIndexMarker908" class="calibre6 pcalibre1 pcalibre"/>of MediaPlayer and SurfaceView to provide a convenient way to play video files. It simplifies the process of video playback by managing the underlying <a id="_idIndexMarker909" class="calibre6 pcalibre1 pcalibre"/>media playback mechanics, making it ideal for use cases that require straightforward video playback without the need for fine-grained control over the media pipeline.</p>
<p class="callout-heading">Note</p>
<p class="callout">SurfaceView is a specialized component in the Android framework that provides a dedicated drawing surface within the app’s view hierarchy. Unlike standard views, which are drawn onto a single canvas managed by the UI thread, SurfaceView can be rendered independently in a separate thread. This allows for more efficient redrawing, especially for demanding content such as video playback or dynamic graphics. SurfaceView is particularly useful when you need to update your views frequently or when the rendering process is computationally intensive as it does not block user interaction while drawing.</p>
<p class="calibre3">Let’s explore <a id="_idIndexMarker910" class="calibre6 pcalibre1 pcalibre"/>some of VideoView’s features so that we can appreciate the practical benefits it offers:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">Simplicity</strong>: VideoView simplifies the implementation of video playback. You can start playing a video with just a few lines of code, handling preparation and playback of the video file automatically.</li>
<li class="calibre14"><strong class="bold">Control integration</strong>: It can be easily integrated with media controls (using MediaController), allowing users to play, pause, and seek through the video.</li>
<li class="calibre14"><strong class="bold">Format support</strong>: VideoView supports various video formats that Android’s MediaPlayer <a id="_idIndexMarker911" class="calibre6 pcalibre1 pcalibre"/>supports, including MP4, 3GP, and more, depending on the device and platform version.</li>
<li class="calibre14"><strong class="bold">Layout flexibility</strong>: Being a view, VideoView can be placed anywhere in your application’s layout and can be resized and styled as needed, just like any other UI component.</li>
</ul>
<p class="calibre3">Understanding VideoView’s features sets the stage for its practical applications. Now, let’s pinpoint <a id="_idIndexMarker912" class="calibre6 pcalibre1 pcalibre"/>exactly where VideoView shines. Here are the best scenarios for using VideoView in your app:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">Simple video playback</strong>: When you need to play videos without requiring advanced playback features such as adaptive streaming, VideoView is a straightforward <a id="_idIndexMarker913" class="calibre6 pcalibre1 pcalibre"/>and effective choice. Adaptive streaming, such <a id="_idIndexMarker914" class="calibre6 pcalibre1 pcalibre"/>as <strong class="bold">HTTP Live Streaming</strong> (<strong class="bold">HLS</strong>) and <strong class="bold">Dynamic Adaptive Streaming over HTTP</strong> (<strong class="bold">DASH</strong>), allows videos to be delivered in varying qualities, depending on network conditions. HLS is widely used for live and on-demand streaming on the web, as well as dynamically adjusting video quality based on the viewer’s internet speed. Similarly, DASH is a flexible standard that enables high-quality streaming of media content over the internet.</li>
<li class="calibre14"><strong class="bold">Local and network videos</strong>: It’s suitable for playing videos stored locally on the device or streamed over the network.</li>
<li class="calibre14"><strong class="bold">Embedded video content</strong>: VideoView is great for applications that need to embed video content directly within their UI, such as tutorial apps, video players, or social media apps with video feeds.</li>
</ul>
<p class="calibre3">Now that we know its features and recommended use cases, let’s look at an example so that we understand how it works. In this example, we’re using the 1.7.0 version of the <code>androidx.media:media</code> library:</p>
<pre class="source-code">
@Composable
fun VideoPlayer(modifier: Modifier = Modifier, videoUrl:
String) {
    val context = LocalContext.current
    AndroidView(
        modifier = modifier,
        factory = { ctx -&gt;
            VideoView(ctx).apply {
                val mediaController = MediaController(ctx)
                setMediaController(mediaController)
                mediaController.setAnchorView(this)
                setVideoURI(Uri.parse(videoUrl))
                start() // Auto-start playback
            }
        }
    )
}</pre> <p class="calibre3">Here, we start by <a id="_idIndexMarker915" class="calibre6 pcalibre1 pcalibre"/>declaring a composable called <code>VideoPlayer</code>. This composable <a id="_idIndexMarker916" class="calibre6 pcalibre1 pcalibre"/>accepts a <code>videoUrl</code> string as a parameter. This specifies the location of the video to be played.</p>
<p class="calibre3">Within the function, <code>LocalContext.current</code> is used to obtain the current context from the Compose environment. The <code>AndroidView</code> composable is then employed to bridge the gap between traditional Android UI components and the Compose world. It takes a factory Lambda expression where <code>VideoView</code> is instantiated by using the context.</p>
<p class="calibre3">Next, <code>MediaController</code> is created and associated with <code>VideoView</code> through <code>setMediaController()</code>, providing standard media controls such as play, pause, and seek to enhance user interaction with the video playback.</p>
<p class="calibre3">The media <a id="_idIndexMarker917" class="calibre6 pcalibre1 pcalibre"/>controller is anchored to <code>VideoView</code> using <code>setAnchorView(this)</code>, ensuring that the control interface is displayed <a id="_idIndexMarker918" class="calibre6 pcalibre1 pcalibre"/>correctly concerning the video view. The video URL that’s passed to the function is parsed into a <code>Uri</code> component and set on <code>VideoView</code> with <code>setVideoURI()</code>, pointing the player to the video content.</p>
<p class="calibre3">Finally, <code>start()</code> is called on <code>VideoView</code> to initiate video playback automatically as soon as the setup is complete and the video is ready to be shown.</p>
<p class="calibre3">In this section, we took a sneak peek at how the MediaPlayer API and VideoView work and their features. Now, it’s time for the crown jewel: ExoPlayer.</p>
<h1 id="_idParaDest-165" class="calibre5"><a id="_idTextAnchor166" class="calibre6 pcalibre1 pcalibre"/>Understanding the basics of ExoPlayer</h1>
<p class="calibre3"><strong class="bold">ExoPlayer</strong> stands as a significant advancement over Android’s basic MediaPlayer, offering a level <a id="_idIndexMarker919" class="calibre6 pcalibre1 pcalibre"/>of flexibility, customization, and support for advanced streaming formats that MediaPlayer simply cannot match. This superiority makes ExoPlayer the go-to choice for developers needing robust, feature-rich media playback capabilities in their applications.</p>
<p class="calibre3">One of ExoPlayer’s most compelling advantages is its adaptability. Unlike the relatively static MediaPlayer, ExoPlayer can be easily adapted and extended to suit specific application needs. Its modular architecture allows developers to include only the components they need, reducing the app’s overall size. Furthermore, ExoPlayer’s customization options extend to its user interface, with the ability to create custom controls and layouts that seamlessly integrate with the rest of the application’s design. This adaptability ensures that developers can craft a unique media playback experience that aligns perfectly with their app’s branding and user interface guidelines.</p>
<p class="calibre3">In the realm of streaming, ExoPlayer’s strengths become even more apparent. It offers out-of-the-box support for modern streaming protocols such as HLS and DASH. These adaptive streaming protocols are essential for delivering content efficiently over the internet, adjusting the quality of the stream in real time based on the user’s current network conditions. This ensures an optimal viewing experience that minimizes buffering and playback interruptions even under fluctuating network speeds.</p>
<p class="calibre3">MediaPlayer, by contrast, offers limited support for such streaming protocols, often requiring developers to implement additional solutions or workarounds to achieve similar functionality. With ExoPlayer, developers gain direct access to these advanced features, simplifying the development process and enhancing the end user experience.</p>
<p class="calibre3">As we can see, ExoPlayer’s functionality is widely superior due to its flexibility and wide format support <a id="_idIndexMarker920" class="calibre6 pcalibre1 pcalibre"/>and those are the reasons we will use it in this project. On the other hand, as it is more complex, we will have to learn more about it before we start to implement our video player using it.</p>
<p class="calibre3">Well, let’s do exactly that and break down ExoPlayer’s architecture.</p>
<h2 id="_idParaDest-166" class="calibre7"><a id="_idTextAnchor167" class="calibre6 pcalibre1 pcalibre"/>Exploring ExoPlayer’s architecture</h2>
<p class="calibre3">ExoPlayer’s architecture is designed to be both flexible and extensible, making it capable of handling a <a id="_idIndexMarker921" class="calibre6 pcalibre1 pcalibre"/>wide range of media playback scenarios. ExoPlayer has several core components that work together to provide a robust and efficient media playback experience. Understanding these components is key to leveraging ExoPlayer’s full capabilities in our applications. Let’s take a look at them here.</p>
<h3 class="calibre9">The ExoPlayer instance – the central media playback engine</h3>
<p class="calibre3">The ExoPlayer instance itself acts as the central hub for media playback, orchestrating the interaction between the various components involved in the playback process, managing the <a id="_idIndexMarker922" class="calibre6 pcalibre1 pcalibre"/>playback state, and coordinating the <a id="_idIndexMarker923" class="calibre6 pcalibre1 pcalibre"/>fetching, decoding, and rendering of media. Unlike Android’s MediaPlayer, which operates as a black box, ExoPlayer provides developers with detailed control over playback and access to the playback pipeline, enabling fine-tuned adjustments to fit the application’s specific needs.</p>
<p class="calibre3">Here’s a simple example of how to initialize ExoPlayer and prepare it to play a media item:</p>
<pre class="source-code">
val context = ... // Your context here
val player = ExoPlayer.Builder(context).build().apply {
    // Media item to be played
    val mediaItem =
        MediaItem.fromUri("http://example.com/media.mp3")
    // Set the media item to be played
    setMediaItem(mediaItem)
    // Prepare the player
    prepare()
    // Start playback
    playWhenReady = true
}</pre> <p class="calibre3">The process begins with creating an <code>ExoPlayer</code> instance, utilizing a context-aware builder pattern <a id="_idIndexMarker924" class="calibre6 pcalibre1 pcalibre"/>that ensures the player is <a id="_idIndexMarker925" class="calibre6 pcalibre1 pcalibre"/>configured for the environment where it operates. Following its instantiation, a media item is specified through a URI, which could either point to a local resource or a remote media file. This media item is then associated with the <code>ExoPlayer</code> instance, indicating what content it should be prepared to play.</p>
<p class="calibre3">Once the media item has been set, the player enters a preparation phase by invoking the <code>prepare()</code> method. During this phase, ExoPlayer analyzes the media, setting up necessary buffers and decoding resources to ensure smooth playback.</p>
<p class="calibre3">The final step in the process involves setting the player’s <code>playWhenReady</code> property to <code>true</code>, a command that triggers playback as soon as the player is fully prepared. This property provides flexibility, allowing developers to control when playback should start. This can be immediately after preparation or delayed based on additional conditions or user interactions.</p>
<h3 class="calibre9">MediaItem – sourcing the media resource</h3>
<p class="calibre3">In ExoPlayer, <strong class="bold">MediaItem</strong> encapsulates <a id="_idIndexMarker926" class="calibre6 pcalibre1 pcalibre"/>details about a media source, such as <a id="_idIndexMarker927" class="calibre6 pcalibre1 pcalibre"/>its URI, metadata, and any configuration related to playback. It is a versatile and essential component that tells ExoPlayer what <a id="_idIndexMarker928" class="calibre6 pcalibre1 pcalibre"/>content to load and play.  These are the key functions of MediaItem:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">Media source specification</strong>: The primary function of MediaItem is to specify the location of the media to be played. This can be a file path, a URL, or a content URI, among other formats.</li>
<li class="calibre14"><strong class="bold">Media configuration</strong>: Beyond just specifying a media source, MediaItem allows for detailed configuration of the playback. This includes setting DRM configurations, specifying subtitles, and defining custom attributes through metadata.</li>
<li class="calibre14"><strong class="bold">Adaptive streaming</strong>: For adaptive streaming content (such as DASH and HLS), MediaItem can include the necessary information for ExoPlayer to adapt the stream’s quality dynamically based on network conditions. This information includes metadata such as the URLs of the various stream segments, available quality levels, and codecs.</li>
<li class="calibre14"><strong class="bold">Playback options</strong>: Developers can use MediaItem to configure specific playback options, such as start and end positions, looping, and more. These options provide fine-grained control over how the media is played.</li>
</ul>
<p class="calibre3">In practice, once a MediaItem is created and configured, it is passed to the ExoPlayer instance so that it can be prepared for playback. You can load a single MediaItem for simple playback scenarios or manage a playlist by loading multiple MediaItems. Let’s see a brief example:</p>
<pre class="source-code">
val mediaItem =
    MediaItem.fromUri("https://example.com/video.mp4")
player.setMediaItem(mediaItem)
player.prepare() // Prepares the player with the provided
                    MediaItem
player.playWhenReady = true // Starts playback as soon as
                               preparation is complete</pre> <p class="calibre3">In this <a id="_idIndexMarker929" class="calibre6 pcalibre1 pcalibre"/>example, we are creating <code>mediaItem</code> from a URL and preparing it <a id="_idIndexMarker930" class="calibre6 pcalibre1 pcalibre"/>to be reproduced by the ExoPlayer instance.</p>
<h3 class="calibre9">TrackSelector – managing media tracks</h3>
<p class="calibre3">The <code>TrackSelector</code> instance is a critical component of ExoPlayer that’s responsible for selecting <a id="_idIndexMarker931" class="calibre6 pcalibre1 pcalibre"/>the specific tracks to be played. A video might contain multiple audio tracks in different languages, several video qualities, or various subtitle tracks, and <code>TrackSelector</code> decides which of these tracks are <a id="_idIndexMarker932" class="calibre6 pcalibre1 pcalibre"/>best suited for the current playback context based on the device’s capabilities, user preferences, and network conditions. This selection process is crucial for adaptive streaming scenarios as a single video is encoded at multiple quality levels and stored on the server.</p>
<p class="calibre3">Here’s an example of its use:</p>
<pre class="source-code">
val trackSelector =
    DefaultTrackSelector(context).apply {
        setParameters(buildUponParameters()
            .setPreferredAudioLanguage("en")
}
val player = ExoPlayer.Builder(context)
    .setTrackSelector(trackSelector)
    .build()</pre> <p class="calibre3">The process starts with the creation of a <code>DefaultTrackSelector</code> instance. The <code>DefaultTrackSelector</code> instance is a component of <code>ExoPlayer</code> that decides which tracks (audio, video, or text) are played from the media based on various criteria, such as the user’s device capabilities and the tracks’ properties. In this example, the track selector is configured to prefer audio tracks in English. This preference is set by modifying the track selector’s parameters, indicating that if the media contains multiple audio tracks in different languages, the English one should be chosen, if available.</p>
<p class="calibre3">After configuring the track selector, it’s used in the construction of the <code>ExoPlayer</code> instance. Here, <code>ExoPlayer.Builder</code> is provided with the application context and the customized track selector when building the player. This ensures that when the <code>ExoPlayer</code> instance prepares and plays media, it uses the logic defined in <code>DefaultTrackSelector</code> for track selection. Essentially, this setup allows for more control over which audio track is selected during playback, based on the predefined criteria (in this case, the language preference).</p>
<p class="calibre3">This approach <a id="_idIndexMarker933" class="calibre6 pcalibre1 pcalibre"/>to configuring ExoPlayer is particularly beneficial in <a id="_idIndexMarker934" class="calibre6 pcalibre1 pcalibre"/>applications that deal with media containing multiple tracks for different audience demographics or in scenarios where the application needs to adhere to user preferences or settings, such as a language selection option. By customizing the track selector, developers can ensure that the media playback experience is optimized for the specific needs and preferences of their users, enhancing overall usability and satisfaction.</p>
<h3 class="calibre9">LoadControl – handling buffering and loading</h3>
<p class="calibre3">The <code>LoadControl</code> component oversees the strategy for buffering and loading media resources. Efficient buffering is essential for smooth playback, especially in streaming scenarios <a id="_idIndexMarker935" class="calibre6 pcalibre1 pcalibre"/>where network conditions can vary widely. The <code>LoadControl</code> component determines how much media data to <a id="_idIndexMarker936" class="calibre6 pcalibre1 pcalibre"/>buffer at any given time, striking a balance between reducing initial loading times and minimizing the likelihood of playback interruptions. We can customize the buffering policy to cater to specific requirements, such as prioritizing quick start times or ensuring uninterrupted playback.</p>
<p class="calibre3">The following is an example of creating a custom <code>LoadControl</code> component to modify the buffer policy:</p>
<pre class="source-code">
val loadControl = DefaultLoadControl.Builder().apply {
    // Set minimum buffer duration to 2 minutes
    setBufferDurationsMs(
        minBufferMs = 2 * 60 * 1000,
        maxBufferMs =
            DefaultLoadControl.DEFAULT_MAX_BUFFER_MS,
        bufferForPlaybackMs =
            DefaultLoadControl
            .DEFAULT_BUFFER_FOR_PLAYBACK_MS,
        bufferForPlaybackAfterRebufferMs =
            DefaultLoadControl
            .DEFAULT_BUFFER_FOR_PLAYBACK_AFTER_REBUFFER_MS
    )
}.build()
val player = ExoPlayer.Builder(context)
    .setLoadControl(loadControl)
    .build()
// Continue setting up the player as before</pre> <p class="calibre3">The example <a id="_idIndexMarker937" class="calibre6 pcalibre1 pcalibre"/>begins by creating an instance of <code>DefaultLoadControl</code> using <code>Builder</code>. Here, <code>DefaultLoadControl</code> is an implementation <a id="_idIndexMarker938" class="calibre6 pcalibre1 pcalibre"/>of the <code>LoadControl</code> interface provided by ExoPlayer and is designed to manage media buffering based on various parameters that I will explain now.</p>
<p class="calibre3">The <code>setBufferDurationsMs</code> method is called on the builder to specify custom buffer durations. Specifically, it sets the minimum buffer duration (<code>minBufferMs</code>) to 2 minutes (120,000 milliseconds). This means that ExoPlayer will attempt to buffer at least 2 minutes of media before starting playback, which can help ensure smooth playback under varying network conditions.</p>
<p class="calibre3">The other parameters (<code>maxBufferMs</code>, <code>bufferForPlaybackMs</code>, and <code>bufferForPlaybackAfterRebufferMs</code>) are set to their default values, which are predefined in <code>DefaultLoadControl</code>. These parameters control the maximum buffer size, the minimum amount of media that must be buffered for playback to start, and the <a id="_idIndexMarker939" class="calibre6 pcalibre1 pcalibre"/>minimum amount of media that <a id="_idIndexMarker940" class="calibre6 pcalibre1 pcalibre"/>must be buffered to resume playback after a rebuffer, respectively.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you want to learn more about the aforementioned options, you can find all the details in the <a id="_idIndexMarker941" class="calibre6 pcalibre1 pcalibre"/>documentation for <strong class="source-inline1">DefaultLoadControl.Builder</strong>: <a href="https://developer.android.com/reference/androidx/media3/exoplayer/DefaultLoadControl.Builder" class="calibre6 pcalibre1 pcalibre">https://developer.android.com/reference/androidx/media3/exoplayer/DefaultLoadControl.Builder</a>.</p>
<p class="calibre3">After configuring the buffer durations, the <code>build()</code> method is called to create the <code>DefaultLoadControl</code> instance with the specified settings.</p>
<p class="calibre3">This custom <code>LoadControl</code> component is then set on a new <code>ExoPlayer</code> instance through the <code>setLoadControl</code> method of <code>ExoPlayer.Builder</code>. This step integrates the custom buffering strategy with the player, meaning that the player will use the specified buffer durations during playback.</p>
<p class="calibre3">Finally, the <code>build</code> method is called on <code>ExoPlayer.Builder</code> to create the <code>ExoPlayer</code> instance that was configured with the custom <code>LoadControl</code> component.</p>
<h3 class="calibre9">Renderers – rendering media to outputs</h3>
<p class="calibre3">Renderers are <a id="_idIndexMarker942" class="calibre6 pcalibre1 pcalibre"/>the components that output the media to <a id="_idIndexMarker943" class="calibre6 pcalibre1 pcalibre"/>the appropriate destination, such as rendering video frames to the screen or audio samples to speakers. ExoPlayer uses separate renderers for different types of tracks, allowing for parallel processing and rendering of audio, video, and text tracks. This separation enables ExoPlayer to support a wide range of media types and formats efficiently. Moreover, developers can implement custom renderers to handle non-standard media types or apply special processing to media before playback.</p>
<p class="calibre3">To illustrate <a id="_idIndexMarker944" class="calibre6 pcalibre1 pcalibre"/>this, consider the following example, where a <a id="_idIndexMarker945" class="calibre6 pcalibre1 pcalibre"/>custom renderer is being used to apply a grayscale filter to video content:</p>
<pre class="source-code">
class GrayscaleVideoRenderer(
    eventHandler: Handler,
    videoListener: VideoRendererEventListener,
    maxDroppedFrameCountToNotify: Int
) : SimpleDecoderVideoRenderer(eventHandler, videoListener, maxDroppedFrameCountToNotify) {
    override fun onOutputFormatChanged(format: Format,
    outputMediaFormat: MediaFormat?) {
        super.onOutputFormatChanged(format,
            outputMediaFormat)
        // Setup to modify the color format to grayscale
    }
    override fun renderOutputBufferToSurface(buffer:
    OutputBuffer, surface: Surface,
    presentationTimeUs: Long) {
        // Apply grayscale effect to the buffer before
           rendering to the surface
    }
}</pre> <p class="calibre3">The <code>GrayscaleVideoRenderer</code> class extends ExoPlayer’s <code>SimpleDecoderVideoRenderer</code> to apply a grayscale effect to video frames during playback. This customization allows it to not just decode and display the video but also transform each frame to grayscale in real time, enhancing the visual presentation for stylistic choices or accessibility.</p>
<p class="calibre3">When initializing, this renderer takes a <code>Handler</code> component for thread-safe event dispatching, a <code>VideoRendererEventListener</code> component for managing video events, and an <a id="_idIndexMarker946" class="calibre6 pcalibre1 pcalibre"/>integer that sets the threshold for notifying about dropped frames. This <a id="_idIndexMarker947" class="calibre6 pcalibre1 pcalibre"/>setup helps keep the playback smooth and responsive.</p>
<p class="calibre3">It overrides the <code>onOutputFormatChanged</code> method, where it prepares for video format changes. This is where adjustments for grayscale processing would be set up. The <code>renderOutputBufferToSurface</code> method is where the grayscale effect is applied to each video frame before they are rendered to the screen.</p>
<p class="calibre3">Now that we are familiar with the most important components of ExoPlayer, let’s integrate it into our project.</p>
<h2 id="_idParaDest-167" class="calibre7"><a id="_idTextAnchor168" class="calibre6 pcalibre1 pcalibre"/>Integrating ExoPlayer into our project</h2>
<p class="calibre3">To integrate <a id="_idIndexMarker948" class="calibre6 pcalibre1 pcalibre"/>ExoPlayer, we have to include the necessary library dependencies in our version catalog:</p>
<pre class="source-code">
[versions]
...
exoPlayer = "1.2.1"
[libraries]
...
exoPlayer-core = { module = "androidx.media3:media3-exoplayer", version.ref = "exoPlayer" }
exoPlayer-ui = { module = " androidx.media3:media3-ui", version.ref = "exoPlayer" }</pre> <p class="calibre3">As with every dependency that we have included, we must add them to the <code>build.gradle</code> file of the module where we are going to use them. In this case, we’ll add it them the <code>build.gradle</code> file for <code>:feature:playback</code>:</p>
<pre class="source-code">
dependencies {
    implementation(libs.exoPlayer.core)
    implementation(libs.exoPlayer.ui)
}</pre> <p class="calibre3">With these <a id="_idIndexMarker949" class="calibre6 pcalibre1 pcalibre"/>two dependencies, we have all the components we need <a id="_idIndexMarker950" class="calibre6 pcalibre1 pcalibre"/>to use ExoPlayer:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">androidx.media3:media3-exoplayer</strong>: This is the core module of ExoPlayer in the Media3 library. It includes the essential classes and interfaces needed for media playback functionality. This module provides the fundamental components for media playback, including the ExoPlayer interface, media source handling, and playback control logic. It is the backbone of media playback in Media3, offering high-performance, low-level media playback capabilities.</li>
<li class="calibre14"><strong class="source-inline1">androidx.media3:media3-ui</strong>: This module provides user interface components for media playback in the Media3 library. It includes pre-built UI components such as <strong class="source-inline1">PlayerView</strong> (a view that displays video content and playback controls) and other UI elements for controlling media playback. These components can be customized or replaced with custom implementations if needed. This module helps developers quickly integrate ExoPlayer with a functional UI for media playback.</li>
</ul>
<p class="calibre3">Now, we’re all set. In the next section, we will build our playback UI and connect it with ExoPlayer.</p>
<h1 id="_idParaDest-168" class="calibre5"><a id="_idTextAnchor169" class="calibre6 pcalibre1 pcalibre"/>Creating the video playback user interface</h1>
<p class="calibre3">In this section, we’re going to build the video playback UI and focus on the essentials: a title bar, close, play/pause, forward and rewind buttons, a progress bar, and a time indicator. We will <a id="_idIndexMarker951" class="calibre6 pcalibre1 pcalibre"/>start by creating the <code>PlaybackScreen</code> composable, the main composable for this new screen, after which we will add the additional components required to make it function.</p>
<h2 id="_idParaDest-169" class="calibre7"><a id="_idTextAnchor170" class="calibre6 pcalibre1 pcalibre"/>Building PlaybackScreen and its composables</h2>
<p class="calibre3">Let’s <a id="_idIndexMarker952" class="calibre6 pcalibre1 pcalibre"/>start building the <code>PlaybackScreen</code> composable:</p>
<pre class="source-code">
@Composable
fun PlaybackScreen() {
    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(Color.Black)
    ) {
        TopMediaRow(Modifier.align(Alignment.TopCenter))
        PlayPauseButton(Modifier.align(Alignment.Center))
        ProgressBarWithTime(Modifier
            .align(Alignment.BottomCenter))
    }
}</pre> <p class="calibre3">We start by declaring a <code>Box</code> container that fills the entire screen and sets its background to black, mimicking the dark mode typically preferred in video playback interfaces. Within this <code>Box</code>, we place three key components that constitute our playback UI: a top media row, a play/pause button, and a progress bar with a time indicator.</p>
<p class="calibre3">Here, <code>TopMediaRow</code> is positioned at the top center of the screen, likely containing the title bar and close button. Then, <code>PlayPauseButton</code> is placed right in the center of the screen, making it easy for users to start or pause playback with a simple tap. Finally, <code>ProgressBarWithTime</code> is aligned at the bottom center, allowing users to see how much of the video has played and how much is left. Each of these components is aligned within the <code>Box</code> container using the <code>Modifier.align</code> method, ensuring they are positioned exactly where we want them in the UI.</p>
<p class="calibre3">Now that <a id="_idIndexMarker953" class="calibre6 pcalibre1 pcalibre"/>we have built the base of the screen, including every composable needed, it’s time to build them. We will start with the <code>TopMediaRow</code> composable:</p>
<pre class="source-code">
@Composable
fun TopMediaRow(modifier: Modifier = Modifier) {
    Row(
        modifier = modifier.fillMaxWidth().padding(20.dp),
        horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically
    ) {
        Text(text = "S1:E1 - Pilot", color = Color.White)
        Icon(imageVector = Icons.Default.Close,
            contentDescription = "Close",
                tint = Color.White)
    }
}</pre> <p class="calibre3">In this <code>TopMediaRow</code> composable function, we’re designing the top part of our video playback UI, which is specifically tailored for displaying the episode information and a close button. This function uses a <code>Row</code> layout to arrange its elements horizontally across the screen. The modifier that’s applied to this <code>Row</code> layout ensures it stretches to fill the maximum <a id="_idIndexMarker954" class="calibre6 pcalibre1 pcalibre"/>width of its parent <a id="_idIndexMarker955" class="calibre6 pcalibre1 pcalibre"/>container and applies a padding of 20 <strong class="bold">density-independent pixels</strong> (<strong class="bold">dp</strong>) around its edges for a neat, uncluttered look.</p>
<p class="calibre3">Within the <code>Row</code> layout, we use two main components: <code>Text</code> and <code>Icon</code>:</p>
<ul class="calibre15">
<li class="calibre14">The <strong class="source-inline1">Text</strong> component displays the episode information, such as <strong class="bold">S1:E1 ‘Pilot’</strong>, in white color, making it easily visible against the dark background typical of video playback screens.</li>
<li class="calibre14">The <strong class="source-inline1">Icon</strong> component uses the default “close” symbol with its tint also set to white to maintain consistency and visibility. The <strong class="source-inline1">horizontalArrangement</strong> property is set to <strong class="source-inline1">Arrangement.SpaceBetween</strong> to ensure the text and icon are placed on opposite ends of the row, while <strong class="source-inline1">verticalAlignment</strong> keeps them centered vertically within the row.</li>
</ul>
<p class="calibre3">Now, let’s move to the next row, which contains the <code>PlayPauseButton</code> composable:</p>
<pre class="source-code">
@Composable
fun PlayPauseButton(modifier: Modifier = Modifier) {
    Row(
        horizontalArrangement = Arrangement.Center,
        verticalAlignment = Alignment.CenterVertically,
        modifier = modifier
    ) {
        IconButton(
            modifier = Modifier.padding(20.dp),
            onClick = { /* Rewind action */ })
        {
            Icon(
                modifier = Modifier
                    .height(80.dp)
                    .width(80.dp),
                imageVector = Icons.Default.ArrowBack,
                contentDescription = "Rewind 10s",
                tint = Color.White)
        }
        IconButton(
            modifier = Modifier
                .padding(20.dp),
            onClick = { /* Play/Pause action */ }
        ) {
            Icon(
            modifier = Modifier
                .height(80.dp)
                .width(80.dp),
            imageVector = Icons.Default.PlayArrow,
            contentDescription = "Play/Pause",
            tint = Color.White)
        }
        IconButton(
            modifier = Modifier
                .padding(20.dp),
            onClick = { /* Fast-forward action */ }) {
            Icon(
                modifier = Modifier
                    .height(80.dp)
                    .width(80.dp),
                imageVector = Icons.Default.ArrowForward,
                contentDescription = "Fast-forward 10s",
                tint = Color.White)
        }
    }
}</pre> <p class="calibre3">The <code>PlayPauseButton</code> composable function will provide the central control mechanism for video playback and incorporate rewind, play/pause, and fast-forward actions <a id="_idIndexMarker956" class="calibre6 pcalibre1 pcalibre"/>within a single, intuitive interface. This function employs a <code>Row</code> layout to horizontally align its child elements – the buttons for each control action – so that they’re centered both horizontally and vertically.</p>
<p class="calibre3">Each button is created using the <code>IconButton</code> component. These buttons are spaced out with a padding of 20 dp to ensure they’re comfortably tappable without the risk of accidental presses. The icons for rewind, play/pause, and fast-forward are sized uniformly at 80 dp by 80 dp, making them large enough to be easily tapped and visually recognized.</p>
<p class="calibre3">The <code>Icon</code> components within each <code>IconButton</code> are specifically chosen to visually represent their respective actions: an arrow pointing backward for rewind, a play arrow for play/pause, and an arrow pointing forward for fast-forward, each accompanied by a content description for accessibility purposes. The placeholder comments within the <code>onClick</code> parameters indicate where the functionality for each button – rewinding the video by 10 seconds, toggling between playing and pausing, and fast-forwarding by 10 seconds – would be implemented.</p>
<p class="calibre3">Finally, we <a id="_idIndexMarker957" class="calibre6 pcalibre1 pcalibre"/>have one last composable to build, the <code>ProgressBarWithTime</code> composable:</p>
<pre class="source-code">
@Composable
fun ProgressBarWithTime(modifier: Modifier = Modifier) {
    Row(
        modifier = modifier
            .fillMaxWidth()
            .wrapContentHeight()
            .padding(horizontal = 16.dp, vertical = 8.dp),
        horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically
    ) {
            val progress = remember { mutableStateOf(0.3f)
                } // Dummy progress
            val formattedTime = "22:49" // Dummy time
            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment =
                    Alignment.CenterVertically
            ) {
                Slider(
                    value = progress.value,
                    onValueChange =
                        { progress.value = it },
                    modifier = Modifier.weight(1f)
                )
                Spacer(modifier = Modifier.width(8.dp))
                Text(text = formattedTime,
                    color = Color.White)
            }
    }
}</pre> <p class="calibre3">This <a id="_idIndexMarker958" class="calibre6 pcalibre1 pcalibre"/>composable is wrapped in a <code>Row</code> layout, which spans the maximum width available (to accommodate the length of the video) and adjusts its height to wrap the content closely, ensuring a tidy appearance with ample padding around its edges for a balanced layout.</p>
<p class="calibre3">The core functionality centers around two elements:</p>
<ul class="calibre15">
<li class="calibre14">The <strong class="source-inline1">Slider</strong> component represents <a id="_idIndexMarker959" class="calibre6 pcalibre1 pcalibre"/>the video’s progress. It uses a mutable state initialized at <strong class="source-inline1">0.3</strong> (30% progress) to simulate the current position of the video playback. This state is interactively adjustable, allowing users to seek through the video. The <strong class="source-inline1">onValueChange</strong> event updates the progress state, reflecting the user’s input. To visually separate the progress bar from the time indicator and to ensure the layout remains intuitive, a spacer is inserted between these elements, maintaining a clear distinction.</li>
<li class="calibre14">Adjacent to the <strong class="source-inline1">Slider</strong> component, the <strong class="source-inline1">Text</strong> component displays the current playback <a id="_idIndexMarker960" class="calibre6 pcalibre1 pcalibre"/>time (set to <strong class="bold">22:49</strong> for now, until we integrate the playback functionality) in white color. The time is displayed to provide users with exact information about how much of the video has been played or how much is left, enhancing the user experience by offering precise control over video playback.</li>
</ul>
<p class="calibre3">Although it may seem that our playback UI is complete, there is still one thing that we should take care of before integrating the playback feature itself. When we are watching a video, we don’t want all those controls to be occupying the screen, making it difficult to watch the content. The controls usually disappear automatically after the user hasn’t been interacting with the screen. So, let’s implement this change.</p>
<h2 id="_idParaDest-170" class="calibre7"><a id="_idTextAnchor171" class="calibre6 pcalibre1 pcalibre"/>Making the controls disappear when playing the content</h2>
<p class="calibre3">We know our playback controls should disappear if they haven’t been used for a while. The easiest <a id="_idIndexMarker961" class="calibre6 pcalibre1 pcalibre"/>way to do this is to have a value that will indicate if the controls should be visible or not, and we will modify its value to <code>false</code> when the screen has been idle for a time. Let’s make these modifications in the <code>PlaybackScreen</code> composable, as follows:</p>
<pre class="source-code">
@Composable
fun PlaybackScreen() {
    val isControlsVisible = remember { mutableStateOf(true) }
    val coroutineScope = rememberCoroutineScope()
    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(Color.Black)
            .pointerInput(Unit) {
                detectTapGestures(
                    onPress = {
                        // Reset the visibility timer on
                           user interaction
                        isControlsVisible.value = true
                        coroutineScope.launch {
                            delay(15000) // 15 seconds
                                            delay
                            isControlsVisible.value = false
                        }
                    }
                )
            }
    ) {
        if (isControlsVisible.value) {
            TopMediaRow(Modifier.align(Alignment.TopCenter))
            PlayPauseButton(Modifier.align(
                Alignment.Center))
            ProgressBarWithTime(Modifier.align(
                Alignment.BottomCenter))
        }
    }
}</pre> <p class="calibre3">The core idea of these modifications is to track user interaction and use a timer to determine when to hide the controls. Initially, as mentioned previously, we’ll introduce a state to manage the visibility of the controls. This state will likely be a Boolean that toggles between visible and invisible (<code>true</code> and <code>false</code>) based on user interaction and the passage of time without interaction.</p>
<p class="calibre3">For detecting user interactions, we could wrap the <code>Box</code> layout that contains our playback <a id="_idIndexMarker962" class="calibre6 pcalibre1 pcalibre"/>UI components in a <code>Modifier.pointerInput</code> Lambda. Inside this Lambda, we can listen for touch input events, and each time a touch is detected, we can reset the timer – a coroutine launched with <code>LaunchedEffect</code> keyed to the visibility state might handle this. This coroutine will wait for 15 seconds of inactivity (no touch events detected) before setting the controls’ visibility state to <code>false</code>, effectively hiding them. To ensure the controls reappear when the user interacts with the screen again, the same touch input detection mechanism will set the visibility state back to <code>true</code>, and the coroutine will restart its countdown.</p>
<p class="calibre3">Incorporating this functionality requires making modifications to the <code>PlaybackScreen</code> composable function so that it includes state handling for visibility and can modify the <code>TopMediaRow</code>, <code>PlayPauseButton</code>, and <code>ProgressBarWithTime</code> functions so that they accept and react to the visibility state. This means each of these components will only be rendered when the state indicates they should be visible.</p>
<p class="calibre3">Once we’ve finished, our playback UI should look like this:</p>
<div><div><img alt="Figure 8.1: Finished playback UI (with controls shown)" src="img/B19443_08_01.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.1: Finished playback UI (with controls shown)</p>
<p class="calibre3">When the controls are hidden, it should just show the video content (this isn’t visible yet as it hasn’t been implemented):</p>
<div><div><img alt="Figure 8.2: Finished playback UI (with controls hidden)" src="img/B19443_08_02.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.2: Finished playback UI (with controls hidden)</p>
<p class="calibre3">In this <a id="_idIndexMarker963" class="calibre6 pcalibre1 pcalibre"/>section, we created a UI to display the videos. In the next section, we will integrate ExoPlayer so that our app can start playing videos.</p>
<h1 id="_idParaDest-171" class="calibre5"><a id="_idTextAnchor172" class="calibre6 pcalibre1 pcalibre"/>Playing video using ExoPlayer</h1>
<p class="calibre3">In this <a id="_idIndexMarker964" class="calibre6 pcalibre1 pcalibre"/>section, we’ll harness the full power of ExoPlayer <a id="_idIndexMarker965" class="calibre6 pcalibre1 pcalibre"/>so that we can integrate it into our newly created video playback UI. Let’s learn how we can do this.</p>
<h2 id="_idParaDest-172" class="calibre7"><a id="_idTextAnchor173" class="calibre6 pcalibre1 pcalibre"/>Creating PlaybackActivity</h2>
<p class="calibre3">We’ll <a id="_idIndexMarker966" class="calibre6 pcalibre1 pcalibre"/>start by creating a new <code>Activity</code> for this <a id="_idIndexMarker967" class="calibre6 pcalibre1 pcalibre"/>functionality called <code>PlaybackActivity</code>:</p>
<pre class="source-code">
class PlaybackActivity: ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            PlaybackScreen()
        }
    }
}</pre> <p class="calibre3">This <code>PlaybackActivity</code> activity will show our already created <code>PlaybackScreen()</code> in its content.</p>
<p class="calibre3">We <a id="_idIndexMarker968" class="calibre6 pcalibre1 pcalibre"/>also want our playback UI to be always displayed <a id="_idIndexMarker969" class="calibre6 pcalibre1 pcalibre"/>in landscape mode. To do so, we’ll configure this activity in the <code>AndroidManifest.xml</code> file, as follows:</p>
<pre class="source-code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;manifest xmlns:android =
"http://schemas.android.com/apk/res/android"&gt;
    &lt;application&gt;
        &lt;activity android:name =
        "com.packt.playback.presentation.PlaybackActivity"
        android:screenOrientation="landscape"/&gt;
    &lt;/application&gt;
&lt;/manifest&gt;</pre> <p class="calibre3">Here, we are declaring <code>PlaybackActivity</code> so that it has landscape as a forced screen orientation. This will ensure it will only be rendered in landscape mode, despite what orientation the user is holding their phone.</p>
<h2 id="_idParaDest-173" class="calibre7"><a id="_idTextAnchor174" class="calibre6 pcalibre1 pcalibre"/>Creating PlaybackViewModel</h2>
<p class="calibre3">Now, we <a id="_idIndexMarker970" class="calibre6 pcalibre1 pcalibre"/>need to create the player, which is the <a id="_idIndexMarker971" class="calibre6 pcalibre1 pcalibre"/>component that’s responsible for managing the media playback. We will create <code>PlaybackViewModel</code> to handle the ExoPlayer instance and all the logic needed for the view to interact with the video player and watch the media.</p>
<p class="calibre3">To start, we <a id="_idIndexMarker972" class="calibre6 pcalibre1 pcalibre"/>are going to build the basic setup <a id="_idIndexMarker973" class="calibre6 pcalibre1 pcalibre"/>logic for our player in <code>PlaybackViewModel</code>:</p>
<pre class="source-code">
@HiltViewModel
class PlaybackViewModel @Inject constructor(): ViewModel()
{
    lateinit var player: ExoPlayer
    @OptIn(UnstableApi::class)
    private fun preparePlayerWithMediaSource(exoPlayer:
    ExoPlayer) {
        val mediaUrl = "https://example.com/media.mp4"
        val mediaSource = ProgressiveMediaSource.Factory(
            DefaultHttpDataSource.Factory())
            .createMediaSource(MediaItem.fromUri(mediaUrl))
        exoPlayer.setMediaSource(mediaSource)
        exoPlayer.prepare()
    }
    fun setupPlayer(context: Context) {
        player = ExoPlayer.Builder(context).build().also {
        exoPlayer -&gt;
            preparePlayerWithMediaSource(exoPlayer)
        }
    }
    override fun onCleared() {
        super.onCleared()
        player.release()
        progressUpdateJob?.cancel()
    }
}</pre> <p class="calibre3">This is the <a id="_idIndexMarker974" class="calibre6 pcalibre1 pcalibre"/>start of our <code>PlaybackViewModel</code> composable, which is <a id="_idIndexMarker975" class="calibre6 pcalibre1 pcalibre"/>designed to manage the media playback functionality of an Android app.</p>
<p class="calibre3">The core component of this <code>ViewModel</code> is the ExoPlayer instance, which is stored in a property named <code>player</code>. This <code>player</code> property is responsible for all media playback operations. However, when <code>ViewModel</code> is first created, the player is not initialized; it’s declared with <code>lateinit</code>, meaning it will be initialized later but before any other component needs to access it.</p>
<p class="calibre3">The <code>setupPlayer</code> function is <a id="_idIndexMarker976" class="calibre6 pcalibre1 pcalibre"/>publicly exposed and intended to be called with a <code>Context</code> object, which provides access to application-specific resources and classes. Inside this function, <code>ExoPlayer.Builder</code> is used to create an instance of <code>ExoPlayer</code>. This setup process involves calling the <code>build()</code> method on the builder, which returns a fully configured <code>ExoPlayer</code> instance. Immediately after creating this instance, the <code>also</code> block executes, calling the <code>preparePlayerWithMediaSource</code> method with the newly created player.</p>
<p class="calibre3">The <code>preparePlayerWithMediaSource</code> method is where the actual media source is set up. It <a id="_idIndexMarker977" class="calibre6 pcalibre1 pcalibre"/>takes an <code>ExoPlayer</code> instance as an argument and configures it to play a specific media file. The URL of the media file is defined as <a href="https://example.com/media.mp4" class="calibre6 pcalibre1 pcalibre">https://example.com/media.mp4</a>. To play this media, <code>ProgressiveMediaSource</code> is created, which is suitable for playing regular media files such as MP4s over HTTP. This media source is then attached to the <code>ExoPlayer</code> instance <a id="_idIndexMarker978" class="calibre6 pcalibre1 pcalibre"/>using the <code>setMediaSource</code> method, and <code>prepare()</code> is called to prepare the player for playback. It’s worth noting that this method is marked as private, meaning it’s intended to be used only within the <code>PlaybackViewModel</code> class. The <code>@OptIn(UnstableApi::class)</code> annotation indicates that this method uses APIs that are not yet stable and may change in the future.</p>
<p class="calibre3">Lastly, the <code>onCleared</code> method overrides a <code>ViewModel</code> life cycle callback that gets called when <code>ViewModel</code> is about to be destroyed. This method releases the <code>ExoPlayer</code> instance by calling <code>player.release()</code>, ensuring that resources are freed and preventing memory leaks.</p>
<p class="calibre3">Now, we’ll add the view that will render the media content in <code>PlaybackScreen</code> and connect it to the player:</p>
<pre class="source-code">
@Composable
fun PlaybackScreen() {
    val viewModel: PlaybackViewModel = hiltViewModel()
    val isControlsVisible = remember { mutableStateOf(true) }
    val coroutineScope = rememberCoroutineScope()
    viewModel.setupPlayer(LocalContext.current)
    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(Color.Black)
            .pointerInput(Unit) {
                detectTapGestures(
                    onPress = {
                        isControlsVisible.value = true
                        coroutineScope.launch {
                            delay(15000) // 15 seconds
                                            delay
                            isControlsVisible.value = false
                        }
                    }
                )
            }
    ) {
        VideoPlayerComposable(
            modifier = Modifier.matchParentSize(),
            player = viewModel.player
        )
        if (isControlsVisible.value) {
            ...
        }
    }
}</pre> <p class="calibre3">In the <code>PlaybackScreen</code> composable, we obtain an instance of <code>PlaybackViewModel</code> using <code>hiltViewModel()</code>. This <code>ViewModel</code> is central to managing the media playback life cycle and interactions within the app.</p>
<p class="calibre3">Once <code>ViewModel</code> is ready, we call <code>viewModel.setupPlayer(LocalContext.current)</code> to initialize <code>ExoPlayer</code>. This setup is crucial because it prepares the player with the appropriate Android context, allowing it to load and play media files effectively. Ensuring that ExoPlayer is initialized with the current context helps manage resources efficiently, which is essential for smooth playback.</p>
<p class="calibre3">The UI <a id="_idIndexMarker979" class="calibre6 pcalibre1 pcalibre"/>component responsible for displaying the video is <code>VideoPlayerComposable</code>. We pass the initialized player from <code>ViewModel</code> to this composable, which is placed inside a <code>Box</code> layout. This layout is configured to fill the maximum size of its parent and sets a black background to emphasize the video content. The <code>Box</code> layout also handles user interactions, listening for tap gestures to toggle the visibility of playback controls. When a tap is detected, it makes the controls visible and starts a coroutine that hides these controls again after 15 seconds if no further interaction occurs.</p>
<p class="calibre3">Inside the <code>Box</code> layout, conditional logic checks the value of <code>isControlsVisible</code>. If <code>true</code>, playback controls are rendered on top of the video. This allows users to interact with the video, such as pausing, skipping, or adjusting the volume, but only when they choose to display the controls.</p>
<p class="calibre3">Finally, we will explore how to implement <code>VideoPlayerComposable</code> so that we can effectively utilize the player to render the video while responding dynamically to user interactions with playback controls.</p>
<p class="calibre3">Let’s see how we can implement this new composable. Unfortunately, at the time of writing, the library doesn’t provide a Jetpack Compose option to show the player, so we need to create one inside an <code>AndroidView</code> composable, as follows:</p>
<pre class="source-code">
@Composable
fun VideoPlayerComposable(
    modifier: Modifier = Modifier,
    player: ExoPlayer
) {
    AndroidView(
        factory = { ctx -&gt;
            PlayerView(ctx).apply {
                layoutParams = ViewGroup.LayoutParams(
                    MATCH_PARENT, MATCH_PARENT)
                setPlayer(player)
                useController = false
            }
        },
        modifier = modifier,
        update = { view -&gt;
            view.player = player
        }
    )
}</pre> <p class="calibre3">The <code>VideoPlayerComposable</code> function takes two parameters:</p>
<ul class="calibre15">
<li class="calibre14">The <strong class="source-inline1">Modifier</strong> instance <a id="_idIndexMarker980" class="calibre6 pcalibre1 pcalibre"/>allows you to customize the layout or appearance of this composable when it’s used elsewhere in your UI</li>
<li class="calibre14">The <strong class="source-inline1">ExoPlayer</strong> instance <a id="_idIndexMarker981" class="calibre6 pcalibre1 pcalibre"/>is the media player that will handle the actual playback of the video content</li>
</ul>
<p class="calibre3">Inside the <code>AndroidView</code> composable, the factory Lambda is where the traditional Android view is created – in this case, <code>PlayerView</code>. Here, <code>PlayerView</code> is a view provided by the <code>ExoPlayer</code> library to display video content and playback controls. Here, it’s initialized with the application context (<code>ctx</code>).</p>
<p class="calibre3">After <a id="_idIndexMarker982" class="calibre6 pcalibre1 pcalibre"/>creating <code>PlayerView</code>, some properties are set on it:</p>
<ul class="calibre15">
<li class="calibre14">Here, <strong class="source-inline1">layoutParams</strong> is set to <strong class="source-inline1">MATCH_PARENT</strong> for both width and height, making <strong class="source-inline1">PlayerView</strong> fill the entire space allocated to it. This ensures that the video will take up as much space as possible, typically the entire screen or the parent container.</li>
<li class="calibre14">Then, <strong class="source-inline1">setPlayer(player)</strong> attaches the passed <strong class="source-inline1">ExoPlayer</strong> instance to <strong class="source-inline1">PlayerView</strong>. This connection is what allows the video loaded in <strong class="source-inline1">ExoPlayer</strong> to be displayed in this view.</li>
<li class="calibre14">Finally, <strong class="source-inline1">useController</strong> is set to <strong class="source-inline1">false</strong>, indicating that the default playback controls provided by <strong class="source-inline1">PlayerView</strong> (such as play, pause, and seek bar) will not be used. We will implement our own controls next.</li>
</ul>
<p class="calibre3">Finally, the update Lambda of <code>AndroidView</code> is where you can update the properties of <code>PlayerView</code> based on changes to the composable’s state or properties.</p>
<p class="calibre3">With these changes, our player is ready to start rendering the media via <code>ViewPlayer</code>. But we still have work to do. We need to bind the already developed controls to the player controls and keep the time and the progress bar of the video updated.</p>
<h2 id="_idParaDest-174" class="calibre7"><a id="_idTextAnchor175" class="calibre6 pcalibre1 pcalibre"/>Connecting the controls with ExoPlayer</h2>
<p class="calibre3">Let’s start <a id="_idIndexMarker983" class="calibre6 pcalibre1 pcalibre"/>modifying the <code>PlayPauseButton</code> composable. In this case, we will need to bind the control functions with the ViewModel:</p>
<pre class="source-code">
@Composable
fun PlayPauseButton(
    isPlaying: Boolean,
    onRewind: () -&gt; Unit,
    onPlayPause: () -&gt; Unit,
    onFastForward: () -&gt; Unit,
    modifier: Modifier = Modifier,
    ) {
    Row(
        horizontalArrangement = Arrangement.Center,
        verticalAlignment = Alignment.CenterVertically,
        modifier = modifier
    ) {
        IconButton(
            onClick = onRewind,
            modifier = Modifier.padding(20.dp)
        ) {
            Icon(
                modifier = Modifier
                    .height(80.dp)
                    .width(80.dp),
                imageVector = Icons.Default.ArrowBack,
                contentDescription = "Rewind 10s",
                tint = Color.White
            )
        }
        IconButton(
            onClick = onPlayPause,
            modifier = Modifier.padding(20.dp)
        ) {
            Icon(
                modifier = Modifier
                    .height(80.dp)
                    .width(80.dp),
                imageVector = if (isPlaying)
                    Icons.Default.Close else
                    Icons.Default.PlayArrow,
                contentDescription = if (isPlaying) "Pause"
                    else "Play",
                tint = Color.White
            )
        }
        IconButton(
            onClick = onFastForward,
            modifier = Modifier.padding(20.dp)
        ) {
            Icon(
                modifier = Modifier
                    .height(80.dp)
                    .width(80.dp),
                imageVector = Icons.Default.ArrowForward,
                contentDescription = "Fast-forward 10s",
                tint = Color.White
            )
        }
    }
}</pre> <p class="calibre3">Now, the <code>PlayPauseButton</code> composable <a id="_idIndexMarker984" class="calibre6 pcalibre1 pcalibre"/>takes several parameters, each serving a specific purpose within <a id="_idIndexMarker985" class="calibre6 pcalibre1 pcalibre"/>the UI component:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">isPlaying</strong> (Boolean): This parameter indicates the current playback state of the video. It is used to determine which icon to display on the play/pause button – either a play icon when the video is paused or a pause icon when the video is actively playing. This allows for intuitive control interactions from the user’s perspective.</li>
<li class="calibre14"><strong class="source-inline1">onRewind</strong> (Lambda function): This is a callback function that’s triggered when the user presses the rewind button. It should contain the logic for what happens when the video is rewound, such as moving the playback position backward by a fixed amount.</li>
<li class="calibre14"><strong class="source-inline1">onPlayPause</strong> (Lambda function): This function is executed when the play/pause button is pressed. It handles toggling between playing and pausing the video based on the current state, facilitating seamless user control over video playback.</li>
<li class="calibre14"><strong class="source-inline1">onFastForward</strong> (Lambda function): Similar to <strong class="source-inline1">onRewind</strong>, this callback is activated when the fast-forward button is pressed. It controls the logic for fast-forwarding the video, advancing the playback position forward by a predetermined interval.</li>
<li class="calibre14"><strong class="source-inline1">modifier</strong> (modifier): This parameter allows the appearance and layout of the button row <a id="_idIndexMarker986" class="calibre6 pcalibre1 pcalibre"/>within the composable to be customized. As we’ve seen previously, wt can be used to apply padding, define alignment, and set dimensions.</li>
</ul>
<p class="calibre3">Now that <a id="_idIndexMarker987" class="calibre6 pcalibre1 pcalibre"/>we’ve added these new parameters, we need to pass them from the parent composable. Here’s how you can include and invoke this composable with the required parameters:</p>
<pre class="source-code">
val isPlaying = viewModel.isPlaying.collectAsState()
PlayPauseButton(
    isPlaying = isPlaying.value,
    onRewind = { viewModel.rewind() },
    onFastForward = {viewModel.fastForward() },
    onPlayPause = {viewModel.togglePlayPause() },
    modifier = Modifier.align(Alignment.Center)
)</pre> <p class="calibre3">As we can see, we have bound every Lambda parameter to <code>ViewModel</code> functions (that are yet to be implemented) and we are providing an <code>isPlaying</code> state to reflect the current playing status of the player.</p>
<p class="calibre3">Now, let’s implement those functions in <code>ViewModel</code>:</p>
<pre class="source-code">
private val _isPlaying = MutableStateFlow&lt;Boolean&gt;(false)
val isPlaying: MutableStateFlow&lt;Boolean&gt; = _isPlaying
fun setupPlayer(context: Context) {
    player = ExoPlayer.Builder(context).build().also {
    exoPlayer -&gt;
        preparePlayerWithMediaSource(exoPlayer)
        exoPlayer.addListener(object : Player.Listener {
            override fun onIsPlayingChanged(isPlaying:
            Boolean) {
                _isPlaying.value = isPlaying
            }
            override fun onPlaybackStateChanged(
            playbackState: Int) {
                super.onPlaybackStateChanged(playbackState)
            }
            override fun onPositionDiscontinuity(
            oldPosition: Player.PositionInfo, newPosition:
            Player.PositionInfo, reason: Int) {
                super.onPositionDiscontinuity(oldPosition,
                    newPosition, reason)
            }
            override fun onTimelineChanged(timeline:
            Timeline, reason: Int) {
                super.onTimelineChanged(timeline, reason)
            }
        })
    }
}
fun togglePlayPause() {
    if (player.isPlaying) {
        player.pause()
    } else {
        player.play()
    }
}
fun rewind() {
    val newPosition =
        (player.currentPosition - 10000).coerceAtLeast(0)
    player.seekTo(newPosition)
}
fun fastForward() {
    val newPosition =
        (player.currentPosition + 10000)
            .coerceAtMost(player.duration)
    player.seekTo(newPosition)
}</pre> <p class="calibre3">First, we have defined a private mutable state flow, <code>_isPlaying</code>, to track whether the video is currently playing. This same state flow is exposed as a public <code>MutableStateFlow</code> component named <code>isPlaying</code>. In this case, <code>isPlaying</code> acts as a single source of truth for the playback state, allowing our UI components to update reactively <a id="_idIndexMarker988" class="calibre6 pcalibre1 pcalibre"/>based on whether the video is playing or paused.</p>
<p class="calibre3">The <code>setupPlayer</code> function, which <a id="_idIndexMarker989" class="calibre6 pcalibre1 pcalibre"/>we’ve already implemented, initializes the <code>ExoPlayer</code> instance. Now, it also attaches a listener to respond to playback events. The listener added overrides several methods, but most importantly, <code>onIsPlayingChanged</code> is used to update <code>_isPlaying.value</code> based on the player’s state.</p>
<p class="calibre3">We’ve also included the functions to manipulate playback that we were already being called from the composable:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">togglePlayPause</strong>: This checks if the player is currently playing and toggles between play and pause. This method directly controls the player’s state, making it the primary way the user interacts with the playback.</li>
<li class="calibre14"><strong class="source-inline1">rewind</strong> and <strong class="source-inline1">fastForward</strong>: These options calculate a new position based on the current playback position and seek to that position. The <strong class="source-inline1">rewind</strong> function moves the playback position backward by 10 seconds, while <strong class="source-inline1">fastForward</strong> moves it forward by 10 seconds. These methods enhance user control over the video, allowing for quick navigation within the content.</li>
</ul>
<p class="calibre3">Now, let’s connect the next (and last) composable, <code>ProgressBarWithTime</code>:</p>
<pre class="source-code">
@Composable
fun ProgressBarWithTime(
    currentPosition: Long,
    duration: Long,
    onSeek: (Long) -&gt; Unit,
    modifier: Modifier = Modifier,
) {
    val progress =
        if (duration &gt; 0) currentPosition.toFloat() /
            duration else 0f
    val formattedTime =
        "${formatTime(currentPosition)} /
            ${formatTime(duration)}"
    Row(
        modifier = modifier
            .fillMaxWidth()
            .wrapContentHeight()
            .padding(horizontal = 16.dp, vertical = 8.dp),
        horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically
    ) {
        Slider(
            value = progress,
            onValueChange = { newValue -&gt;
                val newPosition =
                    (newValue * duration).toLong()
                onSeek(newPosition)
            },
            modifier = Modifier.weight(1f),
            valueRange = 0f..1f
        )
        Spacer(modifier = Modifier.width(8.dp))
        Text(text = formattedTime, color = Color.White)
    }
}</pre> <p class="calibre3">The function now <a id="_idIndexMarker990" class="calibre6 pcalibre1 pcalibre"/>accepts three new parameters: <code>currentPosition</code> and <code>duration</code> to represent the current playback position and the total length of the video in milliseconds, respectively, and an <code>onSeek</code> Lambda function that defines what to do when the user seeks to a new position.</p>
<p class="calibre3">The <code>progress</code> variable calculates how far along the video is, represented as a float between 0 and 1. This is achieved by dividing <code>currentPosition</code> by <code>duration</code>, which specifies a proportion of the video that has been played. If the duration is 0 (to avoid division by zero), progress is set to <code>0f</code>, indicating no progress.</p>
<p class="calibre3">The <code>formattedTime</code> string provides a user-friendly display of the current position and total duration of the video by using a custom formatting function, <code>formatTime()</code>  (as we’ll see next), to convert milliseconds into a more readable format (HH:MM:SS).</p>
<p class="calibre3">Finally, slider progress is now bound to the progress value, and its <code>onValueChange</code> event is wired to call <code>onSeek</code> with the new position when the user interacts with it. This allows the user to seek through the video by moving the slider, with the <code>onSeek</code> function updating the video playback position accordingly.</p>
<p class="calibre3">Regarding the aforementioned <code>formatTime</code> function, it will work as follows:</p>
<pre class="source-code">
fun formatTime(millis: Long): String {
    val totalSeconds = millis / 1000
    val hours = totalSeconds / 3600
    val minutes = (totalSeconds % 3600) / 60
    val seconds = totalSeconds % 60
    return if (hours &gt; 0) {
        String.format("%02d:%02d:%02d", hours, minutes,
            seconds)
    } else {
        String.format("%02d:%02d", minutes, seconds)
    }
}</pre> <p class="calibre3">The input to <a id="_idIndexMarker991" class="calibre6 pcalibre1 pcalibre"/>the function is <code>millis</code>, which represents the time duration in milliseconds. This is a common way to represent time in programming because it’s precise. However, milliseconds aren’t very human-friendly, so the first step inside the function is to convert milliseconds into total seconds by dividing by <code>1000</code>. We’re doing this because there are 1,000 milliseconds in a second.</p>
<p class="calibre3">Once you have the total seconds, the function calculates hours, minutes, and seconds. It divides the total seconds by <code>3600</code> (the number of seconds in an hour) to get hours. The remainder from that division (using the modulo operator, <code>%</code>) is then used to calculate minutes by dividing by <code>60</code> (since there are 60 seconds in a minute). Finally, the remainder from the minutes calculation gives you the seconds.</p>
<p class="calibre3">The last part is where the function formats the time string. If the duration includes hours (that is, if the duration is longer than 60 minutes), it formats the time as HH:MM:SS using <code>String.format()</code>. This method is used to create a formatted string with placeholders (<code>%02d</code>) for hours, minutes, and seconds. Here’s a breakdown of the format:</p>
<ul class="calibre15">
<li class="calibre14">The <strong class="source-inline1">%</strong> symbol indicates the start of a format specifier.</li>
<li class="calibre14">The <strong class="source-inline1">0</strong> specifies that the number should be padded with leading zeros if it has fewer digits than specified.</li>
<li class="calibre14">The <strong class="source-inline1">2</strong> indicates that the number should be at least two digits long.</li>
<li class="calibre14">The <strong class="source-inline1">d</strong> stands for ‘decimal’ and specifies that the placeholder is for an integer number.</li>
</ul>
<p class="calibre3">So, <code>%02d</code> ensures that the number is at least two digits long and padded with zeros if necessary.</p>
<p class="calibre3">Going back <a id="_idIndexMarker992" class="calibre6 pcalibre1 pcalibre"/>to th<a id="_idTextAnchor176" class="calibre6 pcalibre1 pcalibre"/>e composable, we also need to modify where <code>ProgressBarWithTime</code> is called in <code>PlaybackScreen</code>:</p>
<pre class="source-code">
val currentPosition =
    viewModel.currentPosition.collectAsState()
val duration = viewModel.duration.collectAsState()
ProgressBarWithTime(
    currentPosition = currentPosition.value,
    duration = duration.value,
    onSeek = { newPosition -&gt;
        viewModel.seekTo(newPosition)
    },
    modifier = Modifier.align(Alignment.BottomCenter)
)</pre> <p class="calibre3">As we can see, we have bound the <code>seekTo</code> Lambda parameter to a <code>ViewModel</code> function (that is yet to be implemented) and we are also providing <code>duration</code> and <code>currentPosition</code> states.</p>
<p class="calibre3">Now, let’s modify <code>PlaybackViewModel</code> so that we can implement the pending functions related to the progress bar.</p>
<h2 id="_idParaDest-175" class="calibre7"><a id="_idTextAnchor177" class="calibre6 pcalibre1 pcalibre"/>Implementing the video controls in PlaybackViewModel</h2>
<p class="calibre3">The <a id="_idIndexMarker993" class="calibre6 pcalibre1 pcalibre"/>last step to make the progress bar work is to modify <code>PlaybackViewModel</code>. We can add the necessary functionality to control the progress bar like so:</p>
<pre class="source-code">
private val _currentPosition = MutableStateFlow&lt;Long&gt;(0L)
val currentPosition: StateFlow&lt;Long&gt; = _currentPosition
private val _duration = MutableStateFlow&lt;Long&gt;(0L)
val duration: MutableStateFlow&lt;Long&gt; = _duration
private var progressUpdateJob: Job? = null
fun setupPlayer(context: Context) {
    player = ExoPlayer.Builder(context).build().also {
    exoPlayer -&gt;
        preparePlayerWithMediaSource(exoPlayer)
        exoPlayer.addListener(object : Player.Listener {
            override fun onIsPlayingChanged(isPlaying:
            Boolean) {
                _isPlaying.value = isPlaying
                if (isPlaying) {
                    startPeriodicProgressUpdate()
                } else {
                    progressUpdateJob?.cancel()
                }
            }
            override fun onPlaybackStateChanged
            (playbackState: Int) {
                super.onPlaybackStateChanged(playbackState)
                if (playbackState == Player.STATE_READY ||
                playbackState == Player.STATE_BUFFERING) {
                    _duration.value = exoPlayer.duration
                }
            }
            override fun onPositionDiscontinuity(
            oldPosition: Player.PositionInfo, newPosition:
            Player.PositionInfo, reason: Int) {
                super.onPositionDiscontinuity(oldPosition,
                    newPosition, reason)
                _currentPosition.value =
                    newPosition.positionMs
            }
            override fun onTimelineChanged(timeline:
            Timeline, reason: Int) {
                super.onTimelineChanged(timeline, reason)
                if (!timeline.isEmpty) {
                    _duration.value = exoPlayer.duration
                }
            }
        })
    }
}
private fun startPeriodicProgressUpdate() {
    progressUpdateJob?.cancel()
    progressUpdateJob = viewModelScope.launch {
        while (coroutineContext.isActive) {
            val currentPosition = player.currentPosition
            _currentPosition.value = currentPosition
            delay(1000)
        }
    }
}
fun seekTo(position: Long) {
    if (::player.isInitialized &amp;&amp; position &gt;= 0 &amp;&amp;
    position &lt;= player.duration) {
        player.seekTo(position)
    }
}
override fun onCleared() {
    super.onCleared()
    player.release()
    progressUpdateJob?.cancel()
}</pre> <p class="calibre3">With that, we’ve declared private mutable state flows called <code>_currentPosition</code> and <code>_duration</code> for tracking the current playback position and the total video duration, respectively. These are exposed as read-only StateFlows to the rest of the app, ensuring <a id="_idIndexMarker994" class="calibre6 pcalibre1 pcalibre"/>that the UI components can observe these values and react to changes, but cannot modify them directly.</p>
<p class="calibre3">The listener in the <code>setupPlayer</code> function has also been modified to include functionality to keep the two states, <code>_currentPosition</code> and <code>_duration</code>. The following modifications have been made to the listener callbacks:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">onIsPlayingChanged</strong>: This updates the <strong class="source-inline1">_isPlaying</strong> state and controls the start and stop of a job, which periodically updates the current playback position. This is essential for keeping the UI in sync with the actual playback.</li>
<li class="calibre14"><strong class="source-inline1">onPlaybackStateChanged</strong>: This checks if the player is ready or buffering and updates the <strong class="source-inline1">_duration</strong> state with the total duration of the video. This is necessary for setting up the progress bar.</li>
<li class="calibre14"><strong class="source-inline1">onPositionDiscontinuity</strong> and <strong class="source-inline1">onTimelineChanged</strong>: These ensure that changes in the video playback position or timeline (such as seeking or switching to another video) update <strong class="source-inline1">_currentPosition</strong> and <strong class="source-inline1">_duration</strong> correctly.</li>
</ul>
<p class="calibre3">Then, the new function, <code>startPeriodicProgressUpdate</code>, launches a coroutine that periodically updates the <code>_currentPosition</code> state with the player’s current position. This loop runs every second, providing a near-real-time update of the playback position to the UI. It’s crucial for making the progress bar move smoothly as the video plays.</p>
<p class="calibre3">Building <a id="_idIndexMarker995" class="calibre6 pcalibre1 pcalibre"/>on this functionality, the <code>seekTo</code> function allows the video to be seeked to a new position. It checks that the position is within the bounds of the video before calling <code>seekTo</code> on the ExoPlayer instance, effectively letting the user jump to different parts of the video through the progress bar.</p>
<p class="calibre3">Finally, the <code>onCleared</code> method has been modified to cancel the new <code>progressUpdateJob</code> composable in case we have to release the resources.</p>
<p class="calibre3">With these changes, our video player is ready. We just have to modify the hardcoded media URL in <code>PlaybackViewModel</code> (<code>val mediaUrl = "https://example.com/media.mp4"</code>) so that we can provide a URL to an actual video and let the magic happen! At this point, we should see the playback of the provided video.</p>
<p class="calibre3">In the last section of this chapter, we are going to enhance the functionality of our video player a little bit further by learning how to add subtitles.</p>
<h1 id="_idParaDest-176" class="calibre5"><a id="_idTextAnchor178" class="calibre6 pcalibre1 pcalibre"/>Adding subtitles to the video player</h1>
<p class="calibre3">In this section, we’ll be adding subtitles to our video player. Subtitles are crucial for making <a id="_idIndexMarker996" class="calibre6 pcalibre1 pcalibre"/>videos accessible to everyone, but they can also be <a id="_idIndexMarker997" class="calibre6 pcalibre1 pcalibre"/>great for watching videos in noisy environments or when you need to keep the volume down. In this section, we’ll learn how to load and display subtitles alongside our video while handling various formats and ensuring they sync up perfectly with our content.</p>
<p class="calibre3">To add subtitles, follow these steps:</p>
<ol class="calibre13">
<li class="calibre14">Create a MediaSource for your video file, just as you would for any video playback in ExoPlayer. We did this in the previous section.</li>
<li class="calibre14">Create a MediaSource for your subtitle file. This often involves using <strong class="source-inline1">SingleSampleMediaSource</strong> for single subtitle files or similar approaches for different formats.</li>
<li class="calibre14">Use <strong class="source-inline1">MergingMediaSource</strong> to combine the video and subtitle sources. This merged source is then passed to the ExoPlayer instance for playback.</li>
<li class="calibre14">Initialize ExoPlayer with the merged source; it will handle the playback of both video and subtitles.</li>
</ol>
<p class="calibre3">ExoPlayer <a id="_idIndexMarker998" class="calibre6 pcalibre1 pcalibre"/>supports a wide range of subtitle formats so <a id="_idIndexMarker999" class="calibre6 pcalibre1 pcalibre"/>that it can cater to various use cases and standards. Some of the most popular formats are as follows:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">WebVTT</strong> (<strong class="source-inline1">.vtt</strong>): A widely <a id="_idIndexMarker1000" class="calibre6 pcalibre1 pcalibre"/>used format for HTML5 video subtitles that’s supported by many web browsers and platforms:<ul class="calibre16"><li class="calibre14"><strong class="bold">Advantages</strong>: WebVTT is <a id="_idIndexMarker1001" class="calibre6 pcalibre1 pcalibre"/>extensively supported across most modern web browsers, making it ideal for online streaming services. It offers options for styling, positioning, and cue settings, allowing for a customizable viewing experience.</li><li class="calibre14"><strong class="bold">Disadvantages</strong>: Compared to simpler formats such as SRT, WebVTT’s additional <a id="_idIndexMarker1002" class="calibre6 pcalibre1 pcalibre"/>features can make it more complex to create and edit. Also, different platforms and browsers may interpret styling and formatting cues differently, leading to inconsistent presentations.</li></ul></li>
<li class="calibre14"><strong class="bold">SubRip</strong> (<strong class="source-inline1">.srt</strong>): One of <a id="_idIndexMarker1003" class="calibre6 pcalibre1 pcalibre"/>the most common subtitle formats that’s simple in structure and supported by a wide range of media players:<ul class="calibre16"><li class="calibre14"><strong class="bold">Advantages</strong>: The <a id="_idIndexMarker1004" class="calibre6 pcalibre1 pcalibre"/>structure of SRT files is straightforward, making them easy to create, edit, and debug. It is also supported by almost all media players, making it universally applicable for offline and online video playback.</li><li class="calibre14"><strong class="bold">Disadvantages</strong>: It provides <a id="_idIndexMarker1005" class="calibre6 pcalibre1 pcalibre"/>basic text formatting, which limits its ability to customize the appearance of subtitles.</li></ul></li>
</ul>
<p class="calibre3">To give <a id="_idIndexMarker1006" class="calibre6 pcalibre1 pcalibre"/>you an idea of what one of these formats looks like, here’s <a id="_idIndexMarker1007" class="calibre6 pcalibre1 pcalibre"/>an example of the content of a SubRip (<code>.</code><code>srt</code>) file:</p>
<pre class="source-code">
1
00:00:01,000 --&gt; 00:00:03,000
Hello, welcome to our video!
2
00:00:05,000 --&gt; 00:00:08,000
Today, we'll be discussing how to create a simple SRT file.
3
00:00:10,000 --&gt; 00:00:12,000
Let's get started.
4
00:00:15,000 --&gt; 00:00:20,000
Subtitles primarily enhance accessibility and also can be very helpful for understanding dialogue, especially in noisy environments.
5
00:00:22,500 --&gt; 00:00:25,000
And that's all there is to it!</pre> <p class="calibre3">Each block starts with a sequence number (for example, 1, 2, 3, and so on), followed by the time range on the next line (start time --&gt; end time), and then the text of the subtitle. This text can be one or more lines and is followed by a blank line to indicate the end of the subtitle entry. This format can be edited with any text editor and saved with the <code>.</code><code>srt</code> extension.</p>
<p class="calibre3">Now that <a id="_idIndexMarker1008" class="calibre6 pcalibre1 pcalibre"/>we know a bit more about how to add subtitles <a id="_idIndexMarker1009" class="calibre6 pcalibre1 pcalibre"/>to a video in ExoPlayer, let’s add them by default to our already-implemented playback functionality. We just need to change the logic for the player setup in <code>PlaybackViewModel</code>:</p>
<pre class="source-code">
@OptIn(UnstableApi::class)
private fun preparePlayerWithMediaSource(exoPlayer:
ExoPlayer) {
        val mediaUrl = "https://example.com/media.mp4"
        val subtitleUrl =
            "https://example.com/subtitles.srt"
        val videoMediaSource =
            ProgressiveMediaSource.Factory(
                DefaultHttpDataSource.Factory()
        ).createMediaSource(MediaItem.fromUri(mediaUrl))
        val subtitleSource =
            MediaItem.SubtitleConfiguration.Builder(
                Uri.parse(subtitleUrl)).build()
        val subtitleMediaSource =
            SingleSampleMediaSource.Factory(
                DefaultHttpDataSource.Factory()
        ).createMediaSource(subtitleSource, C.TIME_UNSET)
        val mergedSource =
            MergingMediaSource(videoMediaSource,
                subtitleMediaSource)
        exoPlayer.setMediaSource(mergedSource)
        exoPlayer.prepare()
}</pre> <p class="calibre3">In the preceding code, we modified the already existing <code>preparePlayerWithMediaSource</code> function. We started by adding a new media with the subtitles URL.</p>
<p class="calibre3">Then we created <code>MediaSource</code> for the subtitles, and we created a <code>MediaItem.SubtitleConfiguration</code> object from the subtitle URL (<code>subtitleUrl</code>). This configuration specifies how the subtitle should be loaded and displayed.</p>
<p class="calibre3">Then, <code>SingleSampleMediaSource</code> is created for the subtitle configuration. Here, <code>SingleSampleMediaSource</code> is used because subtitle files are typically a single piece of <a id="_idIndexMarker1010" class="calibre6 pcalibre1 pcalibre"/>content rather than streamed content. The <code>createMediaSource</code> method here is slightly different from the video one; it takes the <a id="_idIndexMarker1011" class="calibre6 pcalibre1 pcalibre"/>subtitle configuration and a duration parameter, which is set to <code>C.TIME_UNSET</code> to indicate that the duration is unknown or should be determined from the content itself.</p>
<p class="calibre3">Once both the video and subtitle sources have been created, they’re combined into a single source using <code>MergingMediaSource</code>. This merged source tells <code>ExoPlayer</code> to play the video with the subtitles overlaying it.</p>
<p class="calibre3">Finally, the merged source is set on the <code>ExoPlayer</code> instance with <code>setMediaSource</code>, and <code>prepare()</code> is called. This action causes <code>ExoPlayer</code> to load the media and get ready for playback. When the video plays, the subtitles from the specified SRT file will be displayed at the correct times, as defined in the file.</p>
<p class="calibre3">The following figure shows the subtitles added:</p>
<div><div><img alt="Figure 8.3: Playback with subtitles" src="img/B19443_08_03.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.3: Playback with subtitles</p>
<p class="calibre3">With that, our <a id="_idIndexMarker1012" class="calibre6 pcalibre1 pcalibre"/>player is ready to play back videos. By including <a id="_idIndexMarker1013" class="calibre6 pcalibre1 pcalibre"/>subtitles, it offers a more accessible experience for our users.</p>
<h1 id="_idParaDest-177" class="calibre5"><a id="_idTextAnchor179" class="calibre6 pcalibre1 pcalibre"/>Summary</h1>
<p class="calibre3">In this chapter, we tackled the essentials of adding video playback in our Android app while focusing on the powerful ExoPlayer library. We started by comparing media options in Android before quickly realizing ExoPlayer’s superiority due to its flexibility and wide format support. This set the stage for us to learn how ExoPlayer fits into an app and how to use it for playing videos smoothly.</p>
<p class="calibre3">We then walked through building a user-friendly video playback interface, covering everything from setting up ExoPlayer to managing playback controls. Finally, we explored adding subtitles to make your videos accessible to a wider audience, highlighting ExoPlayer’s capability to enhance inclusivity.</p>
<p class="calibre3">Now that you have a solid grasp of video playback using ExoPlayer, you’re ready to elevate your app with picture-in-picture mode and media casting.</p>
</div>
</body></html>