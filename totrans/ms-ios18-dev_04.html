<html><head></head><body>
		<div><h1 id="_idParaDest-73" class="chapter-number"><a id="_idTextAnchor148"/><st c="0">4</st></h1>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor149"/><st c="2">Advanced Navigation with SwiftUI</st></h1>
			<p><st c="34">In </st><a href="B21795_02.xhtml#_idTextAnchor043"><em class="italic"><st c="38">Chapter 2</st></em></a><st c="47">, we discussed working with</st><a id="_idIndexMarker159"/><st c="74"> the </st><strong class="bold"><st c="79">Observation</st></strong><st c="90"> framework. </st><st c="102">The Observation framework helps to manage communication between different parts of our app and is one of the fundamental building blocks of SwiftUI declarative programming. </st><st c="275">However, it is also one of the tools we will use to implement a good </st><st c="344">navigation system.</st></p>
			<p><st c="362">Why do we have a whole chapter about navigation? </st><st c="412">Isn’t it just showing a different view when the user selects an item in </st><st c="484">a list?</st></p>
			<p><st c="491">Navigation is a massive topic in mobile development. </st><st c="545">A standard app may have dozens of screens, and a more extensive one may have hundreds. </st><st c="632">Understanding how to manage the different routes in our app, which has so many screens, is crucial to our </st><st c="738">app’s success.</st></p>
			<p><st c="752">In this chapter, we will be doing </st><st c="787">the following:</st></p>
			<ul>
				<li><st c="801">Understating why SwiftUI navigation is </st><st c="841">a challenge</st></li>
				<li><st c="852">Exploring </st><st c="863">SwiftUI’s </st><code><st c="873">NavigationStack</st></code></li>
				<li><st c="888">Working with different data models to </st><st c="927">trigger navigation</st></li>
				<li><st c="945">Working with the Coordinator pattern to manage our </st><st c="997">concerns better</st></li>
				<li><st c="1012">Implementing SwiftUI’s </st><code><st c="1036">NavigationSplitView</st></code><st c="1055"> to create a </st><st c="1068">column-based navigation</st></li>
			</ul>
			<p><st c="1091">We’ve got a lot to cover! </st><st c="1118">But before we begin, let’s try to understand why SwiftUI navigation can be </st><st c="1193">a challenge.</st><a id="_idTextAnchor150"/><a id="_idTextAnchor151"/><a id="_idTextAnchor152"/><a id="_idTextAnchor153"/></p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor154"/><st c="1205">Technical requirements</st></h1>
			<p><st c="1228">For this chapter, you’ll need to download Xcode version 16.0 or above from Apple’s </st><st c="1312">App Store.</st></p>
			<p><st c="1322">You’ll also need to be running the latest version of macOS (Ventura or above). </st><st c="1402">Simply search for Xcode in the App Store and select and download the latest version. </st><st c="1487">Launch Xcode and follow any additional installation instructions that your system may prompt you with. </st><st c="1590">Once Xcode has fully launched, you’re ready </st><st c="1634">to go.</st></p>
			<p><st c="1640">Download the sample code from the following GitHub </st><st c="1692">link: </st><a href="https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%204"><st c="1698">https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%204</st></a><st c="1783">.</st></p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor155"/><st c="1784">Understating why SwiftUI navigation is a challenge</st></h1>
			<p><st c="1835">To answer that</st><a id="_idIndexMarker160"/><st c="1850"> question, we need to understand how navigation works intuitively</st><a id="_idTextAnchor156"/><a id="_idTextAnchor157"/><a id="_idTextAnchor158"/><st c="1915">. The user taps on a button, link, or some other event that may occur. </st><st c="1986">Then, the app responds to that event and transitions the view to </st><st c="2051">another screen.</st></p>
			<p><st c="2066">In a sense, we understand this sounds like an event-driven paradigm. </st><st c="2136">When we discuss the differences between SwiftUI and UIKit, we actually discuss the differences between declarative and </st><st c="2255">imperative programming</st><a id="_idTextAnchor159"/><a id="_idTextAnchor160"/><st c="2277">.</st></p>
			<p><st c="2278">Imperative UI, such as UIKit, is also event-driven, while declarative UI, such as SwiftUI, represents the current state. </st><st c="2400">As a result, we can understand why navigation can be seen as simpler in UIKit and may feel more </st><st c="2496">natural there.</st></p>
			<p><st c="2510">Many developers struggle with SwiftUI navigation. </st><st c="2561">They wrap a SwiftUI view inside </st><code><st c="2593">UIHostingController</st></code><st c="2612"> and use the UIKit navigation system. </st><st c="2650">That’s a fair solution for achieving some advanced navigation techniques that are hard to do in SwiftUI. </st><st c="2755">However, we need to remember that SwiftUI has evolved over the years and offers great </st><st c="2841">navigation tools.</st></p>
			<p><st c="2858">Let’s start with the basic navigation tool – </st><code><st c="2904">NavigationStack</st></code><st c="2919">.</st></p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor161"/><st c="2920">Exploring NavigationStack</st></h1>
			<p><st c="2946">When SwiftUI was</st><a id="_idIndexMarker161"/><st c="2963"> introduced, the basic navigation mechanism was based on a view called </st><code><st c="3034">NavigationView</st></code><st c="3048">. However, </st><code><st c="3059">NavigationView</st></code><st c="3073"> was too simple for most apps, and </st><code><st c="3108">NavigationStack</st></code><st c="3123"> replaced it. </st><st c="3137">In fact, Apple deprecated </st><code><st c="3163">NavigationView</st></code><st c="3177">, starting with </st><st c="3193">iOS 18.</st></p>
			<p><st c="3200">Compared to </st><code><st c="3213">NavigationView</st></code><st c="3227">, </st><code><st c="3229">NavigationStack</st></code><st c="3244"> adds a little bit of complexity to the pile, which provides us with </st><st c="3313">new capabilitie</st><a id="_idTextAnchor162"/><a id="_idTextAnchor163"/><st c="3328">s.</st></p>
			<p><st c="3331">Let’s see a simple example of a </st><code><st c="3364">NavigationStack</st></code><st c="3379"> usage:</st></p>
			<pre class="source-code"><st c="3386">
struct ContentView: View {
    var body: some View {
        </st><strong class="bold"><st c="3436">NavigationStack {</st></strong><st c="3453">
            NavigationLink("Tap here to go to the next
            screen") {
                Text("Next Screen!")
            }
        }
    }
}</st></pre>			<p><st c="3536">This code example</st><a id="_idIndexMarker162"/><st c="3554"> looks </st><st c="3561">pretty simple!</st></p>
			<p><st c="3575">However, </st><code><st c="3585">NavigationStack</st></code><st c="3600"> is much more powerful than </st><st c="3628">it seems.</st></p>
			<p><st c="3637">How? </st><st c="3643">The concept of </st><code><st c="3658">NavigationStack</st></code><st c="3673"> is constructed from </st><st c="3694">four components:</st></p>
			<ol>
				<li><code><st c="3786">NavigationView</st></code><st c="3800">. In </st><code><st c="3805">NavigationStack</st></code><st c="3820">, </st><code><st c="3822">NavigationLink</st></code><st c="3836"> describes what happened, and the </st><code><st c="3870">navigationDestination</st></code><st c="3891"> view modifier describes where </st><st c="3922">we go.</st></li>
				<li><strong class="bold"><st c="3928">Linking between data and destinations</st></strong><st c="3966">: In a way, this is a development of the preceding point. </st><st c="4025">The destination is linked to a data type. </st><st c="4067">This means that we can have several navigation links that point to the same destination just because they share the same </st><st c="4188">data type.</st></li>
				<li><strong class="bold"><st c="4198">Allowing us to read and update the path</st></strong><st c="4238">: Here, we have another development of our idea. </st><st c="4288">Because the data and the screen are now linked, we can represent the path as an array of data instances. </st><st c="4393">Modifying the path array also changes our </st><st c="4435">views stack.</st></li>
				<li><code><st c="4509">NavigationLink</st></code><st c="4523"> also had this capability, but the introduction of </st><code><st c="4574">NavigationStack</st></code><st c="4589"> made </st><a id="_idIndexMarker164"/><st c="4595">it obsolete.</st></li>
			</ol>
			<p><st c="4607">Let’s cover each of these four components in detail now, and we’ll start </st><st c="4681">with destinations.</st></p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor164"/><st c="4699">Separating the navigation destination using the navigationDestination view modifier</st></h2>
			<p><st c="4783">If you’ve read my </st><a id="_idIndexMarker165"/><st c="4802">previous </st><a id="_idIndexMarker166"/><st c="4811">books (</st><em class="italic"><st c="4818">Pro iOS Testing</st></em><st c="4834"> and </st><em class="italic"><st c="4839">Mastering Swift Package Manager</st></em><st c="4870"> by </st><em class="italic"><st c="4874">Apress</st></em><st c="4880">, and </st><em class="italic"><st c="4886">The Ultimate iOS Interview Playbook</st></em><st c="4921"> by </st><em class="italic"><st c="4925">Packt Publishing</st></em><st c="4941">) there’s an important principle I keep nagging about: </st><strong class="bold"><st c="4997">separation of concerns</st></strong><st c="5019"> (</st><strong class="bold"><st c="5021">SoC</st></strong><st c="5024">). </st><st c="5028">In SoC, we break our code into distinct modules or </st><a id="_idIndexMarker167"/><st c="5079">components, each with a specific and well-defined responsibility. </st><st c="5145">This makes our code more modular, flexible, and easy </st><st c="5198">to maintain.</st></p>
			<p><st c="5210">When we look back at </st><code><st c="5232">NavigationLink</st></code><st c="5246">, we can see that it has more than one responsibility – it is the actual control that the user taps on and also contains the next </st><st c="5376">screen view.</st></p>
			<p><st c="5388">In </st><code><st c="5392">NavigationStack</st></code><st c="5407">, there’s a new view modifier called </st><code><st c="5444">navigationDestination</st></code><st c="5465">, which allows us to define a destination separately according to a </st><st c="5533">state change.</st></p>
			<p><st c="5546">Let’s see an example of </st><code><st c="5571">navigationDestination</st></code><st c="5592">, based on a </st><st c="5605">binding variable:</st></p>
			<pre class="source-code"><st c="5622">
struct ContentView: View {
    @State var isNextScreenDisplayed: Bool = false
    var body: some View {
        NavigationStack {
            Button("Go to next screen") {
                isNextScreenDisplayed = true
            }
            .</st><strong class="bold"><st c="5799">navigationDestination(isPresented:</st></strong>
<strong class="bold"><st c="5834">              $isNextScreenDisplayed) {</st></strong>
<strong class="bold"><st c="5860">                Text("Next Screen!")</st></strong><st c="5881">
            }
        }
    }
}</st></pre>			<p><st c="5889">In our code example, we can see a </st><code><st c="5924">NavigationStack</st></code><st c="5939"> view containing a button. </st><st c="5966">Notice that there’s no </st><code><st c="5989">NavigationLink</st></code><st c="6003"> view at all, and that’s because we don’t need it. </st><st c="6054">We trigger the navigation by changing the </st><code><st c="6096">@State</st></code><st c="6102"> property named </st><code><st c="6118">isNextScreenDisplayed</st></code><st c="6139"> rather than using a </st><code><st c="6160">NavigationLink</st></code><st c="6174"> view.</st></p>
			<p><st c="6180">The button also has a view modifier called </st><code><st c="6224">navigationDestination</st></code><st c="6245">. The </st><code><st c="6251">navigationDestination</st></code><st c="6272"> view modifier has a binding Boolean variable that is linked to the </st><code><st c="6340">isNextScreenDisplayed</st></code><st c="6361"> state variable. </st><st c="6378">It also has a view builder that contains our next screen (similar </st><st c="6444">to </st><code><st c="6447">NavigationLink</st></code><st c="6461">).</st></p>
			<p><st c="6464">Tapping on the button toggles </st><code><st c="6495">isNextScreenDisplayed</st></code><st c="6516"> and navigates our </st><st c="6535">next screen.</st></p>
			<p><st c="6547">This capability of </st><a id="_idIndexMarker168"/><st c="6567">triggering </st><a id="_idIndexMarker169"/><st c="6578">navigation using </st><code><st c="6595">NavigationLink</st></code><st c="6609"> was available in earlier versions of SwiftUI, but it is deprecated now. </st><st c="6682">But don’t worry – decoupling the destination from the actual control makes our code much more flexible and provides us with </st><st c="6806">more opportunities.</st></p>
			<p><st c="6825">For example, imagine we’re doing an asynchrony operation such as a network request or image processing, and we want to move to the next screen – that can be done easily by toggling a </st><st c="7009">Boolean variable.</st></p>
			<p><st c="7026">Another important aspect of having a separate destination is that we can trigger the same navigation from different places. </st><st c="7151">We can toggle the Boo</st><a id="_idTextAnchor165"/><a id="_idTextAnchor166"/><st c="7172">lean from an asynchronous operation and a button as well. </st><st c="7231">Responding to a state follows a declarative approach rather than the </st><code><st c="7300">NavigationView</st></code><st c="7314"> approach, which was responding to a </st><st c="7351">button tap.</st></p>
			<p><st c="7362">Toggling a Boolean variable is great when navigating to a new screen unrelated to any data. </st><st c="7455">For example, moving to the settings from our main screen is a classic example of using a </st><st c="7544">Boolean binding.</st></p>
			<p><st c="7560">But I </st><a id="_idIndexMarker170"/><st c="7567">promised </st><a id="_idIndexMarker171"/><st c="7576">that </st><code><st c="7581">NavigationStack</st></code><st c="7596"> has more than that, </st><st c="7617">didn’t I?</st></p>
			<p><st c="7626">So, let’s see how we can bind our navigation destinations to </st><st c="7688">data models.</st></p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor167"/><st c="7700">Using data models to trigger navigation</st></h2>
			<p><st c="7740">Developers who </st><a id="_idIndexMarker172"/><st c="7756">are used to </st><a id="_idIndexMarker173"/><st c="7768">UIKit navigation may find the idea of using data models weird. </st><st c="7831">After all, toggling a Boolean for navigation is quite similar to imperative programming, but how does a data model have anything to do </st><st c="7966">with navigation?</st></p>
			<p><st c="7982">We understand that many screens are related to a specific data model. </st><st c="8053">For example, tapping on a movie leads us to a single movie screen if we have a list of movies. </st><st c="8148">Another example is a trips app, where tapping on a specific trip leads us to a screen dedicated to </st><st c="8247">that trip.</st></p>
			<p><st c="8257">If we think even deeper than that, we can represent many screens in our app using a data model. </st><st c="8354">We can distinguish between screens using a data model containing </st><st c="8419">an enum.</st></p>
			<p><st c="8427">Before we set sail with our thoughts, exploring potential possibilities and implementations, let’s see what basic data-based navigation </st><st c="8564">looks like:</st></p>
			<pre class="source-code"><st c="8575">
struct ContentView: View {
</st><strong class="bold"><st c="8603">    private let countries = ["England", "France", "Spain",</st></strong>
<strong class="bold"><st c="8657">    "Italy"]</st></strong><st c="8666">
    var body: some View {
        NavigationStack {
            List(countries, id: \.self) { country in
                </st><strong class="bold"><st c="8748">NavigationLink(country, value: country)</st></strong><st c="8787">
            }
            </st><strong class="bold"><st c="8790">.navigationDestination(for: String.self)</st></strong><st c="8830"> { item
                in
                Text(item)
            }
        }
    }
}</st></pre>			<p><st c="8859">As always, I have highlighted the interesting parts in the preceding code. </st><st c="8935">We have a SwiftUI view that displays a list of countries (based on a </st><st c="9004">constant variable).</st></p>
			<p><st c="9023">Each row has a </st><code><st c="9039">NavigationLink</st></code><st c="9053"> view that displays the country name, but it doesn’t have its own destination this time. </st><st c="9142">Instead, it uses the country as the link’s </st><st c="9185">value parameter.</st></p>
			<p><st c="9201">We can understand what sending the country as a value means only when we look down at the navigation destination. </st><st c="9316">In the code example in the </st><em class="italic"><st c="9343">Separating the navigation destination using the navigationDestination view modifier</st></em><st c="9426"> section, the navigation destination was linked to a Boolean state variable. </st><st c="9503">In this case, the navigation destination performs</st><a id="_idIndexMarker174"/><st c="9552"> only when</st><a id="_idIndexMarker175"/><st c="9562"> there’s a link with a specific data type – in this case, a string type (just like a </st><st c="9647">country value).</st></p>
			<p><st c="9662">In other words, tapping on a country sends its value to the navigation stack using </st><code><st c="9746">NavigationLink</st></code><st c="9760">. The navigation destination catches that and defines what will be our </st><st c="9831">next screen.</st></p>
			<p><st c="9843">We can use the data models to navigate to different places by defining multiple navigation destinations, each responding to a different data </st><st c="9985">model type.</st></p>
			<p><st c="9996">Here’s another example of using a navigation destination to add a navigation to a </st><st c="10079">profile screen:</st></p>
			<pre class="source-code"><st c="10094">
struct Profile</st><strong class="bold"><st c="10109">: Hashable</st></strong><st c="10120"> {
    let firstName: String
    let lastName: String
    let email: String
}
struct ContentView: View {
    let profile = Profile(firstName: "Avi", lastName:
    "Tsadok", email: "myemail@domain.com")
    let countries = ["England", "France", "Spain", "Italy"]
    var body: some View {
        NavigationStack {
            List(countries, id: \.self) { country in
                </st><strong class="bold"><st c="10439">NavigationLink(country, value: country)</st></strong><st c="10478">
            }.toolbar(content: {
                </st><strong class="bold"><st c="10500">NavigationLink("Go to profile", value:</st></strong>
<strong class="bold"><st c="10538">                profile)</st></strong><st c="10547">
            })
            </st><strong class="bold"><st c="10551">.navigationDestination(for: String.self)</st></strong><st c="10591"> { item
                in
                Text(item)
            }
            </st><strong class="bold"><st c="10615">.navigationDestination(for: Profile.self)</st></strong><st c="10656"> {
              profile in
                VStack {
                    Text(profile.firstName)
                    Text(profile.lastName)
                    Text(profile.email)
                }
            }
        }
    }
}</st></pre>			<p><st c="10755">In the preceding code, we see another navigation destination for a data model from the type of </st><code><st c="10851">Profile</st></code><st c="10858">. To navigate the profile screen, we added another </st><code><st c="10909">NavigationLink</st></code><st c="10923"> view in the screen toolbar and sent the profile </st><st c="10972">data model.</st></p>
			<p><st c="10983">Our navigation system is dynamic because we can work with different data models. </st><st c="11065">But that doesn’t stop </st><a id="_idIndexMarker176"/><st c="11087">here. </st><code><st c="11093">NavigationStack</st></code><st c="11108"> can</st><a id="_idIndexMarker177"/><st c="11112"> also reveal and even modify the current view’s stack. </st><st c="11167">We do that using the path </st><st c="11193">binding variable.</st></p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor168"/><st c="11210">Responding to the path variable</st></h2>
			<p><st c="11242">Separating the </st><a id="_idIndexMarker178"/><st c="11258">destination</st><a id="_idIndexMarker179"/><st c="11269"> from its navigation link is great, but </st><code><st c="11309">NavigationStack</st></code><st c="11324">’s ability to observe and update its stack of views is </st><st c="11380">very powerful.</st></p>
			<p><st c="11394">As mentioned, a </st><code><st c="11411">NavigationStack</st></code><st c="11426"> view has a binding variable called </st><code><st c="11462">path</st></code><st c="11466">, and the </st><code><st c="11476">path</st></code><st c="11480"> variable can contain the list of views by their </st><st c="11529">data models.</st></p>
			<p><st c="11541">It is easy to demonstrate that using a </st><st c="11581">linked list:</st></p>
			<pre class="source-code"><st c="11593">
struct ContentView: View {
    let list: LinkedList&lt;Int&gt; = {
        let list = LinkedList&lt;Int&gt;()
        list.head = ListNode(1)
        list.head?.next = ListNode(2)
        list.head?.next?.next = ListNode(3)
        return list
    }()
    </st><strong class="bold"><st c="11786">@State var path: [ListNode&lt;Int&gt;]</st></strong><st c="11818"> = []
    var body: some View {
        </st><strong class="bold"><st c="11846">NavigationStack(path: $path)</st></strong><st c="11874"> {
            VStack {
                NavigationLink("Start", value: list.head)
            }
            .navigationDestination(for: ListNode&lt;Int&gt;.self)
              { node in
                NavigationLink("\(node.value)", value:
                node.next)
              }
        }
    }
}</st></pre>			<p><st c="12045">I chose to demonstrate </st><a id="_idIndexMarker180"/><st c="12069">working</st><a id="_idIndexMarker181"/><st c="12076"> with </st><code><st c="12082">path</st></code><st c="12086"> using a linked list since it’s a great data structure that is similar to a navigation stack (linked items from the </st><st c="12202">same type).</st></p>
			<p><st c="12213">If we observe the </st><code><st c="12232">path</st></code><st c="12236"> variable during navigation, we can see it contains a collection of the list nodes currently active </st><st c="12336">as views.</st></p>
			<p><st c="12345">What’s great about the fact that the </st><code><st c="12383">path</st></code><st c="12387"> variable is bound to the </st><code><st c="12413">NavigationStack</st></code><st c="12428"> is that we can manipulate and </st><st c="12459">modify it:</st></p>
			<pre class="source-code"><st c="12469">
path.append(ListNode(4))</st></pre>			<p><st c="12494">Appending a new list node to </st><code><st c="12524">path</st></code><st c="12528"> triggers the navigation and directs the user to a </st><st c="12579">new screen.</st></p>
			<p><st c="12590">We can also create a whole stack using the </st><code><st c="12634">path</st></code><st c="12638"> variable:</st></p>
			<pre class="source-code"><st c="12648">
path = [ListNode(1), ListNode(2)]</st></pre>			<p><st c="12682">Setting a new array of nodes creates a new stack of corresponding views. </st><st c="12756">This is a great way to implement a deep link or direct the user to a specific location within </st><st c="12850">the app.</st></p>
			<p><st c="12858">You are probably scratching your head right now and thinking, how can we implement it inside an app? </st><st c="12960">What are the use cases where we navigate a few levels down the hierarchy with the same data </st><st c="13052">model type?</st></p>
			<p><st c="13063">So, a data model type doesn’t have to be </st><code><st c="13105">Task</st></code><st c="13109">, </st><code><st c="13111">Album</st></code><st c="13116">, or </st><code><st c="13121">Contact</st></code><st c="13128">. A data model can also describe a screen or a feature. </st><st c="13184">In this way, data collection can describe a navigation path inside </st><st c="13251">an app.</st></p>
			<p><st c="13258">Here’s an example</st><a id="_idIndexMarker182"/><st c="13276"> of a data type that</st><a id="_idIndexMarker183"/><st c="13296"> can describe a screen, followed by a </st><st c="13334">navigation path:</st></p>
			<pre class="source-code"><st c="13350">
enum Screen: Hashable {
    case signin
    case onboarding
    case mainScreen
    case settings
}
@State var path: [Screen] = []</st></pre>			<p><st c="13465">The Enum </st><code><st c="13475">Screen</st></code><st c="13481"> describes the type of screen we want to navigate to, and it’s an easy way to build </st><st c="13565">a stack:</st></p>
			<pre class="source-code"><st c="13573">
path  = [.mainScreen, .settings]</st></pre>			<p><st c="13605">That short line of code builds a stack of views when the first view is the main screen followed by a </st><st c="13707">settings screen.</st></p>
			<p><st c="13723">Using an Enum to display different kinds of screens is great. </st><st c="13786">However, working with different types of data is less convenient with Enum. </st><st c="13862">To solve that issue, we have a more complex solution</st><a id="_idIndexMarker184"/><st c="13914"> than</st><a id="_idIndexMarker185"/><st c="13919"> a collection of instances, and it’s </st><st c="13956">called </st><code><st c="13963">NavigationPath</st></code><st c="13977">.</st></p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor169"/><st c="13978">Working with different types of data using NavigationPath</st></h1>
			<p><code><st c="14036">NavigationPath</st></code><st c="14051"> was</st><a id="_idIndexMarker186"/><st c="14055"> introduced along with </st><code><st c="14078">NavigationStack</st></code><st c="14093">, and it allows us to have more control of our navigation flows. </st><st c="14158">In fact, </st><code><st c="14167">NavigationPath</st></code><st c="14181"> makes navigation with SwiftUI a mix of declarative and imperative programming and is much more similar to the UIKit </st><st c="14298">navigation pattern.</st></p>
			<p><st c="14317">Let’s say we have a music app with a list of songs and albums on its main screen. </st><st c="14400">Tapping on a song leads to a </st><code><st c="14429">song</st></code><st c="14433"> view while tapping on an album navigates to an </st><code><st c="14481">album</st></code><st c="14486"> view. </st><st c="14493">In the previous section, we managed that using an Enum, trying to map the Enum value to a screen view. </st><st c="14596">With </st><code><st c="14601">NavigationPath</st></code><st c="14615">, we can append whatever value we want to the </st><code><st c="14661">path</st></code><st c="14665"> variable as long as its type conforms </st><st c="14704">to </st><code><st c="14707">Hashable</st></code><st c="14715">.</st></p>
			<p><st c="14716">Let’s have a look at the </st><st c="14742">following code:</st></p>
			<pre class="source-code"><st c="14757">
struct ContentView: View {
    </st><strong class="bold"><st c="14785">@State private var navigationPath = NavigationPath()</st></strong><st c="14837">
    @State private var albums: [Album] = [Album(title:
      "Album 1"), Album(title: "Album 2")]
    @State private var songs: [Song] = [Song(title: "Song
      1"), Song(title: "Song 2")]
    var body: some View {
        </st><strong class="bold"><st c="15030">NavigationStack(path: $navigationPath) {</st></strong><st c="15070">
            VStack {
                List {
                    Section(header: Text("Songs")) {
                        ForEach(songs) { song in
                            Button(action: {
                                </st><strong class="bold"><st c="15162">navigationPath.append(song)</st></strong><st c="15189">
                            }) {
                                Text(song.title)
                            }
                        }
                    }
                    Section(header: Text("Albums")) {
                        ForEach(albums) { album in
                            Button(action: {
                              </st><strong class="bold"><st c="15296">navigationPath.append(album)</st></strong><st c="15324">
                            }) {
                                Text(album.title)
                            }
                        }
                    }
                }
                </st><strong class="bold"><st c="15356">.navigationDestination(for: Song.self) {</st></strong>
<strong class="bold"><st c="15396">                song in</st></strong>
<strong class="bold"><st c="15404">                    SongDetailView(song: song,</st></strong>
<strong class="bold"><st c="15431">                     navigationPath: $navigationPath)</st></strong>
<strong class="bold"><st c="15464">                }</st></strong>
<strong class="bold"><st c="15466">                .navigationDestination(for: Album.self) {</st></strong>
<strong class="bold"><st c="15507">                album in</st></strong>
<strong class="bold"><st c="15516">                    AlbumDetailView(album: album)</st></strong>
<strong class="bold"><st c="15546">                }</st></strong><st c="15548">
}</st></pre>			<p><st c="15550">Note that the preceding code example is partial and does not include the </st><st c="15623">child views.</st></p>
			<p><st c="15635">Our music app’s main screen contains four important parts that handle our </st><st c="15710">navigation system:</st></p>
			<p><st c="15728">We start with declaring a state variable that holds our </st><code><st c="15785">path</st></code><st c="15789"> variable </st><st c="15799">called </st><code><st c="15806">NavigationPath</st></code><st c="15820">:</st></p>
			<pre class="source-code"><st c="15822">
    @State private var navigationPath = NavigationPath()</st></pre>			<p><st c="15875">As mentioned earlier, unlike the previous </st><code><st c="15918">path</st></code><st c="15922"> variable we used, in the </st><code><st c="15948">NavigationPath</st></code><st c="15962"> case, we don’t need to define its type. </st><st c="16003">It can hold any type we want as long as it</st><a id="_idIndexMarker187"/><st c="16045"> conforms </st><st c="16055">to </st><code><st c="16058">Hashable</st></code><st c="16066">.</st></p>
			<p><st c="16067">Next, we will initiate </st><code><st c="16091">NavigationStack</st></code><st c="16106"> with our new </st><code><st c="16120">NavigationPath</st></code><st c="16134"> similar to what we did in the </st><st c="16165">previous example:</st></p>
			<pre class="source-code"><st c="16182">
    NavigationStack(path: $navigationPath) {</st></pre>			<p><st c="16223">Notice that we use a similar signature but with a different type – </st><code><st c="16291">Binding&lt;NavigationPath&gt;</st></code><st c="16314"> instead </st><st c="16323">of </st><code><st c="16326">Binding&lt;Data&gt;</st></code><st c="16339">.</st></p>
			<p><st c="16340">Now that we have </st><code><st c="16358">NavigationPath</st></code><st c="16372">, we can navigate to a </st><code><st c="16395">song</st></code><st c="16399"> view or to an </st><code><st c="16414">album</st></code><st c="16419"> view by appending the corresponding object to the </st><st c="16470">navigation path:</st></p>
			<pre class="source-code"><st c="16486">
navigationPath.append(song)</st></pre>			<p><st c="16514">Or, you can do it </st><st c="16533">like so:</st></p>
			<pre class="source-code"><st c="16541">
navigationPath.append(album)</st></pre>			<p><st c="16570">The appending operation triggers the </st><code><st c="16608">navigationDestination</st></code><st c="16629"> view modifier, passing the song or the album that </st><st c="16680">was selected:</st></p>
			<pre class="source-code"><st c="16693">
.navigationDestination(for: Song.self) { song in
    SongDetailView(song: song, navigationPath:
      $navigationPath)
}
.navigationDestination(for: Album.self) { album in
    AlbumDetailView(album: album)
}</st></pre>			<p><st c="16886">In this example, we have a different </st><code><st c="16924">navigationDestination</st></code><st c="16945"> view modifier for each type </st><st c="16974">we pass.</st></p>
			<p><st c="16982">The fact that we can append any entity we want makes </st><code><st c="17036">NavigationPath</st></code><st c="17050"> an ideal component for a flexible </st><st c="17085">navigation system.</st></p>
			<p><st c="17103">We can also use </st><code><st c="17120">NavigationPath</st></code><st c="17134"> to perform a </st><code><st c="17148">Back</st></code><st c="17152"> operation by removing the </st><st c="17179">last component:</st></p>
			<pre class="source-code"><st c="17194">
Button("Back") {
     navigationPath.removeLast()
}</st></pre>			<p><st c="17241">In this example, we added a back button that removes the navigation path’s last components </st><st c="17333">when tapped.</st></p>
			<p><st c="17345">Because we are still in </st><a id="_idIndexMarker188"/><st c="17370">a declarative world, any change we perform to the navigation stack by appending or removing components reflects the change in </st><st c="17496">our UI.</st></p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor170"/><st c="17503">Working with the Coordinator pattern</st></h1>
			<p><st c="17540">The </st><code><st c="17545">NavigationPath</st></code><st c="17559"> and </st><code><st c="17564">NavigationStack</st></code><st c="17579"> combination is robust and provides flexibility in managing </st><a id="_idIndexMarker189"/><st c="17639">navigation. </st><st c="17651">However, as our app scales, controlling how the user moves from screen to screen becomes </st><st c="17740">more complex.</st></p>
			<p><st c="17753">For example, let’s say we have an onboarding flow and want a different set of screens for different user profiles. </st><st c="17869">Or, we want to reuse the same screen within different flows. </st><st c="17930">In each flow, the screen should continue to a </st><st c="17976">different screen.</st></p>
			<p><st c="17993">In each case, it becomes difficult to understand our next view when we are within the screen context. </st><st c="18096">In fact, this problem of managing our navigation is not related only to SwiftUI, and most developers know that </st><st c="18207">from UIKit.</st></p>
			<p><st c="18218">To try and improve our navigation mechanism, we can use what’s called a </st><strong class="bold"><st c="18291">Coordinator pattern</st></strong><st c="18310"> – a pattern that</st><a id="_idIndexMarker190"/><st c="18327"> delegates the navigation logic to a </st><st c="18364">dedicated component.</st></p>
			<p><st c="18384">Let’s try to understand what </st><st c="18414">it means.</st></p>
			<h2 id="_idParaDest-83"><st c="18423">Understandi</st><a id="_idTextAnchor171"/><a id="_idTextAnchor172"/><st c="18435">ng the Coordinator’s principles</st></h2>
			<p><st c="18467">Before we write our </st><a id="_idIndexMarker191"/><st c="18488">first Coordinator together, let’s review some </st><st c="18534">fundamental principles:</st></p>
			<ul>
				<li><st c="18557">The Coordinator is a component that holds the current navigation path and general context. </st><st c="18649">It knows what screen is displayed and the general current flow. </st><st c="18713">The Coordinator also adds a new view to the stack, pops, and shows modal or </st><st c="18789">sheet views.</st></li>
				<li><st c="18801">A view doesn’t know the following view the user should navigate to. </st><st c="18870">What it does know is only the action the user performed. </st><st c="18927">In a way, the view is isolated from the navigation logic and is unaware of the </st><st c="19006">general context.</st></li>
				<li><st c="19022">A coordinator represents a flow. </st><st c="19056">We can have several flows in our app with </st><st c="19098">several coordinators.</st></li>
			</ul>
			<p><st c="19119">As a result of these principles, we can understand that the Coordinator pattern is an improved way of separating our </st><st c="19237">app concerns.</st></p>
			<p><st c="19250">Look at </st><em class="italic"><st c="19259">Figure 4</st></em><em class="italic"><st c="19267">.1</st></em><st c="19269">:</st></p>
			<div><div><img src="img/B21795_04_1.jpg" alt="Figure 4.1: The Coordinator pattern"/><st c="19271"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="19391">Figure 4.1: The Coordinator pattern</st></p>
			<p><em class="italic"><st c="19426">Figure 4</st></em><em class="italic"><st c="19435">.1</st></em><st c="19437"> shows a basic Coordinator pattern. </st><st c="19473">We have an </st><em class="italic"><st c="19484">Albums List</st></em><st c="19495"> view, and when the user selects an album, the action is sent to the </st><em class="italic"><st c="19564">Coordinator</st></em><st c="19575">. Then, the Coordinator decides to navigate to the </st><em class="italic"><st c="19626">Album Detail</st></em><st c="19638"> view by sending the action </st><st c="19666">to </st><code><st c="19669">NavigationPath</st></code><st c="19683">.</st></p>
			<p><st c="19684">In this pattern, the Albums List is unaware of what should happen next. </st><st c="19757">For example, the Coordinator can decide that, in some cases, we should show the user an upsell screen. </st><st c="19860">Or, if it’s part of onboarding, the Coordinator can determine that the Albums List is just a demonstration and that we should proceed to the next step in the </st><st c="20018">onboarding flow.</st></p>
			<p><st c="20034">But how do we structure a Coordinator pattern? </st><st c="20082">How does it work, especially in the </st><st c="20118">SwiftUI world?</st></p>
			<p><st c="20132">There are many ways to build a Coordinator in SwiftUI. </st><st c="20188">The Coordinator pattern I describe here is just an </st><a id="_idIndexMarker192"/><st c="20239">example that demonstrates the basic principles, and we can take that example and adjust it to our </st><st c="20337">project’s needs.</st></p>
			<p><st c="20353">We will start with the most fundamental component – the </st><st c="20410">Coordinator itself.</st></p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor173"/><st c="20429">Building the Coordinator object</st></h2>
			<p><st c="20461">The Coordinator is</st><a id="_idIndexMarker193"/><st c="20480"> the central object that defines the different user actions and navigation options. </st><st c="20564">It also holds the navigation path so it can perform the </st><st c="20620">navigation operations.</st></p>
			<p><st c="20642">We will start by defining a basic </st><st c="20677">Coordinator class:</st></p>
			<pre class="source-code"><st c="20695">
class Coordinator: ObservableObject {
    @Published var path = NavigationPath()
}</st></pre>			<p><st c="20774">We created a Coordinator class that holds a </st><code><st c="20819">NavigationPath</st></code><st c="20833"> object. </st><st c="20842">The </st><code><st c="20846">NavigationPath</st></code><st c="20860"> object is essential – it allows the Coordinator to add more items to the stack, perform pop operations, and understand the current stack. </st><st c="20999">Notice that the Coordinator conforms to the </st><code><st c="21043">ObservableObject</st></code><st c="21059"> protocol and that the path is a published object – that’s because we want the path to be part of </st><code><st c="21157">NavigationStack</st></code><st c="21172"> when we </st><st c="21181">use it.</st></p>
			<p><st c="21188">Next, we define the different user and </st><st c="21228">page actions:</st></p>
			<pre class="source-code"><st c="21241">
enum PageAction: Hashable {
    case gotoAlbumView(album: Album)
    case gotoSettingsView
}
enum UserAction {
    case albumTappedInAlbumsList(album: Album)
    case settingButtonTapped
}</st></pre>			<p><st c="21414">In this example, we </st><a id="_idIndexMarker194"/><st c="21435">created </st><st c="21443">two Enums:</st></p>
			<ul>
				<li><code><st c="21453">PageAction</st></code><st c="21464">: This Enum describes a navigation action our Coordinator needs to perform, such as navigating to an </st><code><st c="21566">album</st></code><st c="21571"> view or a </st><st c="21582">settings view.</st></li>
				<li><code><st c="21596">UserAction</st></code><st c="21607">: This Enum describes an action the user performed, such as tapping on an album in the Albums List or tapping on the </st><st c="21725">settings button.</st></li>
			</ul>
			<p><st c="21741">Notice that some Enums contain associated values, such as the related </st><code><st c="21812">album</st></code><st c="21817"> object.</st></p>
			<p><st c="21825">Now that we have our Enums, we will create two </st><st c="21873">important functions:</st></p>
			<pre class="source-code"><st c="21893">
    func performedAction(action: UserAction) {
        switch action {
        case .albumTappedInAlbumsList(let album):
            path.append(PageAction.gotoAlbumView(album:
            album))
        case .settingButtonTapped:
            path.append(PageAction.gotoSettingsView)
        }
    }
    @ViewBuilder
    func buildView(forPageAction pageAction: PageAction) -&gt;
      some View {
        switch pageAction {
        case .gotoAlbumView(let album):
            AlbumDetailView(album: album)
        case .gotoSettingsView:
            SettingsView()
        }
    }</st></pre>			<p><st c="22324">The first is the </st><code><st c="22342">performAction()</st></code><st c="22357"> function. </st><st c="22368">This function receives </st><code><st c="22391">UserAction</st></code><st c="22401"> as a parameter and appends </st><a id="_idIndexMarker195"/><st c="22429">the corresponding page action to </st><code><st c="22462">NavigationPath</st></code><st c="22476">. This function is the Coordinator’s “brain” – where we decide where to navigate when the user performs a </st><st c="22582">particular action.</st></p>
			<p><st c="22600">In this example, when the user taps the album in the Albums List, we navigate to the </st><code><st c="22686">album</st></code><st c="22691"> view, passing the </st><code><st c="22710">album</st></code><st c="22715"> object. </st><st c="22724">When the user taps the settings button, we navigate to the settings screen. </st><st c="22800">This logic may sound evident and like over-engineering. </st><st c="22856">Still, in a complex world, we have permissions, A/B tests, and other changes, and a centralized place that handles all of these can be </st><st c="22991">extremely valuable.</st></p>
			<p><st c="23010">The second function maps a page action to </st><a id="_idIndexMarker196"/><st c="23053">a SwiftUI view. </st><st c="23069">We will use that now when we </st><st c="23098">build </st><code><st c="23104">CoordinatorView</st></code><st c="23119">.</st></p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor174"/><st c="23120">Adding CoordinatorView</st></h2>
			<p><st c="23143">The Coordinator</st><a id="_idIndexMarker197"/><st c="23159"> class is robust and contains all of</st><a id="_idIndexMarker198"/><st c="23195"> our navigation logic. </st><st c="23218">However, we can’t use the Coordinator to perform the actual navigation. </st><st c="23290">To do that, we must wrap our views with </st><code><st c="23330">CoordinatorView</st></code><st c="23345">, which knows how to work with </st><st c="23376">our Coordinator.</st></p>
			<p><st c="23392">So, let’s see what </st><code><st c="23412">CoordinatorView</st></code> <st c="23427">looks like:</st></p>
			<pre class="source-code"><st c="23439">
struct CoordinatorView: View {
    @ObservedObject private var coordinator = Coordinator()
    var body: some View {
      </st><strong class="bold"><st c="23549">NavigationStack</st></strong><st c="23564">(path: $coordinator.path) {
        AlbumListView()
          .navigationDestination(for:
            PageAction.self, destination: { pageAction in
                coordinator.buildView(forPageAction:
                  pageAction)
                })
        }
        .environmentObject(coordinator)
    }
}</st></pre>			<p><code><st c="23772">CoordinatorView</st></code><st c="23788"> is a simple SwiftUI view that has </st><st c="23823">three components:</st></p>
			<ul>
				<li><code><st c="23840">coordinator</st></code><st c="23852">: In the </st><code><st c="23862">CoordinatorView</st></code><st c="23877">, we added an instance of our </st><code><st c="23907">Coordinator</st></code><st c="23918"> class that we had just built. </st><st c="23949">We made that coordinator an observable object so we can use its path to add and remove views from </st><st c="24047">the stack.</st></li>
				<li><code><st c="24057">NavigationStack</st></code><st c="24073">: This is the same </st><code><st c="24093">NavigationStack</st></code><st c="24108"> we met in this chapter. </st><st c="24133">As mentioned, we use the coordinator path as </st><code><st c="24178">NavigationStack</st></code><st c="24193">, but more importantly, two additional things – we initialize the stack with the root view (</st><code><st c="24285">AlbumListView</st></code><st c="24299">), and we use the Coordinator </st><code><st c="24330">buildView</st></code><st c="24339"> function that maps the page action to view to add the corresponding view to </st><st c="24416">the stack.</st></li>
				<li><code><st c="24426">EnvironmentObject</st></code><st c="24444">: We add an </st><code><st c="24457">environmentObject</st></code><st c="24474"> view modifier to declare an environment object in the coordinator. </st><st c="24542">We do that to provide all the views under </st><code><st c="24584">NavigationStack</st></code><st c="24599"> with access to the Coordinator so they can call the different </st><st c="24662">user actions.</st></li>
			</ul>
			<p><st c="24675">These three components </st><a id="_idIndexMarker199"/><st c="24699">are responsible for connecting </st><a id="_idIndexMarker200"/><st c="24730">our views to the Coordinator logic we </st><st c="24768">have built.</st></p>
			<p><st c="24779">Now, let’s see how </st><code><st c="24799">AlbumListView</st></code><st c="24812"> works with </st><st c="24824">the Coordinator.</st></p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor175"/><st c="24840">Calling the coordinator straight from the view</st></h2>
			<p><st c="24887">Remember one of our </st><a id="_idIndexMarker201"/><st c="24908">coordinator principles – the view’s concern is only to say what </st><em class="italic"><st c="24972">happened</st></em><st c="24980">, not what </st><em class="italic"><st c="24991">will happen</st></em><st c="25002"> next. </st><st c="25009">What will happen is the </st><st c="25033">Coordinator’s concern.</st></p>
			<p><st c="25055">Let’s have a look at how </st><code><st c="25081">AlbumListView</st></code><st c="25094"> deals </st><st c="25101">with it:</st></p>
			<pre class="source-code"><st c="25109">
struct AlbumListView: View {
    </st><strong class="bold"><st c="25139">@EnvironmentObject private var coordinator: Coordinator</st></strong><st c="25194">
    var body: some View {
        List(albums) { album in
            VStack(alignment: .leading) {
                Text(album.title)
                    .font(.headline)
                Text(album.artist)
                    .font(.subheadline)
            }
            .onTapGesture {
                </st><strong class="bold"><st c="25363">coordinator.performedAction(action:</st></strong>
<strong class="bold"><st c="25398">                  .albumTappedInAlbumsList(album: album))</st></strong><st c="25437">
            }
        }
        .navigationTitle("Albums")
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing)
            {
                Button(action: {
                    </st><strong class="bold"><st c="25546">coordinator.performedAction(action:</st></strong>
<strong class="bold"><st c="25581">                      .settingButtonTapped)</st></strong><st c="25602">
                }) {
                    Image(systemName: "gear")
                }
            }
        }
    }
}</st></pre>			<p><st c="25643">The </st><code><st c="25648">AlbumListView</st></code><st c="25661"> struct</st><a id="_idIndexMarker202"/><st c="25668"> contains a list of the user albums and a navigation bar with a </st><st c="25732">settings button.</st></p>
			<p><st c="25748">Tapping on one of the albums calls the Coordinator’s </st><code><st c="25802">performedAction()</st></code><st c="25819"> function, which returns the corresponding Enum and the </st><st c="25875">selected album.</st></p>
			<p><st c="25890">In addition, tapping on the settings button calls the same </st><code><st c="25950">performedAction()</st></code><st c="25967"> function with a different </st><st c="25994">Enum value.</st></p>
			<p><st c="26005">Returning to the beginning of this section under the </st><em class="italic"><st c="26059">Building the Coordinator object</st></em><st c="26090"> part, we can now understand how everything </st><st c="26134">is connected.</st></p>
			<p><st c="26147">We can also understand why the coordinator instance is an environment object – so we can call it straight from </st><st c="26259">the view.</st></p>
			<p><st c="26268">Until now, we discussed </st><code><st c="26293">NavigationStack</st></code><st c="26308"> and the Coordinator pattern. </st><st c="26338">We might think that navigation is only about changing the current view. </st><st c="26410">However, navigation on big screens, such as an iPad screen, often involves working with different columns. </st><st c="26517">So, let’s meet </st><code><st c="26532">NavigationSplitView</st></code><st c="26551"> to see </st><a id="_idIndexMarker203"/><st c="26559">how we nail that down (I told you that navigation is a complex topic, </st><st c="26629">didn’t I?).</st></p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor176"/><st c="26640">Navigating with columns with NavigationSplitView</st></h1>
			<p><st c="26689">One of the things that</st><a id="_idIndexMarker204"/><st c="26712"> we know when building apps for padOS or macOS is that we need to take advantage of the big screen. </st><st c="26812">But what does it mean? </st><st c="26835">Sometimes, it might mean working with a grid instead of a list. </st><st c="26899">However, in the context of navigation, it means that we can work with several columns when each of the columns shows a different view instead of replacing the whole screen each time the </st><st c="27085">user navigates.</st></p>
			<p><st c="27100">In other words – we need to split </st><st c="27135">the screen.</st></p>
			<p><st c="27146">To do that, we can work with a view called </st><code><st c="27190">NavigationSplitView</st></code><st c="27209">, which presents views in two or </st><st c="27242">three columns.</st></p>
			<p><st c="27256">When a user selects an item of one view, it updates the view in the </st><st c="27325">other columns.</st></p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor177"/><st c="27339">Creating NavigationSplitView</st></h2>
			<p><st c="27368">To demonstrate </st><a id="_idIndexMarker205"/><st c="27384">how to use </st><code><st c="27395">NavigationSplitView</st></code><st c="27414">, we will use our music app example and adjust it </st><st c="27464">to padOS.</st></p>
			<p><st c="27473">Let’s start with some important terms – we have three different </st><st c="27538">column types:</st></p>
			<ul>
				<li><code><st c="27551">Sidebar</st></code><st c="27559">: The first column from the left. </st><st c="27594">That’s the main column where we start </st><st c="27632">our navigation.</st></li>
				<li><code><st c="27647">Content</st></code><st c="27655">: When there are three columns, the </st><code><st c="27692">Content</st></code><st c="27699"> column shows data related to the selected item in the </st><code><st c="27754">Sidebar</st></code><st c="27761"> column.</st></li>
				<li><code><st c="27769">Detail</st></code><st c="27776">: The </st><code><st c="27783">Detail</st></code><st c="27789"> column presents the selected item in the </st><code><st c="27831">Content</st></code><st c="27838"> column or the </st><code><st c="27853">Sidebar</st></code><st c="27860"> column. </st><st c="27869">In general, it is the item that is last in the split </st><st c="27922">view hierarchy.</st></li>
			</ul>
			<p><st c="27937">These three terms may initially sound slightly confusing, so let’s jump straight to the code to understand how they all fit together. </st><st c="28072">Here’s an example of </st><code><st c="28093">NavigationSplitView</st></code><st c="28112"> that shows a list of albums, and when tapping on an </st><a id="_idTextAnchor178"/><a id="_idTextAnchor179"/><st c="28165">album, the app shows a list of </st><st c="28196">its </st><a id="_idIndexMarker206"/><st c="28200">songs:</st></p>
			<pre class="source-code"><st c="28206">
    var body: some View {
        </st><strong class="bold"><st c="28229">NavigationSplitView</st></strong><st c="28248"> {
            List(albums, selection: $selectedAlbum) { album
              in
                NavigationLink(album.title, value: album)
            }
        } </st><strong class="bold"><st c="28348">detail: {</st></strong><st c="28357">
            if let selectedAlbum = selectedAlbum {
                List(selectedAlbum.songs, selection:
                  $selectedSong) { song in
                    Text(song.title)
                }
                .navigationTitle(selectedAlbum.title)
            } else {
                Text("Select an album")
            }
        }
    }</st></pre>			<p><st c="28554">Our code shows </st><code><st c="28570">NavigationSplitView</st></code><st c="28589"> with two parts – the sidebar (the first block) and the detail. </st><st c="28653">The sidebar shows a list of albums. </st><st c="28689">Tapping on an album updates the </st><code><st c="28721">selectedAlbum</st></code><st c="28734"> state variable. </st><st c="28751">The </st><code><st c="28755">detail</st></code><st c="28761"> block presents a list of songs about the </st><st c="28803">selected album.</st></p>
			<p><st c="28818">Let’s see how it looks on an iPad within landscape orientation (</st><em class="italic"><st c="28883">Figure 4</st></em><em class="italic"><st c="28892">.2</st></em><st c="28894">):</st></p>
			<div><div><img src="img/B21795_04_2.jpg" alt="Figure 4.2: Two columns in SplitView on iPad – landscape"/><st c="28897"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="28967">Figure 4.2: Two columns in SplitView on iPad – landscape</st></p>
			<p><st c="29023">Here is how it appears in</st><a id="_idIndexMarker207"/><st c="29049"> portrait orientation (</st><em class="italic"><st c="29072">Figure 4</st></em><em class="italic"><st c="29081">.3</st></em><st c="29083">):</st></p>
			<div><div><img src="img/B21795_04_3.jpg" alt="Figure 4.3: Two columns in SplitView in portrait orientation"/><st c="29086"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="29088">Figure 4.3: Two columns in SplitView in portrait orientation</st></p>
			<p><em class="italic"><st c="29148">Figures 4.2</st></em><st c="29160"> and </st><em class="italic"><st c="29165">4.3</st></em><st c="29168"> show how our code runs on an iPad in portrait and landscape orientations. </st><st c="29243">In portrait</st><a id="_idIndexMarker208"/><st c="29254"> orientation, the sidebar view shows up in a drawer, and in landscape orientation, the screen is split, and both views </st><st c="29373">are visible.</st></p>
			<p><st c="29385">But what happens on an iPhone? </st><st c="29417">Do we need to create a dedicated view for smaller devices? </st><st c="29476">Let’s see what happens with the same code on an iPhone (</st><em class="italic"><st c="29532">Figure 4</st></em><em class="italic"><st c="29541">.4</st></em><st c="29543">):</st></p>
			<div><div><img src="img/B21795_04_4.jpg" alt="Figure 4.4: NavigationSplitView on an iPhone"/><st c="29546"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="29598">Figure 4.4: NavigationSplitView on an iPhone</st></p>
			<p><em class="italic"><st c="29642">Figure 4</st></em><em class="italic"><st c="29651">.4</st></em><st c="29653"> shows that the same </st><code><st c="29674">NavigationSplitView</st></code><st c="29693"> just works when running on an iPhone. </st><st c="29732">On small devices, the </st><code><st c="29754">NavigationSplitView</st></code><st c="29773"> constructs a one-page navigation mechanism, similar</st><a id="_idIndexMarker209"/><st c="29825"> to what is seen in </st><code><st c="29845">NavigationStack</st></code><st c="29860"> or even in </st><st c="29872">UIKit’s </st><code><st c="29880">UINavigationController</st></code><st c="29902">.</st></p>
			<p><st c="29903">Now, let’s make things a little bit more complex and add a </st><st c="29963">third column.</st></p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor180"/><st c="29976">Moving to three columns</st></h2>
			<p><st c="30000">In many apps, the data </st><a id="_idIndexMarker210"/><st c="30024">hierarchy is based on two levels. </st><st c="30058">In our example, it is albums and songs, but in other cases, we can find groups and users, teams and players, or projects and tasks. </st><st c="30190">Based on that, we will have to work with a three-level </st><st c="30245">navigation system:</st></p>
			<ul>
				<li><st c="30263">Level 1: List of the first </st><st c="30291">level items</st></li>
				<li><st c="30302">Level 2: Based on the first-level selection, the list of </st><st c="30360">second-level items</st></li>
				<li><st c="30378">Level 3: Details of the selected </st><st c="30412">second-level item</st></li>
			</ul>
			<p><st c="30429">Even though we can present the details of the selected first-level item in a modal screen, we can consider showing it in a third column on an </st><st c="30572">iPad screen.</st></p>
			<p><st c="30584">In the </st><em class="italic"><st c="30592">Creating a NavigationSplitView</st></em><st c="30622"> section, we said that the </st><code><st c="30649">Detail</st></code><st c="30655"> column shows information about the last selected item. </st><st c="30711">This means that if we want to add another column, it will be between the </st><code><st c="30784">Detail</st></code><st c="30790"> column and the </st><code><st c="30806">Sidebar</st></code><st c="30813"> column – this is the </st><code><st c="30835">Content</st></code><st c="30842"> column.</st></p>
			<p><st c="30850">So, let’s add a </st><code><st c="30867">Content</st></code><st c="30874"> column to</st><a id="_idIndexMarker211"/><st c="30884"> our </st><st c="30889">music app:</st></p>
			<pre class="source-code"><st c="30899">
    var body: some View {
        </st><strong class="bold"><st c="30922">NavigationSplitView {</st></strong><st c="30943">
            List(albums, selection: $selectedAlbum) { album
              in
                NavigationLink(album.title, value: album)
            }
        </st><strong class="bold"><st c="31039">} content: {</st></strong><st c="31051">
            if let selectedAlbum = selectedAlbum {
                List(selectedAlbum.songs, selection:
                  $selectedSong) { song in
                    NavigationLink(song.title, value: song)
                }
                .navigationTitle(selectedAlbum.title)
            } else {
                Text("Select an album")
            }
        </st><strong class="bold"><st c="31268">} detail: {</st></strong><st c="31279">
            if let selectedSong = selectedSong {
                VStack {
                    Text("Song Title:
                      \(selectedSong.title)")
                    Text("Artist: \(selectedSong.artist)")
                }
                .padding()
                .navigationTitle(selectedSong.title)
            } else {
                Text("Select a song")
            }
        }
    }</st></pre>			<p><st c="31493">In the preceding code example, we put the list of songs in our new </st><code><st c="31561">Content</st></code><st c="31568"> block and the song details in the </st><code><st c="31603">Detail</st></code><st c="31609"> column. </st><st c="31618">We also used the same technique of </st><code><st c="31653">selectedSong</st></code><st c="31665"> state variable and updated our </st><st c="31697">UI accordingly.</st></p>
			<p><st c="31712">Let’s see how it looks</st><a id="_idIndexMarker212"/><st c="31735"> now on an iPad (</st><em class="italic"><st c="31752">Figure 4</st></em><em class="italic"><st c="31761">.5</st></em><st c="31763">):</st></p>
			<div><div><img src="img/B21795_04_5.jpg" alt="Figure 4.5: Three-columns NavigationSplitView on an iPad"/><st c="31766"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="31849">Figure 4.5: Three-columns NavigationSplitView on an iPad</st></p>
			<p><em class="italic"><st c="31905">Figure 4</st></em><em class="italic"><st c="31914">.5</st></em><st c="31916"> shows a </st><a id="_idIndexMarker213"/><st c="31925">three-column </st><code><st c="31938">NavigationSplitView</st></code><st c="31957"> on an iPad, now with the </st><code><st c="31983">Content</st></code><st c="31990"> column </st><a id="_idTextAnchor181"/><a id="_idTextAnchor182"/><st c="31998">showing the list of albums in </st><st c="32028">the middle.</st></p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor183"/><st c="32039">Summary</st></h1>
			<p><st c="32047">This chapter touches on a crucial topic in mobile development. </st><st c="32111">Navigation has always been an issue, also in UIKit. </st><st c="32163">However, we can achieve an effective navigation mechanism with thoughtful planning based on the product requirements and a balanced approach to flexibility </st><st c="32319">and simplicity.</st></p>
			<p><st c="32334">In this chapter, we went over the reasons why SwiftUI is a challenge, explored </st><code><st c="32414">NavigationStack</st></code><st c="32429">, reviewed the Coordinator pattern, </st><a id="_idTextAnchor184"/><a id="_idTextAnchor185"/><st c="32465">and even discussed a column-based navigation </st><st c="32510">with </st><code><st c="32515">NavigationSplitView</st></code><st c="32534">.</st></p>
			<p><st c="32535">By now, we are more than capable of creating an amazing navigation in </st><st c="32606">our app!</st></p>
			<p><st c="32614">Our next chapter discusses something completely different but exciting: how to break our app’s borders and add features outside our sandbox </st><st c="32755">with WidgetKit.</st></p>
		</div>
	<div></body></html>