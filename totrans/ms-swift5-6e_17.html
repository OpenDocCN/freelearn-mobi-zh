<html><head></head><body>
  <div><h1 class="chapterNumber">17</h1>
    <h1 id="_idParaDest-280" class="chapterTitle">Custom Value Types</h1>
    <p class="normal">In most traditional object-oriented programming languages, we create classes (which are reference types) as blueprints for our objects. In Swift, unlike other object-oriented languages, structures have much of the same functionality as classes, however, they are value types. Apple has said that we should prefer value types, such as structures, to reference types, but what are the differences between a reference type and a value type?</p>
    <p class="normal">In this chapter, you will explore the following topics:</p>
    <ul>
      <li class="bullet">The differences between value types and reference types </li>
      <li class="bullet">Why recursive data types cannot be created as a value type </li>
      <li class="bullet">How to implement copy-on-write in your custom type </li>
      <li class="bullet">How to conform to the <code class="Code-In-Text--PACKT-">Equatable</code> protocol</li>
    </ul>
    <p class="normal">As we saw in <em class="chapterRef">Chapter 8</em>, <em class="italic">Classes, Structures, and Protocols</em>, we have the ability to create our custom types as either a reference type (or class) or a value type (or structure). Let's review the differences between these two types because it is important to understand these differences when determining what type to use for our custom types.</p>
    <h1 id="_idParaDest-281" class="title">Value types and reference types</h1>
    <p class="normal">Structures are value types; when we pass instances of a structure in our application, we pass a copy <a id="_idIndexMarker674"/>of the structure and not the original structure. Classes are reference types; therefore, when we pass an instance of a class within our application, a reference <a id="_idIndexMarker675"/>to the original instance is passed. It is very important to understand this difference. We will discuss a very high-level view here but will provide additional details in <em class="chapterRef">Chapter 18</em>, <em class="italic">Memory Management</em>.</p>
    <p class="normal">When we pass structures within our application, we are passing copies of the structures and not the original structures. This means that the function gets its own copy of the structure, which it can change as needed without affecting the original instance of the structure.</p>
    <p class="normal">When we pass an instance of a class within our application, we are passing a reference to the original instance of the class, therefore, any changes made to the instance of the class will persist.</p>
    <p class="normal">To illustrate the difference between value types and reference types, let's examine a real-world object: a book. If we have a friend who wants to read <em class="italic">Mastering Swift 5.3, Sixth Edition</em>, we could either buy them their own copy or share ours.</p>
    <p class="normal">If we bought our friend their own copy of the book, then any notes they made in the book would remain in their copy of the book and would not be reflected in our copy. This is how passing by value works with structures and variables. Any changes that are made to the structure or variable within the function are not reflected back to the original instance of the structure or variable.</p>
    <p class="normal">If we share <a id="_idIndexMarker676"/>our copy of the book, then any notes that were made in the book will stay in the book when it is returned to us. This is how passing by reference works. Any changes that are made to the instance of the class remain when the function exits.</p>
    <p class="normal">When we <a id="_idIndexMarker677"/>pass an instance of a value type, we are actually passing a copy of the instance. You may be wondering about the performance of large value types when they are passed from one part of our code to another. For structures that have the possibility of becoming very large, we can use copy-on-write.</p>
    <p class="normal">The explanation in the previous paragraphs is pretty straightforward; however, it is a very important concept that we must understand. In this section, we are going to examine the differences between value types and reference types so that we know when to use each type.</p>
    <p class="normal">Let's begin by creating two types; one is going to be a structure (or value type) and the other is going to be a class (or reference type). We will be using these types in this section to demonstrate the differences between value types and reference types. The first type that we will examine is named <code class="Code-In-Text--PACKT-">MyValueType</code>. We will implement <code class="Code-In-Text--PACKT-">MyValueType</code> using a structure, which means that it is a value type, as its name suggests:</p>
    <pre class="programlisting code"><code class="hljs-code">struct MyValueType { 
    var name: String
    var assignment: String 
    var grade: Int
}
</code></pre>
    <p class="normal">In <code class="Code-In-Text--PACKT-">MyValueType</code>, we define three properties. Two of the properties are of the <code class="Code-In-Text--PACKT-">String</code> type (<code class="Code-In-Text--PACKT-">name</code> and <code class="Code-In-Text--PACKT-">assignment</code>) and one is of the <code class="Code-In-Text--PACKT-">Integer</code> type (<code class="Code-In-Text--PACKT-">grade</code>). Now, let's take a look at how we can implement this as a class:</p>
    <pre class="programlisting code"><code class="hljs-code">class MyReferenceType { 
    var name: String
    var assignment: String 
    var grade: Int
    init(name: String, assignment: String, grade: Int) { 
        self.name = name
        self.assignment = assignment 
        self.grade = grade
    }
}
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">MyReferenceType</code> type defines the same three properties as in the <code class="Code-In-Text--PACKT-">MyValueType</code> type, however, we need to define an initializer in the <code class="Code-In-Text--PACKT-">MyReferenceType</code> type that we did not need <a id="_idIndexMarker678"/>to define in the <code class="Code-In-Text--PACKT-">MyValueType</code> type. The reason for this is that structures provide us with a default initializer that will initialize all the properties that need <a id="_idIndexMarker679"/>to be initialized if we do not provide a default initializer.</p>
    <p class="normal">Let's take a look at how we can use each of these types. The following code shows how we can create instances of each of these types:</p>
    <pre class="programlisting code"><code class="hljs-code">var ref = MyReferenceType(name: "Jon", assignment: "Math Test 1", grade: 90)
var val = MyValueType(name: "Jon", assignment: "Math Test 1", grade: 90)
</code></pre>
    <p class="normal">As you can see in this code, instances of structures are created in exactly the same way as the instances of classes. Being able to use the same format to create instances of structures and classes is good because it makes our lives easier; however, we do need to bear in mind that value types behave in a different manner to reference types. Let's explore this; the first thing we need to do is create two functions that will change the grades for the instances of the two types:</p>
    <pre class="programlisting code"><code class="hljs-code">func extraCreditReferenceType(ref: MyReferenceType, extraCredit: Int) {
    ref.grade += extraCredit
}
func extraCreditValueType(val: MyValueType, extraCredit: Int) { 
    val.grade += extraCredit
}
</code></pre>
    <p class="normal">Each of these functions takes an instance of one of our types and an extra credit amount. Within the function, we will add the extra credit amount to the grade. If we try to use this code we will receive an error in the <code class="Code-In-Text--PACKT-">extraCreditValueType()</code> function telling us that the left side of the mutable operation is not mutable. The reason for this is that a value type parameter, by default, is immutable because the function is receiving an immutable copy of the parameter.</p>
    <p class="normal">Using a value type like this protects us from making accidental changes to the instances; this is because the <a id="_idIndexMarker680"/>instances are scoped to the function or type in which they are created. Value types also protect us from having multiple references to the same instance. Therefore, they are, by default, thread (concurrency) safe because each thread <a id="_idIndexMarker681"/>will have its own version of the value type. If we absolutely need to change an instance of a value type outside of its scope, we could use an <code class="Code-In-Text--PACKT-">inout</code> parameter.</p>
    <p class="normal">We define an <code class="Code-In-Text--PACKT-">inout</code> parameter by placing the <code class="Code-In-Text--PACKT-">inout</code> keyword at the start of the parameter's definition. An <code class="Code-In-Text--PACKT-">inout</code> parameter has a value that is passed into the function. This value is then modified by the function and is passed back out of the function to replace the original value.</p>
    <p class="normal">Let's explore how we can use an <code class="Code-In-Text--PACKT-">inout</code> parameter. We will begin by creating a function that is designed to retrieve the grade for an assignment from a data store. However, to simplify our example, we will simply generate a random score. The following code demonstrates how we can write this function.</p>
    <p class="normal">Let's take a look at how we can use value types with the <code class="Code-In-Text--PACKT-">inout</code> keyword to create a version of the previous example that will work correctly. The first thing we need to do is modify the <code class="Code-In-Text--PACKT-">getGradesForAssignment()</code> function to use an instance of <code class="Code-In-Text--PACKT-">MyValueType</code> that it can modify:</p>
    <pre class="programlisting code"><code class="hljs-code">func getGradeForAssignment(assignment: inout MyValueType) {
    // Code to get grade from DB
    // Random code here to illustrate issue 
    let num = Int.random(in: 80..&lt;100)
    assignment.grade = num
    print("Grade for \(assignment.name) is \(num)")
}
</code></pre>
    <p class="normal">This function is designed to retrieve the grade for the assignment that is defined in the <code class="Code-In-Text--PACKT-">MyValueType</code> instance and is then passed into the function. Once the grade is retrieved, we will use it to set the grade property of the <code class="Code-In-Text--PACKT-">MyValueType</code> instance. We will also print the grade out to the console so that we can see what grade it is. Now let's explore how to use this function:</p>
    <pre class="programlisting code"><code class="hljs-code">var mathGrades = [MyValueType]()
var students = ["Jon", "Kailey", "Kara"]
var mathAssignment = MyValueType(name: "", assignment: "Math Assignment", grade: 0)
for student in students { 
    mathAssignment.name = student
    getGradeForAssignment(assignment: &amp;mathAssignment)
    mathGrades.append(mathAssignment)
}
for assignment in mathGrades { 
    print("\(assignment.name): grade \(assignment.grade)")
}
</code></pre>
    <p class="normal">In the previous code, we created a <code class="Code-In-Text--PACKT-">mathGrades</code> array that will store the grades for our assignment and a <code class="Code-In-Text--PACKT-">students</code> array that will contain the names of the students that we wish to <a id="_idIndexMarker682"/>retrieve the grades for. We then created an instance of the <code class="Code-In-Text--PACKT-">MyValueType</code> structure that contains the name for the assignment. We will use this instance to <a id="_idIndexMarker683"/>request the grades from the <code class="Code-In-Text--PACKT-">getGradeForAssignment()</code> function. Notice that when we pass in the <code class="Code-In-Text--PACKT-">mathAssignment</code> instance, we prefix the name of the instance with the <code class="Code-In-Text--PACKT-">&amp;</code> symbol. This lets us know that we are passing the reference to the original instance and not a copy. Now that everything is defined, we will loop through the list of students to retrieve the grades. The output of this code will look similar to the following snippet:</p>
    <pre class="programlisting con"><code class="hljs-con">Grade for Jon is 87 
Grade for Kailey is 90 
Grade for Kara is 83
Jon: grade 87
Kailey: grade 90
Kara: grade 83
</code></pre>
    <p class="normal">The output from this code is what we expected to see, where each instance in the <code class="Code-In-Text--PACKT-">mathGrades</code> array represents the correct grade. The reason this code works correctly is that we are passing a reference from the <code class="Code-In-Text--PACKT-">mathAssignment</code> instance to the <code class="Code-In-Text--PACKT-">getGradeForAssignment()</code> function, and not a copy.</p>
    <p class="normal">There are some things we cannot do with value types that we can do with reference (or class) types. The first thing that we will look at is the recursive data type.</p>
    <h2 id="_idParaDest-282" class="title">Recursive data types for reference types</h2>
    <p class="normal">A recursive data type is a type that contains values of the same type as a property for the type. Recursive <a id="_idIndexMarker684"/>data types are used when we <a id="_idIndexMarker685"/>want to define dynamic data structures, such as lists and trees. The size of these dynamic data structures can grow or shrink depending on our runtime requirements.</p>
    <p class="normal">Linked lists are perfect examples of a dynamic data structure that we can implement using a recursive data type. A linked list is a group of nodes that are linked together and where, in its simplest form, each node maintains a link to the next node in the list. <em class="italic">Figure 17.1</em> shows how a very basic linked list works:</p>
    <figure class="mediaobject"><img src="img/B16683_17_01.png" alt="A screenshot of a cell phone  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 17.1: A basic linked list</p>
    <p class="normal">Each node in the list contains a value or data, and it also contains the link to the next node in the list. If one of the nodes in the list loses the reference to the next node, then the remainder of the list will be lost because each node is only aware of the next node. Some linked lists maintain a link to both the previous nodes and the following nodes to allow us to move both forward and backward through the list.</p>
    <p class="normal">The following code shows how we can create a linked list using a reference type:</p>
    <pre class="programlisting code"><code class="hljs-code">class LinkedListReferenceType { 
    var value: String
    var next: LinkedListReferenceType? 
    init(value: String) {
        self.value = value
    }
}
</code></pre>
    <p class="normal">In the <code class="Code-In-Text--PACKT-">LinkedListReferenceType</code> class, we have two properties. The first property is named <code class="Code-In-Text--PACKT-">value</code> and it contains the data for this instance. The second property is named <code class="Code-In-Text--PACKT-">next</code>, which points to the next item in the linked list. If the <code class="Code-In-Text--PACKT-">next</code> property is <code class="Code-In-Text--PACKT-">nil</code>, then this instance will be the last node in the list. If we try to implement this linked list as a value type, the code will be similar to the following:</p>
    <pre class="programlisting code"><code class="hljs-code">struct LinkedListValueType { 
    var value: String
    var next: LinkedListValueType?
}
</code></pre>
    <p class="normal">When we add this code to a playground, we receive the following error: <code class="Code-In-Text--PACKT-">Recursive</code> <code class="Code-In-Text--PACKT-">value type LinkedListValueType is not allowed</code>. This tells us that Swift does not allow recursive value types. However, we can implement them as a reference type, which we discussed earlier.</p>
    <p class="normal">If you think about it, recursive value types are a really bad idea because of how value types function. Let's examine this for a minute, because it will really stress the difference <a id="_idIndexMarker686"/>between value types and reference types. It will also help you to understand <em class="italic">why </em>we need reference types.</p>
    <p class="normal">Let's say <a id="_idIndexMarker687"/>that we are able to create the <code class="Code-In-Text--PACKT-">LinkedListValueType</code> structure without any errors. Now let's create three nodes for our list, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">var one = LinkedListValueType(value: "One",next: nil) 
var two = LinkedListValueType(value: "Two",next: nil)
var three = LinkedListValueType(value: "Three",next: nil)
</code></pre>
    <p class="normal">Now we will link these nodes together using the following code:</p>
    <pre class="programlisting con"><code class="hljs-con">one.next = two
two.next = three
</code></pre>
    <p class="normal">Do you see the problem with this code? If not, think about how a value type is passed. In the first line, <code class="Code-In-Text--PACKT-">one.next = two</code>, we are not actually setting the <code class="Code-In-Text--PACKT-">next</code> property to the original <code class="Code-In-Text--PACKT-">two</code> instance; in fact, we are actually setting it to a copy of the <code class="Code-In-Text--PACKT-">two</code> instance, because by implementing the <code class="Code-In-Text--PACKT-">LinkedListValueType</code> as a value type, we are passing the value and not the actual instance. This means that in the next line, <code class="Code-In-Text--PACKT-">two.next = three</code>, we are setting the next property of the original <code class="Code-In-Text--PACKT-">two</code> instance to the <code class="Code-In-Text--PACKT-">three</code> instance.</p>
    <p class="normal">However, this change is not reflected back in the copy that was made for the next property of the <code class="Code-In-Text--PACKT-">one</code> instance. Sounds a little confusing? Let's clear it up a little by looking at a diagram that shows the state of our three <code class="Code-In-Text--PACKT-">LinkedListValueType</code> instances if we were able to run this code:</p>
    <figure class="mediaobject"><img src="img/B16683_17_02.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 17.2: A linked list structure example</p>
    <p class="normal">As you can see from the diagram, the next property of the <code class="Code-In-Text--PACKT-">one</code> instance is pointing to a copy of <a id="_idIndexMarker688"/>the <code class="Code-In-Text--PACKT-">two</code> instance whose next property is still <code class="Code-In-Text--PACKT-">nil</code>. The next property of the original <code class="Code-In-Text--PACKT-">two</code> instance, however, is pointing to the <code class="Code-In-Text--PACKT-">three</code> instance. This means that, if we try to go through the list by starting at the <code class="Code-In-Text--PACKT-">one</code> instance, we <a id="_idIndexMarker689"/>will not reach the <code class="Code-In-Text--PACKT-">three</code> instance because the copy of the <code class="Code-In-Text--PACKT-">two</code> instance will still have a <code class="Code-In-Text--PACKT-">next</code> property that is <code class="Code-In-Text--PACKT-">nil</code>.</p>
    <p class="normal">Another thing that we can only do with reference (or class) types is class inheritance.</p>
    <h2 id="_idParaDest-283" class="title">Inheritance for reference types</h2>
    <p class="normal">In object-oriented <a id="_idIndexMarker690"/>programming, inheritance refers to one class (known as a <strong class="keyword">sub</strong> or <strong class="keyword">child</strong> <strong class="keyword">class</strong>) being <a id="_idIndexMarker691"/>derived from another class (known as a <strong class="keyword">super</strong> or <strong class="keyword">parent</strong> <strong class="keyword">class</strong>). The subclass <a id="_idIndexMarker692"/>will inherit methods, properties, and other <a id="_idIndexMarker693"/>characteristics from the superclass. With inheritance, we can also create a class hierarchy where we can have multiple layers of inheritance.</p>
    <p class="normal">Let's <a id="_idIndexMarker694"/>take a look at how we can create a class hierarchy <a id="_idIndexMarker695"/>with classes in Swift. We will start off by creating a base class named <code class="Code-In-Text--PACKT-">Animal</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">class Animal {
    var numberOfLegs = 0 
    func sleeps() {
        print("zzzzz")
    }
    func walking() {
        print("Walking on \(numberOfLegs) legs")
    }
    func speaking() {
        print("No sound")
    }
}
</code></pre>
    <p class="normal">In the <code class="Code-In-Text--PACKT-">Animal</code> class, we defined one property (<code class="Code-In-Text--PACKT-">numberOfLegs</code>) and three methods (<code class="Code-In-Text--PACKT-">sleeps()</code>, <code class="Code-In-Text--PACKT-">walking()</code>, and <code class="Code-In-Text--PACKT-">speaking()</code>). Now, any class that is a subclass of the <code class="Code-In-Text--PACKT-">Animal</code> class will also have these properties and methods. Let's examine how this works by creating two <a id="_idIndexMarker696"/>classes that are subclasses of the <code class="Code-In-Text--PACKT-">Animal</code> class. These two classes will be named <code class="Code-In-Text--PACKT-">Biped</code> (an animal with two legs) and <code class="Code-In-Text--PACKT-">Quadruped</code> (an animal with four legs):</p>
    <pre class="programlisting code"><code class="hljs-code">class Biped: Animal { 
    override init() {
        super.init() numberOfLegs =2
    }
}
class Quadruped: Animal { 
    override init() {
        super.init() numberOfLegs = 4
    }
}
</code></pre>
    <p class="normal">Since these <a id="_idIndexMarker697"/>two classes inherit all the properties and methods from the <code class="Code-In-Text--PACKT-">Animal</code> class, all we need to do is create an initializer that sets the <code class="Code-In-Text--PACKT-">numberOfLegs</code> property to the correct number of legs. Now, let's add another layer of inheritance by creating a <code class="Code-In-Text--PACKT-">Dog</code> class that will be a subclass of the <code class="Code-In-Text--PACKT-">Quadruped</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">class Dog: Quadruped { 
    override func speaking() {
        print("Barking")
    }
}
</code></pre>
    <p class="normal">In the <code class="Code-In-Text--PACKT-">Dog</code> class, we inherit from the <code class="Code-In-Text--PACKT-">Quadruped</code> class, which, in turn, inherits from the <code class="Code-In-Text--PACKT-">Animal</code> class. Therefore, the <code class="Code-In-Text--PACKT-">Dog</code> class will have all the properties, methods, and characteristics of both the <code class="Code-In-Text--PACKT-">Animal</code> and <code class="Code-In-Text--PACKT-">Quadruped</code> classes. If the <code class="Code-In-Text--PACKT-">Quadruped</code> class overrides anything from the <code class="Code-In-Text--PACKT-">Animal</code> class, then the <code class="Code-In-Text--PACKT-">Dog</code> class will inherit the version from the <code class="Code-In-Text--PACKT-">Quadruped</code> class.</p>
    <p class="normal">We can create very complex class hierarchies in this manner; for example, <em class="italic">Figure 17.3</em> expands on the class hierarchy that we just created to add several other animal classes:</p>
    <figure class="mediaobject"><img src="img/B16683_17_03.png" alt="A close up of a piece of paper  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 17.3: Animal class hierarchy</p>
    <p class="normal">Class hierarchies can get very complex. However, as you just saw, they can eliminate a lot of duplicate <a id="_idIndexMarker698"/>code because our subclasses inherit methods, properties, and other characteristics from their superclasses. Therefore, we do not need to recreate them in all of the subclasses.</p>
    <p class="normal">The biggest <a id="_idIndexMarker699"/>drawback of a class hierarchy is the complexity. When we have a complex hierarchy (as shown in the preceding diagram), it is easy to make a change and not realize how it is going to affect all of the subclasses. If you consider the <code class="Code-In-Text--PACKT-">Dog</code> and <code class="Code-In-Text--PACKT-">Cat</code> classes, for example, we may want to add a <code class="Code-In-Text--PACKT-">furColor</code> property to our <code class="Code-In-Text--PACKT-">Quadruped</code> class so that we can set the color of the animal's fur. However, horses do not have fur; they have hair. So, before we can make any changes to a class in our hierarchy, we need to understand how it will affect all the subclasses in the hierarchy.</p>
    <p class="normal">In Swift, it is best to avoid using complex class hierarchies (as shown in this example), and instead use a protocol-oriented design, unless, of course, there are specific reasons to use them. Now that we have a good understanding of reference and value types, let's explore dynamic dispatch.</p>
    <h2 id="_idParaDest-284" class="title">Dynamic dispatch</h2>
    <p class="normal">In the previous section, we learned how to use inheritance with classes in order to inherit and <a id="_idIndexMarker700"/>override the functionality defined in a superclass. You may be wondering how and when the appropriate implementation is chosen. The process of choosing which implementation to call is performed at runtime and is known as <strong class="keyword">dynamic dispatch</strong>.</p>
    <p class="normal">One of the key points to understand from the last paragraph is that the implementation is chosen at runtime. What this means is that a certain amount of runtime overhead is associated with using class inheritance, as shown in the <em class="italic">Inheritance for reference types </em>section. For most applications, this overhead is not a concern; however, for performance-sensitive applications such as games, this overhead can be costly.</p>
    <p class="normal">One of the ways that we can reduce the overhead associated with dynamic dispatch is to use the <code class="Code-In-Text--PACKT-">final</code> keyword. The <code class="Code-In-Text--PACKT-">final</code> keyword puts a restriction on the class, method, or function to indicate that it cannot be overridden, in the case of a method or function, or subclasses, in the case of a class.</p>
    <p class="normal">To use the <code class="Code-In-Text--PACKT-">final</code> keyword, you put it prior to the class, method, or function declaration, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">final func myFunc() {} 
final var myProperty = 0 
final class MyClass {}
</code></pre>
    <p class="normal">In the <em class="italic">Inheritance for reference types</em> section, we defined a <code class="Code-In-Text--PACKT-">class</code> hierarchy that started with the <code class="Code-In-Text--PACKT-">Animal</code> superclass. If we want to restrict subclasses from overriding the <code class="Code-In-Text--PACKT-">walking()</code> method and the <code class="Code-In-Text--PACKT-">numberOfLegs</code> property, we can change the <code class="Code-In-Text--PACKT-">Animal</code> implementation, as shown in the next example:</p>
    <pre class="programlisting code"><code class="hljs-code">class Animal {
    final var numberOfLegs = 0
    func sleeps() { 
        print("zzzzz")
    }
    final func walking() {
        print("Walking on \(numberOfLegs) legs")
    }
    func speaking() { 
        print("No	sound")
    }
}
</code></pre>
    <p class="normal">This change allows the application, at runtime, to make a direct call to the <code class="Code-In-Text--PACKT-">walking()</code> method rather than an indirect call that gives the application a slight performance increase. If you <a id="_idIndexMarker701"/>must use a class hierarchy, it is good practice to use the <code class="Code-In-Text--PACKT-">final</code> keyword wherever possible; however, it is better to use a protocol-oriented design, with value types, to avoid this.</p>
    <p class="normal">Now, let's take a look at something that can help with the performance of our custom value types: copy-on-write.</p>
    <h2 id="_idParaDest-285" class="title">Copy-on-write</h2>
    <p class="normal">Normally, when <a id="_idIndexMarker702"/>we pass an instance of a value type, such as a structure, a new copy of the instance is created. This means that if we have a large data structure that contains 100,000 elements, then every time we pass that instance, we will have to copy all 100,000 elements. This can have a detrimental impact on the performance of our applications, especially if we pass the instance to numerous functions.</p>
    <p class="normal">To solve this issue, Apple has implemented the copy-on-write feature for all the data structures (such as <code class="Code-In-Text--PACKT-">Array</code>, <code class="Code-In-Text--PACKT-">Dictionary</code>, and <code class="Code-In-Text--PACKT-">Set</code>) in the Swift standard library. With copy-on-write, Swift does not make a second copy of the data structure until a change is made to that data structure. Therefore, if we pass an array of 50,000 elements to another part of our code, and that code does not make any changes to the array, we will avoid the runtime overhead of copying all the elements.</p>
    <p class="normal">This is a very useful feature and can greatly increase the performance of our applications. However, our custom value types do not automatically get this feature by default. In this section, we will explore how we can use reference types and value types together to implement the copy-on-write feature for our custom value types. To do this, we will create a very basic queue type that will demonstrate how you can add copy-on-write functionality to your custom value types.</p>
    <p class="normal">We will start off by creating a backend storage type called <code class="Code-In-Text--PACKT-">BackendQueue</code> and will implement it as a reference type. The following code gives our <code class="Code-In-Text--PACKT-">BackendQueue</code> type the basic functionality of a queue type:</p>
    <pre class="programlisting code"><code class="hljs-code">fileprivate class BackendQueue&lt;T&gt; { 
    private var items = [T]()
    public func addItem(item: T) { 
        items.append(item)
    }
    public func getItem() -&gt; T? {
        if items.count &gt; 0 {
            return items.remove(at: 0)
        } else {
            return nil
        }
    }
    public func count() -&gt; Int { 
        return items.count
    }
}
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">BackendQueue</code> type is a generic type that uses an array to store the data. This type contains three methods, which enables us to add items to the queue, retrieve an item from the queue, and return the number of items in the queue. We use the <code class="Code-In-Text--PACKT-">fileprivate</code> access level <a id="_idIndexMarker703"/>to prevent the use of this type outside of the defining source file, because it should only be used to implement the copy-on-write feature for our main queue type.</p>
    <p class="normal">We now need to add a couple of extra items to the <code class="Code-In-Text--PACKT-">BackendQueue</code> type so that we can use it to implement the copy-on-write feature for the main queue type. The first thing that we will add is a public default initializer and a private initializer that can be used to create a new instance of the <code class="Code-In-Text--PACKT-">BackendQueue</code> type; the following code shows the two initializers:</p>
    <pre class="programlisting code"><code class="hljs-code">public init() {}
private init(_ items: [T]) { 
    self.items = items
}
</code></pre>
    <p class="normal">The public initializer will be used to create an instance of the <code class="Code-In-Text--PACKT-">BackendQueue</code> type without any items in the queue. The private initializer will be used internally to create a copy of itself that contains any items that are currently in the queue. Now we will need to create a method that will use the private initializer to create a copy of itself when required:</p>
    <pre class="programlisting code"><code class="hljs-code">public func copy() -&gt; BackendQueue&lt;T&gt; {
    return BackendQueue&lt;T&gt;(items)
}
</code></pre>
    <p class="normal">It could be very easy to make the private initializer public and then let the main queue type call that initializer to create the copy; however, it is good practice to keep the logic needed to create the new copy within the type itself. The reason why you should do this is that if you need to make changes to the type, that may affect how the type is copied. Instead, the logic <a id="_idIndexMarker704"/>that you need to change the type is embedded within the type itself and is easy to find. Additionally, if you use the <code class="Code-In-Text--PACKT-">BackendQueue</code> type as the backend storage for multiple types, you will only need to make the changes to the copy logic in one place if it changes.</p>
    <p class="normal">Here is the final code for the <code class="Code-In-Text--PACKT-">BackendQueue</code> type:</p>
    <pre class="programlisting code"><code class="hljs-code">fileprivate class BackendQueue&lt;T&gt; { 
    private var items = [T]()
    public init() {}
    private init(_ items: [T]) { 
        self.items = items
    }
    public func addItem(item: T) { 
        items.append(item)
    }
    public func getItem() -&gt; T? { 
        if items.count &gt; 0 {
            return items.remove(at: 0)
        } else {
            return nil
        }
    }
    public func count() -&gt; Int { 
        return items.count
    }
    public func copy() -&gt; BackendQueue&lt;T&gt; { 
        return BackendQueue&lt;T&gt;(items)
    }
}
</code></pre>
    <p class="normal">Now let's create our <code class="Code-In-Text--PACKT-">Queue</code> type, which will use the <code class="Code-In-Text--PACKT-">BackendQueue</code> type to implement the copy-on-write feature. The following code adds the basic queue functionality to our <code class="Code-In-Text--PACKT-">Queue</code> type:</p>
    <pre class="programlisting code"><code class="hljs-code">struct Queue {
    private var internalQueue = BackendQueue&lt;Int&gt;()
    public mutating func addItem(item: Int) {
        internalQueue.addItem(item: item)
    }
    public mutating func getItem() -&gt; Int? { 
        return internalQueue.getItem()
    }
    public func count() -&gt; Int { 
        return internalQueue.count()
    }
}
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Queue</code> type is implemented as a value type. This type has one private property of the <code class="Code-In-Text--PACKT-">BackendQueue</code> type, which will be used to store the data. This type contains three methods to <a id="_idIndexMarker705"/>add items to the queue, retrieve an item from the queue, and return the number of items in the queue. Now let's explore how we can add the copy-on-write feature to the <code class="Code-In-Text--PACKT-">Queue</code> type.</p>
    <p class="normal">Swift has a global function named <code class="Code-In-Text--PACKT-">isKnownUniquelyReferenced()</code>. This function will return <code class="Code-In-Text--PACKT-">true</code> if there is only one reference to an instance of a reference type, or <code class="Code-In-Text--PACKT-">false</code> if there is more than one reference.</p>
    <p class="normal">We will begin by adding a function to check whether there is a unique reference to the <code class="Code-In-Text--PACKT-">internalQueue</code> instance. This will be a private function named <code class="Code-In-Text--PACKT-">checkUniquelyReferencedInternalQueue</code>. The following code shows how we can implement this method:</p>
    <pre class="programlisting code"><code class="hljs-code">mutating private func checkUniquelyReferencedInternalQueue() { 
    if !isKnownUniquelyReferenced(&amp;internalQueue) {
        internalQueue = internalQueue.copy() 
        print("Making a copy of internalQueue")
    } else {
        print("Not making a copy of internalQueue")
    }
}
</code></pre>
    <p class="normal">In this method, we check to see whether there are multiple references to the <code class="Code-In-Text--PACKT-">internalQueue</code> instances. If there are multiple references, then we know that we have multiple copies of the <code class="Code-In-Text--PACKT-">Queue</code> instance and, therefore, we can create a new copy.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Queue</code> type itself is a value type; therefore, when we pass an instance of the <code class="Code-In-Text--PACKT-">Queue</code> type within our code, the code that we pass the instance to receives a new copy of that instance. The <code class="Code-In-Text--PACKT-">BackendQueue</code> type, which the <code class="Code-In-Text--PACKT-">Queue</code> type is using, is a reference type. Therefore, when a copy is made of a <code class="Code-In-Text--PACKT-">Queue</code> instance, then that new copy receives a reference to <a id="_idIndexMarker706"/>the original <code class="Code-In-Text--PACKT-">Queue</code>'s <code class="Code-In-Text--PACKT-">BackendQueue</code> instance and not a new copy. This means that each instance of the <code class="Code-In-Text--PACKT-">Queue</code> type has a reference to the same <code class="Code-In-Text--PACKT-">internalQueue</code> instance. Consider the following code as an example; both <code class="Code-In-Text--PACKT-">queue1</code> and <code class="Code-In-Text--PACKT-">queue2</code> have references to the same <code class="Code-In-Text--PACKT-">internalQueue</code> instance:</p>
    <pre class="programlisting code"><code class="hljs-code">var queue1 = Queue()
var queue2 = queue1
</code></pre>
    <p class="normal">In the <code class="Code-In-Text--PACKT-">Queue</code> type, we know that both the <code class="Code-In-Text--PACKT-">addItem()</code> and <code class="Code-In-Text--PACKT-">getItem()</code> methods change the <code class="Code-In-Text--PACKT-">internalQueue</code> instance. Therefore, before we make these changes, we will want to call the <code class="Code-In-Text--PACKT-">checkUniquelyReferencedInternalQueue()</code> method to create a new copy of the <code class="Code-In-Text--PACKT-">internalQueue</code> instance. These two methods will now have the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">public mutating func addItem(item: Int) { 
    checkUniquelyReferencedInternalQueue()
    internalQueue.addItem(item: item)
}
public mutating func getItem() -&gt; Int? { 
    checkUniquelyReferencedInternalQueue()
    return internalQueue.getItem()
}
</code></pre>
    <p class="normal">With this code, when either the <code class="Code-In-Text--PACKT-">addItem()</code> or <code class="Code-In-Text--PACKT-">getItem()</code> methods are called – which will change the data in the <code class="Code-In-Text--PACKT-">internalQueue instance</code> – we use the <code class="Code-In-Text--PACKT-">checkUniquelyReferencedInternalQueue()</code> method to create a new instance of the data structure.</p>
    <p class="normal">Let's add one additional method to the <code class="Code-In-Text--PACKT-">Queue</code> type, which will allow us to see whether there is a unique reference to the <code class="Code-In-Text--PACKT-">internalQueue</code> instance or not. Here is the code for this method:</p>
    <pre class="programlisting code"><code class="hljs-code">mutating public func uniquelyReferenced() -&gt; Bool { 
    return isKnownUniquelyReferenced(&amp;internalQueue)
}
</code></pre>
    <p class="normal">Here is the full code listing for the <code class="Code-In-Text--PACKT-">Queue</code> type:</p>
    <pre class="programlisting code"><code class="hljs-code">struct Queue {
    private var internalQueue = BackendQueue&lt;Int&gt;()
    mutating private func checkUniquelyReferencedInternalQueue() { 
        if !isKnownUniquelyReferenced(&amp;internalQueu<a id="_idIndexMarker707"/>e) {
            print("Making a copy of internalQueue")
            internalQueue = internalQueue.copy()
        } else {
            print("Not making a copy of internalQueue")
        }
    }
    public mutating func addItem(item: Int) { 
        checkUniquelyReferencedInternalQueue()
        internalQueue.addItem(item: item)
    }
    public mutating func getItem() -&gt; Int? {
        checkUniquelyReferencedInternalQueue(); 
        return internalQueue.getItem()
    }
    public func count() -&gt; Int { 
        return internalQueue.count()
    }
    mutating public func uniquelyReferenced() -&gt; Bool { 
        return isKnownUniquelyReferenced(&amp;internalQueue)
    }
}
</code></pre>
    <p class="normal">Now let's examine how the copy-on-write functionality works with the <code class="Code-In-Text--PACKT-">Queue</code> type. We will start off by creating a new instance of the <code class="Code-In-Text--PACKT-">Queue</code> type, adding an item to the queue, and then checking whether we have a unique reference to the <code class="Code-In-Text--PACKT-">internalQueue</code> instance. The following code demonstrates how to do this:</p>
    <pre class="programlisting code"><code class="hljs-code">var queue3 = Queue()
queue3.addItem(item: 1)
print(queue3.uniquelyReferenced())
</code></pre>
    <p class="normal">When we add the item to the queue, the following message will be printed to the console. This tells us that within the <code class="Code-In-Text--PACKT-">checkUniquelyReferencedInternalQueue()</code> method, it was determined that there was only one reference to the <code class="Code-In-Text--PACKT-">internalQueue</code> instance:</p>
    <pre class="programlisting con"><code class="hljs-con">Not making a copy of internalQueue
</code></pre>
    <p class="normal">We can verify this by printing the results of the <code class="Code-In-Text--PACKT-">uniquelyReference()</code> method to the console. Now let's make a copy of the <code class="Code-In-Text--PACKT-">queue3</code> instance by passing it to a new variable, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">var queue4 = queue3
</code></pre>
    <p class="normal">Now let's <a id="_idIndexMarker708"/>check whether we have a unique reference to the <code class="Code-In-Text--PACKT-">internalQueue</code> instances of either the <code class="Code-In-Text--PACKT-">queue3</code> or <code class="Code-In-Text--PACKT-">queue4</code> instance. The following code will do this:</p>
    <pre class="programlisting code"><code class="hljs-code">print(queue3.uniquelyReferenced())
print(queue4.uniquelyReferenced())
</code></pre>
    <p class="normal">This code will print two <code class="Code-In-Text--PACKT-">false</code> messages to the console, letting us know that neither instance has a unique reference to their <code class="Code-In-Text--PACKT-">internalQueue</code> instances. Now let's add an item to either one of the queues. The following code will add another item to the <code class="Code-In-Text--PACKT-">queue3</code> instance:</p>
    <pre class="programlisting code"><code class="hljs-code">queue3.addItem(item: 2)
</code></pre>
    <p class="normal">When we add the item to the queue, we will see the following message printed to the console:</p>
    <pre class="programlisting con"><code class="hljs-con">Making a copy of internalQueue
</code></pre>
    <p class="normal">This message tells us that when we add the new item to the queue, a new copy of the <code class="Code-In-Text--PACKT-">internalQueue</code> instance is created. In order to verify this, we can print the results of the <code class="Code-In-Text--PACKT-">uniquelyReferenced()</code> methods to the console again. If you do check this, you will see two <code class="Code-In-Text--PACKT-">true</code> messages printed to the console this time rather than two <code class="Code-In-Text--PACKT-">false</code> methods. We can now add additional items to the queues and we will see that we are not creating new instances of the <code class="Code-In-Text--PACKT-">internalQueue</code> instance because each instance of the <code class="Code-In-Text--PACKT-">Queue</code> type now has its own copy.</p>
    <div><p class="Information-Box--PACKT-">If you are planning on creating your own data structure that may contain a large number of items, it is recommended that you implement it with the copy-on-write feature as described here. </p>
    </div>
    <p class="normal">If you are <a id="_idIndexMarker709"/>comparing your custom types, it is also recommended that you implement the <code class="Code-In-Text--PACKT-">Equatable</code> protocol within these custom types. This will enable you to compare two instances of the type using the equal-to (<code class="Code-In-Text--PACKT-">==</code>) and not-equal-to (<code class="Code-In-Text--PACKT-">!=</code>) operators.</p>
    <h1 id="_idParaDest-286" class="title">Implementing the Equatable protocol</h1>
    <p class="normal">In this section, we will demonstrate how we can conform to the <code class="Code-In-Text--PACKT-">Equatable</code> protocol using extensions. When <a id="_idIndexMarker710"/>a type conforms to the <code class="Code-In-Text--PACKT-">Equatable</code> protocol, we can use the equal-to (<code class="Code-In-Text--PACKT-">==</code>) operator to compare for equality and the not-equal-to (<code class="Code-In-Text--PACKT-">!=</code>) operator to compare for inequality.</p>
    <div><p class="Tip--PACKT-">If you will be comparing instances of a custom type, then it is a good idea to have that type conform to the <code class="Code-In-Text--PACKT-">Equatable</code> protocol because it makes comparing instances very easy.</p>
    </div>
    <p class="normal">Let's start off by creating the type that we will compare. We will name this type <code class="Code-In-Text--PACKT-">Place</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">struct Place {
    let id: String
    let latitude: Double 
    let longitude: Double
}
</code></pre>
    <p class="normal">In the <code class="Code-In-Text--PACKT-">Place</code> type, we have three properties that represent the ID of the place and the latitude and longitude coordinates for its location. If there are two instances of the <code class="Code-In-Text--PACKT-">Place</code> type that have the same ID and coordinates, then they will be considered the same place.</p>
    <p class="normal">To implement the <code class="Code-In-Text--PACKT-">Equatable</code> protocol, we can create a global function; however, that is not the recommended solution for protocol-oriented programming. We could also add a static function to the <code class="Code-In-Text--PACKT-">Place</code> type itself, but sometimes it is better to pull the functionality needed to conform to a protocol out of the implementation itself. The following code will make the <code class="Code-In-Text--PACKT-">Place</code> type conform to the <code class="Code-In-Text--PACKT-">Equatable</code> protocol:</p>
    <pre class="programlisting code"><code class="hljs-code">extension Place: Equatable {
    static func ==(lhs: Place, rhs: Place) -&gt; Bool { 
        return lhs.id == rhs.id &amp;&amp;
            lhs.latitude == rhs.latitude &amp;&amp; 
            lhs.longitude == rhs.longitude
    }
}
</code></pre>
    <p class="normal">We can now compare the instances of the <code class="Code-In-Text--PACKT-">Place</code> type as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">var placeOne = Place(id: "Fenway Park", latitude: 42.3467, longitude: -71.0972)
var placeTwo = Place(id: "Wrigley Field", latitude: 41.9484, longitude: -87.6553)
print(placeOne == placeTwo)
</code></pre>
    <p class="normal">This will print <code class="Code-In-Text--PACKT-">false</code> because <code class="Code-In-Text--PACKT-">Fenway Park</code> and <code class="Code-In-Text--PACKT-">Wrigley Field</code> are two different baseball stadiums.</p>
    <p class="normal">You may be wondering why we said that it may be better to pull the functionality needed to conform to a protocol out of the implementation itself. Well, think about some of the <a id="_idIndexMarker711"/>larger types that you have created in the past. Personally speaking, I have seen types that had several hundred lines of code and conformed to numerous protocols. By pulling the code that is needed to conform to a protocol out of the type's implementation and putting it in its own extension, we are making our code much easier to read and maintain in the future because the implementation code is isolated in its own extension.</p>
    <p class="normal">Starting with Swift 5.2, if all of the properties conform to the <code class="Code-In-Text--PACKT-">Equatable</code> protocol and you want to compare all of the properties, as shown in the previous examples, we actually do not need to implement the <code class="Code-In-Text--PACKT-">==</code> function. All we really need to do is to implement the code as shown in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code">struct Place: Equatable {
    let id: String
    let latitude: Double 
    let longitude: Double
}
</code></pre>
    <p class="normal">In the previous code, Swift will add all of the boilerplate code to make the <code class="Code-In-Text--PACKT-">Place</code> structure conform to the <code class="Code-In-Text--PACKT-">Equatable</code> protocol for us; however, it is good to know how to implement <a id="_idIndexMarker712"/>this ourselves if all of the properties do not conform to the <code class="Code-In-Text--PACKT-">Equatable</code> protocol or we do not want to compare all of the properties.</p>
    <h1 id="_idParaDest-287" class="title">Summary</h1>
    <p class="normal">In this chapter, we looked at the differences between value types and reference types. We also looked at how to implement copy-on-write and the <code class="Code-In-Text--PACKT-">Equatable</code> protocol with our custom types. We can implement the copy-on-write feature with value types that become very large. We can implement the <code class="Code-In-Text--PACKT-">Equatable</code> protocol for any custom type, including reference types, when we need to compare two instances.</p>
    <p class="normal">While Swift takes care of managing the memory for us, it is still a good idea to understand how this memory management works so that we can avoid the pitfalls that may cause it to fail. In the next chapter, we will look at how memory management in Swift works and demonstrate how it can fail.</p>
  </div>
</body></html>