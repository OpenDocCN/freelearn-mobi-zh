- en: '*Chapter 3*: Conditionals and Optionals'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, you looked at data types, constants, variables, and operations.
    At this point, you are able to write simple programs that process letters and
    numbers. However, programs don't always proceed in sequence. Oftentimes, you will
    need to execute different instructions based on a condition. Swift allows you
    to do this by using **conditionals**, and you will learn how to use them in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing you may have noticed is that, in the last chapter, each variable
    or constant was immediately assigned a value. What if you require a variable where
    the value may not be present initially? You will need a way to create a variable
    that may or may not have a value. Swift allows you to do this by using **optionals**,
    and you will also learn about them in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to write programs that do different
    things based on different conditions, and to handle variables that may or may
    not have a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing conditionals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing optionals and optional binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Please spend some time understanding optionals. They can be daunting for the
    novice programmer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Xcode playground for this chapter is in the `Chapter03` folder of the code
    bundle for this book, which can be downloaded here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/iOS-15-Programming-for-Beginners-Sixth-Edition](https://github.com/PacktPublishing/iOS-15-Programming-for-Beginners-Sixth-Edition)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bit.ly/3woRRKq](https://bit.ly/3woRRKq)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new playground and name it `ConditionalsAndOptionals`. You can type
    in and run all the code in this chapter as you go along. You'll start by learning
    about conditionals.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing conditionals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At times, you''ll want to execute different code blocks based on a specific
    condition, such as in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing between different room types at a hotel. The price for bigger rooms
    would be higher.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switching between different payment methods at an online store. Different payment
    methods would have different procedures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deciding what to order at a fast-food restaurant. Preparation procedures for
    each food item would be different.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To do this, you would use conditionals. In Swift, this is implemented using
    the `if` statement (for a single condition) and the `switch` statement (for multiple
    conditions).
  prefs: []
  type: TYPE_NORMAL
- en: Important information
  prefs: []
  type: TYPE_NORMAL
- en: For more information on conditionals, visit [https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html](https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html).
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how `if` statements are used to execute different tasks depending
    on a condition's value in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using if statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An `if` statement executes a block of code if a condition is `true`, and optionally
    another block of code if the condition is `false`. An `if` statement looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's implement an `if` statement now to see this in action. Imagine that you're
    programming an app for a restaurant. The app would allow you to check if a restaurant
    is open, search for a restaurant, and check to see if a customer is over the drinking
    age limit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: To check if a restaurant is open, add the following code to your playground
    to create a constant and execute a statement if the constant's value is `true`.
    Click the `isRestaurantOpen`, and assigned `true` to it. Next, you have an `if`
    statement that checks the value stored in `isRestaurantOpen`. Since the value
    is `true`, the `print()` statement is executed and `Restaurant is open` is printed
    in the Debug area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try changing the value of `isRestaurantOpen` to `false` and run your code again.
    As the condition is now `false`, nothing will be printed to the Debug area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can also execute statements if a value is `false`. Let''s say the customer
    has searched for a particular restaurant which is not in the app''s database,
    so the app should display a message to say that the restaurant is not found. Type
    in the following code to create a constant and execute a statement if the constant''s
    value is `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The constant `isRestaurantFound` is set to `false`. Next, the `if` statement
    is checked. The `isRestaurantFound == false` condition returns `true`, and `Restaurant
    was not found` is printed in the Debug area.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Try changing the value of `isRestaurantFound` to `true`. As the condition is
    now `false`, nothing will be printed to the Debug area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To execute one set of statements if a condition is `true`, and another set
    of statements if a condition is `false`, use the `else` keyword. Type in the following
    code, which checks if a customer at a bar is over the drinking age limit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `drinkingAgeLimit` is assigned the value `21` and `customerAge` is assigned
    the value `23`. In the `if` statement, `customerAge < drinkingAgeLimit` is checked.
    Since 23 < 21 returns `false`, the `else` statement is executed and `Over age
    limit` is printed in the Debug area. If you change the value of `customerAge`
    to `19`, `customerAge < drinkingAgeLimit` will return `true`, so `Under age limit`
    will be printed in the Debug area.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Up to now, you have only been dealing with single conditions. What if there
    are multiple conditions? That's where `switch` statements come in, and you will
    learn about them in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using switch statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand `switch` statements, let''s start by implementing an `if` statement
    with multiple conditions first. Imagine that you''re programming a traffic light.
    There are three possible conditions for the traffic light—red, yellow, or green—and
    you want something different to happen based on the color of the light. To do
    this, you can chain multiple `if` statements together. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the following code to your playground to implement a traffic light using
    multiple `if` statements and click the `if` condition, `trafficLightColor == "Red"`,
    returns `false`, so the `else` statement is executed. The second `if` condition,
    `trafficLightColor == "Yellow"`, returns `true`, so `Caution` is printed in the
    Debug area and no more `if` conditions are evaluated. Try changing the value of
    `trafficLightColor` to see different results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code used here works, but it''s a little hard to read. In this case, a
    `switch` statement would be more concise and easier to comprehend. A `switch`
    statement looks like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The value is checked and matched to a case, and code for that case is executed.
    If none of the cases match, the code in the `default` case is executed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here''s how to write the `if` statement shown earlier as a `switch` statement.
    Type in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code here is much easier to read and understand when compared to the previous
    version. The value in `trafficLightColor` is `"Yellow"`, so `case "Yellow":` is
    matched and `Caution` is printed in the Debug area. Try changing the value of
    `trafficLightColor` to see different results.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two things to remember about `switch` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`switch` statements in Swift do not fall through the bottom of each case and
    into the next one by default. In the example shown previously, once `case "Red":`
    is matched, `case "Yellow":`, `case "Green":` , and `default:` will not execute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`switch` statements must cover all possible cases. In the example shown previously,
    any `trafficLightColor` value other than `"Red"`, `"Yellow"`, or `"Green"` will
    be matched to `default:` and `Invalid color` will be printed in the Debug area.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This concludes the section on `if` and `switch` statements.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you'll learn about optionals, which allow you to create
    variables without initial values, and **optional binding**, which allows instructions
    to be executed if an optional has a value.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing optionals and optional binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, every time you declared a variable or constant, you assigned a
    value to it immediately. But what if you want to declare a variable first and
    assign a value later? In this case, you would use optionals.
  prefs: []
  type: TYPE_NORMAL
- en: Important information
  prefs: []
  type: TYPE_NORMAL
- en: For more information on optionals, visit [https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html](https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html).
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn how to create and use optionals, and see how they are used in a
    program. Imagine you're writing a program where the user needs to enter the name
    of their spouse. Of course, if the user is not married, there would be no value
    for this. In this case, you can use an optional to represent the spouse's name.
  prefs: []
  type: TYPE_NORMAL
- en: 'An optional may have one of two possible states. It can either contain a value,
    or not contain a value. If an optional contains a value, you can access the value
    inside it. The process of accessing an optional''s value is known as unwrapping
    the optional. Let''s see how this works. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground to create a variable and print its
    contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click the Play/Stop button to run it. Since Swift is type-safe, it will display
    an error, **Variable 'spouseName' used before being initialized**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To resolve this issue, you could assign an empty string to `spouseName`. Modify
    your code as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since `spouseName` should not have a value initially, let''s make it an optional.
    To do so, type a question mark after the type annotation and remove the empty
    string assignment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The warning appears because the `print` statement is treating `spouseName`
    as being of type `Any` instead of `String?`. Click the yellow triangle to display
    possible fixes, and choose the first fix:![Figure 3.2: Expanded warning notification
    with the first fix selected'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.2_B17469.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.2: Expanded warning notification with the first fix selected'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The statement will change to `print(spouseName ?? default value)`. Note the
    use of the `??` operator. This assigns `default value` to `spouseName` if it does
    not contain a value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Replace the `default value` placeholder with `"No value in spouseName"` as
    shown. The warning will disappear. Run your program again and `"No value in spouseName"`
    will appear in the Results area:![Figure 3.3: Results area showing default value'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.3_B17469.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.3: Results area showing default value'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s assign a value to `spouseName`. Modify the code as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add one more line of code to join `spouseName` to another string as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Click on the red circle to display possible fixes, and you''ll see the following:![Figure
    3.4: Expanded error notification'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.4_B17469.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.4: Expanded error notification'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The second fix recommends `spouseName` has a value, but if `spouseName` is `nil`,
    your program will crash.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Click the second fix, and you''ll see an exclamation mark appear after `spouseName`
    in the last line of code, which indicates the optional is force-unwrapped:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When your program runs, `Hello, Nia` is assigned to `greeting`, as shown in
    the Results area. This means that `spouseName` has been successfully unwrapped.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To see the effect of force-unwrapping a variable containing `nil`, set `spouseName`
    to `nil`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To see the effect of optional binding, modify your code as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To see the effect of optional binding when an optional contains `nil`, assign
    `nil` once more to `spouseName`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This concludes the section on optionals and optional binding, and you can now
    create and use optional variables. Awesome!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You're doing great! You learned how to use `if` and `switch` statements, which
    means you are now able to write your own programs that do different things based
    on different conditions.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned about optionals and optional binding. This means you can now
    represent variables that may or may not have a value, and execute instructions
    only if a variable's value is present.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will study how to use a range of values instead of
    single values, and how to repeat program statements using loops.
  prefs: []
  type: TYPE_NORMAL
