<html><head></head><body><h1 id="e-clCK">Chapter 10. Adding the Camera App Integration</h1>
<p id="e-cpiW">Another exciting feature of mobile computing is that most Android devices have some types of camera that can be used to capture photos and/or videos. This chapter will walk you through the steps required to add the ability to capture and upload a picture of a POI and will include the following topics:</p>
<ul id="e-gbdV">
<li id="e-LXFO">Approaches to integrate with a device camera</li>
<li id="e-V29F">Camera permissions and features</li>
<li id="e-u21l">Capturing and displaying a photo</li>
<li id="e-pebu">Uploading an image using an HTTP multipart form upload</li>
</ul>
<h1 id="e-ENgJ">Picking an integration approach</h1>
<p id="e-yzI0">The Android platform provides two different ways to integrate a device's camera feature to your app:</p>
<ul id="e-yoww">
<li id="e-rFGd">Using existing camera apps to integrate using the <code>Intent</code> method</li>
<li id="e-jG58">Creating your own custom activity that interacts directly with the camera using the Android API</li>
</ul>
<p id="e-NFYM">The second approach allows a high degree of control over how the camera view is presented to the user, and how the user interacts with the view. However, the first approach is very straightforward to implement as it reuses the existing device camera apps to capture the picture. We will go with the <code>Intent</code> method as it represents a very practical way to add camera integration.</p>

<h1 id="e-lwBs">Permissions and features</h1>
<p id="e-J4Tl">Before getting into the details of integrating the device camera feature, we will discuss more about the general permissions and features related to the camera in more depth. The following table contains the various permissions that may be required. In our case, we need not specify any of these because we are using the <code>Intent</code> method, where the external camera app will capture the picture for us. The external camera app needs to specify the required camera permissions:</p>
<p id="e-zjZ4">Permission</p>
<p id="e-SwZT">Description</p>
<p id="e-EQS3"><code>CAMERA</code></p>
<p id="e-nWoS">This is required for apps that request permission to use the device's camera; this is not required if you make use of the <code>Intent</code> method</p>
<p id="e-cTsO"><code>WRITE_EXTERNAL_STORAGE</code></p>
<p id="e-AiD4">This permission is required to save images or videos to the device's external storage (SD card)</p>
<p id="e-Q1MH"><code>RECORD_AUDIO</code></p>
<p id="e-Fdaj">If your app records audio with video capture</p>
<p id="e-cqeN">Camera-specific features can be set up in an app's manifest file using the <code>&amp;lt;uses-feature&amp;gt;</code> element. The <code>&amp;lt;uses-feature&amp;gt;</code> declaration is used to inform about the set of hardware and software features on which your application depends. You may specify the <code>required=true</code> to declare that your application cannot function without the declared feature. The feature declaration is used for information purpose only. There is no validation done by the Android system before installing the app.</p>
<p id="e-dvML">The following table depicts the set of features you may define in your application manifest declaration:</p>
<p id="e-T2RS">Feature</p>
<p id="e-sbrY">Description</p>
<p id="e-D7Ru"><code>android.hardware.camera</code></p>
<p id="e-U0eU">The application uses the device's camera. If the device supports multiple cameras, the application uses the camera that faces away from the screen.</p>
<p id="e-A8Ln"><code>android.hardware.camera.autofocus</code></p>
<p id="e-HaG1">Subfeature. The application uses the device camera's autofocus capability.</p>
<p id="e-ra9c"><code>android.hardware.camera.flash</code></p>
<p id="e-XuW4">Subfeature. The application uses the device camera's flash.</p>
<p id="e-mjly"><code>android.hardware.camera.front</code></p>
<p id="e-vPr0">Subfeature. The application uses a front-facing camera on the device.</p>
<p id="e-HvdW"><code>android.hardware.camera.any</code></p>
<p id="e-dYNu">The application uses at least one camera, which can face in any direction. Use this in preference to <code>android.hardware.camera</code> if a back-facing camera is not required.</p>
<p id="e-lLZ0">In our case, we will not specify any features as requirements, but at runtime, we will check whether an external app is available to capture a photo.</p>

<h1 id="e-XdQX">Configuring the emulator</h1>
<p id="e-wwK6">If you are using the emulator for development, you will need to configure it to have a camera. If the computer you are using has a webcam, the emulator can use it as the camera; otherwise, you can choose to have an emulated camera.</p>
<p id="e-pMT4">To configure the emulator for a camera, perform the following steps:</p>
<ol id="e-Qftl">
<li id="e-zRam">From the main menu, navigate to <strong>Tools</strong> and open <strong>Android Emulator Manager</strong>.</li>
<li id="e-Gaxg">Select the emulator you have been working with and choose <strong>Edit</strong>.</li>
<li id="e-pZui">In the middle of the Edit AVD dialog, you will see two dropdowns; one for <strong>Front Camera</strong> and one for <strong>Back Camera</strong>. Make your selections and click on <strong>OK</strong>:<img data-width="521" data-height="603" src="img/aJ42xZHe.jpg"/>
</li>
</ol>

<h1 id="e-Ccpz">Extending the data service</h1>
<p id="e-ljFy">Since we have decided to use an external camera app to capture the picture, it will take care of saving the picture after it has been captured. We will have to provide the storage path where the image will be saved. To save the POI images, we will use a naming scheme such as <code>poiimage&amp;lt;poi id&amp;gt;.jpg</code>.</p>
<p id="e-TvUA">Let's now extend the <code>POIService</code> class with the following additional methods.</p>
<h2 id="e-WqeF">Implementing GetFileName()</h2>
<p id="e-chd2">Let's implement the <code>GetFileName()</code> method in <code>POIService.cs</code> that will take care of providing the absolute path for saving the images in device memory. The absolute path includes the location and the filename. The image files will be named as <code>poiimage&amp;lt;poi id&amp;gt;.jpg</code>. The following listing shows how the filename can be constructed:</p>
<pre id="e-hRKo">public static string GetFileName (int poiId)
{
  String storagePath = System.IO.Path.Combine (Android.OS.Environment.ExternalStorageDirectory.Path, "POIApp");
  String path = System.IO.Path.Combine (storagePath, "poiimage" + poiId + ".jpg");
  return path;
}</pre>
<h2 id="e-RgUp">Implementing GetImage()</h2>
<p id="e-obaP">As discussed in the previous sections, the saving of an image can be done by the camera intent. However, we need to write two helper methods to read and delete the image from device storage.</p>
<p id="e-g1Nk">Let's add the <code>GetImage()</code> helper method that will be used to read the POI image from the device memory location, where it was saved earlier. Add the following listing to the <code>POIService.cs</code> class:</p>
<pre id="e-YzOm">public static Bitmap GetImage(int poiId)
{
  string filename = GetFileName (poiId);
  if (File.Exists (filename)) {
    Java.IO.File imageFile = new Java.IO.File (filename);
    return BitmapFactory.DecodeFile (imageFile.Path);
  }
  return null;
}</pre>
<h2 id="e-Psli">Implementing DeleteImage()</h2>
<p id="e-JGjP">After a user deletes the <code>poi</code> object by clicking on the delete action bar button, currently the POI will be deleted from the server. It is a good idea to delete the corresponding POI image from device memory once the delete from the server side is successful.</p>
<p id="e-pc9y">The following helper method is used to delete the image based on its POI ID:</p>
<pre id="e-EFC3">public void DeleteImage (int poiId)
{
  String filePath = GetFileName (poiId);
  if (File.Exists (filePath)) {
    File.Delete (filePath);
  }
}</pre>
<p id="e-V4HB">In this chapter, we are not dealing with the delete POI; however, to incorporate the changes as described earlier, you need to call the <code>DeleteImage()</code> method in <code>DeletePOIAsync()</code>:</p>
<pre id="e-q6Zu">....
if (response != null || response.IsSuccessStatusCode){
  DeleteImage (poi.Id.Value);
string content = await response.Content.ReadAsStringAsync();
  return content; 
}
....</pre>

<h1 id="e-tWVF">Capturing an image from POIDetailFragment</h1>
<p id="e-mg9Z">We are now ready to take on the task of capturing a photo. This will involve the following tasks:</p>
<ul id="e-g6yR">
<li id="e-MXkv">Adding new user interface widgets to initiate capturing a photo and displaying it</li>
<li id="e-E2gC">Building a photo intent to navigate to an external camera app to capture a photo</li>
<li id="e-PxEo">Processing the results of the photo intent and displaying a photo once it is successfully captured</li>
</ul>
<p id="e-tNbr">The following sections describe the details of each step.</p>
<h2 id="e-kge7">Adding UI elements</h2>
<p id="e-bmI4">There are a few new UI elements that we will need to add to support capturing an image; we need an <code>ImageButton</code> element to initiate the process of capturing an image, and we also need an <code>ImageView</code> element to display the captured POI image. The <code>ImageButton</code> widget can be added adjacent to the location and map buttons, and the <code>ImageView</code> element can be placed as the first widget above the <strong>Name</strong> field.</p>
<p id="e-MJgC">The following list shows the definition of the <code>ImageView</code>, which should be placed inside the <code>LinearLayout</code> before the POI name text field:</p>
<pre id="e-AREv">&amp;lt;LinearLayout
    --- &amp;gt;
    &amp;lt;ImageView
        p1:src="img/ic_placeholder"
        p1:layout_width="wrap_content"
        p1:layout_height="200dp"
        p1:id="@+id/poiImageView"
        p1:layout_gravity="center_horizontal"
        p1:scaleType="centerCrop"
        p1:layout_marginBottom="10dp" /&amp;gt;
    &amp;lt;TextView
        p1:text="Name"
        p1:layout_width="fill_parent"
        p1:layout_height="wrap_content"
        p1:id="@+id/textView10" /&amp;gt;
         ---
&amp;lt;/LinearLayout&amp;gt;</pre>
<p id="e-gyTa">Create a private reference object in <code>POIDetailFragment</code> and assign the reference in <code>OnCreateView()</code>:</p>
<pre id="e-Ez7L">ImageView _poiImageView;
   ...
_poiImageView = view.FindViewById&amp;lt;ImageView&amp;gt; (Resource.Id.poiImageView);</pre>
<p id="e-Y5Ss">Now, we need a button that initiates the camera. We will start by copying the <code>ic_new_picture.png</code> icon from the <code>assets</code> folder to the project's <code>drawable</code> folder and adding it to the project in the same manner, as we did in the previous chapters.</p>
<p id="e-OFSQ">Add the following button definition to the <code>LinearLayout</code> that contains the other two buttons:</p>
<pre id="e-s44G">&amp;lt;ImageButton
    android:src="img/ic_new_picture"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:id="@+id/photoImageButton" /&amp;gt;</pre>
<p id="e-vWp5">The output of the preceding layout changes should look like the following screenshot:</p>
<img data-width="316" data-height="182" src="img/qvGeG67L.jpg"/><p id="e-mjIe">Create a private reference object in <code>POIDetailFragment</code> and assign the reference in <code>OnCreateView()</code> as follows:</p>
<pre id="e-lDje">ImageButton _photoImageButton;
   ...
   _photoImageButton = view.FindViewById&amp;lt;ImageButton&amp;gt; (
     Resource.Id.photoImageButton);
   _photoImageButton.Click += NewPhotoClicked;</pre>
<p id="e-mpeP">Notice that in the preceding code snippets, we are assigning the <code>NewPhotoClicked()</code> event listener to the <code>photoImageButton</code> button. We will complete the <code>NewPhotoClicked()</code> method implementation in the following sections in this chapter.</p>
<h2 id="e-wOR3">Creating the camera Intent</h2>
<p id="e-PXhC">To start an external camera app to capture a photo, we rely on the <code>Intent</code> class again, this time combined with an action. The following listing depicts creating an <code>Intent</code> class with the image capture action:</p>
<pre id="e-kWHh">Intent cameraIntent = new Intent(MediaStore.ActionImageCapture);</pre>
<p id="e-r8Ao">The <code>MediaStore</code> class contains the metadata for all the available media on both internal and external storage devices. The <code>MediaStore.ActionImageCapture</code> action tells the Android platform that you want to capture a photo and are willing to use any existing app that provides these capabilities.</p>
<h2 id="e-qFyL">Checking for registered camera apps</h2>
<p id="e-Rpbe">In Chapter 9, <em>Making POIApp Location Aware</em>, we used <code>PackageManager</code> to check whether there is a map app installed to handle our intent. We now need to perform the same check for an app that can handle our <code>ActionImageCapture</code> intent. The following listing shows the logic we need:</p>
<pre id="e-xpOg">PackageManager packageManager = PackageManager;
IList&amp;lt;ResolveInfo&amp;gt; activities = packageManager.QueryIntentActivities(cameraIntent, 0);
if (activities.Count == 0) {
  //display alert indicating there are no camera apps
}
else {
  //launch the camera Intent
}</pre>
<h2 id="e-Qrvv">Providing additional information with the Intent</h2>
<p id="e-K4Be">Before we start the intent, we need to provide some information to the camera app that processes our request; specifically, a filename and location, and the maximum size of the resulting photo. You must be careful about providing the value of the maximum size; this can be a potential threat that can cause out of memory exceptions. We do this by adding <code>Extras</code> to the intent. The <code>MediaStore</code> class defines a number of standard <code>Extras</code> that can be added to an intent to control how an external app fulfils the intent.</p>
<h3 id="e-Bww0">Providing a filename and location</h3>
<p id="e-PXqJ">The <code>MediaStore.ExtraOutput</code> extra can be used to control the filename and location that the external camera app should use in order to capture an image. We previously added the <code>GetFileName()</code> method in the <code>POIService</code> class to provide the file path information. However, the camera app expects the file path as an instance of <code>Android.Net.Uri</code>; and hence, we will need to convert the string path to an instance of <code>Android.Net.Uri</code>.</p>
<p id="e-CBic">This is a two-step process. First, we create a <code>Java.IO.File</code> object using the string path from the data service and then create an <code>Android.Net.Uri</code> object. The following listing shows how to accomplish the construction of the URI and set up the <code>MediaStore.ExtraOutput</code> extra:</p>
<pre id="e-Q0nz">Java.IO.File imageFile = new Java.IO.File(POIData.Service.GetFilename(_poi.Id.Value));
Android.Net.Uri imageUri = Android.Net.Uri.FromFile (imageFile);
cameraIntent.PutExtra (MediaStore.ExtraOutput, imageUri);</pre>
<h3 id="e-Zbo3">Providing a size limit</h3>
<p id="e-H30J">The <code>MediaStore.ExtraSizeLimit</code> extra limits the image size. It is much more straightforward to set up as shown here:</p>
<pre id="e-RM3O">cameraIntent.PutExtra (MediaStore.ExtraSizeLimit, 1.5 * 1024);</pre>
<h2 id="e-uyrh">Starting the Intent</h2>
<p id="e-XVGv">We are now ready to invoke the camera app by starting the intent by calling the <code>StartActivity()</code> method. Unlike the map app, in the case of a camera intent, we expect the results back from the activity. We are expecting the camera app to provide either a photo or a notification that the user cancelled to capture the photo. This can be accomplished by calling <code>StartActivityForResult()</code> by passing in the intent. The <code>StartActivityForResults()</code> method works in conjunction with an <code>OnActivityResult()</code> activity callback to communicate the results of the intent.</p>
<p id="e-nDkH">The following listing depicts the calling of <code>StartActivityForResult()</code>:</p>
<pre id="e-aKk0">const int CAPTURE_PHOTO = 0;
.. .
StartActivityForResult(cameraIntent, CAPTURE_PHOTO);</pre>
<p id="e-KeG9">Notice the second parameter of <code>StartActivityForResult()</code>. It is an integer value named <code>requestCode</code> that will be returned as a parameter to <code>OnActivityResult()</code> in the callback and help you identify the original reason for launching an intent. The best practice is to define a constant value to pass in for each <code>requestCode</code> that could potentially cause <code>OnActivityResult()</code> to be called.</p>
<p id="e-lY5Z">Note that when we call the <code>StartActivityForResult()</code> method from the fragment, the result will always be returned to the <code>OnActivityResult()</code> method of the activity that hosts <code>POIDetailsFragment</code>. However, in this case, we are looking for the results in <code>POIDetailsFragment</code> itself. For this, we need to override the <code>OnActivityResult()</code> method in all of the hosting activities, and call <code>base.OnActivityResult</code> to fire the callback to the <code>OnActivityResult()</code> method declared on the fragment.</p>
<h2 id="e-Boyg">Completing the NewPhotoClicked() method</h2>
<p id="e-MZ1S">We have covered a number of topics related to starting the camera app in a somewhat fragmented fashion. The following listing is the complete implementation of <code>NewPhotoClicked()</code>:</p>
<pre id="e-KN66">int CAPTURE_PHOTO = 100;
void NewPhotoClicked (object sender, EventArgs e)
{
  if (_poi.Id &amp;lt;= 0){
  Toast.MakeText (activity, "You must save the POI before attaching a photo.", ToastLength.Short).Show ();
  return;
  }
   Intent cameraIntent = new Intent (MediaStore.ActionImageCapture);
  PackageManager packageManager = Activity.PackageManager;
  IList&amp;lt;ResolveInfo&amp;gt; activities = packageManager.QueryIntentActivities (cameraIntent, 0);
  if (activities.Count == 0) {
    Toast.MakeText (activity, "No camera app available.", ToastLength.Short).Show ();
  } else {
    string path = POIService.GetFileName (_poi.Id);
    Java.IO.File imageFile = new Java.IO.File (path);
    Android.Net.Uri imageUri = Android.Net.Uri.FromFile (imageFile);
    cameraIntent.PutExtra (MediaStore.ExtraOutput, imageUri);
    cameraIntent.PutExtra (MediaStore.ExtraSizeLimit, 1 * 1024 * 1024);
    StartActivityForResult (cameraIntent, CAPTURE_PHOTO);
  }
}</pre>
<h2 id="e-AMQX">Processing the results of the Intent</h2>
<p id="e-i8IS">The initiating activity is notified of the results of an intent via the <code>OnActivityResult()</code> callback method. Let's add the following callback to both <code>POIListActivity</code> and <code>POIDetailActivity</code> to trigger the callback back to <code>POIDetailFragment</code>:</p>
<pre id="e-lhfo">protected override void OnActivityResult (int requestCode, Result resultCode, Intent data)
{
  base.OnActivityResult (requestCode, resultCode, data);
}</pre>
<p id="e-WxGy">Now, let's override the <code>OnActivityResult</code> method in the <code>POIDetailFragment</code> class. The following listing shows the signature of the <code>OnActivityResult()</code> method:</p>
<pre id="e-EgCK">public override void OnActivityResult (int requestCode, Result resultCode, Intent data)</pre>
<p id="e-DV5y">We discussed <code>requestCode</code> in the previous section. The <code>resultCode</code> parameter indicates the result of the intent that was launched and is of type <strong>Result</strong>, which can have the following values:</p>
<p id="e-t3f7">Value</p>
<p id="e-Uxrv">Meaning</p>
<p id="e-pLR9"><code>RESULT_OK</code></p>
<p id="e-ihnf">The activity completed the request successfully</p>
<p id="e-egb6"><code>REQUEST_CANCELED</code></p>
<p id="e-xiEA">The activity was canceled, generally, by a user action</p>
<p id="e-iW88"><code>REQUEST_FIRST_USER</code></p>
<p id="e-jVuL">The first value that can be used for a custom meaning</p>
<p id="e-f5Ch">The third parameter, <code>data</code>, is of type <code>Intent</code> and can be used to pass additional information back from the activity that was launched. In our case, we are only concerned with <code>requestCode</code> and <code>resultCode</code>. The following listing shows the implementation of <code>OnActivityResult()</code> in <code>POIDetailFragment</code>:</p>
<pre id="e-y1ne">public override void OnActivityResult (int requestCode, Result resultCode, Intent data)
{
  if (requestCode == CAPTURE_PHOTO) {
    if (resultCode == Result.Ok) {
      Bitmap bitmap = POIService.GetImage (_poi.Id.Value);
      _poiImageView.SetImageBitmap (bitmap);
      if (bitmap != null) {
        bitmap.Dispose ();
        bitmap = null;
      }
    } else {
    Toast.MakeText (Activity, "No picture captured.", ToastLength.Short).show();
    }
  } else {
    base.OnActivityResult (requestCode, resultCode, data);
  }
}</pre>
<p id="e-MAzk">Notice that when <code>resultCode</code> is <code>RESULT_OK</code>, we load the photo that was captured into a Bitmap object and then set the image for <code>_poiImageView</code>. This causes the image to be displayed at the top of the <code>POIDetailFragment</code> layout. If <code>resultCode</code> is not <code>RESULT_OK</code>, we display a toast message to the user, indicating that the action was canceled.</p>
<p id="e-B2PX">We are making use of <code>GetImage()</code> in <code>POIService</code> to retrieve the image from the memory. It is a simple utility method that accepts a POI ID and loads <code>Android.Graphics.Bitmap</code> using the Android utility class <code>BitmapFactory</code>.</p>
<p id="e-PQx5">So far, we have added a lot of code. Run <code>POIApp</code>, and from the <code>POIDetails</code> page, click on the add image button to invoke the camera. Notice that the captured image will be displayed on the <code>POIDetails</code> screen.</p>

<h1 id="e-zrHs">Upload an image using an HTTP multipart</h1>
<p id="e-Ezyj">The last functionality we are left to incorporate in the <code>POIApp</code> sample application is to upload the captured POI image to the server. Currently, we are saving only the POI details on Cloud, and the POI images are stored locally on the user's device memory. It would be nice to upload the image to the server so that we don't lose the images when a user deletes them locally from a device.</p>
<p id="e-yH6o">If the user has captured the photo of the POI and it is available locally on the device memory, then the save action will post the image along with the data using multipart form upload. Otherwise, it will post just the POI JSON data for the save operation.</p>
<p id="e-mW3i">Before we create a multipart form data request, let's first understand the web service API specification. The following block describes the web service API requirements for a multipart form upload:</p>
<pre id="e-PRTm">Endpoint: com.packt.poiapp/api/poi/upload
Request-Type: multipart/form-data POST
    -----BOUNDARY
    Content-Disposition: form-data; name="file"; filename="poiimage1.jpg"
  Content-Type: application/octet-stream
/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL===
  -----BOUNDARY
   -----BOUNDARY
  Content-Disposition: form-data; name="poi"; 
  Content type = application/json, Encoding:UTF8
  Body= {"id":"1","latitude":"51.5033","longitude":"0.1197","name":"London Eye","description":"...","image":""}
  -----BOUNDARY</pre>
<p id="e-uWGd">Notice that the preceding API specification uses the <code>multipart/form-data</code> encoding type. Earlier in this book, for uploading the POI JSON object we used the HTTP <code>POST</code> method, but now we need to send the POI data along with the Bitmap stream, which cannot be uploaded with the <code>POST</code> method. We need to use <code>multipart/form-data</code> encoding type through which we can attach an image, along with several other message contents.</p>
<p id="e-yfHM">A standard delimiter called <code>boundary</code> separates each part of a multipart message. Each part of the message can define its own standard headers, such as <code>Content-Type</code> and <code>Content-Disposition</code>, providing the name of the file whose value it contains. The multipart delimiters and header fields are always 7-bit ASCII, in any case. The content of the image is present right below the <code>Content-Type</code> header, followed by the value of the POI JSON string.</p>
<p id="e-x611">For more detailed information on multipart <code>Content-Type</code>, search for <strong>RFC 1341(MIME)</strong> and visit <a href="http://www.w3.org/Protocols/rfc1341/7_2_Multipart.html">http://www.w3.org/Protocols/rfc1341/7_2_Multipart.html</a>.</p>
<p id="e-XFCf">Now that we understand the API specification to upload the image along with the POI data, let's proceed with the implementation:</p>
<ol id="e-KLxZ">
<li id="e-tQba">Create an overloaded method for <code>CreateOrUpdatePOIAsync()</code> in the <code>POIService</code> class that takes two arguments: object of <code>PointOfInterest</code>, and the POI image <code>bitmap</code>:<pre id="e-PKzF">public async Task&amp;lt;String&amp;gt; CreateOrUpdatePOIAsync(PointOfInterest poi, Bitmap bitmap)
{
...
}</pre>
</li>
<li id="e-YkIy">Add the following snippets to convert the POI object to a JSON object and then to <code>StringContent</code>. I don't need to give you an explanation as we have already done a similar thing while posting the POI data:<pre id="e-ft6c">var settings = new JsonSerializerSettings ();
settings.ContractResolver = new POIContractResolver ();
var poiJson = JsonConvert.SerializeObject (poi, Formatting.None, settings);
var stringContent = new StringContent(poiJson);</pre>
</li>
<li id="e-qxkp">Now convert the Bitmap image to a byte array in order to send it as <code>ByteArrayContent</code> via the multipart form upload:<pre id="e-Cl8d">byte[] bitmapData;
var stream = new MemoryStream();
bitmap.Compress(Bitmap.CompressFormat.Jpeg, 0, stream);
bitmapData = stream.ToArray();
var fileContent = new ByteArrayContent(bitmapData);</pre>
<p id="e-PieC">Notice that the <code>bitmap.Compress()</code> writes a compressed version of the Bitmap to the specified stream. The second integer argument indicates the compression quality ranging from <code>0</code> to <code>100</code>, where <code>0</code> means low quality and <code>100</code> being the maximum (lowest quality).</p>
</li>
<li id="e-hQKw">Add the following additional content headers such as media content type and content disposition. The POI image name is sent in the <code>poiimage&amp;lt;poid&amp;gt;.jpg</code> format. The server that saves the image in the database will use this name:<pre id="e-yEEl">fileContent.Headers.ContentType = 
MediaTypeHeaderValue.Parse ("application/octet-stream");
fileContent.Headers.ContentDisposition = new ContentDispositionHeaderValue("form-data")
{
    Name = "file",
    FileName = "poiimage" + poi.Id.ToString () + ".jpg"
};</pre>
</li>
<li id="e-evtS">Now that we are ready with both the POI data and and image content, we can add both the chunks to the <code>MultipartFormDataContent</code>. The <code>boundary</code> is a random string used as a delimiter to separate each part of the message body:<pre id="e-NhR6">string boundary = "---8d0f01e6b3b5daf";
MultipartFormDataContent multipartContent= new MultipartFormDataContent (boundary);
multipartContent.Add (fileContent);
multipartContent.Add(stringContent, "poi");</pre>
</li>
<li id="e-J7PT">Declare a string constant that represents the web service endpoint to upload the POI image using multipart:<pre id="e-IqHX">private const string UPLOAD_POI = "http://YOUR_IP:8080/com.packt.poiapp/api/poi/upload";</pre>
</li>
<li id="e-N4Mi">Let's now proceed to upload the form content to the server using the <code>HttpClient</code> class in the <code>PostAsync()</code> method. The following code snippet demonstrates posting data to the server using the <code>HttpClient</code> class:<pre id="e-mhfP">HttpClient httpClient = new HttpClient ();
HttpResponseMessage response = await httpClient.PostAsync (UPLOAD_POI, multipartContent);
if (response.IsSuccessStatusCode) {
    string content = await response.Content.ReadAsStringAsync();
    return content;
}
return null;</pre>
</li>
</ol>
<p id="e-GES0">The result of the upload request is sent back to the <code>POIDetailFragment</code>.</p>
<p id="e-G8MT">Now that we have the method ready to upload the image along with the POI JSON data, let's change the logic in the <code>POIDetailFragment</code> class in the <code>SavePOI()</code> method. Currently, the save action validates the user input and calls <code>CreateOrUpdatePOIAsync()</code> by passing the POI object.</p>
<p id="e-eTWy">Now if the user has captured the POI image using the camera, let's instead call the newly created overridden version of <code>CreateOrUpdatePOIAsync()</code> by passing the Bitmap, POI, and activity instance. Add the following logic to the <code>SavePOI()</code> method:</p>
<pre id="e-CEie">POIService service = new POIService ();
Bitmap bitmap = null;
if (_poi.Id&amp;gt;0) {
  bitmap = POIService.GetImage (_poi.Id);  
}
 string response;
if (bitmap != null) {
  response = service.CreateOrUpdatePOIAsync (_poi, bitmap);
} else {
  response = service.CreateOrUpdatePOIAsync (_poi);
}</pre>
<p id="e-kPl2">To make our application memory efficient, it is a good idea to dispose the Bitmap instance after you're done with it. Add the following code to dispose the Bitmap memory:</p>
<pre id="e-lLzN">if (bitmap != null) {
  bitmap.Dispose ();
  bitmap = null;
}</pre>
<p id="e-Ao6k">We have now completed the <code>POIApp</code> app that exercises many of the Xamarin.Android features you will need to utilize for developing a professional app. While the app is relatively simple in nature, we hope that it provides a good starter guide for the Android app development. I wish you good luck with the Xamain.Android development! Happy coding!</p>

<h1 id="e-yzUB">Summary</h1>
<p id="e-Csy9">In this chapter, we completed <code>POIApp</code> by adding integration with the camera. We now have an app that demonstrates many of the features of the Android platform.</p>
<p id="e-Dfr0">In the last chapter, we will discuss the various app distribution channels and steps to prepare your application for deployment.</p>
</body></html>