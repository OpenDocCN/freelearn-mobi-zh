- en: '*Chapter 8*: Implementing an MVVM Architecture'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*: 实现MVVM架构'
- en: In this chapter, we will look at how data can be presented by Android applications
    to end users. We will look over the available architecture patterns for data presentation
    and analyze the differences between them. Later, we will look at the **Model-View-ViewModel
    (MVVM)** pattern, the role it plays in separating business logic and user interface
    updates, and how we can implement it using **Android Architecture Components**.
    Finally, we will look at how we can split the presentation layer across multiple
    library modules. In the exercises of this chapter, we will integrate the layers
    built in the previous chapters with a presentation layer built using MVVM, we
    will create a presentation layer that will plug into the domain layer to fetch
    and update the data, and we will also look at how we handle common logic between
    different modules in the presentation layer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Android应用程序如何向最终用户展示数据。我们将回顾可用于数据展示的架构模式，并分析它们之间的差异。稍后，我们将探讨**模型-视图-视图模型（MVVM）**模式，它在分离业务逻辑和用户界面更新中所起的作用，以及我们如何使用**Android架构组件**来实现它。最后，我们将探讨如何将表示层拆分到多个库模块中。在本章的练习中，我们将整合前几章中构建的层与使用MVVM构建的表示层，我们将创建一个将插入到领域层以获取和更新数据的表示层，并且我们还将探讨如何在表示层的不同模块之间处理常见的逻辑。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Presenting data in Android applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android应用程序中展示数据
- en: Presenting data with MVVM
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MVVM展示数据
- en: Presenting data in multiple modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个模块中展示数据
- en: By the end of the chapter, you will be able to implement the MVVM architecture
    pattern in an Android application using the ViewModel architecture component and
    be able to split the presentation layer into separate library modules.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用ViewModel架构组件在Android应用程序中实现MVVM架构模式，并且能够将表示层拆分为独立的库模块。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter has the following hardware and software requirements:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有以下硬件和软件要求：
- en: Android Studio Arctic Fox 2020.3.1 Patch 3
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android Studio Arctic Fox 2020.3.1 Patch 3
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter8](https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter8).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下位置找到：[https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter8](https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter8)。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3FZJWIl](https://bit.ly/3FZJWIl)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际运行情况：[https://bit.ly/3FZJWIl](https://bit.ly/3FZJWIl)
- en: Presenting data in Android applications
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Android应用程序中展示数据
- en: In this section, we will look at various architecture patterns suitable for
    presenting data in an Android application and analyze their benefits and drawbacks.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨适用于在Android应用程序中展示数据的各种架构模式，并分析它们的优缺点。
- en: 'Early Android applications relied on a pattern similar to the `android.widget.View`
    hierarchy, and the Model is responsible for managing the application''s data.
    The relationship between the components would look something like the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的Android应用程序依赖于类似于`android.widget.View`层次结构的模式，模型负责管理应用程序的数据。组件之间的关系看起来可能如下：
- en: '![Figure 8.1 – Android MVC relationship'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1 – Android MVC关系图'
- en: '](img/Figure_8.01_B18320.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.01_B18320.jpg](img/Figure_8.01_B18320.jpg)'
- en: Figure 8.1 – Android MVC relationship
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – Android MVC关系图
- en: From *Figure 8.1*, we can see that the Controller represented by the activity
    would interact with the Model to fetch and manipulate the data, and then it would
    update the View with the relevant information.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从*图8.1*中，我们可以看到由活动表示的控制器会与模型交互以获取和操作数据，然后它会用相关信息更新视图。
- en: The idea is to have each `Activity` sandboxed as much as possible so that they
    can be offered and shared between multiple applications (like how the Camera application
    is opened by other applications to take photos and offer those photos to those
    applications). Because of this, activities need to be started using intents and
    not by instantiating them. By removing the ability to instantiate an `Activity`
    directly, we lose the ability to inject dependencies through the constructor.
    Another factor we need to consider is that activities have life cycle states,
    and we inherit these states in each `Activity` in our application. All these factors
    combined make an `Activity` very hard or next to impossible to unit test unless
    we use a library such as **Robolectric** or rely on instrumented tests on an Android
    device or emulator. Both options are slow and, in the case of instrumented tests,
    can be expensive when we need to run the tests in testing clouds such as **Firebase
    Test Lab**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是将每个`Activity`尽可能沙盒化，以便它们可以在多个应用程序之间提供和共享（就像相机应用程序被其他应用程序打开来拍照并将这些照片提供给那些应用程序一样）。正因为如此，活动需要通过意图启动，而不是通过实例化它们。通过移除直接实例化`Activity`的能力，我们失去了通过构造函数注入依赖的能力。另一个我们需要考虑的因素是活动具有生命周期状态，我们在应用程序中的每个`Activity`中继承这些状态。所有这些因素加在一起使得`Activity`非常难以测试，或者几乎不可能进行单元测试，除非我们使用像**Robolectric**这样的库，或者依赖于Android设备或模拟器的仪器化测试。这两种选项都速度较慢，在需要在使用测试云（如**Firebase
    Test Lab**）运行测试的情况下，仪器化测试可能成本较高。
- en: 'To solve the problem of unit testing logic that was present in activities and
    later fragments, various adaptations of the `Activity` along with the `android.widget.View`
    hierarchy becomes the View, the Presenter is responsible for fetching the data
    from the model and performing the logic required, updating the View, and the Model
    has the same responsibility as in MVC to handle the application''s data. The relationship
    between these components looks like the following figure:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决存在于活动中的单元测试逻辑问题，以及后来片段中的问题，对`Activity`的各种适应以及`android.widget.View`层次结构变为View，`Presenter`负责从模型中获取数据并执行所需的逻辑，更新`View`，而模型具有与MVC相同的责任来处理应用程序的数据。这些组件之间的关系如下所示：
- en: '![Figure 8.2 – MVP relationship'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2 – MVP关系](img/Figure_8.02_B18320.jpg)'
- en: '](img/Figure_8.02_B18320.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_8.02_B18320.jpg](img/Figure_8.02_B18320.jpg)'
- en: Figure 8.2 – MVP relationship
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – MVP关系
- en: 'The interesting aspect of the relationship between the components is the relationship
    between the Presenter and the View, which goes both ways. The Presenter will update
    the View with the relevant data, but the View will also invoke the Presenter,
    if necessary for user interactions. Because of the relationship between the two
    components, the definition of a contract is required, which looks like the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 组件之间关系的有趣方面是`Presenter`和`View`之间的双向关系。`Presenter`将更新`View`的相关数据，但`View`也会在必要时调用`Presenter`以进行用户交互。由于这两个组件之间的关系，需要定义一个契约，如下所示：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, we have a `View` interface and a `Presenter` interface. The implementation
    of the `Presenter` might look something like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个`View`接口和一个`Presenter`接口。`Presenter`的实现可能看起来像这样：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, the `PresenterImpl` class has a dependency on the `View` and on a `GetUsersUseCase`
    object, which will return a `Flow` object containing a list of users. When the
    `Presenter` receives the list of users, it will call the `showUsers` method from
    the `View`. When the `validateInput` method is called, the `Presenter` will check
    whether the text is empty and invoke the `showInputError` method from the `View`
    with an error message. The implementation of the `View` might look like the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`PresenterImpl`类依赖于`View`类以及一个`GetUsersUseCase`对象，该对象将返回一个包含用户列表的`Flow`对象。当`Presenter`接收到用户列表时，它将调用`View`中的`showUsers`方法。当调用`validateInput`方法时，`Presenter`将检查文本是否为空，并使用错误信息调用`View`中的`showInputError`方法。`View`的实现可能如下所示：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we implement the `View` interface in `MainActivity`; in the implementation
    of the methods, we call the appropriate `View-` related classes to show the relevant
    data, such as showing the error message for an invalid input in a `TextView` object
    and setting the data in a `RecyclerView.Adapter` object. For validating the input,
    when the text changes in an `EditText` object, it will invoke the `Presenter`
    to validate the new text. The `Presenter` dependency will be injected using some
    form of dependency injection.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在 `MainActivity` 中实现了 `View` 接口；在方法的实现中，我们调用适当的 `View-` 相关类来显示相关数据，例如在
    `TextView` 对象中显示无效输入的错误消息，以及在 `RecyclerView.Adapter` 对象中设置数据。为了验证输入，当 `EditText`
    对象中的文本发生变化时，它将调用 `Presenter` 来验证新的文本。`Presenter` 依赖项将通过某种形式的依赖注入来实现。
- en: 'Because presenters will end up performing background operations, we run the
    risk of causing `Context` leaks. This means that we need to factor the life cycle
    of the `Activity` into the MVP contract. To achieve this, we will need to define
    a `close` method in the `Presenter`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因为演示者最终将执行后台操作，我们面临造成 `Context` 泄漏的风险。这意味着我们需要将 `Activity` 的生命周期考虑进 MVP 协议中。为了实现这一点，我们将在
    `Presenter` 中定义一个 `close` 方法：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding snippet, we added the `close` method, which will be called
    in the `onDestroy` method of the `Activity` as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们添加了 `close` 方法，该方法将在 `Activity` 的 `onDestroy` 方法中被调用，如下所示：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The implementation of the `close` method will have to clean up all the resources
    that might cause any leaks:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`close` 方法的实现必须清理所有可能引起泄漏的资源：'
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we are canceling the subscription to the `Flow` object so that we will
    not receive any updates after the `Activity` is destroyed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在取消对 `Flow` 对象的订阅，以确保在 `Activity` 被销毁后不会收到任何更新。
- en: In this section, we have looked at previous architecture patterns used in Android
    applications, from the MVC-like approach that was used in early Android applications
    to MVP, which aimed to solve some of the problems of the initial approach. Although
    MVP was popular in the past and is still present in some Android applications,
    it has slowly been phased out, mainly because of the release of Android Architecture
    Components, which rely on the MVVM pattern, and additionally, Jetpack Compose,
    which works better with data flows, which are more suited to MVVM. In the section
    that follows, we will look at the MVVM architecture pattern and how it is different
    from MVP as a concept.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们回顾了在 Android 应用程序中使用过的先前架构模式，从早期 Android 应用程序中使用的类似 MVC 的方法到 MVP，旨在解决最初方法的一些问题。尽管
    MVP 在过去很受欢迎，并且仍然存在于一些 Android 应用程序中，但它已经被逐渐淘汰，主要是因为 Android 架构组件的发布，这些组件依赖于 MVVM
    模式，以及 Jetpack Compose，它更适合与数据流一起工作，而数据流更适合 MVVM。在接下来的部分中，我们将探讨 MVVM 架构模式以及它与 MVP
    作为概念的不同之处。
- en: Presenting data with MVVM
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MVVM 展示数据
- en: In this section, we will analyze the **Model-View-ViewModel** architecture pattern
    and how it is implemented for Android applications.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将分析 **模型-视图-视图模型（Model-View-ViewModel**） 架构模式及其在 Android 应用程序中的实现方式。
- en: 'MVVM represents a different approach to the Humble Object pattern, which attempts
    to extract the logic out of activities and fragments. In MVVM, the View is represented
    by activities and fragments as it was in MVP, the Model plays the same role, managing
    the data, and the ViewModel sits between the two by requesting the data from the
    Model when the View requires it. The relationship between the three is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM 代表了一种对 Humble Object 模式的不同方法，它试图将逻辑从活动和片段中提取出来。在 MVVM 中，视图由活动和片段表示，就像在
    MVP 中一样，模型扮演相同的角色，管理数据，而视图模型则位于两者之间，当视图需要数据时，从模型请求数据。三者之间的关系如下：
- en: '![Figure 8.3 – MVVM relationship'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.3 – MVVM 关系'
- en: '](img/Figure_8.03_B18320.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.03_B18320.jpg)'
- en: Figure 8.3 – MVVM relationship
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – MVVM 关系
- en: In *Figure 8.3*, we see a unidirectional relationship between the three components.
    The View has a dependency on the ViewModel, and the ViewModel has a dependency
    on the Model. This allows for more flexibility because multiple Views can use
    the same ViewModel. For the data to be updated in the View, MVVM requires an implementation
    of the **Observer** pattern. This means that the ViewModel uses an **Observable**,
    which the View will subscribe to and react to changes in the data.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图8.3*中，我们看到三个组件之间存在单向关系。视图依赖于ViewModel，而ViewModel依赖于模型。这提供了更多的灵活性，因为多个视图可以使用相同的ViewModel。为了在视图中更新数据，MVVM需要一个**观察者模式**的实现。这意味着ViewModel使用一个**可观察的**对象，视图将订阅并响应数据的变化。
- en: To develop Android applications, we have the possibility of using the Android
    Architecture Components libraries, which provide a `ViewModel` class that solves
    the issue of activity and fragment life cycles, combined with coroutine extensions
    useful for subscribing to flows or coroutines to stop the emission of data when
    the activities and fragments are in invalid states for data to be displayed and
    to avoid context leaks.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要开发Android应用程序，我们有使用Android Architecture Components库的可能性，这些库提供了一个`ViewModel`类，该类解决了活动和片段生命周期的问题，并结合了用于订阅流或协程的协程扩展，当活动和片段处于数据显示无效状态时停止数据发射，以避免上下文泄露。
- en: 'From the perspective of `LiveData` (which acts as the observable that the View
    can subscribe to). An example of a `ViewModel` class might look like the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从`LiveData`的角度来看（它充当视图可以订阅的可观察对象）。一个`ViewModel`类的示例可能如下所示：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we load a list of `User` objects and then keep that list inside a `StateFlow`
    object. This `StateFlow` object replaces `LiveData` and represents the observable
    that the View will subscribe to. When the View requires the list of users, it
    will invoke the `load` method.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们加载一个`User`对象的列表，并将其保存在一个`StateFlow`对象中。这个`StateFlow`对象取代了`LiveData`，代表视图将订阅的可观察对象。当视图需要用户列表时，它将调用`load`方法。
- en: In this section, we have analyzed the MVVM architecture pattern and the difference
    between it and the MVP pattern. In the following section, we will look at how
    we can present data using MVVM inside an Android application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们分析了MVVM架构模式和它与MVP模式之间的区别。在下一节中，我们将探讨如何在Android应用程序中使用MVVM来展示数据。
- en: Exercise 08.01 – Implementing MVVM
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习08.01 – 实现MVVM
- en: 'Modify *Exercise 07.02*, *Building a local data source*, of [*Chapter 7*](B18320_07_ePub.xhtml#_idTextAnchor082),
    *Building Data Sources*, so that a new module called `presentation-posts` is created.
    The module will be responsible for displaying the data from `GetPostsWithUsersWithInteractionUseCase`
    using MVVM. The data will be displayed in the following format:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 修改[*第7章*](B18320_07_ePub.xhtml#_idTextAnchor082)中的*练习7.02*，*构建本地数据源*，以便创建一个新的模块`presentation-posts`。该模块将负责使用MVVM显示`GetPostsWithUsersWithInteractionUseCase`的数据。数据将以以下格式显示：
- en: 'A header with the following text: "Total click count: x" where x is the number
    of clicks taken from the `totalClicks` field in the `Interaction` class'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含以下文本的标题："总点击次数：x"，其中x是从`Interaction`类中的`totalClicks`字段获取的点击次数
- en: 'A list of posts where each row contains the following: "Author: x" and "Title:
    y" where x is the `name` field in the `User` class, and y is the `title` field
    in the `Post` class'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列帖子，其中每一行包含以下内容："作者：x"和"标题：y"，其中x是`User`类中的`name`字段，y是`Post`类中的`title`字段
- en: A loading view for when the data is being loaded
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当数据正在加载时的加载视图
- en: A `Snackbar` view for when there is an error
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当出现错误时的`Snackbar`视图
- en: 'To complete this exercise, you will need to do the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个练习，你需要做以下事情：
- en: Create the `presentation-post` module.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`presentation-post`模块。
- en: Create a new sealed class called `UiState`, which will have as subclasses `Loading`,
    `Error` (which will hold an error message), and `Success` (which will hold the
    post data).
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的密封类`UiState`，它将具有子类`Loading`、`Error`（将包含错误消息）和`Success`（将包含帖子数据）。
- en: Create a new class called `PostListItemModel`, which will have `id`, `author`,
    and `name` as fields.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PostListItemModel`的新类，该类将包含`id`、`author`和`name`作为字段。
- en: Create a new class called `PostListModel`, which will have a `headerText` field
    and a list of `PostListItemModel` objects.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PostListModel`的新类，该类将包含一个`headerText`字段和一个`PostListItemModel`对象的列表。
- en: Create a new class called `PostListConverter`, which will convert a `Result.Success`
    object into a `UiState.Success`, which holds the `PostListModel` object and will
    convert a `Result.Error` object into a `UiState.Error` object.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PostListConverter`的新类，该类将`Result.Success`对象转换为`UiState.Success`，它包含`PostListModel`对象，并将`Result.Error`对象转换为`UiState.Error`对象。
- en: Create a new class called `PostListViewModel`, which will load the data from
    `GetPostsWithUsersWithInteractionUseCase`, convert the data using `PostListConverter`,
    and store `UiState` in `StateFlow`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PostListViewModel`的新类，该类将从`GetPostsWithUsersWithInteractionUseCase`加载数据，使用`PostListConverter`转换数据，并将`UiState`存储在`StateFlow`中。
- en: Create a new Kotlin file, which will contain `@Composable` methods responsible
    for drawing the UI.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Kotlin文件，其中将包含负责绘制UI的`@Composable`方法。
- en: Modify `MainActivity` in the `app` module so that it will display the list of
    posts.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`app`模块中的`MainActivity`，使其显示帖子列表。
- en: 'Follow these steps to complete the exercise:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成练习：
- en: Create a new module called `presentation-post`, which will be an Android library
    module.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`presentation-post`的新模块，它将是一个Android库模块。
- en: 'Make sure that in the top-level `build.gradle` file, the following dependencies
    are set:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在顶级`build.gradle`文件中设置了以下依赖项：
- en: '[PRE7]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the same file, add the persistence libraries to the library mappings:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，将持久化库添加到库映射中：
- en: '[PRE8]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we have added dependencies for the ViewModel library as well as the Navigation
    library (which will be used in later exercises).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了ViewModel库以及导航库（将在后续练习中使用）的依赖项。
- en: 'In the `build.gradle` file of the `presentation-post` module, make sure that
    the following plugins are present:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`presentation-post`模块的`build.gradle`文件中，确保存在以下插件：
- en: '[PRE9]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the same file, change the configurations to the ones defined in the top-level
    `build.gradle` file:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，将配置更改为顶级`build.gradle`文件中定义的配置：
- en: '[PRE10]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we keep the same configuration consistent with the other modules in the
    application, and we integrate the Jetpack Compose configuration.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们保持与应用程序中其他模块相同的配置一致，并集成了Jetpack Compose配置。
- en: 'In the same file, add the dependencies to the networking libraries and domain
    modules:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，添加网络库和领域模块的依赖项：
- en: '[PRE11]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the `presentation-post` module, create a package called `list`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`presentation-post`模块中创建一个名为`list`的包。
- en: 'In the `list` package, create the `UiState` class:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`list`包中创建`UiState`类：
- en: '[PRE12]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the same package, create a file called `PostListModels`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一包中，创建一个名为`PostListModels`的文件。
- en: 'In the `PostListModels` file, create the `PostListItemModel` class:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PostListModels`文件中，创建`PostListItemModel`类：
- en: '[PRE13]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the same file, create the `PostListModel` class:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，创建`PostListModel`类：
- en: '[PRE14]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the `presentation-post` module, in the `src/main` folder, create a folder
    called `res`.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`presentation-post`模块的`src/main`文件夹中，创建一个名为`res`的文件夹。
- en: In the `res` folder, create a new folder called `values`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res`文件夹中，创建一个名为`values`的新文件夹。
- en: In the `values` folder, create a file called `strings.xml`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`values`文件夹中，创建一个名为`strings.xml`的文件。
- en: 'In the `strings.xml` file, add the following strings:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`strings.xml`文件中，添加以下字符串：
- en: '[PRE15]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the `list` package, create the `PostListConverter` class:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`list`包中，创建`PostListConverter`类：
- en: '[PRE16]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we convert the `Result.Success` and `Result.Error` objects into equivalent
    `UiState` objects, which will be used to display the information to the user.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`Result.Success`和`Result.Error`对象转换为等效的`UiState`对象，这些对象将用于向用户显示信息。
- en: 'In the `list` package, create the `PostListViewModel` class:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`list`包中，创建`PostListViewModel`类：
- en: '[PRE17]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we get the list of posts and users from the `GetPostsWithUsersInteractionUseCase`
    object, then we convert it to the `UiState` object, and finally, we update `StateFlow`
    with the `UiState` object.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从`GetPostsWithUsersInteractionUseCase`对象获取帖子列表和用户列表，然后将其转换为`UiState`对象，最后使用`UiState`对象更新`StateFlow`。
- en: In the `list` package, create a file called `PostListScreen`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`list`包中，创建一个名为`PostListScreen`的文件。
- en: 'In the `PostListScreen` file, add a method to display a loading widget and
    a `Snackbar` method:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PostListScreen`文件中，添加一个用于显示加载小部件和`Snackbar`方法的方法：
- en: '[PRE18]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the same file, add a method to display the list of posts and the header:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，添加一个用于显示帖子列表和标题的方法：
- en: '[PRE19]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the same file, add a method that will monitor the value of `postListFlow`
    and invoke one of the preceding three methods, depending on the value of the state:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，添加一个方法来监控`postListFlow`的值，并根据状态值调用前面三个方法之一：
- en: '[PRE20]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the `build.gradle` file of the `app` module, make sure that the following
    plugins are added:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app` 模块的 `build.gradle` 文件中，确保添加以下插件：
- en: '[PRE21]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the same file, make sure that the following dependencies are added:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，确保添加以下依赖项：
- en: '[PRE22]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the `app` module, create a package called `injection`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app` 模块中，创建一个名为 `injection` 的包。
- en: 'In the `injection` package, create a class called `AppModule`:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `injection` 包中，创建一个名为 `AppModule` 的类：
- en: '[PRE23]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we provide a `UseCase.Configuration` dependency, which will be injected
    into all the `UseCase` subclasses.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们提供了一个 `UseCase.Configuration` 依赖项，它将被注入到所有的 `UseCase` 子类中。
- en: 'In the `app` module, create a class called `PostApplication`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app` 模块中，创建一个名为 `PostApplication` 的类：
- en: '[PRE24]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add the `PostApplication` class to the `AndroidManifest.xml` file of the `app`
    module:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `PostApplication` 类添加到 `app` 模块的 `AndroidManifest.xml` 文件中：
- en: '[PRE25]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Modify the `MainActivity` class so that it will use the navigation library
    to go to the `PostListScreen` function from the `presentation-post` module:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `MainActivity` 类，使其使用导航库从 `presentation-post` 模块导航到 `PostListScreen` 功能：
- en: '[PRE26]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we run the application, we should see the following screen:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行应用程序，我们应该看到以下屏幕：
- en: '![Figure 8.4 – Output of Exercise 08.01'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.4 – 练习 08.01'
- en: '](img/Figure_8.04_B18320.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.04_B18320.jpg](img/Figure_8.04_B18320.jpg)'
- en: Figure 8.4 – Output of Exercise 08.01
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 练习 08.01 的输出
- en: We can see the list of post titles and the author's name for each post. The
    total click count is, for now, 0 because we haven't connected any logic and are
    yet to modify that value. We will add that logic in the exercises that follow.
    If an error occurs while loading this list, then we will see a snackbar with the
    description of the `Exception` object, and while the data is loaded, an indeterminate
    progress bar will be displayed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到每篇帖子的标题列表和作者姓名。目前总点击次数为 0，因为我们还没有连接任何逻辑，并且尚未修改该值。我们将在后续的练习中添加该逻辑。如果在加载此列表时发生错误，则将显示一个包含
    `Exception` 对象描述的 snackbar，而在数据加载时，将显示一个不确定的进度条。
- en: In this section, we have implemented the presentation layer of an Android application
    using the MVVM architecture pattern and connected the layer to the domain layer
    of the application to display data to the user. In the section that follows, we
    will expand this layer across multiple modules and see how we can navigate between
    screens in different modules.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用 MVVM 架构模式实现了 Android 应用程序的表示层，并将其连接到应用程序的领域层以向用户显示数据。在下一节中，我们将扩展这个层到多个模块，并查看如何在不同的模块之间导航屏幕。
- en: Presenting data in multiple modules
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在多个模块中呈现数据
- en: In this section, we will look at how we can separate the presentation layer
    into multiple modules, how we can handle the interaction between these modules,
    and how they can share the same data.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何将表示层分割成多个模块，如何处理这些模块之间的交互，以及它们如何共享相同的数据。
- en: 'When developing Android applications, we can group screens into different modules.
    For example, we can group a login or registration flow inside a library module
    called *authentication*, or if we have a settings section, we can group those
    screens inside a separate module. Sometimes these screens will have commonalities
    with the rest of the application, such as using the same loading progress bar
    or the same error mechanism. Other times, these screens must navigate to screens
    from other modules. The question we now need to ask is how this can happen without
    creating a dependency between the two modules or other modules that are on the
    same level. Having a direct dependency on these modules will risk creating a cyclic
    dependency as shown here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发 Android 应用程序时，我们可以将屏幕分组到不同的模块中。例如，我们可以将登录或注册流程分组到一个名为 *authentication* 的库模块中，或者如果我们有一个设置部分，我们可以将这些屏幕分组到一个单独的模块中。有时这些屏幕将与应用程序的其余部分有共同点，例如使用相同的加载进度条或相同的错误机制。其他时候，这些屏幕必须从其他模块导航到屏幕。我们现在需要问的问题是，如何在两个模块或其他同一级别的模块之间不创建依赖关系的情况下实现这一点。对这些模块有直接的依赖关系将会有创建循环依赖的风险，如下所示：
- en: '![Figure 8.5 – Module cyclic dependency'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.5 – 模块循环依赖'
- en: '](img/Figure_8.05_B18320.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.05_B18320.jpg](img/Figure_8.05_B18320.jpg)'
- en: Figure 8.5 – Module cyclic dependency
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – 模块循环依赖
- en: 'In *Figure 8.5*, we show what might happen if we want to navigate from the
    `:auth` module to the `:settings` module and vice versa. This currently is impossible
    because of the cyclic dependency between the two modules. To solve this issue,
    we will need to create a new module. This module will hold the common logic shared
    between the two modules and common data. This will look like the following figure:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 8.5* 中，我们展示了如果我们想从 `:auth` 模块导航到 `:settings` 模块，反之亦然，可能会发生什么。这目前是不可能的，因为这两个模块之间存在循环依赖。为了解决这个问题，我们需要创建一个新的模块。这个模块将持有两个模块之间共享的常见逻辑和常见数据。这看起来如下所示：
- en: '![Figure 8.6 – Common presentation module'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.6 – 常见展示模块'
- en: '](img/Figure_8.06_B18320.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_8.06_B18320.jpg]'
- en: Figure 8.6 – Common presentation module
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 常见展示模块
- en: In *Figure 8.6*, we added the `:common` module, which will hold reusable views
    or `@Composable` functions and the navigation data from the app. Over time, this
    module will grow, so it can be split into different modules holding different
    common features of the app (navigation, UI, common logic, and so on).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 8.6* 中，我们添加了 `:common` 模块，该模块将包含可重用的视图或 `@Composable` 函数以及应用中的导航数据。随着时间的推移，这个模块将增长，因此它可以拆分为不同的模块，每个模块持有应用的不同常见功能（导航、UI、常见逻辑等）。
- en: 'If we are using Jetpack Compose for our application, then we can rely on the
    work done in *Exercise 03.02 – Navigating using Jetpack Compose* of [*Chapter
    3*](B18320_03_ePub.xhtml#_idTextAnchor055), *Understanding Data Presentation on
    Android*, where we defined the following structure for the app navigation:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在使用 Jetpack Compose 为我们的应用程序，那么我们可以依赖在 [*第 3 章*](B18320_03_ePub.xhtml#_idTextAnchor055)
    的 *练习 03.02 – 使用 Jetpack Compose 进行导航* 中完成的工作，其中我们为应用导航定义了以下结构：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `routeForName` method was called from the `Users` screen when a user in
    the list was clicked, and then the `NavHost` method would use that route to open
    the `User` screen. When dealing with multiple modules, the routes that will be
    shared by the modules can be stored in the `:common` module so that each module
    will have access to the route. The `:app` module, which will have `NavHost`, will
    then be able to navigate between each screen.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当列表中的用户被点击时，`routeForName` 方法会从 `Users` 屏幕调用，然后 `NavHost` 方法会使用该路由来打开 `User`
    屏幕。在处理多个模块时，将在 `:common` 模块中存储模块之间共享的路由，以便每个模块都可以访问该路由。然后，具有 `NavHost` 的 `:app`
    模块将能够导航到每个屏幕。
- en: 'When it comes to handling common logic between different modules, such as displaying
    the same error or loading views, we can declare the composable functions inside
    the `:common` module:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到处理不同模块之间的常见逻辑，例如显示相同的错误或加载视图时，我们可以在 `:common` 模块中声明可组合函数：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the same state is shared between the different screens in the different
    modules, we can have something like the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不同模块中的不同屏幕共享相同的状态，我们可以有如下类似的情况：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we will check the current state and display the common error and loading
    views, leaving the screens themselves to only concern themselves with the successful
    state.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将检查当前状态并显示常见的错误和加载视图，而屏幕本身只需关注成功状态。
- en: In this section, we have looked at how we can split the presentation layer into
    multiple modules and how to handle the common elements between these modules.
    In the following section, we will look at an exercise on how to achieve this.
    Splitting the presentation layer into multiple modules will decrease application
    build times because Gradle caching will only rebuild modules that contain changes.
    Another benefit comes in the form of drawing boundaries around the application's
    scope, which will be beneficial when it comes to exporting only certain features
    of an application.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何将展示层拆分为多个模块，以及如何处理这些模块之间的常见元素。在下一节中，我们将探讨一个练习，说明如何实现这一点。将展示层拆分为多个模块将减少应用程序构建时间，因为
    Gradle 缓存只会重新构建包含更改的模块。另一个好处是，它为应用程序的范围划定了界限，这在仅导出应用程序的某些功能时将是有益的。
- en: Exercise 08.02 – Multi-module data presentation
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 08.02 – 多模块数据展示
- en: 'Modify *Exercise 08.01 – Implementing MVVM* so that two new modules are created:
    `presentation-post` and `presentation-common`.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 *练习 08.01 – 实现MVVM*，以便创建两个新的模块：`presentation-post` 和 `presentation-common`。
- en: 'The `presentation-common` module will have the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`presentation-common` 模块将包含以下内容：'
- en: The `UiState` class, which will be moved from the `presentation-post` module.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `UiState` 类从 `presentation-post` 模块移动过来。
- en: '`CommonResultConverter`, which will be an abstract class with two methods:
    `convert`, which is a concrete method that will convert the `Result` object into
    a `UiState` object, and `convertSuccess`, which is an abstract method used to
    convert the data from `Result.Success`.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CommonResultConverter`将是一个具有两个方法的抽象类：`convert`是一个将`Result`对象转换为`UiState`对象的具体方法，而`convertSuccess`是一个用于将`Result.Success`中的数据转换的抽象方法。'
- en: '`CommonScreen`, which will have the `@Composable` method for displaying the
    different types of `UiState` and two additional methods for displaying the error
    snackbar and the progress bar. The two methods will be moved from `PostListScreen`.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CommonScreen`将包含用于显示不同类型`UiState`的`@Composable`方法，以及两个额外的用于显示错误snackbar和进度条的方法。这两个方法将从`PostListScreen`移动过来。'
- en: '`AppNavigation`, which will hold the routes to navigate to the list of posts,
    a single post, and a single user.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppNavigation`将包含导航到帖子列表、单个帖子以及单个用户的路由。'
- en: 'The `presentation-post` module will have an additional package to display the
    information of a single post in the following format: Title: x and Body: y, where
    x is the title of a post and y is the body of the post. To display this information,
    a new `ViewModel` and `Converter` class will need to be created, which will convert
    the data from `GetPostUseCase`. When the author text is clicked, the app will
    navigate to the user screen, and when the `Post` list item is clicked, the app
    will navigate to the post screen. When either of these is clicked, `UpdateInteractionUseCase`
    is invoked to increase the number of clicks, which will then be reflected in the
    list header.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`presentation-post`模块将添加一个额外的包来显示单个帖子的信息，格式如下：标题：x 和正文：y，其中x是帖子的标题，y是帖子的正文。为了显示这些信息，需要创建一个新的`ViewModel`和`Converter`类，这些类将把`GetPostUseCase`中的数据转换过来。当点击作者文本时，应用将导航到用户屏幕；当点击`Post`列表项时，应用将导航到帖子屏幕。点击其中任何一个，都会调用`UpdateInteractionUseCase`来增加点击次数，这将随后反映在列表标题中。'
- en: '`presentation-user` will display the information about a single user in the
    following format: Name: x, Username: y, and Email: z, where x, y, and z are represented
    by the information inside the `User` entity. The user data will be loaded from
    `GetUserUseCase`.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`presentation-user`将以以下格式显示单个用户的信息：姓名：x，用户名：y，和电子邮件：z，其中x、y和z由`User`实体中的信息表示。用户数据将从`GetUserUseCase`加载。'
- en: The `app` module will be updated to handle the navigation between all these
    screens.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app`模块将更新以处理所有这些屏幕之间的导航。'
- en: 'To complete this exercise, you will need to do the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个练习，你需要执行以下操作：
- en: Create the `presentation-common` module.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`presentation-common`模块。
- en: Move the `UiState` class and the `Error` and `Loading` `@Composable` functions
    and create a new `@Composable` function, which will handle each type of `UiState`
    object inside the `CommonScreen` file.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`UiState`类和`Error`以及`Loading` `@Composable`函数移动到`CommonScreen`文件中，并创建一个新的`@Composable`函数，该函数将处理`CommonScreen`文件中每种类型的`UiState`对象。
- en: Create the `CommonResultConverter` class.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`CommonResultConverter`类。
- en: Create the `AppNavigation` class.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`AppNavigation`类。
- en: Modify the classes in `presentation-post` to reuse the preceding classes and
    methods.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`presentation-post`中的类以重用前面的类和方法。
- en: Create the `PostScreen`, `PostViewModel`, `PostConverter`, and `PostModel` classes
    responsible for displaying the information about a single post.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建负责显示单个帖子信息的`PostScreen`、`PostViewModel`、`PostConverter`和`PostModel`类。
- en: Create the `presentation-user` module.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`presentation-user`模块。
- en: Create the `UserScreen`, `UserViewModel`, `UserConverter`, and `UserModel` classes
    responsible for displaying the information about a single post.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建负责显示单个帖子信息的`UserScreen`、`UserViewModel`、`UserConverter`和`UserModel`类。
- en: Implement the navigation between the screens.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现屏幕间的导航。
- en: Add the logic to update the number of clicks inside `PostListViewModel`.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PostListViewModel`中添加更新点击次数的逻辑。
- en: 'Follow these steps to complete the exercise:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成练习：
- en: Create the `presentation-common` and `presentation-user` Android library modules.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`presentation-common`和`presentation-user` Android库模块。
- en: Apply steps 3–5 from *Exercise 08.01 – Implementing MVVM* for each of these
    new modules.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*练习08.01 – 实现MVVM*中的步骤3-5应用于这些新模块。
- en: 'In the `build.gradle` file of the `presentation-post` and `presentation-user`
    modules, make sure that the dependency to `presentation-common` is added:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`presentation-post`和`presentation-user`模块的`build.gradle`文件中，确保添加了对`presentation-common`的依赖项。
- en: '[PRE30]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the `presentation-common` module, create a new package called `state`.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `presentation-common` 模块中，创建一个新的包，命名为 `state`。
- en: Move the `UiState` class into the preceding package.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `UiState` 类移动到前面的包中。
- en: 'In the same package, create the `CommonResultConverter` class:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个包中，创建 `CommonResultConverter` 类：
- en: '[PRE31]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we return `UiState.Error` for any `Result.Error` object with the exception
    message, and for `Result.Success`, we return `UiState.Success` and use an abstraction
    for the data inside the `Result.Success` object. This represents a solution for
    how we can extract the common logic for displaying the error.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，对于任何带有异常信息的 `Result.Error` 对象，我们返回 `UiState.Error`，对于 `Result.Success`，我们返回
    `UiState.Success` 并使用 `Result.Success` 对象内部的数据的抽象。这代表了一种解决方案，说明了我们如何提取显示错误的公共逻辑。
- en: 'Modify the `PostListConverter` class from the `presentation-post` module so
    that it will extend `CommonResultConverter` and provide an implementation for
    the `convertSuccess` method:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `presentation-post` 模块中的 `PostListConverter` 类，使其扩展 `CommonResultConverter`
    并为 `convertSuccess` 方法提供实现：
- en: '[PRE32]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we only deal with converting `GetPostsWithUsersWithInteractionUseCase.Response`
    into `PostListModel`, allowing the parent class to handle the error only.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只处理将 `GetPostsWithUsersWithInteractionUseCase.Response` 转换为 `PostListModel`，允许父类处理错误。
- en: In the `state` package from the `presentation-common` module, create a new file
    called `CommonScreen`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `presentation-common` 模块的 `state` 包中，创建一个名为 `CommonScreen` 的新文件。
- en: 'In the `CommonScreen` file, add a `CommonScreen` `@Composable` method, which
    will check `UiState` and invoke `Error` for `UiState.Error` and `Loading` for
    `UiState.Loading`:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CommonScreen` 文件中，添加一个 `CommonScreen` `@Composable` 方法，它将检查 `UiState` 并对
    `UiState.Error` 调用 `Error`，对 `UiState.Loading` 调用 `Loading`：
- en: '[PRE33]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Move the `Error` and `Loading` `@Composable` functions from `PostListScreen`
    into the `CommonScreen` file.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `PostListScreen` 中的 `Error` 和 `Loading` `@Composable` 函数移动到 `CommonScreen`
    文件中。
- en: 'Modify the `PostListScreen` `@Composable` method from the `presentation-post`
    module so that it will use the `CommonScreen` method:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `presentation-post` 模块中的 `PostListScreen` `@Composable` 方法，使其使用 `CommonScreen`
    方法：
- en: '[PRE34]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now the entire logic for converting and showing the list of posts will only
    deal with the associated objects, leaving the error and loading scenarios in the
    `presentation-common` module.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，整个转换和显示帖子列表的逻辑将只处理相关对象，将错误和加载场景留在 `presentation-common` 模块中。
- en: In `presentation-common`, create a new package called `navigation`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `presentation-common` 中，创建一个新的包，命名为 `navigation`。
- en: 'In the `navigation` package, create a class called `PostInput`:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `navigation` 包中，创建一个名为 `PostInput` 的类：
- en: '[PRE35]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This class is meant to represent the input that the post screen will require
    to load its data.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类旨在表示帖子屏幕加载数据所需的输入。
- en: 'In the same package, create a class called `UserInput`:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个包中，创建一个名为 `UserInput` 的类：
- en: '[PRE36]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This class is meant to represent the input that the user screen will require
    to load its data.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类旨在表示用户屏幕加载数据所需的输入。
- en: 'In the same package, create a new class called `NavRoutes`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个包中，创建一个新的类，命名为 `NavRoutes`：
- en: '[PRE37]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we define the paths for each screen. The posts screen will have no arguments,
    but the user and post screens will require the `postId` and `userId` values.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了每个屏幕的路径。帖子屏幕将没有参数，但用户和帖子屏幕将需要 `postId` 和 `userId` 的值。
- en: 'Create the `Posts` class in the `NavRoutes` class:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `NavRoutes` 类中创建 `Posts` 类：
- en: '[PRE38]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Create the `Post` class in the `NavRoutes` class:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `NavRoutes` 类中创建 `Post` 类：
- en: '[PRE39]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we will need to break down the `Post` input into the arguments for the
    URL. The `routeForPost` method will create a `/posts/1` URL for a `Post` object
    that has the ID `1`. The `fromEntry` method will re-assemble the `PostInput` object
    from the navigation entry object. The reason we are taking this approach is that
    the navigation library discourages the use of `Parcelable`, which means that passing
    data between different screens will have to be done through the URL. To avoid
    any issues with keeping track of the arguments across multiple modules, we can
    instead use objects and keep the logic to read from arguments and construct the
    arguments isolated to this class.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要将 `Post` 输入分解为 URL 的参数。`routeForPost` 方法将为具有 ID `1` 的 `Post` 对象创建一个
    `/posts/1` URL。`fromEntry` 方法将从导航条目对象重新组装 `PostInput` 对象。我们采取这种方法的理由是，导航库不鼓励使用
    `Parcelable`，这意味着在不同屏幕之间传递数据将不得不通过 URL 来完成。为了避免在多个模块之间跟踪参数时出现任何问题，我们可以使用对象，并将从参数中读取和构造参数的逻辑隔离到这个类中。
- en: 'Create the `User` class inside the `NavRoutes` class:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `NavRoutes` 类内部创建 `User` 类：
- en: '[PRE40]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, we apply the same principle as we did for the `Post` class.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们应用与`Post`类相同的原理。
- en: Create a new package called `single` in the `presentation-post` module.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`presentation-post`模块中创建一个名为`single`的新包：
- en: 'In the `single` package, create the `PostModel` class:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`single`包内创建`PostModel`类：
- en: '[PRE41]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the `single` package, create the `PostConverter` class:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`single`包内创建`PostConverter`类：
- en: '[PRE42]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Add the `body` string to `strings.xml` of the `presentation-post` module:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`body`字符串添加到`presentation-post`模块的`strings.xml`中：
- en: '[PRE43]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the `single` package, create the `PostViewModel` class:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`single`包内创建`PostViewModel`类：
- en: '[PRE44]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, we are using `GetPostUseCase` to load the information about a particular
    post and are using the converter defined earlier to convert the data into `PostModel`,
    which will be set in the `Flow` object.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用`GetPostUseCase`加载特定帖子的信息，并使用之前定义的转换器将数据转换为`PostModel`，该模型将被设置在`Flow`对象中。
- en: 'In the `single` package, create the `PostScreen` file, which will display the
    post information:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`single`包内创建`PostScreen`文件，该文件将显示帖子信息：
- en: '[PRE45]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, we follow the same principle as for the `PostListScreen` file, where we
    split into two methods, `PostScreen` for observing the `UiState` object and `PostListScreen`
    to deal with drawing the user interface.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们遵循与`PostListScreen`文件相同的原理，将方法分为两个，`PostScreen`用于观察`UiState`对象，`PostListScreen`用于处理用户界面绘制。
- en: In the `presentation-user` module, create a new package called `single`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`presentation-user`模块中，创建一个名为`single`的新包：
- en: 'In the `single` package, create a new class called `UserModel`:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`single`包内创建一个名为`UserModel`的新类：
- en: '[PRE46]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the `single` package, create a new class called `UserConverter`:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`single`包内创建一个名为`UserConverter`的新类：
- en: '[PRE47]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Create the `res/values/strings.xml` file inside the `main` folder in the `presentation-user`
    module:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`presentation-user`模块的`main`文件夹内创建`res/values/strings.xml`文件：
- en: '[PRE48]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Inside the `single` package, create `UserViewModel`:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`single`包内创建`UserViewModel`：
- en: '[PRE49]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, we take the user data from `GetUserUseCase`, convert it using `UserConverter`,
    and post the result in the `Flow` object.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们从`GetUserUseCase`获取用户数据，使用`UserConverter`进行转换，并将结果发布在`Flow`对象中。
- en: 'In the `single` package, create the `UserScreen` file:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`single`包内创建`UserScreen`文件：
- en: '[PRE50]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, we take the same approach as the other screens, where in one method, we
    subscribe to changes in `UiState`, and in the other, we display the user information.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们采用与其他屏幕相同的方法，在一个方法中订阅`UiState`的变化，在另一个方法中显示用户信息。
- en: 'Add the click listeners in `PostListScreen`:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PostListScreen`中添加点击监听器：
- en: '[PRE51]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the preceding snippet, we specify click listeners for when the row is clicked
    and for when the author is clicked. Because we are applying state hoisting, we
    want to propagate the click listeners to the caller of the `PostList` method.
    To achieve this, we define a parameter for each click listener as a lambda function
    that has as input the row data and requires no result. More information about
    lambdas can be found here: [https://kotlinlang.org/docs/lambdas.html#function-types](https://kotlinlang.org/docs/lambdas.html#function-types).'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们指定了行被点击和作者被点击时的点击监听器。因为我们正在应用状态提升，我们希望将点击监听器传播到`PostList`方法的调用者。为此，我们为每个点击监听器定义了一个参数，作为一个接受行数据作为输入且不需要返回结果的lambda函数。有关lambda的更多信息，请参阅此处：[https://kotlinlang.org/docs/lambdas.html#function-types](https://kotlinlang.org/docs/lambdas.html#function-types)。
- en: 'Modify the `PostListScreen` `@Composable` method so that when the user is clicked,
    we navigate to the user screen, and when the row is clicked, we navigate to the
    post:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`PostListScreen`的`@Composable`方法，以便当用户点击时，我们导航到用户界面，当行被点击时，我们导航到帖子：
- en: '[PRE52]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In `build.gradle` of the `app` module, make sure that the dependencies to `presentation-common`
    and `presentation-user` are added:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app`模块的`build.gradle`中，确保添加了对`presentation-common`和`presentation-user`的依赖：
- en: '[PRE53]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the `MainActivity` file, modify the `App` method so that the navigation
    between the different screens is implemented:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainActivity`文件中，修改`App`方法，以便实现不同屏幕之间的导航：
- en: '[PRE54]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here, we add all the screens in the application to the navigation graph, and
    in the case of `UserScreen` and `PostScreen`, we extract the `UserInput` and `PostInput`
    objects from the navigation graph entries. We will now need to add the interaction.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将应用程序中的所有屏幕添加到导航图中，对于`UserScreen`和`PostScreen`，我们从导航图条目中提取`UserInput`和`PostInput`对象。我们现在需要添加交互。
- en: 'Add an `Interaction` field inside `PostListModel`:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PostListModel`内部添加一个`Interaction`字段：
- en: '[PRE55]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Modify `PostListConverter` to include the `interaction` field:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`PostListConverter`以包含`interaction`字段：
- en: '[PRE56]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Add a reference to `UpdateInteractionUseCase` in `PostListViewModel` and a
    method to update the interaction:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PostListViewModel` 中添加对 `UpdateInteractionUseCase` 的引用，并添加一个更新交互的方法：
- en: '[PRE57]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Modify the `PostListScreen` `@Composable` method so that it will call to update
    the interaction for each click:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `PostListScreen` 的 `@Composable` 方法，使其在每次点击时调用更新交互：
- en: '[PRE58]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If we run the application, we will see an output like the one in the following
    figure:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行应用程序，我们将看到如下图的输出：
- en: '![Figure 8.7 – Output of Exercise 08.02'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.7 – 练习 08.02 的输出'
- en: '](img/Figure_8.07_B18320.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.07_B18320.jpg)'
- en: Figure 8.7 – Output of Exercise 08.02
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – 练习 08.02 的输出
- en: We can see from *Figure 8.7* that when the row is clicked, we are taken to the
    screen displaying the post information, and when the author is clicked, we are
    taken to the user information. By placing the `NavRoutes` class in the `presentation-common`
    module, we can navigate from the post list on a screen located in the same module
    (post) and a screen located in a different module (user). The solution of creating
    additional modules is a good way to avoid cyclic dependencies not only for modules
    in the presentation layer but also for modules in the other layers as well.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *图 8.7* 我们可以看到，当点击行时，我们会进入显示帖子信息的屏幕，当点击作者时，我们会进入用户信息屏幕。通过将 `NavRoutes` 类放在
    `presentation-common` 模块中，我们可以从位于同一模块（帖子）的屏幕和位于不同模块（用户）的屏幕上导航到帖子列表。创建额外模块的解决方案是避免循环依赖的好方法，这不仅适用于表示层中的模块，也适用于其他层中的模块。
- en: In this exercise, we have learned how to split the presentation layer into separate
    modules and how we can use a common module to hold shared logic and data required
    by all the modules in the layer. This is a technique that can be used for other
    layers in the application if we want them split up as well.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何将表示层分割成独立的模块，以及我们如何使用公共模块来存储层中所有模块所需的共享逻辑和数据。这是一种技术，如果我们想将应用程序的其他层分割开，我们也可以使用它。
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the presentation layer of an Android application
    and a few different approaches for implementing this layer, such as MVC, MVP,
    and MVVM. We decided to focus on the MVVM approach because of the many benefits
    involving the life cycle and the compatibility with Jetpack Compose. We then looked
    at what happens when we want to split the presentation layer across multiple modules
    and how we can solve the common logic between these modules. In the chapter that
    follows, we will further build upon the MVVM pattern and study the **Model-View-Intent**
    (**MVI**) pattern, which further takes advantage of the Observable pattern to
    incorporate the user actions into states that can be observed.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 Android 应用程序的表示层以及实现此层的一些不同方法，例如 MVC、MVP 和 MVVM。我们决定专注于 MVVM 方法，因为它涉及生命周期和与
    Jetpack Compose 的兼容性带来了许多好处。然后我们探讨了当我们想要将表示层分割到多个模块时会发生什么，以及我们如何解决这些模块之间的公共逻辑。在下一章中，我们将进一步构建
    MVVM 模式，并研究 **模型-视图-意图**（**MVI**）模式，该模式进一步利用可观察模式将用户操作纳入可观察的状态。
