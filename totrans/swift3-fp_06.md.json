["```swift\nlet numbers = [10, 30, 91, 50, 100, 39, 74]\nvar formattedNumbers: [String] = []\n\nfor number in numbers {\n    let formattedNumber = \"\\(number)$\"\n    formattedNumbers.append(formattedNumber)\n}\n\nlet mappedNumbers = numbers.map { \"\\($0)$\" }\n\n```", "```swift\nlet mappedNumbers = numbers.map { \"\\($0)$\" }\n\n```", "```swift\nfunc calculate<T>(a: T,\n                  b: T,\n              funcA: (T, T) -> T,\n              funcB: (T) -> T) -> T {\n\n    return funcA(funcB(a), funcB(b))\n}\n\n```", "```swift\nfunc calculate<T, U>(a: T,\n                 funcA: (T) -> U) -> U {\n\n    return funcA(a)\n}\n\n```", "```swift\nfunc calculate<T, U>(a: [T],\n                 funcA: ([T]) -> [U]) -> [U] {\n\n    return funcA(a)\n}\n\n```", "```swift\nfunc map<T, U>(a: [T], transform: [T] -> [U]) -> [U] {\n    return transform(a)\n}\n\n```", "```swift\nfunc map<ElementInput, ElementResult>(elements: [ElementInput],\n  transform: (ElementInput) -> ElementResult) -> [ElementResult] {\n    var result: [ElementResult] = []\n\n    for element in elements {\n        result.append(transform(element))\n    }\n\n    return result\n}\n\n```", "```swift\nlet numbers = [10, 30, 91, 50, 100, 39, 74]\n\nlet result = map(elements: numbers, transform: { $0 + 2 })\n\n```", "```swift\npublic func map<T>(@noescape transform: (Self.Generator.Element) -> T) ->\n  [T]\n```", "```swift\nlet twoDimensionalArray = [[1, 3, 5], [2, 4, 6]]\nlet oneDimensionalArray = twoDimensionalArray.flatMap { $0 }\n\n```", "```swift\nlet oneDimensionalArray = twoDimensionalArray.flatten().map { $0 }\n\n```", "```swift\nlet transofrmedOneDimensionalArray = twoDimensionalArray.flatMap { \n      $0.map { $0 + 2 } \n}\n```", "```swift\nlet oneDimensionalArray = twoDimensionalArray.flatten().map { $0 + 2 }\n\n```", "```swift\nlet threeDimensionalArray = [[1, [3, 5]], [2, [4, 6]]]\nlet twoDimensionalArray = threeDimensionalArray.flatMap { $0 }\n\n```", "```swift\npublic func filter(@noescape includeElement: \n  (Self.Generator.Element) -> Bool) -> [Self.Generator.Element]\n```", "```swift\nlet numbers = [10, 30, 91, 50, 100, 39, 74]\nlet evenNumbers = numbers.filter { $0 % 2 == 0 }\n\n```", "```swift\nfunc filter<Element> (elements: [Element], \n                      predicate:(Element -> Bool)) -> [Element] {\n    var result = [Element]()\n    for element in elements {\n        if predicate(element) {\n            result.append(element)\n        }\n    }\n    return result\n}\n\n```", "```swift\nlet filteredArray = filter(elements: numbers) { $0 % 2 == 0 }\n\n```", "```swift\nfunc reduce<T>(initial: T, @noescape combine: (T, \n  Self.Generator.Element) -> T) -> T\n```", "```swift\nlet total = numbers.reduce(0) { $0 + $1 }\n\n```", "```swift\nlet total = numbers.reduce(0, combine: +)\n\n```", "```swift\nfunc reduce<Element, Value>(elements: [Element],\n                            initial: Value,\n                            combine: (Value, Element) -> Value) ->     Value {\n    var result = initial\n\n    for element in elements {\n        result = combine(result, element)\n    }\n\n    return result\n}\n\n```", "```swift\nlet total = reduce(elements: numbers, initial: 0) { $0 + $1 }\n\n```", "```swift\nfunc mapIntermsOfReduce<Element, ElementResult>(elements: [Element],\n  transform: Element -> ElementResult) -> [ElementResult] {\n    return reduce(elements: elements, initial: [ElementResult]()) {\n        $0 + [transform( $1 )]\n    }\n}\n\nlet result = mapIntermsOfReduce(elements: numbers, transform: { $0 + 2 })\n```", "```swift\nfunc filterIntermsOfReduce<Element>(elements: [Element],\n                                    predicate: Element -> Bool) -> [Element] {\n    return reduce(elements: elements, initial: []) {\n        predicate($1) ? $0 + [ $1 ] : $0\n    }\n}\n\nlet result = filterIntermsOfReduce(elements: numbers) { $0 % 2 == 0 }\n```", "```swift\nfunc flatMapIntermsOfReduce<Element>(elements: [Element],\n  transform: (Element) -> Element?) -> [Element] {\n    return reduce(elements: elements, initial: []) {\n        guard let transformationResult = transform($1) else {\n            return $0\n        }\n        return $0 + [transformationResult]\n    }\n}\n\nlet anArrayOfNumbers = [1, 3, 5]\nlet oneDimensionalArray = flatMapIntermsOfReduce(elements:\n  anArrayOfNumbers) { $0 + 5 }\n```", "```swift\nfunc flattenIntermsOfReduce<Element>(elements: [[Element]]) -> [Element] {\n    return elements.reduce([]) { $0 + $1 }\n}\n\n```", "```swift\nlet flattened = flattenIntermsOfReduce(elements: [[1, 3, 5], [2, 4, 6]])\n\n```", "```swift\nfunc apply<T, V>(fn: [T] -> V, args: [T]) -> V {\n    return fn(args)\n}\n\n```", "```swift\nlet numbers = [1, 3, 5]\n\nfunc incrementValues(a: [Int]) -> [Int] {\n    return a.map { $0 + 1 }\n}\n\nlet applied = apply(fn: incrementValues, args: numbers)\n```", "```swift\nfunc join<Element: Equatable>(elements: [Element],\n                              separator: String) -> String {\n    return elements.reduce(\"\") {\n        initial, element in\n        let aSeparator = (element == elements.last) ? \"\" : separator\n        return \"\\(initial)\\(element)\\(aSeparator)\"\n    }\n}\n\n```", "```swift\nlet items = [\"First\", \"Second\", \"Third\"]\nlet commaSeparatedItems = join(elements: items, separator: \", \")\n\n```", "```swift\nstruct User {\n    let name: String\n    let age: Int\n}\n\nlet users = [\n    User(name: \"Fehiman\", age: 60),\n    User(name: \"Negar\", age: 30),\n    User(name: \"Milo\", age: 1),\n    User(name: \"Tamina\", age: 6),\n    User(name: \"Neco\", age: 30)\n]\n\n```", "```swift\nlet totalAge = users.map { $0.age }.reduce(0) { $0 + $1 }\n\n```", "```swift\nlet alphabeticNumbers = [\"Three\", \"Five\", \"Nine\", \"Ten\"]\nlet zipped = zip(alphabeticNumbers, numbers).map { $0 }\n\n```", "```swift\nlet listOfNumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nlet sumOfNumbers = reduce(elements: listOfNumbers, initial: 0, combine: +)\n\nprint(sumOfNumbers)\n\n```", "```swift\nlet productOfNumbers = reduce(elements: listOfNumbers, initial: 1,\n  combine: *)\n\nprint(productOfNumbers)\n\n```", "```swift\nlet optionalArray: [String?] = [\"First\", \"Second\", nil, \"Fourth\"]\nlet nonOptionalArray = optionalArray.flatMap { $0 }\n\nprint(nonOptionalArray)\n\n```", "```swift\nlet arrayWithDuplicates = [1, 1, 2, 3, 3, 4, 4, 5, 6, 7]\n\narrayWithDuplicates.reduce([]) { (a: [Int], b: Int) -> [Int] in\n    if a.contains(b) {\n        return a\n    } else {\n        return a + [b]\n    }\n}\n\n```", "```swift\ntypealias Accumlator = (lPartition: [Int], rPartition: [Int])\n\nfunc partition(list: [Int], criteria: (Int) -> Bool) -> Accumlator {\n    return list.reduce((lPartition: [Int](), rPartition: [Int]())) {\n        (accumlator: Accumlator, pivot: Int) -> Accumlator in\n        if criteria(pivot) {\n            return (lPartition: accumlator.lPartition + [pivot],\n              rPartition: accumlator.rPartition)\n        } else {\n            return (rPartition: accumlator.rPartition + [pivot],\n              lPartition: accumlator.lPartition)\n        }\n    }\n}\n\nlet numbersToPartition = [3, 4, 5, 6, 7, 8, 9]\npartition(list: numbersToPartition) { $0 % 2 == 0 }\n\n```", "```swift\nfunc genericPartition<T>(list: [T],\n                         criteria: (T) -> Bool) -> (lPartition: \n[T], \n                         rPartition: [T]) {\n    return list.reduce((lPartition: [T](), rPartition: [T]())) {\n        (accumlator: (lPartition: [T], rPartition: [T]), pivot: T) -> (\n          lPartition: [T], rPartition: [T]) in\n        if criteria(pivot) {\n            return (lPartition: accumlator.lPartition + [pivot],\n              rPartition: accumlator.rPartition)\n        } else {\n            return (rPartition: accumlator.rPartition + [pivot],\n              lPartition: accumlator.lPartition)\n        }\n    }\n}\n\nlet doublesToPartition = [3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]\nprint(genericPartition(list: doublesToPartition) { $0.truncatingRemainder(dividingBy: 2.0) == 0 })\n```"]