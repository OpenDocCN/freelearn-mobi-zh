- en: '*Chapter 3*: Using Lists and Tables'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：使用列表和表格'
- en: There's a good chance that you have built a simple app before, or maybe you
    have tried but didn't quite succeed. If this is the case, you have likely used
    `UITableView` or `UICollectionView`, as both are core components of many iOS applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 很有可能您之前已经构建了一个简单的应用，或者您可能尝试过但并未完全成功。如果是这种情况，您可能已经使用了`UITableView`或`UICollectionView`，因为这两个都是许多iOS应用的核心组件。
- en: If an app shows a list of items, it was likely built using `UITableView`. This
    chapter will ensure that you are up to speed with the ins and outs of `UITableView`
    and `UICollectionView`. In addition to covering the basics, such as how we use
    the delegation pattern, you'll also learn how to access users' data – in this
    case, their contacts – which will be rendered in a `UITableView` and `UICollectionView`
    object.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个应用显示项目列表，它很可能是使用`UITableView`构建的。本章将确保您熟悉`UITableView`和`UICollectionView`的方方面面。除了涵盖基础知识，例如我们如何使用代理模式，您还将学习如何访问用户数据——在这种情况下，他们的联系人——这些数据将在`UITableView`和`UICollectionView`对象中呈现。
- en: We'll finish this chapter by taking a look at lists in SwiftUI, Apple's new
    UI framework announced back in 2019\. We'll touch on the fundamental differences
    between what SwiftUI and UIKit have to offer.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将本章的结尾放在查看SwiftUI中的列表上，这是苹果在2019年宣布的新UI框架。我们将探讨SwiftUI和UIKit提供的根本区别。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Working with `UITableView`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`UITableView`
- en: Exploring table views further
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进一步探索表格视图
- en: Working with `UICollectionView`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`UICollectionView`
- en: Exploring collection views further
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进一步探索集合视图
- en: Working with lists in SwiftUI
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在SwiftUI中使用列表
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you'll need to download Xcode version 11.4 or above from Apple's
    App Store.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要从Apple的App Store下载Xcode版本11.4或更高版本。
- en: You'll also need to be running the latest version of macOS (Catalina or above).
    Simply search for Xcode in the App Store, and select and download the latest version.
    Launch Xcode and follow any additional installation instructions that your system
    may prompt you with. Once Xcode has fully launched, you're ready to go.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要运行最新版本的macOS（Catalina或更高版本）。只需在App Store中搜索Xcode，选择并下载最新版本。启动Xcode，并遵循系统可能提示的任何其他安装说明。一旦Xcode完全启动，您就可以开始了。
- en: 'Download the sample code from the following GitHub link:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下GitHub链接下载示例代码：
- en: '[https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition)'
- en: Working with UITableView
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用UITableView
- en: In this section, we'll start by taking a look at `UITableView`, one of the most
    – if not *the* most – common ways of displaying data in a list in iOS.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先查看`UITableView`，这是在iOS中显示列表数据最常见——如果不是*最*常见的方法之一。
- en: Setting up the project
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置项目
- en: Every time you start a new project in Xcode, you have the option to pick a template
    for your app. Every template contains a small amount of code or some boilerplate
    code to get you started. In most cases, a basic layout will even be set up for
    you. Throughout this book, you should default to using the **Single View App**
    template. Don't be fooled by its name; you can add as many views to your app as
    you would like. This template just provides you with one view to start with.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每次您在Xcode中开始一个新项目时，您都有选择为您的应用选择模板的选项。每个模板都包含一小部分代码或一些样板代码以帮助您开始。在大多数情况下，甚至已经为您设置了一个基本布局。在本书中，您应该默认使用**单视图应用**模板。不要被它的名字所迷惑；您可以为您的应用添加尽可能多的视图。这个模板只是为您提供了一个视图以开始。
- en: In this chapter, you will create an app that is called My Contacts. This app
    displays your user's contacts list in a `UITableView` component that you will
    set up. Let's create a project for this app right now.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将创建一个名为My Contacts的应用。这个应用将在您设置的`UITableView`组件中显示用户的联系人列表。现在让我们为这个应用创建一个项目。
- en: 'In the menu bar, do the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在菜单栏中，执行以下操作：
- en: Select **File** | **New** | **Project**.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**文件** | **新建** | **项目**。
- en: Select **Single View App**.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**单视图应用**。
- en: Name your project `Contacts List` or anything you like.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的项目命名为`联系人列表`或您喜欢的任何名称。
- en: Make sure your programming language is set to **Swift** and the user interface
    is set to **Storyboard** – it should resemble something like the following:![Figure
    3.1 – Xcode new project options
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的编程语言设置为**Swift**，用户界面设置为**Storyboard**——它应该类似于以下内容：![图3.1 – Xcode新项目选项
- en: '](img/Figure_3.01_B14717.jpg)'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure_3.01_B14717.jpg](img/Figure_3.01_B14717.jpg)'
- en: Figure 3.1 – Xcode new project options
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.1 – Xcode新项目选项
- en: From here, click **Next** and then **Create**.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这里，点击**下一步**然后点击**创建**。
- en: Once your project has loaded, open the file named `Main.storyboard` found in
    the navigation tree to the left-hand side.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您的项目加载完成，打开左侧导航树中名为`Main.storyboard`的文件。
- en: The storyboard file is used to lay out all of your application's views and to
    connect them to the code you write. The editor you use to manipulate your storyboard
    is called Interface Builder.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 故事板文件用于布局您应用程序的所有视图，并将它们连接到您编写的代码。您用于操作故事板的编辑器称为界面构建器。
- en: If you have used `UITableView` in the past, you may have used `UITableViewController`.
    The `UITableViewController` class is a subclass of a regular `UIViewController`
    class.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前使用过`UITableView`，您可能使用过`UITableViewController`。`UITableViewController`类是一个常规`UIViewController`类的子类。
- en: The difference is that `UITableViewController` contains a lot of setup that
    you would otherwise have to perform on your own, either in Interface Builder or
    programmatically. To fully understand how `UITableView` is configured and set
    up, we won't use `UITableViewController` in this example.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于`UITableViewController`包含了许多您否则必须自己执行设置，无论是在界面构建器中还是通过编程方式。为了完全理解`UITableView`是如何配置和设置的，我们在这个例子中不会使用`UITableViewController`。
- en: 'Back in Xcode, you''ll notice a button at the top right that has a plus symbol
    on it. Click on this to bring up the object explorer. Once opened, search for
    `Table View`. If you begin typing the name of a potential component, you should
    see a list of suggested options become available – just like in the following
    screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xcode中，您会注意到右上角有一个带有加号符号的按钮。点击此按钮以打开对象浏览器。一旦打开，搜索`Table View`。如果您开始输入潜在组件的名称，您应该会看到一系列建议选项变得可用——就像以下截图所示：
- en: '![Figure 3.2 – Adding an object'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.2 – 添加对象'
- en: '](img/Figure_3.02_B14717.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_3.02_B14717.jpg](img/Figure_3.02_B14717.jpg)'
- en: Figure 3.2 – Adding an object
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 添加对象
- en: Once you find **Table View**, drag it straight onto your canvas in Interface
    Builder. Don't worry about it being placed awkwardly, we're going to fix that
    now by using Auto Layout to add some constraints.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到**表格视图**，直接将其拖动到界面构建器中的画布上。不用担心它放置得是否尴尬，我们现在将通过使用自动布局添加一些约束来修复这个问题。
- en: 'Inside our canvas, highlight the `UITableView` object we just added and click
    on the icon highlighted in the following screenshot. Add in top, leading, trailing,
    and bottom constraints of `0`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的画布中，突出显示我们刚刚添加的`UITableView`对象，然后点击以下截图中突出显示的图标。添加顶部、前导、尾部和底部约束为`0`：
- en: '![Figure 3.3 – Setting constraints'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.3 – 设置约束'
- en: '](img/Figure_3.03_B14717.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_3.03_B14717.jpg](img/Figure_3.03_B14717.jpg)'
- en: Figure 3.3 – Setting constraints
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 设置约束
- en: Once done, click `UITableView` object is now pinned perfectly to each edge of
    your screen. Regardless of what size device this is displayed on, those constraints
    will also be adhered to.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，点击`UITableView`对象，使其完美地固定在屏幕的每个边缘。无论在什么尺寸的设备上显示，这些约束也将得到遵守。
- en: Auto Layout enables you to create layouts that automatically adapt to any screen
    size that exists. Your layout currently uses fixed coordinates and dimensions
    to lay out the table view. For instance, your table view is set up to be positioned
    at 0, with a size of (375, 667). This size is perfect for devices such as the
    iPhone 8 and SE, but it wouldn't fit nicely with the iPhone 11 or iPad Pro. This
    combination of a view's position and size is called the frame.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 自动布局使您能够创建能够自动适应任何现有屏幕大小的布局。您当前的布局使用固定坐标和尺寸来布局表格视图。例如，您的表格视图被设置为在0的位置，大小为（375，667）。这个大小非常适合iPhone
    8和SE等设备，但与iPhone 11或iPad Pro不太搭配。一个视图的位置和尺寸的组合被称为框架。
- en: Auto Layout uses constraints to define a layout instead of a frame. For instance,
    to make the table view fit the entire screen, you would add constraints that pin
    every edge of the table view to the corresponding edge of its superview. Doing
    so would make the table view match its superview's size at all times.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 自动布局使用约束来定义布局而不是框架。例如，为了使表格视图适应整个屏幕，您会添加约束，将表格视图的每个边缘固定到其父视图的相应边缘。这样做会使表格视图始终匹配其父视图的大小。
- en: Fetching contacts data
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取联系人数据
- en: In order for us to be able to fetch the user's contacts from our device, we
    first need to be granted access via the `Contacts` framework.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们能够从我们的设备中获取用户的联系人信息，我们首先需要通过`Contacts`框架获得访问权限。
- en: Apple are really heavy on privacy, so in turn, they require the user to "allow"
    access whenever an app first tries to read from the Address Book. This doesn't
    just stop at the Address Book, too; this can be found for camera access, location
    services, photos, and more.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果对隐私保护非常重视，因此，每当一个应用第一次尝试从地址簿中读取时，他们要求用户“允许”访问。这不仅仅局限于地址簿；这同样适用于相机访问、位置服务、照片等等。
- en: As in our case, when you need to access privacy-sensitive information, you are
    required to specify a reason as to why you would like to access the information.
    Nothing too detailed – but enough to give the user peace of mind as to why you
    would like to access their data.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的情况一样，当你需要访问隐私敏感信息时，你必须指定一个原因，说明你为什么想要访问这些信息。不需要太详细——但足以让用户放心，知道你为什么想要访问他们的数据。
- en: This is done by adding an entry to the `Info.plist` file in your project. Whenever
    you need access to privacy-sensitive information, you are required to specify
    this in your app's `Info.plist` file.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过在你的项目中添加一个条目到`Info.plist`文件来完成。每次你需要访问隐私敏感信息时，你都需要在你的应用的`Info.plist`文件中指定这一点。
- en: 'In order to add this information to `Info.plist`, take the following steps:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将此信息添加到`Info.plist`中，请按照以下步骤操作：
- en: Open it from the list of files in the Project navigator on the left.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左侧的项目导航器中的文件列表中打开它。
- en: Once opened, hover over the words `Information Property List` at the top of
    the file.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦打开，将鼠标悬停在文件顶部的`信息属性列表`上。
- en: A plus icon should appear. Clicking it adds a new empty item with a search field
    to the list.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该会出现一个加号图标。点击它将在列表中添加一个新的空条目，并带有搜索字段。
- en: When you begin typing `Privacy – contacts`, Xcode will filter out options for
    you until there is only one left for you to pick.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你开始输入`隐私 - 联系人`时，Xcode会为你过滤选项，直到只剩下一个选项供你选择。
- en: This option is called **Privacy – Contacts Usage Description** and is the key
    we are looking for.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个选项被称为**隐私 - 联系人使用描述**，这是我们正在寻找的键。
- en: The value for this newly added key should describe the reason that you need
    access to the specified piece of information. In this case, "reads contacts and
    shows them in a list" should be a sufficient explanation. When the user is asked
    for permission to access their contacts, the reason you specified here will be
    shown, so make sure you add an informative message.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新添加的键的值应该描述你需要访问指定信息的原因。在这种情况下，“读取联系人并在列表中显示它们”应该是一个充分的解释。当用户被要求允许访问他们的联系人时，你在这里指定的原因将会显示，所以请确保你添加一个信息性的消息。
- en: Tip
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Make sure you do choose an informative message that is relevant to your app.
    If Apple review this and don't find it to be acceptable, they could question you,
    or even worse, reject the submission of your app.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你选择一个与你的应用相关的信息性消息。如果苹果审查后认为这不合适，他们可能会质疑你，甚至更糟糕的是，拒绝你的应用提交。
- en: Now, let's get down to writing some code. Before you can read contacts, you
    must make sure that the user has given the appropriate permissions for you to
    access the contacts data. To do this, the code must first read the current permission
    status. Once done, the user must either be prompted for permission to access their
    contacts, or the contacts must be fetched.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始编写一些代码。在你能够读取联系人之前，你必须确保用户已经为你提供了适当的权限来访问联系人数据。为此，代码必须首先读取当前的权限状态。一旦完成，用户必须被提示允许访问他们的联系人，或者必须获取联系人信息。
- en: 'Add the following highlighted code to `ViewController.swift`; we''ll cover
    the details a section at a time – but don''t worry, it will all make sense in
    the end:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下高亮代码添加到`ViewController.swift`中；我们将分部分介绍细节——但别担心，最终一切都会变得清晰：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To start, we've imported `Contacts` into our `ViewController` class; by doing
    this, we're allowing the `Contacts` framework API to not just be inside our project,
    but specifically in our `ViewController` class.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`Contacts`框架导入到我们的`ViewController`类中；通过这样做，我们允许`Contacts`框架API不仅存在于我们的项目中，而且特别存在于我们的`ViewController`类中。
- en: 'Next, we''ve added a call to a function named `requestContacts` in `viewDidLoad()`
    – we''ll now need to create this function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在`viewDidLoad()`中添加了对名为`requestContacts`的函数的调用——我们现在需要创建这个函数：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Basically, without going into too many details, this forces iOS (if not already)
    to request permission for your app to access the contacts data. If the current
    status is unknown (or `notDetermined`), then permission will be requested. If
    this is not the case and the framework responds with `didAuthorize == true`, then
    we can now attempt to access the contacts information. We've also added an extra
    condition in there too to check whether we have already previously been authorized.
    You'll notice that `store.requestAccess` looks a little different from a regular
    function call; this is because it uses a completion handler.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，不深入太多细节，这强制 iOS（如果尚未）请求授权你的应用程序访问联系人数据。如果当前状态是未知的（或 `notDetermined`），则将请求权限。如果情况不是这样，并且框架响应
    `didAuthorize == true`，那么我们现在可以尝试访问联系人信息。我们还在其中添加了一个额外的条件来检查我们是否已经被授权。你会注意到 `store.requestAccess`
    的调用看起来与常规函数调用略有不同；这是因为它使用了一个完成处理程序。
- en: 'In asynchronous programming, completion handlers are used often. They allow
    your app to perform some work in the background and then call the completion handler
    when the work is completed. You will find completion handlers throughout many
    frameworks. If you implement a very simple function of your own that takes a callback,
    it might look as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步编程中，经常使用完成处理程序。它们允许你的应用程序在后台执行一些工作，然后在工作完成后调用完成处理程序。你将在许多框架中找到完成处理程序。如果你实现了一个非常简单的带有回调的功能，它可能看起来如下所示：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Calling a completion-handler looks just like calling a function. The reason
    for this is that a completion handler is a block of code, called a closure. Closures
    are a lot like functions because they both contain a potentially reusable block
    of code that is expected to be executed when called.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 调用一个完成处理程序就像调用一个函数一样。之所以这样做，是因为完成处理程序是一段代码，称为闭包。闭包与函数非常相似，因为它们都包含一个可能可重用的代码块，预期在调用时执行。
- en: 'Now, let''s add our final piece of the puzzle by adding in our function to
    retrieve the contacts:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过添加我们的函数来检索联系人，来完成拼图的最后一块：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A brief explanation of the preceding code: we pass an instance of `CNContactStore`
    (which we''ve previously been given permission to access), and then we set up
    a request for specific information we would like with the array of `CNKeyDescriptor`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对前面代码的简要说明：我们传递一个 `CNContactStore` 的实例（我们之前已被授权访问），然后使用 `CNKeyDescriptor` 数组设置我们想要获取的特定信息请求。
- en: Finally, the call is made and will fetch this information, which is returned
    to us in a `CNContact` object.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用被发起，并将获取到的信息以 `CNContact` 对象的形式返回给我们。
- en: Prepping UITableView to display our contacts
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备 `UITableView` 来显示我们的联系人
- en: 'With all that ready, let''s head on back to Interface Builder and add in a
    table view cell:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 准备就绪后，让我们回到 Interface Builder 中，添加一个表格单元格：
- en: Highlight the `UITableView` object we added to the canvas.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高亮显示我们添加到画布上的 `UITableView` 对象。
- en: Click on the `Table View Cell`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `Table View Cell`。
- en: Now, drag this object onto `UITableView`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将这个对象拖到 `UITableView` 上。
- en: 'You''ll notice something a little different this time: the `UITableViewCell`
    object that we dragged automatically snapped into position on our `UITableView`
    object – don''t worry, that''s fine, this is because `UITableViewCell`''s position
    is controlled by the configuration of its `UITableView` object. Next, we are going
    to create an `IBOutlet` for our code. In the same way that we did in [*Chapter
    2*](B14717_02_Final_ASB_ePub.xhtml#_idTextAnchor046), *Working with Dark Mode*,
    create an outlet programmatically in your `ViewController.swift` file, and then
    connect these using Interface Builder.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这次有一点不同：我们拖动的 `UITableViewCell` 对象自动吸附到了我们的 `UITableView` 对象的位置上——别担心，这是正常的，这是因为
    `UITableViewCell` 的位置是由其 `UITableView` 对象的配置控制的。接下来，我们将为我们的代码创建一个 `IBOutlet`。就像我们在
    [*第2章*](B14717_02_Final_ASB_ePub.xhtml#_idTextAnchor046) 中所做的那样，*使用暗黑模式*，在 `ViewController.swift`
    文件中以编程方式创建一个出口，然后使用 Interface Builder 连接它们。
- en: 'Here is an example of the outlet you are going to create:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是你将要创建的出口的示例：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, we need to create a class for `UITableViewCell` – by doing this, we can
    add custom properties to `UITableViewCell`, such as a name, contact information,
    or even an image.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为 `UITableViewCell` 创建一个类——通过这样做，我们可以向 `UITableViewCell` 添加自定义属性，例如姓名、联系信息，甚至图片。
- en: 'Back inside our `ViewController.swift` file (but outside of the `ViewController`
    class declaration), add the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `ViewController.swift` 文件内部（但不在 `ViewController` 类声明外部），添加以下代码：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we've created our custom cell, which is a subclass of `UITableViewCell`
    and will carry all the traits of a table view cell that we need. I've also added
    a couple of `IBOutlet` components for the data that we are going to display.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个自定义单元格，它是 `UITableViewCell` 的子类，并将携带我们需要的所有表格视图单元格特性。我还为将要显示的数据添加了一些
    `IBOutlet` 组件。
- en: Now, let's go hook this up. Head on back to Interface Builder and select the
    `UITableViewCell` object that we added.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将其连接起来。回到 Interface Builder，并选择我们添加的 `UITableViewCell` 对象。
- en: 'Once highlighted, click on the Identity inspector in the right-hand tool window
    and add `ContactCell` as the **Class** name:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦高亮显示，点击右侧工具窗口中的 Identity 检查器，并将 `ContactCell` 作为 **类名** 添加：
- en: '![Figure 3.4 – Table view class'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.4 – 表格视图类](img/Figure_3.04_B14717.jpg)'
- en: '](img/Figure_3.04_B14717.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.4 – 表格视图类](img/Figure_3.04_B14717.jpg)'
- en: Figure 3.4 – Table view class
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 表格视图类
- en: 'Then, click on the Attributes Inspector and type in `contactCell` for **Identifier**:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，点击属性检查器，并输入 `contactCell` 作为 **标识符**：
- en: '![Figure 3.5 – Table view cell identifier'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.5 – 表格视图单元格标识符](img/Figure_3.05_B14717.jpg)'
- en: '](img/Figure_3.05_B14717.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.5 – 带约束的标签](img/Figure_3.05_B14717.jpg)'
- en: Figure 3.5 – Table view cell identifier
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 表格视图单元格标识符
- en: Overriding `UITableViewCell`'s class to our custom class will allow us to use
    Interface Builder to connect objects to the `IBOutlet` components that we just
    created. We'll touch on the identifier later on in this chapter, but it's always
    good to get these bits out of the way at the start.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `UITableViewCell` 的类覆盖为我们自定义的类，这将允许我们使用 Interface Builder 将对象连接到我们刚刚创建的 `IBOutlet`
    组件。我们将在本章后面讨论标识符，但一开始就处理这些事情总是好的。
- en: Now, let's add a couple of objects to `UITableViewCell`. We'll start with `UILabel`,
    and then `UIImageView` (add these in the same way you did the table view and cell
    – have the image to the left of the cell).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们向 `UITableViewCell` 添加一些对象。我们首先从 `UILabel` 开始，然后是 `UIImageView`（以相同的方式添加表格视图和单元格——图片位于单元格的左侧）。
- en: Once added, have a play with the `Autolayout` constraints we learned about earlier.
    The best way to master Auto Layout is trial and error - if you get stuck, just
    refer to the sample project for this chapter to guide you along.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 添加后，尝试使用我们之前学到的 `Autolayout` 约束。掌握 Auto Layout 的最好方法是试错——如果你卡住了，只需参考本章的示例项目来引导你。
- en: 'Once you are done, your cell will look something like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你的单元格将看起来像这样：
- en: '![Figure 3.6 – Label with constraints'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.6 – 带约束的标签](img/Figure_3.06_B14717.jpg)'
- en: '](img/Figure_3.06_B14717.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.6 – 带约束的标签](img/Figure_3.06_B14717.jpg)'
- en: Figure 3.6 – Label with constraints
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 带约束的标签
- en: Now, let's hook each one of these up to the `IBOutlet` components we created
    – all going well, Interface Builder should pick up on the associated class (`ContactCell`)
    and will allow the outlets to be attached without any problems.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这些连接到我们创建的 `IBOutlet` 组件——如果一切顺利，Interface Builder 应该会识别关联的类（`ContactCell`），并将允许无问题地连接出口。
- en: Awesome, we're making great progress, and believe it or not, we're not a million
    miles away from displaying the data in our app – but first, we need to cover some
    important fundamentals of `UITableView` and, more importantly, the delegation
    pattern that iOS used so heavily.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，我们正在取得很大的进步，信不信由你，我们离在应用中显示数据已经不远了——但首先，我们需要了解一些 `UITableView` 的重要基础，更重要的是，iOS
    严重依赖的委托模式。
- en: Understanding protocols and delegation
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解协议和委托
- en: Throughout the iOS SDK and the Foundation framework, a design pattern named
    delegation is used. Delegation allows an object to have another object to perform
    work on its behalf.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个 iOS SDK 和 Foundation 框架中，使用了一个名为委托的设计模式。委托允许一个对象让另一个对象代表它执行工作。
- en: When implemented correctly, it's a great way to separate concerns and decouple
    code within your app.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当正确实现时，这是一种很好的方法，可以在你的应用中分离关注点并解耦代码。
- en: The table view uses the help of two objects to function correctly. One is the
    delegate, and the other is the data source. Any time you use a table view, you
    must configure these two objects yourself. When the time comes for the table view
    to render its contents, it asks data source for information about the data to
    display. The delegate comes into play when a user interacts with the items in
    the table view.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 表格视图使用两个对象来正确运行。一个是委托，另一个是数据源。每次使用表格视图时，你必须自己配置这两个对象。当表格视图需要渲染其内容时，它会向数据源请求有关要显示的数据的信息。当用户与表格视图中的项目交互时，委托就会发挥作用。
- en: If you look at the documentation for `UITableView`, you can find the delegate
    property. The type for delegate is `UITableViewDelegate?`. This tells you two
    things about delegate. First of all, `UITableViewDelegate` is a protocol. This
    means that any object can act as a delegate for a table view, as long as it implements
    the `UITableViewDelegate` protocol. Second, the question mark at the end of the
    type name tells you that the delegate is an optional property. An optional property
    either has a value of the specified type, or it is nil. The table view's delegate
    property is optional because you do not have to set it to create a functioning
    table view.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`UITableView`的文档，你可以找到代理属性。代理的类型是`UITableViewDelegate?`。这告诉你关于代理的两件事。首先，`UITableViewDelegate`是一个协议。这意味着任何对象都可以作为表格视图的代理，只要它实现了`UITableViewDelegate`协议。其次，类型名称末尾的问号告诉你代理是一个可选属性。可选属性要么具有指定的类型值，要么是nil。表格视图的代理属性是可选的，因为你不必设置它来创建一个功能正常的表格视图。
- en: A protocol, such as `UITableViewDelegate`, defines a set of properties and methods
    that must be implemented by any type that wants to conform to the protocol. Not
    all methods must be explicitly implemented by conforming objects. Sometimes, a
    protocol extension provides a reasonable default implementation.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 协议，例如`UITableViewDelegate`，定义了一组必须由任何想要遵守该协议的类型实现的属性和方法。并非所有方法都必须由遵守对象显式实现。有时，协议扩展提供了一个合理的默认实现。
- en: 'In addition to delegate, `UITableView` has a data source property. data source''s
    type is `UITableViewDataSource?`, and just like `UITableViewDelegate`, `UITableViewDataSource`
    is a protocol. However, `UITableViewDelegate` only has optional methods, meaning
    you don''t need to implement any methods to conform to `UITableViewDelegate`.
    `UITableViewDataSource` does have required methods: the methods that need to be
    implemented are used to provide the table view with just enough information to
    be able to display the correct number of cells with the right content in them.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 除了代理之外，`UITableView`还有一个数据源属性。数据源的类型是`UITableViewDataSource?`，就像`UITableViewDelegate`一样，`UITableViewDataSource`也是一个协议。然而，`UITableViewDelegate`只有可选方法，这意味着你不需要实现任何方法来遵守`UITableViewDelegate`。`UITableViewDataSource`确实有一些必需的方法：需要实现的方法用于向表格视图提供足够的信息，以便能够显示正确数量的单元格，并包含正确的内容。
- en: If this is the first time you're learning about protocols and delegation, you
    might feel a little bit lost right now. That's OK; you'll get the hang of it soon.
    Throughout this book, your understanding of topics such as these will improve
    bit by bit. You will even learn about a concept called protocol-oriented programming!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是你第一次学习关于协议和委派的内容，你现在可能会感到有些迷茫。没关系；你很快就会掌握的。在这本书的整个过程中，你对这些主题的理解将逐步提高。你甚至还会了解到一个叫做协议导向编程的概念！
- en: For now, you must understand that a table view asks for a different object for
    the data it needs to show and that it also uses a different object to handle certain
    user interactions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你必须理解表格视图会请求一个不同的对象来显示所需的数据，并且它还会使用一个不同的对象来处理某些用户交互。
- en: 'We can break the flow of displaying content in a table view down into a couple
    of steps; when the table view needs to reload the data, it does the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将表格视图显示内容的流程分解为几个步骤；当表格视图需要重新加载数据时，它会执行以下操作：
- en: The table view checks whether `dataSource` is set, and asks it for the number
    of sections it should render.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表格视图会检查`dataSource`是否已设置，并请求它提供它应该渲染的分区数量。
- en: Once the number of sections is passed back to the table view, `dataSource` is
    asked for the number of items for each section.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦将分区数量传回表格视图，就会要求`dataSource`为每个分区提供项目数量。
- en: With knowledge about the number of sections and items that need to be shown,
    the table view asks `dataSource` for the cells it should display.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在了解需要显示的分区和项目数量后，表格视图会请求`dataSource`提供它应该显示的单元格。
- en: After receiving all of the configured cells, the table view can finally render
    these cells to the screen.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接收到所有配置好的单元格后，表格视图最终可以将这些单元格渲染到屏幕上。
- en: These steps should give you a little bit more insight into how a table view
    uses another object to figure out the contents it should render. This pattern
    is compelling because it makes the table view an extremely flexible component.
    Let's put some of this newfound knowledge to use!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤应该能让你对表格视图如何使用另一个对象来确定它应该渲染的内容有更深入的了解。这种模式很有吸引力，因为它使表格视图成为一个极其灵活的组件。让我们将一些新获得的知识付诸实践！
- en: Conforming to the UITableView protocols
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 符合 `UITableView` 协议
- en: To make `ViewController` both the delegate and the data source for its table
    view, it will have to conform to both protocols. It is a best practice to create
    an extension whenever you make an object conform to a protocol. Ideally, you make
    one extension for each protocol you want to implement. Doing this helps to keep
    your code clean and maintainable.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 `ViewController` 同时成为其表格视图的代理和数据源，它必须符合这两个协议。创建扩展以使对象符合协议是一种最佳实践。理想情况下，为每个要实现的协议创建一个扩展。这样做有助于保持代码的整洁和可维护性。
- en: 'Add the following extension to `ViewController.swift`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下扩展添加到 `ViewController.swift`：
- en: '[PRE6]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After doing this, your code contains an error. That's because none of the required
    methods from `UITableViewDataSource` have been implemented yet.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样做之后，您的代码中包含了一个错误。这是因为还没有实现 `UITableViewDataSource` 所需的任何方法。
- en: 'There are two methods you need to implement to conform to `UITableViewDataSource`.
    These methods are the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要实现两个方法来符合 `UITableViewDataSource` 协议。这些方法如下：
- en: '`tableView(_:numberOfRowsInSection:)`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tableView(_:numberOfRowsInSection:)`'
- en: '`tableView(_:cellForRowAt:)`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tableView(_:cellForRowAt:)`'
- en: Let's go ahead and fix the error Xcode is showing by adjusting the code a little
    bit. We'll also need to make a couple of small changes to display our contacts
    within our table view.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续修复 Xcode 显示的错误，通过稍微调整代码。我们还需要对代码进行一些小的修改，以便在表格视图中显示我们的联系人。
- en: 'We''ll start by adding a global variable to our `ViewController` class. Add
    in the following just after the class declaration:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从向 `ViewController` 类添加一个全局变量开始。在类声明之后添加以下内容：
- en: '[PRE7]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we've instantiated an array of `CNContact`, which is what we get back
    in our `retrieveContacts` function when `store.unifiedContacts` is called.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们实例化了一个 `CNContact` 数组，这是我们调用 `store.unifiedContacts` 时在 `retrieveContacts`
    函数中返回的内容。
- en: 'Now, make the following modification to our `retrieveContacts` function:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对我们的 `retrieveContacts` 函数进行以下修改：
- en: '[PRE8]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Perfect – now fill in the blanks with those delegates:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！现在用那些代理填充空白：
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our first delegate method, `tableView(_:numberOfRowsInSection:)`, requires us
    to return the number of cells we want to display. As we want to display all of
    our contacts, we simply pass back the number of contacts in our array, as highlighted
    in the preceding code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个代理方法 `tableView(_:numberOfRowsInSection:)` 要求我们返回我们想要显示的单元格数。由于我们想要显示所有联系人，我们只需将数组中的联系人数量返回，如前述代码中突出显示的那样。
- en: 'Next, let''s implement the `tableView(_:cellForRowAt:)` delegate. Copy in the
    following code and we''ll go through it one step at a time:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们实现 `tableView(_:cellForRowAt:)` 代理。复制以下代码，我们将一步一步地分析它：
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Basically, this delegate method is called for every cell that is going to be
    generated in our table view, so if `contacts.count == 5`, then this will be called
    5 times. A way for us to identify which cell is currently being called is to inspect
    the `indexPath.row` value that is being passed in with each call.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这个代理方法为将要生成的每个单元格调用，所以如果 `contacts.count == 5`，那么这将被调用5次。我们可以通过检查每次调用中传递的
    `indexPath.row` 值来识别当前被调用的单元格。
- en: If you take a look at the first line of code with the preceding delegate, you'll
    see that we have accessed the specific contact by querying our array of `CNContact`
    with the `indexPath.row` value. From this, we simply just create an instance of
    `UITableViewCell`, assign a property of `CNContact` to `.textLabel`, and return
    the instance.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看带有先前代理的第一行代码，您会看到我们通过查询 `indexPath.row` 值的 `CNContact` 数组来访问特定的联系人。从这个值，我们只是创建一个
    `UITableViewCell` 实例，将 `CNContact` 的一个属性分配给 `.textLabel`，然后返回该实例。
- en: We're almost ready to see our changes in action; just a couple more things to
    add in.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎准备好看到我们的更改生效了；只需添加一些其他内容即可。
- en: 'Head on back to our `viewDidLoad()` function and add the following highlighted
    lines:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的 `viewDidLoad()` 函数，并添加以下突出显示的行：
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we are telling our `UITableView` instance that our current `ViewController`
    class is the delegate base for all `UITableView` protocol operations. In a nutshell
    – the delegates we just added will get called when we try to perform any actions
    on our table view.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在告诉我们的 `UITableView` 实例，我们的当前 `ViewController` 类是所有 `UITableView` 协议操作的代理基础。简而言之——我们刚刚添加的代理将在我们尝试对表格视图执行任何操作时被调用。
- en: 'Finally, add the following highlighted code to the end of our `retrieveContacts`
    functions:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将以下突出显示的代码添加到我们的 `retrieveContacts` 函数的末尾：
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The reason we do this is again down to asynchronous programming. By design,
    our table view will try and display data as soon as `ViewController` is loaded.
    At this point, our contacts may not be available, we may have not been given suitable
    permission, or simply, the function's callback may not have returned all the data
    in time.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做的原因再次归结于异步编程。按照设计，我们的表格视图将在 `ViewController` 加载后立即尝试显示数据。此时，我们的联系人可能不可用，我们可能没有获得适当的权限，或者简单地，函数的回调可能没有及时返回所有数据。
- en: 'So, if that''s the case, once we know that all the data is ready to be displayed,
    we simply ask the table view to reload. Go ahead and run your app in the simulator
    – all going well, you will be prompted by the `Contacts` framework to allow permission
    to access your contacts, shortly followed by a list of contact details:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们知道所有数据都准备好显示，我们只需要求表格视图重新加载即可。现在，请在模拟器中运行你的应用程序——如果一切顺利，你将被 `Contacts`
    框架提示允许访问你的联系人权限，随后将显示联系人详细信息列表：
- en: '![Figure 3.7 – User consent and user list'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.7 – 用户同意和用户列表'
- en: '](img/Figure_3.07_B14717.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.07_B14717.jpg)'
- en: Figure 3.7 – User consent and user list
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 用户同意和用户列表
- en: In this part, we learned about how important protocols and delegates are in
    iOS development, and by hooking up a couple of simple functions, we were able
    to easily yet effectively display data in `UITableView`. Now, let's take a look
    at how we can customize each cell some more, with the `UITableViewCell` override
    we created earlier.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们了解了在 iOS 开发中协议和代理有多么重要，通过连接几个简单的函数，我们能够轻松而有效地在 `UITableView` 中显示数据。现在，让我们看看我们如何使用我们之前创建的
    `UITableViewCell` 重写来进一步自定义每个单元格。
- en: Understanding the custom UITableViewCell override and the reuse identifier
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解自定义 `UITableViewCell` 重写和重用标识符
- en: Back in a previous section, *Prepping UITableView to display our contacts*,
    you'll remember that we created our custom `UITableViewCell` override called `ContactCell`,
    but in the end we never really used it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分，*准备 `UITableView` 显示我们的联系人*，你会记得我们创建了一个自定义的 `UITableViewCell` 重写 `ContactCell`，但最终我们并没有真正使用它。
- en: We did this on purpose, firstly to introduce you to the fact that `UITableViewCell`
    does have a minimal default offering where `textLabel` is given for you to add
    your required text. This can come in handy as a really lightweight way of generating
    a `UITableView` object and displaying some simple data – a no-fuss approach for
    quick wins or a situation where one line is good enough. However, if you want
    to be creative with your cells, then this is where the custom option comes into
    play.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意这样做，首先是为了让你了解 `UITableViewCell` 确实有一个最小的默认提供，其中 `textLabel` 是为你添加所需文本而提供的。这可以作为一个非常轻量级的方式来生成
    `UITableView` 对象并显示一些简单数据——这是一个无需麻烦的快速获胜方法，或者当一行就足够时的情况。然而，如果你想对你的单元格进行创意设计，那么这就是自定义选项发挥作用的地方。
- en: 'Let''s head back to `tableView(_:cellForRowAt:)` and see how we''d make the
    change:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 `tableView(_:cellForRowAt:)` 方法，看看我们如何进行更改：
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, to start with, let''s take a look at the first part:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，首先，让我们看看第一部分：
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we are instantiating the use of a reusable `UITableViewCell` with the
    identifier of `contactCell`, which is of the `ContactCell` class.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用标识符为 `contactCell` 的可重用 `UITableViewCell` 来实例化 `ContactCell` 类。
- en: Sounds confusing? Maybe a little, but think of it this way – we created a custom
    cell class that we assigned to our `UITableViewCell` object back in Interface
    Builder. We then gave this an identifier of `contactCell` – here, we simply called
    upon that cell to be used so that we can access its properties (remember the `nameLabel`
    and `contactImageView` properties we added).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很复杂？也许有一点，但这样想——我们创建了一个自定义的单元格类，并在 Interface Builder 中将其分配给我们的 `UITableViewCell`
    对象。然后我们给它一个 `contactCell` 的标识符——在这里，我们只是调用该单元格以供使用，这样我们就可以访问其属性（记住我们添加的 `nameLabel`
    和 `contactImageView` 属性）。
- en: Once we have access to an instance of that cell, we can then simply assign each
    property accordingly with data taken from our contact instance. Notice that we're
    doing a check against the image data in the contacts due to the possibility of
    no image yet being associated with a contact – here, we've added a little fallback
    to display a system image (using SF Symbols).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们访问到该单元格的实例，我们就可以简单地根据从联系人实例中获取的数据分配每个属性。注意，我们正在检查联系人的图像数据，因为有可能某个联系人还没有关联图像——在这里，我们添加了一个小的回退来显示系统图像（使用
    SF Symbols）。
- en: If you want you add an image, simply fire up the Contacts app in the simulator
    and drag an image from your Mac over - You should now be able to select this and
    assign this from the Contacts app.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想添加一张图片，只需在模拟器中打开“联系人”应用，并将图片从你的Mac上拖拽过来 - 你现在应该能够从“联系人”应用中选择这张图片并分配给它。
- en: 'Go ahead and make those changes, and then run the app again:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，进行这些更改，然后再次运行应用：
- en: '![Figure 3.8 – Contact list with image'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.8 – 带有图片的联系人列表'
- en: '](img/Figure_3.08_B14717.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.08 – Figure_3.08_B14717.jpg](img/Figure_3.08_B14717.jpg)'
- en: Figure 3.8 – Contact list with image
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – 带有图片的联系人列表
- en: Perfect, but what is this `dequeueReusableCell` all about? Don't worry, we'll
    cover that in a later section, *Advances in UITableView and UICollectionView*.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 完美，但这个`dequeueReusableCell`到底是什么意思？别担心，我们将在稍后的部分，*UITableView和UICollectionView的进阶*中介绍。
- en: In this section, we learned how to implement `UITableView` and a custom `UITableViewCell`,
    pulling data obtained by accessing our contacts via the `Contacts` framework and
    displaying it within our app. Now, let's spend some time digging a little deeper
    into the art of table views and how they work.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何实现`UITableView`和自定义的`UITableViewCell`，通过访问`Contacts`框架获取数据，并在我们的应用中显示它。现在，让我们花些时间深入探讨表格视图的艺术及其工作原理。
- en: Exploring UITableView further
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步探索UITableView
- en: In this section, we'll touch on some extra little bits that will allow you to
    make the most out of `UITableView`. We'll also cover in more detail some areas
    previously explored, such as the reuse identifier.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将触及一些额外的细节，这将帮助你充分利用`UITableView`。我们还将更详细地介绍之前探索的一些领域，例如重用标识符。
- en: Further understanding reuse identifiers
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入理解重用标识符
- en: Earlier in this chapter, you learned about cell-reuse in table views. We assigned
    a reuse identifier to a table view cell so that the table view would know which
    cell it should use to display contacts in. Cell-reuse is a concept that is applied
    to a table view so that it can reuse cells that it has already created.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期部分，你学习了表格视图中的单元格重用。我们给表格视图单元格分配了一个重用标识符，这样表格视图就会知道应该使用哪个单元格来显示联系人。单元格重用是一个应用于表格视图的概念，以便它可以重用已经创建的单元格。
- en: This means that the only cells that are in memory are either on the screen or
    barely off the screen. The alternative would be to keep all cells in memory, which
    could potentially mean that hundreds of thousands of cells are held in memory
    at any given time.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在内存中的单元格只有屏幕上或几乎在屏幕上的单元格。另一种选择是保留所有单元格在内存中，这可能会意味着在任何给定时间都有数十万个单元格被保留在内存中。
- en: 'For a visualization of what cell reuse looks like, have a look at the following
    diagram:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化单元格重用看起来是什么样子，请查看以下图表：
- en: '![](img/Figure_3.09_B14717.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图3.09 – Figure_3.09_B14717.jpg](img/Figure_3.09_B14717.jpg)'
- en: Figure 3.9 – Table view cell layout
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – 表格视图单元格布局
- en: As you can see, there are just a few cells in the diagram that are not on the
    visible screen. This roughly equals the number of cells that a table view might
    keep in memory. This means that regardless of the total amount of rows you want
    to show, the table view has roughly constant pressure on your app's memory usage.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，图表中只有少数单元格不在可见屏幕上。这大致等于表格视图可能保留在内存中的单元格数量。这意味着无论你想要显示的总行数有多少，表格视图对你的应用内存使用量的压力大致是恒定的。
- en: A cell is first created when `dequeueReusableCell(withIdentifier:)` is called
    on the table view and it does not have an unused cell available. Once the cell
    is either reused or created, `prepareForReuse()` is called on the cell. This is
    a great spot to reset your cells to their default state by removing any images
    or setting labels back to their default values.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当在表格视图中调用`dequeueReusableCell(withIdentifier:)`方法且没有可用的未使用单元格时，会首先创建一个单元格。一旦单元格被重用或创建，就会在单元格上调用`prepareForReuse()`方法。这是一个重置单元格到默认状态的好地方，通过移除任何图片或将标签设置回默认值。
- en: Next, `tableView(_:willDisplay:forRowAt:)` is called on the table view's delegate.
    This happens right before the cell is shown. You can perform some last-minute
    configuration here, but the majority of the work should already be done in `tableView(_:cellForRowAtIndexPath:)`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在单元格显示之前，会在表格视图的代理上调用`tableView(_:willDisplay:forRowAt:)`方法。你可以在这里进行一些最后的配置，但大部分工作应该在`tableView(_:cellForRowAtIndexPath:)`中完成。
- en: When the cell scrolls off screen, `tableView(_:didEndDisplaying:forRowAt:)`
    is called on the delegate. This signals that a previously visible cell has just
    scrolled out of the view's bounds.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当单元格滚动出屏幕时，会在代理上调用`tableView(_:didEndDisplaying:forRowAt:)`方法。这表示之前可见的单元格刚刚滚动出了视图的边界。
- en: 'With all this cell life cycle information in mind, the best way to fix the
    image reuse bug is by implementing `prepareForReuse()` on `ContactCell`. Add the
    following implementation to remove any images that have previously been set:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑到所有这些单元格生命周期信息的情况下，修复图像重用错误的最佳方式是在`ContactCell`上实现`prepareForReuse()`。添加以下实现以移除之前设置的任何图像：
- en: '[PRE15]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, let's take a look at some other enhancements that we can make in our app
    by using prefetching.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们可以通过使用预取来在我们的应用中实现的其他一些增强功能。
- en: Prefetching in table views
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表格视图中的预取
- en: In addition to `UITableViewDelegate` and `UITableViewDataSource`, a third protocol
    exists that you can implement to improve your table view's performance.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`UITableViewDelegate`和`UITableViewDataSource`之外，还存在第三个协议，您可以实现它来提高表格视图的性能。
- en: It's called `UITableViewDataSourcePrefetching`, and you can use it to enhance
    your data source. If your data source performs some complex task, such as retrieving
    and decoding an image, it could slow down the performance of your table view if
    this task is performed at the moment that the table view wants to retrieve a cell.
    Performing this operation a little bit sooner than that can positively impact
    your app, in those cases.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 它被称为`UITableViewDataSourcePrefetching`，您可以使用它来增强数据源。如果数据源执行一些复杂的任务，例如检索和解码图像，如果在表格视图想要检索单元格的时候执行这个任务，可能会降低表格视图的性能。在这些情况下，提前一点执行这个操作可以积极影响您的应用。
- en: 'So, how would we implement this? Simple, we first just conform `ViewController`
    to the new delegate:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们该如何实现这个功能呢？简单来说，我们首先让`ViewController`符合新的代理协议：
- en: '[PRE16]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You'll notice that a fundamental difference here is within the `indexPath` parameter
    being passed in. This time, we have an array of `IndexPath`, as opposed to a single
    index, in turn, allowing us to perform batch processing on a set of cells that
    our table view would like us to display.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到这里的一个基本区别在于传入的`indexPath`参数。这次，我们有一个`IndexPath`数组，而不是单个索引，从而允许我们对表格视图希望显示的一组单元格执行批量处理。
- en: This would be ideal if data from your cell has to be obtained asynchronously
    – such as an image or real-time data. You could really work hard here to perform
    and calculate the right way to display your data to get the optimum performance.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的单元格数据需要异步获取——例如图像或实时数据——这将非常理想。您真的可以在这里努力工作，以正确地执行和计算显示数据的方式，以获得最佳性能。
- en: Cell selection in table views
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表格视图中的单元格选择
- en: Since a table view will call methods on its delegate whenever they are implemented,
    you don't need to tell the table view that you want to respond to cell selection.
    This automatically works if the table view has a delegate, and if the delegate
    implements `tableView(_:didSelectRowAt:)`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于表格视图会在实现方法时调用其代理的方法，因此您不需要告诉表格视图您想要响应用户对单元格的选择。如果表格视图有一个代理，并且代理实现了`tableView(_:didSelectRowAt:)`，则这会自动工作。
- en: The implementation you'll add to our app, for now, is a very simple one. When
    the user taps a cell, the app displays an alert.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，您将添加到我们的应用中的实现非常简单。当用户点击一个单元格时，应用会显示一个警告框。
- en: 'Add the following code to the extension in `ViewController.swift`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`ViewController.swift`中的扩展部分：
- en: '[PRE17]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `tableView(_:didSelectRowAt:)` method receives two arguments: the first
    is the table view that called this delegate method. The second argument is the
    index path at which the selection occurred.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`tableView(_:didSelectRowAt:)`方法接收两个参数：第一个是调用此代理方法的表格视图。第二个参数是选择发生的索引路径。'
- en: The implementation you wrote for this method uses the index path to retrieve
    the contact that corresponds with the tapped cell, so the contact name can be
    shown in an alert.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您为这个方法编写的实现使用索引路径检索与被点击单元格对应的联系人，因此可以在警告框中显示联系人姓名。
- en: You could also retrieve the contact's name from the tapped cell. However, this
    is not considered good practice because your cells and the underlying data should
    be as loosely coupled as possible.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从被点击的单元格中检索联系人的姓名。然而，这并不被认为是良好的实践，因为您的单元格和底层数据应该尽可能地松散耦合。
- en: When the user taps the **Done** button in the alert, the table view is told
    to deselect the selected row.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在警告框中点击**完成**按钮时，表格视图会被告知取消选中当前行。
- en: If you don't deselect the selected row, the last tapped cell will always remain
    highlighted. Note that the alert is displayed by calling `present(_:animated:completion:)`
    on the view controller. Any time you want to make a view controller display another
    view controller, such as an alert controller, you use this method.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有取消选中选中的行，最后触摸的单元格将始终保持高亮。请注意，通过在视图控制器上调用`present(_:animated:completion:)`来显示警报。任何你想让视图控制器显示另一个视图控制器，例如警报控制器，你都会使用这个方法。
- en: In this section, you learned a lot about what makes a table view tick, including
    a good understanding of how the reuse identifier works. Next, we'll take a look
    at `UICollectionView`, the `UITableView` class's bigger (or younger, really) brother,
    comparing similarities to each class and also key differences, too.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你了解了很多关于使表格视图工作原理的知识，包括对重用标识符的良好理解。接下来，我们将查看`UICollectionView`，这是`UITableView`类的一个更大的（或者更年轻的，实际上）兄弟，比较每个类之间的相似之处以及关键差异。
- en: Working with UICollectionView
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与`UICollectionView`一起工作
- en: In the previous section, we took on the mighty `UITableView` – learning all
    about the delegate pattern and how to build our unique lists with custom cells.
    In this section, we'll take a look at `UICollectionView`, mainly looking at how
    we are comparing one class to another.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们承担了强大的`UITableView`——学习了关于代理模式以及如何使用自定义单元格构建我们独特的列表。在本节中，我们将查看`UICollectionView`，主要关注我们如何将一个类与另一个类进行比较。
- en: 'From the outset, when asked what the fundamental differences are between them
    both, most people will initially say the same thing: "Collection views allow horizontal
    scrolling" – which is very true, but what it''s doing is harnessing the power
    of `UITableView` with the ability to manipulate and override a layout that would
    allow a grid layout, for example.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，当被问及两者之间的基本区别是什么时，大多数人最初都会说同样的话：“集合视图允许水平滚动”——这是非常正确的，但它所做的是利用`UITableView`的力量，具有操纵和覆盖布局的能力，例如允许网格布局。
- en: If you need to go deeper into a complex custom layout, this again is where `UICollectionView`
    comes into play, with the support of the `UICollectionViewDelegateFlowLayout`
    protocol, allowing you as a developer to manipulate custom layouts.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要深入了解一个复杂的自定义布局，`UICollectionView`再次发挥作用，它支持`UICollectionViewDelegateFlowLayout`协议，允许你作为开发者操纵自定义布局。
- en: Setting up our collection view
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的集合视图
- en: 'Let''s start by creating a new project in the exact same way as we did for
    a table view:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以与表格视图相同的方式创建一个新的项目：
- en: This time, search for `Collection View` in the object window (*you won't need
    to add in a* `CollectionView` *cell as the collection view already does this for
    you*).
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次，在对象窗口中搜索`Collection View`（*你不需要添加一个* `CollectionView` *单元格，因为集合视图已经为你做了这件事*）。
- en: Add in your constraints too so that it scales to the full size of the device.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 也要添加你的约束，以便它能够扩展到设备的全尺寸。
- en: Back to `ViewController`, we'll need to create and hook up our `IBOutlet` components
    just like we did with the table view (but call your property something like `collectionView`).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`ViewController`，我们需要创建和连接我们的`IBOutlet`组件，就像我们之前与表格视图所做的那样（但将你的属性命名为类似`collectionView`的东西）。
- en: 'Once you''ve done that, we''ll need to create another extension, but this time,
    our protocols will be slightly different:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了这个步骤，我们就需要创建另一个扩展，但这次，我们的协议将略有不同：
- en: '[PRE18]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Our two delegate methods in the preceding example are as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 之前示例中的两个代理方法如下：
- en: '`collectionView(_:numberOfItemsInSection:)`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collectionView(_:numberOfItemsInSection:)`'
- en: '`collectionView(_:cellForItemAt:)`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collectionView(_:cellForItemAt:)`'
- en: Both offer the same as their `UITableView` counterparts; only one difference
    you'll notice is the reference to the term `Item` rather than `Row`. This is because
    in `UITableView`, the layout is purely linear, so each cell is treated as a row.
    With `UICollectionView`, this is not the case – so, each cell is referred to as
    an item.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 它们两者都提供了与它们的`UITableView`对应项相同的选项；你唯一会注意到的区别是术语`Item`而不是`Row`的引用。这是因为`UITableView`中的布局是纯线性的，所以每个单元格都被视为一行。在`UICollectionView`中，情况并非如此——因此，每个单元格被称为一个项目。
- en: 'Next, we want to create another custom cell. Copy and paste the one we made
    for our table view and make the following highlighted changes:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要创建另一个自定义单元格。复制并粘贴我们为表格视图制作的单元格，并做出以下突出显示的更改：
- en: '[PRE19]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The differences in the preceding code are subtle, but one of them is very important:
    our subclass is now of the `UICollectionViewCell` type (as opposed to `UITableViewCell`),
    and we''ve also added in a couple of extra outlets, as we''ll be adding a touch
    more data.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码中的差异很微妙，但其中之一非常重要：我们的子类现在是`UICollectionViewCell`类型（而不是`UITableViewCell`），我们还添加了一些额外的出口，因为我们还将添加更多数据。
- en: For something different, we are going to create a scrolling horizontal list
    of our contacts and a grid layout. Let's head on over back to the interface builder
    and modify our canvas a little.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有所不同，我们将创建一个滚动水平联系人列表和一个网格布局。让我们回到界面构建器，稍微修改一下我们的画布。
- en: 'We''ll start by adding another text field. Notice from the following figure
    how I can adjust the size of my cell too:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从添加另一个文本字段开始。注意以下图中我如何调整单元格的大小：
- en: '![Figure 3.10 – Collection view cell'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.10 – 收藏视图单元格'
- en: '](img/Figure_3.10_B14717.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_3.10_B14717.jpg)'
- en: Figure 3.10 – Collection view cell
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 – 收藏视图单元格
- en: 'We can do this in a couple of places. If we highlight **Collection View** and
    select the Size Inspector, we can do it in there:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在几个地方做这件事。如果我们突出显示**收藏视图**并选择大小检查器，我们就可以在那里做：
- en: '![Figure 3.11 – Collection View Size Inspector'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.11 – 收藏视图大小检查器'
- en: '](img/Figure_3.11_B14717.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_3.11_B14717.jpg)'
- en: Figure 3.11 – Collection View Size Inspector
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 – 收藏视图大小检查器
- en: 'Alternatively, we can do this directly on the cell itself, as shown in the
    following screenshot, again by selecting the Size Inspector:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以直接在单元格本身上做，如以下截图所示，再次通过选择大小检查器：
- en: '![Figure 3.12 – Collection View Cell Size Inspector'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.12 – 收藏视图单元格大小检查器'
- en: '](img/Figure_3.12_B14717.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_3.12_B14717.jpg)'
- en: Figure 3.12 – Collection View Cell Size Inspector
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 – 收藏视图单元格大小检查器
- en: This is great for two reasons. First, you can set the size of your cell visually,
    which is always a nice and convenient way to do things. Secondly, even if you
    are going to override your cell size programmatically (due to you requiring a
    more dynamic approach), it allows you to visualize and set your constraints so
    that you know what you have to play with. I'm just going to set mine to 150 width
    x 230 height, for now, which should give us enough to play with.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，有两个原因。首先，你可以通过视觉方式设置单元格的大小，这总是做事情的一种既方便又愉快的方式。其次，即使你打算通过编程方式覆盖单元格大小（因为你需要一个更动态的方法），这也允许你可视化和设置约束，这样你就知道你可以玩什么。我现在只是将我的设置为150宽度
    x 230高度，这应该给我们足够的灵活性。
- en: 'So, let''s carry on with setting up our interface. Again, we''ll need to override
    **Class** with our custom class:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们继续设置我们的界面。同样，我们需要用我们的自定义类覆盖**类**：
- en: '![Figure 3.13 – Collection View class'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.13 – 收藏视图类'
- en: '](img/Figure_3.13_B14717.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_3.13_B14717.jpg)'
- en: Figure 3.13 – Collection View class
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 – 收藏视图类
- en: 'Then, we need to assign our cell identifier:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要分配我们的单元格标识符：
- en: '![Figure 3.14 – Collection View cell identifier'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.14 – 收藏视图单元格标识符'
- en: '](img/Figure_3.14_B14717.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_3.14_B14717.jpg)'
- en: Figure 3.14 – Collection View cell identifier
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 – 收藏视图单元格标识符
- en: 'Then, we set **Estimated Height** to **None**. This stops our cell from dynamically
    resizing itself based on the size of the content within the cell (for example,
    a label with a really long name or address):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将**估计高度**设置为**无**。这阻止了我们的单元格根据单元格内内容的大小动态调整大小（例如，一个带有非常长的名字或地址的标签）：
- en: '![Figure 3.15 – Collection View estimated cell size'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.15 – 收藏视图估计的单元格大小'
- en: '](img/Figure_3.15_B14717.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_3.15_B14717.jpg)'
- en: Figure 3.15 – Collection View estimated cell size
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15 – 收藏视图估计的单元格大小
- en: We're almost done – just a few more little things we need to add in. Notice
    anything missing from our `viewDidLoad()` function that we had in the `UITabelView`
    example?
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了——只需要添加一些小东西。你注意到我们的`viewDidLoad()`函数中缺少了什么吗？我们在`UITabelView`示例中有这个函数。
- en: Yep, we've yet to set our delegate method to our `ViewController` object, but
    for this example, I'm going to show you another way that we can do that via Interface
    Builder, as opposed to doing this programmatically.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们还没有将我们的代理方法设置到`ViewController`对象上，但在这个例子中，我将向你展示另一种方法，我们可以通过界面构建器来完成，而不是通过编程方式来完成。
- en: 'Highlight your `CollectionView` object, press and hold *Ctrl* on your keyboard,
    then primary click and hold your cursor – if you start to drag your cursor, you''ll
    see a line (just like when we connect `IBOutlet`). Drag the line to the `ViewController`
    object and release. You''ll then be presented with the following options:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮显示你的 `CollectionView` 对象，按住键盘上的 *Ctrl*，然后单击并按住鼠标——如果你开始拖动鼠标，你会看到一个线（就像我们连接
    `IBOutlet` 一样）。将线拖到 `ViewController` 对象并释放。然后你会看到以下选项：
- en: '![Figure 3.16 – Collection View delegate outlet'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.16 – Collection View delegate outlet'
- en: '](img/Figure_3.16_B14717.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_3.16_B14717.jpg](img/Figure_3.16_B14717.jpg)'
- en: Figure 3.16 – Collection View delegate outlet
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.16 – Collection View 代理出口
- en: Select **dataSource**, and then repeat the process and select **delegate**.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 **dataSource**，然后重复此过程并选择 **delegate**。
- en: 'That''s it – other than a few minor changes here and there, we''ve successfully
    set up `UICollectionView` in pretty much the same way as we did for our `UITableView`.
    Let''s go ahead now and run the project to see how it all looks:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样——除了这里和那里的几个小改动之外，我们已经在很大程度上以与我们的 `UITableView` 相同的方式设置了 `UICollectionView`。现在，让我们运行项目，看看它看起来如何：
- en: '![Figure 3.17 – Collection View layout'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.17 – Collection View layout'
- en: '](img/Figure_3.17_B14717.png)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_3.17_B14717.png](img/Figure_3.17_B14717.png)'
- en: Figure 3.17 – Collection View layout
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.17 – Collection View 布局
- en: That looks great – I mean, apart from the cells looking a little out of place
    – but don't worry, we're going to take a look at our options on how we can change
    that in the next part, by being introduced to the `UICollectionViewDelegateFlowLayout`
    protocol.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很不错——我是说，除了单元格看起来有点不合适之外——但不用担心，我们将在下一部分通过介绍 `UICollectionViewDelegateFlowLayout`
    协议来查看我们如何改变这一点。
- en: Implementing layout with UICollectionViewDelegateFlowLayout
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `UICollectionViewDelegateFlowLayout` 实现布局
- en: In the last section, we created our very first `UICollectionView` project based
    on everything we had learned from creating a `UITableView` project previously.
    One thing we did learn that was fundamentally different from a table view was
    that our cells can be laid out differently.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们根据之前创建 `UITableView` 项目时所学的所有内容创建了我们第一个 `UICollectionView` 项目。我们学到的一件事是，与表格视图相比，我们的单元格可以以不同的方式排列。
- en: So, how do we go about manipulating our cells to get them to do exactly what
    we want them to do? For that, we need to implement the `UICollectionViewDelegateFlowLayout`
    protocol – but what does this have to offer? Let's start by taking a look at one
    of the most commonly used delegate methods in this protocol and how easily it
    can transform our app.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何操作我们的单元格，使它们做到我们想要它们做到的？为此，我们需要实现 `UICollectionViewDelegateFlowLayout`
    协议——但它能提供什么呢？让我们先看看这个协议中最常用的代理方法，以及它如何轻松地改变我们的应用。
- en: 'Over in our extension, add in the following highlighted protocol alongside
    the existing ones:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的扩展中，添加以下突出显示的协议，与现有的协议并列：
- en: '[PRE20]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, in good practice, you can separate each one of these protocols into its
    own extension – but as we are only dealing with a few delegates for each, we'll
    be fine to keep them in one place for now.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照良好的实践，你可以将每个协议分开到它自己的扩展中——但因为我们只处理每个的几个代理，所以我们现在将它们保留在一个地方是完全可以的。
- en: Tip
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If your `ViewController` object starts to get a little large, you can move your
    extensions out into a separate file – this makes working on them easier and keeps
    your files nice and clean.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 `ViewController` 对象开始变得有点大，你可以将你的扩展移动到单独的文件中——这使它们更容易工作，并保持你的文件整洁。
- en: 'Now, we''re going to add in the following `delegate` method:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加以下 `delegate` 方法：
- en: '[PRE21]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `sizeForItem` delegate simply allows us to programmatically set a size
    of our cell, so let''s have a play with that and see what we can come up with.
    Add the following code to the preceding function:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`sizeForItem` 代理简单地允许我们以编程方式设置单元格的大小，所以让我们来玩一下，看看我们能想出什么。将以下代码添加到前面的函数中：'
- en: '[PRE22]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'So, here, we''re performing a nice simple calculation: we''re taking the width
    of the current screen, dividing it by 2, and then subtracting 10 (for a little
    padding), and having that as our cell width. Finally, we''ll add a nice static
    value for our height. Go ahead and run your app and see what it gives us:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这里，我们执行了一个简单而优雅的计算：我们取当前屏幕的宽度，除以 2，然后减去 10（为了有一点填充），然后将其作为单元格宽度。最后，我们将添加一个静态值作为我们的高度。运行你的应用并看看它给出了什么：
- en: '![Figure 3.18 – Collection View layout'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.18 – Collection View layout'
- en: '](img/Figure_3.18_B14717.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_3.18_B14717.jpg](img/Figure_3.18_B14717.jpg)'
- en: Figure 3.18 – Collection View layout
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.18 – Collection View 布局
- en: Nice, let's look at what else we could do. How about simply returning the full
    size of the screen?
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，让我们看看我们还能做什么。简单返回屏幕的全尺寸怎么样？
- en: '[PRE23]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, let''s change the direction of the scroll direction; we can do this via
    Interface Builder by selecting **Collection View**. Change the value to **Horizontal**:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们改变滚动方向；我们可以通过 Interface Builder 来实现，选择 **Collection View**。将值更改为 **Horizontal**：
- en: '![Figure 3.19 – Collection View Scroll Direction'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.19 – 收藏视图滚动方向'
- en: '](img/Figure_3.19_B14717.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.19_B14717.jpg)'
- en: Figure 3.19 – Collection View Scroll Direction
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.19 – 收藏视图滚动方向
- en: Go ahead and run the app again – how does it look?
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 继续运行应用 – 它看起来怎么样？
- en: '![Figure 3.20 – Collection View Scroll Direction layout'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.20 – 收藏视图滚动方向布局'
- en: '](img/Figure_3.20_B14717.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.20_B14717.jpg)'
- en: Figure 3.20 – Collection View Scroll Direction layout
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.20 – 收藏视图滚动方向布局
- en: Perfect – with only a small change, we've managed to make a massive difference
    to our app, clearly highlighting the power of `UICollectionView` compared to `UITableView`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 完美 – 只需稍作修改，我们就为我们的应用带来了巨大的变化，清楚地突出了 `UICollectionView` 相比 `UITableView` 的强大功能。
- en: Before we wrap up this section on `UICollectionView`, let's take a quick look
    at the other delegate methods offered to us by `UICollectionViewDelegateFlowLayout`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束关于 `UICollectionView` 的这一节之前，让我们快速看一下 `UICollectionViewDelegateFlowLayout`
    提供给我们的其他代理方法。
- en: Size of an item (cell)
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项（单元格）的大小
- en: When you need to manipulate the bounds or frame of an item, use `collectionView(_:layout:sizeForItemAt:`,
    which asks the delegate for the size of the specified item's cell.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要操作一个项的边界或框架时，使用 `collectionView(_:layout:sizeForItemAt:)`，它会请求代理指定项的单元格大小。
- en: Section and spacing
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部分（Section）和间距
- en: 'The following are options to programmatically adjust the spacing between cell
    items and sections (excluding headers and footers):'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些用于编程调整单元格项和部分之间间距的选项（不包括头部和页脚）：
- en: '`collectionView(_:layout:insetForSectionAt:)`: Asks the delegate for the margins
    to apply to content in the specified section'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collectionView(_:layout:insetForSectionAt:)`：请求代理指定应用于指定部分内容的边距'
- en: '`collectionView(_:layout:minimumLineSpacingForSectionAt:)`: Asks the delegate
    for the spacing between successive rows or columns of a section'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collectionView(_:layout:minimumLineSpacingForSectionAt:)`：请求代理指定部分中连续行或列之间的间距'
- en: '`collectionView(_:layout:minimumInteritemSpacing ForSectionAt:)`: Asks the
    delegate for the spacing between successive items in the rows or columns of a
    section'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collectionView(_:layout:minimumInteritemSpacing ForSectionAt:)`：请求代理指定部分中行或列中连续项之间的间距'
- en: Footer and header sizing
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 页脚和头部尺寸
- en: 'The following are options to programmatically adjust the spacing between cell
    items specifically for headers and footers:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些用于编程调整单元格项之间间距的选项，特别是针对头部和页脚：
- en: '`collectionView(_:layout:referenceSizeForHeaderInSection:)`: Asks the delegate
    for the size of the header view in the specified section'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collectionView(_:layout:referenceSizeForHeaderInSection:)`：请求代理指定指定部分中头部视图的大小'
- en: '`collectionView(_:layout:referenceSizeForFooterInSection:)`: Asks the delegate
    for the size of the footer view in the specified section'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collectionView(_:layout:referenceSizeForFooterInSection:)`：请求代理指定部分中页脚视图的大小'
- en: In this section, we learned all about `UICollectionView` components – how to
    set them up in Xcode and the differences between them and `UITableView` components
    – and were able to see the benefits they give us along with the `UICollectionViewDelegateFlowLayout`
    protocol in order customize our apps more visually. In the next section, we're
    going to take a look a little deeper into some of the advancements in `UITableView`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了关于 `UICollectionView` 组件的所有内容 – 如何在 Xcode 中设置它们，以及它们与 `UITableView`
    组件之间的区别 – 并且能够看到它们为我们带来的好处，以及通过 `UICollectionViewDelegateFlowLayout` 协议来定制我们的应用，使其更具视觉吸引力。在下一节中，我们将更深入地探讨
    `UITableView` 的一些进步。
- en: Exploring UICollectionView further
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步探索 UICollectionView
- en: In this section, we'll again touch on some extra little bits that, just like
    with our table views, will allow us to really harness the power of a collection
    view – specifically when it comes to calculating the size of your layout. We'll
    start by taking a look at some overrides that we can make use of to achieve this.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们还将再次触及一些额外的小细节，就像我们的表格视图一样，这将使我们能够真正利用收藏视图的力量 – 尤其是在计算布局大小方面。我们将从查看一些我们可以利用的覆盖方法开始。
- en: Implementing a custom UICollectionViewLayout
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现自定义 UICollectionViewLayout
- en: Implementing a large and complex feature such as a custom collection view layout
    might seem like a huge challenge for most people.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个像自定义集合视图布局这样的大型且复杂的特性，对于大多数人来说可能是一个巨大的挑战。
- en: Creating your layout involves calculating the position for every cell that your
    collection view will display. You must ensure that these calculations are performed
    as quickly and as efficiently as possible because your layout calculations directly
    influence the performance of your collection view. A poor layout implementation
    will lead to slow scrolling and a lousy user experience eventually.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 创建你的布局涉及到计算集合视图将要显示的每个单元格的位置。你必须确保这些计算尽可能快、尽可能高效地执行，因为你的布局计算直接影响到集合视图的性能。糟糕的布局实现最终会导致滚动缓慢和糟糕的用户体验。
- en: Luckily, the documentation that has been provided for creating a collection
    view layout is pretty good as a reference to figure out whether you're on the
    right track.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，为创建集合视图布局提供的文档相当不错，可以作为参考来了解你是否走上了正确的道路。
- en: If you take a look at Apple's documentation on `UICollectionViewLayout`, you
    can read about its role in a collection view. The available information shows
    that a custom layout requires you to handle the layout for cells, supplementary
    views, and decoration views. Supplementary views are also known as headers and
    footers.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看苹果关于 `UICollectionViewLayout` 的文档，你可以了解它在集合视图中的作用。可用的信息显示，自定义布局需要你处理单元格、辅助视图和装饰视图的布局。辅助视图也被称为头部和尾部。
- en: 'Let''s take a look at how we could begin to implement that. We''ll start by
    creating our own class to do the job:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何开始实现它。我们首先创建自己的类来完成这项工作：
- en: '[PRE24]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see from the preceding code, here we've implemented a subclass of
    `UICollectionViewLayout` and have a variety of overridden functions that we can
    use – let's go through these now.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，这里我们实现了一个 `UICollectionViewLayout` 的子类，并有许多可以使用的重写函数——现在让我们来了解一下这些函数。
- en: Implementing collectionViewContentSize
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现 `collectionViewContentSize`
- en: A collection view uses the `collectionViewContentSize` property from its layout
    to figure out the size of its contents. This property is especially important
    because it is used to configure and display the scrolling indicators for the collection
    view.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 集合视图使用其布局中的 `collectionViewContentSize` 属性来确定其内容的大小。这个属性特别重要，因为它用于配置和显示集合视图的滚动指示器。
- en: It also provides the collection view with information about the direction in
    which scrolling should be enabled.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 它还提供了集合视图关于滚动应启用方向的详细信息。
- en: Implementing this property uses the number of rows and columns in the collection
    view. It also takes the item size and item spacing into account to come up with
    the size of all of its contents together.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这个属性使用集合视图中的行数和列数。它还考虑了项目大小和项目间距，以确定所有内容的总大小。
- en: Implementing layoutAttributesForElements(in:)
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现 `layoutAttributesForElements(in:)`
- en: More complex than `collectionViewContentSize` is `layoutAttributesForElements(in:)`.
    This method is responsible for providing a collection view with the layout attributes
    for several elements at once.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 比 `collectionViewContentSize` 更复杂的是 `layoutAttributesForElements(in:)`。这个方法负责一次性为集合视图提供多个元素的布局属性。
- en: The collection view always provides a rectangle, for which it needs layout attributes.
    The layout is responsible for providing these attributes to the collection view
    as fast as possible. The implementation of this method must be as efficient as
    you can get it to be. Your scroll performance depends on it.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 集合视图始终提供一个矩形，它需要布局属性。布局负责尽可能快地提供这些属性给集合视图。这个方法的实现必须尽可能高效。你的滚动性能取决于它。
- en: Even though there is only a small number of cells visible at a time, the collection
    view has a lot more content outside of its current viewport. Sometimes it is asked
    to jump to a particular cell, or the user scrolls extremely fast.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一次只能看到少量单元格，但集合视图在其当前视图中还有更多内容。有时它被要求跳转到特定的单元格，或者用户滚动得非常快。
- en: There are many cases where the collection view will ask for all layout attributes
    for several cells at once. When this happens, the layout object can help the cell
    determine which cells should be visible for a particular rectangle. This is possible
    because the layout attributes not only contain the rectangle in which a cell should
    be rendered but they also know the `IndexPath` object that corresponds with that
    specific cell.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多情况下，集合视图会一次性请求多个单元格的所有布局属性。当这种情况发生时，布局对象可以帮助单元格确定特定矩形应该显示哪些单元格。这是可能的，因为布局属性不仅包含单元格应该渲染的矩形，还知道与该特定单元格对应的`IndexPath`对象。
- en: This is a pretty complicated matter, and it's okay if you find this to be a
    little bit confusing. As long as you understand that a collection view can ask
    its layout which cells are present in a certain `CGRect` instance and how they
    should be rendered, you understand what `layoutAttributesForElements(in:)` does.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当复杂的问题，如果你觉得有点困惑，这是完全可以理解的。只要你理解集合视图可以询问其布局在某个`CGRect`实例中哪些单元格存在以及它们应该如何渲染，你就理解了`layoutAttributesForElements(in:)`的作用。
- en: Implementing layoutAttributesForItem(at:)
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现layoutAttributesForItem(at:)方法
- en: Another way that a collection view can request layout attributes for its layout
    is by requesting the attributes for a single item. Because the collection view
    does so by supplying an index path, this method is quite simple to implement.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 集合视图请求其布局的布局属性的另一种方式是请求单个项目的属性。因为集合视图通过提供索引路径来这样做，所以这个方法实现起来相当简单。
- en: The layout you implemented assumes that only a single section exists in the
    collection view and the layout attributes array is sorted by index path because
    that's the order in which all items were inserted into the array.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 你实现的布局假设集合视图中只有一个分区，并且布局属性数组按索引路径排序，因为所有项目都是按照这个顺序插入到数组中的。
- en: Implementing shouldInvalidateLayout(forBoundsChange:)
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现shouldInvalidateLayout(forBoundsChange:)方法
- en: Getting the implementation for `shouldInvalidateLayout(forBoundsChange:)` is
    crucial to having a great collection view layout that has amazing performance.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 获取`shouldInvalidateLayout(forBoundsChange:)`的实现对于拥有性能出色的集合视图布局至关重要。
- en: If you implement this method incorrectly, you could constantly be invalidating
    the layout, meaning you will need to recalculate all the time.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你错误地实现此方法，你可能会不断使布局无效，这意味着你需要不断重新计算。
- en: It's also possible that the collection view will never update its layout at
    all, even when it should. The collection view will call this method any time its
    size changes. For instance, when the user rotates their device or when your app
    runs on an iPad, the user opens another app in multitasking mode.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 还有可能集合视图根本不会更新其布局，即使它应该更新。集合视图会在其大小改变时调用此方法。例如，当用户旋转设备或当你的应用在iPad上运行时，用户在多任务模式下打开另一个应用。
- en: Assigning a custom layout to your collection view
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为你的集合视图分配自定义布局
- en: The final step to using your custom layout is telling your collection view to
    use your layout. You have already seen that you can assign a custom class to the
    layout for a collection view in Interface Builder.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义布局的最终步骤是告诉你的集合视图使用你的布局。你已经在Interface Builder中看到，你可以为集合视图的布局分配一个自定义类。
- en: 'However, this only works when your layout inherits from `UICollectionViewFlowLayout`,
    which your layout does not inherit from. Luckily, you can also set your collection
    view''s layout in code. Update your `viewDidLoad` method in `ViewController.swift`
    by adding the following line to it:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这仅在布局继承自`UICollectionViewFlowLayout`时才有效，而你的布局并没有继承自它。幸运的是，你还可以在代码中设置集合视图的布局。通过在`ViewController.swift`中的`viewDidLoad`方法中添加以下行来更新它：
- en: '[PRE25]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This line sets your new layout as the current layout. You can now remove the
    `UICollectionViewDelegateFlowLayout` extension from `ViewController.swift` as
    it is not needed anymore.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码将你的新布局设置为当前布局。你现在可以移除`ViewController.swift`中的`UICollectionViewDelegateFlowLayout`扩展，因为它不再需要了。
- en: Now that we've looked at layouts in more detail, let's take a look at how we
    handle user interaction with cell selection.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经更详细地了解了布局，让我们看看我们如何处理用户与单元格选择的交互。
- en: Cell selection in collection views
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合视图中的单元格选择
- en: 'Although almost identical to its `UITableView` counterpart, I thought it was
    worth calling this function out:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然几乎与`UITableView`的对应方法相同，但我认为指出这个函数是有价值的：
- en: '[PRE26]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With again the only real difference being that `Row` is replaced with `Item`,
    this delegate method performs in the exact same way.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，唯一的真正区别是 `Row` 被替换成了 `Item`，这个委托方法以完全相同的方式执行。
- en: We can make use of the reuse identifier and work with our cell directly should
    we need to manipulate it in any way (see [*Chapter 5*](B14717_05_Final_ASB_ePub.xhtml#_idTextAnchor141),
    *Immersing Your Users with Animation*, for some exciting things we can do here).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要以任何方式操作它，我们可以使用重用标识符并直接与我们的单元格一起工作（参见 [*第 5 章*](B14717_05_Final_ASB_ePub.xhtml#_idTextAnchor141)，*通过动画让用户沉浸其中*，了解我们在这里可以做一些令人兴奋的事情）。
- en: In this section, we delved into the inner workings of the `UICollectionView`
    layout options and explored further how we can use `UICollectionViewLayout` to
    subclass our own layout, allowing us, the developer, to utilize specific and complex
    calculations should we need too. In our next and final section, we'll take a look
    at how Apple's new powerful UI framework, SwiftUI, handles lists.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们深入探讨了 `UICollectionView` 布局选项的内部工作原理，并进一步探讨了如何使用 `UICollectionViewLayout`
    来创建我们自己的布局子类，这样，作为开发者的我们就可以在需要时利用特定的和复杂的计算。在我们接下来的最后一节中，我们将探讨苹果的新强大 UI 框架 SwiftUI
    如何处理列表。
- en: Working with lists in SwiftUI
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 SwiftUI 中与列表一起工作
- en: Back at WWDC 2019, Apple unveiled to the world a brand-new UI framework called
    SwiftUI. Built from the ground up, SwiftUI is a powerful alternative to UIKit
    and AppKit, offering developers the ability to write code using declarative syntax.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 2019 年的 WWDC，苹果向世界展示了一个全新的 UI 框架，名为 SwiftUI。从头开始构建，SwiftUI 是 UIKit 和 AppKit
    的强大替代品，为开发者提供了使用声明性语法编写代码的能力。
- en: In this section, we are going to cover what SwiftUI has to offer in terms of
    generating lists and what we may need to do going forward should we require the
    use of anything that isn't available to use just yet.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍 SwiftUI 在生成列表方面能提供什么，以及如果我们需要使用目前尚未可用的事物时，我们可能需要做些什么。
- en: Creating our first SwiftUI project
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的第一个 SwiftUI 项目
- en: 'For this, we''re going to need to create a new single view app, the same as
    before, but only this time we''ll need to select **SwiftUI** for our user interface,
    as highlighted in the following screenshot:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个，我们需要创建一个新的单视图应用，就像之前一样，但这次我们需要选择用户界面为 **SwiftUI**，如下面的截图所示：
- en: '![Figure 3.21 – New SwiftUI project'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.21 – 新的 SwiftUI 项目'
- en: '](img/Figure_3.21_B14717.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.21 – 新的 SwiftUI 项目'
- en: Figure 3.21 – New SwiftUI project
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 3.21 – 新的 SwiftUI 项目
- en: If you're unfamiliar with SwiftUI, you'll notice a couple of differences. You'll
    no longer have a `ViewController.swift` file – this has been replaced with `ContentView.swift`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉 SwiftUI，你会注意到一些差异。你将不再有 `ViewController.swift` 文件——这已经被 `ContentView.swift`
    替换。
- en: 'Highlight the file to take a look at the contents; you should see the following
    boilerplate code:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮显示文件以查看其内容；你应该会看到以下样板代码：
- en: '[PRE27]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: First, let's take a look at the `ContentView` struct – this is the first step
    of how SwiftUI builds up its declarative interface. Inside the `ContentView` struct
    is the body. Notice how these conform to either `View` or `some View` – that's
    because the concept of `ViewController` components in SwiftUI is no longer used;
    everything is a view being returned to the window.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看 `ContentView` 结构体——这是 SwiftUI 构建其声明性界面的第一步。在 `ContentView` 结构体中是体。注意这些如何符合
    `View` 或 `some View`——这是因为 SwiftUI 中不再使用 `ViewController` 组件的概念；一切都是一个返回到窗口的视图。
- en: 'But without getting too involved in the workings of SwiftUI, all we care about
    now is the contents of the body declaration. So, in the case of the preceding
    example, all we care about is the following:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 但在不深入了解 SwiftUI 的工作原理的情况下，我们现在所关心的是体声明的内容。因此，在先前的例子中，我们所关心的是以下内容：
- en: '[PRE28]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`Text` is SwiftUI''s equivalent to `UILabel` – pretty neat, right, how a simple
    one line of code can construct, instantiate, and accept a value to display? Oh,
    and no need to add it to the view either – the fact that this line of code is
    present is enough.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`Text` 是 SwiftUI 中 `UILabel` 的等价物——非常酷，对吧？一行简单的代码就能构建、实例化并接受一个值来显示？哦，而且不需要将其添加到视图中——这一行代码的存在就足够了。'
- en: 'Another benefit to using SwiftUI is the ability to preview code changes on
    the fly. If you take a look in Xcode to the right of our opened `ContentView.swift`
    file, you''ll see the preview assistant. Click **Resume** at the top left and
    we should see a preview of our app appear:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SwiftUI 的另一个好处是能够即时预览代码更改。如果你在 Xcode 中查看我们打开的 `ContentView.swift` 文件右侧，你会看到预览助手。点击左上角的
    **Resume**，我们应该会看到我们应用的预览：
- en: '![Figure 3.22 – SwiftUI "Hello, World!"'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.22 – SwiftUI "Hello, World!"'
- en: '](img/Figure_3.22_B14717.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.22 – 图 3.22_B14717.jpg](img/Figure_3.22_B14717.jpg)'
- en: Figure 3.22 – SwiftUI "Hello, World!"
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.22 – SwiftUI "Hello, World!"
- en: Now, let's take a look at how we would add in a list of items.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何添加一个项目列表。
- en: Building a list in SwiftUI
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 SwiftUI 中构建列表
- en: 'We''ll start simple, by just adding our already-existing label to a list. Make
    the following highlighted code change, and if required, press resume in the preview
    assistant window:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从简单开始，只是将已经存在的标签添加到列表中。进行以下突出显示的代码更改，并在需要时在预览辅助窗口中按 "恢复"：
- en: '[PRE29]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'That''s right, it really is as simple as that. Go on and add a couple more
    `Text` views and see how it looks – even try running this in your simulator to
    see how it looks:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 没错，它确实像那样简单。继续添加几个更多的 `Text` 视图，看看效果如何——甚至尝试在你的模拟器中运行它，看看效果：
- en: '![Figure 3.23 – SwiftUI list'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.23 – SwiftUI 列表'
- en: '](img/Figure_3.23_B14717.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.23 – 图 3.23_B14717.jpg](img/Figure_3.23_B14717.jpg)'
- en: Figure 3.23 – SwiftUI list
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.23 – SwiftUI 列表
- en: Nice and simple, but much like we did with our `UITableView` components and
    `UICollectionView` components, let's see how we could go about adding in some
    external data.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 简单又直接，但就像我们处理 `UITableView` 组件和 `UICollectionView` 组件一样，让我们看看我们如何添加一些外部数据。
- en: 'Make the following highlighted change to our code in `ContentView.swift`:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ContentView.swift` 中的代码进行以下突出显示的更改：
- en: '[PRE30]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we've added in a `ForEach` function to our list; this is going to iterate
    around our array of contacts that we created just outside our body.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向我们的列表中添加了一个 `ForEach` 函数；这将遍历我们刚刚在主体外部创建的联系人数组。
- en: 'But if we press resume, you''ll see that we get no data…let''s fix this. Take
    a look just below the `ContentView` struct and you''ll see the following code:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们按 "恢复"，你会发现我们没有数据……让我们解决这个问题。看看 `ContentView` 结构下面，你会看到以下代码：
- en: '[PRE31]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This struct is how our preview assistance can display our app – our own little
    internal testing/playground while we develop our SwiftUI view – without even needing
    to run the simulator.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构是如何显示我们的预览的——我们在开发 SwiftUI 视图时的自己的小内部测试/游乐场——甚至不需要运行模拟器。
- en: 'Let''s add some code in then to inject a little mock data into our preview.
    Make the following highlighted changes:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在其中添加一些代码来注入一些模拟数据到我们的预览中。进行以下突出显示的更改：
- en: '[PRE32]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We simply just create some mock data that we can inject straight into our view,
    if not already updated. Click **Resume** on the preview assistant and see your
    code in action – however, if you run this in the simulator, you won't see anything,
    as the preview is no longer in effect and the app you see is your actual app (which
    we haven't added any data to yet).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需创建一些模拟数据，可以直接将其注入到我们的视图中，如果尚未更新。在预览辅助窗口中点击 **恢复**，看看你的代码如何运行——然而，如果你在模拟器中运行它，你将看不到任何东西，因为预览不再有效，你看到的应用程序实际上是你的实际应用程序（我们还没有添加任何数据）。
- en: The equivalent to creating a custom cell in SwiftUI
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 SwiftUI 中创建自定义单元格的等效方法
- en: It's hard trying not to make a direct comparison to UIKit objects when developing
    with SwiftUI – but we'll all do it and it's okay, because usually there is a way
    to perform a similar action or a new way to learn.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 SwiftUI 开发时，很难不将 UIKit 对象直接进行比较——但我们会这样做，而且没关系，因为通常总有一种方法可以执行类似操作或学习新的方法。
- en: 'Going back to the beginning of this section, I mentioned that SwiftUI is all
    about views, and that''s no different when implementing a custom "cell" for a
    list in SwiftUI. We''ll start by creating a new view (we''ll do this inside of
    your `ContentView.swift` file, but outside of the initial class declaration):'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 回到本节的开头，我提到 SwiftUI 全是关于视图的，当在 SwiftUI 中实现自定义 "单元格" 时，这也没有什么不同。我们将首先创建一个新的视图（我们将在你的
    `ContentView.swift` 文件中这样做，但不在初始类声明之外）：
- en: '[PRE33]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Just like `ContentView`, our new `RowView` is a simple view being created that
    can be used anywhere within SwiftUI. The structs can accept a `name: String` variable
    and will display this within a `Text` view – just like we did inside `ContentView`.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '就像 `ContentView` 一样，我们的新 `RowView` 是一个简单的视图，可以在 SwiftUI 的任何地方使用。结构可以接受一个 `name:
    String` 变量，并在 `Text` 视图中显示它——就像我们在 `ContentView` 中做的那样。'
- en: 'Now, let''s amend our code to make use of this. Make the following highlighted
    changes:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修改我们的代码以利用这一点。进行以下突出显示的更改：
- en: '[PRE34]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It really is a simple as that; we can now treat `RowView` as we did collection
    view or table view cells and decorate them or work on them independently to their
    parent lists.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 真的是很简单；我们现在可以将 `RowView` 当作我们处理集合视图或表格视图单元格一样，装饰它们或独立于父列表进行操作。
- en: You can even create your own preview provider just for `RowView` so that you
    can again inject mock data whilst developing.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以只为 `RowView` 创建自己的预览提供者，这样你就可以在开发过程中再次注入模拟数据。
- en: In this section, we were introduced to SwiftUI as a framework and took a look
    at the basic building blocks needed to create a project. From this, we learned
    about how lists are used and how we can use the preview assistant to our advantage
    when developing SwiftUI interfaces.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了 SwiftUI 作为框架，并查看创建项目所需的基本构建块。从这一点出发，我们了解了列表的使用方法以及我们如何利用预览助手在开发 SwiftUI
    接口时获得优势。
- en: Summary
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at everything to do with lists. We started by learning
    how to create a `UITableView` object – pulling in contacts from our device and
    displaying them in the way we want. We then moved on to `UICollectionView`, comparing
    it against our previous implementation and looking at some of the subtle and larger
    differences it had to offer – such as cell layout and manipulation.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了与列表相关的所有内容。我们首先学习了如何创建 `UITableView` 对象——从我们的设备中拉取联系人并以我们想要的方式显示它们。然后，我们转向
    `UICollectionView`，将其与我们之前的实现进行比较，并查看它提供的一些细微和较大的差异——例如单元格布局和操作。
- en: We then delved a little deeper into each of these, specifically looking at layouts
    with `UICollectionView` components, which is one of its most powerful features.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们深入研究了这些内容的每一个，特别是查看使用 `UICollectionView` 组件的布局，这是其最强大的功能之一。
- en: We then finished off by taking a look at the SwiftUI framework and how Apple
    has made it so easy not only to develop but also to display data in different
    ways that we have been used to previously with the ease of the declarative syntax
    and the use of the preview assistant.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过查看 SwiftUI 框架以及苹果如何使其不仅易于开发，而且易于以我们之前习惯的方式显示数据来结束本节，这得益于声明性语法和预览助手的运用。
- en: In the next chapter, we'll be looking at taking our lists a step further and
    creating a details page for them to navigate to with the use of the cell interaction
    that we covered in this chapter.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步探讨我们的列表，并为它们创建一个详情页面，以便使用本章中介绍的单元格交互进行导航。
- en: Further reading
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Apple Developer documentation on table views:'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apple 开发者文档关于表格视图：
- en: '[https://developer.apple.com/documentation/uikit/views_and_controls/table_views](https://developer.apple.com/documentation/uikit/views_and_controls/table_views)'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/documentation/uikit/views_and_controls/table_views](https://developer.apple.com/documentation/uikit/views_and_controls/table_views)'
- en: 'Apple Developer documentation on collection views:'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apple 开发者文档关于集合视图：
- en: '[https://developer.apple.com/documentation/uikit/views_and_controls/collection_views](https://developer.apple.com/documentation/uikit/views_and_controls/collection_views)'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/documentation/uikit/views_and_controls/collection_views](https://developer.apple.com/documentation/uikit/views_and_controls/collection_views)'
- en: '*Learn SwiftUI* (Packt Publishing):'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习 SwiftUI* (Packt 出版):'
- en: '[https://www.packtpub.com/business-other/learn-swiftui](https://www.packtpub.com/business-other/learn-swiftui)'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/business-other/learn-swiftui](https://www.packtpub.com/business-other/learn-swiftui)'
