- en: '*Chapter 3*: Using Lists and Tables'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's a good chance that you have built a simple app before, or maybe you
    have tried but didn't quite succeed. If this is the case, you have likely used
    `UITableView` or `UICollectionView`, as both are core components of many iOS applications.
  prefs: []
  type: TYPE_NORMAL
- en: If an app shows a list of items, it was likely built using `UITableView`. This
    chapter will ensure that you are up to speed with the ins and outs of `UITableView`
    and `UICollectionView`. In addition to covering the basics, such as how we use
    the delegation pattern, you'll also learn how to access users' data – in this
    case, their contacts – which will be rendered in a `UITableView` and `UICollectionView`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: We'll finish this chapter by taking a look at lists in SwiftUI, Apple's new
    UI framework announced back in 2019\. We'll touch on the fundamental differences
    between what SwiftUI and UIKit have to offer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with `UITableView`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring table views further
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with `UICollectionView`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring collection views further
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with lists in SwiftUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you'll need to download Xcode version 11.4 or above from Apple's
    App Store.
  prefs: []
  type: TYPE_NORMAL
- en: You'll also need to be running the latest version of macOS (Catalina or above).
    Simply search for Xcode in the App Store, and select and download the latest version.
    Launch Xcode and follow any additional installation instructions that your system
    may prompt you with. Once Xcode has fully launched, you're ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the sample code from the following GitHub link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition)'
  prefs: []
  type: TYPE_NORMAL
- en: Working with UITableView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll start by taking a look at `UITableView`, one of the most
    – if not *the* most – common ways of displaying data in a list in iOS.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every time you start a new project in Xcode, you have the option to pick a template
    for your app. Every template contains a small amount of code or some boilerplate
    code to get you started. In most cases, a basic layout will even be set up for
    you. Throughout this book, you should default to using the **Single View App**
    template. Don't be fooled by its name; you can add as many views to your app as
    you would like. This template just provides you with one view to start with.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will create an app that is called My Contacts. This app
    displays your user's contacts list in a `UITableView` component that you will
    set up. Let's create a project for this app right now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the menu bar, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **File** | **New** | **Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Single View App**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name your project `Contacts List` or anything you like.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure your programming language is set to **Swift** and the user interface
    is set to **Storyboard** – it should resemble something like the following:![Figure
    3.1 – Xcode new project options
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.01_B14717.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.1 – Xcode new project options
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: From here, click **Next** and then **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once your project has loaded, open the file named `Main.storyboard` found in
    the navigation tree to the left-hand side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The storyboard file is used to lay out all of your application's views and to
    connect them to the code you write. The editor you use to manipulate your storyboard
    is called Interface Builder.
  prefs: []
  type: TYPE_NORMAL
- en: If you have used `UITableView` in the past, you may have used `UITableViewController`.
    The `UITableViewController` class is a subclass of a regular `UIViewController`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The difference is that `UITableViewController` contains a lot of setup that
    you would otherwise have to perform on your own, either in Interface Builder or
    programmatically. To fully understand how `UITableView` is configured and set
    up, we won't use `UITableViewController` in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in Xcode, you''ll notice a button at the top right that has a plus symbol
    on it. Click on this to bring up the object explorer. Once opened, search for
    `Table View`. If you begin typing the name of a potential component, you should
    see a list of suggested options become available – just like in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Adding an object'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.02_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Adding an object
  prefs: []
  type: TYPE_NORMAL
- en: Once you find **Table View**, drag it straight onto your canvas in Interface
    Builder. Don't worry about it being placed awkwardly, we're going to fix that
    now by using Auto Layout to add some constraints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside our canvas, highlight the `UITableView` object we just added and click
    on the icon highlighted in the following screenshot. Add in top, leading, trailing,
    and bottom constraints of `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Setting constraints'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.03_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Setting constraints
  prefs: []
  type: TYPE_NORMAL
- en: Once done, click `UITableView` object is now pinned perfectly to each edge of
    your screen. Regardless of what size device this is displayed on, those constraints
    will also be adhered to.
  prefs: []
  type: TYPE_NORMAL
- en: Auto Layout enables you to create layouts that automatically adapt to any screen
    size that exists. Your layout currently uses fixed coordinates and dimensions
    to lay out the table view. For instance, your table view is set up to be positioned
    at 0, with a size of (375, 667). This size is perfect for devices such as the
    iPhone 8 and SE, but it wouldn't fit nicely with the iPhone 11 or iPad Pro. This
    combination of a view's position and size is called the frame.
  prefs: []
  type: TYPE_NORMAL
- en: Auto Layout uses constraints to define a layout instead of a frame. For instance,
    to make the table view fit the entire screen, you would add constraints that pin
    every edge of the table view to the corresponding edge of its superview. Doing
    so would make the table view match its superview's size at all times.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching contacts data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order for us to be able to fetch the user's contacts from our device, we
    first need to be granted access via the `Contacts` framework.
  prefs: []
  type: TYPE_NORMAL
- en: Apple are really heavy on privacy, so in turn, they require the user to "allow"
    access whenever an app first tries to read from the Address Book. This doesn't
    just stop at the Address Book, too; this can be found for camera access, location
    services, photos, and more.
  prefs: []
  type: TYPE_NORMAL
- en: As in our case, when you need to access privacy-sensitive information, you are
    required to specify a reason as to why you would like to access the information.
    Nothing too detailed – but enough to give the user peace of mind as to why you
    would like to access their data.
  prefs: []
  type: TYPE_NORMAL
- en: This is done by adding an entry to the `Info.plist` file in your project. Whenever
    you need access to privacy-sensitive information, you are required to specify
    this in your app's `Info.plist` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to add this information to `Info.plist`, take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open it from the list of files in the Project navigator on the left.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once opened, hover over the words `Information Property List` at the top of
    the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A plus icon should appear. Clicking it adds a new empty item with a search field
    to the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you begin typing `Privacy – contacts`, Xcode will filter out options for
    you until there is only one left for you to pick.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This option is called **Privacy – Contacts Usage Description** and is the key
    we are looking for.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The value for this newly added key should describe the reason that you need
    access to the specified piece of information. In this case, "reads contacts and
    shows them in a list" should be a sufficient explanation. When the user is asked
    for permission to access their contacts, the reason you specified here will be
    shown, so make sure you add an informative message.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you do choose an informative message that is relevant to your app.
    If Apple review this and don't find it to be acceptable, they could question you,
    or even worse, reject the submission of your app.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's get down to writing some code. Before you can read contacts, you
    must make sure that the user has given the appropriate permissions for you to
    access the contacts data. To do this, the code must first read the current permission
    status. Once done, the user must either be prompted for permission to access their
    contacts, or the contacts must be fetched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following highlighted code to `ViewController.swift`; we''ll cover
    the details a section at a time – but don''t worry, it will all make sense in
    the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To start, we've imported `Contacts` into our `ViewController` class; by doing
    this, we're allowing the `Contacts` framework API to not just be inside our project,
    but specifically in our `ViewController` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ve added a call to a function named `requestContacts` in `viewDidLoad()`
    – we''ll now need to create this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Basically, without going into too many details, this forces iOS (if not already)
    to request permission for your app to access the contacts data. If the current
    status is unknown (or `notDetermined`), then permission will be requested. If
    this is not the case and the framework responds with `didAuthorize == true`, then
    we can now attempt to access the contacts information. We've also added an extra
    condition in there too to check whether we have already previously been authorized.
    You'll notice that `store.requestAccess` looks a little different from a regular
    function call; this is because it uses a completion handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'In asynchronous programming, completion handlers are used often. They allow
    your app to perform some work in the background and then call the completion handler
    when the work is completed. You will find completion handlers throughout many
    frameworks. If you implement a very simple function of your own that takes a callback,
    it might look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Calling a completion-handler looks just like calling a function. The reason
    for this is that a completion handler is a block of code, called a closure. Closures
    are a lot like functions because they both contain a potentially reusable block
    of code that is expected to be executed when called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add our final piece of the puzzle by adding in our function to
    retrieve the contacts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A brief explanation of the preceding code: we pass an instance of `CNContactStore`
    (which we''ve previously been given permission to access), and then we set up
    a request for specific information we would like with the array of `CNKeyDescriptor`.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the call is made and will fetch this information, which is returned
    to us in a `CNContact` object.
  prefs: []
  type: TYPE_NORMAL
- en: Prepping UITableView to display our contacts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With all that ready, let''s head on back to Interface Builder and add in a
    table view cell:'
  prefs: []
  type: TYPE_NORMAL
- en: Highlight the `UITableView` object we added to the canvas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `Table View Cell`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, drag this object onto `UITableView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You''ll notice something a little different this time: the `UITableViewCell`
    object that we dragged automatically snapped into position on our `UITableView`
    object – don''t worry, that''s fine, this is because `UITableViewCell`''s position
    is controlled by the configuration of its `UITableView` object. Next, we are going
    to create an `IBOutlet` for our code. In the same way that we did in [*Chapter
    2*](B14717_02_Final_ASB_ePub.xhtml#_idTextAnchor046), *Working with Dark Mode*,
    create an outlet programmatically in your `ViewController.swift` file, and then
    connect these using Interface Builder.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of the outlet you are going to create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, we need to create a class for `UITableViewCell` – by doing this, we can
    add custom properties to `UITableViewCell`, such as a name, contact information,
    or even an image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back inside our `ViewController.swift` file (but outside of the `ViewController`
    class declaration), add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've created our custom cell, which is a subclass of `UITableViewCell`
    and will carry all the traits of a table view cell that we need. I've also added
    a couple of `IBOutlet` components for the data that we are going to display.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's go hook this up. Head on back to Interface Builder and select the
    `UITableViewCell` object that we added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once highlighted, click on the Identity inspector in the right-hand tool window
    and add `ContactCell` as the **Class** name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Table view class'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.04_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Table view class
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, click on the Attributes Inspector and type in `contactCell` for **Identifier**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Table view cell identifier'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.05_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – Table view cell identifier
  prefs: []
  type: TYPE_NORMAL
- en: Overriding `UITableViewCell`'s class to our custom class will allow us to use
    Interface Builder to connect objects to the `IBOutlet` components that we just
    created. We'll touch on the identifier later on in this chapter, but it's always
    good to get these bits out of the way at the start.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's add a couple of objects to `UITableViewCell`. We'll start with `UILabel`,
    and then `UIImageView` (add these in the same way you did the table view and cell
    – have the image to the left of the cell).
  prefs: []
  type: TYPE_NORMAL
- en: Once added, have a play with the `Autolayout` constraints we learned about earlier.
    The best way to master Auto Layout is trial and error - if you get stuck, just
    refer to the sample project for this chapter to guide you along.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you are done, your cell will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Label with constraints'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.06_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – Label with constraints
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's hook each one of these up to the `IBOutlet` components we created
    – all going well, Interface Builder should pick up on the associated class (`ContactCell`)
    and will allow the outlets to be attached without any problems.
  prefs: []
  type: TYPE_NORMAL
- en: Awesome, we're making great progress, and believe it or not, we're not a million
    miles away from displaying the data in our app – but first, we need to cover some
    important fundamentals of `UITableView` and, more importantly, the delegation
    pattern that iOS used so heavily.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding protocols and delegation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout the iOS SDK and the Foundation framework, a design pattern named
    delegation is used. Delegation allows an object to have another object to perform
    work on its behalf.
  prefs: []
  type: TYPE_NORMAL
- en: When implemented correctly, it's a great way to separate concerns and decouple
    code within your app.
  prefs: []
  type: TYPE_NORMAL
- en: The table view uses the help of two objects to function correctly. One is the
    delegate, and the other is the data source. Any time you use a table view, you
    must configure these two objects yourself. When the time comes for the table view
    to render its contents, it asks data source for information about the data to
    display. The delegate comes into play when a user interacts with the items in
    the table view.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the documentation for `UITableView`, you can find the delegate
    property. The type for delegate is `UITableViewDelegate?`. This tells you two
    things about delegate. First of all, `UITableViewDelegate` is a protocol. This
    means that any object can act as a delegate for a table view, as long as it implements
    the `UITableViewDelegate` protocol. Second, the question mark at the end of the
    type name tells you that the delegate is an optional property. An optional property
    either has a value of the specified type, or it is nil. The table view's delegate
    property is optional because you do not have to set it to create a functioning
    table view.
  prefs: []
  type: TYPE_NORMAL
- en: A protocol, such as `UITableViewDelegate`, defines a set of properties and methods
    that must be implemented by any type that wants to conform to the protocol. Not
    all methods must be explicitly implemented by conforming objects. Sometimes, a
    protocol extension provides a reasonable default implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to delegate, `UITableView` has a data source property. data source''s
    type is `UITableViewDataSource?`, and just like `UITableViewDelegate`, `UITableViewDataSource`
    is a protocol. However, `UITableViewDelegate` only has optional methods, meaning
    you don''t need to implement any methods to conform to `UITableViewDelegate`.
    `UITableViewDataSource` does have required methods: the methods that need to be
    implemented are used to provide the table view with just enough information to
    be able to display the correct number of cells with the right content in them.'
  prefs: []
  type: TYPE_NORMAL
- en: If this is the first time you're learning about protocols and delegation, you
    might feel a little bit lost right now. That's OK; you'll get the hang of it soon.
    Throughout this book, your understanding of topics such as these will improve
    bit by bit. You will even learn about a concept called protocol-oriented programming!
  prefs: []
  type: TYPE_NORMAL
- en: For now, you must understand that a table view asks for a different object for
    the data it needs to show and that it also uses a different object to handle certain
    user interactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can break the flow of displaying content in a table view down into a couple
    of steps; when the table view needs to reload the data, it does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The table view checks whether `dataSource` is set, and asks it for the number
    of sections it should render.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the number of sections is passed back to the table view, `dataSource` is
    asked for the number of items for each section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With knowledge about the number of sections and items that need to be shown,
    the table view asks `dataSource` for the cells it should display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After receiving all of the configured cells, the table view can finally render
    these cells to the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These steps should give you a little bit more insight into how a table view
    uses another object to figure out the contents it should render. This pattern
    is compelling because it makes the table view an extremely flexible component.
    Let's put some of this newfound knowledge to use!
  prefs: []
  type: TYPE_NORMAL
- en: Conforming to the UITableView protocols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make `ViewController` both the delegate and the data source for its table
    view, it will have to conform to both protocols. It is a best practice to create
    an extension whenever you make an object conform to a protocol. Ideally, you make
    one extension for each protocol you want to implement. Doing this helps to keep
    your code clean and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following extension to `ViewController.swift`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After doing this, your code contains an error. That's because none of the required
    methods from `UITableViewDataSource` have been implemented yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two methods you need to implement to conform to `UITableViewDataSource`.
    These methods are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tableView(_:numberOfRowsInSection:)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tableView(_:cellForRowAt:)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's go ahead and fix the error Xcode is showing by adjusting the code a little
    bit. We'll also need to make a couple of small changes to display our contacts
    within our table view.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by adding a global variable to our `ViewController` class. Add
    in the following just after the class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've instantiated an array of `CNContact`, which is what we get back
    in our `retrieveContacts` function when `store.unifiedContacts` is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, make the following modification to our `retrieveContacts` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Perfect – now fill in the blanks with those delegates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Our first delegate method, `tableView(_:numberOfRowsInSection:)`, requires us
    to return the number of cells we want to display. As we want to display all of
    our contacts, we simply pass back the number of contacts in our array, as highlighted
    in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s implement the `tableView(_:cellForRowAt:)` delegate. Copy in the
    following code and we''ll go through it one step at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Basically, this delegate method is called for every cell that is going to be
    generated in our table view, so if `contacts.count == 5`, then this will be called
    5 times. A way for us to identify which cell is currently being called is to inspect
    the `indexPath.row` value that is being passed in with each call.
  prefs: []
  type: TYPE_NORMAL
- en: If you take a look at the first line of code with the preceding delegate, you'll
    see that we have accessed the specific contact by querying our array of `CNContact`
    with the `indexPath.row` value. From this, we simply just create an instance of
    `UITableViewCell`, assign a property of `CNContact` to `.textLabel`, and return
    the instance.
  prefs: []
  type: TYPE_NORMAL
- en: We're almost ready to see our changes in action; just a couple more things to
    add in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Head on back to our `viewDidLoad()` function and add the following highlighted
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are telling our `UITableView` instance that our current `ViewController`
    class is the delegate base for all `UITableView` protocol operations. In a nutshell
    – the delegates we just added will get called when we try to perform any actions
    on our table view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add the following highlighted code to the end of our `retrieveContacts`
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The reason we do this is again down to asynchronous programming. By design,
    our table view will try and display data as soon as `ViewController` is loaded.
    At this point, our contacts may not be available, we may have not been given suitable
    permission, or simply, the function's callback may not have returned all the data
    in time.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if that''s the case, once we know that all the data is ready to be displayed,
    we simply ask the table view to reload. Go ahead and run your app in the simulator
    – all going well, you will be prompted by the `Contacts` framework to allow permission
    to access your contacts, shortly followed by a list of contact details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – User consent and user list'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.07_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – User consent and user list
  prefs: []
  type: TYPE_NORMAL
- en: In this part, we learned about how important protocols and delegates are in
    iOS development, and by hooking up a couple of simple functions, we were able
    to easily yet effectively display data in `UITableView`. Now, let's take a look
    at how we can customize each cell some more, with the `UITableViewCell` override
    we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the custom UITableViewCell override and the reuse identifier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Back in a previous section, *Prepping UITableView to display our contacts*,
    you'll remember that we created our custom `UITableViewCell` override called `ContactCell`,
    but in the end we never really used it.
  prefs: []
  type: TYPE_NORMAL
- en: We did this on purpose, firstly to introduce you to the fact that `UITableViewCell`
    does have a minimal default offering where `textLabel` is given for you to add
    your required text. This can come in handy as a really lightweight way of generating
    a `UITableView` object and displaying some simple data – a no-fuss approach for
    quick wins or a situation where one line is good enough. However, if you want
    to be creative with your cells, then this is where the custom option comes into
    play.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s head back to `tableView(_:cellForRowAt:)` and see how we''d make the
    change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to start with, let''s take a look at the first part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are instantiating the use of a reusable `UITableViewCell` with the
    identifier of `contactCell`, which is of the `ContactCell` class.
  prefs: []
  type: TYPE_NORMAL
- en: Sounds confusing? Maybe a little, but think of it this way – we created a custom
    cell class that we assigned to our `UITableViewCell` object back in Interface
    Builder. We then gave this an identifier of `contactCell` – here, we simply called
    upon that cell to be used so that we can access its properties (remember the `nameLabel`
    and `contactImageView` properties we added).
  prefs: []
  type: TYPE_NORMAL
- en: Once we have access to an instance of that cell, we can then simply assign each
    property accordingly with data taken from our contact instance. Notice that we're
    doing a check against the image data in the contacts due to the possibility of
    no image yet being associated with a contact – here, we've added a little fallback
    to display a system image (using SF Symbols).
  prefs: []
  type: TYPE_NORMAL
- en: If you want you add an image, simply fire up the Contacts app in the simulator
    and drag an image from your Mac over - You should now be able to select this and
    assign this from the Contacts app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and make those changes, and then run the app again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Contact list with image'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.08_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 – Contact list with image
  prefs: []
  type: TYPE_NORMAL
- en: Perfect, but what is this `dequeueReusableCell` all about? Don't worry, we'll
    cover that in a later section, *Advances in UITableView and UICollectionView*.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to implement `UITableView` and a custom `UITableViewCell`,
    pulling data obtained by accessing our contacts via the `Contacts` framework and
    displaying it within our app. Now, let's spend some time digging a little deeper
    into the art of table views and how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring UITableView further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll touch on some extra little bits that will allow you to
    make the most out of `UITableView`. We'll also cover in more detail some areas
    previously explored, such as the reuse identifier.
  prefs: []
  type: TYPE_NORMAL
- en: Further understanding reuse identifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier in this chapter, you learned about cell-reuse in table views. We assigned
    a reuse identifier to a table view cell so that the table view would know which
    cell it should use to display contacts in. Cell-reuse is a concept that is applied
    to a table view so that it can reuse cells that it has already created.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the only cells that are in memory are either on the screen or
    barely off the screen. The alternative would be to keep all cells in memory, which
    could potentially mean that hundreds of thousands of cells are held in memory
    at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a visualization of what cell reuse looks like, have a look at the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_3.09_B14717.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Table view cell layout
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are just a few cells in the diagram that are not on the
    visible screen. This roughly equals the number of cells that a table view might
    keep in memory. This means that regardless of the total amount of rows you want
    to show, the table view has roughly constant pressure on your app's memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: A cell is first created when `dequeueReusableCell(withIdentifier:)` is called
    on the table view and it does not have an unused cell available. Once the cell
    is either reused or created, `prepareForReuse()` is called on the cell. This is
    a great spot to reset your cells to their default state by removing any images
    or setting labels back to their default values.
  prefs: []
  type: TYPE_NORMAL
- en: Next, `tableView(_:willDisplay:forRowAt:)` is called on the table view's delegate.
    This happens right before the cell is shown. You can perform some last-minute
    configuration here, but the majority of the work should already be done in `tableView(_:cellForRowAtIndexPath:)`.
  prefs: []
  type: TYPE_NORMAL
- en: When the cell scrolls off screen, `tableView(_:didEndDisplaying:forRowAt:)`
    is called on the delegate. This signals that a previously visible cell has just
    scrolled out of the view's bounds.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all this cell life cycle information in mind, the best way to fix the
    image reuse bug is by implementing `prepareForReuse()` on `ContactCell`. Add the
    following implementation to remove any images that have previously been set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's take a look at some other enhancements that we can make in our app
    by using prefetching.
  prefs: []
  type: TYPE_NORMAL
- en: Prefetching in table views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to `UITableViewDelegate` and `UITableViewDataSource`, a third protocol
    exists that you can implement to improve your table view's performance.
  prefs: []
  type: TYPE_NORMAL
- en: It's called `UITableViewDataSourcePrefetching`, and you can use it to enhance
    your data source. If your data source performs some complex task, such as retrieving
    and decoding an image, it could slow down the performance of your table view if
    this task is performed at the moment that the table view wants to retrieve a cell.
    Performing this operation a little bit sooner than that can positively impact
    your app, in those cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how would we implement this? Simple, we first just conform `ViewController`
    to the new delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice that a fundamental difference here is within the `indexPath` parameter
    being passed in. This time, we have an array of `IndexPath`, as opposed to a single
    index, in turn, allowing us to perform batch processing on a set of cells that
    our table view would like us to display.
  prefs: []
  type: TYPE_NORMAL
- en: This would be ideal if data from your cell has to be obtained asynchronously
    – such as an image or real-time data. You could really work hard here to perform
    and calculate the right way to display your data to get the optimum performance.
  prefs: []
  type: TYPE_NORMAL
- en: Cell selection in table views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since a table view will call methods on its delegate whenever they are implemented,
    you don't need to tell the table view that you want to respond to cell selection.
    This automatically works if the table view has a delegate, and if the delegate
    implements `tableView(_:didSelectRowAt:)`.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation you'll add to our app, for now, is a very simple one. When
    the user taps a cell, the app displays an alert.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the extension in `ViewController.swift`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tableView(_:didSelectRowAt:)` method receives two arguments: the first
    is the table view that called this delegate method. The second argument is the
    index path at which the selection occurred.'
  prefs: []
  type: TYPE_NORMAL
- en: The implementation you wrote for this method uses the index path to retrieve
    the contact that corresponds with the tapped cell, so the contact name can be
    shown in an alert.
  prefs: []
  type: TYPE_NORMAL
- en: You could also retrieve the contact's name from the tapped cell. However, this
    is not considered good practice because your cells and the underlying data should
    be as loosely coupled as possible.
  prefs: []
  type: TYPE_NORMAL
- en: When the user taps the **Done** button in the alert, the table view is told
    to deselect the selected row.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't deselect the selected row, the last tapped cell will always remain
    highlighted. Note that the alert is displayed by calling `present(_:animated:completion:)`
    on the view controller. Any time you want to make a view controller display another
    view controller, such as an alert controller, you use this method.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned a lot about what makes a table view tick, including
    a good understanding of how the reuse identifier works. Next, we'll take a look
    at `UICollectionView`, the `UITableView` class's bigger (or younger, really) brother,
    comparing similarities to each class and also key differences, too.
  prefs: []
  type: TYPE_NORMAL
- en: Working with UICollectionView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we took on the mighty `UITableView` – learning all
    about the delegate pattern and how to build our unique lists with custom cells.
    In this section, we'll take a look at `UICollectionView`, mainly looking at how
    we are comparing one class to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the outset, when asked what the fundamental differences are between them
    both, most people will initially say the same thing: "Collection views allow horizontal
    scrolling" – which is very true, but what it''s doing is harnessing the power
    of `UITableView` with the ability to manipulate and override a layout that would
    allow a grid layout, for example.'
  prefs: []
  type: TYPE_NORMAL
- en: If you need to go deeper into a complex custom layout, this again is where `UICollectionView`
    comes into play, with the support of the `UICollectionViewDelegateFlowLayout`
    protocol, allowing you as a developer to manipulate custom layouts.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our collection view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by creating a new project in the exact same way as we did for
    a table view:'
  prefs: []
  type: TYPE_NORMAL
- en: This time, search for `Collection View` in the object window (*you won't need
    to add in a* `CollectionView` *cell as the collection view already does this for
    you*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add in your constraints too so that it scales to the full size of the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back to `ViewController`, we'll need to create and hook up our `IBOutlet` components
    just like we did with the table view (but call your property something like `collectionView`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve done that, we''ll need to create another extension, but this time,
    our protocols will be slightly different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Our two delegate methods in the preceding example are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`collectionView(_:numberOfItemsInSection:)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collectionView(_:cellForItemAt:)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both offer the same as their `UITableView` counterparts; only one difference
    you'll notice is the reference to the term `Item` rather than `Row`. This is because
    in `UITableView`, the layout is purely linear, so each cell is treated as a row.
    With `UICollectionView`, this is not the case – so, each cell is referred to as
    an item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to create another custom cell. Copy and paste the one we made
    for our table view and make the following highlighted changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The differences in the preceding code are subtle, but one of them is very important:
    our subclass is now of the `UICollectionViewCell` type (as opposed to `UITableViewCell`),
    and we''ve also added in a couple of extra outlets, as we''ll be adding a touch
    more data.'
  prefs: []
  type: TYPE_NORMAL
- en: For something different, we are going to create a scrolling horizontal list
    of our contacts and a grid layout. Let's head on over back to the interface builder
    and modify our canvas a little.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by adding another text field. Notice from the following figure
    how I can adjust the size of my cell too:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Collection view cell'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.10_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 – Collection view cell
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this in a couple of places. If we highlight **Collection View** and
    select the Size Inspector, we can do it in there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Collection View Size Inspector'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.11_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 – Collection View Size Inspector
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can do this directly on the cell itself, as shown in the
    following screenshot, again by selecting the Size Inspector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Collection View Cell Size Inspector'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.12_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.12 – Collection View Cell Size Inspector
  prefs: []
  type: TYPE_NORMAL
- en: This is great for two reasons. First, you can set the size of your cell visually,
    which is always a nice and convenient way to do things. Secondly, even if you
    are going to override your cell size programmatically (due to you requiring a
    more dynamic approach), it allows you to visualize and set your constraints so
    that you know what you have to play with. I'm just going to set mine to 150 width
    x 230 height, for now, which should give us enough to play with.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s carry on with setting up our interface. Again, we''ll need to override
    **Class** with our custom class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Collection View class'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.13_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.13 – Collection View class
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we need to assign our cell identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Collection View cell identifier'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.14_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.14 – Collection View cell identifier
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we set **Estimated Height** to **None**. This stops our cell from dynamically
    resizing itself based on the size of the content within the cell (for example,
    a label with a really long name or address):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – Collection View estimated cell size'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.15_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.15 – Collection View estimated cell size
  prefs: []
  type: TYPE_NORMAL
- en: We're almost done – just a few more little things we need to add in. Notice
    anything missing from our `viewDidLoad()` function that we had in the `UITabelView`
    example?
  prefs: []
  type: TYPE_NORMAL
- en: Yep, we've yet to set our delegate method to our `ViewController` object, but
    for this example, I'm going to show you another way that we can do that via Interface
    Builder, as opposed to doing this programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Highlight your `CollectionView` object, press and hold *Ctrl* on your keyboard,
    then primary click and hold your cursor – if you start to drag your cursor, you''ll
    see a line (just like when we connect `IBOutlet`). Drag the line to the `ViewController`
    object and release. You''ll then be presented with the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16 – Collection View delegate outlet'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.16_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.16 – Collection View delegate outlet
  prefs: []
  type: TYPE_NORMAL
- en: Select **dataSource**, and then repeat the process and select **delegate**.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s it – other than a few minor changes here and there, we''ve successfully
    set up `UICollectionView` in pretty much the same way as we did for our `UITableView`.
    Let''s go ahead now and run the project to see how it all looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.17 – Collection View layout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.17_B14717.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.17 – Collection View layout
  prefs: []
  type: TYPE_NORMAL
- en: That looks great – I mean, apart from the cells looking a little out of place
    – but don't worry, we're going to take a look at our options on how we can change
    that in the next part, by being introduced to the `UICollectionViewDelegateFlowLayout`
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing layout with UICollectionViewDelegateFlowLayout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the last section, we created our very first `UICollectionView` project based
    on everything we had learned from creating a `UITableView` project previously.
    One thing we did learn that was fundamentally different from a table view was
    that our cells can be laid out differently.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we go about manipulating our cells to get them to do exactly what
    we want them to do? For that, we need to implement the `UICollectionViewDelegateFlowLayout`
    protocol – but what does this have to offer? Let's start by taking a look at one
    of the most commonly used delegate methods in this protocol and how easily it
    can transform our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over in our extension, add in the following highlighted protocol alongside
    the existing ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now, in good practice, you can separate each one of these protocols into its
    own extension – but as we are only dealing with a few delegates for each, we'll
    be fine to keep them in one place for now.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If your `ViewController` object starts to get a little large, you can move your
    extensions out into a separate file – this makes working on them easier and keeps
    your files nice and clean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''re going to add in the following `delegate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sizeForItem` delegate simply allows us to programmatically set a size
    of our cell, so let''s have a play with that and see what we can come up with.
    Add the following code to the preceding function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'So, here, we''re performing a nice simple calculation: we''re taking the width
    of the current screen, dividing it by 2, and then subtracting 10 (for a little
    padding), and having that as our cell width. Finally, we''ll add a nice static
    value for our height. Go ahead and run your app and see what it gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.18 – Collection View layout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.18_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.18 – Collection View layout
  prefs: []
  type: TYPE_NORMAL
- en: Nice, let's look at what else we could do. How about simply returning the full
    size of the screen?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s change the direction of the scroll direction; we can do this via
    Interface Builder by selecting **Collection View**. Change the value to **Horizontal**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.19 – Collection View Scroll Direction'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.19_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.19 – Collection View Scroll Direction
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and run the app again – how does it look?
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.20 – Collection View Scroll Direction layout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.20_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.20 – Collection View Scroll Direction layout
  prefs: []
  type: TYPE_NORMAL
- en: Perfect – with only a small change, we've managed to make a massive difference
    to our app, clearly highlighting the power of `UICollectionView` compared to `UITableView`.
  prefs: []
  type: TYPE_NORMAL
- en: Before we wrap up this section on `UICollectionView`, let's take a quick look
    at the other delegate methods offered to us by `UICollectionViewDelegateFlowLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: Size of an item (cell)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you need to manipulate the bounds or frame of an item, use `collectionView(_:layout:sizeForItemAt:`,
    which asks the delegate for the size of the specified item's cell.
  prefs: []
  type: TYPE_NORMAL
- en: Section and spacing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are options to programmatically adjust the spacing between cell
    items and sections (excluding headers and footers):'
  prefs: []
  type: TYPE_NORMAL
- en: '`collectionView(_:layout:insetForSectionAt:)`: Asks the delegate for the margins
    to apply to content in the specified section'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collectionView(_:layout:minimumLineSpacingForSectionAt:)`: Asks the delegate
    for the spacing between successive rows or columns of a section'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collectionView(_:layout:minimumInteritemSpacing ForSectionAt:)`: Asks the
    delegate for the spacing between successive items in the rows or columns of a
    section'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Footer and header sizing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are options to programmatically adjust the spacing between cell
    items specifically for headers and footers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`collectionView(_:layout:referenceSizeForHeaderInSection:)`: Asks the delegate
    for the size of the header view in the specified section'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collectionView(_:layout:referenceSizeForFooterInSection:)`: Asks the delegate
    for the size of the footer view in the specified section'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we learned all about `UICollectionView` components – how to
    set them up in Xcode and the differences between them and `UITableView` components
    – and were able to see the benefits they give us along with the `UICollectionViewDelegateFlowLayout`
    protocol in order customize our apps more visually. In the next section, we're
    going to take a look a little deeper into some of the advancements in `UITableView`.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring UICollectionView further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll again touch on some extra little bits that, just like
    with our table views, will allow us to really harness the power of a collection
    view – specifically when it comes to calculating the size of your layout. We'll
    start by taking a look at some overrides that we can make use of to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a custom UICollectionViewLayout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implementing a large and complex feature such as a custom collection view layout
    might seem like a huge challenge for most people.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your layout involves calculating the position for every cell that your
    collection view will display. You must ensure that these calculations are performed
    as quickly and as efficiently as possible because your layout calculations directly
    influence the performance of your collection view. A poor layout implementation
    will lead to slow scrolling and a lousy user experience eventually.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, the documentation that has been provided for creating a collection
    view layout is pretty good as a reference to figure out whether you're on the
    right track.
  prefs: []
  type: TYPE_NORMAL
- en: If you take a look at Apple's documentation on `UICollectionViewLayout`, you
    can read about its role in a collection view. The available information shows
    that a custom layout requires you to handle the layout for cells, supplementary
    views, and decoration views. Supplementary views are also known as headers and
    footers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how we could begin to implement that. We''ll start by
    creating our own class to do the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding code, here we've implemented a subclass of
    `UICollectionViewLayout` and have a variety of overridden functions that we can
    use – let's go through these now.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing collectionViewContentSize
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A collection view uses the `collectionViewContentSize` property from its layout
    to figure out the size of its contents. This property is especially important
    because it is used to configure and display the scrolling indicators for the collection
    view.
  prefs: []
  type: TYPE_NORMAL
- en: It also provides the collection view with information about the direction in
    which scrolling should be enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing this property uses the number of rows and columns in the collection
    view. It also takes the item size and item spacing into account to come up with
    the size of all of its contents together.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing layoutAttributesForElements(in:)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More complex than `collectionViewContentSize` is `layoutAttributesForElements(in:)`.
    This method is responsible for providing a collection view with the layout attributes
    for several elements at once.
  prefs: []
  type: TYPE_NORMAL
- en: The collection view always provides a rectangle, for which it needs layout attributes.
    The layout is responsible for providing these attributes to the collection view
    as fast as possible. The implementation of this method must be as efficient as
    you can get it to be. Your scroll performance depends on it.
  prefs: []
  type: TYPE_NORMAL
- en: Even though there is only a small number of cells visible at a time, the collection
    view has a lot more content outside of its current viewport. Sometimes it is asked
    to jump to a particular cell, or the user scrolls extremely fast.
  prefs: []
  type: TYPE_NORMAL
- en: There are many cases where the collection view will ask for all layout attributes
    for several cells at once. When this happens, the layout object can help the cell
    determine which cells should be visible for a particular rectangle. This is possible
    because the layout attributes not only contain the rectangle in which a cell should
    be rendered but they also know the `IndexPath` object that corresponds with that
    specific cell.
  prefs: []
  type: TYPE_NORMAL
- en: This is a pretty complicated matter, and it's okay if you find this to be a
    little bit confusing. As long as you understand that a collection view can ask
    its layout which cells are present in a certain `CGRect` instance and how they
    should be rendered, you understand what `layoutAttributesForElements(in:)` does.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing layoutAttributesForItem(at:)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another way that a collection view can request layout attributes for its layout
    is by requesting the attributes for a single item. Because the collection view
    does so by supplying an index path, this method is quite simple to implement.
  prefs: []
  type: TYPE_NORMAL
- en: The layout you implemented assumes that only a single section exists in the
    collection view and the layout attributes array is sorted by index path because
    that's the order in which all items were inserted into the array.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing shouldInvalidateLayout(forBoundsChange:)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Getting the implementation for `shouldInvalidateLayout(forBoundsChange:)` is
    crucial to having a great collection view layout that has amazing performance.
  prefs: []
  type: TYPE_NORMAL
- en: If you implement this method incorrectly, you could constantly be invalidating
    the layout, meaning you will need to recalculate all the time.
  prefs: []
  type: TYPE_NORMAL
- en: It's also possible that the collection view will never update its layout at
    all, even when it should. The collection view will call this method any time its
    size changes. For instance, when the user rotates their device or when your app
    runs on an iPad, the user opens another app in multitasking mode.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning a custom layout to your collection view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final step to using your custom layout is telling your collection view to
    use your layout. You have already seen that you can assign a custom class to the
    layout for a collection view in Interface Builder.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this only works when your layout inherits from `UICollectionViewFlowLayout`,
    which your layout does not inherit from. Luckily, you can also set your collection
    view''s layout in code. Update your `viewDidLoad` method in `ViewController.swift`
    by adding the following line to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This line sets your new layout as the current layout. You can now remove the
    `UICollectionViewDelegateFlowLayout` extension from `ViewController.swift` as
    it is not needed anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've looked at layouts in more detail, let's take a look at how we
    handle user interaction with cell selection.
  prefs: []
  type: TYPE_NORMAL
- en: Cell selection in collection views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although almost identical to its `UITableView` counterpart, I thought it was
    worth calling this function out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: With again the only real difference being that `Row` is replaced with `Item`,
    this delegate method performs in the exact same way.
  prefs: []
  type: TYPE_NORMAL
- en: We can make use of the reuse identifier and work with our cell directly should
    we need to manipulate it in any way (see [*Chapter 5*](B14717_05_Final_ASB_ePub.xhtml#_idTextAnchor141),
    *Immersing Your Users with Animation*, for some exciting things we can do here).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we delved into the inner workings of the `UICollectionView`
    layout options and explored further how we can use `UICollectionViewLayout` to
    subclass our own layout, allowing us, the developer, to utilize specific and complex
    calculations should we need too. In our next and final section, we'll take a look
    at how Apple's new powerful UI framework, SwiftUI, handles lists.
  prefs: []
  type: TYPE_NORMAL
- en: Working with lists in SwiftUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back at WWDC 2019, Apple unveiled to the world a brand-new UI framework called
    SwiftUI. Built from the ground up, SwiftUI is a powerful alternative to UIKit
    and AppKit, offering developers the ability to write code using declarative syntax.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to cover what SwiftUI has to offer in terms of
    generating lists and what we may need to do going forward should we require the
    use of anything that isn't available to use just yet.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our first SwiftUI project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this, we''re going to need to create a new single view app, the same as
    before, but only this time we''ll need to select **SwiftUI** for our user interface,
    as highlighted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.21 – New SwiftUI project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.21_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.21 – New SwiftUI project
  prefs: []
  type: TYPE_NORMAL
- en: If you're unfamiliar with SwiftUI, you'll notice a couple of differences. You'll
    no longer have a `ViewController.swift` file – this has been replaced with `ContentView.swift`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Highlight the file to take a look at the contents; you should see the following
    boilerplate code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: First, let's take a look at the `ContentView` struct – this is the first step
    of how SwiftUI builds up its declarative interface. Inside the `ContentView` struct
    is the body. Notice how these conform to either `View` or `some View` – that's
    because the concept of `ViewController` components in SwiftUI is no longer used;
    everything is a view being returned to the window.
  prefs: []
  type: TYPE_NORMAL
- en: 'But without getting too involved in the workings of SwiftUI, all we care about
    now is the contents of the body declaration. So, in the case of the preceding
    example, all we care about is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`Text` is SwiftUI''s equivalent to `UILabel` – pretty neat, right, how a simple
    one line of code can construct, instantiate, and accept a value to display? Oh,
    and no need to add it to the view either – the fact that this line of code is
    present is enough.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another benefit to using SwiftUI is the ability to preview code changes on
    the fly. If you take a look in Xcode to the right of our opened `ContentView.swift`
    file, you''ll see the preview assistant. Click **Resume** at the top left and
    we should see a preview of our app appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.22 – SwiftUI "Hello, World!"'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.22_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.22 – SwiftUI "Hello, World!"
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at how we would add in a list of items.
  prefs: []
  type: TYPE_NORMAL
- en: Building a list in SwiftUI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll start simple, by just adding our already-existing label to a list. Make
    the following highlighted code change, and if required, press resume in the preview
    assistant window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s right, it really is as simple as that. Go on and add a couple more
    `Text` views and see how it looks – even try running this in your simulator to
    see how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.23 – SwiftUI list'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.23_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.23 – SwiftUI list
  prefs: []
  type: TYPE_NORMAL
- en: Nice and simple, but much like we did with our `UITableView` components and
    `UICollectionView` components, let's see how we could go about adding in some
    external data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make the following highlighted change to our code in `ContentView.swift`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've added in a `ForEach` function to our list; this is going to iterate
    around our array of contacts that we created just outside our body.
  prefs: []
  type: TYPE_NORMAL
- en: 'But if we press resume, you''ll see that we get no data…let''s fix this. Take
    a look just below the `ContentView` struct and you''ll see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This struct is how our preview assistance can display our app – our own little
    internal testing/playground while we develop our SwiftUI view – without even needing
    to run the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add some code in then to inject a little mock data into our preview.
    Make the following highlighted changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We simply just create some mock data that we can inject straight into our view,
    if not already updated. Click **Resume** on the preview assistant and see your
    code in action – however, if you run this in the simulator, you won't see anything,
    as the preview is no longer in effect and the app you see is your actual app (which
    we haven't added any data to yet).
  prefs: []
  type: TYPE_NORMAL
- en: The equivalent to creating a custom cell in SwiftUI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's hard trying not to make a direct comparison to UIKit objects when developing
    with SwiftUI – but we'll all do it and it's okay, because usually there is a way
    to perform a similar action or a new way to learn.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to the beginning of this section, I mentioned that SwiftUI is all
    about views, and that''s no different when implementing a custom "cell" for a
    list in SwiftUI. We''ll start by creating a new view (we''ll do this inside of
    your `ContentView.swift` file, but outside of the initial class declaration):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like `ContentView`, our new `RowView` is a simple view being created that
    can be used anywhere within SwiftUI. The structs can accept a `name: String` variable
    and will display this within a `Text` view – just like we did inside `ContentView`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s amend our code to make use of this. Make the following highlighted
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: It really is a simple as that; we can now treat `RowView` as we did collection
    view or table view cells and decorate them or work on them independently to their
    parent lists.
  prefs: []
  type: TYPE_NORMAL
- en: You can even create your own preview provider just for `RowView` so that you
    can again inject mock data whilst developing.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we were introduced to SwiftUI as a framework and took a look
    at the basic building blocks needed to create a project. From this, we learned
    about how lists are used and how we can use the preview assistant to our advantage
    when developing SwiftUI interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at everything to do with lists. We started by learning
    how to create a `UITableView` object – pulling in contacts from our device and
    displaying them in the way we want. We then moved on to `UICollectionView`, comparing
    it against our previous implementation and looking at some of the subtle and larger
    differences it had to offer – such as cell layout and manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: We then delved a little deeper into each of these, specifically looking at layouts
    with `UICollectionView` components, which is one of its most powerful features.
  prefs: []
  type: TYPE_NORMAL
- en: We then finished off by taking a look at the SwiftUI framework and how Apple
    has made it so easy not only to develop but also to display data in different
    ways that we have been used to previously with the ease of the declarative syntax
    and the use of the preview assistant.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be looking at taking our lists a step further and
    creating a details page for them to navigate to with the use of the cell interaction
    that we covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apple Developer documentation on table views:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://developer.apple.com/documentation/uikit/views_and_controls/table_views](https://developer.apple.com/documentation/uikit/views_and_controls/table_views)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Apple Developer documentation on collection views:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://developer.apple.com/documentation/uikit/views_and_controls/collection_views](https://developer.apple.com/documentation/uikit/views_and_controls/collection_views)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Learn SwiftUI* (Packt Publishing):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/business-other/learn-swiftui](https://www.packtpub.com/business-other/learn-swiftui)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
