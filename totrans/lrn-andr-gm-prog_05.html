<html><head></head><body>
        

            
                <h1 class="header-title">Adding Animation to Your Game</h1>
            

            
                
<p>We have learned how to create sprites on screen as well as made our background image scroll continuously. Sprites are basically just images, which are used for game assets. Now, it is time to add a bit more spice to it and make it interesting. In this chapter, we will make our player character appear on screen on top of our background and add an animation that will make the player run. In this chapter, you will learn the following:</p>
<ul>
<li>Creating sprite animations based on sprite sheets</li>
<li>Running basic animations</li>
<li>Creating an abstract class to serve as a foundation for our future game objects</li>
</ul>
<p>By the end of this chapter, you will have a running character on screen. So let's begin!</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Adding animations to make your game more awesome</h1>
            

            
                
<p>To start this chapter, we will need a collection of images, which we call sprites. We saw in the previous chapter how we had used  <kbd>image_1</kbd> and <kbd>image_2</kbd> as examples, but we will expand on them and make this more interesting. We will try and make a proper run cycle of our player character in a sprite sheet. To understand this in a better way, let's take a look at the following image:</p>
<p class="CDPAlignCenter CDPAlign CDPAlignLeft"><img class="image-border" src="img/B05066_05_01.png"/></p>
<p>Our run cycle animation sprites</p>
<p class="CDPAlignCenter CDPAlign CDPAlignLeft">In the preceding image, you can observe we have a set of images that are prefixed with the text <kbd>Run</kbd> followed by a set of numbers that represent frames. So, basically, we will loop from frame <kbd>Run_000</kbd> to <kbd>Run_009</kbd>, which will give us a continuous running effect. However, for the sake of simplicity, we will be merging these frames into one single image and read pixel data from it. Also, to keep it simple, we will only make the run cycle animation to three frames. If you want, you can add more frames for better animation quality. So, we will be using the following sprite sheet:</p>
<div><img class="image-border" src="img/B05066_05_02.jpg"/></div>
<p>This is what an actual sprite sheet looks like; we will name this sprite sheet as player_run.png</p>
<p class="CDPAlignCenter CDPAlign CDPAlignLeft">We will be dealing with pixels to run our animation, so it is extremely important for us to know the dimensions of this image. In simple terms, we need to know the width and height of this image in pixels. The dimensions of one frame of our image are 200 x 82 pixels, where 200 represents the width and 82 represents the height of our image. In our sprite sheet, we have three such sprites. Thus, we simply multiply our width by the number of images in our sprite sheet, which is three in this case. So, the overall width of our image is 600 pixels. As you can see, we are using an image that has a landscape orientation, which means that our image's width is more than the height, so our height dimension remains the same. So, basically to run our animation, we only need to scan through our frames horizontally. The final resolution of our sprite sheet is 200 x 82.</p>
<p>The resolution of your image might differ from the ones in this book, so make sure that you calculate the numbers properly before proceeding with writing them in the code.</p>
<p class="CDPAlignCenter CDPAlign CDPAlignLeft">So, let's dive into the art of animating our player character; however, before we do that, we also need to create our player character on screen. Here's our task list for now:</p>
<ol>
<li>Create a player on screen.</li>
<li>Make Run animation play.</li>
</ol>
<p>Once we are done with these two objectives, we will take touch input in order to make our player jump.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Making our player character</h1>
            

            
                
<p>We saw in the previous chapter how to create our background image. In theory, it is almost similar to the previous chapter to create our player character, but since we are going to deal with animations in the further part of this chapter, we will need to modify our code a bit. Let's get started with that first.</p>
<p>Now, as a programmer, you have to keep in mind that there are many ways to do one particular thing; therefore, just as a demonstration to get a clearer understanding, we will modify our background image code a little. Open up your <kbd>BackgroundImage.java</kbd> file and remove the <kbd>setVector</kbd> method. Now, you will see that there will be an error in our <kbd>GameView.java</kbd> file since our <kbd>setVector</kbd> method does not exist; let's fix that. Make a static final variable, which will be accessible from any class. We will then set it as a speed variable. Then, in our <kbd>BackgroundImage.java</kbd> file's constructor, we will set the displacement variable as the speed for this. Here's how we will modify our code blocks. Code changes are marked in bold.</p>
<p>The following is the code for <kbd>BackgroundImage.java</kbd>:</p>
<pre>
package nikhil.nikmlnkr.game;<br/><br/>import android.graphics.Bitmap;<br/>import android.graphics.Canvas;<br/><br/>public class BackgroundImage {<br/><br/>    private int xc, yc, dxc;<br/>    private Bitmap backgroundImage;<br/><br/>    public BackgroundImage(Bitmap res){<br/>        backgroundImage = res;<br/><strong>        dxc = GameView.MOVINGSPEED;</strong><br/>    }<br/><br/><br/>    public void update(){<br/>        xc += dxc;<br/>        if(xc &lt; -GameView.WIDTH){<br/>            xc=0;<br/>        }<br/>    }<br/><br/>    public void draw(Canvas canvas){<br/>        canvas.drawBitmap(backgroundImage, xc, yc,null);<br/>        if(xc &lt; 0){<br/>            canvas.drawBitmap(backgroundImage, xc + GameView.WIDTH, yc, null);<br/>        }<br/>    }<br/>}
</pre>
<p>Next, let's take a look at the code for <kbd>GameView.java</kbd>:</p>
<pre>
package nikhil.nikmlnkr.game;<br/><br/>import android.content.Context;<br/>import android.graphics.BitmapFactory;<br/>import android.graphics.Canvas;<br/>import android.view.MotionEvent;<br/>import android.view.SurfaceHolder;<br/>import android.view.SurfaceView;<br/><br/><br/>public class GameView extends SurfaceView implements SurfaceHolder.Callback {<br/>    public static final int WIDTH = 1920;<br/>    public static final int HEIGHT = 1080;<br/><strong>    public static final int MOVINGSPEED = -5;<br/></strong>    private MainGameThread mainThread;<br/>    private BackgroundImage bgImg;<br/><br/>    public GameView(Context context){<br/>    super(context);<br/><br/><br/>        //set callback to the surfaceholder to track events<br/>        getHolder().addCallback(this);<br/><br/>        mainThread = new MainGameThread(getHolder(), this);<br/><br/>        //make gamePanel focusable so it can handle events<br/>        setFocusable(true);<br/>    }<br/><br/>    @Override<br/>    public void surfaceChanged(SurfaceHolder holder, int format,<br/>    int width, int height){}<br/><br/>    @Override<br/>    public void surfaceDestroyed(SurfaceHolder holder){<br/>        boolean retry = true;<br/>        while(retry){<br/>            try{<br/>                mainThread.setRunning(false);<br/>                mainThread.join();<br/>            }catch(InterruptedException e){e.printStackTrace();<br/>            }<br/>            retry = false;<br/>        }<br/>    }<br/><br/>    @Override<br/>    public void surfaceCreated(SurfaceHolder holder){<br/><br/>        bgImg = new BackgroundImage(BitmapFactory.decodeResource<br/>        (getResources(), R.drawable.background_image));<br/><br/>        //we can safely start the game loop<br/>        mainThread.setRunning(true);<br/>        mainThread.start();<br/>    }<br/><br/>    @Override<br/>    public boolean onTouchEvent(MotionEvent event){<br/>        return super.onTouchEvent(event);<br/>    }<br/><br/>    public void update(){<br/>        bgImg.update();<br/>    }<br/><br/>    @Override<br/>    public void draw(Canvas canvas){<br/>        final float scaleFactorX = getWidth()/WIDTH;<br/>        final float scaleFactorY = getHeight()/HEIGHT;<br/>        if(canvas != null) {<br/>            final int savedState = canvas.save();<br/>            canvas.scale(scaleFactorX, scaleFactorY);<br/>            bgImg.draw(canvas);<br/>            canvas.restoreToCount(savedState);<br/>        }<br/>    }<br/>}
</pre>
<p>Now, we haven't done anything really here. We have just modified a logic with different variables. In a similar fashion, you can also apply your own logic to come up with different ways to do one particular thing. Let's now move on to actually make our player character appear on the screen.</p>
<p>Try tweaking the code with your own logic and keeping the output same as a challenge to test your skills.</p>
<p>We will now create an abstract class for our future game objects, such as our player character, missiles, and everything else. We are doing this because there are some sets of data, which are required in almost every object we will be creating in future for our game. So, for the purpose of reusability and persistence, we will create this class. We will call it <kbd>GameObj.java</kbd>. Go ahead and create your new class with the steps that we learned from our previous chapters and write the following code in it:</p>
<pre>
package nikhil.nikmlnkr.game;<br/><br/>import android.graphics.Rect;<br/><br/>/**<br/> * Created by Nikhil on 13-01-2017.<br/> */<br/><br/>public abstract class GameObj {<br/>    protected int xc, yc, dxc, dyc; <br/>    //Our x and y coordinates along with their displacement variables<br/>    protected int width, height;<br/>    //width and height of our objects<br/><br/>    public int getXC() {<br/>        return xc;<br/>    }<br/><br/>    public int getYC() {<br/>        return yc;<br/>    }<br/><br/>    public void setXC(int xc) {<br/>        this.xc = xc;<br/>    }<br/><br/>    public void setYC(int yc) {<br/>        this.yc = yc;<br/>    }<br/><br/>    public int getWidth() {<br/>        return width;<br/>    }<br/><br/>    public int getHeight() {<br/>        return height;<br/>    }<br/><br/>    public Rect getRectangle() {<br/>        return new Rect(xc, yc, xc + width, yc + height);<br/>    }<br/>}
</pre>
<p>So, here we have our abstract <kbd>GameObj.java</kbd> class file, which has the variables and get set methods for them. Observe here that we have also used a <kbd>getRectangle()</kbd> method. This method will be used in the next chapter when we will be working with collisions. In theory, to detect collisions on any object, we need to get its rectangular bounds. Anyway, moving ahead, let's now create our <kbd>Player</kbd> class with the help of this new abstract class we made.</p>
<p>Create a new class and name it <kbd>PlayerCharacter.java</kbd>, and write the following code in it:</p>
<pre>
package nikhil.nikmlnkr.game;<br/><br/>import android.graphics.Bitmap;<br/>import android.graphics.Canvas;<br/><br/>/**<br/> * Created by Nikhil on 13-01-2017.<br/> */<br/><br/>public class PlayerCharacter extends GameObj{<br/>private Bitmap spriteSheet;<br/>private int score;<br/>private double dya;<br/>private boolean up, playing;<br/>private AnimationClass ac = new AnimationClass();<br/>private long startTime;<br/><br/>    public PlayerCharacter(Bitmap res, int w, int h, int noOfFrames) {<br/>        xc = 100;<br/>        yc = GameView.HEIGHT/2;<br/>        dyc = 0;<br/>        score = 0;<br/>        height = h;<br/>        width = w;<br/><br/>        Bitmap[] img = new Bitmap[noOfFrames];<br/>        spriteSheet = res;<br/><br/>        for(int i=0; i &lt; img.length;i++){<br/>                img[i] = Bitmap.createBitmap(spriteSheet, i*width, 0, width, height);<br/>        }<br/>        ac.setFrames(img);<br/>        ac.setDelay(10);<br/>        startTime = System.nanoTime();<br/>    }<br/><br/>    public void setUp(boolean b){<br/>        up = b;<br/>    }<br/><br/>    public void update() {<br/>        long elapsed = (System.nanoTime()-startTime)/1000000;<br/>        if(elapsed &gt; 100) {<br/>            score++;<br/>            startTime = System.nanoTime();<br/>        }<br/>        ac.update();<br/>    }<br/><br/>    public void draw(Canvas canvas) {<br/>        canvas.drawBitmap(ac.getImage(), xc, yc, null);<br/>    }<br/><br/>    public int getScore() {<br/>        return score;<br/>    }<br/><br/>    public boolean getPlaying(){<br/>        return playing;<br/>    }<br/><br/>    public void setPlaying(boolean b) {<br/>        playing = b;<br/>    }<br/><br/>    public void resetDYA() {<br/>         dya = 0;<br/>    }<br/><br/>    public void resetScore () {<br/>        score = 0;<br/>    }<br/>}
</pre>
<p>Let's now understand what we have done in our <kbd>PlayerCharacter</kbd> code in further detail:</p>
<ul>
<li>We created our class and extended it to our abstract class, <kbd>GameObj</kbd>, to get access to all the default variables needed for our <kbd>PlayerCharacter</kbd></li>
<li>We created the default constructor for our <kbd>PlayerCharacter</kbd> in which we pass the required data to draw <kbd>PlayerCharacter</kbd> on screen just like the image component is passed in the <kbd>res</kbd> variable along with the width and height of our image with the number of frames we need in our animation</li>
<li>In our constructor, we created a <kbd>for</kbd> loop, which will run through our sprite sheet and give us the animation effect followed by a 10-millisecond delay to play our animations</li>
<li>We then created our <kbd>setUp()</kbd> function, which will take care of the jumping functionality of our player</li>
<li>In our <kbd>update()</kbd> function, we created a loop of events that assign a <kbd>score</kbd> to the player as well as keep the player between upper and lower bounds</li>
<li>After this, we created the <kbd>draw()</kbd> method, which gets the animation from our <kbd>ac</kbd> variable and drew it onto our canvas</li>
<li>This is then followed by simple get and set methods for rest of the variables</li>
</ul>
<p>Our player character is ready; however, we still have to write our <kbd>AnimationClass</kbd>. As you can clearly observe, you must be getting an error on the <kbd>AnimationClass</kbd> line. So, let's go ahead and create our <kbd>AnimationClass.java</kbd> file and write the following code in it:</p>
<pre>
package nikhil.nikmlnkr.game;<br/><br/>import android.graphics.Bitmap;<br/><br/>/**<br/> * Created by Nikhil on 13-01-2017.<br/> */<br/><br/>public class AnimationClass {<br/>    private Bitmap[] frames;<br/>    private int currentFrame;<br/>    private long startTime, delay;<br/>    private boolean playedOnce;<br/><br/>    public void setFrames(Bitmap[] frames){<br/>        this.frames = frames;<br/>        currentFrame = 0;<br/>        startTime = System.nanoTime();<br/>    }<br/><br/>    public void setDelay(long d){<br/>        delay = d;<br/>    }<br/><br/>    public void setFrame(int i) {<br/>        currentFrame = i;<br/>    }<br/><br/>    public void update() {<br/>        long elapsed = (System.nanoTime()-startTime)/1000000;<br/><br/>        if(elapsed &gt; delay) {<br/>            currentFrame++;<br/>            startTime = System.nanoTime();<br/>        }<br/><br/>        if(currentFrame == frames.length) {<br/>            currentFrame = 0;<br/>            playedOnce = true;<br/>        }<br/>    }<br/><br/>    public Bitmap getImage(){<br/>        return frames[currentFrame];<br/>    }<br/><br/>    public int getFrame(){<br/>        return currentFrame;<br/>    }<br/><br/>    public boolean playedOnce() {<br/>        return playedOnce;<br/>    }<br/>}
</pre>
<p>This <kbd>AnimationClass.java</kbd> file is important to run our character's animations. Our <kbd>AnimationClass</kbd> has three main functions, namely <kbd>setFrames()</kbd>, <kbd>update()</kbd>, and <kbd>getImage()</kbd>. Let's take a look at what we have done in this class:</p>
<ul>
<li>We created variables that are needed to access our frames</li>
<li>We created variables that will control the start time and delay between animation frames</li>
<li>We created a Boolean, which will trigger the animation</li>
<li>Next, we created a <kbd>setFrames()</kbd> function, to set frames and set the current frame to <kbd>0</kbd> at start</li>
<li>After that, a <kbd>setDelay()</kbd> function, was created in order to tell the animation to run at short intervals</li>
<li>We then created a <kbd>setFrame()</kbd> function to set the current frame in the running animation</li>
<li>In our <kbd>update()</kbd> function, we started calculating the delay in terms of milliseconds using some simple math calculations, and upon certain intervals, switched the frame of the image</li>
<li>We added a condition that if our last frame has elapsed then we will reset our current frame to 0 in order to give a continuous looping effect</li>
<li>In our <kbd>getImage()</kbd> function, we simply return the value of the image that is currently being drawn on the screen</li>
<li>The <kbd>getFrame()</kbd> function returns us the integer value of the current frame that is being displayed</li>
<li>With the last function, <kbd>playedOnce()</kbd>, as a placeholder for our further gameplay</li>
</ul>
<div><kbd>setFrames()</kbd> and <kbd>setFrame()</kbd> are two different functions. <kbd>setFrames()</kbd> is used to initialize our frames from 0, whereas <kbd>setFrame()</kbd> is used to set frames individually while running.</div>
<p>Now, before moving on to the next part, ensure that you have your image in your drawable folder that you want to use for our player character. Once you have it, it's now time to move on to the next step and instantiate our player on screen. The procedure for this is the same as we did with our background image. Modify your <kbd>GameView.java</kbd> file code to look like this; changes from the preceding code have been highlighted in bold:</p>
<pre>
package nikhil.nikmlnkr.game;<br/><br/>import android.content.Context;<br/>import android.graphics.BitmapFactory;<br/>import android.graphics.Canvas;<br/>import android.view.MotionEvent;<br/>import android.view.SurfaceHolder;<br/>import android.view.SurfaceView;<br/><br/><br/>public class GameView extends SurfaceView implements SurfaceHolder.Callback {<br/>    public static final int WIDTH = 1920;<br/>    public static final int HEIGHT = 1080;<br/>    public static final int MOVINGSPEED = -5;<br/>    private MainGameThread mainThread;<br/>    private BackgroundImage bgImg;<br/><strong>    private PlayerCharacter playerCharacter;</strong><br/><br/>    public GameView(Context context) {<br/>        super(context);<br/><br/><br/>        //set callback to the surfaceholder to track events<br/>        getHolder().addCallback(this);<br/><br/>        mainThread = new MainGameThread(getHolder(), this);<br/><br/>        //make gamePanel focusable so it can handle events<br/>        setFocusable(true);<br/>    }<br/><br/>    @Override<br/>    public void surfaceChanged<br/>    (SurfaceHolder holder, int format, int width, int height){}<br/><br/>    @Override<br/>    public void surfaceDestroyed(SurfaceHolder holder){<br/>    boolean retry = true;<br/>    while(retry)<br/>        {<br/>            try{mainThread.setRunning(false);<br/>                mainThread.join();<br/><br/>        }catch(InterruptedException e){e.printStackTrace();}<br/>            retry = false;<br/>        }<br/><br/>    }<br/><br/>    @Override<br/>    public void surfaceCreated(SurfaceHolder holder){<br/><br/>    bgImg = new<br/>BackgroundImage(BitmapFactory.decodeResource<br/>        (getResources(), <br/>        R.drawable.background_image));<br/><strong>        Drawable d = getResources().getDrawable<br/>        (R.drawable.player_run);</strong><br/><strong>        int w = d.getIntrinsicWidth();</strong><br/><strong>        int h = d.getIntrinsicHeight();</strong><br/><strong>        playerCharacter = new PlayerCharacter<br/>        (BitmapFactory.decodeResource<br/>        (getResources(),R.drawable.player_run),w/3,h,3);</strong><br/>        //we can safely start the game loop<br/>        mainThread.setRunning(true);<br/>        mainThread.start();<br/><br/>    }<br/>    @Override<br/>    public boolean onTouchEvent(MotionEvent event){<br/>        return super.onTouchEvent(event);<br/>    }<br/><br/>    public void update(){<br/>        bgImg.update();<br/><strong>        playerCharacter.update();</strong><br/>    }<br/>    @Override<br/>    public void draw(Canvas canvas){<br/>        final float scaleFactorX = getWidth()/WIDTH;<br/>        final float scaleFactorY = getHeight()/HEIGHT;<br/>        if(canvas!=null) {<br/>            final int savedState = canvas.save();<br/>            canvas.scale(scaleFactorX, scaleFactorY);<br/>            bgImg.draw(canvas);<br/><strong>            playerCharacter.draw(canvas);</strong><br/>            canvas.restoreToCount(savedState);<br/>        }<br/>    }<br/><br/>}
</pre>
<p>Let's do a breakdown of what we did here:</p>
<ol>
<li>We created a reference variable for our <kbd>PlayerCharacter</kbd> using the variable <kbd>playerCharacter</kbd>.</li>
<li>Then, in our <kbd>surfaceCreated()</kbd> method, we gave the <kbd>playerCharacter</kbd> class constructor all the values that it requires. We passed the <kbd>player_run</kbd> image into this code for it to fetch our player's sprite sheet. In the parameters for the constructor of <kbd>PlayerCharacter(BitmapFactory.decodeResource(getResources(),R.drawable.player_run),w/3,h,3);</kbd>, the 'w' corresponds to the width of the image and 'h' corresponds to the height of the image. The parameter 3 here will depend on the number of frames of your sprite. If you have six frames in your sprite, then the parameters would be <kbd>(w/6,h,6)</kbd>.</li>
</ol>
<ol start="3">
<li>After that, in our <kbd>update()</kbd> method, which is after <kbd>bgImg.update()</kbd>, we called the <kbd>playerCharacter.update()</kbd> method that gives a call to the update function of our <kbd>PlayerCharacter</kbd> and thereby plays the animation from the <kbd>AnimationClass.java</kbd> file.</li>
<li>Lastly, we then drew our player character onto our canvas using the <kbd>playerCharacter.draw(canvas);</kbd> code.</li>
</ol>
<p>After you are done with these steps, build and run your game on an emulator or your Android phone device; you will get the following output:</p>
<div><img class="image-border" src="img/B05066_05_03.png"/></div>
<p>Hurray! Our player character is running on the screen (literally)</p>
<p>If you have done everything correctly, then you will have your player character running on the screen on the spot while your background is scrolling continuously; almost half of our game is done here.</p>
<p>Since we have created our <kbd>GameObj</kbd> class, we will be relying on it heavily for our further game objects, such as missiles, particle effects, and everything else.</p>
<p>Congratulations! You just created your first animation!</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Summary</h1>
            

            
                
<p>In this chapter, you learned how to effectively create animations from your sprite sheet as well as create an abstract class to create a foundation for your future game objects. In the next chapter, we will learn how to create our game even more interesting by controlling our animation based on touch inputs. We will learn about collision detection along with creating a missile AI that will spawn from the extreme right of the screen, and our objective will be to dodge the missile.</p>
<p>We will learn about different collision techniques as well as create interactive objects, where we will also add a score on collecting them instead of just incrementing the score with time.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    </body></html>