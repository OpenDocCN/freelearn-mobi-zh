- en: Server-Side Swift
  prefs: []
  type: TYPE_NORMAL
- en: From its very inception, Swift was intended to be a general-purpose programming
    language, applicable for multiple use cases and on multiple platforms, not just
    for building apps for Apple platforms. One of the obvious use cases, other than
    building apps, is creating server-side code. After all, interacting with a server
    is a vital component of almost any app. The vast majority of servers that power
    the internet run on Linux, which is arguably more suited to the task than any
    Apple platform. Therefore, being able to run Swift on Linux is vital to the goal
    of making Swift a viable server-side programming language option.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will investigate installing the Swift toolchain on Linux,
    using a web server framework to build a REST API, and hosting our API via a hosting
    service.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Running Swift on Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a REST API using Vapor and Fluent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database persistence with Fluent and Postgres
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hosting your Vapor app on Heroku
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Swift Package Manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-time communication using WebSockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging and sharing models between server and app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the code for this chapter can be found in this book''s GitHub repository:
    [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter08](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter08)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3kgvhxe](https://bit.ly/3kgvhxe)'
  prefs: []
  type: TYPE_NORMAL
- en: Running Swift on Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Linux operating system is a dominant force in the world of backend servers,
    so to be of any use for server-side development, Swift needs to be available on
    Linux. Fortunately, part of the open source release of Swift includes the Swift
    toolchain on Linux. Let's get it up and running with a "Hello World" program in
    Swift on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe will use Ubuntu 20.04, as this is a very popular and widely used
    Linux distribution, and 20.04 is the latest **Long-Term Support** (**LTS**) version.
    Additionally, pre-built binaries of the Swift toolchain are provided for this
    distribution by the Swift open source team. As a Mac user, I have tested this
    process on an instance of Ubuntu, running in the VirtualBox virtualization environment,
    but there should be no difference when running on bare metal.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s install the Swift toolchain and run our first Swift code on Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to install some dependencies related to the compiler. If you are using
    Ubuntu with a **Graphical User Interface** (**GUI**), open up a Terminal window
    and run the following from the prompt to update the software repositories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the next command to install a number of dependencies required for the Swift
    toolchain:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The Swift team released a prebuilt toolchain for Ubuntu, so we will need to
    download the latest released version and the associated `signature` file. Links
    for these releases can be found at [https://swift.org/download/#releases](https://swift.org/download/#releases).
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the toolchain and PGP signature file for the relevant platform. For
    example, at the time of writing, the most recent release versions can be downloaded
    using `wget` with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The signature file that we downloaded can be used to verify that the toolchain
    archive has not been tampered with or modified during the download. The verification
    will use public PGP keys provided by the Swift project in conjunction with the
    signature file. If you haven''t done so before, you can use the following command
    to retrieve the PGP keys and import them into your keyring:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to check for any key revocation certificates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'With all that done, we can verify the integrity of our downloaded toolchain
    archive (replacing the signature filename below with the one downloaded):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The response should contain the `gpg: Good signature from "Swift 5.x Release
    Signing Key <swift-infrastructure@swift.org>"` line; if it does, the archive has
    been successfully verified, and if not, the download may have been altered and
    should be retrieved from a trusted source on a trusted network.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Don't be alarmed if it says the key is not from a trusted `signature`. This
    is because the system can't find an unbroken chain of certificates from your computer
    to this key; it's okay to ignore this warning.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our archive verified, let''s unzip the archive and see what''s inside
    (replacing the filename that follows with the toolchain downloaded):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Within the archive is a `usr` folder, and within that, a `bin` folder, which
    contains a number of binaries that are related to building Swift; key among them
    is the `swift` binary.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to interact with the Swift toolchain using just the command `swift`;
    to do this, we need to tell the system where to look for the Swift binaries. Open
    up `~/.profile` in your preferred text editor, and add the folder containing your
    Swift toolchain to the `$PATH` export command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Save your `.profile` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log out and log back in for the changes to take effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, when you type `swift` and press *Enter*, the Swift REPL will launch. It
    stands for the **read–eval–print loop** (**REPL**); it's a way to interact with
    the Swift language in a very quick, easy way, much like a playground.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the REPL, you can write Swift commands and press *Enter* to have them executed,
    with each command occurring within the same scope as the previous commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the REPL, type the following Swift expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Press *Enter*, and the REPL will display the outcome of your command, much
    like a playground does:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can print our greeting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the expected response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To leave the REPL and return to your normal command line, type the following
    and press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You just executed Swift code on Ubuntu Linux. The world of
    server-side Swift awaits.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s great to try out Swift code at the command line using the REPL, but what
    we really require is the ability to compile our code into an executable binary
    that we can run on demand. Let''s take our "Hello world!" example and compile
    it into a binary:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your favorite text editor and save the following into a file called `HelloWorld.swift`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'From the command line, in the folder that contains our Swift file, we can compile
    our binary using `swiftc`. We can specify the file or files to compile and use
    the `-o` flag to provide a name for the output binary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can run the binary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Compiling one file is great, but to perform any useful work, we are likely to
    have multiple Swift files that define things like models, controllers, and other
    logic, so how can we compile them into a single, executable binary?
  prefs: []
  type: TYPE_NORMAL
- en: When we have multiple files, we need to be able to define one at the entry point
    of our application. When compiling a Swift binary with multiple files, one of
    them should be called `main.swift`. This file serves as the entry point so that
    when the binary is run, the code in the `main.swift` file is executed from start
    to end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make two Swift files, the first one named `Model.swift`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll create the `main.swift` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s compile these two files into a binary called `Greeter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This can then be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We have now written and compiled a binary from multiple files in Swift on Ubuntu.
  prefs: []
  type: TYPE_NORMAL
- en: Building a REST API using Vapor and Fluent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main use cases for server-side Swift is building REST APIs. Interacting
    with network data is a key function of almost any app, and until now, that server-side
    component had to be built by someone else with the relevant server-side skills.
    Alternatively, it required an app developer to frequently switch between programming
    languages and development environments to build both the client-side and the server-side
    code of an app.
  prefs: []
  type: TYPE_NORMAL
- en: Swift on the server opens the possibility for a developer to work on everything
    involved in the app, and move seamlessly between the client side and server side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Much has been done by the Swift team to encourage the use of Swift on the server,
    including creating a new networking framework for running servers. This new framework
    is called SwiftNIO and is available open-sourced on GitHub: [github.com/apple/swift-nio.](https://github.com/apple/swift-nio)'
  prefs: []
  type: TYPE_NORMAL
- en: This framework is quite low-level, and a number of higher-level frameworks exist
    to make creating a REST API easier using Swift.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use one of the more popular frameworks, Vapor, to build
    a REST API for an app that stores a user's tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vapor is a Swift framework for building web services, that makes accomplishing
    common tasks very easy. At the time of writing, Vapor is at Version 4, which is
    required with Swift 5.2\. More information about Vapor can be found on its website
    at [http://vapor.codes.](http://vapor.codes)
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we will assume that you are developing your Swift web service
    on a Mac, even if it may eventually be deployed to a Linux server.
  prefs: []
  type: TYPE_NORMAL
- en: When writing Swift code that will be deployed on Linux, it's very important
    to test your code by actually running it on Linux, especially if it's initially
    developed on macOS. There are significant differences between Swift's operation
    on macOS and Linux. These differences are often due to the different implementation
    of the Foundation framework on the different platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s verify that we have the right version of Swift installed to run Vapor.
    Run the following command in Terminal to check your version of Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The output should indicate at least `version 5.2`; if this is not the case,
    you will need to update your version of Xcode.
  prefs: []
  type: TYPE_NORMAL
- en: We next need to install Vapor Toolbox, which is a set of command-line tools
    to simplify working with Vapor-based projects. The Vapor CLI is available through
    Homebrew, which is a package manager for macOS. You can find more details about
    Homebrew on its website at [https://brew.sh](https://brew.sh)[.](https://brew.sh)
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, Homebrew has not been updated to support the recently
    released Apple Silicon Macs. If you are using one of these Macs, please check
    the Homebrew website for compatibility information.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t already have Homebrew installed, run the following in Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'With Homebrew installed, we can add the `tap` for Vapor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run Vapor to check whether it''s installed correctly. You should see
    instructions on how to use Vapor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to use Vapor to build our REST API.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a web service to store and manage tasks from an iOS app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Vapor project called `TaskAPI` and then move to the new folder
    that is created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: During this process, you will be asked ***Would you like to use Fluent?*** Answer
    yes to this. You will then be asked which database you would like to use. Select
    **Postgres** (this should be the recommended one).
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you will be asked if you would like to install ***Leaf***. Select
    **No** for now, as this goes slightly outside of the scope of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: You can create your Vapor web service using any IDE, but we are familiar with
    using Xcode, so let's use that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vapor has support for creating an Xcode project containing our Vapor code,
    so let''s launch Xcode for our Vapor project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Xcode will open and the project dependencies will be fetched automatically and
    appear under Swift Package Dependencies in the project navigator. Be patient –
    this can take a few minutes and you might not see any activity straight away.
  prefs: []
  type: TYPE_NORMAL
- en: Once all the dependencies have been fetched, the build and run button will become
    active.
  prefs: []
  type: TYPE_NORMAL
- en: Build and run the project to launch a local web server, which will handle requests
    to `http://127.0.0.1:8080`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `http://127.0.0.1:8080` in a browser and you will see this web page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/52dad583-d066-4208-ad58-32705b7e40e3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Vapor project
  prefs: []
  type: TYPE_NORMAL
- en: It works! You now have your bare-bones Vapor project up and running. Now let's
    take a look at the Xcode project that Vapor has created for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Project Navigator, you will find a Sources group, and two subgroups:
    Run and App. The Run group contains `main.swift`, the file that will be executed
    when you run the app. The App group contains a number of files with some example
    code for setting up a REST API.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `main.swift` file; it will contain the following template code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You shouldn't really need to edit this file; it just performs the required setup
    and starts the web server that serves up our API. What we do need to do is to
    use this setup process to configure Vapor to provide the API we require.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how the default Vapor template sets things up. In the App group,
    open the `configure.swift` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this file, we've imported the `Vapor` module, which contains all the code
    to set up and manage the Vapor web server. We've also got our code for our database,
    but we'll go further into that a little later on. If you look back at `main.swift`,
    you will see that it imports the `App` module; this is the module that will contain
    all of your code for setting up the web server and managing requests and responses.
  prefs: []
  type: TYPE_NORMAL
- en: Note in the preceding code, I've highlighted a required change for the latest
    version of Vapor which may now be included in the most recent template, if you
    are unsure, just copy the preceding code into your project from here or take a
    look at the source files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s switch to `Routes.swift`, and we will see that this is where our
    routes are configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: A route defines a type of request that the web server may receive, and the response
    to send.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that the `"plaintext"` path is defined, which is the URL we
    visited to determine that everything was correctly configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This route is for a `GET` request, with the path string parameter, `plaintext`;
    when our Vapor server was locally run, this related to the URL `http://0.0.0.0:8080`.
    The process of defining a route in Vapor involves providing a closure that takes
    a `Request` object and returns something that conforms to `ResponseRepresentable`;
    Vapor has already defined the string as conforming to `ResponseRepresentable`,
    so in the string, Hello, world! can be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Build and run the Run scheme, if it's not already running, and visit `http://0.0.0.0:8080/hello`
    to see the JSON defined.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **TaskAPI** will accept new tasks as POST requests containing JSON representations
    of the tasks and will return all the existing tasks via `GET` requests.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's define a task – in the App group of your Xcode project, create
    a new file called `Task.swift` in a new group called Models.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating this file, ensure that it is a member of the App target and
    not any others. The Target Membership panel for our new file should look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62d8ea0a-aa0f-402c-8ccc-390a12efe1d9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Target membership
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define our task as having two properties: `description` and `category`,
    plus an identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create a `Task` in code, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: However, we will always create our `Task` objects from the JSON received by
    the `POST` request, so being able to create our `Task` objects directly from JSON
    will be very helpful, and since we will be returning our `Task` objects as JSON,
    being able to convert them to JSON will also be helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Vapor has a framework called Content for dealing with JSON data. Content is
    Vapor's version of Codable (which we learned about in *[Chapter 6](32abd392-d947-461c-a9e9-912b34704c9b.xhtml),
    Building iOS Apps with Swift*).
  prefs: []
  type: TYPE_NORMAL
- en: The Vapor project we created, in turn, creates example code of everything we're
    about to go through. If you get stuck at any time, simply refer to the template
    counterpart for guidance as to where you could be going wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the `Content` conformance to our `Task` model object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: When we are creating a new task, we don't expect the JSON to include the identifier,
    so if it is missing, we can generate a `UUID` using the `Foundation` framework.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our `Task` model object, which can be converted to and from
    JSON, let's create some routes for our API.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Routes.swift`, we need an array of `Task` objects to hold the tasks that
    get created; for the moment, we can just add that to the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll add two routes to the `routes()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the first route, we look for a `POST` request to the `/task` path. If the
    request has JSON, then we can use it to attempt to create a `Task` object using
    the JSON; once created, we can store it in the `tasks` array.
  prefs: []
  type: TYPE_NORMAL
- en: The next route looks for a `get` request to that same path – `/task` – and returns
    a JSON representation of the tasks we stored in our array. This makes use of the
    fact that Vapor has an extension of `Sequence`, which `Array` conforms to, and
    if all items in the `Sequence` conform to `JSONRepresentable`, then the `Sequence`
    can be represented as JSON, too. With these routes defined, let's build and run
    the Run scheme and test them out.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll add a task, sending a `POST` request to `http://0.0.0.0:8080/task`;
    we can do this using the `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This should return a JSON representation of the task we just created, which
    looks like this, although the `id` will be different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s test our route to show all the existing tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This should return the one `Task` we created in an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We now have a simple API that stores our tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Try adding a few more tasks and check whether they are returned from the `GET`
    request.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The API we have created so far allows us to perform some operations on a task;
    namely, to create one and list all the current tasks. Implementing these actions,
    along with other operations such as modifying, deleting, and listing an individual
    task, is very common when building a REST API, so Vapor makes this really easy.
  prefs: []
  type: TYPE_NORMAL
- en: In Vapor, you can define a resource that will define how all these operations
    are performed, and Vapor handles the setting up of routes that follow standard
    practice for REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s a new file called `TaskController.swift` – this will be our new `TaskControllerAPI`
    and will be responsible for housing our REST API response logic and will allow
    a degree of separation between our routing logic and our business logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We are storing the created tasks in a dictionary, with the key being the task
    ID; this allows us to easily retrieve them when the ID is passed as a URL parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create our resource, we provide functions that provide the response for
    each `REST` operation that we would like to support. These areas are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`store`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`show`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replace`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`modify`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`destroy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clear`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aboutItem`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aboutMultiple`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see from the preceding code, we've just created a couple to get going.
    We can add the rest in later as and when we need them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add in an extension that conforms to **RouteCollection**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is where we take our routes that are specific to the core logic in `TaskControllerAPI`
    and define them as we need. With the routing code added here, we no longer need
    these in our `Routes.swift` file, so head on over there now and replace them with
    the following single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Rerun the project and let''s test whether everything still works as expected.
    Let''s create a task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, fetch all tasks to check our newly created task is returned (notice how
    we changed the URL to `create`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We've now created a simple REST API for storing and retrieving tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In the next recipe, we will build on this to make it truly useful.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: More information about the Vapor framework can be found on its website at [https://vapor.codes](https://vapor.codes).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some other popular Swift web frameworks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Kitura: [http://www.kitura.io](http://www.kitura.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Perfect: [http://perfect.org](http://perfect.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Zewo: [http://www.zewo.io](http://zewo.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database persistence with Fluent and Postgres
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our previous project, our task editor would work a treat as long as the server
    kept running, but one quick re-start and everything we've saved would be lost
    forever – which is why persistence, particularly with databases, plays a massive
    part in software development.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we're going to continue to build on our TaskAPI project, adding
    persistence so that our data is always protected.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this section, you''ll need to install Docker on your Mac. Follow this link
    for information on Docker and containerization, along with a link to the installer:
    [https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we''ll need to create our database. Luckily, Vapor can do that for us:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a new file under the `Migration` folder called `CreateTasks.swift`
    and copy the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice our struct conforms to `Migration` – don''t worry, this is normal. Migrations
    are used even for creating databases. In the preceding code, we''re doing the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a database with a schema called `task`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating fields in our database called `"description"`, `"category"`, along
    with an **ID** column
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And that is it, really – job done. However, we need to tell our server to run
    the code and perform the migration (the `create` for us).
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back over to `Configure.swift` and add in the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: When our server application starts, the database will be created. Don't worry
    – Vapor only does this once, so if your database already exists, then it won't
    try and create it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to adjust our code to allow our models to persist to the database
    matching the properties in our model to the fields we just created. Head back
    over to the `Task.swift` file and make the following highlighted changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We'll go through the structure of this later on in the *How it works...* section,
    but for now, you just need to make sure the changes are in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, head back over to our `TaskController.swift` and make the following changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We're almost ready to go. Now we just need to get an instance of our database
    up and running. We'll achieve this by using a Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Docker installed and running (if you are using Mac, you should have an
    icon that represents Docker on your toolbar), enter the following command in Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Notice they perfectly match the details we've got in our `Configure.swift` file.
    Feel free to adjust them accordingly to suit your specific needs/conventions.
  prefs: []
  type: TYPE_NORMAL
- en: 'All being well, you should see the following in Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This means everything is going well. Once installed, we're ready to launch our
    new and improved REST API. Go ahead and run the project from Xcode. You should
    notice the database migration/creation in Xcode's console window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now launched, use our existing cURL command to add multiple items to our database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now, restart the server (via Xcode) and call our `get` request. You should see
    a list of all the items we recently persisted. From this, you can now go on to
    update your API with `put` and `delete` commands, and many others that adhere
    to API standards. As this book concentrates on Swift as a programming language,
    we'll leave that up to you to have a play around with.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With our API now up and running, let''s dig a little deeper into how we made
    the persistence work. Let''s start by taking a closer look at our `Task.swift`
    class model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, our class now conforms to Model – which is a protocol used
    by the Fluent framework. This allows us to add attributes to our properties so
    we can bind these to fields within our database, such as the `category` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Without this, Fluent wouldn't know how to bind this causing a failure in persistence.
    Another added benefit is that our properties are not tied to the naming convention
    of the database; something that's not a problem when starting from scratch, but
    this is potentially helpful when working with legacy systems.
  prefs: []
  type: TYPE_NORMAL
- en: You'll also notice the `schema = "task"` constant we have in there, again another
    part of the inner workings of our binding that allows our Model to be bound only
    to a particular database schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back over to our `TaskControllerAPI()` class and you''ll see that the changes
    we made reference a `.db` property. Let''s take a look at these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we decode our data using `content` to bind this to our
    Model `(Task())`. We are now able to perform a `.save` operation on our `task`
    object as this now conforms to **Model** from Fluent.
  prefs: []
  type: TYPE_NORMAL
- en: The save is being performed on the `req.db` and then in turn being **.map**(ed)
    – once the operation is complete and successful, we can see that the task is returned
    (which is why we see this in the output window when performing our cURL command).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you break down the preceding, the syntax makes a little more sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: For those familiar with the previous way of implementing databases in Vapor,
    you'll certainly appreciate this new and much-improved way of setting up persistence.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Vapor provides a number of other database providers that can be used instead
    of Postgres:'
  prefs: []
  type: TYPE_NORMAL
- en: '**MySQL**: [https://github.com/vapor/mysql-provider](https://github.com/vapor/mysql-provider)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SQLite**: [https://github.com/vapor-community/sqlite-provider](https://github.com/vapor-community/sqlite-provider)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Redis**: [https://github.com/vapor/redis-provider](https://github.com/vapor/redis-provider)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mongo**: [https://github.com/vapor-community/mongo-provider](https://github.com/vapor-community/mongo-provider)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hosting your Vapor app on Heroku
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipes in this chapter, we created a REST API that stores and
    retrieves information from a Postgres database. We have our Vapor web server running
    on our local machine and can interact with it over HTTP requests; however, unless
    you plan on making your machine available to the public internet, this is of limited
    use, and we need to find somewhere to host our data and REST interface.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, Swift's support on hosting services is the exception
    rather than the norm; however, support is growing. Heroku is a popular hosting
    service that provides dynamic scaling of resources and a really simple deployment
    mechanism. It also has support for Swift and Postgres, so in this recipe, we will
    deploy our REST API to Heroku.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Heroku provides simple and scalable infrastructure for your server-side projects.
    Once deployed, instances of your app are called Dymos, and additional Dymos can
    be started to cope with increased load.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment to Heroku happens through a remote Git repository. When you are ready
    to deploy your app, simply push the code to Heroku.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, visit [http://www.heroku.com](http://www.heroku.com) and sign up for
    a free account. Next, we will install the Heroku CLI (**Command-Line Interface**),
    as this is helpful for interacting with Heroku. Since we installed Homebrew in
    the previous recipes, we can use it to get the Heroku CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to log into the Heroku CLI with the account that we just created.
    Run the `login` command and follow the instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We now have our Heroku CLI set up and ready to use.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the deployment mechanism for Heroku is Git, we need to create a local
    Git repo.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Terminal, navigate to the folder containing our `TaskAPI` app that we built
    in the previous recipes, and create a local Git repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to stage all the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, commit all the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will set up this Vapor project to use Heroku and follow the instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: You will be asked if you would like a custom name for your app. If you choose
    not to have a custom app name, then a random app name will be assigned in the
    form of two words and a number; for example, `afternoon-bastion-18185`. Therefore,
    the app's URL will be `https://afternoon-bastion-18185.herokuapp.com`.
  prefs: []
  type: TYPE_NORMAL
- en: You will also be asked if you want to provide a custom build pack and a custom
    executable name. You can answer no to both of these.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to associate our local Git repository with the Heroku app we just created.
    Run the following command, replacing the final parameter with the name of the
    app that Heroku just created for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: To get our database-backed API up and running on our local machine, we ran a
    `Postgresql` service and configured Vapor's connection to it using a configuration
    JSON file in `Config`/`secret`. However, this configuration is specific to our
    local machine, and so we need to start a `PostgreSQL` database service on Heroku
    and configure Vapor to connect to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, the Heroku CLI makes this really easy; just run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In this command, `hobby-dev` is the pricing plan to use for the database, which
    is free for up to 10,000 database rows.
  prefs: []
  type: TYPE_NORMAL
- en: This will cause the database to be made available to your Heroku Dymo whenever
    your app is deployed. By running `heroku config`, we can see that an environment
    variable called `DATABASE_URL` is created, containing the connection URL for the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to ensure that Vapor knows how to connect to the database when
    it's running on Heroku. To do this, we will add a configuration to `Procfile`,
    which is used by Heroku to set up the environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the root of the project, create a file named `Procfile`; open this file
    and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This will allow Vapor to use the PostgreSQL database set up on Heroku.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s commit the change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to push our code to Heroku, which will then be deployed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: At the time of writing this book - there was/is an open pull request to fix
    an issue with a missing file `LinuxTests.swift`if Heroku gives you an error performing
    the above push, simply create a blank file called `LinuxTests.swift`and re-commit
    & push again.
  prefs: []
  type: TYPE_NORMAL
- en: 'It may take a while, but eventually, Heroku will report that the code has been
    deployed and will provide the URL for the deployed app, which will look similar
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: You have a deployed version of our `TaskAPI` running on Heroku. You can rerun
    all the cURL tests from the last recipe, but with the preceding hostname in the
    place of `http://0.0.0.0:8080`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we have built in this chapter is just the tip of the iceberg of what Vapor
    is capable of. Vapor has built-in support for authentication, templating, and
    much more, so check out [http://vapor.codes](http://vapor.codes) for the full
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The team behind Vapor has launched its own hosting service, Vapor Cloud. This
    really simplifies the process of getting your Vapor app online. At the time of
    writing, this service is in open beta; you can find out more and sign up at [https://vapor.cloud](https://vapor.cloud).
  prefs: []
  type: TYPE_NORMAL
- en: The Swift Package Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependency package management has been around for a while now in software development
    – the ability to add a dependent framework or snippet to your code base without
    the need for any major integration has often been seen as a benefit to many.
  prefs: []
  type: TYPE_NORMAL
- en: Managers such as NuGet and NPM are widely used and maintained by the community.
    Specifically for iOS development, CocoaPods and Carthage have been the big players;
    that was until the introduction of the **Swift Package Manager** or **SPM** for
    short.
  prefs: []
  type: TYPE_NORMAL
- en: Although it's been around much longer than you might think, it was recently
    announced at WWDC 2019 that Xcode 11 would have full integration support for the
    Swift Package Manager.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to learn how to add a dependency to our project
    using the Swift Package Manager.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this project, we'll continue using our recent Xcode project where we implemented
    Fluent and Postgres – you can follow along in the sample recipe from GitHub or
    alternatively make a copy on disk of your current project and work from that.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, open Xcode and from the file tree, locate the following filename:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you should see the start of the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, I've highlighted our main area of interest. Here, we
    currently have a list of existing dependencies – in our case, the Vapor framework
    and two Fluent dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s go ahead and add another one in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Give Xcode a moment or so and it should start to download the new dependency.
    Failing that, you can push this along a little by using the following command
    in Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: If there are any errors with your package file, you'll see them here. Once completed,
    you'll see your new dependency alongside the existing ones in the File Explorer
    to the left of Xcode.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also allows you to add package dependencies via the GUI, from Xcode. Select
    File | Swift Packages to see a list of options. Unfortunately, these are only
    currently supported for `.xcproject` files (which Vapor does not use).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So now we''ve added in our framework, how does SPM work its magic? We''ll start
    by taking a look at the dependency section of our `Packages.swift` file again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: I've highlighted two main areas here from our recent addition – the first is
    the URL. Much like other dependency packages such as Cocoapods and Carthage, SPM
    pulls its code from a (or your) Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: Without going into too many details about how a package is actually made, versioning
    for dependencies is done using tags. In the preceding code, we're looking for
    any version of the package that starts from 1.0.0 (so the latest could be version
    10.2.2, for all we know), but we've made a decision that at the very least, version
    1.0.0 is good enough for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'But maybe we want to be more specific. Let''s see how we''d do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're specifying that we only want to use version 1.2.3\. The format of
    the version numbers that we are checking against is what is called semantic versioning.
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows us to add additional conditions to our packages such as `upToNextMajor`
    and `upToNextMinor` from a specific set version. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '`upToNextMajor` will include any version up to version 2.0.0.'
  prefs: []
  type: TYPE_NORMAL
- en: '`upToNextMinor` will include any version up to version 1.3.0 (so 1.2.x basically).'
  prefs: []
  type: TYPE_NORMAL
- en: More often than not, you won't really need to worry about this, but with a framework
    dependent on other frameworks, sometimes this can really come in handy to keep
    everything nice and tidy in your project.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, let''s take a look at the remaining code in our `Packages.swift` file
    – let''s start at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Although this appears to be commented out, it actually plays a big part in our
    packages file. Here, we're setting the version of Swift that our dependencies
    must comply with. So if a dependency being downloaded is built with an older version
    of Swift and is currently unsupported, SPM will let us know about it.
  prefs: []
  type: TYPE_NORMAL
- en: On the flip side too, if our dependency is newer than our version of Swift,
    this will be handled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s take a look at the targets section. At first glance, you might
    feel a little overwhelmed as to what is going on in here, but it is actually straightforward,
    and for those familiar with other dependency management tools, this will be familiar
    ground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, I've highlighted some key areas. The first is the list
    of targets. All we are doing here is identifying one of our targets (in our case
    our **App** target) and adding a list of specific dependencies for that target.
  prefs: []
  type: TYPE_NORMAL
- en: These names are the actual package names once installed – not the Git URL. These
    are defined outside the targets array on a more global scale for our project.
    Here, we are simply cherry-picking what should be used for what specific target.
  prefs: []
  type: TYPE_NORMAL
- en: The same goes for `swiftSettings` too, a place where we can set Swift-specific
    optimizations for the build when in either release or debug mode (but generally
    we do this for release builds).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, refer to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Semantic versioning: [https://semver.org](https://semver.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Building for production: [https://github.com/swift-server/guides#building-for-production](https://github.com/swift-server/guides#building-for-production)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CocoaPods: [https://cocoapods.org](https://cocoapods.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Carthage: [https://github.com/Carthage/Carthage](https://github.com/Carthage/Carthage)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-time communication using WebSockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Communicating via WebSockets has been around for a long time and plays an integral
    part in server-to-server, server-to-client, and client-to-server communications.
    WebSockets allow open and constant communication between both parties, thus allowing
    data to be sent and received without the need for "polling" for changes.
  prefs: []
  type: TYPE_NORMAL
- en: A commonplace where you might see WebSockets being used would be a chat window
    – a constant line of communication between each device (usually via a server).
    Think of it as the "telephone line" of the internet (which is actually not too
    far from the truth).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to take our previously built Vapor project and
    communicate in real time with a companion iOS app.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this section, you'll need the completed project from our previous section.
    Feel free to continue to work on the sample project found in the Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you'll need the **TaskAPIApp** project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, let''s head over to our `Routes.swift` file and add in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Look familiar? Here, we are ultimately creating an "endpoint" for our WebSocket
    called `"talk-back"`. When successfully connected, all data will be received via
    the `ws` parameter in the function. But how can we intercept this? Well, there
    are a couple of ways actually. Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Our client, when connected to our server via WebSockets, can send a number of
    specific commands, such as sending plain text or sending binary text. For this
    recipe, we'll just be using `onText`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code and run your server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: So, essentially, what we are doing here is listening for a message from our
    client (any message), but if the message meets our specific condition, we're going
    to send a response straight back.
  prefs: []
  type: TYPE_NORMAL
- en: Now, from the GitHub repository, fire up the **TaskAPIApp** project in Xcode.
    Here, you'll notice we're using a third-party dependency called Starscream to
    enable our app as a WebSocket client – we could have gone through and built our
    own but that was a little out of scope and unnecessary for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to note: we used SPM in order to obtain the Starscream dependency
    – take a look in the Xcode project and compare it to our Vapor project to see
    how it matches up!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, with the iOS app loaded, check out the `ViewController.swift` file and
    make sure the localhost URL is correct as per your current setup (it should be
    the same if you are following along):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'If you take a closer look in the `ViewController.swift` file, you''ll see the
    following hooked up to an `IBAction`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: We've got the option to send a String via our WebSocket connection – boom!
  prefs: []
  type: TYPE_NORMAL
- en: Launch the project (still making sure your Vapor server is running locally)
    and click the button. What do you see? All being well, you should see the words
    Is it me you are looking for...? appear in the `UILabe``l` – nice!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WebSockets in Vapor act in a similar way to routes. Just as we said about our
    talk-back endpoint we created that the only difference was that the connection
    was open, the difference here is there have been no additional calls made – our
    server didn't need to rebuild and re-connect a new URL request, so there's no
    additional authorization or authentication. Our client (much like our server)
    was just listening for a response.
  prefs: []
  type: TYPE_NORMAL
- en: All WebSocket calls are asynchronous – and don't reply in the usual request/response
    pattern that we see with HTTP. However, it is up to you, the client or the server,
    to manage this connection, checking to make sure it is still not alive, and being
    ready to handle the requests at any time.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We touched earlier on the `onText` and `onBinary` functions available to us
    when receiving a message from our client, but by default, WebSockets constantly
    ping each other to make sure they are still active (or alive). We can monitor
    these requests by intercepting them with the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternately, we can use our Vapor project to connect to a WebSocket too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending messages whilst connected as a client is performed in the same way
    as we sent a message earlier, either through plain text or binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'While sending messages is done asynchronously, sometimes we would like to know
    if our message has been sent successfully – we can do this with the use of the
    `eventLoop` promise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we have these options to close and handle our open WebSocket connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: WebSockets really are a way of opening up your server in terms of real-time
    connectivity to your client. There are usually many things that it can be used
    for, such as dashboard reporting and chat messaging.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'WebSockets: [https://docs.vapor.codes/4.0/websockets/](https://docs.vapor.codes/4.0/websockets/)'
  prefs: []
  type: TYPE_NORMAL
- en: Packaging and sharing models between server and app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Server-side Swift is credited for the fact that web application developers can
    harness the power of the Swift programming language first hand. This, along with
    the power of the open source community behind it – even in what is still classed
    as its infancy - means that server-side Swift is already a worthy production-quality
    option.
  prefs: []
  type: TYPE_NORMAL
- en: But what about other advantages, specifically for iOS developers who now build
    their apps using Swift? Other than knowledge of syntax and specific APIs, what
    else can they benefit from?
  prefs: []
  type: TYPE_NORMAL
- en: As we saw earlier in this chapter, with the integration of the Swift Package
    Manager into Xcode, we can now build out some of our code into a module that we
    can reuse in both our server-side Swift apps and our iOS apps.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this section, we'll continue to work on our Vapor project and will continue
    to work on a Mac using Xcode.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a moment, let's take a step away from our Vapor app. We'll start by creating
    a new Swift package module. In Xcode, click on **File** | **New** | **Swift Package
    –** call it `TaskModule` and click Save. You should now be presented with a brand-new
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you take a look at File Explorer, you''ll see some familiar files, such
    as `Packages.swift`. Our main concern is the files that live inside the Sources
    folder – here is where your files and classes will live and will grow as part
    of the module you want to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/05cee1ff-cdd9-453a-8d40-c311d61f65de.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Sources folder
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating a new file called `TaskViewModel.swift` – this file
    will be a view model to the model we created in our Vapor project.
  prefs: []
  type: TYPE_NORMAL
- en: A view model is basically a model that only houses data based on what is required
    to render a particular view, for example, a response model from a server might
    have 20 properties all containing information such as date timestamps, created
    by, and so on, but our rendered view may only be interested in a handful of that
    information or may want to manipulate or compute some of the data into one single
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are building a very basic view model, an enum class
    to bind our category to a 1-1 match on our title property, and a computed property
    for an image URL.
  prefs: []
  type: TYPE_NORMAL
- en: As it stands, that code can be used in either our server-side Swift project
    or an iOS app – but how do we get it to do both? Well, easy! As we've created
    this as a Swift package, we can just import it as a Swift package . Close this
    project from Xcode (important) and head on over to `Packages.swift` in your Vapor
    app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following highlighted changes. Note that the local path must be the
    one on your machine – this needs to point to the directory where your `Packages.swift`
    file lives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're doing just as we did previously – adding in our package and then
    referencing a module name to the package for our specific target.
  prefs: []
  type: TYPE_NORMAL
- en: Give Xcode a moment to pick up this change and, as if by magic, you'll see our
    recently created module inside our dependency tree. Let's go ahead and try and
    use it.
  prefs: []
  type: TYPE_NORMAL
- en: For now, let's add this into our `TaskControllerAPI()` file as it is in here
    that we find bind our original **Task** model from our response.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by importing our Module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'All being well, this should resolve nicely. Now let''s try and access our view
    model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'And it really is as simple as that. Let''s take a look at this from the other
    side now and see how we can use this same module in our iOS app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to make sure that our `TaskModule` folder is initialized as
    a Git repo and there is an initial commit performed – I''ll explain why shortly,
    but for now, just simply perform the following commands in Terminal to initialize
    a repository for the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Now open our existing project, `TaskAPIApp`, in Xcode and select **File** |
    **Swift** **Package** | **Add Package Dependency**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll be presented with a GUI asking for the URL for a Git repository. As
    ours is currently local, we need to give it in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Xcode requires an active Git repository in order to pull a dependency – so
    we''ve just created one locally, as opposed to remotely. Xcode is happy and will
    allow us to continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1f46004-0502-416e-abe3-40c38b64f0dc.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – Choose a package repository
  prefs: []
  type: TYPE_NORMAL
- en: 'The next screen should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6db05d2b-d16a-4a36-bb36-1e126ae45fbd.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Choose the package option
  prefs: []
  type: TYPE_NORMAL
- en: Specify a **Branch** and enter `master` and click **Next**. All being well,
    Xcode should be ready to import your dependency – click Finish.
  prefs: []
  type: TYPE_NORMAL
- en: Go back over to your Xcode project and you'll now see `TaskModule` successfully
    imported into your project. Let's make sure this is all working as expected. Head
    on over to your `ViewControler.swift` file and let's try and use our view model.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by importing our `TaskModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we should be able to access our view model perfectly from anywhere
    within our iOS code base:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Wonderful – we've now successfully created and reused our view model in both
    our iOS and server-side Swift project.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The beauty of being able to use our code in both server-side Swift and iOS
    projects doesn''t have to stop at things like view models; specific computed logic
    can sit in here too, but you just have to be aware of a couple of things: remember
    your server-side Swift project is 99% likely to be running on a Linux server,
    so frameworks such as UIKit won''t be available for use; however, this works both
    ways too.'
  prefs: []
  type: TYPE_NORMAL
- en: Our `Codable` equivalent `Content` on Vapor which won't be available in our
    iOS project (as it simply just isn't needed there), so think carefully about how
    you want to split and share your logic. Take time to understand your requirements
    and separation of concerns when developing your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'That aside, there are ways to target specific operating systems that our apps
    could be running on. Let''s have a look at how we would achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to be a bit more specific, you can identify operating systems with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Again, if you're running your server-side Swift project on macOS, you'll be
    fine – but you're not really future-proofing your code as you may find at some
    point in the future, it's going to be more cost-effective and versatile to run
    your app on a Linux box.
  prefs: []
  type: TYPE_NORMAL
- en: Looking a little deeper into how the Swift Package Manager works is not as complex
    as you might think – although, I may add, it has exceptional convenience and power.
  prefs: []
  type: TYPE_NORMAL
- en: For those familiar with workspaces in Xcode, this follows a not too dissimilar
    pattern – essentially, your module is a link to the project we created earlier.
    The version of the code that is pulled into your project is defined by the `version
    number`, `branch`, or even `commit` we specify.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a package to use internally is one thing, but distributing it to others
    – either within your organization or the community – is another.
  prefs: []
  type: TYPE_NORMAL
- en: This is where hosting your package in a remote Git repository comes in handy.
    This not only allows you to version-control the changes in your package independently,
    but you can choose to administer these with a private repository, allowing for
    controlled internal use.
  prefs: []
  type: TYPE_NORMAL
