- en: Server-Side Swift
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端Swift
- en: From its very inception, Swift was intended to be a general-purpose programming
    language, applicable for multiple use cases and on multiple platforms, not just
    for building apps for Apple platforms. One of the obvious use cases, other than
    building apps, is creating server-side code. After all, interacting with a server
    is a vital component of almost any app. The vast majority of servers that power
    the internet run on Linux, which is arguably more suited to the task than any
    Apple platform. Therefore, being able to run Swift on Linux is vital to the goal
    of making Swift a viable server-side programming language option.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从其诞生之初，Swift就被设计成一种通用编程语言，适用于多种用例和多个平台，而不仅仅是用于构建Apple平台的应用程序。除了构建应用程序之外，另一个明显的用例是创建服务器端代码。毕竟，与服务器交互是几乎所有应用程序的一个关键组成部分。支撑互联网的大多数服务器都运行在Linux上，这在某种程度上比任何Apple平台更适合这项任务。因此，能够在Linux上运行Swift对于使Swift成为可行的服务器端编程语言选项至关重要。
- en: In this chapter, we will investigate installing the Swift toolchain on Linux,
    using a web server framework to build a REST API, and hosting our API via a hosting
    service.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨在Linux上安装Swift工具链，使用Web服务器框架构建REST API，并通过托管服务托管我们的API。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Running Swift on Linux
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux上运行Swift
- en: Building a REST API using Vapor and Fluent
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vapor和Fluent构建REST API
- en: Database persistence with Fluent and Postgres
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Fluent和Postgres进行数据库持久化
- en: Hosting your Vapor app on Heroku
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Heroku上托管你的Vapor应用程序
- en: The Swift Package Manager
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift包管理器
- en: Real-time communication using WebSockets
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用WebSockets进行实时通信
- en: Packaging and sharing models between server and app
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器和应用程序之间打包和共享模型
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All the code for this chapter can be found in this book''s GitHub repository:
    [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter08](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter08)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码都可以在这个书的GitHub仓库中找到：[https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter08](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter08)
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3kgvhxe](https://bit.ly/3kgvhxe)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：[https://bit.ly/3kgvhxe](https://bit.ly/3kgvhxe)
- en: Running Swift on Linux
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Linux上运行Swift
- en: The Linux operating system is a dominant force in the world of backend servers,
    so to be of any use for server-side development, Swift needs to be available on
    Linux. Fortunately, part of the open source release of Swift includes the Swift
    toolchain on Linux. Let's get it up and running with a "Hello World" program in
    Swift on Linux.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Linux操作系统在后台服务器领域是一个主导力量，因此为了在服务器端开发中发挥作用，Swift需要在Linux上可用。幸运的是，Swift开源发布的一部分包括Linux上的Swift工具链。让我们通过在Linux上的Swift“Hello
    World”程序来启动它。
- en: Getting started
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门
- en: This recipe will use Ubuntu 20.04, as this is a very popular and widely used
    Linux distribution, and 20.04 is the latest **Long-Term Support** (**LTS**) version.
    Additionally, pre-built binaries of the Swift toolchain are provided for this
    distribution by the Swift open source team. As a Mac user, I have tested this
    process on an instance of Ubuntu, running in the VirtualBox virtualization environment,
    but there should be no difference when running on bare metal.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱将使用Ubuntu 20.04，因为这个Linux发行版非常受欢迎且广泛使用，20.04是最新版的**长期支持**（**LTS**）版本。此外，Swift开源团队还为这个发行版提供了预构建的二进制文件。作为一名Mac用户，我已经在Ubuntu的实例上测试了此过程，该实例在VirtualBox虚拟化环境中运行，但在裸机上运行时应该没有差异。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s install the Swift toolchain and run our first Swift code on Linux:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装Swift工具链并在Linux上运行我们的第一个Swift代码：
- en: 'We need to install some dependencies related to the compiler. If you are using
    Ubuntu with a **Graphical User Interface** (**GUI**), open up a Terminal window
    and run the following from the prompt to update the software repositories:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要安装一些与编译器相关的依赖项。如果你使用的是带有**图形用户界面**（**GUI**）的Ubuntu，请打开一个终端窗口，并在提示符下运行以下命令以更新软件仓库：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Run the next command to install a number of dependencies required for the Swift
    toolchain:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以安装Swift工具链所需的多个依赖项：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The Swift team released a prebuilt toolchain for Ubuntu, so we will need to
    download the latest released version and the associated `signature` file. Links
    for these releases can be found at [https://swift.org/download/#releases](https://swift.org/download/#releases).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Swift团队为Ubuntu发布了预构建的工具链，因此我们需要下载最新发布的版本和相关`signature`文件。这些发布版本的链接可以在[https://swift.org/download/#releases](https://swift.org/download/#releases)找到。
- en: 'Download the toolchain and PGP signature file for the relevant platform. For
    example, at the time of writing, the most recent release versions can be downloaded
    using `wget` with the following command:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载相关平台的工具链和PGP签名文件。例如，在撰写本文时，最新的发布版本可以使用以下`wget`命令下载：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The signature file that we downloaded can be used to verify that the toolchain
    archive has not been tampered with or modified during the download. The verification
    will use public PGP keys provided by the Swift project in conjunction with the
    signature file. If you haven''t done so before, you can use the following command
    to retrieve the PGP keys and import them into your keyring:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们下载的签名文件可以用来验证工具链存档在下载过程中没有被篡改或修改。验证将使用Swift项目提供的公共PGP密钥与签名文件一起进行。如果您之前还没有这样做，可以使用以下命令检索PGP密钥并将它们导入到您的密钥环中：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we need to check for any key revocation certificates:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要检查是否有任何密钥吊销证书：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With all that done, we can verify the integrity of our downloaded toolchain
    archive (replacing the signature filename below with the one downloaded):'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成所有这些后，我们可以验证下载的工具链存档的完整性（将下面的签名文件名替换为下载的文件名）：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The response should contain the `gpg: Good signature from "Swift 5.x Release
    Signing Key <swift-infrastructure@swift.org>"` line; if it does, the archive has
    been successfully verified, and if not, the download may have been altered and
    should be retrieved from a trusted source on a trusted network.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '响应应包含`gpg: Good signature from "Swift 5.x Release Signing Key <swift-infrastructure@swift.org>"`行；如果是这样，存档已成功验证，如果不是，下载可能已被篡改，应从受信任网络上的受信任源检索。'
- en: Don't be alarmed if it says the key is not from a trusted `signature`. This
    is because the system can't find an unbroken chain of certificates from your computer
    to this key; it's okay to ignore this warning.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它说密钥不是来自受信任的`signature`，请不要惊慌。这是因为系统无法从您的计算机到该密钥找到未中断的证书链；可以忽略此警告。
- en: 'With our archive verified, let''s unzip the archive and see what''s inside
    (replacing the filename that follows with the toolchain downloaded):'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在验证存档后，让我们解压存档并查看里面有什么（将下面的文件名替换为下载的工具链）：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Within the archive is a `usr` folder, and within that, a `bin` folder, which
    contains a number of binaries that are related to building Swift; key among them
    is the `swift` binary.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在存档中有一个`usr`文件夹，在该文件夹中，有一个`bin`文件夹，其中包含与构建Swift相关的多个二进制文件；其中最重要的是`swift`二进制文件。
- en: 'We want to interact with the Swift toolchain using just the command `swift`;
    to do this, we need to tell the system where to look for the Swift binaries. Open
    up `~/.profile` in your preferred text editor, and add the folder containing your
    Swift toolchain to the `$PATH` export command:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望仅使用`swift`命令与Swift工具链交互；为此，我们需要告诉系统在哪里查找Swift二进制文件。使用您首选的文本编辑器打开`~/.profile`，并将包含您的Swift工具链的文件夹添加到`$PATH`导出命令中：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Save your `.profile` file.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的`.profile`文件。
- en: Log out and log back in for the changes to take effect.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出并重新登录以使更改生效。
- en: Now, when you type `swift` and press *Enter*, the Swift REPL will launch. It
    stands for the **read–eval–print loop** (**REPL**); it's a way to interact with
    the Swift language in a very quick, easy way, much like a playground.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当您输入`swift`并按*Enter*时，Swift REPL将启动。它代表**读取-评估-打印循环**（**REPL**）；这是一种以非常快速、简单的方式与Swift语言交互的方法，就像游乐场一样。
- en: In the REPL, you can write Swift commands and press *Enter* to have them executed,
    with each command occurring within the same scope as the previous commands.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在REPL中，您可以编写Swift命令并按*Enter*键执行它们，每个命令都在与上一个命令相同的范围内。
- en: 'In the REPL, type the following Swift expression:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中，输入以下Swift表达式：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Press *Enter*, and the REPL will display the outcome of your command, much
    like a playground does:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Enter*，REPL将显示您命令的结果，就像游乐场一样：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we can print our greeting:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以打印我们的问候语：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We get the expected response:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到预期的响应：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To leave the REPL and return to your normal command line, type the following
    and press *Enter*:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要离开REPL并返回到您的正常命令行，请输入以下内容并按*Enter*：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Congratulations! You just executed Swift code on Ubuntu Linux. The world of
    server-side Swift awaits.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚在Ubuntu Linux上执行了Swift代码。服务器端Swift的世界在等待着你。
- en: There's more...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'It''s great to try out Swift code at the command line using the REPL, but what
    we really require is the ability to compile our code into an executable binary
    that we can run on demand. Let''s take our "Hello world!" example and compile
    it into a binary:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中尝试Swift代码是很好的，但我们真正需要的是将我们的代码编译成一个可执行的二进制文件，我们可以按需运行它。让我们将我们的“Hello world!”示例编译成一个二进制文件：
- en: 'Open your favorite text editor and save the following into a file called `HelloWorld.swift`:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你喜欢的文本编辑器，将以下内容保存到一个名为`HelloWorld.swift`的文件中：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'From the command line, in the folder that contains our Swift file, we can compile
    our binary using `swiftc`. We can specify the file or files to compile and use
    the `-o` flag to provide a name for the output binary:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，在包含我们的Swift文件的文件夹中，我们可以使用`swiftc`编译我们的二进制文件。我们可以指定要编译的文件或文件，并使用`-o`标志为输出二进制文件提供名称：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we can run the binary:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以运行这个二进制文件：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Compiling one file is great, but to perform any useful work, we are likely to
    have multiple Swift files that define things like models, controllers, and other
    logic, so how can we compile them into a single, executable binary?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 编译一个文件是很好的，但为了执行任何有用的任务，我们可能需要多个Swift文件来定义诸如模型、控制器和其他逻辑等，那么我们如何将它们编译成一个单一的、可执行的二进制文件呢？
- en: When we have multiple files, we need to be able to define one at the entry point
    of our application. When compiling a Swift binary with multiple files, one of
    them should be called `main.swift`. This file serves as the entry point so that
    when the binary is run, the code in the `main.swift` file is executed from start
    to end.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有多于一个文件时，我们需要能够在应用入口点定义一个。当编译包含多个文件的Swift二进制文件时，其中一个应该被命名为`main.swift`。这个文件作为入口点，所以当二进制文件运行时，`main.swift`文件中的代码会从头到尾执行。
- en: 'Let''s make two Swift files, the first one named `Model.swift`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建两个Swift文件，第一个文件命名为`Model.swift`：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we''ll create the `main.swift` file:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建`main.swift`文件：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let''s compile these two files into a binary called `Greeter`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这些两个文件编译成一个名为`Greeter`的二进制文件：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This can then be executed:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以被执行：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have now written and compiled a binary from multiple files in Swift on Ubuntu.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经在Ubuntu上的Swift中编写并编译了一个由多个文件组成的二进制文件。
- en: Building a REST API using Vapor and Fluent
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vapor和Fluent构建REST API
- en: One of the main use cases for server-side Swift is building REST APIs. Interacting
    with network data is a key function of almost any app, and until now, that server-side
    component had to be built by someone else with the relevant server-side skills.
    Alternatively, it required an app developer to frequently switch between programming
    languages and development environments to build both the client-side and the server-side
    code of an app.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端Swift的主要用例之一是构建REST API。与网络数据交互是几乎所有应用的关键功能，直到现在，这个服务器端组件必须由具有相关服务器端技能的其他人构建。或者，它要求应用开发者频繁地在编程语言和开发环境之间切换，以构建应用的前端和后端代码。
- en: Swift on the server opens the possibility for a developer to work on everything
    involved in the app, and move seamlessly between the client side and server side.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端的Swift为开发者提供了在应用的所有方面工作的可能性，并且可以在客户端和服务器端之间无缝切换。
- en: 'Much has been done by the Swift team to encourage the use of Swift on the server,
    including creating a new networking framework for running servers. This new framework
    is called SwiftNIO and is available open-sourced on GitHub: [github.com/apple/swift-nio.](https://github.com/apple/swift-nio)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Swift团队已经做了很多工作来鼓励在服务器上使用Swift，包括创建一个新的用于运行服务器的网络框架。这个新的框架被称为SwiftNIO，并且可以在GitHub上以开源的形式获得：[github.com/apple/swift-nio.](https://github.com/apple/swift-nio)
- en: This framework is quite low-level, and a number of higher-level frameworks exist
    to make creating a REST API easier using Swift.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个框架相当底层，存在许多高级框架，它们使用Swift使创建REST API变得更加容易。
- en: In this recipe, we will use one of the more popular frameworks, Vapor, to build
    a REST API for an app that stores a user's tasks.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用一个更受欢迎的框架，Vapor，来构建一个用于存储用户任务的应用的REST API。
- en: Getting started
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门
- en: Vapor is a Swift framework for building web services, that makes accomplishing
    common tasks very easy. At the time of writing, Vapor is at Version 4, which is
    required with Swift 5.2\. More information about Vapor can be found on its website
    at [http://vapor.codes.](http://vapor.codes)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Vapor是一个用于构建网络服务的Swift框架，它使完成常见任务变得非常容易。在撰写本文时，Vapor处于版本4，这是与Swift 5.2一起要求的。有关Vapor的更多信息，请访问其网站：[http://vapor.codes.](http://vapor.codes)
- en: For this recipe, we will assume that you are developing your Swift web service
    on a Mac, even if it may eventually be deployed to a Linux server.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将假设您正在Mac上开发Swift网络服务，即使它最终可能部署到Linux服务器。
- en: When writing Swift code that will be deployed on Linux, it's very important
    to test your code by actually running it on Linux, especially if it's initially
    developed on macOS. There are significant differences between Swift's operation
    on macOS and Linux. These differences are often due to the different implementation
    of the Foundation framework on the different platforms.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写将在Linux上部署的Swift代码时，通过实际上在Linux上运行代码来测试您的代码非常重要，尤其是如果它最初是在macOS上开发的。Swift在macOS和Linux上的操作之间存在重大差异。这些差异通常是由于不同平台对Foundation框架的不同实现。
- en: 'Let''s verify that we have the right version of Swift installed to run Vapor.
    Run the following command in Terminal to check your version of Swift:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证我们是否安装了正确的Swift版本以运行Vapor。在终端中运行以下命令以检查您的Swift版本：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The output should indicate at least `version 5.2`; if this is not the case,
    you will need to update your version of Xcode.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应至少指示`版本 5.2`；如果不是这种情况，您需要更新您的Xcode版本。
- en: We next need to install Vapor Toolbox, which is a set of command-line tools
    to simplify working with Vapor-based projects. The Vapor CLI is available through
    Homebrew, which is a package manager for macOS. You can find more details about
    Homebrew on its website at [https://brew.sh](https://brew.sh)[.](https://brew.sh)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要安装Vapor Toolbox，它是一组命令行工具，用于简化与基于Vapor的项目的工作。Vapor CLI可通过Homebrew获得，Homebrew是macOS的包管理器。您可以在其网站上找到有关Homebrew的更多详细信息：[https://brew.sh](https://brew.sh)[.](https://brew.sh)
- en: At the time of writing, Homebrew has not been updated to support the recently
    released Apple Silicon Macs. If you are using one of these Macs, please check
    the Homebrew website for compatibility information.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Homebrew尚未更新以支持最近发布的Apple Silicon Macs。如果您使用的是这些Mac之一，请访问Homebrew网站以获取兼容性信息。
- en: 'If you don''t already have Homebrew installed, run the following in Terminal:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未安装Homebrew，请在终端中运行以下命令：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With Homebrew installed, we can add the `tap` for Vapor:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Homebrew后，我们可以添加Vapor的`tap`：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s run Vapor to check whether it''s installed correctly. You should see
    instructions on how to use Vapor:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行Vapor来检查它是否正确安装。您应该会看到如何使用Vapor的说明：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We are now ready to use Vapor to build our REST API.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用Vapor来构建我们的REST API了。
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will create a web service to store and manage tasks from an iOS app:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个网络服务来存储和管理来自iOS应用的任务：
- en: 'Create a new Vapor project called `TaskAPI` and then move to the new folder
    that is created:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`TaskAPI`的新Vapor项目，然后移动到创建的新文件夹：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: During this process, you will be asked ***Would you like to use Fluent?*** Answer
    yes to this. You will then be asked which database you would like to use. Select
    **Postgres** (this should be the recommended one).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，您将被询问“您想使用Fluent吗？”回答“是”。然后您将被询问您想使用哪个数据库。选择**Postgres**（这应该是推荐的选项）。
- en: Additionally, you will be asked if you would like to install ***Leaf***. Select
    **No** for now, as this goes slightly outside of the scope of this recipe.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您将被询问是否想安装**Leaf**。目前选择**否**，因为这稍微超出了本配方的范围。
- en: You can create your Vapor web service using any IDE, but we are familiar with
    using Xcode, so let's use that.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用任何IDE创建您的Vapor网络服务，但我们熟悉使用Xcode，所以让我们使用它。
- en: 'Vapor has support for creating an Xcode project containing our Vapor code,
    so let''s launch Xcode for our Vapor project:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Vapor支持创建包含我们的Vapor代码的Xcode项目，所以让我们为我们的Vapor项目启动Xcode：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Xcode will open and the project dependencies will be fetched automatically and
    appear under Swift Package Dependencies in the project navigator. Be patient –
    this can take a few minutes and you might not see any activity straight away.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode将打开，项目依赖项将自动获取并出现在项目导航器中的Swift包依赖项下。请耐心等待——这可能需要几分钟，您可能一开始看不到任何活动。
- en: Once all the dependencies have been fetched, the build and run button will become
    active.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有依赖项都已获取，构建和运行按钮将变为活动状态。
- en: Build and run the project to launch a local web server, which will handle requests
    to `http://127.0.0.1:8080`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行项目以启动本地Web服务器，该服务器将处理对`http://127.0.0.1:8080`的请求。
- en: 'Open `http://127.0.0.1:8080` in a browser and you will see this web page:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开`http://127.0.0.1:8080`，您将看到以下网页：
- en: '![](img/52dad583-d066-4208-ad58-32705b7e40e3.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/52dad583-d066-4208-ad58-32705b7e40e3.png)'
- en: Figure 8.1 – Vapor project
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – Vapor项目
- en: It works! You now have your bare-bones Vapor project up and running. Now let's
    take a look at the Xcode project that Vapor has created for us.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 它工作了！现在您已经有了您的裸骨Vapor项目并正在运行。现在让我们看看Vapor为我们创建的Xcode项目。
- en: 'In the Project Navigator, you will find a Sources group, and two subgroups:
    Run and App. The Run group contains `main.swift`, the file that will be executed
    when you run the app. The App group contains a number of files with some example
    code for setting up a REST API.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中，您将找到一个名为“源”的组，以及两个子组：运行和应用程序。运行组包含`main.swift`文件，这是您运行应用程序时将执行的文件。应用程序组包含一些用于设置REST
    API的示例代码的多个文件。
- en: 'Open the `main.swift` file; it will contain the following template code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`main.swift`文件；它将包含以下模板代码：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You shouldn't really need to edit this file; it just performs the required setup
    and starts the web server that serves up our API. What we do need to do is to
    use this setup process to configure Vapor to provide the API we require.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您实际上并不需要编辑此文件；它只是执行所需的设置并启动为我们提供API的Web服务器。我们需要做的是使用此设置过程来配置Vapor以提供我们所需的API。
- en: 'Let''s look at how the default Vapor template sets things up. In the App group,
    open the `configure.swift` file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看默认Vapor模板是如何设置这些内容的。在应用程序组中，打开`configure.swift`文件：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this file, we've imported the `Vapor` module, which contains all the code
    to set up and manage the Vapor web server. We've also got our code for our database,
    but we'll go further into that a little later on. If you look back at `main.swift`,
    you will see that it imports the `App` module; this is the module that will contain
    all of your code for setting up the web server and managing requests and responses.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，我们导入了`Vapor`模块，该模块包含设置和管理Vapor Web服务器的所有代码。我们还有我们的数据库代码，但我们会稍后进一步介绍。如果您回顾一下`main.swift`文件，您会看到它导入了`App`模块；这是包含您设置Web服务器和管理请求和响应的所有代码的模块。
- en: Note in the preceding code, I've highlighted a required change for the latest
    version of Vapor which may now be included in the most recent template, if you
    are unsure, just copy the preceding code into your project from here or take a
    look at the source files.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在前面代码中，我突出显示了对最新版本Vapor的必要更改，这可能已包含在最新的模板中，如果您不确定，只需将前面的代码从此处复制到您的项目中，或者查看源文件。
- en: 'Next, let''s switch to `Routes.swift`, and we will see that this is where our
    routes are configured:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们切换到`Routes.swift`文件，我们会看到这是我们的路由配置的地方：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: A route defines a type of request that the web server may receive, and the response
    to send.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 路由定义了Web服务器可能接收的请求类型以及要发送的响应。
- en: 'You will notice that the `"plaintext"` path is defined, which is the URL we
    visited to determine that everything was correctly configured:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到定义了`"plaintext"`路径，这是我们访问以确定一切配置正确的URL：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This route is for a `GET` request, with the path string parameter, `plaintext`;
    when our Vapor server was locally run, this related to the URL `http://0.0.0.0:8080`.
    The process of defining a route in Vapor involves providing a closure that takes
    a `Request` object and returns something that conforms to `ResponseRepresentable`;
    Vapor has already defined the string as conforming to `ResponseRepresentable`,
    so in the string, Hello, world! can be returned.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此路由是为`GET`请求，带有路径字符串参数`plaintext`；当我们的Vapor服务器在本地运行时，这与URL`http://0.0.0.0:8080`相关。在Vapor中定义路由的过程涉及提供一个闭包，该闭包接受一个`Request`对象并返回符合`ResponseRepresentable`的对象；Vapor已经定义了字符串符合`ResponseRepresentable`，因此可以在字符串中返回“Hello,
    world!”。
- en: Build and run the Run scheme, if it's not already running, and visit `http://0.0.0.0:8080/hello`
    to see the JSON defined.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未运行，构建并运行运行方案，并访问`http://0.0.0.0:8080/hello`以查看定义的JSON。
- en: How it works...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The **TaskAPI** will accept new tasks as POST requests containing JSON representations
    of the tasks and will return all the existing tasks via `GET` requests.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**TaskAPI**将接受包含任务JSON表示的POST请求中的新任务，并通过`GET`请求返回所有现有任务。'
- en: First, let's define a task – in the App group of your Xcode project, create
    a new file called `Task.swift` in a new group called Models.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义一个任务 – 在你的Xcode项目的App组中，在名为`Models`的新组中创建一个名为`Task.swift`的新文件。
- en: 'After creating this file, ensure that it is a member of the App target and
    not any others. The Target Membership panel for our new file should look like
    this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此文件后，请确保它是App目标的成员，而不是其他任何成员。我们新文件的目标成员面板应如下所示：
- en: '![](img/62d8ea0a-aa0f-402c-8ccc-390a12efe1d9.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/62d8ea0a-aa0f-402c-8ccc-390a12efe1d9.png)'
- en: Figure 8.2 – Target membership
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 目标成员
- en: 'Now, let''s define our task as having two properties: `description` and `category`,
    plus an identifier:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义我们的任务具有两个属性：`description`和`category`，以及一个标识符：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can now create a `Task` in code, like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在代码中创建一个`Task`，如下所示：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: However, we will always create our `Task` objects from the JSON received by
    the `POST` request, so being able to create our `Task` objects directly from JSON
    will be very helpful, and since we will be returning our `Task` objects as JSON,
    being able to convert them to JSON will also be helpful.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将始终从`POST`请求接收到的JSON创建我们的`Task`对象，所以能够直接从JSON创建我们的`Task`对象将非常有帮助，并且由于我们将返回我们的`Task`对象作为JSON，所以能够将它们转换为JSON也将非常有帮助。
- en: Vapor has a framework called Content for dealing with JSON data. Content is
    Vapor's version of Codable (which we learned about in *[Chapter 6](32abd392-d947-461c-a9e9-912b34704c9b.xhtml),
    Building iOS Apps with Swift*).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Vapor有一个名为Content的框架，用于处理JSON数据。Content是Vapor的`Codable`版本（我们在*[第6章](32abd392-d947-461c-a9e9-912b34704c9b.xhtml)，使用Swift构建iOS应用*)中了解到的）。
- en: The Vapor project we created, in turn, creates example code of everything we're
    about to go through. If you get stuck at any time, simply refer to the template
    counterpart for guidance as to where you could be going wrong.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的Vapor项目反过来创建了我们将要经历的示例代码。如果你在任何时候遇到困难，只需参考模板对应部分以获取指导，了解你可能出错的地方。
- en: 'Let''s add the `Content` conformance to our `Task` model object:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给我们的`Task`模型对象添加`Content`一致性：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When we are creating a new task, we don't expect the JSON to include the identifier,
    so if it is missing, we can generate a `UUID` using the `Foundation` framework.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个新任务时，我们不会期望JSON包含标识符，所以如果它缺失，我们可以使用`Foundation`框架生成一个`UUID`。
- en: Now that we have our `Task` model object, which can be converted to and from
    JSON, let's create some routes for our API.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了可以转换为JSON并从JSON转换的`Task`模型对象，让我们为我们的API创建一些路由。
- en: 'In `Routes.swift`, we need an array of `Task` objects to hold the tasks that
    get created; for the moment, we can just add that to the top of the file:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Routes.swift`中，我们需要一个`Task`对象的数组来保存创建的任务；目前，我们只需将其添加到文件顶部：
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we''ll add two routes to the `routes()` method:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向`routes()`方法添加两个路由：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the first route, we look for a `POST` request to the `/task` path. If the
    request has JSON, then we can use it to attempt to create a `Task` object using
    the JSON; once created, we can store it in the `tasks` array.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个路由中，我们查找对`/task`路径的`POST`请求。如果请求包含JSON，则我们可以使用它来尝试使用JSON创建一个`Task`对象；一旦创建，我们就可以将其存储在`tasks`数组中。
- en: The next route looks for a `get` request to that same path – `/task` – and returns
    a JSON representation of the tasks we stored in our array. This makes use of the
    fact that Vapor has an extension of `Sequence`, which `Array` conforms to, and
    if all items in the `Sequence` conform to `JSONRepresentable`, then the `Sequence`
    can be represented as JSON, too. With these routes defined, let's build and run
    the Run scheme and test them out.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个路由查找对同一路径 – `/task` – 的`get`请求，并返回我们存储在数组中的任务的JSON表示。这是利用了Vapor有一个扩展名为`Sequence`的事实，而`Array`符合`Sequence`，如果`Sequence`中的所有项目都符合`JSONRepresentable`，则`Sequence`也可以表示为JSON。定义了这些路由后，让我们构建并运行Run方案，并测试它们。
- en: 'We''ll add a task, sending a `POST` request to `http://0.0.0.0:8080/task`;
    we can do this using the `curl` command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个任务，通过向`http://0.0.0.0:8080/task`发送`POST`请求；我们可以使用`curl`命令来做这件事：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This should return a JSON representation of the task we just created, which
    looks like this, although the `id` will be different:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该返回我们刚刚创建的任务的JSON表示，如下所示，尽管`id`将不同：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, let''s test our route to show all the existing tasks:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们测试我们的路由以显示所有现有任务：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This should return the one `Task` we created in an array:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该返回我们创建的一个`Task`数组：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We now have a simple API that stores our tasks.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个简单的API来存储我们的任务。
- en: Try adding a few more tasks and check whether they are returned from the `GET`
    request.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试添加更多任务并检查它们是否从`GET`请求返回。
- en: There's more...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The API we have created so far allows us to perform some operations on a task;
    namely, to create one and list all the current tasks. Implementing these actions,
    along with other operations such as modifying, deleting, and listing an individual
    task, is very common when building a REST API, so Vapor makes this really easy.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止创建的API允许我们在任务上执行一些操作；即创建一个任务和列出所有当前任务。实现这些操作，以及其他如修改、删除和列出单个任务的操作，在构建REST
    API时非常常见，因此Vapor使这变得非常简单。
- en: In Vapor, you can define a resource that will define how all these operations
    are performed, and Vapor handles the setting up of routes that follow standard
    practice for REST APIs.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vapor中，你可以定义一个资源，它将定义所有这些操作是如何执行的，Vapor会处理遵循REST API标准实践的路线设置。
- en: 'Let''s a new file called `TaskController.swift` – this will be our new `TaskControllerAPI`
    and will be responsible for housing our REST API response logic and will allow
    a degree of separation between our routing logic and our business logic:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`TaskController.swift`的新文件——这将是我们新的`TaskControllerAPI`，它将负责存放我们的REST
    API响应逻辑，并将允许我们的路由逻辑和业务逻辑之间有一定的分离：
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We are storing the created tasks in a dictionary, with the key being the task
    ID; this allows us to easily retrieve them when the ID is passed as a URL parameter.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将创建的任务存储在字典中，键是任务ID；这使我们能够轻松检索当ID作为URL参数传递时。
- en: 'To create our resource, we provide functions that provide the response for
    each `REST` operation that we would like to support. These areas are listed here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的资源，我们提供函数，为每个我们希望支持的`REST`操作提供响应。这些区域在此列出：
- en: '`index`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index`'
- en: '`store`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`store`'
- en: '`show`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`show`'
- en: '`replace`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replace`'
- en: '`modify`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modify`'
- en: '`destroy`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`destroy`'
- en: '`clear`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear`'
- en: '`aboutItem`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aboutItem`'
- en: '`aboutMultiple`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aboutMultiple`'
- en: As you can see from the preceding code, we've just created a couple to get going.
    We can add the rest in later as and when we need them.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的代码中看到的，我们刚刚创建了一些以开始。我们可以根据需要稍后添加其余部分。
- en: 'Now let''s add in an extension that conforms to **RouteCollection**:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加一个扩展，使其符合**RouteCollection**：
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here is where we take our routes that are specific to the core logic in `TaskControllerAPI`
    and define them as we need. With the routing code added here, we no longer need
    these in our `Routes.swift` file, so head on over there now and replace them with
    the following single line:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们将针对`TaskControllerAPI`核心逻辑的特定路由提取出来，并按需定义它们的地方。在这里添加了路由代码后，我们不再需要在`Routes.swift`文件中保留这些代码，所以现在就去那里，用以下单行代码替换它们：
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Rerun the project and let''s test whether everything still works as expected.
    Let''s create a task:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行项目，并测试是否一切仍然按预期工作。让我们创建一个任务：
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, fetch all tasks to check our newly created task is returned (notice how
    we changed the URL to `create`):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，获取所有任务以检查我们新创建的任务是否被返回（注意我们如何将URL更改为`create`）：
- en: '[PRE43]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We've now created a simple REST API for storing and retrieving tasks.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经创建了一个简单的REST API来存储和检索任务。
- en: In the next recipe, we will build on this to make it truly useful.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个菜谱中，我们将在此基础上构建，使其真正有用。
- en: See also
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: More information about the Vapor framework can be found on its website at [https://vapor.codes](https://vapor.codes).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于Vapor框架的信息可以在其网站上找到：[https://vapor.codes](https://vapor.codes)。
- en: 'Here are some other popular Swift web frameworks:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些其他流行的Swift网络框架：
- en: 'Kitura: [http://www.kitura.io](http://www.kitura.io)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kitura：[http://www.kitura.io](http://www.kitura.io)
- en: 'Perfect: [http://perfect.org](http://perfect.org)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完美：[http://perfect.org](http://perfect.org)
- en: 'Zewo: [http://www.zewo.io](http://zewo.io/)'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zewo：[http://www.zewo.io](http://zewo.io/)
- en: Database persistence with Fluent and Postgres
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Fluent和Postgres进行数据库持久性
- en: In our previous project, our task editor would work a treat as long as the server
    kept running, but one quick re-start and everything we've saved would be lost
    forever – which is why persistence, particularly with databases, plays a massive
    part in software development.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的项目中，只要服务器保持运行，我们的任务编辑器就会工作得很好，但一旦快速重启，我们保存的所有内容都会永远丢失——这就是为什么持久性，尤其是在数据库方面，在软件开发中起着至关重要的作用。
- en: In this section, we're going to continue to build on our TaskAPI project, adding
    persistence so that our data is always protected.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将继续构建我们的TaskAPI项目，添加持久性，以确保我们的数据始终得到保护。
- en: Getting ready
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this section, you''ll need to install Docker on your Mac. Follow this link
    for information on Docker and containerization, along with a link to the installer:
    [https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop).'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，你需要在你的 Mac 上安装 Docker。点击此链接获取有关 Docker 和容器化的信息，以及安装程序的链接：[https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop)。
- en: How to do it...
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First, we''ll need to create our database. Luckily, Vapor can do that for us:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建我们的数据库。幸运的是，Vapor 可以为我们做这件事：
- en: 'Start by creating a new file under the `Migration` folder called `CreateTasks.swift`
    and copy the following:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 `Migration` 文件夹下创建一个名为 `CreateTasks.swift` 的新文件，并复制以下内容：
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Notice our struct conforms to `Migration` – don''t worry, this is normal. Migrations
    are used even for creating databases. In the preceding code, we''re doing the
    following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们的结构符合 `Migration` – 不要担心，这是正常的。迁移在创建数据库时也会使用。在先前的代码中，我们正在执行以下操作：
- en: Creating a database with a schema called `task`
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 `task` 的数据库模式
- en: Creating fields in our database called `"description"`, `"category"`, along
    with an **ID** column
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的数据库中创建名为 `"description"`、`"category"` 的字段，以及一个 **ID** 列
- en: And that is it, really – job done. However, we need to tell our server to run
    the code and perform the migration (the `create` for us).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，任务完成了。然而，我们需要告诉我们的服务器运行代码并执行迁移（对我们来说是 `create`）。
- en: 'Go back over to `Configure.swift` and add in the following lines:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 `Configure.swift` 并添加以下行：
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: When our server application starts, the database will be created. Don't worry
    – Vapor only does this once, so if your database already exists, then it won't
    try and create it again.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的服务器应用程序启动时，数据库将被创建。不要担心 – Vapor 只会这样做一次，所以如果你的数据库已经存在，它将不会尝试再次创建它。
- en: 'Next, we need to adjust our code to allow our models to persist to the database
    matching the properties in our model to the fields we just created. Head back
    over to the `Task.swift` file and make the following highlighted changes:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要调整我们的代码，以便我们的模型可以持久化到数据库中，将模型中的属性与刚刚创建的字段相匹配。回到 `Task.swift` 文件并做出以下突出显示的更改：
- en: '[PRE46]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We'll go through the structure of this later on in the *How it works...* section,
    but for now, you just need to make sure the changes are in.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 *如何工作...* 部分稍后介绍这个结构的细节，但你现在只需确保更改已经实施。
- en: 'Next, head back over to our `TaskController.swift` and make the following changes:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，回到我们的 `TaskController.swift` 并进行以下更改：
- en: '[PRE47]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We're almost ready to go. Now we just need to get an instance of our database
    up and running. We'll achieve this by using a Docker container.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎准备就绪了。现在我们只需要启动并运行我们的数据库实例。我们将通过使用 Docker 容器来实现这一点。
- en: 'With Docker installed and running (if you are using Mac, you should have an
    icon that represents Docker on your toolbar), enter the following command in Terminal:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在使用 Mac（你应该在工具栏上有一个代表 Docker 的图标），在终端中输入以下命令：
- en: '[PRE48]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Notice they perfectly match the details we've got in our `Configure.swift` file.
    Feel free to adjust them accordingly to suit your specific needs/conventions.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意它们完美地匹配我们在 `Configure.swift` 文件中的详细信息。请随意根据您的具体需求/约定进行调整。
- en: 'All being well, you should see the following in Terminal:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应在终端中看到以下内容：
- en: '[PRE49]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This means everything is going well. Once installed, we're ready to launch our
    new and improved REST API. Go ahead and run the project from Xcode. You should
    notice the database migration/creation in Xcode's console window.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着一切顺利。一旦安装完成，我们就准备好启动我们新的改进后的 REST API。从 Xcode 中运行项目。你应该会在 Xcode 的控制台窗口中注意到数据库迁移/创建。
- en: 'Now launched, use our existing cURL command to add multiple items to our database:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在已启动，使用我们现有的 cURL 命令向我们的数据库添加多个项目：
- en: '[PRE50]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, restart the server (via Xcode) and call our `get` request. You should see
    a list of all the items we recently persisted. From this, you can now go on to
    update your API with `put` and `delete` commands, and many others that adhere
    to API standards. As this book concentrates on Swift as a programming language,
    we'll leave that up to you to have a play around with.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过 Xcode 重新启动服务器并调用我们的 `get` 请求。你应该能看到我们最近持久化的所有项目的列表。从现在起，你可以继续使用 `put`
    和 `delete` 命令以及其他符合 API 标准的命令来更新你的 API。由于本书专注于 Swift 作为编程语言，我们将把这个留给你自己去尝试。
- en: How it works...
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'With our API now up and running, let''s dig a little deeper into how we made
    the persistence work. Let''s start by taking a closer look at our `Task.swift`
    class model:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的API现在已经上线并运行，让我们深入探讨一下我们是如何实现持久化的。让我们首先仔细看看我们的`Task.swift`类模型：
- en: '[PRE51]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As you can see, our class now conforms to Model – which is a protocol used
    by the Fluent framework. This allows us to add attributes to our properties so
    we can bind these to fields within our database, such as the `category` property:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的类现在符合Model协议——这是Fluent框架使用的协议。这允许我们向属性添加属性，以便我们可以将这些属性绑定到数据库中的字段，例如`category`属性：
- en: '[PRE52]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Without this, Fluent wouldn't know how to bind this causing a failure in persistence.
    Another added benefit is that our properties are not tied to the naming convention
    of the database; something that's not a problem when starting from scratch, but
    this is potentially helpful when working with legacy systems.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这个，Fluent将不知道如何绑定它，这会导致持久化失败。另一个额外的优点是我们的属性不绑定到数据库的命名约定；当从零开始时这不是问题，但与遗留系统一起工作时这可能很有帮助。
- en: You'll also notice the `schema = "task"` constant we have in there, again another
    part of the inner workings of our binding that allows our Model to be bound only
    to a particular database schema.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到我们那里的`schema = "task"`常量，这又是我们绑定内部工作的一部分，允许我们的模型仅绑定到特定的数据库模式。
- en: 'Go back over to our `TaskControllerAPI()` class and you''ll see that the changes
    we made reference a `.db` property. Let''s take a look at these:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`TaskControllerAPI()`类，你会看到我们做的更改引用了一个`.db`属性。让我们来看看这些：
- en: '[PRE53]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In the preceding code, we decode our data using `content` to bind this to our
    Model `(Task())`. We are now able to perform a `.save` operation on our `task`
    object as this now conforms to **Model** from Fluent.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`content`解码我们的数据，将其绑定到我们的模型`(Task())`。我们现在能够对`task`对象执行`.save`操作，因为现在它符合Fluent的**Model**。
- en: The save is being performed on the `req.db` and then in turn being **.map**(ed)
    – once the operation is complete and successful, we can see that the task is returned
    (which is why we see this in the output window when performing our cURL command).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 保存操作是在`req.db`上执行的，然后依次被**.map**(映射)——一旦操作完成并成功，我们可以看到任务被返回（这就是为什么我们在执行cURL命令时在输出窗口中看到这个）。
- en: 'If you break down the preceding, the syntax makes a little more sense:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你分解前面的内容，语法会更有意义：
- en: '[PRE54]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: For those familiar with the previous way of implementing databases in Vapor,
    you'll certainly appreciate this new and much-improved way of setting up persistence.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉Vapor中之前实现数据库方式的人来说，你肯定会欣赏这种新的、改进后的设置持久化的方式。
- en: See also
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: 'Vapor provides a number of other database providers that can be used instead
    of Postgres:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Vapor提供了一些其他数据库提供程序，可以用作Postgres的替代：
- en: '**MySQL**: [https://github.com/vapor/mysql-provider](https://github.com/vapor/mysql-provider)'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MySQL**: [https://github.com/vapor/mysql-provider](https://github.com/vapor/mysql-provider)'
- en: '**SQLite**: [https://github.com/vapor-community/sqlite-provider](https://github.com/vapor-community/sqlite-provider)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQLite**: [https://github.com/vapor-community/sqlite-provider](https://github.com/vapor-community/sqlite-provider)'
- en: '**Redis**: [https://github.com/vapor/redis-provider](https://github.com/vapor/redis-provider)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Redis**: [https://github.com/vapor/redis-provider](https://github.com/vapor/redis-provider)'
- en: '**Mongo**: [https://github.com/vapor-community/mongo-provider](https://github.com/vapor-community/mongo-provider)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mongo**: [https://github.com/vapor-community/mongo-provider](https://github.com/vapor-community/mongo-provider)'
- en: Hosting your Vapor app on Heroku
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Heroku上托管你的Vapor应用
- en: In the previous recipes in this chapter, we created a REST API that stores and
    retrieves information from a Postgres database. We have our Vapor web server running
    on our local machine and can interact with it over HTTP requests; however, unless
    you plan on making your machine available to the public internet, this is of limited
    use, and we need to find somewhere to host our data and REST interface.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面的示例中，我们创建了一个REST API，该API从Postgres数据库存储和检索信息。我们的Vapor网络服务器在我们的本地机器上运行，并且可以通过HTTP请求与之交互；然而，除非你打算让你的机器对公众互联网开放，否则这用处有限，我们需要找到一个地方来托管我们的数据和REST接口。
- en: At the time of writing, Swift's support on hosting services is the exception
    rather than the norm; however, support is growing. Heroku is a popular hosting
    service that provides dynamic scaling of resources and a really simple deployment
    mechanism. It also has support for Swift and Postgres, so in this recipe, we will
    deploy our REST API to Heroku.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Swift在托管服务上的支持是例外而不是常态；然而，支持正在增长。Heroku是一个流行的托管服务，它提供资源的动态扩展和非常简单的部署机制。它还支持Swift和Postgres，因此在本菜谱中，我们将部署我们的REST
    API到Heroku。
- en: Getting started
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门
- en: Heroku provides simple and scalable infrastructure for your server-side projects.
    Once deployed, instances of your app are called Dymos, and additional Dymos can
    be started to cope with increased load.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku为您的服务器端项目提供简单且可扩展的基础设施。一旦部署，您的应用实例被称为Dymos，并且可以启动额外的Dymos以应对增加的负载。
- en: Deployment to Heroku happens through a remote Git repository. When you are ready
    to deploy your app, simply push the code to Heroku.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用部署到Heroku是通过远程Git仓库完成的。当您准备好部署应用时，只需将代码推送到Heroku。
- en: 'First, visit [http://www.heroku.com](http://www.heroku.com) and sign up for
    a free account. Next, we will install the Heroku CLI (**Command-Line Interface**),
    as this is helpful for interacting with Heroku. Since we installed Homebrew in
    the previous recipes, we can use it to get the Heroku CLI:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，访问 [http://www.heroku.com](http://www.heroku.com) 并注册一个免费账户。接下来，我们将安装Heroku
    CLI（**命令行界面**），因为这有助于与Heroku交互。由于我们在之前的菜谱中安装了Homebrew，我们可以使用它来获取Heroku CLI：
- en: '[PRE55]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, we need to log into the Heroku CLI with the account that we just created.
    Run the `login` command and follow the instructions:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用我们刚刚创建的账户登录到Heroku CLI。运行 `login` 命令并遵循指示：
- en: '[PRE56]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We now have our Heroku CLI set up and ready to use.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了Heroku CLI并准备好使用。
- en: How to do it...
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Since the deployment mechanism for Heroku is Git, we need to create a local
    Git repo.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Heroku的部署机制是Git，我们需要创建一个本地Git仓库。
- en: 'In Terminal, navigate to the folder containing our `TaskAPI` app that we built
    in the previous recipes, and create a local Git repo:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，导航到包含我们之前菜谱中构建的 `TaskAPI` 应用程序的文件夹，并创建一个本地Git仓库：
- en: '[PRE57]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now we need to stage all the files:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要暂存所有文件：
- en: '[PRE58]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, commit all the code:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，提交所有代码：
- en: '[PRE59]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Next, we will set up this Vapor project to use Heroku and follow the instructions:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将设置这个Vapor项目以使用Heroku并遵循以下说明：
- en: '[PRE60]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: You will be asked if you would like a custom name for your app. If you choose
    not to have a custom app name, then a random app name will be assigned in the
    form of two words and a number; for example, `afternoon-bastion-18185`. Therefore,
    the app's URL will be `https://afternoon-bastion-18185.herokuapp.com`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被询问是否希望为您的应用提供一个自定义名称。如果您选择不使用自定义应用名称，则将随机分配一个由两个单词和一个数字组成的应用名称；例如，`afternoon-bastion-18185`。因此，应用的URL将是
    `https://afternoon-bastion-18185.herokuapp.com`。
- en: You will also be asked if you want to provide a custom build pack and a custom
    executable name. You can answer no to both of these.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 您还将被询问是否想要提供自定义构建包和自定义可执行名称。您可以对这两个问题都回答“否”。
- en: 'We need to associate our local Git repository with the Heroku app we just created.
    Run the following command, replacing the final parameter with the name of the
    app that Heroku just created for you:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将我们的本地Git仓库与刚刚创建的Heroku应用关联起来。运行以下命令，将最后的参数替换为Heroku为您创建的应用名称：
- en: '[PRE61]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: To get our database-backed API up and running on our local machine, we ran a
    `Postgresql` service and configured Vapor's connection to it using a configuration
    JSON file in `Config`/`secret`. However, this configuration is specific to our
    local machine, and so we need to start a `PostgreSQL` database service on Heroku
    and configure Vapor to connect to it.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的本地机器上运行数据库支持的API，我们运行了一个 `Postgresql` 服务，并使用 `Config`/`secret` 中的配置JSON文件配置了Vapor的连接。然而，这个配置仅针对我们的本地机器，因此我们需要在Heroku上启动一个
    `PostgreSQL` 数据库服务，并配置Vapor以连接到它。
- en: 'Luckily, the Heroku CLI makes this really easy; just run the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Heroku CLI 使得这个过程变得非常简单；只需运行以下命令：
- en: '[PRE62]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In this command, `hobby-dev` is the pricing plan to use for the database, which
    is free for up to 10,000 database rows.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令中，`hobby-dev` 是用于数据库的定价计划，最多支持10,000条数据库记录，且免费。
- en: This will cause the database to be made available to your Heroku Dymo whenever
    your app is deployed. By running `heroku config`, we can see that an environment
    variable called `DATABASE_URL` is created, containing the connection URL for the
    database.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使得数据库在你部署应用时对 Heroku Dymo 可用。通过运行 `heroku config`，我们可以看到创建了一个名为 `DATABASE_URL`
    的环境变量，其中包含了数据库的连接 URL。
- en: Now, we need to ensure that Vapor knows how to connect to the database when
    it's running on Heroku. To do this, we will add a configuration to `Procfile`,
    which is used by Heroku to set up the environment.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要确保 Vapor 在 Heroku 上运行时知道如何连接到数据库。为此，我们将在 `Procfile` 中添加一个配置，这是 Heroku
    用于设置环境所使用的。
- en: 'In the root of the project, create a file named `Procfile`; open this file
    and add the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的根目录下创建一个名为 `Procfile` 的文件；打开此文件并添加以下内容：
- en: '[PRE63]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This will allow Vapor to use the PostgreSQL database set up on Heroku.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许 Vapor 使用在 Heroku 上设置的 PostgreSQL 数据库。
- en: 'Now, let''s commit the change:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们提交更改：
- en: '[PRE64]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We are now ready to push our code to Heroku, which will then be deployed:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好将代码推送到 Heroku，然后它将被部署：
- en: '[PRE65]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: At the time of writing this book - there was/is an open pull request to fix
    an issue with a missing file `LinuxTests.swift`if Heroku gives you an error performing
    the above push, simply create a blank file called `LinuxTests.swift`and re-commit
    & push again.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时 – 有一个针对缺失文件 `LinuxTests.swift` 问题的公开拉取请求，如果 Heroku 在执行上述推送时给你错误，只需创建一个名为
    `LinuxTests.swift` 的空文件，然后重新提交并再次推送。
- en: 'It may take a while, but eventually, Heroku will report that the code has been
    deployed and will provide the URL for the deployed app, which will look similar
    to this:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 可能需要一段时间，但最终，Heroku 将会报告代码已部署，并提供已部署应用的 URL，其外观将类似于以下这样：
- en: '[PRE66]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: You have a deployed version of our `TaskAPI` running on Heroku. You can rerun
    all the cURL tests from the last recipe, but with the preceding hostname in the
    place of `http://0.0.0.0:8080`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个在 Heroku 上运行的 `TaskAPI` 部署版本。你可以重新运行上一配方中的所有 cURL 测试，但将前面的主机名替换为 `http://0.0.0.0:8080`。
- en: See also
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: What we have built in this chapter is just the tip of the iceberg of what Vapor
    is capable of. Vapor has built-in support for authentication, templating, and
    much more, so check out [http://vapor.codes](http://vapor.codes) for the full
    documentation.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中构建的只是 Vapor 能力的冰山一角。Vapor 内置了对身份验证、模板化等功能的支持，因此请查看 [http://vapor.codes](http://vapor.codes)
    以获取完整的文档。
- en: The team behind Vapor has launched its own hosting service, Vapor Cloud. This
    really simplifies the process of getting your Vapor app online. At the time of
    writing, this service is in open beta; you can find out more and sign up at [https://vapor.cloud](https://vapor.cloud).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Vapor 背后的团队推出了自己的托管服务，Vapor Cloud。这极大地简化了将你的 Vapor 应用上线的过程。在撰写本文时，此服务处于公开测试版；你可以在
    [https://vapor.cloud](https://vapor.cloud) 获取更多信息并注册。
- en: The Swift Package Manager
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift 包管理器
- en: Dependency package management has been around for a while now in software development
    – the ability to add a dependent framework or snippet to your code base without
    the need for any major integration has often been seen as a benefit to many.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖包管理在软件开发中已经存在了一段时间 – 能够在不进行任何重大集成的情况下将依赖框架或代码片段添加到你的代码库中，这通常被视为许多人的好处。
- en: Managers such as NuGet and NPM are widely used and maintained by the community.
    Specifically for iOS development, CocoaPods and Carthage have been the big players;
    that was until the introduction of the **Swift Package Manager** or **SPM** for
    short.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如 NuGet 和 NPM 这样的管理器被广泛使用并由社区维护。特别是对于 iOS 开发，CocoaPods 和 Carthage 一直是主要玩家；直到
    **Swift Package Manager** 或简称 **SPM** 的引入。
- en: Although it's been around much longer than you might think, it was recently
    announced at WWDC 2019 that Xcode 11 would have full integration support for the
    Swift Package Manager.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它存在的时间可能比你想象的要长，但最近在 WWDC 2019 上宣布，Xcode 11 将对 Swift 包管理器提供完整的集成支持。
- en: In this recipe, we are going to learn how to add a dependency to our project
    using the Swift Package Manager.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何使用 Swift 包管理器将依赖项添加到我们的项目中。
- en: Getting started
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门
- en: For this project, we'll continue using our recent Xcode project where we implemented
    Fluent and Postgres – you can follow along in the sample recipe from GitHub or
    alternatively make a copy on disk of your current project and work from that.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将继续使用我们最近实现的 Xcode 项目，其中包含了 Fluent 和 Postgres – 你可以在 GitHub 上的示例配方中跟随操作，或者你也可以在磁盘上创建当前项目的副本并从那里开始工作。
- en: How to do it...
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First, open Xcode and from the file tree, locate the following filename:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开 Xcode 并从文件树中找到以下文件名：
- en: '[PRE67]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Here, you should see the start of the following code:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里，您应该看到以下代码的开始部分：
- en: '[PRE68]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In the preceding code, I've highlighted our main area of interest. Here, we
    currently have a list of existing dependencies – in our case, the Vapor framework
    and two Fluent dependencies.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码中，我已突出显示我们的主要关注区域。在这里，我们目前有一份现有依赖项的列表——在我们的案例中，是 Vapor 框架和两个 Fluent 依赖项。
- en: 'So let''s go ahead and add another one in:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以让我们再添加一个：
- en: '[PRE69]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Give Xcode a moment or so and it should start to download the new dependency.
    Failing that, you can push this along a little by using the following command
    in Terminal:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给 Xcode 一点时间，它应该开始下载新的依赖项。如果失败，您可以使用以下命令在终端中推动这个过程：
- en: '[PRE70]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: If there are any errors with your package file, you'll see them here. Once completed,
    you'll see your new dependency alongside the existing ones in the File Explorer
    to the left of Xcode.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的包文件有任何错误，您将在这里看到它们。完成后，您将在 Xcode 左侧的文件资源管理器中看到您的新依赖项与现有依赖项并列。
- en: Xcode also allows you to add package dependencies via the GUI, from Xcode. Select
    File | Swift Packages to see a list of options. Unfortunately, these are only
    currently supported for `.xcproject` files (which Vapor does not use).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还允许您通过 GUI 从 Xcode 添加包依赖项，选择 File | Swift Packages 查看选项列表。不幸的是，这些选项目前仅支持
    `.xcproject` 文件（Vapor 不使用此类文件）。
- en: How it works...
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'So now we''ve added in our framework, how does SPM work its magic? We''ll start
    by taking a look at the dependency section of our `Packages.swift` file again:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经添加了我们的框架，SPM 是如何施展魔法的呢？我们将再次查看 `Packages.swift` 文件的依赖项部分：
- en: '[PRE71]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: I've highlighted two main areas here from our recent addition – the first is
    the URL. Much like other dependency packages such as Cocoapods and Carthage, SPM
    pulls its code from a (or your) Git repository.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里突出显示了最近添加的两个主要区域——第一个是 URL。与 Cocoapods 和 Carthage 等其他依赖项包类似，SPM 从（或您的）Git
    仓库中拉取代码。
- en: Without going into too many details about how a package is actually made, versioning
    for dependencies is done using tags. In the preceding code, we're looking for
    any version of the package that starts from 1.0.0 (so the latest could be version
    10.2.2, for all we know), but we've made a decision that at the very least, version
    1.0.0 is good enough for us.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入探讨包是如何实际制作的，依赖项的版本控制是通过标签完成的。在先前的代码中，我们正在寻找任何从 1.0.0 版本开始的包版本（所以最新的可能是版本
    10.2.2，我们无从得知），但我们已经决定至少版本 1.0.0 对我们来说已经足够好了。
- en: 'But maybe we want to be more specific. Let''s see how we''d do that:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 但也许我们想要更具体一些。让我们看看我们该如何做到这一点：
- en: '[PRE72]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Here, we're specifying that we only want to use version 1.2.3\. The format of
    the version numbers that we are checking against is what is called semantic versioning.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们指定我们只想使用 1.2.3 版本。我们正在检查的版本号格式被称为语义版本控制。
- en: 'This allows us to add additional conditions to our packages such as `upToNextMajor`
    and `upToNextMinor` from a specific set version. Here is an example:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们向我们的包添加额外的条件，例如从特定版本添加 `upToNextMajor` 和 `upToNextMinor`。以下是一个示例：
- en: '[PRE73]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '`upToNextMajor` will include any version up to version 2.0.0.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`upToNextMajor` 将包括所有版本，直到版本 2.0.0。'
- en: '`upToNextMinor` will include any version up to version 1.3.0 (so 1.2.x basically).'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`upToNextMinor` 将包括所有版本，直到版本 1.3.0（即 1.2.x）。'
- en: More often than not, you won't really need to worry about this, but with a framework
    dependent on other frameworks, sometimes this can really come in handy to keep
    everything nice and tidy in your project.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 更多时候，您实际上并不需要担心这个问题，但当一个框架依赖于其他框架时，有时这确实可以派上用场，以保持项目整洁有序。
- en: There's more...
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Finally, let''s take a look at the remaining code in our `Packages.swift` file
    – let''s start at the top:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看 `Packages.swift` 文件中剩余的代码——让我们从顶部开始：
- en: '[PRE74]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Although this appears to be commented out, it actually plays a big part in our
    packages file. Here, we're setting the version of Swift that our dependencies
    must comply with. So if a dependency being downloaded is built with an older version
    of Swift and is currently unsupported, SPM will let us know about it.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来像是被注释掉了，但实际上它在我们的包文件中起着重要作用。在这里，我们正在设置我们的依赖项必须遵守的 Swift 版本。因此，如果一个正在下载的依赖项是用较旧的
    Swift 版本构建的并且目前不受支持，SPM 将会通知我们。
- en: On the flip side too, if our dependency is newer than our version of Swift,
    this will be handled.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们的依赖项版本比我们的 Swift 版本新，这也会得到处理。
- en: 'Next, let''s take a look at the targets section. At first glance, you might
    feel a little overwhelmed as to what is going on in here, but it is actually straightforward,
    and for those familiar with other dependency management tools, this will be familiar
    ground:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看目标部分。乍一看，你可能会觉得这里发生的事情让你有些不知所措，但实际上它非常简单，对于那些熟悉其他依赖管理工具的人来说，这将是熟悉的领域：
- en: '[PRE75]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In the preceding code, I've highlighted some key areas. The first is the list
    of targets. All we are doing here is identifying one of our targets (in our case
    our **App** target) and adding a list of specific dependencies for that target.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我突出了一些关键区域。第一个是目标列表。我们在这里所做的只是识别我们的一个目标（在我们的例子中是我们的**App**目标）并为该目标添加一个特定的依赖列表。
- en: These names are the actual package names once installed – not the Git URL. These
    are defined outside the targets array on a more global scale for our project.
    Here, we are simply cherry-picking what should be used for what specific target.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这些名称是安装后的实际包名——不是 Git URL。这些在项目中的更全局范围内定义，在目标数组之外。在这里，我们只是挑选出应该用于特定目标的。
- en: The same goes for `swiftSettings` too, a place where we can set Swift-specific
    optimizations for the build when in either release or debug mode (but generally
    we do this for release builds).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于`swiftSettings`也是如此，这是一个我们可以为发布或调试模式设置 Swift 特定优化构建的地方（但通常我们只为发布构建这样做）。
- en: See also
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For more information, refer to the following links:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参阅以下链接：
- en: 'Semantic versioning: [https://semver.org](https://semver.org)'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语义化版本控制：[https://semver.org](https://semver.org)
- en: 'Building for production: [https://github.com/swift-server/guides#building-for-production](https://github.com/swift-server/guides#building-for-production)'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为生产构建：[https://github.com/swift-server/guides#building-for-production](https://github.com/swift-server/guides#building-for-production)
- en: 'CocoaPods: [https://cocoapods.org](https://cocoapods.org)'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CocoaPods：[https://cocoapods.org](https://cocoapods.org)
- en: 'Carthage: [https://github.com/Carthage/Carthage](https://github.com/Carthage/Carthage)'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Carthage：[https://github.com/Carthage/Carthage](https://github.com/Carthage/Carthage)
- en: Real-time communication using WebSockets
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 WebSocket 进行实时通信
- en: Communicating via WebSockets has been around for a long time and plays an integral
    part in server-to-server, server-to-client, and client-to-server communications.
    WebSockets allow open and constant communication between both parties, thus allowing
    data to be sent and received without the need for "polling" for changes.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 WebSocket 进行通信已经存在很长时间，并在服务器到服务器、服务器到客户端和客户端到服务器通信中扮演着至关重要的角色。WebSocket 允许双方进行开放和持续的通信，从而允许在不需要“轮询”变化的情况下发送和接收数据。
- en: A commonplace where you might see WebSockets being used would be a chat window
    – a constant line of communication between each device (usually via a server).
    Think of it as the "telephone line" of the internet (which is actually not too
    far from the truth).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在聊天窗口中看到 WebSocket 的应用，这是一个在各个设备之间（通常通过服务器）保持持续通信的窗口。把它想象成互联网的“电话线”（这实际上并不离真相太远）。
- en: In this section, we are going to take our previously built Vapor project and
    communicate in real time with a companion iOS app.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用之前构建的 Vapor 项目，并与一个配套的 iOS 应用进行实时通信。
- en: Getting started
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门
- en: For this section, you'll need the completed project from our previous section.
    Feel free to continue to work on the sample project found in the Git repository.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，你需要我们上一节完成的项目。请随意继续在 Git 仓库中找到的示例项目上进行工作。
- en: In addition, you'll need the **TaskAPIApp** project.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还需要**TaskAPIApp**项目。
- en: How to do it...
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'First of all, let''s head over to our `Routes.swift` file and add in the following:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们转到我们的`Routes.swift`文件，并添加以下内容：
- en: '[PRE76]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Look familiar? Here, we are ultimately creating an "endpoint" for our WebSocket
    called `"talk-back"`. When successfully connected, all data will be received via
    the `ws` parameter in the function. But how can we intercept this? Well, there
    are a couple of ways actually. Let''s take a look:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来熟悉吗？在这里，我们最终为我们的 WebSocket 创建了一个名为“talk-back”的“端点”。当成功连接时，所有数据将通过函数中的`ws`参数接收。但如何拦截它呢？实际上有几个方法。让我们看看：
- en: '[PRE77]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Our client, when connected to our server via WebSockets, can send a number of
    specific commands, such as sending plain text or sending binary text. For this
    recipe, we'll just be using `onText`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的客户端通过 WebSocket 连接到我们的服务器时，它可以发送一系列特定的命令，例如发送纯文本或发送二进制文本。对于这个配方，我们将只使用`onText`。
- en: 'Add the following code and run your server:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码并运行你的服务器：
- en: '[PRE78]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: So, essentially, what we are doing here is listening for a message from our
    client (any message), but if the message meets our specific condition, we're going
    to send a response straight back.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本质上，我们在这里所做的是监听来自客户端的消息（任何消息），但如果消息符合我们的特定条件，我们将直接发送响应。
- en: Now, from the GitHub repository, fire up the **TaskAPIApp** project in Xcode.
    Here, you'll notice we're using a third-party dependency called Starscream to
    enable our app as a WebSocket client – we could have gone through and built our
    own but that was a little out of scope and unnecessary for this recipe.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从 GitHub 仓库中，在 Xcode 中启动 **TaskAPIApp** 项目。在这里，你会注意到我们正在使用一个名为 Starscream
    的第三方依赖项来使我们的应用成为 WebSocket 客户端——我们本可以自己构建，但这超出了范围，并且对于这个配方来说是不必要的。
- en: 'One thing to note: we used SPM in order to obtain the Starscream dependency
    – take a look in the Xcode project and compare it to our Vapor project to see
    how it matches up!'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个需要注意的事项：我们使用了 SPM 来获取 Starscream 依赖项——看看 Xcode 项目，并与我们的 Vapor 项目进行比较，看看它们是如何匹配的！
- en: 'Okay, with the iOS app loaded, check out the `ViewController.swift` file and
    make sure the localhost URL is correct as per your current setup (it should be
    the same if you are following along):'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，iOS 应用加载后，检查 `ViewController.swift` 文件，确保 localhost URL 与你的当前设置正确（如果你在跟随操作，它应该是相同的）：
- en: '[PRE79]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'If you take a closer look in the `ViewController.swift` file, you''ll see the
    following hooked up to an `IBAction`:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细查看 `ViewController.swift` 文件，你会看到以下内容连接到一个 `IBAction`：
- en: '[PRE80]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: We've got the option to send a String via our WebSocket connection – boom!
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有通过 WebSocket 连接发送 String 的选项——砰！
- en: Launch the project (still making sure your Vapor server is running locally)
    and click the button. What do you see? All being well, you should see the words
    Is it me you are looking for...? appear in the `UILabe``l` – nice!
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 启动项目（同时确保你的 Vapor 服务器在本地上运行）并点击按钮。你看到了什么？如果一切顺利，你应该会看到“你在找的是我吗...？”这些字样出现在 `UILabe``l`
    中——不错！
- en: How it works...
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: WebSockets in Vapor act in a similar way to routes. Just as we said about our
    talk-back endpoint we created that the only difference was that the connection
    was open, the difference here is there have been no additional calls made – our
    server didn't need to rebuild and re-connect a new URL request, so there's no
    additional authorization or authentication. Our client (much like our server)
    was just listening for a response.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vapor 中，WebSocket 的行为与路由类似。正如我们之前所说的，我们创建的回话端点的唯一区别是连接是开放的，这里的区别是没有任何额外的调用——我们的服务器不需要重建和重新连接新的
    URL 请求，因此没有额外的授权或认证。我们的客户端（就像我们的服务器一样）只是在等待响应。
- en: All WebSocket calls are asynchronous – and don't reply in the usual request/response
    pattern that we see with HTTP. However, it is up to you, the client or the server,
    to manage this connection, checking to make sure it is still not alive, and being
    ready to handle the requests at any time.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的 WebSocket 调用都是异步的——并且不会像我们在 HTTP 中看到的那样以通常的请求/响应模式回复。然而，这取决于你，客户端或服务器，来管理这个连接，确保它仍然活跃，并随时准备好处理请求。
- en: There's more...
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We touched earlier on the `onText` and `onBinary` functions available to us
    when receiving a message from our client, but by default, WebSockets constantly
    ping each other to make sure they are still active (or alive). We can monitor
    these requests by intercepting them with the following functions:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到了当从客户端接收消息时，我们可用的 `onText` 和 `onBinary` 函数，但默认情况下，WebSocket 会不断 ping 来确保它们仍然活跃（或存活）。我们可以通过以下函数来监控这些请求：
- en: '[PRE81]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Alternately, we can use our Vapor project to connect to a WebSocket too:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以使用我们的 Vapor 项目来连接 WebSocket：
- en: '[PRE82]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Sending messages whilst connected as a client is performed in the same way
    as we sent a message earlier, either through plain text or binary:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 作为客户端连接时发送消息的方式与之前发送消息的方式相同，无论是通过纯文本还是二进制：
- en: '[PRE83]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'While sending messages is done asynchronously, sometimes we would like to know
    if our message has been sent successfully – we can do this with the use of the
    `eventLoop` promise:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然发送消息是异步进行的，但有时我们想知道我们的消息是否已成功发送——我们可以使用 `eventLoop` 的承诺来实现：
- en: '[PRE84]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'And finally, we have these options to close and handle our open WebSocket connections:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有以下选项来关闭和处理我们的开放 WebSocket 连接：
- en: '[PRE85]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: WebSockets really are a way of opening up your server in terms of real-time
    connectivity to your client. There are usually many things that it can be used
    for, such as dashboard reporting and chat messaging.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets 确实是一种打开服务器，以便与客户端建立实时连接的方式。它通常可以用于许多事情，例如仪表板报告和聊天消息。
- en: See also
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'WebSockets: [https://docs.vapor.codes/4.0/websockets/](https://docs.vapor.codes/4.0/websockets/)'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 'WebSockets: [https://docs.vapor.codes/4.0/websockets/](https://docs.vapor.codes/4.0/websockets/)'
- en: Packaging and sharing models between server and app
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在服务器和应用程序之间打包和共享模型
- en: Server-side Swift is credited for the fact that web application developers can
    harness the power of the Swift programming language first hand. This, along with
    the power of the open source community behind it – even in what is still classed
    as its infancy - means that server-side Swift is already a worthy production-quality
    option.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端 Swift 被认为是网络应用程序开发者能够直接利用 Swift 编程语言的力量。这，加上其背后的开源社区的力量——即使在它仍被视为婴儿期的情况下——意味着服务器端
    Swift 已经是一个值得生产质量的选项。
- en: But what about other advantages, specifically for iOS developers who now build
    their apps using Swift? Other than knowledge of syntax and specific APIs, what
    else can they benefit from?
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 但其他优势又如何呢？特别是对于现在使用 Swift 构建应用程序的 iOS 开发者来说？除了对语法和特定 API 的了解之外，他们还能从中得到什么好处？
- en: As we saw earlier in this chapter, with the integration of the Swift Package
    Manager into Xcode, we can now build out some of our code into a module that we
    can reuse in both our server-side Swift apps and our iOS apps.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面所看到的，随着 Swift 包管理器集成到 Xcode 中，我们现在可以将一些代码构建成一个模块，我们可以在服务器端 Swift 应用程序和
    iOS 应用程序中重用它。
- en: Getting started
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用
- en: For this section, we'll continue to work on our Vapor project and will continue
    to work on a Mac using Xcode.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将继续我们的 Vapor 项目，并继续在 Mac 上使用 Xcode 进行工作。
- en: How to do it...
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: For a moment, let's take a step away from our Vapor app. We'll start by creating
    a new Swift package module. In Xcode, click on **File** | **New** | **Swift Package
    –** call it `TaskModule` and click Save. You should now be presented with a brand-new
    project.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时从我们的 Vapor 应用程序中退一步。我们将首先创建一个新的 Swift 包模块。在 Xcode 中，点击 **文件** | **新建**
    | **Swift 包**——命名为 `TaskModule` 并点击保存。你现在应该会看到一个全新的项目。
- en: 'If you take a look at File Explorer, you''ll see some familiar files, such
    as `Packages.swift`. Our main concern is the files that live inside the Sources
    folder – here is where your files and classes will live and will grow as part
    of the module you want to use:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看文件资源管理器，你会看到一些熟悉的文件，例如 `Packages.swift`。我们主要关注位于 Sources 文件夹中的文件——这里将存放你的文件和类，并将作为你想要使用的模块的一部分而增长：
- en: '![](img/05cee1ff-cdd9-453a-8d40-c311d61f65de.png)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![](img/05cee1ff-cdd9-453a-8d40-c311d61f65de.png)'
- en: Figure 8.3 – Sources folder
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – Sources 文件夹
- en: Let's start by creating a new file called `TaskViewModel.swift` – this file
    will be a view model to the model we created in our Vapor project.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个名为 `TaskViewModel.swift` 的新文件——这个文件将是我们在 Vapor 项目中创建的模型的一个视图模型。
- en: A view model is basically a model that only houses data based on what is required
    to render a particular view, for example, a response model from a server might
    have 20 properties all containing information such as date timestamps, created
    by, and so on, but our rendered view may only be interested in a handful of that
    information or may want to manipulate or compute some of the data into one single
    property.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 视图模型基本上是一个只包含用于渲染特定视图所需数据的模型，例如，来自服务器的响应模型可能有 20 个属性，包含诸如日期时间戳、创建者等信息，但我们的渲染视图可能只对其中的一小部分信息感兴趣，或者可能想要将一些数据操作或计算成一个单一的属性。
- en: 'Add the following code:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE86]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In the preceding code, we are building a very basic view model, an enum class
    to bind our category to a 1-1 match on our title property, and a computed property
    for an image URL.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们构建了一个非常基本的视图模型，一个枚举类，将我们的类别绑定到标题属性的 1-1 匹配，以及一个用于图像 URL 的计算属性。
- en: As it stands, that code can be used in either our server-side Swift project
    or an iOS app – but how do we get it to do both? Well, easy! As we've created
    this as a Swift package, we can just import it as a Swift package . Close this
    project from Xcode (important) and head on over to `Packages.swift` in your Vapor
    app.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这段代码可以用于我们的服务器端 Swift 项目或 iOS 应用程序——但我们如何让它两者都能做呢？很简单！因为我们将其创建为一个 Swift 包，我们可以直接将其作为
    Swift 包导入。请从 Xcode 中关闭此项目（非常重要）并转到你的 Vapor 应用程序中的 `Packages.swift`。
- en: 'Add the following highlighted changes. Note that the local path must be the
    one on your machine – this needs to point to the directory where your `Packages.swift`
    file lives:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下突出显示的更改。注意，本地路径必须是你的机器上的路径——这需要指向你的 `Packages.swift` 文件所在的目录：
- en: '[PRE87]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Here, we're doing just as we did previously – adding in our package and then
    referencing a module name to the package for our specific target.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们做的就是像之前一样——添加我们的包，然后为我们的特定目标引用包中的模块名称。
- en: Give Xcode a moment to pick up this change and, as if by magic, you'll see our
    recently created module inside our dependency tree. Let's go ahead and try and
    use it.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 给Xcode一点时间来获取这个更改，就像魔法一样，你将看到我们最近创建的模块在依赖树中。让我们继续尝试使用它。
- en: For now, let's add this into our `TaskControllerAPI()` file as it is in here
    that we find bind our original **Task** model from our response.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，让我们将这个内容添加到我们的 `TaskControllerAPI()` 文件中，因为正是在这里我们找到了从响应中绑定我们的原始 **Task**
    模型。
- en: 'We''ll start by importing our Module:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始导入我们的模块：
- en: '[PRE88]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'All being well, this should resolve nicely. Now let''s try and access our view
    model:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，这应该可以很好地解决。现在让我们尝试访问我们的视图模型：
- en: '[PRE89]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'And it really is as simple as that. Let''s take a look at this from the other
    side now and see how we can use this same module in our iOS app:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 真的是这样简单。现在让我们从另一个角度来看这个问题，看看我们如何在iOS应用程序中使用这个相同的模块：
- en: 'First, we need to make sure that our `TaskModule` folder is initialized as
    a Git repo and there is an initial commit performed – I''ll explain why shortly,
    but for now, just simply perform the following commands in Terminal to initialize
    a repository for the project:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要确保我们的 `TaskModule` 文件夹被初始化为一个Git仓库，并且执行了一个初始提交——我很快会解释原因，但现在是简单地执行以下命令在终端中为项目初始化一个仓库：
- en: '[PRE90]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Now open our existing project, `TaskAPIApp`, in Xcode and select **File** |
    **Swift** **Package** | **Add Package Dependency**.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开我们的现有项目，`TaskAPIApp`，在Xcode中，选择 **文件** | **Swift** **包** | **添加包依赖**。
- en: 'You''ll be presented with a GUI asking for the URL for a Git repository. As
    ours is currently local, we need to give it in the following format:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到一个GUI，要求输入Git仓库的URL。由于我们目前是本地的，我们需要以下格式提供：
- en: '[PRE91]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Xcode requires an active Git repository in order to pull a dependency – so
    we''ve just created one locally, as opposed to remotely. Xcode is happy and will
    allow us to continue:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode需要一个活动的Git仓库来拉取依赖项——所以我们已经在本地上创建了一个，而不是在远程。Xcode很高兴，并允许我们继续：
- en: '![](img/d1f46004-0502-416e-abe3-40c38b64f0dc.png)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1f46004-0502-416e-abe3-40c38b64f0dc.png)'
- en: Figure 8.4 – Choose a package repository
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 - 选择包仓库
- en: 'The next screen should now look like this:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个屏幕现在应该看起来像这样：
- en: '![](img/6db05d2b-d16a-4a36-bb36-1e126ae45fbd.png)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6db05d2b-d16a-4a36-bb36-1e126ae45fbd.png)'
- en: Figure 8.5 – Choose the package option
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 - 选择包选项
- en: Specify a **Branch** and enter `master` and click **Next**. All being well,
    Xcode should be ready to import your dependency – click Finish.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 指定一个 **分支** 并输入 `master`，然后点击 **下一步**。如果一切顺利，Xcode应该准备好导入你的依赖项——点击完成。
- en: Go back over to your Xcode project and you'll now see `TaskModule` successfully
    imported into your project. Let's make sure this is all working as expected. Head
    on over to your `ViewControler.swift` file and let's try and use our view model.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到你的Xcode项目，你现在将看到 `TaskModule` 成功导入到你的项目中。让我们确保一切按预期工作。前往你的 `ViewControler.swift`
    文件，让我们尝试使用我们的视图模型。
- en: 'We''ll start by importing our `TaskModule`:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始导入我们的 `TaskModule`：
- en: '[PRE92]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'And now we should be able to access our view model perfectly from anywhere
    within our iOS code base:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该能够从iOS代码库的任何地方完美地访问我们的视图模型：
- en: '[PRE93]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Wonderful – we've now successfully created and reused our view model in both
    our iOS and server-side Swift project.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了——我们现在已经在iOS和服务器端Swift项目中成功创建并重用了我们的视图模型。
- en: How it works...
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The beauty of being able to use our code in both server-side Swift and iOS
    projects doesn''t have to stop at things like view models; specific computed logic
    can sit in here too, but you just have to be aware of a couple of things: remember
    your server-side Swift project is 99% likely to be running on a Linux server,
    so frameworks such as UIKit won''t be available for use; however, this works both
    ways too.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在我们的服务器端Swift和iOS项目中使用我们的代码的美妙之处并不仅限于视图模型；特定的计算逻辑也可以放在这里，但你必须注意几件事：记住你的服务器端Swift项目有99%的可能性是在Linux服务器上运行的，所以像UIKit这样的框架将不可用；然而，这也同样适用。
- en: Our `Codable` equivalent `Content` on Vapor which won't be available in our
    iOS project (as it simply just isn't needed there), so think carefully about how
    you want to split and share your logic. Take time to understand your requirements
    and separation of concerns when developing your application.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vapor 中，我们的 `Codable` 等价物 `Content` 在我们的 iOS 项目中不可用（因为它在那里根本不需要），所以仔细考虑你想要如何分割和共享你的逻辑。花时间了解你的需求以及开发应用程序时的关注点分离。
- en: 'That aside, there are ways to target specific operating systems that our apps
    could be running on. Let''s have a look at how we would achieve this:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，还有方法可以针对特定的操作系统进行目标定位，我们的应用程序可能在这些操作系统上运行。让我们看看我们如何实现这一点：
- en: '[PRE94]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'If you need to be a bit more specific, you can identify operating systems with
    the following:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更加具体一些，你可以使用以下方式来识别操作系统：
- en: '[PRE95]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Again, if you're running your server-side Swift project on macOS, you'll be
    fine – but you're not really future-proofing your code as you may find at some
    point in the future, it's going to be more cost-effective and versatile to run
    your app on a Linux box.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，如果你在 macOS 上运行你的服务器端 Swift 项目，那么你没问题——但你并没有真正为你的代码提供未来保障，因为你可能会在未来某个时刻发现，在
    Linux 服务器上运行你的应用程序将更加经济高效且灵活。
- en: Looking a little deeper into how the Swift Package Manager works is not as complex
    as you might think – although, I may add, it has exceptional convenience and power.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 深入了解 Swift 包管理器的工作原理并不像你想象的那么复杂——尽管，我可能要补充一点，它具有非凡的便利性和功能。
- en: For those familiar with workspaces in Xcode, this follows a not too dissimilar
    pattern – essentially, your module is a link to the project we created earlier.
    The version of the code that is pulled into your project is defined by the `version
    number`, `branch`, or even `commit` we specify.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉 Xcode 中的工作区的人来说，这遵循了一个不太不同的模式——本质上，你的模块是我们之前创建的项目的一个链接。被拉入你项目的代码版本由我们指定的`版本号`、`分支`甚至`提交`来定义。
- en: There's more...
  id: totrans-433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Creating a package to use internally is one thing, but distributing it to others
    – either within your organization or the community – is another.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个用于内部使用的包是一回事，但将其分发给他人——无论是在你的组织内部还是社区中——则是另一回事。
- en: This is where hosting your package in a remote Git repository comes in handy.
    This not only allows you to version-control the changes in your package independently,
    but you can choose to administer these with a private repository, allowing for
    controlled internal use.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么将你的包托管在远程 Git 仓库中非常有用。这不仅允许你独立地对包中的更改进行版本控制，而且你可以选择使用私有仓库来管理这些更改，从而实现受控的内部使用。
