<html><head></head><body>
		<div><h1 id="_idParaDest-238"><em class="italic"><a id="_idTextAnchor494"/>Chapter 16</em>: Creating Your First Widget</h1>
			<p>With iOS 14, Apple introduced WidgetKit. Users are now able to use widgets on their home screens. By displaying small amounts of useful information on the home screen, widgets provide a key functionality to users that was long-awaited. Some examples are checking stock market prices, weather or traffic conditions, the next meeting on your calendar, and so on with just a glance at the home screen. The use cases are limitless!</p>
			<p>In this chapter, you will learn about the basic foundations of WidgetKit, as well as the key aspects of widget design and their limitations. Then, we will build a widget from scratch. Starting with a very simple, small-sized widget, we will extend its capabilities by creating new sizes, network calls, dynamic configurations, placeholder views, and much more! We will discuss all these topics in the following sections:</p>
			<ul>
				<li>Introducing widgets and WidgetKit</li>
				<li>Developing your first widget</li>
			</ul>
			<p>By the end of this chapter, you will be able to create your own widgets to enable your apps to provide a unique new feature so that users will download your app and engage with it much more.</p>
			<h1 id="_idParaDest-239"><a id="_idTextAnchor495"/>Technical requirements</h1>
			<p>The code bundle for this chapter includes a starter project called <code>CryptoWidget_1_small_start</code> and subsequent parts. You can find them in the code bundle repository:</p>
			<p><a href="https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition">https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition</a></p>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor496"/>Introducing widgets and WidgetKit</h1>
			<p>In this section, we are<a id="_idIndexMarker819"/> going to learn about the basics of WidgetKit and the options and guidelines for<a id="_idIndexMarker820"/> widgets in iOS 14.</p>
			<p>Users and developers have been requesting a particular feature for years: they all wanted to have widgets on their home screen. Widgets allow users to configure, personalize, and consume little pieces of relevant data from their home screen. They also enable developers to offer users glanceable content and create added value to their apps. </p>
			<p>Here is a preview of what a <strong class="bold">widget</strong> (in this case, the Calendar and Reminders widgets) looks like on the home<a id="_idIndexMarker821"/> screen of the iPhone:</p>
			<div><div><img src="img/Figure_16.01_B14717.jpg" alt="Figure 16.1 – iOS home screen with widgets&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.1 – iOS home screen with widgets</p>
			<p>This is now possible on iOS 14 and macOS 11 and later. Developers can create widgets across iOS, iPadOS, and macOS<a id="_idIndexMarker822"/> using <strong class="bold">WidgetKit</strong> and the new <strong class="bold">widget API</strong> for<a id="_idIndexMarker823"/> SwiftUI.</p>
			<p><strong class="bold">Smart Stack</strong> on iOS 14<a id="_idIndexMarker824"/> contains a set of different widgets, including ones that the user opens frequently. If the <a id="_idIndexMarker825"/>user enables <strong class="bold">Smart Rotate</strong>, Siri can highlight relevant widgets within custom stacks.</p>
			<p class="callout-heading">Widgets created on iOS 13 and earlier</p>
			<p class="callout">Widgets created before iOS 14 can't be placed on the home screen, but they are still available on the Today view and in the macOS Notification Center.</p>
			<p>After this intro to the new widget feature, let's see what options we have when building a widget and what the design guidelines from Apple are.</p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor497"/>Widget options</h2>
			<p>Users can place widgets on the home screen or the Today view on iOS, the Today view on iPad, or the Notification <a id="_idIndexMarker826"/>Center on macOS. </p>
			<p>Widgets come in three sizes: small, medium, and large. Each size should have a different purpose; a bigger version of a widget should not just be the same as the small one but with bigger font and images. The idea behind having different sizes for a widget is that the bigger the size, the more information it should contain. For example, a weather widget will provide just the current temperature in the small-sized version, but it will also include the weekly forecast in the medium-sized one.</p>
			<p>Users can arrange widgets on different parts of their screen, and even create stacks of widgets to group them up.</p>
			<p>In order to develop a widget, developers need to create a new extension for their app: a <strong class="bold">widget extension</strong>. They can<a id="_idIndexMarker827"/> configure the widget with a timeline provider. A timeline provider updates the widget information when needed.</p>
			<p>Suppose a widget needs some configuration (for example, selecting a default city in a weather app, or multiple cities to display in a large-sized weather widget). In that case, developers should add a custom Siri intent to the widget extension. Creating a custom Siri intent automatically provides the widget with a customization interface for the user.</p>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor498"/>Widget guidelines</h2>
			<p>When creating a<a id="_idIndexMarker828"/> widget for iOS 14 or macOS 11, take into account the following design guidelines: </p>
			<ul>
				<li>Focus your widget on the main feature of your app. For example, if your app is about the stock market, your widget could display the user portfolio's total value.  </li>
				<li>Each widget size should display a different amount of information. If your cycling tracker widget displays the current calories burned today in the small size, it can also display the week's calories per day in the medium size, and add extra info such as the number of km/miles traveled on the big size.</li>
				<li>Prefer dynamic information that changes during the day to fixed information; it will make your widget more appealing to the user.</li>
				<li>Prefer simple widgets with fewer configuration options to the opposite.</li>
				<li>Widgets offer tap target and detection, letting the user select and tap on them to open detailed information in the app. Small-sized widgets support a single tap target; medium- and big-sized widgets support multiple targets. Try to keep it simple.</li>
				<li>Support dark mode. Also consider using SF Pro as the font and SF Symbols if needed.</li>
			</ul>
			<p>In this section, we learned about the new widget feature and WidgetKit. We covered the different options available and the design guidelines when building a widget. In the next section, we will start building a simple widget from scratch, and we will add more features step by step.</p>
			<h1 id="_idParaDest-243"><a id="_idTextAnchor499"/>Developing your first widget</h1>
			<p>In this section, we will use <a id="_idIndexMarker829"/>an existing app to create a widget on top of it step by step.</p>
			<p>The app that we will work on is a crypto ticker, in which the user can check the latest prices of different cryptocurrencies. We will create a widget that will allow users to glance at crypto prices from their home screen, so they don't have to open the app itself. </p>
			<p>Go ahead and open the project named <code>CryptoWidget_start</code> from the code bundle of this chapter. This is the base project on top of which we will build our widget. Before jumping into the task, let's do a quick review of the base project itself. </p>
			<p>Build and launch the project. The app displays a list of cryptocurrencies' prices:</p>
			<div><div><img src="img/Figure_16.02_B14717.jpg" alt="Figure 16.2 – Base app&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.2 – Base app</p>
			<p>You can also go into a detailed view of each coin, but just for demo purposes, it doesn't contain additional info. As we are going to work with an existing code base, let's highlight some key points before modifying it:</p>
			<ul>
				<li>The project is structured into three groups of files (apart from the default-generated files and app delegates): <code>Views</code>, <code>Model</code>, and <code>Network</code>.</li>
				<li>The <code>Views</code> folder contains the <code>UIView</code> files of the project. The views have been created using SwiftUI. SwiftUI is the recommended way to go when building widgets with WidgetKit. Don't worry if you are not familiar with SwiftUI; we will only use basic views in this project.</li>
				<li>Inside the <code>Network</code> folder, we<a id="_idIndexMarker830"/> have a class named <code>DataManager.swift</code>. This class contains the <code>getData()</code> method, which is responsible for fetching the crypto prices from the API of CoinMarketCap. You can create a free developer account on their website to get up-to-date prices. Otherwise, the demo app uses a demo key that gives us historical prices for the cryptos that we are using. If you create your own account, you just need to substitute the value of this key with your own key: <code>let apiKeyValue = "b54bcf4d-1bca-4e8e-9a24-22ff2c3d462c"</code>.</li>
				<li>The <code>Model</code> folder contains basic structs to work with the <code>getData()</code> method results: <code>Coin</code> and <code>CoinList</code>. These structs will contain information about the crypto symbols and prices from the API.</li>
			</ul>
			<p>Now, let's take a look at the main view of the project, located in the <code>ContentView.swift</code> file inside the <code>Views</code> folder. The <code>ContentView</code> struct contains <code>@ObservedObject var dataManager = DataManager()</code>. The <code>@ObservedObject</code> tag indicates that this SwiftUI view will observe changes in the <code>dataManager</code> struct, and it will refresh/react to them. Remember that <code>dataManager</code> is the class that we are using to retrieve the crypto data from the network, so it makes sense that our main view is observing any changes. Check the body of <code>ContentView</code>:</p>
			<pre>var body: some View {
  NavigationView {
    if <strong class="bold">dataManager.loading</strong> {
      Text("Loading...")
    } else {
      CoinListView(data: <strong class="bold">dataManager.coins.data</strong>)
    }
  }
}</pre>
			<p>The view will display a simple <code>Loading…</code> text while <code>dataManager</code> is in the loading state, and it will display <code>CoinListView</code> when <code>dataManager</code> finishes loading and contains some data. Simple! Now, if you check the implementation of <code>CoinListView.swift</code>, you will see that it is a simple list<a id="_idIndexMarker831"/> displaying the information for every coin that it receives as input:</p>
			<pre>var body: some View {
  VStack {
    <strong class="bold">ForEach</strong>(<strong class="bold">data</strong>, id: \.symbol){ coin in
      <strong class="bold">CoinRow</strong>(coin: coin)
    }
  }
}</pre>
			<p>Nothing too fancy for now! We have, so far, <code>dataManager</code>, which calls <code>getData()</code> to fetch coin information from an API, and <code>ContentView</code>, which displays <code>Loading…</code> text while the data is being called, and displays a list with coin details when the coin's information has been retrieved. Everything was done with a few classes and a few lines of code… that is the power of SwiftUI! Now that we have a clear view of the base project, let's jump into creating a widget extension to start building our awesome crypto coin widget!</p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor500"/>Creating a widget extension</h2>
			<p>The first step to add a widget to <a id="_idIndexMarker832"/>an app is to create a widget extension. Creating a widget extension will provide us with a default implementation of the widget protocol, which will help us to get the basic pieces ready.</p>
			<p>Before creating the extension, let's review the parts of a widget extension displayed in the following diagram: </p>
			<div><div><img src="img/Figure_16.03_B14717.jpg" alt="Figure 16.3 – Widget building blocks&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.3 – Widget building blocks</p>
			<p>As you can see in the preceding diagram, the following are descriptions of the building blocks of a widget extension:</p>
			<ul>
				<li>If the widget is configurable by the user, it will need a custom Siri intent configuration definition. For example, a widget that displays stocks can ask the user for a configuration to choose what stocks to display.</li>
				<li>A provider is<a id="_idIndexMarker833"/> needed that will provide the data to display on the widget. The provider can generate placeholder data (that is, show when the user is browsing the widget gallery or loading), a timeline (to represent data over time), and a snapshot (the units that compose a timeline).</li>
				<li>A SwiftUI view to display the data is needed.</li>
			</ul>
			<p>When creating a widget target, Xcode will autogenerate placeholders for all these classes. Let's do it now; follow these steps:</p>
			<ol>
				<li>In the project named <code>CryptoWidget_start</code>, go to <strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">Target</strong> |<strong class="bold"> Widget Extension</strong>.</li>
				<li>You can use <code>CryptoWidgetExtension</code> as the product name a<a id="_idTextAnchor501"/><a id="_idTextAnchor502"/>nd check the <strong class="bold">Include Configuration Intent</strong> option:<div><img src="img/Figure_16.04_B14717.jpg" alt="Figure 16.4 – Widget extension options&#13;&#10;"/></div><p class="figure-caption">Figure 16.4 – Widget extension options</p></li>
				<li>Click <strong class="bold">Activate</strong> on the following popup.</li>
			</ol>
			<p>If you have followed the<a id="_idIndexMarker834"/> preceding steps, your project should now contain a new target with the following folder structure:</p>
			<div><div><img src="img/Figure_16.05_B14717.jpg" alt="Figure 16.5 – Widget target structure&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.5 – Widget target structure</p>
			<p>When creating the widget extension, Xcode has autogenerated two important files: <code>CryptoWidgetExtension.swift</code> and <code>CryptoWidgetExtension.intentdefinition</code>. Let's focus for now on <code>CryptoWidgetExtension.swift</code>. Open it and let's take a look. Check the following piece of code:</p>
			<pre><strong class="bold">@main</strong>
struct CryptoWidgetExtension: Widget {
    let kind: String = "CryptoWidgetExtension"
    var body: some WidgetConfiguration {
        <strong class="bold">IntentConfiguration</strong>(kind: kind, intent: ConfigurationIntent.self, provider: Provider()) { entry in
            <strong class="bold">CryptoWidgetExtensionEntryView(entry: entry)</strong>
        }
        .configurationDisplayName("My Widge<a id="_idTextAnchor503"/><a id="_idTextAnchor504"/>t")
        .description("This is an example widget.")
    }
}</pre>
			<p>As you can see, and as<a id="_idIndexMarker835"/> discussed before, we have the basic building pieces of the widget:</p>
			<ul>
				<li>An intent configuration, to allow the user to configure the widget, named <code>IntentConfiguration</code></li>
				<li>A provider to provide data to the widget: <code>Provider()</code></li>
				<li>A view to display the data: <code>CryptoWidgetExtensionEntryView</code></li>
			</ul>
			<p>The <code>CryptoWidgetExtension</code> struct is tagged as <code>@main</code>, meaning that is the entry point of the widget. The body is formed of <code>IntentConfiguration</code> and <code>CryptoWidgetExtensionEntryView</code>, which receives an <code>entry</code> instance as input. </p>
			<p>In the same file, we also have the autogenerated definitions for the required methods of <code>Provider</code> (<code>placeholder()</code>, <code>getSnapshot()</code>, and <code>getTimeline()</code>):</p>
			<ul>
				<li>The <code>placeholder(…)</code> method will provide the widget with the initial view the first time the widget is rendered. The placeholder will give the user a general idea of what the widget will look like.</li>
				<li>The <code>getSnapshot(…in context…)</code> method will provide the widget with a value (entry) to display when the widget needs to be shown in transient situations. The <code>isPreview</code> property from <code>context</code> indicates that the widget is being shown in the widget gallery. In those cases, the snapshot has to be fast: those scenarios may require the developer to use dummy data and avoid network calls to return the snapshot as fast as possible.</li>
				<li>The <code>getTimeline(…)</code> method <a id="_idIndexMarker836"/>will provide the widget with an array of values to display over the current time (and optionally in the future). </li>
			</ul>
			<p>There is another important modifier that we will use later. Just after <code>.description("This is an example widget.")</code>, add the fol<a id="_idTextAnchor505"/><a id="_idTextAnchor506"/>lowing line:</p>
			<pre> .supportedFamilies([.systemSmall])</pre>
			<p>This is where we configure the different sizes available for this widget. Later on in the chapter, we will add the medium-sized type.</p>
			<p>Now, let's take a look at another part of the code. At the end of the file, you will find the <code>Preview</code> section:</p>
			<pre>struct CryptoWidgetExtension_Previews: PreviewProvider {
    static var previews: some View {
        CryptoWidgetExtensionEntryView(entry: SimpleEntry(date: Date(), configuration: ConfigurationIntent()))
            .previewContext(WidgetPreviewContext(family: .systemSmall))
    }
}</pre>
			<p>This part of the code will allow us to display a preview with SwiftUI of what our widget will look like while developing it. If you launch the preview, you will see that right now, it just displays the time (go to <strong class="bold">Editor</strong> | <strong class="bold">Canvas</strong> on the top menu of Xcode if you don't see the preview tab):</p>
			<div><div><img src="img/Figure_16.06_B14717.jpg" alt="Figure 16.6 – Editor canvas preview&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.6 – Editor canvas preview</p>
			<p>That is great! We can code and <a id="_idIndexMarker837"/>see the final results in real time. Let's analyze a bit how we are getting this kind of widget view with the time on it. See how we are using <code>CryptoWidgetExtensionEntryView</code> as the main view of the preview?</p>
			<pre><strong class="bold">CryptoWidgetExtensionEntryView</strong>(entry: <strong class="bold">SimpleEntry</strong>(date: Date(), configuration: <strong class="bold">ConfigurationIntent</strong>()))
    .previewContext(<strong class="bold">WidgetPreviewContext</strong>(family: .systemSmall))</pre>
			<p>This view is receiving <code>SimpleEntry</code> (with just the date) and a plain, empty <code>ConfigurationIntent</code>. </p>
			<p>Then, we are applying a modifier to the view by creating <code>previewContext</code> and assigning <code>WidgetPreviewContext</code> as <code>.systemSmall</code>. By doing this, we are rendering the view inside the preview of a small widget!</p>
			<p>What is <code>CryptoWidgetExtensionEntryView</code> doing with <code>SimpleEntry</code>? Let's check the implementation:</p>
			<pre>struct CryptoWidgetExtensionEntryView : View {
    var entry: Provider.Entry
    var body: some View {
        <strong class="bold">Text(entry.date, style: .time)</strong>
    }
}</pre>
			<p>Well, it is just displaying text with the date! So, in summary, the preview is doing the following:</p>
			<ul>
				<li>Using <code>SimpleEntry</code> as the data input for the widget</li>
				<li>Using <code>CryptoWidgetExtensionEntryView</code> as the main view to display that data entry</li>
				<li>Using the <code>WidgetPreviewContext</code> modifier to use a small widget as the canvas for the preview</li>
			</ul>
			<p>With all these concepts in <a id="_idIndexMarker838"/>mind, it is time to start creating our own widget. Let's modify the preceding structs to display the value of Bitcoin instead of a simple date.</p>
			<p>First, if we want to display a coin's value (Bitcoin, for example) in the widget, we need an entry to contain that information. Let's add an array of <code>Coin</code> to the properties of the <code>SimpleEntry</code> struct:</p>
			<pre>struct SimpleEntry: TimelineEntry {
  let date: Date
  let configuration: ConfigurationIntent
<strong class="bold">  let coins: [Coin]</strong>
}</pre>
			<p>By storing the <code>coins</code> property, the entry can deliver this information to the widget's view later on. If you try to build the project, you will get an error like this:</p>
			<pre>Cannot find type 'Coin' in scope</pre>
			<p>This happens because the <code>Coin</code> file is only part of the main app target. We need to select <code>Coin</code> and all the other files under the <code>Views</code>, <code>Network</code>, and <code>Model</code> folders and add them to the widget's target:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_16.07_B14717.jpg" alt="Figure 16.7 – Sharing files from the main app to the widget target&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.7 – Sharing files from the main app to the widget target</p>
			<p>After adding the files of the previous<a id="_idIndexMarker839"/> screenshot to the widget target, you will get new, different errors when compiling. The main reason for all these errors is that you have added a new property to <code>Coin</code>, and now there are parts in the <code>Provider</code> struct where we are initializing a <code>Coin</code> instance without that new property. To fix it, we will add some dummy data (for now) into the <code>Provider</code> implementation to pass it as the coins when creating any <code>SimpleEntry</code> instance inside <code>Provider</code>. Later on, we will use real data from the API instead of that dummy one.</p>
			<p>Add the following code inside the <code>Provider</code> struct. Its first line will appear as follows:</p>
			<pre>struct Provider: IntentTimelineProvider {
    <strong class="bold">let coins = [Coin(id: 1, name: "Bitcoin", symbol: "BTC", quote: Quote(USD: QuoteData(price: 20000))), Coin(id: 1, name: "Litecoin", symbol: "LTC", quote: Quote(USD: QuoteData(price: 200)))]</strong>
//…</pre>
			<p>We are creating some fake data to generate a <code>Coin</code> array, containing some values for Bitcoin and Litecoin. Now, we can use this <code>coins</code> value to inject it into the three places in which we are creating <code>SimpleEntry</code> inside the <code>Provider</code> class:</p>
			<ul>
				<li>First, we inject it inside the <code>placeholder(…)</code> method:<pre>SimpleEntry(date: Date(), configuration: ConfigurationIntent(), coins: coins)</pre></li>
				<li>Then, we inject it inside the <code>getSnapshot(…)</code> method:<pre>let entry = SimpleEntry(date: Date(), configuration: configuration, coins: coins)</pre></li>
				<li>We then inject it inside the <code>getTimeline(…)</code> method:<pre>let entry = SimpleEntry(date: entryDate, configuration: configuration, coins: coins)</pre></li>
			</ul>
			<p>Finally, you may have the exact<a id="_idIndexMarker840"/> same problem inside the <code>CryptoWidgetExtension_Previews</code> struct. The <code>previews</code> property is using <code>SimpleEntry</code> to display it in the widget. You need to add the <code>coins</code> property again. Just use this code:</p>
			<pre>CryptoWidgetExtensionEntryView(entry: SimpleEntry(date: Date(), configuration: ConfigurationIntent(), coins: [Coin(id: 1, name: "Bitcoin", symbol: "BTC", quote: Quote(USD: QuoteData(price: 20000))), Coin(id: 1, name: "Litecoin", symbol: "LTC", quote: Quote(USD: QuoteData(price: 200)))]))
          .previewContext(WidgetPreviewContext(family: .systemSmall))</pre>
			<p>Great! The project should compile properly now. Try to render the preview to see what happens. Oops! You should still see the date/time in the little widget and no coin values! Why? We are passing the coin values into the entry to the widget, but the view of the widget is not using it yet. Check the current implementation:</p>
			<pre>struct CryptoWidgetExtensionEntryView : View {
  var <strong class="bold">entry: Provider.Entry</strong>
  var body: some View {
      <strong class="bold">Text(entry.date</strong>, style: .time)
  }
}</pre>
			<p>We have <code>entry</code> with coins information inside, but we are only displaying the date. We need to modify the view to show the new information! In the main app, we have a view that, given a coin, displays its name and price. Let's use it. Change the <code>CryptoWidgetExtensionEntryView</code> implementation for this (changes are highlighted):</p>
			<pre>struct CryptoWidgetExtensionEntryView : View {
  var entry: Provider.Entry
  var body: some View {
    <strong class="bold">CoinDetail(coin: entry.coins[0])</strong>
  }
}</pre>
			<p>Now, build and refresh the<a id="_idIndexMarker841"/> preview. Great! You should see the price and name of Bitcoin on the widget, as in the following screenshot:</p>
			<div><div><img src="img/Figure_16.08_B14717.jpg" alt="Figure 16.8 – Widget showing the Bitcoin price&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.8 – Widget showing the Bitcoin price</p>
			<p>If you want to try it in the simulator, just launch the widget target. Remember that you should have launched (at least once) the main app first.</p>
			<p>In this section, we learned how to add a widget extension to an app. Then, we explored the main components and the relationship between them: the provider, the entries, the view of the widget, and the preview system of SwiftUI. Finally, we modified all these components to adapt them to our needs and created our first small widget. In the next section, we will learn how to add a placeholder preview and how to add a medium-sized widget too!</p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor507"/>Implementing multiple-size widgets</h2>
			<p>In the previous section, we <a id="_idIndexMarker842"/>added a widget target to a project and created the widget's first view, the small-sized one. Let's do some modifications now in order to develop a medium-sized widget, and also a placeholder preview for the widget.</p>
			<p>If you didn't follow along with the previous section, you can use the project named <code>CryptoWidget_1_small_widget</code>. Let's start by adding a placeholder preview to the project. When rendering your widget for the first time, WidgetKit will render it as a placeholder. In order to render <a id="_idIndexMarker843"/>data, it will ask the provider for an entry using the following method:</p>
			<pre>func placeholder(in context: Context) -&gt; SimpleEntry </pre>
			<p>But in order to be able to see how it would appear while we develop it, we can create a preview of it using SwiftUI. Go ahead and add the following struct to the <code>CryptoWidgetExte<a id="_idTextAnchor508"/><a id="_idTextAnchor509"/>nsion.swift</code> file:</p>
			<pre>struct PlaceholderView : View {
  let coins = [Coin(id: 1, name: "Bitcoin", symbol: "BTC", quote: Quote(USD: QuoteData(price: 20000))), Coin(id: 1, name: "Litecoin", symbol: "LTC", quote: Quote(USD: QuoteData(pr<a id="_idTextAnchor510"/><a id="_idTextAnchor511"/>ice: 200)))]
    var body: some View {
      CryptoWidgetExtensionEntryView(entry: SimpleEntry(date: Date(), configuration: ConfigurationIntent(), coins: coins))<strong class="bold">.redacted(reason: .placeholder)</strong>
    }
}</pre>
			<p>See how we are using the main widget view (<code>CryptoWidgetExtensionEntryView</code>) as the placeholder view, and we are feeding it with dummy coins data? However, the interesting part is the highlighted part: <code>.redacted(reason: .placeholder)</code>. Now that we have created a placeholder view with dummy data, let's create a preview of it and check what the effect of the <code>redacted</code> modifier is. </p>
			<p>Remove the implementation of <code>CryptoWidgetExtension_Previews</code> and add this new one, with the modified code highlighted as follows:</p>
			<pre>struct CryptoWidgetExtension_Previews: PreviewProvider {
    static var previews: some View {
      <strong class="bold">Group {</strong>
        CryptoWidgetExtensionEntryView(entry: SimpleEntry(date: Date(), configuration: ConfigurationIntent(), coins: [Coin(id: 1, name: "Bitcoin", symbol: "BTC", quote: Quote(USD: QuoteData(price: 20000))), Coin(id: 1, name: "Litecoin", symbol: "LTC", quote: Quote(USD: QuoteData(price: 200)))]))
          .previewContext(WidgetPreviewContext(family: .systemSmall))
        <strong class="bold">PlaceholderView()</strong>
<strong class="bold">          .previewContext(WidgetPreviewContext(family: .systemSmall))</strong>
<strong class="bold">      }</strong>
    }
}</pre>
			<p>First, we are encapsulating the previous <code>CryptoWidgetExtensionEntryView</code> view inside <code>Group</code>. This is because now we want to display a group of previews, <code>CryptoWidgetExtensionEntryView,</code> and the new <code>Placeholder</code>.</p>
			<p>Then, we are adding the<a id="_idIndexMarker844"/> newly created <code>Placeholder</code> view, and applying to it a <code>previewContext</code> of a small widget, like before. Compile and resume the preview render; you should see the following:</p>
			<div><div><img src="img/Figure_16.09_B14717.jpg" alt="Figure 16.9 – Placeholder view with a redacted modifier&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.9 – Placeholder view with a redacted modifier</p>
			<p>Do you now see the effect of <code>.redacted(reason: .placeholder)</code>? SwiftUI is replacing labels with placeholder views of them. It is straightforward to create a placeholder view of your widgets like this!</p>
			<p>Currently, we have a small-sized widget and a preview of it. Let's start creating a medium-sized version of it. Bigger widgets should use the extra available space to provide users with added value. Your medium- or big-sized widget should not be a simple, bigger-sized version of the small one. In our case, we are displaying the price of Bitcoin in a small size. Now, in the medium size, we will<a id="_idIndexMarker845"/> display the value of multiple cryptocurrencies at once. The user will get a bigger picture of the market with just a glance!</p>
			<p>In the previous section, we configured <code>supportedFamilies</code> to allow the small size of the widget. We need to add the medium size too. You will find it in the <code>CryptoWidgetExtension</code> struct. Add <code>.systemMedium</code> to <code>supportedFamilies</code>, so the configuration line should look like this:</p>
			<pre>.supportedFamilies([.systemSmall, <strong class="bold">.systemMedium</strong>])</pre>
			<p>Let's now create a preview of the medium-sized widget. Go ahead and add a new <code>Group</code> below the existing one in <code>CryptoWidgetExtension_Previews</code>. Add the following code just where the existing <code>Group{ … }</code> finishes (so you should have one group after the other):</p>
			<pre>Group {
  CryptoWidgetExtensionEntryView(entry: SimpleEntry(date: Date(), configuration: ConfigurationIntent(), coins: [Coin(id: 1, name: "Bitcoin", symbol: "BTC", quote: Quote(USD: QuoteData(price: 20000))), Coin(id: 1, name: "Litecoin", symbol: "LTC", quote: Quote(USD: QuoteData(price: 200))), Coin(id: 1, name: "Ethereum", symbol: "ETH", quote: Quote(USD: QuoteData(price: 1200)))]))
    .previewContext(WidgetPreviewContext(family: .<strong class="bold">systemMedium</strong>))
  PlaceholderView()
    .previewContext(WidgetPreviewContext(family: .<strong class="bold">systemMedium</strong>))
}</pre>
			<p>See how this new group of views is the same as the existing one, with the only difference being in the highlighted code? We are now displaying the widget and its placeholder inside a <code>systemMedium</code> preview. If you resume the render, you should see these two new previews (apart from the previous small-sized ones):</p>
			<div><div><img src="img/Figure_16.10_B14717.jpg" alt="Figure 16.10 – Medium-sized widget and placeholder&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.10 – Medium-sized widget and placeholder</p>
			<p>You can imagine how, for a user, this result would be very disappointing. We are displaying the exact same information as in the small widget but taking up more space on their home screen (which is very valuable to them!). Let's improve this by changing the layout of our <code>CryptoWidgetExtensionEntryView</code> when the system is displaying a medium-sized version. We can make use of the extra space to display more than just one coin at a time. Remove the implementation of <code>CryptoWidgetExtensionEntryView</code> and use the following one:</p>
			<pre>struct CryptoWidgetExtensionEntryView : View {
  var entry: Provider.Entry
  //1
  <strong class="bold">@Environment(\.widgetFamily)</strong> var family
  //2
  <strong class="bold">@ViewBuilder</strong>
  var body: some View {
    switch family {
    //3
    case .systemSmall where entry.coins.count &gt; 0:
      <strong class="bold">CoinDetail(coin: entry.coins[0])</strong>
    //4
    case .systemMedium where entry.coins.count &gt; 0:
      HStack(alignment: .center) {
        Spacer()
        CoinDetail(coin: entry.coins.first!)
        Spacer()
        <strong class="bold">CoinListView(data: entry.coins)</strong>
        Spacer()
      }
    //5
    default:
      PlaceholderView()
    }
  }
}</pre>
			<p>Let's discuss the numbered comments in the code:</p>
			<ol>
				<li value="1">We are using the <code>@Environment(\.widgetFamily)</code> variable, which allows us to know which <a id="_idIndexMarker846"/>widget family is being used. Based on that info, we can use different layouts for different sizes.</li>
				<li>The view has to declare its body with <code>@ViewBuilder</code> because the type of view it uses varies. </li>
				<li>We use the <code>family</code> (<code>widgetFamily</code>) property to switch over it and provide different views for different widget sizes. For the small-sized widget, we keep using the <code>CoinDetail</code> view as before.</li>
				<li>For the medium-sized widget, we use a combination of views that let us display the details of a coin and a list of other coins by its side. In this way, we add more value and use the space available to provide extra info to the user.</li>
				<li>Finally, we use <code>Placeholder</code> for the <code>default</code> case of the switch.</li>
			</ol>
			<p>Now you can resume the preview to see the changes. The medium-sized group should look like this:</p>
			<div><div><img src="img/Figure_16.11_B14717.jpg" alt="Figure 16.11 – Medium-sized widget&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.11 – Medium-sized widget</p>
			<p>Great! We now have a different widget for the medium-sized family that provides some extra value to the user! We still have one important task ahead. The data that we are displaying in both the small and medium sizes is just dummy data. Also, we are not letting the user choose which coin they want to display in the small-sized widget; we are forcing it to display Bitcoin, and they may not be interested in that one.</p>
			<p>In the next section, we<a id="_idIndexMarker847"/> will learn how to provide the widget with a dynamic configuration (so the user can configure options for the widget) and how to display real data.</p>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor512"/>Providing the widget with data and configuration</h2>
			<p>Up to this point, we have a widget<a id="_idIndexMarker848"/> with various sizes and a placeholder view that is displaying dummy data about cryptocurrencies. In this section, we will swap that dummy data with real data coming from an API, and we will also let the user configure some options to personalize the widget even more.</p>
			<p>If you didn't follow along with the previous section, you can use the project named <code>CryptoWidget_2_medium_widget</code>. </p>
			<p>Let's start by providing the widget with real data. The entity that is providing the entries (and therefore the data) to the widget view is <code>Provider</code>. Somehow, we need <code>Provider</code> to be aware of our data source and serve incoming data to the views. In our main app, the struct responsible for providing data is <code>DataManager</code>. Go ahead and add the following property to the <code>Provider</code> struct, in the <code>CryptoWidgetExtension.swift</code> file:</p>
			<pre>@ObservedObject var dataManager = DataManager()</pre>
			<p>We are adding an<a id="_idIndexMarker849"/> instance of <code>DataManager</code> to the widget's <code>Provider</code>. Note that we are marking this property with the <code>@ObservedObject</code> tag. If you haven't used it in SwiftUI before, whenever an observable property wrapped with this tag changes, it invalidates any view that depends on it.</p>
			<p>Every time that <code>DataManager</code> changes, the views that depend on it will invalidate and refresh to reflect those changes. Now, we can delete the dummy data from <code>Provider</code> and use the data manager instead. Remove this line:</p>
			<pre>let coins = [Coin(id: 1, name: "Bitcoin", symbol: "BTC", quote: Quote(USD: QuoteData(price: 20000))), Coin(id: 1, name: "Litecoin", symbol: "LTC", quote: Quote(USD: QuoteData(price: 200)))]</pre>
			<p>If you build the project, you will get three compile errors—one in each provider's method, where we were using the <code>coins</code> property that we just deleted. Go ahead and use the <code>dataManager.coins.data</code> property instead of the deleted coins one. This property from <code>dataManager</code> contains the real data retrieved from the API.</p>
			<p>Now, launch the main app, remove the previous widget from the device, and add it again to the home screen. You should see something like this:</p>
			<div><div><img src="img/Figure_16.12_B14717.jpg" alt="Figure 16.12 – Widget gallery&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.12 – Widget gallery</p>
			<p>That is excellent <a id="_idIndexMarker850"/>news! This is no longer dummy data; we have up to five coins in the list with real values (remember that these values will not be up to date if you are using the sandbox endpoint, as discussed at the beginning of the chapter).</p>
			<p>Now we have real values showing in the widget. The final step is going to be to improve the small-sized widget a little bit. Currently, the small-sized widget shows the price of Bitcoin. But the user may be interested in other cryptocurrencies. We will use a configuration intent to allow the user to input configuration values and make our widgets more dynamic.</p>
			<p>At the beginning of the chapter, when we added the widget extension to the main app, we selected the <code>CryptoWidgetExtension.intentdefinition</code> inside the widget extension folder. This is a Siri intent definition file, where we can configure the options that our widget will accept as user input. Let's configure the intent definition for our specific case. We want the user to be able to select<a id="_idIndexMarker851"/> a coin from a predefined list of coin names, to display the price of that coin in the small-sized widget. </p>
			<p>Let's start by creating an enum with the following values: <code>BTC</code>, <code>LTC</code>, and <code>ETH</code>:</p>
			<ol>
				<li value="1">Click on the <code>CryptoWidgetExtension.intentdefinition</code> file. In the <code>coinSelect</code> and change the type to <strong class="bold">Add Enum</strong>. </li>
				<li>This action will take you<a id="_idIndexMarker852"/> forward to creating a new enum. Call the enum <code>Coin Select</code> and ad<a id="_idTextAnchor515"/><a id="_idTextAnchor516"/>d the following values:<p><code>1</code>. <code>LTC</code></p><p><code>2</code>. <code>ETH</code></p><p><code>3</code>. <code>BTC</code></p><p>It should look like this:</p><div><img src="img/Figure_16.13_B14717.jpg" alt="Figure 16.13 – Coin Select enum configuration&#13;&#10;"/></div><p class="figure-caption">Figure 16.13 – Coin Select enum configuration</p></li>
				<li>Now go back to the <strong class="bold">Configuration</strong> section of the intent. You can uncheck the <strong class="bold">Siri can ask for value when run</strong> option. Make sure that the other options are set as in the following screenshot:<div><img src="img/Figure_16.14_B14717.jpg" alt="Figure 16.14 – Custom Intent configuration&#13;&#10;"/></div><p class="figure-caption">Figure 16.14 – Custom Intent configuration</p><p>With the custom<a id="_idIndexMarker853"/> intent configured like this and the enum created to display some list values, we are ready to use this intent in our widget. </p></li>
				<li>Go back to the <code>CryptoWidgetExtension.swift</code> file and check the <code>SimpleEntry</code> definition. Inside each entry, we have access to the <code>configuration</code> property (which is an instance of the <code>ConfigurationIntent</code> that we just configured). This means that we have access to the custom intent values every time we access an entry.<p>Now, in <code>CryptoWidgetExtensionEntryView</code>, we have an <code>entry</code> available (of course! It is the data that we want to display). Therefore, we have access to the configuration intent inside it. Let's make use of it then! We are going to modify the <code>.systemSmall</code> switch case to use the configuration intent information and display different coins, instead of just displaying Bitcoin. </p></li>
				<li>Go ahead and locate the following code:<pre>case .systemSmall where entry.coins.count &gt; 0:
      CoinDetail(coin: entry.coins[0]) </pre></li>
				<li>Replace it with<a id="_idIndexMarker854"/> this new one:<pre>case .systemSmall where entry.coins.count &gt; 0:
  switch <code>entry.configuration.coinselect</code>) to know which coin from the enum the user selected. Based on that, we are displaying a specific coin in the small-sized widget.</p><p>Try to build the project. You may get a compile error. This error happens because the widget doesn't yet know about the custom Siri intent type (even though Xcode generated it for us). This error may be fixed in future versions of Xcode. If you have an error, check the following:</p></li>
				<li>Go to the main app settings and, under the <code>ConfigurationIntent</code> intent under the <strong class="bold">Supported Intents</strong> section, as in the following screenshot:<div><img src="img/Figure_16.15_B14717.jpg" alt="Figure 16.15 – Adding your intent to the Supported Intents section&#13;&#10;"/></div><p class="figure-caption">Figure 16.15 – Adding your intent to the Supported Intents section</p></li>
				<li>Build the project <a id="_idIndexMarker855"/>again, and the compile errors should be gone. </li>
				<li>If you still have any errors, try the following: <p>a) Compile and run the target of the main app. </p><p>b) Run the target of the widget. Delete the widget from the simulator and add it again (the small-sized one). </p></li>
				<li>Now, if you long-press over the small-sized widget on the device (or simulator), you should be able to see the <strong class="bold">Edit Widget</strong> option. It will display your new custom intent, as in the following screenshot:<div><img src="img/Figure_16.16_B14717.jpg" alt="Figure 16.16 – Widget configuration options&#13;&#10;"/></div><p class="figure-caption">Figure 16.16 – Widget configuration options</p></li>
				<li>Try selecting <strong class="bold">ETH</strong> or <strong class="bold">LTC</strong>. Then, your widget will reload and display that coin! This is great; we now have a configurable crypto widget. </li>
			</ol>
			<p>In this section, we learned how to <a id="_idIndexMarker856"/>make a widget configurable using a Siri intent, so the user is able to select values and edit the widget from the home screen. </p>
			<p>Now, there is another topic that we haven't discussed yet. In the <code>Provider</code> struct, we learned that the <code>getTimeline(…)</code> method will provide the widget with an array of values to display over time, to refresh the information being displayed and stay up to date. But we didn't discuss how we control when the widget is actually refreshing, or even whether we are in control of it. We are going to learn about this in the next section.</p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor517"/>Refreshing the widget's data</h2>
			<p>Keeping widgets up to date<a id="_idIndexMarker857"/> consumes system resources and can require significant battery usage. For this reason, the system will limit the number of updates that each widget can perform during the day in order to save battery life.</p>
			<p>With this idea in mind, we have to understand that we don't have full control over our widget's refresh time and frequency, and that widgets are not always active. We are able to give the system some hints about when would be ideal for our widget to refresh, but ultimately, the system will decide it.</p>
			<p>The system uses a budget to distribute reloads over time. That budget is affected by the following factors:</p>
			<ul>
				<li>How many times has the widget been displayed to the user?</li>
				<li>When was the last time the widget was reloaded?</li>
				<li>Is the widget's main app active?</li>
			</ul>
			<p>The allocated budget for a widget lasts 24 hours. A widget that a user visits a lot can get up to 70 refreshes per day, meaning it can update once every 15 minutes or so. </p>
			<p>You can help WidgetKit estimate the best budget for your widget by providing as much information as you can in your widget's <code>Timeline</code> method. Some examples are as follows: </p>
			<ul>
				<li>A cooking widget that<a id="_idIndexMarker858"/> follows a recipe can schedule different steps in the timeline to show the cooking steps at certain points in time: preheat the oven for 15 minutes, cook for 30 minutes, let it rest for 10 minutes, and so on. That would result in a timeline with entries separated over time at specific minutes (15 – 30 – 10). WidgetKit will try to refresh your widget at those points in time, to display the proper entries.</li>
				<li>For a widget to remind users to drink water every 2 hours, you may produce a timeline to remind users about drinking a glass of water every 2 hours. But you can also be more efficient and avoid any refreshes during nighttime when the user is sleeping. That will produce a more efficient timeline and save some budget that WidgetKit can use to refresh your widget more often when it is really needed.</li>
			</ul>
			<p>Now, in our specific example of the crypto ticker widget, let's modify the timeline to ask WidgetKit to refresh our widget every 5 minutes (a very aggressive request!). But we know cryptocurrencies are very volatile and for this example, we want to refresh the price as much as possible. Follow these steps:</p>
			<ol>
				<li value="1">Go ahead and open the project named <code>CryptoWidget_4_timeline</code> from the code bundle of this chapter. First, let's create a new method inside <code>DataManager</code> that allows us to fetch the latest crypto data with a completion block. </li>
				<li>Add the following method to the struct:<pre>func refresh(completionHandler: @escaping (CoinList) -&gt; Void) {
  guard let url = URL(string: apiUrl) else { return }
  var request = URLRequest(url: url)
  request.setValue(apiKeyValue, forHTTPHeaderField: apiKeyHeader)
  URLSession.shared.dataTask(with: request){ (data, _, _) in
    print("Update coins")
    guard let data = data else { return }
    let coins = try! JSONDecoder().decode(CoinList.self, from: data)
    DispatchQueue.main.async {
      print(coins)
      self.coins = coins
      self.loading = false
      completionHandler(coins)
    }
  }.resume()
}</pre><p>See how the method is similar to <code>getData()</code>, but this one is not <code>private</code> and it also returns <code>coins</code> inside a <code>completion</code> handler for us to use on demand. </p></li>
				<li>Next, go to the file<a id="_idIndexMarker859"/> called <code>CryptoWidgetExtension.swift</code> and modify the <code>getTimeline(…)</code> method inside the <code>Provider</code> struct to contain the following implementation instead:<pre>func getTimeline(for configuration: ConfigurationIntent, in context: Context, completion: @escaping (Timeline&lt;Entry&gt;) -&gt; ()) {
  print("New Timeline \(Date())")
  <strong class="bold">dataManager.refresh</strong> { (coins) in
    let currentDate = Date()
    let futureDate = Calendar.current.date(byAdding: .minute, value: 15, to: currentDate)!
    let timeline = Timeline(entries: [SimpleEntry(date: Date(), configuration: configuration, coins: coins.data)], policy: <strong class="bold">.after(futureDate)</strong>)
    completion(timeline)
  }
}</pre></li>
			</ol>
			<p>Let's see what is happening in the method:</p>
			<ol>
				<li value="1">First, we are using the new method that we created, <code>refresh(…)</code>, to get the latest values of the crypto coins.</li>
				<li>Once we have the coins<a id="_idIndexMarker860"/> ready in the completion handler, we are creating a future date that is 15 minutes into the future.</li>
				<li>Then, we create <code>Timeline</code> with a <code>SimpleEntry</code> that contains the latest values for <code>coins</code>, and a refresh policy. The refresh policy is set to create a new timeline after 15 minutes have passed (<code>futureDate</code>). Usually, 15 minutes is the minimum time needed for WidgetKit to update your widget again. If you try lower values, you may not get any results.<p>So, to wrap this method up, when WidgetKit requests a timeline from us, we are calling our API to get the latest crypto values, then we wrap them in an entry ready for the widget views to be displayed, and we establish a refresh policy of "after 15 minutes have passed." </p></li>
				<li>Now try deleting the app and the widget from the simulator or your device. Install both the app and the extension and add a small widget to the home screen. The moment you add the widget, you should see in the logs the first statement of the timeline method, similar to this:<pre><strong class="bold">New Timeline 2021-01-23 20<a id="_idTextAnchor518"/><a id="_idTextAnchor519"/>:51:51 +0000</strong></pre><p>Then, after 15 minutes, you should see it appearing again. The refresh policy has kicked in, and we have provided a refreshed version with the latest values again:</p><pre><strong class="bold">New Timeline 2021-01-23 21:06:52 +0000</strong></pre></li>
			</ol>
			<p>Great! We know now how to refresh our widgets! Just a last note: there are more refresh policies other than <code>.a<a id="_idTextAnchor520"/><a id="_idTextAnchor521"/>fter</code>. Here are the options:</p>
			<ul>
				<li><code>TimelineReloadPolicy.after(Date)</code>: A new timeline will be generated after the specific date has passed.</li>
				<li><code>TimelineReloadPolicy.atEnd</code>: A new timeline will be generated after the last entry of the current timeline passes.</li>
				<li><code>TimelineReloadPolicy.never</code>: The widget's app will be responsible for letting WidgetKit know when the next timeline is ready.</li>
			</ul>
			<p>In this section, we<a id="_idIndexMarker861"/> learned the basics of how WidgetKit decides when to refresh your widgets, and how we can provide timelines and refresh policies so that the system has a better idea of when we want our widgets to be updated. Now, let's wrap up the chapter with a summary.</p>
			<h1 id="_idParaDest-248"><a id="_idTextAnchor522"/>Summary</h1>
			<p>We started the chapter by learning about the basics of widgets and WidgetKit. We learned about the general guidelines, the basic options, and their purpose. After that intro, we jumped straight into developing our first widget. We started by adding a small-sized widget to an existing app. </p>
			<p>Then, we added a placeholder view to the widget so that it gives the user a good idea of what the widget would look like the first time it loads. After that, we created a bigger, medium-sized widget version that is able to display much more information and provide more value than the small-sized widget. </p>
			<p>Finally, we learned how to make the widget configurable by the user with the help of Siri custom intents. By using a custom intent, users are able to provide certain configuration values to the widget to personalize the experience.</p>
			<p>In this chapter, you learned how to create widgets and make the most out of WidgetKit. In the next chapter, we will learn about ARKit, the augmented reality framework from Apple.</p>
		</div>
	</body></html>