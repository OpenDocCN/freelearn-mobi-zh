["```swift\n// Audio definitions\n#define SND_BUTTON @\"button.caf\"\n#define SND_TURN @\"bike_turn.caf\"\n\n// Graphics definitions\n#define IMG_BIKE @\"lightbulb.png\"\n#define IMG_GLOW @\"glow.png\"\n#define IMG_BUTTON @\"rightarrow.png\"\n#define IMG_SPECK @\"whitespeck.png\"\n\ntypedef enum {\n    kBluePlayer,\n    kRedPlayer\n} PlayerID;\n\ntypedef enum {\n    kNoChange, // NoChange only used in bluetooth games\n    kUp,\n    kRight,\n    kLeft,\n    kDown\n} Direction;\n```", "```swift\n#import <Foundation/Foundation.h>\n#import \"cocos2d.h\"\n#import \"CLDefinitions.h\"\n\n@class CLPlayfieldLayer;\n\n@interface CLBike : CCSprite {\n    CGSize size; // Window size returned from CCDirector\n\n    CLPlayfieldLayer *myPlayfield; // game layer\n\n    PlayerID _thisPlayerID; // Player Number\n\n    ccColor3B _wallColor; // Blue or green color\n\n    float _bikeSpeed; // rate of travel for this bike\n    Direction _bikeDirection; // facing which direction?\n\n    CCSprite *glow; // The colored bulb glow sprite\n\n    CCSprite *_currentWall; // Wall connected to bike\n    CCSprite *_priorWall; // Wall created before current\n\n    NSInteger wallWidth; // How wide the walls are\n\n    BOOL isRemotePlayer; // Is this a non-local player?\n    BOOL isCrashed; // Did this bike crash?\n}\n\n@property (nonatomic, assign) PlayerID thisPlayerID;\n@property (nonatomic, assign) float bikeSpeed;\n@property (nonatomic, assign) Direction bikeDirection;\n@property (nonatomic, assign) ccColor3B wallColor;\n@property (nonatomic, assign) BOOL isRemotePlayer;\n@property (nonatomic, assign) BOOL isCrashed;\n@property (nonatomic, retain) CCSprite *currentWall;\n@property (nonatomic, retain) CCSprite *priorWall;\n\n+(id) bikeForPlayer:(PlayerID)playerID \n           PlayerNo:(NSInteger)playerNo \n            onLayer:(CLPlayfieldLayer*)thisLayer\n           isRemote:(BOOL)remotePlayer;\n\n-(void) moveForDistance:(float)dist;\n-(void) move;\n-(void) turnRight;\n-(void) turnLeft;\n-(void) crash;\n\n-(CGPoint) wallAnchorPoint;\n\n@end\n```", "```swift\n+(id) bikeForPlayer:(PlayerID)playerID \n           PlayerNo:(NSInteger)playerNo \n            onLayer:(CLPlayfieldLayer*)thisLayer\n           isRemote:(BOOL)remotePlayer;\n```", "```swift\n#import \"CLBike.h\"\n#import \"CLPlayfieldLayer.h\"\n#import \"SimpleAudioEngine.h\"\n\n@implementation CLBike\n\n@synthesize thisPlayerID = _thisPlayerID;\n@synthesize bikeSpeed = _bikeSpeed;\n@synthesize bikeDirection = _bikeDirection;\n@synthesize wallColor = _wallColor;\n@synthesize currentWall = _currentWall;\n@synthesize priorWall = _priorWall;\n@synthesize isRemotePlayer;\n@synthesize isCrashed;\n\n+(id) bikeForPlayer:(PlayerID)playerID \n           PlayerNo:(NSInteger)playerNo \n            onLayer:(CLPlayfieldLayer*)thisLayer\n           isRemote:(BOOL)remotePlayer\n{\n    return [[[self alloc] initForPlayer:playerID \n                               PlayerNo:playerNo \n                                onLayer:thisLayer\n                               isRemote:remotePlayer] \n            autorelease];   \n}\n```", "```swift\n-(id) initForPlayer:(PlayerID)playerID \n           PlayerNo:(NSInteger)playerNo \n            onLayer:(CLPlayfieldLayer*)thisLayer\n           isRemote:(BOOL)remotePlayer {\n    if(self = [super initWithSpriteFrameName:IMG_BIKE]) {\n        myPlayfield = thisLayer;\n\n        isRemotePlayer = remotePlayer;\n\n        size = [[CCDirector sharedDirector] winSize];\n\n        self.thisPlayerID = playerID;\n        self.bikeSpeed = 3.0;\n        self.bikeDirection = kUp;\n        self.anchorPoint = ccp(0.5,0);\n        self.scale = 0.25;\n        self.isCrashed = NO;\n\n        // Set the player's wall color\n        switch (self.thisPlayerID) {\n            case kRedPlayer:\n                self.wallColor = ccc3(255, 75, 75);\n                break;\n            case kBluePlayer:\n                self.wallColor = ccc3(75, 75, 255);\n                break;\n        }\n```", "```swift\nswitch (playerNo) {\n            case 1:\n                // Starts at bottom of screen\n                [self setPosition:ccp(size.width/2,64)];\n                break;\n            case 2:\n                // Starts at top of screen\n                [self setPosition:ccp(size.width/2,960)];\n                self.bikeDirection = kDown;\n                break;\n        }\n\n        [self rotateBike];\n\n        glow = [CCSprite spriteWithSpriteFrameName:IMG_GLOW];\n        [glow setAnchorPoint:[self anchorPoint]];\n        [glow setPosition:ccp(34,26)];\n        [glow setColor:self.wallColor];\n        [self addChild:glow z:-1];\n\n        // Bike's wall init here\n    }\n    return self;\n}\n```", "```swift\n-(void) rotateBike {\n    // Rotate the bike to match the direction\n    switch (self.bikeDirection) {\n        case kUp:\n            self.rotation = 0;\n            break;\n        case kRight:\n            self.rotation = 90;\n            break;\n        case kDown:\n            self.rotation = 180;\n            break;\n        case kLeft:\n            self.rotation = -90;\n            break;\n        default:\n            break;\n    }\n}\n```", "```swift\n-(void) turnRight {\n    // Turn the bike to the right\n    switch (self.bikeDirection) {\n        case kUp:\n            self.bikeDirection = kRight;\n            break;\n        case kRight:\n            self.bikeDirection = kDown;\n            break;\n        case kDown:\n            self.bikeDirection = kLeft;\n            break;\n        case kLeft:\n            self.bikeDirection = kUp;\n            break;\n        default:\n            break;\n    }\n\n    // Rotate the bike to the new direction\n    [self rotateBike];\n\n    // Play the turn sound\n    [[SimpleAudioEngine sharedEngine] playEffect:SND_TURN];\n\n    // Wall assignments\n\n    // Remote game\n}\n```", "```swift\n-(void) createWallFrom:(CGPoint)orig to:(CGPoint)dest {\n    CCSprite *aWall = [CCSprite \n                       spriteWithSpriteFrameName:IMG_SPECK];\n    [aWall setColor:ccYELLOW];\n    [aWall setPosition:orig];\n    [aWall setAnchorPoint:ccp(0,0)];\n    [aWall setScaleX:ABS(orig.x - dest.x) + 3];\n    [aWall setScaleY:ABS(orig.y - dest.y) + 3];\n    [cyclesheet addChild:aWall];\n\n    [bikeWalls addObject:aWall]; \n}\n```", "```swift\n-(void) createOuterWalls {\n    // Bottom\n    [self createWallFrom:ccp(59,62) to:ccp(709,62)];\n    // Top\n    [self createWallFrom:ccp(59,962) to:ccp(709,962)];\n    // Left\n    [self createWallFrom:ccp(59,62) to:ccp(59,962)];\n    // Right\n    [self createWallFrom:ccp(709,62) to:ccp(709,962)];\n}\n```", "```swift\n-(CCSprite*) createWallFromBike:(CLBike*)thisBike {\n\n    CCSprite *aWall = [CCSprite \n                       spriteWithSpriteFrameName:IMG_SPECK];\n    [aWall setColor:thisBike.wallColor];\n    [aWall setAnchorPoint:[thisBike wallAnchorPoint]];\n    [aWall setPosition:thisBike.position];\n\n    [cyclesheet addChild:aWall];\n\n    [bikeWalls addObject:aWall];\n\n    return aWall;\n}\n```", "```swift\n-(CGPoint) wallAnchorPoint {\n    // Calculate the anchor point, based on direction\n    switch (self.bikeDirection) {\n        case kUp:\n            return ccp(0.5,0);\n            break;\n        case kRight:\n            return ccp(0,0.5);\n            break;\n        case kDown:\n            return ccp(0.5,1);\n            break;\n        case kLeft:\n            return ccp(1,0.5);\n            break;\n        default:\n            return ccp(0.5,0.5);\n            break;\n    }\n}\n```", "```swift\n        // Bike's wall init here\n        wallWidth = 5;\n\n        self.priorWall = nil;\n        self.currentWall = [myPlayfield \n                            createWallFromBike:self];\n```", "```swift\n    // Wall assignments\n    self.priorWall = self.currentWall;\n    self.currentWall = [myPlayfield \n                        createWallFromBike:self];\n```", "```swift\n-(void) move {\n    // Move this bike (if local player)\n    [self moveForDistance:self.bikeSpeed];\n\n    // Remote game\n}\n```", "```swift\n-(void)moveForDistance:(float)dist {\n    // Update bike position and scales the currentWall\n    switch (self.bikeDirection) {\n        case kUp:\n            [self setPosition:ccp(self.position.x,\n                                  self.position.y + \n                                  dist)];\n            [self.currentWall setScaleY:\n             ABS(self.currentWall.position.y - \n                 self.position.y)];\n\n            [self.currentWall setScaleX:wallWidth];\n\n            break;\n        case kDown:\n            [self setPosition:ccp(self.position.x,\n                                  self.position.y - \n                                  dist)];\n\n            [self.currentWall setScaleY:\n             ABS(self.currentWall.position.y\n                 - self.position.y)];\n\n            [self.currentWall setScaleX:wallWidth];\n\n            break;\n        case kLeft:\n            [self setPosition:ccp(self.position.x - \n                                  dist,\n                                  self.position.y)];\n\n            [self.currentWall setScaleX:\n             ABS(self.currentWall.position.x \n                 - self.position.x)];\n\n            [self.currentWall setScaleY:wallWidth];\n\n            break;\n        case kRight:\n            [self setPosition:ccp(self.position.x + \n                                  dist,\n                                  self.position.y)];\n\n            [self.currentWall setScaleX:\n             ABS(self.currentWall.position.x \n                 - self.position.x)];\n\n            [self.currentWall setScaleY:wallWidth];\n\n            break;\n        default:\n            break;\n    }\n}\n```", "```swift\n#import <Foundation/Foundation.h>\n#import \"cocos2d.h\"\n#import \"CLDefinitions.h\"\n#import \"CLBike.h\"\n\n@interface CLButton : CCSprite <CCTargetedTouchDelegate> {\n    BOOL isLeft; // Is this a left turn button?\n    CLBike *parentBike; // Bike the button controls\n    CLPlayfieldLayer *myPlayfield; // main game layer\n}\n\n+(id) buttonForBike:(CLBike*)thisBike\n         asPlayerNo:(NSInteger)playerNo\n             isLeft:(BOOL)isLeftButton\n            onLayer:(CLPlayfieldLayer*)thisLayer;\n\n@end\n```", "```swift\n#import \"CLButton.h\"\n#import \"CLDefinitions.h\"\n#import \"CLPlayfieldLayer.h\"\n\n@implementation CLButton\n\n#pragma mark Initialization\n+(id) buttonForBike:(CLBike*)thisBike \n         asPlayerNo:(NSInteger)playerNo \n             isLeft:(BOOL)isLeftButton\n            onLayer:(CLPlayfieldLayer*)thisLayer {\n    return [[[self alloc] initForBike:thisBike \n                           asPlayerNo:playerNo \n                               isLeft:isLeftButton\n                              onLayer:thisLayer] \n            autorelease];   \n}\n```", "```swift\n-(id) initForBike:(CLBike*)thisBike \n       asPlayerNo:(NSInteger)playerNo \n           isLeft:(BOOL)isLeftButton\n            onLayer:(CLPlayfieldLayer*)thisLayer {   \n    if( self = [super initWithSpriteFrameName:IMG_BUTTON]) {\n\n        // Store whether this is a left button\n        isLeft = isLeftButton;\n\n        // Keep track of the parent bike\n        parentBike = thisBike;\n\n        // Keep track of the parent layer\n        myPlayfield = thisLayer;\n\n        // Set the tint of the button\n        [self setColor:parentBike.wallColor];\n\n        // Base values for positioning\n        float newY = 30;\n        float newX = [[CCDirector sharedDirector] \n                      winSize].width / 4;\n\n        // Selective logic to position the buttons\n        switch (playerNo) {\n            case 1:\n                if (isLeft) {\n                    // Flip the image so it points left\n                    [self setFlipX:YES];\n                } else {\n                    // Move it to the right\n                    newX *= 3;\n                } \n                break;\n            case 2:\n                // Player 2 is upside down at the top\n                newY = 994;\n\n                // Flip the buttons to face player\n                [self setFlipY:YES];\n\n                if (isLeft) {\n                    // Move it to the right\n                    newX *= 3;\n                } else {\n                    // Flip the image so it points left\n                    [self setFlipX:YES];\n                }\n                break;\n        }\n\n        [self setPosition:ccp(newX, newY)];\n\n    }\n    return self;\n}\n```", "```swift\n-(BOOL) ccTouchBegan:(UITouch *)touch withEvent:(UIEvent *)event {\n    // Prevent touches if the layer not accepting touches\n    if (myPlayfield.isTouchBlocked) {\n        return NO;\n    }\n\n    CGPoint loc = [touch locationInView:[touch view]];\n    CGPoint convLoc = [[CCDirector sharedDirector]\n                       convertToGL:loc];\n\n    // Create an expanded hit box for this class\n    CGRect hitRect = CGRectInset(self.boundingBox, 0, -50.0);\n\n    // If touched, send a turn msg to the parent bike\n    if (CGRectContainsPoint(hitRect, convLoc)) {\n        if (isLeft) {\n            [self flashButton];\n            [parentBike turnLeft];\n        } else {\n            [self flashButton];\n            [parentBike turnRight];\n        }\n    }\n\n    return YES;\n}\n```", "```swift\n-(void) flashButton {\n    // Tint to the original white color\n    CCTintTo *tintA = [CCTintTo actionWithDuration:0.1\n                                               red:255 \n                                             green:255 \n                                              blue:255];\n    // Tint back to the original color\n    CCCallBlock *tintB = [CCCallBlock actionWithBlock:\n                ^{[self setColor:parentBike.wallColor];}];\n    // Run these two actions in sequence\n    [self runAction:[CCSequence actions: tintA, \n                     tintB, nil]];\n}\n```", "```swift\n ^{\n[self dosomething];\n  }\n```", "```swift\n-(void)onEnter\n{\n    [[[CCDirector sharedDirector] touchDispatcher] \n     addTargetedDelegate:self \n     priority:0 \n     swallowsTouches:NO];\n\n    [super onEnter];\n}\n-(void)onExit\n{\n    parentBike = nil;\n    myPlayfield = nil;\n\n    [[[CCDirector sharedDirector] touchDispatcher] \n     removeDelegate:self];\n\n    [super onExit];\n}\n```", "```swift\n-(id) init {\n    if(self = [super init]) {\n\n        CGSize size = [[CCDirector sharedDirector] winSize];\n\n        // create a blank render texture\n        firstGrid = [[CCRenderTexture alloc] \n            initWithWidth:700 height:950 \n            pixelFormat:kCCTexture2DPixelFormat_RGBA8888];\n\n        // Draw the first grid in a render texture\n        [self drawGrid];\n\n        [[firstGrid sprite] setAnchorPoint:ccp(0.5,0.5)];\n        [[firstGrid sprite] setPosition:ccp(size.width/2,\n                                    size.height/2)];\n        [[firstGrid sprite] setOpacity:50];\n\n        // Override the default blend\n        [[firstGrid sprite] setBlendFunc:\n            (ccBlendFunc){GL_SRC_ALPHA,\n             GL_ONE_MINUS_SRC_ALPHA}];\n\n        [self addChild:firstGrid];\n\n        // Second grid\n\n        // Start grids moving\n\n    }\n    return self;\n}\n```", "```swift\n-(void) drawGrid {\n    // Start drawing on the Render Texture\n    [firstGrid begin];\n\n    glLineWidth( 3.0f * CC_CONTENT_SCALE_FACTOR() );\n    ccDrawColor4F(1, 1, 1, 1);\n\n    float left = 0;\n    float right = firstGrid.sprite.textureRect.size.width;\n    float top = firstGrid.sprite.textureRect.size.height;\n    float bottom = 0;\n    float gridSize = 40;\n\n    // Draw the vertical lines\n    for (float x = left; x <= right; x+=gridSize) {\n        ccDrawLine(ccp(x, bottom), ccp(x, top));\n    }\n\n    // Draw the horizontal lines\n    for (float y = bottom; y <= top; y+=gridSize) {\n        ccDrawLine(ccp(left, y), ccp(right, y));\n    }\n\n    // Done drawing on the Render Texture\n    [firstGrid end];\n\n}\n```", "```swift\n-(void) dealloc {\n    [firstGrid release];\n\n    [super dealloc];\n}\n```", "```swift\n        // Second grid\n        // Clone the grid as a separate sprite\n        secondGrid = [CCSprite spriteWithTexture:\n                      [[firstGrid sprite] texture]];\n        [secondGrid setAnchorPoint:ccp(0.5,0.5)];\n        [secondGrid setPosition:ccp(size.width/2,\n                                    size.height/2)];\n        [secondGrid setOpacity:60];\n        [secondGrid setColor:ccWHITE];\n        [self addChild:secondGrid];\n```", "```swift\n-(void) moveFirstGrid {\n    // Set up actions to shift the grid around\n    CCMoveBy *left = [CCMoveBy actionWithDuration:1.0\n                            position:ccp(-10,-10)];\n    CCMoveBy *right = [CCMoveBy actionWithDuration:1.0\n                            position:ccp(20,20)];\n    CCMoveBy *back = [CCMoveBy actionWithDuration:1.0\n                            position:ccp(-10,-10)];\n\n    CCTintBy *tintA = [CCTintBy actionWithDuration:8.0\n                        red:255 green:255 blue:0];\n    CCTintBy *tintB = [CCTintBy actionWithDuration:4.0\n                        red:0 green:255 blue:255];\n\n    CCRepeatForever *repeater = [CCRepeatForever \n        actionWithAction:[CCSequence actions:\n                          left,\n                          right,\n                          back, nil]];\n    CCRepeatForever *repeater2 = [CCRepeatForever\n                                  actionWithAction:\n                                  [CCSequence actions:\n                                   tintA, tintB, nil]];\n\n    [[firstGrid sprite] runAction:repeater];\n    [[firstGrid sprite] runAction:repeater2];    \n}\n```", "```swift\n        // Start grids moving\n        [self moveFirstGrid];\n        [self moveSecondGrid];\n```", "```swift\n-(void) visit {\n    // We use the glScissor to clip the edges\n    // So we can shift stuff around in here, but not\n    // go outside our boundaries\n    glEnable(GL_SCISSOR_TEST);\n    glScissor(59 * CC_CONTENT_SCALE_FACTOR(),\n              62 * CC_CONTENT_SCALE_FACTOR(),\n              650 * CC_CONTENT_SCALE_FACTOR(),\n              900 * CC_CONTENT_SCALE_FACTOR());\n    [super visit];\n   glDisable(GL_SCISSOR_TEST);\n}\n```", "```swift\n+(id) gameWithRemoteGame:(BOOL)isRemoteGame {\n    return [[[self alloc] initWithRemoteGame:isRemoteGame] autorelease];\n}\n\n-(id) initWithRemoteGame:(BOOL)isRemoteGame {\n    if(self = [super init]) {\n\n        size = [[CCDirector sharedDirector] winSize];\n\n        // Load the spritesheet\n        [[CCSpriteFrameCache sharedSpriteFrameCache]\n           addSpriteFramesWithFile:@\"cyclesheet.plist\"];\n        cyclesheet = [CCSpriteBatchNode\n           batchNodeWithFile:@\"cyclesheet.png\"];\n\n        // Add the batch node to the layer\n        [self addChild:cyclesheet z:1];\n\n        bikeWalls = [[NSMutableArray alloc] init];\n        remoteGame = isRemoteGame;\n        isGameOver = NO;\n        isTouchBlocked = NO;\n        // Build the background grid\n        CCNode *grid = [CLRenderGrid node];\n        [self addChild:grid z:-1];\n\n        // Build the outer walls\n        [self createOuterWalls];\n\n    }\n    return self;\n}\n```", "```swift\n-(void) onEnterTransitionDidFinish {\n    if (remoteGame) {\n        // Remote Game\n        [self findPeer:self];\n    } else {\n        // Initial Player Setup\n        [self generateRedAsPlayerNo:1 isRemote:NO];\n        [self generateBlueAsPlayerNo:2 isRemote:NO];\n        [self scheduleUpdate]; \n    }\n    [super onEnterTransitionDidFinish];\n}\n```", "```swift\n-(void) generateRedAsPlayerNo:(NSInteger)playerNo\n                     isRemote:(BOOL)remotePlayer {\n    // Generate the red player's bike\n    redBike = [CLBike bikeForPlayer:kRedPlayer \n                           PlayerNo:playerNo \n                            onLayer:self \n                           isRemote:remotePlayer];\n    [cyclesheet addChild:redBike];\n\n    // Only create buttons for the local player\n    if (remotePlayer == NO) {\n\n        CLButton *right = [CLButton \n                           buttonForBike:redBike\n                           asPlayerNo:playerNo\n                           isLeft:NO \n                           onLayer:self];\n        [cyclesheet addChild:right];\n\n        CLButton *left = [CLButton \n                          buttonForBike:redBike\n                          asPlayerNo:playerNo\n                          isLeft:YES\n                          onLayer:self];\n        [cyclesheet addChild:left];\n    }\n}\n```", "```swift\n-(void) checkForCollisions {\n    for (CCSprite *aWall in bikeWalls) {\n        // Compare wall to blue bike\n        if (CGRectIntersectsRect([aWall boundingBox],\n                                 [blueBike boundingBox]) \n            && aWall != blueBike.currentWall \n            && aWall != blueBike.priorWall) {\n                  [self crashForBike:blueBike];\n            break;\n        }  \n        //Compare wall to red bike\n        if (CGRectIntersectsRect([aWall boundingBox], \n                                 [redBike boundingBox]) \n            && aWall != redBike.currentWall \n            && aWall != redBike.priorWall) {\n                  [self crashForBike:redBike];\n            break;\n        }\n\n    }\n}\n```", "```swift\n-(void) update:(ccTime)dt {\n    // We only use the move method if this is a local\n    // player.  We move the opponent via the data \n    // connection\n    if (![redBike isRemotePlayer]) {\n        [redBike move];\n    }\n\n    if (![blueBike isRemotePlayer]) {\n        [blueBike move];\n    }\n\n    [self checkForCollisions];\n}\n```", "```swift\n-(void) crashForBike:(CLBike*)thisBike {\n    [self unscheduleUpdate];\n\n    // The bike crash sequence\n    [thisBike crash];\n\n    // Prevent all touches for now\n    isTouchBlocked = YES;\n\n    // Identify game over\n    isGameOver = YES;\n\n    // Game over sequence\n    [self displayGameOver];\n}\n```", "```swift\n-(void) crash {\n    self.isCrashed = YES;\n\n    [glow removeFromParentAndCleanup:NO];\n\n    CCScaleTo *scale = [CCScaleTo actionWithDuration:0.5\n                                               scale:2];\n    CCFadeOut *fade = [CCFadeOut actionWithDuration:1.0];\n\n    [self runAction:[CCSequence actions:scale, fade, nil]];\n}\n```", "```swift\n#import <GameKit/GameKit.h>\n\n@interface CLPlayfieldLayer : CCLayer <GKPeerPickerControllerDelegate, GKSessionDelegate> {\n```", "```swift\n     // GameKit specific variables\n    GKPeerPickerController *gkPicker; // Peer Picker\n    GKSession *gkSession; // The session\n    NSString *gamePeerId; // Identifier from peer\n    NSInteger playerNumber; // To assign bike colors\n    GKPeerConnectionState currentState;\n```", "```swift\n-(void) findPeer:(id)sender {\n    //Initialize and show the picker\n    gkPicker = [[GKPeerPickerController alloc] init];\n    gkPicker.delegate = self;\n    gkPicker.connectionTypesMask = \n                GKPeerPickerConnectionTypeNearby;\n    [gkPicker show];\n\n    playerNumber = 1;\n}\n```", "```swift\n-(GKSession*) peerPickerController:(GKPeerPickerController*)picker \nsessionForConnectionType:(GKPeerPickerConnectionType)type {\n     gkSession = [[GKSession alloc] \n             initWithSessionID:@\"Ch6_Cycles\"\n             displayName:nil \n             sessionMode:GKSessionModePeer];\n             gkSession.delegate = self;\n             return gkSession;\n}\n```", "```swift\n-(void) peerPickerController:(GKPeerPickerController*)picker\n              didConnectPeer:(NSString*)peerID \n                   toSession:(GKSession*)currSession {\n    // Dismiss the peerPicker\n    [gkSession setDataReceiveHandler:self\n                         withContext:NULL];\n    [gkPicker dismiss];\n    gkPicker.delegate = nil;\n    [gkPicker autorelease];\n\n    //Set the other player's ID\n    gamePeerId = peerID;\n}\n```", "```swift\n-(void) peerPickerControllerDidCancel: (GKPeerPickerController*)picker\n{\n    //User cancelled.  Release the delegate.\n    picker.delegate = nil;\n    [picker autorelease];\n\n    // If there is a session, cancel it\n    if(gkSession != nil) {\n        [self invalidateSession:gkSession];\n        gkSession = nil;\n    }\n\n    // Return to the main menu\n    [self returnToMainMenu];\n}\n```", "```swift\n-(void) returnToMainMenu {\n    // If there is a GameKit Session, invalidate it\n    if(gkSession != nil) {\n        [self invalidateSession:gkSession];\n        gkSession = nil;\n    }\n\n    [[CCDirector sharedDirector] \n             replaceScene:[CLMenuScene node]];\n}\n```", "```swift\n-(void) session:(GKSession*)session \ndidReceiveConnectionRequestFromPeer:(NSString*)peerI {\n    //We are player 2 (blue)\n    playerNumber = 2;\n}\n```", "```swift\n-(void) session:(GKSession*)session \n     connectionWithPeerFailed:(NSString*)peerID \n                    withError:(NSError*)error {\n    // Connection Failed\n    [gkPicker dismiss];\n    gkPicker.delegate = nil;\n    [gkPicker autorelease];\n\n    [self returnToMainMenu];\n}\n\n-(void) session:(GKSession*)session \n                didFailWithError:(NSError*)error {\n    // Connection Failed\n    [gkPicker dismiss];\n    gkPicker.delegate = nil;\n    [gkPicker autorelease];\n\n    [self returnToMainMenu];\n}\n```", "```swift\n-(void) invalidateSession:(GKSession*)session {\n    if(session != nil) {\n        [session disconnectFromAllPeers];\n        session.available = NO;\n        [session setDataReceiveHandler: nil \n                           withContext: NULL];\n        session.delegate = nil;\n        [session autorelease];\n        session = nil;\n    }\n}\n```", "```swift\n-(void) session:(GKSession*)session peer:(NSString*)peerID \n          didChangeState:(GKPeerConnectionState)state {\n    if (currentState == GKPeerStateConnecting &&\n        state != GKPeerStateConnected) {\n          // Reset the player number\n          playerNumber = 1;\n    } else if(state == GKPeerStateConnected){\n         //We have now connected to a peer\n        if (playerNumber == 2) {\n            // We are the server, blue player\n            [self generateRedAsPlayerNo:2 isRemote:YES];\n            [self generateBlueAsPlayerNo:1 isRemote:NO];\n        } else {\n            // We are the client, red player\n            [self generateRedAsPlayerNo:1 isRemote:NO];\n            [self generateBlueAsPlayerNo:2 isRemote:YES]; \n        }\n        // Start the game\n        [self scheduleUpdate];    \n  } else if(state == GKPeerStateDisconnected) {\n      // We were disconnected\n      [self unscheduleUpdate];\n      // User alert\n      NSString *msg = [NSString stringWithFormat:\n                         @\"Lost device %@.\", \n                    [session displayNameForPeer:peerID]];\n      UIAlertView *alert = [[UIAlertView alloc] \n                        initWithTitle:@\"Lost Connection\" \n                        message:msg delegate:self \n                        cancelButtonTitle:@\"Game Aborted\" \n                        otherButtonTitles:nil];\n      [alert show];\n      [alert release];\n\n      [self returnToMainMenu];\n  }\n    // Keep the current state\n    currentState = state;\n}\n```", "```swift\n-(void) sendDataWithDirection:(Direction)dir \n                   orDistance:(float)dist {\n\n    //Pack data\n    NSMutableData *dataToSend = [[NSMutableData alloc] init];\n    NSKeyedArchiver *archiver = [[NSKeyedArchiver alloc]\n                initForWritingWithMutableData:dataToSend];\n\n    [archiver encodeInt:dir forKey:@\"direction\"];\n    [archiver encodeFloat:dist forKey:@\"distance\"];\n\n    [archiver finishEncoding];\n\n    // Send the data, reliably\n        [gkSession sendData:dataToSend toPeers:\n         [NSArray arrayWithObject:gamePeerId] \n               withDataMode:GKSendDataReliable\n                      error:nil];\n\n    [archiver release];\n    [dataToSend release];\n}\n```", "```swift\n-(void) receiveData:(NSData*)data fromPeer:(NSString*)peer\n          inSession:(GKSession*)session context:(void*)context {\n\n    NSKeyedUnarchiver *unarchiver = [[NSKeyedUnarchiver \n                    alloc] initForReadingWithData:data];\n\n    Direction dir = [unarchiver \n                     decodeIntForKey:@\"direction\"];\n    NSInteger dist = [unarchiver \n                      decodeFloatForKey:@\"distance\"];\n\n    // Determine which bike to use, hold in whichBike \n    CLBike *whichBike = ((playerNumber == 1)? blueBike:\n                         redBike);\n\n    // Process the data\n    if (dir == kNoChange) {\n        // This was a move forward packet\n        [whichBike moveForDistance:dist];\n    } else if (dir == kLeft) {\n        // This is a turn left packet\n        [whichBike turnLeft];\n    } else if (dir == kRight) {\n        // This is a turn right packet\n        [whichBike turnRight];\n    }\n}\n```", "```swift\n-(void) sendPacketForMove:(float)distance {\n    // We only send a packet if we are playing a remote\n    // game, and this bike is the LOCAL player\n    if (myPlayfield.remoteGame && self.isRemotePlayer == NO) {\n        [myPlayfield sendDataWithDirection:kNoChange\n                                orDistance:distance];\n    }\n}\n```", "```swift\n-(void) move {\n    // Move this bike (if local player)\n    [self moveForDistance:self.bikeSpeed];\n\n    // Remote game\n    [self sendPacketForMove:self.bikeSpeed];\n}\n```", "```swift\n-(void) sendPacketForTurn:(Direction)turnDir {\n    // We only send a packet if we are playing a remote\n    // game, and this bike is the LOCAL player\n    if (myPlayfield.remoteGame && self.isRemotePlayer == NO) {\n        [myPlayfield sendDataWithDirection:turnDir\n                                orDistance:0];\n    }\n}\n```", "```swift\n    // Remote game\n    [self sendPacketForTurn:kRight];\n```", "```swift\n    // Remote game\n    [self sendPacketForTurn:kLeft];\n```"]