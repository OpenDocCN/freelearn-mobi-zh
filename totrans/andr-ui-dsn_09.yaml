- en: Chapter 9. Optimizing Your UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your app's user interface is your most direct connection to the user, so you'll
    want to make sure it's *perfect*.
  prefs: []
  type: TYPE_NORMAL
- en: Up until now we've concentrated on creating a beautifully designed user interface
    that's packed with useful features—but this is only half the battle. If your app
    is going to rack up those 5-star Google Play reviews, you'll need to create a
    UI that's quick to render, responsive, and generally delivers an all-around great
    user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Performance is crucial to creating a successful UI, and a successful app in
    general. If your app is laggy, prone to crashing, gobbles up data and memory,
    or drains the user's battery, then no one is going to want to use it, no matter
    how good your UI looks!
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I'm going to show you how to hunt out all the most common performance
    problems that may be impacting your app. Since you'll want to fix any problems
    you do encounter, along the way I'll also be touching on some of the reasons why
    these problems occur in the first place, and the steps you can take to address
    them.
  prefs: []
  type: TYPE_NORMAL
- en: By the time you've completed this chapter, you'll know how to create a smooth
    and responsive UI that people will *love* using.
  prefs: []
  type: TYPE_NORMAL
- en: Timing your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Don't wait for your app to start throwing errors before you go looking for performance-related
    problems. Your app could be slowly leaking memory, allocating too many objects,
    or struggling under the weight of a complex view hierarchy. None of these will
    necessarily throw an error, but they'll definitely have a negative impact on your
    app's performance.
  prefs: []
  type: TYPE_NORMAL
- en: If you're going to create a high-performance app, you need to go *looking* for
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: Timing your code is a powerful way of seeing *exactly* what's going on in your
    app, including any sections of code that are running slower or longer than others.
    The first Android SDK tool we're going to look at lets you do just that.
  prefs: []
  type: TYPE_NORMAL
- en: '**TraceView** is a graphical viewer that can profile any Android app running
    on your device.'
  prefs: []
  type: TYPE_NORMAL
- en: TraceView, like most of the tools we're going to cover in this chapter, can
    only measure a running application. So the first step is to install the app you
    want to test on your Android device, and then attach that device to your computer.
    Alternatively, you could use an emulator and suitable AVD. Make sure your app
    is running and its UI is visible.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Before and after—measuring your app''s performance**'
  prefs: []
  type: TYPE_NORMAL
- en: When you discover a problem with your app, obviously you're going to want to
    fix that problem. But after you've made some changes, how do you know that the
    problem is truly fixed?
  prefs: []
  type: TYPE_NORMAL
- en: If you use TraceView to measure your app's performance before and after you
    make your changes, you'll have all the data you need to see whether your optimizations
    have had any significant impact on your app's performance. So even if you don't
    identify any code that needs optimizing, TraceView's output is still valuable
    data that you should keep to hand and refer back to as you work on optimizing
    your app.
  prefs: []
  type: TYPE_NORMAL
- en: To launch TraceView, select **Tools** from the Android Studio toolbar, followed
    by **Android** and **Android Device Monitor**. The **Android Device Monitor**
    will open in a new window.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Android Device Monitor** is a standalone tool that's included as part
    of the Android SDK. Throughout this chapter, I'll be using several tools that
    are included in the **Android Device Monitor**. Although I'll be accessing the
    **Android Device Monitor** via the Android Studio user interface throughout this
    chapter, you can also launch the **Android Device Monitor** separately. If you
    want to bypass Android Studio, or if you're using Eclipse, you can launch the
    **Android Device Monitor** by finding the `monitor` file in your Android SDK download
    and double-clicking it. The **Android Device Monitor** will then open in a new
    window.
  prefs: []
  type: TYPE_NORMAL
- en: In the **Android Device Monitor** window, select the **DDMS** tab. Along the
    left-hand side of the screen you'll find a **Devices** tab that lists all the
    currently detected devices and emulators. Select the device or AVD that contains
    your app, and you'll see a list of all the processes that are running on this
    device. Select the process you want to profile.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't see your application in the list, check it's running and that its
    UI is visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start method profiling by clicking the Start Method Profiling icon (where the
    cursor is positioned in the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Timing your code](img/B05061_9_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point, you''ll be presented with two profiling options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Trace-based profiling**: Traces the entry and exit of *every *method, no
    matter how small. This kind of profiling has a massive overhead, so you should
    only trace everything when you have absolutely no idea what to profile. You can
    then use this data to narrow your search for a follow-up round of sample-based
    profiling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sample-based profiling**: Collects the call stacks at a frequency specified
    by you. With this kind of profiling, the overhead is proportional to the sampling
    frequency, so the overhead is generally much more manageable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make your selection and TraceView will start recording. Spend some time interacting
    with your app, making sure to interact with all the sections and methods you want
    to profile. Then, click the Stop Method Profiling icon and DDMS will pull the
    trace file from your device and load it in the viewer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depending on how much recording you've done, this data may take a few moments
    to launch, so you may need to be patient.
  prefs: []
  type: TYPE_NORMAL
- en: You'll end up with a trace file that looks something like this:![Timing your
    code](img/B05061_9_2.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 'A trace file consists of:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Timeline panel:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This panel displays where each thread and method started and stopped, so you
    can track how your code is executing over time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The timeline panel displays each thread's execution on its own row, in a different
    color. You'll see a spike where each method starts (the left bar) and stops (the
    right bar). The line between these points is the amount of time it took the method
    to execute.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you spot any long lines of the same color, this is an indication that this
    method is eating up processing time and you should gather more information about
    this method. Click on any method you want to learn more about, and its stats will
    appear in the Profile panel.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Profile Panel:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This panel provides lots of information about what happened inside the currently
    selected method, including how many times that method was called, how many times
    it was called recursively, and the percentage of total CPU time used by this method,
    inclusive and exclusive of the execution time of all its child methods. This data
    helps you identify any methods that need optimizing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Identifying overdraw
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When Android draws the screen, it starts with the highest-level container and
    then draws all the children and grandchildren on top of this parent view. This
    means that an individual pixel may be drawn more than once in a single cycle,
    in a process known as **overdraw**.
  prefs: []
  type: TYPE_NORMAL
- en: Coloring pixels that are only going to end up getting covered by subsequent
    views is a waste of processing power, and the more times you paint the screen,
    the more overdraw you're adding.
  prefs: []
  type: TYPE_NORMAL
- en: Overdraw is a particular problem for mobile devices such as Android, which have
    limited memory bandwidth to begin with and may struggle with GPU-intensive drawing
    tasks. By identifying and rectifying unnecessary or excessive overdraw, you'll
    increase your app's rendering speed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Large amounts of overdraw can also indicate more serious problems with your
    user interface, so checking the amount of overdraw in your app can also point
    you in the direction of areas you should investigate further.
  prefs: []
  type: TYPE_NORMAL
- en: It's unrealistic to try and eliminate *every* instance of overdraw, as some
    areas of overdraw are normal and unavoidable. If your app has a blue background,
    then every element you place on top of that background is going to cause some
    overdraw, but this is unavoidable—can you imagine releasing an app that's just
    a single blue screen, and nothing else?
  prefs: []
  type: TYPE_NORMAL
- en: You only need to worry about excessive amounts of overdraw, such as multiple
    full-screen layers, or overdraw that doesn't contribute anything to the final
    image the user sees on screen, such as content that's completely hidden behind
    other views.
  prefs: []
  type: TYPE_NORMAL
- en: Android devices running 4.2 and higher have a built-in feature that lets you
    see the amount of overdraw present in any app installed on your Android device
    (and even the amount of overdraw present throughout the Android system, if you're
    curious about that sort of thing).
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the amount of overdraw that''s occurring in your app, install the app
    you want to test on a physical Android device running 4.2 or later. Then open
    your device''s **Settings**, followed by **Developer options**. Give **Debug GPU
    Overdraw** a tap, and select **Show overdraw areas** from the pop-up that appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying overdraw](img/B05061_9_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Debug GPU overdraw** pop-up contains a **Show areas for Deuteranomaly**
    option, which serves the same purpose as the standard **Debug GPU Overdraw**,
    but with color correction to compensate for people with deuteranopia color blindness
    (reduced sensitivity to green light).
  prefs: []
  type: TYPE_NORMAL
- en: With this option selected, the Android system colors each area of the screen
    differently, depending on how many times each pixel has been drawn and redrawn.
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying overdraw](img/B05061_9_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'These colors are your guide to areas where overdraw is a particular problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No Color = no overdraw**: These pixels were painted once.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blue**: An overdraw of 1x, so these pixels were painted twice. In other words,
    the screen was drawn once, and then drawn again on top. Although the amount of
    overdraw you can afford varies from device to device, the majority of devices
    should be able to handle a single level of overdraw. Large areas of blue are acceptable,
    but if the entire window is blue then you may want to investigate further to see
    whether you can strip away some of this overdraw.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Green**: An overdraw of 2x. These pixels were painted three times. Medium-sized
    areas of green are okay, but if more than half of your screen is green you should
    look into whether you can optimize some of this green away.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Light red**: An overdraw of 3x. Some small areas of light red may be unavoidable,
    but any medium or large areas of red are a cause for concern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dark red**: An overdraw of 4x, which means this pixel was painted at least
    five times—possibly even more! You should *always* investigate any dark red areas.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you''re investigating an area of excessive overdraw, your first stop should
    be checking out the layout''s corresponding XML file to see whether there''s any
    obvious areas of overlap. In particular, be on the lookout for:'
  prefs: []
  type: TYPE_NORMAL
- en: Any drawables that aren't visible to the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any backgrounds that are being drawn on top of one another, particularly full-screen
    backgrounds. If your UI has several layers of background before your app even
    starts drawing its content, then you're inevitability going to end up with some
    serious overdraw.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any areas that draw a white background on top of another white background.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewGroups` nested inside `ViewGroups`. Look into whether you can replace
    these multiple `ViewGroups` with a `RelativeLayout`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another tool that's useful for identifying unnecessary views and nested layouts
    is the **Hierarchy View** tool that comes with the Android SDK and is accessed
    through the **Android Device Monitor**.
  prefs: []
  type: TYPE_NORMAL
- en: Like many of the diagnostic tools I'll be using throughout this chapter, **Hierarchy
    View** can only communicate with an app that's running in an AVD or a physical
    Android device. However, unlike the other diagnostic tools, **Hierarchy View**
    can only connect to a device that's running a developer version of the Android
    operating system. If you *don't *have a developer device, you can get around this
    restriction by adding the `ViewServer` class ([https://github.com/romainguy/ViewServer](https://github.com/romainguy/ViewServer)
    ) to your project.
  prefs: []
  type: TYPE_NORMAL
- en: If you're using a physical Android device, you also need to make sure debugging
    is enabled. Open your device's **Settings**, followed by **Developer options**,
    and then drag the **Android debugging** slider to the **On** position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Android Device Monitor (by selecting **Tools** | **Android |** **Android
    Device Monitor**) and click the **Hierarchy View** button (where the cursor is
    positioned in the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying overdraw](img/B05061_9_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Select your device from the **Windows** tab and you'll see a list of all the
    Activity objects running on the selected device, listed by component name.
  prefs: []
  type: TYPE_NORMAL
- en: To populate the various **Hierarchy View** panes, click the blue **load the
    view hierarchy into the tree view** icon. Depending on how complex your app's
    view hierarchy is, the tree may take some time to load.
  prefs: []
  type: TYPE_NORMAL
- en: Once your project's **Hierarchy View** has loaded, you may want to spend some
    time exploring that hierarchy in the various windows (I'll be discussing these
    in more detail in the next section), but one of the quickest and easiest ways
    of identifying large areas of overdraw is to export the Activity's hierarchy as
    a Photoshop document.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a PSD document from the **Hierarchy View** output, each `View`
    is displayed as a separate layer. This means you can use the PSD document to peel
    back each layer of your app, and see exactly what each layer is contributing to
    your UI. Inspecting each layer can help you identify sources of overdraw, or if
    you already suspect that certain areas of your app are suffering from overdraw,
    then you can put your theory to the test by hiding the different layers and seeing
    how this impacts the final rendered image the user sees on screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'To export your hierarchy as a Photoshop document, click the **Capture the window
    layers as a Photoshop document** icon (where the cursor is positioned in the following
    screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying overdraw](img/B05061_9_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This button generates a PSD file that you can inspect in Adobe Photoshop or
    in any image-editing tool that supports PSD files, such as the free and open source
    Gimp program ([https://www.gimp.org](https://www.gimp.org)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying overdraw](img/B05061_9_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Examining the layers of our application in GIMP
  prefs: []
  type: TYPE_NORMAL
- en: Spend some time exploring the different layers that make up your UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'This PSD document is particularly useful for identifying one of the major causes
    of overdraw: multiple white backgrounds. Multiple white backgrounds can be difficult
    to spot, so one trick is to replace the white backgrounds in your PSD file with
    different images. You can then check what portions of these images are visible
    as you move through the different layers of your UI.'
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying your Hierarchy View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another common cause of performance problems is your app's **Hierarchy View**.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the Android system renders each view, it goes through three stages: measure,
    layout, and draw. The time it takes the system to complete each stage is affected
    by the number of views in your hierarchy, and how these views are arranged.'
  prefs: []
  type: TYPE_NORMAL
- en: Arranging your views in deeper, more complex, hierarchies will have a noticeable
    impact on your app's rendering speed. You should be on the lookout for any opportunities
    to flatten your view hierarchy and remove nested layouts.
  prefs: []
  type: TYPE_NORMAL
- en: As well as highlighting areas of overdraw, **Hierarchy View** helps you visualize
    your app's view hierarchy and provides some really useful performance information
    about how long each view takes to render.
  prefs: []
  type: TYPE_NORMAL
- en: The **Hierarchy View** tool consists of three different windows.
  prefs: []
  type: TYPE_NORMAL
- en: Tree View
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This window provides a bird''s eye view of the currently selected Activity''s
    view hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tree View](img/B05061_9_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Each node in Tree View represents a single `View`. When you select a node,
    additional information about that `View` appears in a small window above the node:'
  prefs: []
  type: TYPE_NORMAL
- en: '**View class**: The object''s class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View object address**: A pointer to the `View` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View object ID**: The value of the object''s `android:id` attribute'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You'll also see a preview of how this `View` will appear on an Android device.
    By seeing exactly what each `View` is contributing to the final UI, you can decide
    whether this `View` is adding anything of value. If it isn't, then you should
    remove it from your app.
  prefs: []
  type: TYPE_NORMAL
- en: Tree overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This window contains a map representation of the Activity''s entire view hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tree overview](img/B05061_9_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This high-level view of your hierarchy structure is particularly useful for
    seeing just how complex your view hierarchy really is, as well as helping you
    identify nested layouts and other opportunities to flatten your layout.
  prefs: []
  type: TYPE_NORMAL
- en: Layout View
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This window displays a skeleton of your Activity's UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you select a node in either the **Tree View** or **Tree Overview** window,
    the **Layout View** highlights the areas that this `View` paints. Again, this
    helps you weed out redundant `Views`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Layout View](img/B05061_9_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: While **Hierarchy View** is great for spotting nested layouts and redundant
    views, there are some view hierarchy issues that you can't spot just by looking
    at these three windows.
  prefs: []
  type: TYPE_NORMAL
- en: To help you identify any problems that may be lurking beneath the surface, you
    can use the **Hierarchy View** tool to measure how long it takes each `View` to
    move through each phase of the rendering process (measure, layout, and draw).
    Armed with this information, you'll know exactly what `Views` you need to optimize.
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchy View's **Tree Overview** doesn't display render times by default.
    To add this information to the **Tree Overview**, you need to select the root
    node of the part of the tree you want to profile. Then click the green, red, and
    purple Venn diagram icon (when you hover over this icon, you'll see an **Obtain
    layout times for tree rooted at selected node** tooltip).
  prefs: []
  type: TYPE_NORMAL
- en: After a few moments, three colored dots will appear on each node within this
    section of the view hierarchy. These dots indicate the rendering speed of this
    `View` relative to the other profiled `Views`.
  prefs: []
  type: TYPE_NORMAL
- en: 'From left to right, these dots indicate the time it takes to:'
  prefs: []
  type: TYPE_NORMAL
- en: Measure the view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layout the view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Draw the view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The color of each dot indicates the time it takes the `View` to move through
    each phase of the rendering process:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Green**: This view is faster than at least half of the other profiled nodes.
    A green dot in the measure position means that this view has a faster layout time
    than at least 50% of the other profiled nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Yellow**: This view is in the slowest 50% of all the profiled nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Red**: This view is the slowest out of all the profiled nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use this information to identify which `Views` are the slowest to measure,
    layout, and draw, so you not only know which `Views` you need to optimize but
    also the part of the rendering process you should be focusing on.
  prefs: []
  type: TYPE_NORMAL
- en: When you click a profiled node you'll also see the measure, layout, and draw
    times for that `View`, displayed in milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: '![Layout View](img/B05061_9_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Just remember that these performance indicators are relative to one another,
    so your view hierarchy is always going to include some red and yellow nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Before you start looking for ways to optimize `Views` with yellow and red dots,
    ask yourself whether these `Views` have a good reason for rendering more slowly,
    for example views that have more children are always going to lag behind nodes
    that have less children.
  prefs: []
  type: TYPE_NORMAL
- en: Spotting memory leaks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android may be a memory-managed environment, but you still need to scrutinize
    how your app is handling memory.
  prefs: []
  type: TYPE_NORMAL
- en: '**Garbage collection** (**GC**) can *only* remove objects that it recognizes
    as unreachable. If your app allocates objects that the Android system doesn''t
    identify as unreachable, then those objects are never going to get garbage collected.
    They''re going to hang around, polluting your heap, and taking up valuable space.'
  prefs: []
  type: TYPE_NORMAL
- en: As your app continues to leak objects that the system can't garbage collect,
    the amount of usable space will get smaller and smaller. The Android system will
    try to compensate for this shrinking memory by running longer and more frequent
    GC events.
  prefs: []
  type: TYPE_NORMAL
- en: While your typical GC event won't have a noticeable impact on your app's performance,
    as more and longer GC events start occurring in a small space of time, your users
    may notice a drop in performance, and may even encounter an `OutOfMemoryError`.
  prefs: []
  type: TYPE_NORMAL
- en: Memory leaks can be difficult to detect, but the Android SDK comes with several
    tools that you can use to scour your app for those sometimes subtle signs of memory-management
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: Memory monitor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Memory monitor tracks your app's memory usage over time. This is another tool
    that can only communicate with a running app, so make sure to install your app
    on a physical device or an emulator before you proceed.
  prefs: []
  type: TYPE_NORMAL
- en: You can access memory monitor from the main Android Studio screen by selecting
    the **Android Monitor** tab towards the bottom of the screen, and then selecting
    the **Memory** tab.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the app you want to test is visible onscreen. As soon as memory monitor
    detects your running app, it'll start recording memory usage, displaying the memory
    your app is using in dark blue and the unallocated memory in light blue.
  prefs: []
  type: TYPE_NORMAL
- en: '![Memory monitor](img/B05061_9_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Troubleshooting**'
  prefs: []
  type: TYPE_NORMAL
- en: If Memory Monitor displays a **No debuggable applications** message, open Android
    Studio's **Tools** menu, select **Android,** and make sure **Enable adb integration**
    is selected. This feature can be temperamental, so if it doesn't work at first
    then try the *very* high-tech solution of toggling **Enable adb integration**
    on and off a few times. If you're using a physical Android device, it may also
    help to disconnect your device and reconnect it to a different USB port.
  prefs: []
  type: TYPE_NORMAL
- en: Spend some time interacting with your app while keeping an eye on memory monitor.
    Eventually your app's memory usage will swell until there's no unallocated memory
    left. At this point, the system will free up some memory by triggering a GC event,
    causing the allocated memory to drop.
  prefs: []
  type: TYPE_NORMAL
- en: Most GC events are perfectly normal, but if you see GC events becoming longer
    and more frequent then this is an indication that a memory leak may be occurring
    in your app.
  prefs: []
  type: TYPE_NORMAL
- en: If you track a suspected memory leak over a period of time, you may eventually
    see the Android system try to accommodate your app's insatiable thirst for memory
    by granting it a higher memory ceiling. If you see this happening in memory monitor,
    then this is a sign that a serious memory leak is occurring in your app, and you
    should investigate it in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Heap tab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you spot strange memory usage in the memory monitor, you can use the Android
    Device Monitor's Heap tab to gather more information about how your app is using
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, this tab provides data about your app's heap usage, including
    the kind of objects your app is allocating, the number of allocated objects, and
    how much space these objects are taking up.
  prefs: []
  type: TYPE_NORMAL
- en: Android smartphones and tablets have a finite amount of heap space that can
    only accommodate a certain number of objects. As the heap grows, the Android system
    will try to free up memory by triggering a GC event—which we already know is bad
    news for performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the heap tab, launch the **Android Device Monitor**, select the **DDMS**
    tab, and then select your device or AVD from the **Devices** panel, followed by
    the process you want to examine. Click the **Update heap** button (where the cursor
    is positioned in the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Heap tab](img/B05061_9_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Select the **Heap** tab and spend some time interacting with your app.
  prefs: []
  type: TYPE_NORMAL
- en: The heap output is only displayed after a GC event has occurred, so you'll either
    have to be patient and wait for an organic GC event, or you can force a GC event
    by clicking the **Cause GC** button. Once a GC has occurred, the Heap tab will
    display information about your app's heap usage.
  prefs: []
  type: TYPE_NORMAL
- en: '![Heap tab](img/B05061_9_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Spend some time interacting with your app, triggering GC events before *and*
    after you perform different actions so you can compare how these actions impact
    the heap. In this way, you can isolate the actions that are causing the memory
    leak, as well as any other memory-related problems your app is experiencing.
  prefs: []
  type: TYPE_NORMAL
- en: When you're tracking down problems in your app's heap, it may to help to generate
    a HPROF file, which is a snapshot of all the objects in your app's heap plus detailed
    information about the related classes and instances.
  prefs: []
  type: TYPE_NORMAL
- en: Once you've generated a HPROF file, you can view it in Android Studio or in
    a separate profiling tool, such as the Eclipse Memory Analyzer ([http://www.eclipse.org/mat](http://www.eclipse.org/mat)).
  prefs: []
  type: TYPE_NORMAL
- en: To retrieve a HPROF file, click the **Dump HPROF** icon (next to the **Update
    Heap** icon). Give your file a name and save it.
  prefs: []
  type: TYPE_NORMAL
- en: To analyze your heap dump in Android Studio, open your HPROF file as a new Android
    project. Android Studio will automatically open the file in its Android Memory
    HPROF Viewer, ready for you to analyze in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: '![Heap tab](img/B05061_9_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Object allocation – understanding memory churn
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another common memory problem that you should check for is memory churn.
  prefs: []
  type: TYPE_NORMAL
- en: Memory churn occurs when your app allocates lots of temporary objects in a short
    period of time, which can quickly gobble up a device's available memory, triggering
    those performance-sapping GC events.
  prefs: []
  type: TYPE_NORMAL
- en: You can check for memory churn using the Android SDK's **Allocation Tracker**,
    which lists all the objects your app is allocating to memory when you perform
    different actions. If you spot any suspicious-looking allocations, you can then
    use **Allocation Tracker** to inspect the classes and threads that are responsible
    for allocating these objects.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the Android Device Monitor, select the **DDMS** tab and then open the **Allocation
    Tracker** tab. Select your device or AVD from the **Devices** tab, followed by
    the process you want to examine.
  prefs: []
  type: TYPE_NORMAL
- en: In the **Allocation Tracker** tab, click the **Start Tracking** button and spend
    some time interacting with your app. To see a list of all the objects that have
    been allocated since you started tracking, click the **Get Allocation**s button.
    Android Studio will then open a tab that displays all the allocations that occurred
    during this sampling period.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on any allocated object to see more information about that object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Object allocation – understanding memory churn](img/B05061_9_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you're ready to stop collecting data, click the **Stop Tracking** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each row in the **Allocation Tracking** tab represents a specific allocation,
    and provides the following information for that allocation:'
  prefs: []
  type: TYPE_NORMAL
- en: Allocation order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allocation size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allocated class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread ID. This is the thread that made the allocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allocated In. This is the function in your code that's responsible for this
    allocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging your project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's crucial that you thoroughly test your app for bugs before releasing it.
    Android Studio provides a range of tools that you can use to debug an app running
    on an emulator or a physical Android device, although these tools can only test
    a debuggable version of your app, which means you'll need to run your app in debug
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run your app in debug mode, open your project''s module-level `build.gradle`
    file and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After editing your Gradle build file, make sure you sync your project. Next,
    click the **Debug** icon or select **Run** from the Android Studio toolbar, followed
    by **Debug**.
  prefs: []
  type: TYPE_NORMAL
- en: Select the AVD or physical Android device where you want to install and test
    the debuggable version of your app. Once your app has loaded, Android Studio's
    **Debug** perspective should open automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the **Debug** perspective doesn't open automatically, select **View** from
    the Android Studio toolbar, followed by **Tool window** and **Debug**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Debug perspective consists of:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Debugger**: Displays threads and variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Console**: Displays the device status'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To debug an app that's already running, click **Attach debugger to Android process**.
    In the **Choose Process** window, select the device and the app you want to attach
    the debugger to and then click **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have a debuggable version of your app up and running, you can view
    the log messages related to your application. To view these messages, select the
    **Android Monitor** tab that appears along the bottom of the Android Studio screen
    and then select the l**ogcat** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging your project](img/B05061_9_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Logcat can sometimes be a case of information overload, so Android Studio provides
    several ways of filtering the logcat output. One method is to use the **Log Level**
    drop-down menu. By default, this menu is set to **Verbose**, which displays all
    log messages, but there are several more specific options you can choose from:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Debug**: Displays log messages that are useful during development, plus message
    levels lower in this list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Info**:Displays expected log messages for regular usage, plus message levels
    lower in this list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Warn**:Displays possible issues that are not yet errors, plus message levels
    lower in this list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error**: Displays issues that have caused errors, plus message levels lower
    in this list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assert**: Displays issues that should *never* happen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If none of these filters meet your debugging needs, you can create custom filters.
    Open the **Show only selected application** dropdown (towards the right side of
    the **logcat** panel) and then select **Edit Filter Configuration**.
  prefs: []
  type: TYPE_NORMAL
- en: 'This opens a **Create New LogCat Filter** window, where you can craft a new
    filter by providing the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filter name**: If you''re creating a new filter, you should give this filter
    a unique name. If you''re modifying an existing filter, select it from the left-hand
    pane and its name will appear in this field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log Tag**: Every log message has a tag associated with it, which indicates
    the system component the message originated from. If you want to see messages
    that originate from a certain system component only, you can enter that component''s
    tag here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log Message**: If you only want to see messages that contain certain elements
    or character strings, specify them in the **Log Message** field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Package Name**: If you want your filter to display messages that relate to
    a certain package only, enter this package name here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PID**: If you only want to see messages that refer to a specific process,
    enter that process ID here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log Level**: To filter based on log level, open this dropdown and select
    anything other than the default **Verbose** option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with breakpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having trouble working out where an error is originating from? You can use breakpoints
    to pause the execution of your app at a particular line of code. By creating multiple
    breakpoints and scrutinizing your app every time it comes to a stop, you can gradually
    isolate the portion of code that's responsible for the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set a breakpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the file where you want to create your breakpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the line where you want to set your breakpoint and click on this line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the yellow portion that appears in the left-hand sidebar. A red dot will
    appear, indicating that you've successfully created a breakpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Working with breakpoints](img/B05061_9_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After creating your breakpoints, click the Rerun app icon (the green **Play**
    icon along the left-hand toolbar).
  prefs: []
  type: TYPE_NORMAL
- en: Every time Android Studio reaches a breakpoint, it'll pause the execution of
    your app and highlight the triggered breakpoint in your code. You can then open
    the **Debug** window (by selecting the **Debug** tab in the bottom toolbar) and
    use the debugger and console to gather more information about what's going on
    in your app at this exact point in the execution of your code. You may also want
    to take a look at the **logcat** output. Repeat this process until you've isolated
    the code that's causing the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring your breakpoints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you have a very specific kind of breakpoint in mind, you can make some changes
    to your breakpoint settings. Start by clicking the **View Breakpoints** icon (where
    the cursor is positioned in the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring your breakpoints](img/B05061_9_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Breakpoint window appears and lists all the breakpoints you've created in
    the current project. To see what changes you can make to a breakpoint, select
    that breakpoint from the left-hand list.
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring your breakpoints](img/B05061_9_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This window gives you lots of different options for configuring the selected
    breakpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Suspend**: Select this checkbox to enable a suspend policy for this breakpoint,
    then choose from **All** (when a breakpoint is hit, all threads are suspended)
    or **Thread** (when a breakpoint is hit, only the thread where the breakpoint
    is hit is suspended).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Condition**: Select this checkbox, then in the accompanying textbox specify
    a condition for hitting this breakpoint. The condition must be a Java Boolean
    expression with a `true/false` value. This condition is evaluated each time the
    breakpoint is reached, and if the result is true the specified action is performed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log message to console**: Select this checkbox to display a log message in
    the console when this breakpoint is hit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log evaluated expression**: Select this checkbox to evaluate an expression
    when this breakpoint is hit and display the results in Android Studio''s console.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remove once hit**: When enabled, this breakpoint will be triggered once and
    then removed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disabled until the selected breakpoint is hit**: This breakpoint is dependent
    on another breakpoint, and will only be enabled once the specified breakpoint
    has been triggered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instance filters**: To limit breakpoint hits to instances of a particular
    object, select this checkbox and then provide the ID value of the instance you
    want to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class filters**: Select this checkbox to have this breakpoint behave differently
    in reaction to different classes. Then, specify the classes that''ll trigger the
    breakpoint in the accompanying textbox. To define classes where the breakpoint *shouldn''t*
    be triggered, add these classes to the textbox but preface them with a minus symbol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pass count**: Define the number of times a breakpoint should be reached,
    but ignored, by selecting this checkbox and then specifying the number of times
    the breakpoint should be skipped. After the specified number of passes, the breakpoint
    will be triggered as normal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining your code with Lint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's important to check that there are no problems with the structural quality
    of your code, as these can cause errors and have a negative impact on your app's
    performance. Conveniently, the Android SDK comes with Lint, a static code-scanning
    tool that's *perfect* for identifying and correcting structural problems with
    your code.
  prefs: []
  type: TYPE_NORMAL
- en: In Android Studio, the configured Lint expressions run every time you build
    your app and print the output to Android Studio's **Events log**, which you can
    access by selecting the **Events log** tab.
  prefs: []
  type: TYPE_NORMAL
- en: However, you can also run Lint on a specific module at any time, by right-clicking
    on that module's file or folder and then selecting **Analyze** **| ** **Inspect
    code,** followed by the area you want to inspect (**Whole project, ** **Module**,
    or **Custom Scope**). Make your selection, and Android Studio automatically opens
    a new **Inspection** tab where you can view the Lint output.
  prefs: []
  type: TYPE_NORMAL
- en: To help you zero in on critical problems, Lint provides a description and a
    severity level for every issue it reports.
  prefs: []
  type: TYPE_NORMAL
- en: '![Examining your code with Lint](img/B05061_9_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Make sure you correct *all* errors that Lint detects before you release your
    app.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to make some changes to the default Lint settings, select **Android
    Studio** from the toolbar, followed by **Preferences**. In the window that appears,
    double-click **Editor** and select **Inspections**.
  prefs: []
  type: TYPE_NORMAL
- en: This opens the **Inspection Configuration** page, which lists all the supported
    Lint profiles and inspections.
  prefs: []
  type: TYPE_NORMAL
- en: '![Examining your code with Lint](img/B05061_9_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, you can explore the different inspections and make edits such as changing
    their severity level and scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also run Lint inspections for a specific build variant or for all build
    variants, by adding the `lintOptions` property to your project''s module-level `build.gradle`
    file. For example, if you wanted to set your Lint''s `abortOnError` option to `false`,
    you''d need to add the following to your `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can find a complete list of all your Lint configuration options at Google's
    GitHub ([http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.LintOptions.html#com.android.build.gradle.internal.dsl.LintOptions](http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.LintOptions.html#com.android.build.gradle.internal.dsl.LintOptions)).
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing your code with ProGuard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ProGuard tool shrinks and optimizes your code by removing unused code and
    renaming classes, fields, and methods with semantically obscure names. The end
    result is a smaller `APK` that's more difficult to reverse engineer, something
    that's particularly important if your app has access to sensitive information.
  prefs: []
  type: TYPE_NORMAL
- en: 'ProGuard runs automatically when you build your app in release mode. To build
    a release version of your app, you need to enable the `minifyEnabled` property
    in your project''s module-level `build.gradle` file and make sure `buildTypes`
    is set to `release`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `getDefaultProguardFile` attribute obtains the default ProGuard settings
    specified in the `Android/sdk/tools/proguard/proguard-android.txt` file that you
    downloaded as part of the Android SDK. Alternatively, you can use the `proguard-android-optimize.txt`
    file, which contains the same rules but has optimization enabled.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to add some project-specific options to the default ProGuard settings,
    open your project's `Gradle Scripts/proguard-rules.pro` file and add your new
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the different ProGuard settings that you can add
    to this file, check out the ProGuard manual ( [https://stuff.mit.edu/afs/sipb/project/android/sdk/android-sdk-linux/tools/proguard/docs/index.html#manual/retrace/examples.html](https://stuff.mit.edu/afs/sipb/project/android/sdk/android-sdk-linux/tools/proguard/docs/index.html#manual/retrace/examples.html)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: Scrutinize each pixel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another tool you may want to explore is **Pixel Perfect**.
  prefs: []
  type: TYPE_NORMAL
- en: The **Pixel Perfect** window displays a magnified version of the screen that's
    currently visible on the attached Android device or emulator, and lets you scrutinize
    the individual pixels that make up your UI. You can also use it to overlay an
    image over your UI, which is handy for checking how your UI compares to your digital
    wireframes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Pixel Perfect** is integrated into the **Android Device Monitor**. To launch
    **Pixel Perfect**, select **Window** from the **Android Device Monitor** toolbar,
    followed by **Open Perspective**, **Pixel Perfect,** and **OK**.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scrutinize each pixel](img/B05061_9_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **Pixel Perfect** window contains the following areas.
  prefs: []
  type: TYPE_NORMAL
- en: Pixel Perfect pane
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This window displays a magnified version of the UI that's currently visible
    on the connected Android device or AVD.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Pixel Perfect doesn't update automatically to reflect changes that
    occur on screen, so you'll need to keep clicking this pane's **Refresh Screenshot**
    icon. Alternatively, if you want Pixel Perfect to update automatically, then select
    the **Automatically Refresh the screenshot** icon.
  prefs: []
  type: TYPE_NORMAL
- en: One of Pixel Perfect's most useful features is the ability to load `jpg`, `jpeg`, `png`, `gif`,
    or `bmp` images as an overlay. This is particularly useful if you want to take
    stock of how the current screen compares to your original design, as you can load
    a digital wireframe (or any other digital design docs you have to hand) as an
    overlay.
  prefs: []
  type: TYPE_NORMAL
- en: To load an image as an overlay, navigate to the screen you want to work with
    and make sure it's being displayed in the Pixel Perfect window. Select the **Load
    an image to overlay the screenshot** icon, and then select the image you want
    to use as your overlay.
  prefs: []
  type: TYPE_NORMAL
- en: Pixel Perfect tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a hierarchical list of all the `View` objects that are currently visible.
    Just be aware that system objects also appear in this list.
  prefs: []
  type: TYPE_NORMAL
- en: Pixel Perfect Loupe pane
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pane contains the magnified screen image, overlaid by a grid where one
    square represents one pixel. To see more information about a particular pixel,
    select it and the Loupe pane will display the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pixel swatch**: A rectangle filled with the same color as the selected pixel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTML color code**: The pixel''s corresponding hexadecimal RGB code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RGB color values**: The pixel''s R, G, and B color values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**X and Y coordinates**: The pixel''s coordinates, as a px value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processes and threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How your app handles threads and processes has a significant impact on your
    app's performance. By default, when the user launches an app, the Android system
    creates a single thread of execution for that application. All components run
    in this single thread, which is known as the *main* thread or the *UI* thread.
  prefs: []
  type: TYPE_NORMAL
- en: Unless you specify otherwise, most of the operations you perform in your app
    run in the foreground on this main thread. Most of the time this single-thread
    model works fine, but if your app needs to perform particularly intensive work
    or long-running operations, then the main thread can become blocked. This can
    cause your app to freeze, display system errors, and potentially even crash.
  prefs: []
  type: TYPE_NORMAL
- en: If you're going to deliver a good user experience, then it's vital you don't
    block the UI thread with intensive or long-running operations. If you do need
    to run demanding processes, then you should create additional threads.
  prefs: []
  type: TYPE_NORMAL
- en: This involves specifying which process a certain component belongs to in your
    project's `Manifest` file. The `Manifest` entry for each type of component (activity,
    service, receiver, or provider) includes an `android:process` attribute that specifies
    the process where this component should run. If you want the system to create
    a new process for this component, preface the `android:process` value with a colon,
    for example `android:process=":myprocess"`.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to handle more complex interactions, you may want to consider using
    a `Handler` to process messages delivered from the main thread, or you could use
    the `AsyncTask` class to simplify the execution of worker thread tasks that need
    to interact with your UI.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Using AsyncTask**'
  prefs: []
  type: TYPE_NORMAL
- en: '`AsyncTask` provides you with an easy way of performing synchronous work on
    your user interface without blocking the main thread. Using `AsyncTask`, you can
    separate tasks into the work that should be performed on the main thread and operations
    that should be performed on a separate worker thread. In this way, `AsyncTask`
    is a way of executing some work in a background thread and then publishing the
    results back to the main thread.'
  prefs: []
  type: TYPE_NORMAL
- en: To use `AsyncTask`, you need to subclass `AsyncTask` and then implement the `doInBackground()`
    callback method, which executes automatically on a worker thread and performs
    background operations. The value returned by `doInBackground()` is then sent to `onPostExecute()`,
    and from here you can run the task by calling `execute()` on the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, you should only use `AsyncTasks` for short operations. If you need
    to keep threads running for more than a few seconds, it's recommended that you
    use APIs such as `Executor`, `ThreadPoolExecutor,` and `FutureTask`, which are
    provided as part of the `java.util.concurrent` package.
  prefs: []
  type: TYPE_NORMAL
- en: Terminating processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When deciding how your application should handle processes, it's worth bearing
    in mind that even though the Android system will try and maintain all processes
    for as long as possible, it will kill off processes if memory starts getting low.
  prefs: []
  type: TYPE_NORMAL
- en: When deciding what processes to keep alive and which processes to terminate,
    the system decides how important each process is to the user by placing these
    processes in an **importance hierarchy**. Processes with the lowest importance
    are the first to go, while processes at the top of the importance hierarchy are
    rarely killed off.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Android system will increase the ranking of a process if another, more important,
    process depends on it. A process that's supporting another process can *never *be
    ranked lower than the most important process it's supporting.
  prefs: []
  type: TYPE_NORMAL
- en: Ranked from most important to least important, the different levels of Android's
    importance hierarchy are detailed in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Foreground processes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is a process that''s essential for the actions the user is currently performing.
    The Android system assigns a process this ranking if it hosts either:'
  prefs: []
  type: TYPE_NORMAL
- en: An `Activity` that the user is interacting with
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Service` that's running in the foreground
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Service` that's bound to the activity the user is currently interacting with
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Service` that's executing one of its lifecycle callbacks (`onCreate`, `onStart`,
    or `onDestroy`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `BroadcastReceiver` that's executing its `onReceive()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If any of these conditions are true, that process is considered a foreground
    process. The Android system only kills foreground processes as a very last resort.
  prefs: []
  type: TYPE_NORMAL
- en: Visible processes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a process that doesn't have any foreground components but may still
    affect what the user is seeing on screen. The Android system assigns this ranking
    if the process hosts a `Service` that's bound to a visible Activity, or an Activity
    that's not in the foreground but is still visible to the user, for example an
    Activity where the `onPause()` method has been called.
  prefs: []
  type: TYPE_NORMAL
- en: The Android system will only kill a visible process if there's not enough memory
    to support all foreground processes.
  prefs: []
  type: TYPE_NORMAL
- en: Service processes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a process that's running a `Service`, but doesn't fall into either of
    the two higher categories.
  prefs: []
  type: TYPE_NORMAL
- en: Although service processes are not directly related to anything the user sees,
    they usually perform actions that the user cares about. The system will avoid
    killing service processes unless doing so is the only way to keep all foreground
    and visible processes running.
  prefs: []
  type: TYPE_NORMAL
- en: Background processes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Background processes hold an Activity that's not currently visible to the user.
    Since background processes don't have a direct impact on the user experience,
    the system may kill background processes off at any time if it needs to reclaim
    memory for foreground, visible, or service processes.
  prefs: []
  type: TYPE_NORMAL
- en: Empty processes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a process that doesn't hold any active components. The system may keep
    empty processes alive for caching purposes, but make no mistake, they're the first
    to go if the system needs to free up some memory.
  prefs: []
  type: TYPE_NORMAL
- en: Re-using layouts with > and <merge/>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Android platform provides a range of simple, reusable UI components known
    as widgets, but sometimes there may be larger or more complex UI components that
    you need to reuse across multiple screens, such as a panel containing a progress
    bar and a **Cancel** button, or a user profile consisting of a username and an
    avatar.
  prefs: []
  type: TYPE_NORMAL
- en: If your project features elements that you want to use multiple times, you can
    save yourself time and effort by implementing these elements as a reusable layout.
    You can then import these reusable elements into as many layout files as you want,
    using Android's `>` and `<merge/>` tags.
  prefs: []
  type: TYPE_NORMAL
- en: To extract common elements into a reusable layout, create a new XML layout resource
    file and then define the UI elements you want to reuse. Pay special attention
    to the file's root view as this will also be included every time you embed this
    component in other layouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'To import your reusable component into a layout resource file, just add the
    `include` tag and reference the layout file you want to import. For example, if
    you''d created a reusable layout called `contactslist` and wanted to import this
    component into another layout, you''d use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: However, be aware that using the `include` tag can introduce redundant `ViewGroups`
    into your view hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you have a layout called `main_layout.xml` that uses a vertical `LinearLayout`
    as its root view. You have a re-usable `contactslist_layout.xml` component that
    you want to include in this `main_layout` file, but the `contactslist_layout`
    also uses a vertical `LinearLayout` as its root view.
  prefs: []
  type: TYPE_NORMAL
- en: If you include `contactslist_layout.xml` in your main layout, you're going to
    end up with a vertical `LinearLayout` inside a vertical `LinearLayout`. This duplicate
    vertical layout isn't contributing anything to the UI, but it *is* making your
    view hierarchy more complex and potentially slowing down your app. So how do we
    get rid of this duplicate `LinearLayout`? The answer is by using the `merge` tag.
  prefs: []
  type: TYPE_NORMAL
- en: The `merge` element helps to eliminate the redundant `ViewGroups` that can work
    their way into your view hierarchy when you include reusable layouts.
  prefs: []
  type: TYPE_NORMAL
- en: When you use the `merge` element as the root view of a reusable layout, the `LayoutInflator`
    skips the `merge` tag and inserts the reusable views into the `main_layout` as
    though they've always been part of that layout. As a result, your view hierarchy
    is simpler—which is nothing but good news for your app's performance!
  prefs: []
  type: TYPE_NORMAL
- en: Loading views only when needed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Depending on your app, you may find yourself with a user interface that contains
    a large number of complex views that you rarely use, such as pop-ups and progress
    indicators.
  prefs: []
  type: TYPE_NORMAL
- en: One possible solution to this problem is to add some of these complex `Views`
    via a `ViewStub`, which is a variation of the `include` tag. A `ViewStub` is a
    lightweight view that isn't included in your layout directly, so it's very cheap
    to keep in your view hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: When you add a `View` via a `ViewStub`, the `ViewStub` only loads the `View`
    as and when it's needed. This allows you to create complex layouts consisting
    of lots of small views, and your UI will still render quickly and smoothly as
    you're not immediately populating your user interface with lots of complex `Views`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a `ViewStub`, you need to specify the layout you want to inflate using
    the `android:id` attribute, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When it''s time to load your `ViewStub''s` layout, you just need to set the `ViewStub`
    to visible. To do this, either change the visibility of the stub by calling `setVisibility(View.VISIBLE)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Or invoke the `inflate()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The inflated layout replaces the `ViewStub`, and at this point the `ViewStub`
    element is no longer part of your view hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ViewStub` currently doesn''t support the `merge` tag in the layouts to be
    inflated.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I covered some of the most common performance problems you
    need to be aware of when developing Android apps, including overdraw, memory leaks,
    and complex view hierarchies.
  prefs: []
  type: TYPE_NORMAL
- en: We took an in-depth look at numerous tools you can use to check whether some
    of the most common performance problems are affecting your Android projects. We
    also looked at how to gather more information about any problems you *do* diagnose,
    so you're in a better position to fix them.
  prefs: []
  type: TYPE_NORMAL
- en: There's just one chapter left to go! In the final chapter, I'm going to cover
    all the best practices and guidelines that didn't fit neatly into any of the previous
    chapters. And since security is such a big concern for mobile users and developers
    at the moment, I'll also show you how to lock down your UI (and your app in general)
    so you can be confident that your app isn't leaving users open to security vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
