["```java\n-- Public Method: saveValue() --> save single-line file (replace contents) \nfunction saveValue( strFilename, strValue )\n-- will save specified value to specified file\nlocal theFile = strFilename\nlocal theValue = strValue\nlocal path = system.pathForFile( theFile, system.DocumentsDirectory )\n-- io.open opens a file at path. returns nil if no file found\n-- \"w+\": update mode, all previous data is erased\nlocal file = io.open( path, \"w+\" )\nif file then\n-- write game score to the text file\nfile:write( theValue )\nio.close( file )\nend\nend\n-- Public Method: loadValue() --> load single-line file and store it into variable\nfunction loadValue( strFilename )\n-- will load specified file, or create new file if it doesn't exist\nlocal theFile = strFilename\nlocal path = system.pathForFile( theFile, system.DocumentsDirectory )\n-- io.open opens a file at path. returns nil if no file found\n-- \"r\": read mode\nlocal file = io.open( path, \"r\" )\nif file then\n-- read all contents of file into a string\n-- \"*a\": reads the whole file, starting at the current position\nlocal contents = file:read( \"*a\" )\nio.close( file )\nreturn contents\nelse\n-- create file b/c it doesn't exist yet\n-- \"w\": write mode\nfile = io.open( path, \"w\" )\nfile:write( \"0\" )\nio.close( file )\nreturn \"0\"\nend\nend\n\n```", "```java\nlocal path = system.pathForFile( \"Icon.png\", system.ResourceDirectory )\n\n```", "```java\n    local highScoreText\n    local highScore\n\n    ```", "```java\n    local saveValue = function( strFilename, strValue )\n    -- will save specified value to specified file\n    local theFile = strFilename\n    local theValue = strValue\n    local path = system.pathForFile( theFile, system.DocumentsDirectory )\n    -- io.open opens a file at path. returns nil if no file found\n    local file = io.open( path, \"w+\" )\n    if file then\n    -- write game score to the text file\n    file:write( theValue )\n    io.close( file )\n    end\n    end\n\n    ```", "```java\n    local loadValue = function( strFilename )\n    -- will load specified file, or create new file if it doesn't exist\n    local theFile = strFilename\n    local path = system.pathForFile( theFile, system.DocumentsDirectory )\n    -- io.open opens a file at path. returns nil if no file found\n    local file = io.open( path, \"r\" )\n    if file then\n    -- read all contents of file into a string\n    local contents = file:read( \"*a\" )\n    io.close( file )\n    return contents\n    else\n    -- create file b/c it doesn't exist yet\n    file = io.open( path, \"w\" )\n    file:write( \"0\" )\n    io.close( file )\n    return \"0\"\n    end\n    end\n\n    ```", "```java\n    if gameScore > highScore then\n    highScore = gameScore\n    local highScoreFilename = \"highScore.data\"\n    saveValue( highScoreFilename, tostring(highScore) )\n    end\n\n    ```", "```java\n    highScoreText = display.newText( \"Best Game Score: \" .. tostring( highScore ), 0, 0, \"Arial\", 30 )\n    highScoreText:setTextColor( 255, 255, 255, 255 )\n    highScoreText.xScale = 0.5; highScoreText.yScale = 0.5\n    highScoreText.x = 240\n    highScoreText.y = 120\n    gameGroup:insert( highScoreText )\n\n    ```", "```java\n    local highScoreFilename = \"highScore.data\"\n    local loadedHighScore = loadValue( highScoreFilename )\n    highScore = tonumber(loadedHighScore)\n\n    ```", "```java\n    -- Place near other game variables\n    local pauseBtn\n    local pauseBG\n    -- Place after gameOverSound\n    local btnSound = audio.loadSound( \"btnSound.wav\" )\n\n    ```", "```java\n    local onPauseTouch = function( event )\n    if event.phase == \"release\" and pauseBtn.isActive then\n    audio.play( btnSound )\n    -- Pause the game\n    if gameIsActive then\n    gameIsActive = false\n    physics.pause()\n    local function pauseGame()\n    timer.pause( startDrop )\n    print(\"timer has been paused\")\n    end\n    timer.performWithDelay(1, pauseGame)\n    -- SHADE\n    if not shade then\n    shade = display.newRect( 0, 0, 570, 380 )\n    shade:setFillColor( 0, 0, 0, 255 )\n    shade.x = 240; shade.y = 160\n    gameGroup:insert( shade )\n    end\n    shade.alpha = 0.5\n    -- SHOW MENU BUTTON\n    if pauseBG then\n    pauseBG.isVisible = true\n    pauseBG.isActive = true\n    pauseBG:toFront()\n    end\n    pauseBtn:toFront()\n\n    ```", "```java\n    else\n    if shade then\n    display.remove( shade )\n    shade = nil\n    end\n    if pauseBG then\n    pauseBG.isVisible = false\n    pauseBG.isActive = false\n    end\n    gameIsActive = true\n    physics.start()\n    local function resumeGame()\n    timer.resume( startDrop )\n    print(\"timer has been resumed\")\n    end\n    timer.performWithDelay(1, resumeGame)\n    end\n    end\n    end\n\n    ```", "```java\n    pauseBtn = ui.newButton{\n    defaultSrc = \"pausebtn.png\",\n    defaultX = 44,\n    defaultY = 44,\n    overSrc = \"pausebtn-over.png\",\n    overX = 44,\n    overY = 44,\n    onEvent = onPauseTouch,\n    id = \"PauseButton\",\n    text = \"\",\n    font = \"Helvetica\",\n    textColor = { 255, 255, 255, 255 },\n    size = 16,\n    emboss = false\n    }\n    pauseBtn.x = 38; pauseBtn.y = 288\n    pauseBtn.isVisible = false\n    pauseBtn.isActive = false\n    gameGroup:insert( pauseBtn )\n    pauseBG = display.newImageRect( \"pauseoverlay.png\", 480, 320 )\n    pauseBG.x = 240; pauseBG.y = 160\n    pauseBG.isVisible = false\n    pauseBG.isActive = false\n    gameGroup:insert( pauseBG )\n\n    ```", "```java\n    pauseBtn.isVisible = true\n    pauseBtn.isActive = true\n\n    ```", "```java\n    pauseBtn.isVisible = false\n    pauseBtn.isActive = false\n\n    ```", "```java\n    display.setStatusBar( display.HiddenStatusBar )\n    local gameGroup = display.newGroup()\n\n    ```", "```java\n    local storyboard = require( \"storyboard\" )\n    local scene = storyboard.newScene()\n\n    ```", "```java\n    -- Called when the scene's view does not exist:\n    function scene:createScene( event )\n    local gameGroup = self.view\n    -- completely remove loadgame's view\n    storyboard.removeScene( \"loadgame\" )\n    print( \"\\nmaingame: createScene event\")\n    end\n\n    ```", "```java\n    -- Called immediately after scene has moved onscreen:\n    function scene:enterScene( event )\n    local gameGroup = self.view\n\n    ```", "```java\n    return gameGroup -- Code will not run if this line is not removed\n\n    ```", "```java\n    print( \"maingame: enterScene event\" )\n    end\n\n    ```", "```java\n    -- Called when scene is about to move offscreen:\n    function scene:exitScene( event )\n    print( \"maingame: exitScene event\" )\n    end\n    -- Called prior to the removal of scene's \"view\" (display group)\n    function scene:destroyScene( event )\n    print( \"((destroying maingame's view))\" )\n    end\n\n    ```", "```java\n    -- \"createScene\" event is dispatched if scene's view does not exist\n    scene:addEventListener( \"createScene\", scene )\n    -- \"enterScene\" event is dispatched whenever scene transition has finished\n    scene:addEventListener( \"enterScene\", scene )\n    -- \"exitScene\" event is dispatched before next scene's transition begins\n    scene:addEventListener( \"exitScene\", scene )\n    -- \"destroyScene\" event is dispatched before view is unloaded, which can be\n    -- automatically unloaded in low memory situations, or explicitly via a call to\n    -- storyboard.purgeScene() or storyboard.removeScene().\n    scene:addEventListener( \"destroyScene\", scene )\n    return scene\n\n    ```", "```java\n    display.setStatusBar( display.HiddenStatusBar )\n\n    ```", "```java\n    -- require controller module\n    local storyboard = require ( \"storyboard\" )\n    -- load first screen\n    storyboard.gotoScene( \"loadmainmenu\" )\n\n    ```", "```java\nlocal onMenuTouch = function( event )\nif event.phase == \"release\" then\naudio.play( btnSound )\nstoryboard.gotoScene( \"mainmenu\", \"fade\", 500 )\nend\nend\nmenuBtn = ui.newButton{\ndefaultSrc = \"menubtn.png\",\ndefaultX = 60,\ndefaultY = 60,\noverSrc = \"menubtn-over.png\",\noverX = 60,\noverY = 60,\nonEvent = onMenuTouch,\nid = \"MenuButton\",\ntext = \"\",\nfont = \"Helvetica\",\ntextColor = { 255, 255, 255, 255 },\nsize = 16,\nemboss = false\n}\nmenuBtn.x = 100; menuBtn.y = 260\ngameGroup:insert( menuBtn )\n\n```", "```java\n    local storyboard = require( \"storyboard\" )\n    local scene = storyboard.newScene()\n\n    ```", "```java\n    local myTimer\n    local loadingImage\n    -- Called when the scene's view does not exist:\n    function scene:createScene( event )\n    local screenGroup = self.view\n    print( \"\\nloadmainmenu: createScene event\" )\n    end\n\n    ```", "```java\n    -- Called immediately after scene has moved onscreen:\n    function scene:enterScene( event )\n    local screenGroup = self.view\n    print( \"loadmainmenu: enterScene event\" )\n\n    ```", "```java\n    loadingImage = display.newImageRect( \"loading.png\", 480, 320 )\n    loadingImage.x = 240; loadingImage.y = 160\n    screenGroup:insert( loadingImage )\n\n    ```", "```java\n    local goToMenu = function()\n    storyboard.gotoScene( \"mainmenu\", \"zoomOutInFadeRotate\", 500 )\n    end\n\n    ```", "```java\n    myTimer = timer.performWithDelay( 1000, goToMenu, 1 )\n    end\n\n    ```", "```java\n    -- Called when scene is about to move offscreen:\n    function scene:exitScene()\n    if myTimer then timer.cancel( myTimer ); end\n    print( \"loadmainmenu: exitScene event\" )\n    end\n    -- Called prior to the removal of scene's \"view\" (display group)\n    function scene:destroyScene( event )\n    print( \"((destroying loadmainmenu's view))\" )\n    end\n\n    ```", "```java\n    -- \"createScene\" event is dispatched if scene's view does not exist\n    scene:addEventListener( \"createScene\", scene )\n    -- \"enterScene\" event is dispatched whenever scene transition has finished\n    scene:addEventListener( \"enterScene\", scene )\n    -- \"exitScene\" event is dispatched before next scene's transition begins\n    scene:addEventListener( \"exitScene\", scene )\n    -- \"destroyScene\" event is dispatched before view is unloaded, which can be\n    scene:addEventListener( \"destroyScene\", scene )\n    return scene\n\n    ```", "```java\n    local storyboard = require( \"storyboard\" )\n    local scene = storyboard.newScene()\n    local myTimer\n    local loadingImage\n    -- Called when the scene's view does not exist:\n    function scene:createScene( event )\n    local screenGroup = self.view\n    -- completely remove mainmenu\n    storyboard.removeScene( \"mainmenu\" )\n    print( \"\\nloadgame: createScene event\" )\n    end\n    -- Called immediately after scene has moved onscreen:\n    function scene:enterScene( event )\n    local screenGroup = self.view\n    print( \"loadgame: enterScene event\" )\n    loadingImage = display.newImageRect( \"loading.png\", 480, 320 )\n    loadingImage.x = 240; loadingImage.y = 160\n    screenGroup:insert( loadingImage )\n    local changeScene = function()\n    storyboard.gotoScene( \"maingame\", \"flipFadeOutIn\", 500 )\n    end\n    myTimer = timer.performWithDelay( 1000, changeScene, 1 )\n    end\n    -- Called when scene is about to move offscreen:\n    function scene:exitScene()\n    if myTimer then timer.cancel( myTimer ); end\n    print( \"loadgame: exitScene event\" )\n    end\n    -- Called prior to the removal of scene's \"view\" (display group)\n    function scene:destroyScene( event )\n    print( \"((destroying loadgame's view))\" )\n    end\n    -- \"createScene\" event is dispatched if scene's view does not exist\n    scene:addEventListener( \"createScene\", scene )\n    -- \"enterScene\" event is dispatched whenever scene transition has finished\n    scene:addEventListener( \"enterScene\", scene )\n    -- \"exitScene\" event is dispatched before next scene's transition begins\n    scene:addEventListener( \"exitScene\", scene )\n    -- \"destroyScene\" event is dispatched before view is unloaded, which can be\n    scene:addEventListener( \"destroyScene\", scene )\n    return scene\n\n    ```", "```java\n    local storyboard = require( \"storyboard\" )\n    local scene = storyboard.newScene()\n    local ui = require(\"ui\")\n    local btnAnim\n    local btnSound = audio.loadSound( \"btnSound.wav\" )\n\n    ```", "```java\n    -- Called when the scene's view does not exist:\n    function scene:createScene( event )\n    local screenGroup = self.view\n    -- completely remove maingame and options\n    storyboard.removeScene( \"maingame\" )\n    storyboard.removeScene( \"options\" )\n    print( \"\\nmainmenu: createScene event\" )\n    end\n\n    ```", "```java\n    -- Called immediately after scene has moved onscreen:\n    function scene:enterScene( event )\n    local screenGroup = self.view\n    print( \"mainmenu: enterScene event\" )\n    local backgroundImage = display.newImageRect( \"mainMenuBG.png\", 480, 320 )\n    backgroundImage.x = 240; backgroundImage.y = 160\n    screenGroup:insert( backgroundImage )\n\n    ```", "```java\n    local playBtn\n    local onPlayTouch = function( event )\n    if event.phase == \"release\" then\n    audio.play( btnSound )\n    storyboard.gotoScene( \"loadgame\", \"fade\", 300 )\n    end\n    end\n    playBtn = ui.newButton{\n    defaultSrc = \"playbtn.png\",\n    defaultX = 100,\n    defaultY = 100,\n    overSrc = \"playbtn-over.png\",\n    overX = 100,\n    overY = 100,\n    onEvent = onPlayTouch,\n    id = \"PlayButton\",\n    text = \"\",\n    font = \"Helvetica\",\n    textColor = { 255, 255, 255, 255 },\n    size = 16,\n    emboss = false\n    }\n    playBtn.x = 240; playBtn.y = 440\n    screenGroup:insert( playBtn )\n\n    ```", "```java\n    btnAnim = transition.to( playBtn, { time=500, y=260, transition=easing.inOutExpo } )\n\n    ```", "```java\n    local optBtn\n    local onOptionsTouch = function( event )\n    if event.phase == \"release\" then\n    audio.play( btnSound )\n    storyboard.gotoScene( \"options\", \"crossFade\", 300 )\n    end\n    end\n    optBtn = ui.newButton{\n    defaultSrc = \"optbtn.png\",\n    defaultX = 60,\n    defaultY = 60,\n    overSrc = \"optbtn-over.png\",\n    overX = 60,\n    overY = 60,\n    onEvent = onOptionsTouch,\n    id = \"OptionsButton\",\n    text = \"\",\n    font = \"Helvetica\",\n    textColor = { 255, 255, 255, 255 },\n    size = 16,\n    emboss = false\n    }\n    optBtn.x = 430; optBtn.y = 440\n    screenGroup:insert( optBtn )\n\n    ```", "```java\n    btnAnim = transition.to( optBtn, { time=500, y=280, transition=easing.inOutExpo } )\n    end\n\n    ```", "```java\n    -- Called when scene is about to move offscreen:\n    function scene:exitScene()\n    if btnAnim then transition.cancel( btnAnim ); end\n    print( \"mainmenu: exitScene event\" )\n    end\n    -- Called prior to the removal of scene's \"view\" (display group)\n    function scene:destroyScene( event )\n    print( \"((destroying mainmenu's view))\" )\n    end\n\n    ```", "```java\n    -- \"createScene\" event is dispatched if scene's view does not exist\n    scene:addEventListener( \"createScene\", scene )\n    -- \"enterScene\" event is dispatched whenever scene transition has finished\n    scene:addEventListener( \"enterScene\", scene )\n    -- \"exitScene\" event is dispatched before next scene's transition begins\n    scene:addEventListener( \"exitScene\", scene )\n    -- \"destroyScene\" event is dispatched before view is unloaded, which can be\n    scene:addEventListener( \"destroyScene\", scene )\n    return scene\n\n    ```", "```java\n    local storyboard = require( \"storyboard\" )\n    local scene = storyboard.newScene()\n    local ui = require(\"ui\")\n    local btnAnim\n    local btnSound = audio.loadSound( \"btnSound.wav\" )\n\n    ```", "```java\n    -- Called when the scene's view does not exist:\n    function scene:createScene( event )\n    local screenGroup = self.view\n    -- completely remove mainmenu and creditsScreen\n    storyboard.removeScene( \"mainmenu\" )\n    storyboard.removeScene( \"creditsScreen\" )\n    print( \"\\noptions: createScene event\" )\n    end\n\n    ```", "```java\n    -- Called immediately after scene has moved onscreen:\n    function scene:enterScene( event )\n    local screenGroup = self.view\n    print( \"options: enterScene event\" )\n    local backgroundImage = display.newImageRect( \"optionsBG.png\", 480, 320 )\n    backgroundImage.x = 240; backgroundImage.y = 160\n    screenGroup:insert( backgroundImage )\n\n    ```", "```java\n    local creditsBtn\n    local onCreditsTouch = function( event )\n    if event.phase == \"release\" then\n    audio.play( btnSound )\n    storyboard.gotoScene( \"creditsScreen\", \"crossFade\", 300 )\n    end\n    end\n    creditsBtn = ui.newButton{\n    defaultSrc = \"creditsbtn.png\",\n    defaultX = 100,\n    defaultY = 100,\n    overSrc = \"creditsbtn-over.png\",\n    overX = 100,\n    overY = 100,\n    onEvent = onCreditsTouch,\n    id = \"CreditsButton\",\n    text = \"\",\n    font = \"Helvetica\",\n    textColor = { 255, 255, 255, 255 },\n    size = 16,\n    emboss = false\n    }\n    creditsBtn.x = 240; creditsBtn.y = 440\n    screenGroup:insert( creditsBtn )\n    btnAnim = transition.to( creditsBtn, { time=500, y=260, transition=easing.inOutExpo } )\n\n    ```", "```java\n    local closeBtn\n    local onCloseTouch = function( event )\n    if event.phase == \"release\" then\n    audio.play( tapSound )\n    storyboard.gotoScene( \"mainmenu\", \"zoomInOutFadeRotate\", 500 )\n    end\n    end\n    closeBtn = ui.newButton{\n    defaultSrc = \"closebtn.png\",\n    defaultX = 60,\n    defaultY = 60,\n    overSrc = \"closebtn-over.png\",\n    overX = 60,\n    overY = 60,\n    onEvent = onCloseTouch,\n    id = \"CloseButton\",\n    text = \"\",\n    font = \"Helvetica\",\n    textColor = { 255, 255, 255, 255 },\n    size = 16,\n    emboss = false\n    }\n    closeBtn.x = 50; closeBtn.y = 280\n    screenGroup:insert( closeBtn )\n    end\n\n    ```", "```java\n    -- Called when scene is about to move offscreen:\n    function scene:exitScene()\n    if btnAnim then transition.cancel( btnAnim ); end\n    print( \"options: exitScene event\" )\n    end\n    -- Called prior to the removal of scene's \"view\" (display group)\n    function scene:destroyScene( event )\n    print( \"((destroying options's view))\" )\n    end\n    -- \"createScene\" event is dispatched if scene's view does not exist\n    scene:addEventListener( \"createScene\", scene )\n    -- \"enterScene\" event is dispatched whenever scene transition has finished\n    options menuoptions menuaddingscene:addEventListener( \"enterScene\", scene )\n    -- \"exitScene\" event is dispatched before next scene's transition begins\n    scene:addEventListener( \"exitScene\", scene )\n    -- \"destroyScene\" event is dispatched before view is unloaded, which can be\n    scene:addEventListener( \"destroyScene\", scene )\n    return scene\n\n    ```", "```java\n    local storyboard = require( \"storyboard\" )\n    local scene = storyboard.newScene()\n    local backgroundImage\n\n    ```", "```java\n    -- Called when the scene's view does not exist:\n    function scene:createScene( event )\n    local screenGroup = self.view\n    -- completely remove options\n    storyboard.removeScene( \"options\" )\n    print( \"\\ncreditsScreen: createScene event\" )\n    end\n\n    ```", "```java\n    -- Called immediately after scene has moved onscreen:\n    function scene:enterScene( event )\n    local screenGroup = self.view\n    print( \"creditsScreen: enterScene event\" )\n    backgroundImage = display.newImageRect( \"creditsScreen.png\", 480, 320 )\n    backgroundImage.x = 240; backgroundImage.y = 160\n    screenGroup:insert( backgroundImage )\n\n    ```", "```java\n    local changeToOptions = function( event )\n    if event.phase == \"began\" then\n    storyboard.gotoScene( \"options\", \"crossFade\", 300 )\n    end\n    end\n    backgroundImage:addEventListener( \"touch\", changeToOptions)\n    end\n\n    ```", "```java\n    -- Called when scene is about to move offscreen:\n    function scene:exitScene()\n    print( \"creditsScreen: exitScene event\" )\n    end\n    -- Called prior to the removal of scene's \"view\" (display group)\n    function scene:destroyScene( event )\n    print( \"((destroying creditsScreen's view))\" )\n    end\n    -- \"createScene\" event is dispatched if scene's view does not exist\n    scene:addEventListener( \"createScene\", scene )\n    -- \"enterScene\" event is dispatched whenever scene transition has finished\n    scene:addEventListener( \"enterScene\", scene )\n    -- \"exitScene\" event is dispatched before next scene's transition begins\n    scene:addEventListener( \"exitScene\", scene )\n    -- \"destroyScene\" event is dispatched before view is unloaded, which can be\n    scene:addEventListener( \"destroyScene\", scene )\n    return scene\n\n    ```"]