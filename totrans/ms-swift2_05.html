<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Classes and Structures</h1></div></div></div><p>The first programming language that I learned was BASIC. It was a good language to begin programming with, but once I traded in my Commodore Vic-20 for a PCjr (yes, I had a PCjr and I really enjoyed it), I realized that there were other, more advanced languages out there, and spent a lot of time learning Pascal and C. It wasn't until I started college that I heard the term "object-oriented language". At that time, object-oriented languages were so new that there were no real courses on them, but I was able to experiment a little with C++. After I graduated, I left object-oriented programming behind, and it really wasn't until several years later, when I started to experiment with C++ again, that I really discovered the power and flexibility of object-oriented programming.</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating and using classes and structures</li><li class="listitem" style="list-style-type: disc">Adding properties and property observers to classes and structures</li><li class="listitem" style="list-style-type: disc">Adding methods to classes and structures</li><li class="listitem" style="list-style-type: disc">Adding initializers to classes and structures</li><li class="listitem" style="list-style-type: disc">Using access controls</li><li class="listitem" style="list-style-type: disc">Creating a class hierarchy</li><li class="listitem" style="list-style-type: disc">Extending a class</li><li class="listitem" style="list-style-type: disc">Understanding memory management and ARC</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec29"/>What are classes and structures?</h1></div></div></div><p>In Swift, classes and structures <a class="indexterm" id="id259"/>are very similar. If we really want to master Swift, it is very important to understand what makes classes and structures so similar and also what sets them apart because they are the building blocks of your applications. Apple describes classes and structures as:</p><div><blockquote class="blockquote"><p><em>"Classes and structures are general-purpose, flexible constructs that become the building blocks of your program's code. You define properties and methods to add functionality to your classes and structures by using the already familiar syntax  of constants, variables, and functions."</em></p></blockquote></div><p>Let's begin by taking a quick look at some of the similarities between classes and structures.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec90"/>Similarities between classes and structures</h2></div></div></div><p>In Swift, classes and structures <a class="indexterm" id="id260"/>are more similar than they are in other languages, such as Objective-C. The following is a list of some of the features that classes and structures share:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Properties: These are used to store information in our classes and structures</li><li class="listitem" style="list-style-type: disc">Methods: These provide functionality for our classes and structures</li><li class="listitem" style="list-style-type: disc">Initializers: These are used when initializing instances of our classes and structures</li><li class="listitem" style="list-style-type: disc">Subscripts: These  provide access to values using the subscript syntax</li><li class="listitem" style="list-style-type: disc">Extensions: These help in extending both classes and structures</li></ul></div><p>Now let's take a quick look at some of the differences between classes and structures.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec91"/>Differences between classes and structures</h2></div></div></div><p>While classes and structures <a class="indexterm" id="id261"/>are very similar, there are also several very important differences. The following is a list of some of the differences between classes and structures in Swift:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Type: A structure is a value type while a class is a reference type</li><li class="listitem" style="list-style-type: disc">Inheritance: A structure cannot inherit from other types while a class can</li><li class="listitem" style="list-style-type: disc">Deinitializers: Structures cannot have custom deinitializers while a class can</li><li class="listitem" style="list-style-type: disc">Multiple references: We can have more than one reference to a class instance; however, with structures, we cannot</li></ul></div><p>Throughout this chapter, we will be emphasizing the differences between classes and structures to help us understand when to use each. Before we really dive into classes and structures, let's take a look at the difference between value types (structures) and reference types (classes). In order to understand when to use classes and structures and how to properly use them, it is important to understand the difference between value and reference types.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec92"/>Value versus reference types</h2></div></div></div><p>Structures such <a class="indexterm" id="id262"/>as enums and tuples are value types. This means when we pass instances of a structure within our application, we pass a copy of the structure and not the original structure. Classes are reference types, which means when we pass an instance of a class within our application, we pass a reference to the original instance. It is very important to understand the difference between value and reference types. We will give a very high-level view here, and will provide additional details in the <em>Memory management</em> section at the end of this chapter.</p><p>When we pass structures within our application, we are passing copies of the structures and not the original structures. Since a function gets its own copy of the structure, it can change it as needed, without affecting the original instance of the structure.</p><p>When we pass an instance of a class within our application, we are passing a reference to the original instance of the class. Since we pass an instance of a class to a function, the function is getting a reference to the original instance; therefore, any changes made within the function will remain once the function exits.</p><p>To illustrate the difference between value and reference types, let's look at a real-world object—a book. If we had a friend that wanted to read <em>Mastering Swift</em>, we could either buy them their own copy or share ours.</p><p>If we bought our friend their own copy of the book, then any notes they made within the book would remain in their copy of the book and would not be reflected in our copy. This is how pass by value works with structures and variables. Any changes that are made to the structure or variable within the function are not reflected in the original instance of the structure or variable.</p><p>If we share our copy of the book, then any notes they made within the book would stay in the book when they returned it to us. This is how pass by reference works. Any changes that are made to the instance of the class remains when the function exits.</p><p>To read more about value versus reference types, see the <em>Memory management</em> section at the end of this chapter.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec30"/>Creating a class or structure</h1></div></div></div><p>We use the same <a class="indexterm" id="id263"/>syntax to define classes and structures. The only difference is we define a class using the <code class="literal">class</code> keyword, and a structure by using the <code class="literal">struct</code> keyword. Let's look at the syntax used to create both classes and structures:</p><div><pre class="programlisting">class MyClass {
  // MyClass definition
}

struct MyStruct {
  // MyStruct definition
}</pre></div><p>In the preceding <a class="indexterm" id="id264"/>code, we define a new class named <code class="literal">MyClass</code> and a new structure named <code class="literal">MyStruct</code>. This effectively creates two new Swift types named <code class="literal">MyClass</code> and <code class="literal">MyStruct</code>. When we name a new type, we want to use the standard naming convention set by Swift where the name is in camel case, with the first letter being uppercase. Any method or property defined within the class or structure should also be named using camel case with the first letter being lowercase.</p><p>Empty classes and structures are not that useful, so let's look at how we can add properties to our classes and structures.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec93"/>Properties</h2></div></div></div><p>Properties associate values <a class="indexterm" id="id265"/>with a class or a structure. There are two types of properties, which are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Stored properties: They <a class="indexterm" id="id266"/>store variable or constant values as part of an instance of a class or structure. Stored properties can also have property observers that can monitor the property for changes and respond with custom actions when the value of the property changes.</li><li class="listitem" style="list-style-type: disc">Computed properties: They<a class="indexterm" id="id267"/> do not store a value themselves, but retrieve and possibly set other properties. The value returned by a computed property can also be calculated when it is requested.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec94"/>Stored properties</h2></div></div></div><p>A stored property is a <a class="indexterm" id="id268"/>variable or constant that is stored as part of an instance of a class or structure. We can provide a default value for stored properties. These are defined with the <code class="literal">var</code> keyword. Let's look at how we would use stored properties in classes and structures. In the following code, we will create a structure named <code class="literal">MyStruct</code> and a class named <code class="literal">MyClass</code>. The structure and the class both contain two stored properties, <code class="literal">c</code> and <code class="literal">v</code>. The stored property <code class="literal">c</code> is a constant because it is defined with the <code class="literal">let</code> keyword, and <code class="literal">v</code> is a variable because it is defined with the <code class="literal">var</code> keyword. Let's take a look at the following code:</p><div><pre class="programlisting">struct MyStruct {
  let c = 5
  var v = ""
}

class MyClass {
  let c = 5
  var v = ""
}</pre></div><p>As we can see <a class="indexterm" id="id269"/>from the example, the syntax to define a stored property is the same for both classes and properties. Let's look at how we would create an instance of both the structure and class. The following code creates an instance of the <code class="literal">MyStruct</code> structure named <code class="literal">myStruct</code> and an instance of the <code class="literal">MyClass</code> class named <code class="literal">myClass</code>:</p><div><pre class="programlisting">var myStruct = MyStruct()
var myClass = MyClass()</pre></div><p>One of the differences <a class="indexterm" id="id270"/>between a structure and a class is that, by default, a structure creates an initializer that lets us populate the stored properties when we create an instance of the structure. Therefore, we could also create an instance of the <code class="literal">MyStruct</code> like this:</p><div><pre class="programlisting">var myStruct = MyStruct(v: "Hello")</pre></div><p>In the preceding example, the initializer is used to set the variable <code class="literal">v</code>, and the <code class="literal">c</code> constant will contain the number 5 that is set in the <code class="literal">struct</code> itself. If, for example, we did not give the constant an initial value, as shown in the following example, the default initializer would be used to also set the constant as well:</p><div><pre class="programlisting">struct MyStruct {
  let c: Int
  var v = ""
}</pre></div><p>The following example shows how the initializer for this new <code class="literal">struct</code> would work:</p><div><pre class="programlisting">var myStruct = MyStruct(c: 10, v: "Hello")</pre></div><p>This allows us to define a constant where we set the value when we initialize the class or struct at runtime rather than hardcoding the value of the constant in our code.</p><p>The order in which the parameters appear in the initializer is the order that we defined them in. In the previous example, we defined the c constant first; therefore, it is the first parameter in the initializer. We defined the v parameter second; therefore it is the second parameter in the initializer.</p><p>To set or read a stored property, we use the standard dot syntax. Let's look at how we would set and read stored properties in Swift:</p><div><pre class="programlisting">var x = myClass.c
myClass.v = "Howdy"</pre></div><p>Before we move on to computed properties, let's create a structure and class that will represent an employee. We <a class="indexterm" id="id271"/>will be using and expanding these throughout this chapter to show how classes and structures are similar and how they differ:</p><div><pre class="programlisting">struct EmployeeStruct {
  var firstName = ""
  var lastName = ""
  var salaryYear = 0.0
}

public class EmployeeClass {
  var firstName = ""
  var lastName = ""
  var salaryYear = 0.0
}</pre></div><p>The employee structure<a class="indexterm" id="id272"/> is named <code class="literal">EmployeeStruct</code> and the employee class is named <code class="literal">EmployeeClass</code>. Both the class and structure have three stored properties: <code class="literal">firstName</code>, <code class="literal">lastName</code>, and <code class="literal">salaryYear</code>.</p><p>Within our structure or class, we can now access these properties by using the name of the property or the <code class="literal">self</code> keyword. Every instance of a structure or class has a property named <code class="literal">self</code>. This property refers to the instance itself; therefore, we can use it to access the properties within the instance. The following examples show how we can access the properties with the <code class="literal">self</code> keyword within the instance of the structure or class:</p><div><pre class="programlisting">self.firstName = "Jon"
self.lastName = "Hoffman"</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec95"/>Computed properties</h2></div></div></div><p>Computed properties <a class="indexterm" id="id273"/>are properties that do not <a class="indexterm" id="id274"/>have backend variables that are used to store the values associated with the property. The values of a computed property are usually computed when code requests it. You can think of a computed property as a function disguised as a property. Let's take a look at how we would define a read-only computed property:</p><div><pre class="programlisting">var salaryWeek: Double {
get{
  return self.salaryYear/52
  }
}</pre></div><p>To create a read-only computed property, we begin by defining it as if it were a normal variable with the <code class="literal">var</code> <a class="indexterm" id="id275"/>keyword, followed by the variable name, colon and the variable type. What comes next is different; we add a curly bracket at the end of the declaration and then define a <code class="literal">getter</code> method that is called when the value of our computed property is requested. In the example, the <code class="literal">getter</code> method divides the current value of the <code class="literal">salaryYear</code> property by <code class="literal">52</code> to get the employee's weekly salary.</p><p>We can simplify the definition of the read-only computed property by removing the <code class="literal">get</code> keyword. We could rewrite the <code class="literal">salaryWeek</code> function like this:</p><div><pre class="programlisting">var salaryWeek: Double {
  return self.salaryYear/52
}</pre></div><p>Computed properties <a class="indexterm" id="id276"/>are not limited to being read-only, we can also write to them. To enable the <code class="literal">salaryWeek</code> property to be writeable, we would need to add a <code class="literal">setter</code> method. The following example shows how we would add a <code class="literal">setter</code> method that will set the <code class="literal">salaryYear</code> property, based on the value being passed into the <code class="literal">salaryWeek</code> property:</p><div><pre class="programlisting">var salaryWeek: Double {
  get {
    return self.salaryYear/52
  }
  set (newSalaryWeek){
    self.salaryYear = newSalaryWeek*52
  }
}</pre></div><p>We can simplify the setter definition by not defining a name for the new value. In this case, the value would be assigned to a default variable name, <code class="literal">newValue</code>. The <code class="literal">salaryWeek</code> computed property could be rewritten like this:</p><div><pre class="programlisting">var salaryWeek: Double {
  get{
    return self.salaryYear/52
  }	
  set{
    self.salaryYear = newValue*52
  }
}</pre></div><p>The <code class="literal">salaryWeek</code> computed property, as written in the preceding example, could be added to either the <code class="literal">EmployeeClass</code> class or the <code class="literal">EmployeeStruct</code> structure without any modifications. Let's see how we would do this by adding the <code class="literal">salaryWeek</code> property to our <code class="literal">EmployeeClass</code> class:</p><div><pre class="programlisting">public class EmployeeClass {
  var firstName = ""
  var lastName = ""
  var salaryYear = 0.0
  var salaryWeek: Double {
    get{
      return self.salaryYear/52
    }
    set (newSalaryWeek){
      self.salaryYear = newSalaryWeek*52
    }
  }
}</pre></div><p>Now, let's look at how <a class="indexterm" id="id277"/>we would add the <code class="literal">salaryWeek</code> computed property to the <code class="literal">EmployeeStruct</code> structure:</p><div><pre class="programlisting">struct EmployeeStruct {
    var firstName = ""
    var lastName = ""
    var salaryYear = 0.0
    var salaryWeek: Double {
        get{
            return self.salaryYear/52
        }
        set (newSalaryWeek){
            self.salaryYear = newSalaryWeek*52
        }
    }
}</pre></div><p>As we can see, the <a class="indexterm" id="id278"/>class and structure definitions are the same so far, except for the initial class or <code class="literal">struct</code> keywords are used to define them as either a structure or a class.</p><p>We read and write to a computed property exactly as we would to a stored property. Code that is external to the class or structure should not be aware that the property is a computer property. Let's see this in action by creating an instance of the <code class="literal">EmployeeStruct</code> structure:</p><div><pre class="programlisting">var f = EmployeeStruct(firstName: "Jon", lastName: "Hoffman", salaryYear: 39000)

print(f.salaryWeek) //prints 750.00 to the console
f.salaryWeek = 1000
print(f.salaryWeek) //prints 1000.00 to the console
print(f.salaryYear) //prints 52000.00 to the console</pre></div><p>The preceding example <a class="indexterm" id="id279"/>starts off by creating an instance of the <code class="literal">EmployStruct</code> structure with the <code class="literal">salaryYear</code> value being set to <code class="literal">39,000</code>. Next, we print the value of the <code class="literal">salaryWeek</code> property to the <code class="literal">console</code>. This value is currently <code class="literal">750.00</code>. We then set the <code class="literal">salaryWeek</code> property to <code class="literal">1000.00</code> and print out both the <code class="literal">salaryWeek</code> and <code class="literal">salaryYear</code> properties to the console. The values of the <code class="literal">salaryWeek</code> and <code class="literal">salaryYear</code> properties are now <code class="literal">1000.00</code> and <code class="literal">52000</code> respectively. As we can see, in this example, setting either the <code class="literal">salaryWeek</code> or <code class="literal">salaryYear</code> property changes the values returned by both.</p><p>Computed properties can <a class="indexterm" id="id280"/>be very useful for offering different views of the same data. For example, if we had a value that represented the length of something, we could store the length in centimeters and then use computed properties that calculate the values for meters, millimeters, and kilometers.</p><p>Now, let's take a look at property observers.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec96"/>Property observers</h2></div></div></div><p>Property observers <a class="indexterm" id="id281"/>are called every time the <a class="indexterm" id="id282"/>value of the property is set. We can add property observers to any non-lazy stored property. We can also add property observers to any inherited stored or computed property by overriding the property in the subclass. We will look at the <em>Overriding properties</em> section a little later in this chapter.</p><p>There are two property observers that we can set in Swift—<code class="literal">willSet</code> and <code class="literal">didSet</code>. The <code class="literal">willSet</code> observer is called right before the property is set, and the <code class="literal">didSet</code> observer is called right after the property is set.</p><p>One thing to note about property observers is that they are not called when the value is set during initialization. Let's look at how we would add a property observer to the salary property of our <code class="literal">EmployeeClass</code> class and <code class="literal">EmployeeStruct</code> structure:</p><div><pre class="programlisting">var salaryYear: Double = 0.0 {
  willSet(newSalary) {
    print("About to set salaryYear to \(newSalary)")
  }
  didSet {
    if salaryWeek &gt; oldValue {
      print("\(firstName) got a raise")
    }
    else {
      print("\(firstName) did not get a raise")
    }
  }
}</pre></div><p>When we add a property observer to a stored property, we need to include the type of the value being stored within the definition of the property. In the preceding example, we did not need to define our <code class="literal">salaryYear</code> property as a <code class="literal">Double</code> type; however, when we add property observers the definition is required.</p><p>After the property <a class="indexterm" id="id283"/>definition, we define a <code class="literal">willSet</code> observer that simply prints out the new value that the <code class="literal">salaryYear</code> property will be set to. We also define a <code class="literal">didSet</code> observer that will check whether the new value is greater than the old value and if so, it will print out that the employee got a raise, otherwise, it will print out that the employee did not get a raise.</p><p>As with the getter in computed properties, we do not need to define the name for the new value for the <code class="literal">willSet</code> observer. If<a class="indexterm" id="id284"/> we do not define a name, the new value is put in a constant named <code class="literal">newValue</code>. The following example shows how we would rewrite the previous <code class="literal">willSet</code> observer without defining a name for the new value:</p><div><pre class="programlisting">willSet {
    print("About to set salaryYear to \(newValue)")
}</pre></div><p>As we have seen, properties are mainly used to store information associated with a class or structure, and methods are mainly used to add the business logic to a class or structure. Let's look at how we would add methods to class or structure.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec97"/>Methods</h2></div></div></div><p>Methods are <a class="indexterm" id="id285"/>functions that are associated with a class or structure. A <a class="indexterm" id="id286"/>method, like a function, will encapsulate the code for a specific task or functionality that is associated with the class or structure. Let's look at how we would define a method in classes and structures. The following code will return the full name of the employee by using the <code class="literal">firstName</code> and <code class="literal">lastName</code> properties:</p><div><pre class="programlisting">func getFullName() -&gt; String {
    return firstName + " " + lastName
}</pre></div><p>We define this method exactly as we would define any function. A method is simply a function that is associated with a specific class or structure, and everything that we learned about functions in the previous chapters applies to methods. The <code class="literal">getFullName()</code> function can be added directly to the <code class="literal">EmployeeClass</code> class or <code class="literal">EmployeeStruct</code> structure without any modification.</p><p>To access a method, we use the same dot syntax we used to access properties. The following code shows <a class="indexterm" id="id287"/>how we would access the <code class="literal">getFullName()</code> method of a class and a structure:</p><div><pre class="programlisting">var e = EmployeeClass()
var f = EmployeeStruct(firstName: "Jon", lastName: "Hoffman", salaryYear: 50000)

e.firstName = "Jon"
e.lastName = "Hoffman"
e.salaryYear = 50000.00

print(e.getFullName()) //Jon Hoffman is printed to the console
print(f.getFullName()) //Jon Hoffman is printed to the console</pre></div><p>In the preceding example, we initialize an instance of both the <code class="literal">EmployeeClass</code> class and <code class="literal">EmployeeStruct</code> structure. We populate the structure and class with the same information and then use the <code class="literal">getFullName()</code> method to print the full name of the employee to the console. In both cases, <code class="literal">Jon Hoffman</code> is printed to the console.</p><p>There is a difference in how we define methods for classes and structures, which we need to update property values within the method. Let's look at how we would define a method that gives an employee a raise within the <code class="literal">EmployeeClass</code> class:</p><div><pre class="programlisting">func giveRaise(amount: Double) {
  self.salaryYear += amount
}</pre></div><p>If we add the <a class="indexterm" id="id288"/>preceding code to our <code class="literal">EmployeeClass</code>, it works as expected and when we call the method, with an amount, the employee gets a raise. However, if we try to add this method as it is written to the <code class="literal">EmployeeStruct</code> structure, we receive the <code class="literal">Cannot invoke '+=' with an argument list of type '(Double, Double)'</code> error. By default, we are not allowed to update property values within a method of a structure. If we want to modify a property, we can opt into mutating behavior for that method by adding the <code class="literal">mutating</code> keyword before the <code class="literal">func</code> keyword of the method declaration. Therefore, the following code would be the correct way to define the <code class="literal">giveRaise()</code> method for the <code class="literal">EmployeeStruct</code> structure:</p><div><pre class="programlisting">mutating func giveRase(amount: Double) {
    self.salaryYear += amount
}</pre></div><p>In the preceding examples, we used the <code class="literal">self</code> property. Every instance of a type has a property called <code class="literal">self</code>, which is the instance itself. We use the <code class="literal">self</code> property to refer to the current instance of the type within the instance itself, so when we write <code class="literal">self.salaryYear</code>, we ask for the value of the <code class="literal">salaryYear</code> property of the current instance.</p><p>The <code class="literal">self</code> property can be used to distinguish between a local variable and instance variable that have the same name. Let's look at an example that illustrates this:</p><div><pre class="programlisting">func compareFirstName(firstName: String) -&gt; Bool {
  return self.firstName == firstName
}</pre></div><p>In the preceding example, the <a class="indexterm" id="id289"/>method accepts an argument with the name, <code class="literal">firstName</code>. There is also a property that has this name. We use the self property to specify that we want the instance property with the name, <code class="literal">firstName</code>, and not the local variable with this name.</p><p>Other than the <code class="literal">mutating</code> keyword being required for methods that change the value of the structure's properties, methods can be defined and used exactly as functions are defined and used. Therefore, everything we learned about functions in the previous chapter can be applied to methods.</p><p>There are <a class="indexterm" id="id290"/>times when we want to initialize properties or perform some business logic when a class or structure is first initialized. For this, we will use an initializer.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec31"/>Custom initializers</h1></div></div></div><p>Initializers are called <a class="indexterm" id="id291"/>when we initialize a new instance of a particular type (class or structure). Initialization is the process of preparing an instance for use. The initialization process can include setting initial values for stored properties, verifying resources, such as web services, files, and so on are available, or setting up the UI properly. Initializers are generally used to ensure that the instance of the class or structure is properly initialized prior to first use.</p><p>Initializers are special methods that are used to create a new instance of a type. We define an initializer exactly as we would define other methods, but we must use the <code class="literal">init</code> keyword as the name of the initializer to tell the compiler that this method is an initializer. In its simplest form, the initializer does not accept any arguments. Let's look at the syntax used to write a simple initializer:</p><div><pre class="programlisting">init() {
  //Perform initialization here
}</pre></div><p>This format works for both classes and structures. By default, all classes and structures have an empty default initializer that we can override if we choose to. We saw these default initializers when we used the <code class="literal">EmployeeClass</code> class and <code class="literal">EmployeeStruct</code> structure in the previous section. Structures also have an additional default initializer, which we saw with the <code class="literal">EmployeeStruct</code> structure that accepts a value for each stored property and initializes them with those values. Let's look at how we would add custom initializers to our <code class="literal">EmployeeClass</code> class and <code class="literal">EmployeeStruct</code> structure. In the following code, we create three <a class="indexterm" id="id292"/>custom initializers that will work for both the <code class="literal">EmployeeClass</code> class and <code class="literal">EmployeeStruct</code> structure:</p><div><pre class="programlisting">init() {
  self.firstName = ""
  self.lastName = ""
  self.salaryYear = 0.0
}
   
init(firstName: String, lastName: String) {
  self.firstName = firstName
  self.lastName = lastName
  self.salaryYear = 0.0
}
   
init(firstName: String, lastName: String, salaryYear: Double) {
  self.firstName = firstName
  self.lastName = lastName
  self.salaryYear = salaryYear
}</pre></div><p>The first initializer, <code class="literal">init()</code>, when used, will set all of the stored properties to their default values. The second initializer, <code class="literal">init(firstName: String, lastName: String)</code>, when used, will populate the <code class="literal">firstName</code> and <code class="literal">lastName</code> properties with the values of the arguments. The third initializer, <code class="literal">init(firstName: String, lastName: String, salaryYear: Double)</code>, will populate all the properties with the values of the arguments.</p><p>In the previous example we can see that in Swift, unlike Objective-C, an initializer does not have a return value. This means that we do not have to define the return type for the initializer or have a return statement within the initializer. Let's look at how we would use these initializers:</p><div><pre class="programlisting">var g = EmployeeClass()
var h = EmployeeStruct(firstName: "Me", lastName: "Moe")
var i = EmployeeClass(firstName: "Me", lastName: "Moe", salaryYear: 45000)</pre></div><p>The variable <code class="literal">g</code> uses the <code class="literal">init()</code> initializer to create an instance of the <code class="literal">EmployeeClass</code> class; therefore, all the properties of this <code class="literal">EmployeeClass</code> instance contain their default values.</p><p>The <code class="literal">h</code> variable uses the <code class="literal">init(firstName: String, lastName: String)</code> initializer to create an instance of the <code class="literal">EmployeeStruct</code> structure; therefore, the <code class="literal">firstName</code> property of the structure is set to <code class="literal">Me</code> and the <code class="literal">lastName</code> property is set to <code class="literal">Moe</code>, which are the two arguments passed into the initializer. The <code class="literal">salaryYear</code> property is still set to the default value of 0.0.</p><p>The <code class="literal">EmployeeClass</code> sets the <code class="literal">init(firstName: String, lastName: String, salaryYear: Double)</code> initializer to create an instance of the <code class="literal">EmployeeClass</code> class; therefore, the <code class="literal">firstName</code> property is set to <code class="literal">Me</code>, the <code class="literal">lastName</code> property is set to <code class="literal">Moe</code>, and the <code class="literal">salaryYear</code> is set to <code class="literal">45000</code>.</p><p>Since all the initializers <a class="indexterm" id="id293"/>are identified with the <code class="literal">init</code> keyword, the parameters and parameter types are used to identify which initializer to use. Therefore, Swift provides automatic external names for all of these parameters. In the previous example. We can see that when we use an initializer that has parameters, we include the parameter names. Let's take a look at internal and external parameter names with initializers.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec98"/>Internal and external parameter names</h2></div></div></div><p>Just like functions, the parameters <a class="indexterm" id="id294"/>associated with an initializer can have separate internal and external names. Unlike functions, if we do not supply external parameter names for our parameters, Swift will automatically generate them for us. In the previous examples, we did not include external parameter names in the definition of the initializers, so Swift created them for us using the internal parameter name as the external parameter name.</p><p>If we wanted to supply our own <a class="indexterm" id="id295"/>parameter names, we would do so by putting the external function name before the internal function name, exactly as we do with any normal function. Let's look at how we would define our own external parameter names by redefining one of the initializers within our <code class="literal">EmployeeClass</code> class:</p><div><pre class="programlisting">init(employeeWithFirstName firstName: String, lastName lastName: String, andSalary salaryYear: Double) {
  self.firstName = firstName
  self.lastName = lastName
  self.salaryYear = salaryYear
}</pre></div><p>In the preceding example, we created the <code class="literal">init(employeeWithFirstName firstName: String, lastName lastName: String, andSalary salaryYear: Double)</code> initializer. This initializer will create an instance of the <code class="literal">EmployeeClass</code> class and populate the instance properties with the value of the arguments. In this example, each of the parameters has both external and internal property names. Let's look at how we would use this initializer, with the external property names, to create an instance of the <code class="literal">EmployeeClass</code> class:</p><div><pre class="programlisting">var i = EmployeeClass(employeeWithFirstName: "Me", lastName: "Moe", andSalary: 45000)</pre></div><p>Notice that we are now using the external parameter names as we defined in our initializer. Using <a class="indexterm" id="id296"/>external parameter names can help make our code more readable and differentiate between different initializers.</p><p>So, what will happen<a class="indexterm" id="id297"/> if our initializer fails? For example, what if our class relies on a specific resource, such as web service or a specific file that is not currently available? This is where failable initializers come in.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec99"/>Failable initializers</h2></div></div></div><p>A failable initializer is<a class="indexterm" id="id298"/> an initializer that may fail to<a class="indexterm" id="id299"/> initialize the resources needed for a class or a structure, thereby rendering the instance unusable. When using a failable initializer, the result of the initializer is an optional type, containing either a valid instance of the type or nil.</p><p>An initializer can be made failable by adding a question mark (<code class="literal">?</code>) after the <code class="literal">init</code> keyword. Let's look at how we would create a failable initializer that will not allow a new employee to be initialized with a salary below <code class="literal">$20,000</code> a year:</p><div><pre class="programlisting">init?(firstName: String, lastName: String, salaryYear: Double) {
  self.firstName = firstName
  self.lastName = lastName
  self.salaryYear = salaryYear
  if self.salaryYear &lt; 20000 {
    return nil
  }
}</pre></div><p>In the previous example, we did not include a <code class="literal">return</code> statement within the initializer because Swift does not need to return the initialized instance; however, in a failable initializer, if the initialization fails, we will return a <code class="literal">nil</code>. If the initializer successfully initializes the instance, we do not need to return anything. Therefore, in our example, if the yearly salary that is passed in is below <code class="literal">$20,000</code> a year, we return <code class="literal">nil</code>, indicating that the initialization failed, otherwise, nothing will be returned. Let's look at how we would use a failable initializer to create an instance of a class or structure:</p><div><pre class="programlisting">if let f = EmployeeClass(firstName: "Jon", lastName: "Hoffman", 
  salaryYear: 29000) {
  print(f.getFullName())
} else {
  print("Failed to initialize")
}</pre></div><p>In the previous example, we initialize the instance of the <code class="literal">EmployeeClass</code> class with a yearly salary greater than $20,000; therefore, the instance gets initialized correctly and the full name of <code class="literal">Jon Hoffman</code> is printed <a class="indexterm" id="id300"/>to the console. Now let's try to initialize an instance of the <code class="literal">EmployeeClass</code> class with a yearly salary less than $20,000 to see how it fails:</p><div><pre class="programlisting">if let f = EmployeeClass(firstName: "Jon", lastName: "Hoffman", salaryYear: 19000) {
  print(f.getFullName())
  print(f.compareFirstName("Jon"))
} else {
  print("Failed to initialize")
}</pre></div><p>In the example, the <a class="indexterm" id="id301"/>yearly salary that we are attempting to initialize for our employee is less than $20,000; therefore, the initialization fails and a <code class="literal">Failed to initialize</code> message is printed to the console.</p><p>There are times when we want to restrict access to certain parts of our code. This enables us to hide implementation details and only expose the interfaces we want to expose. This feature is handled with named access controls.</p><p>Access control allows us to restrict the access and visibility to parts of our code. This allows us to hide implementation details and only expose the interfaces we want the external code to access. We can assign specific access levels to both classes and structures. We can also assign specific access levels to properties, methods, and initializers that belong to our classes and structures.</p><p>In Swift, there are three access levels:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Public</strong>: This is the most visible access control level. It allows us to use the property, method, class, and so on anywhere we want to import the module. Basically, anything can use a property, method, class, and so on that has an access control level of public. This level is primarily used by frameworks to expose the framework's public API.</li><li class="listitem" style="list-style-type: disc"><strong>Internal</strong>: This is the default access level. This access level allows us to use the property, method, class, and so on in the defining source as well as the module that the source is in (the application or framework). If this level is used in a framework, it lets other parts of the framework use the property, method, class, and so on, but code outside the framework will be unable to access it.</li><li class="listitem" style="list-style-type: disc"><strong>Private</strong>: This is the least visible access control level. It only allows us to use the property, method, class, and so on in the source file that defines it.</li></ul></div><p>If we are writing code that will be self-contained within a single application and there is no need for it to be made available outside the application, then we can largely ignore access controls. The default access level of internal already matches this requirement. We may, however, want to hide parts of the implementation, which can be done by setting the access level to private, but that should be an exception and not the rule.</p><p>When we are <a class="indexterm" id="id302"/>developing frameworks, the access controls really become useful. We would need to mark the public facing interfaces as public, so other modules such as applications that import the framework can use them. We would then use the internal and private access control levels to mark the interfaces that we want to use internally to the framework and the source file, respectively.</p><p>To define access levels, we <a class="indexterm" id="id303"/>place the name of the level before the definition of the entity. The following code shows examples of how we would add access levels to several entities:</p><div><pre class="programlisting">private struct EmployeeStruct {}
public class EmployeeClass {}
internal class EmployeeClass2 {}
public var firstName = "Jon"
internal var lastName = "Hoffman"
private var salaryYear = 0.0
public func getFullName() -&gt; String {}
private func giveRaise(amount: Double) {}</pre></div><p>There are some limitations with access controls, but these limitations are there to ensure that access levels in Swift follow a simple guiding principle—<em>no entity can be defined in terms of another entity that has a lower (more restrictive) access level</em>. What this means is we cannot assign a higher (less restrictive) access level to an entity when it relies on another entity that has a lower (more restrictive) access level.</p><p>As following examples:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We cannot mark a method as being public when one of the arguments or the return type has an access level of private because external code would not have access to the private type</li><li class="listitem" style="list-style-type: disc">We cannot set the access level of a method or property to public when the class or structure has an access level of private because external code would not be able to access the constructor when the class is private</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec32"/>Inheritance</h1></div></div></div><p>The concept of inheritance<a class="indexterm" id="id304"/> is a basic object-oriented development concept. Inheritance allows a class to be defined as having a certain set of characteristics and then other classes can be derived from that class. The derived class inherits all of the features of the class it is inheriting from (unless the derived class overrides those characteristics) and then usually adds additional characteristics of its own.</p><p>With inheritance, we can create what is known as a class hierarchy. In a class hierarchy, the class at the top of the hierarchy is known as the <a class="indexterm" id="id305"/>
<strong>base class</strong> and the derived classes are known as <a class="indexterm" id="id306"/>
<strong>subclasses</strong>. We are not limited to only creating subclasses from a base class; we can also create <a class="indexterm" id="id307"/>subclasses from other subclasses. The class that a subclass is derived from is known as the parent or superclass. In Swift, a class can have only one parent class, known as single inheritance.</p><div><div><h3 class="title"><a id="note12"/>Note</h3><p>Inheritance is one of the fundamental differences that separate classes from structures. Classes can be derived from a parent or super class, but a structure cannot be.</p></div></div><p>Subclasses can call and access the properties, methods, and subscripts of their super class. They can also override the properties, methods, and subscripts of their super class. Subclasses can add property observers to properties that they inherit from a super class, so they can be notified when the values of the properties change. Let's look at an example that illustrates how inheritance works in Swift.</p><p>We will start off by defining a base class named <code class="literal">Plant</code>. The <code class="literal">Plant</code> class will have two properties, <code class="literal">height</code> and <code class="literal">age</code>. It will also have one method, <code class="literal">growHeight()</code>. The <code class="literal">height</code> property will represent the height of the plant, the <code class="literal">age</code> property will represent the age of the plant, and the <code class="literal">growHeight()</code> method will be used to increase the height of the plant. Here is how we would define the <code class="literal">Plant</code> class:</p><div><pre class="programlisting">class Plant {
    var height = 0.0
    var age = 0
   
    func growHeight(inches: Double) {
        self.height +=  inches;
    }
}</pre></div><p>Now that we have our <code class="literal">Plant</code> base class, let's see how we would define a subclass of it. We will name this subclass <code class="literal">Tree</code>. The <code class="literal">Tree</code> class will inherit the <code class="literal">age</code> and <code class="literal">height</code> properties of the <code class="literal">Plant</code> class and add one additional property named <code class="literal">limbs</code>. It will also inherit the <code class="literal">growHeight()</code> method of the <code class="literal">Plant</code> class and add two additional methods: <code class="literal">limbGrow()</code>, where a new limbs is grown, and <code class="literal">limbFall()</code>, where one of the limbs falls off the tree. Let's have a look at the following code:</p><div><pre class="programlisting">class Tree: Plant {
  private var limbs = 0
 
  func limbGrow() {
    self.limbs++
  }
  func limbFall() {
    self.limbs--
  }
}</pre></div><p>We indicate that a <a class="indexterm" id="id308"/>class has a super class by adding a colon and the name of the super class to the end of the class definition. In the <code class="literal">Tree</code> example, we indicated that the <code class="literal">Tree</code> class has a super class named <code class="literal">Plant</code>.</p><p>Now, let's look at how we could use the <code class="literal">Tree</code> class that inherited the <code class="literal">age</code> and <code class="literal">height</code> properties from the <code class="literal">Plant</code> class:</p><div><pre class="programlisting">var tree = Tree()
tree.age = 5
tree.height = 4
tree.limbGrow()
tree.limbGrow()</pre></div><p>The preceding example begins by creating an instance of the <code class="literal">Tree</code> class. We then set the <code class="literal">age</code> and <code class="literal">height</code> properties to <code class="literal">5</code> and <code class="literal">4</code>, respectively, and add two limbs to the tree by calling the <code class="literal">limbGrow()</code> method twice.</p><p>We now have a base class named <code class="literal">Plant</code> that has a subclass named <code class="literal">Tree</code>. This means that the super (or parent) class of <code class="literal">Tree</code> is the <code class="literal">Plant</code> class. This also means that one of the subclasses (or child classes) of <code class="literal">Plant</code> is named <code class="literal">Tree</code>. There are, however, lots of different kinds of trees in the world. Let's create two subclasses from the <code class="literal">Tree</code> class. These subclasses will be the <code class="literal">PineTree</code> class and the <code class="literal">OakTree</code> class:</p><div><pre class="programlisting">class PineTree: Tree {
  var needles = 0
}

class OakTree: Tree {
  var leaves = 0
}</pre></div><p>The class hierarchy now looks like this:</p><div><img alt="Inheritance" src="img/B05115_05_01.jpg"/></div><p>It is important to keep in mind that in Swift, a class can have multiple subclasses; however, a class can have only one super class. There are times when a subclass needs to provide its own implementation of a method or property that it inherited from its super class. This is known as overriding.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec33"/>Overriding methods and properties</h1></div></div></div><p>To override a<a class="indexterm" id="id309"/> method, property, or subscript, we need to prefix the <a class="indexterm" id="id310"/>definition with the <code class="literal">override</code> keyword. This tells the compiler that we intend to override something in the super class and that we did not make a duplicate definition by mistake. The <code class="literal">override</code> keyword does prompt the Swift compiler to verify that the super class (or one of its parents) has <a class="indexterm" id="id311"/>a matching declaration that can be overridden. If it cannot find a matching declaration in one of the super classes, an error will be thrown.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec100"/>Overriding methods</h2></div></div></div><p>Let's look at how <a class="indexterm" id="id312"/>we would override a method. We will start by adding a <code class="literal">getDetails()</code> method to the <code class="literal">Plant</code> class that we will then override in the child classes. The following code shows how the new Plant class looks similar to with the <code class="literal">getDetails()</code> method added:</p><div><pre class="programlisting">class Plant {
  var height = 0.0
  var age = 0
 
  func growHeight(inches: Double) {
    self.height +=  inches;
  }
  
  func getDetails() -&gt; String {
    return "Plant Details"
  }
}</pre></div><p>Now let's see how we would override the <code class="literal">getDetails()</code> method in the <code class="literal">Tree</code> class:</p><div><pre class="programlisting">class Tree: Plant {
  private var limbs = 0
  
  func limbGrow() {
    self.limbs++
  }
  func limbFall() {
    self.limbs--
  }
  
  override func getDetails() -&gt; String {
    return "Tree Details"
  }
}</pre></div><p>The thing to note here is that we do not use the <code class="literal">override</code> keyword in the <code class="literal">Plant</code> class because it is the first class to implement this method; however, we do include it in the <code class="literal">Tree</code> class since we are overriding the <code class="literal">getDetails()</code> method from the <code class="literal">Plant</code> class. Now, let's see what happens if we call the <code class="literal">getDetails()</code> method from an instance of the <code class="literal">Plant</code> and <code class="literal">Tree</code> classes:</p><div><pre class="programlisting">var plant = Plant()
var tree = Tree()
print("Plant: \(plant.getDetails())")
print("Tree: \(tree.getDetails())")</pre></div><p>The previous example <a class="indexterm" id="id313"/>would print the following two lines to the console:</p><div><pre class="programlisting">Plant: Plant Details
Tree: Tree Details</pre></div><p>As we can see, the <code class="literal">getDetails()</code> method in the <code class="literal">Tree</code> subclass overrides the <code class="literal">getDetails()</code> of its parent <code class="literal">Plant</code> class.</p><p>Inside the <code class="literal">Tree</code> class, we can still call the <code class="literal">getDetails()</code> method (or any overridden method, property, or subscript) of its super class by using the <code class="literal">super</code> prefix. Let's see how we would call the <code class="literal">getDetails()</code> method of the <code class="literal">Plant</code> class from an instance of the <code class="literal">Tree</code> class. We will begin by replacing the <code class="literal">getDetails()</code> method in the <code class="literal">Plant</code> class with the following method that will generate a string containing the values of the <code class="literal">height</code> and <code class="literal">age</code> properties. Let's take a look at the following code:</p><div><pre class="programlisting">func getDetails() -&gt; String {
    return "Height:  \(height)  age:  \(age)"
}</pre></div><p>In the preceding code, we are changing the <code class="literal">getDetails()</code> method to return a string that contains the <code class="literal">height</code> and <code class="literal">age</code> of the plant. Now let's replace the <code class="literal">getDetails()</code> method for the <code class="literal">Tree</code> class with the following method:</p><div><pre class="programlisting">override func getDetails() -&gt; String {
  var details = super.getDetails()
  return "\(details)  limbs:  \(limbs)"
}</pre></div><p>In the preceding example, we begin by calling the <code class="literal">getDetails()</code> method of the super class (the <code class="literal">Plant</code> class in this case) to get a string containing the tree's <code class="literal">height</code> and <code class="literal">age</code>. We then build a new string object that contains the results of the <code class="literal">getDetails()</code> method from the super class, adds the number of limbs to it and then returns it. Let's look at what happens if we call the <code class="literal">getDetails()</code> method of the <code class="literal">Tree</code> class:</p><div><pre class="programlisting">var tree = Tree()
tree.age = 5
tree.height = 4
tree.limbGrow()
tree.limbGrow()
print(tree.getDetails())</pre></div><p>If we run the <a class="indexterm" id="id314"/>preceding code, the following line would be printed to the console:</p><div><pre class="programlisting">Height:  4.0  age:  5  limbs:  2</pre></div><p>As we can see, the string that is returned contains the <code class="literal">height</code> and <code class="literal">age</code> information from the <code class="literal">Plant</code> class and the limbs information from the <code class="literal">Tree</code> class.</p><p>We can also chain the overridden methods. Let's see what happens if we add the following method to the <code class="literal">OakTree</code> class:</p><div><pre class="programlisting">override func getDetails() -&gt; String {
  let details = super.getDetails()
  return "\(details)  Leaves:  \(leaves)"
}</pre></div><p>When we call the <code class="literal">getDetails()</code> method of an instance of the <code class="literal">OakTree</code> class, it calls the <code class="literal">getDetails()</code> method of its super class (the <code class="literal">Tree</code> class). The <code class="literal">getDetails()</code> method of the <code class="literal">Tree</code> class also calls the <code class="literal">getDetails()</code> method of its super class (the <code class="literal">Plant</code> class). The <code class="literal">getDetails()</code> method of the <code class="literal">Tree</code> class will finally create a string object that contains the <code class="literal">height</code> and <code class="literal">age</code> from the <code class="literal">Plant</code> class, the <code class="literal">limbs</code> from the <code class="literal">Tree</code> class, and the <code class="literal">leaves</code> from the <code class="literal">OakTree</code> class. Let's look at an example of this:</p><div><pre class="programlisting">var tree = OakTree()
tree.age = 5
tree.height = 4
tree.leaves = 50
tree.limbGrow()
tree.limbGrow()
print(tree.getDetails())</pre></div><p>If we run the preceding code, we would see the following line printed to the console:</p><div><pre class="programlisting">Height:  4.0  age:  5  limbs:  2  Leaves:  50</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec101"/>Overriding properties</h2></div></div></div><p>We can provide <a class="indexterm" id="id315"/>custom <code class="literal">getter</code> and <code class="literal">setter</code> to override any inherited property. When we override a property, we must provide the name and the type of property we are overriding, so the compiler can verify one of the classes in the class hierarchy has a matching property to override. While overriding properties are not as common as overriding methods, it is good for us to know how to do this when we need.</p><p>Let's see how we would override a property by adding the following method to our <code class="literal">Plant</code> class:</p><div><pre class="programlisting">var description: String {
  get {
    return "Base class is Plant."
  }
}</pre></div><p>The <code class="literal">description</code> property is a basic read-only property. This property returns the string, <code class="literal">Base class is Plant.</code>. Now let's override this property by adding the following property to the <code class="literal">Tree</code> class:</p><div><pre class="programlisting">override var description: String {
  return "\(super.description)  I am a Tree class."
}</pre></div><p>When we override a <a class="indexterm" id="id316"/>property, we use the same <code class="literal">override</code> keyword that we use when we override a method. The <code class="literal">override</code> keyword tells the compiler that we want to override a property, so the compiler can verify that another class in the class hierarchy contains a matching property to override. We then implement the property as we would any other property. Calling the <code class="literal">description</code> property of the tree would result in the <code class="literal">Base class is Plant. I am a Tree class.</code>. string being returned.</p><p>There are times when we want to prevent a subclass from overriding the properties and methods. There are also times when we want to prevent an entire class from being subclassed. Let's see how we do this.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec102"/>Preventing overrides</h2></div></div></div><p>To prevent <a class="indexterm" id="id317"/>overrides or subclassing, we use the <code class="literal">final</code> keyword. To use the <code class="literal">final</code> keyword, we add it before the item's definition. Examples are <code class="literal">final func</code>, <code class="literal">final var</code>, and <code class="literal">final class</code>.</p><p>Any attempt to override an item marked final will throw a compile-time error.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec34"/>Protocols</h1></div></div></div><p>There are times<a class="indexterm" id="id318"/> when we would like to describe the implementations (methods, properties, and other requirements) of a class without actually providing the implementation. For this, we would use protocols.</p><p>Protocols define a blueprint of methods, properties, and other requirements for a class or a structure. A class or a structure can then provide an implementation that conforms to those requirements. The class or structure that provides the implementation is said to conform to the protocol.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec35"/>Protocol syntax</h1></div></div></div><p>The syntax to<a class="indexterm" id="id319"/> define a protocol is very similar to how we define a class or a structure. The following example shows the syntax used to define a protocol:</p><div><pre class="programlisting">protocol MyProtocol {
  //protocol definition here
}</pre></div><p>We state that a class or structure conforms to a particular protocol by placing the name of the protocol after the class or structure's name, separated by a colon. Here is an example of how we would state that a class conforms to the <code class="literal">MyProtocol</code> protocol:</p><div><pre class="programlisting">class myClass: MyProtocol {
  //class implementation here
}</pre></div><p>A class or a structure can conform to multiple protocols. We would list the protocols that the class or structure conforms to by separating them with commas. The following example shows how we would state that our class conforms to multiple protocols:</p><div><pre class="programlisting">class MyClass: MyProtocol, AnotherProtocol, ThirdProtocol {
  // class implementation here
}</pre></div><p>When we need a class to inherit from a super class and implement a protocol, we would list the super class first, followed by the protocols. The following example illustrates this:</p><div><pre class="programlisting">Class MyClass: MySuperClass, MyProtocol, MyProtocol2 {
  // Class implementation here
}</pre></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec103"/>Property requirements</h2></div></div></div><p>A protocol can <a class="indexterm" id="id320"/>require that the conforming class or structure provide certain properties with a specified name and type. The protocol does not say if the property should be a stored or computed property because the implementation details are left up to the conforming class or structure.</p><p>When defining a property within a protocol, we must specify whether the property is a read-only or a read-write property by using the <code class="literal">get</code> and <code class="literal">set</code> keywords. Let's look at how we would define properties within a protocol by creating a <code class="literal">FullName</code> protocol:</p><div><pre class="programlisting">protocol FullName {
  var firstName: String {get set}
  var lastName: String {get set}
}</pre></div><p>The <code class="literal">FullName</code> protocol defines two properties, which any class or structure that conforms to the protocol must implement. These are the <code class="literal">firstName</code> and <code class="literal">lastName</code> properties. Both these properties in the <code class="literal">FullName</code> protocol are read-write properties. If we wanted to <a class="indexterm" id="id321"/>specify that the property is read-only, we would define it with only the <code class="literal">get</code> keyword, like this:</p><div><pre class="programlisting"> var readOnly: String {get}</pre></div><p>Let's see how we would create a <code class="literal">Scientist</code> class that conforms to this protocol:</p><div><pre class="programlisting">class Scientist: FullName {
  var firstName = ""
  var lastName = ""
}</pre></div><p>If we had forgotten to include either the <code class="literal">firstName</code> or <code class="literal">lastName</code> property, we would have received a <code class="literal">Scientist does not conform to protocol 'FullName'</code> error message. We also need to make sure that the type of the property is the same. For example, if we changed the <code class="literal">lastName</code> definition in the <code class="literal">Scientist</code> class to <code class="literal">var lastName = 42</code>, we would also receive a <code class="literal">Scientist does not conform to protocol 'FullName'</code> error message because the protocol specifies that we must have a <code class="literal">lastName</code> property of the string type.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec104"/>Method requirements</h2></div></div></div><p>A protocol can require<a class="indexterm" id="id322"/> that the conforming class or structure provide certain methods. We define a method within a protocol exactly as we do within a normal class or structure, except without the curly braces or method body. Let's add a <code class="literal">getFullName()</code> method to our <code class="literal">FullName</code> protocol and <code class="literal">Scientist</code> class.</p><p>The following example shows how the <code class="literal">FullName</code> protocol would look with the <code class="literal">getFullName()</code> method added:</p><div><pre class="programlisting">protocol FullName {
  var firstName: String {get set}
  var lastName: String {get set}

  func getFullName() -&gt; String
}</pre></div><p>Now, we will need to add a <code class="literal">getFullName()</code> method to our Scientist class so that it will properly conform to the <code class="literal">FullName</code> protocol:</p><div><pre class="programlisting">class Scientist: FullName {
  var firstName = ""
  var lastName = ""
  var field = ""   

  func getFullName() -&gt; String {
    return "\(firstName) \(lastName) studies \(field)"
  }
}</pre></div><p>Structures can conform to Swift protocols exactly as classes do. The following example shows how we<a class="indexterm" id="id323"/> can create a <code class="literal">FootballPlayer</code> structure that conforms to the <code class="literal">FullName</code> protocol:</p><div><pre class="programlisting">struct FootballPlayer: FullName {
    var firstName = ""
    var lastName = ""
    var number = 0
   
    func getFullName() -&gt; String {
        return "\(firstName) \(lastName) has the number \(number)"
    }
}</pre></div><p>When a class or structure conforms to a Swift protocol, we can be sure that it has implemented the required properties and methods. This can be very useful when we want to ensure that certain properties or methods are implemented over various classes, as our preceding examples show.</p><p>Protocols are also very useful when we want to decouple our code from requiring specific classes or structures. The following code shows how we would decouple our code using the <code class="literal">FullName</code> protocol, the <code class="literal">Scientist</code> class, and the <code class="literal">FootballPlayer</code> structure that we have already built:</p><div><pre class="programlisting">var scientist = Scientist()
scientist.firstName = "Kara"
scientist.lastName = "Hoffman"
scientist.field = "Physics"

var player = FootballPlayer();
player.firstName = "Dan"
player.lastName = "Marino"
player.number = 13

var person: FullName
person = scientist
print(person.getFullName())
person = player
print(player.getFullName())</pre></div><p>In the preceding code, we begin by creating an instance of the <code class="literal">Scientist</code> class and the <code class="literal">FootballPlayer</code> structure. We then create a <code class="literal">person</code> variable that is of the <code class="literal">FullName</code> (protocol) type and set it to the <code class="literal">scientist</code> instance that we just created. We then call the <code class="literal">getFullName()</code> method to retrieve our description. This will print out the <code class="literal">Kara Hoffman studies Physics</code> message to the console.</p><p>We then set the <code class="literal">person</code> variable <a class="indexterm" id="id324"/>equal to the <code class="literal">player</code> instance and call the <code class="literal">getFullName()</code> method again. This will print out the <code class="literal">Dan Marino has the number 13</code> message to the console.</p><p>As we can see, the <code class="literal">person</code> variable does not care what the actual implementation class or structure is. Since we defined the <code class="literal">person</code> variable to be of the <code class="literal">FullName</code> type, we can set the <code class="literal">person</code> variable to an instance of any class or structure that conforms to the <code class="literal">FullName</code> protocol.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec105"/>Optional requirements</h2></div></div></div><p>There are times when we <a class="indexterm" id="id325"/>want protocols to define optional requirements, that is, methods or properties that are not required to be implemented. To use optional requirements, we need to start off by marking the protocol with the <code class="literal">@objc</code> attribute. To mark a property or method as optional, we use the <code class="literal">optional</code> keyword.</p><div><div><h3 class="title"><a id="note13"/>Note</h3><p>One very important thing to note about using the <code class="literal">@objc</code> attribute is that only classes can adopt protocols marked with it; structures cannot adopt these protocols.</p></div></div><p>Let's look at how we would use the <code class="literal">optional</code> keyword to define optional properties and methods:</p><div><pre class="programlisting">@objc protocol Phone {
  var phoneNumber: String {get set}
  optional var emailAddress: String {get set}
  
  func dialNumber()
  optional func getEmail()
}</pre></div><p>In the <code class="literal">Phone</code> protocol we just created, we defined a required property named <code class="literal">phoneNumber</code>, and an optional property named <code class="literal">emailAddress</code>. Also, in the <code class="literal">Phone</code> protocol, we defined a required function named <code class="literal">dialNumber()</code> and an optional function named <code class="literal">getEmail()</code>. This means that a class that adopts the <code class="literal">Phone</code> protocol must provide a <code class="literal">phoneNumber</code> property and a <code class="literal">dialNumber()</code> method. A class that adopts the Phone protocol can also optionally provide an <code class="literal">emailAddress</code> property and a <code class="literal">getEmail()</code> method, but it is not required too.</p><p>Swift 2 adds protocol extensions to Swift. This is a very exciting and important feature in the Swift language. To read about protocol extensions, please refer to <a class="link" href="ch06.html" title="Chapter 6. Using Protocols and Protocol Extensions">Chapter 6</a>, <em>Using Protocols and Protocol Extensions</em>.</p><p>There are times <a class="indexterm" id="id326"/>when we need to add additional functionality to an existing class or structure. To do this, we use extensions.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec36"/>Extensions</h1></div></div></div><p>With extensions, we <a class="indexterm" id="id327"/>can add new properties, methods, initializers, and subscripts, or make an existing class or structure conform to a protocol. One thing to note is that extensions cannot override the existing functionality.</p><p>To define an extension, we<a class="indexterm" id="id328"/> use the <code class="literal">extension</code> keyword, followed by the type that we are extending. The following example shows how we would create an extension that extends the string class:</p><div><pre class="programlisting">extension String {
  //add new functionality here
}</pre></div><p>Let's see how extensions work by adding a <code class="literal">reverse()</code> method and a <code class="literal">firstLetter</code> property to Swift's standard string class:</p><div><pre class="programlisting">extension String {
    var firstLetter: Character {
        get {
            return self.characters.first
        }
    }

    func reverse() -&gt; String {
        var reverse = ""
        for letter in self.characters {
            reverse = "\(letter)" + reverse
        }
        return reverse
    }
}</pre></div><p>When we extend an existing class or structure, we define properties, methods, initializers, subscripts, and protocols in exactly the same way as we would normally define them in a standard class or structure. In the string extension example, we see that we define the <code class="literal">reverse()</code> method and the <code class="literal">firstLetter</code> property exactly as we would define them in a normal class.</p><p>Extensions are very useful for adding additional functionality to classes and structures from external frameworks, even for Apple's frameworks, as demonstrated in the examples. It is preferred to use extensions to add additional functionality to classes from external frameworks rather than subclassing because it allows us to use the classes provided by the frameworks throughout our code.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec37"/>Memory management</h1></div></div></div><p>As I mentioned at the<a class="indexterm" id="id329"/> start of this chapter, structures are value types and classes are reference types. What this means is that when we pass an instance of a structure within our application, such as a parameter of a method, we create a new instance of the structure in the memory. This new instance of the structure is only valid while the application is in the scope where the structure was created. Once the structure goes out of scope, the new instance of the structure is destroyed and the memory is released. This makes memory management of structures pretty easy and somewhat painless.</p><p>Classes, on the other hand, are of the reference type. This means that we allocate the memory for the instance of the class only once when it is initially created. When we want to pass an instance of the class within our application, as either a function argument or by assigning it to a variable, we really pass a reference to where the instance is stored in the memory. Since the instance of a class may be referenced in multiple scopes (unlike a structure), it cannot be automatically destroyed, and memory is not released when it goes out of scope if it is referenced in another scope. Therefore, Swift need some form of memory management to track and release the memory used by instances of classes when the class is no longer needed. Swift uses <a class="indexterm" id="id330"/>
<strong>Automatic Reference Counting (ARC)</strong> to track and manage memory usage.</p><p>With ARC, for the most part, memory management in Swift simply works. ARC will automatically track the references to instances of classes, and when an instance is no longer needed (no references pointing to it), ARC will automatically destroy the instance and release the memory. There are a few instances where ARC requires additional information about relationships to properly manage the memory. Before we look at the instances where ARC needs help, let's look at how memory management and ARC work.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec106"/>Reference versus value types</h2></div></div></div><p>Let's look at an <a class="indexterm" id="id331"/>example that illustrates how a reference type (instance of a class) and a value type (instance of a structure or a variable) are passed to a function. We will begin by defining a new class named <code class="literal">MyClass</code> and a new structure named <code class="literal">MyStruct</code>. The <code class="literal">MyClass</code> class and the <code class="literal">MyStruct</code> structure each contain one property named <code class="literal">name</code>:</p><div><pre class="programlisting">class MyClass {
  var name = ""
}

struct MyStruct {
  var name = ""
}</pre></div><p>We will now create a function that will accept, as parameters, one instance of the <code class="literal">MyClass</code> class and one instance of the <code class="literal">MyStruct</code> struct. Within the function, we will change the value of the <code class="literal">name</code> property of both the <code class="literal">MyClass</code> class and the <code class="literal">MyStruct</code> structure. Then, by examining the value of that property once the function exits, we will be able to see how instances of a class and structure are passed to functions. Here is the code for the <code class="literal">showPass()</code> function:</p><div><pre class="programlisting">func showPass(myc: MyClass, var mys: MyStruct) {
    print("Received Class: \(myc.name) Struct: \(mys.name)")
    myc.name = "Set in function - class"
    mys.name = "Set in function - struct"
    print("Set  Class: \(myc.name) Struct: \(mys.name)")
}</pre></div><p>In the <code class="literal">showPass()</code> function, we print the values of the named properties for both the <code class="literal">MyClass</code> and <code class="literal">MyStruct</code> instances to the console. We then change the values of the named properties and reprint the values to the console again. This will show us the value of the properties when the function first begins and the value after the properties were changed (just before the function exits).</p><p>Now, to see how a reference type and a value type are passed to a function, we will create an instance of both the <code class="literal">MyClass</code> class and the <code class="literal">MyStruct</code> structure, set the values of the <code class="literal">name</code> properties, and pass those instances to the <code class="literal">showPass()</code> function. The function will then change the values of the <code class="literal">name</code> properties and then return control back to the code that calls it. Finally, we will examine the value of the name properties after the <code class="literal">showPass()</code> function exits to see whether they have their original value or the value set in the function. Here is the code to do this:</p><div><pre class="programlisting">var mci = MyClass()
mci.name = "set in main - class"

var msi = MyStruct()
msi.name = "set in main - struct"

print("Main  Class: \(mci.name) Struct: \(msi.name)")

showPass(mci, msi)
print("Main  Class: \(mci.name) Struct: \(msi.name)")</pre></div><p>If we run this code, we see the following output:</p><div><pre class="programlisting">Received Class: set in main - class Struct: set in main - struct
Set Class: Set in function - class Struct: Set in function - struct
Main Class: Set in function - class Struct: set in main – struct</pre></div><p>As we can see <a class="indexterm" id="id332"/>from the output, the <code class="literal">showPass()</code> function receives the instance of the class and structure with the name properties set to <code class="literal">set in main - class</code> and <code class="literal">set in main - struct</code>, respectively. Next, just before the function exits we see, that the <code class="literal">name</code> property of the class is set to <code class="literal">Set in function - class</code> and the <code class="literal">name</code> property of the structure is set to <code class="literal">Set in function - struct</code>. Finally, when the function exits and we are back to the main part of the code, we see that the <code class="literal">name</code> property of the class is set to <code class="literal">Set in function - class</code>, which was set in the <code class="literal">showPass()</code> function. However, the <code class="literal">name</code> property of the structure has the value that was originally set prior to calling the function, <code class="literal">set in main - struct</code>.</p><p>This example illustrates that when we pass a reference type (instance of a class) to a function, we are passing a reference to the original class that means any changes we make are kept when the function exits. When we pass a value type (instance of a structure or a variable) to a function, we are passing the value (copy of the instance), which means any changes that we make are made to the local copy and are lost once the function exits.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec107"/>The working of ARC</h2></div></div></div><p>Whenever we create a <a class="indexterm" id="id333"/>new instance of a class, ARC allocates the memory needed to store that class. This ensures that there is enough memory to store the information associated with that instance of the class, and also locks the memory so that nothing overwrites it. When the instance of the class is no longer needed, ARC will release the memory allocated for the class so that it can be used for other purposes. This ensures that we are not tying up memory that is no longer needed.</p><p>If ARC were to release the memory for an instance of a class that we still needed, it would not be possible to retrieve the class information from memory. If we did try to access the instance of the class after the memory was released, there is a possibility that our application would crash. To ensure memory is not released for an instance of a class that is still needed, ARC counts how many times the instance is referenced (how many active properties, variables, or constants are pointing to the instance of the class). Once the reference count for an instance of a class equals zero (nothing is referencing the instance), the memory is released.</p><p>All of the previous <a class="indexterm" id="id334"/>examples run properly in a Playground, the following examples will not. When we run sample code in a Playground, ARC does not release objects that we create; this is by design so that we can see how the application runs and also the state of the objects at each step. Therefore, we will need to run these samples as an iOS or OS X project. Let's look at an example of how ARC works.</p><p>We begin by creating a <code class="literal">MyClass</code> class with the following code:</p><div><pre class="programlisting">class MyClass {
  var name = ""
  init(name: String) {
    self.name = name
    print("Initializing class with name \(self.name)")
  }
  deinit {
   print("Releasing class with name \(self.name)")
  }
}</pre></div><p>This class is very similar to our previous <code class="literal">MyClass</code> class, except that we add a deinitializer that is called just before an instance of the class is destroyed and removed from memory. This deinitializer prints out a message to the console that lets us know that the instance of the class is about to be removed.</p><p>Now, let's look at the code that shows how ARC creates and destroys instances of a class:</p><div><pre class="programlisting">  var class1ref1: MyClass? = MyClass(name: "One")
  var class2ref1: MyClass? = MyClass(name: "Two")
  var class2ref2: MyClass? = class2ref1
  
  print("Setting class1ref1 to nil")
  class1ref1 = nil
  
  print("Setting class2ref1 to nil")
  class2ref1 = nil
  
  print("Setting class2ref2 to nil")
  class2ref2 = nil</pre></div><p>In the example, we begin by creating two instances of the <code class="literal">MyClass</code> class named <code class="literal">class1ref1</code> (which stands for class 1 reference 1) and <code class="literal">class2ref1</code> (which stands for class 2 reference 1). We then create a second reference to <code class="literal">class2ref1</code> named <code class="literal">class2ref2</code>. Now, in order to see how ARC works, we need to begin setting the references to nil. We start out by setting the <code class="literal">class1ref1</code> to <code class="literal">nil</code>. Since there is only one reference to <code class="literal">class1ref1</code>, the deinitializer will be called. Once the deinitializer completes its task, in our case, it prints a message to the console<a class="indexterm" id="id335"/> letting us know that the instance of the class has been destroyed and the memory has been released.</p><p>We then set the <code class="literal">class2ref1</code> to nil, but there is a second reference to this class (<code class="literal">class2ref2</code>) that prevents ARC from destroying the instance so that the deinitializer is not called. Finally, we set <code class="literal">class2ref2</code> to nil, which allows ARC to destroy this instance of the <code class="literal">MyClass</code> class.</p><p>If we run this code, we will see the following output, which illustrates how ARC works:</p><div><pre class="programlisting">Initializing class with name One
Initializing class with name Two
Setting class1ref1 to nil
Releasing class with name One
Setting class2ref1 to nil
Setting class2ref2 to nil
Releasing class with name Two</pre></div><p>From the example, it seems that ARC handles memory management very well. However, it is possible to write code that will prevent ARC from working properly.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec108"/>Strong reference cycles</h2></div></div></div><p>A strong reference cycle<a class="indexterm" id="id336"/> is where the instance of two classes holds a strong reference to each other, preventing ARC from releasing either instance. Strong reference cycles are a lot easier to understand with an example, so let's create one. Once again, we are not able to use a Playground for this example, so we need to create an Xcode project. In the project, we start off by creating two classes named <code class="literal">MyClass1</code> and <code class="literal">MyClass2</code> with the following code:</p><div><pre class="programlisting">class MyClass1 {
  var name = ""
  var class2: MyClass2?

  init(name: String) {
    self.name = name
    print("Initializing class with name \(self.name)")
  }
  deinit {
    print("Releaseing class with name \(self.name)")
  }
  
}

class MyClass2 {
  var name = ""
  var class1: MyClass1?

  init(name: String) {
    self.name = name
    print("Initializing class2 with name \(self.name)")
  }
  deinit {
    print("Releaseing class2 with name \(self.name)")
  }

}</pre></div><p>As we can see <a class="indexterm" id="id337"/>from the code, <code class="literal">MyClass1</code> contains an instance of <code class="literal">MyClass2</code>; therefore, the instance of <code class="literal">MyClass2</code> cannot be released until <code class="literal">MyClass1</code> is destroyed. We can also see from the code that <code class="literal">MyClass2</code> contains an instance of <code class="literal">MyClass1</code>; therefore, the instance of <code class="literal">MyClass1</code> cannot be released until <code class="literal">MyClass2</code> is destroyed. This creates a cycle of dependency in which neither instance can be destroyed until the other one is destroyed. Let's see how this works by running the following code:</p><div><pre class="programlisting">var class1: MyClass1? = MyClass1(name: "Class1")
var class2: MyClass2? = MyClass2(name: "Class2")
//class1 and class2 each have a reference count of 1
       .
class1?.class2 = class2
//Class2 now has a reference count of 2
class2?.class1 = class1
//class1 now has a reference count of 2
       .
print("Setting classes to nil")
class2 = nil
//class2 now has a reference count of 1, not destroyed
class1 = nil
//class1 now has a reference count of 1, not destroyed</pre></div><p>As we can see from the comments in the example, the reference counters for each instance never reaches zero; therefore, ARC cannot destroy the instances, thereby creating a memory leak. A memory leak is where an application continues to use memory but does not properly release it. This can cause an application to eventually crash.</p><p>To resolve a strong reference cycle, we need to prevent one of the classes from keeping a strong hold on the instance of the other class, thereby allowing ARC to destroy them both. Swift provides two ways of doing this by letting us define the properties as either a weak reference or an unowned reference.</p><p>The difference <a class="indexterm" id="id338"/>between a weak reference and an unowned reference is that the instance which a weak reference refers to can be nil, whereas the instance that an unowned reference is referring to cannot be nil. This means that when we use a weak reference, the property must be an optional property since it can be nil. Let's see how we would use unowned and weak references to resolve a strong reference cycle. Let's start by looking at the unowned reference.</p><p>We begin by creating two more classes, <code class="literal">MyClass3</code> and <code class="literal">MyClass4</code>:</p><div><pre class="programlisting">class MyClass3 {
    var name = ""
    unowned let class4: MyClass4

    init(name: String, class4: MyClass4) {
        self.name = name
        self.class4 = class4
        print("Initializing class3 with name \(self.name)")
    }
    deinit {
        print("Releasing class3 with name \(self.name)")
    }
   
}

class MyClass4{
    var name = ""
    var class3: MyClass3?

    init(name: String) {
        self.name = name
        print("Initializing class4 with name \(self.name)")
    }
    deinit {
        print("Releasing class4 with name \(self.name)")
    }
}</pre></div><p>The <code class="literal">MyClass4</code> class looks pretty similar to the <code class="literal">MyClass1</code> and <code class="literal">MyClass2</code> classes in the preceding example. What is different here is the <code class="literal">MyClass3</code> class. In the <code class="literal">MyClass3</code> class, we set the <code class="literal">class4</code> property to <code class="literal">unowned</code>, which means it cannot be nil and it does not keep a strong reference to the <code class="literal">MyClass4</code> instance that it is referring to. Since the <code class="literal">class4</code> property cannot be <code class="literal">nil</code>, we also need to set it when the class is initialized.</p><p>Now let's see how we can initialize and deinitialize the instances of these classes with the following code:</p><div><pre class="programlisting">var class4 = MyClass4(name: "Class4")
var class3: MyClass3? = MyClass3(name: "class3", class4: class4)
    
class4.class3 = class3
    
print("Classes going out of scope")</pre></div><p>In the preceding code, we<a class="indexterm" id="id339"/> create an instance of the <code class="literal">MyClass4</code> class and then use that instance to create an instance of the <code class="literal">MyClass3</code> class. We then set the <code class="literal">class3</code> property of the <code class="literal">MyClass4</code> instance to the <code class="literal">MyClass3</code> instance we just created. This creates a reference cycle of dependency between the two classes again, but this time, the <code class="literal">MyClass3</code> instance is not keeping a strong hold on the <code class="literal">MyClass4</code> instance, allowing ARC to release both instances when they are no longer needed.</p><p>If we run this code, we see the following output, showing that both the <code class="literal">MyClass3</code> and <code class="literal">MyClass4</code> instances are released and the memory is freed:</p><div><pre class="programlisting">Initializing class4 with name Class4
Initializing class3 with name class3
Classes going out of scope.
Releasing class4 with name Class4
Releasing class3 with name class3</pre></div><p>Now let's look at how we would use a weak reference to prevent a strong reference cycle. We begin by creating two new classes:</p><div><pre class="programlisting">class MyClass5 {
  var name = ""
  var class6: MyClass6?
  init(name: String) {
    self.name = name
    print("Initializing class5 with name \(self.name)")
  }
  deinit {
    print("Releasing class5 with name \(self.name)")
  }
}

class MyClass6 {
  var name = ""
  weak var class5: MyClass5?
  init(name: String) {
    self.name = name
    print("Initializing class6 with name \(self.name)")
  }
  deinit {
    print("Releasing class6 with name \(self.name)")
  }
}</pre></div><p>The <code class="literal">MyClass5</code> and <code class="literal">MyClass6</code> classes<a class="indexterm" id="id340"/> look very similar to the <code class="literal">MyClass1</code> and <code class="literal">MyClass2</code> classes we created earlier to show how a strong reference cycle works. The big difference is that we define the <code class="literal">class5</code> property in the <code class="literal">MyClass6</code> class as a weak reference.</p><p>Now, let's see how we can initialize and deinitialize instances of these classes with the following code:</p><div><pre class="programlisting">var class5: MyClass5? = MyClass5(name: "Class5")
var class6: MyClass6? = MyClass6(name: "Class6")
   
class5?.class6 = class6
class6?.class5 = class5
   
print("Classes going out of scope ")</pre></div><p>In the preceding code, we create instances of the <code class="literal">MyClass5</code> and <code class="literal">MyClass6</code> classes and then set the properties of those classes to point to the instance of the other class. Once again, this creates a cycle of dependency, but since we set the <code class="literal">class5</code> property of the <code class="literal">MyClass6</code> class to weak, it does not create a strong reference, allowing both instances to be released.</p><p>If we run the code, we will see the following output, showing that both the <code class="literal">MyClass5</code> and <code class="literal">MyClass6</code> instances are released and the memory is freed:</p><div><pre class="programlisting">Initializing class5 with name Class5
Initializing class6 with name Class6
Classes going out of scope.
Releasing class5 with name Class5
Releasing class6 with name Class6</pre></div><p>It is recommended that we avoid creating circular dependencies, as shown in this section, but there are times when we need them. For those times, remember that ARC does need some help to release them.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec38"/>Summary</h1></div></div></div><p>As this chapter ends, we end the introduction to the Swift programming language. At this point, we have enough knowledge of the Swift language to begin writing our own applications; however, there is still much to learn.</p><p>In the following chapters, we will look in more depth at some of the concepts that we already discussed, such as optionals and subscripts. We will also show how we would perform common tasks with Swift, such as parsing common file formats and handling concurrency. Finally, we will also have some chapters that will help us write better code like a sample Swift style guide, and a chapter on design patterns.</p></div></body></html>