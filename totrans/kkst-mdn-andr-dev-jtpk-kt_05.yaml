- en: '*Chapter 4*: Handling Async Operations with Coroutines'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''re focusing on another library that, although is not in
    the Jetpack library suite, is essential for writing solid applications: **Kotlin
    coroutines**.'
  prefs: []
  type: TYPE_NORMAL
- en: Coroutines represent a more convenient way of handling async work and concurrency
    jobs on Android.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will study how we can replace callbacks with coroutines
    in our Restaurants application. In the first section, *Introducing Kotlin coroutines*,
    we will gain a better understanding of what coroutines are, how they work, and
    why we need them in our apps.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, *Exploring the basic elements of coroutines*, we will explore
    the core elements of coroutines, and we will understand how to use them to handle
    asynchronous work more concisely.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the *Using coroutines for async work* section, we will implement
    coroutines in our Restaurants application and let them handle the network requests.
    Additionally, we will add error handling and integrate some of the best practices
    when working with coroutines in Android apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, in this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Kotlin coroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the basic elements of coroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using coroutines for async work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before jumping in, let's set up the technical requirements for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building Compose-based Android projects with coroutines usually requires your
    day-to-day tools. However, to follow along with this chapter smoothly, make sure
    you have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer
    Android Studio version or even Canary builds but note that IDE interface and other
    generated code files might differ from the ones used throughout this book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kotlin 1.6.10, or a newer plugin, installed in Android Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Restaurants app code from the previous chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The starting point for this chapter is represented by the Restaurants application
    developed in the previous chapter. If you haven't followed the implementation
    from the previous chapter, access the starting point for this chapter by navigating
    to the `Chapter_03` directory of the repository and importing the Android project
    entitled `chapter_3_restaurants_app`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the solution code for this chapter, navigate to the `Chapter_04`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_04/chapter_4_restaurants_app](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_04/chapter_4_restaurants_app).'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Kotlin coroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Coroutines** are part of the Kotlin API. They introduce a new and easier
    way of handling async work and concurrency jobs.'
  prefs: []
  type: TYPE_NORMAL
- en: Often, with Android, we need to run or execute different tasks behind the scenes.
    In the meantime, we don't want to block the main thread of the application and
    get an unresponsive UI.
  prefs: []
  type: TYPE_NORMAL
- en: To mitigate this issue, coroutines allow you to execute async work much easier
    while providing main-thread safety for your Android apps. You can use the Coroutines
    API by launching one **coroutine**, or more, depending on your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will cover three essential questions about the Coroutines
    API that derive from what we stated earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a coroutine?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the features and advantages of coroutines?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do coroutines work?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's jump in!
  prefs: []
  type: TYPE_NORMAL
- en: What is a coroutine?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A coroutine is a concurrency design pattern for async work. A *coroutine represents
    an instance of suspendable computation*.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, coroutines are sequences or blocks of code that represent a
    computational task that can be suspended. We call them **suspendable** because
    coroutines can be suspended and resumed mid-execution, which makes them efficient
    for concurrent tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'When comparing coroutines with threads, we can say the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A coroutine is a lightweight version of a thread but not a thread. Coroutines
    are light because creating coroutines doesn't allocate new threads – typically,
    coroutines use predefined thread pools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like threads, coroutines can run in parallel, wait for each other, and communicate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unlike threads, coroutines are very cheap: we can create thousands of them
    and pay very few penalties in terms of performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let's understand the purpose behind coroutines a bit better.
  prefs: []
  type: TYPE_NORMAL
- en: The features and advantages of coroutines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By now, we know that on Android, coroutines can help us to move long-running
    async work from the main thread into a separate thread. Essentially, coroutines
    have two primary possible usages:'
  prefs: []
  type: TYPE_NORMAL
- en: For handling async work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For handling multithreading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will only cover how to correctly handle async work with
    coroutines in Android apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, before we try to understand how to do that with coroutines, let''s
    explore the advantages that coroutines bring over other alternatives that we''ve
    used in the past: `AsyncTask` classes, callbacks, and reactive frameworks. A coroutine
    is described as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lightweight**: We can launch many coroutines on a single thread. Coroutines
    support execution suspension on the thread as opposed to blocking it, resulting
    in less memory overhead. Additionally, a coroutine is not always bound to a specific
    thread – it might start its execution on one thread and yield the result on a
    different one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easily cancelable**: When canceling the parent coroutine, any children coroutines
    that were launched within the same scope will be canceled. If you have launched
    multiple coroutines that run operations concurrently, cancelation is straightforward
    and applies to the entire affected coroutine hierarchy; therefore, this eliminates
    any potential memory leaks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Activity`, `Fragment`, `ViewModel`, and more. This means that you can launch
    coroutines safely from these components, as they will be canceled automatically
    when different lifecycle events occur, so you don''t have to worry about memory
    leaks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have mentioned the word *scope* several times, and I promise that we will
    explain it later. Until then, you can think of the coroutine scope as an entity
    that controls the lifetime of launched coroutines.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now we have an idea of the features of coroutines. Yet, to better understand
    their purpose, first, we need to understand why we should offload async work from
    the main thread to a separate worker thread.
  prefs: []
  type: TYPE_NORMAL
- en: How do coroutines work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Android runtime, the main thread is responsible for two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the UI of the application on the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the UI upon user interactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplistically viewed, the main thread calls a drawing method on the screen
    canvas. This method might be familiar to you as the `onDraw()` method, and we
    can assume that for your device to render UI at 60 frames per second, the Android
    Runtime will call this method roughly every 16 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: If, for some reason, we execute heavy async work on the main thread, the application
    might freeze or stutter. This happens because the main thread was busy serving
    our async work; therefore, it missed several `onDraw()` calls that could have
    updated the UI and prevented the freezing effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we need to make a network request to our server. This operation
    might take time because we must wait for a response, which depends on the web
    API''s speed and the user''s connectivity. Let''s imagine that such a method is
    named `getNetworkResponse()` and we are calling it from the main thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17788_04_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Blocking the main thread with async work
  prefs: []
  type: TYPE_NORMAL
- en: From the time it launched the network request, the main thread kept waiting
    for a response and couldn't do anything in the meantime. We can see that several
    `onDraw()` calls were missed because the main thread was busy executing our `getNetworkResponse()`
    method call and waiting for a result.
  prefs: []
  type: TYPE_NORMAL
- en: 'To mitigate this issue, we''ve used many mechanisms in the past. Yet, coroutines
    are much easier to use and work perfectly with the Android ecosystem. So, it''s
    time to see how they can enable us to execute async work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17788_04_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Executing async work on a different thread by using a coroutine
  prefs: []
  type: TYPE_NORMAL
- en: With coroutines, we can offload any nasty blocking calls – such as the `getNetworkResponse()`
    method call – from the main thread onto a coroutine.
  prefs: []
  type: TYPE_NORMAL
- en: The coroutine works on a separate thread and is in charge of executing the network
    request and waiting for the response. This way, the main thread is not blocked,
    and no `onDraw()` calls are missed; therefore, we avoid getting any freezing screen
    effects.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of how coroutines work, it's time to
    explore the components that coroutines are based on.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the basic elements of coroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A very simplistic approach for getting async work done with coroutines could
    be expressed as follows: first, define the suspended functions and then create
    coroutines that execute the suspended functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Yet, we're not only unsure what suspending functions look like, but we also
    don't know how to allow coroutines to perform asynchronous work for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take things, step by step, and start with the two essential actions
    that we need to execute async work with coroutines:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating suspending functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching coroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these terms make little sense now, so let's address this, starting with
    suspending functions!
  prefs: []
  type: TYPE_NORMAL
- en: Creating suspending functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing that we need in order to work with coroutines is to define a
    suspending function where the blocking task resides.
  prefs: []
  type: TYPE_NORMAL
- en: A **suspending** function is a special function that can be paused (suspended)
    and resumed at some later point in time. This allows us to execute long-running
    jobs while the function is suspended and, finally, resume it when the work is
    complete.
  prefs: []
  type: TYPE_NORMAL
- en: Our regular function calls within our code are mostly executed synchronously
    on the main thread. Essentially, suspending functions allow us to execute jobs
    asynchronously in the background without blocking the thread where those functions
    are called from.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we need to save some details about a user to a local database.
    This operation takes time, so we need to display an animation until it finishes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If this operation is called on the main thread, the animation will freeze for
    a few hundreds of milliseconds while the user's details are saved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a closer look at the code presented earlier and ask yourself the following:
    *which method call should be suspendable?*'
  prefs: []
  type: TYPE_NORMAL
- en: Since the `storeUser()` method takes a while to finish, we want this method
    to be a suspending function because this function should be paused until the user's
    details are saved and then resumed when the job is done. This ensures that we
    do not block the main thread or freeze the animation.
  prefs: []
  type: TYPE_NORMAL
- en: Yet, how can we make the `storeUser()` method a suspending function?
  prefs: []
  type: TYPE_NORMAL
- en: 'A suspending function is a regular function that is marked with the `suspend`
    keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We know that the `storeUser()` method saves details to a database, which takes
    a good while. So, in order to prevent this job from blocking the UI, we've marked
    the method with an additional `suspend` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we mark a method with the `suspend` keyword, trying to call it
    in our code results in a compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17788_04_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Calling suspending functions from regular functions results in
    a compilation error
  prefs: []
  type: TYPE_NORMAL
- en: Suspending functions can only be called from inside a coroutine or from inside
    another suspending function. Instead of calling our `storeUser()` suspending method
    from a regular method, let's create a coroutine and call it from there.
  prefs: []
  type: TYPE_NORMAL
- en: Launching coroutines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To execute a suspend function, first, we need to create and launch a coroutine.
    To do that, we need to call a coroutine builder on a coroutine scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We have just launched our first coroutine and called our suspending function
    inside it! Let''s break down what just happened:'
  prefs: []
  type: TYPE_NORMAL
- en: We've used a `GlobalScope` coroutine scope, which manages the coroutines that
    are launched within it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the coroutine scope, we called the `launch()` coroutine builder to create
    a coroutine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we passed the `Dispatchers.IO` dispatcher to the coroutine builder. In
    this case, we want to save the user details inside the database on a thread reserved
    for I/O operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the block that the `launch()` coroutine builder has provided us with,
    we call our `storeUser()` suspending function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we have successfully moved our blocking work away from the main thread to
    a worker thread. Therefore, we have made sure that the UI will not be blocked,
    and the animation will run smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: However, now that we have implemented suspending work in our `saveDetails()`
    method, you might be wondering what the order of function calls within this method
    will be.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand how the regular synchronous world blends with the suspending
    world, let''s add some logs to our previous code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Remember, the only suspending function in this block of code that will take
    some time to compute is `database.storeUser()`. Now, let's imagine that we have
    run the preceding piece of code.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs: []
  type: TYPE_NORMAL
- en: Before checking the following output, try to think about the order of the logs
    yourself. What do you expect the order of function calls to be?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17788_04_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – The output order of regular and suspending functions
  prefs: []
  type: TYPE_NORMAL
- en: 'The order of the function calls is a bit out of order, but it is definitely
    correct. Let''s see what happened:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the log function with the `Preparing to launch coroutine` message was
    called. This method call was done on the main (UI) thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Even though up next, we launched the coroutine, we can see that the second
    log function called was the last one in our code: `Continuing program execution`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is because the coroutine is a bridge to the suspending world, so every
    function call from the coroutine will be run on a different thread from the main
    thread. More precisely, the operation of switching from the main thread to `Dispatchers.IO`
    will take some time. This means that all of these methods inside the coroutine
    will be executed after the method call outside of the coroutine.
  prefs: []
  type: TYPE_NORMAL
- en: The next log function call is with the `Starting to do async work` message.
    This method is called inside the coroutine on a thread reserved for I/O operations.
    This log marks the start of execution for all suspending work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, after all of the blocking work from the `database.storeUser()` suspending
    function has been finished, the last log function call with the `Finished async
    work` message is called. This log marks the end of the coroutine execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we''ve understood how the regular world blends with the suspended
    world in terms of function calls, there are still many terms and concepts that
    have been thrown at you. Mainly, you might be wondering the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a coroutine scope?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's a coroutine dispatcher?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's a coroutine builder?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's clarify these concepts, starting with coroutine scopes.
  prefs: []
  type: TYPE_NORMAL
- en: Coroutine scopes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Essentially, coroutines run in **coroutine scopes**. To start a coroutine, first,
    you need a coroutine scope because it tracks all of the coroutines launched inside
    it and has the ability to cancel them. This way, you can control how long the
    coroutines should live and when they should be canceled.
  prefs: []
  type: TYPE_NORMAL
- en: 'A coroutine scope contains a `CoroutineContext` object, which defines the context
    in which the coroutine runs. In the previous example, we used a predefined scope,
    `GlobalScope`, but you can also define a custom scope by constructing a `CoroutineContext`
    object and passing it to a `CoroutineScope()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `CoroutineScope()` function expects a `CoroutineContext` object passed to
    its `context` parameter and knows how to build one out of the box. It does this
    by receiving elements with a special `plus` operator and then constructing the
    context behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the time, the two most important elements to construct a `CoroutineContext`
    object are the ones that we just passed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `Job` object: This represents a cancelable component that controls the lifecycle
    of a coroutine launched in a specific scope. When a job is canceled, the job will
    cancel the coroutine it manages. For example, if we have defined a `job` object
    and a custom `myScope` object inside an `Activity` class, a good place to cancel
    the coroutine would be in the `onDestroy()` callback by calling the `cancel()`
    method on the `job` object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By doing this, we've ensured that our async work done within our coroutine,
    which uses the `myScope` scope, will stop when the activity has been destroyed
    and will not cause any memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `Dispatcher` object: Marking a method as suspended provides no details about
    the thread pool it should run on. So, by passing a `Dispatcher` object to the
    `CoroutineScope` constructor, we can make sure that all suspended functions called
    in the coroutine that use this scope will default to the specified `Dispatcher`
    object. In our example, all coroutines launched in `myScope` will run their work,
    by default, in the `Dispatchers.IO` thread pool and will not block the UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the `CoroutineContext` object can also contain an exception handler
    object, which we will define later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the custom scopes that you can define, as we did earlier, you can
    use predefined coroutine scopes that are bound to a certain lifecycle component.
    In such cases, you will no longer need to define a scope with a job or to manually
    cancel the coroutine scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GlobalScope`: This allows the coroutines to live as long as the application
    is alive. In the previous example, we used this scope for simplicity, but `GlobalScope`
    should be avoided since the work launched within this coroutine scope is only
    canceled when the application has been destroyed. Using this scope in a component
    that has a narrower lifecycle than the application – such as an `Activity` component,
    might allow the coroutine to outlive that component''s lifecycle and produce memory
    leaks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lifecycleScope`: This scopes coroutines to the lifecycle of a `LifecycleOwner`
    instance such as an `Activity` component or a `Fragment` component. We can use
    the `lifecycleScope` scope defined in the Jetpack KTX extensions package:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By launching coroutines within this context, we ensure that if the `Fragment`
    component gets destroyed, the coroutine scope will automatically be canceled;
    therefore, this will also cancel our coroutine.
  prefs: []
  type: TYPE_NORMAL
- en: '`viewModelScope`: To scope our coroutines to live as long as the `ViewModel`
    component does, we can use the predefined `viewModelScope` scope:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By launching coroutines within this context, we ensure that if the `ViewModel`
    component gets cleared, the coroutine scope will cancel its work – in other words,
    it will automatically cancel our coroutine.
  prefs: []
  type: TYPE_NORMAL
- en: '`rememberCoroutineScope`: To scope a coroutine to the composition cycle of
    a composable function, we can use the predefined `rememberCoroutineScope` scope:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Therefore, a coroutine's lifecycle is bound to the composition cycle of `UserComposable`.
    This means that when `UserComposable` leaves the composition, the scope will be
    automatically canceled, thereby preventing the coroutine from outliving the composition
    lifecycle of its parent composable.
  prefs: []
  type: TYPE_NORMAL
- en: Since we want the coroutine to be launched only once upon composition and not
    at every recomposition, we wrapped the coroutine with a `LaunchedEffect` composable.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we covered what coroutine scopes are and how they allow us to control
    the lifetime of coroutines, it's time to better understand what dispatchers are.
  prefs: []
  type: TYPE_NORMAL
- en: Dispatchers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **CoroutineDispatcher** object allows us to configure what thread pool our
    work should be executed on. The point of coroutines is to help us move blocking
    work away from the main thread. So, somehow, we need to instruct the coroutines
    what threads to use for the work that we pass to them.
  prefs: []
  type: TYPE_NORMAL
- en: To do that, we need to configure the `CoroutineContext` object of the coroutines
    to set a specific dispatcher. In fact, when we covered coroutine scopes, we've
    explained how `CoroutineContext` is defined by a job and a dispatcher.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating custom scopes, we can specify the default dispatcher right when
    we instantiate the scope, just as we did previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the default dispatcher of `myScope` is `Dispatchers.IO`. This
    means that whatever suspending work we pass to the coroutines that are launched
    with `myScope`, the work will be moved to a special thread pool for I/O background
    work.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of predefined coroutine scopes, such as with `lifecycleScope`,
    `viewModelScope`, or `rememberCoroutineScope`, we can specify the desired default
    dispatcher when starting our coroutine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We start coroutines with coroutine builders such as `launch` or `async`, which
    we will cover in the next section. Until then, we need to understand that when
    launching a coroutine, we can also modify the `CoroutineContext` object of the
    coroutine by specifying a `CoroutineDispatcher` object.
  prefs: []
  type: TYPE_NORMAL
- en: Now we've used `Dispatchers.IO` as a dispatcher throughout our examples. But
    are there any other dispatchers that are of use to us?
  prefs: []
  type: TYPE_NORMAL
- en: '`Dispatchers.IO` is a dispatcher offered by the Coroutines API, but in addition
    to this, coroutines offer other dispatchers too. Let''s list the most notable
    dispatchers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Dispatchers.Main`: This dispatches work to the main thread on Android. It
    is ideal for light work (which doesn''t block the UI) or actual UI function calls
    and interactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dispatchers.IO`: This dispatches blocking work to a background thread pool
    that specializes in handling disk-heavy or network-heavy operations. This dispatcher
    should be specified for suspending work on local databases or executing network
    requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dispatchers.Default`: This dispatches blocking work to a background thread
    pool that specializes in CPU-intensive tasks, such as sorting long lists, parsing
    JSON, and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the previous examples, we set a specific dispatcher of `Dispatchers.IO` for
    the `CoroutineContext` object of the coroutines launched, ensuring that suspended
    work will be dispatched by this specific dispatcher.
  prefs: []
  type: TYPE_NORMAL
- en: 'But we''ve made a critical mistake! Let''s take a look at the code again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The main issue with this code is that the `startAnimation()` and `stopAnimation()`
    functions are probably not even suspending functions, as they interact with the
    UI.
  prefs: []
  type: TYPE_NORMAL
- en: We wanted to run our `database.storeUser()` blocking work on a background thread,
    so we specified the `Dispatchers.IO` dispatcher to the `CoroutineContext` object.
    But this means that all the rest of the code in the coroutine block (that is,
    the `startAnimation()` and `stopAnimation()` function calls) will be dispatched
    to a thread pool intended for background work instead of being dispatched to the
    main thread.
  prefs: []
  type: TYPE_NORMAL
- en: To have more fine-grained control regarding what threads our functions are being
    dispatched to, coroutines allow us to control the dispatcher by using the `withContext`
    block, which creates a block of code that can run on a different dispatcher.
  prefs: []
  type: TYPE_NORMAL
- en: Since `startAnimation()` and `stopAnimation()` have to work on the main thread,
    let's refactor our example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s launch our coroutine with the default dispatcher of `Dispatchers.Main`,
    and then wrap our work, which has to be run on a background thread (the `database.storeUser(user)`
    suspending function), with a `withContext` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `withContext` function allows us to define a more granular `CoroutineContext`
    object for the block that it exposes. In our case, we had to pass the `Dispatchers.IO`
    dispatcher to make sure our blocking work with the database will run on the background
    thread instead of being dispatched to the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, our coroutine will have all its work dispatched to the `Dispatchers.Main`
    dispatcher, unless you define another more granular context that has its own `CoroutineDispatcher`
    set.
  prefs: []
  type: TYPE_NORMAL
- en: Now we've covered how to use dispatchers and how to ensure more granular control
    over how our work is dispatched to different threads. However, we haven't covered
    what the `launch { }` block means. Let's do that next.
  prefs: []
  type: TYPE_NORMAL
- en: Coroutine builders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`launch`) are extension functions on `CoroutineScope` and allow us to create
    and start coroutines. Essentially, they are a bridge between the normal synchronous
    world with regular functions and the suspending world with suspending functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Since we can't call suspending functions inside regular functions, a coroutine
    builder method executed on the `CoroutineScope` object creates a scoped coroutine
    that provides us with a block of code where we can call our suspending functions.
    Without scopes, we cannot create coroutines – which is good since this practice
    helps to prevent memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use three builder functions to create coroutines:'
  prefs: []
  type: TYPE_NORMAL
- en: '`launch`: This starts a coroutine that runs concurrently with the rest of the
    code. Coroutines started with `launch` won''t return the result to the caller
    – instead, all of the suspending functions will run sequentially inside the block
    that `launch` exposes. It''s our job to get the result from the suspending functions
    and then interact with that result:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Most of the time, if you don't need concurrent work, `launch` is the go-to option
    for starting coroutines since it allows you to run your suspending work inside
    the block of code provided and doesn't care about anything else.
  prefs: []
  type: TYPE_NORMAL
- en: If no dispatcher is specified in the coroutine builder, the dispatcher that
    is going to be used is the dispatcher provided by default by the `CoroutineScope`
    used to start the coroutine. In our case, if we wouldn't have specified a dispatcher,
    our coroutine launched with the `launch` coroutine builder will have used the
    `Dispatchers.Main` dispatcher defined by default by `lifecycleScope`.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from `lifecycleScope`, `viewModelScope` also provides the same predefined
    dispatcher of `Dispatchers.Main`. `GlobalScope` on the other hand, defaults to
    `Dispatchers.Default` if no dispatcher was provided to the coroutine builder.
  prefs: []
  type: TYPE_NORMAL
- en: '`async`: This starts a new coroutine, and it allows you to return the result
    as a `Deferred<T>` object, where `T` is your expected data type. The deferred
    object is a promise that your result, `T`, will be returned in the future. To
    start the coroutine and get a result, you need to call the suspending function,
    `await`, which blocks the calling thread:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can't use `async` in a normal function as it has to call the `await` suspending
    function to get the result. To fix that, first, we've created a parent coroutine
    with `launch` and started the child coroutine with `async` inside it. This means
    the child coroutine that was started with `async` inherits its `CoroutineContext`
    object from the parent coroutine that was started with `launch`.
  prefs: []
  type: TYPE_NORMAL
- en: With `async`, we can get the results of the concurrent work in one place. Where
    the `async` coroutine builder shines (and where it's recommended to be used) is
    in tasks with parallel execution where results are required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we need to simultaneously convert two pieces of text into speech
    and then play both results at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this particular example, both the resulting `deferredTitleAudio` and `deferredSubtitleAudio`
    tasks will run in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: Since our Restaurants application hasn't featured concurrent work until now,
    we won't go any deeper in terms of concurrency topics.
  prefs: []
  type: TYPE_NORMAL
- en: '`runBlocking`: This starts a coroutine that blocks the current thread on which
    it is invoked until the coroutine has been completed. This builder should be avoided
    for async work within our app since creating threads and blocking them is less
    efficient. However, this coroutine builder can be used for unit tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have covered the basics of coroutines, it's high time we implement
    coroutines in our Restaurants application!
  prefs: []
  type: TYPE_NORMAL
- en: Using coroutines for async work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing that we have to do is identify the async/heavy work that we
    have done in our Restaurants application.
  prefs: []
  type: TYPE_NORMAL
- en: Without looking at the code, we know that our app retrieves a list of restaurants
    from the server. It does that by initiating a network request with Retrofit and
    then waits for a response. This action qualifies as an async job because we don't
    want to block the main (UI) thread while the app waits for the network response
    to arrive.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we check out the `RestaurantsViewModel` class, we can identify that the
    `getRestaurants()` method is the one place in our application where heavy blocking
    work is happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When we implemented the network request, we used Retrofit's `enqueue()` method
    to which we passed a `Callback` object where we could wait for the result without
    blocking the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: To simplify the way we handle this async operation of getting the restaurants
    from the server, we will implement coroutines. This will allow us to ditch callbacks
    and make our code more concise.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will cover two main steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing coroutines instead of callbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the way our app works with coroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing coroutines instead of callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To handle async work with coroutines, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Define our async work in a suspending function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, create a coroutine and call the suspending function inside it to obtain
    the result asynchronously.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enough with the theory, it''s time to code! Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `RestaurantsApiService` interface, add the `suspend` keyword to
    the `getRestaurants()` method and replace the `Call<List<Restaurant>>` return
    type of the method with `List<Restaurant>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Retrofit supports coroutines out of the box for network requests. This means
    that we can mark any method in our Retrofit interface with the `suspend` keyword;
    therefore, we can transform the network requests to suspending work that isn't
    blocking the main thread of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, the `Call<T>` return type is redundant. We no longer need Retrofit
    to return a `Call` object on which we would normally enqueue a `Callback` object
    to listen for the response – all of this will be handled by the Coroutines API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we will no longer receive a `Call` object from Retrofit, we will also
    not need the `Callback` object in our `RestaurantsViewModel` class. Clean up the
    `RestaurantsViewModel` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove the `restaurantsCall: Call<List<Restaurant>` member variable.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the `restaurantsCall.cancel()` method call inside the `onCleared()` callback.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the entire body of the `getRestaurants()` method.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside the `getRestaurants()` method, call the `restInterface.getRestaurants()`
    suspending function and store the result in a `restaurants` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The IDE will throw an error telling us that we cannot call the `restInterface.getRestaurants()`
    suspending function from the regular `getRestaurants()` function within the `ViewModel`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: To fix this, we must create a coroutine, launch it, and call the suspending
    function there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before creating a coroutine, we need to create a `CoroutineScope` object. Inside
    the `ViewModel` component, define a member variable of type `Job` and another
    of type `CoroutineScope`, just as we learned earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `job` variable is the handle that will allow us to cancel the coroutine
    scope, while the `scope` variable will ensure we keep track of the coroutines
    that are going be to be launched with it.
  prefs: []
  type: TYPE_NORMAL
- en: Since the network request is a heavy blocking operation, we want its suspending
    work to be executed on the `IO` thread pool to avoid blocking the main thread,
    so we specified the `Dispatchers.IO` dispatcher for our `scope` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `onCleared()` callback method, call the `cancel()` method in the
    newly created job variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By calling `cancel()` on our `job` variable, we ensure that if the `RestaurantsViewModel`
    component is destroyed (for example, in scenarios where the user navigates to
    a different screen) the coroutine `scope` object will be canceled through its
    `job` object reference. Effectively, this will cancel any suspending work and
    prevent the coroutine from causing a memory leak.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `getRestaurants()` method in our `ViewModel` component, create a
    coroutine by calling `launch` on the previously defined `scope` object, and inside
    that body exposed by the coroutine add the existing code where we obtain the restaurants:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Success! We have launched a coroutine that executes our suspending work of obtaining
    the restaurants from the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the initial code to update our `State` object with the newly received
    restaurants so that the Compose UI displays them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: However, this approach is flawed. Can you point out why?
  prefs: []
  type: TYPE_NORMAL
- en: Well, we are updating the UI on an incorrect thread. Our `scope` is defined
    to run the coroutine on a thread from the `Dispatchers.IO` thread pool, but updating
    the UI should happen on the Main thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `getRestaurants()` method, wrap the line of code where the Compose
    `State` object is updated with a `withContext` block that specifies the `Dispatchers.Main`
    dispatcher:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By doing this, we ensure that while heavy work is being done on the background
    threads, the UI is updated from the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now successfully implemented coroutines in our app. We have defined
    a scope and created a coroutine where we executed our suspending work: a network
    request.'
  prefs: []
  type: TYPE_NORMAL
- en: You can now **Run** the application and notice that on the outside, the behavior
    of the app hasn't changed. However, behind the scenes, our async work was done
    with the help of coroutines in a more elegant manner than before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Even so, there are a few things that could be improved. Let's tackle those next.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the way our app works with coroutines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our app uses a coroutine to move heavy work from the main thread to specialized
    threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we think about our particular implementation, we can find some
    ways to improve our coroutine-related code:'
  prefs: []
  type: TYPE_NORMAL
- en: Use predefined scopes as opposed to custom scopes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add error handling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that every `suspend` function is safe to be called on any `Dispatcher`
    object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start with the fun one: replacing our custom scope with a predefined
    one!'
  prefs: []
  type: TYPE_NORMAL
- en: Using predefined scopes as opposed to custom scopes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our current implementation, we''ve defined a custom `CoroutineScope` object
    that will make sure that its coroutines will live as long as the `RestaurantsViewModel`
    instance. To achieve this, we pass a `Job` object to our `CoroutineScope` builder
    and cancel it when the `ViewModel` component is destroyed: on the `onCleared()`
    callback method.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, remember that coroutines are well integrated with the Jetpack libraries,
    and when we define scopes, we also talk about predefined scopes such as `lifecycleScope`,
    `viewModelScope`, and more. These scopes make sure that their coroutines live
    as long as the component they are bound to, for example, `lifecycleScope` is bound
    to a `Fragment` or `Activity` component.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you are launching a coroutine inside components such as `Activity`,
    `Fragment`, `ViewModel`, or even composable functions, remember that instead of
    creating and managing your own `CoroutineScope` object, you can use the predefined
    ones that take care of canceling coroutines automatically. By using predefined
    scopes, you can better avoid memory leaks as any suspending work is cancelled
    when needed.
  prefs: []
  type: TYPE_NORMAL
- en: In our scenario, we can simplify our code and replace our custom `CoroutineScope`
    object with the `viewModelScope` one. Behind the scenes, this predefined scope
    will take care of canceling all of the coroutines launched with it when its parent
    `ViewModel` instance has been cleared or destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do that now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `getRestaurants()` method of the `RestaurantsViewModel` class, replace
    `scope` with `viewModelScope`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we will no longer use our `scope` object, we need to make sure that our
    coroutine will run the suspending work in the background, just as it did with
    the previous scope. Pass a `Dispatchers.IO` dispatcher to the `launch` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Usually, the `launch` coroutine builder inherits `CoroutineContext` from its
    parent coroutine. In our particular case though, if no dispatcher is specified,
    coroutines launched with `viewModelScope` will default to using `Dispatchers.Main`.
  prefs: []
  type: TYPE_NORMAL
- en: However, we want our network request to be executed on a background thread from
    the specialized I/O thread pool, so we passed an initial `CoroutineContext` object
    with a `Dispatchers.IO` dispatcher to our `launch` call.
  prefs: []
  type: TYPE_NORMAL
- en: Remove the `onCleared()` callback method entirely from the `ViewModel` class.
    We will no longer need to cancel our coroutine `scope` from a `job` object because
    `viewModelScope` takes care of that for us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the `job` and `scope` member variables from the `RestaurantsViewModel`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can now **Run** the application and again notice that on the outside, the
    behavior of the app hasn't changed. Our code now works the same but is greatly
    simplified because we used a predefined scope instead of handling everything by
    ourselves.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we must re-add error handling to our project. However, this time, we will
    do it in the context of coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: Adding error handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous implementation with callbacks, we received an error callback
    from Retrofit. However, with coroutines, it appears that since our suspending
    function returns `List<Restaurant>>`, there is no room for error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, we are not handling any error that could be thrown. For example, if
    you try to launch the application without internet right now, Retrofit will throw
    a `Throwable` object, which, in turn, will crash our app with a similar error
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To handle errors, we can simply wrap suspending function calls in a `try catch`
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding approach is fine, but the code becomes less concise because of
    another level of nesting. Additionally, to better support a single point of error
    handling, coroutines allow you to pass a `CoroutineExceptionHandler` object to
    the context of your `CoroutineScope` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – The signature of CoroutineExceptionHandler'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17788_04_5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – The signature of CoroutineExceptionHandler
  prefs: []
  type: TYPE_NORMAL
- en: The `CoroutineExceptionHandler` object allows us to handle errors thrown by
    any coroutine launched within a `CoroutineScope` object, no matter how nested
    it might be. This handler gives us access to a function that exposes the `CoroutineContext`
    object and the `Throwable` object thrown in this particular context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add such a handler to the `RestaurantsViewModel` class. Perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define an `errorHandler` member variable of type `CoroutineExceptionHandler`
    and print the stack trace of the `exception: Throwable` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We're not interested in the first parameter of type `CoroutineContext`, so we
    named it with an underscore, `_`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `getRestaurants()` method, pass the `errorHandler` variable to the
    `launch` block using the `+` operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By passing our `errorHandler` variable to the `launch` method, we make sure
    that the `CoroutineContext` object of this coroutine sets this `CoroutineExceptionHandler`,
    which will allow us to handle errors inside our handler.
  prefs: []
  type: TYPE_NORMAL
- en: Try running the app again without the internet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now the app shouldn't crash because the `errorHandler` variable will catch the
    `Throwable` object thrown by Retrofit and allow us to print its stack trace.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As an improvement, try to find a way of notifying the UI that an error has occurred,
    thereby informing the user of what just happened.
  prefs: []
  type: TYPE_NORMAL
- en: We are now handling errors with coroutines, so it's time to move to the last
    point of improvement – handling the switch of dispatchers correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Making sure that every suspending function is safe to be called on any dispatcher
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When defining suspending functions, a good practice is to make sure that every
    suspending function can be called on any `Dispatcher` object. This way, the caller
    (in our case, the coroutine) doesn't have to worry about what thread will be needed
    to execute the suspending function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s analyze our code with the coroutine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getRestaurants()` method of the `restInterface: RestaurantsApiService`
    interface is a suspending function. This function should always be run on `Dispatchers.IO`
    since it executes a heavy I/O operation, that is, the network request.'
  prefs: []
  type: TYPE_NORMAL
- en: However, this would mean that whenever we have to call `restInterface.getRestaurants()`,
    we either have to call this suspending function from a coroutine that has a scope
    of `Dispatchers.IO` – just as we did previously – or always wrap it in a `withContext(Dispatchers.IO)`
    block inside the caller coroutine.
  prefs: []
  type: TYPE_NORMAL
- en: Both of these alternatives don't scale well. Imagine that you have to call `restInterface.getRestaurants()`
    10 times in the `RestaurantsViewModel` class. You would always have to be careful
    with setting the dispatcher when calling this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s address this by creating a separate method where we can specify the
    correct dispatcher for our suspending function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `RestaurantsViewModel` class, create a separate suspending method,
    called `getRemoteRestaurants()`, and wrap the `restInterface.getRestaurants()`
    call there with a `withContext()` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To the `withContext` method, we''ve passed the corresponding dispatcher for
    this suspending function: `Dispatchers.IO`.'
  prefs: []
  type: TYPE_NORMAL
- en: This means that whenever this suspending function is called (from a coroutine
    or another suspending function), the dispatcher will be switched to `Dispatchers.IO`
    for the `restInterface.getRestaurants()` call's execution.
  prefs: []
  type: TYPE_NORMAL
- en: By doing so, we make sure that whoever is calling `getRemoteRestaurants()` will
    not have to care about the correct thread dispatcher for the content of this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `getRestaurants()` method of the `ViewModel` component, replace the
    `restInterface.getRestaurants()` method call with `getRemoteRestaurants()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since the content of the `getRemoteRestaurants()` method will be called on
    its appropriate dispatcher, we no longer have to pass `Dispatchers.IO` to the
    launch block. Remove the `Dispatchers.IO` dispatcher from the coroutine `launch`
    block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By default, the launch block will inherit the `CoroutineContext` (and so its
    defined `Dispatcher` object) from its parent coroutine. In our case, there is
    no parent coroutine, so the `launch` block will launch a coroutine on the `Dispatchers.Main`
    thread which was predefined by the `viewModelScope` custom scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the coroutine will now run on the `Dispatchers.Main` thread, we can remove
    the redundant `withContext(Dispatchers.Main)` block from within the `getRestaurants()`
    method. The `getRestaurants()` method should now look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, the `getRestaurants()` method where we launched the coroutine is much
    easier to read and understand. Our suspending function call, for instance, `getRemoteRestaurants()`,
    is called inside this coroutine on the `Dispatchers.Main` dispatcher. However,
    at the same time, our suspending function has its own `withContext()` block with
    its corresponding `Dispatcher` object set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This practice allows us to call suspending functions from coroutines with any
    given `Dispatcher` object, simply because the suspending functions have their
    own `CoroutineContext` object set with their appropriate `Dispatcher` objects.
  prefs: []
  type: TYPE_NORMAL
- en: At runtime, even though the coroutines are launched on their initial `Dispatcher`
    object, when our suspending functions are called, the `Dispatcher` object is briefly
    overridden for every suspending function that is internally wrapped with a `withContext`
    block.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For Retrofit interface calls such as `restInterface.getRestaurants()`, we can
    skip wrapping them in `withContext()` blocks because Retrofit already does this
    behind the scenes and sets the `Dispatchers.IO` dispatcher for all suspending
    methods from within its interface.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the application should behave the same. However, in terms of good practices,
    we made sure that the correct `Dispatcher` object is set for every suspending
    function out of the box, and without us having to manually set it in every coroutine.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we improved the way dispatchers are set within our suspending function
    and coroutine, it's time to wrap this chapter up.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how coroutines allow us to write async code in a
    much clearer and more concise way.
  prefs: []
  type: TYPE_NORMAL
- en: 'We understood what coroutines are, how they work, and why they are needed in
    the first place. We unveiled the core elements of coroutines: from `suspend` functions
    to `CoroutineScope` objects, to `CoroutineContext` objects and `Dispatcher` objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we replaced the callbacks with coroutines in our Restaurants application
    and noticed how the code is much easier to understand and less nested. Additionally,
    we learned how to perform error handling with coroutines and integrated some of
    the best practices when working with coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will add another Compose-based screen to our Restaurants
    application and learn how to navigate between screens in Compose with yet another
    Jetpack library.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While canceling coroutines might seem simple with the help of the associated
    `Job` objects, it's important to note that any cancelation must be cooperative.
    More specifically, when coroutines perform suspending work based on conditional
    statements, you must ensure the coroutine is cooperative with respect to canceling.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read about this topic, in more detail, in the official documentation:
    [https://kotlinlang.org/docs/cancellation-and-timeouts.html#cancellation-is-cooperative](https://kotlinlang.org/docs/cancellation-and-timeouts.html#cancellation-is-cooperative).'
  prefs: []
  type: TYPE_NORMAL
