- en: '*Chapter 4*: Handling Async Operations with Coroutines'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：使用协程处理异步操作'
- en: 'In this chapter, we''re focusing on another library that, although is not in
    the Jetpack library suite, is essential for writing solid applications: **Kotlin
    coroutines**.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于另一个库，尽管它不在Jetpack库套件中，但对于编写稳健的应用程序至关重要：**Kotlin协程**。
- en: Coroutines represent a more convenient way of handling async work and concurrency
    jobs on Android.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 协程代表了在Android上处理异步工作和并发任务的一种更方便的方式。
- en: In this chapter, we will study how we can replace callbacks with coroutines
    in our Restaurants application. In the first section, *Introducing Kotlin coroutines*,
    we will gain a better understanding of what coroutines are, how they work, and
    why we need them in our apps.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究如何在我们的餐厅应用中用协程替换回调。在第一部分*介绍Kotlin协程*中，我们将更好地理解协程是什么，它们是如何工作的，以及为什么我们需要在我们的应用中使用它们。
- en: In the next section, *Exploring the basic elements of coroutines*, we will explore
    the core elements of coroutines, and we will understand how to use them to handle
    asynchronous work more concisely.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节*探索协程的基本元素*中，我们将探索协程的核心元素，并了解如何更简洁地使用它们来处理异步工作。
- en: Finally, in the *Using coroutines for async work* section, we will implement
    coroutines in our Restaurants application and let them handle the network requests.
    Additionally, we will add error handling and integrate some of the best practices
    when working with coroutines in Android apps.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在*使用协程进行异步工作*部分，我们将在我们的餐厅应用中实现协程，并让它们处理网络请求。此外，我们还将添加错误处理，并在Android应用中使用协程时整合一些最佳实践。
- en: 'To summarize, in this chapter, we''re going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本章中，我们将涵盖以下主要内容：
- en: Introducing Kotlin coroutines
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Kotlin协程
- en: Exploring the basic elements of coroutines
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索协程的基本元素
- en: Using coroutines for async work
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用协程进行异步工作
- en: Before jumping in, let's set up the technical requirements for this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入之前，让我们为这一章设置技术要求。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Building Compose-based Android projects with coroutines usually requires your
    day-to-day tools. However, to follow along with this chapter smoothly, make sure
    you have the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用协程构建基于Compose的Android项目通常需要您的日常工具。但是，为了顺利地跟随本章，请确保您有以下内容：
- en: The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer
    Android Studio version or even Canary builds but note that IDE interface and other
    generated code files might differ from the ones used throughout this book.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arctic Fox 2020.3.1版本的Android Studio。您也可以使用更新的Android Studio版本或甚至Canary构建，但请注意，IDE界面和其他生成的代码文件可能与本书中使用的不同。
- en: Kotlin 1.6.10, or a newer plugin, installed in Android Studio
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin 1.6.10或更新的插件，已安装在Android Studio中
- en: The Restaurants app code from the previous chapter.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上一章的餐厅应用代码。
- en: The starting point for this chapter is represented by the Restaurants application
    developed in the previous chapter. If you haven't followed the implementation
    from the previous chapter, access the starting point for this chapter by navigating
    to the `Chapter_03` directory of the repository and importing the Android project
    entitled `chapter_3_restaurants_app`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的起点是上一章开发的餐厅应用。如果您没有跟随上一章的实现，请通过导航到存储库中的`Chapter_03`目录并导入名为`chapter_3_restaurants_app`的Android项目来访问本章的起点。
- en: 'To access the solution code for this chapter, navigate to the `Chapter_04`
    directory:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本章的解决方案代码，请导航到`Chapter_04`目录：
- en: '[https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_04/chapter_4_restaurants_app](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_04/chapter_4_restaurants_app).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_04/chapter_4_restaurants_app](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_04/chapter_4_restaurants_app)。'
- en: Introducing Kotlin coroutines
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Kotlin协程
- en: '**Coroutines** are part of the Kotlin API. They introduce a new and easier
    way of handling async work and concurrency jobs.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**协程**是Kotlin API的一部分。它们引入了一种新的、更简单的方式来处理异步工作和并发任务。'
- en: Often, with Android, we need to run or execute different tasks behind the scenes.
    In the meantime, we don't want to block the main thread of the application and
    get an unresponsive UI.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在Android中，我们需要在幕后运行或执行不同的任务。同时，我们不想阻塞应用程序的主线程，并得到一个无响应的用户界面。
- en: To mitigate this issue, coroutines allow you to execute async work much easier
    while providing main-thread safety for your Android apps. You can use the Coroutines
    API by launching one **coroutine**, or more, depending on your needs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻这个问题，协程允许你更容易地执行异步工作，同时为你的Android应用提供主线程安全性。你可以根据需要启动一个或多个**协程**来使用协程API。
- en: 'In this section, we will cover three essential questions about the Coroutines
    API that derive from what we stated earlier:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖三个关于协程API的基本问题，这些问题源于我们之前提到的内容：
- en: What is a coroutine?
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是协程？
- en: What are the features and advantages of coroutines?
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程有哪些特性和优势？
- en: How do coroutines work?
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程是如何工作的？
- en: Let's jump in!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: What is a coroutine?
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是协程？
- en: A coroutine is a concurrency design pattern for async work. A *coroutine represents
    an instance of suspendable computation*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是异步工作的并发设计模式。*协程代表了一个可挂起的计算实例*。
- en: In other words, coroutines are sequences or blocks of code that represent a
    computational task that can be suspended. We call them **suspendable** because
    coroutines can be suspended and resumed mid-execution, which makes them efficient
    for concurrent tasks.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，协程是表示可挂起计算任务的代码序列或块。我们称它们为**可挂起的**，因为协程可以在执行过程中被挂起和恢复，这使得它们对并发任务非常高效。
- en: 'When comparing coroutines with threads, we can say the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当比较协程和线程时，我们可以这样说：
- en: A coroutine is a lightweight version of a thread but not a thread. Coroutines
    are light because creating coroutines doesn't allocate new threads – typically,
    coroutines use predefined thread pools.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程是线程的轻量级版本，但并非线程。协程之所以轻量，是因为创建协程不会分配新的线程——通常，协程使用预定义的线程池。
- en: Like threads, coroutines can run in parallel, wait for each other, and communicate.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 和线程一样，协程可以并行运行，互相等待，并进行通信。
- en: 'Unlike threads, coroutines are very cheap: we can create thousands of them
    and pay very few penalties in terms of performance.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与线程不同，协程非常便宜：我们可以创建成千上万的协程，而在性能方面几乎不付出任何代价。
- en: Next, let's understand the purpose behind coroutines a bit better.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更好地理解协程背后的目的。
- en: The features and advantages of coroutines
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协程的特性和优势
- en: 'By now, we know that on Android, coroutines can help us to move long-running
    async work from the main thread into a separate thread. Essentially, coroutines
    have two primary possible usages:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道在Android上，协程可以帮助我们将长时间运行的异步工作从主线程移动到单独的线程。本质上，协程有两个主要可能的用途：
- en: For handling async work
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于处理异步工作
- en: For handling multithreading
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于处理多线程
- en: In this chapter, we will only cover how to correctly handle async work with
    coroutines in Android apps.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将仅介绍如何在Android应用中正确地使用协程处理异步工作。
- en: 'However, before we try to understand how to do that with coroutines, let''s
    explore the advantages that coroutines bring over other alternatives that we''ve
    used in the past: `AsyncTask` classes, callbacks, and reactive frameworks. A coroutine
    is described as the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们尝试理解如何使用协程来实现这一点之前，让我们先探索协程相较于我们过去使用的其他替代方案（如`AsyncTask`类、回调和响应式框架）所提供的优势。协程被描述如下：
- en: '**Lightweight**: We can launch many coroutines on a single thread. Coroutines
    support execution suspension on the thread as opposed to blocking it, resulting
    in less memory overhead. Additionally, a coroutine is not always bound to a specific
    thread – it might start its execution on one thread and yield the result on a
    different one.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻量级**：我们可以在单个线程上启动许多协程。协程支持在线程上的执行挂起，而不是阻塞它，这导致更少的内存开销。此外，协程并不总是绑定到特定的线程——它可能在一个线程上开始执行，并在另一个线程上产生结果。'
- en: '**Easily cancelable**: When canceling the parent coroutine, any children coroutines
    that were launched within the same scope will be canceled. If you have launched
    multiple coroutines that run operations concurrently, cancelation is straightforward
    and applies to the entire affected coroutine hierarchy; therefore, this eliminates
    any potential memory leaks.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于取消**：当取消父协程时，在同一作用域内启动的任何子协程都将被取消。如果你启动了多个并发运行的操作的协程，取消操作简单直接，并适用于整个受影响的协程层次结构；因此，这消除了任何潜在的内存泄漏。'
- en: '`Activity`, `Fragment`, `ViewModel`, and more. This means that you can launch
    coroutines safely from these components, as they will be canceled automatically
    when different lifecycle events occur, so you don''t have to worry about memory
    leaks.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Activity`、`Fragment`、`ViewModel`等。这意味着您可以从这些组件安全地启动协程，因为当发生不同的生命周期事件时，它们将自动取消，因此您不必担心内存泄漏。'
- en: Note
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: We have mentioned the word *scope* several times, and I promise that we will
    explain it later. Until then, you can think of the coroutine scope as an entity
    that controls the lifetime of launched coroutines.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们多次提到了单词*作用域*，我保证我们会在稍后解释它。在此之前，您可以将协程作用域视为一个控制已启动协程生命周期的实体。
- en: Now we have an idea of the features of coroutines. Yet, to better understand
    their purpose, first, we need to understand why we should offload async work from
    the main thread to a separate worker thread.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对协程的功能有了概念。然而，为了更好地理解它们的目的，首先，我们需要了解为什么我们应该将异步工作从主线程卸载到单独的工作线程。
- en: How do coroutines work?
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协程是如何工作的？
- en: 'In Android runtime, the main thread is responsible for two things:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android运行时，主线程负责两件事：
- en: Drawing the UI of the application on the screen
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在屏幕上绘制应用程序的UI
- en: Updating the UI upon user interactions
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在用户交互时更新UI
- en: Simplistically viewed, the main thread calls a drawing method on the screen
    canvas. This method might be familiar to you as the `onDraw()` method, and we
    can assume that for your device to render UI at 60 frames per second, the Android
    Runtime will call this method roughly every 16 milliseconds.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，主线程在屏幕画布上调用一个绘图方法。这个方法可能对您来说很熟悉，就是`onDraw()`方法，我们可以假设为了您的设备以每秒60帧的速度渲染UI，Android运行时会大约每16毫秒调用这个方法一次。
- en: If, for some reason, we execute heavy async work on the main thread, the application
    might freeze or stutter. This happens because the main thread was busy serving
    our async work; therefore, it missed several `onDraw()` calls that could have
    updated the UI and prevented the freezing effect.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因，我们在主线程上执行了繁重的异步工作，应用程序可能会冻结或卡顿。这是因为主线程忙于处理我们的异步工作；因此，它错过了几个本可以更新UI并防止冻结效果的`onDraw()`调用。
- en: 'Let''s say that we need to make a network request to our server. This operation
    might take time because we must wait for a response, which depends on the web
    API''s speed and the user''s connectivity. Let''s imagine that such a method is
    named `getNetworkResponse()` and we are calling it from the main thread:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要向我们的服务器发起一个网络请求。这个操作可能需要时间，因为我们必须等待响应，这取决于Web API的速度和用户的连接性。让我们想象这样一个方法被命名为`getNetworkResponse()`，并且我们是从主线程调用它的：
- en: '![](img/B17788_04_1.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17788_04_1.jpg)'
- en: Figure 4.1 – Blocking the main thread with async work
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 异步工作阻塞主线程
- en: From the time it launched the network request, the main thread kept waiting
    for a response and couldn't do anything in the meantime. We can see that several
    `onDraw()` calls were missed because the main thread was busy executing our `getNetworkResponse()`
    method call and waiting for a result.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从它发起网络请求的那一刻起，主线程一直在等待响应，同时无法做任何事情。我们可以看到，由于主线程忙于执行我们的`getNetworkResponse()`方法调用并等待结果，因此错过了几个`onDraw()`调用。
- en: 'To mitigate this issue, we''ve used many mechanisms in the past. Yet, coroutines
    are much easier to use and work perfectly with the Android ecosystem. So, it''s
    time to see how they can enable us to execute async work:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻这个问题，我们过去使用了许多机制。然而，协程的使用更加简单，并且与Android生态系统完美配合。因此，是时候看看它们如何使我们能够执行异步工作了：
- en: '![](img/B17788_04_2.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17788_04_2.jpg)'
- en: Figure 4.2 – Executing async work on a different thread by using a coroutine
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 通过协程在另一个线程上执行异步工作
- en: With coroutines, we can offload any nasty blocking calls – such as the `getNetworkResponse()`
    method call – from the main thread onto a coroutine.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用协程，我们可以将任何讨厌的阻塞调用（如`getNetworkResponse()`方法调用）从主线程卸载到协程。
- en: The coroutine works on a separate thread and is in charge of executing the network
    request and waiting for the response. This way, the main thread is not blocked,
    and no `onDraw()` calls are missed; therefore, we avoid getting any freezing screen
    effects.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 协程在单独的线程上运行，负责执行网络请求并等待响应。这样，主线程就不会被阻塞，也不会错过任何`onDraw()`调用；因此，我们避免了出现任何屏幕冻结效果。
- en: Now that we have a basic understanding of how coroutines work, it's time to
    explore the components that coroutines are based on.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对协程的工作原理有了基本的了解，是时候探索协程所基于的组件了。
- en: Exploring the basic elements of coroutines
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索协程的基本元素
- en: 'A very simplistic approach for getting async work done with coroutines could
    be expressed as follows: first, define the suspended functions and then create
    coroutines that execute the suspended functions.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用协程完成异步工作的一个非常简单的方案可以表达如下：首先定义挂起函数，然后创建执行挂起函数的协程。
- en: Yet, we're not only unsure what suspending functions look like, but we also
    don't know how to allow coroutines to perform asynchronous work for us.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不仅不确定挂起函数看起来像什么，而且也不知道如何允许协程为我们执行异步工作。
- en: 'Let''s take things, step by step, and start with the two essential actions
    that we need to execute async work with coroutines:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步来，从我们需要使用协程执行异步工作的两个基本操作开始：
- en: Creating suspending functions
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建挂起函数
- en: Launching coroutines
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动协程
- en: All of these terms make little sense now, so let's address this, starting with
    suspending functions!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些术语现在都几乎没有什么意义，所以让我们来解决这个问题，从挂起函数开始！
- en: Creating suspending functions
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建挂起函数
- en: The first thing that we need in order to work with coroutines is to define a
    suspending function where the blocking task resides.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用协程，我们首先需要定义一个挂起函数，其中包含阻塞任务。
- en: A **suspending** function is a special function that can be paused (suspended)
    and resumed at some later point in time. This allows us to execute long-running
    jobs while the function is suspended and, finally, resume it when the work is
    complete.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**挂起**函数是一种特殊函数，可以在某个时间点暂停（挂起），然后在稍后某个时间点恢复。这允许我们在函数挂起时执行长时间运行的任务，并在工作完成时最终恢复它。'
- en: Our regular function calls within our code are mostly executed synchronously
    on the main thread. Essentially, suspending functions allow us to execute jobs
    asynchronously in the background without blocking the thread where those functions
    are called from.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码中的常规函数调用大多数都是在主线程上同步执行的。本质上，挂起函数允许我们在后台异步执行任务，而不会阻塞调用这些函数的线程。
- en: 'Let''s say that we need to save some details about a user to a local database.
    This operation takes time, so we need to display an animation until it finishes:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要将有关用户的某些详细信息保存到本地数据库中。这个操作需要时间，因此我们需要显示一个动画直到它完成：
- en: '[PRE0]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If this operation is called on the main thread, the animation will freeze for
    a few hundreds of milliseconds while the user's details are saved.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个操作在主线程上调用，当用户的详细信息被保存时，动画将冻结几百毫秒。
- en: 'Take a closer look at the code presented earlier and ask yourself the following:
    *which method call should be suspendable?*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看看之前提供的代码，并问自己以下问题：*哪个方法调用应该是可挂起的？*
- en: Since the `storeUser()` method takes a while to finish, we want this method
    to be a suspending function because this function should be paused until the user's
    details are saved and then resumed when the job is done. This ensures that we
    do not block the main thread or freeze the animation.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`storeUser()`方法需要一段时间才能完成，我们希望这个方法成为一个挂起函数，因为这个函数应该在用户的详细信息保存后暂停，然后在任务完成时恢复。这确保了我们不会阻塞主线程或冻结动画。
- en: Yet, how can we make the `storeUser()` method a suspending function?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们如何使`storeUser()`方法成为一个挂起函数？
- en: 'A suspending function is a regular function that is marked with the `suspend`
    keyword:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 挂起函数是一个带有`suspend`关键字的常规函数：
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We know that the `storeUser()` method saves details to a database, which takes
    a good while. So, in order to prevent this job from blocking the UI, we've marked
    the method with an additional `suspend` keyword.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道`storeUser()`方法将详细信息保存到数据库中，这需要一段时间。因此，为了防止这个任务阻塞UI，我们用额外的`suspend`关键字标记了该方法。
- en: 'However, if we mark a method with the `suspend` keyword, trying to call it
    in our code results in a compilation error:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们用一个`suspend`关键字标记一个方法，试图在我们的代码中调用它，会导致编译错误：
- en: '![](img/B17788_04_3.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17788_04_3.jpg)'
- en: Figure 4.3 – Calling suspending functions from regular functions results in
    a compilation error
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 从常规函数调用挂起函数会导致编译错误
- en: Suspending functions can only be called from inside a coroutine or from inside
    another suspending function. Instead of calling our `storeUser()` suspending method
    from a regular method, let's create a coroutine and call it from there.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 挂起函数只能从协程内部或从另一个挂起函数内部调用。而不是从常规方法中调用我们的`storeUser()`挂起方法，让我们创建一个协程并从那里调用它。
- en: Launching coroutines
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动协程
- en: 'To execute a suspend function, first, we need to create and launch a coroutine.
    To do that, we need to call a coroutine builder on a coroutine scope:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行一个暂停函数，首先，我们需要创建并启动一个协程。为此，我们需要在协程作用域上调用协程构建器：
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We have just launched our first coroutine and called our suspending function
    inside it! Let''s break down what just happened:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚启动了我们的第一个协程，并在其中调用了暂停函数！让我们分析一下刚刚发生了什么：
- en: We've used a `GlobalScope` coroutine scope, which manages the coroutines that
    are launched within it.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了一个`GlobalScope`协程作用域，它管理着在其中启动的协程。
- en: In the coroutine scope, we called the `launch()` coroutine builder to create
    a coroutine.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在协程作用域内，我们调用了`launch()`协程构建器来创建一个协程。
- en: Then, we passed the `Dispatchers.IO` dispatcher to the coroutine builder. In
    this case, we want to save the user details inside the database on a thread reserved
    for I/O operations.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将`Dispatchers.IO`调度器传递给协程构建器。在这种情况下，我们希望在为I/O操作保留的线程中保存用户详细信息。
- en: Inside the block that the `launch()` coroutine builder has provided us with,
    we call our `storeUser()` suspending function.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`launch()`协程构建器为我们提供的块内，我们调用我们的`storeUser()`暂停函数。
- en: Now we have successfully moved our blocking work away from the main thread to
    a worker thread. Therefore, we have made sure that the UI will not be blocked,
    and the animation will run smoothly.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功地将阻塞工作从主线程移至工作线程。因此，我们确保了UI不会被阻塞，动画可以流畅运行。
- en: However, now that we have implemented suspending work in our `saveDetails()`
    method, you might be wondering what the order of function calls within this method
    will be.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在我们在`saveDetails()`方法中实现了工作暂停，你可能想知道这个方法内函数调用的顺序是什么。
- en: 'To better understand how the regular synchronous world blends with the suspending
    world, let''s add some logs to our previous code snippet:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解正常同步世界与暂停世界的融合，让我们在我们的代码片段中添加一些日志：
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Remember, the only suspending function in this block of code that will take
    some time to compute is `database.storeUser()`. Now, let's imagine that we have
    run the preceding piece of code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在这段代码块中，唯一需要花费一些时间来计算的暂停函数是`database.storeUser()`。现在，让我们想象我们已经运行了前面的代码片段。
- en: Exercise
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Before checking the following output, try to think about the order of the logs
    yourself. What do you expect the order of function calls to be?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查以下输出之前，试着自己思考日志的顺序。你期望函数调用的顺序是什么？
- en: 'Let''s see the output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看输出：
- en: '![](img/B17788_04_4.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17788_04_4.jpg)'
- en: Figure 4.4 – The output order of regular and suspending functions
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – 正常函数和暂停函数的输出顺序
- en: 'The order of the function calls is a bit out of order, but it is definitely
    correct. Let''s see what happened:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用的顺序有点混乱，但绝对是正确的。让我们看看发生了什么：
- en: First, the log function with the `Preparing to launch coroutine` message was
    called. This method call was done on the main (UI) thread.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，带有`Preparing to launch coroutine`信息的日志函数被调用。这个方法调用是在主线程（UI）上完成的。
- en: 'Even though up next, we launched the coroutine, we can see that the second
    log function called was the last one in our code: `Continuing program execution`.'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管接下来我们启动了协程，但我们可以看到第二个日志函数调用是我们代码中的最后一条：`Continuing program execution`。
- en: This is because the coroutine is a bridge to the suspending world, so every
    function call from the coroutine will be run on a different thread from the main
    thread. More precisely, the operation of switching from the main thread to `Dispatchers.IO`
    will take some time. This means that all of these methods inside the coroutine
    will be executed after the method call outside of the coroutine.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为协程是连接到暂停世界的桥梁，所以协程中的每一个函数调用都会在主线程之外的不同线程上运行。更精确地说，从主线程切换到`Dispatchers.IO`的操作将花费一些时间。这意味着协程内的所有这些方法都将在外部协程的方法调用之后执行。
- en: The next log function call is with the `Starting to do async work` message.
    This method is called inside the coroutine on a thread reserved for I/O operations.
    This log marks the start of execution for all suspending work.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一条日志函数调用是带有`Starting to do async work`信息的。这个方法在协程中在一个为I/O操作保留的线程上被调用。这条日志标志着所有暂停工作的执行开始。
- en: Finally, after all of the blocking work from the `database.storeUser()` suspending
    function has been finished, the last log function call with the `Finished async
    work` message is called. This log marks the end of the coroutine execution.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`database.storeUser()`暂停函数中的所有阻塞工作完成后，最后一条带有`Finished async work`信息的日志函数调用被调用。这条日志标志着协程执行的结束。
- en: 'Now that we''ve understood how the regular world blends with the suspended
    world in terms of function calls, there are still many terms and concepts that
    have been thrown at you. Mainly, you might be wondering the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了在函数调用方面，常规世界与挂起世界是如何融合的，但仍有许多术语和概念被抛给了你。主要的是，你可能想知道以下内容：
- en: What is a coroutine scope?
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程作用域是什么？
- en: What's a coroutine dispatcher?
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是协程调度器？
- en: What's a coroutine builder?
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是协程构建器？
- en: Let's clarify these concepts, starting with coroutine scopes.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们澄清这些概念，从协程作用域开始。
- en: Coroutine scopes
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协程作用域
- en: Essentially, coroutines run in **coroutine scopes**. To start a coroutine, first,
    you need a coroutine scope because it tracks all of the coroutines launched inside
    it and has the ability to cancel them. This way, you can control how long the
    coroutines should live and when they should be canceled.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，协程在 **协程作用域** 中运行。要启动一个协程，首先需要一个协程作用域，因为它跟踪其内部启动的所有协程，并且有取消它们的能力。这样，你可以控制协程应该存活多久以及何时取消。
- en: 'A coroutine scope contains a `CoroutineContext` object, which defines the context
    in which the coroutine runs. In the previous example, we used a predefined scope,
    `GlobalScope`, but you can also define a custom scope by constructing a `CoroutineContext`
    object and passing it to a `CoroutineScope()` function, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 协程作用域包含一个 `CoroutineContext` 对象，它定义了协程运行的环境。在上一个示例中，我们使用了预定义的作用域 `GlobalScope`，但你也可以通过构造一个
    `CoroutineContext` 对象并将其传递给 `CoroutineScope()` 函数来定义一个自定义作用域，如下所示：
- en: '[PRE4]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `CoroutineScope()` function expects a `CoroutineContext` object passed to
    its `context` parameter and knows how to build one out of the box. It does this
    by receiving elements with a special `plus` operator and then constructing the
    context behind the scenes.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`CoroutineScope()` 函数期望一个传递给其 `context` 参数的 `CoroutineContext` 对象，并且知道如何通过特殊的
    `plus` 运算符接收元素，然后在幕后构建上下文。'
- en: 'Most of the time, the two most important elements to construct a `CoroutineContext`
    object are the ones that we just passed:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，构建 `CoroutineContext` 对象的两个最重要的元素就是我们刚刚传递的：
- en: 'A `Job` object: This represents a cancelable component that controls the lifecycle
    of a coroutine launched in a specific scope. When a job is canceled, the job will
    cancel the coroutine it manages. For example, if we have defined a `job` object
    and a custom `myScope` object inside an `Activity` class, a good place to cancel
    the coroutine would be in the `onDestroy()` callback by calling the `cancel()`
    method on the `job` object:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `Job` 对象：这代表一个可取消的组件，它控制特定作用域中启动的协程的生命周期。当一个作业被取消时，该作业将取消它所管理的协程。例如，如果我们在一个
    `Activity` 类中定义了一个 `job` 对象和一个自定义的 `myScope` 对象，那么在 `onDestroy()` 回调中调用 `job`
    对象的 `cancel()` 方法是一个取消协程的好地方：
- en: '[PRE5]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By doing this, we've ensured that our async work done within our coroutine,
    which uses the `myScope` scope, will stop when the activity has been destroyed
    and will not cause any memory leaks.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们确保了在协程中完成的异步工作，该协程使用 `myScope` 作用域，将在活动被销毁时停止，并且不会造成任何内存泄漏。
- en: 'A `Dispatcher` object: Marking a method as suspended provides no details about
    the thread pool it should run on. So, by passing a `Dispatcher` object to the
    `CoroutineScope` constructor, we can make sure that all suspended functions called
    in the coroutine that use this scope will default to the specified `Dispatcher`
    object. In our example, all coroutines launched in `myScope` will run their work,
    by default, in the `Dispatchers.IO` thread pool and will not block the UI.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `Dispatcher` 对象：将方法标记为挂起并不会提供关于它应该在哪个线程池上运行的详细信息。因此，通过将一个 `Dispatcher` 对象传递给
    `CoroutineScope` 构造函数，我们可以确保在协程中调用并使用此作用域的所有挂起函数将默认使用指定的 `Dispatcher` 对象。在我们的示例中，所有在
    `myScope` 中启动的协程将默认在 `Dispatchers.IO` 线程池中运行，并且不会阻塞 UI。
- en: Note that the `CoroutineContext` object can also contain an exception handler
    object, which we will define later on.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`CoroutineContext` 对象还可以包含一个异常处理对象，我们将在稍后定义。
- en: 'Apart from the custom scopes that you can define, as we did earlier, you can
    use predefined coroutine scopes that are bound to a certain lifecycle component.
    In such cases, you will no longer need to define a scope with a job or to manually
    cancel the coroutine scope:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们之前定义的自定义作用域之外，你还可以使用预定义的与特定生命周期组件绑定的协程作用域。在这种情况下，你将不再需要使用作业定义作用域或手动取消协程作用域：
- en: '`GlobalScope`: This allows the coroutines to live as long as the application
    is alive. In the previous example, we used this scope for simplicity, but `GlobalScope`
    should be avoided since the work launched within this coroutine scope is only
    canceled when the application has been destroyed. Using this scope in a component
    that has a narrower lifecycle than the application – such as an `Activity` component,
    might allow the coroutine to outlive that component''s lifecycle and produce memory
    leaks.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GlobalScope`: 这允许协程与应用程序的生命周期保持一致。在之前的例子中，我们为了简单起见使用了这个作用域，但应该避免使用`GlobalScope`，因为在这个协程作用域内启动的工作只有当应用程序被销毁时才会取消。在具有比应用程序更窄的生命周期的组件（如`Activity`组件）中使用此作用域可能会允许协程超出该组件的生命周期并产生内存泄漏。'
- en: '`lifecycleScope`: This scopes coroutines to the lifecycle of a `LifecycleOwner`
    instance such as an `Activity` component or a `Fragment` component. We can use
    the `lifecycleScope` scope defined in the Jetpack KTX extensions package:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lifecycleScope`: 这个作用域将协程与`LifecycleOwner`实例的生命周期相关联，例如`Activity`组件或`Fragment`组件。我们可以使用Jetpack
    KTX扩展包中定义的`lifecycleScope`作用域：'
- en: '[PRE6]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: By launching coroutines within this context, we ensure that if the `Fragment`
    component gets destroyed, the coroutine scope will automatically be canceled;
    therefore, this will also cancel our coroutine.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在这个上下文中启动协程，我们确保如果`Fragment`组件被销毁，协程作用域将自动取消；因此，这也会取消我们的协程。
- en: '`viewModelScope`: To scope our coroutines to live as long as the `ViewModel`
    component does, we can use the predefined `viewModelScope` scope:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`viewModelScope`: 为了让我们的协程与`ViewModel`组件的生命周期保持一致，我们可以使用预定义的`viewModelScope`作用域：'
- en: '[PRE7]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By launching coroutines within this context, we ensure that if the `ViewModel`
    component gets cleared, the coroutine scope will cancel its work – in other words,
    it will automatically cancel our coroutine.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在这个上下文中启动协程，我们确保如果`ViewModel`组件被清除，协程作用域将取消其工作——换句话说，它将自动取消我们的协程。
- en: '`rememberCoroutineScope`: To scope a coroutine to the composition cycle of
    a composable function, we can use the predefined `rememberCoroutineScope` scope:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rememberCoroutineScope`: 为了将协程作用域与可组合函数的组合周期相关联，我们可以使用预定义的`rememberCoroutineScope`作用域：'
- en: '[PRE8]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Therefore, a coroutine's lifecycle is bound to the composition cycle of `UserComposable`.
    This means that when `UserComposable` leaves the composition, the scope will be
    automatically canceled, thereby preventing the coroutine from outliving the composition
    lifecycle of its parent composable.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，协程的生命周期绑定到`UserComposable`的组合周期。这意味着当`UserComposable`离开组合时，作用域将自动取消，从而防止协程超出其父可组合组件的组合生命周期。
- en: Since we want the coroutine to be launched only once upon composition and not
    at every recomposition, we wrapped the coroutine with a `LaunchedEffect` composable.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望协程仅在组合时启动一次，而不是在每次重新组合时启动，所以我们用`LaunchedEffect`可组合包装了协程。
- en: Now that we covered what coroutine scopes are and how they allow us to control
    the lifetime of coroutines, it's time to better understand what dispatchers are.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了协程作用域是什么以及它们如何允许我们控制协程的生命周期，是时候更好地理解分发器了。
- en: Dispatchers
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分发器
- en: A **CoroutineDispatcher** object allows us to configure what thread pool our
    work should be executed on. The point of coroutines is to help us move blocking
    work away from the main thread. So, somehow, we need to instruct the coroutines
    what threads to use for the work that we pass to them.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**CoroutineDispatcher**对象允许我们配置工作应该执行在哪个线程池上。协程的目的是帮助我们将阻塞工作从主线程移开。因此，我们需要以某种方式指导协程使用哪些线程来执行我们传递给它们的工作。'
- en: To do that, we need to configure the `CoroutineContext` object of the coroutines
    to set a specific dispatcher. In fact, when we covered coroutine scopes, we've
    explained how `CoroutineContext` is defined by a job and a dispatcher.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要配置协程的`CoroutineContext`对象以设置特定的分发器。实际上，当我们介绍协程作用域时，我们已经解释了`CoroutineContext`是由一个作业和一个分发器定义的。
- en: 'When creating custom scopes, we can specify the default dispatcher right when
    we instantiate the scope, just as we did previously:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建自定义作用域时，我们可以在实例化作用域时指定默认的分发器，就像我们之前做的那样：
- en: '[PRE9]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this case, the default dispatcher of `myScope` is `Dispatchers.IO`. This
    means that whatever suspending work we pass to the coroutines that are launched
    with `myScope`, the work will be moved to a special thread pool for I/O background
    work.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`myScope`的默认分发器是`Dispatchers.IO`。这意味着无论我们传递给使用`myScope`启动的协程的挂起工作是什么，工作都会被移动到专门用于I/O后台工作的线程池。
- en: 'In the case of predefined coroutine scopes, such as with `lifecycleScope`,
    `viewModelScope`, or `rememberCoroutineScope`, we can specify the desired default
    dispatcher when starting our coroutine:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于预定义的协程作用域，例如使用 `lifecycleScope`、`viewModelScope` 或 `rememberCoroutineScope`，我们可以在启动协程时指定所需的默认调度器：
- en: '[PRE10]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We start coroutines with coroutine builders such as `launch` or `async`, which
    we will cover in the next section. Until then, we need to understand that when
    launching a coroutine, we can also modify the `CoroutineContext` object of the
    coroutine by specifying a `CoroutineDispatcher` object.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `launch` 或 `async` 等协程构建器启动协程，这些内容将在下一节中介绍。在此之前，我们需要了解在启动协程时，我们还可以通过指定
    `CoroutineDispatcher` 对象来修改协程的 `CoroutineContext` 对象。
- en: Now we've used `Dispatchers.IO` as a dispatcher throughout our examples. But
    are there any other dispatchers that are of use to us?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在所有示例中使用了 `Dispatchers.IO` 作为调度器。但还有其他对我们有用的调度器吗？
- en: '`Dispatchers.IO` is a dispatcher offered by the Coroutines API, but in addition
    to this, coroutines offer other dispatchers too. Let''s list the most notable
    dispatchers as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dispatchers.IO` 是 Coroutines API 提供的调度器，但除了这个之外，协程还提供了其他调度器。以下列出最显著的调度器：'
- en: '`Dispatchers.Main`: This dispatches work to the main thread on Android. It
    is ideal for light work (which doesn''t block the UI) or actual UI function calls
    and interactions.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dispatchers.Main`：在 Android 上将工作分发到主线程。对于轻量级工作（不会阻塞 UI）或实际的 UI 函数调用和交互来说，这是理想的。'
- en: '`Dispatchers.IO`: This dispatches blocking work to a background thread pool
    that specializes in handling disk-heavy or network-heavy operations. This dispatcher
    should be specified for suspending work on local databases or executing network
    requests.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dispatchers.IO`：将阻塞工作分发到专门处理磁盘密集型或网络密集型操作的后台线程池。对于在本地数据库上挂起工作或执行网络请求，应指定此调度器。'
- en: '`Dispatchers.Default`: This dispatches blocking work to a background thread
    pool that specializes in CPU-intensive tasks, such as sorting long lists, parsing
    JSON, and more.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dispatchers.Default`：将阻塞工作分发到专门处理 CPU 密集型任务（如排序长列表、解析 JSON 等）的后台线程池。'
- en: In the previous examples, we set a specific dispatcher of `Dispatchers.IO` for
    the `CoroutineContext` object of the coroutines launched, ensuring that suspended
    work will be dispatched by this specific dispatcher.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们为启动的协程的 `CoroutineContext` 对象设置了特定的 `Dispatchers.IO` 调度器，确保挂起的任务将由这个特定的调度器分发。
- en: 'But we''ve made a critical mistake! Let''s take a look at the code again:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们犯了一个关键的错误！让我们再次查看代码：
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The main issue with this code is that the `startAnimation()` and `stopAnimation()`
    functions are probably not even suspending functions, as they interact with the
    UI.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的主要问题是 `startAnimation()` 和 `stopAnimation()` 函数可能甚至不是挂起函数，因为它们与 UI 进行交互。
- en: We wanted to run our `database.storeUser()` blocking work on a background thread,
    so we specified the `Dispatchers.IO` dispatcher to the `CoroutineContext` object.
    But this means that all the rest of the code in the coroutine block (that is,
    the `startAnimation()` and `stopAnimation()` function calls) will be dispatched
    to a thread pool intended for background work instead of being dispatched to the
    main thread.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将 `database.storeUser()` 的阻塞工作在后台线程上运行，因此我们将 `Dispatchers.IO` 调度器指定给 `CoroutineContext`
    对象。但这意味着协程块中的所有其他代码（即 `startAnimation()` 和 `stopAnimation()` 函数调用）将被分发到旨在处理后台工作的线程池，而不是分发到主线程。
- en: To have more fine-grained control regarding what threads our functions are being
    dispatched to, coroutines allow us to control the dispatcher by using the `withContext`
    block, which creates a block of code that can run on a different dispatcher.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更精细地控制函数被分发到哪些线程，协程允许我们通过使用 `withContext` 块来控制调度器，该块创建了一个可以在不同调度器上运行的代码块。
- en: Since `startAnimation()` and `stopAnimation()` have to work on the main thread,
    let's refactor our example.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `startAnimation()` 和 `stopAnimation()` 必须在主线程上工作，让我们重构我们的示例。
- en: 'Let''s launch our coroutine with the default dispatcher of `Dispatchers.Main`,
    and then wrap our work, which has to be run on a background thread (the `database.storeUser(user)`
    suspending function), with a `withContext` block:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `Dispatchers.Main` 的默认调度器启动我们的协程，然后使用 `withContext` 块包装必须运行在后台线程（即 `database.storeUser(user)`
    挂起函数）上的工作：
- en: '[PRE12]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `withContext` function allows us to define a more granular `CoroutineContext`
    object for the block that it exposes. In our case, we had to pass the `Dispatchers.IO`
    dispatcher to make sure our blocking work with the database will run on the background
    thread instead of being dispatched to the main thread.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`withContext` 函数允许我们为其暴露的块定义一个更细粒度的 `CoroutineContext` 对象。在我们的例子中，我们必须传递 `Dispatchers.IO`
    分派器，以确保我们的数据库阻塞工作在后台线程上运行，而不是被分派到主线程。'
- en: In other words, our coroutine will have all its work dispatched to the `Dispatchers.Main`
    dispatcher, unless you define another more granular context that has its own `CoroutineDispatcher`
    set.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们的协程将把所有工作分派给 `Dispatchers.Main` 分派器，除非你定义另一个更细粒度的上下文，该上下文有自己的 `CoroutineDispatcher`
    设置。
- en: Now we've covered how to use dispatchers and how to ensure more granular control
    over how our work is dispatched to different threads. However, we haven't covered
    what the `launch { }` block means. Let's do that next.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了如何使用分派器以及如何确保对工作分派到不同线程有更细粒度的控制。然而，我们还没有介绍 `launch { }` 块的含义。让我们接下来看看这个。
- en: Coroutine builders
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协程构建器
- en: '`launch`) are extension functions on `CoroutineScope` and allow us to create
    and start coroutines. Essentially, they are a bridge between the normal synchronous
    world with regular functions and the suspending world with suspending functions.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: (`launch`) 是 `CoroutineScope` 的扩展函数，允许我们创建和启动协程。本质上，它们是正常同步世界（具有常规函数）和挂起世界（具有挂起函数）之间的桥梁。
- en: Since we can't call suspending functions inside regular functions, a coroutine
    builder method executed on the `CoroutineScope` object creates a scoped coroutine
    that provides us with a block of code where we can call our suspending functions.
    Without scopes, we cannot create coroutines – which is good since this practice
    helps to prevent memory leaks.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们无法在常规函数内部调用挂起函数，因此在 `CoroutineScope` 对象上执行协程构建方法会创建一个作用域协程，它为我们提供了一个代码块，我们可以在这里调用我们的挂起函数。没有作用域，我们无法创建协程
    - 这很好，因为这种做法有助于防止内存泄漏。
- en: 'We can use three builder functions to create coroutines:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用三个构建函数来创建协程：
- en: '`launch`: This starts a coroutine that runs concurrently with the rest of the
    code. Coroutines started with `launch` won''t return the result to the caller
    – instead, all of the suspending functions will run sequentially inside the block
    that `launch` exposes. It''s our job to get the result from the suspending functions
    and then interact with that result:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`launch`: 这将启动一个与代码其余部分并发运行的协程。使用 `launch` 启动的协程不会将结果返回给调用者 - 相反，所有挂起函数都会在
    `launch` 暴露的块内部顺序执行。我们的任务是获取挂起函数的结果，然后与该结果进行交互：'
- en: '[PRE13]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Most of the time, if you don't need concurrent work, `launch` is the go-to option
    for starting coroutines since it allows you to run your suspending work inside
    the block of code provided and doesn't care about anything else.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，如果你不需要并发工作，`launch` 是启动协程的首选选项，因为它允许你在提供的代码块内部运行你的挂起工作，并且不关心其他任何事情。
- en: If no dispatcher is specified in the coroutine builder, the dispatcher that
    is going to be used is the dispatcher provided by default by the `CoroutineScope`
    used to start the coroutine. In our case, if we wouldn't have specified a dispatcher,
    our coroutine launched with the `launch` coroutine builder will have used the
    `Dispatchers.Main` dispatcher defined by default by `lifecycleScope`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在协程构建器中没有指定分派器，将要使用的分派器是用于启动协程的 `CoroutineScope` 默认提供的分派器。在我们的例子中，如果我们没有指定分派器，使用
    `launch` 协程构建器启动的协程将使用由 `lifecycleScope` 默认定义的 `Dispatchers.Main` 分派器。
- en: Apart from `lifecycleScope`, `viewModelScope` also provides the same predefined
    dispatcher of `Dispatchers.Main`. `GlobalScope` on the other hand, defaults to
    `Dispatchers.Default` if no dispatcher was provided to the coroutine builder.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `lifecycleScope`，`viewModelScope` 也提供了相同的预定义分派器 `Dispatchers.Main`。另一方面，如果未向协程构建器提供分派器，则
    `GlobalScope` 默认为 `Dispatchers.Default`。
- en: '`async`: This starts a new coroutine, and it allows you to return the result
    as a `Deferred<T>` object, where `T` is your expected data type. The deferred
    object is a promise that your result, `T`, will be returned in the future. To
    start the coroutine and get a result, you need to call the suspending function,
    `await`, which blocks the calling thread:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async`: 这将启动一个新的协程，并允许你将结果作为 `Deferred<T>` 对象返回，其中 `T` 是你期望的数据类型。延迟对象是对你的结果
    `T` 将在未来返回的承诺。要启动协程并获取结果，你需要调用挂起函数 `await`，这将阻塞调用线程：'
- en: '[PRE14]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can't use `async` in a normal function as it has to call the `await` suspending
    function to get the result. To fix that, first, we've created a parent coroutine
    with `launch` and started the child coroutine with `async` inside it. This means
    the child coroutine that was started with `async` inherits its `CoroutineContext`
    object from the parent coroutine that was started with `launch`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在普通函数中使用 `async`，因为它必须调用 `await` 挂起函数来获取结果。为了解决这个问题，我们首先使用 `launch` 创建了一个父协程，并在其中启动了子协程。这意味着使用
    `async` 启动的子协程从使用 `launch` 启动的父协程继承了其 `CoroutineContext` 对象。
- en: With `async`, we can get the results of the concurrent work in one place. Where
    the `async` coroutine builder shines (and where it's recommended to be used) is
    in tasks with parallel execution where results are required.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `async`，我们可以在一个地方获取并发工作的结果。`async` 协程构建器在具有并行执行且需要结果的任务中表现出色（并且推荐使用）。
- en: 'Let''s say that we need to simultaneously convert two pieces of text into speech
    and then play both results at the same time:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要同时将两段文本转换为语音，然后同时播放这两个结果：
- en: '[PRE15]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this particular example, both the resulting `deferredTitleAudio` and `deferredSubtitleAudio`
    tasks will run in parallel.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的例子中，`deferredTitleAudio` 和 `deferredSubtitleAudio` 这两个结果任务将并行运行。
- en: Since our Restaurants application hasn't featured concurrent work until now,
    we won't go any deeper in terms of concurrency topics.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的餐厅应用之前没有包含并发工作，我们不会深入探讨并发主题。
- en: '`runBlocking`: This starts a coroutine that blocks the current thread on which
    it is invoked until the coroutine has been completed. This builder should be avoided
    for async work within our app since creating threads and blocking them is less
    efficient. However, this coroutine builder can be used for unit tests.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runBlocking`：这将在被调用的当前线程上启动一个协程，直到协程完成才会阻塞该线程。由于创建线程和阻塞它们效率较低，因此应避免在我们的应用中用于异步工作。然而，这个协程构建器可以用于单元测试。'
- en: Now that we have covered the basics of coroutines, it's high time we implement
    coroutines in our Restaurants application!
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了协程的基础知识，是时候在我们的餐厅应用中实现协程了！
- en: Using coroutines for async work
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用协程进行异步工作
- en: The first thing that we have to do is identify the async/heavy work that we
    have done in our Restaurants application.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的第一件事是确定我们在餐厅应用中已经完成的异步/重型工作。
- en: Without looking at the code, we know that our app retrieves a list of restaurants
    from the server. It does that by initiating a network request with Retrofit and
    then waits for a response. This action qualifies as an async job because we don't
    want to block the main (UI) thread while the app waits for the network response
    to arrive.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 不看代码，我们知道我们的应用通过使用 Retrofit 初始化网络请求并等待响应来从服务器检索餐厅列表。这个动作符合异步任务的标准，因为我们不希望应用在等待网络响应到达时阻塞主（UI）线程。
- en: 'If we check out the `RestaurantsViewModel` class, we can identify that the
    `getRestaurants()` method is the one place in our application where heavy blocking
    work is happening:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 `RestaurantsViewModel` 类，我们可以确定 `getRestaurants()` 方法是我们应用中发生重型阻塞工作的唯一地方：
- en: '[PRE16]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When we implemented the network request, we used Retrofit's `enqueue()` method
    to which we passed a `Callback` object where we could wait for the result without
    blocking the main thread.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现网络请求时，我们使用了 Retrofit 的 `enqueue()` 方法，并将一个 `Callback` 对象传递给它，这样我们就可以等待结果而不阻塞主线程。
- en: To simplify the way we handle this async operation of getting the restaurants
    from the server, we will implement coroutines. This will allow us to ditch callbacks
    and make our code more concise.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化我们从服务器获取餐厅信息这一异步操作的处理方式，我们将实现协程。这将使我们能够放弃回调，使我们的代码更加简洁。
- en: 'In this section, we will cover two main steps:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍两个主要步骤：
- en: Implementing coroutines instead of callbacks
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用协程代替回调
- en: Improving the way our app works with coroutines
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过协程改进我们的应用工作方式
- en: Let's get started!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Implementing coroutines instead of callbacks
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用协程代替回调
- en: 'To handle async work with coroutines, we need to do the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用协程处理异步工作，我们需要执行以下操作：
- en: Define our async work in a suspending function.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个挂起函数中定义我们的异步工作。
- en: Next, create a coroutine and call the suspending function inside it to obtain
    the result asynchronously.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，创建一个协程，并在其中调用挂起函数以异步获取结果。
- en: 'Enough with the theory, it''s time to code! Perform the following steps:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 理论已经足够了，现在是时候编写代码了！执行以下步骤：
- en: 'Inside the `RestaurantsApiService` interface, add the `suspend` keyword to
    the `getRestaurants()` method and replace the `Call<List<Restaurant>>` return
    type of the method with `List<Restaurant>`:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RestaurantsApiService` 接口内部，将 `suspend` 关键字添加到 `getRestaurants()` 方法中，并将方法的
    `Call<List<Restaurant>>` 返回类型替换为 `List<Restaurant>`：
- en: '[PRE17]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Retrofit supports coroutines out of the box for network requests. This means
    that we can mark any method in our Retrofit interface with the `suspend` keyword;
    therefore, we can transform the network requests to suspending work that isn't
    blocking the main thread of the application.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Retrofit 默认支持协程用于网络请求。这意味着我们可以在 Retrofit 接口中的任何方法上使用 `suspend` 关键字；因此，我们可以将网络请求转换为不会阻塞应用程序主线程的挂起工作。
- en: Because of this, the `Call<T>` return type is redundant. We no longer need Retrofit
    to return a `Call` object on which we would normally enqueue a `Callback` object
    to listen for the response – all of this will be handled by the Coroutines API.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，`Call<T>` 返回类型是多余的。我们不再需要 Retrofit 返回一个 `Call` 对象，我们通常会在上面排队一个 `Callback`
    对象来监听响应 - 所有这些都将由协程 API 处理。
- en: 'Since we will no longer receive a `Call` object from Retrofit, we will also
    not need the `Callback` object in our `RestaurantsViewModel` class. Clean up the
    `RestaurantsViewModel` component:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们不再从 Retrofit 接收 `Call` 对象，因此我们也不再需要在 `RestaurantsViewModel` 类中使用 `Callback`
    对象。清理 `RestaurantsViewModel` 组件：
- en: 'Remove the `restaurantsCall: Call<List<Restaurant>` member variable.'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '移除 `restaurantsCall: Call<List<Restaurant>>` 成员变量。'
- en: Remove the `restaurantsCall.cancel()` method call inside the `onCleared()` callback.
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除 `onCleared()` 回调中的 `restaurantsCall.cancel()` 方法调用。
- en: Remove the entire body of the `getRestaurants()` method.
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除 `getRestaurants()` 方法的整个主体。
- en: 'Inside the `getRestaurants()` method, call the `restInterface.getRestaurants()`
    suspending function and store the result in a `restaurants` variable:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `getRestaurants()` 方法内部，调用 `restInterface.getRestaurants()` 挂起函数并将结果存储在 `restaurants`
    变量中：
- en: '[PRE18]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The IDE will throw an error telling us that we cannot call the `restInterface.getRestaurants()`
    suspending function from the regular `getRestaurants()` function within the `ViewModel`
    component.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: IDE 将抛出一个错误，告诉我们不能在 `ViewModel` 组件的常规 `getRestaurants()` 函数中调用 `restInterface.getRestaurants()`
    挂起函数。
- en: To fix this, we must create a coroutine, launch it, and call the suspending
    function there.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们必须创建一个协程，启动它，并在那里调用挂起函数。
- en: 'Before creating a coroutine, we need to create a `CoroutineScope` object. Inside
    the `ViewModel` component, define a member variable of type `Job` and another
    of type `CoroutineScope`, just as we learned earlier:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建协程之前，我们需要创建一个 `CoroutineScope` 对象。在 `ViewModel` 组件内部，定义一个类型为 `Job` 的成员变量和另一个类型为
    `CoroutineScope` 的成员变量，就像我们之前学过的那样：
- en: '[PRE19]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `job` variable is the handle that will allow us to cancel the coroutine
    scope, while the `scope` variable will ensure we keep track of the coroutines
    that are going be to be launched with it.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`job` 变量是允许我们取消协程范围的句柄，而 `scope` 变量将确保我们跟踪将要使用它的协程。'
- en: Since the network request is a heavy blocking operation, we want its suspending
    work to be executed on the `IO` thread pool to avoid blocking the main thread,
    so we specified the `Dispatchers.IO` dispatcher for our `scope` object.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由于网络请求是一个重量级的阻塞操作，我们希望其挂起工作在 `IO` 线程池上执行，以避免阻塞主线程，因此我们为我们的 `scope` 对象指定了 `Dispatchers.IO`
    分发器。
- en: 'Inside the `onCleared()` callback method, call the `cancel()` method in the
    newly created job variable:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onCleared()` 回调方法内部，调用新创建的 `job` 变量中的 `cancel()` 方法：
- en: '[PRE20]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: By calling `cancel()` on our `job` variable, we ensure that if the `RestaurantsViewModel`
    component is destroyed (for example, in scenarios where the user navigates to
    a different screen) the coroutine `scope` object will be canceled through its
    `job` object reference. Effectively, this will cancel any suspending work and
    prevent the coroutine from causing a memory leak.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `job` 变量上调用 `cancel()`，我们确保如果 `RestaurantsViewModel` 组件被销毁（例如，在用户导航到不同屏幕的场景中），协程
    `scope` 对象将通过其 `job` 对象引用被取消。实际上，这将取消任何挂起工作，并防止协程导致内存泄漏。
- en: 'Inside the `getRestaurants()` method in our `ViewModel` component, create a
    coroutine by calling `launch` on the previously defined `scope` object, and inside
    that body exposed by the coroutine add the existing code where we obtain the restaurants:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `ViewModel` 组件中的 `getRestaurants()` 方法内部，通过在先前定义的 `scope` 对象上调用 `launch`
    来创建一个协程，并在协程暴露的体内添加我们获取餐厅的现有代码：
- en: '[PRE21]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Success! We have launched a coroutine that executes our suspending work of obtaining
    the restaurants from the server.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！我们已经启动了一个协程，执行了从服务器获取餐厅的挂起工作。
- en: 'Next, add the initial code to update our `State` object with the newly received
    restaurants so that the Compose UI displays them:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加初始代码来更新我们的 `State` 对象，以便 Compose UI 显示新收到的餐厅：
- en: '[PRE22]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: However, this approach is flawed. Can you point out why?
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法是有缺陷的。你能指出为什么吗？
- en: Well, we are updating the UI on an incorrect thread. Our `scope` is defined
    to run the coroutine on a thread from the `Dispatchers.IO` thread pool, but updating
    the UI should happen on the Main thread.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们正在错误的线程上更新 UI。我们的 `scope` 被定义为在 `Dispatchers.IO` 线程池中的一个线程上运行协程，但更新 UI 应该在主线程上发生。
- en: 'Inside the `getRestaurants()` method, wrap the line of code where the Compose
    `State` object is updated with a `withContext` block that specifies the `Dispatchers.Main`
    dispatcher:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `getRestaurants()` 方法中，将更新 Compose `State` 对象的代码行用 `withContext` 块包装，该块指定了
    `Dispatchers.Main` 分发器：
- en: '[PRE23]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: By doing this, we ensure that while heavy work is being done on the background
    threads, the UI is updated from the main thread.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们确保在后台线程上执行繁重的工作的同时，UI 从主线程更新。
- en: 'We have now successfully implemented coroutines in our app. We have defined
    a scope and created a coroutine where we executed our suspending work: a network
    request.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经在我们的应用中成功实现了协程。我们定义了一个作用域并创建了一个协程，在那里我们执行了我们的挂起工作：一个网络请求。
- en: You can now **Run** the application and notice that on the outside, the behavior
    of the app hasn't changed. However, behind the scenes, our async work was done
    with the help of coroutines in a more elegant manner than before.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以 **运行** 应用程序，并注意在外部，应用程序的行为并没有改变。然而，在幕后，我们的异步工作是在比以前更优雅的方式下通过协程完成的。
- en: Even so, there are a few things that could be improved. Let's tackle those next.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 即使如此，还有一些事情可以改进。让我们接下来解决这些问题。
- en: Improving the way our app works with coroutines
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进我们应用与协程协同工作的方式
- en: Our app uses a coroutine to move heavy work from the main thread to specialized
    threads.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用使用协程将繁重的工作从主线程移动到专门的线程。
- en: 'However, if we think about our particular implementation, we can find some
    ways to improve our coroutine-related code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们考虑我们的特定实现，我们可以找到一些改进与协程相关的代码的方法：
- en: Use predefined scopes as opposed to custom scopes.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用预定义的作用域而不是自定义的作用域。
- en: Add error handling.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加错误处理。
- en: Make sure that every `suspend` function is safe to be called on any `Dispatcher`
    object.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保每个 `suspend` 函数都可以安全地调用在任何 `Dispatcher` 对象上。
- en: 'Let''s start with the fun one: replacing our custom scope with a predefined
    one!'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从有趣的部分开始：用预定义的作用域替换我们的自定义作用域！
- en: Using predefined scopes as opposed to custom scopes
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用预定义的作用域而不是自定义的作用域
- en: 'In our current implementation, we''ve defined a custom `CoroutineScope` object
    that will make sure that its coroutines will live as long as the `RestaurantsViewModel`
    instance. To achieve this, we pass a `Job` object to our `CoroutineScope` builder
    and cancel it when the `ViewModel` component is destroyed: on the `onCleared()`
    callback method.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的当前实现中，我们定义了一个自定义的 `CoroutineScope` 对象，这将确保其协程的寿命与 `RestaurantsViewModel`
    实例一样长。为了实现这一点，我们将一个 `Job` 对象传递给我们的 `CoroutineScope` 构建器，并在 `ViewModel` 组件被销毁时取消它：在
    `onCleared()` 回调方法中。
- en: Now, remember that coroutines are well integrated with the Jetpack libraries,
    and when we define scopes, we also talk about predefined scopes such as `lifecycleScope`,
    `viewModelScope`, and more. These scopes make sure that their coroutines live
    as long as the component they are bound to, for example, `lifecycleScope` is bound
    to a `Fragment` or `Activity` component.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，记住协程与 Jetpack 库很好地集成，当我们定义作用域时，我们也讨论了预定义的作用域，例如 `lifecycleScope`、`viewModelScope`
    以及更多。这些作用域确保它们的协程寿命与它们所绑定组件的寿命一样长，例如，`lifecycleScope` 是绑定到 `Fragment` 或 `Activity`
    组件的。
- en: Note
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Whenever you are launching a coroutine inside components such as `Activity`,
    `Fragment`, `ViewModel`, or even composable functions, remember that instead of
    creating and managing your own `CoroutineScope` object, you can use the predefined
    ones that take care of canceling coroutines automatically. By using predefined
    scopes, you can better avoid memory leaks as any suspending work is cancelled
    when needed.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时你在 `Activity`、`Fragment`、`ViewModel` 或甚至可组合函数等组件中启动协程，请记住，你不需要创建和管理自己的 `CoroutineScope`
    对象，你可以使用预定义的，它们会自动取消协程。通过使用预定义的作用域，你可以更好地避免内存泄漏，因为任何挂起的工作在需要时都会被取消。
- en: In our scenario, we can simplify our code and replace our custom `CoroutineScope`
    object with the `viewModelScope` one. Behind the scenes, this predefined scope
    will take care of canceling all of the coroutines launched with it when its parent
    `ViewModel` instance has been cleared or destroyed.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，我们可以简化我们的代码，并用 `viewModelScope` 替换我们的自定义 `CoroutineScope` 对象。幕后，这个预定义的作用域将负责在其父
    `ViewModel` 实例被清除或销毁时取消所有与之一起启动的协程。
- en: 'Let''s do that now:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来做这件事：
- en: 'Inside the `getRestaurants()` method of the `RestaurantsViewModel` class, replace
    `scope` with `viewModelScope`:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RestaurantsViewModel` 类的 `getRestaurants()` 方法中，将 `scope` 替换为 `viewModelScope`：
- en: '[PRE24]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Since we will no longer use our `scope` object, we need to make sure that our
    coroutine will run the suspending work in the background, just as it did with
    the previous scope. Pass a `Dispatchers.IO` dispatcher to the `launch` method:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们不再使用我们的 `scope` 对象，我们需要确保我们的协程将在后台运行挂起工作，就像它使用之前的范围一样。将 `Dispatchers.IO`
    分发器传递给 `launch` 方法：
- en: '[PRE25]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Usually, the `launch` coroutine builder inherits `CoroutineContext` from its
    parent coroutine. In our particular case though, if no dispatcher is specified,
    coroutines launched with `viewModelScope` will default to using `Dispatchers.Main`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`launch` 协程构建器从其父协程继承 `CoroutineContext`。然而，在我们的特定情况下，如果没有指定分发器，使用 `viewModelScope`
    启动的协程将默认使用 `Dispatchers.Main`。
- en: However, we want our network request to be executed on a background thread from
    the specialized I/O thread pool, so we passed an initial `CoroutineContext` object
    with a `Dispatchers.IO` dispatcher to our `launch` call.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们希望我们的网络请求在专门的 I/O 线程池的背景线程上执行，因此我们在 `launch` 调用中传递了一个带有 `Dispatchers.IO`
    分发器的初始 `CoroutineContext` 对象。
- en: Remove the `onCleared()` callback method entirely from the `ViewModel` class.
    We will no longer need to cancel our coroutine `scope` from a `job` object because
    `viewModelScope` takes care of that for us.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完全从 `ViewModel` 类中移除 `onCleared()` 回调方法。我们将不再需要从 `job` 对象中取消我们的协程 `scope`，因为
    `viewModelScope` 会为我们处理这件事。
- en: Remove the `job` and `scope` member variables from the `RestaurantsViewModel`
    class.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `RestaurantsViewModel` 类中移除 `job` 和 `scope` 成员变量。
- en: You can now **Run** the application and again notice that on the outside, the
    behavior of the app hasn't changed. Our code now works the same but is greatly
    simplified because we used a predefined scope instead of handling everything by
    ourselves.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以 **运行** 应用程序，并再次注意到在外部，应用程序的行为并没有改变。我们的代码现在工作方式相同，但大大简化了，因为我们使用了预定义的作用域，而不是自己处理所有事情。
- en: Next, we must re-add error handling to our project. However, this time, we will
    do it in the context of coroutines.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须重新在我们的项目中添加错误处理。然而，这次，我们将在协程的上下文中进行。
- en: Adding error handling
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加错误处理
- en: In the previous implementation with callbacks, we received an error callback
    from Retrofit. However, with coroutines, it appears that since our suspending
    function returns `List<Restaurant>>`, there is no room for error.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的带有回调的实现中，我们从 Retrofit 接收了一个错误回调。然而，使用协程时，似乎由于我们的挂起函数返回 `List<Restaurant>`，所以没有空间来处理错误。
- en: 'Indeed, we are not handling any error that could be thrown. For example, if
    you try to launch the application without internet right now, Retrofit will throw
    a `Throwable` object, which, in turn, will crash our app with a similar error
    as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们并没有处理可能抛出的任何错误。例如，如果你现在尝试在没有互联网的情况下启动应用程序，Retrofit 将会抛出一个 `Throwable`
    对象，这反过来会导致我们的应用程序崩溃，并出现如下类似的错误：
- en: '[PRE26]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To handle errors, we can simply wrap suspending function calls in a `try catch`
    block:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理错误，我们可以在挂起函数调用中简单地使用 `try catch` 块：
- en: '[PRE27]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding approach is fine, but the code becomes less concise because of
    another level of nesting. Additionally, to better support a single point of error
    handling, coroutines allow you to pass a `CoroutineExceptionHandler` object to
    the context of your `CoroutineScope` object:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法是可以的，但由于又增加了一层嵌套，代码变得不那么简洁。此外，为了更好地支持单点错误处理，协程允许你将 `CoroutineExceptionHandler`
    对象传递到你的 `CoroutineScope` 对象的上下文中：
- en: '![Figure 4.5 – The signature of CoroutineExceptionHandler'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.5 – The signature of CoroutineExceptionHandler]'
- en: '](img/B17788_04_5.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17788_04_5.jpg]'
- en: Figure 4.5 – The signature of CoroutineExceptionHandler
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – `CoroutineExceptionHandler` 的签名
- en: The `CoroutineExceptionHandler` object allows us to handle errors thrown by
    any coroutine launched within a `CoroutineScope` object, no matter how nested
    it might be. This handler gives us access to a function that exposes the `CoroutineContext`
    object and the `Throwable` object thrown in this particular context.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`CoroutineExceptionHandler`对象允许我们处理在`CoroutineScope`对象内部启动的任何协程抛出的错误，无论它可能有多层嵌套。此处理程序为我们提供了访问函数，该函数公开了`CoroutineContext`对象和在此特定上下文中抛出的`Throwable`对象。'
- en: 'Let''s add such a handler to the `RestaurantsViewModel` class. Perform the
    following steps:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`RestaurantsViewModel`类中添加这样的处理程序。执行以下步骤：
- en: 'Define an `errorHandler` member variable of type `CoroutineExceptionHandler`
    and print the stack trace of the `exception: Throwable` parameter:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '定义一个类型为`CoroutineExceptionHandler`的`errorHandler`成员变量，并打印`exception: Throwable`参数的堆栈跟踪：'
- en: '[PRE28]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We're not interested in the first parameter of type `CoroutineContext`, so we
    named it with an underscore, `_`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对类型为`CoroutineContext`的第一个参数不感兴趣，所以我们用下划线命名它，`_`。
- en: 'Inside the `getRestaurants()` method, pass the `errorHandler` variable to the
    `launch` block using the `+` operator:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`getRestaurants()`方法内部，使用`+`运算符将`errorHandler`变量传递给`launch`块：
- en: '[PRE29]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: By passing our `errorHandler` variable to the `launch` method, we make sure
    that the `CoroutineContext` object of this coroutine sets this `CoroutineExceptionHandler`,
    which will allow us to handle errors inside our handler.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将我们的`errorHandler`变量传递给`launch`方法，我们确保这个协程的`CoroutineContext`对象设置了此`CoroutineExceptionHandler`，这将允许我们在处理程序内部处理错误。
- en: Try running the app again without the internet.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在没有互联网的情况下再次运行应用。
- en: Now the app shouldn't crash because the `errorHandler` variable will catch the
    `Throwable` object thrown by Retrofit and allow us to print its stack trace.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用不应该崩溃，因为`errorHandler`变量会捕获Retrofit抛出的`Throwable`对象，并允许我们打印其堆栈跟踪。
- en: Note
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As an improvement, try to find a way of notifying the UI that an error has occurred,
    thereby informing the user of what just happened.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 作为改进，尝试找到一种方法来通知UI已发生错误，从而告知用户刚刚发生了什么。
- en: We are now handling errors with coroutines, so it's time to move to the last
    point of improvement – handling the switch of dispatchers correctly.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在使用协程处理错误，因此是时候转向最后一个改进点——正确处理调度器的切换。
- en: Making sure that every suspending function is safe to be called on any dispatcher
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确保每个挂起函数可以在任何调度器上安全调用
- en: When defining suspending functions, a good practice is to make sure that every
    suspending function can be called on any `Dispatcher` object. This way, the caller
    (in our case, the coroutine) doesn't have to worry about what thread will be needed
    to execute the suspending function.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 定义挂起函数时，一个好的做法是确保每个挂起函数可以在任何`Dispatcher`对象上调用。这样，调用者（在我们的情况下，是协程）就不必担心需要什么线程来执行挂起函数。
- en: 'Let''s analyze our code with the coroutine:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用协程分析我们的代码：
- en: '[PRE30]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `getRestaurants()` method of the `restInterface: RestaurantsApiService`
    interface is a suspending function. This function should always be run on `Dispatchers.IO`
    since it executes a heavy I/O operation, that is, the network request.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`restInterface: RestaurantsApiService`接口的`getRestaurants()`方法是一个挂起函数。这个函数应该始终在`Dispatchers.IO`上运行，因为它执行一个重I/O操作，即网络请求。'
- en: However, this would mean that whenever we have to call `restInterface.getRestaurants()`,
    we either have to call this suspending function from a coroutine that has a scope
    of `Dispatchers.IO` – just as we did previously – or always wrap it in a `withContext(Dispatchers.IO)`
    block inside the caller coroutine.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这意味着每次我们必须调用`restInterface.getRestaurants()`时，我们要么必须从具有`Dispatchers.IO`范围的协程中调用这个挂起函数——就像我们之前做的那样——或者总是将调用者协程中的`withContext(Dispatchers.IO)`块包装起来。
- en: Both of these alternatives don't scale well. Imagine that you have to call `restInterface.getRestaurants()`
    10 times in the `RestaurantsViewModel` class. You would always have to be careful
    with setting the dispatcher when calling this function.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种替代方案都不太容易扩展。想象一下，你必须在`RestaurantsViewModel`类中调用`restInterface.getRestaurants()`
    10次。你总是需要在调用此函数时小心设置调度器。
- en: 'Let''s address this by creating a separate method where we can specify the
    correct dispatcher for our suspending function:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个单独的方法来解决这个问题，我们可以在其中指定挂起函数的正确调度器：
- en: 'Inside the `RestaurantsViewModel` class, create a separate suspending method,
    called `getRemoteRestaurants()`, and wrap the `restInterface.getRestaurants()`
    call there with a `withContext()` block:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RestaurantsViewModel`类内部，创建一个单独的挂起方法，称为`getRemoteRestaurants()`，并在其中用`withContext()`块包裹`restinterface.getRestaurants()`调用：
- en: '[PRE31]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To the `withContext` method, we''ve passed the corresponding dispatcher for
    this suspending function: `Dispatchers.IO`.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向`withContext`方法传递了为此挂起函数对应的调度器：`Dispatchers.IO`。
- en: This means that whenever this suspending function is called (from a coroutine
    or another suspending function), the dispatcher will be switched to `Dispatchers.IO`
    for the `restInterface.getRestaurants()` call's execution.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每当调用此挂起函数（从一个协程或另一个挂起函数）时，调度器将切换到`Dispatchers.IO`以执行`restinterface.getRestaurants()`调用。
- en: By doing so, we make sure that whoever is calling `getRemoteRestaurants()` will
    not have to care about the correct thread dispatcher for the content of this method.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们确保调用`getRemoteRestaurants()`的人不必关心此方法内容的正确线程调度器。
- en: 'In the `getRestaurants()` method of the `ViewModel` component, replace the
    `restInterface.getRestaurants()` method call with `getRemoteRestaurants()`:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewModel`组件的`getRestaurants()`方法中，将`restInterface.getRestaurants()`方法调用替换为`getRemoteRestaurants()`：
- en: '[PRE32]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Since the content of the `getRemoteRestaurants()` method will be called on
    its appropriate dispatcher, we no longer have to pass `Dispatchers.IO` to the
    launch block. Remove the `Dispatchers.IO` dispatcher from the coroutine `launch`
    block:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`getRemoteRestaurants()`方法的内容将在其适当的调度器上调用，我们不再需要将`Dispatchers.IO`传递给启动块。从协程的`launch`块中移除`Dispatchers.IO`调度器：
- en: '[PRE33]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: By default, the launch block will inherit the `CoroutineContext` (and so its
    defined `Dispatcher` object) from its parent coroutine. In our case, there is
    no parent coroutine, so the `launch` block will launch a coroutine on the `Dispatchers.Main`
    thread which was predefined by the `viewModelScope` custom scope.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，启动块将从其父协程继承`CoroutineContext`（以及其定义的`Dispatcher`对象）。在我们的例子中，没有父协程，因此`launch`块将在`viewModelScope`自定义作用域预定义的`Dispatchers.Main`线程上启动协程。
- en: 'Since the coroutine will now run on the `Dispatchers.Main` thread, we can remove
    the redundant `withContext(Dispatchers.Main)` block from within the `getRestaurants()`
    method. The `getRestaurants()` method should now look like this:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于协程现在将在`Dispatchers.Main`线程上运行，我们可以从`getRestaurants()`方法中移除多余的`withContext(Dispatchers.Main)`块。`getRestaurants()`方法现在应该看起来像这样：
- en: '[PRE34]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, the `getRestaurants()` method where we launched the coroutine is much
    easier to read and understand. Our suspending function call, for instance, `getRemoteRestaurants()`,
    is called inside this coroutine on the `Dispatchers.Main` dispatcher. However,
    at the same time, our suspending function has its own `withContext()` block with
    its corresponding `Dispatcher` object set:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们启动协程的`getRestaurants()`方法更容易阅读和理解。例如，我们的挂起函数调用`getRemoteRestaurants()`是在`Dispatchers.Main`调度器上的这个协程内部进行的。然而，与此同时，我们的挂起函数有自己的`withContext()`块，并设置了相应的`Dispatcher`对象：
- en: '[PRE35]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This practice allows us to call suspending functions from coroutines with any
    given `Dispatcher` object, simply because the suspending functions have their
    own `CoroutineContext` object set with their appropriate `Dispatcher` objects.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法允许我们从具有任何给定`Dispatcher`对象的协程中调用挂起函数，因为挂起函数有自己的`CoroutineContext`对象，并设置了适当的`Dispatcher`对象。
- en: At runtime, even though the coroutines are launched on their initial `Dispatcher`
    object, when our suspending functions are called, the `Dispatcher` object is briefly
    overridden for every suspending function that is internally wrapped with a `withContext`
    block.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，尽管协程是在它们的初始`Dispatcher`对象上启动的，但当我们调用挂起函数时，`Dispatcher`对象会暂时被`withContext`块内部包装的每个挂起函数覆盖。
- en: Note
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For Retrofit interface calls such as `restInterface.getRestaurants()`, we can
    skip wrapping them in `withContext()` blocks because Retrofit already does this
    behind the scenes and sets the `Dispatchers.IO` dispatcher for all suspending
    methods from within its interface.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像`restInterface.getRestaurants()`这样的Retrofit接口调用，我们可以跳过将它们包裹在`withContext()`块中，因为Retrofit已经在幕后做了这件事，并为它接口内的所有挂起方法设置了`Dispatchers.IO`调度器。
- en: Finally, the application should behave the same. However, in terms of good practices,
    we made sure that the correct `Dispatcher` object is set for every suspending
    function out of the box, and without us having to manually set it in every coroutine.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，应用程序应该表现相同。然而，在良好的实践方面，我们确保每个挂起函数都默认设置了正确的 `Dispatcher` 对象，而无需我们在每个协程中手动设置它。
- en: Now that we improved the way dispatchers are set within our suspending function
    and coroutine, it's time to wrap this chapter up.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们改进了在挂起函数和协程中设置调度器的方式，是时候总结本章内容了。
- en: Summary
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how coroutines allow us to write async code in a
    much clearer and more concise way.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了协程如何让我们以更清晰、更简洁的方式编写异步代码。
- en: 'We understood what coroutines are, how they work, and why they are needed in
    the first place. We unveiled the core elements of coroutines: from `suspend` functions
    to `CoroutineScope` objects, to `CoroutineContext` objects and `Dispatcher` objects.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了协程是什么，它们是如何工作的，以及为什么一开始就需要它们。我们揭示了协程的核心元素：从 `suspend` 函数到 `CoroutineScope`
    对象，再到 `CoroutineContext` 对象和 `Dispatcher` 对象。
- en: Then, we replaced the callbacks with coroutines in our Restaurants application
    and noticed how the code is much easier to understand and less nested. Additionally,
    we learned how to perform error handling with coroutines and integrated some of
    the best practices when working with coroutines.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在我们的 Restaurants 应用程序中将回调替换为协程，并注意到代码变得更加易于理解，嵌套程度更低。此外，我们还学习了如何使用协程进行错误处理，并在与协程一起工作时整合了一些最佳实践。
- en: In the next chapter, we will add another Compose-based screen to our Restaurants
    application and learn how to navigate between screens in Compose with yet another
    Jetpack library.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将向我们的 Restaurants 应用程序添加另一个基于 Compose 的屏幕，并学习如何在 Compose 中使用另一个 Jetpack
    库在屏幕之间进行导航。
- en: Further reading
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: While canceling coroutines might seem simple with the help of the associated
    `Job` objects, it's important to note that any cancelation must be cooperative.
    More specifically, when coroutines perform suspending work based on conditional
    statements, you must ensure the coroutine is cooperative with respect to canceling.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然借助相关的 `Job` 对象取消协程可能看起来很简单，但重要的是要注意任何取消都必须是协作的。更具体地说，当协程根据条件语句执行挂起操作时，你必须确保协程在取消方面是协作的。
- en: 'You can read about this topic, in more detail, in the official documentation:
    [https://kotlinlang.org/docs/cancellation-and-timeouts.html#cancellation-is-cooperative](https://kotlinlang.org/docs/cancellation-and-timeouts.html#cancellation-is-cooperative).'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方文档中了解更多关于这个主题的信息：[https://kotlinlang.org/docs/cancellation-and-timeouts.html#cancellation-is-cooperative](https://kotlinlang.org/docs/cancellation-and-timeouts.html#cancellation-is-cooperative)。
