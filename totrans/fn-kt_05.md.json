["```kt\nfun sum(a:Int, b:Int): Int {\n   return a + b\n}\n```", "```kt\nfun sum(a:Int, b:Int): Int = a + b\n```", "```kt\nfun sum(a:Int, b:Int) = a + b\n```", "```kt\nfun basicFunction(name: String, size: Int) {\n\n}\n```", "```kt\nfun aVarargFun(vararg names: String) {\n   names.forEach(::println)\n}\n\nfun main(args: Array<String>) {\n   aVarargFun()\n   aVarargFun(\"Angela\", \"Brenda\", \"Caroline\")\n}\n```", "```kt\nfun multipleVarargs(vararg names: String, vararg sizes: Int) {\n// Compilation error, \"Multiple vararg-parameters are prohibited\"\n}\n```", "```kt\nfun unless(condition: Boolean, block: () -> Unit) {\n   if (!condition) block()\n}\n\nunless(someBoolean) {\n   println(\"You can't access this website\")\n}\n```", "```kt\nfun <T, R> transform(vararg ts: T, f: (T) -> R): List<R> = ts.map(f)\n```", "```kt\ntransform(1, 2, 3, 4) { i -> i.toString() }\n```", "```kt\nfun <T> emit(t: T, vararg listeners: (T) -> Unit) = listeners.forEach { listener ->\n    listener(t)\n}\n\nemit(1){i -> println(i)} //Compilation error. Passing value as a vararg is only allowed inside a parenthesized argument list\n```", "```kt\nemit(1, ::println, {i -> println(i * 2)})\n```", "```kt\ntypealias Kg = Double\ntypealias cm = Int\n\ndata class Customer(val firstName: String,\n               val middleName: String,\n               val lastName: String,\n               val passportNumber: String,\n               val weight: Kg,\n               val height: cm)\n```", "```kt\nval customer1 = Customer(\"John\", \"Carl\", \"Doe\", \"XX234\", 82.3, 180)\n```", "```kt\nval customer2 = Customer(\n      lastName = \"Doe\",\n      firstName = \"John\",\n      middleName = \"Carl\",\n      height = 180,\n      weight = 82.3,\n      passportNumber = \"XX234\")\n```", "```kt\nfun paramAfterVararg(courseId: Int, vararg students: String, roomTemperature: Double) {\n    //Do something here\n}\n\nparamAfterVararg(68, \"Abel\", \"Barbara\", \"Carl\", \"Diane\", roomTemperature = 18.0)\n```", "```kt\nfun high(f: (Int, String) -> Unit) {\n   f(1, \"Romeo\")\n}\n\nhigh { q, w ->\n    //Do something\n}\n```", "```kt\nfun high(f: (age:Int, name:String) -> Unit) {\n   f(1, \"Romeo\")\n}\n```", "```kt\nfun high(f: (age:Int, name:String) -> Unit) {\n   f(age = 3, name = \"Luciana\") //compilation error\n}\n```", "```kt\ndata class Programmer(val firstName: String,\n                 val lastName: String,\n                 val favouriteLanguage: String = \"Kotlin\",\n                 val yearsOfExperience: Int = 0)\n```", "```kt\nval programmer1 = Programmer(\"John\", \"Doe\")\n```", "```kt\nval programmer2 = Programmer(\"John\", \"Doe\", 12) //Error\n\nval programmer2 = Programmer(\"John\", \"Doe\", yearsOfExperience = 12) //OK\n```", "```kt\nval programmer3 = Programmer(\"John\", \"Doe\", \"TypeScript\", 1)\n```", "```kt\nfun String.sendToConsole() = println(this)\n\nfun main(args: Array<String>) {\n   \"Hello world! (from an extension function)\".sendToConsole()\n}\n```", "```kt\nfun sendToConsole(string: String) = println(string)\n\nsendToConsole(\"Hello world! (from a normal function)\")\n```", "```kt\nclass Human(private val name: String)\n\nfun Human.speak(): String = \"${this.name} makes a noise\" //Cannot access 'name': it is private in 'Human'\n```", "```kt\nopen class Canine {\n   open fun speak() = \"<generic canine noise>\"\n}\n\nclass Dog : Canine() {\n   override fun speak() = \"woof!!\"\n}\n\nfun printSpeak(canine: Canine) {\n   println(canine.speak())\n}\n```", "```kt\nprintSpeak(Canine())\nprintSpeak(Dog())\n```", "```kt\nopen class Feline\n\nfun Feline.speak() = \"<generic feline noise>\"\n\nclass Cat : Feline()\n\nfun Cat.speak() = \"meow!!\"\n\nfun printSpeak(feline: Feline) {\n   println(feline.speak())\n}\n```", "```kt\nprintSpeak(Feline())\nprintSpeak(Cat()\n```", "```kt\nopen class Primate(val name: String)\n\nfun Primate.speak() = \"$name: <generic primate noise>\"\n\nopen class GiantApe(name: String) : Primate(name)\n\nfun GiantApe.speak() = \"${this.name} :<scary 100db roar>\"\n\nfun printSpeak(primate: Primate) {\n println(primate.speak())\n}\n\nprintSpeak(Primate(\"Koko\"))\nprintSpeak(GiantApe(\"Kong\"))\n```", "```kt\nopen class Caregiver(val name: String) {\n   open fun Feline.react() = \"PURRR!!!\"\n\n   fun Primate.react() = \"*$name plays with ${this@Caregiver.name}*\"\n\n   fun takeCare(feline: Feline) {\n      println(\"Feline reacts: ${feline.react()}\")\n   }\n\n   fun takeCare(primate: Primate){\n      println(\"Primate reacts: ${primate.react()}\")\n   }\n}\n```", "```kt\nclass Dispatcher {\n   val dispatcher: Dispatcher = this\n\n   fun Int.extension(){\n      val receiver: Int = this\n      val dispatcher: Dispatcher = this@Dispatcher\n   }\n}\n```", "```kt\nval adam = Caregiver(\"Adam\")\n\nval fulgencio = Cat()\n\nval koko = Primate(\"Koko\")\n\nadam.takeCare(fulgencio)\nadam.takeCare(koko)\n```", "```kt\nopen class Vet(name: String): Caregiver(name) {\n   override fun Feline.react() = \"*runs away from $name*\"\n}\n```", "```kt\nval brenda = Vet(\"Brenda\")\n\nlistOf(adam, brenda).forEach { caregiver ->\n   println(\"${caregiver.javaClass.simpleName} ${caregiver.name}\")\n   caregiver.takeCare(fulgencio)\n   caregiver.takeCare(koko)\n}\n\n```", "```kt\nclass Worker {\n   fun work() = \"*working hard*\"\n\n   private fun rest() = \"*resting*\"\n}\n\nfun Worker.work() = \"*not working so hard*\"\n\nfun <T> Worker.work(t:T) = \"*working on $t*\"\n\nfun Worker.rest() = \"*playing video games*\"\n```", "```kt\nval worker = Worker()\n\nprintln(worker.work())\n\nprintln(worker.work(\"refactoring\"))\n\nprintln(worker.rest())\n```", "```kt\nobject Builder {\n\n}\n\nfun Builder.buildBridge() = \"A shinny new bridge\"\n```", "```kt\nclass Designer {\n   companion object {\n\n   }\n\n   object Desk {\n\n   }\n}\n\nfun Designer.Companion.fastPrototype() = \"Prototype\"\n\nfun Designer.Desk.portofolio() = listOf(\"Project1\", \"Project2\")\n```", "```kt\nDesigner.fastPrototype()\nDesigner.Desk.portofolio().forEach(::println)\n```", "```kt\ninfix fun Int.superOperation(i: Int) = this + i\n\nfun main(args: Array<String>) {\n   1 superOperation 2\n   1.superOperation(2)\n}\n```", "```kt\n\"Kotlin\" shouldStartWith \"Ko\"\n```", "```kt\n\"Kotlin\" `should start with` \"Ko\"\n```", "```kt\nobject All {\n   infix fun your(base: Pair<Base, Us>) {}\n}\n\nobject Base {\n   infix fun are(belong: Belong) = this\n}\n\nobject Belong\n\nobject Us\n\nfun main(args: Array<String>) {\n   All your (Base are Belong to Us)\n}\n```", "```kt\nclass Wolf(val name:String) {\n   operator fun plus(wolf: Wolf) = Pack(mapOf(name to this, wolf.name to wolf))\n}\n\nclass Pack(val members:Map<String, Wolf>)\n\nfun main(args: Array<String>) {\n   val talbot = Wolf(\"Talbot\")\n   val northPack: Pack = talbot + Wolf(\"Big Bertha\") // talbot.plus(Wolf(\"...\"))\n}\n```", "```kt\noperator fun Pack.plus(wolf: Wolf) = Pack(this.members.toMutableMap() + (wolf.name to wolf))\n\nval biggerPack = northPack + Wolf(\"Bad Wolf\")\n```", "```kt\n/** A function that takes 1 argument. */\npublic interface Function1<in P1, out R> : Function<R> {\n    /** Invokes the function with the specified argument. */\n    public operator fun invoke(p1: P1): R\n}\n```", "```kt\nenum class WolfActions {\n   SLEEP, WALK, BITE\n}\n\nclass Wolf(val name:String) {\n   operator fun invoke(action: WolfActions) = when (action) {\n      WolfActions.SLEEP -> \"$name is sleeping\"\n      WolfActions.WALK -> \"$name is walking\"\n      WolfActions.BITE -> \"$name is biting\"\n   }\n}\n\nfun main(args: Array<String>) {\n   val talbot = Wolf(\"Talbot\")\n\n   talbot(WolfActions.SLEEP) // talbot.invoke(WolfActions.SLEEP)\n}\n```", "```kt\noperator fun Pack.get(name: String) = members[name]!!\n\nval badWolf = biggerPack[\"Bad Wolf\"]\n```", "```kt\nenum class WolfRelationships {\n   FRIEND, SIBLING, ENEMY, PARTNER\n}\n\noperator fun Wolf.set(relationship: WolfRelationships, wolf: Wolf) {\n   println(\"${wolf.name} is my new $relationship\")\n}\n\ntalbot[WolfRelationships.ENEMY] = badWolf\n```", "```kt\noperator fun Wolf.not() = \"$name is angry!!!\"\n\n!talbot // talbot.not()\n\n```", "```kt\nimport javafx.application.Application\nimport tornadofx.*\n\nfun main(args: Array<String>) {\n   Application.launch(FxApp::class.java, *args)\n}\n\nclass FxApp: App(FxView::class)\n\nclass FxView: View() {\n   override val root = vbox {\n      label(\"Functional Kotlin\")\n      button(\"Press me\")\n   }\n}\n```", "```kt\nval joinWithPipe = with(listOf(\"One\", \"Two\", \"Three\")){\n   joinToString(separator = \"|\")\n}\n```", "```kt\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    return receiver.block()\n}\n```", "```kt\nval html = buildString {\n   append(\"<html>\\n\")\n   append(\"\\t<body>\\n\")\n   append(\"\\t\\t<ul>\\n\")\n   listOf(1, 2, 3).forEach { i ->\n      append(\"\\t\\t\\t<li>$i</li>\\n\")\n   }\n   append(\"\\t\\t<ul>\\n\")\n   append(\"\\t</body>\\n\")\n   append(\"</htm\n\nl>\")\n}\n```", "```kt\npublic inline fun buildString(builderAction: StringBuilder.() -> Unit): String =\n        StringBuilder().apply(builderAction).toString()\n```", "```kt\npublic inline fun <T> T.apply(block: T.() -> Unit): T {    \n    block()\n    return this\n}\n```", "```kt\n<bicycle description=\"Fast carbon commuter\">\n    <bar material=\"ALUMINIUM\" type=\"FLAT\">\n    </bar>\n    <frame material=\"CARBON\">\n        <wheel brake=\"DISK\" material=\"ALUMINIUM\">\n        </wheel>\n    </frame>\n    <fork material=\"CARBON\">\n        <wheel brake=\"DISK\" material=\"ALUMINIUM\">\n        </wheel>\n    </fork>\n</bicycle>  \n```", "```kt\nfun main(args: Array<String>) {\n   val commuter = bicycle {\n      description(\"Fast carbon commuter\")\n      bar {\n         barType = FLAT\n         material = ALUMINIUM\n      }\n      frame {\n         material = CARBON\n         backWheel {\n            material = ALUMINIUM\n            brake = DISK\n         }\n      }\n      fork {\n         material = CARBON\n         frontWheel {\n            material = ALUMINIUM\n            brake = DISK\n         }\n      }\n   }\n\n   println(commuter)\n}\n```", "```kt\ninterface Element {\n   fun render(builder: StringBuilder, indent: String)\n}\n```", "```kt\n@DslMarker\nannotation class ElementMarker\n\n@ElementMarker\nabstract class Part(private val name: String) : Element {\n   private val children = arrayListOf<Element>()\n   protected val attributes = hashMapOf<String, String>()\n\n   protected fun <T : Element> initElement(element: T, init: T.() -> Unit): T {\n      element.init()\n      children.add(element)\n      return element\n   }\n\n   override fun render(builder: StringBuilder, indent: String) {\n      builder.append(\"$indent<$name${renderAttributes()}>\\n\")\n      children.forEach { c -> c.render(builder, indent + \"\\t\") }\n      builder.append(\"$indent</$name>\\n\")\n   }\n\n   private fun renderAttributes(): String = buildString {\n      attributes.forEach { attr, value -> append(\" $attr=\\\"$value\\\"\") }\n   }\n\n   override fun toString(): String = buildString {\n      render(this, \"\")\n   }\n}\n```", "```kt\nval commuter = bicycle {\n   description(\"Fast carbon commuter\")\n   bar {\n      barType = FLAT\n      material = ALUMINIUM\n      frame {  } //compilation error\n   }\n```", "```kt\nval commuter = bicycle {\n   description(\"Fast carbon commuter\")\n   bar {\n      barType = FLAT\n      material = ALUMINIUM\n      this@bicycle.frame{ }\n   }\n```", "```kt\nenum class Material {\n   CARBON, STEEL, TITANIUM, ALUMINIUM\n}\n\nenum class BarType {\n   DROP, FLAT, TT, BULLHORN\n}\n\nenum class Brake {\n   RIM, DISK\n}\n```", "```kt\nabstract class PartWithMaterial(name: String) : Part(name) {\n   var material: Material\n      get() = Material.valueOf(attributes[\"material\"]!!)\n      set(value) {\n         attributes[\"material\"] = value.name\n      }\n}\n```", "```kt\nclass Bicycle : Part(\"bicycle\") {\n\n   fun description(description: String) {\n      attributes[\"description\"] = description\n   }\n\n   fun frame(init: Frame.() -> Unit) = initElement(Frame(), init)\n\n   fun fork(init: Fork.() -> Unit) = initElement(Fork(), init)\n\n   fun bar(init: Bar.() -> Unit) = initElement(Bar(), init)\n}\n```", "```kt\nclass Frame : PartWithMaterial(\"frame\") {\n   fun backWheel(init: Wheel.() -> Unit) = initElement(Wheel(), init)\n}\n```", "```kt\nclass Wheel : PartWithMaterial(\"wheel\") {\n   var brake: Brake\n      get() = Brake.valueOf(attributes[\"brake\"]!!)\n      set(value) {\n         attributes[\"brake\"] = value.name\n      }\n}\n```", "```kt\nclass Bar : PartWithMaterial(\"bar\") {\n\n   var barType: BarType\n      get() = BarType.valueOf(attributes[\"type\"]!!)\n      set(value) {\n         attributes[\"type\"] = value.name\n      }\n}\n```", "```kt\nclass Fork : PartWithMaterial(\"fork\") {\n   fun frontWheel(init: Wheel.() -> Unit) = initElement(Wheel(), init)\n}\n```", "```kt\nfun bicycle(init: Bicycle.() -> Unit): Bicycle {\n   val cycle = Bicycle()\n   cycle.init()\n   return cycle\n}\n```", "```kt\nfun <T> time(body: () -> T): Pair<T, Long> {\n   val startTime = System.nanoTime()\n   val v = body()\n   val endTime = System.nanoTime()\n   return v to endTime - startTime\n}\n\nfun main(args: Array<String>) {\n   val (_,time) = time { Thread.sleep(1000) }\n   println(\"time = $time\")\n}\n```", "```kt\nval (_, time) = time(object : Function0<Unit> {\n   override fun invoke() {\n      Thread.sleep(1000)\n   }\n})\n```", "```kt\ninline fun <T> inTime(body: () -> T): Pair<T, Long> {\n   val startTime = System.nanoTime()\n   val v = body()\n   val endTime = System.nanoTime()\n   return v to endTime - startTime\n}\n\nfun main(args: Array<String>) {\n   val (_, inTime) = inTime { Thread.sleep(1000) }\n   println(\"inTime = $inTime\")\n}\n\n```", "```kt\nval startTime = System.nanoTime()\nval v = Thread.sleep(1000)\nval endTime = System.nanoTime()\nval (_, inTime) = (v to endTime - startTime)\n```", "```kt\ndata class User(val name: String)\n\nclass UserService {\n   val listeners = mutableListOf<(User) -> Unit>()\n   val users = mutableListOf<User>() \n\n   fun addListener(listener: (User) -> Unit) {\n      listeners += listener\n   }\n}\n```", "```kt\ninline fun addListener(listener: (User) -> Unit) {\n   listeners += listener //compilation error: Illegal use of inline-parameter listener\n}\n```", "```kt\n//Warning: Expected performance impact of inlining addListener can be insignificant\ninline fun addListener(noinline listener: (User) -> Unit) { \n   listeners += listener\n}\n```", "```kt\ninline fun transformName(transform: (name: String) -> String): List<User> {\n\n   val buildUser = { name: String ->\n      User(transform(name)) //compilation error: Can't inline transform here\n   }\n\n   return users.map { user -> buildUser(user.name) }\n}\n```", "```kt\ninline fun transformName(crossinline transform: (name: String) -> String): List<User> {\n\n   val buildUser = { name: String ->\n      User(transform(name)) \n   }\n\n   return users.map { user -> buildUser(user.name) }\n}\n\nfun main(args: Array<String>) {\n   val service = UserService()\n\n   service.transformName(String::toLowerCase)\n}\n```", "```kt\nfun tailrecFib(n: Long): Long {\n   tailrec fun go(n: Long, prev: Long, cur: Long): Long {\n      return if (n == 0L) {\n         prev\n      } else {\n         go(n - 1, cur, prev + cur)\n      }\n   }\n\n   return go(n, 0, 1)\n}\n```", "```kt\nfun tailrecFactorial(n: Long): Long {\n   tailrec fun go(n: Long, acc: Long): Long {\n      return if (n <= 0) {\n         acc\n      } else {\n         go(n - 1, n * acc)\n      }\n   }\n\n   return go(n, 1)\n}\n```", "```kt\nsealed class FunList<out T> {\n   object Nil : FunList<Nothing>()\n\n   data class Cons<out T>(val head: T, val tail: FunList<T>) : FunList<T>()\n\n   fun forEach(f: (T) -> Unit) {\n      tailrec fun go(list: FunList<T>, f: (T) -> Unit) {\n         when (list) {\n            is Cons -> {\n               f(list.head)\n               go(list.tail, f)\n            }\n            is Nil -> Unit//Do nothing\n         }\n      }\n\n      go(this, f)\n   }\n\n   fun <R> fold(init: R, f: (R, T) -> R): R {\n      tailrec fun go(list: FunList<T>, init: R, f: (R, T) -> R): R = when (list) {\n         is Cons -> go(list.tail, f(init, list.head), f)\n         is Nil -> init\n      }\n\n      return go(this, init, f)\n   }\n\n   fun reverse(): FunList<T> = fold(Nil as FunList<T>) { acc, i -> Cons(i, acc) }\n\n   fun <R> foldRight(init: R, f: (R, T) -> R): R = this.reverse().fold(init, f)\n\n   fun <R> map(f:(T) -> R): FunList<R> = foldRight(Nil as FunList<R>){ tail, head -> Cons(f(head), tail) }\n\n}\n```", "```kt\nfun <T, S> unfold(s: S, f: (S) -> Pair<T, S>?): Sequence<T> {\n   val result = f(s)\n   return if (result != null) {\n      sequenceOf(result.first) + unfold(result.second, f)\n   } else {\n      sequenceOf()\n   }\n}\n```", "```kt\nfun <T> elements(element: T, numOfValues: Int): Sequence<T> {\n   return unfold(1) { i ->\n      if (numOfValues > i)\n         element to i + 1\n      else\n         null\n   }\n}\n\nfun main(args: Array<String>) {\n   val strings = elements(\"Kotlin\", 5)\n   strings.forEach(::println)\n}\n```", "```kt\nfun factorial(size: Int): Sequence<Long> {\n   return sequenceOf(1L) + unfold(1L to 1) { (acc, n) ->\n      if (size > n) {\n         val x = n * acc\n         (x) to (x to n + 1)\n      } else\n         null\n   }\n}\n```", "```kt\nfun fib(size: Int): Sequence<Long> {\n   return sequenceOf(1L) + unfold(Triple(0L, 1L, 1)) { (cur, next</span>, n) ->\n      if (size > n) {\n         val x = cur + next\n         (x) to Triple(next, x, n + 1)\n      }\n      else\n         null\n   }\n}\n```"]