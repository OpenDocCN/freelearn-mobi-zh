<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Testing an Application</h1>
                </header>
            
            <article>
                
<p>To make an application more usable and attractive, we always concentrate on the logos, contents, UI, experiences, and so on, besides we also take care of the coding style. We use the latest architectures and frameworks to reduce code lines and boiler codes in order to make a robust, simple, and fast application. However, many developers forget about the testing phase. Some might not realize there's an issue until a crash report generates during application use, because they didn't adequately test during the project. Generally, some developers skip testing, as they don't want to spend some extra time on writing test cases that are not directly used in the project. This is a common mistake and results in falling quality.</p>
<p>Applications that randomly crash will always be disliked by the user, which is why the most successful Android apps always undergo thorough testing. In-depth testing can iron out an app's bugs, and optimize memory use, as well as allowing you to improve the condition of an app in regards to functional behavior, usabilities, and correctness. </p>
<p>In this chapter, we will walk through testing and its use in both Spring and Android. This chapter covers the following topics:</p>
<ul>
<li style="list-style-type: none">
<ul>
<li>Software testing</li>
<li>Fundamental of testing</li>
<li>Unit testing on Spring Boot</li>
<li>Creating a project</li>
<li>JUnit</li>
<li>UI testing on Android</li>
<li>Espresso</li>
</ul>
</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p class="mce-root">You will need to import some dependencies for both Spring and Android. Here are the dependencies.</p>
<ul>
<li><strong>Spring</strong></li>
</ul>
<p>To implement the dependency for testing, you need to add the testing dependency in the <kbd>pom.xml</kbd> file:</p>
<pre>&lt;!-- This is to implement the testing functions for the spring project --&gt;<br/>&lt;dependency&gt;<br/>   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>   &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;<br/>   &lt;scope&gt;test&lt;/scope&gt;<br/>&lt;/dependency&gt;</pre>
<ul>
<li><strong>Android</strong></li>
</ul>
<p>To test an Android project, we need to implement the testing dependencies in the <kbd>gradle</kbd> file. To add the dependencies, we need to implement in the dependencies <kbd>{...}</kbd> of <kbd>build.gradle</kbd> (app module) file. Here is a snippet code of this <kbd>build.gradle</kbd> file:</p>
<pre class="mce-root">// Dependencies for local unit tests<br/>dependencies{<br/>testImplementation "junit:junit:$rootProject.ext.junitVersion"<br/><br/>// Espresso UI Testing dependencies.<br/>androidTestImplementation "com.android.support.test.espresso:espresso-core:$rootProject.ext.espressoVersion"<br/>androidTestImplementation "com.android.support.test.espresso:espresso-contrib:$rootProject.ext.espressoVersion"<br/>androidTestImplementation "com.android.support.test.espresso:espresso-intents:$rootProject.ext.espressoVersion"<br/>}</pre>
<p class="mce-root">The source code with an example for this chapter is available on GitHub at the following link: <a href="https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter10">https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter10</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Software testing</h1>
                </header>
            
            <article>
                
<p>Software testing is one of the most essential parts of any project. Testing evaluates the stability, usability, quality assurance, functionality of components, and ensures that the software is ready to publish in the market. It also helps to find out the errors, missing requirements of a project, and so on. Testing uses techniques to execute some processes in an application or program with the intent to find bugs.</p>
<p class="mce-root">In <a href="1f77948f-747b-42f1-b15b-fec3910d97d6.xhtml" target="_blank">Chapter 6</a>, <em>Accessing the Database</em> and <a href="7f273ca8-ce1d-4577-b24c-26d0957f1c74.xhtml" target="_blank">Chapter 9</a>, <em>Creating an Application</em>, we created Spring applications and implemented REST APIs. Then we tested with a third-party tool called Insomnia. After this, we mentioned the URL path with the HTTP CRUD request functions and checked the output. This system was fine and we could see the output directly. However, it can often be difficult to find the errors and bugs, as it can't show you the errors or any abnormal behavior. Though this project is running, it's not necessarily safe to release to the market. Therefore, we need to further test its stability. Let's run through two popular testing tools and frameworks, JUnit and Espresso. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JUnit</h1>
                </header>
            
            <article>
                
<p>JUnit is the most popular testing framework, built for Java, and is open source. It has almost all the features and modules necessary to test a Java-based application in a test-driven development environment. JUnit mainly focuses on writing tests that are automated for a certain class or function. It helps to call a function and check for the expected output. Before seeing some examples of JUnit in use, let's learn about its advantages. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advantages of JUnit</h1>
                </header>
            
            <article>
                
<p>JUnit is widely used for testing Java applications because of its user-friendly functionalities. It has some powerful advantages, such as the following:</p>
<ul>
<li>The JUnit framework is open source</li>
<li>It provides text-based command lines as well as AWT-based and Swing-based graphical test mechanisms</li>
<li>It has some annotations to utilize test functions</li>
<li>It has a test runner to test running applications</li>
<li>It allows you to write code</li>
<li>It can test automatically and provide feedback</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Basic annotations of JUnit</h1>
                </header>
            
            <article>
                
<p>JUnit has some basic and important annotations, such as the following:</p>
<ul>
<li>The <kbd>@BeforeClass</kbd>: This runs once before any test functions in the class. In this function, you can connect the database or connection pool. This function has to be a static method.</li>
<li>The <kbd>@AfterClass</kbd>: This runs once after any test functions in the class. In this function, you can close the database connection and cleanup.</li>
<li>The <kbd>@Before</kbd>: This can run before <kbd>@Test</kbd> annotated functions. Here you create some objects and share to all <kbd>@Test</kbd> annotated testing functions.</li>
<li>The <kbd>@After</kbd>: This can run after <kbd>@Test</kbd> annotated functions. Here, you modify or clean the objects and share to all <kbd>@Test</kbd> annotated testing functions.</li>
<li>The <kbd>@Test</kbd>: This annotated function is the test function.</li>
</ul>
<p>Now we'll look at an example of how to test a project with JUnit. Here, you can learn about the life cycle of the testing annotations and the use of these annotations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a project</h1>
                </header>
            
            <article>
                
<p>Let's create a project where we will create REST APIs using a database for users, and show a list of the user details. In this project, we will use JDBC, MySQL, and <span>Spring Boot</span>.</p>
<p>To create a project, go to <a href="https://start.spring.io">https://start.spring.io</a> and create a Kotlin-based project with the following given dependencies:</p>
<ul>
<li>Web</li>
<li>JDBC</li>
<li>MySQL</li>
<li>DevTools</li>
</ul>
<p class="mce-root">Now we'll create some demo code, and we can test them. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Test a project using JUnit </h1>
                </header>
            
            <article>
                
<p>Open your project that we generated previously and follow these steps:</p>
<ol>
<li>Go to the <span class="packt_screen">test</span> | <span class="packt_screen">kotlin</span> | <span class="packt_screen">com.packtpub.sunnat629.testing_application</span>, as in this screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e8a5f4af-5037-4b0e-bddc-ee636f5bea7a.png" style="width:24.00em;height:15.92em;"/></p>
<ol start="2">
<li>Now create a class named <kbd>JUnitTestClass.kt</kbd> where we will create some test cases using the annotations. Here is the sample code:</li>
</ol>
<pre>class JUnitTestClass {<br/><br/>    companion object {<br/>        @BeforeClass<br/>        @JvmStatic<br/>        fun runBeforeClass(){<br/>            println("============ @BeforeClass ============\n")<br/>        }<br/><br/>        @AfterClass<br/>        @JvmStatic<br/>        fun runAfterClass(){<br/>            println("============ @AfterClass ============")<br/>        }<br/>    }<br/><br/>    @Before<br/>    fun runBefore(){<br/>        println("============ @Before ============")<br/>    }<br/><br/>    @After<br/>    fun runAfter(){<br/>        println("============ @After ============\n")<br/>    }<br/><br/>    @Test<br/>    fun runTest1(){<br/>        println("============ @TEST One ============")<br/>    }<br/><br/>    @Test<br/>    fun runTest2(){<br/>        println("============ @TEST Two ============")<br/>    }<br/>}</pre>
<p>You can see that we have written the <kbd>@BeforeClass</kbd> and <kbd>@AfterClass</kbd> annotated function in the <kbd>companion object {}</kbd>, which means these functions are static. In Kotlin, you have to write the static variables and functions in the <kbd>companion object {}</kbd>.</p>
<p>We have used the <kbd>@JvmStatic</kbd> annotation. This is especially used in Kotlin to specify that this function is static and needs to be generated in the element of this function.</p>
<ol start="3">
<li>Now run this test by clicking the <span class="packt_screen">Run Test</span> icon beside the function name, as in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b7e204dd-d59f-4bf6-9c6f-adf2eae5a0ee.png" style="width:31.75em;height:21.33em;"/></p>
<p>After running the test on all the test cases, it will show the results; namely, pass or fail. Here is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7ee2aa2c-2ecd-4cc8-95ab-d5b7bb8dc177.png" style="width:54.08em;height:16.25em;"/></p>
<p>Here you can see that we had two test cases named <kbd>runTest1</kbd> and <kbd>runTest2</kbd> that have passed the test. </p>
<ol start="4">
<li>Now modify our <kbd>runTest1</kbd> function and write logic:</li>
</ol>
<pre>@Test<br/>fun runTest1(){<br/>    println("============ @TEST One Start ============")<br/>    assertEquals(6, doSum(3,2))<br/>    println("============ @TEST One End ============")<br/>}<br/><br/>private fun doSum(num1: Int, num2: Int): Int{<br/>        return num1 + num2<br/>    }</pre>
<p>Here, we have done a very simple equation to check the testing function. We have used a method of <kbd>Assert</kbd> class. The <kbd>assertEquals()</kbd> is a method of assert, and mainly checks the equality with the two inputs. Here, for example, we provide <kbd>6</kbd> and (<em>2+3</em>), which is not true and it will show an error.</p>
<p>If the equation is correct, then you will see the test is passed or it will show an error with the expected result. Here is what the result looks like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e7dd4a81-706e-4d43-af97-f6f34fb2af9e.png" style="width:37.42em;height:7.25em;"/></p>
<p>There are a lot of Assert methods. Here are some of them:</p>
<ul>
<li>The <kbd>assertArrayEquals</kbd>: This will return the equality of two array types input</li>
<li>The <kbd>assertEquals</kbd>: This will return the equality of two same types of input such as <kbd>int</kbd>, <kbd>long</kbd>, <kbd>double</kbd>, <kbd>String</kbd>, and so on</li>
<li>The <kbd>assertTrue</kbd>: This will assert that the given condition is <kbd>true</kbd></li>
<li>The <kbd>assertFalse</kbd>: This will assert that the given condition is <kbd>false</kbd></li>
<li>The <kbd>assertNotNull</kbd>: This will assert that the given object is not null</li>
<li>The <kbd>assertNull</kbd>: This will assert that the given object is null</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a test case for a Rest API </h1>
                </header>
            
            <article>
                
<p>Now we will see how to test the database using the JPA and Hibernate of a Spring project. Here are the steps of how to test the database using JPA:</p>
<ol>
<li>Open the social_network project. The link is here: <a href="https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter09/social_network">https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter09/social_network</a>.</li>
<li>Now go to the <span class="packt_screen">test</span> | <span class="packt_screen">kotlin</span> | <span class="packt_screen">com.packtpub.sunnat629.social_network</span> package and create a file named <kbd>ProfileRepositoryTest.kt</kbd> with two annotations named <kbd>@RunWith(SpringRunner::class)</kbd> and <kbd>@DataJpaTest</kbd>.</li>
</ol>
<p>Here is the code of the <kbd>ProfileRepositoryTest.kt</kbd>:</p>
<pre>@RunWith(SpringRunner::class)<br/>@DataJpaTest<br/>class ProfileRepositoryTest {<br/><br/>    @Autowired<br/>    private lateinit var entityManager: TestEntityManager<br/><br/>    @Autowired<br/>    private lateinit var profileRepository: ProfileRepository<br/><br/>    @Test<br/>    fun getUserTesting(){<br/>        val newProfile = getNewProfile()<br/>        val saveProfile = entityManager.merge(newProfile)<br/><br/>        val foundProfile = profileRepository.getOne(saveProfile.id!!)<br/><br/>        assertThat(foundProfile.username)<br/>                .isEqualTo(saveProfile.username)<br/>    }<br/><br/>    private fun getNewProfile(): Profile {<br/>        return Profile( "naruto",<br/>                "12345",<br/>                "naruto123@gmail.com",<br/>                "Naruto",<br/>                "Uzumak")<br/>    }<br/>  }</pre>
<p>The following is an explanation of the preceding code:</p>
<ul>
<li>The <kbd>@RunWith(SpringRunner::class)</kbd> is the annotation in the connector between the Spring and JUnit. It uses the Spring's testing support to run JUnit.</li>
<li>The <kbd>@DataJpaTest</kbd> enables the JPA testing features.</li>
<li>We autowired the TestEntityManager, which is mainly designed for JPA testing and JPA EntityManager's alternative.</li>
<li>The <kbd>getUserTesting()</kbd>, which has the <kbd>@Test</kbd> annotation and is the main testing function.</li>
</ul>
<p>Now, we will insert a demo <kbd>Profile</kbd> object and check if the insertion is working or not. To begin with, we have to create a Profile object using the <kbd>getNewProfile()</kbd> function.</p>
<p>After this we save this profile as a new variable, such as this:</p>
<pre>val saveProfile = entityManager.merge(newProfile)</pre>
<p>Here, we used the <kbd>entityManager.merge()</kbd>, which will insert the profile in the database.</p>
<p>We also autowired the <kbd>profileRepository</kbd> now use this line to fetch the inserted profile by the ID:</p>
<pre>val foundProfile = profileRepository.getOne(saveProfile.id!!)</pre>
<p>Now we have used the <kbd>assertThat()</kbd> to check the given logic is correct or not. In this function, we have checked the created profile and the fetched profile:</p>
<pre> assertThat(foundProfile.username).isEqualTo(saveProfile.username)</pre>
<p>Now, if there are any errors regarding insertion or communication with the database, it will return an error.</p>
<p>Here is the output of our test:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e02ffe30-dff8-4fc9-a22e-b8bdb0977567.png" style="width:42.08em;height:13.00em;"/></p>
<p>If you provide something as a false value, or the test encounters an error, it will output the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fb440c59-99f4-4255-8f6a-19da81ca5a58.png" style="width:50.92em;height:10.42em;"/></p>
<p>We have entered a profile name as <kbd>naruto</kbd>, but we tested the name <kbd>Uzumak</kbd>, which is why it didn't match. The result subsequently failed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">UI testing on Android</h1>
                </header>
            
            <article>
                
<p>Nowadays, people are more dependent on mobile than desktop. If we consider Android, millions of applications are on the Play Store and other app stores. So, it is very important to test the UI to make a UI bug free and stable product in the app store. You need to be very careful during testing as there are myriad devices with various display sizes. For the backend, you can test with the JUnit and the system is same. But now our test will be UI-based and so we will use Espresso. This is the most popular framework for UI testing. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Espresso</h1>
                </header>
            
            <article>
                
<p>Espresso is an open source framework and an instrumentation-based API, designed by Google. It is good practice to create some test cases of various scenarios of the project. It helps to find out the unexpected results or bugs of the UI, as well as the use case. It automatically syncs the actions of the test with the UI of the application. It allows you to test on both real devices and emulators. But there is a disadvantage of the use in a real device due to its high price to test various size of displays and manufacturers. So an emulator is the best solution to reduce the cost and time for testing. According to the Espresso testers, almost 99% of bugs on an Android application can be detected by this framework. The APIs of Espresso are very small, predictable, and easy to learn. You can also customize these APIs if you want. </p>
<p>Let's create a project and test it with Espresso.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an application</h1>
                </header>
            
            <article>
                
<p>Let's create a simple Android app as a client that will retrieve the REST API using the GitHub API:</p>
<ol>
<li>First of all, we need to create an app from Android Studio and put down your project and the company domain. Don't forget to check <span class="packt_screen">Include Kotlin support</span>. The following screenshot shows the <span class="packt_screen">Create Android Project</span> window:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ab3e546a-93a9-4d6d-a0f5-b5e02688e207.png" style="width:60.58em;height:44.00em;"/></p>
<ol start="2">
<li>Then select the <span class="packt_screen">minimum API version</span> from the <span class="packt_screen">Phone and Tablet</span> option. There is no need to add other options for this project. After clicking <span class="packt_screen">Next</span>, in the <strong>add an Activity to mobile</strong> field, you can select <span class="packt_screen">Empty Activity </span>and then, after renaming the activity name and layout, click <span class="packt_screen">Finish</span>. After the build, you will be ready to start creating an Android app.</li>
</ol>
<p>After creating the project, we need to implement the dependencies to test.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Injecting dependencies</h1>
                </header>
            
            <article>
                
<p>This project is mainly to test UI the application and so we need to implement Espresso. Write down the given lines to implement Espresso in the <kbd>dependencies{}</kbd> block of <kbd>build.gradle</kbd> (Module—app):</p>
<pre>testImplementation 'junit:junit:4.12'<br/>androidTestImplementation 'com.android.support.test:runner:1.0.2'<br/><br/>// Espresso UI Testing dependencies.<br/>androidTestImplementation "com.android.support.test.espresso:espresso-core:3.0.2"<br/>androidTestImplementation "com.android.support.test.espresso:espresso-contrib:3.0.2"<br/>androidTestImplementation "com.android.support.test.espresso:espresso-intents:3.0.2"</pre>
<p>Then in the same file, add the code to implement the JUnit3 and JUnit4 tests against an Android package in the <kbd>android{}</kbd> block:</p>
<pre>testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"</pre>
<p><kbd>AndroidJUnitRunn<span>er</span></kbd> <span>i</span><span>s the instrumentation runner. It mainly controls the test APK, the environment, and all of the test launches. </span></p>
<p>Now sync the project to download and add the dependencies to the project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modifying the application</h1>
                </header>
            
            <article>
                
<p>We have learned how to create an app based on <kbd>RecyclerView</kbd> in <a href="7f273ca8-ce1d-4577-b24c-26d0957f1c74.xhtml">Chapter 9</a>, <em>Creating an Application</em>, so we can just run through the concept of this app. We have a user data class with the ID and username. We will insert 100 users in the database and show in a custom <kbd>RecyclerView</kbd>. We also use a <kbd>UserItemAdapter</kbd> to customize the <kbd>RecyclerView</kbd>.</p>
<p>Clone this project if you want: <a href="https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter10/TestingWithEspresso">https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter10/TestingWithEspresso</a>.</p>
<p>In this project, you find the <kbd>MainActivity.kt</kbd> where you can find a list view. Here is a piece of code from this class:</p>
<pre>----<br/>----<br/> userLists.adapter = UserItemAdapter(this, userList)<br/>----<br/>----</pre>
<p>Here, the <kbd>userLists</kbd> is the RecyclerView and we have the <kbd>UserItemAdapter</kbd> custom adapter of a <kbd>UserModel</kbd>. Here, the <kbd>UserModel</kbd> code is where we take the ID and name of a user:</p>
<pre>data class User(var userID: Int, var username: String)</pre>
<p>Now, we will test this list view using Espresso with some major functions that are frequently used in our projects. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating testing files</h1>
                </header>
            
            <article>
                
<p>Let's write some test cases. To write this code, we need to create new files in the <span class="packt_screen">androidTest</span> package. To do this, follow the steps:</p>
<ol>
<li>Now go to <span class="packt_screen">src</span> | <span class="packt_screen">androidTest</span> | <span class="packt_screen">java</span> | <kbd>module_name</kbd> of the project. Here is a screenshot of this directory:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4197e394-9bc9-4bfb-9484-24e771e8a1aa.png" style="width:18.58em;height:9.50em;"/></p>
<ol start="2">
<li>Create a class named <kbd>MainActivityTest.kt</kbd> with <kbd>@RunWith(AndroidJUnit4::class)</kbd> annotation. This annotation will link the test and the app features.</li>
</ol>
<p>Let's create our very first Espresso test:</p>
<p>First of all, we need to connect our <kbd>MainActivity</kbd> class. To do this, we will initialize a variable of <kbd>ActivityTestRule&lt;MainActivity&gt;</kbd> and it will provide all the functionalities for the <kbd>MainActivity</kbd>. It has an annotation of <kbd>@Rule</kbd>, which means testing for a single activity and here it is <kbd>MainActivity</kbd>.</p>
<p>This <kbd>getCountUser()</kbd> function is for checking the number of your list:</p>
<pre>// User count Matching<br/>@Test<br/>fun getCountUser(){<br/>    onView(withId(R.id.userLists))<br/>        .check(matches(itemCount(20)))<br/>}</pre>
<p>In the previous code, we do the following:</p>
<ul>
<li><kbd>ViewMatchers.onView()</kbd> means it will take a matcher logic.</li>
<li> <kbd>ViewMatchers.withId()</kbd> uses to connect the component of your activity's layout. In our <kbd>main_activity.xml</kbd>, the ID name of the <kbd>RecyclerView</kbd> is <kbd>userLists</kbd>, so we connect it here.</li>
<li><kbd>check(..)</kbd> will return a Boolean. </li>
<li>The <kbd>matches(itemCount(20)</kbd> means it will match the given number with your user list number.</li>
</ul>
<p>We need to create the <kbd>itemCount()</kbd> manually. To do this, create a class named <kbd>CustomUserMatchers.kt</kbd>. Here, is the code of this class:</p>
<pre>class CustomUserMatchers {<br/>    companion object {<br/>        fun itemCount(count: Int): Matcher&lt;View&gt;{<br/>            return object : BoundedMatcher&lt;View, RecyclerView&gt;(RecyclerView::class.java){<br/>                override fun describeTo(description: Description?) {<br/>                    description!!.appendText("Total User = $count")<br/>                }<br/><br/>                override fun matchesSafely(item: RecyclerView?): Boolean {<br/>                    return item?.adapter?.itemCount == count<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p>Here, we create a <kbd>CustomUserMatchers.kt</kbd> class where we create a static function and return a <kbd>Matcher&lt;View&gt;</kbd>.</p>
<p><kbd>BoundedMatcher&lt;View, RecyclerView&gt;(RecyclerView::class.java)</kbd> have two functions named <kbd>describeTo(description: Description?)</kbd> and <kbd>matchesSafely(item: RecyclerView?)</kbd> and we have overriden these classes. </p>
<p>In the <kbd>matchesSafely</kbd>, we will check the equality of the list number with the given number.</p>
<p>In our output list, we have <kbd>100</kbd> users but here the given number is <kbd>20</kbd>. So when you run the test, it will fail, as in this screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9d6919af-7300-40b2-8172-497f75c3a35b.png"/></p>
<p>If you provide <kbd>100</kbd> and run then you can see that the test is passed, as in this screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><kbd><img src="assets/34ea9ddd-d353-4a8c-8d6c-67af3492cc9a.png"/></kbd></p>
<p>Now create a test case named <kbd>getUserPosition()</kbd> to get a specific position and click it:</p>
<pre>// User Click with a position number<br/>@Test<br/>fun getUserPosition(){<br/>    onView(withId(R.id.userLists))<br/>        .perform(actionOnItemAtPosition<br/>        &lt;RecyclerView.ViewHolder&gt;(34, click()))<br/>}</pre>
<p>The <kbd>actionOnItemAtPosition&lt;RecyclerView.ViewHolder&gt;</kbd> is to select a position of the <kbd>RecyclerView</kbd> list using the <kbd>RecyclerView</kbd>. <kbd>ViewHolder</kbd> and then we use a <kbd>click()</kbd> of row 34 of the list. That means this test will go to your given position and then it will click that item. You can see in the following screenshot that it has clicked and showed the Toast that the test case has clicked the row 34 of the list: </p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/79b3d81c-9da2-49ae-b71f-d69e4d2cb1ab.png" style="width:14.92em;height:26.58em;"/></p>
<p>If you look at the logcat, you will also notice that the test has been passed. Here is the output of the logcat of Android Studio:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3fbe8da7-1310-492f-adde-758ed53e12a4.png" style="width:46.92em;height:10.42em;"/></p>
<ul>
<li>Create a <kbd>getIsDisplayed()</kbd> function to test whether the given list is displaying or not.</li>
<li>The <kbd>withId(R.id.userLists)</kbd> will get the listview of the <kbd>MainActivity</kbd>.</li>
</ul>
<ul>
<li>The <kbd>check(matches(isDisplayed()))</kbd> checks whether the list is displaying in the device or not: </li>
</ul>
<pre>// User list display test<br/>@Test<br/>fun getIsDisplayed(){<br/>    onView(withId(R.id.userLists))<br/>        .check(matches(isDisplayed()))<br/>}</pre>
<p>Create a <kbd>getIsClickable()</kbd> function to test whether the given list is displaying or not. The <kbd>withId(R.id.userRoot)</kbd> will get the <kbd>ConstraintLayout</kbd> and <kbd>check(matches(isClickable()))</kbd> will match layout's clickability status of the list:</p>
<pre>// User list display test<br/>@Test<br/>fun getIsClickable(){<br/>    onView(withId(R.id.userRoot))<br/>        .check(matches(isClickable()))<br/>}</pre>
<p class="mce-root">Create a <kbd>getScrollToBottom()</kbd> function to check how to scroll to the specific position. The <kbd>withId(R.id.userLists)</kbd> will get the list view and <kbd>perform(scrollToPosition&lt;RecyclerView.ViewHolder&gt;(activityTestRule.activity.userLists.adapter!!.itemCount - 1))</kbd> will scroll to the bottom of the list. Using this test case, you can see whether the list is smooth or not:</p>
<pre>// User list scroll to bottom<br/>@Test<br/>fun getScrollToBottom(){<br/>    onView(withId(R.id.userLists))<br/>        .perform(scrollToPosition&lt;RecyclerView.ViewHolder&gt;(activityTestRule.activity.userLists.adapter!!.itemCount - 1))<br/>}</pre>
<p>There are even more functions of Espresso. You can check this cheat sheet (<a href="https://developer.android.com/training/testing/espresso/cheat-sheet">https://developer.android.com/training/testing/espresso/cheat-sheet</a>), which is provided by Google. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Testing is always a good way to discover errors in the UI, backend code, or logic. It helps to understand the reason for crashes. Here, we have learned about two powerful frameworks. One is JUnit and another is Espresso. In this chapter, we have seen how to add the dependencies for testing. We have learned how to implement the JUnit into a project. We saw how to use the logic in our test case and how to check to see the pass or fail result of a test case. Additionally, we have seen how to connect the database for testing. Then, we saw how to insert a demo object into a database, and subsequently, fetch it from the database, after which we have matched the object.</p>
<p>In Android testing, we have used the Espresso framework to test the UI. Finally, we have seen some uses of the Espresso APIs and how to handle and connect them with a specific activity. This chapter gave you a brief idea of testing so that you can use test cases to perfect your project. If you want to learn more, please see our reference book under the <em>Further reading</em> section.</p>
<p>If you are reading this paragraph, that means you have finished this book and are ready to build a server-based and client-based projects alone. Now you are a one-man army, able to create a server and mobile application with security, databases, and testing. I hope you enjoyed reading this book and that it will be a reference point in your upcoming projects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What types of code does JUnit support?</li>
<li>Who designed Espresso?</li>
<li>In which platform, JUnit uses?</li>
<li>Why is the Espresso used in the Andriod application?</li>
<li>What is the Android testing strategy?</li>
<li>What is the standard ratio of testing?</li>
<li>How do you test different screen sizes on devices?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li><em>Android Application Testing Guide</em> (<a href="https://www.packtpub.com/application-development/android-application-testing-guide">https://www.packtpub.com/application-development/android-application-testing-guide</a>) by Diego Torres Milano</li>
<li><em>Learning Android Application Testing</em> (<a href="https://www.packtpub.com/application-development/learning-android-application-testing">https://www.packtpub.com/application-development/learning-android-application-testing</a>) by Paul Blundell, Diego Torres Milano</li>
<li><em>Spring Framework Master Class - Beginner to Expert [Video]</em> (<a href="https://www.packtpub.com/application-development/spring-framework-master-class-beginner-expert-video">https://www.packtpub.com/application-development/spring-framework-master-class-beginner-expert-video</a>) by Ranga Karanam</li>
</ul>


            </article>

            
        </section>
    </body></html>