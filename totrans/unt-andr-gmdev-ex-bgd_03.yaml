- en: Chapter 3. The Backbone of Any Game – Meshes, Materials, and Animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*In the previous chapter we learned about the GUI. We started by creating a
    simple Tic-tac-toe game to learn about the basic pieces. This was followed by
    styling the GUI to change the look of the game. Finally, we adjusted the game
    so it would expand automatically to fit a screen of any size.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*This chapter is about the core of any game: meshes, materials, and animations.
    Without these blocks there is generally nothing to show players. You could, of
    course, just use flat images in the GUI. But, where is the fun in that? If you
    are going to choose a 3D game engine, you might as well make full use of its capabilities.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*To understand meshes, materials, and animations, we will be creating a Tank
    Battle game. This project will be used in a few other chapters. By the end of
    the book, it will be one of the two robust games we will create. For this chapter,
    the player will get to drive a tank around a small city, he/she will be able to
    shoot at animated targets, and we will add a counter to track the scores.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Importing the meshes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the materials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the prefabs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ray tracing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be starting a new project for this chapter, so follow along in the first
    section to get it started.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though this project will eventually grow to become much larger than the previous
    ones, the actual setup is similar and not overly complex. You will also need a
    number of starting assets for this project; they will be described during the
    setup process. Due to the complexity and specific nature of these assets, it is
    recommended to use the ones provided for now.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – the setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have done in the previous two chapters, we will need to create a new project
    so that we can create our next game. Obviously, the first thing to do is to start
    a new Unity project. For organizational purposes, name it `Ch3_TankBattle_CS`.
  prefs: []
  type: TYPE_NORMAL
- en: This project will also grow to become much larger than our previous projects,
    so we should create some folders to keep things organized. For starters, create
    six folders. The top level folders will be the `Models`, `Scripts`, and `Prefabs`
    folders. Inside `Models`, create `Environment`, `Tanks`, and `Targets`. Having
    these folders makes the project significantly more manageable. Any complete model
    can consist of a mesh file, one or more textures, a material for every texture,
    and potentially dozens of animation files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we go too far, it is a good idea to change your target platform to Android,
    if you haven't already done so. Every time the target platform is changed, all
    of the assets in the project need to be re-imported. This is an automatic step
    carried out by Unity, but will take an increasing amount of time as your project
    grows. By setting our target platform before there is anything in the project,
    we save loads of time later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will also make use of a very powerful part of Unity. Prefabs are special
    objects that make the process of creating a game significantly easier. The name
    means prefabricated—created beforehand and replicated. What this means for us
    is, we can completely set up a target for our tank to shoot at and turn it into
    a prefab. Then, we can place instances of that prefab throughout the game world.
    If we ever need to make a change to the targets, all we need to do is modify the
    original prefab. Any change made to a prefab is also made on any instance of that
    prefab. Don't worry; it makes more sense when used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will also need to create some meshes and textures for this project. To start
    with, we will need a tank. It is kind of hard to have a battle of tanks without
    any tanks. The tank that is provided has a turret and cannon, which are separate
    pieces. We will also use a trick to make the tank's treads look like they are
    moving, so that each of them are separate pieces and also use a separate texture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the location of our battle, a portion of a city was created. Instead of
    applying a specific texture to the city, some tile-able textures will be used.
    Also, there is a wall around the city to keep the player from falling out of the
    world.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we will need an animated target. The one that is provided is rigged
    up like the human arm, with a bull's eye for the hand. It has four animations.
    The first starts in a curled position and goes to an extended position. The second
    is the reverse of the first one, going from the extended position to the curled
    position. The third starts in the extended position and is flung back, as if hit
    in the front, and returns to the curled position. The last is just like the third
    one, but it goes forward as if hit from behind. These are fairly simple animations,
    but they will serve us well in learning about Unity's animation system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Very little happened here, we simply created the project and added some folders.
    There was also a little discussion about the assets we would be using for this
    chapter's project.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the meshes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several ways to import assets to Unity. We will be going over perhaps
    the simplest and certainly the best ways for groups of assets.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – importing the tank
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the Unity Editor, start by right-clicking on your `Tanks` folder and
    selecting **Show in Explorer** from the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This opens the folder that contains the asset that was selected. In this case,
    the `Models` folder is opened in the Windows folder browser. We just need to put
    our tank and its textures into the `Tanks` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The files provided for this chapter are `Tank.blend`, `Tanks_Type01.png`, and
    `TankTread.png` files. Also, utilizing `.blend` files in Unity requires Blender
    to be installed on your system. Blender is a free modeling program available at
    [http://www.blender.org](http://www.blender.org). Unity makes use of it in order
    to convert the previously mentioned files into ones that it can fully utilize.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When we return to Unity, the fact that we added files will be detected and they
    will be automatically imported. This is one of the best things about Unity. There
    is no need to explicitly tell Unity to import. If there are changes within the
    project's assets, it just does so.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You might also notice that an extra folder and some files were created when
    Unity imported our tank. Whenever a new mesh is imported, by default Unity will
    try to pair it with the materials. We will go into more detail about what a material
    is in Unity in the next section. For now, it is an object that keeps track of
    how to display a texture on a mesh. Based on the information in the mesh, Unity
    looks in the project for a material with the correct name. If one cannot be found,
    a `Materials` folder is created next to the mesh and the missing materials are
    created inside it. When creating these materials, Unity also searches for the
    right textures. This is why it is important to add textures to the folder at the
    same time as the mesh, so that they all can be imported together. If you did not
    add the textures at the same time as the tank, the section about creating materials
    will describe how to add textures to materials.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just imported our tank into Unity. It is really quite simple. Changes made
    to any of the assets or folders of the project are automatically detected by Unity,
    and anything that needs to be is suitably imported.
  prefs: []
  type: TYPE_NORMAL
- en: Tank import settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When importing any asset into Unity, it is done by using a default group of
    settings. Any of these settings can be changed from the **Inspector** window.
    With your new tank selected, we will go over the import settings for a model here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Tank import settings](img/2014OT_03_01.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The top of the Unity Editor has three tabs: **Model**, **Rig**, and **Animations**.
    The **Model** page handles the mesh itself, while **Rig** and **Animations** are
    for importing animations. For now, we only care about the **Model** page, so select
    it if it is not already selected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Meshes** section of the **Import Settings** window starts with the **Scale
    Factor** attribute. This is a value that tells Unity how big the mesh is by default.
    One generic unit or one meter from your modeling program translates to one unit
    in Unity. This tank was made in generic units, so the tank's scale factor is one.
    If you were working in centimeters when making the tank, the scale factor would
    be 0.01, because a centimeter is a hundredth of a meter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next option, **Mesh Compression**, will become important in the final chapter
    when we go over the optimization of our games. The higher the compression is set,
    the smaller the file is in the game. However, this will start to introduce weirdness
    to your mesh as Unity works to make it smaller. For now, leave it **Off**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Read/Write Enabled** is useful if you want to make changes to the mesh while
    the game is playing. This could allow you to do some really cool things such as
    destructible environments where your scripts break the meshes into pieces based
    on where they are being shot at. However, it also means that Unity has to keep
    a copy of the mesh in memory, which could really start to lag a system if it is
    complex. This is outside the scope of this book, so unchecking the option is a
    good idea.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimize Mesh** is a good one to leave on, unless you are doing something
    specific and fancy with the mesh. With it on, Unity does some special magic behind
    the scenes. In computer graphics and especially Unity, every mesh is ultimately
    a series of triangles being drawn on screen. This option allows Unity to reorder
    the triangles in the file so that the whole mesh will be drawn faster and more
    easily.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next option, **Generate Colliders**, is a useful one if doing complex things
    with **Physics**. Unity has a set of simple collider shapes that should be used
    whenever possible, because they are easier to process. However, there are situations
    where they won't quite get the job done, for example, rubble or a half-pipe where
    the collision shape is too complex to be made with a series of simple shapes.
    That is why Unity has a **Mesh Collider** component. With this option checked,
    a **Mesh Collider** component is added to every mesh in our model. We will be
    sticking with simple colliders in this chapter, so leave the **Generate Colliders**
    option off.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Swap UVs** and **Generate Lightmap UVs** are primarily used when working
    with lighting, especially lightmaps. Unity can handle two sets of UV coordinates
    on a model. Normally, the first is used for the texture and the second for the
    lightmap or shadow texture. If they are in the wrong order, **Swap UVs** will
    change them, so that the second set now comes first. If you need an unwrap for
    a lightmap, but did not create one, **Generate Lightmap UVs** will create one
    for you. We are not working with lightmaps in this project, so both of these can
    remain off.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next section of options, **Normals & Tangents**, begins with the **Normals**
    option. This defines how Unity will get a hold of the normals of your mesh. By
    default, they are imported from the file; but there is also the option to make
    Unity calculate them based on the way the mesh is defined. Or, if we set this
    option to **None**, Unity will not import the normals. **Normals** are needed
    if we want our mesh to be affected by real-time lighting or make use of normal
    maps. We will be making use of real-time lighting in this project, so leave it
    set to **Import**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tangents**, **Smoothing Angle**, and **Split Tangents** are used if your
    mesh has a normal map. Tangents are needed to determine how lighting interacts
    with a normal-mapped surface. By default, Unity will calculate these for you.
    Importing tangents is only possible from a few file types. The smoothing angle
    dictates whether shading across an edge would be smooth or sharp, based on the
    angle between the two faces. The **Split Tangents** option is there to handle
    a few specific lighting quirks. If lighting is broken by seams, enabling this
    option will fix it. Normal maps are great for making a low-resolution game look
    like a high-resolution one. However, because of all the extra files and information
    needed to use them, they are not ideal for a mobile game. Therefore, we will not
    be using them in this book and all of these options can be turned off to save
    memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last section, **Materials**, defines how Unity should look for materials.
    The first option, **Import Materials**, is to decide whether or not a material
    should be imported. If it is turned off, a default white material will be applied.
    This material will not show up anywhere in your project; it is a hidden default.
    For models that will not have any textures, such as collision meshes, this could
    be turned off. For our tank and nearly every other case, this should be left on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last two options, **Material Naming** and **Material Search**, work together
    to name and find the materials for the mesh. Directly below them, there is a text
    box that describes how Unity will go about searching for the material. The name
    of the material being searched for can be the name of the texture used in the
    modeling program, the name of the material created in the modeling program, or
    the name of the model plus the material. If a texture name cannot be found, the
    material name will be used instead. By default, Unity does a **Recursive-Up**
    search. This means that we start by looking in the `Materials` folder, followed
    by any materials that are in the same folder. We then check the parent folder
    for matching materials, followed by the folder above that. This continues until
    we either find the material that has the correct name or we reach the root assets
    folder. Alternatively we have the options of checking the entire project by only
    looking in the `Materials` folder that is next to our model. The defaults for
    these options are just fine. In general, they do not need to be changed. They
    are most easily changed with the Unity Editor scripting, which will not be covered
    in this book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we have a pair of buttons: **Revert** and **Apply**. Whenever changes
    are made to the import settings, one of these two buttons must be chosen. The
    **Revert** button cancels the changes and switches the import settings back to
    what they were before changes were made. **Apply** confirms the changes and re-imports
    the model with the new settings. If these buttons are not selected, Unity will
    complain with a pop up and force a choice before letting you mess with anything
    else.![Tank import settings](img/2014OT_03_02.png.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we have two types of previews. The **Imported Object** section is a
    preview of what the object will look like in the **Inspector** window, if added
    to the **Scene** view and selected. The **Preview** window is what the model will
    look like in the **Scene** view. You can click-and-drag in this window to rotate
    the object and look at it from different angles. Also, there is a little blue
    button in this window. By clicking on this button, you will be able to add labels
    to the object. Then, these labels are also searchable in the **Project** window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the tank
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have the tank imported, we need to set it up. We will be adjusting
    the arrangement of the tank as well as creating a few scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the tank
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, the creation of our tank will primarily consist of the creation
    and arrangement of the tank's components.
  prefs: []
  type: TYPE_NORMAL
- en: Start by dragging the tank from the **Project** window to the **Hierarchy**
    window. You will notice that the name of the tank appears in blue color in the
    **Hierarchy** window. This is because it is a prefab instance. Any model in your
    project largely acts like a prefab. But, we want our tank to do more than just
    sit there. So, being a prefab of a static mesh is not helpful. Therefore, select
    your tank in the **Hierarchy** window and we will start making it useful by removing
    the `Animator` component. To do this, select the gear to the right of the `Animator`
    component in the **Inspector** window. From the new drop-down list, select **Remove
    Component** and it will be removed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are using the tank provided by default, selecting the different parts
    of it will reveal that all the pivot points are at the base. This will not be
    useful for making our turret and cannon pivot properly. The easiest way to solve
    this is by adding new empty `GameObject` to act as pivot points.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Any object in the scene is a `GameObject`. Any empty `GameObject` is one that
    only has a **Transform** component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At the top of the Unity Editor, **Create Empty** is the first option under the
    **GameObject** button. It creates the objects we need. Create two empty `GameObjects`,
    and position one at the base of the turret and the other at the base of the cannon.
    Also, rename them to `TurretPivot` and `CannonPivot` respectively. This can be
    done with the textbox at the very top of the **Inspector** window, if the object
    is selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy** window, drag `TurretPivot` onto `Tank`. This changes the
    parent of `TurretPivot` to `Tank`. Then, drag the object, that is, the turret
    mesh, onto `TurretPivot`. In code, we will be rotating the pivot point, not the
    mesh directly. When a parent object moves or rotates, all of the children objects
    move with it. When you make this change, Unity will complain about the change
    to the original hierarchy of the object; just checking to make sure it is a change
    you want to do and not an accident.![Time for action – creating the tank](img/2014OT_03_03.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because losing that connection to the prefab can potentially break a game, Unity
    just wants to be sure that we actually want it to happen. So, click on **Continue**
    and we can finish working with the tank without other complaints from Unity. We
    also need to make `CannonPivot` a child of `TurretPivot`, and the cannon a child
    of `CannonPivot`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To finish off our hierarchy changes, we need to place the camera. Because we
    want it to appear as if the player is actually in the tank, the camera should
    be placed behind and above the tank with a tilt slightly downward to focus on
    a spot a few tank lengths ahead. Once positioned, make it a child of `TurretPivot`
    as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We set up the basic structure that our tank will use. By making use of multiple
    objects in this way, we can control their movements and actions independently
    from each other. At this point, instead of having a rigid tank that only points
    forward, we can tilt, rotate, and aim each piece independently.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Also, the tank should be centered above the point that you want the whole thing
    to pivot around. If yours is not, you can select everything that is under the
    base tank object in the **Hierarchy** window and move it around.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – keeping score
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A short script for keeping track of the player's score will constitute the focus
    of this short section.
  prefs: []
  type: TYPE_NORMAL
- en: To make this tank work, we are going to need three scripts. The first is fairly
    simple. Create a new script and name it `ScoreCounter`. It will, as the name implies,
    track the score. Create it in the `Scripts` folder and clear out the default functions,
    just like every other script we have made so far.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following line of code to the new script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For the most part, this should look familiar from the previous chapter. First
    we define an integer counter. Because it is static, other scripts (such as the
    ones we will create for the targets) will be able to modify this number and give
    us the score.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We follow with an `OnGUI` function that defines a `Rect` class and displays
    the score using the `GUI.Box` function. A Box is just like a Label, but it has
    a black background by default. This will make it easier to see as we move around.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just created a very simple script. It will track our score throughout the
    game. Also, instead of doing any of the score incrementation itself, other scripts
    will update the counter to give points to the player.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – controlling the chassis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A normal tank rotates in place, and it can easily move forward and back. We
    will make our tank do this with the creation of a single script.
  prefs: []
  type: TYPE_NORMAL
- en: The second script is called `ChassisControls`. It will make our tank move around.
    Create it in the `Scripts` folder as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first three lines of the script define the variables the tank will need
    to move around. We will also be able to change them in the **Inspector** window,
    in case our tank is too fast or too slow. The first line defines a variable that
    holds a connection to a `CharacterController` component. This component will easily
    move the tank around, but will allow it to be stopped by walls and other colliders.
    The next two lines of code define how fast we move and rotate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's add our good friend `OnGUI` to the mix. This should look mostly familiar.
    We are creating four buttons that will sit in the bottom-left corner of the screen.
    When the first two buttons are pressed, we make a call to a function that will
    move our tank and give it a value for how fast it can move. A positive value is
    going to move us forward and a negative value will move us backward. The last
    two buttons do the same thing, except with rotation instead of movement. A positive
    value will rotate to the right and a negative value will rotate the tank to the
    left. These buttons are also `RepeatButtons`. A normal button will only activate
    once for each time it is pressed. A repeat button is active as long as it is held
    down. The good side of this is that it will allow our tank to move every frame
    the button is held down. The down side is a quirk in how the `RepeatButton` and
    `OnGUI` functions work. If one of these buttons is active, nothing will be drawn
    after that button in the `OnGUI` function. It is a bit annoying, but suits our
    needs for now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Only two functions left to go. We start the following line of code by defining
    our `MoveTank` function. It needs to be passed with a speed value to dictate how
    far and in which direction to go. It was mentioned a moment ago; a positive value
    will go forward and a negative value will go backwards.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order to move in three-dimensional spaces, we need a vector—a value with
    both direction and magnitude. Therefore, we define a movement vector and set it
    to the tank''s forward direction, multiplied by the tank''s speed, and again multiplied
    by the amount of time since the last frame. If you remember from the geometry
    class, 3D space has three directions: x, y, and z. In Unity, the following convention
    applies: x is to the right, y is up, and z is forward. The **Transform** component
    holds an object''s position, rotation, and scale. We can access the **Transform**
    component of any object in Unity by calling upon the `.transform` value that Unity
    provides. The **Transform** component also provides a forward value that will
    give us a vector that points forward relative to the object. Also, we want to
    move at a regular pace, for example, a certain number of meters per second, hence
    we make use of `Time.deltaTime`. This is a value provided by Unity that holds
    how many seconds it has been since the last frame of the game was drawn on screen.
    Think of it like a flip book. In order to make it look like a guy is walking across
    the page, he needs to move slightly on each page. In the case of a game, the pages
    are not flipped regularly. So, we have to modify our movement by how long it has
    taken to flip to the new page. This helps us to maintain an even pace.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we want to stay on the ground. In general, any character you want to
    control in a game does not automatically receive all of the physics that a boulder
    would, such as gravity. For example, when jumping, you temporarily remove gravity
    so the character can go up. That is why the next line of code does a simple implementation
    of gravity by subtracting the normal speed of gravity and again keeps it in pace
    with our frame rate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, for the `MoveTank` function, we actually do the moving. The `CharacterController`
    component has a special `Move` function that will move the character but constrain
    it by collisions. We just need to tell it how far and in which direction we want
    to move this frame by passing the `Move` vector to it. That final curly brace,
    of course, closes off the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `RotateTank` function is the last one. This function also needs a speed
    value to dictate how fast and in which direction to rotate. We start by defining
    another vector; but, instead of defining which direction to move, this one will
    dictate which direction to rotate around. In this case, we will be rotating around
    our up direction. We then multiply that by our speed and `Time.deltaTime` to move
    fast enough and keep pace with our frame rate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last bit of the function actually does the rotation. The **Transform** component
    provides a `Rotate` function. Rotation, especially in 3D space, can become weird
    and difficult very quickly. The `Rotate` function handles all of that for us;
    we just need to supply it with the values to be applied for rotation. Also, don't
    forget the curly brace to close off the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a script to control the movement of our tank. It will draw a group
    of buttons on the screen, so that our tank can move forward and back. This is
    done using a special `Move` function from the `CharacterController` component.
    We also used a special `Rotate` function provided by the **Transform** component
    to rotate our tank using another set of buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – controlling the turret
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This script will allow the player to rotate their turret and aim the cannon.
  prefs: []
  type: TYPE_NORMAL
- en: The last script we need to create for our tank is `TurretControls`. This script
    will allow players to rotate the turret left and right and tilt the cannon up
    and down. As with all of the others, create it in the `Scripts` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first two variables we define will hold pointers to the turret and cannon
    pivots, the empty `GameObjects` that we created for our tank. The second set is
    the speed that our turret and cannon will rotate at. Finally we have some limit
    values. If we didn't limit how much our cannon could rotate, it would just spin
    around and around, passing through our tank. This isn't the most realistic behavior
    for a tank, so we must put some limits on it. The limits are in the range of 300
    because straight ahead is zero degree and down is 90 degree. We want it to be
    the upwards angle, so it is in the range of 300\. We also use 359.9 because Unity
    will change 360 to zero so it can continue to rotate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next step is to create the `OnGUI` function to draw buttons and give the
    player control of the turret. This function is almost identical to the `OnGUI`
    function we made for the `ChassisControls` script. The differences are in the
    fact that the `Rects` class will move to the bottom-right corner of the screen,
    and that we are calling the `RotateCannon` and `RotateTurret` functions. When
    we send a speed to `RotateCannon`, we need a positive value to go up and a negative
    value to go down. `RotateTurret` will largely function like the `RotateTank` function;
    a positive speed will rotate to the right and a negative speed will rotate to
    the left.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next is the `RotateTurret` function. It works exactly in the same way as the
    `RotateTank` function. However, instead of looking at a `CharacterController`
    component 's `Transform` variable, we act upon the `turretPivot` variable that
    was defined at the beginning of the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last function, `RotateCannon`, gets a little more down-and-dirty with rotations.
    The fault completely lies with the need to put limits on the rotation of the cannon.
    After opening the function, the first step is to figure out how much we are going
    to be rotating this frame. We are using a float value instead of a vector because
    we have to set the rotation ourselves.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we define a variable that holds our current rotation. We do this because
    Unity will not let us act on the rotation directly. Unity actually keeps track
    of rotation as a quaternion. This is a complex method of defining rotations that
    is beyond the scope of this book. Luckily, Unity gives us access to an x, y, z
    method of defining rotations called `EulerAngles`. It is a rotation around each
    of the three axes in 3D space. The `localEulerAngles` value of a **Transform**
    component is the rotation relative to the parent `GameObject`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: It is called `EulerAngles` because of *Leonhard Euler*, a Swiss mathematician
    who defined this method of defining rotations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we adjust the rotation and apply the limits in one go through the use
    of the `Mathf.Clamp` function. `Mathf` is a group of useful math functions. The
    `Clamp` function takes a value and makes it no lower and no higher than the other
    two values passed to the function. So, we first send it our x axis rotation, which
    is the result of subtracting `rotate` from the current x rotation of `euler`.
    Because the positive rotation is clockwise around an axis, we have to subtract
    our rotation to go up instead of down with a positive value. Next, we pass our
    lower limit to the `Clamp` function, followed by our higher limit: the `lowCannonLimit`
    and `highCannonLimit` variables that we defined at the top of the script.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we have to actually apply the new rotation to our cannon's pivot point.
    This is simply setting the `localEulerAngles` value of the **Transform** component
    to the new value. And again, be sure to use the curly brace to close off the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a script that will control the turret of the tank. Through the use
    of buttons on the screen, the player is able to tilt the cannon and rotate the
    turret. This script functioned in a very similar manner to the `ChassisControls`
    script we created earlier. The difference came in limiting the amount the cannon
    can tilt.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – putting the pieces together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That was the last of the scripts, for the moment. We have our tank and our scripts;
    the next step is to put them together.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to add them to our tank. Remember how we added our `Tic-tac-toe`
    script to the camera in the last chapter? Start by selecting your tank in the
    **Hierarchy** window. Before they work, we will first need to add the `CharacterController`
    component to our tank. So, go to the top of the Unity Editor and select **Component**,
    then select **Physics**, and finally click on the **Character Controller** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will notice that a green capsule also appears on the tank in the Scene view;
    at the same time the new component is added. This capsule represents the space
    that will collide and interact with other colliders. The values on the CharacterController
    component let us control how it interacts with other colliders. For most cases,
    the defaults for the first four are just fine.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Slope Limit**: This attribute shows us how steep an incline the controller
    can move up.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Step Offset**: This attribute shows us how high a step can be before it starts
    to block movement.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Skin Width**: This defines how far another collider can penetrate this controller''s
    collider before it is completely stopped. This is mostly used for squeezing between
    objects.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Min Move Distance**: This attribute is for limiting jitter. It is the minimum
    amount of movement that has to be applied in a frame before it will actually move.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Center**, **Radius**, and **Height**: These attributes define the size of
    the capsule that you see in the Scene view. They are used for the collision.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action – putting the pieces together](img/2014OT_03_04.png.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: The last three values are what we care about right now. We need to adjust these
    values to match our tank's values as closely as possible. Admittedly the capsule
    is round and our tank is square, but a `CharacterController` component is the
    easiest way to move a character with collision and will be used most often. Use
    values of `2.3` for the **Radius** attribute and the **Y** portion of the **Center**
    attribute; everything else can be left at the default values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is now time to add the scripts to our tank. Do this by selecting the tank
    in the **Hierarchy** window and dragging the `ChassisControls`, `TurretControls`,
    and `ScoreCounter` scripts onto the **Inspector** window. This is just as we did
    it in the previous chapters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before the tank will work, we need to finish creating the connections that we
    started in our scripts. Start by clicking the `CharacterController` component's
    name and dragging it to the **Character Control** value that is on our new `ChassisControls`
    script component. Unity lets us connect object variables in the Unity Editor,
    so that they do not have to be hard coded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also need to connect our turret and cannon pivot points. So, click-and-drag
    the points from the **Hierarchy** window to the corresponding variable on the
    `TurretControls` script component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the scene as `TankBattle` and try it out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just finished putting our tank together. Unless you look at the **Scene**
    view while using the movement controls, it is hard to tell that the tank is moving.
    The turret controls can be seen in the **Game** view, though. Other than not having
    a point of reference for whether or not our tank is moving, it runs pretty well.
    The next step and the next section will give us that reference point as we add
    our city.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – cannon alignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might notice a quick jump when you first try to tilt the cannon. Such behavior
    is annoying and makes the game look broken. Try adjusting the cannon to fix it.
    If you are having trouble with it, take a look at the cannon's starting rotation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the materials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Unity, the materials are the defining factor for how models are drawn on
    the screen. They can be as simple as coloring it all blue, or as complex as reflective
    water with waves. In this section, we will cover the details of the controls for
    a material. We will also create our city and some simple materials to texture
    it with.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the city
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a city gives our tanks and our players a good place to play.
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of this section, no part of the provided city was given a specific
    texture. It was just unwrapped and some tile-able textures were created. So, we
    need to start by importing the city and the textures to the `Environment` folder.
    Do it the same way that we imported the tank.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The files are `TankBattleCity.blend`, `brick_001.png`, `brick_002.png`, `brick_003.png`,
    `dirt_001.png`, `dirt_003.png`, `pebbles_001.png`, `rocks_001.png`, `rubble_001.png`,
    and `water_002.png`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Because the city was unwrapped, Unity still created a single material for it.
    However, textures were never applied in any modeling program. So, the material
    is plain white. We have several extra textures, so we are going to need more than
    that one material for the whole city. Creating a new material is simple; it is
    done just as with creating a new script. Right-click on the `Materials` folder
    inside the `Environment` folder, and select **Create** followed by **Material**,
    which is about halfway down the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will create a new material in the folder and immediately allow us to name
    it. Name the material, `Pebbles`.![Time for action – creating the city](img/2014OT_03_05.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With your new material selected, take a look at the **Inspector** window. When
    we have a material selected, we get the options needed to change its look.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the very top of the **Inspector** window, we have the material's name, followed
    by a **Shader** drop-down list. A shader is essentially a short script that tells
    the graphics card how to draw something on screen. You will use the **Diffuse**
    shader most often, so it is always selected by default. This is where you would
    select from your Bump-mapped shaders, specular, transparent, and a plethora of
    other options. If you were to create some custom shaders, they would also be found
    here.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The next little block will only be visible if Unity has something to warn you
    about. In this case, it is advising us to use a different shader for performance
    reasons. However, that is a discussion for [Chapter 9](ch09.html "Chapter 9. Optimization"),
    *Optimization*, so we will ignore it for now.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we have the **Main Color** value with a colored square next to it. By
    clicking on that square, the **Color Picker** window will open and let us select
    any color we want. This color value changes the tinting on the texture being drawn
    by the material. Because we don't have a texture yet, you will notice that it
    just changes the color of the ball in the **Preview** window.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Base (RGB)** value is under the **Main Color** value. This is the texture.
    The box on the right, with **None (Texture)** and a **Select** button in it, is
    a preview box for the texture being used by this material. To add a texture to
    the material, either drag one to this box from the **Project** window, or click
    on the **Select** button. The button opens a new window that holds the thumbnails
    of every texture that is currently in the project. You can scroll through or use
    the search bar to find the texture that you need and double-click to select it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To the left of the box, we have our **Tiling** and **Offset** controls. The
    **Tiling** values dictate how many times the texture will repeat across the normalized
    UV space in the x and y directions. The **Offset** is how far off zero the texture
    starts in the normalized UV space. You can select the number fields and input
    values to modify them. Doing so, and paying attention to the **Preview** window
    below, you will see how they change the texture. Tiling textures are most commonly
    used for large surfaces where the texture is similar enough across the surface
    that it just repeats.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Our **Preview** window is at the bottom of the **Inspector** window. It functions
    just as the one we saw for our tank mesh. What makes this one special, though,
    is the two buttons in the top-right corner of this window. The one to the left
    scrolls through a set of preview shapes. By clicking on it you'll be able to see
    how the texture looks on a sphere, cube, cylinder, or torus. The other button
    toggles between the two types of lighting.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the `pebbles_001` texture to this material by dragging it from the **Project**
    window and dropping it on the **Base (RGB)** preview box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use values of 30 for the material's **Tiling** and a light tan color for the
    **Main Color** option, so that the texture can be sized right and more pleasing
    to look at.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To see our new material in action, first drag your city to the **Hierarchy**
    window, so that it is added to the **Scene** view. By right-clicking-and-dragging,
    you can look around in your **Scene** view. Look over at the streets of the city.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, drag your new material from the **Project** window into your **Scene**
    view. While dragging the material around, you should see the meshes change to
    appear as if they are using the material. Once you are over the streets, let go
    of your left mouse button. The material is now applied to the mesh.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However, we currently have a whole quarter of a city to texture. So, create
    more materials and use the remaining textures on the rest of the city. Create
    a new material for each extra texture, plus four extra of `brick_002`, so, we
    can have different colors for each building height.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply your new materials to the city, either by comparison with the following
    figure or through your own artistic whim:![Time for action – creating the city](img/2014OT_03_06.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: When trying to get to the center fountain, if your tank is in the way, select
    your tank in the **Hierarchy** window and use the **Gizmo** option in the **Scene**
    view to drag it out of the way.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you were to try to play the game now, you might notice that we have a couple
    of problems. For starters, we only have a quarter of a city; perhaps you have
    more if you made your own city. There is still no collision on the city, so we
    fall right through it when moving. Also, the tank is a little large for this city,
    and it is too dark to see where we are going. Turning on the lights is the quickest
    solution to fix this problem.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: At the top of the Unity Editor, select **GameObject**, followed by **Create
    Other**, and finally **Directional Light**. This creates an object that emits
    light in a single direction. The next chapter explains lights and how to control
    them, so the details will be left for later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Changing the size of our tank is also pretty simple. Select it in the **Hierarchy**
    window and look for the **Scale** label in our **Transform** component. Changing
    the **X**, **Y**, and **Z** values under **Scale** will change the size of our
    tank. Be sure to change them evenly or some weirdness will occur when we start
    rotating the tank. Values of 0.5 make the tank small enough to fit through the
    small streets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next up is collision for the city. For the most part, we will be able to get
    away with simple collision shapes that are faster to process. However, the circular
    center of the city will require something special. Start by double-clicking on
    the walls of one of the square buildings in the **Scene** view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: When dealing with prefabs, which the city still is, clicking on any object that
    makes up the prefab will select the root prefab object. Once a prefab is selected,
    clicking on any part of it will select that individual piece. Because this behavior
    is different from non-prefab objects, you need to be mindful of it when selecting
    objects in the **Scene** view.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With a set of walls selected, go to the top of the Unity Editor and select **Component**,
    followed by **Physics**, and finally **Box Collider**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because we are adding the collider to a specific mesh, Unity does its best to
    automatically fit the collider to the shape. For us, this means that the new `BoxCollider`
    component is already sized to fit the building. Continue by adding `BoxColliders`
    to the rest of the square buildings and the outer wall. Our streets are essentially
    just a plain, so a `BoxCollider` component will work just fine for them as well.
    Though pointed at the top, the obelisk in the center of the fountain is essentially
    just a box; so, another `BoxCollider` will suit it fine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have one last building and the fountain ring to deal with. These are not
    boxes, spheres, or capsules. So, our simple colliders will not work. Select the
    walls of the last building, the one next to the center fountain. A few options
    down from where you were selecting **Box Collider**, there is a **Mesh Collider**
    option. This will add a `MeshCollider` component to our object. This component
    does what its name suggests; it takes a mesh and turns it into a collider. By
    adding it to a specific mesh, the `MeshCollider` component automatically selects
    that mesh to be collideable. You should also add `MeshColliders` to the short
    ledge around the center building and the ring wall around the fountain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last problem to solve is the duplication of our city quarter. Start by selecting
    the root `city` object in your hierarchy, `TankBattleCity`, and remove the `Animator`
    component from it. The city is not going to animate, so it does not need this
    component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, right-click on the city in the **Hierarchy** window and select **Duplicate**.
    This creates a copy of the object that was selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate the city quarter twice more and we will have the four parts of our
    city. The only problem is that they are all in the exact same position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to rotate three of the pieces to make a full city. Select one and set
    the **Y Rotation** value in the **Transform** component to `90`. This will rotate
    it 90 degrees around the vertical axis and give us half of a city.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will complete the city by setting one of the remaining pieces to `180` and
    another to `270`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That leaves one last thing to do. We have four center fountains. In three of
    the four city pieces, select the three meshes that make up the center fountain
    (the `Obelisk`, `Wall`, and `Water`) and click on the *Delete* key on your keyboard.
    Confirm that you want to break the prefab connection each time, and our city will
    be complete.![Time for action – creating the city](img/2014OT_03_07.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Try out the game now. We can drive around the city and rotate our turret. It
    is so much fun. We created materials and textured the city. After making it possible
    to collide with the buildings and road, we duplicated the section so that we could
    have a whole city.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – decorating the city
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have all the skills needed to import meshes and create materials,
    the challenge is to decorate the city. Create some rubble and tank traps and practice
    importing them to Unity and setting them up in the scene. If you really want to
    go above and beyond, try your hand at creating your own city. Choose something
    from the world, or choose something from your imagination. Once it is created,
    we can release the tanks in it.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – moving treads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is just one thing left to do, and then we will be done with materials
    and can go on to make the game even more fun. Remember the **Offset** value of
    the materials? It turns out that we can actually control that with a script. Start
    by opening up the `ChassisControls` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, we need to add a few variables to the beginning of the script. The first
    two will hold references to our tank tread renderers, the part of the mesh object
    that keeps track of the material that is applied to the mesh and actually does
    the drawing. This is just like how the `characterControl` variable holds a reference
    to our `CharacterController` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The second two variables will keep track of the amount of offset applied to
    each tread. We store it here because it is a faster reference than trying to look
    it up from the thread's material each frame.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To make use of the new values, these lines need to be added to the end of the
    `MoveTank` function. The first line here adjusts the offset for the right tread
    as per our speed and keeps in time with our frame rate. The second line utilizes
    the material value of a `Renderer` component to find our tank tread material.
    The `mainTextureOffset` value of the material is the offset of the primary texture
    in the material. In the case of our diffuse materials, it is the only texture.
    Then, we have to set the offset to a new `Vector2` value that will contain our
    new offset value. `Vector2` is just like `Vector3` we used for moving, but works
    in 2D space instead of 3D space. A texture is flat, hence 2D space. The last two
    lines of the code do the same thing as the other two, but for the left tank tread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make the connections to the `Renderer` components of our treads, do the
    same thing that we did for the pivot points: drag the tread meshes from the **Hierarchy**
    window to the corresponding value in the **Inspector** window. Once done, be sure
    to save it and try it out.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We updated our `ChassisControls` script to make the tank treads move. As the
    tank is driven around, the textures pan in the appropriate direction. This is
    the same type of functionality that is used to make waves in water and other textures
    that move.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – turning with the treads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The movement of the material doesn't quite match the speed of the tank. Figure
    out how to add a speed value for the tank's treads. Also, it would be cool if
    they moved in opposite directions when the tank is rotating. Real tanks turn by
    making one tread go forward and the other back.
  prefs: []
  type: TYPE_NORMAL
- en: Animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next topic we will be covering is animation. As we explore animations in
    Unity, we will be creating some targets for our tank to shoot at. Much of the
    power of Unity's animation system, Mecanim, lies in working with humanoid characters.
    But, setting up and animating human type characters is a book unto itself, so
    it will not be covered here. However, there is still much we can learn and do
    with Mecanim.
  prefs: []
  type: TYPE_NORMAL
- en: Before we continue with the explanation of the animation import settings, we
    need an animated model to work with. We have one last set of assets to import
    to our project. Import the `Target.blend` and `Target.png` files into the `Targets`
    folder of our project. Once imported, adjust the **Import Settings** window on
    the **Model** page for the target, just as we did for the tank. Now switch to
    the **Rig** tab.![Animations](img/2014OT_03_08.png.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Animation Type** attribute tells Unity what type of skeleton the current
    model is going to use when animating.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Humanoid** option adds many more buttons and switches to this page for
    working with human type characters. But again, it is too complex to cover here.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Generic** rig still uses Mecanim and many of its features. Really, this
    is just any animation skeleton that does not resemble a human in structure.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The third option, **Legacy**, utilizes Unity's old animation system. But, this
    system will be phased out over the next few versions of Unity, so it will not
    be covered either.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The last option, **None**, indicates that the object will not be animating.
    You could select this option for both the tank and the city, because it also keeps
    Unity from adding that `Animator` component and saves space in the final project
    size.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Root Node** value is a list of every object that is in the model file.
    Its purpose is to select the base object of your animation rig. For this target,
    select **Bone_Arm_Upper**, which is underneath the second **Armature** option.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Animations](img/2014OT_03_09.png.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The last page of the import settings, **Animations**, contains everything that
    we need to get the animations from our files into Unity. At the top of the **Target
    Import Settings** window, we have the **Import Animation** checkbox. If an object
    is not going to animate, it is a good idea to turn this option off. Doing so will
    also save space in your project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The option below that, **Bake Animations**, is only used when your animations
    contain Kinematics and are from 3Ds Max or Maya. This target is from Blender,
    so the option is grayed out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next four options, **Anim. Compression**, **Rotation Error**, **Position
    Error**, and **Scale Error**, are primarily for smoothing jittery animations.
    Nearly all of the time, the defaults will suit just fine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Clips** section is what we are really concerned about. This will be a
    list of every animation clip that is currently being imported from the model.
    On the left-hand side of the list, we have the name of the clip. On the right-hand
    side, we can see the start and end frames of the clip.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unity will add the **Default Take** animation clip to every new model. This
    is a clip generated from the default preview range of your modelling program,
    when the file was saved.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In Blender, it is also possible to create a series of actions for each rig.
    By default, they are imported by Unity as animation clips. In this case, the **ArmatureAction**
    clip is created.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Below and to the right-hand side of the clips, there is a little tab with **+**
    and **-** buttons. These two buttons add a clip to the end and remove the selected
    clip respectively.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Animations](img/2014OT_03_10.png.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: When a clip is selected, the next section appears. It starts with a text field
    for changing the name of the clip.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Below the text field, there is a **Source Take** drop-down list. This list is
    the same as the default animations. Most of the time, you will just use **Default
    Take**; but if your animation is ever appearing wrong or is missing, try changing
    the **Source Take** drop-down list first.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we have a small timeline, followed by input fields for the start and end
    frames of the animation clip. Clicking-and-dragging on the two blue flags in the
    timeline will change the numbers in the input fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next we have **Loop Pose** and **Cycle Offset**. If we want our animation to
    repeat, check the box next to **Loop Pose**. When an animation is looping, **Cycle
    Offset** will become available. This value lets us adjust the frame that the looping
    animation starts on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next three small sections, **Root Transform Rotation**, **Root Transform
    Position (Y)**, and **Root Transform Position (XZ)**, allow us to control the
    movement of a character through the animation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All three of these sections have a **Bake into Pose** option. If these are
    left unchecked, the movement of the root node (we selected it under the **Rig**
    page) within the animation is translated into movement of the whole object. Think
    of it like this: say you were to animate a character running to the right and
    inside of the animation program, you actually move them, rather than animating
    in place as normal. With Unity''s old animation system, for the physical part
    of a character to move the collider, the `GameObject` had to be moved with code.
    So, if you were to use that animation, the character would appear as if it had
    moved, but it would have no collision. With this new system, the whole character
    will move when that animation is played. However, this requires a different and
    more complex setup to work completely. So, it was not chosen to be used on the
    tank, though we could have used it.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of the three sections also has a **Based Upon** drop-down option. The choice
    of this option dictates the object's center for each of the sections. There are
    more choices if you are working with humanoid characters, but for now we only
    have two.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A choice of **Root Node** means the pivot point of the root node object is the
    center.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: A choice of **Original** means the origin as defined by the animation program
    is the center of the object.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: There is also an **Offset** option for the first two of these sections that
    works to correct errors in the motion. When animating a walk cycle for a character,
    if the character is pulling to the side slightly, adjusting the **Offset** option
    under **Root Transform Rotation** will correct it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The last option for our animation clip is a **Transform Mask** option. By clicking
    on the arrow to the left, you can expand a list of all objects in the model. Each
    object has a checkbox next to it. The objects that are not checked will not be
    animated when this clip is played. This is useful in the case of a hand-waving
    animation. Such an animation would only need to move the arm and hand, so we would
    uncheck all of the objects that might make up the body of the character. We could
    then layer animations, making our character capable of waving while standing,
    walking, or running, without the need to create three extra animations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we have our **Revert** button, **Apply** button, and the **Preview**
    window at the bottom. Just as with all of our other import settings, we have to
    hit one of these buttons when changes are made. This **Preview** window is made
    special by the speed slider in the top-right corner and the big **play** button
    in the top-left corner. By clicking on this button, we can preview the selected
    animation. This lets us detect those errors in motion that we talked about earlier,
    and just generally make sure that the animation is what we want.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The target's animations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, now that the description is all out of the way, let's actually make something
    with it. We start by setting up the animations for the target.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – setting up target's animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the knowledge we just gained, we can now set up our target's animations.
  prefs: []
  type: TYPE_NORMAL
- en: For starters, if you missed or skipped it earlier, be sure to import the `Target.blend`
    and `Target.png` files to the `Targets` folder. Also, on the **Rig** page of the
    import settings, set the **Animation Type** attribute to **Generic** and the **Root
    Node** attribute to **Bone_Arm_Upper**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need a total of six animations. By clicking on the **+** button in the **Clips**
    section, you can add four more animations. If you have added too many, click on
    the **-** button to remove the extra clips.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All of these clips should have a **Source Take** drop-down list of **Default
    Take** and all of the **Bake into Pose** options should be checked, because the
    target isn't going to be moving from its starting location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, let's create our idle animations. Select the first clip and rename it
    to `Idle_Retract`. Because it is a mechanical object, we can get away with a really
    short animation; so short that we are just going to use the first frame. Set the
    starting frame to `0.9` and the ending frame to `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also need to turn on **Loop Pose** because idle animations are of course
    looping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The extended idle animation is created in almost exactly the same manner. Select
    the second clip and rename it to `Idle_Extend`. The starting frame here is `14`
    and the ending frame is `14.1`. Also, this animation needs to loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our next two animations are for when the target extends and retracts. They are
    going to be called `Extend` and `Retract`, so rename the next two clips. The `Extend`
    animation will start at frame `1` and end at frame `13`. The `Retract` animation
    starts at frame `28` and ends at frame `40`. Neither of these will loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last two animations also will not loop. They are for when we shoot the targets.
    There is one for being shot in the front and one for being shot from behind. The
    `Hit_Front` animation will be from frame `57` to frame `87`. The `Hit_Back` animation
    will be from frame `98` to frame `128`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once all of the changes are made, be sure to click on **Apply** or they will
    not be saved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We set up the animations that will be used by our targets. There were six in
    total. They may not seem like much now, but the next section would be lost without
    them.
  prefs: []
  type: TYPE_NORMAL
- en: State machines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order for us to control these new animations in Unity, we need to set up
    a state machine. A state machine is just a fancy object that keeps track of what
    an object can do, and how to transition between those things. Think of it in terms
    of a builder from a Real Time Strategy game. The builder has a walk state that
    is used when moving to the next construction site. When it gets there, it switches
    to a build state. If an enemy shows up, the builder will enter a run away state
    until the enemy is gone. Finally, there is an idle state for when the builder
    is doing nothing. In Unity, these are called Animator Controllers when working
    with animations and Mecanim.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the target state machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The use of a state machine allows us to focus more on what the target is doing,
    while letting Unity handle the *how it is going to do it* part.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Animator Controller is simple and done just as we have been doing
    for our scripts and materials. The option is second from the bottom of the **Create**
    menu. Create one in the `Targets` folder and name it `TargetController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on `TargetController` to open a new window.![Time for action –
    creating the target state machine](img/2014OT_03_11.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Animator** window is where we edit our state machines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top-left corner of the window, there is a breadcrumb trail as you might
    find on a website that lets us see where we are in the state machine at a glance.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Auto Live Link** button in the top-right controls our ability to see the
    state machine's update in real time with the game. This is useful for debugging
    transitions and controls for the character.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Underneath the breadcrumb trail, there are a list of layers and a button for
    adding new layers. Every state machine will have at least the **Base Layer**.
    Adding additional layers would allow us to blend state machines. Say we have a
    character that walks around normal when at full health. When his health drops
    below half, he starts to limp. If the character has only ten percent of his health
    left, he starts to crawl. This would be achieved through the use of layers.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: At the bottom-left corner of the window, there is the **Parameters** list. Clicking
    on the **+** button will add a new parameter to the list. These parameters can
    be Boolean, float, vector, and integer values. The transitions between states
    are most often triggered by changes in the parameters. Any scripts working with
    the state machine can modify these values.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, that green box in the center with **Any State** on it that allows a
    character to transition from any action to a specific one. When a character's
    health drops below zero, we want them to go to the death state. The **Any State**
    box would hold this transition, and it would be able to pull the character out
    of any other state and put them in the death state.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To create a new state, right-click on the grid that is inside our **Animator**
    window. Mouse over **Create State** and select **Empty**. This creates a new empty
    state for our state machine. Normally new states are gray but, because this is
    the first state in our machine it is orange, which is the color of the default
    state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every state machine will start in its default state. Click on the state to select
    it, and we can take a look at it in the **Inspector** window.![Time for action
    – creating the target state machine](img/2014OT_03_12.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top, there is a text field for changing the name of the state.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Below that, you can add a tag for organizational purposes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, there is a **Speed** field. This field controls the speed of the animation.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Motion** field is where we will add connections to the animation clips
    that we created earlier.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Foot IK** option lets us decide if we want to let part of the animation
    be calculated with IK. We did not set up any IK for these animations, so we do
    not need to worry about this option.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The last option, **Mirror**, is used to flip the left and right (or x axis)
    of the animation. If you created a right-hand-waving animation, this option would
    let you change it to a left-hand-waving animation.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Below that, there is the list of transitions that go from this state to another
    state. These are transitions out of the state, not into it. As you will soon see,
    a transition in this list appears as the name of the current state with an arrow
    to the right, followed by the name of the state it is connected to.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Checkboxes also appear under the **Solo** and **Mute** labels on the right.
    These are for debugging transitions between states. Any number of the transitions
    can be muted at one time, but only one can be soloed at a time. When a transition
    has been muted, it means that the state machine will ignore it when deciding which
    transition to make. Checking the solo box is the same as muting all but one of
    the transitions. It is just a quick way of making it the only active transition.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to need one state for each of our target's animations. So, create
    five more states and rename all six to match the names of the animation clips
    we created earlier. The default state, the orange one, should be named `Idle_Retract`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Project** window, click on the little triangle to the left of the **Target**
    model.![Time for action – creating the target state machine](img/2014OT_03_13.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This expands the model, so that we can see all of the objects that make up that
    model in Unity. The first group, as indicated by the little thumbnails next to
    each object, is the raw mesh data. This is followed by an Avatar object; this
    is what keeps track of the **Rig** setup. Below that, there are the animation
    clip objects; these are what we are interested in right now. The objects that
    make up the model are at the bottom of the stack.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Select each state in your **Animator** window and pair it with the correct clip
    by dragging an animation clip from the **Project** window and dropping it on the
    **Motion** field in the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The thumbnail for animation clips looks like a little play button.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action – creating the target state machine](img/2014OT_03_14.png.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Before we can create our transitions, we need a few parameters. Click on the
    **+** button next to **Parameters** in the bottom-left corner of the window and
    select **Float** from the menu that appears. A new parameter should now appear
    in the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new field on the left is the name of the parameter; rename this one to `time`.
    The field on the right is the current value of this parameter. When debugging
    our state machine, we can modify these values here to trigger changes in the state
    machine. Any changes made by the scripts while the game is running will also appear
    here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need two more parameters. Create two Boolean parameters and rename them to
    `wasHit` and `inTheFront`. These will trigger the machine to change to the getting
    hit states, while the `time` parameter will trigger the machine to utilize the
    `extend` and `retract` states.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To create a new transition, right-click on a state and select **Make Transition**
    from the menu that pops up. A transition line is now connected from the state
    to your mouse. To complete the transition creation, click on the state that you
    wish to connect to. There is an arrow on the line, indicating the direction of
    the transition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need a transition from `Idle_Retract` to `Extend`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We also need a transition from `Extend` to `Idle_Extend`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Idle_Extend` needs three transitions, one each going to `Retract`, `Hit_Front`,
    and `Hit_Back`.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Retract`, `Hit_Front`, and `Hit_Back` need a transition going to `Idle_Retract`.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Use the following diagram for reference. If you create a transition or state
    that you do not want, select it and click on the *Delete* key on your keyboard
    to remove it.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action – creating the target state machine](img/2014OT_03_16.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: If you click on one of the transition lines, then we can take a look at its
    settings.![Time for action – creating the target state machine](img/2014OT_03_17.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top of the **Inspector** window, we have the same indicators of which
    states we are transitioning between that we had in the state, the name of the
    state the transition starts in followed by an arrow, and finally the name of the
    state the transition ends in.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Underneath the familiar **Transitions** list, there is a text field where we
    can give our transitions specific names. This would be useful if we had several
    different types of transitions between the same two states.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Directly under the field, there is a more exact path-based indication of which
    states the transition is between.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Atomic** checkbox allows us to decide whether or not a transition can
    be interrupted. If **Atomic** is checked, it cannot be interrupted.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the example about the **Any State** option and the death state, perhaps we
    were shot while pulling out a sword, going from an idle state to an attack state.
    That transition cannot be atomic, if we are to avoid the weirdness of completing
    our sword draw before falling over dead.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Next is a timeline block that lets us preview the transition between animations.
    Dragging the little flag left and right, we can watch the transition in the **Preview**
    window below. The top half of this block holds wave forms that indicate the movement
    contained in an animation. The bottom half shows the states as boxes that overlap
    where the transition actually occurs. Either of these boxes can be dragged to
    change the length of the transition.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Because our two idle animations are of negligible length, this can't be seen
    in our setup normally. If you temporarily create a transition between the `extend`
    and `retract` states, it would be visible.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Lastly, we have a **Conditions** list. Using the parameters we set up, we can
    create any number of conditions here that must be met before this transition can
    take place.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The default condition is **Exit Time**. This means that, when the first state
    reaches a certain percentage of the way through its animation, as defined by the
    float field to the right, it will start transitioning into the next state. For
    half of our transitions, this is what we want. The other half, namely anything
    that exits our idle states, need to be based on our parameters.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: There is also another **Preview** window at the bottom of the **Inspector**
    panel. It functions just like the one for the animation import settings page,
    but this one plays the transition between the two relevant animations.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the transition between the `Idle_Retract` state and `Extend` state. We
    want the targets to randomly pop up. This will be controlled by a script changing
    the `time` parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on `Exit Time` under the **Conditions** list to bring up the list of parameters
    and select time from the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to turn a float value into a conditional statement, we need to compare
    it with another value. That is why we got a new drop-down button of comparison
    options when we selected the parameter. A float value will be either greater than
    or less than the value on the right. Our time will be counting down, so select
    **Less** from the list and leave the value at zero.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the conditions for the transition between the `Idle_Extend` and `Retract`
    states to be the same.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the transition between the `Idle_Extend` state and `Hit_Front` state, we
    will use both of the Boolean parameters that were created. Select the transition
    and click on the **+** button under **Conditions** to add a second condition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the first condition, select **wasHit** and select **inTheFront** for the
    second condition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A Boolean is either true or false. In the case of the transitions, it needs
    to know which of those values it is waiting for. For this transition, both should
    be left as true.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, set up the conditions for the transition between `Idle_Extend` and `Hit_Back`,
    just as you did for the previous transition. The difference being that false needs
    to be selected from the drop-down list next to the `inTheFront` conditional.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a state machine that will be used by our targets. By linking each
    state to an animation and connecting them all with transitions, the target will
    be able to switch between animations. This transitioning is controlled through
    adding conditionals and parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – scripting the target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We only need one more piece before we can finish putting the target together.
  prefs: []
  type: TYPE_NORMAL
- en: That piece is a script. Create a new script in our `Scripts` folder and name
    it `Target`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, in order to interact with our state machine, we need a reference to the
    `Animator` component. It is the component that you removed from the tank and the
    city. The `Animator` component is what ties all of the pieces of animation together.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is followed by two float values that will dictate the range of time, in seconds,
    that our targets will sit in their idle states.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we have three values that will hold the ID numbers of the parameters that
    we need to change. It is technically possible to just use the names of the parameters
    to set them, but using the ID number is much faster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last two variables will hold the ID numbers of the two idle states. We
    need these for checking which state we are in. All of the IDs are initially set
    to `-1` as a dummy value, we set them to their actual values with the following
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Awake` function is a special function in Unity that is called on every
    script at the beginning of the game. Its purpose is initialization before the
    game gets underway, perfect for initially setting our ID values. For each ID,
    we make a call to the `Animator.StringToHash` function. This function calculates
    the ID number of the parameter or state that we give it the name of. The state
    names also need to be prefixed with `Base Layer`. This is because Unity wants
    us to be specific when it is possible to have several different layers with states
    that are named the same thing. It is also very important that the name here exactly
    matches the name in the **Animator** window. If it does not, IDs will not match,
    errors will occur, and the script will not function correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To make use of all of these IDs, we turn to our very good friend—the `Update`
    function. At the beginning of the function, we use the `GetCurrentAnimatorStateInfo`
    function to figure out which state is the current one. We send it a zero because
    it wants to know the index of the layer we are inquiring about, of which we only
    have the one. The function returns an object with the info about the current state,
    and we grab the `nameHash` value (also known as the ID value) of this state right
    away and set our variable to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next line of code is a comparison with our idle state IDs to figure out
    if we are in one of those states. If we are, we call upon the `SubtractTime` function
    (which we will write in a moment) to reduce the `time` parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the target is not currently in one of its idle states, we start by checking
    to see if we were hit. If so, the hit is cleared using the `ClearHit` function
    and the `time` parameter is reset using the `ResetTime` function. Both functions
    will also be written in a moment. Finally, we check to see if our timer had dropped
    below zero. If that is the case, we again reset the timer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `SubtractTime` function we use the `GetFloat` function of our `Animator`
    component to retrieve the value of a float parameter. By sending it our `timeId`
    variable, we can receive the current value of the `time` parameter. Like we did
    with the tank, we then use `Time.deltaTime` to keep in pace with our frame rate
    and subtract time from the timer. Once done, we need to give the state machine
    the new value, which is done with the `SetFloat` function. We tell it which parameter
    to change by giving it an ID value, and we tell it what to change it to by giving
    it our new time value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next function to create is `ClearHit`. This function uses `SetBool` from
    the `Animator` component to set Boolean parameters. It functions just as the `SetFloat`
    function. We just give it an ID and a value. In this case, we are setting both
    of our Boolean parameters to false so that the state machine no longer thinks
    it has been hit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last function for the script is `ResetTime`. This is another quick function.
    First, we use the `Random.Range` function to get a random value. By passing it
    a minimum and maximum value, our new random number will be between them. Finally
    we use the `SetFloat` function to give the state machine the new value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a script to control the state machine of our target. For comparing
    states and setting parameters, we gathered and used IDs. For now, do not worry
    about when the hit states are activated. It will be made clear in the following
    section when we finally make the tank shoot.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the prefab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have the model, animations, state machine, and script, finally it
    is time to create the target and turn it into a prefab.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have all the pieces; the next step is to put them together.
  prefs: []
  type: TYPE_NORMAL
- en: Start by dragging the **Target** model from the **Project** window to the **Hierarchy**
    window. This creates a new instance of the `target` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By selecting the new `target` object, we can see that it already has an `Animator`
    component attached; we just need to add a reference to `AnimatorController` that
    we created. Do this by dragging `TargetController` from the **Project** window
    and dropping it on the Animator component's **Controller** field, just as with
    all the other object references we have set up so far.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, we need to add the `Target` script to the object and connect a reference
    to the `Animator` component in its relevant field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last thing to do to the target object is to add a collider to actually receive
    our cannon shots. Unfortunately, because the `target` object uses bones and a
    rig to animate, it is not as simple as adding a collider directly to the mesh
    we will be shooting at. Instead, we need to create a new empty `GameObject`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename it `TargetCollider`, and make it a child of the target's `Bone_Target`
    bone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `MeshCollider` component to the new `GameObject`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need to provide it with some mesh data. Find the `Target` mesh data
    in the **Project** window, underneath the **Target** model. Drag it to the **Mesh**
    value of the `MeshCollider` component. This causes a green cylinder to appear
    in the **Scene** view. This is our collision, but it is actually not on the target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The many objects in the **Project** window can be easily told apart by the little
    symbol that sits next to each. The symbol for a mesh is a gray and blue grid.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action – creating the target](img/1.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Use the **Transform** component to set the GameObject's position to `4` for
    the **X** value and `0` for both **Y** and **Z**. The rotation needs to be changed
    to `0` for **X**, `-90` for **Y** and `90` for **Z**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we made the changes, you probably noticed that the font of everything that
    was new or changed became bold. This is to indicate that something is different
    with this prefab instance when compared to the original. Remember, models are
    essentially prefabs; their problem is that we cannot directly make changes such
    as adding scripts. To make this target into a new prefab, simply drag it from
    the **Hierarchy** window and drop it on the `Prefabs` folder in the **Project**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this spiffy new prefab created, populate the city with it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In placing all of these targets, you probably noticed that they are a little
    large. Instead of editing each target individually or even all of them as a group,
    we only have to make a change to the original prefab. Select the `Target` prefab
    in the **Project** window. The **Inspector** window displays the same information
    for a root prefab object as it does for any other object in the scene. With our
    prefab selected, half the scale and all of the instances already in the scene
    will automatically be updated to match. We can also make changes to the min and
    max idle times and have it affect the whole scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just finished creating the targets for our tank. By making use of Unity's
    prefab system, we are also able to duplicate the target throughout our game and
    easily make changes that affect them all.
  prefs: []
  type: TYPE_NORMAL
- en: If you wanted one of the targets to be larger than all of the others, you could
    change it in the scene. Any changes made to a prefab instance are saved, and they
    take precedence over changes made to the root prefab object. Also, when looking
    at an instance in the **Inspector** window, there will be three new buttons at
    the top of the window. The **Select** button selects the root prefab object in
    the **Project** window. **Revert** will remove any unique changes made to this
    instance, whereas the **Apply** button updates the root object with all the changes
    that were made in this instance.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – more targets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using all that you have learned about animations and state machines, your challenge
    here is to create a second type of target. Play around with different movements
    and behaviors. Perhaps, create one that transitions from waving around to standing
    still.
  prefs: []
  type: TYPE_NORMAL
- en: Ray tracing to shoot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Play the game now; it is pretty cool. We have our drivable tank and textured
    city. We even have fancy animated targets. We are just missing one thing: how
    do we shoot? We need to make one more script and we can shoot targets to our heart''s
    content.'
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – simple shooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the addition of one more object and a single script, we can start shooting
    at our targets.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to add an empty `GameObject` to our tank. Rename it to `MuzzlePoint`
    and make it a child of the cannon's pivot point object. Once done, position it
    at the end of the cannon so the blue arrow points away from the tank, along the
    same direction as the cannon. This will be the point where our bullets will come
    from.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also need something to indicate where we are shooting. The explosions are
    covered in future chapters, so choose **Sphere** from the **Create Other** menu
    and rename it `TargetPoint`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the sphere's scale to `0.2` for each axis and give it a red material. This
    way it can be more easily seen, without being completely obtrusive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the `SphereCollider` component from `TargetPoint`. The `SphereCollider`
    has to be removed because we don't want to shoot our own target indicator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, create a new script and call it `FireControls`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This should start to look familiar to you. We start with variables to hold references
    to our muzzle and targeting objects that we just created. They are followed by
    an `OnGUI` function that draws a button in the bottom-right corner of the screen,
    just above where we drew the turret control buttons. If the button is pressed,
    we call upon the `Fire` function that we will create next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Fire` function starts by defining a variable that will hold the detailed
    information about what was shot. It is followed by an `if` statement that checks
    the `Physics.Raycast` function. The `Raycast` function works just like shooting
    a gun. We start with a position (the muzzle point's position) pointing in a specific
    direction (forward relative to the muzzle point) and get out what was hit. If
    we hit something, the `if` statement evaluates to true; otherwise it is false
    and we would skip ahead. When we do hit something, we first move our target point
    to the point that was hit. We then use the `SendMessage` function to tell what
    we hit that it was hit. The `SendMessage` function is only available for `GameObjects`
    and `MonoBehaviours`, and our `Target` script is on the root object for the target,
    hence the `hit.transform.root.gameObject` in order to get at the `GameObject`
    that was hit. The `SendMessage` function takes the name of a function and tries
    to find it on the `GameObject` to which the message was sent. We are also providing
    it with a value, `hit.point`, to give to the function that should be found. The
    `SendMessageOptions.DontRequireReceiver` part of the line keeps the function from
    throwing an error if it is unable to find the desired function. The last part
    of our `Fire` function occurs if we didn't hit anything. We send our target point
    back to the world origin, so the player can tell that they missed everything.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last thing to do is to add the `Hit` function to the end of our `Target`
    script. We start the function by getting the current state ID, just as we did
    earlier in the script. However, this time we check only against our extended idle
    ID. If they do not match, we use return to exit the function early. We do this
    because we don't want to let the player shoot any targets that are down or in
    mid transition. If our state is correct, we continue by telling the animation
    that we were hit using the `SetBool` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The rest of the `Hit` function figures out which side the target was hit on.
    To do this, we first had to convert the point that we received from world space
    into local space. The `InverseTransformPoint` function from our **Transform**
    component does this nicely. We then do a check to see where the shot came from.
    Because of the way the target is constructed, if the shot was positive on the
    x axis, it came from behind. Otherwise, it came from the front. Either way, we
    set the `inTheFront` parameter from our state machine to the proper value. Then
    we give the player some points by incrementing the static variable that we created
    on our `ScoreCounter` script, way back at the beginning of the chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, be sure to add the new `FireControls` script to the tank. Also, you
    need to connect the references to the `MuzzelPoint` and `TargetPoint` objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a script that allows us to fire the cannon of our tank. The method
    of using ray tracing is the simplest and most widely used. In general, bullets
    fly too fast for us to see them. Ray tracing is like this, that is; it is instant.
    However, this method does not take gravity, or anything else that might change
    the direction of a bullet, into account.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – better GUI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that all of the buttons and components are in place, make them look better.
    Use the skills you gained from the previous chapter to style the GUI and make
    it great. Perhaps you could even manage to create a directional pad for the movement.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: And, that is it! The chapter was long and we learned a lot. We imported meshes
    and set up a tank. We created materials so that color could be added to a city.
    We also animated some targets and learned how to shoot them down. It was a lot
    and it is time for a break. Play the game, shoot some targets, and gather those
    points. The project is all done and ready to be built to your device of choice.
    The build process is the same as both of the previous projects, so have fun!
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is about special camera effects and lighting. We will be learning
    about lights and their types. Our Tank Battle game will expand through the addition
    of a skybox and several lights. We will also take a look at distance fog. With
    the addition of shadows and lightmaps, the city we will battle in really starts
    to become interesting and dynamic.
  prefs: []
  type: TYPE_NORMAL
