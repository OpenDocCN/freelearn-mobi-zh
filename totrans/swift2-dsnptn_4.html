<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Structural Patterns – Adapter and Facade</h1></div></div></div><p>In this chapter, we will discuss two new structural patterns: the adapter and facade patterns. We will focus on the adapter pattern that joins together types that were not designed to work with each other. Then, we will discuss the facade pattern that simplifies the interface of a set of complex systems.</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec22"/>The adapter pattern</h1></div></div></div><p>This <a class="indexterm" id="id187"/>pattern <a class="indexterm" id="id188"/>is often used when dealing with frameworks, libraries, and APIs to easily "adapt" the old and existing interfaces to the new requirements of a program.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec80"/>Roles</h2></div></div></div><p>The adapter <a class="indexterm" id="id189"/>pattern converts the interface of another existing class into an interface waited by the existing clients to allow them to work together. Thanks to this pattern, you can integrate components for which you normally cannot modify the source code and things that often appear with the use of a framework.</p><p>Note that you should avoid using this pattern if you already have source code access to the component.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec81"/>Design</h2></div></div></div><p>The generic<a class="indexterm" id="id190"/> class diagram of the pattern is as follows:</p><div><img alt="Design" src="img/4852_04_01.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec82"/>Participants</h2></div></div></div><p>In the <a class="indexterm" id="id191"/>preceding diagram, you can see the four participants of this pattern:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ITarget</code>: This <a class="indexterm" id="id192"/>introduces the method signature of the object through this interface</li><li class="listitem" style="list-style-type: disc"><code class="literal">Client</code>: The <a class="indexterm" id="id193"/>client interacts with objects that implement the <code class="literal">ITarget</code> interface</li><li class="listitem" style="list-style-type: disc"><code class="literal">Adapter</code>: This <a class="indexterm" id="id194"/>class implements the method of the <code class="literal">ITarget</code> interface and invokes the method of the adapted object</li><li class="listitem" style="list-style-type: disc"><code class="literal">Adaptee</code>: This is <a class="indexterm" id="id195"/>the object for which we need to adapt its interface to make it manipulable by the client</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec83"/>Collaboration</h2></div></div></div><p>The client<a class="indexterm" id="id196"/> invokes the <code class="literal">methodA()</code>adapter that itself invokes the <code class="literal">methodB()</code>adapter of the <code class="literal">adaptee</code> object.</p><p>The following following screenshot represent the organization of our project:</p><div><img alt="Collaboration" src="img/4852_04_02.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec84"/>Illustration</h2></div></div></div><p>The <a class="indexterm" id="id197"/>sales director of your company wants to produce a universal battery charger for mobile phones. This charger can deliver up to 10 volts as output. As the CIO of the company, a member of your development team presents you a first prototype of the charger.</p><p>In this chapter, I created a new OS X Command Line Tool project that you'll find in the <code class="literal">first_prototype</code> folder, and I have named it <code class="literal">ChargerPrototype</code>.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec04"/>Implementing our first prototype</h3></div></div></div><p>Our <a class="indexterm" id="id198"/>project is organized as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">Interfaces</code> folder contains the definition of the methods that the client will invoke to charge the phone</li><li class="listitem" style="list-style-type: disc">The <code class="literal">PhonePrototype.swift</code> file is a class that defines our test phone and implements the <code class="literal">IChargeable</code> protocol</li></ul></div><p>The result is as follows:</p><div><img alt="Implementing our first prototype" src="img/4582_04_03.jpg"/></div><p>The <code class="literal">ChargeableProtocol</code> interface <a class="indexterm" id="id199"/>is a simple protocol that defines the signature of the <code class="literal">charge</code> method:</p><div><pre class="programlisting">import Foundation

protocol ChargeableProtocol {
  
  /// This function is called to charge a mobile phone
  ///
  /// Usage:
  ///
  ///    charge(5.5)
  ///
  /// - Parameter volts: voltage needed to charge the battery
  ///
  /// - returns: Void
  func charge(volts: Double)
}</pre></div><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>Consider that Swift protocols have the same concepts as interfaces.</p><p>There are some differences between protocols and Java interfaces, which are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Swift protocols can also specify properties that must be implemented (for example, fields)</li><li class="listitem" style="list-style-type: disc">Swift protocols need to deal with values/references through the use of the mutating keyword (because protocols can be implemented by structs and classes)</li></ul></div><p>You can combine protocols at any point with the <code class="literal">protocol&lt;&gt;</code> keyword, for example, declaring a function parameter that must adhere to the <code class="literal">A</code> and <code class="literal">B</code> protocols, which is as follows:</p><div><pre class="programlisting">func foo ( var1 : protocol&lt;A, B&gt; ){}</pre></div></div></div><p>Next, we <a class="indexterm" id="id200"/>define a <code class="literal">PhonePrototype</code> class that can be charged using the <code class="literal">ChargeableProtocol</code> protocol:</p><div><pre class="programlisting">class PhonePrototype: ChargeableProtocol {
  /// This function is called to charge a mobile phone
  ///
  /// Usage:
  ///
  ///    charge(5.5)
  ///
  /// - Parameter volts: voltage needed to charge the battery
  ///
  /// - returns: Void
  func charge(volts: Double) {
    print("Charging our PhonePrototype")
    print("current voltage \(volts)")
  }
}</pre></div><p>Note the comments added to the code here. With Swift, you can add organized comments that allow you to see the information with a popover (by holding <em>Alt</em> + pointing mouse cursor on the swift the method you want usage information). To check the result of how the comment are displayed proceed like this:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">Charger.swift</code> file. This file represents our universal charger.</li><li class="listitem">Tap and hold the <em>Alt</em> key.</li><li class="listitem">Position the mouse <code class="literal">charge</code> that appears in the <code class="literal">self.phone.charge(volts)</code> statement. An interrogation point <code class="literal">?</code> will appear.</li><li class="listitem">Click on charge.</li></ol></div><p>Then, you will see the following popover, as shown in the following screenshot:</p><div><img alt="Implementing our first prototype" src="img/4582_04_04.jpg"/></div><p>You should <a class="indexterm" id="id201"/>consider detailed comments of your functions as best practices. Make sure that all your methods are fully commented. You can check how the popover is well-documented, as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use <code class="literal">///</code> to start documenting your code</li><li class="listitem" style="list-style-type: disc">Use <code class="literal">– Parameter parametername: description of the parameter</code> to describe your parameter</li><li class="listitem" style="list-style-type: disc">Use <code class="literal">– returns: type to return</code> to describe the returned type</li></ul></div><div><div><h3 class="title"><a id="note13"/>Note</h3><p>For more information on existing keywords to document your code, you should check out the following website:</p><p>
<a class="ulink" href="http://ericasadun.com/2015/06/14/swift-header-documentation-in-xcode-7/">http://ericasadun.com/2015/06/14/swift-header-documentation-in-xcode-7/</a>.</p></div></div><p>Your engineers present you the prototype of the charger and it seems to work fine.</p><p>After loading the <code class="literal">ChargerPrototype.xcodeproject</code> file in Xcode, click on run to launch the code.</p><p>On the console, you will see the following result:</p><div><img alt="Implementing our first prototype" src="img/4582_04_05.jpg"/></div><p>Let's see how <a class="indexterm" id="id202"/>the <code class="literal">Charger</code> class has been implemented:</p><div><pre class="programlisting">import Foundation

class Charger {
  var phone: ChargeableProtocol!
  let volts = 10.0
  
  func plugMobilePhone(phone: ChargeableProtocol){
    print("A mobile is plugged")
    self.phone = phone
    self.phone.charge(volts)
  }
}</pre></div><p>The implementation of the preceding code is quite simple. By reading it line by line we can deduct how it works:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Our charger contains a reference to a phone. The phone must implement <code class="literal">ChargeableProtocol</code>. Of course, our universal charger will only communicate with this interface.</li><li class="listitem" style="list-style-type: disc">Then, we have a method where we can plug our phone.</li><li class="listitem" style="list-style-type: disc">We assign the phone to our reference and call the charge method of the referenced phone.</li></ul></div><p>So, your mobile phone charger works fine with all mobile phone chargers that implement <code class="literal">ChargeableProtocol</code>.</p><p>However, there is a problem. Your charger works fine with all phones that implement <code class="literal">ChargeableProtocol</code> but not with mobile phones available on the market. Indeed, each mobile phone manufacturer has its own interface to charge its own products.</p><p>It is impossible to use our charger with the existing mobile phone! A roof for a company that wants to sell universal mobile phone chargers.</p><p>You can plan an urgent meeting with your teams in order to find a solution to avoid the bankruptcy of <a class="indexterm" id="id203"/>your company.</p><div><div><h3 class="title"><a id="tip06"/>Tip</h3><p>Mike, a new developer of your company, proposes a solution: "To make all mobile phones work with our charger, they need to implement <code class="literal">ChargeableProtocol</code>, but we cannot modify the mobile phones because we do not have the source code. So, we can tell each manufacturer to implement <code class="literal">ChargeableProtocol</code> on their iPhones."</p><p>Kevin, the IT project manager, replies, "Mike, welcome to the company, but your solution is not a good choice. Manufacturers have their own systems and they don't want to change them. And what would we do with the phones that are already sold that don't implement <code class="literal">ChargeableProtocol</code>?"</p><p>Kevin continues, "The problem that we have is not the manufacturers' problem; he doesn't have to adapt their code to make our charger work with their products, it is up to our company to adapt ours. Yes, we must adapt our code."</p><p>Mike then asks, "So, how do you want to proceed?"</p><p>Kevin replies, "Well, the concept is simple. If you plan a trip to France, the electrical outlet specifications and shapes are not adapted to the ones that we have here in the U.S. I stumbled upon an adapter that I bought from an electrical shop near my home. This adapter accepts the shape and specification of my American cable and the other one that can be plugged into the French electrical outlet because the side plugged in has the same shape and specification as the French one. All transformations between the U.S. and French specifications are done in the adapter itself."</p><p>"The problem is the same here. We must adapt our charger, depending on the manufacturer. So, we will have an adapter per mobile phone and continue to have a unique charger."</p><p>Julien, the CEO, replies, "Great, Kevin! Let's go now. We must make our universal charger available before Christmas!"</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec05"/>Implementation</h3></div></div></div><p>The first thing <a class="indexterm" id="id204"/>that we need to do is to prepare our adapter to make it work with our charger. The charger works only with object that implements <code class="literal">ChargeableProtocol</code>. We will need to implement <code class="literal">ChargeableProtocol</code> with each adapter that we will create.</p><p>Once the side charger "plugged to" adapter is completed by implementing <code class="literal">ChargeableProtocol</code>, we will add a reference to the mobile phone that the adapter adapts. Our universal charger doesn't manipulate <a class="indexterm" id="id205"/>the mobile phone instance; it is the role of the adapter to manipulate it.</p><p>Open the <code class="literal">ChargerWithAdapter.xcodeproj</code> project and check the organization of our code:</p><div><img alt="Implementation" src="img/4582_04_06.jpg"/></div><p>We have grouped our actors in the following three folders:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Adaptees</code>: This contains the component that we must adapt. You can consider this one if you do not have the source code. Remember that you should not use the adapter pattern if you own the source code of the <code class="literal">Adaptee</code> folder.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Adapters</code>: This contains our adapters depending on the mobile phones that we must charge.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Interface</code>: This contains the interface implemented by our adapters and manipulated by the client.</li><li class="listitem" style="list-style-type: disc"><code class="literal">main.swift</code>: This represents the client: the universal charger.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Charger.swift</code>: This is the object that needs to be adapted.</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec06"/>Implementation of our adaptees</h3></div></div></div><p>Let's study <a class="indexterm" id="id206"/>two mobiles phones that we need to adapt: the "Pear" mobile phone and "SamSing" mobile phone: Note that in real life, you will not have the source code of the adaptee, the object that needs to be adapted, you'll only work with their known interfaces.</p><p>Let's first analyze the SamSing mobile phone:</p><div><pre class="programlisting">import Foundation
class SamSingMobilePhone {
  
  enum VoltageError: ErrorType {
    case TooHigh
    case TooLow
  }
  
  ///Accept only 10 volts
  func chargeBattery(volts: Double) throws {
    if volts &gt; 10 { throw VoltageError.TooHigh }
    if volts &lt; 10 { throw VoltageError.TooLow }
    
    print("SamSing mobile phone is charging")
    print("Current voltage \(volts)")
  }
}</pre></div><p>Now, let's analyze the Pear mobile phone:</p><div><pre class="programlisting">import Foundation

class PearMobilePhone {
  
  enum PearVoltageError: ErrorType {
    case NoPower
    case TooLow
    case TooHigh
  }
  
  ///Accept only 5.5 volts
  func charge(volts: Double) throws {
    guard volts &gt; 0 else { throw PearVoltageError.NoPower}
    if volts &gt; 5.5 { throw PearVoltageError.TooHigh }
    if volts &lt; 5.5 { throw PearVoltageError.TooLow }
    
    print("Pear mobile phone is charging")
    print ("Current voltage \(volts)")
  }
}</pre></div><p>These two classes <a class="indexterm" id="id207"/>represent our objects that need to be adapted: the first one is the <code class="literal">SamSingMobilePhone</code> class that has a method called <code class="literal">chargeBattery</code>. This is the method used by the original charger to charge the SamSing mobile phone.</p><p>The second one is the <code class="literal">PearMobilePhone</code> class that allows the original charger to charge the battery but this one is simply called <code class="literal">charge</code>. Note that the two mobiles phone need different voltages to be charged.</p><p>So what you see here is that our universal charger will need to be adapted to call the <code class="literal">charge</code> method when the Pear mobile phone is plugged in and call the <code class="literal">chargeBattery</code> method when the SamSing mobile phone is plugged in.</p><p>We will have to make an adapter for each mobile phone type that we want to be able to charge.</p><p>As mentioned earlier, you should not have the source code of the <code class="literal">adaptee</code> object when you use the adapter pattern. The source code is provided here only for demonstration purposes.</p><p>Have you checked the source code of our two adaptees? I have voluntary introduced two new Swift keywords that I wish to present you.</p><p>First, both classes have an enumeration of possible errors that the charger can handle. The SamSing will throw an error if the voltage is too high or too low; the Pear model can throw the same errors and can throw another one if there is absolutely no power when it is plugged to the charger. As mentioned in the documentation, in Swift, errors are represented by values of type conforming to the <code class="literal">ErrorType</code> protocol. This is the reason why you see each enumeration implementing the <code class="literal">ErrorType</code> protocol:</p><div><pre class="programlisting">  enum PearVoltageError: ErrorType {
    case NoPower
    case TooLow
    case TooHigh
  }</pre></div><p>Having this enumeration is not sufficient; we need to handle errors when the <code class="literal">charge</code> method is called. For this, we need to tell the method to throw an exception.</p><p>For this, we simply add the <code class="literal">throw</code> keyword just before we define the return type, as follows:</p><div><pre class="programlisting">func chargeBattery(volts:Double) throws {</pre></div><p>Remember that this function definition is exactly the same as:</p><div><pre class="programlisting">func charge(volts:Double) throws -&gt; Void {</pre></div><p>Not providing the return type is equivalent to stating that the return type is of the type <code class="literal">Void</code>.</p><p>Well, once our <a class="indexterm" id="id208"/>method is informed that it can handle errors, we still have to raise an error when it is necessary to do so. We make some conditional checks at the beginning of the method, and if something goes wrong, it throws an exception. To raise an exception, we simply use the <code class="literal">throw</code> keyword just before the <code class="literal">ErrorType</code> object (implementing the ErrorType protocol) that we want to raise. (Here is a <code class="literal">VoltageError</code>):</p><div><pre class="programlisting">if volts &gt; 10 { throw VoltageError.TooHigh }
if volts &lt; 10 { throw VoltageError.TooLow }</pre></div><p>As mentioned earlier, the <code class="literal">PearMobilePhone</code> class raises an error; this is when the method receives <code class="literal">0</code> voltage from the charger. In this case, the <code class="literal">PearVoltageError.NoPower</code> value of the <code class="literal">PearVoltageError</code> enumeration type will be raised.</p><p>Let's investigate the <code class="literal">charge</code> method of the <code class="literal">PearMobilePhone</code> class:</p><div><pre class="programlisting"> ///Accept only 5.5 volts
  func charge(volts: Double) throws -&gt; Void {
    guard volts &gt; 0 else { throw PearVoltageError.NoPower}
    if volts &gt; 5.5 { throw PearVoltageError.TooHigh }
    if volts &lt; 5.5 { throw PearVoltageError.TooLow }
    
    print("Pear mobile phone is charging")
    print("Current voltage \(volts)")
  }</pre></div><p>We see that the two <code class="literal">if</code> statements check whether the voltage is, superior to 5.5 volts in the first case, and inferior to 5.5 volts in the second case. Each of these <code class="literal">if</code> statements can throw an error: <code class="literal">TooHigh</code> or <code class="literal">TooLow</code>.</p><p>Now, let's check how the <code class="literal">NoPower</code> error is raised:</p><div><pre class="programlisting">    guard volts &gt; 0 else { throw PearVoltageError.NoPower}</pre></div><p>This statement introduces the new Swift 2 keyword, <code class="literal">guard … else {</code>.</p><p>The <code class="literal">guard</code> statement is like an <code class="literal">if</code> statement. It executes statements depending on the Boolean value of an expression. The condition must be true for the program to continue after the <code class="literal">guard</code> statement. A <code class="literal">guard</code> statement always has an <code class="literal">else</code> clause. The statement in this clause is executed if the expression is not true.</p><p>The <code class="literal">guard</code> statement allows you to perform an early exit when checking conditions.</p><p>Something that I really like about <code class="literal">guard</code> is to be able to use it as follows:</p><div><pre class="programlisting">guard let unwrappedVar = myVar else {
  return
}
print("myVar : \(unwrappedVar)")</pre></div><p>With an earlier version of Swift, you would have written something like this:</p><div><pre class="programlisting">If let unwrappedVar = myVar {
  Print("myVar : \(unwrappedVar"))
}else {
  return
}
//now if you call the print statement below this will not work
//because unwrappedVar is no longer available in this scope.
print("myVar : \(unwrappedVar)")</pre></div><p>So, come back to <a class="indexterm" id="id209"/>our pattern. We have seen that our two mobile phones don't have the same interface, and we now need to create an adapter for each of them, as shown in the following diagram:</p><div><img alt="Implementation of our adaptees" src="img/4852_04_07.jpg"/></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec07"/>Implementation of the SamSingAdapter class</h3></div></div></div><p>In the <a class="indexterm" id="id210"/>preceding diagram, we can now code our new adapter that will be able to work with the SamSing mobile phone as follows:</p><div><pre class="programlisting">import Foundation

class SamSingAdapter: ChargeableProtocol {
  
  var samSingPhone: SamSingMobilePhone!
  
  init(phone: SamSingMobilePhone){
    samSingPhone = phone
  }
  
  func charge(volts: Double) {
    do {
      print("Adapter started")
      _ = try samSingPhone.chargeBattery(volts)
      print("Adapter ended")
    }catch SamSingMobilePhone.VoltageError.TooHigh{
      print("Voltage is too high")
    }catch SamSingMobilePhone.VoltageError.TooLow{
      print("Voltage is too low")
    }catch{
      print("an error occured")
    }
  }
}</pre></div><p>We created a <a class="indexterm" id="id211"/>new <code class="literal">SamSingAdapter</code> class that implements <code class="literal">ChargeableProtocol</code>. We need to provide a <code class="literal">charge</code> method that takes the voltage as an argument.</p><p>We add a constant called <code class="literal">samSingPhone</code> that instantiates a <code class="literal">SamSingMobilePhone()</code> object, which we will use to call its own <code class="literal">chargeBattery</code> method.</p><p>We pass <code class="literal">SamSingMobilePhone</code> as an argument to the constructor of the adapter to get a reference to the mobile that we want to charge. Then, we implement the code of the charge method. (Remember that this is the only method that the client knows.)</p><p>Once again, I want to show you some new things that appear with Swift 2.</p><p>Swift 2 introduces the <code class="literal">do</code>, <code class="literal">try</code>, <code class="literal">catch</code>, and <code class="literal">throw</code> mechanisms. We already discussed the <code class="literal">throw</code> statement when we discovered our two <code class="literal">Adaptee</code> classes.</p><p>A method that has the <code class="literal">throw</code> keyword in its definition is as follows:</p><div><pre class="programlisting">func chargeBattery(volts:Double) throws {</pre></div><p>It must be called using the <code class="literal">try</code> statement, as this is designed to be clear for developers:</p><div><pre class="programlisting">    _ = try samSingPhone.chargeBattery(volts)</pre></div><p>The <code class="literal">_</code> symbol is a wildcard because the <code class="literal">chargeBattery</code> method of the SamSing mobile doesn't return any value (in fact, it returns <code class="literal">Void</code>). It is useless to write such a statement:</p><div><pre class="programlisting">    let myVar = try samSingPhone.chargeBattery(volts)</pre></div><p>Because you want to handle errors that can be thrown by the <code class="literal">chargeBattery</code> method, this statement must be inside a <code class="literal">do { } catch</code> block:</p><div><pre class="programlisting">    do {
      print("Adapter started")
      _ = try samSingPhone.chargeBattery(volts)
      print("Adapter ended")
    }catch SamSingMobilePhone.VoltageError.TooHigh{
      print("Voltage is too high")
}
//…..</pre></div><p>So, in the <code class="literal">do</code> block, you'll <a class="indexterm" id="id212"/>add the called method that might throw an error, and if you want to handle it, you can catch it in the <code class="literal">catch</code> blocks:</p><div><pre class="programlisting">catch SamSingMobilePhone.VoltageError.TooHigh{
      print("Voltage is too high")
    }catch SamSingMobilePhone.VoltageError.TooLow{
      print("Voltage is too low")
    }catch{
      print("an error occured")
    }</pre></div><p>The <code class="literal">catch</code> statement will silence all errors and the code will continue to run. If you want to know more about error handling with Swift 2, I recommend that you check out the following website:</p><p>
<a class="ulink" href="https://www.hackingwithswift.com/new-syntax-swift-2-error-handling-try-catch">https://www.hackingwithswift.com/new-syntax-swift-2-error-handling-try-catch</a>.</p><p>Our <code class="literal">SamSingAdapter</code> class is now ready. We will now do the same with the <code class="literal">PearAdapter</code> class.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec08"/>Implementation of the PearAdapter class</h3></div></div></div><p>We <a class="indexterm" id="id213"/>will proceed in the same way as the <code class="literal">SamSingAdapter</code> class but with the Pear mobile phone:</p><div><pre class="programlisting">import Foundation

class PearAdapter: ChargeableProtocol {
  
  var pearMobilePhone:PearMobilePhone!
  
  init(phone: PearMobilePhone){
    pearMobilePhone = phone
  }
  
  func charge(volts: Double) {
    do {
      print("Adapter started")
      _ = try pearMobilePhone.charge(5.5)
      print("Adapter ended")
    }catch PearMobilePhone.PearVoltageError.TooHigh{
      print("Voltage is too high")
    }catch PearMobilePhone.PearVoltageError.TooLow{
      print("Voltage is too low")
    }catch{
      print("an error occured")
    }
  }
}</pre></div><p>Here, the main <a class="indexterm" id="id214"/>differences are that we now have a reference to a <code class="literal">PearMobilePhone</code> object and our <code class="literal">charge</code> method (that implements <code class="literal">ChargeableProtocol</code>) calls the <code class="literal">pearMobilePhone.charge</code> method.</p><p>We also need to manage the voltage sent to the phone. An adapter must transform any value to conform to the interface of the adaptee. If we send a very high voltage, our mobile phone will burn and our customers will stop buying our products. So, in our adapter, we set the voltage value sent to the Pear mobile phone to 5.5 volts.</p><p>We also catch all the errors that can be thrown by the <code class="literal">charge</code> method of the <code class="literal">pearMobilePhone</code> object.</p><div><div><h3 class="title"><a id="note14"/>Note</h3><p>Swift 2 requires an exhaustive <code class="literal">try</code>/<code class="literal">catch</code> error handling. The last <code class="literal">catch</code> statement is our default catch-all block.</p></div></div><p>As we have set the value to 5.5 volts, which is the only voltage accepted by the Pear mobile phone, we will never raise an error, so it is quiet unreadable to have so many catch blocks.</p><p>Well, Apple proposes an alternative to you. You can write our adapter like this:</p><div><pre class="programlisting">  func charge(volts: Double) {
      print("Adapter started")
      _ = try! pearMobilePhone.charge(5.5)
      print("Adapter ended")
  }</pre></div><p>The <code class="literal">try!</code> method allows you to avoid using <code class="literal">do</code>/<code class="literal">catch</code> because you are promising that the call will never fail.</p><p>We have our universal charger, already ready, two adapters, and two mobile phones to test our charger. Remember that our charger provides 10 volts by default.</p><p>Let's write our simple test program in the <code class="literal">main.swift</code> file:</p><div><pre class="programlisting">import Foundation

print("*** start test program")
// Create our Charger
let charger = Charger()
print("*** charger ready test program")

//Test 1
//Charge a Pear Mobile Phone
print("Will charge a Pear Mobile Phone")
//1 mobile and adapter creation
let pearPhone = PearMobilePhone()
let pearAdapter = PearAdapter(phone: pearPhone)
//we plug the portable to our charger through the adapter
charger.plugMobilePhone(pearAdapter)

print("*** -")
//Test 2
//Charge a SamSing Mobile Phone
print("Will charge a SamSing Mobile Phone")
//1 mobile and adapter creation
let samSingPhone = SamSingMobilePhone()
let samSingAdapter = SamSingAdapter(phone: samSingPhone)
//we plug the portable to our charger through the adapter
charger.plugMobilePhone(samSingAdapter)

print("*** end test program")</pre></div><p>I don't think that<a class="indexterm" id="id215"/> I need to provide you with more details as the complete code is mentioned here. We prepare our charger, take the first phone, use an appropriate adapter, and then plug the adapter (which is plugged in to our phone too) to the charger. We do the same with the second phone.</p><p>Let's run the code and check our result:</p><div><img alt="Implementation of the PearAdapter class" src="img/4582_04_08.jpg"/></div><p>Well, it doesn't <a class="indexterm" id="id216"/>matter what the mobile is; using our appropriate adapter, by default, the charger will send 10 volts, to the adapter, then the adapter will transform this voltage (or not) and call the appropriate charge method on the phone itself.</p><p>This concludes the discovery of the adapter pattern.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec23"/>The facade pattern</h1></div></div></div><p>The<a class="indexterm" id="id217"/> facade pattern<a class="indexterm" id="id218"/> is a simple pattern used to group the interfaces of a group of objects and a unified interface that is easier to use by a client.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec85"/>Roles</h2></div></div></div><p>The<a class="indexterm" id="id219"/> facade pattern allows you to provide the operations that might be desirable by a user. The pattern encapsulates the interface of each object that is considered as a low-level interface. To construct the unified interface, we might need to implement some methods<a class="indexterm" id="id220"/> that will compose the low-level interfaces:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It must be used to provide a simple interface of a complex system. The architecture of the system can be composed of several small classes that allow great modularity, but clients don't need such properties. They only need something simple that meets to their needs.</li><li class="listitem" style="list-style-type: disc">It can be used to divide the system into subsystems. The façade will be an interface that allows the communication between subsystems.</li><li class="listitem" style="list-style-type: disc">It can <a class="indexterm" id="id221"/>be also used to encapsulate the implementation of a system toward an external consumer.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec86"/>Design</h2></div></div></div><p>The<a class="indexterm" id="id222"/> facade pattern is designed to hide the complexity of a system. Its interface can be entirely new. It must not conform to the existing interface. We can provide several facades to the same system depending on the end user that we have and the functionality that we want to provide to the facade:</p><div><img alt="Design" src="img/4852_04_09.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec87"/>Participants</h2></div></div></div><p>The<a class="indexterm" id="id223"/> participants of this pattern are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Facade and its interface are the abstract parts of the system that are exposed to the clients. This class has some references to classes and components that are part of the system, and they have their methods used by the facade to implement the unified interface.</li><li class="listitem" style="list-style-type: disc">The<a class="indexterm" id="id224"/> classes and components of the system implement the functionalities of the system and answer requests coming from the facade. They do not need the facade to be able to work.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec88"/>Collaboration</h2></div></div></div><p>Clients <a class="indexterm" id="id225"/>communicate with the system through the facade façade. Then, the façade itself invokes classes and components of the system. The facade doesn't only send requests to classes and components of the subsystem. It must also adapt its own interface to the objects and components interfaces, using a specific code to allow communication of objects.</p><p>The following sequence diagram describes this case:</p><div><img alt="Collaboration" src="img/4852_04_10.jpg"/></div><p>Clients using the facade should not directly access the objects of the system.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec89"/>Illustration</h2></div></div></div><p>We <a class="indexterm" id="id226"/>want to provide a simple interface to provide our clients with an easy way to find hotels near an input address and corresponding to some criteria (such as the number of stars.)</p><p>In our company, we have a subsystem that provides a catalog of hotels that includes their locations and number of stars for each of them.</p><p>We already <a class="indexterm" id="id227"/>have a FindPoi Webservice that can search for a hotel near a location point (latitude and longitude), which uses some criteria: the maximum distance to search and the numbers of stars we want.</p><p>As you can see, the service needs a location point, which means that we pass an object with a latitude and longitude.</p><p>As the consumer of our facade will only tell us its real address, we need services that will geocode the address to a GPS point with a latitude and longitude.</p><p>The sequence diagram shows you what we will do to provide our simplified interface:</p><div><img alt="Illustration" src="img/4852_04_11.jpg"/></div><p>Open the Xcode project called <code class="literal">FacadePattern</code> and the <code class="literal">main.swift</code> file. This file represents a client that will consume our facade.</p><p>Our facade is, in fact, a service that allows a client to search for a hotel near the location that is sent as an input that has two criteria: <code class="literal">distanceMax</code> and number of stars for the hotel.</p><p>This is how the service will be called:</p><div><pre class="programlisting">var results = svcFacadeFindHotel.findHotel(myAdress, distanceMax: 2.0, stars: 4)</pre></div><p>The complete code of the client is as follows:</p><div><pre class="programlisting">import Foundation


//I am a consumer of the service
// my addess is
// 1 infinite Loop
// Cupertino, CA 95014

let svcFacadeFindHotel = ServiceFindHotelNearBy()

let myAdress = " 1 Infinite Loop Cupertino, CA 95014 USA"
var results = svcFacadeFindHotel.findHotel(myAdress, distanceMax: 2.0, stars: 4)

print("*** RESULTS ")
print("Their is \(results?.count) results :")

if let results = results {
  for var h in results{
    print("Hotel latitude:\(h.location.latitude) longitude:\(h.location.longitude), stars: \(h.stars)")
  }
}</pre></div><p>We open a <a class="indexterm" id="id228"/>connection for our <code class="literal">ServiceFindHotelNearBy</code> service. We tell what our current address is and then display the results if any. Here, we have 125 results (from 1,000 generated in the <code class="literal">HotelCatalog</code> object):</p><div><img alt="Illustration" src="img/4582_04_12.jpg"/></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec09"/>Implementation of the facade</h3></div></div></div><p>Based <a class="indexterm" id="id229"/>on the sequence diagram and method of the service consumed by the client, the facade called <code class="literal">ServiceFindHotelNearBy</code> in our sample project will have the following code:</p><div><pre class="programlisting">import Foundation

class ServiceFindHotelNearBy: ServiceFindHotelNearByProtocol {
  
  //return a list of hotel that corresponds to our criteria
  func findHotel(from: String, distanceMax: Double, stars: Int) -&gt; [Hotel]? {
      let svcGeocoding = Geocoding()
      let svcFindPoi = FindPoi()
      let systemhotelCatalog = HotelCatalog()
    
      //Geocode our adress to GPS Points
      let fromLocation = svcGeocoding.getGeocoordinates(from)
    
      //retrieve all hotels in the catalog
      let allHotels = systemhotelCatalog.getCatalog()
    
      //find POI that corresponds to our criteria
      let results = svcFindPoi.findPoiNearBy(fromLocation, distanceMax: distanceMax, stars: stars, catalog: allHotels)
    return results
  }
}</pre></div><p>The facade is <a class="indexterm" id="id230"/>well-described as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First, we make a connection to all the needed systems: the <code class="literal">Geocoding</code>, <code class="literal">FindPoi</code>, and <code class="literal">SystemHotelCatalog</code> Webservices (our subsystems).</li><li class="listitem" style="list-style-type: disc">Then, we orchestrate our calls based on the sequence diagram.</li><li class="listitem" style="list-style-type: disc">We first geocode the address into a GPS point.</li><li class="listitem" style="list-style-type: disc">Then, we get <code class="literal">allHotels</code> from the <code class="literal">systemHotelCatalog</code> object (which represent a subsystem) because we need to send it as an argument to the <code class="literal">FindPoi</code> service.</li><li class="listitem" style="list-style-type: disc">This is what we need to do in our next statement. We need to pass the <code class="literal">distanceMax</code> value, number of stars value, and GPS point we just geocoded as arguments of the <code class="literal">findPoiNearBy</code> method of the <code class="literal">FindPoi</code> service.</li><li class="listitem" style="list-style-type: disc">Then, we return the results to the client.</li></ul></div><p>As you can see, the facade has encapsulated all the needed calls to the subsystem, hiding the complexity of retrieving hotels corresponding to the wishes of the client. This concludes the description of the facade pattern.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec24"/>Summary</h1></div></div></div><p>This chapter concludes the discovery of the seven structural patterns. The adapter pattern has much more in common with the bridge pattern. The main difference is in the purpose of the pattern.</p><p>A bridge separates an interface and its implementation, whereas an adapter changes the interface of an existing object.</p><p>The decorator adds a functionality to an object without changing its interface and should be transparent to the application. For the adapter, this is not the case, it is not transparent from the client perspective: the adapter is the named implementation of the interface that a client sees, so the adapter is not hidden from the client.</p><p>The proxy pattern doesn't change any interface. It defines substitute objects for other objects.</p><p>The facade pattern transforms high-level requests into low-level requests by communicating with other subsystems. It hides the complexity of these subsystems by providing a simple interface that the client can see.</p><p>In the next chapter, we will start with our first three behavioral patterns: the <code class="literal">Strategy</code>, <code class="literal">State</code>, and <code class="literal">Template</code> methods.</p></div></body></html>