- en: Chapter 5. Advanced Augmented Reality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a lot of possibilities for delivering augmented reality experiences.
    In this chapter, we will discuss a lot of the advanced features that are available
    when using Vuforia with Unity. We will do that while developing a small arcade
    augmented reality game. The game is a classic arcade game, with an augmented reality
    twist that will make it feel fresh. We will be making an augmented reality whack
    a mole game.
  prefs: []
  type: TYPE_NORMAL
- en: Augmented reality games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lot of developers misunderstand the value of augmented reality games. Many
    view AR games as unprofitable and marginalized due to the fact that most, if not
    all, AR games cannot go viral and tend to not sell. This might be true due to
    the fact that AR games tend to require motion, a trackable, or both, like in the
    game we will now make. Those requirements make the game not playable at any time
    by the user, but what a lot of people tend to overlook is that it is ok for AR
    games not to go viral.
  prefs: []
  type: TYPE_NORMAL
- en: 'AR games, while not going to spawn the next Angry Birds, can deliver a unique
    experience for a specific purpose. For example, AR games can be used quite effectively
    for promotion games. The game can trigger on a promotion flyer or a page in the
    magazine and then a competitive game spawns up with a chance to win a real prize,
    for example. This insures that the user received a positive experience in the
    form of a fresh AR game, and at the same time, we are sure the user viewed the
    promotion and joined a competition. AR games can also be used in exhibitions or
    stores for many uses: promotional or pure entertainment.'
  prefs: []
  type: TYPE_NORMAL
- en: Unity as a game engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Surely Unity makes making AR apps easier and deployable to multiple platforms,
    but that is not where its true power comes from. Unity is first and foremost a
    very powerful modern game engine. It is used to power some of the industry's known
    games, both on mobile and PC. Not utilizing that kind of power to deliver very
    fresh AR experiences is inexcusable, because it is quite easy to understand how
    the engine works.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will go over some of the elements in Unity that allow the
    making of simple games. We will go over how to add audio effects to the game,
    how to animate objects, how to set the world's physics, how to control particle
    effects, and how to factor in user interactions. Hopefully that will be enough
    to display how effective it is to build an AR game in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we can start a new Unity project for the Whack-A-Mole game that we are
    creating. Like we did previously in the book, we set up Unity''s environment for
    the AR app. The following are the steps again:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the value of **Platform** to **IOS** from the **Build Settings** under
    the **File** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import Vuforia Unity package by navigating to **Import Package** | **Assets**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the `exampleDataset.unitypackage` file that we used previously in [Chapter
    3](ch03.html "Chapter 3. Understanding Vuforia"), *Understanding Vuforia*, that
    contains the dataset for trackables. They are available in this chapter's assets
    too.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add **ARCamera** and **ImageTarget** prefabs from the **Qualcomm Augmented reality**
    prefab folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **ImageTarget** to use the dataset we have imported, and set it to use
    **Chips** target from the **Inspector**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **ARCamera** to load our dataset and activate it as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the scene to the **Assets** folder, and name it `Level`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows created the project for our Whack-A-Mole game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the environment](img/0032OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We should end up with similar settings for the environment, as shown in the
    preceding screenshot. Now it is ready for us to start adding the elements that
    will make up our game.
  prefs: []
  type: TYPE_NORMAL
- en: The Whack-A-Mole game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will go over the design of the game we are making. It is
    a simple Whack-A-Mole game with a twist. Over our target, we want to render a
    ground filled with mole holes, where the moles will pop up and down randomly from
    them. The user will be able to shoot balls at the moles from the device to the
    target; if a ball hits a mole, we will make the mole disappear with a sound effect
    and spawn a particle effect.
  prefs: []
  type: TYPE_NORMAL
- en: There will be no score system or a way to actually clear the level. We will
    just have this game as a demonstration of how games are made for AR in a simple
    way. All assets used in this game are available in the `Assets` folder in the
    code bundle of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the ground for moles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing we need to do is to create the ground level from which moles
    will pop up. We need to create a plane that will be layered right on top of the
    trackable with a ground texture attached to it.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a plane from the **GameObject** menu. Choose **Create other** and
    click **Plane**. This will create a plane in the scene. Make sure the plane we
    created has the same position as the trackable; both should be at the global origin,
    which is at (0, 0, 0).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, resize the plane like we have done before by clicking on the **Resize**
    button at the top-left toolbar. Resize the plane so that its width exactly covers
    the trackable. The height of the plane most likely will be bigger than the trackable,
    but that is all right as long as the trackable is completely covered in the scene.
    The following screenshot shows the Z-Buffer distortion:![Creating the ground for
    moles](img/0032OS_05_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We might have noticed that the distortion that is happening between the trackable
    and the plane we just added. This is because both the trackable and the plane
    have the exact same position in the y axis. The engine doesn't know which one
    to render on top of the other, and something called **Z-Buffer conflict** happens,
    where the engine keeps on alternating between the components to be rendered on
    the top. The solution is to simply adjust the plane's y axis position to be slightly
    above that of the trackable.
  prefs: []
  type: TYPE_NORMAL
- en: Name the plane `Ground`, and attach it to the trackable by dragging-and-dropping
    it from the **Hierarchy** list to **ImageTarget**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that the ground plane is in place, the first thing we will get the urge
    to do is to lose that plain white texture that is there by default on the plane.
    We would want it to look like an actual ground, so we will create a material for
    it. Materials for Unity are components that carry the information of what is the
    texture of the object and what shader is used to render it. It is very important
    and used extensively for almost every object in any scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, create two folders in the **Assets** folder of our project from Unity.
    Name one `Textures`; this is where we will keep the texture images of our materials,
    and the other `Materials`; this is where we are going to create our materials.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now drag-and-drop the file named **Ground.jpg** into the **Textures** folder
    we just created. We could also add the asset through the **Assets** menu, like
    we saw before. This just added the texture image for the ground to our project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's create the material; inside the **Materials** folder we just created,
    from the **Assets** menu, choose **Material**. This creates a new material that
    we will name as `Ground`. Now attach the **Ground** material we created to the
    ground plane. Do this by simply dragging the material and dropping it on **Ground**
    plane in the **Hierarchy** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice that the plane stays white as it was before; this is because we haven''t
    attached the texture yet to the material. To do that, access the material we just
    added to the **Ground** plane by selecting the **Ground** plane and from the **Inspector**;
    here we will find the **Material** we assigned. There is a small **Texture** property
    under **Material**, drag-and-drop the texture we added earlier to this box. The
    following screenshot shows the **Ground** material attached:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the ground for moles](img/0032OS_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now we have an ok looking ground for our moles. Notice that the shader for the
    material is **Diffuse**. This type of shader is suitable for opaque materials
    and works perfectly fine for the ground texture. Later on, we can use different
    shaders for different materials to achieve different results, such as the transparency
    or particle shader.
  prefs: []
  type: TYPE_NORMAL
- en: The Whack-A-Mole model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the ground to build on, it is time to add our mole model to
    the project. Simply create a folder in the **Assets** folder, and name it `Models`.
    Drag-and-drop the file from the chapter assets named `WhackAMoleModel.fbx`. Unity
    will automatically import the model into the project and will create a prefab
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: Like we have done before, drag-and-drop the prefab created for `WhackAMoleModel`
    into our scene. You might not automatically see where the model was added; this
    is mainly because the model is too small in comparison to the ground plane. If
    you focus on the model by holding the *F* key, you will see how small the model
    is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: To change that, we can scale the model using the same way we did before, which
    is to scale it from the editor, or we can change the FBX Converter settings. The
    FBX Converter settings handle how the model is inserted into our scene through
    many settings specific to the model. If we are to scale the model in the editor,
    it will naturally not have a 1:1 ratio between the model and the world. This is
    done in real time, takes up resources, and makes scripting more confusing and
    frustrating. It is recommend to scale objects from their model settings.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the model's prefab in the folder, and the **Inspector** will display
    the **FBX Converter** settings. There is a setting for **Scale Factor**, that
    is by default set to a very small value, which is **0.01**. This is how big the
    model is to be inserted to the scene compared to its original scale from the 3D
    modeling application. Change this setting to **0.7**, and click on **Apply**.
    The model will resize automatically in the scene without changing the scale transform
    in the scene itself. The following screenshot shows `WhackAMoleModel` scaled and
    positioned in the middle:![The Whack-A-Mole model](img/0032OS_05_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position the model exactly at the center of the ground and to be on top of the
    ground correctly. After that, attach the **WhackAMoleModel** object to the **ImageTarget**
    in the **Hierarchy** to set the **ImageTarget** as its parent object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding colliders to the scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unity simulates physics for the objects in the game, but only when we specify
    what is being simulated and how. The reason for this is that in most games, not
    every single object is simulated by physics. For example, not every wall in every
    game is breakable. There are static objects that are just there simply defying
    physics, but for games, that is quite all right.
  prefs: []
  type: TYPE_NORMAL
- en: '**Collider** is a component that we can attach to any object in the scene that
    makes this object "collidable" with any other collidable object. For example,
    if we are making a shooting game such as *Call of Duty* or the likes of it, if
    we do not attach a collider to all walls in our game, the game character will
    be able to simple "walk through" the wall. This is, of course, not desirable.'
  prefs: []
  type: TYPE_NORMAL
- en: For our game, we need to be able to "whack" the mole; if there is no collider
    on the mole, we certainly won't be able to whack it. Also, the balls that we will
    be shooting at the moles need to be able to collide with the ground, not just
    pass through it. All of this is possible with colliders.
  prefs: []
  type: TYPE_NORMAL
- en: First, select the **WhackAMoleModel** from the scene, and expand it to reveal
    the **MoleHill** and the character. Those are the two components to which we need
    to add the colliders. First, select the character from the scene, and select **Box
    Collider** by navigating to **Component** | **Physics**. This will add a collider
    with the shape of a box around the character. The box won't be exactly wrapping
    the character, but it is cheap on resources, and is enough in our case to simulate
    a good collision with the balls that we will fire at the moles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, select the **MoleHill**; the **MoleHill** is irregular in shape, and we
    need the ball collision with it to be simulated more effectively than what a box
    collider can do. This is why we need to use a Mesh collider. From the same previous
    menu, now choose **Mesh Collider** to be added to the **MoleHill** model. What
    the **Mesh Collider** does is that it adds a collider that is exactly the same
    shape as the model on top of it, so it simulates the collision exactly the same
    as the model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows colliders added to the **Mole** model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding colliders to the scene](img/0032OS_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the ground already has a collider added to it. That is because,
    by default, any primitive object created in the editor has a collider attached
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the ball for the ball gun
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the general feeling of the game being set, we need to create
    the gun's projectile. It is understandable that because it's a ball gun, it will
    just shoot spheres, which we can create through a script. But before we can do
    that, we need a role model for the script to clone and create in the scene. So,
    the next thing we will work on is creating the basis for the gun's projectile
    prefab.
  prefs: []
  type: TYPE_NORMAL
- en: Select **ARCamera** from the **Hierarchy** panel, and then from the **GameObject**
    menu navigate to **Create** | **Other** | **Sphere**. This will create a sphere
    where **ARCamera** is; however, it will not parent it to the camera. It is particularly
    useful when creating objects at the position of other objects. Change the name
    of the sphere we just created to `Ball`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, the main idea is to have the projectile occupy at least half the camera's
    view and be at the center of it to give the user a sense of immersion while shooting
    the balls at the moles. This is easily achievable with everything we know. Simply
    position the ball directly in front of the camera and resize it till you feel
    its size is appropriate to the camera. We can check how big it will look like
    if we look at the **Game** panel in the editor or **Camera Preview** at the bottom-right
    corner of the **Scene** panel when selecting the camera.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the position and scale is right, create a material in the **Materials**
    folder, and name it `ball`. When selecting this material, in the Inspector you
    will notice a color box that is by default set to **white**. For the ball, we
    do not need a texture like we did for the ground, but rather, just a color that
    will make it contrast over the environment. So, just set the color box to red,
    and then attach the material to the ball. The following screenshot shows the **Ball**
    projectile in the **Scene** panel:![Creating the ball for the ball gun](img/0032OS_05_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that the ball already has a collider by default, which will come in handy
    when we want the ball to actually collide with the moles and the ground.
  prefs: []
  type: TYPE_NORMAL
- en: There is one fundamental thing to point out; adding a collider to the object
    doesn't make it simulated by physics in the engine, it only makes it collidable
    with other colliders. But of course, we want the projectile to act like a real
    projectile and respond to gravity and forces. We want the projectile to bounce
    off of the floor and off of the moles in a natural way. This is easily simulated
    in Unity, but we need to tell Unity what to simulate and how.
  prefs: []
  type: TYPE_NORMAL
- en: Select the **ball** object from the **Hierarchy** panel, and from **Components**
    menu, go to **Physics**, and select **Rigidbody**. This adds a Rigidbody component
    to the ball. What the Rigidbody component does is that it simulates physics on
    the object it is attached to as if the object is a rigid body in the real world.
    It simulates gravity, bounce, external forces, and everything to which you would
    expect a real-world rigid body be subjected to, such as an air drag.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the Rigidbody component is set to simulate gravity on the object.
    We do not need to change any settings in Rigidbody because they all suit us for
    now. Simply click the Play button, and we will immediately see the ball falling
    down in the game world under the effect of gravity.
  prefs: []
  type: TYPE_NORMAL
- en: Setting global gravity settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We might have noticed that the ball was falling a little too slow for it to
    feel natural for the game. This is mainly because our scale is not 1:1 with the
    game. It is rather 1:1 with the real world. This is because it is an AR application,
    and the concern is for it to feel natural with the real-world interaction. This,
    however, makes us all giants in comparison to the game world when using the AR
    game. So, it's not that the ball that is falling too slow, a bit of Einstein's
    relativity coming, it's that the ball that is falling a great distance in relation
    to us.
  prefs: []
  type: TYPE_NORMAL
- en: To remedy that, we need to bring up the force of gravity to compensate for the
    giant status in which we are located. If the gravity is stronger, the ball will
    fall faster and will give us the feeling that it is natural for our own real world.
    Luckily, changing the gravity setting in a Unity project is quite simple.
  prefs: []
  type: TYPE_NORMAL
- en: From the **Edit** menu, go to **Project** settings, and select **Physics**.
    In the **Inspector**, we will be presented with a number of settings all related
    to how physics works. We can change any of them, but we only need one changed
    for now. The first setting is related to gravity. Gravity in the real world acts
    on the y axis and is roughly -9.81 in magnitude. We need this to be 6 times stronger,
    so change it to `-60.81`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Run button, and watch the ball fall much faster and in a more natural
    manner. The following screenshot shows the gravity settings for the project:![Setting
    global gravity settings](img/0032OS_05_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This should take care of the physics compensation value and should work naturally
    in the real world in an AR environment.
  prefs: []
  type: TYPE_NORMAL
- en: Adding audio sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now need to create sound sources in the scene to handle sound effects for
    the game. **Sound sources** are audio sources that can be position in the world
    for 3D positional sound or simple 2D sounds. In order to hear sound effects in
    the game, audio sources are needed to produce the sound, but also we need a listener
    to actually capture the created sound to present to the user.
  prefs: []
  type: TYPE_NORMAL
- en: By default, **ARCamera** has a listener component added to it, so we only need
    to add the audio sources to it.
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder and name it `Audio` in the **Assets** folder. Drag-and-drop
    the two files inside the **Audio** folder in the chapter's assets. This will import
    the two audio files named `ballFire.wav` and `moleHit.wav`. We will use the first
    for the sound effect of firing the ball from the gun, and the second for when
    a ball hits a mole.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because this is an arcade game, we do not need 3D sound positions; we mostly
    need all audio to be 2D and independent of how far or close we are to the sound
    source. We do this by changing the setting for the audio assets, which we just
    imported, in the Inspector.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the audio file from the **Audio** folder, and from the **Inspector**
    uncheck the checkbox named **3D Sound**. Do the same for both files. The following
    screenshot shows the audio settings for the audio files:![Adding audio sources](img/0032OS_05_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, select **ARCamera**, and then from the **GameObject** menu, select **Create
    Empty**. What this does is it creates an empty object in the world and near **ARCamera**.
    Now, rename the object to `ballFireAudio`. Now, select the object we have just
    created, and from the **Component** menu, navigate to **Audio** | **Audio source**.
    Repeat the same steps to create `moleHitAudio`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag-and-drop the audio file from the **Audio** folder appropriately into the
    audio source component we have just created. This effectively creates sound sources
    in our scene. Just uncheck the checkbox named **Play on Awake**, because we need
    to control this audio source through code. It is a useful option to test how the
    sound source will play out in the game panel though. The following screenshot
    shows sound source settings for **ballFireAudio**:![Adding audio sources](img/0032OS_05_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that the sound sources are in place, we can easily call on them from script
    to add to the immersion of the app.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting the ball gun
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already created the projectile for the gun, and we also created the
    sound source for it, but we are yet to make this act like a ball gun; this is
    when scripting comes in handy.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to do is to create a prefab for the projectile we created.
    This is to be able to clone the projectile through the script and fire it at the
    poor moles. To do that, simply create a folder in the **Assets** folder, and name
    it `Prefabs`. Drag-and-drop the **Ball** object from the **Hierarchy** panel to
    the folder you just created. Now we have a prefab that we can call upon through
    code and can create as many balls as we want.
  prefs: []
  type: TYPE_NORMAL
- en: The ball we have attached to the camera is meaningless, because we will be creating
    the projectiles through code. So, after we have already made a prefab of the ball,
    we no longer need it in the scene, but before we remove that, there is another
    step. We need to have a placeholder from which the projectiles spawn. That placeholder
    should be in the same position and with the same rotation as the ball we have
    in the scene right now.
  prefs: []
  type: TYPE_NORMAL
- en: First, we add an empty object to the scene from the **GameObject** menu. Now,
    attach that object to the **ARCamera** object by dragging-and-dropping it. Rename
    that object to `BallPlaceHolder`. We need the `BallPlaceHolder` object to have
    the exact same transformation as that of the **Ball** object. Unfortunately, there
    is no automatic function in Unity that copies the transformation for two objects,
    so we need to manually copy it. Click the **Ball** object and copy both the position
    and rotation of that object, and insert them into the `BallPlaceHolder` object.
    Then, delete the **Ball** object, because we no longer need it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows **BallPlaceHolder** added to the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scripting the ball gun](img/0032OS_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, it is time to create a folder for our scripts. Create a new folder in **Assets**,
    and rename it **Scripts**. Inside the **Scripts** folder, from **Assets** menu,
    navigate to **Create** | **C# Script**. Name the created file `ballGun`. Now,
    double-click on it, and Unity will automatically open its MonoDevelop Editor for
    us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the Unity MonoDevelop Editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scripting the ball gun](img/0032OS_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Unity automatically creates a number of things for us in the MonoDevelop Editor.
    First, it creates a class template with the name of the script file. This is why
    the script filename must be that of the class name, among other reasons. It adds
    two empty functions for us that are very crucial to game development on the platform.
  prefs: []
  type: TYPE_NORMAL
- en: The `Start()` function is a function that is called automatically by Unity engine
    when the scene starts. It is very useful for variable initialization, and can
    be thought of as the constructor for the class.
  prefs: []
  type: TYPE_NORMAL
- en: The `Update()` function is a very important function that Unity automatically
    calls on every frame that passes in the game. This is very important for keeping
    track of the game object state, maintaining game logic, and many other uses. It
    is strongly advised not to have intensive calculations inside the `Update()` function,
    because it will slow down the frame rates of the game, because Unity doesn't render
    the next frame till all `Update()` functions in the game are executed completely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the script after the code has been added to it and see
    what every function does. The following screenshot shows the `ballGun.cs` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scripting the ball gun](img/0032OS_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is how the script that will control the behavior of the ball gun appears.
    We will be attaching this script to the `ARCamera` object, and it will respond
    to user's touch anywhere on the screen to fire a ball directly toward where the
    user is pointing the camera. Let's see what every function does in this script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first things we see are the declared variables for the script. They follow
    a similar syntax to what you would expect from a C# language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `public` or `private` status of the variable is very important in Unity.
    This is because `public` variables appear in the Editor, and their values can
    be set in the **Inspector**. This is particularly useful and should be kept in
    mind.
  prefs: []
  type: TYPE_NORMAL
- en: The `projectile` variable is what we will use from which to link to the **Ball**
    prefab. It is `public`, because we will set its value from the Editor, as we will
    see in a little while. `projectile` is of type `GameObject`, which is the general
    type for any object in the game. It contains a large number of relevant functions
    and variables that often come in handy. wer sadfas
  prefs: []
  type: TYPE_NORMAL
- en: The variable `projectilePlaceHolder` is of type `Transform`. It will hold the
    transform information of the `BallPlaceHolder` object we have in the scene on
    which to spawn projectiles.
  prefs: []
  type: TYPE_NORMAL
- en: For the variable `ballFireAudio`, as its name suggests, we will be using this
    to link to the audio source object we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Trackable` variable will be used to link to the `ImageTarget` object.
    We will use it to parent the spawned projectiles to it. We will do that to allow
    the balls to disappear if `Trackable` is lost from sight:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how our `Start()` function looks like. In this function, we are initializing
    both `ballFireAudio` and `Trackable` variables. We do that by finding the `GameObject`
    from the scene and attaching it to the variable. Notice that we find the `GameObject`
    by its name; if the name is different, change it accordingly, or the variable
    will not be initialized correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is our `Update()` function that will be called with every frame. It mainly
    listens for user interaction; if the user touches the screen or clicks with the
    mouse, a **Ball** prefab is instantiated and a force is applied on it to propel
    it forward with a sound effect. Repeated clicks or touches will spawn more balls.
  prefs: []
  type: TYPE_NORMAL
- en: What `Input.GetMouseButtonDown(0)` does is that it returns `true` if the user
    clicks with the mouse or touches the screen. This is how we listen if the user
    interacted with the screen. If it is `true`, we proceed with our game logic.
  prefs: []
  type: TYPE_NORMAL
- en: We first play the audio attached to the game object `ballFireAudio` to play
    the sound effect for ball shooting.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we instantiate a new clone from the prefab **Ball** attached to a projectile
    variable. We instantiate it into the variable `obj` with the transform of the
    `projectilePlaceHolder` position and the rotation of the camera so that it always
    fires forward.
  prefs: []
  type: TYPE_NORMAL
- en: We then apply the relative force to the instantiated object's `Rigidbody` component
    to fire forward. The direction is `Vector3.forward`, which is the object's forward
    direction. We multiply it by `Time.deltaTime`; we do this to make the force frame
    rate independent (`Time.deltaTime` is the time since the last frame). This avoids
    making the ball slower if the frame rate drops down for any reason. Then we multiply
    by the force's power. Notice that the force is really big; this is because we
    need the ball to fire forward quickly and to also compensate for the ratio between
    the game world and the real world as we saw with gravity.
  prefs: []
  type: TYPE_NORMAL
- en: We then parent the instantiated object to `ImageTarget` so that it behaves correctly
    with the image target.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we destroy the object with a delay of 5 seconds. We do that because
    we do not ever want projectiles to disappear, as this will really deteriorate
    the performance of the app.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our script is ready, we need to attach it to the **ARCamera** object.
    Do this by dragging the script and dropping it on the **ARCamera** object. The
    script component will appear in **ARCamera** and we will notice that the two public
    variables **Projectile** and **Projectile Place Holder** are visible in the **Inspector**`.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need to drag-and-drop the **Ball** prefab from the **Prefabs** folder
    to the **Projectile** variable in the **Inspector**. We also need to drag-and-drop
    the **BallPlaceHolder** object from the scene to the variable **Projectile Place
    Holder** variable in the **Inspector**. The following shows **ARCamera** with
    the `ballGun.cs` script attached:![Scripting the ball gun](img/0032OS_05_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that our script is attached correctly to our **ARCamera** object, we can
    now try it out in the **Game** view. Click on Run and the click over the panel.
    The camera will shoot out balls. The following screenshot shows the `ballGun.cs`
    script in action:![Scripting the ball gun](img/0032OS_05_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On testing the script, we might notice that the balls are a little too small
    in comparison to the mole. We can change that through the **Ball** prefab direction
    from the **Prefabs** folder. Select it, and then change the scale value for (x,
    y, z) to `20`. This is a prime example of how useful prefabs are when doing changes,
    because it automatically propagates it for the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Vuforia trackable event handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More often than not, we need to attach a certain behavior that triggers when
    a trackable is found. To do this, we must understand how to keep a track of trackable
    events, such as trackable found or trackable lost. Vuforia makes this easy for
    us by providing a template script named `DefaultTrackableEventHandler`. This script
    is by default attached to any **ImageTarget** prefab. It should be there now in
    our **ImageTarget** object in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: What the script does is it handles the event of a trackable found or a trackable
    lost. It is the script responsible for rendering the 3D content when the trackable
    is found, and making it disappear when it is lost as well. It is important to
    notice that it is however not responsible for the perspective or the **ARCamera**
    position on the trackable, this is handled by another script , which is beyond
    our scope.
  prefs: []
  type: TYPE_NORMAL
- en: Vuforia recommends that we create our own trackable event handler scripts using
    the `DefaultTrackableEventHandler` script as a template. This is exactly what
    we will do now by adding a very small function to the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the script named `DefaultTrackableEventHandler`, which can be found inside
    the `Scripts` folder under the `Qualcomm Augmented reality` folder. It should
    look similar to the following screenshot, where the `DefaultTrackableEventHandler.cs`
    script is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Vuforia trackable event handler](img/0032OS_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following three functions are important to understand from this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnTrackableStateChanged`: This function is called every time the state of
    the trackable is changed, whether it is found or lost. It then determines if it
    is detected or lost, and appropriately calls on the event function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnTrackingFound`: This is the function that is called when the trackable is
    found. It is responsible for rendering all the children of the `ImageTarget` object
    and switching on their colliders.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnTrackingLost`: This function is called when the trackable is lost. It is
    responsible for turning off the rendering for all the child objects of `ImageTarget`.
    It also turns off the collider for them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are the three crucial functions in the script. We will leave them as they
    are for our app, but for one modification. We need to add a new function that
    returns the status of the trackable to tell us whether the trackable is detected
    or not. This will be useful for us when animating the mole character, as we will
    see in a little while.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new C# script in the `Scripts` folder and name it `MoleTrackableEventHandler`.
    Now copy all the code from the script `DefaultTrackableEventHandler` and paste
    it inside the script we just created. It is important to change the class name
    from `DefaultTrackableEventHandler` to `MoleTrackableEventHandler`, else errors
    will appear in Unity due to the fact that the class name is not the same as the
    filename.
  prefs: []
  type: TYPE_NORMAL
- en: 'After modification, the script will look similar to the following screenshot,
    where the `MoleTrackableEventHandler.cs` script is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Vuforia trackable event handler](img/0032OS_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We added the variable `TrackableStatus`, which we want to hold the state of
    the trackable. It will be `true` if it is visible, and `false` if not. We then
    created a function and named it `trackableVisible`, which will return the variable
    `TrackableStatus`.
  prefs: []
  type: TYPE_NORMAL
- en: We then simply set the `TrackableStatus` to `true` when found and `false` when
    not found inside the function `OnTrackableStateChanged()`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we call on the function `trackableVisible()`; it will effectively tell
    us if the trackable is visible or not.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to attach the `MoleTrackableEventHandler` to the `ImageTarget`
    object in our scene. We now do not need `DefaultTrackableEventHandler` attached
    to `ImageTarget`, so we need to delete that component or simply disable it.
  prefs: []
  type: TYPE_NORMAL
- en: '`DefaultTrackabeEventHandler` can be customized later on for all sorts of effects
    such as playing a sound or video when the trackable is found, or controlling specific
    GUI objects to respond to the trackable. It gives us a lot of control over the
    behavior of the AR app, so it always pays off to keep it in mind.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Particles prefab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Particles** in Unity is a very useful tool that many developers use. With
    it, it is possible to create fog, dust, flames, explosions, and all sorts of effects.
    The effect on resources is usually minimal, as Particles uses small 2D images
    animated to give the effect needed, hence the name Particles.'
  prefs: []
  type: TYPE_NORMAL
- en: For our app, it will be useful to add dust particles appear when we whack the
    mole with the balls fired at them. Although learning how to create particles is
    outside the scope of this book, we will see how we can add one to the scene that
    is already made, because there are a number of free particles available through
    the Unity store.
  prefs: []
  type: TYPE_NORMAL
- en: Import the package named `DustParticles` to the project. Add the prefab we just
    imported to the scene. You will automatically notice the dust cloud being simulated
    in the Editor. Now, we only need to position it appropriately over the molehill
    and have it look as if the dust is rising from the hold, then parent it to the
    Mole object. In a little while, we will see how we can call on this particle system
    and activated it through code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the position of the **Character** object to be under the ground, because
    this is where they should be when the game starts. It will also give us a good
    idea how the dust will look like with character not present. Simply move the `Character`
    on the y axis till it is just below the ground and not visible. The following
    screenshot shows dust particles added to the scene:![Adding a Particles prefab](img/0032OS_05_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unity is a great tool, but like everything else, it is not perfect. What it
    lacks, however, is usually remedied by a very active community that create add-ons
    and scripts for it. One of the most useful and free scripts available for Unity
    is iTween.
  prefs: []
  type: TYPE_NORMAL
- en: '**iTween** is a script that allows us to animate objects quite easily through
    script. It is very customizable, and fits most object animation needs for games.
    For example, iTween can easily be used to animate a missile in a game to home
    at the target in a fluid manner. In our case, we will use iTween to animate the
    mole coming out of the molehill and going back.'
  prefs: []
  type: TYPE_NORMAL
- en: iTween can be easily added from the Unity's Asset store. It is for free; simply
    search for it in the Unity Asset store, which is accessible from the **Window**
    menu, then download and import into the project. Now, we can access iTween functions
    easily from code.
  prefs: []
  type: TYPE_NORMAL
- en: iTween's documentations can be found at [http://itween.pixelplacement.com/documentation.php](http://itween.pixelplacement.com/documentation.php).
  prefs: []
  type: TYPE_NORMAL
- en: Scripting the mole character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that iTween is in place, let's see how we can script the mole character
    to make use of iTween and animate the character correctly. What we are aiming
    to achieve with the mole script at this stage is to have it animate up and down
    from the molehill. The animation should start at a random time between two ranges
    to avoid repetition and predictability of the behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how this script looks like. The following screenshot
    shows `moleAnimator.cs` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scripting the mole character](img/0032OS_05_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first three lines in the `Start()` function are quite simple. We find and
    attach the mole hit sound source to `moleHitAudio` to be used by us in the script.
    We find and attach the dust particle system to use as a hit effect. We then find
    the `ImageTarget` object and only use the script component `MoleTrackableEventHandler`.
    We do this to be able to call on the function that added, which is `trackableVisible`,
    to check to see if the trackable is visible or not. This is one way of accessing
    other class' functions in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last line in the `Start()` function starts the animation sequence; let''s
    see how it does it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is the line of code that starts the whole animation sequence on the mole
    character. `MoveBy()` is a function in the iTween class that allows animating
    objects in a given axis by moving them along it. We first give it the current
    game object to which the script is attached, which will be the mole character,
    and then we pass in the `iTween.Hash` parameters to set what kind of animation
    we want.
  prefs: []
  type: TYPE_NORMAL
- en: The parameters for `iTween.Hash` are very important, but easy to understand.
    It follows the syntax of `(parameter name string, parameter value)`. First, we
    give it the actual axis on which we want to animate, which is in our case y axis.
    Then, we set a value for `easyType`, which governs the slowing down and speeding
    up of the animation to make it not feel abrupt; `easeInOutQuad` is a perfect natural
    feel for our character. We set the speed of the animation to `20`. Now for the
    delay, which is the delay of the animation start, we add a random value to make
    moles animate at different times, and not all at the same time, because we will
    have more than one mole in our scene at a later stage. The `oncomplete` parameter
    is the name of the function to be called once the animation is complete. Because
    this line animates the character up and out of the hole, it calls on `animComplete_up`,
    which in turn will animate the character back down and into the hole, as we will
    see next.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the function `animComplete_Up`, we will see that it only contains
    a single line of code that does something similar to what the `Start()` function
    did in its last code line, but reversed. It animates the character back down and
    into the hole, which makes sense, because we want the character to not pop up
    and down from the molehill. Notice that the `oncomplete` parameter calls on `animComplete_Down`,
    which we will take a look at next.
  prefs: []
  type: TYPE_NORMAL
- en: In function `animComplete_Down`, we do two things. First we check to see if
    the trackable is visible by calling the `trackableVisible()` function, which is
    a member of `MoleTrackableEventHandler`. If the target is visible, we turn on
    `renderer` and `collider` for the object. This makes the object visible and collidable.
    We do this because we will make the mole disappear when the ball hits it, but
    we should only make it reappear if the trackable is visible, otherwise it will
    interfere with how `ImageTarget` renders objects, and we will see floating objects
    on the camera when there is no tracked target. Next, it animates the object back
    up and then `oncomplete` in turn calls `animComplete_Up`, making a perfect recursive
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: The last function, which is `OnCollisionEnter`, is a Unity event that fires
    up whenever two colliders collide with each other. It is sent to any object with
    a collider attached to it. We use this event to check if any ball hit the mole
    or not. If it does hit the mole, we then play the hit sound and the dust particles.
    We then turn off the renderer of the object to make it disappear and turn off
    the collider to not interfere with any more balls.
  prefs: []
  type: TYPE_NORMAL
- en: This is the script that will handle the mole behavior for us. Now all we have
    to do is attach it to the `Character` object inside the `WhackAMoleModel` object
    and hit Play. We can immediately see the mole is animating correctly and randomly.
    Also, if a ball hits it, sound effects and dust particles are played, indicating
    a correct whack.
  prefs: []
  type: TYPE_NORMAL
- en: Now as our mole object is complete, prefab the whole object into the `Prefabs`
    folder and then add multiple mole objects into the scene to have more than one
    mole. Add as many as you would want, but I believe four is a good enough number,
    considering how small the trackable is.
  prefs: []
  type: TYPE_NORMAL
- en: Mask shader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are mostly done with the game. We have the behavior of all our objects in
    place and are ready for deployment; but we are missing one last thing. We might
    have noticed that when the moles go underground, they are still visible from the
    side angle. This will be apparent as well when deploying the app to the device
    in AR environment. There is an easy solution we can do to hide those moles when
    they go underground in an AR environment, which is using a depth mask shader.
  prefs: []
  type: TYPE_NORMAL
- en: Add the shader asset named `DepthMask.shader`, which can be found in the chapter's
    assets. Then, we want to create a cube in our scene that will be as big as the
    ground plane and name it `mask`, and hide all the moles behind it, as shown in
    the following screenshot. The following screenshot also shows the **Mask** object
    added to scene:![Mask shader](img/0032OS_05_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Of course, this object is not acting as a mask yet, it is just an ordinary cube.
    To give it the mask properties, we need to create a material for it in the **Materials**
    folder and name it `Mask`. Because we added the **DepthMask** shader, it should
    be automatically available in the **Shader** dropdown list for the material. Simply
    choose the **DepthMask** shader from there, and then attach the material to the
    **Mask** object. The following screenshot shows the **DepthMask** shader activated:![Mask
    shader](img/0032OS_05_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We immediately notice that the cube has disappeared, but further inspection
    reveals that not only the cube is not visible, but also the moles behind it. This
    effectively fixes our problem by hiding the moles underground.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we covered a lot of ground on the advanced AR development in
    Unity. We created a perfectly functional and fun game that utilizes a lot of concepts
    in both Unity and Vuforia. All we need to do now is deploy the game to a device
    and play with it. Maybe add a score system, or maybe add a limited number of balls
    to hit the mole. The sky is your limit. Experiment with it, and create an experience
    that users will appreciate.
  prefs: []
  type: TYPE_NORMAL
