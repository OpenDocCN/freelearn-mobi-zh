- en: Chapter 5. Advanced Augmented Reality
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章. 高级增强现实
- en: There are a lot of possibilities for delivering augmented reality experiences.
    In this chapter, we will discuss a lot of the advanced features that are available
    when using Vuforia with Unity. We will do that while developing a small arcade
    augmented reality game. The game is a classic arcade game, with an augmented reality
    twist that will make it feel fresh. We will be making an augmented reality whack
    a mole game.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供增强现实体验方面有很多可能性。在本章中，我们将讨论使用 Vuforia 与 Unity 结合时可用的大量高级功能。我们将通过开发一个小型街机增强现实游戏来实现这一点。这个游戏是一个经典的街机游戏，通过增强现实的变化使其感觉新鲜。我们将制作一个增强现实打地鼠游戏。
- en: Augmented reality games
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强现实游戏
- en: A lot of developers misunderstand the value of augmented reality games. Many
    view AR games as unprofitable and marginalized due to the fact that most, if not
    all, AR games cannot go viral and tend to not sell. This might be true due to
    the fact that AR games tend to require motion, a trackable, or both, like in the
    game we will now make. Those requirements make the game not playable at any time
    by the user, but what a lot of people tend to overlook is that it is ok for AR
    games not to go viral.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者误解了增强现实游戏的价值。许多人认为 AR 游戏由于大多数，如果不是所有 AR 游戏都无法病毒式传播且往往不畅销，因此无利可图且被边缘化。这可能是因为
    AR 游戏往往需要动作、可追踪的物体，或者两者都需要，就像我们现在要制作的游戏一样。这些要求使得游戏不能在任何时候由用户玩，但很多人往往忽视的是，AR 游戏不病毒式传播是可以接受的。
- en: 'AR games, while not going to spawn the next Angry Birds, can deliver a unique
    experience for a specific purpose. For example, AR games can be used quite effectively
    for promotion games. The game can trigger on a promotion flyer or a page in the
    magazine and then a competitive game spawns up with a chance to win a real prize,
    for example. This insures that the user received a positive experience in the
    form of a fresh AR game, and at the same time, we are sure the user viewed the
    promotion and joined a competition. AR games can also be used in exhibitions or
    stores for many uses: promotional or pure entertainment.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: AR 游戏，虽然不会产生下一个愤怒的小鸟，但可以为特定目的提供独特的体验。例如，AR 游戏可以非常有效地用于促销游戏。游戏可以在促销传单或杂志页面触发，然后产生一个竞争游戏，有机会赢得真实奖品，例如。这确保了用户以新鲜
    AR 游戏的形式获得积极体验，同时，我们确信用户已经观看了促销并参与了比赛。AR 游戏也可以用于展览或商店的多种用途：促销或纯粹娱乐。
- en: Unity as a game engine
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity 作为游戏引擎
- en: Surely Unity makes making AR apps easier and deployable to multiple platforms,
    but that is not where its true power comes from. Unity is first and foremost a
    very powerful modern game engine. It is used to power some of the industry's known
    games, both on mobile and PC. Not utilizing that kind of power to deliver very
    fresh AR experiences is inexcusable, because it is quite easy to understand how
    the engine works.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Unity 使得制作 AR 应用更加容易，并且可以部署到多个平台，但这并不是它的真正力量所在。Unity 首先是一个非常强大的现代游戏引擎。它被用来驱动一些行业知名的游戏，无论是在移动设备还是
    PC 上。不利用这种力量来提供非常新鲜的 AR 体验是不可原谅的，因为理解引擎的工作方式相当容易。
- en: In this chapter, we will go over some of the elements in Unity that allow the
    making of simple games. We will go over how to add audio effects to the game,
    how to animate objects, how to set the world's physics, how to control particle
    effects, and how to factor in user interactions. Hopefully that will be enough
    to display how effective it is to build an AR game in Unity.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍 Unity 中的一些元素，这些元素允许制作简单的游戏。我们将介绍如何向游戏添加音效，如何动画化对象，如何设置世界的物理，如何控制粒子效果，以及如何考虑用户交互。希望这足以展示在
    Unity 中构建 AR 游戏的有效性。
- en: Setting up the environment
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置环境
- en: 'Now, we can start a new Unity project for the Whack-A-Mole game that we are
    creating. Like we did previously in the book, we set up Unity''s environment for
    the AR app. The following are the steps again:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始创建我们正在制作的 Whack-A-Mole 游戏的新 Unity 项目。就像我们在书中之前做的那样，我们为 AR 应用设置了 Unity
    的环境。以下步骤再次说明：
- en: Change the value of **Platform** to **IOS** from the **Build Settings** under
    the **File** menu.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Platform** 的值从 **File** 菜单下的 **Build Settings** 修改为 **IOS**。
- en: Import Vuforia Unity package by navigating to **Import Package** | **Assets**.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到 **Import Package** | **Assets** 导入 Vuforia Unity 包。
- en: Import the `exampleDataset.unitypackage` file that we used previously in [Chapter
    3](ch03.html "Chapter 3. Understanding Vuforia"), *Understanding Vuforia*, that
    contains the dataset for trackables. They are available in this chapter's assets
    too.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入之前在[第3章](ch03.html "第3章。理解Vuforia")中使用的`exampleDataset.unitypackage`文件，该文件包含可追踪数据的集，它们也包含在本章的资产中。
- en: Add **ARCamera** and **ImageTarget** prefabs from the **Qualcomm Augmented reality**
    prefab folder.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Qualcomm增强现实**预制件文件夹中添加**ARCamera**和**ImageTarget**预制件。
- en: Set the **ImageTarget** to use the dataset we have imported, and set it to use
    **Chips** target from the **Inspector**.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**ImageTarget**设置为使用我们导入的数据集，并在**检查器**中将其设置为使用**Chips**目标。
- en: Set **ARCamera** to load our dataset and activate it as well.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**ARCamera**设置为加载我们的数据集并激活它。
- en: Save the scene to the **Assets** folder, and name it `Level`.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将场景保存到**资产**文件夹中，并命名为`Level`。
- en: 'The following screenshot shows created the project for our Whack-A-Mole game:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了为我们的Whack-A-Mole游戏创建的项目：
- en: '![Setting up the environment](img/0032OS_05_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![设置环境](img/0032OS_05_01.jpg)'
- en: We should end up with similar settings for the environment, as shown in the
    preceding screenshot. Now it is ready for us to start adding the elements that
    will make up our game.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该对环境有类似的设置，如前述截图所示。现在它已经准备好，我们可以开始添加构成我们游戏的各种元素了。
- en: The Whack-A-Mole game
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Whack-A-Mole游戏
- en: In this section, we will go over the design of the game we are making. It is
    a simple Whack-A-Mole game with a twist. Over our target, we want to render a
    ground filled with mole holes, where the moles will pop up and down randomly from
    them. The user will be able to shoot balls at the moles from the device to the
    target; if a ball hits a mole, we will make the mole disappear with a sound effect
    and spawn a particle effect.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论我们正在制作的游戏的架构。这是一个带有转折点的简单Whack-A-Mole游戏。在我们的目标上方，我们想要渲染一个充满地鼠洞的地面，地鼠会从这些洞中随机上下跳跃。用户将能够从设备向目标射击球，如果球击中地鼠，我们将通过音效使地鼠消失并产生粒子效果。
- en: There will be no score system or a way to actually clear the level. We will
    just have this game as a demonstration of how games are made for AR in a simple
    way. All assets used in this game are available in the `Assets` folder in the
    code bundle of this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将不会有得分系统或清除关卡的方法。我们只是将这个游戏作为一个简单方式制作AR游戏的演示。本游戏中使用的所有资产都可在本章代码包的`Assets`文件夹中找到。
- en: Creating the ground for moles
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建地鼠的地面
- en: The first thing we need to do is to create the ground level from which moles
    will pop up. We need to create a plane that will be layered right on top of the
    trackable with a ground texture attached to it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要做的是创建一个基础层，这样地鼠就会从这个层中冒出来。我们需要创建一个平面，这个平面将直接覆盖在可追踪层上，并且附有一个地面纹理。
- en: Let's create a plane from the **GameObject** menu. Choose **Create other** and
    click **Plane**. This will create a plane in the scene. Make sure the plane we
    created has the same position as the trackable; both should be at the global origin,
    which is at (0, 0, 0).
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从**GameObject**菜单创建一个平面。选择**创建其他**并点击**Plane**。这将创建一个场景中的平面。确保我们创建的平面与可追踪层具有相同的位置；两者都应位于全局原点，即(0,
    0, 0)。
- en: Now, resize the plane like we have done before by clicking on the **Resize**
    button at the top-left toolbar. Resize the plane so that its width exactly covers
    the trackable. The height of the plane most likely will be bigger than the trackable,
    but that is all right as long as the trackable is completely covered in the scene.
    The following screenshot shows the Z-Buffer distortion:![Creating the ground for
    moles](img/0032OS_05_02.jpg)
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过点击左上角的工具栏上的**调整大小**按钮，像之前一样调整平面的尺寸。调整平面的宽度，使其正好覆盖可追踪层。平面的高度很可能比可追踪层大，但这没关系，只要可追踪层在场景中完全被覆盖即可。以下截图显示了Z-缓冲区扭曲：![创建地鼠的地面](img/0032OS_05_02.jpg)
- en: We might have noticed that the distortion that is happening between the trackable
    and the plane we just added. This is because both the trackable and the plane
    have the exact same position in the y axis. The engine doesn't know which one
    to render on top of the other, and something called **Z-Buffer conflict** happens,
    where the engine keeps on alternating between the components to be rendered on
    the top. The solution is to simply adjust the plane's y axis position to be slightly
    above that of the trackable.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能已经注意到，在可追踪对象和我们刚刚添加的平面之间发生的扭曲。这是因为可追踪对象和平面在 y 轴上的位置完全相同。引擎不知道应该渲染在另一个之上，因此发生了所谓的
    **Z-Buffer 冲突**，其中引擎不断在要渲染的组件之间交替。解决方案是简单地调整平面的 y 轴位置，使其略微高于可追踪对象的位置。
- en: Name the plane `Ground`, and attach it to the trackable by dragging-and-dropping
    it from the **Hierarchy** list to **ImageTarget**.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将平面命名为 `Ground`，并通过从 **Hierarchy** 列表拖动并放置到 **ImageTarget** 上来将其附加到可追踪对象上。
- en: Now that the ground plane is in place, the first thing we will get the urge
    to do is to lose that plain white texture that is there by default on the plane.
    We would want it to look like an actual ground, so we will create a material for
    it. Materials for Unity are components that carry the information of what is the
    texture of the object and what shader is used to render it. It is very important
    and used extensively for almost every object in any scene.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在地面平面已经就位，我们首先会想要去除平面上默认的纯白色纹理。我们希望它看起来像真正的地面，因此我们将为其创建一个材质。Unity 的材质是组件，它们携带有关对象纹理和用于渲染它的着色器的信息。它非常重要，并且几乎在场景中的每个对象上都得到了广泛的应用。
- en: First, create two folders in the **Assets** folder of our project from Unity.
    Name one `Textures`; this is where we will keep the texture images of our materials,
    and the other `Materials`; this is where we are going to create our materials.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 Unity 项目的 **Assets** 文件夹中创建两个文件夹。将其中一个命名为 `Textures`；这是我们将会保存材质纹理图像的地方，另一个命名为
    `Materials`；这是我们将会创建材质的地方。
- en: Now drag-and-drop the file named **Ground.jpg** into the **Textures** folder
    we just created. We could also add the asset through the **Assets** menu, like
    we saw before. This just added the texture image for the ground to our project.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将名为 **Ground.jpg** 的文件拖动并放置到我们刚刚创建的 **Textures** 文件夹中。我们也可以通过 **Assets**
    菜单添加资产，就像之前看到的那样。这只是在项目中添加了地面的纹理图像。
- en: Now, let's create the material; inside the **Materials** folder we just created,
    from the **Assets** menu, choose **Material**. This creates a new material that
    we will name as `Ground`. Now attach the **Ground** material we created to the
    ground plane. Do this by simply dragging the material and dropping it on **Ground**
    plane in the **Hierarchy** panel.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建材质；在刚刚创建的 **Materials** 文件夹中，从 **Assets** 菜单选择 **Material**。这会创建一个新的材质，我们将命名为
    `Ground`。现在将我们创建的 **Ground** 材质附加到地面平面上。通过简单地拖动材质并将其放置在 **Hierarchy** 面板中的 **Ground**
    平面上来完成此操作。
- en: 'Notice that the plane stays white as it was before; this is because we haven''t
    attached the texture yet to the material. To do that, access the material we just
    added to the **Ground** plane by selecting the **Ground** plane and from the **Inspector**;
    here we will find the **Material** we assigned. There is a small **Texture** property
    under **Material**, drag-and-drop the texture we added earlier to this box. The
    following screenshot shows the **Ground** material attached:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到平面保持白色，就像之前一样；这是因为我们还没有将纹理附加到材质上。为此，通过选择 **Ground** 平面并从 **Inspector** 中访问我们刚刚添加到
    **Ground** 平面的材质；在这里我们将找到分配的 **Material**。在 **Material** 下有一个小的 **Texture** 属性，将我们之前添加的纹理拖动并放置到这个框中。以下截图显示了附加的
    **Ground** 材质：
- en: '![Creating the ground for moles](img/0032OS_05_03.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![为老鼠创建地面](img/0032OS_05_03.jpg)'
- en: Now we have an ok looking ground for our moles. Notice that the shader for the
    material is **Diffuse**. This type of shader is suitable for opaque materials
    and works perfectly fine for the ground texture. Later on, we can use different
    shaders for different materials to achieve different results, such as the transparency
    or particle shader.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为我们的老鼠有了看起来不错的地面。请注意，该材质的着色器是 **Diffuse**。这种着色器适用于不透明材质，并且对于地面纹理来说效果非常好。稍后，我们可以为不同的材质使用不同的着色器以实现不同的效果，例如透明度或粒子着色器。
- en: The Whack-A-Mole model
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Whack-A-Mole 模型
- en: Now that we have the ground to build on, it is time to add our mole model to
    the project. Simply create a folder in the **Assets** folder, and name it `Models`.
    Drag-and-drop the file from the chapter assets named `WhackAMoleModel.fbx`. Unity
    will automatically import the model into the project and will create a prefab
    for us.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了可以建造的地面，是时候将我们的鼹鼠模型添加到项目中了。只需在**Assets**文件夹中创建一个文件夹，并将其命名为`Models`。将章节资源中名为`WhackAMoleModel.fbx`的文件拖放到文件夹中。Unity将自动将模型导入到项目中，并为我们创建一个预制体。
- en: Like we have done before, drag-and-drop the prefab created for `WhackAMoleModel`
    into our scene. You might not automatically see where the model was added; this
    is mainly because the model is too small in comparison to the ground plane. If
    you focus on the model by holding the *F* key, you will see how small the model
    is.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们之前做的那样，将为`WhackAMoleModel`创建的预制体拖放到我们的场景中。你可能不会自动看到模型被添加的位置；这主要是因为与地面平面相比，模型太小了。如果你通过按住*F*键来聚焦于模型，你会看到模型有多小。
- en: Tip
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To change that, we can scale the model using the same way we did before, which
    is to scale it from the editor, or we can change the FBX Converter settings. The
    FBX Converter settings handle how the model is inserted into our scene through
    many settings specific to the model. If we are to scale the model in the editor,
    it will naturally not have a 1:1 ratio between the model and the world. This is
    done in real time, takes up resources, and makes scripting more confusing and
    frustrating. It is recommend to scale objects from their model settings.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要改变这一点，我们可以使用之前的方法缩放模型，即从编辑器中进行缩放，或者我们可以更改FBX转换器的设置。FBX转换器设置处理模型如何通过许多针对模型特定的设置插入到我们的场景中。如果我们要在编辑器中缩放模型，它将自然地没有模型与世界的1:1比例。这是实时进行的，占用资源，并使脚本编写更加复杂和令人沮丧。建议从模型设置中缩放对象。
- en: Click on the model's prefab in the folder, and the **Inspector** will display
    the **FBX Converter** settings. There is a setting for **Scale Factor**, that
    is by default set to a very small value, which is **0.01**. This is how big the
    model is to be inserted to the scene compared to its original scale from the 3D
    modeling application. Change this setting to **0.7**, and click on **Apply**.
    The model will resize automatically in the scene without changing the scale transform
    in the scene itself. The following screenshot shows `WhackAMoleModel` scaled and
    positioned in the middle:![The Whack-A-Mole model](img/0032OS_05_04.jpg)
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件夹中单击模型的预制体，**Inspector**将显示**FBX Converter**设置。有一个**缩放因子**设置，默认设置为非常小的值，即**0.01**。这是模型相对于从3D建模应用程序中原始缩放的插入到场景中的大小。将此设置更改为**0.7**，然后单击**应用**。模型将在场景中自动调整大小，而不会改变场景本身的缩放变换。以下截图显示了缩放并定位在中间的`WhackAMoleModel`：![Whack-A-Mole模型](img/0032OS_05_04.jpg)
- en: Position the model exactly at the center of the ground and to be on top of the
    ground correctly. After that, attach the **WhackAMoleModel** object to the **ImageTarget**
    in the **Hierarchy** to set the **ImageTarget** as its parent object.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模型精确放置在地面的中心，并确保正确位于地面之上。之后，将**WhackAMoleModel**对象附加到**Hierarchy**中的**ImageTarget**，将其设置为父对象。
- en: Adding colliders to the scene
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向场景添加碰撞器
- en: Unity simulates physics for the objects in the game, but only when we specify
    what is being simulated and how. The reason for this is that in most games, not
    every single object is simulated by physics. For example, not every wall in every
    game is breakable. There are static objects that are just there simply defying
    physics, but for games, that is quite all right.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Unity为游戏中的对象模拟物理，但仅当我们指定要模拟的内容和方式时。这样做的原因是，在大多数游戏中，并非每个对象都由物理模拟。例如，并非每个游戏中的墙壁都是可破坏的。有一些静态对象只是在那里简单地违反物理定律，但对于游戏来说，这是完全可以接受的。
- en: '**Collider** is a component that we can attach to any object in the scene that
    makes this object "collidable" with any other collidable object. For example,
    if we are making a shooting game such as *Call of Duty* or the likes of it, if
    we do not attach a collider to all walls in our game, the game character will
    be able to simple "walk through" the wall. This is, of course, not desirable.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**Collider**是一个组件，我们可以将其附加到场景中的任何对象上，使该对象能够与其他可碰撞对象“碰撞”。例如，如果我们正在制作像*使命召唤*这样的射击游戏，如果我们没有将碰撞器附加到游戏中的所有墙上，游戏角色将能够简单地“穿过”墙壁。这当然是不希望的。'
- en: For our game, we need to be able to "whack" the mole; if there is no collider
    on the mole, we certainly won't be able to whack it. Also, the balls that we will
    be shooting at the moles need to be able to collide with the ground, not just
    pass through it. All of this is possible with colliders.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的游戏，我们需要能够“敲打”鼹鼠；如果鼹鼠上没有碰撞器，我们当然无法敲打它。此外，我们将要向鼹鼠射击的球体需要能够与地面碰撞，而不仅仅是穿过它。所有这些都可以通过碰撞器实现。
- en: First, select the **WhackAMoleModel** from the scene, and expand it to reveal
    the **MoleHill** and the character. Those are the two components to which we need
    to add the colliders. First, select the character from the scene, and select **Box
    Collider** by navigating to **Component** | **Physics**. This will add a collider
    with the shape of a box around the character. The box won't be exactly wrapping
    the character, but it is cheap on resources, and is enough in our case to simulate
    a good collision with the balls that we will fire at the moles.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从场景中选择**WhackAMoleModel**，并将其展开以显示**MoleHill**和角色。这些是我们需要添加碰撞器的两个组件。首先，从场景中选择角色，然后通过导航到**Component**
    | **Physics**选择**Box Collider**。这将添加一个围绕角色的盒子形状的碰撞器。盒子不会完全包裹角色，但它对资源的消耗很小，在我们的情况下足以模拟与我们将要向鼹鼠发射的球体良好的碰撞。
- en: Next, select the **MoleHill**; the **MoleHill** is irregular in shape, and we
    need the ball collision with it to be simulated more effectively than what a box
    collider can do. This is why we need to use a Mesh collider. From the same previous
    menu, now choose **Mesh Collider** to be added to the **MoleHill** model. What
    the **Mesh Collider** does is that it adds a collider that is exactly the same
    shape as the model on top of it, so it simulates the collision exactly the same
    as the model.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择**MoleHill**；**MoleHill**的形状不规则，我们需要球体与它的碰撞效果比盒子碰撞器能做得更有效。这就是为什么我们需要使用网格碰撞器。从相同的先前菜单，现在选择将**Mesh
    Collider**添加到**MoleHill**模型中。**Mesh Collider**的作用是添加一个与顶部模型形状完全相同的碰撞器，因此它模拟的碰撞与模型完全相同。
- en: 'The following screenshot shows colliders added to the **Mole** model:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了添加到**Mole**模型中的碰撞器：
- en: '![Adding colliders to the scene](img/0032OS_05_05.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![向场景添加碰撞器](img/0032OS_05_05.jpg)'
- en: Notice that the ground already has a collider added to it. That is because,
    by default, any primitive object created in the editor has a collider attached
    to it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，地面已经添加了碰撞器。这是因为，默认情况下，在编辑器中创建的任何原始对象都附有一个碰撞器。
- en: Creating the ball for the ball gun
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为球枪创建球体
- en: Now that we have the general feeling of the game being set, we need to create
    the gun's projectile. It is understandable that because it's a ball gun, it will
    just shoot spheres, which we can create through a script. But before we can do
    that, we need a role model for the script to clone and create in the scene. So,
    the next thing we will work on is creating the basis for the gun's projectile
    prefab.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对游戏的整体感觉已经设定，我们需要创建枪的投射物。可以理解的是，因为这是一把球枪，所以它只会射击球体，我们可以通过脚本创建球体。但在我们能够这样做之前，我们需要一个脚本的角色模型来克隆并在场景中创建。所以，接下来我们将要处理的是创建枪的投射物预制件的基础。
- en: Select **ARCamera** from the **Hierarchy** panel, and then from the **GameObject**
    menu navigate to **Create** | **Other** | **Sphere**. This will create a sphere
    where **ARCamera** is; however, it will not parent it to the camera. It is particularly
    useful when creating objects at the position of other objects. Change the name
    of the sphere we just created to `Ball`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次**面板中选择**ARCamera**，然后从**GameObject**菜单导航到**Create** | **Other** | **Sphere**。这将创建一个球体，位于**ARCamera**的位置；然而，它不会将其作为子对象添加到相机中。这在创建位于其他对象位置的对象时特别有用。将我们刚刚创建的球体的名称更改为`Ball`。
- en: Now, the main idea is to have the projectile occupy at least half the camera's
    view and be at the center of it to give the user a sense of immersion while shooting
    the balls at the moles. This is easily achievable with everything we know. Simply
    position the ball directly in front of the camera and resize it till you feel
    its size is appropriate to the camera. We can check how big it will look like
    if we look at the **Game** panel in the editor or **Camera Preview** at the bottom-right
    corner of the **Scene** panel when selecting the camera.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，主要想法是让投射物占据至少相机视野的一半，并位于其中心，以便在向鼹鼠射击球体时给用户带来沉浸感。这很容易实现。只需将球体直接放置在相机前方，并调整其大小，直到你觉得它的大小适合相机。我们可以通过在编辑器中的**Game**面板或选择相机时**场景**面板右下角的**Camera
    Preview**来查看它将看起来有多大。
- en: Once the position and scale is right, create a material in the **Materials**
    folder, and name it `ball`. When selecting this material, in the Inspector you
    will notice a color box that is by default set to **white**. For the ball, we
    do not need a texture like we did for the ground, but rather, just a color that
    will make it contrast over the environment. So, just set the color box to red,
    and then attach the material to the ball. The following screenshot shows the **Ball**
    projectile in the **Scene** panel:![Creating the ball for the ball gun](img/0032OS_05_06.jpg)
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦位置和比例正确，在**材质**文件夹中创建一个材质，命名为`ball`。当选择这个材质时，在检查器中你会注意到一个默认设置为**白色**的颜色框。对于球体，我们不需要像地面那样的纹理，而只需要一种使其在环境中对比的颜色。所以，只需将颜色框设置为红色，然后将材质附加到球体上。以下截图显示了**球体**投射物在**场景**面板中的样子：![为球体枪创建球体](img/0032OS_05_06.jpg)
- en: Notice that the ball already has a collider by default, which will come in handy
    when we want the ball to actually collide with the moles and the ground.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到球体默认已经有一个碰撞器，这在我们需要球体实际与地鼠和地面碰撞时将非常有用。
- en: There is one fundamental thing to point out; adding a collider to the object
    doesn't make it simulated by physics in the engine, it only makes it collidable
    with other colliders. But of course, we want the projectile to act like a real
    projectile and respond to gravity and forces. We want the projectile to bounce
    off of the floor and off of the moles in a natural way. This is easily simulated
    in Unity, but we need to tell Unity what to simulate and how.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个基本的事情需要指出；给对象添加碰撞器并不会使其在引擎中被物理模拟，它只会使其与其他碰撞器发生碰撞。但当然，我们希望投射物像真实投射物一样行动，并对重力及力做出反应。我们希望投射物以自然的方式从地板和地鼠上弹跳。这很容易在Unity中模拟，但我们需要告诉Unity要模拟什么以及如何模拟。
- en: Select the **ball** object from the **Hierarchy** panel, and from **Components**
    menu, go to **Physics**, and select **Rigidbody**. This adds a Rigidbody component
    to the ball. What the Rigidbody component does is that it simulates physics on
    the object it is attached to as if the object is a rigid body in the real world.
    It simulates gravity, bounce, external forces, and everything to which you would
    expect a real-world rigid body be subjected to, such as an air drag.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从**层次**面板中选择**球体**对象，然后在**组件**菜单中，转到**物理**，并选择**刚体**。这将为球体添加一个刚体组件。刚体组件的作用是模拟它所附加对象上的物理，就像这个对象在现实世界中是一个刚体一样。它模拟重力、弹跳、外力以及所有你期望现实世界刚体会受到的影响，例如空气阻力。
- en: By default, the Rigidbody component is set to simulate gravity on the object.
    We do not need to change any settings in Rigidbody because they all suit us for
    now. Simply click the Play button, and we will immediately see the ball falling
    down in the game world under the effect of gravity.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，刚体组件被设置为在对象上模拟重力。我们不需要在刚体中更改任何设置，因为它们现在都适合我们。只需点击播放按钮，我们就会立即看到球体在游戏世界中在重力作用下下落。
- en: Setting global gravity settings
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置全局重力设置
- en: We might have noticed that the ball was falling a little too slow for it to
    feel natural for the game. This is mainly because our scale is not 1:1 with the
    game. It is rather 1:1 with the real world. This is because it is an AR application,
    and the concern is for it to feel natural with the real-world interaction. This,
    however, makes us all giants in comparison to the game world when using the AR
    game. So, it's not that the ball that is falling too slow, a bit of Einstein's
    relativity coming, it's that the ball that is falling a great distance in relation
    to us.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能已经注意到球体下落得太慢，以至于在游戏中感觉不自然。这主要是因为我们的比例不是1:1与游戏匹配。它实际上是1:1与现实世界匹配。这是因为它是一个增强现实应用，我们关心的是它与现实世界的交互感觉自然。然而，这却使得我们在使用增强现实游戏时，相对于游戏世界都变成了巨人。所以，并不是球体下落得太慢，而是有点爱因斯坦相对论的意味，相对于我们，球体下落了很长的距离。
- en: To remedy that, we need to bring up the force of gravity to compensate for the
    giant status in which we are located. If the gravity is stronger, the ball will
    fall faster and will give us the feeling that it is natural for our own real world.
    Luckily, changing the gravity setting in a Unity project is quite simple.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要提高重力，以补偿我们所在巨人状态。如果重力更强，球体下落得更快，并给我们一种它在我们自己的真实世界中是自然的感受。幸运的是，在Unity项目中更改重力设置相当简单。
- en: From the **Edit** menu, go to **Project** settings, and select **Physics**.
    In the **Inspector**, we will be presented with a number of settings all related
    to how physics works. We can change any of them, but we only need one changed
    for now. The first setting is related to gravity. Gravity in the real world acts
    on the y axis and is roughly -9.81 in magnitude. We need this to be 6 times stronger,
    so change it to `-60.81`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Edit**菜单中，转到**Project**设置，并选择**Physics**。在**Inspector**中，我们将看到与物理工作方式相关的多个设置。我们可以更改任何一个，但现在我们只需要更改一个。第一个设置与重力相关。现实世界中的重力作用于y轴，其大小大约为-9.81。我们需要将其强度增加到6倍，所以将其更改为`-60.81`。
- en: Click on the Run button, and watch the ball fall much faster and in a more natural
    manner. The following screenshot shows the gravity settings for the project:![Setting
    global gravity settings](img/0032OS_05_07.jpg)
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击运行按钮，观察球体下落得更快，方式也更自然。以下截图显示了项目的重力设置：![设置全局重力设置](img/0032OS_05_07.jpg)
- en: This should take care of the physics compensation value and should work naturally
    in the real world in an AR environment.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会处理物理补偿值，并在真实世界的AR环境中自然工作。
- en: Adding audio sources
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加音频源
- en: We now need to create sound sources in the scene to handle sound effects for
    the game. **Sound sources** are audio sources that can be position in the world
    for 3D positional sound or simple 2D sounds. In order to hear sound effects in
    the game, audio sources are needed to produce the sound, but also we need a listener
    to actually capture the created sound to present to the user.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在场景中创建声音源来处理游戏的声音效果。**声音源**是可以放置在世界上用于3D位置声音或简单2D声音的音频源。为了在游戏中听到声音效果，需要音频源来产生声音，但我们还需要一个监听器来实际捕获创建的声音并呈现给用户。
- en: By default, **ARCamera** has a listener component added to it, so we only need
    to add the audio sources to it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，**ARCamera**已经添加了一个监听器组件，所以我们只需要将音频源添加到它上面。
- en: Create a folder and name it `Audio` in the **Assets** folder. Drag-and-drop
    the two files inside the **Audio** folder in the chapter's assets. This will import
    the two audio files named `ballFire.wav` and `moleHit.wav`. We will use the first
    for the sound effect of firing the ball from the gun, and the second for when
    a ball hits a mole.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Assets**文件夹中创建一个文件夹，并将其命名为`Audio`。将两个文件拖放到**Audio**文件夹中的章节资产中。这将导入名为`ballFire.wav`和`moleHit.wav`的两个音频文件。我们将第一个用于枪支发射球体的声音效果，第二个用于球体击中鼹鼠时。
- en: Because this is an arcade game, we do not need 3D sound positions; we mostly
    need all audio to be 2D and independent of how far or close we are to the sound
    source. We do this by changing the setting for the audio assets, which we just
    imported, in the Inspector.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为这是一个街机游戏，我们不需要3D声音位置；我们主要需要所有音频都是2D的，并且与声音源的距离远近无关。我们通过在检查器中更改我们刚刚导入的音频资源的设置来实现这一点。
- en: Select the audio file from the **Audio** folder, and from the **Inspector**
    uncheck the checkbox named **3D Sound**. Do the same for both files. The following
    screenshot shows the audio settings for the audio files:![Adding audio sources](img/0032OS_05_08.jpg)
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Audio**文件夹中选择音频文件，并在**Inspector**中取消勾选名为**3D Sound**的复选框。对两个文件都做同样的事情。以下截图显示了音频文件的音频设置：![添加音频源](img/0032OS_05_08.jpg)
- en: Now, select **ARCamera**, and then from the **GameObject** menu, select **Create
    Empty**. What this does is it creates an empty object in the world and near **ARCamera**.
    Now, rename the object to `ballFireAudio`. Now, select the object we have just
    created, and from the **Component** menu, navigate to **Audio** | **Audio source**.
    Repeat the same steps to create `moleHitAudio`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，选择**ARCamera**，然后从**GameObject**菜单中选择**Create Empty**。这样做会在世界中创建一个空对象，并且靠近**ARCamera**。现在，将对象重命名为`ballFireAudio`。现在，选择我们刚刚创建的对象，从**Component**菜单导航到**Audio**
    | **Audio source**。重复相同的步骤来创建`moleHitAudio`。
- en: Drag-and-drop the audio file from the **Audio** folder appropriately into the
    audio source component we have just created. This effectively creates sound sources
    in our scene. Just uncheck the checkbox named **Play on Awake**, because we need
    to control this audio source through code. It is a useful option to test how the
    sound source will play out in the game panel though. The following screenshot
    shows sound source settings for **ballFireAudio**:![Adding audio sources](img/0032OS_05_09.jpg)
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Audio**文件夹中的音频文件适当地拖放到我们刚刚创建的音频源组件中。这实际上在我们的场景中创建了声音源。只需取消勾选名为**Play on Awake**的复选框，因为我们需要通过代码来控制这个音频源。尽管这是一个在游戏面板中测试声音源如何播放的有用选项。以下截图显示了**ballFireAudio**的声音源设置：![添加音频源](img/0032OS_05_09.jpg)
- en: Now that the sound sources are in place, we can easily call on them from script
    to add to the immersion of the app.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在声音源已经设置好了，我们可以轻松地从脚本中调用它们，以增加应用程序的沉浸感。
- en: Scripting the ball gun
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写球枪脚本
- en: We have already created the projectile for the gun, and we also created the
    sound source for it, but we are yet to make this act like a ball gun; this is
    when scripting comes in handy.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为枪创建了弹射物，我们也为它创建了声音源，但我们还没有让它像球枪一样工作；这就是脚本派上用场的时候了。
- en: The first thing we need to do is to create a prefab for the projectile we created.
    This is to be able to clone the projectile through the script and fire it at the
    poor moles. To do that, simply create a folder in the **Assets** folder, and name
    it `Prefabs`. Drag-and-drop the **Ball** object from the **Hierarchy** panel to
    the folder you just created. Now we have a prefab that we can call upon through
    code and can create as many balls as we want.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是为我们创建的弹射物创建一个预制体。这是为了能够通过脚本克隆弹射物并向可怜的鼹鼠发射。为此，只需在**Assets**文件夹中创建一个文件夹，并将其命名为`Prefabs`。从**Hierarchy**面板中将**Ball**对象拖放到你刚刚创建的文件夹中。现在我们有一个可以通过代码调用并创建任意数量球的预制体。
- en: The ball we have attached to the camera is meaningless, because we will be creating
    the projectiles through code. So, after we have already made a prefab of the ball,
    we no longer need it in the scene, but before we remove that, there is another
    step. We need to have a placeholder from which the projectiles spawn. That placeholder
    should be in the same position and with the same rotation as the ball we have
    in the scene right now.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们附加到相机上的球是没有意义的，因为我们将通过代码创建弹射物。所以，在我们已经制作了球的预制体之后，我们不再需要在场景中使用它，但在我们移除它之前，还有另一个步骤。我们需要有一个占位符，从该占位符中生成弹射物。这个占位符应该与场景中现在的球具有相同的位置和旋转。
- en: First, we add an empty object to the scene from the **GameObject** menu. Now,
    attach that object to the **ARCamera** object by dragging-and-dropping it. Rename
    that object to `BallPlaceHolder`. We need the `BallPlaceHolder` object to have
    the exact same transformation as that of the **Ball** object. Unfortunately, there
    is no automatic function in Unity that copies the transformation for two objects,
    so we need to manually copy it. Click the **Ball** object and copy both the position
    and rotation of that object, and insert them into the `BallPlaceHolder` object.
    Then, delete the **Ball** object, because we no longer need it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从**GameObject**菜单中添加一个空对象到场景中。现在，通过拖放将该对象附加到**ARCamera**对象上。将那个对象重命名为`BallPlaceHolder`。我们需要`BallPlaceHolder`对象与**Ball**对象具有完全相同的变换。不幸的是，Unity中没有自动复制两个对象变换的功能，因此我们需要手动复制。点击**Ball**对象，复制该对象的位置和旋转，并将它们插入到`BallPlaceHolder`对象中。然后，删除**Ball**对象，因为我们不再需要它了。
- en: 'The following screenshot shows **BallPlaceHolder** added to the scene:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了添加到场景中的**BallPlaceHolder**：
- en: '![Scripting the ball gun](img/0032OS_05_10.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![编写球枪脚本](img/0032OS_05_10.jpg)'
- en: Now, it is time to create a folder for our scripts. Create a new folder in **Assets**,
    and rename it **Scripts**. Inside the **Scripts** folder, from **Assets** menu,
    navigate to **Create** | **C# Script**. Name the created file `ballGun`. Now,
    double-click on it, and Unity will automatically open its MonoDevelop Editor for
    us.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候为我们的脚本创建一个文件夹了。在**Assets**中创建一个新的文件夹，并将其重命名为**Scripts**。在**Scripts**文件夹内，从**Assets**菜单导航到**Create**
    | **C# Script**。将创建的文件命名为`ballGun`。现在，双击它，Unity将自动为我们打开其MonoDevelop编辑器。
- en: 'The following screenshot shows the Unity MonoDevelop Editor:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了Unity MonoDevelop编辑器：
- en: '![Scripting the ball gun](img/0032OS_05_11.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![编写球枪脚本](img/0032OS_05_11.jpg)'
- en: Unity automatically creates a number of things for us in the MonoDevelop Editor.
    First, it creates a class template with the name of the script file. This is why
    the script filename must be that of the class name, among other reasons. It adds
    two empty functions for us that are very crucial to game development on the platform.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Unity在MonoDevelop编辑器中为我们自动创建了许多东西。首先，它创建了一个以脚本文件名命名的类模板。这就是为什么脚本文件名必须是类名的原因之一。它为我们添加了两个空函数，这对平台上的游戏开发至关重要。
- en: The `Start()` function is a function that is called automatically by Unity engine
    when the scene starts. It is very useful for variable initialization, and can
    be thought of as the constructor for the class.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start()`函数是一个Unity引擎在场景开始时自动调用的函数。它对于变量初始化非常有用，可以将其视为类的构造函数。'
- en: The `Update()` function is a very important function that Unity automatically
    calls on every frame that passes in the game. This is very important for keeping
    track of the game object state, maintaining game logic, and many other uses. It
    is strongly advised not to have intensive calculations inside the `Update()` function,
    because it will slow down the frame rates of the game, because Unity doesn't render
    the next frame till all `Update()` functions in the game are executed completely.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update()`函数是一个非常重要的函数，Unity会在游戏中的每一帧自动调用它。这对于跟踪游戏对象状态、维护游戏逻辑以及许多其他用途非常重要。强烈建议不要在`Update()`函数中进行密集计算，因为这会降低游戏的帧率，因为Unity不会渲染下一帧，直到游戏中的所有`Update()`函数都完全执行完毕。'
- en: 'Now, let''s look at the script after the code has been added to it and see
    what every function does. The following screenshot shows the `ballGun.cs` script:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看添加代码后的脚本，看看每个函数都做了什么。以下截图显示了`ballGun.cs`脚本：
- en: '![Scripting the ball gun](img/0032OS_05_12.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![球枪脚本](img/0032OS_05_12.jpg)'
- en: This is how the script that will control the behavior of the ball gun appears.
    We will be attaching this script to the `ARCamera` object, and it will respond
    to user's touch anywhere on the screen to fire a ball directly toward where the
    user is pointing the camera. Let's see what every function does in this script.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是控制球枪行为的脚本的样子。我们将把这个脚本附加到`ARCamera`对象上，并且它会响应用户在屏幕上的任何触摸，直接向用户指向的方向发射球。让我们看看这个脚本中的每个函数都做了什么。
- en: 'The first things we see are the declared variables for the script. They follow
    a similar syntax to what you would expect from a C# language:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看到的是脚本中声明的变量。它们的语法与您从C#语言中期望的类似：
- en: '[PRE0]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `public` or `private` status of the variable is very important in Unity.
    This is because `public` variables appear in the Editor, and their values can
    be set in the **Inspector**. This is particularly useful and should be kept in
    mind.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，变量的`public`或`private`状态非常重要。这是因为`public`变量会出现在编辑器中，并且可以在**检查器**中设置它们的值。这一点特别有用，应该牢记在心。
- en: The `projectile` variable is what we will use from which to link to the **Ball**
    prefab. It is `public`, because we will set its value from the Editor, as we will
    see in a little while. `projectile` is of type `GameObject`, which is the general
    type for any object in the game. It contains a large number of relevant functions
    and variables that often come in handy. wer sadfas
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`projectile`变量是我们将用于链接到**球**预制件的变量。它是`public`的，因为我们将在稍后从编辑器设置其值。`projectile`是`GameObject`类型，它是游戏中任何对象的通用类型。它包含大量相关函数和变量，这些函数和变量经常很有用。wer
    sadfas'
- en: The variable `projectilePlaceHolder` is of type `Transform`. It will hold the
    transform information of the `BallPlaceHolder` object we have in the scene on
    which to spawn projectiles.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`projectilePlaceHolder`是`Transform`类型。它将保存场景中`BallPlaceHolder`对象的变换信息，该对象用于生成弹射物。
- en: For the variable `ballFireAudio`, as its name suggests, we will be using this
    to link to the audio source object we created earlier.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于变量`ballFireAudio`，正如其名称所暗示的，我们将使用它来链接到我们之前创建的音频源对象。
- en: 'The `Trackable` variable will be used to link to the `ImageTarget` object.
    We will use it to parent the spawned projectiles to it. We will do that to allow
    the balls to disappear if `Trackable` is lost from sight:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Trackable`变量将用于链接到`ImageTarget`对象。我们将使用它将生成的弹射物作为其子对象。我们将这样做，以便在`Trackable`从视线中消失时，球能够消失：'
- en: '[PRE1]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is how our `Start()` function looks like. In this function, we are initializing
    both `ballFireAudio` and `Trackable` variables. We do that by finding the `GameObject`
    from the scene and attaching it to the variable. Notice that we find the `GameObject`
    by its name; if the name is different, change it accordingly, or the variable
    will not be initialized correctly:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的`Start()`函数看起来像什么。在这个函数中，我们初始化了`ballFireAudio`和`Trackable`变量。我们通过从场景中找到`GameObject`并将其附加到变量来实现这一点。注意，我们是通过名称找到`GameObject`的；如果名称不同，相应地更改它，否则变量将无法正确初始化：
- en: '[PRE2]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is our `Update()` function that will be called with every frame. It mainly
    listens for user interaction; if the user touches the screen or clicks with the
    mouse, a **Ball** prefab is instantiated and a force is applied on it to propel
    it forward with a sound effect. Repeated clicks or touches will spawn more balls.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`Update()`函数，它将在每一帧被调用。它主要监听用户交互；如果用户触摸屏幕或用鼠标点击，就会实例化一个**球体**预制体，并对其施加力以向前推进，同时发出声音效果。重复点击或触摸将产生更多的球体。
- en: What `Input.GetMouseButtonDown(0)` does is that it returns `true` if the user
    clicks with the mouse or touches the screen. This is how we listen if the user
    interacted with the screen. If it is `true`, we proceed with our game logic.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Input.GetMouseButtonDown(0)`的作用是，如果用户点击鼠标或触摸屏幕，则返回`true`。这就是我们如何监听用户是否与屏幕交互。如果是`true`，我们就继续执行游戏逻辑。'
- en: We first play the audio attached to the game object `ballFireAudio` to play
    the sound effect for ball shooting.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先播放附加到游戏对象`ballFireAudio`的音频，以播放球体射击的声音效果。
- en: Next, we instantiate a new clone from the prefab **Ball** attached to a projectile
    variable. We instantiate it into the variable `obj` with the transform of the
    `projectilePlaceHolder` position and the rotation of the camera so that it always
    fires forward.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从附加到投射物变量的预制体**球体**中实例化一个新的克隆。我们将其实例化到变量`obj`中，位置为`projectilePlaceHolder`的变换，旋转为摄像机的旋转，以确保它总是向前发射。
- en: We then apply the relative force to the instantiated object's `Rigidbody` component
    to fire forward. The direction is `Vector3.forward`, which is the object's forward
    direction. We multiply it by `Time.deltaTime`; we do this to make the force frame
    rate independent (`Time.deltaTime` is the time since the last frame). This avoids
    making the ball slower if the frame rate drops down for any reason. Then we multiply
    by the force's power. Notice that the force is really big; this is because we
    need the ball to fire forward quickly and to also compensate for the ratio between
    the game world and the real world as we saw with gravity.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将相对力应用到实例化对象的`Rigidbody`组件上，以向前发射。方向是`Vector3.forward`，这是对象的正向。我们将其乘以`Time.deltaTime`；我们这样做是为了使力不受帧率的影响（`Time.deltaTime`是上一帧以来的时间）。这样做可以避免由于任何原因帧率下降时球体变慢。然后我们乘以力的功率。注意，力实际上很大；这是因为我们需要球体快速向前发射，并且还需要补偿游戏世界与现实世界之间的比例，正如我们通过重力所看到的那样。
- en: We then parent the instantiated object to `ImageTarget` so that it behaves correctly
    with the image target.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将实例化对象设置为`ImageTarget`的父对象，以便它能够正确地与图像目标一起工作。
- en: Finally, we destroy the object with a delay of 5 seconds. We do that because
    we do not ever want projectiles to disappear, as this will really deteriorate
    the performance of the app.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们延迟5秒后销毁对象。我们这样做是因为我们绝对不希望投射物消失，因为这会真正降低应用程序的性能。
- en: Now that our script is ready, we need to attach it to the **ARCamera** object.
    Do this by dragging the script and dropping it on the **ARCamera** object. The
    script component will appear in **ARCamera** and we will notice that the two public
    variables **Projectile** and **Projectile Place Holder** are visible in the **Inspector**`.`
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的脚本已经准备好了，我们需要将其附加到**ARCamera**对象。通过将脚本拖动并放置在**ARCamera**对象上完成此操作。脚本组件将出现在**ARCamera**中，我们将会注意到两个公共变量**投射物**和**投射物占位符**在**检查器**中是可见的。
- en: Now, we need to drag-and-drop the **Ball** prefab from the **Prefabs** folder
    to the **Projectile** variable in the **Inspector**. We also need to drag-and-drop
    the **BallPlaceHolder** object from the scene to the variable **Projectile Place
    Holder** variable in the **Inspector**. The following shows **ARCamera** with
    the `ballGun.cs` script attached:![Scripting the ball gun](img/0032OS_05_13.jpg)
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将**球体**预制体从**预制体**文件夹拖放到**检查器**中的**投射物**变量。我们还需要将**球体占位符**对象从场景拖放到**检查器**中的**投射物占位符**变量。以下展示了附加了`ballGun.cs`脚本的**ARCamera**：![球枪脚本](img/0032OS_05_13.jpg)
- en: Now that our script is attached correctly to our **ARCamera** object, we can
    now try it out in the **Game** view. Click on Run and the click over the panel.
    The camera will shoot out balls. The following screenshot shows the `ballGun.cs`
    script in action:![Scripting the ball gun](img/0032OS_05_14.jpg)
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经正确地将脚本附加到**ARCamera**对象上，我们可以在**Game**视图中尝试它。点击运行并点击面板。相机将射出球体。以下截图显示了`ballGun.cs`脚本在运行中的样子：![脚本化球枪](img/0032OS_05_14.jpg)
- en: On testing the script, we might notice that the balls are a little too small
    in comparison to the mole. We can change that through the **Ball** prefab direction
    from the **Prefabs** folder. Select it, and then change the scale value for (x,
    y, z) to `20`. This is a prime example of how useful prefabs are when doing changes,
    because it automatically propagates it for the project.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试脚本时，我们可能会注意到球体相对于鼹鼠来说有点太小。我们可以通过从**Prefabs**文件夹中的**Ball**预制体方向进行更改。选择它，然后更改(x,
    y, z)的缩放值到`20`。这是一个很好的例子，说明了预制体在进行更改时的有用性，因为它会自动将更改传播到整个项目中。
- en: Vuforia trackable event handler
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vuforia可追踪事件处理
- en: More often than not, we need to attach a certain behavior that triggers when
    a trackable is found. To do this, we must understand how to keep a track of trackable
    events, such as trackable found or trackable lost. Vuforia makes this easy for
    us by providing a template script named `DefaultTrackableEventHandler`. This script
    is by default attached to any **ImageTarget** prefab. It should be there now in
    our **ImageTarget** object in the scene.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 更多的时候，我们需要在可追踪对象被找到时触发某种行为。为此，我们必须了解如何跟踪可追踪事件，例如可追踪对象被找到或丢失。Vuforia通过提供一个名为`DefaultTrackableEventHandler`的模板脚本，使我们能够轻松地做到这一点。默认情况下，此脚本会附加到任何**ImageTarget**预制体上。现在它应该已经存在于场景中的**ImageTarget**对象中了。
- en: What the script does is it handles the event of a trackable found or a trackable
    lost. It is the script responsible for rendering the 3D content when the trackable
    is found, and making it disappear when it is lost as well. It is important to
    notice that it is however not responsible for the perspective or the **ARCamera**
    position on the trackable, this is handled by another script , which is beyond
    our scope.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本所执行的操作是处理可追踪对象被找到或丢失的事件。当可追踪对象被找到时，它负责渲染3D内容，当它丢失时，使其消失。需要注意的是，它并不负责可追踪对象上的视角或**ARCamera**的位置，这部分由另一个脚本处理，这超出了我们的范围。
- en: Vuforia recommends that we create our own trackable event handler scripts using
    the `DefaultTrackableEventHandler` script as a template. This is exactly what
    we will do now by adding a very small function to the script.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Vuforia建议我们使用`DefaultTrackableEventHandler`脚本作为模板来创建自己的可追踪事件处理脚本。这正是我们现在将要做的，通过向脚本中添加一个非常小的函数。
- en: 'Open the script named `DefaultTrackableEventHandler`, which can be found inside
    the `Scripts` folder under the `Qualcomm Augmented reality` folder. It should
    look similar to the following screenshot, where the `DefaultTrackableEventHandler.cs`
    script is shown:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 打开名为`DefaultTrackableEventHandler`的脚本，该脚本位于`Qualcomm Augmented reality`文件夹下的`Scripts`文件夹中。它应该看起来类似于以下截图，其中显示了`DefaultTrackableEventHandler.cs`脚本：
- en: '![Vuforia trackable event handler](img/0032OS_05_15.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![Vuforia可追踪事件处理](img/0032OS_05_15.jpg)'
- en: 'The following three functions are important to understand from this script:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从此脚本中，以下三个函数是重要的：
- en: '`OnTrackableStateChanged`: This function is called every time the state of
    the trackable is changed, whether it is found or lost. It then determines if it
    is detected or lost, and appropriately calls on the event function.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnTrackableStateChanged`: 每当可追踪对象的状态发生变化时，无论是被找到还是丢失，都会调用此函数。然后它确定是否被检测到或丢失，并相应地调用事件函数。'
- en: '`OnTrackingFound`: This is the function that is called when the trackable is
    found. It is responsible for rendering all the children of the `ImageTarget` object
    and switching on their colliders.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnTrackingFound`: 当可追踪对象被找到时，会调用此函数。它负责渲染`ImageTarget`对象的全部子对象，并开启它们的碰撞器。'
- en: '`OnTrackingLost`: This function is called when the trackable is lost. It is
    responsible for turning off the rendering for all the child objects of `ImageTarget`.
    It also turns off the collider for them.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnTrackingLost`: 当可追踪对象丢失时，会调用此函数。它负责关闭`ImageTarget`的所有子对象的渲染，并关闭它们的碰撞器。'
- en: These are the three crucial functions in the script. We will leave them as they
    are for our app, but for one modification. We need to add a new function that
    returns the status of the trackable to tell us whether the trackable is detected
    or not. This will be useful for us when animating the mole character, as we will
    see in a little while.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是脚本中的三个关键函数。我们将保持它们不变，但进行一个修改。我们需要添加一个新函数，该函数返回可追踪对象的状态，告诉我们是否检测到可追踪对象。当我们在稍后看到动画的土拨鼠角色时，这将对我们很有用。
- en: Create a new C# script in the `Scripts` folder and name it `MoleTrackableEventHandler`.
    Now copy all the code from the script `DefaultTrackableEventHandler` and paste
    it inside the script we just created. It is important to change the class name
    from `DefaultTrackableEventHandler` to `MoleTrackableEventHandler`, else errors
    will appear in Unity due to the fact that the class name is not the same as the
    filename.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Scripts`文件夹中创建一个新的C#脚本，并将其命名为`MoleTrackableEventHandler`。现在将`DefaultTrackableEventHandler`脚本中的所有代码复制并粘贴到我们刚刚创建的脚本中。重要的是要将类名从`DefaultTrackableEventHandler`更改为`MoleTrackableEventHandler`，否则由于类名与文件名不匹配，Unity中会出现错误。
- en: 'After modification, the script will look similar to the following screenshot,
    where the `MoleTrackableEventHandler.cs` script is shown:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后，脚本将类似于以下截图，其中显示了`MoleTrackableEventHandler.cs`脚本：
- en: '![Vuforia trackable event handler](img/0032OS_05_16.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![Vuforia可追踪事件处理器](img/0032OS_05_16.jpg)'
- en: We added the variable `TrackableStatus`, which we want to hold the state of
    the trackable. It will be `true` if it is visible, and `false` if not. We then
    created a function and named it `trackableVisible`, which will return the variable
    `TrackableStatus`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了变量`TrackableStatus`，我们希望它保存可追踪对象的状态。如果它是可见的，则为`true`，如果不可见，则为`false`。然后我们创建了一个函数，并将其命名为`trackableVisible`，该函数将返回变量`TrackableStatus`。
- en: We then simply set the `TrackableStatus` to `true` when found and `false` when
    not found inside the function `OnTrackableStateChanged()`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`OnTrackableStateChanged()`函数中简单地将`TrackableStatus`设置为`true`，当找到时，设置为`false`，当未找到时。
- en: Now, if we call on the function `trackableVisible()`; it will effectively tell
    us if the trackable is visible or not.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们调用`trackableVisible()`函数；它将有效地告诉我们可追踪对象是否可见。
- en: Now, we need to attach the `MoleTrackableEventHandler` to the `ImageTarget`
    object in our scene. We now do not need `DefaultTrackableEventHandler` attached
    to `ImageTarget`, so we need to delete that component or simply disable it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将`MoleTrackableEventHandler`附加到场景中的`ImageTarget`对象上。我们现在不需要将`DefaultTrackableEventHandler`附加到`ImageTarget`上，因此我们需要删除该组件或简单地禁用它。
- en: '`DefaultTrackabeEventHandler` can be customized later on for all sorts of effects
    such as playing a sound or video when the trackable is found, or controlling specific
    GUI objects to respond to the trackable. It gives us a lot of control over the
    behavior of the AR app, so it always pays off to keep it in mind.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`DefaultTrackabeEventHandler`可以稍后进行自定义，以实现各种效果，例如当找到可追踪对象时播放声音或视频，或控制特定的GUI对象以响应可追踪对象。它为我们提供了对AR应用行为的很大控制，因此始终记住这一点是有益的。'
- en: Adding a Particles prefab
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加粒子预制体
- en: '**Particles** in Unity is a very useful tool that many developers use. With
    it, it is possible to create fog, dust, flames, explosions, and all sorts of effects.
    The effect on resources is usually minimal, as Particles uses small 2D images
    animated to give the effect needed, hence the name Particles.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，**粒子**是一个非常实用的工具，许多开发者都在使用它。使用它，可以创建雾气、灰尘、火焰、爆炸以及各种效果。对资源的影响通常很小，因为粒子使用小的2D图像动画来产生所需的效果，因此得名“粒子”。
- en: For our app, it will be useful to add dust particles appear when we whack the
    mole with the balls fired at them. Although learning how to create particles is
    outside the scope of this book, we will see how we can add one to the scene that
    is already made, because there are a number of free particles available through
    the Unity store.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用，添加当我们用球击打土拨鼠时出现的灰尘粒子将会很有用。尽管学习如何创建粒子超出了本书的范围，但我们将看到我们如何将一个粒子添加到已经制作好的场景中，因为Unity商店中有许多可用的免费粒子。
- en: Import the package named `DustParticles` to the project. Add the prefab we just
    imported to the scene. You will automatically notice the dust cloud being simulated
    in the Editor. Now, we only need to position it appropriately over the molehill
    and have it look as if the dust is rising from the hold, then parent it to the
    Mole object. In a little while, we will see how we can call on this particle system
    and activated it through code.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为`DustParticles`的包导入到项目中。将我们刚刚导入的预制体添加到场景中。你将自动注意到编辑器中正在模拟尘云。现在，我们只需要适当地将其定位在鼠丘上方，使其看起来像尘土从洞中升起，然后将其设置为Mole对象的子对象。不久后，我们将看到如何通过代码调用这个粒子系统并激活它。
- en: Change the position of the **Character** object to be under the ground, because
    this is where they should be when the game starts. It will also give us a good
    idea how the dust will look like with character not present. Simply move the `Character`
    on the y axis till it is just below the ground and not visible. The following
    screenshot shows dust particles added to the scene:![Adding a Particles prefab](img/0032OS_05_17.jpg)
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**角色**对象的位置调整到地面以下，因为游戏开始时它们应该在那里。这也会给我们一个很好的想法，看看没有角色时尘土会是什么样子。只需将`Character`在y轴上移动，直到它刚好在地面以下且不可见。以下截图显示了场景中添加的尘粒：![添加尘粒预制体](img/0032OS_05_17.jpg)
- en: Unity is a great tool, but like everything else, it is not perfect. What it
    lacks, however, is usually remedied by a very active community that create add-ons
    and scripts for it. One of the most useful and free scripts available for Unity
    is iTween.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Unity是一个伟大的工具，但像其他所有东西一样，它并不完美。然而，它所缺乏的通常会被一个非常活跃的社区所弥补，他们会为它创建附加组件和脚本。对于Unity来说，最有用且免费的脚本之一是iTween。
- en: '**iTween** is a script that allows us to animate objects quite easily through
    script. It is very customizable, and fits most object animation needs for games.
    For example, iTween can easily be used to animate a missile in a game to home
    at the target in a fluid manner. In our case, we will use iTween to animate the
    mole coming out of the molehill and going back.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**iTween**是一个脚本，允许我们通过脚本轻松地动画化对象。它非常可定制，适合大多数游戏对象动画需求。例如，iTween可以轻松地用来在游戏中动画化导弹，使其以流畅的方式飞向目标。在我们的案例中，我们将使用iTween来动画化老鼠从鼠丘中出来又回去。'
- en: iTween can be easily added from the Unity's Asset store. It is for free; simply
    search for it in the Unity Asset store, which is accessible from the **Window**
    menu, then download and import into the project. Now, we can access iTween functions
    easily from code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: iTween可以从Unity的Asset商店轻松添加。它是免费的；只需在Unity Asset商店中搜索它，它可以通过**窗口**菜单访问，然后下载并导入到项目中。现在，我们可以从代码中轻松访问iTween函数。
- en: iTween's documentations can be found at [http://itween.pixelplacement.com/documentation.php](http://itween.pixelplacement.com/documentation.php).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: iTween的文档可以在[http://itween.pixelplacement.com/documentation.php](http://itween.pixelplacement.com/documentation.php)找到。
- en: Scripting the mole character
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写老鼠角色的脚本
- en: Now that iTween is in place, let's see how we can script the mole character
    to make use of iTween and animate the character correctly. What we are aiming
    to achieve with the mole script at this stage is to have it animate up and down
    from the molehill. The animation should start at a random time between two ranges
    to avoid repetition and predictability of the behavior.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，iTween已经设置好了，让我们看看如何编写老鼠角色的脚本以利用iTween并正确地动画化角色。在这个阶段，我们希望通过老鼠脚本实现的是让它从鼠丘上下跳动。动画应该从两个范围之间的随机时间开始，以避免行为的重复和可预测性。
- en: 'Let''s take a look at how this script looks like. The following screenshot
    shows `moleAnimator.cs` script:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个脚本的样子。以下截图显示了`moleAnimator.cs`脚本：
- en: '![Scripting the mole character](img/0032OS_05_18.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![编写老鼠角色的脚本](img/0032OS_05_18.jpg)'
- en: The first three lines in the `Start()` function are quite simple. We find and
    attach the mole hit sound source to `moleHitAudio` to be used by us in the script.
    We find and attach the dust particle system to use as a hit effect. We then find
    the `ImageTarget` object and only use the script component `MoleTrackableEventHandler`.
    We do this to be able to call on the function that added, which is `trackableVisible`,
    to check to see if the trackable is visible or not. This is one way of accessing
    other class' functions in Unity.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start()`函数的前三行相当简单。我们找到并附加了击中老鼠的声音源到`moleHitAudio`，以便我们在脚本中使用。我们找到并附加了尘粒系统作为击中效果。然后我们找到`ImageTarget`对象，并且只使用脚本组件`MoleTrackableEventHandler`。我们这样做是为了能够调用添加的功能，即`trackableVisible`，以检查可追踪对象是否可见。这是在Unity中访问其他类函数的一种方式。'
- en: 'The last line in the `Start()` function starts the animation sequence; let''s
    see how it does it:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start()` 函数中的最后一行启动了动画序列；让我们看看它是如何做到的：'
- en: '[PRE3]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is the line of code that starts the whole animation sequence on the mole
    character. `MoveBy()` is a function in the iTween class that allows animating
    objects in a given axis by moving them along it. We first give it the current
    game object to which the script is attached, which will be the mole character,
    and then we pass in the `iTween.Hash` parameters to set what kind of animation
    we want.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是启动鼹鼠角色整个动画序列的代码行。`MoveBy()` 是 iTween 类中的一个函数，它允许通过沿着给定轴移动对象来在给定轴上动画化对象。我们首先给它当前的游戏对象，该脚本附加的对象，即鼹鼠角色，然后我们传递
    `iTween.Hash` 参数来设置我们想要的动画类型。
- en: The parameters for `iTween.Hash` are very important, but easy to understand.
    It follows the syntax of `(parameter name string, parameter value)`. First, we
    give it the actual axis on which we want to animate, which is in our case y axis.
    Then, we set a value for `easyType`, which governs the slowing down and speeding
    up of the animation to make it not feel abrupt; `easeInOutQuad` is a perfect natural
    feel for our character. We set the speed of the animation to `20`. Now for the
    delay, which is the delay of the animation start, we add a random value to make
    moles animate at different times, and not all at the same time, because we will
    have more than one mole in our scene at a later stage. The `oncomplete` parameter
    is the name of the function to be called once the animation is complete. Because
    this line animates the character up and out of the hole, it calls on `animComplete_up`,
    which in turn will animate the character back down and into the hole, as we will
    see next.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`iTween.Hash` 的参数非常重要，但很容易理解。它遵循 `(参数名称字符串，参数值)` 的语法。首先，我们给出我们想要在其实际轴上动画化的轴，在我们的例子中是
    y 轴。然后，我们为 `easyType` 设置一个值，它控制动画的减速和加速，使其不会感觉突兀；`easeInOutQuad` 对我们的角色来说是一种完美的自然感觉。我们将动画速度设置为
    `20`。现在对于延迟，这是动画开始前的延迟，我们添加一个随机值，使鼹鼠在不同的时间动画化，而不是同时，因为在我们场景的后期阶段我们将有不止一个鼹鼠。`oncomplete`
    参数是在动画完成后要调用的函数的名称。因为这一行动画化角色向上并从洞中出来，所以它调用了 `animComplete_up`，这反过来又会将角色动画化回洞中，正如我们接下来将要看到的。'
- en: If we look at the function `animComplete_Up`, we will see that it only contains
    a single line of code that does something similar to what the `Start()` function
    did in its last code line, but reversed. It animates the character back down and
    into the hole, which makes sense, because we want the character to not pop up
    and down from the molehill. Notice that the `oncomplete` parameter calls on `animComplete_Down`,
    which we will take a look at next.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 `animComplete_Up` 函数，我们会看到它只包含一行代码，这行代码执行的操作与 `Start()` 函数在其最后一行代码中执行的操作类似，但方向相反。它将角色动画化回洞中，这是有道理的，因为我们不希望角色从鼹鼠丘上弹跳。注意，`oncomplete`
    参数调用了 `animComplete_Down`，这是我们接下来要查看的。
- en: In function `animComplete_Down`, we do two things. First we check to see if
    the trackable is visible by calling the `trackableVisible()` function, which is
    a member of `MoleTrackableEventHandler`. If the target is visible, we turn on
    `renderer` and `collider` for the object. This makes the object visible and collidable.
    We do this because we will make the mole disappear when the ball hits it, but
    we should only make it reappear if the trackable is visible, otherwise it will
    interfere with how `ImageTarget` renders objects, and we will see floating objects
    on the camera when there is no tracked target. Next, it animates the object back
    up and then `oncomplete` in turn calls `animComplete_Up`, making a perfect recursive
    loop.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `animComplete_Down` 函数中，我们做了两件事。首先，我们通过调用 `trackableVisible()` 函数来检查可追踪对象是否可见，这是
    `MoleTrackableEventHandler` 的一个成员。如果目标可见，我们打开 `renderer` 和 `collider` 对象。这使得对象可见并可碰撞。我们这样做是因为当球击中鼹鼠时，我们将使鼹鼠消失，但只有当可追踪对象可见时，我们才应该使其重新出现，否则它将干扰
    `ImageTarget` 渲染对象的方式，并且当没有追踪目标时，我们将在相机上看到漂浮的对象。接下来，它将对象动画化回原位，然后 `oncomplete`
    依次调用 `animComplete_Up`，形成一个完美的递归循环。
- en: The last function, which is `OnCollisionEnter`, is a Unity event that fires
    up whenever two colliders collide with each other. It is sent to any object with
    a collider attached to it. We use this event to check if any ball hit the mole
    or not. If it does hit the mole, we then play the hit sound and the dust particles.
    We then turn off the renderer of the object to make it disappear and turn off
    the collider to not interfere with any more balls.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个函数，即 `OnCollisionEnter`，是Unity事件，每当两个碰撞体相互碰撞时都会触发。它发送到任何附加了碰撞体的对象。我们使用此事件来检查是否有球击中了鼹鼠。如果击中了鼹鼠，我们就播放击打音效和灰尘粒子。然后我们关闭对象的渲染器使其消失，并关闭碰撞体以避免干扰其他球。
- en: This is the script that will handle the mole behavior for us. Now all we have
    to do is attach it to the `Character` object inside the `WhackAMoleModel` object
    and hit Play. We can immediately see the mole is animating correctly and randomly.
    Also, if a ball hits it, sound effects and dust particles are played, indicating
    a correct whack.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将为我们处理鼹鼠行为的脚本。现在我们只需将其附加到 `WhackAMoleModel` 对象内部的 `Character` 对象上，然后播放。我们可以立即看到鼹鼠正在正确且随机地动画化。此外，如果球击中它，会播放音效和灰尘粒子，表示击打正确。
- en: Now as our mole object is complete, prefab the whole object into the `Prefabs`
    folder and then add multiple mole objects into the scene to have more than one
    mole. Add as many as you would want, but I believe four is a good enough number,
    considering how small the trackable is.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们完成了鼹鼠对象，将其整个预制件放入 `Prefabs` 文件夹中，然后将多个鼹鼠对象添加到场景中，以便有不止一个鼹鼠。添加尽可能多的鼹鼠，但我相信四个就足够了，考虑到可追踪物的大小。
- en: Mask shader
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遮罩着色器
- en: We are mostly done with the game. We have the behavior of all our objects in
    place and are ready for deployment; but we are missing one last thing. We might
    have noticed that when the moles go underground, they are still visible from the
    side angle. This will be apparent as well when deploying the app to the device
    in AR environment. There is an easy solution we can do to hide those moles when
    they go underground in an AR environment, which is using a depth mask shader.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏开发基本完成。我们已经设置了所有对象的行为，并准备部署；但我们还缺少最后一件事。我们可能已经注意到，当鼹鼠钻入地下时，它们仍然可以从侧面看到。当将应用程序部署到AR环境中的设备上时，这也会很明显。我们有一个简单的解决方案可以隐藏在AR环境中地下钻入的鼹鼠，那就是使用深度遮罩着色器。
- en: Add the shader asset named `DepthMask.shader`, which can be found in the chapter's
    assets. Then, we want to create a cube in our scene that will be as big as the
    ground plane and name it `mask`, and hide all the moles behind it, as shown in
    the following screenshot. The following screenshot also shows the **Mask** object
    added to scene:![Mask shader](img/0032OS_05_19.jpg)
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为 `DepthMask.shader` 的着色器资产添加到章节的资产中。然后，我们想在场景中创建一个与地面平面一样大的立方体，命名为 `mask`，并隐藏其后的所有鼹鼠，如下面的截图所示。下面的截图还显示了添加到场景中的
    **Mask** 对象：![Mask shader](img/0032OS_05_19.jpg)
- en: Of course, this object is not acting as a mask yet, it is just an ordinary cube.
    To give it the mask properties, we need to create a material for it in the **Materials**
    folder and name it `Mask`. Because we added the **DepthMask** shader, it should
    be automatically available in the **Shader** dropdown list for the material. Simply
    choose the **DepthMask** shader from there, and then attach the material to the
    **Mask** object. The following screenshot shows the **DepthMask** shader activated:![Mask
    shader](img/0032OS_05_20.jpg)
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，这个对象目前还没有作为遮罩使用，它只是一个普通的立方体。为了给它遮罩属性，我们需要在 **Materials** 文件夹中为其创建一个材质，命名为
    `Mask`。因为我们添加了 **DepthMask** 着色器，它应该会自动出现在材质的 **Shader** 下拉列表中。只需从那里选择 **DepthMask**
    着色器，然后将材质附加到 **Mask** 对象上。下面的截图显示了激活的 **DepthMask** 着色器：![Mask shader](img/0032OS_05_20.jpg)
- en: We immediately notice that the cube has disappeared, but further inspection
    reveals that not only the cube is not visible, but also the moles behind it. This
    effectively fixes our problem by hiding the moles underground.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们立即注意到立方体消失了，但进一步的检查发现，不仅立方体不可见，而且其后的鼹鼠也不可见。这有效地解决了我们的问题，通过隐藏地下鼹鼠。
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we covered a lot of ground on the advanced AR development in
    Unity. We created a perfectly functional and fun game that utilizes a lot of concepts
    in both Unity and Vuforia. All we need to do now is deploy the game to a device
    and play with it. Maybe add a score system, or maybe add a limited number of balls
    to hit the mole. The sky is your limit. Experiment with it, and create an experience
    that users will appreciate.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细介绍了在Unity中高级AR开发的众多内容。我们创建了一个功能完善且有趣的游戏，该游戏利用了Unity和Vuforia中的许多概念。现在我们所需做的只是将游戏部署到设备上并玩它。也许可以添加一个得分系统，或者也许可以添加有限数量的球来击打鼹鼠。天空是你的极限。尝试各种可能性，并创造一个用户会欣赏的体验。
