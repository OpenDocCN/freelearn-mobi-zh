<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-35"><a id="_idTextAnchor041" class="calibre3 pcalibre pcalibre1"/>3</h1>
<h1 id="_idParaDest-36" class="calibre6"><a id="_idTextAnchor042" class="calibre3 pcalibre pcalibre1"/>Jetpack Compose Layout Basics</h1>
<p class="calibre4">A good UI and user experience are core to our apps. As Android developers, we must be keenly aware of these two areas and learn how to use the different tools provided for us to create UIs. Google introduced <strong class="bold">Jetpack Compose</strong>, a modern UI toolkit to help<a id="_idIndexMarker075" class="calibre3 pcalibre pcalibre1"/><a id="_idIndexMarker076" class="calibre3 pcalibre pcalibre1"/> developers create intuitive UIs with ease.</p>
<p class="calibre4">In this chapter, we’ll look at Jetpack Compose, a declarative way of creating UIs for our apps. We will learn the basics of Jetpack Compose and layouts in Jetpack Compose.</p>
<p class="calibre4">In this chapter, we’re going to cover the following main topics:</p>
<ul class="calibre16">
<li class="calibre15">Introduction to Jetpack Compose</li>
<li class="calibre15">Jetpack Compose layouts</li>
</ul>
<h1 id="_idParaDest-37" class="calibre6"><a id="_idTextAnchor043" class="calibre3 pcalibre pcalibre1"/>Technical requirements</h1>
<p class="calibre4">To follow the instructions in this chapter, you will need to have Android Studio Hedgehog or later (<a href="https://developer.android.com/studio" class="calibre3 pcalibre pcalibre1">https://developer.android.com/studio</a>) downloaded.</p>
<p class="calibre4">You can find the code for this chapter at <a href="https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterthree" class="calibre3 pcalibre pcalibre1">https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterthree</a>.</p>
<h1 id="_idParaDest-38" class="calibre6"><a id="_idTextAnchor044" class="calibre3 pcalibre pcalibre1"/>Introduction to Jetpack Compose</h1>
<p class="calibre4">Over the years, Android UI development <a id="_idIndexMarker077" class="calibre3 pcalibre pcalibre1"/><a id="_idIndexMarker078" class="calibre3 pcalibre pcalibre1"/>has undergone significant transformations with various frameworks and libraries emerging to simplify the process.</p>
<p class="calibre4">Before Jetpack Compose, this is <a id="_idIndexMarker079" class="calibre3 pcalibre pcalibre1"/><a id="_idIndexMarker080" class="calibre3 pcalibre pcalibre1"/>how we used to write UIs for our apps:</p>
<ul class="calibre16">
<li class="calibre15">Views were inflated from XML layout files. XML-based views are still supported alongside Jetpack Compose for backward compatibility and mixed use cases where apps have both XML layouts and Jetpack Compose.</li>
<li class="calibre15">Themes, styles, and value resources were also defined in XML files.</li>
<li class="calibre15">For us to be able to access the views from XML files, we used view binding or data binding.</li>
<li class="calibre15">This method of writing a UI required huge effort, requiring more boilerplate code and being error prone.</li>
</ul>
<p class="calibre4">Google developed Jetpack Compose as a modern <strong class="bold">declarative</strong> UI toolkit. It allows us to <a id="_idIndexMarker081" class="calibre3 pcalibre pcalibre1"/><a id="_idIndexMarker082" class="calibre3 pcalibre pcalibre1"/><a id="_idIndexMarker083" class="calibre3 pcalibre pcalibre1"/>create UIs with less code. Layouts created in Jetpack Compose are responsive to different screen sizes and orientations. It is also easier and more productive to write UIs in Compose. With Jetpack Compose, we can reuse components across our code bases. Jetpack Compose also allows us to use code from XML components in our composables.</p>
<p class="calibre4">Jetpack Compose is entirely in Kotlin, meaning it takes advantage of the powerful language features that Kotlin offers. The <strong class="bold">view system</strong>, which was<a id="_idIndexMarker084" class="calibre3 pcalibre pcalibre1"/><a id="_idIndexMarker085" class="calibre3 pcalibre pcalibre1"/> used to create UIs before Compose, was more procedural. We had to manage complex life cycles and handle any changes in state manually. Jetpack Compose is a whole other paradigm that uses declarative programming. We describe what the UI should be like based on a state. This enables us to have dynamic content and less boilerplate code and develop our UIs faster.</p>
<p class="calibre4">To understand Jetpack Compose, let us first dive deep into the differences between the declarative and imperative approaches to writing UIs.</p>
<h2 id="_idParaDest-39" class="calibre7"><a id="_idTextAnchor045" class="calibre3 pcalibre pcalibre1"/>Declarative versus imperative UIs</h2>
<p class="calibre4">In imperative UIs, we specify step by step<a id="_idIndexMarker086" class="calibre3 pcalibre pcalibre1"/><a id="_idIndexMarker087" class="calibre3 pcalibre pcalibre1"/> the instructions describing how the UI should be built and updated. We explicitly define the sequence of operations to create and modify UI elements. We rely on mutable state variables to represent the current state of the UI. We manually update these state variables as the UI changes and respond to<a id="_idIndexMarker088" class="calibre3 pcalibre pcalibre1"/><a id="_idIndexMarker089" class="calibre3 pcalibre pcalibre1"/> user interactions.</p>
<p class="calibre4">In declarative UIs, we focus on describing the desired outcome rather than specifying the step-by-step instructions. We define what the UI should look like based on the current state, and the framework handles the rest. We define the UI using declarative markup or code. We express the desired UI structure, layout, and behavior by describing the relationships between UI elements and their properties.</p>
<p class="calibre4">The declarative approach puts more emphasis on the immutable state, where the UI state is represented by immutable data objects. Instead of directly mutating the state, we create new instances of the data objects to reflect the desired changes in the UI.</p>
<p class="calibre4">In a declarative UI, the framework takes care of updating the UI based on changes in the application state. We specify the relationships between the UI and the underlying state, and the framework automatically updates the UI to reflect those changes.</p>
<p class="calibre4">Now that we understand both imperative and declarative approaches, let’s look at an example of each. Let’s create a simple UI for a counter using <a id="_idIndexMarker090" class="calibre3 pcalibre pcalibre1"/><a id="_idIndexMarker091" class="calibre3 pcalibre pcalibre1"/>both the declarative UI in Jetpack Compose (Kotlin) and the imperative UI in XML (Android XML layout). The example will showcase the differences in syntax and the approach between the two. The Jetpack Compose<a id="_idIndexMarker092" class="calibre3 pcalibre pcalibre1"/><a id="_idIndexMarker093" class="calibre3 pcalibre pcalibre1"/> version looks like this:</p>
<pre class="source-code">
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
class MainActivity : ComponentActivity() {
  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContent {
        MyApp()
    }
  }
}
@Composable
fun MyApp() {
  var count by remember { mutableStateOf(0) }
  Column(
    modifier = Modifier.padding(16.dp)
  ) {
      Text(text = "Counter: $count", style = MaterialTheme.typography.bodyLarge)
      Spacer(modifier = Modifier.height(16.dp))
      Button(onClick = { count++ }) {
        Text("Increment")
      }
    }
}</pre> <p class="calibre4">In the preceding example, we have a <code>MyApp</code> composable function that defines the UI for the app. The UI is defined in a declarative manner, by using composables to define the UI and handling state changes using the remember composable. The UI is defined using a functional approach. Also, we can see that the UI is defined in a more concise manner.</p>
<p class="calibre4">With the imperative approach, we <a id="_idIndexMarker094" class="calibre3 pcalibre pcalibre1"/><a id="_idIndexMarker095" class="calibre3 pcalibre pcalibre1"/>must first create the<a id="_idIndexMarker096" class="calibre3 pcalibre pcalibre1"/><a id="_idIndexMarker097" class="calibre3 pcalibre pcalibre1"/> XML UI, as shown in the following code block:</p>
<pre class="source-code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;RelativeLayout 
  
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  android:padding="16dp"&gt;
  &lt;TextView
    android:id="@+id/counterTextView"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_centerHorizontal="true"
    android:text="Counter: 0"
    android:textSize="20sp" /&gt;
  &lt;Button
    android:id="@+id/incrementButton"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_below="@id/counterTextView"
    android:layout_centerHorizontal="true"
    android:layout_marginTop="16dp"
    android:text="Increment" /&gt;
&lt;/RelativeLayout&gt;</pre> <p class="calibre4">With the layout file created, we can now create the activity class, which will inflate the layout file and handle the button click:</p>
<pre class="source-code">
import android.os.Bundle
import android.widget.Button
import android.widget.TextView
import androidx.appcompat.app.AppCompatActivity
class MainActivity : AppCompatActivity() {
  private var count = 0
  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)
    val counterTextView: TextView = findViewById(R.id.counterTextView)
    val incrementButton: Button = findViewById(R.id.incrementButton)
    incrementButton.setOnClickListener {
      count++
      counterTextView.text = "Counter: $count"
    }
  }
}</pre> <p class="calibre4">In this example, the XML layout is inflated in the <code>onCreate</code> method of the <code>MainActivity</code> class, and UI elements are accessed and manipulated programmatically.</p>
<p class="calibre4">In the preceding examples, the Jetpack Compose code is written in Kotlin and provides a more declarative approach, defining the UI in<a id="_idIndexMarker098" class="calibre3 pcalibre pcalibre1"/><a id="_idIndexMarker099" class="calibre3 pcalibre pcalibre1"/> a functional manner. The XML layout, on the other hand, is written imperatively in XML, specifying the <a id="_idIndexMarker100" class="calibre3 pcalibre pcalibre1"/><a id="_idIndexMarker101" class="calibre3 pcalibre pcalibre1"/>UI structure and properties in a more step-by-step manner using XML and interacting with them imperatively in Kotlin code. Jetpack Compose allows for a more concise and expressive representation of the UI using a declarative syntax.</p>
<p class="calibre4">Now that we have a clear understanding of the imperative and declarative ways of writing UIs, in the next section, we will be diving deep into the building blocks of Jetpack Compose.</p>
<h2 id="_idParaDest-40" class="calibre7"><a id="_idTextAnchor046" class="calibre3 pcalibre pcalibre1"/>Composable functions</h2>
<p class="calibre4">As shown in <em class="italic">Figure 3</em><em class="italic">.1</em>, composable functions are<a id="_idIndexMarker102" class="calibre3 pcalibre pcalibre1"/><a id="_idIndexMarker103" class="calibre3 pcalibre pcalibre1"/> the main building<a id="_idIndexMarker104" class="calibre3 pcalibre pcalibre1"/><a id="_idIndexMarker105" class="calibre3 pcalibre pcalibre1"/> blocks of Jetpack Compose:</p>
<div><div><img alt="Figure 3.1 – Compose UI" src="img/B19779_03_01.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Compose UI</p>
<p class="calibre4">A composable function describes how to render a UI. This function must be annotated with the <code>@Composable</code> function. When you annotate a function with this annotation, it means that the function describes how to compose a specific part of the UI. Composable functions are meant to be <strong class="bold">reusable</strong>. They can be called multiple times while the UI is <a id="_idIndexMarker106" class="calibre3 pcalibre pcalibre1"/><a id="_idIndexMarker107" class="calibre3 pcalibre pcalibre1"/>active. Whenever the state of the composable changes, it goes through a process of <a id="_idIndexMarker108" class="calibre3 pcalibre pcalibre1"/><a id="_idIndexMarker109" class="calibre3 pcalibre pcalibre1"/>recomposition, which enables the UI to display the latest state.</p>
<p class="calibre4">Composable functions are <strong class="bold">pure functions</strong>, meaning they <a id="_idIndexMarker110" class="calibre3 pcalibre pcalibre1"/><a id="_idIndexMarker111" class="calibre3 pcalibre pcalibre1"/>don’t have any side effects. They produce the same output when called several times with the same input. This ensures the functions are predictable and efficient in dispatching updates to the UI. However, there are exceptions, for example, launching a coroutine within a composable of calling external methods that do have side-effects, which should be avoided or handled carefully.</p>
<p class="calibre4">Smaller composable functions can be combined to build complex UIs. You can reuse and nest composables inside other composables.</p>
<p class="calibre4">Let’s look at an example of a composable function:</p>
<pre class="source-code">
@Composable
fun PacktPublishing(bookName: String) {
    Text(text = "Title of the book is: $bookName")
}
PacktPublishing</strong> function is annotated with the <code>@Composable</code> annotation. The function takes a parameter, <code>bookName</code>, which is a <code>String</code>. Inside the function, we have another composable from the Material <a id="_idIndexMarker112" class="calibre3 pcalibre pcalibre1"/><a id="_idIndexMarker113" class="calibre3 pcalibre pcalibre1"/>Design library. The composable renders some text to our UI.</pre>
<p class="calibre4">When designing our UIs, we usually want to see<a id="_idIndexMarker114" class="calibre3 pcalibre pcalibre1"/><a id="_idIndexMarker115" class="calibre3 pcalibre pcalibre1"/> how the UIs look without running our app. Luckily, we have <strong class="bold">previews</strong>, which visualize our composable functions. We will be learning about them in the next section.</p>
<h2 id="_idParaDest-41" class="calibre7"><a id="_idTextAnchor047" class="calibre3 pcalibre pcalibre1"/>Previews</h2>
<p class="calibre4">In Jetpack Compose, we have the <code>@Preview</code> annotation, which generates a preview of our composable function or a group of Compose components<a id="_idIndexMarker116" class="calibre3 pcalibre pcalibre1"/><a id="_idIndexMarker117" class="calibre3 pcalibre pcalibre1"/> inside Android Studio. It has an interactive mode to allow us to interact with our <a id="_idIndexMarker118" class="calibre3 pcalibre pcalibre1"/><a id="_idIndexMarker119" class="calibre3 pcalibre pcalibre1"/>Compose functions. This gives us a way to quickly visualize our designs and easily make changes when needed.</p>
<p class="calibre4">This is how our <code>PacktPublishing</code> composable function would look like with a preview:</p>
<pre class="source-code">
@Preview(showBackground = true)
@Composable
fun PacktPublishingPreview() {
    PacktPublishing("Android Development with Kotlin")
}</pre> <p class="calibre4">We have used the <code>@Preview</code> annotation to indicate that we want to build a preview for this function. Additionally, we have set the <code>showBackground</code> parameter to <code>true</code>, which adds a white background to our preview. We have named the function with the <code>Preview</code> suffix. The preview is also a composable function.</p>
<p class="calibre4">To be able to see the preview, you need to be in the <strong class="bold">split or design mode</strong> in your<a id="_idIndexMarker120" class="calibre3 pcalibre pcalibre1"/><a id="_idIndexMarker121" class="calibre3 pcalibre pcalibre1"/> editor. These options are normally at the top right of Android Studio. We also need to do a build for Android Studio to generate a preview, which will look as follows:</p>
<div><div><img alt="Figure 3.2 – Text preview" src="img/B19779_03_02.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Text preview</p>
<p class="calibre4">As seen in <em class="italic">Figure 3</em><em class="italic">.2</em>, we have a text that displays the string that we passed to the function. The preview also has a white background and its name at the top left.</p>
<p class="calibre4">We can show previews for both dark and light color schemes. We can also configure properties such as the devices and preview windows to be applied.</p>
<p class="calibre4">Previews are great for quick iterations while designing UIs. However, they are not a replacement for actual device/emulator testing, particularly<a id="_idIndexMarker122" class="calibre3 pcalibre pcalibre1"/><a id="_idIndexMarker123" class="calibre3 pcalibre pcalibre1"/> for things such <a id="_idIndexMarker124" class="calibre3 pcalibre pcalibre1"/><a id="_idIndexMarker125" class="calibre3 pcalibre pcalibre1"/>as animations, interactions, or dynamic data.</p>
<p class="calibre4">With an understanding of what previews are and how to create them, let us look into one more Compose feature, <strong class="bold">modifiers</strong>, in the next section.</p>
<h2 id="_idParaDest-42" class="calibre7"><a id="_idTextAnchor048" class="calibre3 pcalibre pcalibre1"/>Modifiers</h2>
<p class="calibre4">Modifiers allow us to decorate our<a id="_idIndexMarker126" class="calibre3 pcalibre pcalibre1"/><a id="_idIndexMarker127" class="calibre3 pcalibre pcalibre1"/> composable functions by enabling the following:</p>
<ul class="calibre16">
<li class="calibre15">Change composables’ size, behavior, and appearance</li>
<li class="calibre15">Add more information</li>
<li class="calibre15">Process user input</li>
<li class="calibre15">Add interactions such as clicks and ripple effects</li>
</ul>
<p class="calibre4">With modifiers, we can change various aspects of our composable, such as size, padding, color, and shape. Most Jetpack Compose components from the library allow us to provide a modifier as a parameter. For example, if we need to provide padding to our preview text, we will have the following:</p>
<pre class="source-code">
Text(
    modifier = Modifier.padding(16.dp),
    text = "Title of the book is: $bookName"
)</pre> <p class="calibre4">We have added the padding modifier to the <code>Text</code> composable. This will add <code>16.dp</code><code>Text</code> composable. <code>16.dp</code> is a <strong class="bold">density-independent</strong> pixel unit in Jetpack <a id="_idIndexMarker128" class="calibre3 pcalibre pcalibre1"/><a id="_idIndexMarker129" class="calibre3 pcalibre pcalibre1"/>Compose. This means it will remain consistent and adjust properly to different screen densities.</p>
<p class="calibre4">We can chain the different modifier functions in one composable. When chaining modifiers, the order of application is crucial. If we don’t achieve the desired result, we need to double-check the order. Let’s observe this concept in practice:</p>
<pre class="source-code">
Text(
    modifier = Modifier
        .fillMaxWidth()
        .padding(16.dp)
        .background(Color.Green),
    text = "Title of the book is: $bookName"
)</pre> <p class="calibre4">We have added two more modifiers. The first is the <code>fillMaxWidth</code> modifier, which is added to the text composable. This will make the text <a id="_idIndexMarker130" class="calibre3 pcalibre pcalibre1"/><a id="_idIndexMarker131" class="calibre3 pcalibre pcalibre1"/>composable take the full width of the parent. The other one is the background modifier to the <code>Text</code> composable. This will<a id="_idIndexMarker132" class="calibre3 pcalibre pcalibre1"/><a id="_idIndexMarker133" class="calibre3 pcalibre pcalibre1"/> add a background color to the text composable. The preview for our text will look as follows:</p>
<div><div><img alt="Figure 3.3 – Text modifier preview" src="img/B19779_03_03.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Text modifier preview</p>
<p class="calibre4">As seen in the preceding screenshot, the text now occupies the whole width of the device and has a green background. It also has a padding of <code>16dp</code> all around.</p>
<p class="calibre4">Modifiers do not modify the original composable. They return a new, modified instance. This ensures our composable remains unchanged and immutable. Immutability, a fundamental principle in functional programming, ensures that the state remains unchanged, simplifying state management and reducing side effects. This approach enhances predictability and readability by adhering to the principles of referential transparency. The ability to compose functions, exemplified by chaining modifier functions, facilitates a concise and readable expression of complex UI behavior without altering the original composable. In addition to using the existing modifiers, we can also create our own modifiers when needed.</p>
<p class="calibre4">Now that you have an understanding of what modifiers are, we are going to build on that knowledge by learning about Jetpack Compose layouts in the next section.</p>
<h1 id="_idParaDest-43" class="calibre6"><a id="_idTextAnchor049" class="calibre3 pcalibre pcalibre1"/>Jetpack Compose layouts</h1>
<p class="calibre4">Jetpack Compose has a variety of pre-built layouts <a id="_idIndexMarker134" class="calibre3 pcalibre pcalibre1"/><a id="_idIndexMarker135" class="calibre3 pcalibre pcalibre1"/>for us to use. Before looking at the different layouts present, let us first understand how Jetpack Compose transforms<a id="_idIndexMarker136" class="calibre3 pcalibre pcalibre1"/><a id="_idIndexMarker137" class="calibre3 pcalibre pcalibre1"/> state into UI.</p>
<div><div><img alt="Figure 3.4 – How Compose transforms state into UI" src="img/B19779_03_04.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.4 – How Compose transforms state into UI</p>
<p class="calibre4">From the preceding diagram, we can see that our state is transformed into a UI in the following steps:</p>
<ol class="calibre14">
<li class="calibre15"><strong class="bold">Composition</strong><p class="calibre4">This is the initial phase. The Compose compiler creates a tree of UI elements. Each element is a function that represents a UI element. Compose then calls the functions to create the UI tree. The composition step is responsible for determining <a id="_idIndexMarker138" class="calibre3 pcalibre pcalibre1"/>which composables need updates and which ones can be reused. This happens by comparing a previous tree of composables with the new tree and only updating the ones that have changed. This makes this step very efficient as only elements with updates are updated.</p></li>
<li class="calibre15"><strong class="bold">Layout</strong><p class="calibre4">This step happens after the composition phase. Here, the Compose compiler takes the tree generated in the composition phase and determines its size, position, and layout. Each composable is measured and positioned within the layout based on its parent and any constraints set. This phase is responsible for determining the final position and size of each UI element on the screen. It is also responsible for creating the final layout tree used in the drawing phase.</p></li>
<li class="calibre15"><strong class="bold">Drawing</strong><p class="calibre4">This is the last phase of transforming our UI to state. In this phase, the Compose compiler takes the final layout tree created in the layout phase and uses it to draw the elements on the screen. This is done by walking through the tree and issuing draw commands to the underlying graphics system. This phase is responsible for rendering the final UI on the screen.</p></li>
</ol>
<p class="calibre4">These three phases<a id="_idIndexMarker139" class="calibre3 pcalibre pcalibre1"/> work together to create our UI in Jetpack Compose. The composition phase builds a tree of composables, the layout phase positions and sizes them, and the drawing phase renders them on the screen. This entire process is optimized, performant, and efficient, allowing for fast and smooth UI rendering in even complex UIs.</p>
<p class="calibre4">Now that we understand how the Compose compiler renders our UI, let us see the layouts that are in Compose.</p>
<p class="calibre4">Jetpack Compose offers the following layouts out of the box:</p>
<ul class="calibre16">
<li class="calibre15"><strong class="source-inline1">Column</strong></li>
<li class="calibre15"><strong class="source-inline1">Row</strong></li>
<li class="calibre15"><strong class="source-inline1">Box</strong></li>
<li class="calibre15">Lists</li>
</ul>
<p class="calibre4">We are going to look at each of these layouts in detail in the next subsections. To begin with, let us look the <code>Column</code> layout.</p>
<h2 id="_idParaDest-44" class="calibre7"><a id="_idTextAnchor050" class="calibre3 pcalibre pcalibre1"/>Column</h2>
<p class="calibre4">We use <code>Column</code> when we <a id="_idIndexMarker140" class="calibre3 pcalibre pcalibre1"/>want to organize items vertically. An example of the use of <code>Column</code> is as follows:</p>
<pre class="source-code">
Column {
    Text(text = "Android")
    Text(text = "Kotlin")
    Text(text = "Compose")
}</pre> <p class="calibre4">In the preceding code, we have created <code>Column</code> with three text elements. Adding a preview for this <a id="_idIndexMarker141" class="calibre3 pcalibre pcalibre1"/>generates the following UI for us:</p>
<div><div><img alt="Figure 3.5 – Column preview" src="img/B19779_03_05.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Column preview</p>
<p class="calibre4">As seen from the preceding screenshot, the design is basic. We are going to polish it up a bit by using modifiers since Jetpack Compose also provides support for modifiers in these layouts. Let us add these changes to our column:</p>
<pre class="source-code">
Column(
    modifier = Modifier
        .fillMaxSize()
        .padding(16.dp),
    verticalArrangement = Arrangement.Center,
    horizontalAlignment = Alignment.CenterHorizontally
) {
    Text(text = "Android")
    Text(text = "Kotlin")
    Text(text = "Compose")
}</pre> <p class="calibre4">Here, we have added a <code>Modifier</code> to our <code>Column</code>. In the modifier parameter, we specify the <code>fillMaxSize</code> modifier, which makes our column fill the available space within the parent. This is helpful for <a id="_idIndexMarker142" class="calibre3 pcalibre pcalibre1"/>building full-view screens for our UIs. We have also added padding of <code>16.dp</code> to our column.</p>
<p class="calibre4">Additionally, we have specified two more parameters for our column. One is <code>verticalArrangement</code>, which we use to specify the vertical arrangement of the children of this view. In this case, we specify <code>Arrangement.Center</code>, which places all the children of our <code>Column</code> vertically at the center. The other parameter is <code>horizontalAlignment</code>, which is the horizontal alignment of the children of the layout. In this case, we specify the value to be <code>Alignment.CenterHorizontally</code>, which will align all the children at the center horizontally. Our preview with the preceding changes will look like this:</p>
<div><div><img alt="Figure 3.6 – Column modifiers preview" src="img/B19779_03_06.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Column modifiers preview</p>
<p class="calibre4">From the preceding screenshot, we can now see our column occupies the whole screen and all the text elements are<a id="_idIndexMarker143" class="calibre3 pcalibre pcalibre1"/> centered vertically and horizontally within the parent.</p>
<p class="calibre4">Let us now learn about the <code>Row</code> composable in the next section.</p>
<h2 id="_idParaDest-45" class="calibre7"><a id="_idTextAnchor051" class="calibre3 pcalibre pcalibre1"/>Row</h2>
<p class="calibre4">We use <code>Row</code> when we<a id="_idIndexMarker144" class="calibre3 pcalibre pcalibre1"/> want to organize items horizontally. An example of the use of <code>Row</code> is as follows:</p>
<pre class="source-code">
Row {
    Text(text = "Android")
    Text(text = "Kotlin")
    Text(text = "Compose")
}</pre> <p class="calibre4">In the preceding code, the <code>Row</code> composable<a id="_idIndexMarker145" class="calibre3 pcalibre pcalibre1"/> is used to display three text elements horizontally in a row. The preview for this will look like this:</p>
<div><div><img alt="Figure 3.7 – Row preview" src="img/B19779_03_07.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.7 – Row preview</p>
<p class="calibre4">The text elements are all arranged next to each other in a horizontal row. <code>Row</code>, like the composable, supports the addition of modifiers. Let us modify our <code>Row</code> to look as follows:</p>
<pre class="source-code">
Row(
    modifier = Modifier
        .fillMaxSize()
        .padding(16.dp),
    verticalAlignment = Alignment.CenterVertically,
    horizontalArrangement = Arrangement.SpaceEvenly
) {
    Text(text = "Android")
    Text(text = "Kotlin")
    Text(text = "Compose")
}</pre> <p class="calibre4">In the preceding code, we have added modifiers to the <code>Row</code> composable. The <code>fillMaxSize</code> modifier makes the row fill the entire available space. The padding modifier adds padding to the <code>Row</code>. The <code>verticalAlignment</code> and <code>horizontalArrangement</code> modifiers are used to align the children of the <code>Row</code> vertically and horizontally, respectively. Notice <a id="_idIndexMarker146" class="calibre3 pcalibre pcalibre1"/>that for the <code>horizontalArrangement</code> modifier, we use the <code>Arrangement.SpaceEvenly</code> option. This makes sure each of the children occupies equal space in the parent. The preview for this looks as follows:</p>
<div><div><img alt="Figure 3.8 – Row modifiers preview" src="img/B19779_03_08.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.8 – Row modifiers preview</p>
<p class="calibre4">As seen in <em class="italic">Figure 3</em><em class="italic">.8</em>, the row occupies the whole screen, and the text elements are evenly spaced within the<a id="_idIndexMarker147" class="calibre3 pcalibre pcalibre1"/> screen width.</p>
<p class="calibre4">In the next section, we will be learning about the <code>Box</code> layout.</p>
<h2 id="_idParaDest-46" class="calibre7"><a id="_idTextAnchor052" class="calibre3 pcalibre pcalibre1"/>Box</h2>
<p class="calibre4">The <code>Box</code> layout allows us<a id="_idIndexMarker148" class="calibre3 pcalibre pcalibre1"/> to position child elements in a flexible way using the X and Y coordinates. Let us see a code example:</p>
<pre class="source-code">
Box(
    modifier = Modifier
        .size(100.dp),
    contentAlignment = Alignment.Center
) {
    Icon(
        modifier = Modifier
            .size(80.dp),
        imageVector = Icons.Outlined.Notifications,
        contentDescription = null,
        tint = Color.Green
    )
    Text(text = "9")
}</pre> <p class="calibre4">In the preceding code, we have a <code>Box</code> composable that has an <code>Icon</code> and <code>Text</code> composable as its children. We have <a id="_idIndexMarker149" class="calibre3 pcalibre pcalibre1"/>set the size of the <code>Box</code> composable to <code>100.dp</code> and the <code>Icon</code> composable to <code>80.dp</code>. The text and icon composables are placed in the center of the <code>Box</code> composable using the <code>contentAlignment</code> parameter. They are placed in the center of the <code>Box</code> composable because we have specified the <code>contentAlignment</code> parameter as <code>Alignment.Center</code>. They are also stacked on top of each other because the <code>Box</code> composable is a layout composable that stacks its children on top of each other. The preview for our <code>Box</code> composable looks as follows:</p>
<div><div><img alt="Figure 3.9 – Box preview" src="img/B19779_03_09.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.9 – Box preview</p>
<p class="calibre4">As we can see from <em class="italic">Figure 3</em><em class="italic">.9</em>, the notification icon and the text are stacked together. The <code>Box</code> composable enables us to<a id="_idIndexMarker150" class="calibre3 pcalibre pcalibre1"/> achieve this and much more.</p>
<p class="calibre4">Now let us look at how to display lists in Jetpack Compose in the next section.</p>
<h2 id="_idParaDest-47" class="calibre7"><a id="_idTextAnchor053" class="calibre3 pcalibre pcalibre1"/>Lists</h2>
<p class="calibre4">As Android developers, we<a id="_idIndexMarker151" class="calibre3 pcalibre pcalibre1"/> need to make apps that display lists of items. It can be a list of movies, orders, songs, or books. So, how do we do that in Compose? The good news for us is that Jetpack Compose makes it easier for us to do so. Compose provides the <code>LazyColumn</code> and <code>LazyRow</code> components, which can be used to display a list of items. These components are very efficient and performant. They only render the items that are visible on the screen, rather than rendering all the items at once. <code>LazyColumn</code> displays items vertically, while <code>LazyRow</code> displays items horizontally. <code>LazyColumn</code> and <code>LazyRow</code> are normally optimized for large datasets and at times are not suitable for all use cases. These composable functions allow you to define<a id="_idIndexMarker152" class="calibre3 pcalibre pcalibre1"/> the contents of the list as a function that returns a single item, and then Compose will automatically generate and render the UI elements for each item in the list as they become visible on the screen.</p>
<p class="calibre4">Let’s see an example of <code>LazyColumn</code>:</p>
<pre class="source-code">
LazyColumn(
    modifier = Modifier
        .fillMaxSize()
        .background(Color.LightGray)
) {
    items(100) {
        Text(
            modifier = Modifier
                .padding(8.dp),
            text = "Item number $it"
        )
    }
}</pre> <p class="calibre4">We have <code>LazyColumn</code> with 100 items. Each item is a <code>Text</code> composable. The preview for this looks as follows:</p>
<div><div><img alt="Figure 3.10 – LazyColumn preview" src="img/B19779_03_10.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.10 – LazyColumn preview</p>
<p class="calibre4">We can see from <em class="italic">Figure 3</em><em class="italic">.10</em> that we now have a list of items that scroll vertically. As mentioned, it only shows the items that can fit on the screen. If we use interactive mode on our preview, we will be<a id="_idIndexMarker153" class="calibre3 pcalibre pcalibre1"/> able to scroll through to the bottom of the list.</p>
<p class="calibre4">Let us see the <code>LazyRow</code> equivalent as well:</p>
<pre class="source-code">
LazyRow(
    modifier = Modifier
        .fillMaxWidth()
        .background(Color.LightGray)
        .padding(8.dp)
) {
    items(100) {
        Text(
            modifier = Modifier
                .padding(8.dp),
            text = "Item number $it"
        )
    }
}</pre> <p class="calibre4">We have <code>LazyRow</code> with 100 items. Each<a id="_idIndexMarker154" class="calibre3 pcalibre pcalibre1"/> item is a <code>Text</code> composable. The preview for this looks as follows:</p>
<div><div><img alt="Figure 3.11 – LazyRow preview" src="img/B19779_03_11.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.11 – LazyRow preview</p>
<p class="calibre4">We can see from <em class="italic">Figure 3</em><em class="italic">.11</em> that we now have a list of items that scroll horizontally. Similar to <code>LazyColumn</code>, it only shows the items that can fit on the screen. If we use interactive mode on our preview, we can scroll through to the end of the list.</p>
<p class="calibre4">We also have two more types of list layouts, <code>LazyVerticalGrid</code> and <code>LazyHorizontalGrid</code>. The two layouts are part of the lazy grids and help us to arrange our content in grids. They’re commonly used in applications such as galleries, movies, and spreadsheets. <code>LazyVerticalGrid</code> creates a vertical list of items in a grid. Let us look at the sample code for <code>LazyVerticalGrid</code>:</p>
<pre class="source-code">
LazyVerticalGrid(
    modifier = Modifier
        .fillMaxSize()
        .background(Color.LightGray)
        .padding(8.dp),
    columns = GridCells.Fixed(3)
) {
    items(100) {
        Text(
            modifier = Modifier
                .padding(8.dp),
            text = "Item number $it"
        )
    }
}</pre> <p class="calibre4">We have used the <code>LazyVerticalGrid</code> composable. We pass our modifiers as before. Notice we also have the <code>columns</code> parameter. This parameter allows us to specify the number of columns and how items are arranged within the columns. In this case, we specified <code>GridCells</code> to be <code>Fixed</code>. This means the grid will have a fixed number of columns or rows in it is a <code>LazyHorizontalGrid</code>. We also have the <code>Adaptive</code> type, which <a id="_idIndexMarker155" class="calibre3 pcalibre pcalibre1"/>defines a grid with as many rows or columns as possible with the condition that every cell has a minimum size and all extra space is distributed evenly. Our preview will look as follows:</p>
<div><div><img alt="Figure 3.12 – LazyVerticalGrid preview" src="img/B19779_03_12.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.12 – LazyVerticalGrid preview</p>
<p class="calibre4">We have our text elements in a grid of three columns. We are now able to scroll through the items vertically. Let us<a id="_idIndexMarker156" class="calibre3 pcalibre pcalibre1"/> now look at the code for <code>LazyHorizontalGrid</code>:</p>
<pre class="source-code">
LazyHorizontalGrid(
    modifier = Modifier
        .fillMaxSize()
        .background(Color.LightGray)
        .padding(8.dp),
    rows = GridCells.Fixed(3)
) {
    items(100) {
        Text(
            modifier = Modifier
                .padding(8.dp),
            text = "Item number $it"
        )
    }
}</pre> <p class="calibre4">The code is similar to that for <code>LazyVerticalGrid</code>. The only difference is that we are using <code>LazyHorizontalGrid</code> and<a id="_idIndexMarker157" class="calibre3 pcalibre pcalibre1"/> instead of columns, we are now passing <code>rows</code> to describe how the cells will form the rows. The preview will look like this:</p>
<div><div><img alt="Figure 3.13 – LazyHorizontalGrid preview" src="img/B19779_03_13.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.13 – LazyHorizontalGrid preview</p>
<p class="calibre4">As seen in <em class="italic">Figure 3</em><em class="italic">.13</em>, we now have three rows on the entire screen, and we can also scroll through them<a id="_idIndexMarker158" class="calibre3 pcalibre pcalibre1"/> horizontally.</p>
<p class="calibre4">In addition to <code>LazyVerticalGrid</code> and <code>LazyHorizontalGrid</code>, we also have <code>LazyVerticalStaggeredGrid</code> and <code>LazyHorizontalStaggeredGrid</code>, which are remarkably similar; the only difference is that they adapt to the children’s height and width, respectively, meaning they all do not have uniform height or width.</p>
<p class="calibre4">Let us now have a<a id="_idIndexMarker159" class="calibre3 pcalibre pcalibre1"/> look at <code>ConstraintLayout</code> in the next section.</p>
<h3 class="calibre9">ConstraintLayout</h3>
<p class="calibre4">This layout enables us to create responsive layouts. We can create complex layouts with relative positioning. <code>ConstraintLayout</code> uses chains, barriers, and guidelines to position child elements<a id="_idIndexMarker160" class="calibre3 pcalibre pcalibre1"/> relative to each other.</p>
<p class="calibre4">It comes as a separate dependency, and we need to add it to our project. To add it, let us add this dependency to our app <code>build.gradle</code> file:</p>
<pre class="source-code">
 implementation 'androidx.constraintlayout:constraintlayout-compose:1.0.1'</pre> <p class="calibre4">This adds the Jetpack Compose dependency to our project. The layout code for the constraint layout is as follows:</p>
<pre class="source-code">
ConstraintLayout(
  modifier = Modifier
    .padding(16.dp)
) {
    val (icon, text) = createRefs()
      Icon(
          modifier = Modifier
            .size(80.dp)
            .constrainAs(icon) {
                top.linkTo(parent.top)
                bottom.linkTo(parent.bottom)
                start.linkTo(parent.start)
            },
          imageVector = Icons.Outlined.Notifications,
          contentDescription = null,
          tint = Color.Green
      )
    Text(
        modifier = Modifier
          .constrainAs(text) {
              top.linkTo(parent.top)
              bottom.linkTo(parent.bottom)
              start.linkTo(icon.end) },
        text = "9",
        style = MaterialTheme.typography.titleLarge
    )
}</pre> <p class="calibre4">In the preceding code, we used the <code>ConstraintLayout</code> composable function to create <code>ConstraintLayout</code>. Inside <code>ConstraintLayout</code>, we used the <code>createRefs()</code> function to create two references, one for the icon and one for the text. We then used the <code>constrainAs()</code> function to constrain the icon and the text to the parent. We used the <code>linkTo()</code> function to link the icon and the text to the parent. In this case, we have linked <a id="_idIndexMarker161" class="calibre3 pcalibre pcalibre1"/>the icon to the start, top, and bottom of the parent. For the text, we have linked it to the top and bottom of the parent. We have additionally linked the start of the text to the end of the icon. Our preview will look as follows:</p>
<div><div><img alt="Figure 3.14 – ConstraintLayout preview" src="img/B19779_03_14.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.14 – ConstraintLayout preview</p>
<p class="calibre4">From the preceding<a id="_idIndexMarker162" class="calibre3 pcalibre pcalibre1"/> screenshot, we can see that we have an icon and text to the right of the icon. <code>ConstraintLayout</code> helps in positioning items relative to the parent or each other.</p>
<h1 id="_idParaDest-48" class="calibre6"><a id="_idTextAnchor054" class="calibre3 pcalibre pcalibre1"/>Summary</h1>
<p class="calibre4">In this chapter, we have introduced ourselves to Jetpack Compose, a declarative way of creating UIs for apps. We have also learned about the different layouts that are in Compose and how the Jetpack Compose compiler renders state into a UI.</p>
<p class="calibre4">In the next chapter, we will be building on top of what we have learned and look at how to design beautiful and intuitive apps with <strong class="bold">Material Design 3</strong>. We’re going to learn about Material Design 3, its features, and how to add dynamic color to our app.</p>
</div>
</body></html>