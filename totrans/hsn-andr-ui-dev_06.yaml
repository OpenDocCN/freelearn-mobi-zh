- en: Storing and Retrieving Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储和检索数据
- en: Data storage might not, at first glance, seem to be at all related to a user
    interface, but in the majority of applications, the user interface exists to manipulate
    long-lived data both on the device and on the network. This means that while it
    does not directly influence the look of the application, it does influence the
    user experience. Users expect the application to always reflect the latest data
    available to them, as we explored in [Chapter 5](6afcbdf4-555b-4073-9e53-4a87bc0f6459.xhtml),
    *Binding Data to Widgets*. Applications written using a reactive pattern ensure
    that the user interface is always up to date with the latest data available to
    the application, and the Android data binding system helps to make writing reactive
    applications easy. Even without the data binding framework, Android itself has
    always been built for reactive applications from the very bottom layers upward,
    but until recently, this behavior required huge amounts of boilerplate code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，数据存储似乎与用户界面毫不相关，但在大多数应用程序中，用户界面存在是为了在设备和网络上操纵持久数据。这意味着虽然它不会直接影响应用程序的外观，但它确实会影响用户体验。用户期望应用程序始终反映他们可用的最新数据，正如我们在[第5章](6afcbdf4-555b-4073-9e53-4a87bc0f6459.xhtml)中探讨的，“将数据绑定到小部件”。使用响应式模式编写的应用程序确保用户界面始终与应用程序可用的最新数据保持同步，Android数据绑定系统有助于简化编写响应式应用程序的过程。即使没有数据绑定框架，Android本身也始终从底层向上构建为响应式应用程序，但直到最近，这种行为需要大量的样板代码。
- en: When you develop any sort of application, it's important to establish a data
    container or authority within the application. In most web systems, this will
    be a database. The system may have many other layers to its data storage, such
    as caches and in-memory object models, but the *authority* in this case will be
    the database. Android applications may appear more complex at first; you typically
    have a server with some data, you often have a local database, and then there
    is also whatever is on screen and in-memory. Keeping all of these states in-sync
    might appear to be a nightmare, but it's actually well taken care of.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开发任何类型的应用程序时，在应用程序内建立数据容器或权限是非常重要的。在大多数Web系统中，这将是一个数据库。系统可能还有许多其他数据存储层，例如缓存和内存中的对象模型，但在这个情况下，“权限”将是数据库。Android应用程序可能一开始看起来更复杂；你通常有一个包含一些数据的服务器，你通常有一个本地数据库，然后还有屏幕上和内存中的内容。保持所有这些状态同步可能看起来像是一场噩梦，但实际上已经得到了妥善处理。
- en: The Android team have built a collection of APIs known collectively as the Architecture
    Components. These collectively simplify the job of writing reactive applications
    by taking care of the most common problems when writing an application. They include
    APIs for storing and retrieving data, and for reacting to changes in state of
    the application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Android团队构建了一个名为架构组件的API集合。这些组件共同简化了编写响应式应用程序的工作，因为它们处理了编写应用程序时最常见的常见问题。它们包括用于存储和检索数据的API，以及用于响应应用程序状态变化的API。
- en: 'In this chapter, we''ll look at the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: How data and storage can influence the user experience
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据和存储如何影响用户体验
- en: The tools Android provides to store and retrieve structured data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android提供的用于存储和检索结构化数据的工具
- en: The best ways to keep the user interface up to date with the data store
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持用户界面与数据存储同步的最佳方式
- en: Building an SQLite database store using the Room persistence API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Room持久化API构建SQLite数据库存储
- en: Data storage in Android
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android中的数据存储
- en: Almost every application needs to store data persistently at some point. Any
    data that needs to remain intact when your application is stopped must be placed
    in some kind of data storage system where you can retrieve it again later. You
    can store all the data on the server, but then your application will only function
    when the user has an active internet connection and will only ever be as fast
    as their available connection. You can also store data as files on the device's
    local filesystem, but this means you need to either load all the data into memory
    and save the whole application state every time it changes, or you need to write
    complicated logic to maintain integrity between the various files your application
    will write.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个应用程序在某个时候都需要持久化存储数据。任何需要在应用程序停止时保持完整的数据都必须放置在某种数据存储系统中，以便以后可以再次检索它。您可以将所有数据存储在服务器上，但这样您的应用程序只有在用户有活跃的互联网连接时才能工作，并且速度将仅限于他们的可用连接速度。您还可以将数据作为文件存储在设备的本地文件系统中，但这意味着您需要每次更改时都将所有数据加载到内存中并保存整个应用程序状态，或者您需要编写复杂的逻辑来维护应用程序将写入的各种文件之间的完整性。
- en: The Android ecosystem has a large number of database systems available, the
    most popular of which is probably SQLite. Data can be saved in SQLite tables and
    retrieved through structured queries. This provides an ideal way to store all
    of your application data on the device, while only ever retrieving what the application
    needs. An SQLite database can be instructed to exactly which fields on which records
    you need to retrieve, and you can use indices to make this process very fast.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Android生态系统提供了大量的数据库系统，其中最流行的大概是SQLite。数据可以保存在SQLite表中，并通过结构化查询检索。这为在设备上存储所有应用程序数据提供了一个理想的方式，同时只检索应用程序所需的数据。可以指示SQLite数据库精确检索哪些记录上的哪些字段，您可以使用索引来使此过程非常快速。
- en: 'Persistent data storage and object mapping does come at a significant cost--as
    fast as a database lookup might be, it takes significantly longer than is acceptable
    on the main thread, where it creates delays in graphics rendering and event dispatching.
    So once again, you want data to be loaded from a background thread. This can create
    some additional challenges: how do you ensure that the data is always up to date,
    and doesn''t get stagnated when it''s involved in `Activity` life cycles and is
    being persisted and loaded from multiple storage systems? This can quickly get
    out of hand, but again, Android has a whole ecosystem of structures that are designed
    to keep things under control.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 持久性数据存储和对象映射确实会带来显著的成本——数据库查找可能很快，但在主线程上它需要的时间明显长于可接受的范围，这会在图形渲染和事件分发中造成延迟。因此，您再次希望数据从后台线程加载。这可能会带来一些额外的挑战：如何确保数据始终是最新的，并且在涉及`Activity`生命周期、持久化和从多个存储系统加载时不会停滞？这可能会迅速失控，但再次强调，Android有一个完整的生态系统，旨在保持一切井然有序。
- en: 'When creating an Android application, it''s best to design it so that anything
    being edited by the user on the current `Activity` remains in a mutable in-memory
    model, as in the following diagram:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建Android应用程序时，最好设计它，以便用户在当前`Activity`中编辑的任何内容都保持在可变的内存模型中，如图所示：
- en: '![](img/302c94cf-42fe-472b-bd10-c0d014d3dd03.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/302c94cf-42fe-472b-bd10-c0d014d3dd03.jpg)'
- en: 'This design pattern will provide your application with good performance, while
    also allowing you to easily *cancel* changes by simply discarding the in-memory
    model that the user has been changing. When the user is viewing rather than editing
    data, a different approach is needed. When a user is looking at a screen such
    as their email inbox, or a chat conversation, they expect it to update without
    their interaction. When this is the case, it''s better to follow a unidirectional
    data flow design, such as the one in this diagram:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式将为您的应用程序提供良好的性能，同时让您能够通过简单地丢弃用户正在更改的内存模型来轻松地*取消*更改。当用户正在查看而不是编辑数据时，需要不同的方法。当用户查看如他们的电子邮件收件箱或聊天对话的屏幕时，他们期望它在没有他们的交互下更新。在这种情况下，最好遵循单向数据流设计，如图中所示：
- en: '![](img/28f796f6-2f10-4afb-bc40-112c2363ed76.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/28f796f6-2f10-4afb-bc40-112c2363ed76.jpg)'
- en: The **Incoming Change** in this diagram can be from absolutely anywhere. It
    can be from another part of the application, or it can be from the network, or
    it can even be from another part of the screen the user is looking at. The important
    thing is that the database (**DB**) is always updated first, which then triggers
    the **Model** to be reloaded or updated, and that in turn triggers the **User
    Interface** to update. This is in opposition to a **Model** where the **User Interface**
    receives the incoming event and fetches the new data. Here, the **User Interface**
    will always receive the latest data directly.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的**传入更改**可以来自任何地方。它可以来自应用程序的另一个部分，也可以来自网络，甚至可以来自用户正在查看的屏幕的另一部分。重要的是数据库（**DB**）总是首先更新，然后触发**模型**重新加载或更新，进而触发**用户界面**更新。这与**模型**相反，其中**用户界面**接收传入的事件并获取新数据。在这里，**用户界面**将始终直接接收最新数据。
- en: Using the SQLite database
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SQLite 数据库
- en: SQLite is an excellent little SQL compatible database that is embedded into
    the core Android system. This allows you to leverage a complete SQL database without
    having to ship one with your application (which will raise your code size dramatically).
    This makes it the most common tool for storing structured data on Android, but
    it's by no means the only option.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 是一个嵌入到核心 Android 系统中的优秀小型 SQL 兼容数据库。这允许您利用完整的 SQL 数据库，而无需将数据库与您的应用程序一起分发（这将大大增加您的代码大小）。这使得它成为
    Android 上存储结构化数据最常用的工具，但绝不是唯一的选择。
- en: For many applications that require real-time synchronization with a server,
    people use Firebase Database. **Firebase** is a Google cloud product that includes
    a powerful document database that synchronizes its data in real time, all the
    way to the client. This means that an event is triggered on a client when any
    of its data is modified from outside, making it suitable for chat and messaging
    applications. However, tools such as Firebase require a large additional client-side
    API, tie your application to a service, and are very difficult to port your application
    away for later. Applications built with them may also violate privacy laws in
    some countries if the application were to store private information without first
    encrypting it on the client side. In these cases, you'll either need to set up
    your own synchronization system, or use a database with filtered real-time synchronization,
    such as the *CouchDB project* from Apache.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多需要与服务器实时同步的应用程序，人们使用 Firebase 数据库。**Firebase**是谷歌云产品，包括一个功能强大的文档数据库，它实时同步其数据，直到客户端。这意味着当其数据从外部被修改时，客户端会触发一个事件，这使得它非常适合聊天和消息应用。然而，像
    Firebase 这样的工具需要大量的额外客户端 API，将您的应用程序绑定到某个服务，并且很难将应用程序迁移到其他平台。使用它们构建的应用程序也可能会违反某些国家的隐私法律，如果应用程序在客户端未加密的情况下存储私人信息。在这些情况下，您可能需要设置自己的同步系统，或者使用具有过滤实时同步功能的数据库，例如
    Apache 的 *CouchDB 项目*。
- en: Most typically though, SQLite serves as an excellent choice for storing structured
    data on the client. It's flexible, very powerful, and very fast, and because it's
    baked into the Android platform, it doesn't add any direct size overhead to your
    application. Most Java developers will be used to JDBC when accessing an SQL database,
    and while Android does have JDBC support, the `android.database` and `android.database.sqlite`
    packages are the preferred methods of accessing the database and are much faster.
    Android also offers an additional layer of abstraction above the direct use of
    SQLite, which we'll explore next.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，SQLite 作为客户端存储结构化数据的优秀选择。它灵活、非常强大且非常快速，并且因为它已经集成到 Android 平台，所以不会为您的应用程序增加任何直接的大小开销。大多数
    Java 开发者在访问 SQL 数据库时都会使用 JDBC，尽管 Android 也提供了 JDBC 支持，但 `android.database` 和 `android.database.sqlite`
    包是访问数据库的首选方法，而且速度更快。Android 还提供了一层额外的抽象，用于直接使用 SQLite，我们将在下一节中探讨这一点。
- en: For more information about SQLite and how to get the most out of it, it's worth
    browsing the project's excellent documentation at [https://sqlite.org/](https://sqlite.org/).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解有关 SQLite 的更多信息以及如何充分利用它，建议浏览该项目的优秀文档，网址为 [https://sqlite.org/](https://sqlite.org/)。
- en: Introducing Room
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Room
- en: 'Direct use of SQLite requires a huge amount of code dedicated to converting
    the SQLite structured data into Java objects, and then preparing SQL statements
    to store those objects back into the database. Mapping an SQL record to a Java
    object normally takes the following form:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用SQLite需要大量的代码来将SQLite结构化数据转换为Java对象，然后准备SQL语句将这些对象存储回数据库。将SQL记录映射到Java对象的通常形式如下：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can immediately see, there's a lot of code there that you will need to
    repeat again and again for every one of your data-model objects.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如您立即所见，那里有很多代码，您将需要为每个数据模型对象重复使用。
- en: Fortunately, Google has produced a solution to this boilerplate as part of their
    Architecture Components, and it's called **Room**. Room is an API and code generator
    that allows you to define your object model and the SQL queries you want to execute
    while it writes the boilerplate **Data Access Objects** (**DAO**) classes for
    you. Room is an excellent choice because all the heavy lifting is done at compile
    time by generating source code for your application. This also means that it requires
    much less additional code to be included in your application, which helps keep
    your application smaller on the end user's device.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Google作为其架构组件的一部分提供了解决这个模板问题的方案，它被称为**Room**。Room是一个API和代码生成器，允许您定义您的对象模型和您想要执行的SQL查询，同时它会为您编写模板**数据访问对象**（**DAO**）类。Room是一个极佳的选择，因为所有繁重的工作都是在编译时通过为您的应用程序生成源代码来完成的。这也意味着它需要包含在您的应用程序中的额外代码要少得多，这有助于保持您的应用程序在最终用户设备上的体积更小。
- en: Room isn't a traditional **Object/Relational** (**O/R**) mapping layer, but
    rather allows you to define the `SELECT` statements, and copies whatever data
    they return to an object model that you specify. As a result, it doesn't directly
    handle inter-object relationships (such as `ClaimItem` containing an array of
    `Attachment` objects). While this may seem like a problem, it's a very important
    feature! Relationships like these are common in object models, but are expensive
    to implement in an Object/Relational layer, since every call to `ClaimItem.getAttachments`
    would require another database query, and on Android, those calls are likely to
    leak onto the main thread.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Room不是一个传统的**对象/关系**（**O/R**）映射层，而是允许您定义`SELECT`语句，并将它们返回的数据复制到您指定的对象模型中。因此，它不直接处理对象之间的关系（例如`ClaimItem`包含一个`Attachment`对象的数组）。虽然这看起来像是一个问题，但它是一个非常重要的特性！这类关系在对象模型中很常见，但在对象/关系层中实现起来成本很高，因为每次调用`ClaimItem.getAttachments`都需要另一个数据库查询，而在Android中，这些调用很可能会泄漏到主线程。
- en: Instead, Room is designed so that you can create object models that are suitable
    for data-binding, and build SQL queries that can return them directly. This pushes
    the complexity back into the database, and helps encourage a single query to display
    programming behavior.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Room被设计成您可以创建适合数据绑定的对象模型，并构建可以直接返回它们的SQL查询。这把复杂性推回到数据库中，并有助于鼓励使用单个查询来显示编程行为。
- en: Adding Room to the project
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向项目中添加房间
- en: 'Room is part of the Architecture Components, and is not imported into projects
    by default. Instead, you need to add them as a dependency to your project by following
    these simple steps:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Room是架构组件的一部分，默认情况下不会导入到项目中。相反，您需要按照以下简单步骤将它们作为依赖项添加到您的项目中：
- en: 'In the Android panel, open the Gradle Scripts subsection and then open the
    `build.gradle` for the app module:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android面板中，打开Gradle脚本子部分，然后打开应用模块的`build.gradle`文件：
- en: '![](img/2d3959c0-ae5d-4725-a438-6d57e0b53eca.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2d3959c0-ae5d-4725-a438-6d57e0b53eca.png)'
- en: 'At the bottom of the file, you''ll find a dependencies block; at the bottom
    of the block, add the following two lines of code:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件底部，您会找到一个依赖项块；在块的底部，添加以下两行代码：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Use the Sync Now link at the top of the editor to synchronize your project with
    its Gradle file. Android Studio will automatically download the new Room dependencies
    for your project.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用编辑器顶部的“立即同步”链接将项目与其Gradle文件同步。Android Studio将自动下载您项目的新Room依赖项。
- en: Your project now has the Room API and its code generators integrated, and you
    can start creating a persistent object model and database schema.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的项目现在已集成Room API及其代码生成器，您可以开始创建持久对象模型和数据库模式。
- en: Creating an Entity model
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建实体模型
- en: Room, much like an SQL database, is optionally asymmetric; what you write to
    it might not be in the exact same format as what you read from it. When you write
    to a `Room` database, you save `Entity` objects, but when you read, you can read
    virtually any Java object. This allows you to define object models that best suit
    your user interface, and load them with `JOIN` queries rather than resorting to
    one or more additional queries for each object you wish to present to the user.
    While `JOIN` queries might be overly expensive on a server, on a mobile device
    they are often significantly faster than a multiquery alternative. As such, when
    defining an entity model, it's worth considering what you will need to save in
    your database as well as what specific fields you will need on your user interface.
    The data you need to write to storage becomes your entity, while the fields on
    your user interface become fields in Java objects that can be queried through
    Room.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Room，就像一个SQL数据库一样，是可选的非对称的；你写入它的内容可能与从它读取的内容格式不完全相同。当你向Room数据库写入时，你保存`Entity`对象，但在读取时，你可以读取几乎任何Java对象。这允许你定义最适合用户界面的对象模型，并通过`JOIN`查询加载它们，而不是为每个要向用户展示的对象进行一个或多个额外的查询。虽然`JOIN`查询在服务器上可能过于昂贵，但在移动设备上，它们通常比多查询替代方案要快得多。因此，在定义实体模型时，值得考虑你需要在数据库中保存什么，以及你需要在用户界面上使用哪些特定字段。你需要写入存储的数据成为你的实体，而用户界面的字段成为可以通过Room查询的Java对象中的字段。
- en: 'An `Entity` class in Room is annotated with `@Entity`, and is expected to follow
    certain rules:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Room中的`Entity`类被注解为`@Entity`，并预期遵循某些规则：
- en: Fields must either be `public` or have Java Beans style getters and setters
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段必须是`public`的或者有Java Beans风格的getter和setter
- en: At least one field must be marked as a primary key using the `@PrimaryKey` annotation
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少有一个字段必须使用`@PrimaryKey`注解标记为主键
- en: Room expects a single `public` constructor, so you may need to mark the other
    constructors with an `@Ignore` annotation in order for your code to compile. It's
    often best to leave only a default (no arguments) constructor for Room to use
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Room期望一个单独的`public`构造函数，因此你可能需要使用`@Ignore`注解标记其他构造函数，以便你的代码可以编译。通常最好只为Room留下一个默认（无参数）的构造函数
- en: 'In order to start storing claim data using Room, we will need to modify the
    existing `ClaimItem` and `Attachment` classes so that they are valid entities.
    This will involve making them usable as relational structures; `ClaimItem` and
    `Attachment` will both need an ID primary key, and attachment will need a foreign
    key identifier for the `ClaimItem` that it belongs to. Perform the following steps
    to modify these two data model classes so that they can be stored as entities
    using Room:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Room开始存储索赔数据，我们需要修改现有的`ClaimItem`和`Attachment`类，使它们成为有效的实体。这涉及到使它们作为关系结构可用；`ClaimItem`和`Attachment`都需要一个ID主键，并且附件需要为其所属的`ClaimItem`的外键标识符。执行以下步骤以修改这两个数据模型类，以便它们可以使用Room作为实体存储：
- en: Start by opening the `ClaimItem` source file in Android Studio.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在Android Studio中打开`ClaimItem`源文件。
- en: 'Annotate the class declaration with `@Entity`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`@Entity`注解类声明：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add an ID field, annotate it with `@PrimaryKey`, and tell Room that you want
    it generated by the database rather than having to create IDs manually (you can
    also add getters and setters for this field if you like):'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个ID字段，使用`@PrimaryKey`注解它，并告诉Room你希望它由数据库生成，而不是手动创建ID（如果你喜欢，也可以为这个字段添加getter和setter）：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Leaving the fields `public` means that Room will directly access the fields
    in preference to using getters and setters. Field access can be much faster than
    method calls to the getters and setters.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将字段保留为`public`意味着Room将直接访问字段，而不是使用getter和setter。字段访问可能比调用getter和setter的方法调用要快得多。
- en: 'Tell Room to ignore the `List` of `Attachment`. Room is unable to directly
    persist these sorts of relationships, and your application will fail to compile
    when it tries to generate mapping code for this field:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉Room忽略`Attachment`的`List`。Room无法直接持久化这类关系，当它尝试为这个字段生成映射代码时，你的应用程序将无法编译：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Modify the `Parcelable` implementation of `ClaimItem` to save and restore the
    ID field:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`ClaimItem`的`Parcelable`实现以保存和恢复ID字段：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Open the `Attachment` source file.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`附件`源文件。
- en: 'Add the `Entity` annotation to the `Attachment` class; this time you''ll need
    to include an `@Index` annotation as well to tell Room to generate a database
    index on a new field you''ll be adding--`claimItemId`. The index will ensure that
    queries to fetch the attachments for a specific `ClaimItem` record are nice and
    fast:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Entity`注解添加到`Attachment`类中；这次你还需要包括一个`@Index`注解，以告诉Room在即将添加的新字段`claimItemId`上生成数据库索引。索引将确保查询特定`ClaimItem`记录的附件时非常快速：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the database primary key field for the `Attachment`, and the new `claimItemId`
    field that will be used to indicate which `ClaimItem` the `Attachment` belongs
    to when it''s stored in the database:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Attachment`添加数据库主键字段，以及新的`claimItemId`字段，该字段将用于指示当`Attachment`存储在数据库中时它属于哪个`ClaimItem`：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Ensure that there is a `public` default constructor, and that any other `public`
    constructors are marked with `@Ignore`:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保存在一个`public`默认构造函数，并且任何其他`public`构造函数都标记为`@Ignore`：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Update the `Attachment` classes `Parcelable` implementation to include the
    new fields:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`Attachment`类的`Parcelable`实现，以包括新字段：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, modifying an existing object model to be stored in a `Room`
    database is very simple. Room will now be able to generate code to load and save
    these objects from tables in its database; it'll also be able to generate the
    database schema from these classes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，将现有的对象模型修改为存储在`Room`数据库中非常简单。Room现在能够生成代码来从其数据库的表中加载和保存这些对象；它还能从这些类中生成数据库模式。
- en: Creating the Data Access Layer
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据访问层
- en: 'Now that you have something to write into the database, you need some way to
    actually write it, and a way to retrieve it again. The most common pattern is
    to have a dedicated class to deal with this for each class--a Data Access Object
    class, also known as a DAO. In Room, however, all you have to do is declare what
    they should look like using an interface; Room will write the implementation code
    for you. You define your queries using the `@Query` annotation on a method, like
    this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了一些要写入数据库的内容，你需要一种实际写入的方法，以及一种再次检索它的方法。最常见的方式是为每个类创建一个专门处理此类操作的类——数据访问对象（Data
    Access Object，简称DAO）。然而，在Room中，你只需要使用接口声明它们应该是什么样子；Room会为你生成实现代码。你可以通过在方法上使用`@Query`注解来定义你的查询，如下所示：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This has a huge advantage over traditional O/R mapping layers in that you can
    still write any form of SQL query, and let Room figure out how to convert it into
    the object model you ask for. If it can''t write the code, you get an error at
    compile time, rather than potentially having your app crash for your users. This
    also has an additional advantage: Room can bind your SQL queries to non-entity
    classes, allowing you to leverage the full power of your SQLite database without
    having to do all the column/field/object mapping by hand. For example, you can
    define a special `DisplayContact` class for displaying the summary data for a
    contact in a list, and then query them directly using a `join`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这与传统O/R映射层相比具有巨大优势，因为你仍然可以编写任何形式的SQL查询，让Room来决定如何将其转换为所需的对象模型。如果它无法生成代码，你将在编译时得到错误，而不是应用程序可能因为用户而崩溃。这还有一个额外的优势：Room可以将你的SQL查询绑定到非实体类，让你能够充分利用SQLite数据库的全部功能，而无需手动进行所有列/字段/对象映射。例如，你可以定义一个特殊的`DisplayContact`类来显示联系人列表中的摘要数据，然后直接使用`join`查询它们：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding query doesn't return an object that can be directly saved in the
    database; it's the result of looking at two different tables and collecting fields
    from both of them. Room copes with this just fine though, and doesn't need any
    sort of annotations on the classes to be returned.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的查询不会返回可以直接保存到数据库中的对象；它是查看两个不同的表并收集它们字段的结果。尽管如此，Room处理这种情况非常得心应手，并且不需要对返回的类进行任何类型的注解。
- en: The LiveData class
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LiveData类
- en: Room does much more than binding your database structures to objects and back
    again; it offers you the ability to write reactive programs much more simply.
    As already mentioned, Room is one of the Android Architecture Components libraries.
    Architecture Components collectively provide generic infrastructure that can be
    used to more rapidly build reactive applications, while also maintaining excellent
    performance and safety. One of the most important classes in the architecture
    components is `LiveData`. `LiveData` is a generic encapsulation of data that is
    subject to external changes. `LiveData` can be observed, much like the classes
    used for data-bound layouts. The primary difference is that `LiveData` will always
    trigger a *first* event on any new observer, providing it with the current data
    state.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Room 执行的不仅仅是将数据库结构绑定到对象并再次绑定；它还为您提供了编写更简单反应性程序的能力。如前所述，Room 是 Android 架构组件库之一。架构组件共同提供了一般基础设施，可用于快速构建反应性应用程序，同时保持出色的性能和安全性。架构组件中最重要的类之一是
    `LiveData`。`LiveData` 是对外部更改敏感的数据的通用封装。`LiveData` 可以被观察，就像用于数据绑定布局的类一样。主要区别在于
    `LiveData` 将始终在新的观察者上触发一个 *首次* 事件，并提供当前的数据状态。
- en: Room has built-in support for `LiveData`, meaning that you can return any object
    wrapped in a `LiveData` in order to receive any changes that occur to that object.
    At the time of writing, Room implements this by watching each of the tables for
    changes. This means you may receive updates to objects, even though they haven't
    actually changed. This should not be a problem for most applications, because
    the queries still run on a worker thread and only the notification happens on
    the main thread. This makes `LiveData` the preferred method for querying the database
    in most situations, because it takes care of running and processing the query
    on a worker, freeing your main thread to handle events and keep your application
    running smoothly.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Room 内置了对 `LiveData` 的支持，这意味着您可以通过返回任何包装在 `LiveData` 中的对象来接收对该对象发生的任何更改。在撰写本文时，Room
    通过监视每个表的变化来实现这一点。这意味着即使对象实际上没有发生变化，您也可能收到对象的更新。对于大多数应用程序来说，这不应该是一个问题，因为查询仍在工作线程上运行，而通知仅在主线程上发生。这使得
    `LiveData` 在大多数情况下成为查询数据库的首选方法，因为它负责在工作线程上运行和处理查询，从而释放主线程来处理事件并保持应用程序平稳运行。
- en: '`LiveData` is not part of Room directly, so you''ll need to follow these steps
    to add `LiveData` and the other Architecture Components to your project:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`LiveData` 不是 Room 的直接部分，因此您需要按照以下步骤将 `LiveData` 和其他架构组件添加到您的项目中：'
- en: 'In the Android panel, open the Gradle Scripts subsection and then open the
    build.gradle for the app module:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Android 面板中，打开 Gradle Scripts 子部分，然后打开应用模块的 build.gradle 文件：
- en: '![](img/9ad95035-2fd3-4ea9-adeb-fcfa1f8491b8.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9ad95035-2fd3-4ea9-adeb-fcfa1f8491b8.png)'
- en: 'At the bottom of the file, you''ll find a dependencies block; at the bottom
    of the block, add the following two lines of code:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件底部，您会找到一个依赖项块；在块的底部，添加以下两行代码：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Use the Sync Now link at the top of the editor to synchronize your project with
    it's Gradle file, and download the new dependencies.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用编辑器顶部的 Sync Now 链接将您的项目与其 Gradle 文件同步，并下载新的依赖项。
- en: Implementing Data Access Objects in Room
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Room 中实现数据访问对象
- en: You'll need to implement two different Data Access Object classes for the Claim
    application, one for each `Entity` object. Technically speaking, Room doesn't
    enforce one DAO per entity, and you can have a single DAO interface for your entire
    application or have one per screen. However, the most common pattern is to have
    one DAO class per entity type, even when some of its query methods return statistics
    or other views on the data. When working with more complex datasets, it's worth
    considering introducing additional DAO interfaces to cover queries that are either
    screen-specific or where the data overlaps several entities.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要为 Claim 应用程序实现两个不同的数据访问对象类，一个用于每个 `Entity` 对象。从技术上讲，Room 不强制要求每个实体有一个 DAO，您可以为整个应用程序或每个屏幕使用一个单一的
    DAO 接口。然而，最常见的设计模式是每个实体类型有一个 DAO 类，即使其中一些查询方法返回统计数据或其他数据视图。当处理更复杂的数据集时，考虑引入额外的
    DAO 接口来覆盖特定于屏幕的查询或数据重叠在多个实体上的查询。
- en: 'Here''s how to implement the Data Access Object interfaces for the Claim example
    application, step by step:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何逐步实现 Claim 示例应用程序的数据访问对象接口：
- en: Right-click on the `model` package in Android Studio and select New | Java Class.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Android Studio 中，右键单击 `model` 包，然后选择 New | Java Class。
- en: Name the new class `db.ClaimItemDao`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新类命名为 `db.ClaimItemDao`。
- en: Change the Kind field to Interface. Room DAO types are normally interfaces,
    although this isn't a strict requirement, and they can also be abstract classes.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Kind 字段更改为“接口”。Room DAO 类型通常是接口，尽管这不是严格的要求，它们也可以是抽象类。
- en: Click OK to create the new package and class.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”以创建新的包和类。
- en: 'Annotate the interface with `@Dao` to mark it as a data-access-object:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `@Dao` 注解接口以将其标记为数据访问对象：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Declare a query method to fetch all the `ClaimItem` objects in order of the
    most recent first; ensure that it returns a `LiveData` so that the changes are
    reflected:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个查询方法以按最近的时间顺序获取所有 `ClaimItem` 对象；确保它返回 `LiveData` 以反映更改：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, you need methods to insert, update, and delete the `ClaimItem` objects
    in the database; these methods always take only the `Entity` object and instead
    of a query, are annotated with their operation. In the case of the insert method,
    it''s useful to have it return the generated ID of the new record:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您需要方法来在数据库中插入、更新和删除 `ClaimItem` 对象；这些方法仅接受 `Entity` 对象，而不是查询，而是用它们的操作进行注释。在插入方法的情况下，返回新记录生成的
    ID 是有用的：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, right-click on the `db` package again, and select New | Java Class.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次在 `db` 包上右键单击，并选择“新建”|“Java 类”。
- en: Name the new class `AttachmentDao`, and make Kind to Interface.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新类命名为 `AttachmentDao`，并将其 Kind 设置为“接口”。
- en: Click OK to create the `AttachmentDao` class.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”以创建 `AttachmentDao` 类。
- en: 'Declare the new interface as a `Dao`:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明新的接口为 `Dao`：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Write a query method to fetch the `Attachment` objects for a single `ClaimItem`.
    This is where the index you declared on `Attachment` becomes important:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个查询方法以获取单个 `ClaimItem` 的 `Attachment` 对象。这是您在 `Attachment` 上声明的索引变得重要的地方：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Declare the insert, update, and delete methods for the `Attachment` classes,
    just as you did with the `ClaimItem` methods:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明 `Attachment` 类的插入、更新和删除方法，就像您对 `ClaimItem` 方法所做的那样：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Creating a database
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据库
- en: When writing an application using Room, you'll need to define at least one *Database*
    class. Each of these corresponds to a specific database schema--a collection of
    Entity classes and the various ways in which they can be saved, and loaded from
    storage. It may also serve as a convenient place to write other database-related
    logic for your application. For example, the `ClaimItem` and `Attachment` classes
    need to save and load various types that Room will not understand; for example,
    `Date`, `File`, the `Category` enum, and `Attachment` `Type` enum. Each of these
    classes will need a `TypeConverter` method that can be used to convert it to and
    from primitives that are understood by Room.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Room 编写应用程序时，您需要定义至少一个 *数据库* 类。每个此类都对应于一个特定的数据库模式--一组实体类及其保存和从存储中加载的各种方式。它还可以作为编写应用程序中其他数据库相关逻辑的方便位置。例如，`ClaimItem`
    和 `Attachment` 类需要保存和加载 Room 无法理解的各种类型；例如，`Date`、`File`、`Category` 枚举和 `Attachment`
    `Type` 枚举。每个此类都需要一个 `TypeConverter` 方法，该方法可用于将其转换为 Room 能够理解的原始类型，并从原始类型转换回来。
- en: 'Room Database classes are abstract. This is because they are extended by the
    Room annotation processor to produce the implementation you''ll use at runtime.
    This allows you to define any number of concrete method implementations in a database
    class that might be useful for your application. Follow these steps to declare
    your new Room enabled database class:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Room 数据库类是抽象的。这是因为 Room 注解处理器会扩展它们以生成您在运行时使用的实现。这允许您在数据库类中定义任何数量的具体方法实现，这些实现可能对您的应用程序有用。按照以下步骤声明您的新
    Room 兼容数据库类：
- en: Right-click on the `db` package in Android Studio, and select New | Java Class.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Android Studio 中右键单击 `db` 包，然后选择“新建”|“Java 类”。
- en: Name the new class `ClaimDatabase`, and change its Superclass to `RoomDatabase`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新类命名为 `ClaimDatabase`，并将其 Superclass 设置为 `RoomDatabase`。
- en: Select the Abstract modifier.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“抽象”修饰符。
- en: Click OK to create the new class.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”以创建新的类。
- en: 'Annotate the class to indicate it as a database, and declare that it will store
    the `ClaimItem` and `Attachment` entities. You''ll also need to specify the schema
    version, which will be `1` for the first version:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释该类以表明它是一个数据库，并声明它将存储 `ClaimItem` 和 `Attachment` 实体。您还需要指定模式版本，对于第一个版本将是 `1`：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As mentioned earlier, you''ll need to declare `TypeConverter` methods for all
    the non-primitive fields that `ClaimItem` and `Attachment` use. You need to tell
    the database where these methods can be found, and in this case, it''ll be the
    `ClaimDatabase` class itself:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，您需要为`ClaimItem`和`Attachment`使用的所有非原始字段声明`TypeConverter`方法。您需要告诉数据库这些方法的位置，在这种情况下，它将是`ClaimDatabase`类本身：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, define `abstract` methods to retrieve the Data Access Object implementations
    you created earlier; these methods will be implemented by the subclass generated
    by Room:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义用于检索您之前创建的数据访问对象实现的`abstract`方法；这些方法将由Room生成的子类实现：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, you''ll need to tell Room how to convert the various fields to and from
    the primitives supported by the database. Start by implementing methods to convert
    `Date` objects into a timestamp long that can be stored in the database (SQLite
    has no `DATE` or `DATETIME` types):'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您需要告诉Room如何将各种字段转换为数据库支持的原始类型，并将其转换回原始类型。首先，实现将`Date`对象转换为可以存储在数据库中的时间戳长整型的方法（SQLite没有`DATE`或`DATETIME`类型）：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now continue with this pattern for the other types that the `ClaimItem` and
    `Attachment` need:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在继续使用这种模式来处理`ClaimItem`和`Attachment`需要的其他类型：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `TypeConverter` methods will be found and used by the Room annotation processor.
    They are invoked directly from the generated code, based on the types used in
    the Java classes being stored or retrieved. This means that they have almost no
    additional runtime overhead.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`TypeConverter`方法将由Room注解处理器找到并使用。它们直接从生成的代码中调用，基于存储或检索的Java类中使用的类型。这意味着它们几乎没有额外的运行时开销。'
- en: Accessing your Room database
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问您的Room数据库
- en: So far, you've built all the components for a Room managed SQLite database,
    but you still don't actually have access to it. You can't instantiate the `ClaimDatabase`
    class directly because it's abstract, and you have the same problem with the DAO
    interfaces, so what's the best way to access the database? Room provides you with
    an entry class that will correctly instantiate the generated `ClaimDatabase` implementation,
    but that isn't the whole story; your entire application relies on this database,
    and it should be set up when the application starts and should be accessible by
    the entire application.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经为Room管理的SQLite数据库构建了所有组件，但您实际上仍然无法访问它。由于它是抽象的，您不能直接实例化`ClaimDatabase`类，您在DAO接口上也有同样的问题，那么访问数据库的最佳方法是什么？Room为您提供了一个条目类，该类将正确实例化生成的`ClaimDatabase`实现，但这并不是全部故事；您的整个应用程序都依赖于这个数据库，它应该在应用程序启动时设置，并且应该对整个应用程序可访问。
- en: 'You can use a singleton `ClaimDatabase` object, but then where will the SQLite
    database file be placed? In order for it to be stored in your application''s private
    space, you need a Context object. Enter the `Application` class, which when used,
    holds the first `onCreate` method that will be invoked in your application. Follow
    these quick steps to build a simple `Application` class that will instantiate
    and hold a reference to your `ClaimDatabase`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用一个单例`ClaimDatabase`对象，但那么SQLite数据库文件将放在哪里呢？为了使其存储在应用程序的私有空间中，您需要一个Context对象。进入`Application`类，当使用时，它将持有将在您的应用程序中调用的第一个`onCreate`方法。按照以下快速步骤构建一个简单的`Application`类，该类将实例化并保留对您的`ClaimDatabase`的引用：
- en: Right-click on your root package (that is, `com.packtpub.claim`) and select
    New | Java Class.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击您的根包（即`com.packtpub.claim`），然后选择“新建”|“Java类”。
- en: Name the new class `ClaimApplication`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新类命名为`ClaimApplication`。
- en: Make its Superclass `android.app.Application`.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其超类设置为`android.app.Application`。
- en: Click OK to create the application class.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”以创建应用程序类。
- en: 'Declare a static `ClaimDatabase` to be used by the application:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个静态的`ClaimDatabase`以供应用程序使用：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Override the `onCreate` method and use it to instantiate the `ClaimDatabase`
    object using Room; this will happen before anything else in your application:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`onCreate`方法，并使用它通过Room实例化`ClaimDatabase`对象；这将在您的应用程序中的任何其他操作之前发生：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Provide a `public` `static` method for other parts of the application to use,
    to access the singleton database instance:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个`public` `static`方法，供应用程序的其他部分使用，以访问单例数据库实例：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You need to register the `ClaimApplication` with the Android platform so that
    it knows to initialize it when the application is started. You do this by opening
    the manifests directory and opening the `AndroidManifest.xml` file.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要将`ClaimApplication`注册到Android平台，以便它在应用程序启动时初始化它。您可以通过打开manifests目录并打开`AndroidManifest.xml`文件来完成此操作。
- en: 'In the `<application>` element, you''ll need to add an `android:name` attribute
    to tell the Android platform the name of the class that represents the root of
    your application:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `<application>` 元素中，你需要添加一个 `android:name` 属性来告诉 Android 平台代表应用程序根的类的名称：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, whenever any part of your application needs the database, it can simply
    invoke `ClaimApplication.getClaimDatabase()` to retrieve a global instance, and
    because it's no longer tied to a specific context instance, it can be invoked
    from anywhere (even a presenter).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当你的应用程序的任何部分需要数据库时，它都可以简单地调用 `ClaimApplication.getClaimDatabase()` 来检索一个全局实例，并且因为它不再与特定的上下文实例相关联，所以它可以从任何地方调用（甚至是一个演示者）。
- en: Test your knowledge
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: The Room API for Android provides which of the following?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Android 的 Room API 提供了以下哪些？
- en: A complete database solution
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个完整的数据库解决方案
- en: A lightweight API on top of SQLite
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 SQLite 之上的轻量级 API
- en: An object storage engine
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个对象存储引擎
- en: Returning `LiveData` from a Room DAO requires that you do which of these?
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Room DAO 返回 `LiveData` 需要做哪些？
- en: You observe it for changes in order to retrieve data
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你观察它以获取数据的变化
- en: You run the query on the main thread
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在主线程上运行查询
- en: You call the query method again when notified by the `LiveData` object
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你被 `LiveData` 对象通知时，再次调用查询方法
- en: Database queries that don't return `LiveData` should do what?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不返回 `LiveData` 的数据库查询应该做什么？
- en: Be avoided
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该避免
- en: Be run on a worker thread
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在工作线程上运行
- en: Return `Cursor` objects
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回 `Cursor` 对象
- en: Writing an update method for Room requires which of the listed?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 Room 编写更新方法需要哪些列表中的？
- en: An `@Query(“UPDATE` method on a DAO interface
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 DAO 接口上的 `@Query("UPDATE")` 方法
- en: An `@Update` method taking an `Entity` object on an interface
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个接口上的 `@Update` 方法，接受一个 `Entity` 对象
- en: Will be added to your `Entity` implementations
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将添加到你的 `Entity` 实现中
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The way you store and retrieve structured data in an Android application has
    a direct knock-on-effect on how your user will experience your application. When
    you choose to use a system like Room, CouchDB, or Firebase, where data changes
    are pushed through the application as updates, the user will naturally have a
    reactive application. What's more, the application will generally be responsive
    because these patterns naturally keep slow running queries and updates off the
    application main thread.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 Android 应用程序中存储和检索结构化数据的方式将直接影响你的用户如何体验你的应用程序。当你选择使用 Room、CouchDB 或 Firebase
    这样的系统时，数据更改作为更新推送到应用程序，用户将自然拥有一个反应式应用程序。更重要的是，应用程序通常将是响应式的，因为这些模式自然地将缓慢运行的查询和更新从应用程序主线程上移除。
- en: Room provides an excellent addition to the standard Android data storage ecosystem,
    not only dramatically reducing the need to write boilerplate data access code,
    but also providing a well-defined and excellently-written interface to run reactive
    queries for data. Of course, not all of your application needs to be reactive;
    once an object is delivered via a `LiveData` object, it's just an object and can
    be used as an in-memory snapshot or even edited if it's mutable.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Room 为标准的 Android 数据存储生态系统提供了一个出色的补充，不仅大大减少了编写样板数据访问代码的需求，而且还提供了一个定义良好且编写出色的接口来运行数据反应式查询。当然，你的应用程序不需要全部都是反应式的；一旦通过
    `LiveData` 对象传递了一个对象，它就只是一个对象，可以用作内存快照，甚至如果它是可变的，还可以进行编辑。
- en: When using Room, it's important to remember that you should avoid complex relationships
    between objects, because Room won't be able to save and resolve these for you.
    They're normally a sign that you might need to rethink how you are structuring
    your data; complex relationships will dramatically slow down the queries and therefore
    any user interface that depends on them. Typically, these relationships should
    be handled by creating presentation-specific object models, and then using a join
    in your query to fetch all the required data. For more information about SQL and
    how to use it in SQLite, take a look at the SQLite documentation and tutorials
    on the SQLite project's website, at [https://sqlite.org/](https://sqlite.org/).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Room 时，重要的是要记住你应该避免对象之间的复杂关系，因为 Room 将无法为你保存和解析这些关系。这通常是一个迹象，表明你可能需要重新思考你的数据结构；复杂的关系将大大减慢查询速度，因此任何依赖于它们的用户界面。通常，这些关系应该通过创建特定于演示的对象模型来处理，然后在查询中使用连接来检索所有所需的数据。有关
    SQL 和如何在 SQLite 中使用它的更多信息，请参阅 SQLite 文档和 SQLite 项目网站上的教程，网址为 [https://sqlite.org/](https://sqlite.org/)。
- en: In the next chapter, we'll look at building overview screens. These are extremely
    common start screens in applications; they often form the central screen of an
    application, somewhere that the user is brought back to again and again during
    navigation. Android has a massively versatile widget for these screens--the `RecyclerView`.
    Also, we'll explore how to use the `RecyclerView`, by coupling it to `LiveData`
    and using Data Binding to keep it up to date with the rest of the application.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨构建概览屏幕的方法。这些屏幕在应用程序中极为常见，通常是应用程序的中心屏幕，用户在导航过程中会反复返回到这个屏幕。Android
    为这些屏幕提供了一个极其灵活的组件——`RecyclerView`。此外，我们还将探讨如何使用 `RecyclerView`，通过将其与 `LiveData`
    结合并使用数据绑定来确保它与应用程序的其他部分保持同步更新。
