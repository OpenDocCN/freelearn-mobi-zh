- en: Storing and Retrieving Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data storage might not, at first glance, seem to be at all related to a user
    interface, but in the majority of applications, the user interface exists to manipulate
    long-lived data both on the device and on the network. This means that while it
    does not directly influence the look of the application, it does influence the
    user experience. Users expect the application to always reflect the latest data
    available to them, as we explored in [Chapter 5](6afcbdf4-555b-4073-9e53-4a87bc0f6459.xhtml),
    *Binding Data to Widgets*. Applications written using a reactive pattern ensure
    that the user interface is always up to date with the latest data available to
    the application, and the Android data binding system helps to make writing reactive
    applications easy. Even without the data binding framework, Android itself has
    always been built for reactive applications from the very bottom layers upward,
    but until recently, this behavior required huge amounts of boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: When you develop any sort of application, it's important to establish a data
    container or authority within the application. In most web systems, this will
    be a database. The system may have many other layers to its data storage, such
    as caches and in-memory object models, but the *authority* in this case will be
    the database. Android applications may appear more complex at first; you typically
    have a server with some data, you often have a local database, and then there
    is also whatever is on screen and in-memory. Keeping all of these states in-sync
    might appear to be a nightmare, but it's actually well taken care of.
  prefs: []
  type: TYPE_NORMAL
- en: The Android team have built a collection of APIs known collectively as the Architecture
    Components. These collectively simplify the job of writing reactive applications
    by taking care of the most common problems when writing an application. They include
    APIs for storing and retrieving data, and for reacting to changes in state of
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How data and storage can influence the user experience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tools Android provides to store and retrieve structured data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The best ways to keep the user interface up to date with the data store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an SQLite database store using the Room persistence API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data storage in Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost every application needs to store data persistently at some point. Any
    data that needs to remain intact when your application is stopped must be placed
    in some kind of data storage system where you can retrieve it again later. You
    can store all the data on the server, but then your application will only function
    when the user has an active internet connection and will only ever be as fast
    as their available connection. You can also store data as files on the device's
    local filesystem, but this means you need to either load all the data into memory
    and save the whole application state every time it changes, or you need to write
    complicated logic to maintain integrity between the various files your application
    will write.
  prefs: []
  type: TYPE_NORMAL
- en: The Android ecosystem has a large number of database systems available, the
    most popular of which is probably SQLite. Data can be saved in SQLite tables and
    retrieved through structured queries. This provides an ideal way to store all
    of your application data on the device, while only ever retrieving what the application
    needs. An SQLite database can be instructed to exactly which fields on which records
    you need to retrieve, and you can use indices to make this process very fast.
  prefs: []
  type: TYPE_NORMAL
- en: 'Persistent data storage and object mapping does come at a significant cost--as
    fast as a database lookup might be, it takes significantly longer than is acceptable
    on the main thread, where it creates delays in graphics rendering and event dispatching.
    So once again, you want data to be loaded from a background thread. This can create
    some additional challenges: how do you ensure that the data is always up to date,
    and doesn''t get stagnated when it''s involved in `Activity` life cycles and is
    being persisted and loaded from multiple storage systems? This can quickly get
    out of hand, but again, Android has a whole ecosystem of structures that are designed
    to keep things under control.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating an Android application, it''s best to design it so that anything
    being edited by the user on the current `Activity` remains in a mutable in-memory
    model, as in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/302c94cf-42fe-472b-bd10-c0d014d3dd03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This design pattern will provide your application with good performance, while
    also allowing you to easily *cancel* changes by simply discarding the in-memory
    model that the user has been changing. When the user is viewing rather than editing
    data, a different approach is needed. When a user is looking at a screen such
    as their email inbox, or a chat conversation, they expect it to update without
    their interaction. When this is the case, it''s better to follow a unidirectional
    data flow design, such as the one in this diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/28f796f6-2f10-4afb-bc40-112c2363ed76.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **Incoming Change** in this diagram can be from absolutely anywhere. It
    can be from another part of the application, or it can be from the network, or
    it can even be from another part of the screen the user is looking at. The important
    thing is that the database (**DB**) is always updated first, which then triggers
    the **Model** to be reloaded or updated, and that in turn triggers the **User
    Interface** to update. This is in opposition to a **Model** where the **User Interface**
    receives the incoming event and fetches the new data. Here, the **User Interface**
    will always receive the latest data directly.
  prefs: []
  type: TYPE_NORMAL
- en: Using the SQLite database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQLite is an excellent little SQL compatible database that is embedded into
    the core Android system. This allows you to leverage a complete SQL database without
    having to ship one with your application (which will raise your code size dramatically).
    This makes it the most common tool for storing structured data on Android, but
    it's by no means the only option.
  prefs: []
  type: TYPE_NORMAL
- en: For many applications that require real-time synchronization with a server,
    people use Firebase Database. **Firebase** is a Google cloud product that includes
    a powerful document database that synchronizes its data in real time, all the
    way to the client. This means that an event is triggered on a client when any
    of its data is modified from outside, making it suitable for chat and messaging
    applications. However, tools such as Firebase require a large additional client-side
    API, tie your application to a service, and are very difficult to port your application
    away for later. Applications built with them may also violate privacy laws in
    some countries if the application were to store private information without first
    encrypting it on the client side. In these cases, you'll either need to set up
    your own synchronization system, or use a database with filtered real-time synchronization,
    such as the *CouchDB project* from Apache.
  prefs: []
  type: TYPE_NORMAL
- en: Most typically though, SQLite serves as an excellent choice for storing structured
    data on the client. It's flexible, very powerful, and very fast, and because it's
    baked into the Android platform, it doesn't add any direct size overhead to your
    application. Most Java developers will be used to JDBC when accessing an SQL database,
    and while Android does have JDBC support, the `android.database` and `android.database.sqlite`
    packages are the preferred methods of accessing the database and are much faster.
    Android also offers an additional layer of abstraction above the direct use of
    SQLite, which we'll explore next.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about SQLite and how to get the most out of it, it's worth
    browsing the project's excellent documentation at [https://sqlite.org/](https://sqlite.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Room
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Direct use of SQLite requires a huge amount of code dedicated to converting
    the SQLite structured data into Java objects, and then preparing SQL statements
    to store those objects back into the database. Mapping an SQL record to a Java
    object normally takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can immediately see, there's a lot of code there that you will need to
    repeat again and again for every one of your data-model objects.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Google has produced a solution to this boilerplate as part of their
    Architecture Components, and it's called **Room**. Room is an API and code generator
    that allows you to define your object model and the SQL queries you want to execute
    while it writes the boilerplate **Data Access Objects** (**DAO**) classes for
    you. Room is an excellent choice because all the heavy lifting is done at compile
    time by generating source code for your application. This also means that it requires
    much less additional code to be included in your application, which helps keep
    your application smaller on the end user's device.
  prefs: []
  type: TYPE_NORMAL
- en: Room isn't a traditional **Object/Relational** (**O/R**) mapping layer, but
    rather allows you to define the `SELECT` statements, and copies whatever data
    they return to an object model that you specify. As a result, it doesn't directly
    handle inter-object relationships (such as `ClaimItem` containing an array of
    `Attachment` objects). While this may seem like a problem, it's a very important
    feature! Relationships like these are common in object models, but are expensive
    to implement in an Object/Relational layer, since every call to `ClaimItem.getAttachments`
    would require another database query, and on Android, those calls are likely to
    leak onto the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, Room is designed so that you can create object models that are suitable
    for data-binding, and build SQL queries that can return them directly. This pushes
    the complexity back into the database, and helps encourage a single query to display
    programming behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Room to the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Room is part of the Architecture Components, and is not imported into projects
    by default. Instead, you need to add them as a dependency to your project by following
    these simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Android panel, open the Gradle Scripts subsection and then open the
    `build.gradle` for the app module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2d3959c0-ae5d-4725-a438-6d57e0b53eca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At the bottom of the file, you''ll find a dependencies block; at the bottom
    of the block, add the following two lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Use the Sync Now link at the top of the editor to synchronize your project with
    its Gradle file. Android Studio will automatically download the new Room dependencies
    for your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your project now has the Room API and its code generators integrated, and you
    can start creating a persistent object model and database schema.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating an Entity model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Room, much like an SQL database, is optionally asymmetric; what you write to
    it might not be in the exact same format as what you read from it. When you write
    to a `Room` database, you save `Entity` objects, but when you read, you can read
    virtually any Java object. This allows you to define object models that best suit
    your user interface, and load them with `JOIN` queries rather than resorting to
    one or more additional queries for each object you wish to present to the user.
    While `JOIN` queries might be overly expensive on a server, on a mobile device
    they are often significantly faster than a multiquery alternative. As such, when
    defining an entity model, it's worth considering what you will need to save in
    your database as well as what specific fields you will need on your user interface.
    The data you need to write to storage becomes your entity, while the fields on
    your user interface become fields in Java objects that can be queried through
    Room.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `Entity` class in Room is annotated with `@Entity`, and is expected to follow
    certain rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Fields must either be `public` or have Java Beans style getters and setters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At least one field must be marked as a primary key using the `@PrimaryKey` annotation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Room expects a single `public` constructor, so you may need to mark the other
    constructors with an `@Ignore` annotation in order for your code to compile. It's
    often best to leave only a default (no arguments) constructor for Room to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to start storing claim data using Room, we will need to modify the
    existing `ClaimItem` and `Attachment` classes so that they are valid entities.
    This will involve making them usable as relational structures; `ClaimItem` and
    `Attachment` will both need an ID primary key, and attachment will need a foreign
    key identifier for the `ClaimItem` that it belongs to. Perform the following steps
    to modify these two data model classes so that they can be stored as entities
    using Room:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by opening the `ClaimItem` source file in Android Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Annotate the class declaration with `@Entity`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an ID field, annotate it with `@PrimaryKey`, and tell Room that you want
    it generated by the database rather than having to create IDs manually (you can
    also add getters and setters for this field if you like):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Leaving the fields `public` means that Room will directly access the fields
    in preference to using getters and setters. Field access can be much faster than
    method calls to the getters and setters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tell Room to ignore the `List` of `Attachment`. Room is unable to directly
    persist these sorts of relationships, and your application will fail to compile
    when it tries to generate mapping code for this field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the `Parcelable` implementation of `ClaimItem` to save and restore the
    ID field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Open the `Attachment` source file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `Entity` annotation to the `Attachment` class; this time you''ll need
    to include an `@Index` annotation as well to tell Room to generate a database
    index on a new field you''ll be adding--`claimItemId`. The index will ensure that
    queries to fetch the attachments for a specific `ClaimItem` record are nice and
    fast:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the database primary key field for the `Attachment`, and the new `claimItemId`
    field that will be used to indicate which `ClaimItem` the `Attachment` belongs
    to when it''s stored in the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that there is a `public` default constructor, and that any other `public`
    constructors are marked with `@Ignore`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `Attachment` classes `Parcelable` implementation to include the
    new fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, modifying an existing object model to be stored in a `Room`
    database is very simple. Room will now be able to generate code to load and save
    these objects from tables in its database; it'll also be able to generate the
    database schema from these classes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Data Access Layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you have something to write into the database, you need some way to
    actually write it, and a way to retrieve it again. The most common pattern is
    to have a dedicated class to deal with this for each class--a Data Access Object
    class, also known as a DAO. In Room, however, all you have to do is declare what
    they should look like using an interface; Room will write the implementation code
    for you. You define your queries using the `@Query` annotation on a method, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This has a huge advantage over traditional O/R mapping layers in that you can
    still write any form of SQL query, and let Room figure out how to convert it into
    the object model you ask for. If it can''t write the code, you get an error at
    compile time, rather than potentially having your app crash for your users. This
    also has an additional advantage: Room can bind your SQL queries to non-entity
    classes, allowing you to leverage the full power of your SQLite database without
    having to do all the column/field/object mapping by hand. For example, you can
    define a special `DisplayContact` class for displaying the summary data for a
    contact in a list, and then query them directly using a `join`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding query doesn't return an object that can be directly saved in the
    database; it's the result of looking at two different tables and collecting fields
    from both of them. Room copes with this just fine though, and doesn't need any
    sort of annotations on the classes to be returned.
  prefs: []
  type: TYPE_NORMAL
- en: The LiveData class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Room does much more than binding your database structures to objects and back
    again; it offers you the ability to write reactive programs much more simply.
    As already mentioned, Room is one of the Android Architecture Components libraries.
    Architecture Components collectively provide generic infrastructure that can be
    used to more rapidly build reactive applications, while also maintaining excellent
    performance and safety. One of the most important classes in the architecture
    components is `LiveData`. `LiveData` is a generic encapsulation of data that is
    subject to external changes. `LiveData` can be observed, much like the classes
    used for data-bound layouts. The primary difference is that `LiveData` will always
    trigger a *first* event on any new observer, providing it with the current data
    state.
  prefs: []
  type: TYPE_NORMAL
- en: Room has built-in support for `LiveData`, meaning that you can return any object
    wrapped in a `LiveData` in order to receive any changes that occur to that object.
    At the time of writing, Room implements this by watching each of the tables for
    changes. This means you may receive updates to objects, even though they haven't
    actually changed. This should not be a problem for most applications, because
    the queries still run on a worker thread and only the notification happens on
    the main thread. This makes `LiveData` the preferred method for querying the database
    in most situations, because it takes care of running and processing the query
    on a worker, freeing your main thread to handle events and keep your application
    running smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '`LiveData` is not part of Room directly, so you''ll need to follow these steps
    to add `LiveData` and the other Architecture Components to your project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Android panel, open the Gradle Scripts subsection and then open the
    build.gradle for the app module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9ad95035-2fd3-4ea9-adeb-fcfa1f8491b8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At the bottom of the file, you''ll find a dependencies block; at the bottom
    of the block, add the following two lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Use the Sync Now link at the top of the editor to synchronize your project with
    it's Gradle file, and download the new dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing Data Access Objects in Room
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You'll need to implement two different Data Access Object classes for the Claim
    application, one for each `Entity` object. Technically speaking, Room doesn't
    enforce one DAO per entity, and you can have a single DAO interface for your entire
    application or have one per screen. However, the most common pattern is to have
    one DAO class per entity type, even when some of its query methods return statistics
    or other views on the data. When working with more complex datasets, it's worth
    considering introducing additional DAO interfaces to cover queries that are either
    screen-specific or where the data overlaps several entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how to implement the Data Access Object interfaces for the Claim example
    application, step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `model` package in Android Studio and select New | Java Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new class `db.ClaimItemDao`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the Kind field to Interface. Room DAO types are normally interfaces,
    although this isn't a strict requirement, and they can also be abstract classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click OK to create the new package and class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Annotate the interface with `@Dao` to mark it as a data-access-object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a query method to fetch all the `ClaimItem` objects in order of the
    most recent first; ensure that it returns a `LiveData` so that the changes are
    reflected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you need methods to insert, update, and delete the `ClaimItem` objects
    in the database; these methods always take only the `Entity` object and instead
    of a query, are annotated with their operation. In the case of the insert method,
    it''s useful to have it return the generated ID of the new record:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, right-click on the `db` package again, and select New | Java Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new class `AttachmentDao`, and make Kind to Interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click OK to create the `AttachmentDao` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the new interface as a `Dao`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a query method to fetch the `Attachment` objects for a single `ClaimItem`.
    This is where the index you declared on `Attachment` becomes important:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the insert, update, and delete methods for the `Attachment` classes,
    just as you did with the `ClaimItem` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Creating a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing an application using Room, you'll need to define at least one *Database*
    class. Each of these corresponds to a specific database schema--a collection of
    Entity classes and the various ways in which they can be saved, and loaded from
    storage. It may also serve as a convenient place to write other database-related
    logic for your application. For example, the `ClaimItem` and `Attachment` classes
    need to save and load various types that Room will not understand; for example,
    `Date`, `File`, the `Category` enum, and `Attachment` `Type` enum. Each of these
    classes will need a `TypeConverter` method that can be used to convert it to and
    from primitives that are understood by Room.
  prefs: []
  type: TYPE_NORMAL
- en: 'Room Database classes are abstract. This is because they are extended by the
    Room annotation processor to produce the implementation you''ll use at runtime.
    This allows you to define any number of concrete method implementations in a database
    class that might be useful for your application. Follow these steps to declare
    your new Room enabled database class:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `db` package in Android Studio, and select New | Java Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new class `ClaimDatabase`, and change its Superclass to `RoomDatabase`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Abstract modifier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click OK to create the new class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Annotate the class to indicate it as a database, and declare that it will store
    the `ClaimItem` and `Attachment` entities. You''ll also need to specify the schema
    version, which will be `1` for the first version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned earlier, you''ll need to declare `TypeConverter` methods for all
    the non-primitive fields that `ClaimItem` and `Attachment` use. You need to tell
    the database where these methods can be found, and in this case, it''ll be the
    `ClaimDatabase` class itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, define `abstract` methods to retrieve the Data Access Object implementations
    you created earlier; these methods will be implemented by the subclass generated
    by Room:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you''ll need to tell Room how to convert the various fields to and from
    the primitives supported by the database. Start by implementing methods to convert
    `Date` objects into a timestamp long that can be stored in the database (SQLite
    has no `DATE` or `DATETIME` types):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now continue with this pattern for the other types that the `ClaimItem` and
    `Attachment` need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `TypeConverter` methods will be found and used by the Room annotation processor.
    They are invoked directly from the generated code, based on the types used in
    the Java classes being stored or retrieved. This means that they have almost no
    additional runtime overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing your Room database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you've built all the components for a Room managed SQLite database,
    but you still don't actually have access to it. You can't instantiate the `ClaimDatabase`
    class directly because it's abstract, and you have the same problem with the DAO
    interfaces, so what's the best way to access the database? Room provides you with
    an entry class that will correctly instantiate the generated `ClaimDatabase` implementation,
    but that isn't the whole story; your entire application relies on this database,
    and it should be set up when the application starts and should be accessible by
    the entire application.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use a singleton `ClaimDatabase` object, but then where will the SQLite
    database file be placed? In order for it to be stored in your application''s private
    space, you need a Context object. Enter the `Application` class, which when used,
    holds the first `onCreate` method that will be invoked in your application. Follow
    these quick steps to build a simple `Application` class that will instantiate
    and hold a reference to your `ClaimDatabase`:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on your root package (that is, `com.packtpub.claim`) and select
    New | Java Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new class `ClaimApplication`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make its Superclass `android.app.Application`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click OK to create the application class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare a static `ClaimDatabase` to be used by the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Override the `onCreate` method and use it to instantiate the `ClaimDatabase`
    object using Room; this will happen before anything else in your application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Provide a `public` `static` method for other parts of the application to use,
    to access the singleton database instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You need to register the `ClaimApplication` with the Android platform so that
    it knows to initialize it when the application is started. You do this by opening
    the manifests directory and opening the `AndroidManifest.xml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `<application>` element, you''ll need to add an `android:name` attribute
    to tell the Android platform the name of the class that represents the root of
    your application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now, whenever any part of your application needs the database, it can simply
    invoke `ClaimApplication.getClaimDatabase()` to retrieve a global instance, and
    because it's no longer tied to a specific context instance, it can be invoked
    from anywhere (even a presenter).
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Room API for Android provides which of the following?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A complete database solution
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A lightweight API on top of SQLite
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An object storage engine
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning `LiveData` from a Room DAO requires that you do which of these?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You observe it for changes in order to retrieve data
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You run the query on the main thread
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You call the query method again when notified by the `LiveData` object
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Database queries that don't return `LiveData` should do what?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Be avoided
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Be run on a worker thread
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Return `Cursor` objects
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing an update method for Room requires which of the listed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An `@Query(“UPDATE` method on a DAO interface
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An `@Update` method taking an `Entity` object on an interface
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Will be added to your `Entity` implementations
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The way you store and retrieve structured data in an Android application has
    a direct knock-on-effect on how your user will experience your application. When
    you choose to use a system like Room, CouchDB, or Firebase, where data changes
    are pushed through the application as updates, the user will naturally have a
    reactive application. What's more, the application will generally be responsive
    because these patterns naturally keep slow running queries and updates off the
    application main thread.
  prefs: []
  type: TYPE_NORMAL
- en: Room provides an excellent addition to the standard Android data storage ecosystem,
    not only dramatically reducing the need to write boilerplate data access code,
    but also providing a well-defined and excellently-written interface to run reactive
    queries for data. Of course, not all of your application needs to be reactive;
    once an object is delivered via a `LiveData` object, it's just an object and can
    be used as an in-memory snapshot or even edited if it's mutable.
  prefs: []
  type: TYPE_NORMAL
- en: When using Room, it's important to remember that you should avoid complex relationships
    between objects, because Room won't be able to save and resolve these for you.
    They're normally a sign that you might need to rethink how you are structuring
    your data; complex relationships will dramatically slow down the queries and therefore
    any user interface that depends on them. Typically, these relationships should
    be handled by creating presentation-specific object models, and then using a join
    in your query to fetch all the required data. For more information about SQL and
    how to use it in SQLite, take a look at the SQLite documentation and tutorials
    on the SQLite project's website, at [https://sqlite.org/](https://sqlite.org/).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at building overview screens. These are extremely
    common start screens in applications; they often form the central screen of an
    application, somewhere that the user is brought back to again and again during
    navigation. Android has a massively versatile widget for these screens--the `RecyclerView`.
    Also, we'll explore how to use the `RecyclerView`, by coupling it to `LiveData`
    and using Data Binding to keep it up to date with the rest of the application.
  prefs: []
  type: TYPE_NORMAL
