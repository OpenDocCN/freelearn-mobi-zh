- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Performance and Scalability
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能和可扩展性
- en: Software systems grow with business and changing environments manifested in
    higher complexity, more diverse user demands, and heavier workloads. The ability
    to maintain high performance and scale under growth becomes critical. Performance
    refers to how quickly a system can process and respond to requests, while scalability
    describes a system’s capacity to handle a higher volume of traffic and usage over
    time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 软件系统随着业务和不断变化的环境而增长，表现为更高的复杂性、更多样化的用户需求和更重的负载。在增长过程中保持高性能和可扩展性变得至关重要。性能指的是系统处理和响应请求的速度，而可扩展性描述的是系统随着时间的推移处理更高流量和使用的容量。
- en: Poor performance can lead to frustrating user experiences, lost productivity,
    and even complete system failures. And systems that can’t scale to meet rising
    demands will quickly become overwhelmed and unusable. Therefore, ensuring optimal
    performance and scalability is a key challenge for any software engineering project.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 低性能可能导致令人沮丧的用户体验、生产力下降，甚至完全的系统故障。而无法扩展以满足日益增长需求的系统将很快变得不堪重负，无法使用。因此，确保最佳性能和可扩展性是任何软件工程项目的关键挑战。
- en: In this chapter, we’ll explore the core concepts and principles of performance
    engineering and scalable system design. We’ll discuss common performance bottlenecks
    and mitigation strategies, review techniques for load testing and benchmarking,
    and cover architectural patterns and design choices that enable horizontal and
    vertical scalability.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨性能工程和可扩展系统设计的核心概念和原则。我们将讨论常见的性能瓶颈和缓解策略，回顾负载测试和基准测试的技术，并涵盖支持水平和垂直扩展的架构模式和设计选择。
- en: By the end of this chapter, you’ll have a solid understanding of how to build
    highly performant, scalable systems that can withstand the pressure of real-world
    demands.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将深入了解如何构建高性能、可扩展的系统，以承受现实世界需求的压力。
- en: 'We’re going to cover the following topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Dimensions of performance and scalability
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能和可扩展性的维度
- en: Optimize performance now or later?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在还是稍后优化性能？
- en: Performance test planning
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能测试规划
- en: Executing a performance test
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行性能测试
- en: Micro-benchmarking
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微基准测试
- en: Strategies for performance improvement
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能提升策略
- en: Ultra-low latency systems
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 极低延迟系统
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find all the code files used in this chapter on GitHub: [https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-12](https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-12)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章使用的所有代码文件：[https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-12](https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-12)
- en: Dimensions of performance and scalability
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能和可扩展性的维度
- en: 'Performance is the efficiency of a system in executing tasks and responding
    to requests. It’s measured by various metrics:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 性能是系统执行任务和响应请求的效率。它通过各种指标来衡量：
- en: '**Latency**: The time taken for the system to respond to a request.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟**：系统响应请求所需的时间。'
- en: '**Throughput**: The number of requests processed in a given time frame.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**吞吐量**：在给定时间框架内处理的请求数量。'
- en: '**Resource utilization**: The percentage of resources (for example CPU, memory,
    network, files, and so on) used during operations.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源利用率**：在操作期间使用的资源（例如CPU、内存、网络、文件等）的百分比。'
- en: '**Concurrent users**: The number of users effectively served by the system
    simultaneously without degradation in performance.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发用户**：系统同时有效服务而不会降低性能的用户数量。'
- en: '**Page load time**: The total time taken for a screen to fully load, including
    all assets (images, videos, scripts, and so on)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**页面加载时间**：屏幕完全加载所需的总时间，包括所有资源（图像、视频、脚本等）'
- en: '**Queue size**: The number of requests waiting to be processed by the server'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**队列大小**：等待服务器处理的请求数量'
- en: '**Time to first byte** (**TTFB**): The time that elapsed from when the client
    initiated a request to the client receiving the first byte from the server.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**首次字节时间**（**TTFB**）：从客户端发起请求到客户端从服务器接收到第一个字节所经过的时间。'
- en: '**Cache hit ratio**: The percentage of requests served from the cache versus
    those from the slower secondary data source. A higher ratio indicates more efficient
    caching.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存命中率**：从缓存中服务请求的百分比与从较慢的二级数据源中服务请求的百分比。更高的比率表明缓存效率更高。'
- en: '**Error rate**: The percentage of requests resulting in errors (for example,
    HTTP error statuses). High error rates indicate problems with the application
    or infrastructure.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误率**：导致错误的请求百分比（例如，HTTP错误状态）。高错误率表明应用程序或基础设施存在问题。'
- en: 'Scalability is the capacity of a system to handle increased load without degrading
    performance. It indicates how well a system can grow and adapt to an increase
    in user traffic and data volume. Scalability can be categorized into two types:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性是指系统在不降低性能的情况下处理增加负载的能力。它表明系统可以增长并适应用户流量和数据量的增加。可扩展性可以分为两种类型：
- en: '**Vertical scaling**: Adding more resources (for example, CPU or RAM) to a
    single node to increase its capacity. This is also known as **scale up**.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垂直扩展**：向单个节点添加更多资源（例如，CPU或RAM）以增加其容量。这也被称为**向上扩展**。'
- en: '**Horizontal scaling**: Adding more nodes to distribute the load and improve
    capacity in a distributed system. This is also known as **scale out**.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平扩展**：向分布式系统中添加更多节点以分散负载并提高容量。这也被称为**向外扩展**。'
- en: Scalability is also the capacity of a system to downsize when the load is reduced.
    Scaling down is usually concerned with the flexible use of resources and cost
    savings. It’s still an important aspect of scalability, but the focus is usually
    on scaling up and scaling out.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性也是系统在负载减少时缩小规模的能力。缩小规模通常涉及资源的灵活使用和成本节约。这仍然是可扩展性的一个重要方面，但重点通常放在向上扩展和向外扩展上。
- en: 'Scalability can be measured by the following metrics:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性可以通过以下指标来衡量：
- en: '**Scalability ratio**: The ratio of the increase in performance to the increase
    in resources such as the number of servers'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性比率**：性能增加与资源增加（如服务器数量）之间的比率'
- en: '**Time to scale**: The time taken between adding resources to extra resources
    becoming operational in the system'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展时间**：向系统中添加资源到额外资源变为可操作之间的时间'
- en: These metrics are useful in measuring how a change in the system may affect
    performance and scalability. Without them, it’s difficult to decide whether performance
    should be optimized or not. We’re going to discuss this decision in depth in the
    next section.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指标有助于衡量系统中的变化可能如何影响性能和可扩展性。没有它们，很难决定是否应该优化性能。我们将在下一节深入讨论这个决定。
- en: Optimize performance now or later?
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在优化性能还是以后再优化？
- en: Engineers and architects often face the question of whether performance should
    be optimized now or later. This happens from the early stages of system design
    to already established production systems.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 工程师和架构师经常面临是否应该现在优化性能还是以后再优化的问题。这发生在系统设计的早期阶段，以及已经建立的生产系统中。
- en: We all know optimizing performance is crucial, but whether to prioritize it
    from day one isn’t a simple binary question.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道优化性能至关重要，但是否从第一天开始就优先考虑它并不是一个简单的是非问题。
- en: You may have heard of someone who said “*Premature optimization is the root
    of evil.*” The statement itself is theatrical, but there are some merits in it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过有人说过“*过早优化是万恶之源*”。这个说法本身很戏剧化，但其中确实有一些优点。
- en: You may also have heard a quote saying, “*Make it work, make it right, make
    it fast.*” This was coined by software engineer *Kent Beck*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也听说过一句名言，“*先让它工作，再让它正确，最后让它变快*。” 这是由软件工程师*Kent Beck*提出的。
- en: So, what would be the consequences if a system is optimized prematurely, or
    if we reverse the order to “make it fast” too early?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果系统过早优化，或者如果我们过早地“让它变快”，会有什么后果呢？
- en: Spending too much time on performance improvements before understanding user
    behaviors and requirements can lead to wasted effort. Moreover, it creates an
    unnecessarily complex architecture that hinders the team’s productivity. The team
    may have to simplify the over-engineered system, which also requires effort. In
    that sense, the team is punished twice for improving performance too early.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解用户行为和需求之前花费太多时间进行性能改进可能导致努力白费。此外，它创建了一个不必要的复杂架构，阻碍了团队的效率。团队可能不得不简化过度设计的系统，这也需要付出努力。从这个意义上说，团队因为过早提高性能而受到了两次惩罚。
- en: Considerations for optimizing performance and scalability
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化性能和可扩展性的考虑因素
- en: 'There are several factors to consider regarding whether the system should be
    optimized for performance and scalability:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑系统是否应该为了性能和可扩展性进行优化时，有几个因素需要考虑：
- en: '**Core features completeness**: If the core features of a system are still
    being developed, then it’s often more important to focus on delivering core features
    and functionality initially. This is the first step: “*Make* *it work.*”'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**核心功能完整性**：如果一个系统的核心功能仍在开发中，那么最初专注于交付核心功能和功能通常更为重要。这是第一步：“*让它工作*。”'
- en: 'In addition, we must ensure the system behaves as expected as per functional
    requirements. Correctness should always come before performance. This is the second
    step: “*Make* *it right.*”'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，我们必须确保系统按照功能要求的行为符合预期。正确性始终应该优于性能。这是第二步：“*让它正确*。”
- en: '**Performance metrics**: Before optimizing performance or improving scalability,
    it’s paramount to have current performance metrics as a baseline. A performance
    baseline provides insights into the current system bottlenecks that help the team
    prioritize which area should be improved first.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能指标**：在优化性能或提高可扩展性之前，拥有当前的性能指标作为基准至关重要。性能基准可以提供关于当前系统瓶颈的见解，帮助团队确定哪个区域应该首先改进。'
- en: A performance benchmark enables empirical and objective comparison of whether
    a change has resulted in better or worse performance, or whether an attempt to
    improve performance has achieved its goals.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 性能基准测试可以经验性地和客观地比较一个变更是否导致了更好的或更差的表现，或者是否尝试改进性能已经达到了其目标。
- en: '**Non-functional requirements**: Non-functional requirements are a useful source
    of guidance on whether the system needs to be optimized now. Non-functional requirements
    for performance can be driven by regulatory constraints, external system integration
    conformance, or principles of user experiences.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非功能性需求**：非功能性需求是关于系统是否需要现在进行优化的有用指导。性能的非功能性需求可能由监管约束、外部系统集成合规性或用户体验原则驱动。'
- en: '**Critical use cases, user experiences, and competitors**: If the application
    is expected to handle high traffic from the beginning (for example, product launch
    events, training, or marketing campaigns), then early optimization is essential.
    If the application’s performance directly impacts user satisfaction, it’s important
    to address performance concerns early to avoid negative feedback. The current
    performance metrics of competitors also indicate how much the application’s performance
    should be optimized.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关键用例、用户体验和竞争对手**：如果一个应用从一开始就预计要处理大量流量（例如，产品发布活动、培训或营销活动），那么早期优化是必不可少的。如果一个应用的性能直接影响用户满意度，那么早期解决性能问题以避免负面反馈很重要。竞争对手的当前性能指标也表明了应用性能应该优化多少。'
- en: '**Scalability needs**: If rapid growth or scaling needs are anticipated for
    an application, implementing good performance practices from the beginning will
    save time and effort later.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性需求**：如果一个应用预计会有快速增长或扩展需求，那么从一开始就实施良好的性能实践可以在以后节省时间和精力。'
- en: Best practices for performance
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能最佳实践
- en: 'Even if it may not be the right time to optimize performance, there are some
    best practices to at least not make performance worse:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 即使现在可能不是优化性能的最佳时机，也有一些最佳实践至少可以避免性能变得更差：
- en: '**Measure first**: Measure the current performance metrics, ideally all operations,
    but as a bottom line, measure the core features and most frequent operations.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**先测量**：测量当前的性能指标，理想情况下是所有操作，但底线是测量核心功能和最频繁的操作。'
- en: '**Implement basic optimization**: Basic performance best practices such as
    efficient database queries in the early stage of development.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现基本优化**：在开发早期阶段，实现基本性能最佳实践，例如高效的数据库查询。'
- en: '**Plan for scalability**: Plan and have scalability in mind when designing
    system architecture to allow for easier optimization later without major refactoring.
    Sometimes, it’s about not putting restrictions that would limit scalability.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性规划**：在设计系统架构时，考虑到可扩展性，以便在以后更容易优化而无需进行大规模重构。有时，这关乎不要设置限制，这些限制会限制可扩展性。'
- en: While it isn’t always necessary to optimize performance on day one, incorporating
    basic performance considerations into your development process can lead to better
    long-term results. Focus on delivering value first, then iterate on performance
    as the application evolves. Let’s go through an example of performance measurement
    to understand this better.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不一定需要在第一天就优化性能，但将基本性能考虑纳入您的开发流程可以导致更好的长期结果。首先关注交付价值，然后随着应用的演变对性能进行迭代。让我们通过一个性能测量的例子来更好地理解这一点。
- en: An example of basic performance measurement
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本性能测量的示例
- en: 'Here’s a basic example of an operation to be measured:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个要测量的操作的基本示例：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The goal of this example is to find out the following aspects:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的目标是找出以下方面：
- en: '**Throughput**: How many operations can be performed in a second'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**吞吐量**：每秒可以执行多少操作'
- en: '**Latency**: How long it takes to finish an operation on average'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟**：平均完成一个操作所需的时间'
- en: 'A small function, `measureTotalTimeElapsed`, must be defined to measure the
    total time elapsed for all iterations of the operation:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 必须定义一个小的函数`measureTotalTimeElapsed`来测量操作所有迭代的总时间消耗：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This function uses the `measureTimeMillis` Kotlin function from Standard Library
    to capture the time spent in repeating the operation.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用标准库中的`measureTimeMillis` Kotlin函数来捕获重复操作所花费的时间。
- en: 'Finally, this is the `main` function to launch the test:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是启动测试的`main`函数：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This function defines the operation to be executed 1,000 times. After invoking
    the `measure` **TotalTimeElapsed** function with the Lambda expression that runs
    the `sampleOperation` function, the total time elapsed in milliseconds is returned.
    Then, the throughput is calculated as the number of iterations divided by the
    total elapsed time in seconds. The average latency is calculated as the inverse
    reciprocal of throughput – the total time elapsed divided by the number of iterations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数定义了要执行1,000次的操作。通过使用Lambda表达式调用`measure` **TotalTimeElapsed**函数，该表达式运行`sampleOperation`函数，返回总的毫秒时间消耗。然后，吞吐量计算为迭代次数除以总消耗时间（秒）。平均延迟计算为吞吐量的倒数倒数——总时间消耗除以迭代次数。
- en: 'This is a sample output from running the test:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行测试的样本输出：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since the sample function, `sampleOperation`, only makes the thread sleep for
    1 millisecond, the average latency is 1 millisecond, as expected. The throughput
    in this run is close to 800, but it varies in every run.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于示例函数`sampleOperation`仅使线程休眠1毫秒，因此平均延迟如预期为1毫秒。在此运行中，吞吐量接近800，但每次运行都会有所不同。
- en: 'Kotlin Standard Library provides a few functions for time measurement:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin标准库提供了一些时间测量的函数：
- en: 'Return time elapsed in milliseconds (used in this example): `measureTimeMillis`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回时间消耗的毫秒数（在本例中使用）：`measureTimeMillis`
- en: 'Return time elapsed in nanoseconds: `measureNanoTime`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回时间消耗的纳秒数：`measureNanoTime`
- en: 'Return time elapsed as `Duration`: `measureTime`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回时间消耗作为`Duration`：`measureTime`
- en: 'Return time elapsed and the value returned from the Lambda expression: `measureTimedValue`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回时间消耗和Lambda表达式返回的值：`measureTimedValue`
- en: For real-life performance critical systems, this is certainly not enough. Due
    to this, in the next section, we’ll cover the main types of performance tests.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于现实生活中的性能关键系统，这当然是不够的。因此，在下一节中，我们将介绍性能测试的主要类型。
- en: Performance tests
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能测试
- en: Performance tests are a category of test that evaluates the speed, responsiveness,
    and stability of a system under a given workload. In this section, we’ll look
    at the main types of performance tests.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试是一类测试，它评估系统在给定负载下的速度、响应性和稳定性。在本节中，我们将探讨性能测试的主要类型。
- en: Load testing
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 负载测试
- en: Load tests aim to assess the behaviors of a system under expected load conditions,
    such as a configured number of concurrent requests. The goal is to identify bottlenecks
    in application or infrastructure where performance may degrade under load. It
    ensures the system can handle anticipated traffic without performance degradation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 负载测试旨在评估系统在预期负载条件下的行为，例如配置的并发请求数量。目标是识别在负载下性能可能下降的应用程序或基础设施中的瓶颈。它确保系统可以处理预期的流量而不会出现性能下降。
- en: Stress testing
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 压力测试
- en: Stress tests aim to evaluate the system’s performance under extreme load conditions
    beyond its normal operational capacity. They also help us determine the breaking
    point of the system and how it fails under stress, so proactive monitoring and
    alerts can be deployed for precautions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 压力测试旨在评估系统在超出其正常操作容量极限的极端负载条件下的性能。它们还帮助我们确定系统的断裂点以及它在压力下的失败方式，因此可以部署主动监控和警报以采取预防措施。
- en: Endurance testing (soak testing)
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 耐久性测试（浸泡测试）
- en: Endurance tests, known as soak tests, focus on the stability and performance
    of a system over an extended period. This extended period is used to identify
    issues that accumulate or emerge over time, such as memory leaks, resource exhaustion,
    or performance degradation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 耐久性测试，也称为浸泡测试，专注于系统在长时间内的稳定性和性能。这个长时间是用来识别随着时间的推移积累或出现的问题，例如内存泄漏、资源耗尽或性能下降。
- en: Spike testing
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 峰值测试
- en: Spike tests introduce a sudden increase in load (the “spike”) so that we can
    observe how the system reacts in this situation. The result illustrates how the
    system can handle abrupt changes in traffic without failure.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 峰值测试引入突然增加的负载（即“峰值”），以便我们可以观察系统在这种情况下的反应。结果说明了系统如何处理突然的交通变化而不会失败。
- en: Volume and latency testing
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 体积和延迟测试
- en: Volume tests evaluate the system’s performance with a large volume of data.
    Latency tests measure the time delay between a request and the corresponding response.
    They usually measure metrics such as throughput and latency to ensure the application
    can meet **service-level agreements** (**SLAs**) or **service-level** **objectives**
    (**SLOs**).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 体积测试评估系统在大量数据下的性能。延迟测试测量请求和相应响应之间的时间延迟。它们通常测量吞吐量和延迟等指标，以确保应用程序可以满足**服务级别协议**（**SLAs**）或**服务级别****目标**（**SLOs**）。
- en: Scalability testing
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可伸缩性测试
- en: Scalability tests aim to determine how well the system can scale up or down
    in response to increasing or decreasing loads. It measures the performance of
    the system as resources are added or removed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 可伸缩性测试旨在确定系统在响应增加或减少的负载时如何扩展或缩小。它测量在添加或移除资源时系统的性能。
- en: Configuration testing
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置测试
- en: Configuration tests aim to identify the optimal configuration for performance.
    They involve running performance tests under different configurations, including
    hardware, software, and the network.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 配置测试旨在确定性能的最佳配置。这包括在不同的配置下运行性能测试，包括硬件、软件和网络。
- en: Planning a performance test
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能测试规划
- en: Although there are different types of performance tests, planning and executing
    performance tests are similar. The difference is in the details of each step.
    In this section, we’ll explore the journey of planning and executing a performance
    test.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有不同类型的性能测试，但规划和执行性能测试的过程是相似的。区别在于每个步骤的细节。在本节中，我们将探讨规划和执行性能测试的旅程。
- en: Planning
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规划
- en: In the planning phase, first, the objectives of the test should be defined.
    This means we must define the information we want to get out of the tests – for
    example, can a household record be created within 50 milliseconds? Can the system
    handle 5,000 concurrent requests without degradation? These objectives are the
    primary drives to plan and execute a performance test. They also determine which
    type of performance tests can be used.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在规划阶段，首先，应该定义测试的目标。这意味着我们必须定义我们希望从测试中获得的信息——例如，能否在50毫秒内创建一个家庭记录？系统能否在不降级的情况下处理5,000个并发请求？这些目标是规划执行性能测试的主要驱动力。它们还决定了可以使用哪种类型的性能测试。
- en: Then, business scenarios for performance tests should be defined. Usually, the
    objectives would have given a great hint at which scenarios would be used, but
    it’s worth exploring the details of the steps involved in each scenario and formalizing
    them as a blueprint of the test script.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，应该定义性能测试的业务场景。通常，目标会给出关于将使用哪些场景的很大提示，但值得探索每个场景中涉及的步骤的细节，并将它们正式化为测试脚本的蓝图。
- en: The last part of planning is to specify the load levels to run, including the
    number of users and the duration of the test. Sometimes, it isn’t so clear which
    level to run, especially if we want to find the breaking point of the system.
    This is OK initially since performance tests are meant to run iteratively.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 规划的最后部分是指定要运行的负载级别，包括用户数量和测试持续时间。有时，并不清楚要运行哪个级别，特别是如果我们想找到系统的断点。这最初是可以接受的，因为性能测试旨在迭代运行。
- en: Preparation and development
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备和开发
- en: Once there’s an initial plan, the performance test can be prepared and developed.
    These activities can happen in parallel.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦有了初步计划，性能测试就可以准备和开发。这些活动可以并行进行。
- en: 'The test script is the core of the test execution. The test needs to be automated
    to achieve consistent results. This involves a big decision on which tool to use.
    Here’s a list of commonly used tools:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 测试脚本是测试执行的核心。测试需要自动化以实现一致的结果。这涉及到一个重大的决定，即使用哪个工具。以下是一份常用工具的列表：
- en: '**Apache JMeter** ([https://jmeter.apache.org/](https://jmeter.apache.org/)):
    Open source, free, GUI support, distributed testing, plugin support, and Java-based'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apache JMeter** ([https://jmeter.apache.org/](https://jmeter.apache.org/)):
    开源，免费，支持图形用户界面，分布式测试，插件支持，基于Java'
- en: '**LoadRunner by OpenText** ([https://www.opentext.com/](https://www.opentext.com/)):
    Commercial licenses, GUI, integration with CI/CD tools, analytics and reporting
    support, and support for Java'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenText的LoadRunner** ([https://www.opentext.com/](https://www.opentext.com/)):
    商业许可证，图形用户界面，与CI/CD工具集成，支持分析和报告，以及Java支持'
- en: '**Gatling** ([https://docs.gatling.io/](https://docs.gatling.io/)): Open source,
    commercial licenses with additional features, and scripts can be written in Kotlin'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gatling** ([https://docs.gatling.io/](https://docs.gatling.io/)): 开源，带有额外功能的商业许可证，脚本可以用Kotlin编写'
- en: '**K6** ([https://k6.io/](https://k6.io/)): Open source, subscription-based
    for cloud features, and can integrate with CI/CD scripts written in **JavaScript**
    (**JS**)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**K6** ([https://k6.io/](https://k6.io/)): 开源，基于订阅的云功能，可以与用**JavaScript**（**JS**）编写的CI/CD脚本集成'
- en: '**Locust** ([https://locust.io/](https://locust.io/)): Open source, GUI support,
    distributed testing, and scripts written in Python'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Locust** ([https://locust.io/](https://locust.io/)): 开源，支持图形用户界面，分布式测试，脚本用Python编写'
- en: '**BlazeMeter** ([https://www.blazemeter.com/](https://www.blazemeter.com/)):
    Free with limited features, commercial licenses, cloud-based, GUI support, real-time
    reporting and analytics, integrated with CI/CD, and supports JMeter scripts'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BlazeMeter** ([https://www.blazemeter.com/](https://www.blazemeter.com/)):
    免费版功能有限，商业许可证，基于云，支持图形用户界面，实时报告和分析，与CI/CD集成，支持JMeter脚本'
- en: These tools provide comprehensive features such as organizing test scripts,
    managing multiple test configurations, metrics measurement, analytics, and reporting.
    You also have the option to build your own drivers of performance tests. This
    is applicable if your tests are simple and there are sufficient metric measurements
    without external tools.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具提供全面的功能，例如组织测试脚本、管理多个测试配置、度量测量、分析和报告。您还可以选择构建自己的性能测试驱动程序。如果测试简单且没有外部工具的度量测量足够，则适用。
- en: Appropriate metric measurement needs to be set up according to what the test
    script requires. The metrics can be measured by the testing tools, or by the monitoring
    tools already embedded in the system, as discussed previously in [*Chapter 11*](B21737_11.xhtml#_idTextAnchor358).
    Any missing metrics need to be set up before executing the tests.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 需要根据测试脚本的要求设置适当的度量测量。这些度量可以通过测试工具或如前所述已嵌入系统的监控工具进行测量。任何缺失的度量在执行测试之前都需要设置。
- en: Meanwhile, a test environment needs to be set up for execution. Ideally, the
    environment should be comparable to the actual production environment where the
    system runs. If that’s too expensive, an environment of a smaller scale can be
    used to project expected performance, with a degree of inaccuracy in mind.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，需要设置一个测试环境以进行执行。理想情况下，环境应该与系统实际运行的实际生产环境相当。如果成本太高，可以使用较小规模的环境来预测预期性能，同时考虑到一定的误差。
- en: The test environment should be an isolated sandbox that does nothing but the
    performance tests. It can be a challenge for some organizations to replicate a
    production-like environment for performance testing. Replicating an environment
    with data alone may already be a challenge for some organizations. In addition,
    the environment needs to have the necessary data to run the test scenarios.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 测试环境应该是一个隔离的沙盒，只进行性能测试。对于某些组织来说，复制类似生产环境的性能测试环境可能是一个挑战。仅用数据复制环境可能对某些组织来说已经是一个挑战。此外，环境需要具备运行测试场景所需的数据。
- en: Sometimes, the system has integration with third-party systems. In this case,
    the external integration would need to be stubbed out with simulators.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，系统会与第三方系统集成。在这种情况下，外部集成需要使用模拟器进行模拟。
- en: Execution and iteration
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行和迭代
- en: Once we have the test scripts, test environments, and corresponding metrics
    set up, we’re ready to execute the performance test. It’s vital to allow an iterative
    feedback loop where tests can run multiple times, and there could be changes between
    each test. Within each iteration, the same operation should be executed numerous
    times so that we have enough data points to perform analysis.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了测试脚本、测试环境和相应的指标，我们就可以执行性能测试。允许迭代反馈循环至关重要，其中测试可以多次运行，并且每次测试之间可能会有变化。在每次迭代中，应执行相同的操作多次，以便我们有足够的数据点进行分析。
- en: The tests should be run twice at a minimum, where the initial run identifies
    a bottleneck, then a change is made with the intent to eliminate the bottleneck,
    and finally, another run proves the bottleneck no longer exists, as indicated
    by metrics.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 至少应运行两次测试，初始运行识别瓶颈，然后进行更改以消除瓶颈，最后再次运行以证明瓶颈不再存在，如指标所示。
- en: Realistically, another bottleneck will emerge after the biggest one is eliminated.
    The performance landscape will change for every change that’s made to improve
    performance. The iteration can end when the objectives are completed, or a new
    problem may be discovered during the process.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在消除最大的瓶颈之后，另一个瓶颈将会出现。性能景观将随着为提高性能所做的每一次改变而改变。当目标完成时，迭代可以结束，或者在这个过程中可能会发现新的问题。
- en: 'The iterative execution of a performance test can be seen in *Figure 12**.1*:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试的迭代执行可以在*图12.1*中看到：
- en: '![Figure 12.1 – A sample workflow of performance testing](img/B21737_12_1.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 性能测试的示例工作流程](img/B21737_12_1.jpg)'
- en: Figure 12.1 – A sample workflow of performance testing
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 性能测试的示例工作流程
- en: In each run, the test is executed by running the test script. The test script
    usually starts with warm-up operations. For example, if we’re going to send 10,000
    requests 100 times, the first 10 times can be treated as a warm-up, so the metrics
    aren’t considered.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次运行中，测试通过执行测试脚本进行。测试脚本通常以预热操作开始。例如，如果我们打算发送10,000个请求100次，前10次可以被视为预热，因此这些指标不考虑。
- en: Warming up allows the system to reach a stable state before actual performance
    measurements are taken. Processing initial requests triggers the cache so that
    it populates with frequently accessed data. It also allows the system to allocate
    resources such as thread, memory, and database connections effectively. Other
    transient factors such as just-in-time compilation, garbage collection, and resource
    contention can be reduced by warming up the system.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 预热允许系统在实际性能测量之前达到稳定状态。处理初始请求触发缓存，使其填充频繁访问的数据。它还允许系统有效地分配资源，如线程、内存和数据库连接。通过预热系统，可以减少其他瞬态因素，如即时编译、垃圾收集和资源竞争。
- en: 'After running the test, a report should be generated from the metric data that’s
    been collected. The report should be constructed in a format that allows iterations
    to be compared. The raw data is then analyzed to produce statistical figures such
    as the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行测试后，应从收集到的指标数据生成报告。报告应构建成一个允许迭代进行比较的格式。然后分析原始数据以生成如下统计图表：
- en: The mean and median percentiles of the response time
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应时间的平均值和中位数百分位数
- en: Average and peak throughputs; increase in throughput divided by the increase
    in resource which indicates scaling efficiency
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均和峰值吞吐量；吞吐量的增加除以资源的增加，这表明了扩展效率
- en: The overall error rate and error rates by types
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总体错误率和按类型划分的错误率
- en: Average and maximum latency
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均和最大延迟
- en: The number of concurrent users being handled without degradation
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够处理而不降级的并发用户数量
- en: The time for which the load was maintained
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维持负载的时间
- en: From these numbers, some bottlenecks may be identified. Some figures can be
    below the non-functional requirements, SLAs, or SLOs. Some figures can stand out
    as particularly slow compared to others. These bottlenecks drive the changes required
    to improve overall performance.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些数字中，可以识别出一些瓶颈。一些数字可能低于非功能性需求、SLA或SLO。一些数字可能与其他数字相比特别慢。这些瓶颈推动了为提高整体性能所需的变化。
- en: Especially in early iterations, deficiencies in the test scripts may be identified.
    It isn’t uncommon to realize the test script itself isn’t efficient and causes
    slowness in the system. The test script may have unnecessary loops or complex
    logic that slows down the script’s execution time. The test script may have an
    artificial wait time between requests, which as a result limits the throughput.
    Other factors, such as error handling, synchronous operations, resource contention,
    and network performance, can also skew the result of performance tests. These
    findings lead to the test script being reviewed and updated for future runs.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在早期迭代中，可能会发现测试脚本中的缺陷。测试脚本本身效率低下并导致系统变慢的情况并不少见。测试脚本可能包含不必要的循环或复杂的逻辑，这会减慢脚本的执行时间。测试脚本可能在请求之间有虚假的等待时间，这结果限制了吞吐量。其他因素，如错误处理、同步操作、资源竞争和网络性能，也可能扭曲性能测试的结果。这些发现导致测试脚本被审查和更新以供未来运行。
- en: After changes are made, the performance tests should be executed again to examine
    whether the target performance statistical figures have improved, and at the same,
    to ensure the changes don’t deteriorate system performance in other areas.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行修改后，应再次执行性能测试，以检查目标性能统计指标是否有所提升，同时确保这些更改不会在其他区域降低系统性能。
- en: 'This repetitive exercise carries on until we’re satisfied with the results.
    There are several possibilities where the iteration should stop:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这种重复的练习会持续进行，直到我们对结果感到满意。有几个可能的情况，迭代应该停止：
- en: The test objectives have been completed – for example, we’ve detected the maximum
    number of requests the system can handle without performance degradation
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试目标已经完成——例如，我们已经检测到系统在不降低性能的情况下可以处理的最大请求数量。
- en: The performance metrics have fulfilled the non-functional requirements, SLAs,
    or SLOs
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能指标已满足非功能性需求、SLA或SLO
- en: The time spent on performance testing has exceeded the original time-boxed duration
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能测试所花费的时间已经超过了最初的时间盒限制
- en: Performance testing is meant to be a recurring exercise. A successful and satisfactory
    performance test only supports the assumption that the system is capable of handling
    requests within the configuration and parameters in the test scripts. The system
    usage pattern is constantly changing due to business growth and new features being
    introduced over time.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试应被视为一种反复进行的练习。一次成功且令人满意的表现测试只能支持假设系统能够在测试脚本中的配置和参数下处理请求。由于业务增长和新功能的引入，系统使用模式会不断变化。
- en: Benefits of performance testing
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能测试的好处
- en: Performance testing provides insights into how the system performs under pre-configured
    loads. It indicates how we can optimize the system to provide a fast and reliable
    user experience, even under heavy load. It helps stakeholders understand system
    limits and make informed decisions about scaling and infrastructure. It also identifies
    potential issues before they impact users, reducing the risk of downtime or service
    degradation.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试提供了在预配置负载下系统性能的见解。它表明我们如何优化系统以提供快速且可靠的用户体验，即使在重负载下也是如此。它帮助利益相关者了解系统限制并就扩展和基础设施做出明智的决定。它还在这些问题影响用户之前识别潜在问题，从而降低停机或服务退化的风险。
- en: Performance tests are essential for ensuring that applications meet user expectations
    and maintain stability under varying conditions. By conducting different types
    of performance tests, organizations can identify and address potential issues,
    optimize performance, and enhance overall user satisfaction.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试对于确保应用程序满足用户期望并在不同条件下保持稳定性至关重要。通过进行不同类型的性能测试，组织可以识别和解决潜在问题，优化性能，并提高整体用户满意度。
- en: Next, we’ll consider a technique that’s used iteratively to measure a function’s
    performance. This technique is called micro-benchmarking.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将考虑一种迭代使用的技术来衡量函数的性能。这种技术被称为微基准测试。
- en: Micro-benchmarking
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微基准测试
- en: 'While performance testing focuses on system-level performance, micro-benchmarking
    is a performance measurement of a small and isolated piece of code at the function
    level. Micro-benchmarking is usually applicable to the following areas:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然性能测试关注的是系统级性能，但微基准测试是在函数级别对一小块独立代码的性能测量。微基准测试通常适用于以下领域：
- en: The algorithm that sits in the core of the whole system – for example, a search
    algorithm for an internet search engine
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个系统核心处的算法——例如，互联网搜索引擎的搜索算法
- en: The function that’s used most frequently by end users
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户最频繁使用的功能
- en: The function that’s exposed as an API to external systems
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为API暴露给外部系统的功能
- en: The code path that’s mission-critical and performance-sensitive
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至关重要的代码路径和性能敏感
- en: When comparing the implementations of a function, an algorithm, or a code change
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当比较一个函数、算法或代码更改的实现时
- en: '**Kotlin benchmarking** ([https://github.com/Kotlin/kotlinx-benchmark](https://github.com/Kotlin/kotlinx-benchmark))
    is the most popular tool for running benchmarks for Kotlin code. It wraps the
    classic **Java Microbenchmark Harness** (**JMH**) framework, and it supports Kotlin
    through **Java Virtual Machine** (**JVM**), JS, Native, and even **Web** **Assembly**
    (**WASM**).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kotlin基准测试** ([https://github.com/Kotlin/kotlinx-benchmark](https://github.com/Kotlin/kotlinx-benchmark))
    是运行Kotlin代码基准测试最流行的工具。它封装了经典的**Java微基准工具**（**JMH**）框架，并通过**Java虚拟机**（**JVM**）、JS、本地和甚至**Web
    Assembly**（**WASM**）支持Kotlin。'
- en: Setting up micro-benchmarking with a Gradle Kotlin DSL script
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Gradle Kotlin DSL脚本设置微基准测试
- en: 'It’s simple to set up benchmarking with a Gradle Kotlin DSL script. For example,
    for JVM, we need the following plugins:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Gradle Kotlin DSL脚本设置基准测试很简单。例如，对于JVM，我们需要以下插件：
- en: '[PRE4]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The first plugin is for Kotlin micro-benchmarking, while the second plugin
    is used to open the final Kotlin classes for instrumentation. Now, we need to
    make sure the plugins and dependencies can be looked up from repositories:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个插件用于Kotlin微基准测试，而第二个插件用于打开最终的Kotlin类以进行测试。现在，我们需要确保可以从存储库中查找插件和依赖项：
- en: '[PRE5]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, a code dependency on Kotlin micro-benchmarking needs to be declared:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，需要声明对Kotlin微基准测试的代码依赖项：
- en: '[PRE6]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we need to configure the `allOpen` plugin so that it only opens Kotlin
    classes with the `State` annotation:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要配置`allOpen`插件，使其仅打开带有`State`注解的Kotlin类：
- en: '[PRE7]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The final part of the setup is setting up micro-benchmarking itself:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 设置的最后部分是设置微基准测试本身：
- en: '[PRE8]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The configuration is called `main` and has been chosen to run. It’s possible
    to configure the number of warmup iterations, the number of iterations to be measured,
    and the length of how long each iteration should last. However, an annotation-based
    configuration has been used in this example.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 配置被命名为`main`并已被选中运行。可以配置预热迭代次数、要测量的迭代次数以及每次迭代应持续多长时间。然而，此示例中使用了基于注解的配置。
- en: The micro-benchmarking test
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微基准测试
- en: 'The actual benchmark runner code is annotated so that it can be picked by the
    runner for execution with a specific configuration. Please note that this test
    should be placed in the `main` source folder (not the `test` source folder) so
    that it can be picked up by the plugin:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的基准测试运行器代码被注释，以便运行器可以按照特定配置执行它。请注意，此测试应放置在`main`源文件夹（而不是`test`源文件夹）中，以便插件可以捕获：
- en: '[PRE9]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This micro-benchmarking test evaluates the performance of the function that
    combines two `State` annotation triggers the `allOpen` plugin to open this class
    for instrumentation. Then, the `Fork` annotation defines how many threads are
    used for execution. Other annotations specify the number of iterations for warmup,
    execution, and the duration of each iteration.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此微基准测试评估了结合两个`State`注解触发`allOpen`插件打开此类进行测试的功能的性能。然后，`Fork`注解定义了用于执行的线程数。其他注解指定了预热、执行迭代的次数以及每次迭代的持续时间。
- en: For example, the `setup` annotation function is used to create the data required
    to run the test, while the `combineUUIDBenchmark` function, which has the `Benchmark`
    annotation, is the major function to be measured.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`setup`注解函数用于创建运行测试所需的数据，而具有`Benchmark`注解的`combineUUIDBenchmark`函数是主要要测量的功能。
- en: Micro-benchmarking runner
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微基准测试运行器
- en: 'To run micro-benchmarking, we can use the following Gradle command:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行微基准测试，我们可以使用以下Gradle命令：
- en: '[PRE10]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The summary of the result is printed to the console, while the detailed report
    is generated under the `/``build/reports/benchmarks/main` folder:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 结果摘要打印到控制台，而详细报告生成在`/``build/reports/benchmarks/main`文件夹下：
- en: '[PRE11]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The format of micro-benchmarking is designed to compare runs. Improvements can
    be made between runs, and the next run should demonstrate whether the changes
    have made a difference.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 微基准测试的格式旨在比较运行情况。可以在运行之间进行改进，并且下一次运行应该展示这些更改是否产生了影响。
- en: Micro-benchmarking is a valuable subset of performance testing that focuses
    on code implementation. By understanding the performance characteristics of isolated
    functions, engineers can make targeted optimizations. In contrast, performance
    testing takes a holistic approach to assess how well the entire system performs
    under various conditions. Both practices are essential for delivering high-performance
    systems.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 微基准测试是性能测试的一个有价值的子集，它专注于代码实现。通过了解独立函数的性能特征，工程师可以进行有针对性的优化。相比之下，性能测试采用整体方法来评估整个系统在各种条件下的性能。这两种实践对于交付高性能系统都是必不可少的。
- en: There’s another tool that measures and analyzes the performance of an application,
    but visually with graphical user interfaces. This tool is called the application
    profiler, and we’re going to cover it in the next section.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一个工具可以测量和分析应用程序的性能，但通过图形用户界面进行可视化。这个工具被称为应用程序性能分析器，我们将在下一节中介绍它。
- en: Application profiling
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序性能分析
- en: Profiling works by monitoring and analyzing the performance of an application
    at runtime. Profilers instrument code and intercept calls to collect performance
    measurements, such as elapsed time and the number of invocations. It can generate
    the stack trace of the application to visualize relationships between functions.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析通过监控和分析应用程序在运行时的性能来工作。性能分析器对代码进行仪器化并拦截调用以收集性能度量，例如已用时间和调用次数。它可以生成应用程序的堆栈跟踪，以可视化函数之间的关系。
- en: The profiler tool also monitors memory allocation and deallocation, analyzes
    the heap dump, and identifies potential memory leaks.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析工具还监控内存分配和释放，分析堆转储，并识别潜在的内存泄漏。
- en: At the same time, the profiler tool measures CPU cycles that have been consumed
    by various parts of the code and identifies computing-intensive functions. The
    profiler tool also monitors the usage of other resources, such as file operations,
    network activities, and interactions, among threads to provide a comprehensive
    view of resource utilization.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，性能分析工具测量代码各个部分消耗的CPU周期，并识别计算密集型函数。性能分析工具还监控其他资源的使用情况，例如文件操作、网络活动以及线程之间的交互，以提供资源利用的全面视图。
- en: The profiler tool comes with detailed reports that are visualized in the user
    interface to assist engineers in pinpointing the areas that require optimization.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析工具附带详细的报告，这些报告在用户界面中以可视化形式呈现，以帮助工程师定位需要优化的区域。
- en: However, running an application with the profiler significantly slows down performance
    due to invasive instrumentation and measurement. The metric data that’s captured
    should be treated as a magnification of the actual runtime and be used to find
    areas that are slow, inefficient, or resource-consuming.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于侵入性的仪器化和测量，使用性能分析器运行应用程序会显著降低性能。捕获的度量数据应被视为实际运行时间的放大，并用于查找运行缓慢、效率低下或资源消耗大的区域。
- en: 'There are several popular profiler tools available for Kotlin engineers:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Kotlin工程师，有几种流行的性能分析工具可供选择：
- en: '**YourKit Java** **Profiler** ([https://www.yourkit.com/java/profiler/](https://www.yourkit.com/java/profiler/))'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**YourKit Java 性能分析器** ([https://www.yourkit.com/java/profiler/](https://www.yourkit.com/java/profiler/))'
- en: '**VisualVM** ([https://visualvm.github.io/startupprofiler.html](https://visualvm.github.io/startupprofiler.html))'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VisualVM** ([https://visualvm.github.io/startupprofiler.html](https://visualvm.github.io/startupprofiler.html))'
- en: '**IntelliJ IDEA** **Profiler** ([https://www.jetbrains.com/pages/intellij-idea-profiler/](https://www.jetbrains.com/pages/intellij-idea-profiler/))'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IntelliJ IDEA 性能分析器** ([https://www.jetbrains.com/pages/intellij-idea-profiler/](https://www.jetbrains.com/pages/intellij-idea-profiler/))'
- en: '**JProfiler** ([https://www.ej-technologies.com/jprofiler](https://www.ej-technologies.com/jprofiler))'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JProfiler** ([https://www.ej-technologies.com/jprofiler](https://www.ej-technologies.com/jprofiler))'
- en: '**Async** **Profiler** ([https://github.com/async-profiler/async-profiler](https://github.com/async-profiler/async-profiler))'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Async Profiler** ([https://github.com/async-profiler/async-profiler](https://github.com/async-profiler/async-profiler))'
- en: '**Java Mission** **Control** ([https://www.oracle.com/java/technologies/jdk-mission-control.html](https://www.oracle.com/java/technologies/jdk-mission-control.html))'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java Mission Control** ([https://www.oracle.com/java/technologies/jdk-mission-control.html](https://www.oracle.com/java/technologies/jdk-mission-control.html))'
- en: Application profilers should be used to analyze performance-critical operations.
    They don’t usually run in production environments due to instrumentation being
    slowed down significantly. It’s common to run profilers in a lower environment
    with inputs simulating the production environment.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序剖析器应用于分析性能关键操作。由于仪器显著减慢，它们通常不会在生产环境中运行。在较低的环境中运行剖析器，输入模拟生产环境是很常见的。
- en: Next, we’re going to cover a few performance improvement strategies.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍一些性能提升策略。
- en: Strategies for performance improvement
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能提升策略
- en: Improving the performance of a system often requires a diverse approach that
    addresses various aspects. No silver bullet magically boosts performance. However,
    some common strategies help engineers navigate the problem to meet the non-functional
    requirements.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 提升系统的性能通常需要一种多样化的方法，以解决各个方面的问题。没有银弹可以神奇地提升性能。然而，一些常见的策略有助于工程师解决问题，以满足非功能性需求。
- en: Testing, testing, testing
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试，测试，测试
- en: Performance tests should be conducted continuously and repetitively. When there’s
    a perceived performance issue, it’s unlikely to know the root cause without running
    performance tests. Instead of blindly applying “performance fixes,” engineers
    should execute performance tests to understand the problem first.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试应持续和重复进行。当出现感知的性能问题时，如果不运行性能测试，很难知道根本原因。工程师不应盲目应用“性能修复”，而应首先执行性能测试以了解问题。
- en: Performance tests should be treated as both troubleshooting and discovery tools.
    There are always bottlenecks in the system that surprise engineers.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试应被视为故障排除和发现工具。系统中总是存在让工程师感到意外的瓶颈。
- en: Avoiding expensive operations
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免昂贵的操作
- en: More often than not, performance issues are caused by a mismatch between the
    nature of the operations and the actual implementation. In other words, resources
    are used in unnecessary areas that would use excessive resources and computation
    power. If excessive resources are spent on expensive operations, then there will
    be performance issues.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 更多的时候，性能问题是由操作的性质与实际实现之间的不匹配引起的。换句话说，资源被用于不必要的区域，这会导致过度使用资源和计算能力。如果过度消耗资源在昂贵的操作上，那么就会出现性能问题。
- en: Let’s consider an example scenario that demonstrates performance optimization
    by avoiding expensive operations.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个示例场景，该场景通过避免昂贵的操作来展示性能优化。
- en: Scenario – iteration on expensive operations
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 场景 – 对昂贵操作的迭代
- en: 'Imagine that there’s a function that’s expensive to execute. This expense is
    high for several reasons:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下有一个执行成本很高的函数。这种成本高的原因有几个：
- en: It’s a remote synchronous call to another application
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个远程同步调用到另一个应用程序
- en: It’s computationally expensive and/or resource-hungry
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它计算成本高且/或资源密集
- en: It involves files, databases, messaging, networks, or other resources
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它涉及文件、数据库、消息传递、网络或其他资源
- en: It may be blocked until a result comes back
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能被阻塞，直到结果返回
- en: 'We know the following function isn’t expensive, but let’s pretend it is for
    the sake of discussion:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道以下函数并不昂贵，但为了讨论的目的，让我们假装它是昂贵的：
- en: '[PRE12]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'On top of this function, we’d like to run some filtering, mapping, and selection:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数之上，我们希望运行一些过滤、映射和选择：
- en: '[PRE13]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: First, this piece of code filters to take only numbers greater than 3\. Then,
    it invokes the `expensive` function and gets a new number. At the end, only the
    first two numbers are selected. The `println` function is called to show which
    value is evaluated in the `filter`, `map`, or `take` function.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这段代码通过只过滤出大于3的数字来筛选。然后，它调用`expensive`函数并得到一个新的数字。最后，只选择昂贵的操作中的前两个数字。调用`println`函数以显示在`filter`、`map`或`take`函数中评估的值。
- en: 'Executing this piece of code produces the following console output:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此段代码会产生以下控制台输出：
- en: '[PRE14]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: All five numbers are evaluated if they’re greater than 3\. The numbers `7`,
    `23`, and `63` are greater than 3, so they’re passed to the `expensive` operation.
    Finally, only the first two numbers from the expensive operation are returned.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些数字大于3，则评估所有五个数字。数字`7`、`23`和`63`大于3，因此它们被传递给`expensive`操作。最后，只返回昂贵的操作中的前两个数字。
- en: The expensive operation for the third number isn’t necessary because only the
    first two numbers are selected at the end. In addition, it could have found the
    first two numbers during filtering and stopped checking the rest of the values.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第三个数字的昂贵操作是不必要的，因为最终只选择了前两个数字。此外，它可以在过滤过程中找到前两个数字并停止检查其他值。
- en: 'Optimized with the `asSequence` function from Kotlin Standard Library, the
    code looks as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Kotlin标准库中的`asSequence`函数优化后，代码如下所示：
- en: '[PRE15]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'However, executing the preceding code prints the following to the console:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，执行前面的代码会在控制台打印以下内容：
- en: '[PRE16]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'No filtering, no expensive operation, or selection was run. This is because
    the `asSequence` function doesn’t build the list until there’s a terminal function.
    Let’s update the code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 没有过滤，没有昂贵的操作或选择被运行。这是因为`asSequence`函数直到有终端函数才会构建列表。让我们更新代码：
- en: '[PRE17]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, the execution prints the following to the console:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行会在控制台打印以下内容：
- en: '[PRE18]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The sequence operation understands it only takes the first two numbers, so it
    looks for the first two numbers greater than 3 and stops there. The number `63`
    wasn’t even processed. The first number greater than 3 was `7`, so `7` was passed
    to the `expensive` operation. The second number greater than 3 was `23`, so `23`
    was also passed to the `expensive` operation. This implementation has saved one
    `expensive` operation compared to the previous one.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 序列操作只理解只取前两个数字，因此它寻找大于3的第一个两个数字并停止。数字`63`甚至没有被处理。第一个大于3的数字是`7`，所以`7`被传递到`昂贵的`操作。第二个大于3的数字是`23`，所以`23`也被传递到`昂贵的`操作。与之前的实现相比，这种实现节省了一个`昂贵的`操作。
- en: An example of a performance improvement journey
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能改进之旅的例子
- en: 'The households in the village have decided to run a survey to rate each household’s
    services. A vote consists of a rating from 1 to 3:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 村庄中的住户已经决定运行一项调查来评估每个住户的服务。投票包括从1到3的评分：
- en: '**1**: Good'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1**: 好'
- en: '**2**: Average'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2**: 一般'
- en: '**3**: Poor'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3**: 差'
- en: A household can vote for all other households, but only one vote can be made
    per household. Households are given 1 day to submit all the votes. Let’s also
    assume one household provides only one service.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一个住户可以为所有其他住户投票，但每个住户只能投一票。住户有1天时间提交所有投票。让我们也假设一个住户只提供一项服务。
- en: Each household has a “score,” which is the sum of the rank numbers of all votes
    to that household. The household that has the highest score becomes the household
    that provides the best service in the village.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 每个住户都有一个“得分”，这是所有投票的排名数字之和。得分最高的住户成为村庄中提供最佳服务的住户。
- en: So, if there are *n* households in the village, the maximum number of votes
    will be `n x (n- 1`). We need a system that calculates the score of all households
    being voted for, and that records all votes as audit records. The system also
    needs to display non-final scores for each household when voting is in progress.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果村庄中有*n*个住户，最大投票数将是`n x (n- 1)`。我们需要一个系统来计算所有被投票住户的得分，并记录所有投票作为审计记录。系统还需要在投票进行时显示每个住户的非最终得分。
- en: 'A simplistic architecture of this voting system may look as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个投票系统的简单架构可能如下所示：
- en: '![Figure 12.2 – Simulated survey architecture v0.1](img/B21737_12_2.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – 模拟调查架构 v0.1](img/B21737_12_2.jpg)'
- en: Figure 12.2 – Simulated survey architecture v0.1
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 模拟调查架构 v0.1
- en: 'All households submit their votes to be validated by **Voting Service**. The
    service validates the following aspects:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 所有住户将他们的投票提交给**投票服务**进行验证。服务验证以下方面：
- en: All households involved are valid
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有参与的住户都是有效的
- en: A household can’t vote for itself
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个住户不能为自己投票
- en: A household can only vote for another household once
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个住户只能对另一个住户投一次票
- en: The vote has a valid rank
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投票具有有效排名
- en: Since the voting happens in one day for the village, there’s a need for the
    system to respond quickly (**latency**) so that it can process many votes within
    a certain period (**throughput**) and support a vast number of households (**scalability**).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 由于投票在村庄的一天内进行，系统需要快速响应（**延迟**），以便在特定时间段内处理大量投票并支持大量住户（**可扩展性**）。
- en: The system expects many concurrent requests to **Voting Service** at a time,
    and that could cause a spike.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 系统预期在某一时刻会有许多并发请求到**投票服务**，这可能会导致峰值。
- en: It’s possible to scale up the service vertically by adding more resources (CPU,
    memory, and so on). However, there are physical limitations regarding the number
    of CPU sockets or the maximum RAM it can support. Adding more resources also leads
    to diminishing returns, in which performance doesn’t improve proportionally due
    to other bottlenecks. The only running instance is also the single point of failure
    that if this instance fails, the entire system becomes unavailable.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过添加更多资源（CPU、内存等）来垂直扩展服务。然而，在CPU插座数量或最大支持的RAM方面存在物理限制。添加更多资源也会导致收益递减，即由于其他瓶颈，性能不会成比例提高。唯一的运行实例也是单点故障，如果这个实例失败，整个系统将不可用。
- en: Alternatively, the system can scale out horizontally if we add more instances
    of the service. A **load balancer** can be deployed to distribute load across
    multiple instances of the service, preventing any single instance from becoming
    a bottleneck. This significantly increases throughput by enabling parallel processing.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们添加更多服务实例，系统可以水平扩展。可以部署一个**负载均衡器**来在服务的多个实例之间分配负载，防止任何单个实例成为瓶颈。这通过启用并行处理显著提高了吞吐量。
- en: 'The load balancer has some knowledge of the load of each instance, so it can
    route the next request to the instance with the least load. This allows us to
    add more instances to handle increased loads. With that, the architecture has
    changed, as shown in *Figure 12**.3*:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡器对每个实例的负载有一些了解，因此它可以路由下一个请求到负载最少的实例。这使我们能够添加更多实例来处理增加的负载。因此，架构已经改变，如*图12.3*所示：
- en: '![Figure 12.3 – Simulated survey architecture v0.2](img/B21737_12_3.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3 – 模拟调查架构 v0.2](img/B21737_12_3.jpg)'
- en: Figure 12.3 – Simulated survey architecture v0.2
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – 模拟调查架构 v0.2
- en: Now, **Voting Service** has two stateful validation rules. The first is that
    the households involved must be valid. The second is that each household can only
    vote for other households once.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，**投票服务**有两个状态验证规则。第一个是参与的家庭必须是有效的。第二个是每个家庭只能对其他家庭投票一次。
- en: The household records are frequently accessed, and they can be queried in the
    database remotely. **Caching** all household records in each service instance
    is a sensible strategy to speed up validation.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 家庭记录经常被访问，并且可以在数据库中远程查询。在每个服务实例中**缓存**所有家庭记录是一种合理的策略，可以加快验证速度。
- en: Enforcing the rule that one household can only vote for another household would
    benefit from caching. If we cache a list of households that a given household
    has voted for (the *x-voted-by-y-list*), then we can enforce this business rule.
    However, there’s a complication if any instance can handle any household because
    it implies sharing the list.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 执行一条规则，即一个家庭只能为另一个家庭投票，将受益于缓存。如果我们缓存一个给定家庭已投票的家庭列表（即*x-voted-by-y列表*），那么我们可以执行这项业务规则。然而，如果任何实例可以处理任何家庭，那么它意味着共享这个列表，这会带来复杂性。
- en: There are two options we can consider. The first option is that we can use a
    distributed in-memory database such as Redis so the *x-voted-by-y-lists* can be
    shared, at the cost of having a distributed in-memory database and potential resource
    contention.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以考虑两种选择。第一种选择是我们可以使用如Redis这样的分布式内存数据库，这样*x-voted-by-y列表*就可以共享，但代价是拥有一个分布式内存数据库和潜在的资源竞争。
- en: The second option is to configure the load balancer so that it supports sticky
    routing. Requests from one household always go to the one responsible instance.
    Each instance knows its assignment and can locally cache the *x-voted-by-y-lists*
    from the database during startup. The local cache is also updated as it processes
    incoming requests.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是配置负载均衡器，使其支持粘性路由。来自一个家庭的请求总是路由到负责的实例。每个实例都知道自己的分配，并在启动时可以本地缓存数据库中的*x-voted-by-y列表*。本地缓存也会在处理传入请求时更新。
- en: At this point, the bottleneck has shifted to the database since all the traffic
    is eventually funneled into it and each request can only be responded to after
    database operations have finished. This impacts the latency of the response to
    each voting request.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，瓶颈已经转移到数据库，因为所有流量最终都会流入其中，每个请求只有在数据库操作完成后才能得到响应。这影响了每个投票请求的响应延迟。
- en: The score needs to be calculated for each household being voted in. This is
    an accumulated number that leaves little room for parallel processing. Each validated
    vote also needs to be kept as an audit record in the database.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 需要为每个被投票的家庭计算分数。这是一个累积数，几乎没有并行处理的空间。每个经过验证的投票也需要作为审计记录保留在数据库中。
- en: However, votes validated by **Voting Service** can be further processed asynchronously.
    Each vote can be partitioned by the household being voted for, so if **Household
    1** votes for **Household 2**, the vote goes to the “bucket” for **Household 2**.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由**投票服务**验证的投票可以进一步异步处理。每个投票可以根据被投票的家庭进行分区，因此如果**家庭1**为**家庭2**投票，则该投票将进入**家庭2**的“桶”。
- en: 'Resolve a household to a bucket can be as simple as a modulo function, that
    is, the remainder of a hash number divided by the number of buckets:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个家庭解析到桶中可以像模函数一样简单，即一个哈希数除以桶数的余数：
- en: '[PRE19]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Each bucket is an event stream. **Voting Service** can respond to the voting
    request after an event is published to the corresponding event topic representing
    the bucket. The vote counting, score calculation, and vote persistence metrics
    will be processed when downstream components consume the event. This change will
    significantly reduce the latency of each voting request.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 每个桶都是一个事件流。**投票服务**可以在将事件发布到代表该桶的事件主题后响应投票请求。投票计数、评分计算和投票持久化指标将在下游组件消费事件时进行处理。这种变化将显著降低每个投票请求的延迟。
- en: 'The updated architecture looks like this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的架构看起来像这样：
- en: '![Figure 12.4 – Simulated survey architecture v0.3](img/B21737_12_4.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4 – 模拟调查架构 v0.3](img/B21737_12_4.jpg)'
- en: Figure 12.4 – Simulated survey architecture v0.3
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – 模拟调查架构 v0.3
- en: 'This approach has a limitation: the number of buckets that are fixed at runtime.
    Events are already routed to the bucket, and we need to maintain the bucket assignment
    to calculate the score correctly.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有一个限制：运行时固定的桶的数量。事件已经路由到桶中，我们需要维护桶分配以正确计算分数。
- en: 'The downstream operations require persisting the result in the database eventually,
    and we want to avoid overloading the database. Let’s examine the data to be persisted:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 下游操作最终需要在数据库中持久化结果，而我们希望避免数据库过载。让我们检查需要持久化的数据：
- en: '**Score for each household**: One accumulative number per household; historical
    numbers don’t matter'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每个家庭的分数**：每个家庭一个累积数；历史数字无关紧要'
- en: '**Vote audit record**: Each record needs to be kept, and each record is independent
    of each other'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**投票审计记录**：每条记录都需要保留，并且每条记录之间相互独立'
- en: The score numbers and vote audit records are different in their natures, so
    it makes sense for them to be processed differently. It’s better to keep this
    temporary data in a transient local cache to reduce database load but persist
    the values periodically.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 分数数字和投票审计记录在性质上不同，因此它们以不同的方式处理是有意义的。最好将这种临时数据保存在瞬态本地缓存中，以减少数据库负载，但定期持久化这些值。
- en: 'Here, we can introduce two components:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以介绍两个组件：
- en: The first one, **Vote Counter**, consumes the event stream for its one assigned
    bucket and calculates scores for its responsible households. It doesn’t update
    the score records in the database immediately. Instead, it flushes the latest
    scores to the database with a fixed schedule – for example, every 10 minutes.
    This mechanism “soaks” the spike of votes and turns it into regular updates.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个组件，**投票计数器**，消费其分配的桶的事件流，并为它负责的家庭计算分数。它不会立即更新数据库中的分数记录。相反，它会按照固定的时间表刷新最新的分数到数据库中——例如，每10分钟一次。这种机制“吸收”了投票的峰值，并将其转化为常规更新。
- en: There are multiple instances of **Vote Counter**, and there should be at least
    two instances consuming one bucket to provide availability. Each score record
    should consist of a household name, the number of votes, the score, and a timestamp.
    There should be de-duplication rules that only persist newer records and skip
    the old ones.
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有多个**投票计数器**实例，并且至少应该有两个实例消费一个桶以提供可用性。每个分数记录应包括家庭名称、投票数、分数和时间戳。应该有去重规则，只持久化较新的记录并跳过旧的记录。
- en: The second component, **Vote Journalist**, consumes a batch of events at a time
    and flushes the update into the database in one transaction. If the transaction
    fails, the events in the batch aren’t acknowledged and will be processed again
    later. **Vote Journalist** instances of the same bucket should be configured so
    that only one instance receives the batch of events. The batching processing significantly
    increases the throughput of vote audit record persistence. However, it would require
    performance testing to discover the optimal batch size that can scale with the
    number of votes and still be processed within the memory limits of the process.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个组件，**投票记者**，一次消费一批事件，并将更新在一个事务中刷新到数据库。如果事务失败，批次中的事件不会被确认，并将稍后再次处理。**投票记者**实例应配置为只有一个实例接收事件批次。批量处理显著增加了投票审计记录持久化的吞吐量。然而，它需要性能测试来发现可以随着投票数量扩展且仍在进程内存限制内处理的最佳批次大小。
- en: 'With all these performance concerns considered, we have the final 1.0 architecture,
    as shown in *Figure 12**.5*:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些性能问题，我们得到了最终的1.0架构，如图*图12.5*所示：
- en: '![Figure 12.5 – Simulated survey architecture v1.0](img/B21737_12_5.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图12.5 – 模拟调查架构v1.0](img/B21737_12_5.jpg)'
- en: Figure 12.5 – Simulated survey architecture v1.0
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – 模拟调查架构v1.0
- en: In this architecture, we’ve optimized the process of load balancing the incoming
    requests to multiple instances of **Voting Service** for validation. This increases
    the throughput and scalability. Then, we introduced local caching of households
    and the *x-voted-by-y-lists* in each service instance to speed up the validation
    process. It also supports horizontal scaling by adding more instances.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个架构中，我们优化了将传入请求负载均衡到多个**投票服务**实例以进行验证的过程。这增加了吞吐量和可伸缩性。然后，我们在每个服务实例中引入了住户和*x-voted-by-y-lists*的本地缓存，以加快验证过程。它还通过添加更多实例支持水平扩展。
- en: 'After, we created a few buckets of event streams for each one responsible for
    several households exclusively. After **Voting Service** validates a request to
    be valid, it responds to the original request and publishes an event stream to
    the corresponding bucket. This reduces the latency for the response to the voting
    request:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为每个只负责几个住户的事件流创建了一些桶。在**投票服务**验证请求有效后，它响应原始请求并向相应的桶发布事件流。这减少了投票请求响应的延迟：
- en: '**Vote Counter** is introduced to calculate the scores of households that have
    been assigned to the given bucket. It sends the latest scores to the database
    periodically and soaks up the spike.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**投票计数器**被引入以计算分配给给定桶的住户的分数。它定期将最新分数发送到数据库，并吸收峰值。'
- en: '**Vote Journalist** is introduced to receive a batch of events at a time and
    to persist them to the database in one transaction. Batch processing increases
    the throughput of vote audit record persistence.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**投票记者**被引入以一次接收一批事件，并将它们在一个事务中持久化到数据库。批量处理增加了投票审计记录持久化的吞吐量。'
- en: In this example, we learned how to optimize the throughput, latency, and scalability
    of a system. Performance improvements are highly situational. We simply shouldn’t
    copy a pattern to another system and believe it will perform. Performance needs
    to be measured and tested. A change is only considered a performance improvement
    when the metrics prove it. However, some known best practices of performance can
    be improved, something we’ll cover in the next section.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们学习了如何优化系统的吞吐量、延迟和可伸缩性。性能改进是非常情境化的。我们绝对不应该将一个模式复制到另一个系统中并相信它将表现良好。性能需要被衡量和测试。只有当指标证明时，一个变化才被认为是性能改进。然而，一些已知的性能最佳实践可以改进，我们将在下一节中介绍。
- en: Best practices of performance in Kotlin
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kotlin的性能最佳实践
- en: Kotlin has a few features that aim to reduce overhead and therefore improve
    performance. However, these features come with justifications so that engineers
    can make a conscious decision when to use them. They aren’t expected to be used
    everywhere without reasoning.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin有一些旨在减少开销并因此提高性能的功能。然而，这些功能都有合理的依据，以便工程师可以在使用它们时做出有意识的决策。它们并不期望在没有理由的情况下被到处使用。
- en: In-line functions
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内联函数
- en: In-line Kotlin functions are simply copied to the caller to reduce the need
    to invoke the function itself. This is particularly useful if there’s a deep stack
    of functions or if there’s a higher-order function.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 内联Kotlin函数简单地复制到调用者以减少调用函数本身的必要性。这在存在函数调用栈较深或存在高阶函数的情况下特别有用。
- en: 'In-line functions can be declared by adding a modifier at the function level,
    like so:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 内联函数可以通过在函数级别添加修饰符来声明，如下所示：
- en: '[PRE20]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The use of immutable and mutable data structures
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用不可变和可变数据结构
- en: Immutable data eliminates the need for locking in multi-thread environments.
    In Kotlin, `List`, `Set`, and `Map` collections work with immutable data.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变数据消除了多线程环境中的锁定需求。在Kotlin中，`List`、`Set`和`Map`集合使用不可变数据。
- en: However, if we’re building a bigger object, such as a string, it’s advisable
    to use mutable collections or the `StringBuilder` class to avoid unnecessary object
    creation that could trigger garbage collection in Kotlin/JVM.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们正在构建一个更大的对象，例如字符串，建议使用可变集合或`StringBuilder`类来避免不必要的对象创建，这可能会在Kotlin/JVM中触发垃圾回收。
- en: The use of coroutines for asynchronous operations
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用协程进行异步操作
- en: Kotlin’s coroutine library enables the program to invoke asynchronous operations
    so that the thread isn’t blocked and can perform other operations while waiting
    for the asynchronous result to come back. It enables better resource management
    and quicker response in applications.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin的协程库使程序能够调用异步操作，这样线程就不会被阻塞，可以在等待异步结果返回的同时执行其他操作。它使应用程序的资源管理更好，响应更快。
- en: 'For example, imagine that there are two time-consuming functions:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象有两个耗时的函数：
- en: '[PRE21]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'These two functions have the `suspend` modifier to indicate they can be paused
    and resumed without blocking the thread. The `main` function that uses these two
    suspend functions is shown here:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数具有`suspend`修饰符，表示它们可以在不阻塞线程的情况下暂停和恢复。使用这两个挂起函数的`main`函数如下所示：
- en: '[PRE22]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `runBlocking` function starts a coroutine that blocks the current thread
    until its execution is complete. Within this block, there are two `async` functions
    to invoke the two time-consuming `suspend` functions. The `async` function returns
    a `Deferred` object on which we invoke the `await` function to block until the
    result returns. The two numbers that are returned by the respective time-consuming
    functions are added and the sum is printed to the console.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`runBlocking`函数启动一个协程，直到其执行完成才释放当前线程。在这个块中，有两个`async`函数来调用两个耗时的`suspend`函数。`async`函数返回一个`Deferred`对象，我们在这个对象上调用`await`函数以阻塞，直到结果返回。两个耗时函数返回的数字相加，并将总和打印到控制台。'
- en: Note that Kotlin code written with the best practices of performance in mind
    would still need to be measured. Empirical results are the only proof.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使考虑到性能的最佳实践，用Kotlin编写的代码仍需进行测量。经验结果才是唯一的证明。
- en: Next, we’re going to briefly mention ultra-low latency systems and how they
    push performance and scalability to the extreme.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将简要介绍超低延迟系统以及它们如何将性能和可扩展性推向极致。
- en: Ultra-low latency systems
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超低延迟系统
- en: Ultra-low latency systems operate in the microsecond or nanosecond magnitude.
    They run in an environment where low response time is critical and even essential.
    They can be seen in financial trading, telecommunications, gaming, and industrial
    automation.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 超低延迟系统在微秒或纳秒量级运行。它们在一个低响应时间至关重要的环境中运行，甚至可以说是必不可少的。这些系统可以在金融交易、电信、游戏和工业自动化中看到。
- en: These systems aim to achieve the lowest possible latency, highest efficiency,
    high predictability, and high concurrency regarding processing. They involve all
    aspects of a system to reduce response time, such as network optimization, hardware
    acceleration, load balancing, and efficient algorithms.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这些系统旨在实现尽可能低的延迟、最高的效率、高可预测性和高并发性，以处理。它们涉及系统的各个方面以减少响应时间，例如网络优化、硬件加速、负载均衡和高效算法。
- en: These systems are usually written in system-level programming languages such
    as C++ and Rust. However, there are a few ultra-low latency systems written in
    Kotlin or Java that operate in the microsecond magnitude.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这些系统通常用系统级编程语言如C++和Rust编写。然而，也有一些超低延迟系统是用Kotlin或Java编写的，它们在微秒量级运行。
- en: 'The low latency systems in Kotlin or Java employ several technical designs
    that aren’t as common:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin或Java中的低延迟系统采用了一些不太常见的技术设计：
- en: Reuse objects, avoid object creation, and avoid garbage collection.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复使用对象，避免创建对象，并避免垃圾回收。
- en: Use specific JVM vendors for better performance.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特定的 JVM 供应商以获得更好的性能。
- en: Avoid the use of third-party libraries to reduce overhead and ensure you have
    full control over performance.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用第三方库以减少开销并确保您对性能有完全的控制。
- en: Use the **Disruptor pattern** as it provides a large ring buffer for inter-thread
    lock-free communication and memory barriers for data visibility in a thread.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **Disruptor 模式**，因为它提供了一个大环形缓冲区，用于线程间的无锁通信，并在线程中提供内存屏障以实现数据可见性。
- en: Use a single-thread model for each JVM process to reduce context switching,
    lock contention, and the need for synchronous and concurrency processing.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个 JVM 进程使用单线程模型以减少上下文切换、锁竞争以及同步和并发处理的需求。
- en: Write code or design systems that are aware of and optimized for the underlying
    hardware and network infrastructure they run on. This is also called **mechanical
    sympathy**.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写或设计对底层硬件和网络基础设施有意识且针对其优化的代码或系统。这也被称为 **机械同理心**。
- en: Ultra-low latency systems have the justification that they can break a few design
    principles (for example, immutable objects) in exchange for higher performance.
    They are exceptional cases due to the demanding need for low latency, high throughput,
    and quick response time. When developing these systems, performance tests are
    critical and should be part of the normal development activities.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 超低延迟系统有理由打破一些设计原则（例如，不可变对象），以换取更高的性能。由于对低延迟、高吞吐量和快速响应时间的严格要求，它们是特殊情况。在开发这些系统时，性能测试至关重要，应成为常规开发活动的一部分。
- en: 'Developing ultra-low latency systems is a specialized topic whose content is
    beyond the scope of this chapter. However, there are a few pieces of reading material
    that you may find useful:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 开发超低延迟系统是一个专业话题，其内容超出了本章的范围。然而，有一些阅读材料可能对您有所帮助：
- en: '*Mechanical empathy*, by Martin Thompson ([https://mechanical-sympathy.blogspot.com/](https://mechanical-sympathy.blogspot.com/))'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*机械同理心*，由马丁·汤普森撰写 ([https://mechanical-sympathy.blogspot.com/](https://mechanical-sympathy.blogspot.com/))'
- en: '*LMAX* *Disruptor* ([https://lmax-exchange.github.io/disruptor/](https://lmax-exchange.github.io/disruptor/))'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*LMAX Disruptor* ([https://lmax-exchange.github.io/disruptor/](https://lmax-exchange.github.io/disruptor/))'
- en: '*Simple Binary* *Encoding* ([https://github.com/real-logic/simple-binary-encoding](https://github.com/real-logic/simple-binary-encoding))'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*简单二进制编码* ([https://github.com/real-logic/simple-binary-encoding](https://github.com/real-logic/simple-binary-encoding))'
- en: '*Aeron* *messaging* ([https://github.com/real-logic/aeron](https://github.com/real-logic/aeron))'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Aeron 消息传递* ([https://github.com/real-logic/aeron](https://github.com/real-logic/aeron))'
- en: Summary
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered different dimensions of performance and scalability
    and mentioned a few essential metrics that measure how well a system performs
    and scales. We emphasized the importance of performance tests, several types of
    performance tests, and how to plan one. We also provided an example of micro-benchmarking
    in Kotlin before discussing the use of a profiler to achieve better performance.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了性能和可扩展性的不同维度，并提到了一些衡量系统性能和可扩展性的基本指标。我们强调了性能测试的重要性，几种类型的性能测试以及如何规划它们。我们还提供了一个
    Kotlin 中的微基准测试示例，然后讨论了使用分析器以实现更好性能的方法。
- en: Then, we delved into some strategies for performance improvement. We considered
    a scenario where only necessary expensive operations were executed. We also looked
    at an example of a journey of performance improvement for a system in a real-life
    situation. This allowed us to consider a few best practices regarding performance
    in Kotlin through code examples.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们深入探讨了性能提升的一些策略。我们考虑了一个只执行必要昂贵操作的场景。我们还观察了一个在现实情况下系统性能提升的例子。这使我们能够通过代码示例考虑一些关于
    Kotlin 性能的最佳实践。
- en: Finally, we briefly introduced ultra-low latency systems and where they can
    be used.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们简要介绍了超低延迟系统及其应用领域。
- en: In the next chapter, we’re going to discuss the topic of software testing.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论软件测试这一主题。
