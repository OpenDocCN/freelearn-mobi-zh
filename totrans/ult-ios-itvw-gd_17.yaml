- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Acing the Coding Assessment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed architecture in depth. Architecture discussions
    tend to be very theoretical and methodological; the same can be said for design
    pattern discussions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will get to the meat – to the code, working with Xcode,
    and playing with algorithms. We will cover everything related to coding interview
    tasks, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to succeed in a live coding interview, the different tests, and how to code
    like a pro
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to excel in home assessments by discussing different skills to use and reviewing
    home assessment examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to avoid mistakes that may raise red flags in our interviews
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the final chapter! You will be fully prepared for your first interview
    by the end of it. Now, let’s dive straight into tips for the live coding interview.
  prefs: []
  type: TYPE_NORMAL
- en: Succeeding in live coding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The live coding interview is probably the most intimidating in the process.
  prefs: []
  type: TYPE_NORMAL
- en: It’s easy to understand why – for most developers, it’s a stage that is an uncomfortable
    situation in any case.
  prefs: []
  type: TYPE_NORMAL
- en: For a start, in most cases, we aren’t working in our beloved (to some of us)
    Xcode. We are required to handle tasks that we usually don’t face in our day-to-day
    work, and we’re doing that under pressure while someone is watching us at every
    step.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why I said “probably” and “most developers” at the start of this
    section is that it doesn’t have to be intimidating. Sure, live coding is a stressful
    interview, but we can make it exciting and much more joyful with the right approach.
  prefs: []
  type: TYPE_NORMAL
- en: Skeptical? Don’t be! Throughout the preceding 12 chapters, we have observed
    that proper preparation can make anything achievable.
  prefs: []
  type: TYPE_NORMAL
- en: Before we rush into the interview itself, let’s learn about the different environments
    we will work in and the different types of tests.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the different live coding tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike the other interview stages, the live coding interview usually has different
    shapes and forms that dramatically affect how the whole interview feels and looks.
  prefs: []
  type: TYPE_NORMAL
- en: There are three types of live coding interviews – whiteboard, online, and in-person.
    We call them live coding here, but each provides different experiences and challenges.
    Let’s start with the whiteboard interview.
  prefs: []
  type: TYPE_NORMAL
- en: The whiteboard interview
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If I recall correctly, this is the third time we’re mentioning the importance
    of the whiteboard. The first time was in [*Chapter 2*](B18653_02.xhtml#_idTextAnchor041),
    when we discussed preparing for the interview process (in the *Getting ready for
    the screening interview* section). The second time was in [*Chapter 12*](B18653_12.xhtml#_idTextAnchor360)
    (in the *The architecture design interview* section) when we discussed the architecture
    interview, and now, we’re mentioning it in approaching the live coding stage.
  prefs: []
  type: TYPE_NORMAL
- en: Why is the whiteboard such an essential tool in interviews? What makes interviewers
    highly value the whiteboard, and how can we maximize it for our benefit?
  prefs: []
  type: TYPE_NORMAL
- en: Well, the whiteboard has one significant advantage – it promotes clarity and
    communication between people and allows us to visualize our thinking when explaining
    an idea. That’s the reason why most meeting rooms include a whiteboard.
  prefs: []
  type: TYPE_NORMAL
- en: Now, as candidates, it is sometimes difficult to use the whiteboard if we are
    not used to it. And the fact that we’re standing there struggling with a coding
    question doesn’t help that situation either.
  prefs: []
  type: TYPE_NORMAL
- en: But it can also be a good tool for communicating with our interviewer, as we
    did in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If you think that communication is not a big deal in interviews, let’s get into
    the online interview, and you’ll understand why it is critical.
  prefs: []
  type: TYPE_NORMAL
- en: The online interview
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The online interview is a session that takes place via a **video conference**
    using a platform such as Zoom, FaceTime, or Google Meet.
  prefs: []
  type: TYPE_NORMAL
- en: You might think the online interview’s significant advantage would be using
    an **integrated development environment** (**IDE**). But in most cases, the session
    happens on a dedicated website without indentation, code completion, or syntax
    highlighting.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, the online coding interview has another drawback that we didn’t
    have in the whiteboard interview: communication.'
  prefs: []
  type: TYPE_NORMAL
- en: I have observed, on multiple occasions, that interaction with the interviewer
    plays a vital role in the success of an interview. It is undeniable that communication
    is more challenging in online sessions compared to in-person meetings.
  prefs: []
  type: TYPE_NORMAL
- en: However, complaining is not the path to success.
  prefs: []
  type: TYPE_NORMAL
- en: We need to look for other advantages of an online coding session. For example,
    the fact that we are coding on a computer allows us to edit and push rows down
    if needed. Whiteboard editing is much more difficult and forces us to plan what
    we are going to write.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, scheduling and preparing for an online coding interview is comparatively
    more straightforward. Remote meetings and using computers are likely within our
    comfort zone, as the Covid-19 era has taught us how to navigate these aspects
    effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Combining both worlds – the in-person coding interview
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The “in-person” coding interview takes place on a laptop in front of our interviewer.
    This is a unique approach compared to the previous two methods (whiteboard and
    remote), and there’s an excellent reason for that. The in-person coding interview
    has an advantage in terms of personal interaction. Still, this advantage is often
    not strong enough when considering the logistical efforts that come with it.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the whiteboard coding interview is preferable when discussing in-person
    sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Having said that, the in-person coding interview usually happens in companies
    that wish to see us coding in a natural working environment. In some instances,
    the interviewer accompanies us while we code, while in other cases, we are given
    privacy to code in a room on our own, with the interviewer checking in periodically
    to assess our progress. Both cases can be stressful for developers, having to
    code while someone is watching them. But sometimes, that’s part of the test –
    to see how we perform complex tasks under slight pressure.
  prefs: []
  type: TYPE_NORMAL
- en: All three ways (whiteboard, in-person, and remote coding) are common, and all
    of them can be stressful experiences. The best way to decrease the pressure level
    is to practice and be prepared for this challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing ourselves for the coding interview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I know you might be thinking that the fact that we are veteran developers means
    that we are ready for a coding interview since coding is what we do almost every
    day. But you can’t be more wrong on that – the coding interview requires new skills
    and techniques to pass it successfully.
  prefs: []
  type: TYPE_NORMAL
- en: We have already reviewed the different coding test types – whiteboard, in-person,
    and remote. We will see that some skills need to be sharpened to pass these tests.
    We’ll start with the first and primary one – writing code in a plain text editor.
  prefs: []
  type: TYPE_NORMAL
- en: Working with a plain text editor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In most coding interviews, we will work with a **plain text editor**. A whiteboard,
    for that matter, is a plain text editor.
  prefs: []
  type: TYPE_NORMAL
- en: A plain text editor lacks syntax highlighting, indentation, and code completion,
    creating an unfamiliar environment for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'It might be easy to declare a function without any problems in a plain text
    editor, as you can see in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: But that’s the easy part! Let’s see what the challenges are and how we deal
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: Spotting syntax errors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Syntax highlighting helps us spot keywords and expressions, but it also helps
    us find syntax errors, such as missing parentheses, brackets, or semicolons. In
    a text editor, there’s a best practice of typing both open and closed brackets
    or parentheses and only then writing the expression inside.
  prefs: []
  type: TYPE_NORMAL
- en: However, on a whiteboard, we can’t use that technique. One option is to *highlight
    delimiters* ourselves and write them in a different color. Sure, doing that can
    slow us down, but it will make our code much clearer and more aesthetic. Another
    option is to *draw the delimiter bigger*, which is another way of highlighting.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding typos
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While syntax is just one aspect of an IDE, code completion is another crucial
    feature. We are used to writing extended descriptive functions and variable names,
    relying on the code editor to handle them through code completion. However, that’s
    not the case with a plain text editor. Without code completion, typos can break
    our code. Although typos can be more acceptable in whiteboard coding interviews
    than in in-person or remote interviews, they still look bad and unprofessional.
  prefs: []
  type: TYPE_NORMAL
- en: A way to help us avoid typos is to use clear and short names for functions and
    variables. That can speed up the coding and help us organize our writing on the
    whiteboard.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering complex Swift expressions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I mentioned earlier how simple it is to declare a function in Swift. But Swift
    is much more than functions and variables declarations. So, to master Swift, we
    need to have complete knowledge of more complex expressions and functions, such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Collections functions – **filter**, **map**, and **reduce**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced type system features – generics and protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuples and enums
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This list contains features prone to mistakes, and when I say mistakes, I don’t
    mean just cosmetic ones. The closure format, for example, has critical components
    that directly affect our code flow. The same goes for generics and protocols.
  prefs: []
  type: TYPE_NORMAL
- en: We should practice Swift’s complex expressions and ensure we master them.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining code organization
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Code organization is a critical topic because it’s a real challenge when working
    with a plain editor. As you know, a plain editor doesn’t have indentation, which
    usually helps us to create a readable and organized code. Remember closures and
    filtering? Trying to read these Swift features without indentation is complex,
    and code readability affects our chances of success.
  prefs: []
  type: TYPE_NORMAL
- en: Indentation becomes even more critical when coding on a whiteboard. On a laptop,
    at least, we can use tabs, something that doesn’t exist on whiteboards.
  prefs: []
  type: TYPE_NORMAL
- en: We understand now that many of the challenges we face in plain text editor coding
    become even more prominent on a whiteboard. Don’t worry! There’s still time to
    manage that.
  prefs: []
  type: TYPE_NORMAL
- en: Practicing on a whiteboard
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For most of us, coding on a whiteboard is not natural. Consider developers who
    have spent nearly 10,000 hours coding in front of a computer; the transition to
    coding on a whiteboard can be challenging.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to coding on a whiteboard as opposed to a laptop, there are several
    challenges that we should bear in mind. For example, whiteboards don’t have scroll
    capabilities, it is much more difficult to edit or insert new rows, there are
    no straight lines or font sizes, and our canvas is just one big white surface
    without a grid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having said that, some tips can help us improve our whiteboarding skills. Let’s
    go over them:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Visualize our code structure*: As I said, whiteboards don’t have any built-in
    scrolling mechanism, and their coding area is fixed. Therefore, before coding
    on a whiteboard, we should visualize our answer structure. Notice I wrote *answer*
    and not *code*. The reason for that is that our answer is much more than just
    the function we were supposed to implement – there are tests, diagrams, and perhaps
    even notes we need to consider. We should divide the whiteboard into zones and
    allocate space for each answer’s component. Of course, the same goes for the coding
    area itself – try to imagine how long your answer will be and choose your font
    size accordingly. Look at *Figure 13**.1*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 13.1 – Dividing the whiteboard into spaces](img/Figure_13.01_B18653.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – Dividing the whiteboard into spaces
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 13**.1* shows how we set a different space for each part of our answer.
    Organizing your whiteboard is the key to presenting a clear answer.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Use diagrams*: We talked about allocating a specific space for diagrams. However,
    diagrams are not a limitation of whiteboards at all – drawing diagrams is a significant
    advantage we don’t have on a laptop, especially when working remotely. Diagrams
    let us visualize our algorithms, ideas, and thoughts and communicate them to our
    interviewer much better. When practicing coding questions, we should try to illustrate
    our thinking and answers. The best way to learn how to do that is to watch videos
    on the internet that explain how to solve different algorithms and focus on the
    visual part. We should know how to describe flows, arrays, trees, and database
    schemes on a whiteboard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Practice out loud*: A common challenge many developers face is solving a coding
    question on a whiteboard while effectively explaining it. Why? Because most developers
    are not used to writing code down on a whiteboard and then explaining it at the
    same time. We shouldn’t just practice writing on a whiteboard – we should also
    practice presenting our solutions while thinking out loud, whether to ourselves
    or others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Few developers have good whiteboard drawing skills, but practicing is an effective
    way to improve dramatically. These small tips can raise the bar and provide us
    with more skills.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move on to the actual coding. How do we start?
  prefs: []
  type: TYPE_NORMAL
- en: Starting to code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we understand the different interview options, we can start with the
    real fun – coding. Can you guess what tip I have when facing a coding question
    unrelated to iOS, Swift, or coding in general?
  prefs: []
  type: TYPE_NORMAL
- en: Take your time
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We first need to relax, step back, and analyze our task. It is a common mistake
    to start coding immediately even if we (think that we) already know the answer.
  prefs: []
  type: TYPE_NORMAL
- en: First, sure, you might know the answer or at least know how to approach the
    question. But take one or two minutes to rethink what you will do. Maybe find
    a more effective way to solve the question or a more engaging way to present the
    answer. If you have the time, why not use it?
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, taking your time is not a bad sign for the interviewer. The opposite
    is the truth. The fact that you are not rushing to code is a sign that you are
    thinking before you act and want to focus on planning and researching. In the
    previous chapter, we said interviewers are searching for soft skills during the
    architecture interview. However, soft skills are tested everywhere, including
    in the coding interview. Planning and critical thinking, essential soft skills,
    are also evaluated during the interview process.
  prefs: []
  type: TYPE_NORMAL
- en: Start with testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Are we doing **test-driven development** (**TDD**)? Well, not exactly. One of
    the most noticeable differences between the coding and the architecture interview
    is that in the coding interview, we must understand all our constraints and guidelines
    from the beginning. We can’t discover them as the interview proceeds.
  prefs: []
  type: TYPE_NORMAL
- en: In coding interviews, the session begins when we ask our interviewer for all
    the necessary information to accomplish our task.
  prefs: []
  type: TYPE_NORMAL
- en: But how do we know what to ask?
  prefs: []
  type: TYPE_NORMAL
- en: The best way is to *write down the tests for the function* we will code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following coding question:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a function in Swift that takes an array of integers as input and returns
    the maximum difference between any two elements in the array. The maximum difference
    should be calculated by subtracting the smallest element from the largest element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s write down our test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These test cases are crucial for us to provide a good answer. First, they answer
    all our questions – what if we have negative numbers? What if the input has one
    element or no elements at all?
  prefs: []
  type: TYPE_NORMAL
- en: Not only can the test cases lead us to the algorithm we need to write, but they
    also behave as a checklist throughout the session. If we want to ensure we’ve
    finished our coding and covered all our cases, we can review the list and check
    our code.
  prefs: []
  type: TYPE_NORMAL
- en: Start strong – don’t be afraid of brute force
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One thing that rings in our heads during interviews is that we need to provide
    an optimized solution in terms of space and time complexity.
  prefs: []
  type: TYPE_NORMAL
- en: And this is true – providing an efficient solution is one of the things we are
    tested on. But, as a starting point, we need to focus on accomplishing the task
    and only then optimize it. In other words, we should start with **brute force**.
  prefs: []
  type: TYPE_NORMAL
- en: What is brute force?
  prefs: []
  type: TYPE_NORMAL
- en: The term *brute force* refers to a straightforward approach to solving a problem
    involving basic algorithms without thinking of optimizations and efficiency. Brute-force
    solutions are impractical in real-world scenarios due to their high space and
    time complexity.
  prefs: []
  type: TYPE_NORMAL
- en: If brute force is not practical in real-life scenarios, why have I suggested
    starting with it?
  prefs: []
  type: TYPE_NORMAL
- en: When we receive a task to do, we first want to provide a working solution. A
    working solution proves that we understand the problem and is a great starting
    point for optimization. We can start measuring the time and space complexity and
    perform incremental updates.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, brute force is an anchor for further changes we want to make,
    providing us the flexibility to revert and find an alternate path if something
    goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go over an example:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the maximum sum of a subarray within an array of integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The brute-force solution would be to iterate an array with two nested loops
    while maintaining a `maxSum` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the first loop, we iterate all the elements in the array, and for each iteration,
    we create another loop that starts from the current element until the end of the
    same array. In this approach, we cover all the different subarray combinations
    and try to find the maximum sum by using the `maxSum` array.
  prefs: []
  type: TYPE_NORMAL
- en: This solution works! But we understand that using nested arrays makes our algorithm
    inefficient with a time complexity of O(n^2).
  prefs: []
  type: TYPE_NORMAL
- en: So, how can we improve it?
  prefs: []
  type: TYPE_NORMAL
- en: We said a brute-force solution is a great starting point for optimization. Having
    two nested loops should raise a concern – we understand that our time complexity
    is too high. Usually, the trade-off for time is space. In this case, we can have
    one array iteration and preserve the current sum in a specific variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an optimized version of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding algorithm is called **Kadane’s algorithm**, and it is an efficient
    way to solve that problem. In Kadane’s algorithm, we calculate the maximum subarray
    that ends in a specific index using the previous index’s subarray calculation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Confused? Let’s test it on a random array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Kadane’s algorithm is a clever algorithm that provides an efficient and straightforward
    solution to a complex problem. You would not be expected to be able to use this
    algorithm if you haven’t come across it before. But the point here is that we
    have two versions for our answer, and unless the optimal solution pops into our
    mind, we should start with the brute-force method and then continue solving the
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: Coding like a pro
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, how do we code like a pro? We already know that our chances to succeed in
    the coding interview have much to do with how much we practice and solve algorithm
    problems at home. But practicing is only part of the solution. There are some
    key factors that we should follow during the session.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with two critical key factors – time and space complexities.
  prefs: []
  type: TYPE_NORMAL
- en: Use the terms “time complexity” and “space complexity”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve mentioned time and space complexities in this chapter several times for
    a good reason. We know that effective communication with the interviewer is essential,
    and it should be done with proper terms.
  prefs: []
  type: TYPE_NORMAL
- en: After we finish the brute-force solution (as soon as possible), we need to optimize
    it and use the correct terms. This is so important because time and space complexities
    are objective ways to evaluate our code’s efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: For example, saying something such as “*It’s not efficient to have a nested
    loop*” is not a professional way of describing an algorithm. The proper way would
    be, “*This algorithm has a time complexity of O(N^2), but I think we can improve
    it* *to O(N)*.”
  prefs: []
  type: TYPE_NORMAL
- en: So, what is time complexity? The following information box provides a definition.
  prefs: []
  type: TYPE_NORMAL
- en: What is time complexity?
  prefs: []
  type: TYPE_NORMAL
- en: Time complexity refers to the time an algorithm requires to run as the input
    size grows. We describe the input size as **N** and express the complexity with
    big-O notation.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several use cases for time complexity:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Constant time complexity, “O(1)”*: Accessing a specific index in an array
    or performing basic arithmetic operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Linear time complexity, “O(n)”*: Iterating an array or a linked list with
    the size of **n**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Quadratic time complexity, “O(n^2)”*: Using nested loops or bubble sort'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Logarithmic time complexity, “O(log n)”*: Binary search'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I don’t want to get into too many details about time and space complexity,
    but there are two things to keep in mind when discussing complexity in an interview:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Complexity calculation*: This is a topic we should address before starting
    the interview, and it’s broader than we think. First, we should count the different
    operations in our code and define each’s complexity. Then, we need to sum it up
    and, in the end, determine the complexity of different inputs – best, worst, and
    average cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Understand logarithmic time complexity*: Most of the use cases I mentioned
    earlier are straightforward, but O(log n) is the one that confuses many developers.
    This complexity describes an algorithm whose runtime grows nonlinearly (**logarithmically**)
    with the input size. The increase is slower than O(n) and O(n^2), making it more
    efficient.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s have a look at the following `findElement` function and try to calculate
    its time complexity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The algorithm is simple – we iterate in an array and check each element to see
    whether it’s equal to the target function parameter. If we find an element with
    the same value, we return `true`. Otherwise, we return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: To calculate the function time complexity, we need to list our operations and
    describe their complexity individually. We have a `for` loop with a time complexity
    of O(n) and an `if` statement with a time complexity of O(1).
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the overall time complexity of the function is O(n), and it is
    determined by the linear dominant operation.
  prefs: []
  type: TYPE_NORMAL
- en: And what about **space complexity**?
  prefs: []
  type: TYPE_NORMAL
- en: What is space complexity?
  prefs: []
  type: TYPE_NORMAL
- en: Space complexity refers to the memory or storage an algorithm requires to run
    as the input size grows. We describe the input size as **N** and express the complexity
    with big-O notation.
  prefs: []
  type: TYPE_NORMAL
- en: Space complexity is usually the trade-off of time complexity. When we optimize
    an algorithm, we need to consider the balance between the amount of memory it
    consumes and the time taken to execute the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'We measure space complexity in a similar way as we do for time complexity.
    For instance, let’s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `printNumbers()` function takes `n` as input and creates an array to store
    the numbers from 1 to `n`. The space complexity of this function is O(n) as the
    size of the numbers grows linearly with the input `n`.
  prefs: []
  type: TYPE_NORMAL
- en: The main goal of using time and space complexities is to not only communicate
    with the interviewer professionally, but also to be able to evaluate our solutions
    so we can provide an optimized answer.
  prefs: []
  type: TYPE_NORMAL
- en: Come with a set of tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Never enter a combat field without a weapon or ammo – the same goes for a coding
    interview and a suitable set of tools. Every interview question or challenge can
    be addressed if we come prepared with a list of techniques to help us.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can have a complex question about linked lists. To solve that
    question, we must master the basics of a linked list – how to traverse a list,
    remove/add an element, or convert a list into an array and vice versa. We should
    know how to do these things before we come to the interview.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the basic data structures well can help us focus on the real challenge,
    which is the algorithm itself. In the previous chapter, we discussed app architectures
    and said that design patterns are the building blocks of architecture. Here, we
    also have building blocks. We start with data structures, then go over the fundamental
    design patterns that manipulate these data structures, and then the algorithms
    that are based upon these patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Leave time for testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not testing is a common mistake many candidates make in coding interviews. When
    we discussed how to start the coding interview, we discussed testing as a key
    to understanding the problem. Eventually, the coding interview evolves around
    the tests – they are the key to understanding the problem, but they are also our
    checklist that ensures our answers fulfill the interviewer’s requirements.
  prefs: []
  type: TYPE_NORMAL
- en: But it’s not just leaving time for testing – presume that your tests will fail
    and you’ll have to fix them, so you’ll also need to leave time to fix bugs, similar
    to a real-world deployment process.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, I’ve aimed to guide you through solving complex interview challenges
    by accompanying you every step of the way. The architecture interview (discussed
    in [*Chapter 12*](B18653_12.xhtml#_idTextAnchor360)) and the coding interview
    are separate interviews that target your development skills from different angles.
    The home assessment is the interview that combines most of your skills.
  prefs: []
  type: TYPE_NORMAL
- en: Excelling in a home assessment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **home assessment** is a common interview task many companies use to check
    a candidate’s skills in dealing with a real-world problem. Home assessments require
    us to plan, architect, code, test, and deploy, sometimes with unfamiliar iOS topics
    we have no experience with.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with analyzing what a home assessment is.
  prefs: []
  type: TYPE_NORMAL
- en: What does a home assessment look like?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The framework for a regular home assessment won’t come to you as a surprise.
    However, it is still worth going over it so we can be aligned on the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Assignment*: This is the initial phase where we receive the task, including
    the requirements and instructions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Understanding*: In this stage, we carefully read the instructions and analyze
    the requirements. This is also the phase where we ask the interviewer anything
    we are unclear about and clarify what we must do.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Execution*: This is the current assignment implementation, which typically
    takes place remotely. However, there are instances where it may be carried out
    at the hiring company’s office. This step involves planning and writing our task,
    and if carried out at home, the execution phase may span several days.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Testing*: Once the implementation is complete, we test our solution. That
    includes running test cases and addressing bugs and issues.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Submission*: After the testing, we must submit the assignment to the interviewer.
    In most cases, the submission is done using Git for convenience.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Post-delivery discussion*: In many companies, the interview is followed by
    a discussion or another interview where the interviewer will review the assessment
    with you to understand the different decisions and approaches taken while doing
    the home assessment.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The exact structure may vary between companies and assessments, but this framework
    provides an understanding of the significant steps involved in the process.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what a home assessment looks like, let’s understand why companies
    choose to spend their and our time on this type of task.
  prefs: []
  type: TYPE_NORMAL
- en: The different skills being tested in a home assessment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The home assessment examines some skills that are hard to test in the other
    interview stages, primarily the ability to develop an end-to-end app.
  prefs: []
  type: TYPE_NORMAL
- en: The skills required for a home assessment are both soft and hard, representing
    what is needed from an iOS developer in real-world situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the skills are what we’ve discussed in previous chapters, but let’s
    list them here so we can be aligned on what the interviewer expects from us:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Technical proficiency*: We are being tested for our technical skills – Swift,
    frameworks, Xcode, and other tools are all part of the skills we need to master
    as part of the test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Problem solving*: Home assessments check our ability to solve problems and
    break them into smaller, more manageable steps while using our experience and
    creativity. Architecture and app design are part of those skills, which are crucial
    in these kinds of tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Algorithm design:* This may not be as superior a skill as the coding test,
    but it is part of the home assessment. Notice that we have a project, probably
    a tiny app, to develop. Being able to choose suitable data structures and write
    efficient algorithms may be required to solve complex problems and demonstrate
    our knowledge.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Attention to detail*: Unlike the other interview steps, in the home assessment,
    we have time. How much time? Enough to provide a good, accurate, and error-free
    solution. So, you see, more time means more expectations of us, and we are tested
    on being able to handle edge cases and complete code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Code quality*: Our approach to the home assessment needs to resemble a complete
    project in terms of code quality. It means we need to document our code using
    comments, perform testing and QA, choose proper naming conventions, and have an
    organized file structure. Yes, I know it’s a *small* project for an interview.
    But here’s a secret – at this stage, the interviewer already knows we can build
    a table view and set up a Singleton. The quality of the implementation is what
    is important.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Independence*: One of the best things about home assessments is that they
    allow us to showcase our ability to fulfill a task from end to end, including
    project setup, coding, testing, and deployment, while being observed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having said that, the different skills required depend on the specific role
    and the company we are interviewing for. At this stage, we should already know
    what the company culture is and what is expected from us.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s go over some common examples of projects you may encounter in a home
    assessment.
  prefs: []
  type: TYPE_NORMAL
- en: Going over examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before moving on, a quick note on how to read these examples. You probably won’t
    encounter one of these examples in an interview, and that’s perfectly fine because
    that is not my intention. The goal of providing these examples is to strengthen
    your skills and make you prepared for the unknown. Unlike iOS interview questions,
    where knowledge matters, a home assessment concerns skills and techniques. That’s
    why I’m trying to emphasize the list of skills and the home assessment process.
  prefs: []
  type: TYPE_NORMAL
- en: Each example can teach us a different aspect of the home assessment, and the
    ability to quickly build a small app with a short explanation is crucial for that
    task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go over the examples and pay attention to what’s essential:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Build a to-do list app*: A home assessment focuses on table views, local data
    storage, and state management. Also, typical to-do apps usually support offline
    work and provide a streamlined user experience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Build a weather app with an engaging user interface and reactive API updates*:
    It’s important to integrate Combine frameworks in this kind of app to provide
    updated information to the user in an elegant design pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Build a photo gallery app*: Photo gallery apps require close work with **PhotoKit**
    (the iOS SDK’s photos framework), working with a collection view while optimizing
    it for fast loading and caching. Also, memory management capabilities are essential
    to handle large amounts of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Create a social media feed*: A social media feed usually works with a table
    view combined with a pagination pattern. It is vital to provide efficient memory
    management, user interactions such as likes and comments, and image loading as
    part of the feed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Build a calendar app*: A calendar app requires managing an events list with
    tight integration to the **EventKit** framework (Apple’s framework that helps
    us connect to the calendar), including a table view with a pagination design pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these assessments requires us to face different challenges, implement
    various design patterns, and tweak the architecture to create an organized project.
    It’s a great mental exercise for your brain, trying to think about the different
    solutions and architectures, and is something that can improve your chances of
    succeeding in the test.
  prefs: []
  type: TYPE_NORMAL
- en: Even though our code results are extremely important, it is important to understand
    that our interviewer is looking at additional aspects of our work – red flags.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding red flags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand what live coding interviews and home assessments are,
    let’s briefly discuss perfection. Do we have to provide a perfect solution to
    pass the interview? What is the interviewer looking for?
  prefs: []
  type: TYPE_NORMAL
- en: That’s not an easy question as it may differ for various interviewers and companies.
  prefs: []
  type: TYPE_NORMAL
- en: 'But there’s something that all interviewers will look out for: red flags. The
    fact that we didn’t provide an optimized solution or didn’t know a particular
    Swift feature can be accepted by many interviewers – in most cases, they are looking
    for signals of something unhealthy in the way we approach, think, and code.'
  prefs: []
  type: TYPE_NORMAL
- en: There are red flags we should avoid, even if they may initially seem insignificant
    to the interview process. Let’s go over some of them now.
  prefs: []
  type: TYPE_NORMAL
- en: Inability to explain or defend a solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a red flag that incorporates two crucial missing skills. The first one
    is *deep thinking and code/design understanding*. Many developers use their memory
    to regurgitate solutions without understanding why and how they work. Passing
    an interview question is not enough; we should also understand why we have done
    what we have done. Now that we are at the end of the book, it is essential to
    go back and validate that we fully understand the different answers and solutions.
  prefs: []
  type: TYPE_NORMAL
- en: The second skill is *communication and the ability to explain* ourselves. Sometimes
    it is hard to find the right words to describe why we made certain decisions,
    which can be translated into communication skills. But that is what this book
    is for – to help you verbalize your knowledge and get you ready for the interview.
  prefs: []
  type: TYPE_NORMAL
- en: Dichotomic thinking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many interview questions, especially the design, architecture, and coding questions,
    require trade-offs and multiple approaches to be considered. There’s no room for
    black-and-white thinking without explaining the alternative solutions. We should
    always be flexible and understand that there is not always a single correct answer.
  prefs: []
  type: TYPE_NORMAL
- en: Limited error handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While it may sound trivial, ignoring error handling can be perceived as a red
    flag by interviewers, indicating a potentially unhealthy approach. Focusing on
    happy flows suggests a lack of attention to detail and a very shallow level of
    development. Handling code flows that may produce errors and unexpected results
    is significant.
  prefs: []
  type: TYPE_NORMAL
- en: Poor code quality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our code is our artwork, and it should look good and express our expertise and
    capabilities as developers. But what does this mean? It means we should make structured
    and organized code with clear naming conventions, including comments and documentation.
    Try to avoid too short and unclear names and add indentations and spaces to your
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Also, good separations, short functions, and folder organization can greatly
    help with our code appearence and clarity. The basics do matter at this stage.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That’s it! We have reached the finale of the book, and what an exciting journey
    it has been!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this concluding chapter, we delved into live coding, home assessments, and
    avoiding red flags. We learned how to tackle a whiteboard task, what to focus
    on when coding, and how to approach this important stage in the process. At this
    point, you should feel prepared to tackle the most experimental stage of the interview
    process: the coding assessment.'
  prefs: []
  type: TYPE_NORMAL
- en: While the book may have ended, our journey of practice and hard work is just
    beginning. The world of iOS development is vast, and there is always more to learn
    and explore. Each chapter, section, and question has opened the door to numerous
    topics that can help you improve.
  prefs: []
  type: TYPE_NORMAL
- en: So, don’t stop now; you’re just getting started. Embrace continuous learning
    and strive for excellence in your iOS development career.
  prefs: []
  type: TYPE_NORMAL
