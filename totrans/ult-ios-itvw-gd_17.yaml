- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Acing the Coding Assessment
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在编码评估中取得优异成绩
- en: In the previous chapter, we discussed architecture in depth. Architecture discussions
    tend to be very theoretical and methodological; the same can be said for design
    pattern discussions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们深入讨论了架构。架构讨论往往非常理论化和方法论；同样可以说，设计模式讨论也是如此。
- en: 'In this chapter, we will get to the meat – to the code, working with Xcode,
    and playing with algorithms. We will cover everything related to coding interview
    tasks, such as the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨实质内容——代码、使用Xcode以及玩转算法。我们将涵盖与编码面试任务相关的所有内容，例如以下内容：
- en: How to succeed in a live coding interview, the different tests, and how to code
    like a pro
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在现场编码面试中取得成功，不同的测试，以及如何像专业人士一样编码
- en: How to excel in home assessments by discussing different skills to use and reviewing
    home assessment examples
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过讨论不同的技能和复习家庭评估示例来在家评估中脱颖而出
- en: How to avoid mistakes that may raise red flags in our interviews
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何避免在面试中可能引起红灯的失误
- en: This is the final chapter! You will be fully prepared for your first interview
    by the end of it. Now, let’s dive straight into tips for the live coding interview.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是最后一章！你将在本章结束时为你的第一次面试做好充分准备。现在，让我们直接进入现场编码面试的技巧。
- en: Succeeding in live coding
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现场编码的成功
- en: The live coding interview is probably the most intimidating in the process.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现场编码面试可能是整个过程中最令人畏惧的。
- en: It’s easy to understand why – for most developers, it’s a stage that is an uncomfortable
    situation in any case.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易理解为什么——对于大多数开发者来说，这无论如何都是一个不舒服的情况。
- en: For a start, in most cases, we aren’t working in our beloved (to some of us)
    Xcode. We are required to handle tasks that we usually don’t face in our day-to-day
    work, and we’re doing that under pressure while someone is watching us at every
    step.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在大多数情况下，我们并不是在我们心爱的（对于一些人来说）Xcode中工作。我们需要处理我们通常在日常生活中不会面对的任务，而且我们是在压力下完成的，而且有人在每一步都监视着我们。
- en: The reason why I said “probably” and “most developers” at the start of this
    section is that it doesn’t have to be intimidating. Sure, live coding is a stressful
    interview, but we can make it exciting and much more joyful with the right approach.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本文节开头说“可能”和“大多数开发者”的原因是，这并不一定令人感到畏惧。当然，现场编码是一个压力很大的面试，但我们可以通过正确的方法让它变得有趣得多，也更加愉快。
- en: Skeptical? Don’t be! Throughout the preceding 12 chapters, we have observed
    that proper preparation can make anything achievable.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 怀疑？不要怀疑！在前面的12章中，我们已经观察到，适当的准备可以使任何事情变得可行。
- en: Before we rush into the interview itself, let’s learn about the different environments
    we will work in and the different types of tests.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们匆忙进入面试本身之前，让我们了解一下我们将工作的不同环境和不同类型的测试。
- en: Learning about the different live coding tests
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解不同的现场编码测试
- en: Unlike the other interview stages, the live coding interview usually has different
    shapes and forms that dramatically affect how the whole interview feels and looks.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他面试阶段不同，现场编码面试通常有不同的形式和结构，这会极大地影响整个面试的感觉和外观。
- en: There are three types of live coding interviews – whiteboard, online, and in-person.
    We call them live coding here, but each provides different experiences and challenges.
    Let’s start with the whiteboard interview.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种类型的现场编码面试——白板、在线和面对面。在这里，我们称之为现场编码，但每种都提供不同的体验和挑战。让我们从白板面试开始。
- en: The whiteboard interview
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 白板面试
- en: If I recall correctly, this is the third time we’re mentioning the importance
    of the whiteboard. The first time was in [*Chapter 2*](B18653_02.xhtml#_idTextAnchor041),
    when we discussed preparing for the interview process (in the *Getting ready for
    the screening interview* section). The second time was in [*Chapter 12*](B18653_12.xhtml#_idTextAnchor360)
    (in the *The architecture design interview* section) when we discussed the architecture
    interview, and now, we’re mentioning it in approaching the live coding stage.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我记得正确的话，这是我们第三次提到白板的重要性。第一次是在[第2章](B18653_02.xhtml#_idTextAnchor041)，当时我们讨论了面试准备过程（在“准备筛选面试”部分）。第二次是在[第12章](B18653_12.xhtml#_idTextAnchor360)（在“架构设计面试”部分）讨论架构面试，现在，我们再次提到它，是在进入现场编码阶段时。
- en: Why is the whiteboard such an essential tool in interviews? What makes interviewers
    highly value the whiteboard, and how can we maximize it for our benefit?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么白板在面试中如此重要？是什么让面试官高度重视白板，以及我们如何最大限度地利用它来为我们自身谋利？
- en: Well, the whiteboard has one significant advantage – it promotes clarity and
    communication between people and allows us to visualize our thinking when explaining
    an idea. That’s the reason why most meeting rooms include a whiteboard.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，白板有一个显著的优势——它促进了人与人之间的清晰沟通，并允许我们在解释一个想法时可视化我们的思考。这就是为什么大多数会议室都包括白板的原因。
- en: Now, as candidates, it is sometimes difficult to use the whiteboard if we are
    not used to it. And the fact that we’re standing there struggling with a coding
    question doesn’t help that situation either.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，作为候选人，如果我们不习惯使用白板，有时很难使用它。而且，我们站在那里努力解决编码问题，这也不利于这种情况。
- en: But it can also be a good tool for communicating with our interviewer, as we
    did in the previous chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 但它也可以是我们与面试官沟通的好工具，就像我们在上一章中所做的那样。
- en: If you think that communication is not a big deal in interviews, let’s get into
    the online interview, and you’ll understand why it is critical.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为沟通在面试中不是什么大问题，那就让我们进入在线面试，你将会明白为什么它是至关重要的。
- en: The online interview
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在线面试
- en: The online interview is a session that takes place via a **video conference**
    using a platform such as Zoom, FaceTime, or Google Meet.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在线面试是通过使用Zoom、FaceTime或Google Meet等平台进行的视频会议。
- en: You might think the online interview’s significant advantage would be using
    an **integrated development environment** (**IDE**). But in most cases, the session
    happens on a dedicated website without indentation, code completion, or syntax
    highlighting.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为在线面试的一个显著优势是使用**集成开发环境**（**IDE**）。但在大多数情况下，会议是在一个专门的网站上进行的，没有缩进、代码补全或语法高亮。
- en: 'In addition, the online coding interview has another drawback that we didn’t
    have in the whiteboard interview: communication.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在线编码面试还有一个我们在白板面试中没有的缺点：沟通。
- en: I have observed, on multiple occasions, that interaction with the interviewer
    plays a vital role in the success of an interview. It is undeniable that communication
    is more challenging in online sessions compared to in-person meetings.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我观察到，在多次面试中，与面试官的互动在面试成功中起着至关重要的作用。不可否认的是，与面对面会议相比，在线会议中的沟通更具挑战性。
- en: However, complaining is not the path to success.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，抱怨不是通往成功的道路。
- en: We need to look for other advantages of an online coding session. For example,
    the fact that we are coding on a computer allows us to edit and push rows down
    if needed. Whiteboard editing is much more difficult and forces us to plan what
    we are going to write.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要寻找在线编码会议的其他优势。例如，我们是在电脑上编码的事实使我们能够在需要时编辑和向下推行代码。白板编辑要困难得多，并迫使我们规划将要写的内容。
- en: Furthermore, scheduling and preparing for an online coding interview is comparatively
    more straightforward. Remote meetings and using computers are likely within our
    comfort zone, as the Covid-19 era has taught us how to navigate these aspects
    effectively.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，安排和准备在线编码面试相对简单。远程会议和使用电脑可能在我们舒适区内，因为Covid-19时代教会了我们如何有效地处理这些方面。
- en: Combining both worlds – the in-person coding interview
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结合两个世界——面对面编码面试
- en: The “in-person” coding interview takes place on a laptop in front of our interviewer.
    This is a unique approach compared to the previous two methods (whiteboard and
    remote), and there’s an excellent reason for that. The in-person coding interview
    has an advantage in terms of personal interaction. Still, this advantage is often
    not strong enough when considering the logistical efforts that come with it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: “面对面”编码面试是在面试官面前的笔记本电脑上进行的。与之前两种方法（白板和远程）相比，这是一种独特的方法，而且有很好的理由。面对面编码面试在个人互动方面具有优势。然而，考虑到随之而来的后勤努力，这种优势通常并不足够强大。
- en: Therefore, the whiteboard coding interview is preferable when discussing in-person
    sessions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在讨论面对面会议时，白板编码面试更受欢迎。
- en: Having said that, the in-person coding interview usually happens in companies
    that wish to see us coding in a natural working environment. In some instances,
    the interviewer accompanies us while we code, while in other cases, we are given
    privacy to code in a room on our own, with the interviewer checking in periodically
    to assess our progress. Both cases can be stressful for developers, having to
    code while someone is watching them. But sometimes, that’s part of the test –
    to see how we perform complex tasks under slight pressure.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，面对面的编码面试通常发生在希望看到我们在自然工作环境中编码的公司。在某些情况下，面试官在我们编码时陪伴我们，而在其他情况下，我们被给予隐私，在房间里自己编码，面试官定期检查以评估我们的进度。这两种情况都可能对开发者造成压力，因为他们需要在有人观看的情况下编码。但有时，这可能是测试的一部分——看看我们在轻微的压力下如何执行复杂任务。
- en: All three ways (whiteboard, in-person, and remote coding) are common, and all
    of them can be stressful experiences. The best way to decrease the pressure level
    is to practice and be prepared for this challenge.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三种方式（白板、面对面和远程编码）都很常见，而且所有这些都可以是压力很大的体验。降低压力水平的最佳方法是练习并为此挑战做好准备。
- en: Preparing ourselves for the coding interview
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为编码面试做好准备
- en: I know you might be thinking that the fact that we are veteran developers means
    that we are ready for a coding interview since coding is what we do almost every
    day. But you can’t be more wrong on that – the coding interview requires new skills
    and techniques to pass it successfully.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你可能认为，作为资深开发者，我们已经准备好编码面试，因为编码是我们几乎每天都在做的事情。但你在这一点上大错特错了——编码面试需要新的技能和技术才能成功通过。
- en: We have already reviewed the different coding test types – whiteboard, in-person,
    and remote. We will see that some skills need to be sharpened to pass these tests.
    We’ll start with the first and primary one – writing code in a plain text editor.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经回顾了不同的编码测试类型——白板、面对面和远程。我们将看到，为了通过这些测试，需要磨练一些技能。我们将从第一个和最重要的一个开始——在纯文本编辑器中编写代码。
- en: Working with a plain text editor
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用纯文本编辑器
- en: In most coding interviews, we will work with a **plain text editor**. A whiteboard,
    for that matter, is a plain text editor.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数编码面试中，我们将使用一个**纯文本编辑器**。实际上，白板也是一个纯文本编辑器。
- en: A plain text editor lacks syntax highlighting, indentation, and code completion,
    creating an unfamiliar environment for us.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 纯文本编辑器缺乏语法高亮、缩进和代码补全，为我们创造了一个不熟悉的环境。
- en: 'It might be easy to declare a function without any problems in a plain text
    editor, as you can see in the following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯文本编辑器中声明一个函数可能很容易，没有任何问题，就像以下代码所示：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: But that’s the easy part! Let’s see what the challenges are and how we deal
    with them.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 但这只是容易的部分！让我们看看挑战是什么，以及我们如何应对它们。
- en: Spotting syntax errors
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 识别语法错误
- en: Syntax highlighting helps us spot keywords and expressions, but it also helps
    us find syntax errors, such as missing parentheses, brackets, or semicolons. In
    a text editor, there’s a best practice of typing both open and closed brackets
    or parentheses and only then writing the expression inside.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 语法高亮帮助我们识别关键词和表达式，但它也帮助我们找到语法错误，例如缺少括号、方括号或分号。在文本编辑器中，有一个最佳实践是先输入开闭括号或括号，然后再写表达式。
- en: However, on a whiteboard, we can’t use that technique. One option is to *highlight
    delimiters* ourselves and write them in a different color. Sure, doing that can
    slow us down, but it will make our code much clearer and more aesthetic. Another
    option is to *draw the delimiter bigger*, which is another way of highlighting.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在白板上，我们不能使用那种技术。一个选择是**我们自己突出分隔符**并将它们用不同的颜色写出来。当然，这样做可能会减慢我们的速度，但会使我们的代码更加清晰和美观。另一个选择是**将分隔符画得更大**，这是另一种突出显示的方法。
- en: Avoiding typos
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 避免打字错误
- en: While syntax is just one aspect of an IDE, code completion is another crucial
    feature. We are used to writing extended descriptive functions and variable names,
    relying on the code editor to handle them through code completion. However, that’s
    not the case with a plain text editor. Without code completion, typos can break
    our code. Although typos can be more acceptable in whiteboard coding interviews
    than in in-person or remote interviews, they still look bad and unprofessional.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然语法是IDE的一个方面，但代码补全是一个另一个关键特性。我们习惯于编写扩展描述性函数和变量名，依赖代码编辑器通过代码补全来处理它们。然而，在纯文本编辑器中并非如此。没有代码补全，打字错误可能会破坏我们的代码。尽管在白板编码面试中，打字错误可能比面对面或远程面试更可接受，但它们仍然看起来不好，不够专业。
- en: A way to help us avoid typos is to use clear and short names for functions and
    variables. That can speed up the coding and help us organize our writing on the
    whiteboard.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们避免打字错误，我们可以为函数和变量使用清晰简短的名字。这可以加快编码速度，并帮助我们组织白板上的写作。
- en: Mastering complex Swift expressions
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 掌握复杂的 Swift 表达式
- en: 'I mentioned earlier how simple it is to declare a function in Swift. But Swift
    is much more than functions and variables declarations. So, to master Swift, we
    need to have complete knowledge of more complex expressions and functions, such
    as the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过在 Swift 中声明函数是多么简单。但 Swift 远不止函数和变量声明。因此，要掌握 Swift，我们需要对更复杂的表达式和函数有全面的知识，例如以下内容：
- en: Collections functions – **filter**, **map**, and **reduce**
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合函数 – **filter**、**map** 和 **reduce**
- en: Closures
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包
- en: Advanced type system features – generics and protocols
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级类型系统特性 – 泛型和协议
- en: Tuples and enums
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组与枚举
- en: This list contains features prone to mistakes, and when I say mistakes, I don’t
    mean just cosmetic ones. The closure format, for example, has critical components
    that directly affect our code flow. The same goes for generics and protocols.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表包含容易出错的特性，当我提到错误时，我不仅仅是指外观上的错误。例如，闭包格式有直接影响我们代码流程的关键组件。泛型和协议也是如此。
- en: We should practice Swift’s complex expressions and ensure we master them.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该练习 Swift 的复杂表达式，并确保我们掌握了它们。
- en: Maintaining code organization
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 维护代码组织
- en: Code organization is a critical topic because it’s a real challenge when working
    with a plain editor. As you know, a plain editor doesn’t have indentation, which
    usually helps us to create a readable and organized code. Remember closures and
    filtering? Trying to read these Swift features without indentation is complex,
    and code readability affects our chances of success.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 代码组织是一个关键话题，因为在使用纯文本编辑器时，这是一个真正的挑战。正如你所知，纯文本编辑器没有缩进，这通常有助于我们创建可读性和组织性强的代码。还记得闭包和过滤吗？在没有缩进的情况下尝试阅读这些
    Swift 功能是复杂的，代码的可读性影响我们的成功机会。
- en: Indentation becomes even more critical when coding on a whiteboard. On a laptop,
    at least, we can use tabs, something that doesn’t exist on whiteboards.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当在白板上编码时，缩进变得尤为重要。至少在笔记本电脑上，我们可以使用制表符，而白板上没有这种功能。
- en: We understand now that many of the challenges we face in plain text editor coding
    become even more prominent on a whiteboard. Don’t worry! There’s still time to
    manage that.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在明白，我们在纯文本编辑器编码中面临的许多挑战在白板上变得更加突出。别担心！还有时间来管理这些。
- en: Practicing on a whiteboard
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在白板上练习
- en: For most of us, coding on a whiteboard is not natural. Consider developers who
    have spent nearly 10,000 hours coding in front of a computer; the transition to
    coding on a whiteboard can be challenging.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们大多数人来说，在白板上编码并不自然。考虑那些在电脑前编码了近 10,000 小时的开发者；转向在白板上编码可能是一个挑战。
- en: When it comes to coding on a whiteboard as opposed to a laptop, there are several
    challenges that we should bear in mind. For example, whiteboards don’t have scroll
    capabilities, it is much more difficult to edit or insert new rows, there are
    no straight lines or font sizes, and our canvas is just one big white surface
    without a grid.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到在白板上编码而不是在笔记本电脑上编码时，有几个挑战我们应该记住。例如，白板没有滚动功能，编辑或插入新行要困难得多，没有直线或字体大小，我们的画布只是一个没有网格的大白表面。
- en: 'Having said that, some tips can help us improve our whiteboarding skills. Let’s
    go over them:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，一些技巧可以帮助我们提高白板技能。让我们来看看它们：
- en: '*Visualize our code structure*: As I said, whiteboards don’t have any built-in
    scrolling mechanism, and their coding area is fixed. Therefore, before coding
    on a whiteboard, we should visualize our answer structure. Notice I wrote *answer*
    and not *code*. The reason for that is that our answer is much more than just
    the function we were supposed to implement – there are tests, diagrams, and perhaps
    even notes we need to consider. We should divide the whiteboard into zones and
    allocate space for each answer’s component. Of course, the same goes for the coding
    area itself – try to imagine how long your answer will be and choose your font
    size accordingly. Look at *Figure 13**.1*:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可视化我们的代码结构*：正如我说的，白板没有内置的滚动机制，它们的编码区域是固定的。因此，在白板上编码之前，我们应该可视化我们的答案结构。注意我写的是
    *answer* 而不是 *code*。这是因为我们的答案远不止我们本应实现的函数——还有测试、图表，甚至可能还有我们需要考虑的笔记。我们应该将白板划分为区域，并为每个答案的组件分配空间。当然，这也适用于编码区域本身——尝试想象你的答案会有多长，并相应地选择字体大小。看看
    *图 13**.1*：'
- en: '![Figure 13.1 – Dividing the whiteboard into spaces](img/Figure_13.01_B18653.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1 – 将白板划分为空间](img/Figure_13.01_B18653.jpg)'
- en: Figure 13.1 – Dividing the whiteboard into spaces
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – 将白板划分为空间
- en: '*Figure 13**.1* shows how we set a different space for each part of our answer.
    Organizing your whiteboard is the key to presenting a clear answer.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13.1* 展示了如何为我们的答案的每一部分设置不同的空间。组织你的白板是展示清晰答案的关键。'
- en: '*Use diagrams*: We talked about allocating a specific space for diagrams. However,
    diagrams are not a limitation of whiteboards at all – drawing diagrams is a significant
    advantage we don’t have on a laptop, especially when working remotely. Diagrams
    let us visualize our algorithms, ideas, and thoughts and communicate them to our
    interviewer much better. When practicing coding questions, we should try to illustrate
    our thinking and answers. The best way to learn how to do that is to watch videos
    on the internet that explain how to solve different algorithms and focus on the
    visual part. We should know how to describe flows, arrays, trees, and database
    schemes on a whiteboard.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用图表*：我们讨论了为图表分配特定空间。然而，图表绝不是白板的限制——绘制图表是我们笔记本电脑上没有的显著优势，尤其是在远程工作时。图表让我们能够可视化我们的算法、想法和思考，并将它们更好地传达给我们的面试官。在练习编码问题时，我们应该尝试说明我们的思考和答案。学习如何做到这一点最好的方式是观看互联网上解释如何解决不同算法的视频，并关注视觉部分。我们应该知道如何在白板上描述流程、数组、树和数据库模式。'
- en: '*Practice out loud*: A common challenge many developers face is solving a coding
    question on a whiteboard while effectively explaining it. Why? Because most developers
    are not used to writing code down on a whiteboard and then explaining it at the
    same time. We shouldn’t just practice writing on a whiteboard – we should also
    practice presenting our solutions while thinking out loud, whether to ourselves
    or others.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*大声练习*：许多开发者面临的一个常见挑战是在白板上解决编码问题，同时有效地解释它。为什么？因为大多数开发者不习惯在白板上写下代码，并同时解释它。我们不仅应该练习在白板上写作，还应该练习在思考的同时展示我们的解决方案，无论是给自己还是给别人。'
- en: Few developers have good whiteboard drawing skills, but practicing is an effective
    way to improve dramatically. These small tips can raise the bar and provide us
    with more skills.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有开发者有很好的白板绘图技能，但练习是显著提高的有效方法。这些小贴士可以提高标准，并为我们提供更多技能。
- en: Now, let’s move on to the actual coding. How do we start?
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续进行实际的编码。我们该如何开始？
- en: Starting to code
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始编码
- en: Now that we understand the different interview options, we can start with the
    real fun – coding. Can you guess what tip I have when facing a coding question
    unrelated to iOS, Swift, or coding in general?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了不同的面试选项，我们可以开始真正的乐趣——编码。你能猜到当我面对与 iOS、Swift 或一般编码无关的编码问题时有什么建议吗？
- en: Take your time
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 慢慢来
- en: We first need to relax, step back, and analyze our task. It is a common mistake
    to start coding immediately even if we (think that we) already know the answer.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要放松，退后一步，分析我们的任务。即使我们（认为）已经知道答案，立即开始编码是一个常见的错误。
- en: First, sure, you might know the answer or at least know how to approach the
    question. But take one or two minutes to rethink what you will do. Maybe find
    a more effective way to solve the question or a more engaging way to present the
    answer. If you have the time, why not use it?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当然，你可能知道答案，或者至少知道如何接近这个问题。但花上一两分钟重新思考你将做什么。也许找到一个更有效的方法来解决这个题目，或者一个更有吸引力的方式来展示答案。如果你有时间，为什么不利用它呢？
- en: Furthermore, taking your time is not a bad sign for the interviewer. The opposite
    is the truth. The fact that you are not rushing to code is a sign that you are
    thinking before you act and want to focus on planning and researching. In the
    previous chapter, we said interviewers are searching for soft skills during the
    architecture interview. However, soft skills are tested everywhere, including
    in the coding interview. Planning and critical thinking, essential soft skills,
    are also evaluated during the interview process.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，花时间并不是面试官眼中的坏信号。相反，这是真的。你之所以不急于编码，是因为你行动前先思考，想要专注于规划和研究。在上一章中，我们提到面试官在架构面试中寻找软技能。然而，软技能在各个地方都会被测试，包括在编码面试中。规划和批判性思维，这些基本的软技能，在面试过程中也会被评估。
- en: Start with testing
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从测试开始
- en: Are we doing **test-driven development** (**TDD**)? Well, not exactly. One of
    the most noticeable differences between the coding and the architecture interview
    is that in the coding interview, we must understand all our constraints and guidelines
    from the beginning. We can’t discover them as the interview proceeds.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是在做**测试驱动开发**（**TDD**）吗？嗯，不是的。编码面试和架构面试之间最明显的区别之一是，在编码面试中，我们必须从一开始就理解所有约束和指南。我们不能在面试过程中发现它们。
- en: In coding interviews, the session begins when we ask our interviewer for all
    the necessary information to accomplish our task.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码面试中，会话开始于我们向面试官询问完成任务的必要信息。
- en: But how do we know what to ask?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何知道要问什么？
- en: The best way is to *write down the tests for the function* we will code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的方法是**写下我们将要编写的函数的测试用例**。
- en: 'Look at the following coding question:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下编码问题：
- en: Write a function in Swift that takes an array of integers as input and returns
    the maximum difference between any two elements in the array. The maximum difference
    should be calculated by subtracting the smallest element from the largest element.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Swift函数，该函数接受一个整数数组作为输入，并返回数组中任意两个元素之间的最大差值。最大差值应通过从最大元素中减去最小元素来计算。
- en: 'Now, let’s write down our test cases:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们写下我们的测试用例：
- en: '[PRE1]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These test cases are crucial for us to provide a good answer. First, they answer
    all our questions – what if we have negative numbers? What if the input has one
    element or no elements at all?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试用例对我们提供良好答案至关重要。首先，它们回答了我们的所有问题——如果我们有负数怎么办？如果输入只有一个元素或没有元素怎么办？
- en: Not only can the test cases lead us to the algorithm we need to write, but they
    also behave as a checklist throughout the session. If we want to ensure we’ve
    finished our coding and covered all our cases, we can review the list and check
    our code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例不仅可以帮助我们确定需要编写的算法，而且在整个会话中充当检查清单。如果我们想确保我们已经完成了编码并覆盖了所有情况，我们可以查看列表并检查我们的代码。
- en: Start strong – don’t be afraid of brute force
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开门见山——不要害怕使用暴力法
- en: One thing that rings in our heads during interviews is that we need to provide
    an optimized solution in terms of space and time complexity.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在面试过程中，我们脑海中回响的一件事是我们需要提供一个在空间和时间复杂度方面优化的解决方案。
- en: And this is true – providing an efficient solution is one of the things we are
    tested on. But, as a starting point, we need to focus on accomplishing the task
    and only then optimize it. In other words, we should start with **brute force**.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点是正确的——提供有效的解决方案是我们需要接受考验的事情之一。但是，作为一个起点，我们需要专注于完成任务，然后才能进行优化。换句话说，我们应该从**暴力法**开始。
- en: What is brute force?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是暴力法？
- en: The term *brute force* refers to a straightforward approach to solving a problem
    involving basic algorithms without thinking of optimizations and efficiency. Brute-force
    solutions are impractical in real-world scenarios due to their high space and
    time complexity.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**暴力法**指的是一种直接解决问题的方法，涉及基本算法，而不考虑优化和效率。由于空间和时间复杂度较高，暴力法在实际场景中不切实际。
- en: If brute force is not practical in real-life scenarios, why have I suggested
    starting with it?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果暴力法在现实场景中不实用，为什么我建议从它开始？
- en: When we receive a task to do, we first want to provide a working solution. A
    working solution proves that we understand the problem and is a great starting
    point for optimization. We can start measuring the time and space complexity and
    perform incremental updates.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们收到一个任务时，我们首先想要提供一个可行的解决方案。可行的解决方案证明我们理解了问题，并且是优化的良好起点。我们可以开始测量时间和空间复杂度，并执行增量更新。
- en: In other words, brute force is an anchor for further changes we want to make,
    providing us the flexibility to revert and find an alternate path if something
    goes wrong.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，暴力法是我们想要进行的进一步更改的锚点，为我们提供了灵活性，以便在出现问题时可以回退并找到另一条路径。
- en: 'Let’s go over an example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子：
- en: Find the maximum sum of a subarray within an array of integers.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 找到一个整数数组中子数组的最大和。
- en: 'The brute-force solution would be to iterate an array with two nested loops
    while maintaining a `maxSum` variable:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 暴力法的解决方案是使用两个嵌套循环遍历数组，同时维护一个`maxSum`变量：
- en: '[PRE2]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the first loop, we iterate all the elements in the array, and for each iteration,
    we create another loop that starts from the current element until the end of the
    same array. In this approach, we cover all the different subarray combinations
    and try to find the maximum sum by using the `maxSum` array.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个循环中，我们遍历数组中的所有元素，并且对于每次迭代，我们创建另一个从当前元素开始到数组末尾的循环。在这种方法中，我们覆盖了所有不同的子数组组合，并尝试使用`maxSum`数组找到最大和。
- en: This solution works! But we understand that using nested arrays makes our algorithm
    inefficient with a time complexity of O(n^2).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案是有效的！但我们理解使用嵌套数组使我们的算法在时间复杂度为O(n^2)的情况下变得低效。
- en: So, how can we improve it?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何改进它呢？
- en: We said a brute-force solution is a great starting point for optimization. Having
    two nested loops should raise a concern – we understand that our time complexity
    is too high. Usually, the trade-off for time is space. In this case, we can have
    one array iteration and preserve the current sum in a specific variable.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说过暴力解法是优化的一个很好的起点。有两个嵌套循环可能会引起担忧——我们理解我们的时间复杂度太高了。通常，时间与空间的权衡。在这种情况下，我们可以有一个数组迭代，并保留当前和在一个特定的变量中。
- en: 'Let’s see an optimized version of the code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码的优化版本：
- en: '[PRE3]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding algorithm is called **Kadane’s algorithm**, and it is an efficient
    way to solve that problem. In Kadane’s algorithm, we calculate the maximum subarray
    that ends in a specific index using the previous index’s subarray calculation.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 上述算法被称为**Kadane算法**，它是一种高效解决该问题的方法。在Kadane算法中，我们通过使用前一个索引的子数组计算来计算以特定索引结束的最大子数组。
- en: 'Confused? Let’s test it on a random array:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 感到困惑？让我们在一个随机数组上测试它：
- en: '[PRE4]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Kadane’s algorithm is a clever algorithm that provides an efficient and straightforward
    solution to a complex problem. You would not be expected to be able to use this
    algorithm if you haven’t come across it before. But the point here is that we
    have two versions for our answer, and unless the optimal solution pops into our
    mind, we should start with the brute-force method and then continue solving the
    problem.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Kadane算法是一个巧妙的算法，它提供了一个高效且直接解决复杂问题的方法。如果你之前没有遇到过这个算法，你不会期望能够使用它。但这里的重点是，我们有我们的答案的两个版本，除非最优解突然出现在我们的脑海中，否则我们应该从暴力方法开始，然后继续解决问题。
- en: Coding like a pro
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 专业的编码
- en: So, how do we code like a pro? We already know that our chances to succeed in
    the coding interview have much to do with how much we practice and solve algorithm
    problems at home. But practicing is only part of the solution. There are some
    key factors that we should follow during the session.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何像专业人士一样编写代码？我们已经知道我们成功通过编码面试的机会与我们在家练习和解决算法问题有很大关系。但练习只是解决方案的一部分。在会话期间，我们应该遵循一些关键因素。
- en: Let’s start with two critical key factors – time and space complexities.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从两个关键因素——时间和空间复杂度——开始。
- en: Use the terms “time complexity” and “space complexity”
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用“时间复杂度”和“空间复杂度”这两个术语
- en: We’ve mentioned time and space complexities in this chapter several times for
    a good reason. We know that effective communication with the interviewer is essential,
    and it should be done with proper terms.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中多次提到时间和空间复杂度，这是有充分理由的。我们知道与面试官的有效沟通至关重要，而且应该使用适当的术语。
- en: After we finish the brute-force solution (as soon as possible), we need to optimize
    it and use the correct terms. This is so important because time and space complexities
    are objective ways to evaluate our code’s efficiency.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成暴力解法（尽可能快）之后，我们需要对其进行优化并使用正确的术语。这一点非常重要，因为时间和空间复杂度是评估我们代码效率的客观方法。
- en: For example, saying something such as “*It’s not efficient to have a nested
    loop*” is not a professional way of describing an algorithm. The proper way would
    be, “*This algorithm has a time complexity of O(N^2), but I think we can improve
    it* *to O(N)*.”
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，说“*嵌套循环不是一种高效的方法*”并不是描述算法的专业方式。正确的方式应该是，“*这个算法的时间复杂度为O(N^2)，但我认为我们可以将其改进到O(N)*。”
- en: So, what is time complexity? The following information box provides a definition.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，时间复杂度是什么？以下信息框提供了一个定义。
- en: What is time complexity?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是时间复杂度？
- en: Time complexity refers to the time an algorithm requires to run as the input
    size grows. We describe the input size as **N** and express the complexity with
    big-O notation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 时间复杂度指的是随着输入规模的增加，算法运行所需的时间。我们描述输入规模为**N**，并用大O符号表示复杂度。
- en: 'There are several use cases for time complexity:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 时间复杂度有几个应用场景：
- en: '*Constant time complexity, “O(1)”*: Accessing a specific index in an array
    or performing basic arithmetic operations'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*常数时间复杂度，“O(1)”*：访问数组中的特定索引或执行基本算术运算'
- en: '*Linear time complexity, “O(n)”*: Iterating an array or a linked list with
    the size of **n**'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*线性时间复杂度，“O(n)”*：迭代大小为 **n** 的数组或链表'
- en: '*Quadratic time complexity, “O(n^2)”*: Using nested loops or bubble sort'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*二次时间复杂度，“O(n^2)”*：使用嵌套循环或冒泡排序'
- en: '*Logarithmic time complexity, “O(log n)”*: Binary search'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对数时间复杂度，“O(log n)”*：二分查找'
- en: 'I don’t want to get into too many details about time and space complexity,
    but there are two things to keep in mind when discussing complexity in an interview:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我不想过多地讨论时间和空间复杂度，但在面试讨论复杂度时，有两件事需要记住：
- en: '*Complexity calculation*: This is a topic we should address before starting
    the interview, and it’s broader than we think. First, we should count the different
    operations in our code and define each’s complexity. Then, we need to sum it up
    and, in the end, determine the complexity of different inputs – best, worst, and
    average cases.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*复杂度计算*：这是一个我们在面试开始前应该解决的问题，而且比我们想象的要广泛。首先，我们应该计算代码中的不同操作，并定义每个操作的复杂度。然后，我们需要将它们加起来，最后确定不同输入的复杂度——最佳、最坏和平均情况。'
- en: '*Understand logarithmic time complexity*: Most of the use cases I mentioned
    earlier are straightforward, but O(log n) is the one that confuses many developers.
    This complexity describes an algorithm whose runtime grows nonlinearly (**logarithmically**)
    with the input size. The increase is slower than O(n) and O(n^2), making it more
    efficient.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*理解对数时间复杂度*：我之前提到的大多数用例都很直接，但 O(log n) 是让许多开发者感到困惑的一个。这种复杂度描述了一个算法，其运行时间随着输入大小的增加呈非线性（**对数**）增长。增长速度比
    O(n) 和 O(n^2) 慢，使其更有效。'
- en: 'Let’s have a look at the following `findElement` function and try to calculate
    its time complexity:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看下面的 `findElement` 函数，并尝试计算其时间复杂度：
- en: '[PRE5]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The algorithm is simple – we iterate in an array and check each element to see
    whether it’s equal to the target function parameter. If we find an element with
    the same value, we return `true`. Otherwise, we return `false`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 算法很简单——我们在数组中迭代，检查每个元素是否与目标函数参数相等。如果我们找到一个具有相同值的元素，我们返回 `true`。否则，我们返回 `false`。
- en: To calculate the function time complexity, we need to list our operations and
    describe their complexity individually. We have a `for` loop with a time complexity
    of O(n) and an `if` statement with a time complexity of O(1).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算函数的时间复杂度，我们需要列出我们的操作，并分别描述它们的复杂度。我们有一个时间复杂度为 O(n) 的 `for` 循环和一个时间复杂度为 O(1)
    的 `if` 语句。
- en: In this case, the overall time complexity of the function is O(n), and it is
    determined by the linear dominant operation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，函数的整体时间复杂度是 O(n)，它由线性主导操作决定。
- en: And what about **space complexity**?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 那么关于 **空间复杂度** 呢？
- en: What is space complexity?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是空间复杂度？
- en: Space complexity refers to the memory or storage an algorithm requires to run
    as the input size grows. We describe the input size as **N** and express the complexity
    with big-O notation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 空间复杂度指的是算法在输入大小增加时所需的内存或存储。我们将输入大小表示为 **N**，并用大-O 符号表示其复杂度。
- en: Space complexity is usually the trade-off of time complexity. When we optimize
    an algorithm, we need to consider the balance between the amount of memory it
    consumes and the time taken to execute the algorithm.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 空间复杂度通常是时间复杂度的权衡。当我们优化算法时，我们需要考虑它消耗的内存量和执行算法所需的时间之间的平衡。
- en: 'We measure space complexity in a similar way as we do for time complexity.
    For instance, let’s look at the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以类似的方式测量空间复杂度，就像我们测量时间复杂度一样。例如，让我们看看以下代码：
- en: '[PRE6]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `printNumbers()` function takes `n` as input and creates an array to store
    the numbers from 1 to `n`. The space complexity of this function is O(n) as the
    size of the numbers grows linearly with the input `n`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`printNumbers()` 函数接收 `n` 作为输入，并创建一个数组来存储从 1 到 `n` 的数字。这个函数的空间复杂度是 O(n)，因为数字的大小与输入
    `n` 线性增长。'
- en: The main goal of using time and space complexities is to not only communicate
    with the interviewer professionally, but also to be able to evaluate our solutions
    so we can provide an optimized answer.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用时间和空间复杂度的主要目标是不仅与面试官进行专业沟通，而且能够评估我们的解决方案，以便我们能够提供优化的答案。
- en: Come with a set of tools
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带着一套工具
- en: Never enter a combat field without a weapon or ammo – the same goes for a coding
    interview and a suitable set of tools. Every interview question or challenge can
    be addressed if we come prepared with a list of techniques to help us.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要在没有武器或弹药的情况下进入战场——这对编码面试和合适的工具集也是一样的。如果我们准备了一份技术列表来帮助我们，每个面试问题或挑战都可以得到解决。
- en: For example, we can have a complex question about linked lists. To solve that
    question, we must master the basics of a linked list – how to traverse a list,
    remove/add an element, or convert a list into an array and vice versa. We should
    know how to do these things before we come to the interview.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以有一个关于链表的复杂问题。为了解决这个问题，我们必须掌握链表的基本知识——如何遍历列表、删除/添加元素，或者将列表转换为数组以及相反。在我们到达面试之前，我们应该知道如何做这些事情。
- en: Knowing the basic data structures well can help us focus on the real challenge,
    which is the algorithm itself. In the previous chapter, we discussed app architectures
    and said that design patterns are the building blocks of architecture. Here, we
    also have building blocks. We start with data structures, then go over the fundamental
    design patterns that manipulate these data structures, and then the algorithms
    that are based upon these patterns.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 熟练掌握基本数据结构可以帮助我们专注于真正的挑战，即算法本身。在前一章中，我们讨论了应用架构，并说设计模式是架构的构建块。在这里，我们也有构建块。我们首先从数据结构开始，然后了解操纵这些数据结构的基本设计模式，最后是建立在这些模式之上的算法。
- en: Leave time for testing
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为测试留出时间
- en: Not testing is a common mistake many candidates make in coding interviews. When
    we discussed how to start the coding interview, we discussed testing as a key
    to understanding the problem. Eventually, the coding interview evolves around
    the tests – they are the key to understanding the problem, but they are also our
    checklist that ensures our answers fulfill the interviewer’s requirements.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 不进行测试是许多候选人在编码面试中犯的常见错误。当我们讨论如何开始编码面试时，我们讨论了测试作为理解问题的关键。最终，编码面试围绕着测试展开——它们是理解问题的关键，但它们也是我们的清单，确保我们的答案满足面试官的要求。
- en: But it’s not just leaving time for testing – presume that your tests will fail
    and you’ll have to fix them, so you’ll also need to leave time to fix bugs, similar
    to a real-world deployment process.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 但不仅仅是留出时间进行测试——假设你的测试会失败，你需要修复它们，所以你还需要留出时间来修复错误，这类似于现实世界的部署过程。
- en: In this book, I’ve aimed to guide you through solving complex interview challenges
    by accompanying you every step of the way. The architecture interview (discussed
    in [*Chapter 12*](B18653_12.xhtml#_idTextAnchor360)) and the coding interview
    are separate interviews that target your development skills from different angles.
    The home assessment is the interview that combines most of your skills.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我旨在通过陪伴你每一步，指导你解决复杂的面试挑战。架构面试（在第[*第12章*](B18653_12.xhtml#_idTextAnchor360)中讨论）和编码面试是针对你的开发技能从不同角度进行的单独面试。家庭评估是结合了你大部分技能的面试。
- en: Excelling in a home assessment
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在家庭评估中表现出色
- en: A **home assessment** is a common interview task many companies use to check
    a candidate’s skills in dealing with a real-world problem. Home assessments require
    us to plan, architect, code, test, and deploy, sometimes with unfamiliar iOS topics
    we have no experience with.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**家庭评估**是许多公司用来检查候选人处理现实世界问题技能的常见面试任务。家庭评估要求我们规划、设计、编码、测试和部署，有时涉及到我们不熟悉的iOS主题。'
- en: Let’s start with analyzing what a home assessment is.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从分析什么是家庭评估开始。
- en: What does a home assessment look like?
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 家庭评估是什么样的？
- en: 'The framework for a regular home assessment won’t come to you as a surprise.
    However, it is still worth going over it so we can be aligned on the process:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正常家庭评估的框架不会让你感到惊讶。然而，仍然值得回顾它，这样我们就可以在流程上达成一致：
- en: '*Assignment*: This is the initial phase where we receive the task, including
    the requirements and instructions.'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*任务分配*：这是初始阶段，我们接收任务，包括要求和说明。'
- en: '*Understanding*: In this stage, we carefully read the instructions and analyze
    the requirements. This is also the phase where we ask the interviewer anything
    we are unclear about and clarify what we must do.'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*理解*：在这个阶段，我们仔细阅读说明并分析要求。这也是我们向面试官询问任何不清楚的问题并澄清我们必须做什么的阶段。'
- en: '*Execution*: This is the current assignment implementation, which typically
    takes place remotely. However, there are instances where it may be carried out
    at the hiring company’s office. This step involves planning and writing our task,
    and if carried out at home, the execution phase may span several days.'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*执行*: 这是当前作业的实现，通常是在远程进行。然而，也有可能在招聘公司的办公室进行。这一步骤包括规划和编写我们的任务，如果在家进行，执行阶段可能持续几天。'
- en: '*Testing*: Once the implementation is complete, we test our solution. That
    includes running test cases and addressing bugs and issues.'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*测试*: 一旦实现完成，我们就测试我们的解决方案。这包括运行测试用例和解决错误和问题。'
- en: '*Submission*: After the testing, we must submit the assignment to the interviewer.
    In most cases, the submission is done using Git for convenience.'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*提交*: 在测试之后，我们必须将作业提交给面试官。在大多数情况下，提交是通过Git来方便完成的。'
- en: '*Post-delivery discussion*: In many companies, the interview is followed by
    a discussion or another interview where the interviewer will review the assessment
    with you to understand the different decisions and approaches taken while doing
    the home assessment.'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*交付后讨论*: 在许多公司，面试之后会有一场讨论或另一场面试，面试官会与你一起回顾评估，以了解在家庭评估过程中所采取的不同决策和做法。'
- en: The exact structure may vary between companies and assessments, but this framework
    provides an understanding of the significant steps involved in the process.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的公司和评估可能有不同的具体结构，但这个框架为我们提供了对过程中涉及的重要步骤的理解。
- en: Now that we know what a home assessment looks like, let’s understand why companies
    choose to spend their and our time on this type of task.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了家庭评估的样子，让我们来理解为什么公司愿意花费他们的时间和我们的时间在这类任务上。
- en: The different skills being tested in a home assessment
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 家庭评估中测试的不同技能
- en: The home assessment examines some skills that are hard to test in the other
    interview stages, primarily the ability to develop an end-to-end app.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 家庭评估检查了一些在其他面试阶段难以测试的技能，主要是开发端到端应用程序的能力。
- en: The skills required for a home assessment are both soft and hard, representing
    what is needed from an iOS developer in real-world situations.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 家庭评估所需的技能既有软技能也有硬技能，代表了iOS开发者在实际情况下所需具备的技能。
- en: 'Most of the skills are what we’ve discussed in previous chapters, but let’s
    list them here so we can be aligned on what the interviewer expects from us:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数技能都是我们在前面的章节中讨论过的，但让我们在这里列出它们，以便我们能够明确面试官对我们有什么期望：
- en: '*Technical proficiency*: We are being tested for our technical skills – Swift,
    frameworks, Xcode, and other tools are all part of the skills we need to master
    as part of the test.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*技术熟练度*: 我们正在接受对我们技术技能的测试——Swift、框架、Xcode和其他工具都是测试中需要掌握的技能的一部分。'
- en: '*Problem solving*: Home assessments check our ability to solve problems and
    break them into smaller, more manageable steps while using our experience and
    creativity. Architecture and app design are part of those skills, which are crucial
    in these kinds of tests.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*问题解决*: 家庭评估检查我们解决问题的能力，并在使用我们的经验和创造力将问题分解成更小、更易于管理的步骤时，这些技能是必不可少的。架构和应用程序设计是这些技能的一部分，在这些类型的测试中至关重要。'
- en: '*Algorithm design:* This may not be as superior a skill as the coding test,
    but it is part of the home assessment. Notice that we have a project, probably
    a tiny app, to develop. Being able to choose suitable data structures and write
    efficient algorithms may be required to solve complex problems and demonstrate
    our knowledge.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*算法设计*: 这可能不如编码测试那样高级，但它也是家庭评估的一部分。请注意，我们有一个项目，可能是一个小程序，需要开发。能够选择合适的数据结构和编写高效的算法可能是解决复杂问题并展示我们知识所必需的。'
- en: '*Attention to detail*: Unlike the other interview steps, in the home assessment,
    we have time. How much time? Enough to provide a good, accurate, and error-free
    solution. So, you see, more time means more expectations of us, and we are tested
    on being able to handle edge cases and complete code.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*注重细节*: 与其他面试步骤不同，在家庭评估中，我们有时间。有多少时间？足够的时间来提供一个好、准确且无错误的解决方案。所以，你看，时间越多，对我们期望就越高，我们也会被测试是否能够处理边缘情况并完成代码。'
- en: '*Code quality*: Our approach to the home assessment needs to resemble a complete
    project in terms of code quality. It means we need to document our code using
    comments, perform testing and QA, choose proper naming conventions, and have an
    organized file structure. Yes, I know it’s a *small* project for an interview.
    But here’s a secret – at this stage, the interviewer already knows we can build
    a table view and set up a Singleton. The quality of the implementation is what
    is important.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代码质量*：我们的家庭评估方法在代码质量方面需要类似于完整项目的样子。这意味着我们需要使用注释来记录代码，进行测试和质量保证，选择合适的命名约定，并拥有有组织的文件结构。我知道，对于一个面试来说，这是一个*小*项目。但这里有一个秘密——在这个阶段，面试官已经知道我们能够构建表格视图并设置单例。实现的质量才是最重要的。'
- en: '*Independence*: One of the best things about home assessments is that they
    allow us to showcase our ability to fulfill a task from end to end, including
    project setup, coding, testing, and deployment, while being observed.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*独立性*：家庭评估的最好之处之一是它们允许我们展示从项目设置、编码、测试到部署的端到端完成任务的能力，同时受到观察。'
- en: Having said that, the different skills required depend on the specific role
    and the company we are interviewing for. At this stage, we should already know
    what the company culture is and what is expected from us.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，所需的不同技能取决于我们申请的具体职位和公司。在这个阶段，我们应该已经了解公司的文化以及对我们有什么期望。
- en: Now, let’s go over some common examples of projects you may encounter in a home
    assessment.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一些家庭评估中可能遇到的项目常见示例。
- en: Going over examples
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查示例
- en: Before moving on, a quick note on how to read these examples. You probably won’t
    encounter one of these examples in an interview, and that’s perfectly fine because
    that is not my intention. The goal of providing these examples is to strengthen
    your skills and make you prepared for the unknown. Unlike iOS interview questions,
    where knowledge matters, a home assessment concerns skills and techniques. That’s
    why I’m trying to emphasize the list of skills and the home assessment process.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，简要说明如何阅读这些示例。你可能不会在面试中遇到这些示例之一，这完全正常，因为那不是我的意图。提供这些示例的目的是加强你的技能，让你为未知做好准备。与iOS面试问题不同，那里的知识很重要，而家庭评估关注的是技能和技术。这就是为什么我要强调技能列表和家庭评估过程。
- en: Each example can teach us a different aspect of the home assessment, and the
    ability to quickly build a small app with a short explanation is crucial for that
    task.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 每个示例都可以教会我们家庭评估的不同方面，而快速构建一个小型应用并提供简短解释的能力对于这项任务至关重要。
- en: 'Let’s go over the examples and pay attention to what’s essential:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下示例，并注意哪些是重要的：
- en: '*Build a to-do list app*: A home assessment focuses on table views, local data
    storage, and state management. Also, typical to-do apps usually support offline
    work and provide a streamlined user experience.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构建待办事项应用*：家庭评估侧重于表格视图、本地数据存储和状态管理。此外，典型的待办事项应用通常支持离线工作并提供流畅的用户体验。'
- en: '*Build a weather app with an engaging user interface and reactive API updates*:
    It’s important to integrate Combine frameworks in this kind of app to provide
    updated information to the user in an elegant design pattern.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构建一个具有吸引人的用户界面和反应式API更新的天气应用*：在这个类型的应用中集成Combine框架很重要，以优雅的设计模式向用户提供更新信息。'
- en: '*Build a photo gallery app*: Photo gallery apps require close work with **PhotoKit**
    (the iOS SDK’s photos framework), working with a collection view while optimizing
    it for fast loading and caching. Also, memory management capabilities are essential
    to handle large amounts of data.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构建照片库应用*：照片库应用需要与**PhotoKit**（iOS SDK的照片框架）紧密合作，同时优化其快速加载和缓存性能。此外，内存管理能力对于处理大量数据至关重要。'
- en: '*Create a social media feed*: A social media feed usually works with a table
    view combined with a pagination pattern. It is vital to provide efficient memory
    management, user interactions such as likes and comments, and image loading as
    part of the feed.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建社交媒体动态*：社交媒体动态通常结合表格视图和分页模式工作。提供有效的内存管理、用户交互（如点赞和评论）以及作为动态一部分的图片加载是至关重要的。'
- en: '*Build a calendar app*: A calendar app requires managing an events list with
    tight integration to the **EventKit** framework (Apple’s framework that helps
    us connect to the calendar), including a table view with a pagination design pattern.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构建日历应用*：日历应用需要管理事件列表，并与**EventKit**框架（帮助我们连接到日历的Apple框架）紧密集成，包括具有分页设计模式的表格视图。'
- en: Each of these assessments requires us to face different challenges, implement
    various design patterns, and tweak the architecture to create an organized project.
    It’s a great mental exercise for your brain, trying to think about the different
    solutions and architectures, and is something that can improve your chances of
    succeeding in the test.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这样的评估都需要我们面对不同的挑战，实现各种设计模式，并调整架构以创建一个有组织的项目。尝试思考不同的解决方案和架构是一项很好的脑力锻炼，可以提高你在测试中成功的机会。
- en: Even though our code results are extremely important, it is important to understand
    that our interviewer is looking at additional aspects of our work – red flags.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的代码结果极其重要，但重要的是要理解我们的面试官正在关注我们工作的其他方面——红旗。
- en: Avoiding red flags
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免红旗
- en: Now that we understand what live coding interviews and home assessments are,
    let’s briefly discuss perfection. Do we have to provide a perfect solution to
    pass the interview? What is the interviewer looking for?
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了现场编码面试和家庭评估是什么，让我们简要讨论一下完美。我们是否必须提供一个完美的解决方案才能通过面试？面试官在寻找什么？
- en: That’s not an easy question as it may differ for various interviewers and companies.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个简单的问题，因为它可能因不同的面试官和公司而异。
- en: 'But there’s something that all interviewers will look out for: red flags. The
    fact that we didn’t provide an optimized solution or didn’t know a particular
    Swift feature can be accepted by many interviewers – in most cases, they are looking
    for signals of something unhealthy in the way we approach, think, and code.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 但所有面试官都会寻找的是：红旗。我们没有提供优化解决方案或不知道特定的Swift功能这一事实，许多面试官可以接受——在大多数情况下，他们寻找的是我们处理、思考和编码方式中不健康信号的迹象。
- en: There are red flags we should avoid, even if they may initially seem insignificant
    to the interview process. Let’s go over some of them now.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些红旗我们应该避免，即使它们在面试过程中可能看起来微不足道。现在让我们简要回顾一些。
- en: Inability to explain or defend a solution
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无法解释或捍卫解决方案
- en: This is a red flag that incorporates two crucial missing skills. The first one
    is *deep thinking and code/design understanding*. Many developers use their memory
    to regurgitate solutions without understanding why and how they work. Passing
    an interview question is not enough; we should also understand why we have done
    what we have done. Now that we are at the end of the book, it is essential to
    go back and validate that we fully understand the different answers and solutions.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个红旗，它包含了两个关键缺失的技能。第一个是*深入思考和代码/设计理解*。许多开发者只是依靠记忆来重复解决方案，而不理解为什么以及它们是如何工作的。通过面试问题是不够的；我们还应该理解我们为什么这样做。现在我们到了书的结尾，回到过去并验证我们是否完全理解了不同的答案和解决方案是至关重要的。
- en: The second skill is *communication and the ability to explain* ourselves. Sometimes
    it is hard to find the right words to describe why we made certain decisions,
    which can be translated into communication skills. But that is what this book
    is for – to help you verbalize your knowledge and get you ready for the interview.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个技能是*沟通和解释能力*。有时很难找到合适的词语来描述我们为什么做出某些决定，这可以转化为沟通技巧。但这就是这本书的目的——帮助你表达你的知识，并为你准备面试。
- en: Dichotomic thinking
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二分法思维
- en: Many interview questions, especially the design, architecture, and coding questions,
    require trade-offs and multiple approaches to be considered. There’s no room for
    black-and-white thinking without explaining the alternative solutions. We should
    always be flexible and understand that there is not always a single correct answer.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 许多面试问题，尤其是设计、架构和编码问题，需要权衡和考虑多种方法。如果不解释替代解决方案，就没有黑白分明的思维空间。我们应该始终灵活，并理解并非总是只有一个正确答案。
- en: Limited error handling
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理有限
- en: While it may sound trivial, ignoring error handling can be perceived as a red
    flag by interviewers, indicating a potentially unhealthy approach. Focusing on
    happy flows suggests a lack of attention to detail and a very shallow level of
    development. Handling code flows that may produce errors and unexpected results
    is significant.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能听起来微不足道，但忽视错误处理可能会被面试官视为红旗，表明可能存在不健康的方法。专注于快乐流程表明缺乏对细节的关注和非常浅薄的开发水平。处理可能产生错误和意外结果的代码流程是重要的。
- en: Poor code quality
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码质量差
- en: Our code is our artwork, and it should look good and express our expertise and
    capabilities as developers. But what does this mean? It means we should make structured
    and organized code with clear naming conventions, including comments and documentation.
    Try to avoid too short and unclear names and add indentations and spaces to your
    code.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码是我们的艺术品，它应该看起来很好，并表达我们作为开发者的专业能力和技能。但这究竟意味着什么？这意味着我们应该编写结构化和有组织的代码，包括注释和文档在内的清晰命名约定。尽量避免使用过短且不清晰的名字，并在你的代码中添加缩进和空格。
- en: Also, good separations, short functions, and folder organization can greatly
    help with our code appearence and clarity. The basics do matter at this stage.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，良好的分离、简短的功能和文件夹组织可以极大地帮助我们改善代码的外观和清晰度。在这个阶段，基础知识确实很重要。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: That’s it! We have reached the finale of the book, and what an exciting journey
    it has been!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们已经到达了这本书的终点，这是一段多么激动人心的旅程！
- en: 'In this concluding chapter, we delved into live coding, home assessments, and
    avoiding red flags. We learned how to tackle a whiteboard task, what to focus
    on when coding, and how to approach this important stage in the process. At this
    point, you should feel prepared to tackle the most experimental stage of the interview
    process: the coding assessment.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章的结尾，我们深入探讨了现场编码、家庭评估和避免红旗。我们学习了如何应对白板任务，编码时应关注什么，以及如何处理这个过程的重要阶段。此时，你应该感到准备充分，去应对面试过程中最实验性的阶段：编码评估。
- en: While the book may have ended, our journey of practice and hard work is just
    beginning. The world of iOS development is vast, and there is always more to learn
    and explore. Each chapter, section, and question has opened the door to numerous
    topics that can help you improve.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这本书可能已经结束，但我们的实践和努力之旅才刚刚开始。iOS 开发的世界广阔无垠，总有更多东西可以学习和探索。每一章、每一节和每一个问题都为你打开了一扇通往众多可以帮助你提升的话题的大门。
- en: So, don’t stop now; you’re just getting started. Embrace continuous learning
    and strive for excellence in your iOS development career.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在不要停下来；你才刚刚开始。拥抱持续学习，并在你的 iOS 开发职业生涯中追求卓越。
