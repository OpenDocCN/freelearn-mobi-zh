- en: Mastering the Building Blocks
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握构建块
- en: The previous chapter explained the basic types that form the building blocks
    of the Swift language. In this chapter, we will build on this knowledge to create
    more complex structures, such as arrays and dictionaries, before moving on and
    looking at some of the little gems Swift offers, such as tuples and typealias.
    Finally, we'll round off this chapter by looking at extensions and access control
    – both of which are key components that contribute to a sound yet efficient codebase.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章解释了构成 Swift 语言基石的基本类型。在本章中，我们将在此基础上创建更复杂的数据结构，如数组和字典，然后再探讨 Swift 提供的一些小宝藏，如元组和
    typealias。最后，我们将通过探讨扩展和访问控制来结束本章，这两者都是对构建稳健且高效的代码库至关重要的组件。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Bundling variables into tuples
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将变量打包成元组
- en: Ordering your data with arrays
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数组对数据进行排序
- en: Containing your data in sets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用集合来存储数据
- en: Storing key-value pairs with dictionaries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字典存储键值对
- en: Subscripts for custom types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义类型的下标
- en: Changing your name with typealias
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 typealias 更改你的名字
- en: Getting property changing notifications using property observers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性观察器获取属性更改通知
- en: Extending functionality with extensions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用扩展扩展功能
- en: Controlling access with access control
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用访问控制来控制访问
- en: Let's get started!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code for this chapter can be found in this book's GitHub repository
    at [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter02](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter02)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码都可以在这本书的 GitHub 仓库中找到：[https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter02](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter02)
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/2YGayJh](https://bit.ly/2YGayJh)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：[https://bit.ly/2YGayJh](https://bit.ly/2YGayJh)
- en: Bundling variables into tuples
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将变量打包成元组
- en: A **tuple** is a combination of two or more values that can be treated as one.
    If you have ever wished you could return more than one value from a function or
    method, you should find tuples very interesting.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**元组**是由两个或更多值组成的组合，可以被视为一个整体。如果你曾经希望从一个函数或方法中返回多个值，你应该会发现元组非常有趣。'
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a new playground and add the following statement:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的游乐场并添加以下语句：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This example uses one function from `Foundation`. We will delve into Foundation
    in more detail in [Chapter 5](a632f18a-5826-4757-90bc-7701c78edaaf.xhtml), *Beyond
    the Standard Library*, but for now, we just need to import it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用 `Foundation` 中的一个函数。我们将在第 5 章“超越标准库”中更详细地探讨 Foundation，但就目前而言，我们只需要导入它。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s imagine that we are building an app that pulls movie ratings from multiple
    sources and presents them together to help the user decide which movie to watch.
    These sources may use different rating systems, such as the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象我们正在构建一个应用程序，该应用程序从多个来源获取电影评分并将它们一起展示，以帮助用户决定看哪部电影。这些来源可能使用不同的评分系统，如下所示：
- en: Number of stars out of 5
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5 星中的星级数量
- en: Points out of 10
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10 分中的得分
- en: Percentage score
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 百分比得分
- en: We want to normalize these ratings so that they can be compared directly and
    displayed side by side. We want all the ratings to be represented as a number
    of stars out of 5, so we will write a function that will return the number of
    whole stars out of 5\. We will then use this to display the correct number of
    stars in our **user interface** (**UI**).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将这些评分标准化，以便可以直接比较并并排显示。我们希望所有评分都表示为 5 星中的星级数量，因此我们将编写一个函数，该函数将返回 5 星中的整星级数。然后我们将使用这个函数来显示用户界面（UI）中正确的星级数量。
- en: 'Our UI also includes a label that will read x Star Movie, where **x** is the
    number of stars. It would be useful if our function returned both the number of
    stars and a string that we can put in the UI. We can use a tuple to do this. Let''s
    get started:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 UI 还包括一个标签，它将读取 x 星电影，其中 **x** 是星级数。如果我们的函数返回星级数和可以放入 UI 的字符串将非常有用。我们可以使用元组来完成这个任务。让我们开始吧：
- en: 'Create a function to normalize the star ratings. The following function takes
    a rating and a total possible rating, and then returns a tuple of the normalized
    rating and a string to display in the UI:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数来标准化星级评分。以下函数接受一个评分和一个可能的总评分，然后返回一个包含标准化评分和用于 UI 显示的字符串的元组：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Inside the function, calculate the fraction of the total score. Then, multiply
    that by our normalized total score, 5, and round it to the nearest whole number:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数内部，计算总分数的分数。然后，将这个分数乘以我们的标准化总分数5，并四舍五入到最接近的整数：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Still within the function, take the rounded fraction and convert it from a
    `Float` into an `Int`. Then, create the display string and return both `Int` and
    `String` as a tuple:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在函数内部，将四舍五入的分数从`Float`转换为`Int`。然后，创建显示字符串，并将`Int`和`String`作为元组返回：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Call our new function and store the result in a constant:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用我们新的函数，并将结果存储在一个常量中：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Retrieve the number of stars rating from the tuple and print the result:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从元组中检索星级评分并打印结果：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Retrieve the display string from the tuple and print the result:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从元组中检索显示字符串并打印结果：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With that, we have created and used a tuple.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就创建并使用了元组。
- en: How it works...
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A tuple is declared as a comma-separated list of the types it contains, within
    brackets. In the preceding code, you can see a tuple being declared as `(Int,
    String)`. The function, `normalizedStarRating`, normalizes the rating and creates
    `numberOfStars` as the closest round number of stars and `ratingString` as a display
    string. These values are then combined into a tuple by putting them, separated
    by a comma, within brackets; that is, `(numberOfStars, ratingString)`. This tuple
    value is then returned by the function.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 元组被声明为一个逗号分隔的类型列表，用括号括起来。在上面的代码中，你可以看到一个被声明为`(Int, String)`的元组。函数`normalizedStarRating`标准化评分，并将`numberOfStars`作为最接近的星级数，`ratingString`作为显示字符串。然后，将这些值通过在括号内用逗号分隔组合成一个元组；即`(numberOfStars,
    ratingString)`。这个元组值随后由函数返回。
- en: 'Next, let''s look at what we can do with that returned tuple value:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们可以用返回的元组值做什么：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Calling our function returns a tuple that we store in a constant called `ratingAndDisplayString`.
    We can access the tuple''s components by accessing the numbered member of the
    tuple:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 调用我们的函数返回一个元组，我们将其存储在一个名为`ratingAndDisplayString`的常量中。我们可以通过访问元组的编号成员来访问元组的组件：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As is the case with most numbered systems in programming languages, the member
    numbering system starts with `0`. The number that's used to identify a certain
    place within a numbered collection is called an index.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数编程语言中的编号系统一样，成员编号系统从`0`开始。用于识别编号集合中某个位置的数字称为索引。
- en: 'There is another way to retrieve the components of a tuple that can be easier
    to remember than the numbered index. By specifying a tuple of variable names,
    each value of the tuple will be assigned to the respective variable names. Due
    to this, we can simplify accessing the tuple values and printing the result:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有另一种方法可以检索元组的组件，这可能比使用编号索引更容易记住。通过指定一个变量名元组，元组的每个值将被分配给相应的变量名。因此，我们可以简化访问元组值和打印结果：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since the numerical value is the first value in the returned tuple, this gets
    assigned to the `nextNumber` constant, while the second value, the string, gets
    assigned to `nextString`. These can then be used like any other constant and removes
    the need to remember which index refers to which value.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数值是返回元组中的第一个值，因此它被分配给`nextNumber`常量，而第二个值，即字符串，被分配给`nextString`。然后，它们可以像任何其他常量一样使用，从而消除了记住哪个索引对应哪个值的需求。
- en: There's more...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'As we mentioned previously, accessing a tuple''s components via a number is
    not ideal as we have to remember their order in the tuple to ensure that we are
    accessing the correct one. To provide some context, we can add labels to the tuple
    components, which can be used to identify them when they are accessed. Tuple labels
    are defined in a similar way to parameter labels, preceding the type and separated
    by a `:`. Let''s add labels to the function we created in this recipe and then
    use those labels to access the tuple values:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，通过数字访问元组的组件并不理想，因为我们必须记住它们在元组中的顺序以确保我们访问的是正确的组件。为了提供一些上下文，我们可以在元组组件上添加标签，这样在访问它们时就可以用来识别。元组标签的定义方式与参数标签类似，位于类型之前，并用冒号分隔。让我们给这个菜谱中创建的函数添加标签，然后使用这些标签来访问元组值：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As part of the function declaration, we can see the tuple being declared:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 作为函数声明的一部分，我们可以看到元组是如何被声明的：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When a tuple of that type is created, the provided values are preceded by the
    label:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建这种类型的元组时，提供的值前面有一个标签：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To access the components of the tuple, we can use these labels (although the
    number of indexes still work):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问元组的组件，我们可以使用这些标签（尽管索引的数量仍然有效）：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tuples are a convenient and lightweight way to bundle values together.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是捆绑值的一种方便且轻量级的方式。
- en: In this example, we created a tuple with two components. However, a tuple can
    contain any number of components.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个包含两个组件的元组。然而，元组可以包含任意数量的组件。
- en: See also
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Further information about tuples can be found in Apple's documentation on the
    Swift language at [https://docs.swift.org/swift-book/ReferenceManual/Types.html](https://docs.swift.org/swift-book/ReferenceManual/Types.html).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 关于元组的更多信息可以在 Apple 的 Swift 语言文档中找到，请参阅[https://docs.swift.org/swift-book/ReferenceManual/Types.html](https://docs.swift.org/swift-book/ReferenceManual/Types.html)。
- en: Ordering your data with arrays
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数组对数据进行排序
- en: 'So far in this book, we have learned about many different Swift constructs:
    **classes**, **structs**, **enums**, **closures**, **protocols**, and **tuples**.
    However, it is rare to deal with just one instance of these on their own. Often,
    we will have many of these constructs, and we need a way to collect multiple instances
    and place them in useful data structures. Over the next few recipes, we will examine
    three collection data structures provided by Swift; that is, **arrays**, **sets**,
    and **dictionaries** (dictionaries are often called **hash tables** in other programming
    languages):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，我们已经学习了多种不同的 Swift 构造：**类**、**结构体**、**枚举**、**闭包**、**协议**和**元组**。然而，单独处理这些构造中的一个实例的情况很少见。通常，我们会拥有许多这样的构造，我们需要一种方法来收集多个实例并将它们放置在有用的数据结构中。在接下来的几个菜谱中，我们将检查
    Swift 提供的三个集合数据结构；即，**数组**、**集合**和**字典**（在其他编程语言中，字典通常被称为**哈希表**）：
- en: '![](img/9466565c-ce50-4e7d-bcae-1107183c6582.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9466565c-ce50-4e7d-bcae-1107183c6582.png)'
- en: Figure 2.1 – Collection of data structures
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 数据结构集合
- en: While doing this, we will look at how to use them to store and access information,
    and then examine their relative characteristics.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在做这件事的时候，我们将看看如何使用它们来存储和访问信息，然后检查它们的相对特性。
- en: Getting started
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始
- en: First, let's investigate **arrays**, which are ordered lists of elements. We
    won't be using any components from the previous recipes, so you can create a new
    playground for this recipe.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们研究**数组**，它们是有序元素列表。我们不会使用之前菜谱中的任何组件，因此你可以为这个菜谱创建一个新的游乐场。
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s use an array to organize a list of movies to watch:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用数组来组织要观看的电影列表：
- en: 'Create an array called `moviesToWatch`. This will hold our strings:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `moviesToWatch` 的数组。这将存储我们的字符串：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Append three movies to the end of our movie list array:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将三部电影追加到我们的电影列表数组末尾：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Print the names of each movie in the list, in turn:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按顺序打印列表中每部电影的名称：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Print a count of the number of movies in the list so far:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印到目前为止列表中电影的数量：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Insert a new movie into the list so that it''s the third one in it. Since arrays
    are zero-based, this is done at index 2:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表中插入一部新电影，使其成为第三个。由于数组是基于0的，这是在索引2处完成的：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Print the list count to check it has increased by one and print the newly updated
    list:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印列表计数以检查它是否增加了1，并打印更新后的新列表：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Use the `first` and `last` array properties to access their respective values
    and print them:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `first` 和 `last` 数组属性访问它们各自的值并打印它们：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Use an index subscript to access the second movie in the list and print it.
    Then, set a new value to that same subscript. Once you''ve done that, print the
    list count to check the number of movies that haven''t changed and print the list
    to check that the second array element has changed:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用索引下标访问列表中的第二部电影并打印它。然后，将新值设置到相同的下标。一旦完成，打印列表计数以检查未更改的电影数量，并打印列表以检查第二个数组元素是否已更改：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a new array of spy movies by initializing it with some movies using
    the array literal syntax:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用数组字面量语法初始化一个新的间谍电影数组：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Combine the two arrays we have created using the addition operator (`+`) and
    assign them back to the `moviesToWatch` variable. Then, print the array count
    so that it reflects the two lists combined and print the new list:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用加法运算符（`+`）将我们创建的两个数组合并，并将它们赋值回 `moviesToWatch` 变量。然后，打印数组计数以反映合并的两个列表，并打印新列表：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, use an array convenience initializer to create an array that contains
    three entries that are the same. Then, update each array element so that the rest
    of their movie titles are shown:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用数组便利初始化器创建一个包含三个相同条目的数组。然后，更新每个数组元素，以便显示其余的电影标题：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s replace part of our existing movie list with our `starWarsTrilogy` list,
    and then print the count and list:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将我们现有的电影列表的一部分替换为我们的 `starWarsTrilogy` 列表，然后打印计数和列表：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Lastly, remove the last movie in the list and check that the array count has
    reduced by one:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，删除列表中的最后一部电影，并检查数组计数是否减少了一个：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With that, we've looked at many ways we can create and manipulate arrays.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就探讨了多种创建和操作数组的方法。
- en: How it works...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When creating an array, we need to specify the type of elements that will be
    stored in the array. The array element type is declared in angular brackets as
    part of the array''s type declaration. In our case, we are storing strings:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建数组时，我们需要指定将存储在数组中的元素类型。数组元素类型在数组的类型声明中用尖括号声明。在我们的例子中，我们存储字符串：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding code uses a Swift language feature called **generics**, which
    can be found in many programming languages, and will be covered in detail in [Chapter
    4](abdc6918-3b36-4495-9c61-f2b9551dd700.xhtml), *Generics, Operators, and Nested
    Types*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码使用了 Swift 语言的一个特性，称为 **泛型**，这在许多编程语言中都可以找到，将在第4章中详细介绍，*泛型、运算符和嵌套类型*。
- en: 'The `append` method of `Array` will add a new element to the end of the array.
    Now that we have put some elements in the array, we can retrieve and print those
    elements:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array` 的 `append` 方法将在数组的末尾添加一个新元素。现在我们已经将一些元素放入数组中，我们可以检索并打印这些元素：'
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Elements in an array are numbered with a zero-based index, so the first element
    in the array is at index 0, the second is at index 1, the third is at index 2,
    and so on. We can access the elements in the array using a subscript, in which
    we provide the index of the element we want to access. A subscript is specified
    in square brackets, after the array instance's name.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的元素使用基于零的索引编号，因此数组中的第一个元素在索引0，第二个在索引1，第三个在索引2，依此类推。我们可以使用下标访问数组中的元素，其中我们提供要访问的元素的索引。下标在数组实例名称后用方括号指定。
- en: 'When an element is accessed using the index subscript, no check is done to
    ensure you have provided a valid index. In fact, if an index is provided that
    the array doesn''t contain, this will cause a crash. Instead, we can use some
    index helper methods on `Array` to ensure that we have an index that is valid
    for this array. Let''s use one of these helper methods to check an index that
    we know is valid for our array, and then another that we know is not valid:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用索引下标访问元素时，不会进行检查以确保你提供了有效的索引。实际上，如果提供了一个数组不包含的索引，这将导致崩溃。相反，我们可以使用 `Array`
    上的某些索引辅助方法来确保我们有一个适用于此数组的有效索引。让我们使用这些辅助方法之一来检查我们已知适用于我们数组的索引，然后使用另一个我们知道不是有效索引的索引：
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `index` method lets us specify the index we want as an offset of the first
    index parameter, but as something that's limited by the last index parameter.
    This will return the valid index if it is within the bounds, or `nil` if it is
    not. By the end of the playground, the `moviesToWatch` array contains six elements,
    in which case retrieving index 5 is successful but index 10 returns `nil`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`index` 方法允许我们指定我们想要的索引作为第一个索引参数的偏移量，但作为受最后一个索引参数限制的偏移量。如果它在范围内，这将返回有效索引，如果不在范围内，则返回
    `nil`。到游乐场结束时，`moviesToWatch` 数组包含六个元素，在这种情况下，检索索引5是成功的，但索引10返回 `nil`。'
- en: In the next chapter, we will cover how to make decisions based on whether this
    index exists, but for now, it's just useful to know that this method is available.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何根据该索引是否存在来做出决策，但到目前为止，了解这种方法可用就足够了。
- en: 'Arrays have a `count` property that tells us how many elements they store.
    So, when we add an element, this value will change:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 数组有一个 `count` 属性，它告诉我们它们存储了多少个元素。因此，当我们添加一个元素时，这个值将改变：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Elements can be inserted anywhere in the array using the same zero-based index
    that we used in the preceding code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用与前面代码中相同的基于零的索引在任何位置插入数组中的元素：
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: So, by inserting `"The Matrix"` at index 2, it will be placed at the third position
    in our array, and all the elements at position 2 or greater will be moved down
    by 1.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过在索引2处插入 `"The Matrix"`，它将被放置在我们数组中的第三个位置，并且索引2或更大的所有元素都将向下移动1位。
- en: 'This increases the array''s count:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这增加了数组的计数：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The array also provides some helpful computed properties for accessing elements
    at either end of the array:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 数组还提供了一些有用的计算属性，用于访问数组的两端元素：
- en: '[PRE33]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: These properties are optional values as the array may be empty, and if it is,
    these will be `nil`. However, accessing an array element via an index subscript
    returns a non-optional value.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性是可选值，因为数组可能为空，如果是这样，这些值将是 `nil`。然而，通过索引下标访问数组元素返回的是一个非可选值。
- en: 'In addition to retrieving values via the subscript, we can also assign values
    to an array subscript:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过下标检索值之外，我们还可以将值赋给数组下标：
- en: '[PRE34]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This will replace the element at the given index with the new value.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这将用新值替换给定索引处的元素。
- en: 'When we created our first array, we created an empty array and then appended
    values to it. Additionally, an array literal can be used to create an array that
    already contains values:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建第一个数组时，我们创建了一个空数组，然后向其中添加了值。此外，还可以使用数组字面量来创建一个已经包含值的数组：
- en: '[PRE35]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'An array type can be specified with the element type enclosed by square brackets,
    and the array literal can be defined by comma-separated elements within square
    brackets. So, we can define an array of integers like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用方括号内的元素类型来指定数组类型，并且可以通过方括号内用逗号分隔的元素来定义数组字面量。因此，我们可以这样定义一个整数数组：
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As we learned in the previous chapter, the compiler can often infer the type
    from the value we assign, and when the type is inferred, we don''t need to specify
    it. In both the preceding arrays, `spyMovieSuggestions` and `fibonacci`, all the
    elements in the array are of the same type; that is, `String` and `Int`, respectively.
    Since these types can be inferred, we don''t need to define them:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中学到的，编译器通常可以从我们分配的值中推断类型，并且当类型被推断时，我们不需要指定它。在前面的两个数组中，`spyMovieSuggestions`
    和 `fibonacci`，数组中的所有元素都是同一类型；即 `String` 和 `Int`，分别。由于这些类型可以推断，我们不需要定义它们：
- en: '[PRE37]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Arrays can be combined using the `+` operator:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `+` 运算符组合数组：
- en: '[PRE38]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This will create a new array by appending the elements in the second array to
    the first.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过将第二个数组中的元素追加到第一个数组中来创建一个新的数组。
- en: 'The array provides a convenience initializer that will fill an array with repeating
    elements. We can use this initializer to create an array with the name of a well-known
    movie trilogy:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 数组提供了一个方便的初始化器，该初始化器将重复元素填充到数组中。我们可以使用这个初始化器来创建一个包含著名电影三部曲名称的数组：
- en: '[PRE39]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can then combine subscript access, string appending, and subscript assignment
    to add the full movie name to our trilogy array:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以结合下标访问、字符串连接和下标赋值，将完整的电影名称添加到我们的三部曲数组中：
- en: '[PRE40]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The array also provides a helper for replacing a range of values with the values
    contained in another array:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 数组还提供了一个辅助函数，用于将一组值替换为另一个数组中的值：
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we have specified a range using `...` to indicate a range between two
    integer values, inclusive of those values. So, this range contains the integers
    2, 3, and 4.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `...` 来指定两个整数值之间的范围，包括这些值。因此，这个范围包含整数2、3和4。
- en: 'We will specify ranges in this way in subsequent chapters. Alternatively, you
    can specify a range that goes up to, but not including, the top of the range.
    This is known as a half-open range:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续章节中，我们将以这种方式指定范围。或者，您可以指定一个范围，该范围向上到但不包括范围的顶部。这被称为半开区间：
- en: '[PRE42]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'For our arrays, we''ve added elements, accessed them, and replaced them, so
    we need to know how to remove elements from an array:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的数组，我们已经添加了元素、访问了它们，并替换了它们，因此我们需要知道如何从数组中删除元素：
- en: '[PRE43]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Provide the index of the element to the `remove` method. By doing this, the
    element at that index will be removed from the array, and all the subsequent elements
    will move up one place to fill the empty space. This will reduce the array''s
    count by 1:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将元素的索引提供给 `remove` 方法。通过这样做，该索引处的元素将从数组中移除，并且所有后续元素将向上移动一个位置以填充空位。这将使数组的计数减少1：
- en: '[PRE44]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: There's more...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you are familiar with Objective-C, you will have used `NSArray`, which provides
    similar functionalities to a Swift array. You may also remember that `NSArray`
    is immutable, which means its contents can''t be changed once it''s been created.
    If you need to change its contents, then an `NSMutableArray` should be used instead.
    Due to this, you may be wondering if Swift has similar concepts of mutable and
    immutable arrays. It does but rather than using separate mutable and immutable
    types, you create a mutable array by declaring it as a variable and an immutable
    array by declaring it as a constant:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 Objective-C，你将使用 `NSArray`，它提供了与 Swift 数组类似的功能。你可能也记得 `NSArray` 是不可变的，这意味着一旦创建，其内容就不能更改。如果你需要更改其内容，则应使用
    `NSMutableArray`。因此，你可能想知道 Swift 是否有类似可变和不可变数组的概念。它确实有，但与使用单独的可变和不可变类型不同，你通过将其声明为变量来创建可变数组，通过将其声明为常量来创建不可变数组：
- en: '[PRE45]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: To understand why this is the case, it's important to know that an array is
    a value type, as are the other collection types in Swift.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么是这样，重要的是要知道数组是一个值类型，Swift 中的其他集合类型也是值类型。
- en: As we saw in the previous chapter, a value type is immutable in nature and creates
    a changed copy whenever it is mutated. Therefore, by assigning the array to a
    constant using `let`, we prevent any new value from being assigned, making mutating
    the array impossible.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，值类型本质上是不可变的，并且每次它被修改时都会创建一个更改后的副本。因此，通过使用 `let` 将数组分配给常量，我们防止了任何新值被分配，这使得修改数组成为不可能。
- en: See also
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Further information about arrays can be found in Apple's documentation on the
    Swift language at [https://developer.apple.com/documentation/swift/array](https://developer.apple.com/documentation/swift/array).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于数组的信息可以在 Apple 的 Swift 语言文档中找到，链接为 [https://developer.apple.com/documentation/swift/array](https://developer.apple.com/documentation/swift/array)。
- en: Arrays use generics to define the element type they contain. Generics will be
    discussed in detail in [Chapter 4](abdc6918-3b36-4495-9c61-f2b9551dd700.xhtml),
    *Generics, Operators, and Nested Types*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 数组使用泛型来定义它们包含的元素类型。泛型将在第 4 章 [Generics, Operators, and Nested Types](abdc6918-3b36-4495-9c61-f2b9551dd700.xhtml)
    中详细讨论。
- en: Containing your data in sets
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在集合中保存你的数据
- en: The next collection type we will look at is a **set**. Sets differ from arrays
    in two important ways. The elements in a set are stored *unordered*, and each
    unique element is only held once. In this recipe, we will learn how to create
    and manipulate sets.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的下一个集合类型是 **集合**。集合与数组在两个重要方面有所不同。集合中的元素是 **无序** 存储的，并且每个唯一的元素只保留一次。在这个菜谱中，我们将学习如何创建和操作集合。
- en: How to do it...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, let''s explore some ways we can create sets and perform set algebra
    on them:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们探索一些我们可以创建集合并在其上执行集合代数的方法：
- en: 'Create an array that contains the first nine Fibonacci numbers, and also a
    set containing the same:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含前九个斐波那契数的数组，以及一个包含相同元素的集合：
- en: '[PRE46]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Print out the number of elements in each collection using the `count` property.
    Despite being created with the same elements, the count value is different:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `count` 属性打印出每个集合中的元素数量。尽管它们是由相同的元素创建的，但计数值是不同的：
- en: '[PRE47]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Insert an element into a set of animals, remove an element, and check whether
    a set contains a given element:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向一个动物集合中插入一个元素，删除一个元素，并检查集合是否包含一个给定的元素：
- en: '[PRE48]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Create some sets containing common mathematical number groups. We will use
    these to explore some methods for set algebra:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包含常见数学数字组的集合。我们将使用这些集合来探索一些集合代数的方法：
- en: '[PRE49]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Obtain the union of two sets and print the result:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取两个集合的并集并打印结果：
- en: '[PRE50]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Obtain the intersection of two sets and print the result:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取两个集合的交集并打印结果：
- en: '[PRE51]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Obtain the symmetric difference of two sets and print the result:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取两个集合的对称差并打印结果：
- en: '[PRE52]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Obtain the result of subtracting one set from another and print the result:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取从另一个集合中减去一个集合的结果并打印结果：
- en: '[PRE53]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Next, we will examine the set membership comparison methods that are available:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将检查可用的集合成员比较方法：
- en: 'Create some sets with overlapping membership:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一些具有重叠成员的集合：
- en: '[PRE54]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Use the `isSubset` method to determine whether one set is a subset of another.
    Then, print the result:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `isSubset` 方法确定一个集合是否是另一个集合的子集。然后，打印结果：
- en: '[PRE55]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Use the `isSuperset` method to determine whether one set is a superset of another.
    Then, print the result:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `isSuperset` 方法确定一个集合是否是另一个集合的超集。然后，打印结果：
- en: '[PRE56]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Use the `isStrictSubset` method to determine whether one set is a strict subset
    of another. Then, print the result:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `isStrictSubset` 方法确定一个集合是否是另一个集合的严格子集。然后，打印结果：
- en: '[PRE57]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Use the `isStrictSuperset` method to determine whether one set is a strict
    superset of another. Then, print the result:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`isStrictSuperset`方法确定一个集合是否是另一个集合的严格超集。然后，打印结果：
- en: '[PRE58]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Use the `isDisjoint` method to determine whether one set is disjointed with
    another. Then, print the result:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`isDisjoint`方法确定一个集合是否与另一个集合不交集。然后，打印结果：
- en: '[PRE59]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How it works...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Sets are created in almost the same way as arrays, and like arrays, we have
    to specify the element type that we will be stored in them:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 集合的创建几乎与数组相同，并且像数组一样，我们必须指定将要存储在其中的元素类型：
- en: '[PRE60]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Arrays and sets store their elements differently. If you provide multiple elements
    of the same value to an array, it will store them multiple times. A set works
    differently; it will only store one version of each unique element. Therefore,
    in the preceding Fibonacci number sequence, the array stores two elements for
    the first two values, `1, 1`, but the set will store this as just one `1` element.
    This leads to the collections having different counts, despite being created with
    the same values:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 数组和集合存储元素的方式不同。如果你向数组提供多个相同值的元素，它将会多次存储它们。集合的工作方式不同；它只会存储每个唯一元素的单一版本。因此，在先前的斐波那契数列中，数组存储了前两个值`1,
    1`的两个元素，但集合只会存储这个`1`元素。这导致集合具有不同的计数，尽管它们是用相同的值创建的：
- en: '[PRE61]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This ability to store elements uniquely is made possible due to a requirement
    that a set has regarding the type of elements it can hold. A set's elements must
    conform to the `Hashable` protocol. This protocol requires a `hashValue` property
    to be provided as an `Int`, and the set uses this `hashValue` to do its uniqueness
    comparison. Both the `Int` and `String` types conform to `Hashable`, but any custom
    types that will be stored in a set will also need to conform to `Hashable`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这种唯一存储元素的能力是由于集合对其可以持有的元素类型的要求。集合的元素必须符合`Hashable`协议。该协议要求提供一个`hashValue`属性作为`Int`，集合使用这个`hashValue`来进行唯一性比较。`Int`和`String`类型都符合`Hashable`，但任何将存储在集合中的自定义类型也需要符合`Hashable`。
- en: A set's `insert`, `remove`, and `contains` methods work as you would expect,
    with the compiler enforcing that the correct types are provided. This compiler
    type checking is done thanks to the **generics** constraints that all the collection
    types have. We will cover generics in more detail in [Chapter 4](abdc6918-3b36-4495-9c61-f2b9551dd700.xhtml),
    *Generics, Operators, and Nested Types*.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 集合的`insert`、`remove`和`contains`方法按预期工作，编译器强制执行提供正确的类型。这种编译器类型检查是通过所有集合类型都具有的泛型约束来完成的。我们将在第4章中更详细地介绍泛型，*泛型、运算符和嵌套类型*。
- en: Union
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并集
- en: 'The `union` method returns a set containing all the unique elements from the
    set that the method is called on, as well as the set that was provided as a parameter:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`union`方法返回一个包含调用该方法时集合的所有唯一元素以及作为参数提供的集合的集合：'
- en: '[PRE62]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The following diagram depicts the Union of Set A and Set B:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了集合A和集合B的并集：
- en: '![](img/59c17cc6-b85a-4ac7-b5a7-b785c46250b0.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/59c17cc6-b85a-4ac7-b5a7-b785c46250b0.png)'
- en: Figure 2.2 – Union of sets
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 集合并集
- en: Intersection
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交集
- en: 'The `intersection` method returns a set of unique elements that were contained
    in both the set that the method was called on and the set that was provided as
    a parameter:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`intersection`方法返回一个集合，其中包含调用该方法时集合和作为参数提供的集合中共同包含的唯一元素：'
- en: '[PRE63]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The following diagram depicts the Intersection of Set A and Set B:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了集合A和集合B的交集：
- en: '![](img/51783c0f-21db-4fd7-9014-e85a1e07c9fb.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/51783c0f-21db-4fd7-9014-e85a1e07c9fb.png)'
- en: Figure 2.3 – Set intersection
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – 集合交集
- en: Symmetric difference
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对称差集
- en: 'The `symmetricDifference` method returns a set of unique elements that are
    in either the set the method is called on, or the set that''s provided as a parameter,
    but not elements that are in both:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`symmetricDifference`方法返回一个集合，其中包含调用该方法时集合或提供的参数集合中的唯一元素，但不包括两个集合都有的元素：'
- en: '[PRE64]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This `set` operation is sometimes referred to as method is so `exclusiveOr`,
    both other programming languages, including previous versions of Swift.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这种`set`操作有时被称为方法，因为在其他编程语言中，包括Swift的早期版本，都称为`exclusiveOr`。
- en: 'The following diagram depicts the Symmetric Difference of Set A and Set B:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了集合A和集合B的对称差集：
- en: '![](img/df2aff4d-ef9d-4390-8b76-4065c892a8ed.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/df2aff4d-ef9d-4390-8b76-4065c892a8ed.png)'
- en: Figure 2.4 – Symmetric difference
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 对称差集
- en: Subtracting
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 减法
- en: 'The `subtracting` method returns a unique set of elements that can be found
    in the set the method was called on, but not in the set that was passed as a parameter.
    Unlike the other set manipulation methods we''ve mentioned, this will not necessarily
    return the same value if you swap the set that the method is called on with the
    set provided as a parameter:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`subtracting` 方法返回一个唯一的元素集合，这些元素可以在调用该方法所在的集合中找到，但不在传递作为参数的集合中。与我们所提到的其他集合操作方法不同，如果您交换调用该方法所在的集合与提供的参数集合，则此方法不一定返回相同的值：'
- en: '[PRE65]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The following diagram depicts the set that''s created by Subtracting Set B
    from Set A:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了从集合A中减去集合B所创建的集合：
- en: '![](img/4a012c09-14cc-4871-a56c-eeefaceb6520.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a012c09-14cc-4871-a56c-eeefaceb6520.png)'
- en: Figure 2.5– Subtracting a set
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5– 减去一个集合
- en: Membership comparison
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 成员比较
- en: In addition to set manipulation methods, there are a number of methods we can
    use to determine information about set membership.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 除了集合操作方法之外，还有一些我们可以用来确定集合成员信息的方法。
- en: 'The `isSubset` method will return true if all the elements in the set that
    the method is called on are contained within the set that''s passed as a parameter:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`isSubset` 方法将在调用该方法所在的集合中的所有元素都包含在传递作为参数的集合中时返回 true：'
- en: '[PRE66]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The following diagram depicts Set B as the subset of Set A:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了集合B是集合A的子集：
- en: '![](img/6e8393bc-3f75-4167-b2a9-7b8838b91fb8.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e8393bc-3f75-4167-b2a9-7b8838b91fb8.png)'
- en: Figure 2.6 – Subset
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 子集
- en: 'This will also return true if the two sets are equal (they contain the same
    elements). If you only want a true value if the set that the method is called
    on is a subset and *not* equal, then you can use `isStrictSubset`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个集合相等（它们包含相同的元素），这也会返回 true。如果您只想在调用该方法所在的集合是子集且不相等时返回 true，则可以使用 `isStrictSubset`：
- en: '[PRE67]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `isSuperset` method will return true if all the elements in the set that
    have been passed as a parameter are within the set that the method is called on:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`isSuperset` 方法将在所有作为参数传递到集合中的元素都包含在调用该方法所在的集合中时返回 true：'
- en: '[PRE68]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The following diagram depicts Set A as the superset of Set B:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了集合A是集合B的超集：
- en: '![](img/b5a19446-b50f-428a-8c8e-08ea715425c0.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5a19446-b50f-428a-8c8e-08ea715425c0.png)'
- en: Figure 2.7 – Superset
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 超集
- en: 'This will also return true if the two sets are equal (they contain the same
    elements). If you only want a true value if the set that the method is called
    on is a superset and not equal, then you can use `isStrictSuperset`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个集合相等（它们包含相同的元素），这也会返回 true。如果您只想在调用该方法所在的集合是超集且不相等时返回 true，则可以使用 `isStrictSuperset`：
- en: '[PRE69]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The `isDisjoint` method will return true if there are no common elements between
    the set that the method is called on and the set that was passed as a parameter:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`isDisjoint` 方法将在调用该方法所在的集合和传递作为参数的集合之间没有共同元素时返回 true：'
- en: '[PRE70]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The following diagram shows that Set A and Set B are disjoint:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示表明集合A和集合B是互斥的：
- en: '![](img/d287cfca-139b-4ee9-b258-15d8ad631be0.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d287cfca-139b-4ee9-b258-15d8ad631be0.png)'
- en: Figure 2.8 – Disjoint
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 互斥
- en: 'As with arrays, a set can be declared immutable by assigning it to a `let`
    constant instead of a `var` variable:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，可以通过将其分配给 `let` 常量而不是 `var` 变量来声明集合为不可变：
- en: '[PRE71]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This is because a set, like the other collection types, is a value type. Removing
    an element would mutate the set, which creates a new copy, but a `let` constant
    can't have a new value assigned to it, so the compiler prevents any mutating operations.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为集合，就像其他集合类型一样，是一个值类型。移除一个元素将修改集合，这会创建一个新的副本，但 `let` 常量不能分配新的值，因此编译器会阻止任何修改操作。
- en: See also
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Further information about arrays can be found in Apple's documentation on the
    Swift language at [https://docs.swift.org/swift-book/LanguageGuide/CollectionTypes.html](https://docs.swift.org/swift-book/LanguageGuide/CollectionTypes.html).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组的更多信息可以在苹果公司关于Swift语言的文档中找到，请参阅[https://docs.swift.org/swift-book/LanguageGuide/CollectionTypes.html](https://docs.swift.org/swift-book/LanguageGuide/CollectionTypes.html)。
- en: Sets use generics to define the element types they contain. Generics will be
    discussed in detail in [Chapter 4](abdc6918-3b36-4495-9c61-f2b9551dd700.xhtml),
    *Generics, Operators, and Nested Types*.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 集合使用泛型来定义它们包含的元素类型。泛型将在第4章中详细讨论，*泛型、运算符和嵌套类型*。
- en: Storing key-value pairs with dictionaries
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用字典存储键值对
- en: The last collection type we will look at is the **dictionary**. This is a familiar
    construct in programming languages, where it is sometimes referred to as a **hash
    table**. A dictionary holds a collection of pairings between a key and a value.
    The **key** can be any element that conforms to the `Hashable` protocol (just
    like elements in a set), while the **value** can be any type. The contents of
    a dictionary is not stored in order, unlike an array; instead, the *key* is used
    both when storing a value and as a lookup when retrieving a value.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的最后一种集合类型是**字典**。这是编程语言中的一个熟悉的结构，有时被称为**哈希表**。字典包含键和值之间的配对集合。**键**可以是符合`Hashable`协议的任何元素（就像集合中的元素一样），而**值**可以是任何类型。字典的内容不是按顺序存储的，与数组不同；相反，*键*在存储值和检索值时都使用。
- en: Getting ready
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will use a dictionary to store details of people at a place
    of work. We need to store and retrieve a person's information based on their role
    in the organization, such as a company directory. To hold this person's information,
    we will use a modified version of our `Person` class from [Chapter 1](f9d48715-ffca-464f-95bf-722958f02e72.xhtml),
    *Swift Building Blocks*.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用字典来存储工作场所的人员详细信息。我们需要根据人员在组织中的角色（例如公司目录）来存储和检索个人信息。为了保存此人的信息，我们将使用从[第1章](f9d48715-ffca-464f-95bf-722958f02e72.xhtml)，“Swift构建块”中修改过的`Person`类。
- en: 'Enter the following code into a new playground:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码输入到一个新的游乐场中：
- en: '[PRE72]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: How to do it...
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s use the `Person` object we defined previously to build up our workplace
    directory using a dictionary:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用之前定义的`Person`对象，通过字典构建我们的工作场所目录：
- en: 'Create a `Dictionary` for the employee directory:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个员工目录的`Dictionary`：
- en: '[PRE73]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Populate the dictionary with employee details:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用员工详细信息填充字典：
- en: '[PRE74]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Retrieve an array of all the keys in the dictionary. This will give us an array
    of all the roles in the organization:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取字典中所有键的数组。这将给我们一个包含组织中所有角色的数组：
- en: '[PRE75]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Use a key to retrieve one of the employees and print the result:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用键检索一名员工并打印结果：
- en: '[PRE76]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Replace a value in the dictionary by assigning a new value against an existing
    key. The previous value for the key is discarded when a new value is set:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过对现有键分配新值来替换字典中的值。当设置新值时，将丢弃该键的旧值：
- en: '[PRE77]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: With that, we have learned how to create, populate, and look up values in a
    dictionary.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经学会了如何创建、填充和查找字典中的值。
- en: How it works...
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As with the other collection types, when we create a dictionary, we need to
    provide the types that the dictionary will be holding. For dictionaries, there
    are two types that we need to define. The first is the type of the key (which
    must conform to `Hashable`), while the second is the type of the value being stored
    against the key. For our dictionary, we are using `String` for the key and `Person`
    for the values being stored:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他集合类型一样，当我们创建一个字典时，我们需要提供字典将持有的类型。对于字典，我们需要定义两种类型。第一种是键的类型（必须符合`Hashable`），第二种是存储在键上的值的类型。对于我们的字典，我们使用`String`作为键，`Person`作为存储的值：
- en: '[PRE78]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'As with an array, we can specify a `dictionary` type using square brackets
    and create one using a dictionary literal, where `:` separates the key and the
    value:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，我们可以使用方括号指定`dictionary`类型，并使用字典字面量创建一个，其中`:`分隔键和值：
- en: '[PRE79]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Therefore, we can change our dictionary definition so that it looks like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以更改我们的字典定义，使其看起来像这样：
- en: '[PRE80]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The `[:]` symbol denotes an empty dictionary as a dictionary literal.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`[:]`符号表示一个空字典作为字典字面量。'
- en: 'Elements are added to a dictionary using a subscript. Unlike an array, which
    takes an `Int` index in the subscript, a dictionary takes the key and then pairs
    the given value with the given key. In the following example, we are assigning
    a `Person` object to the `"Captain"` key:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 使用下标向字典中添加元素。与数组不同，数组在下标中使用`Int`索引，而字典使用键，然后将给定的值与给定的键配对。在以下示例中，我们将一个`Person`对象分配给`"Captain"`键：
- en: '[PRE81]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: If no value currently exists, the assigned value will be added. If a value already
    exists for the given key, the old value will be replaced with the new value and
    the old value will be discarded.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前不存在值，则将分配的值添加。如果给定键已存在值，则旧值将被新值替换，并且旧值将被丢弃。
- en: 'There are properties on the dictionary that provide all the keys and values.
    These properties are of a custom collection type that can be passed to an array
    initializer to create an array:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 字典上有一些属性提供了所有的键和值。这些属性是自定义集合类型，可以传递给数组初始化器以创建一个数组：
- en: '[PRE82]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: To display all the dictionary's keys, as provided by the `keys` property, we
    can either create an array or iterate over the collection directly. We will cover
    iterating over a collection's values in the next chapter, so for now, we will
    create an array.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示字典的所有键，如`keys`属性所提供的，我们可以创建一个数组或直接迭代集合。我们将在下一章中介绍迭代集合的值，所以现在我们将创建一个数组。
- en: 'Next, we will use one of the values from an array of keys, alongside the crew,
    to retrieve full details about the associated `Person`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用数组中的一个键值，与船员一起检索关联的`Person`的完整详细信息：
- en: '[PRE83]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We get the first element using the `first` property, but since this is an optional
    type, we need to force unwrap it using `!`. We can pass `firstRole`, which is
    now a non-optional `String` to the dictionary subscript, to get the `Person` object
    associated with that key. The return type for retrieving the value via subscript
    is also optional, so it also needs to be force unwrapped before we print its values.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`first`属性获取第一个元素，但由于这是一个可选类型，我们需要使用`!`来强制解包。我们可以将`firstRole`传递给字典下标，它现在是一个非可选的`String`，以获取与该键关联的`Person`对象。通过下标检索值的返回类型也是可选的，因此在我们打印其值之前也需要强制解包。
- en: '**Force unwrapping** is usually an unsafe thing to do since if we force unwrap
    a value that turns out to be `nil`, our code will crash. We advise you to check
    that a value isn''t `nil` before unwrapping the optional. We will cover how to
    do this in the next chapter.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**强制解包**通常是不安全的事情，因为如果我们强制解包一个最终是`nil`的值，我们的代码将会崩溃。我们建议你在解包可选值之前检查该值不是`nil`。我们将在下一章中介绍如何做到这一点。'
- en: There's more...
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this recipe, we used strings as the keys for our dictionary. However, we
    can also use a type that conforms to the `Hashable` protocol.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用了字符串作为字典的键。然而，我们也可以使用符合`Hashable`协议的类型。
- en: One downside of using `String` as a key for our employee directory is that it
    is very easy to mistype an employee's role or look for a role that you expect
    to exist but doesn't. So, we can improve our implementation by using something
    that conforms to `Hashable` and is better suited to being used as a key in our
    model.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`String`作为员工目录的键的一个缺点是，很容易误输入员工的职位或查找一个你期望存在但实际上不存在的职位。因此，我们可以通过使用符合`Hashable`协议并且更适合作为模型中键的东西来改进我们的实现。
- en: 'We have a finite set of employee roles in our model, and an **enumeration**
    is perfect for representing a finite number of options, so let''s define our roles
    as an enum:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模型中，我们有一组有限的员工职位，枚举是表示有限数量选项的完美选择，所以让我们将我们的角色定义为枚举：
- en: '[PRE84]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now, let''s change our `Dictionary` definition so that it uses this new `enum`
    as a key, and then insert our employees using these `enum` values:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们改变我们的`字典`定义，使其使用这个新的`枚举`作为键，然后插入我们的员工，使用这些`枚举`值：
- en: '[PRE85]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: You will also need to change all the other uses of `crew` so that they use the
    new enum-based key.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要更改所有其他使用`crew`的地方，使它们使用新的基于枚举的键。
- en: 'Let''s take a look at how and why this works. We created `Role` as a `String`-based
    enum:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何以及为什么这样工作的。我们创建了一个基于`String`的`Role`枚举：
- en: '[PRE86]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Defining it in this way has two benefits:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式定义有两个好处：
- en: We intend to display these roles to the user, so we will need a string representation
    of the `Role` enum, regardless of how we defined it.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们打算向用户显示这些职位，所以我们需要一个`Role`枚举的字符串表示形式，无论我们如何定义它。
- en: Enums have a little bit of protocol and generics magic in them, which means
    that if an enum is backed by a type that implements the `Hashable` protocol (as
    `String` does), the enum also automatically implements the `Hashable` protocol.
    Therefore, defining `Role` as being String-based satisfies the dictionary requirement
    of a key being `Hashable` without us having to do any extra work.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举中包含一点协议和泛型魔法，这意味着如果一个枚举由实现`Hashable`协议的类型（如`String`）支持，那么枚举也会自动实现`Hashable`协议。因此，将`Role`定义为基于字符串的枚举，满足了字典对键必须是`Hashable`的要求，而无需我们做任何额外的工作。
- en: 'With our `crew` dictionary now defined as having a Role-based key, all subscript
    operations have to use a value in the role enum:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的`crew`字典现在定义为基于`Role`键，所有下标操作都必须使用角色枚举中的值：
- en: '[PRE87]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The compiler enforces this, so it's no longer possible to use an incorrect role
    when interacting with our employee directory. This pattern of using Swift's constructs
    and type system to enforce the correct use of your code is something we should
    strive to do, as it can reduce bugs and prevent our code from being used in unexpected
    ways.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器强制执行此操作，因此在与我们的员工目录交互时不再可能使用不正确的角色。使用Swift的构造和类型系统来强制正确使用你的代码是我们应该努力做到的，因为它可以减少错误并防止我们的代码以意外的方式被使用。
- en: See also
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Further information about dictionaries can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/collections](http://swiftbook.link/docs/collections).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 关于字典的更多信息可以在苹果公司关于Swift语言的文档中找到，请参阅[http://swiftbook.link/docs/collections](http://swiftbook.link/docs/collections)。
- en: Subscripts for custom types
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义类型的下标
- en: By using collection types, we have seen that their elements are accessed through
    subscripts. However, it's not just collection types that can have subscripts;
    your own custom types can provide subscript functionality too.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用集合类型，我们已经看到它们的元素是通过下标访问的。然而，不仅仅是集合类型可以有下标；你的自定义类型也可以提供下标功能。
- en: Getting ready
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will create a simple game of *tic-tac-toe*, also known as
    *Noughts and Crosses*. To do this, we need a three-by-three grid of positions,
    with each position being filled by either a nought from Player 1, a cross from
    Player 2, or nothing. We can store these positions in an array of arrays.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个简单的井字棋游戏，也称为“圈叉游戏”。为此，我们需要一个三行三列的位置网格，每个位置由玩家1的零、玩家2的叉或空位填充。我们可以将这些位置存储在数组数组中。
- en: 'The initial game setup code uses the concepts we''ve already covered in this
    book, so we won''t go into its implementation. Enter the following code into a
    new playground so that we can see how subscripts can improve its usage:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 初始游戏设置代码使用了我们在本书中已经介绍的概念，所以我们将不会深入其实现。将以下代码输入到一个新的游乐场中，以便我们可以看到下标如何改进其使用：
- en: '[PRE88]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: How to do it...
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s run through how we can use the tic-tac-toe game defined previously,
    as well as how we can improve how it is used, using a subscript. We will also
    examine how this works:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下如何使用之前定义的井字棋游戏，以及如何使用下标改进其使用方式。我们还将检查这是如何工作的：
- en: 'Let''s create an instance of our `TicTacToe` grid:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个`TicTacToe`网格的实例：
- en: '[PRE89]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'For a player to make a move, we need to change the `GridPosition` value that''s
    been assigned to the relevant place in the array of arrays. This is used to store
    the grid positions. Player 1 will place a nought in the middle position of the
    grid, which would be row position 1, column position 1 (since it''s a zero-based
    array):'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要让玩家进行移动，我们需要更改分配给数组中相关位置的`GridPosition`值。这用于存储网格位置。玩家1将在网格中间位置放置一个零，这将位于行位置1，列位置1（因为它是基于零的数组）：
- en: '[PRE90]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Next, Player 2 places their cross in the top-right position, which is row position
    0, column position 2:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，玩家2将他们的叉放在右上角的位置，这是行位置0，列位置2：
- en: '[PRE91]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: We can make moves in our game. We can do this by adding information directly
    to the `gridStorage` array, which isn't ideal. The player shouldn't need to know
    how the moves are stored, and we should be able to change how we store the game
    information without having to change how the moves are made. To solve this, let's
    create a subscript of our game struct so that making a move in the game is just
    like assigning a value to an array.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在游戏中进行移动。我们可以通过直接向`gridStorage`数组添加信息来实现这一点，但这并不理想。玩家不需要知道移动是如何存储的，而且我们应该能够更改存储游戏信息的方式，而无需更改移动方式。为了解决这个问题，让我们创建游戏结构体的下标，以便在游戏中进行移动就像为数组赋值一样。
- en: 'Add the following subscript method to the `TicTacToe` struct:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下下标方法添加到`TicTacToe`结构体中：
- en: '[PRE92]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'So, now, we can change how each player makes their move and finish the game:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，现在我们可以改变每个玩家如何移动并完成游戏：
- en: '[PRE93]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Just like when using an array, we can use a subscript to access the value,
    as well as assign a value to it:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像使用数组一样，我们可以使用下标来访问值，以及为其赋值：
- en: '[PRE94]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: How it works...
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Subscript functionality can be defined within a class, struct, or enum, or
    declared within a protocol as a requirement. To do this, we can define `subscript`
    (which is a reserved keyword that activates the required functionality) with input
    parameters and an output type:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 下标功能可以在类、结构体或枚举中定义，也可以在协议中声明为要求。为此，我们可以定义`subscript`（这是一个保留关键字，用于激活所需功能），并带有输入参数和输出类型：
- en: '[PRE95]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'This subscript definition works like a computed property, where `get` can be
    defined to allow you to access values through `subscript` and `set` can be defined
    to assign values using `subscript`:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `subscript` 定义的工作方式就像是一个计算属性，其中 `get` 可以定义为允许你通过 `subscript` 访问值，而 `set`
    可以定义为使用 `subscript` 分配值：
- en: '[PRE96]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Any number of input parameters can be defined, and these should be provided
    as comma-separated values in the subscript:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 可以定义任意数量的输入参数，并且这些参数应以逗号分隔的值在 `subscript` 中提供：
- en: '[PRE97]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: There's more...
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Just like parameters defined in a function, `subscript` parameters can have
    additional labels. If defined, these become required at the call site, so the
    `subscript` we added can alternatively be defined as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在函数中定义的参数一样，`subscript` 参数可以有额外的标签。如果定义了，这些标签在调用位置是必需的，因此我们添加的 `subscript`
    可以定义为以下形式：
- en: '[PRE98]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'In this case, when using the `subscript`, we would also provide the labels
    in the `subscript`:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当使用 `subscript` 时，我们还会在 `subscript` 中提供标签：
- en: '[PRE99]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: See also
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Further information about subscripts can be found in Apple's documentation on
    the Swift language at [http://swiftbook.link/docs/subscripts](http://swiftbook.link/docs/subscripts).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 关于下标的更多信息可以在苹果关于 Swift 语言的文档中找到，请参阅 [http://swiftbook.link/docs/subscripts](http://swiftbook.link/docs/subscripts)。
- en: Changing your name with typealias
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `typealias` 更改名称
- en: The `typealias` declaration allows you to create an alias for a type (and is
    therefore pretty accurately named!). You can specify a name that can be used in
    place of any given type of definition. If this type is quite complex, a typeAlias
    can be a useful way to simplify its use.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`typealias` 声明允许你为类型创建别名（因此它的命名非常准确！）。你可以指定一个可以用来替代任何给定类型定义的名称。如果这个类型相当复杂，`typealias`
    可以是一种简化其使用的方法。'
- en: How to do it...
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will use a typealias to replace an array definition:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `typealias` 来替换数组定义：
- en: 'First, let''s create something we can store in an array. In this instance,
    let''s create a `Pug` struct:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一些可以存储在数组中的东西。在这个例子中，让我们创建一个 `Pug` 结构体：
- en: '[PRE100]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Now, we can create an array that will contain instances of a `Pug` struct:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个数组，它将包含 `Pug` 结构体的实例：
- en: '[PRE101]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: As you may or may not know, the collective noun for a group of pugs is called
    a **grumble**.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能知道也可能不知道，一群哈巴狗的集体名词叫做 **grumble**。
- en: 'We can set up a `typealias` to define an array of pugs as a `Grumble`:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以设置一个 `typealias` 来定义哈巴狗数组为 `Grumble`：
- en: '[PRE102]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'With this defined, we can substitute `Grumble` wherever we would use `[Pug]`
    or `Array<Pug>`:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义之后，我们可以在任何使用 `[Pug]` 或 `Array<Pug>` 的地方替换为 `Grumble`：
- en: '[PRE103]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'However, this isn''t some new type – it is just an array with all the same
    functionalities:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，这并不是某种新型别——它只是一个具有所有相同功能的数组：
- en: '[PRE104]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: There's more...
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The preceding example allows us to use types in a more natural and expressive
    way. In addition, we can use a `typealias` to simplify a more complex type that
    may be used in multiple places.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例使我们能够以更自然和表达的方式使用类型。此外，我们可以使用 `typealias` 来简化可能在多个地方使用的更复杂类型。
- en: 'To see how this might be useful, we can partially build an object to fetch
    program information:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这可能有什么用，我们可以部分构建一个对象来获取节目信息：
- en: '[PRE105]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'In the `ProgrammeFetcher` object, we have two methods that take a channel and
    a result handler closure. The result handler closure has the following definition.
    We have to define this twice; once for each method:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ProgrammeFetcher` 对象中，我们有两个方法，它们接受一个频道和一个结果处理闭包。结果处理闭包具有以下定义。我们必须为每个方法定义两次：
- en: '[PRE106]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Instead, we can define this closure definition with a `typealias` called `FetchResultHandler`
    and replace each method definition with a reference to this `typealias`:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以使用名为 `FetchResultHandler` 的 `typealias` 来定义这个闭包定义，并用这个 `typealias` 的引用替换每个方法定义：
- en: '[PRE107]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Not only does this save us from defining the closure type twice, but it is also
    a better description of the function that the closure performs.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅这使我们免于两次定义闭包类型，而且它也是对闭包执行的功能的更好描述。
- en: 'Using `typealias` doesn''t affect how we provide closure to the method:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `typealias` 并不影响我们向方法提供闭包的方式：
- en: '[PRE108]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: See also
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Further information about typealias can be found in Apple's documentation on
    the Swift language at [http://swiftbook.link/docs/declarations](http://swiftbook.link/docs/declarations).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `typealias` 的更多信息可以在苹果关于 Swift 语言的文档中找到，请参阅 [http://swiftbook.link/docs/declarations](http://swiftbook.link/docs/declarations)。
- en: Getting property changing notifications using property observers
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用属性观察器获取属性更改通知
- en: It's common to want to know when a property's value changes. Perhaps you want
    to update the value of another property or update some user interface element.
    In Objective-C, this was often accomplished by writing your own getter and setter
    or using **Key-Value Observing** (**KVO**), but in Swift, we have native support
    for property observers.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 想要知道属性值何时发生变化是很常见的。可能你想要更新另一个属性的值或更新一些用户界面元素。在 Objective-C 中，这通常是通过编写自己的 getter
    和 setter 或使用 **键值观察**（**KVO**）来实现的，但在 Swift 中，我们有了对属性观察器的原生支持。
- en: Getting ready
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To examine property observers, we should create an object with a property that
    we want to observe. Let''s create an object that manages users and a property
    that holds the current user''s name:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查属性观察器，我们应该创建一个具有我们想要观察的属性的物体。让我们创建一个管理用户和包含当前用户名的属性的物体：
- en: '[PRE109]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: We want to present some friendly messages when the current user changes. We'll
    use property observers to do this.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当当前用户更改时，我们想要显示一些友好的消息。我们将使用属性观察器来完成这个任务。
- en: How to do it...
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s get started:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'Amend the `currentUserName` property definition so that it looks as follows:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `currentUserName` 属性定义，使其看起来如下：
- en: '[PRE110]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Create an instance of `UserManager` and change the current username. This will
    generate friendly messages:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `UserManager` 的实例并更改当前用户名。这将生成友好的消息：
- en: '[PRE111]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: How it works...
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Property observers can be added within curly brackets after the property declaration,
    and there are two types: `willSet` and `didSet`.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 属性观察器可以添加在属性声明之后的括号内，并且有两种类型：`willSet` 和 `didSet`。
- en: 'The `willSet` observer will be called before the property is set and provides
    the value that will be set on the property. This new value can be given a name
    within brackets; for example, `newUserName`:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`willSet` 观察器将在属性设置之前调用，并提供将要设置在属性上的值。这个新值可以在括号内命名；例如，`newUserName`：'
- en: '[PRE112]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The `didSet` observer will be called after the property is set and provides
    the value that the property had before being set. This old value can be given
    a name within brackets; for example, `oldUserName`:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`didSet` 观察器将在属性设置后调用，并提供属性设置之前的值。这个旧值可以在括号内命名；例如，`oldUserName`：'
- en: '[PRE113]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: There's more...
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The new value and old value that are passed into the property observers have
    implicit names, so there is no need to explicitly name them. The `willSet` observer
    is passed a value with an implicit name of `newValue`, and the `didSet` observer
    is passed a value with an implicit name of `oldValue`.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给属性观察器的新值和旧值具有隐含的名称，因此没有必要显式地命名它们。`willSet` 观察器传递一个具有隐含名称 `newValue` 的值，而
    `didSet` 观察器传递一个具有隐含名称 `oldValue` 的值。
- en: 'Therefore, we can remove our explicit names and use the implicit value names:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以移除显式名称并使用隐含值名称：
- en: '[PRE114]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: See also
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: Further information about property observers can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/properties](http://swiftbook.link/docs/properties).
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于属性观察器的信息可以在 Apple 的 Swift 语言文档中找到，请参阅[http://swiftbook.link/docs/properties](http://swiftbook.link/docs/properties)。
- en: Extending functionality with extensions
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用扩展扩展功能
- en: Extensions let us add functionality to our existing classes, structs, enums,
    and protocols. This can be especially useful when the original type is provided
    by an external framework, which means you aren't able to add functionality directly.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展让我们能够向现有的类、结构体、枚举和协议添加功能。当原始类型由外部框架提供时，这特别有用，这意味着你无法直接添加功能。
- en: Getting ready
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Imagine that we often need to obtain the first word from a given string. Rather
    than repeatedly writing the code to split the string into words and then retrieving
    the first word, we can extend the functionality of `String` to provide its own
    first word.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们经常需要从一个给定的字符串中获取第一个单词。而不是反复编写将字符串拆分为单词并检索第一个单词的代码，我们可以扩展 `String` 的功能以提供它自己的第一个单词。
- en: How to do it...
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s get started:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'Create an extension of `String`:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `String` 的扩展：
- en: '[PRE115]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Within the extension''s curly brackets, add a function that returns the first
    word from the string:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在扩展的括号内添加一个返回字符串中第一个单词的函数：
- en: '[PRE116]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Now, we can use this new method on `String` to get the first word from a phrase:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用这个新的方法在 `String` 上获取短语中的第一个单词：
- en: '[PRE117]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: How it works...
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We can define an extension using the `extension` keyword and then specify the
    type we want to extend. The implementation of this extension is defined within
    curly brackets:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `extension` 关键字定义一个扩展，然后指定我们想要扩展的类型。这个扩展的实现定义在大括号内：
- en: '[PRE118]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Methods and computed properties can be defined in extensions in the same way
    that they can be defined within classes, structs, and enums. Here, we will add
    a `firstWord` function to the `String` struct:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 方法和计算属性可以在扩展中定义，就像它们可以在类、结构体和枚举中定义一样。在这里，我们将向 `String` 结构体添加一个 `firstWord` 函数：
- en: '[PRE119]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The implementation of the `firstWord` method is not important for this recipe,
    so we'll just touch on it briefly.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`firstWord` 方法的实现对于这个食谱来说并不重要，所以我们只是简要地提及它。'
- en: 'In Swift, `String` is a collection, so we can use the collection methods to
    find the first index of an empty space. However, this could be `nil` since the
    string may contain only one word or no characters at all, so if the index is `nil`,
    we must use the `endIndex` instead. The nil coalescing operator (`??`) is only
    used to assign `endIndex` if `firstIndex(of: " ")` is `nil`. More generally, it
    will evaluate the value on the left-hand side of the operator, unless it is `nil`,
    in which case it will assign the value on the right-hand side.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '在 Swift 中，`String` 是一个集合，因此我们可以使用集合方法来找到空格的第一个索引。然而，这可能是 `nil`，因为字符串可能只包含一个单词或没有任何字符，所以如果索引是
    `nil`，我们必须使用 `endIndex`。nil 合并操作符（`??`）仅用于在 `firstIndex(of: " ")` 是 `nil` 时分配
    `endIndex`。更一般地说，它将评估操作符左侧的值，除非它是 `nil`，在这种情况下，它将分配操作符右侧的值。'
- en: Then, we use the index of the first space to retrieve the substring up to the
    index, which has a `SubString` type. We then use that to create and return a `String`.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用第一个空格的索引来检索直到该索引的子字符串，它具有 `SubString` 类型。然后我们使用它来创建并返回一个 `String`。
- en: 'Extensions can implement anything that uses the existing functionality, but
    they can''t store information in a new property. Therefore, computed properties
    can be added, but stored properties cannot. Let''s change our `firstWord` method
    so that it''s a computed property instead:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展可以实现使用现有功能的一切，但不能在新的属性中存储信息。因此，可以添加计算属性，但不能添加存储属性。让我们将 `firstWord` 方法改为计算属性：
- en: '[PRE120]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: There's more...
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Extensions can also be used to add protocol conformance, so let''s create a
    protocol that we want to add conformance to:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展也可以用来添加协议符合性，所以让我们创建一个我们想要添加符合性的协议：
- en: 'The protocol declares that something can be represented as an `Int`:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 协议声明某物可以表示为 `Int`：
- en: '[PRE121]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'We can extend `Int` and have it conform to `IntRepresentable` by returning
    itself:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将 `Int` 扩展并使其符合 `IntRepresentable`，通过返回其自身：
- en: '[PRE122]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Next, we''ll extend `String`, and we''ll use an `Int` constructor that takes
    a `String` and returns an `Int` if our `String` contains digits that represent
    an integer:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将扩展 `String`，并使用一个接受 `String` 并返回 `Int` 的 `Int` 构造函数，如果我们的 `String` 包含表示整数的数字：
- en: '[PRE123]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'We can also extend our own custom types and add conformance to the same protocol,
    so let''s create an `enum` that can be `IntRepresentable`:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以扩展我们自己的自定义类型，并添加对同一协议的符合性，所以让我们创建一个可以 `IntRepresentable` 的 `enum`：
- en: '[PRE124]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Since our enum is Int-based, we can conform to `IntRepresentable` by providing
    a `rawValue`:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的枚举基于 `Int`，我们可以通过提供 `rawValue` 来符合 `IntRepresentable`：
- en: '[PRE125]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'We now have `String`, `Int`, and `CrewComplement` all conforming to `IntRepresentable`,
    and since we didn''t define `String` or `Int`, we have only been able to add conformance
    through the use of extensions. This common conformance allows us to treat them
    as the same type:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`String`、`Int` 和 `CrewComplement` 都符合 `IntRepresentable`，由于我们没有定义 `String`
    或 `Int`，我们只能通过使用扩展来添加符合性。这种共同的符合性允许我们将它们视为相同类型：
- en: '[PRE126]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: The preceding example includes the use of `compactMap` and the ternary operator,
    which haven't been covered in this book. Further information can be found in the
    *See also* section.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例中包含了 `compactMap` 和三元操作符的使用，这些在本章中尚未介绍。更多信息可以在 *参见* 部分找到。
- en: See also
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Further information about extensions can be found in Apple's documentation on
    the Swift language at [http://swiftbook.link/docs/extensions](http://swiftbook.link/docs/extensions).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 关于扩展的更多信息可以在 Apple 的 Swift 语言文档中找到，请参阅 [http://swiftbook.link/docs/extensions](http://swiftbook.link/docs/extensions)。
- en: The documentation for `compactMap` can be found at [https://developer.apple.com/documentation/swift/sequence/2950916-compactmap](https://developer.apple.com/documentation/swift/sequence/2950916-compactmap).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '`compactMap` 的文档可以在[https://developer.apple.com/documentation/swift/sequence/2950916-compactmap](https://developer.apple.com/documentation/swift/sequence/2950916-compactmap)找到。'
- en: Further information about the ternary operator can be found at [https://docs.swift.org/swift-book/LanguageGuide/BasicOperators.html#ID71](https://docs.swift.org/swift-book/LanguageGuide/BasicOperators.html#ID71).
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 关于三元运算符的更多信息可以在[https://docs.swift.org/swift-book/LanguageGuide/BasicOperators.html#ID71](https://docs.swift.org/swift-book/LanguageGuide/BasicOperators.html#ID71)找到。
- en: Controlling access with access control
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用访问控制控制访问
- en: Swift provides fine-grained access control, allowing you to specify the visibility
    that your code has to other areas of code. This enables you to be deliberate about
    the interface you provide to other parts of the system, thus encapsulating implementation
    logic and helping separate the areas of concern.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 提供了细粒度的访问控制，允许你指定你的代码对其他代码区域的可见性。这使你可以有意识地决定提供给系统其他部分的接口，从而封装实现逻辑并帮助分离关注点。
- en: 'Swift has five access levels:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 有五个访问级别：
- en: '**Private**: Only accessible within the existing scope (defined by curly brackets)
    or extensions in the same file.'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有**：只能在现有作用域（由大括号定义）或同一文件中的扩展内访问。'
- en: '**File private**: Accessible to anything in the same file, but nothing outside
    the file.'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件私有**：同一文件中的任何内容都可以访问，但文件外部的内容则不能。'
- en: '**Internal**: Accessible to anything in the same module, but nothing outside
    the module.'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部**：同一模块中的任何内容都可以访问，但模块外的内容则不能。'
- en: '**Public**: Accessible both inside and outside the module, but cannot be subclassed
    or overwritten outside of the defining module.'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公开**：在模块内部和外部都可以访问，但不能在定义模块之外进行子类化或重写。'
- en: '**Open**: Accessible everywhere, with no restrictions in terms of its use,
    and can therefore be subclassed and overwritten.'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公开**：在所有地方都可以访问，使用上没有限制，因此可以被子类化和重写。'
- en: These can be applied to types, properties, and functions.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以应用于类型、属性和函数。
- en: Getting ready
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To explore each of these access levels, we need to step outside our playground
    comfort zone and create a module. To have something that will hold our module
    and a playground that can use it, we will need to create an Xcode workspace:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索这些访问级别中的每一个，我们需要走出我们的游乐场舒适区并创建一个模块。为了有一个可以包含我们的模块以及可以使用它的游乐场，我们需要创建一个 Xcode
    工作区：
- en: 'In Xcode, select File | New | Workspace... from the menu:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Xcode 中，从菜单中选择文件 | 新 | 工作区...：
- en: '![](img/382a9997-8a62-4b03-82d8-ee46ffc86cb5.png)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/382a9997-8a62-4b03-82d8-ee46ffc86cb5.png)'
- en: Figure 2.9 – Xcode – New project
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – Xcode – 新项目
- en: 'Give your workspace a name, such as `AccessControl`, and choose a save location.
    You will now see an empty workspace:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给你的工作区起一个名字，例如 `AccessControl`，并选择一个保存位置。你现在将看到一个空的工作区：
- en: '![](img/e19c4f3f-0822-4566-a963-c85eb82bf34a.png)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e19c4f3f-0822-4566-a963-c85eb82bf34a.png)'
- en: Figure 2.10 – Xcode – New project structure
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 – Xcode – 新项目结构
- en: In this workspace, we need to create a module. To illustrate the access controls
    that are available, let's have our module represent something that tightly controls
    which information it exposes, and which information it keeps hidden. One thing
    that fits this definition is Apple; that is, the company.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个工作区中，我们需要创建一个模块。为了说明可用的访问控制，让我们让我们的模块代表一个紧密控制其暴露哪些信息以及隐藏哪些信息的实体。符合这个定义的一个例子是苹果公司；即，这家公司。
- en: 'Create a new project from the Xcode menu by selecting File | New | Project...:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从 Xcode 菜单中选择文件 | 新 | 项目...来创建一个新项目：
- en: '![](img/98ddc071-6982-47f5-b48d-81b953112ed3.png)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/98ddc071-6982-47f5-b48d-81b953112ed3.png)'
- en: Figure 2.11 – New project
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 – 新项目
- en: 'From the template selector, select Framework:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从模板选择器中选择框架：
- en: '![](img/7099a811-ebef-4327-a2f3-028dcbeeed78.png)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7099a811-ebef-4327-a2f3-028dcbeeed78.png)'
- en: Figure 2.12 – New project framework
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 – 新项目框架
- en: 'Name the project `AppleInc`:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目命名为 `AppleInc`：
- en: '![](img/6fdc3f65-3799-4641-9595-0a65abfcca43.png)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6fdc3f65-3799-4641-9595-0a65abfcca43.png)'
- en: Figure 2.13 – Naming the project
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13 – 命名项目
- en: 'Choose a location. Then, at the bottom of the window, ensure that Add to: has
    been set to the workspace we just created:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个位置。然后，在窗口底部，确保“添加到”已设置为刚刚创建的工作区：
- en: '![](img/ead95109-a886-435d-801c-185500b3605f.png)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ead95109-a886-435d-801c-185500b3605f.png)'
- en: Figure 2.14 – New project workspace group
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14 – 新项目工作区组
- en: 'Now that we have a module, let''s set up a playground to use it in. From the
    Xcode menu, select File | New | Playground...:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经有一个模块了，让我们设置一个游乐场来使用它。从Xcode菜单中选择File | New | Playground...：
- en: '![](img/a804521f-f114-4011-887b-73fcb4aa093c.png)'
  id: totrans-461
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a804521f-f114-4011-887b-73fcb4aa093c.png)'
- en: Figure 2.15 – New playground
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15 – 新的游乐场
- en: 'Give the playground a name and save it to a location:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给游乐场起一个名字并将其保存到位置：
- en: '![](img/f392ab21-7d05-4a4c-9ff1-e4a826bfb62b.png)'
  id: totrans-464
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f392ab21-7d05-4a4c-9ff1-e4a826bfb62b.png)'
- en: Figure 2.16 – New project
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16 – 新项目
- en: This playground will not be added to the workspace automatically; you will need
    to locate the playground you just created and drag it into the file explorer pane
    on the left-hand side of your workspace.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此游乐场将不会自动添加到工作区中；您需要找到您刚刚创建的游乐场并将其拖放到工作区左侧的文件资源管理器窗格中。
- en: 'Press the run button on the Xcode toolbar to build the `AppleInc` module:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Xcode工具栏上按运行按钮来构建`AppleInc`模块：
- en: '![](img/5aac1934-f7bf-4178-a60b-3b85db9563f9.png)'
  id: totrans-468
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5aac1934-f7bf-4178-a60b-3b85db9563f9.png)'
- en: Figure 2.17 – Xcode toolbar
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17 – Xcode工具栏
- en: 'Select the playground from the file navigator and add an import statement to
    the top of the file:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文件导航器中选择游乐场，并将导入语句添加到文件顶部：
- en: '[PRE127]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: We are now ready to look into the different access controls that are available.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以查看可用的不同访问控制。
- en: How to do it...
  id: totrans-473
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s investigate the most restrictive of the access controls: `private`.
    Structures marked as `private` are only visible within the scope of the type they
    have been defined in, as well as any extensions of that type that are located
    in the same file. We know that Apple has super-secret areas where it works on
    its new products, so let''s create one:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调查最限制性的访问控制：`private`。标记为`private`的结构仅在其定义的类型的作用域内可见，以及位于同一文件中的该类型的任何扩展。我们知道苹果有超级秘密的区域，在那里它正在开发新产品，因此让我们创建一个：
- en: Select the `AppleInc` group in the file navigator and create a new file by selecting
    File | New | File... from the menu. Let's call it `SecretProductDepartment`.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件导航器中选择`AppleInc`组，然后从菜单中选择File | New | File...来创建一个新文件。让我们称它为`SecretProductDepartment`。
- en: 'In this new file, create a `SecretProductDepartment` class using the `private`
    access control:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个新文件中，使用`private`访问控制创建一个`SecretProductDepartment`类：
- en: '[PRE128]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Next, let's look at the `fileprivate` access control. Structures marked as `fileprivate`
    are only visible within the file that they are defined in, so a collection of
    related structures defined in the same file will be visible to each other, but
    anything outside the file will not see these structures.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`fileprivate`访问控制。标记为`fileprivate`的结构仅在其定义的文件内部可见，因此同一文件中定义的相关结构集合将相互可见，但文件外部的内容将看不到这些结构。
- en: When you buy an iPhone from the Apple Store, it's not made in-store; it's made
    in a factory that the public doesn't have access to. So, let's model this using
    `fileprivate`.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在苹果商店购买iPhone时，它不是在店内制造的；它是在公众无法访问的工厂制造的。因此，让我们使用`fileprivate`来模拟这一点。
- en: 'Create a new file called `AppleStore`. Then, create structures for `AppleStore`
    and `Factory` using the `fileprivate` access control:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`AppleStore`的新文件。然后，使用`fileprivate`访问控制创建`AppleStore`和`Factory`的结构：
- en: '[PRE129]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: To investigate the `public` access control, we will be defining something that
    is visible outside the defining module but cannot be subclassed or overridden.
    Apple itself is the perfect candidate to model this behavior as certain parts
    of it are visible to the public. However, it closely guards its image and brand,
    so *subclassing* Apple to alter and customize it will not be allowed.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 要调查`公共`访问控制，我们将定义一些在定义模块外部可见但不能进行子类化或覆盖的东西。苹果本身是模拟这种行为的完美候选者，因为它的某些部分对公众可见。然而，它非常重视其形象和品牌，因此不允许对苹果进行子类化以进行更改和定制。
- en: 'Create a new file called `Apple` and create a class for Apple that uses the
    `public` access control:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Apple`的新文件，并为苹果创建一个使用`public`访问控制的类：
- en: '[PRE130]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Lastly, we have the `open` access control. Structures defined as `open` are
    available outside the module and can be subclassed and overridden without restriction.
    To explain this last control, we want to model something that exists within Apple's
    domain but is completely open and free from restrictions. So, for this, we can
    use the Swift language itself!
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`开放`访问控制。被定义为`开放`的结构可以在模块外部使用，并且可以无限制地进行子类化和覆盖。为了解释这种最后的控制，我们想要模拟苹果领域内存在但完全开放且不受限制的东西。因此，为此，我们可以使用Swift语言本身！
- en: Swift has been open sourced by Apple, so while they maintain the project, the
    source code is fully available for others to take, modify, and improve.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 已经被苹果开源，因此尽管他们维护该项目，源代码对其他人来说是完全可用的，他们可以获取、修改和改进。
- en: 'Create a new file called `SwiftLanguage` and create a class for the Swift language
    that uses the `open` access control:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `SwiftLanguage` 的新文件，并创建一个使用 `open` 访问控制的 Swift 语言类：
- en: '[PRE131]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: We now have a module that uses Swift's access controls to provide interfaces
    that match our model and provide the appropriate visibility.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个模块，它使用 Swift 的访问控制来提供与我们的模型相匹配的接口，并提供适当的可见性。
- en: How it works...
  id: totrans-490
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s examine our `SecretProductDepartment` class to see how its visibility
    matches our model:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查我们的 `SecretProductDepartment` 类，看看它的可见性是如何与我们的模型相匹配的：
- en: '[PRE132]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: The `SecretProductDepartment` class is declared without an access control keyword,
    and when no access control is specified, the default control of `internal` is
    applied. Since we want the secret product department to be visible within Apple,
    but not from outside Apple, this is the correct access control to use.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '`SecretProductDepartment` 类没有声明访问控制关键字，当没有指定访问控制时，默认控制为 `internal`。由于我们希望秘密产品部门在苹果公司内部可见，但不在苹果公司外部可见，这是正确的访问控制方式。'
- en: 'The two properties of the `secretCodeWord` and `secretProducts` classes are
    marked as private, thus hiding their values and existence from anything outside
    the `SecretProductDepartment` class. To see this restriction in action, add the
    following to the same file, but outside the class:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '`secretCodeWord` 和 `secretProducts` 类的两个属性被标记为私有，因此隐藏了它们的值和存在性，使其无法从 `SecretProductDepartment`
    类外部访问。要查看此限制的实际效果，请将以下内容添加到同一文件中，但位于类外部：'
- en: '[PRE133]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: When you try to build the module, you are told that `secretCodeWord` can't be
    accessed due to the `private` protection level.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试构建模块时，你会被告知由于 `private` 保护级别，无法访问 `secretCodeWord`。
- en: 'While these properties are not directly accessible, we can provide an interface
    that allows the information to be provided in a controlled way. This is what the
    `nextProduct` method provides:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些属性不能直接访问，但我们可以提供一个接口，以受控的方式提供信息。这正是 `nextProduct` 方法提供的：
- en: '[PRE134]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: If the correct codeword is passed, it will provide the name of the next product
    from the secret department, but the details of all other products, and the codeword
    itself, will be hidden. Since this method doesn't have a specified access control,
    it is set to the default of `internal`.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递了正确的密码词，它将提供秘密部门的下一个产品的名称，但所有其他产品的细节以及密码词本身都将被隐藏。由于此方法没有指定访问控制，它被设置为默认的
    `internal`。
- en: It's not possible for contents within a structure to have a more permissive
    access control than the structure itself. For instance, we can't define the `nextProduct`
    method as being `public` because this is more permissive than the class it is
    defined in, which is only `internal`.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 结构内的内容不能比结构本身有更宽松的访问控制。例如，我们不能将 `nextProduct` 方法定义为 `public`，因为这比定义它的类（仅 `internal`）更宽松。
- en: Thinking about it, this is the obvious outcome as you cannot create an instance
    of an internal class outside of the defining module, so how can you possibly call
    a method on a class instance that you can't even create?
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 想想看，这是显而易见的结果，因为你不能在定义模块之外创建内部类的实例，那么你怎么可能调用一个你甚至无法创建的类的实例上的方法呢？
- en: 'Next, let''s look at the `AppleStore.swift` file we created. The purpose here
    is to provide people outside of Apple with the ability to purchase an iPhone through
    the Apple Store, but to restrict the creation of iPhones to just the factories
    where they are built, and then restrict access to those factories to just the
    Apple Store:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们创建的 `AppleStore.swift` 文件。这里的目的是让苹果公司以外的人能够通过苹果商店购买 iPhone，但将 iPhone
    的创建限制在它们被制造的工厂，然后仅将访问权限限制在苹果商店：
- en: '[PRE135]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Since we want to be able to sell iPhones outside of the `AppleInc` module, the
    `DeviceModel` enum and the `AppleiPhone` and `AppleStore` classes are all declared
    as `public`. This has the benefit of making them available outside the module
    but preventing them from being subclassed or modified. Given how Apple protects
    the look and feel of their phones and stores, this seems correct for this model.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望能够在 `AppleInc` 模块外部销售 iPhone，因此 `DeviceModel` 枚举以及 `AppleiPhone` 和 `AppleStore`
    类都被声明为 `public`。这有利于使它们在模块外部可用，但防止它们被继承或修改。考虑到苹果对其手机和商店的外观和感觉的保护，这似乎是正确的模型。
- en: 'The Apple Store needs to get their iPhones from somewhere; that is, from the
    factory:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果商店需要从某处获取他们的 iPhone；也就是说，从工厂：
- en: '[PRE136]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: By making the `Factory` class `fileprivate`, it is only visible within this
    file, which is perfect because we only want the Apple Store to be able to use
    the factory to create iPhones.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 `Factory` 类声明为 `fileprivate`，它只在本文件中可见，这是完美的，因为我们只想让苹果商店能够使用工厂来创建 iPhone。
- en: 'We have also restricted the iPhone''s initialization method so that it can
    only be accessed from structures in this file:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还限制了 iPhone 的初始化方法，使其只能从本文件中的结构体访问：
- en: '[PRE137]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: The resulting iPhone is public, but only structures within this file can create
    iPhone class objects in the first place. In this case, this is done by the factory.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 结果生成的 iPhone 是 `public` 的，但只有本文件中的结构体才能首先创建 iPhone 类对象。在这种情况下，这是由工厂完成的。
- en: 'Next, let''s look at the `Apple.swift` file:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `Apple.swift` 文件：
- en: '[PRE138]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The preceding code made both the `Person` and `Apple` classes public, along
    with the `newEmployee` method. This allows new employees to join the company.
    The CEO, however, is defined as both public and private:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使 `Person` 和 `Apple` 类以及 `newEmployee` 方法都变为 `public`，这允许新员工加入公司。然而，CEO
    被定义为既是 `public` 也是 `private`：
- en: '[PRE139]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: We can define a separate, more restrictive, access control for setting a property
    than the one that was set for getting it. This has the effect of making it a read-only
    property from outside the defining structure. This provides the access we require
    since we want the CEO to be visible outside of the `AppleInc` module, but we want
    to only be able to change the CEO from within Apple.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为设置属性定义一个比获取属性时设置的更严格的单独访问控制。这会使它从定义结构外部成为一个只读属性。这提供了我们所需要的访问权限，因为我们希望 CEO
    在 `AppleInc` 模块外部可见，但我们只想从苹果内部更改 CEO。
- en: 'The final access control is `open`. We applied this to the `SwiftLanguage`
    class:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的访问控制是 `open`。我们将其应用于 `SwiftLanguage` 类：
- en: '[PRE140]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: By declaring the class and methods as `open`, we are allowing them to be subclassed,
    overridden, and modified by anyone, including those outside the `AppleInc` module.
    With the Swift language being fully open source, this matches what we are trying
    to achieve.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将类和方法声明为 `open`，我们允许任何人（包括 `AppleInc` 模块外的人）对其进行子类化、重写和修改。由于 Swift 语言是完全开源的，这符合我们想要实现的目标。
- en: There's more...
  id: totrans-519
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'With our module fully defined, let''s see how things look from outside the
    module. We need to build the module to make it available to the playground. Select
    the playground; it should contain a statement that imports the `AppleInc` module:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模块完全定义后，让我们看看模块外部的样子。我们需要构建模块以使其在 playground 中可用。选择 playground；它应该包含一个导入
    `AppleInc` 模块的语句：
- en: '[PRE141]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'First, let''s look at the most accessible class that we created; that is, `SwiftLanguage`.
    Let''s subclass the `SwiftLanguage` class and override its behavior:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们创建的最易访问的类；那就是 `SwiftLanguage`。让我们对 `SwiftLanguage` 类进行子类化并重写其行为：
- en: '[PRE142]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Since `SwiftLanguage` is `open`, we can subclass it to add more supported platforms
    and increase its version number.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `SwiftLanguage` 是 `open` 的，我们可以通过它来创建子类，以添加更多支持的平台并增加其版本号。
- en: 'Next, let''s create an instance of the `Apple` class and see how we can interact
    with it:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建 `Apple` 类的一个实例并看看我们如何与之交互：
- en: '[PRE143]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: We can create `Person` and provide it to Apple as a new employee since the `Person`
    class and the `newEmployee` method are declared as public. We can retrieve information
    about the CEO, but we aren't able to set a new CEO as we defined the property
    as `private (set)`.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Person` 类和 `newEmployee` 方法被声明为 `public`，我们可以创建 `Person` 并将其提供给苹果作为新员工。我们可以获取关于
    CEO 的信息，但无法设置新的 CEO，因为我们定义的属性为 `private (set)`。
- en: 'Another one of the public interfaces `selliPhone` provided by the module allows
    us to buy an iPhone from the Apple Store:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 模块提供的另一个公共接口 `selliPhone` 允许我们从苹果商店购买 iPhone：
- en: '[PRE144]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: We can retrieve a new iPhone from the Apple Store because we declared the `selliPhone`
    method as `public`. However, we can't create a new iPhone directly since the iPhone's
    `init` method is declared as `fileprivate`.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从苹果商店获取一个新的 iPhone，因为我们声明了 `selliPhone` 方法为 `public`。然而，我们无法直接创建一个新的 iPhone，因为
    iPhone 的 `init` 方法被声明为 `fileprivate`。
- en: See also
  id: totrans-531
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考也
- en: Further information about access control can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/access-control](http://swiftbook.link/docs/access-control).
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于访问控制的信息可以在苹果关于 Swift 语言的文档中找到，请参阅 [http://swiftbook.link/docs/access-control](http://swiftbook.link/docs/access-control)。
