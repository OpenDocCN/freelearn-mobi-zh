- en: Mastering the Building Blocks
  prefs: []
  type: TYPE_NORMAL
- en: The previous chapter explained the basic types that form the building blocks
    of the Swift language. In this chapter, we will build on this knowledge to create
    more complex structures, such as arrays and dictionaries, before moving on and
    looking at some of the little gems Swift offers, such as tuples and typealias.
    Finally, we'll round off this chapter by looking at extensions and access control
    â€“ both of which are key components that contribute to a sound yet efficient codebase.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Bundling variables into tuples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ordering your data with arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containing your data in sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing key-value pairs with dictionaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscripts for custom types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing your name with typealias
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting property changing notifications using property observers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending functionality with extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling access with access control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code for this chapter can be found in this book's GitHub repository
    at [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter02](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter02)
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/2YGayJh](https://bit.ly/2YGayJh)'
  prefs: []
  type: TYPE_NORMAL
- en: Bundling variables into tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **tuple** is a combination of two or more values that can be treated as one.
    If you have ever wished you could return more than one value from a function or
    method, you should find tuples very interesting.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new playground and add the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This example uses one function from `Foundation`. We will delve into Foundation
    in more detail in [Chapter 5](a632f18a-5826-4757-90bc-7701c78edaaf.xhtml), *Beyond
    the Standard Library*, but for now, we just need to import it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s imagine that we are building an app that pulls movie ratings from multiple
    sources and presents them together to help the user decide which movie to watch.
    These sources may use different rating systems, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Number of stars out of 5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Points out of 10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Percentage score
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to normalize these ratings so that they can be compared directly and
    displayed side by side. We want all the ratings to be represented as a number
    of stars out of 5, so we will write a function that will return the number of
    whole stars out of 5\. We will then use this to display the correct number of
    stars in our **user interface** (**UI**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our UI also includes a label that will read x Star Movie, where **x** is the
    number of stars. It would be useful if our function returned both the number of
    stars and a string that we can put in the UI. We can use a tuple to do this. Let''s
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a function to normalize the star ratings. The following function takes
    a rating and a total possible rating, and then returns a tuple of the normalized
    rating and a string to display in the UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the function, calculate the fraction of the total score. Then, multiply
    that by our normalized total score, 5, and round it to the nearest whole number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Still within the function, take the rounded fraction and convert it from a
    `Float` into an `Int`. Then, create the display string and return both `Int` and
    `String` as a tuple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Call our new function and store the result in a constant:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieve the number of stars rating from the tuple and print the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieve the display string from the tuple and print the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With that, we have created and used a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A tuple is declared as a comma-separated list of the types it contains, within
    brackets. In the preceding code, you can see a tuple being declared as `(Int,
    String)`. The function, `normalizedStarRating`, normalizes the rating and creates
    `numberOfStars` as the closest round number of stars and `ratingString` as a display
    string. These values are then combined into a tuple by putting them, separated
    by a comma, within brackets; that is, `(numberOfStars, ratingString)`. This tuple
    value is then returned by the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s look at what we can do with that returned tuple value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling our function returns a tuple that we store in a constant called `ratingAndDisplayString`.
    We can access the tuple''s components by accessing the numbered member of the
    tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As is the case with most numbered systems in programming languages, the member
    numbering system starts with `0`. The number that's used to identify a certain
    place within a numbered collection is called an index.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another way to retrieve the components of a tuple that can be easier
    to remember than the numbered index. By specifying a tuple of variable names,
    each value of the tuple will be assigned to the respective variable names. Due
    to this, we can simplify accessing the tuple values and printing the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Since the numerical value is the first value in the returned tuple, this gets
    assigned to the `nextNumber` constant, while the second value, the string, gets
    assigned to `nextString`. These can then be used like any other constant and removes
    the need to remember which index refers to which value.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned previously, accessing a tuple''s components via a number is
    not ideal as we have to remember their order in the tuple to ensure that we are
    accessing the correct one. To provide some context, we can add labels to the tuple
    components, which can be used to identify them when they are accessed. Tuple labels
    are defined in a similar way to parameter labels, preceding the type and separated
    by a `:`. Let''s add labels to the function we created in this recipe and then
    use those labels to access the tuple values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As part of the function declaration, we can see the tuple being declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When a tuple of that type is created, the provided values are preceded by the
    label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the components of the tuple, we can use these labels (although the
    number of indexes still work):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Tuples are a convenient and lightweight way to bundle values together.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we created a tuple with two components. However, a tuple can
    contain any number of components.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about tuples can be found in Apple's documentation on the
    Swift language at [https://docs.swift.org/swift-book/ReferenceManual/Types.html](https://docs.swift.org/swift-book/ReferenceManual/Types.html).
  prefs: []
  type: TYPE_NORMAL
- en: Ordering your data with arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far in this book, we have learned about many different Swift constructs:
    **classes**, **structs**, **enums**, **closures**, **protocols**, and **tuples**.
    However, it is rare to deal with just one instance of these on their own. Often,
    we will have many of these constructs, and we need a way to collect multiple instances
    and place them in useful data structures. Over the next few recipes, we will examine
    three collection data structures provided by Swift; that is, **arrays**, **sets**,
    and **dictionaries** (dictionaries are often called **hash tables** in other programming
    languages):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9466565c-ce50-4e7d-bcae-1107183c6582.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 â€“ Collection of data structures
  prefs: []
  type: TYPE_NORMAL
- en: While doing this, we will look at how to use them to store and access information,
    and then examine their relative characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let's investigate **arrays**, which are ordered lists of elements. We
    won't be using any components from the previous recipes, so you can create a new
    playground for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s use an array to organize a list of movies to watch:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an array called `moviesToWatch`. This will hold our strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Append three movies to the end of our movie list array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the names of each movie in the list, in turn:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Print a count of the number of movies in the list so far:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert a new movie into the list so that it''s the third one in it. Since arrays
    are zero-based, this is done at index 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the list count to check it has increased by one and print the newly updated
    list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `first` and `last` array properties to access their respective values
    and print them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Use an index subscript to access the second movie in the list and print it.
    Then, set a new value to that same subscript. Once you''ve done that, print the
    list count to check the number of movies that haven''t changed and print the list
    to check that the second array element has changed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new array of spy movies by initializing it with some movies using
    the array literal syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Combine the two arrays we have created using the addition operator (`+`) and
    assign them back to the `moviesToWatch` variable. Then, print the array count
    so that it reflects the two lists combined and print the new list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, use an array convenience initializer to create an array that contains
    three entries that are the same. Then, update each array element so that the rest
    of their movie titles are shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s replace part of our existing movie list with our `starWarsTrilogy` list,
    and then print the count and list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, remove the last movie in the list and check that the array count has
    reduced by one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: With that, we've looked at many ways we can create and manipulate arrays.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When creating an array, we need to specify the type of elements that will be
    stored in the array. The array element type is declared in angular brackets as
    part of the array''s type declaration. In our case, we are storing strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses a Swift language feature called **generics**, which
    can be found in many programming languages, and will be covered in detail in [Chapter
    4](abdc6918-3b36-4495-9c61-f2b9551dd700.xhtml), *Generics, Operators, and Nested
    Types*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `append` method of `Array` will add a new element to the end of the array.
    Now that we have put some elements in the array, we can retrieve and print those
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Elements in an array are numbered with a zero-based index, so the first element
    in the array is at index 0, the second is at index 1, the third is at index 2,
    and so on. We can access the elements in the array using a subscript, in which
    we provide the index of the element we want to access. A subscript is specified
    in square brackets, after the array instance's name.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an element is accessed using the index subscript, no check is done to
    ensure you have provided a valid index. In fact, if an index is provided that
    the array doesn''t contain, this will cause a crash. Instead, we can use some
    index helper methods on `Array` to ensure that we have an index that is valid
    for this array. Let''s use one of these helper methods to check an index that
    we know is valid for our array, and then another that we know is not valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `index` method lets us specify the index we want as an offset of the first
    index parameter, but as something that's limited by the last index parameter.
    This will return the valid index if it is within the bounds, or `nil` if it is
    not. By the end of the playground, the `moviesToWatch` array contains six elements,
    in which case retrieving index 5 is successful but index 10 returns `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover how to make decisions based on whether this
    index exists, but for now, it's just useful to know that this method is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays have a `count` property that tells us how many elements they store.
    So, when we add an element, this value will change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Elements can be inserted anywhere in the array using the same zero-based index
    that we used in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: So, by inserting `"The Matrix"` at index 2, it will be placed at the third position
    in our array, and all the elements at position 2 or greater will be moved down
    by 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'This increases the array''s count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The array also provides some helpful computed properties for accessing elements
    at either end of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: These properties are optional values as the array may be empty, and if it is,
    these will be `nil`. However, accessing an array element via an index subscript
    returns a non-optional value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to retrieving values via the subscript, we can also assign values
    to an array subscript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This will replace the element at the given index with the new value.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we created our first array, we created an empty array and then appended
    values to it. Additionally, an array literal can be used to create an array that
    already contains values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'An array type can be specified with the element type enclosed by square brackets,
    and the array literal can be defined by comma-separated elements within square
    brackets. So, we can define an array of integers like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'As we learned in the previous chapter, the compiler can often infer the type
    from the value we assign, and when the type is inferred, we don''t need to specify
    it. In both the preceding arrays, `spyMovieSuggestions` and `fibonacci`, all the
    elements in the array are of the same type; that is, `String` and `Int`, respectively.
    Since these types can be inferred, we don''t need to define them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Arrays can be combined using the `+` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This will create a new array by appending the elements in the second array to
    the first.
  prefs: []
  type: TYPE_NORMAL
- en: 'The array provides a convenience initializer that will fill an array with repeating
    elements. We can use this initializer to create an array with the name of a well-known
    movie trilogy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then combine subscript access, string appending, and subscript assignment
    to add the full movie name to our trilogy array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The array also provides a helper for replacing a range of values with the values
    contained in another array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have specified a range using `...` to indicate a range between two
    integer values, inclusive of those values. So, this range contains the integers
    2, 3, and 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will specify ranges in this way in subsequent chapters. Alternatively, you
    can specify a range that goes up to, but not including, the top of the range.
    This is known as a half-open range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'For our arrays, we''ve added elements, accessed them, and replaced them, so
    we need to know how to remove elements from an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Provide the index of the element to the `remove` method. By doing this, the
    element at that index will be removed from the array, and all the subsequent elements
    will move up one place to fill the empty space. This will reduce the array''s
    count by 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are familiar with Objective-C, you will have used `NSArray`, which provides
    similar functionalities to a Swift array. You may also remember that `NSArray`
    is immutable, which means its contents can''t be changed once it''s been created.
    If you need to change its contents, then an `NSMutableArray` should be used instead.
    Due to this, you may be wondering if Swift has similar concepts of mutable and
    immutable arrays. It does but rather than using separate mutable and immutable
    types, you create a mutable array by declaring it as a variable and an immutable
    array by declaring it as a constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: To understand why this is the case, it's important to know that an array is
    a value type, as are the other collection types in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in the previous chapter, a value type is immutable in nature and creates
    a changed copy whenever it is mutated. Therefore, by assigning the array to a
    constant using `let`, we prevent any new value from being assigned, making mutating
    the array impossible.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about arrays can be found in Apple's documentation on the
    Swift language at [https://developer.apple.com/documentation/swift/array](https://developer.apple.com/documentation/swift/array).
  prefs: []
  type: TYPE_NORMAL
- en: Arrays use generics to define the element type they contain. Generics will be
    discussed in detail in [Chapter 4](abdc6918-3b36-4495-9c61-f2b9551dd700.xhtml),
    *Generics, Operators, and Nested Types*.
  prefs: []
  type: TYPE_NORMAL
- en: Containing your data in sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next collection type we will look at is a **set**. Sets differ from arrays
    in two important ways. The elements in a set are stored *unordered*, and each
    unique element is only held once. In this recipe, we will learn how to create
    and manipulate sets.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s explore some ways we can create sets and perform set algebra
    on them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an array that contains the first nine Fibonacci numbers, and also a
    set containing the same:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Print out the number of elements in each collection using the `count` property.
    Despite being created with the same elements, the count value is different:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert an element into a set of animals, remove an element, and check whether
    a set contains a given element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Create some sets containing common mathematical number groups. We will use
    these to explore some methods for set algebra:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Obtain the union of two sets and print the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Obtain the intersection of two sets and print the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Obtain the symmetric difference of two sets and print the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Obtain the result of subtracting one set from another and print the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will examine the set membership comparison methods that are available:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create some sets with overlapping membership:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `isSubset` method to determine whether one set is a subset of another.
    Then, print the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `isSuperset` method to determine whether one set is a superset of another.
    Then, print the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `isStrictSubset` method to determine whether one set is a strict subset
    of another. Then, print the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `isStrictSuperset` method to determine whether one set is a strict
    superset of another. Then, print the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `isDisjoint` method to determine whether one set is disjointed with
    another. Then, print the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sets are created in almost the same way as arrays, and like arrays, we have
    to specify the element type that we will be stored in them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Arrays and sets store their elements differently. If you provide multiple elements
    of the same value to an array, it will store them multiple times. A set works
    differently; it will only store one version of each unique element. Therefore,
    in the preceding Fibonacci number sequence, the array stores two elements for
    the first two values, `1, 1`, but the set will store this as just one `1` element.
    This leads to the collections having different counts, despite being created with
    the same values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This ability to store elements uniquely is made possible due to a requirement
    that a set has regarding the type of elements it can hold. A set's elements must
    conform to the `Hashable` protocol. This protocol requires a `hashValue` property
    to be provided as an `Int`, and the set uses this `hashValue` to do its uniqueness
    comparison. Both the `Int` and `String` types conform to `Hashable`, but any custom
    types that will be stored in a set will also need to conform to `Hashable`.
  prefs: []
  type: TYPE_NORMAL
- en: A set's `insert`, `remove`, and `contains` methods work as you would expect,
    with the compiler enforcing that the correct types are provided. This compiler
    type checking is done thanks to the **generics** constraints that all the collection
    types have. We will cover generics in more detail in [Chapter 4](abdc6918-3b36-4495-9c61-f2b9551dd700.xhtml),
    *Generics, Operators, and Nested Types*.
  prefs: []
  type: TYPE_NORMAL
- en: Union
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `union` method returns a set containing all the unique elements from the
    set that the method is called on, as well as the set that was provided as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram depicts the Union of Set A and Set B:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/59c17cc6-b85a-4ac7-b5a7-b785c46250b0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 â€“ Union of sets
  prefs: []
  type: TYPE_NORMAL
- en: Intersection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `intersection` method returns a set of unique elements that were contained
    in both the set that the method was called on and the set that was provided as
    a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram depicts the Intersection of Set A and Set B:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51783c0f-21db-4fd7-9014-e85a1e07c9fb.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 â€“ Set intersection
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric difference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `symmetricDifference` method returns a set of unique elements that are
    in either the set the method is called on, or the set that''s provided as a parameter,
    but not elements that are in both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This `set` operation is sometimes referred to as method is so `exclusiveOr`,
    both other programming languages, including previous versions of Swift.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts the Symmetric Difference of Set A and Set B:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df2aff4d-ef9d-4390-8b76-4065c892a8ed.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 â€“ Symmetric difference
  prefs: []
  type: TYPE_NORMAL
- en: Subtracting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `subtracting` method returns a unique set of elements that can be found
    in the set the method was called on, but not in the set that was passed as a parameter.
    Unlike the other set manipulation methods we''ve mentioned, this will not necessarily
    return the same value if you swap the set that the method is called on with the
    set provided as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram depicts the set that''s created by Subtracting Set B
    from Set A:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a012c09-14cc-4871-a56c-eeefaceb6520.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5â€“ Subtracting a set
  prefs: []
  type: TYPE_NORMAL
- en: Membership comparison
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to set manipulation methods, there are a number of methods we can
    use to determine information about set membership.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `isSubset` method will return true if all the elements in the set that
    the method is called on are contained within the set that''s passed as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram depicts Set B as the subset of Set A:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e8393bc-3f75-4167-b2a9-7b8838b91fb8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 â€“ Subset
  prefs: []
  type: TYPE_NORMAL
- en: 'This will also return true if the two sets are equal (they contain the same
    elements). If you only want a true value if the set that the method is called
    on is a subset and *not* equal, then you can use `isStrictSubset`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isSuperset` method will return true if all the elements in the set that
    have been passed as a parameter are within the set that the method is called on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram depicts Set A as the superset of Set B:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5a19446-b50f-428a-8c8e-08ea715425c0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 â€“ Superset
  prefs: []
  type: TYPE_NORMAL
- en: 'This will also return true if the two sets are equal (they contain the same
    elements). If you only want a true value if the set that the method is called
    on is a superset and not equal, then you can use `isStrictSuperset`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isDisjoint` method will return true if there are no common elements between
    the set that the method is called on and the set that was passed as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram shows that Set A and Set B are disjoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d287cfca-139b-4ee9-b258-15d8ad631be0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 â€“ Disjoint
  prefs: []
  type: TYPE_NORMAL
- en: 'As with arrays, a set can be declared immutable by assigning it to a `let`
    constant instead of a `var` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This is because a set, like the other collection types, is a value type. Removing
    an element would mutate the set, which creates a new copy, but a `let` constant
    can't have a new value assigned to it, so the compiler prevents any mutating operations.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about arrays can be found in Apple's documentation on the
    Swift language at [https://docs.swift.org/swift-book/LanguageGuide/CollectionTypes.html](https://docs.swift.org/swift-book/LanguageGuide/CollectionTypes.html).
  prefs: []
  type: TYPE_NORMAL
- en: Sets use generics to define the element types they contain. Generics will be
    discussed in detail in [Chapter 4](abdc6918-3b36-4495-9c61-f2b9551dd700.xhtml),
    *Generics, Operators, and Nested Types*.
  prefs: []
  type: TYPE_NORMAL
- en: Storing key-value pairs with dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last collection type we will look at is the **dictionary**. This is a familiar
    construct in programming languages, where it is sometimes referred to as a **hash
    table**. A dictionary holds a collection of pairings between a key and a value.
    The **key** can be any element that conforms to the `Hashable` protocol (just
    like elements in a set), while the **value** can be any type. The contents of
    a dictionary is not stored in order, unlike an array; instead, the *key* is used
    both when storing a value and as a lookup when retrieving a value.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will use a dictionary to store details of people at a place
    of work. We need to store and retrieve a person's information based on their role
    in the organization, such as a company directory. To hold this person's information,
    we will use a modified version of our `Person` class from [Chapter 1](f9d48715-ffca-464f-95bf-722958f02e72.xhtml),
    *Swift Building Blocks*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code into a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s use the `Person` object we defined previously to build up our workplace
    directory using a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Dictionary` for the employee directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Populate the dictionary with employee details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieve an array of all the keys in the dictionary. This will give us an array
    of all the roles in the organization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Use a key to retrieve one of the employees and print the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace a value in the dictionary by assigning a new value against an existing
    key. The previous value for the key is discarded when a new value is set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: With that, we have learned how to create, populate, and look up values in a
    dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with the other collection types, when we create a dictionary, we need to
    provide the types that the dictionary will be holding. For dictionaries, there
    are two types that we need to define. The first is the type of the key (which
    must conform to `Hashable`), while the second is the type of the value being stored
    against the key. For our dictionary, we are using `String` for the key and `Person`
    for the values being stored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'As with an array, we can specify a `dictionary` type using square brackets
    and create one using a dictionary literal, where `:` separates the key and the
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, we can change our dictionary definition so that it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The `[:]` symbol denotes an empty dictionary as a dictionary literal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Elements are added to a dictionary using a subscript. Unlike an array, which
    takes an `Int` index in the subscript, a dictionary takes the key and then pairs
    the given value with the given key. In the following example, we are assigning
    a `Person` object to the `"Captain"` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: If no value currently exists, the assigned value will be added. If a value already
    exists for the given key, the old value will be replaced with the new value and
    the old value will be discarded.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are properties on the dictionary that provide all the keys and values.
    These properties are of a custom collection type that can be passed to an array
    initializer to create an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: To display all the dictionary's keys, as provided by the `keys` property, we
    can either create an array or iterate over the collection directly. We will cover
    iterating over a collection's values in the next chapter, so for now, we will
    create an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will use one of the values from an array of keys, alongside the crew,
    to retrieve full details about the associated `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: We get the first element using the `first` property, but since this is an optional
    type, we need to force unwrap it using `!`. We can pass `firstRole`, which is
    now a non-optional `String` to the dictionary subscript, to get the `Person` object
    associated with that key. The return type for retrieving the value via subscript
    is also optional, so it also needs to be force unwrapped before we print its values.
  prefs: []
  type: TYPE_NORMAL
- en: '**Force unwrapping** is usually an unsafe thing to do since if we force unwrap
    a value that turns out to be `nil`, our code will crash. We advise you to check
    that a value isn''t `nil` before unwrapping the optional. We will cover how to
    do this in the next chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we used strings as the keys for our dictionary. However, we
    can also use a type that conforms to the `Hashable` protocol.
  prefs: []
  type: TYPE_NORMAL
- en: One downside of using `String` as a key for our employee directory is that it
    is very easy to mistype an employee's role or look for a role that you expect
    to exist but doesn't. So, we can improve our implementation by using something
    that conforms to `Hashable` and is better suited to being used as a key in our
    model.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a finite set of employee roles in our model, and an **enumeration**
    is perfect for representing a finite number of options, so let''s define our roles
    as an enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s change our `Dictionary` definition so that it uses this new `enum`
    as a key, and then insert our employees using these `enum` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: You will also need to change all the other uses of `crew` so that they use the
    new enum-based key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how and why this works. We created `Role` as a `String`-based
    enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Defining it in this way has two benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: We intend to display these roles to the user, so we will need a string representation
    of the `Role` enum, regardless of how we defined it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enums have a little bit of protocol and generics magic in them, which means
    that if an enum is backed by a type that implements the `Hashable` protocol (as
    `String` does), the enum also automatically implements the `Hashable` protocol.
    Therefore, defining `Role` as being String-based satisfies the dictionary requirement
    of a key being `Hashable` without us having to do any extra work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With our `crew` dictionary now defined as having a Role-based key, all subscript
    operations have to use a value in the role enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The compiler enforces this, so it's no longer possible to use an incorrect role
    when interacting with our employee directory. This pattern of using Swift's constructs
    and type system to enforce the correct use of your code is something we should
    strive to do, as it can reduce bugs and prevent our code from being used in unexpected
    ways.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about dictionaries can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/collections](http://swiftbook.link/docs/collections).
  prefs: []
  type: TYPE_NORMAL
- en: Subscripts for custom types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By using collection types, we have seen that their elements are accessed through
    subscripts. However, it's not just collection types that can have subscripts;
    your own custom types can provide subscript functionality too.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will create a simple game of *tic-tac-toe*, also known as
    *Noughts and Crosses*. To do this, we need a three-by-three grid of positions,
    with each position being filled by either a nought from Player 1, a cross from
    Player 2, or nothing. We can store these positions in an array of arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial game setup code uses the concepts we''ve already covered in this
    book, so we won''t go into its implementation. Enter the following code into a
    new playground so that we can see how subscripts can improve its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s run through how we can use the tic-tac-toe game defined previously,
    as well as how we can improve how it is used, using a subscript. We will also
    examine how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an instance of our `TicTacToe` grid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'For a player to make a move, we need to change the `GridPosition` value that''s
    been assigned to the relevant place in the array of arrays. This is used to store
    the grid positions. Player 1 will place a nought in the middle position of the
    grid, which would be row position 1, column position 1 (since it''s a zero-based
    array):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, Player 2 places their cross in the top-right position, which is row position
    0, column position 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: We can make moves in our game. We can do this by adding information directly
    to the `gridStorage` array, which isn't ideal. The player shouldn't need to know
    how the moves are stored, and we should be able to change how we store the game
    information without having to change how the moves are made. To solve this, let's
    create a subscript of our game struct so that making a move in the game is just
    like assigning a value to an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following subscript method to the `TicTacToe` struct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'So, now, we can change how each player makes their move and finish the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when using an array, we can use a subscript to access the value,
    as well as assign a value to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Subscript functionality can be defined within a class, struct, or enum, or
    declared within a protocol as a requirement. To do this, we can define `subscript`
    (which is a reserved keyword that activates the required functionality) with input
    parameters and an output type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'This subscript definition works like a computed property, where `get` can be
    defined to allow you to access values through `subscript` and `set` can be defined
    to assign values using `subscript`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Any number of input parameters can be defined, and these should be provided
    as comma-separated values in the subscript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like parameters defined in a function, `subscript` parameters can have
    additional labels. If defined, these become required at the call site, so the
    `subscript` we added can alternatively be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, when using the `subscript`, we would also provide the labels
    in the `subscript`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about subscripts can be found in Apple's documentation on
    the Swift language at [http://swiftbook.link/docs/subscripts](http://swiftbook.link/docs/subscripts).
  prefs: []
  type: TYPE_NORMAL
- en: Changing your name with typealias
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `typealias` declaration allows you to create an alias for a type (and is
    therefore pretty accurately named!). You can specify a name that can be used in
    place of any given type of definition. If this type is quite complex, a typeAlias
    can be a useful way to simplify its use.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use a typealias to replace an array definition:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create something we can store in an array. In this instance,
    let''s create a `Pug` struct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create an array that will contain instances of a `Pug` struct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: As you may or may not know, the collective noun for a group of pugs is called
    a **grumble**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can set up a `typealias` to define an array of pugs as a `Grumble`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'With this defined, we can substitute `Grumble` wherever we would use `[Pug]`
    or `Array<Pug>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this isn''t some new type â€“ it is just an array with all the same
    functionalities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding example allows us to use types in a more natural and expressive
    way. In addition, we can use a `typealias` to simplify a more complex type that
    may be used in multiple places.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this might be useful, we can partially build an object to fetch
    program information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `ProgrammeFetcher` object, we have two methods that take a channel and
    a result handler closure. The result handler closure has the following definition.
    We have to define this twice; once for each method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we can define this closure definition with a `typealias` called `FetchResultHandler`
    and replace each method definition with a reference to this `typealias`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Not only does this save us from defining the closure type twice, but it is also
    a better description of the function that the closure performs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `typealias` doesn''t affect how we provide closure to the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about typealias can be found in Apple's documentation on
    the Swift language at [http://swiftbook.link/docs/declarations](http://swiftbook.link/docs/declarations).
  prefs: []
  type: TYPE_NORMAL
- en: Getting property changing notifications using property observers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's common to want to know when a property's value changes. Perhaps you want
    to update the value of another property or update some user interface element.
    In Objective-C, this was often accomplished by writing your own getter and setter
    or using **Key-Value Observing** (**KVO**), but in Swift, we have native support
    for property observers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To examine property observers, we should create an object with a property that
    we want to observe. Let''s create an object that manages users and a property
    that holds the current user''s name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: We want to present some friendly messages when the current user changes. We'll
    use property observers to do this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Amend the `currentUserName` property definition so that it looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an instance of `UserManager` and change the current username. This will
    generate friendly messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Property observers can be added within curly brackets after the property declaration,
    and there are two types: `willSet` and `didSet`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `willSet` observer will be called before the property is set and provides
    the value that will be set on the property. This new value can be given a name
    within brackets; for example, `newUserName`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'The `didSet` observer will be called after the property is set and provides
    the value that the property had before being set. This old value can be given
    a name within brackets; for example, `oldUserName`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The new value and old value that are passed into the property observers have
    implicit names, so there is no need to explicitly name them. The `willSet` observer
    is passed a value with an implicit name of `newValue`, and the `didSet` observer
    is passed a value with an implicit name of `oldValue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we can remove our explicit names and use the implicit value names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about property observers can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/properties](http://swiftbook.link/docs/properties).
  prefs: []
  type: TYPE_NORMAL
- en: Extending functionality with extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extensions let us add functionality to our existing classes, structs, enums,
    and protocols. This can be especially useful when the original type is provided
    by an external framework, which means you aren't able to add functionality directly.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine that we often need to obtain the first word from a given string. Rather
    than repeatedly writing the code to split the string into words and then retrieving
    the first word, we can extend the functionality of `String` to provide its own
    first word.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an extension of `String`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the extension''s curly brackets, add a function that returns the first
    word from the string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use this new method on `String` to get the first word from a phrase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can define an extension using the `extension` keyword and then specify the
    type we want to extend. The implementation of this extension is defined within
    curly brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Methods and computed properties can be defined in extensions in the same way
    that they can be defined within classes, structs, and enums. Here, we will add
    a `firstWord` function to the `String` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of the `firstWord` method is not important for this recipe,
    so we'll just touch on it briefly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift, `String` is a collection, so we can use the collection methods to
    find the first index of an empty space. However, this could be `nil` since the
    string may contain only one word or no characters at all, so if the index is `nil`,
    we must use the `endIndex` instead. The nil coalescing operator (`??`) is only
    used to assign `endIndex` if `firstIndex(of: " ")` is `nil`. More generally, it
    will evaluate the value on the left-hand side of the operator, unless it is `nil`,
    in which case it will assign the value on the right-hand side.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we use the index of the first space to retrieve the substring up to the
    index, which has a `SubString` type. We then use that to create and return a `String`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extensions can implement anything that uses the existing functionality, but
    they can''t store information in a new property. Therefore, computed properties
    can be added, but stored properties cannot. Let''s change our `firstWord` method
    so that it''s a computed property instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Extensions can also be used to add protocol conformance, so let''s create a
    protocol that we want to add conformance to:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The protocol declares that something can be represented as an `Int`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'We can extend `Int` and have it conform to `IntRepresentable` by returning
    itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll extend `String`, and we''ll use an `Int` constructor that takes
    a `String` and returns an `Int` if our `String` contains digits that represent
    an integer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also extend our own custom types and add conformance to the same protocol,
    so let''s create an `enum` that can be `IntRepresentable`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Since our enum is Int-based, we can conform to `IntRepresentable` by providing
    a `rawValue`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have `String`, `Int`, and `CrewComplement` all conforming to `IntRepresentable`,
    and since we didn''t define `String` or `Int`, we have only been able to add conformance
    through the use of extensions. This common conformance allows us to treat them
    as the same type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example includes the use of `compactMap` and the ternary operator,
    which haven't been covered in this book. Further information can be found in the
    *See also* section.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about extensions can be found in Apple's documentation on
    the Swift language at [http://swiftbook.link/docs/extensions](http://swiftbook.link/docs/extensions).
  prefs: []
  type: TYPE_NORMAL
- en: The documentation for `compactMap` can be found at [https://developer.apple.com/documentation/swift/sequence/2950916-compactmap](https://developer.apple.com/documentation/swift/sequence/2950916-compactmap).
  prefs: []
  type: TYPE_NORMAL
- en: Further information about the ternary operator can be found at [https://docs.swift.org/swift-book/LanguageGuide/BasicOperators.html#ID71](https://docs.swift.org/swift-book/LanguageGuide/BasicOperators.html#ID71).
  prefs: []
  type: TYPE_NORMAL
- en: Controlling access with access control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swift provides fine-grained access control, allowing you to specify the visibility
    that your code has to other areas of code. This enables you to be deliberate about
    the interface you provide to other parts of the system, thus encapsulating implementation
    logic and helping separate the areas of concern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift has five access levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Private**: Only accessible within the existing scope (defined by curly brackets)
    or extensions in the same file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File private**: Accessible to anything in the same file, but nothing outside
    the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internal**: Accessible to anything in the same module, but nothing outside
    the module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Public**: Accessible both inside and outside the module, but cannot be subclassed
    or overwritten outside of the defining module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open**: Accessible everywhere, with no restrictions in terms of its use,
    and can therefore be subclassed and overwritten.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These can be applied to types, properties, and functions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To explore each of these access levels, we need to step outside our playground
    comfort zone and create a module. To have something that will hold our module
    and a playground that can use it, we will need to create an Xcode workspace:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Xcode, select File | New | Workspace... from the menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/382a9997-8a62-4b03-82d8-ee46ffc86cb5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 â€“ Xcode â€“ New project
  prefs: []
  type: TYPE_NORMAL
- en: 'Give your workspace a name, such as `AccessControl`, and choose a save location.
    You will now see an empty workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e19c4f3f-0822-4566-a963-c85eb82bf34a.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 â€“ Xcode â€“ New project structure
  prefs: []
  type: TYPE_NORMAL
- en: In this workspace, we need to create a module. To illustrate the access controls
    that are available, let's have our module represent something that tightly controls
    which information it exposes, and which information it keeps hidden. One thing
    that fits this definition is Apple; that is, the company.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project from the Xcode menu by selecting File | New | Project...:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/98ddc071-6982-47f5-b48d-81b953112ed3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 â€“ New project
  prefs: []
  type: TYPE_NORMAL
- en: 'From the template selector, select Framework:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7099a811-ebef-4327-a2f3-028dcbeeed78.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 â€“ New project framework
  prefs: []
  type: TYPE_NORMAL
- en: 'Name the project `AppleInc`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6fdc3f65-3799-4641-9595-0a65abfcca43.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 â€“ Naming the project
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose a location. Then, at the bottom of the window, ensure that Add to: has
    been set to the workspace we just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ead95109-a886-435d-801c-185500b3605f.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.14 â€“ New project workspace group
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a module, let''s set up a playground to use it in. From the
    Xcode menu, select File | New | Playground...:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a804521f-f114-4011-887b-73fcb4aa093c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.15 â€“ New playground
  prefs: []
  type: TYPE_NORMAL
- en: 'Give the playground a name and save it to a location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f392ab21-7d05-4a4c-9ff1-e4a826bfb62b.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.16 â€“ New project
  prefs: []
  type: TYPE_NORMAL
- en: This playground will not be added to the workspace automatically; you will need
    to locate the playground you just created and drag it into the file explorer pane
    on the left-hand side of your workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Press the run button on the Xcode toolbar to build the `AppleInc` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5aac1934-f7bf-4178-a60b-3b85db9563f9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.17 â€“ Xcode toolbar
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the playground from the file navigator and add an import statement to
    the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to look into the different access controls that are available.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s investigate the most restrictive of the access controls: `private`.
    Structures marked as `private` are only visible within the scope of the type they
    have been defined in, as well as any extensions of that type that are located
    in the same file. We know that Apple has super-secret areas where it works on
    its new products, so let''s create one:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `AppleInc` group in the file navigator and create a new file by selecting
    File | New | File... from the menu. Let's call it `SecretProductDepartment`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this new file, create a `SecretProductDepartment` class using the `private`
    access control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's look at the `fileprivate` access control. Structures marked as `fileprivate`
    are only visible within the file that they are defined in, so a collection of
    related structures defined in the same file will be visible to each other, but
    anything outside the file will not see these structures.
  prefs: []
  type: TYPE_NORMAL
- en: When you buy an iPhone from the Apple Store, it's not made in-store; it's made
    in a factory that the public doesn't have access to. So, let's model this using
    `fileprivate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `AppleStore`. Then, create structures for `AppleStore`
    and `Factory` using the `fileprivate` access control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: To investigate the `public` access control, we will be defining something that
    is visible outside the defining module but cannot be subclassed or overridden.
    Apple itself is the perfect candidate to model this behavior as certain parts
    of it are visible to the public. However, it closely guards its image and brand,
    so *subclassing* Apple to alter and customize it will not be allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `Apple` and create a class for Apple that uses the
    `public` access control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, we have the `open` access control. Structures defined as `open` are
    available outside the module and can be subclassed and overridden without restriction.
    To explain this last control, we want to model something that exists within Apple's
    domain but is completely open and free from restrictions. So, for this, we can
    use the Swift language itself!
  prefs: []
  type: TYPE_NORMAL
- en: Swift has been open sourced by Apple, so while they maintain the project, the
    source code is fully available for others to take, modify, and improve.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `SwiftLanguage` and create a class for the Swift language
    that uses the `open` access control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: We now have a module that uses Swift's access controls to provide interfaces
    that match our model and provide the appropriate visibility.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s examine our `SecretProductDepartment` class to see how its visibility
    matches our model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: The `SecretProductDepartment` class is declared without an access control keyword,
    and when no access control is specified, the default control of `internal` is
    applied. Since we want the secret product department to be visible within Apple,
    but not from outside Apple, this is the correct access control to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two properties of the `secretCodeWord` and `secretProducts` classes are
    marked as private, thus hiding their values and existence from anything outside
    the `SecretProductDepartment` class. To see this restriction in action, add the
    following to the same file, but outside the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: When you try to build the module, you are told that `secretCodeWord` can't be
    accessed due to the `private` protection level.
  prefs: []
  type: TYPE_NORMAL
- en: 'While these properties are not directly accessible, we can provide an interface
    that allows the information to be provided in a controlled way. This is what the
    `nextProduct` method provides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: If the correct codeword is passed, it will provide the name of the next product
    from the secret department, but the details of all other products, and the codeword
    itself, will be hidden. Since this method doesn't have a specified access control,
    it is set to the default of `internal`.
  prefs: []
  type: TYPE_NORMAL
- en: It's not possible for contents within a structure to have a more permissive
    access control than the structure itself. For instance, we can't define the `nextProduct`
    method as being `public` because this is more permissive than the class it is
    defined in, which is only `internal`.
  prefs: []
  type: TYPE_NORMAL
- en: Thinking about it, this is the obvious outcome as you cannot create an instance
    of an internal class outside of the defining module, so how can you possibly call
    a method on a class instance that you can't even create?
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s look at the `AppleStore.swift` file we created. The purpose here
    is to provide people outside of Apple with the ability to purchase an iPhone through
    the Apple Store, but to restrict the creation of iPhones to just the factories
    where they are built, and then restrict access to those factories to just the
    Apple Store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Since we want to be able to sell iPhones outside of the `AppleInc` module, the
    `DeviceModel` enum and the `AppleiPhone` and `AppleStore` classes are all declared
    as `public`. This has the benefit of making them available outside the module
    but preventing them from being subclassed or modified. Given how Apple protects
    the look and feel of their phones and stores, this seems correct for this model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Apple Store needs to get their iPhones from somewhere; that is, from the
    factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: By making the `Factory` class `fileprivate`, it is only visible within this
    file, which is perfect because we only want the Apple Store to be able to use
    the factory to create iPhones.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have also restricted the iPhone''s initialization method so that it can
    only be accessed from structures in this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: The resulting iPhone is public, but only structures within this file can create
    iPhone class objects in the first place. In this case, this is done by the factory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s look at the `Apple.swift` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code made both the `Person` and `Apple` classes public, along
    with the `newEmployee` method. This allows new employees to join the company.
    The CEO, however, is defined as both public and private:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: We can define a separate, more restrictive, access control for setting a property
    than the one that was set for getting it. This has the effect of making it a read-only
    property from outside the defining structure. This provides the access we require
    since we want the CEO to be visible outside of the `AppleInc` module, but we want
    to only be able to change the CEO from within Apple.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final access control is `open`. We applied this to the `SwiftLanguage`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: By declaring the class and methods as `open`, we are allowing them to be subclassed,
    overridden, and modified by anyone, including those outside the `AppleInc` module.
    With the Swift language being fully open source, this matches what we are trying
    to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With our module fully defined, let''s see how things look from outside the
    module. We need to build the module to make it available to the playground. Select
    the playground; it should contain a statement that imports the `AppleInc` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'First, let''s look at the most accessible class that we created; that is, `SwiftLanguage`.
    Let''s subclass the `SwiftLanguage` class and override its behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Since `SwiftLanguage` is `open`, we can subclass it to add more supported platforms
    and increase its version number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s create an instance of the `Apple` class and see how we can interact
    with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: We can create `Person` and provide it to Apple as a new employee since the `Person`
    class and the `newEmployee` method are declared as public. We can retrieve information
    about the CEO, but we aren't able to set a new CEO as we defined the property
    as `private (set)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another one of the public interfaces `selliPhone` provided by the module allows
    us to buy an iPhone from the Apple Store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: We can retrieve a new iPhone from the Apple Store because we declared the `selliPhone`
    method as `public`. However, we can't create a new iPhone directly since the iPhone's
    `init` method is declared as `fileprivate`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about access control can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/access-control](http://swiftbook.link/docs/access-control).
  prefs: []
  type: TYPE_NORMAL
