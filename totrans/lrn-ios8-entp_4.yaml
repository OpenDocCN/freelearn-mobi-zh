- en: Chapter 4. APIs Introduced in iOS 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**API** stands for **application programming interface**. An API is a set of
    commands, functions, sections of code, and protocols that programmers can use
    in their applications. They are predefined functions available for programmers
    to use instead of writing them from scratch. While APIs make a programmer''s task
    easier, an API is a software-to-software interface, not a user interface. With
    APIs, applications communicate with each other without any user intervention.
    Some popular APIs are Google Map APIs, Twitter APIs, YouTube APIs, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using AirDrop to remotely send/receive files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iOS's first native game engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text kit to manage your typography
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sample projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a lot of major updates done by Apple for developers to incorporate
    into their app. The user interface has been completely redesigned. iOS 7 introduces
    a new animation system to create 2D and 2.5D games. Multitasking enhancements,
    peer-to-peer connectivity, and many other important features have been added.
  prefs: []
  type: TYPE_NORMAL
- en: Using AirDrop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apple introduced a new feature in iOS 7 called **AirDrop**. AirDrop is used
    to easily share pictures, contacts, notes, and more with other nearby iOS devices.
    It uses Bluetooth to detect nearby devices. When a connection is established via
    Bluetooth, it''ll create an ad hoc Wi-Fi network to link the two devices together.
    There is a class called `UIActivityViewController` available to integrate AirDrop
    in our apps. We just need to tell this class which objects we want to share, and
    it handles the rest. The `UIActivityViewController` class is a standard view controller
    class that provides several standard services, such as copying items to the clipboard,
    sharing content on social media sites, sending items via messages, and so on.
    In iOS 7 SDK, this class is served with the built-in AirDrop feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s understand this feature with a small activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Xcode and make a new project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the image view and button into the storyboard from the interface builder.
    Our storyboard will look like the following screenshot:![Using AirDrop](img/1829OT_04_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag any image in Xcode below the class files that you want to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the image view from the storyboard and move to the Attribute Inspector.
    Then, in the **Image** textbox, give it the same name as that of the image we
    dragged in Xcode, as shown in the following screenshot:![Using AirDrop](img/1829OT_04_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, link the image view and the button to `viewcontroller.h` and create one
    array in which we will store the content that we want to transfer from AirDrop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following screenshot will show the content that we want to transfer:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Using AirDrop](img/1829OT_04_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Move to `viewController.m` and add the following code to the `viewDidLoad`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we created one string that we want to share and created
    one `UIImage` object that stores our image.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we added both of them to our defined array. Now, let''s add some code
    in our button event as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding code, we created `UIActivityViewController` with our `activityItems`
    array. With the `excludedActivityTypes` property, we excluded all the activities
    that are not needed, leaving AirDrop as the only sharing option. Finally, we presented
    the activity view controller. The following screenshot illustrates the preceding
    code snippet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Using AirDrop](img/1829OT_04_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: It is now time to compile and run our program. After execution, our simulator
    will look like the following screenshot:![Using AirDrop](img/1829OT_04_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap on the **Share With Air Drop** button. Our simulator will now look like
    this:![Using AirDrop](img/1829OT_04_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, no options are available because we have excluded all the options except
    the AirDrop option, and the simulator does not support AirDrop. When we put this
    code on the real device, it will show us the devices that are available for sharing
    and the devices that have AirDrop.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: SpriteKit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apple has launched its first game engine, SpriteKit, that allows us to create
    games for iOS without being dependent on third-party game libraries. It is very
    powerful and inclined towards the traditional iOS framework approach when it comes
    to its usage. It''s also very easy to adopt and learn. In addition to this, it
    supports lots of features such as physics simulations, a texture atlas, gravity,
    restitution, and game center support. Moreover, it comes with very rich developer
    documentation at the **Apple Development Center**. It''s very useful and well
    written. You might need to understand the anatomy of game development first to
    get started in SpriteKit. So, there are two basic and most important terms here:
    one is Scenes, and the other one is Sprites. Scenes can be considered as the levels
    in the games. So, in any game, the score layer, the **HUD** (**Heads-Up Display**)
    layer, and the gameplay layer can act as different scenes. However, any object
    in the scene, such as the player or enemy, can be considered as a sprite.'
  prefs: []
  type: TYPE_NORMAL
- en: The iOS native game framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apple has introduced its own native 2D game framework called SpriteKit. SpriteKit
    is a great 2D game engine that offers support for sprites, animations, filters,
    and masking. Most importantly, it also offers support for the physics engine to
    provide a real-world simulation for the game.
  prefs: []
  type: TYPE_NORMAL
- en: Apple provides a sample game called *Adventure Game* to get started with SpriteKit.
    You can check out the sample SpriteKit game project at [https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/CodeExplainedAdventure/AdventureArchitecture/AdventureArchitecture](https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/CodeExplainedAdventure/AdventureArchitecture/AdventureArchitecture).
    This sample project provides a glimpse into the capability of this framework.
    However, the project is complicated to understand; for learning purposes, you
    just want to create something simple to understand and learn. To have a deeper
    understanding of SpriteKit-based games, we will build a bunch of mini games in
    this book. To understand the basics of SpriteKit game programming, we will build
    a mini *AntKilling* game in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start building the *AntKilling* game by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start your Xcode. Navigate to **File** | **New** | **Project**. Then, in the
    prompt window, navigate to **iOS** | **Application** | **SpriteKit Game** and
    click on **Next**, as shown in the following screenshot:![The iOS native game
    framework](img/1829OT_04_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in all the project details in the prompt window and enter `AntKilling`
    as **Product Name**. Also provide the name of your organization and select the
    device name as **iPhone** and **Class Prefix** as **AK**. Click on **Next** as
    shown in the following screenshot:![The iOS native game framework](img/1829OT_04_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a location on your drive to save the project and then click on **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, build the sample project to check its output. Once you build and run the
    project with the Play button, you will see the following screen on your device:![The
    iOS native game framework](img/1829OT_04_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, the sample SpriteKit project plays a label with a background
    color. SpriteKit works on the concept of scenes, which can be understood as the
    levels or screens of the game. There can be multiple scenes working at the same
    time; for example, there can be a gameplay scene, HUD scene, and the score scene
    running at the same time in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can look at more detailed arrangements for the starter project by performing
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the main directory, you already have one scene created by default; this scene
    is called `AKMyScene`. Now, click on `AKMyScene.m` to explore the code for adding
    the label on the screen. You should see something similar to following screenshot:![The
    iOS native game framework](img/1829OT_04_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we have to update this file with our code to create our *AntKilling* game.
    We have to fulfill a few prerequisites to get started with the code; for example,
    we have to lock the orientation to landscape as we want a landscape-orientation
    game.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To change the orientation of the game, open the **AntKilling** project settings
    and navigate to **TARGETS** | **General**. You will see something similar to the
    following screenshot:![The iOS native game framework](img/1829OT_04_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, in the **General** tab, uncheck **Portrait** under the **Device Orientation**
    option so that the final settings look similar to the following screenshot:![The
    iOS native game framework](img/1829OT_04_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, build and run the project. You will be able to see the app started in the
    landscape orientation.![The iOS native game framework](img/1829OT_04_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, it's time to update `AKMyScene` to hold our ant sprites. Just download
    and open all the resources you got for this chapter and add them to your Xcode
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While adding the resources to the Xcode project, make sure that the selected
    target is **AntKilling** and that the **Copy items into destination group folder**
    is checked, if needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, delete all the existing code from `AKMyScene.m` and make it look similar
    to following screenshot:![The iOS native game framework](img/1829OT_04_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, here is the explanation of what we did so far:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, we created a private interface to declare the private variables:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, in the `init` method, we printed a log to print the size of the screen:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'We changed the screen background color to white using the following line of
    code:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following line of code, we created a sprite object using the `spriteNodeWithImageNamed`
    method and passed the image name to it. Then, we positioned the sprite object
    to `(100, 100)` of the screen, which is in the bottom-left corner of the screen.
    Then, finally, we added it as a child method:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Now, build and run your application. You will see something similar to the following
    screenshot:![The iOS native game framework](img/1829OT_04_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, as you can see, the screen color has changed to white, but there is no
    ant on the screen. This means there is something wrong with the code. So now,
    let''s check our logs, which should print the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So, we found out that the scene size is wrong; it should print `568` as the
    width and `320` as the height, and it is printing the opposite.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To debug this, navigate to the `viewDidLoad` method of your `AKViewController.m`.
    This will be something similar to the one shown in the following screenshot:![The
    iOS native game framework](img/1829OT_04_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, from this method, we can see that our scene absorbs the size from the bounds
    of the view, and this `viewDidLoad` method is invoked even before the view has
    been added to the view hierarchy. Thus, it has not responded to the layout changes.
    As a result of the inconsistent view bounds, our scene is getting started with
    the wrong bounds.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To solve this issue, we have to move the scene startup code in the `viewWillLayoutSubviews`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After removing the code from the `viewDidLoad` method and pasting it to `viewWillLayoutSubviews`,
    the code file will look similar to the one shown in the following screenshot:![The
    iOS native game framework](img/1829OT_04_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, again, build and run the app. You will see the following output:![The iOS
    native game framework](img/1829OT_04_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congrats! You have fixed the issue; now, your ant has appeared on the screen
    at your given location. If you observe closely, you can see that the status bar
    is coming on the top of the game, and this is not looking great.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To remove the status bar from the screen, open your `AntKilling-Info.plist`
    file and add the `UIViewControllerBasedStatusBarAppearance` attribute and the
    value as `NO`. Your `.plist` file should be similar to following screenshot:![The
    iOS native game framework](img/1829OT_04_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build and run your project again. You should be able to see the game without
    the status bar now, as shown in the following screenshot:![The iOS native game
    framework](img/1829OT_04_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This looks perfect now; our ant is residing on the screen as expected. So now,
    our next objective is to animate the ant when we tap on it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To accomplish this, we need to add the following code in the `AKMyScene.m`
    file just below our `initWithSize` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final code file will look similar to the one shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![The iOS native game framework](img/1829OT_04_21.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Let''s go through it line-by-line to understand what we have done so far:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To begin with, we added the `-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent
    *)event` method to the grab all the touches on the scene.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, in the function the first line allowed us to grab the `UITouch *touch =
    [touches anyObject];` touch.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next line, we grabbed the touch and converted it to the `CGPoint positionInScene
    = [touch locationInNode:self];` location.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using the following line, we fetched the sprite that was touched:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you have the sprite object, compare and check whether the selected object
    is the ant bug. If it''s the ant bug, then animate the object by adding the following
    line of code:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Now, this code will animate the selected sprite. Build and run the project,
    and you will see the ant animating when we tap on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will soon notice that, on tapping on the ant, it starts animating, but
    there is no way to stop this. So, let''s add a way to stop this animation once
    you click anywhere on the scene. Go to the `- (void)touchesBegan:(NSSet *)touches
    withEvent:(UIEvent *)event` method and update it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you observe closely, you can see that we have added an `if`/`else` condition
    to check whether the ant animates when we tap on it and whether all actions stop
    when we tap anywhere outside the screen. To stop all the actions on the sprite,
    we can use the `removeAllActions` method on the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Text Kit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `UIKit` framework includes several classes whose purpose is to display
    text in a user''s app, such as `UITextView`, `UITextField`, `UILabel`, and `UIWebView`.
    Text views, created from the `UITextView` class, are meant to display different
    types of text on screen. `UITextView` is a powerful layout engine called **Text
    Kit**. Text Kit is built on top of **Core Text**, so it provides the same speed
    and power as that of Core Text. `UITextView` is fully integrated with Text Kit;
    it provides editing and display capabilities that enable users to input text,
    specify formatting attributes, and view the results. The other Text Kit classes
    provide text storage and layout capabilities. The following diagram shows the
    position of Text Kit among other iOS text and graphic frameworks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text Kit](img/1829OT_04_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We know that Text Kit is a collection of many classes and functions. However,
    there are three primary classes of Text Kit:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NSTextStorage` (text storage class)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NSLayoutManager` (layout manager class)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NSTextContainer` (text container class)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NSTextStorage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `NSTextStorage` class is responsible for storing all text attribute-related
    information, such as font, size, or paragraph information. The `NSTextStorage`
    class is a subclass of the `NSMutableAttributedString` class, and that's why it
    is responsible for keeping all text attributes. Besides this, its role also lies
    in making sure that all the edited text attribute data will remain consistent
    throughout all the management and editing operations that might be performed.
  prefs: []
  type: TYPE_NORMAL
- en: NSLayoutManager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `NSLayoutManager` class, as its name implies, manages the way in which the
    text data stored in a `NSTextStorage` object will be displayed in a view. Its
    job is to handle and support any view object that the text can be displayed in
    and perform any required conversions of Unicode characters to glyphs so that each
    character properly appears on screen. An object of this class is notified by `NSTextStorage`
    about any modifications made to the text and its attributes, so every change immediately
    gets reflected in the corresponding view.
  prefs: []
  type: TYPE_NORMAL
- en: NSTextContainer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `NSTextContainer` class actually specifies the view where the text will
    appear, and it handles information regarding this view (such as its frame or shape).
    However, a quite important characteristic of this class is its ability to keep
    an array of Bezier paths that define areas that should be excluded from the allowed
    region where the text will appear. This gives Text Kit the unique possibility
    of letting text flow around images or other non-text objects and allowing developers
    to display text in an impressive or demanding manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Text Kit is a set of classes and protocols in the `UIKit` framework that provide
    high-quality typographical services that enable apps to store, layout, and display
    text with all kinds of typesetting: kerning, ligatures, line breaking, and justification.'
  prefs: []
  type: TYPE_NORMAL
- en: Kerning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All characters have different and irregular shapes, and these shapes must be
    placed exactly adjacent to each other. Text kit layout takes this into account;
    for example, a capital letter, *T*, has a lot of free space under its "wings"
    and moves the following lowercase letters closer. This results in significantly
    improved legibility of text, especially in longer pieces of writing. The following
    screenshot illustrates kerning:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Kerning](img/1829OT_04_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Ligatures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is an artistic feature of Text Kit. Some characters look nice when they
    are combined, for example when *f* is combined with *l*. These combined symbols
    are called glyphs.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ligatures](img/1829OT_04_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Line breaking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create lines from a string of glyphs, the layout engine must perform line
    breaking by finding a point at which to end one line and begin the next. In the
    text system, you can specify line breaking at either word or glyph boundaries.
    In Roman text, a word broken between glyphs requires the insertion of a hyphen
    glyph at the breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Justification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lines of text can also be justified; for horizontal text, the lines are aligned
    on both right and left margins by varying interword and interglyph spacing, as
    shown in the following screenshot. The system performs alignment and justification,
    if requested, after the text stream has been broken into lines, hyphens have been
    added, and other glyph substitutions have been made.
  prefs: []
  type: TYPE_NORMAL
- en: '![Justification](img/1829OT_04_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s move to exclusion paths again. We know that Text Kit contains many classes,
    and Text Container is one of them. One great feature of it is that it can store
    an array of `UIBezierPath` and force text to flow around these paths; as they
    are excluded from the text draw region, they are called **exclusion paths**. Let''s
    understand how they work by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Xcode and create a new project. Go to the storyboard, drag a **Text Field**
    to view, and edit the text as you want (as shown in the following screenshot):![Justification](img/1829OT_04_26.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag an image view on the text view, as follows:![Justification](img/1829OT_04_27.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an image on the image view, as we did earlier. Drag any image in Xcode,
    as shown in the following screenshot, and give the same name to the image view
    via the Attribute Inspector as that of the dragged image:![Justification](img/1829OT_04_28.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile and run the code; our simulator will look like the following screenshot.
    It's cutting our text part below the image; this is not the output that we expected.![Justification](img/1829OT_04_31.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To implement the exclusive path text, we need to add some code. First of all,
    link the text field and image view to the `viewController.h` file, as shown in
    the following screenshot:![Justification](img/1829OT_04_29.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `viewController.m` file, write the following code in the `viewDidLoad`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding code, we first checked whether the image view is hidden or
    not (`_propertyName` is also a way to access any property other than `self.property`).
    If it''s hidden (the initial state), then we have to set the exclusion path to
    the text container object of the text view so that the text flows around the image
    view and, of course, to make the image view visible:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This line is used to convert the image view coordinates from the `self.view`
    view to the text view, so both the image view and the floating text exist in the
    same area. Next, using the `bezierPathWithRect:` class method of the `UIBezierPath`
    class, we created the Bezier path by the frame specified by its parameter; in
    our case, this is the frame (converted to the text view's coordinates) of the
    image view. We added this Bezier path to `NSArray`, and finally, we set the exclusion
    path. Note that, in the `else` case, we set the exclusion path to `nil`, because
    we don't want our text to flow when the image view is not there.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Our `viewController.m` file will look like the one shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Justification](img/1829OT_04_30.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Run the code. Now, our text will not be cut because of the image. Look at the
    following screenshot; it's not cutting our text, and our text continues after
    the image in each line. Text gives space to the image through the `UIBezierPath`
    class and makes a different class for the image view. So, now, you can try it
    for round-shaped images or other images of any shape.![Justification](img/1829OT_04_32.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned a lot of interesting things, including how to create
    a game, add an image between text, and share it with AirDrop. All these APIs are
    introduced in iOS 7\. After this chapter, try to extend all the activities performed
    here. This will clarify your concepts. In the next chapter, we will learn iOS
    8 APIs, including PhotoKit, manual camera control, and the Handoff concept.
  prefs: []
  type: TYPE_NORMAL
