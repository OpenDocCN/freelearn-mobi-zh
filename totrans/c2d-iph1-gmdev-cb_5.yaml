- en: Chapter 5. Scenes and Menus
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 场景和菜单
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Switching scenes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切换场景
- en: Transitioning between scenes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 场景之间的转换
- en: Using CCLayerMultiplex
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CCLayerMultiplex
- en: Using CCLabel
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CCLabel
- en: Using CCMenu
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CCMenu
- en: Creating shadowed menu labels
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建带阴影的菜单标签
- en: UIKit alert dialogs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UIKit警告对话框
- en: Wrapping UIKit
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包装UIKit
- en: Creating draggable menu windows
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可拖拽的菜单窗口
- en: Creating a horizontal scrollable menu
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建水平可滚动菜单
- en: Creating a vertical sliding menu grid
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建垂直滑动菜单网格
- en: Creating a loading screen with indicator
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带指示器的加载屏幕创建
- en: Creating a minimap
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建缩略图
- en: Introduction
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: All games have auxillary **Graphical User Interface (GUI)** requirements like
    **menus** and in-game **Heads-Up Displays(HUD)** . In this chapter, we will explain
    the techniques used to create these elements as well as how to incorporate them
    into an underlying structure of scenes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 所有游戏都有辅助的**图形用户界面(GUI)**需求，如**菜单**和游戏中的**抬头显示(HUD)**。在本章中，我们将解释创建这些元素的技术以及如何将它们整合到场景的基本结构中。
- en: Switching scenes
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切换场景
- en: A **scene** is the basic high-level `CCNode` object. All other nodes are considered
    children of a scene. Only one scene can be running at a time. Scenes are managed
    using a **stack** data structure. In this recipe, we will see how to **push**
    and **pop** scenes onto the stack.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**是基本的高级`CCNode`对象。所有其他节点都被视为场景的子节点。一次只能运行一个场景。场景使用**堆栈**数据结构进行管理。在本菜谱中，我们将看到如何**推入**和**弹出**场景到堆栈上。'
- en: '![Switching scenes](img/4002_05_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![切换场景](img/4002_05_01.jpg)'
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 *RecipeCollection02* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Execute the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The common convention in Cocos2d is to sub-class `CCLayer` when creating a simple
    scene. This allows us to couple our single `CCScene` to a `CCLayer` using only
    one class. That class inherits `CCLayer`, but it has a class method that returns
    itself packaged inside a `CCScene:`
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在Cocos2d中，常见的做法是在创建简单场景时对`CCLayer`进行子类化。这允许我们仅使用一个类将我们的单个`CCScene`与`CCLayer`耦合。这个类继承自`CCLayer`，但它有一个返回自身包装在`CCScene`中的类方法：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, our class is named `TreeSceneMenu`. By pressing one of its
    two buttons, you push another scene onto the stack with an appropriate sub-string
    name. This creates a binary tree of possible scene combinations. Popping the root
    scene will kick you back to the main recipe chooser scene.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的类名为`TreeSceneMenu`。通过按下其两个按钮之一，可以将另一个场景推入堆栈，并带有适当的子字符串名称。这创建了一个可能的场景组合的二叉树。弹出根场景将把你带回主菜谱选择场景。
- en: 'Layers versus scenes:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 层与场景：
- en: The layer/scene distinction is mostly a formal one. Scenes separate out the
    most basic parts of a game and are treated as such. For example, there are a number
    of transitions that can be used when going between scenes (see the next recipe).
    Layers, on the other hand, are designed to be the only nodes directly added to
    scenes. Layers are where all the action happens. Other nodes are attached to them
    and they implement the `TouchEventsDelegate` protocol to handle input. The only
    difference between scenes and layers is that scenes require a little more memory
    and processor overhead when pushed onto the stack. So, the fewer scenes on the
    stack at any one time, the better.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 层/场景的区别主要是一个形式上的区别。场景将游戏的最基本部分分离出来，并被视为这样。例如，在场景之间切换时可以使用多种过渡效果（见下一个菜谱）。另一方面，层被设计为是唯一直接添加到场景中的节点。层是所有动作发生的地方。其他节点附着在其上，并实现`TouchEventsDelegate`协议以处理输入。场景和层之间的唯一区别是，当场景被推入堆栈时，场景需要更多的内存和处理器的开销。因此，在任何时候堆栈上的场景越少，越好。
- en: Transitioning between scenes
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景之间的转换
- en: As mentioned in the previous recipe, scenes are the root CCNodes and only one
    can be running at a time. When switching between scenes, we can apply transitions
    to make the scene change more explicit and stylish. In this recipe, you can demo
    all of the built-in scene transitions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个菜谱中提到的，场景是根CCNodes，一次只能运行一个。在场景之间切换时，我们可以应用过渡效果，使场景变化更加明确和时尚。在这个菜谱中，你可以演示所有内置的场景过渡效果。
- en: '![Transitioning between scenes](img/4002_05_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![场景转换](img/4002_05_02.jpg)'
- en: Getting ready
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 *RecipeCollection02* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Execute the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `CCTransitionScene` class creates a transition effect, when it is instantiated
    with a regular `CCScene` and then immediately pushed onto the scene stack. This
    is done using the following lines:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用常规的 `CCScene` 实例化 `CCTransitionScene` 类并立即将其推入场景栈时，它将创建一个过渡效果。这是通过以下行完成的：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this example, we are using a ''fade to white'' transition while loading
    the `MyScene` scene. Here is a list of the built-in Cocos2d transition classes:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在加载 `MyScene` 场景时使用了一个“淡入白色”的过渡效果。以下是内置的 Cocos2d 过渡类列表：
- en: '`CCTransitionFadeTR, CCTransitionJumpZoom, CCTransitionMoveInL, CCTransitionSplitCols,
    CCTransitionSceneOriented. CCTransitionPageTurn, CCTransitionRadialCCW, CCTransitionFade,
    CCTransitionRotoZoom, CCTransitionShrinkGrow, CCTransitionSlideInL`, and `CCTransitionTurnOffTiles`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`CCTransitionFadeTR, CCTransitionJumpZoom, CCTransitionMoveInL, CCTransitionSplitCols,
    CCTransitionSceneOriented, CCTransitionPageTurn, CCTransitionRadialCCW, CCTransitionFade,
    CCTransitionRotoZoom, CCTransitionShrinkGrow, CCTransitionSlideInL`，以及 `CCTransitionTurnOffTiles`'
- en: There's more...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In addition to pushing a scene with a transition, you may also pop a scene
    with a transition by adding the following method to the `CCDirector` class:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用过渡效果推送场景外，你还可以通过向 `CCDirector` 类添加以下方法来使用过渡效果弹出场景：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This pops the scene with a nice transition effect.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这将以一个漂亮的过渡效果弹出场景。
- en: Using CCLayerMultiplex
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CCLayerMultiplex
- en: The `CCLayerMultiplex` class provides functionality to seamlessly switch between
    multiple layers. In this example, we have three similar layers assigned to a multiplex
    layer. Each layer displays buttons used to switch to any of the other layers.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`CCLayerMultiplex` 类提供了在多个层之间无缝切换的功能。在这个例子中，我们有三层相似的层分配给一个复用层。每个层显示用于切换到其他任何层的按钮。'
- en: '![Using CCLayerMultiplex](img/4002_05_03.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![使用 CCLayerMultiplex](img/4002_05_03.jpg)'
- en: Getting ready
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 *RecipeCollection02* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This technique offers an alternative style of control flow from that of switching
    between scenes. It allows the instantiation of multiple layers, and the on-the-fly
    activation and suspension of those layers. The multiplex layer is created using
    the following class method:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术提供了一种不同于场景切换之间的控制流风格的替代方式。它允许实例化多个层，并动态地激活和挂起这些层。通过以下类方法创建复用层：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are many ways to make use of this technique. It provides a flat alternative
    to hierarchically stacking scenes.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以利用这项技术。它提供了一个平铺的替代方案，用于分层堆叠场景。
- en: Using CCLabel
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CCLabel
- en: 'Throughout this book, we''ve been making use of a number of different label
    types. In this recipe, we will briefly explain the three commonly used label classes:
    `CCLabelAtlas, CCLabelBMFont,` and `CCLabelTTF`.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们一直在使用多种不同的标签类型。在这个菜谱中，我们将简要解释三个常用的标签类：`CCLabelAtlas, CCLabelBMFont,`
    和 `CCLabelTTF`。
- en: '![Using CCLabel](img/4002_05_04.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![使用 CCLabel](img/4002_05_04.jpg)'
- en: Getting ready
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 *RecipeCollection02* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Each label type has advantages and disadvantages.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 每种标签类型都有其优缺点。
- en: '`CCLabelAtlas:`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CCLabelAtlas:`'
- en: The simplest way to draw text onto the screen is to use the `CCLabelAtlas` class.
    This allows you to draw fixed-width bitmap fonts. It is a low-tech solution that
    essentially indexes a texture file sequentially using standard ASCII values. The
    only meta information provided is character size and what the first character
    in the map is.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在屏幕上绘制文本的最简单方法是使用 `CCLabelAtlas` 类。这允许你绘制固定宽度的位图字体。这是一个低技术解决方案，本质上是通过标准ASCII值顺序索引纹理文件。提供的唯一元信息是字符大小和地图中的第一个字符。
- en: '`CCLabelBMFont:`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CCLabelBMFont:`'
- en: 'The `CCLabelBMFont` class has the speed advantage of bitmap font drawing along
    with many other features. It uses the FNT file format to store non fixed-width
    bitmap fonts. These fonts can be created with a number of editors including **Hiero**,
    which can be found at: [http://www.n4te.com/hiero/hiero.jnlp](http://www.n4te.com/hiero/hiero.jnlp).
    `CCLabelBMFont` treats each character as a CCSprite sub-node. This allows us to
    manipulate them individually.'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`CCLabelBMFont` 类具有位图字体绘制的速度优势，以及许多其他功能。它使用 FNT 文件格式来存储非固定宽度位图字体。这些字体可以使用包括
    **Hiero** 在内的多个编辑器创建，Hiero 可以在以下网址找到：[http://www.n4te.com/hiero/hiero.jnlp](http://www.n4te.com/hiero/hiero.jnlp)。`CCLabelBMFont`
    将每个字符视为 CCSprite 子节点。这允许我们单独操作它们。'
- en: '`CCLabelTTF:`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CCLabelTTF:`'
- en: Finally, the `CCLabelTTF` class allows drawing of **TrueType** fonts. This allows
    for the convenience of using built-in system fonts as well as other TrueType fonts
    that you can specify. It must be noted that TrueType fonts render slowly and should
    only be used for static text. Bitmap fonts should be used for text that will be
    updated frequently like a score display.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，`CCLabelTTF` 类允许绘制 **TrueType** 字体。这允许使用内置系统字体以及其他您指定的 TrueType 字体。必须注意，TrueType
    字体的渲染速度较慢，应仅用于静态文本。对于将频繁更新的文本（如得分显示）应使用位图字体。
- en: Using CCMenu
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CCMenu
- en: Cocos2d provides menu tools that make the process of creating a simple menu
    very easy. In this example, we will see how to create a simple menu, adjust menu
    alignment, enable/disable menu items, and more.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d 提供的菜单工具使得创建简单菜单的过程变得非常简单。在这个例子中，我们将看到如何创建简单菜单，调整菜单对齐，启用/禁用菜单项，等等。
- en: '![Using CCMenu](img/4002_05_05.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![使用 CCMenu](img/4002_05_05.jpg)'
- en: Getting ready
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 *RecipeCollection02* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The `CCMenu` class acts as a container holding a configurable list of `CCMenuItem`
    objects:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`CCMenu` 类充当一个容器，其中包含可配置的 `CCMenuItem` 对象列表：'
- en: '`CCMenuItemFont:`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CCMenuItemFont:`'
- en: 'The `CCMenuItemFont` class is a helper class designed to quickly create `CCMenuItemLabel`
    objects using TrueType fonts. It provides class methods which act as shortcuts
    to ease the process of creating a menu item label. Font name and size are set
    through class methods:'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`CCMenuItemFont` 类是一个辅助类，旨在通过类方法快速创建使用 TrueType 字体的 `CCMenuItemLabel` 对象。它提供了作为创建菜单项标签过程快捷方式的类方法。字体名称和大小通过类方法设置：'
- en: '[PRE9]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A `CCMenuItemFont` object is then created through a class method:'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后通过类方法创建一个 `CCMenuItemFont` 对象：
- en: '[PRE10]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This class is used throughout the book to create menus item labels.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个类在整本书中用于创建菜单项标签。
- en: '`CCMenuItemLabel:`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CCMenuItemLabel:`'
- en: 'For more control over menu item labels, you can use `CCMenuItemLabel` directly:'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了对菜单项标签有更多控制，您可以直接使用 `CCMenuItemLabel`：
- en: '[PRE11]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This allows you to add bitmap fonts using `CCLabelBMFont` and `CCLabelAtlas`.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这允许您使用 `CCLabelBMFont` 和 `CCLabelAtlas` 添加位图字体。
- en: '`CCMenuItemSprite:`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CCMenuItemSprite:`'
- en: 'The `CCMenuItemSprite` class creates a tappable button as a menu item instead
    of a textual label:'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`CCMenuItemSprite` 类创建一个可触摸的按钮作为菜单项，而不是文本标签：'
- en: '[PRE12]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Two or three sprites are recommended to create a compelling button effect.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 建议使用两个或三个精灵来创建引人注目的按钮效果。
- en: '`CCMenuItemToggle:` A toggle-able menu item contains a list of menu items to
    iterate through:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CCMenuItemToggle:` 可切换的菜单项包含一个要迭代的菜单项列表：'
- en: '[PRE13]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The current state can be identified by the `selectedIndex` property on the menu
    item. This is usually handled in the item's callback method.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以通过菜单项上的 `selectedIndex` 属性识别当前状态。这通常在项的回调方法中处理。
- en: 'Automatically aligning menu items:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动对齐菜单项：
- en: 'By using the following methods, a `CCMenu` object''s items can be aligned horizontally
    or vertically:'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过使用以下方法，可以水平或垂直对齐 `CCMenu` 对象的项：
- en: '[PRE14]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Menus can also be aligned in columns or rows:'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 菜单也可以按列或行对齐：
- en: '[PRE15]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The list of `NSNumber` objects must total the number of menu items attached
    to the menu for the alignment to process correctly.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`NSNumber` 对象的列表总数必须等于附加到菜单的菜单项数量，以便正确处理对齐。'
- en: 'Manually aligning menu items:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动对齐菜单项：
- en: Menu items can also be manually positioned using the `position` property like
    on any other `CCNode` object.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 菜单项也可以像任何其他 `CCNode` 对象一样使用 `position` 属性手动定位。
- en: 'Enabling/disabling menu items:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用/禁用菜单项：
- en: All menu items can be disabled so as to make them ignore touches. Labels can
    have their `disabledColor` property set to indicate this, while instances of `CCMenuItemSprite`
    have a specific sprite set to indicate this.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有菜单项都可以被禁用，以便它们忽略触摸。标签可以将它们的 `disabledColor` 属性设置为指示这一点，而 `CCMenuItemSprite`
    的实例有一个特定的精灵来指示这一点。
- en: Creating shadowed menu labels
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建阴影菜单标签
- en: With a dynamic swirl of colors often in the background, labels can sometimes
    be hard to identify onscreen. To remedy this, we can create labels with dark shadows
    behind them. In this recipe, we will create a few of these labels.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 常常在背景中有一个动态的色彩漩涡，标签有时在屏幕上难以识别。为了解决这个问题，我们可以创建带有暗阴影的标签。在这个菜谱中，我们将创建几个这样的标签。
- en: '![Creating shadowed menu labels](img/4002_05_06.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![创建阴影菜单标签](img/4002_05_06.jpg)'
- en: Getting ready
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅项目 *RecipeCollection02* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Execute the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `ShadowLabel` class creates a child `CCMenuItemLabel` object that is positioned
    behind and slightly to the side of its parent. Methods are overriden, so the two
    labels are synchronized.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShadowLabel` 类创建了一个位于其父对象后面并稍微偏向一侧的子 `CCMenuItemLabel` 对象。方法被覆盖，因此两个标签是同步的。'
- en: 'Caveats:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意事项：
- en: The only caveat to this approach is that menus using this class cannot be auto-aligned,
    as the 'shadow' label must also be added as a menu item.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种方法的唯一缺点是，使用此类的菜单无法自动对齐，因为“阴影”标签也必须作为菜单项添加。
- en: There's More...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: In this example, we set the `tag` property on each `ShadowLabel` so it can be
    properly identified during a callback. This is the same `tag` property that we've
    used in the past; only it has been re-purposed for this role.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们为每个 `ShadowLabel` 设置了 `tag` 属性，以便在回调期间正确识别。这与我们过去使用的相同的 `tag` 属性；只是它被重新用于这个角色。
- en: 'Adding shadows in a font editor:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在字体编辑器中添加阴影：
- en: As an alternative to technique used previously, shadows can be added to TrueType
    font using a font editor. The trade-off here is less code and a faster render
    time. But, you must first take time to add the shadows to the font in the editor.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为之前使用技术的替代方案，可以使用字体编辑器将阴影添加到 TrueType 字体中。这里的权衡是代码更少，渲染时间更快。但是，您必须首先花时间在编辑器中将阴影添加到字体中。
- en: UIKit alert dialogs
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UIKit 警告对话框
- en: In the next two recipes, we will experiment with the black art of integrating
    **UIKit** elements into a Cocos2d game. In this example, we see a UIKit **alert**
    dialog with choices and associated callback methods.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个菜谱中，我们将尝试将 **UIKit** 元素集成到 Cocos2d 游戏中的黑色艺术。在这个例子中，我们看到一个带有选择和关联回调方法的
    UIKit **警告** 对话框。
- en: '![UIKit alert dialogs](img/4002_05_07.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![UIKit 警告对话框](img/4002_05_07.jpg)'
- en: Getting ready
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅项目 *RecipeCollection02* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Execute the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Showing an alert is fairly straightforward. We instantiate a `UIAlertView` object
    with some basic information and then call the `show` method. This launches our
    alert.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 显示一个警告信息相对直接。我们创建一个包含一些基本信息 `UIAlertView` 对象，然后调用 `show` 方法。这会启动我们的警告。
- en: Using `UIAlertViewDelegate:`
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `UIAlertViewDelegate`：
- en: 'The `UIAlertViewDelegate` protocol dictates that we handle the following method:'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`UIAlertViewDelegate` 协议规定我们处理以下方法：'
- en: '[PRE18]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This allows us to handle alert responses by inspecting the returned buttonIndex
    variable.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这允许我们通过检查返回的 `buttonIndex` 变量来处理警告响应。
- en: Wrapping UIKit
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包装 UIKit
- en: Other UIKit classes offer a wide range of time-tested UI functionality. Cocos2d
    requires the use of a UIKit wrapper to transform UIKit objects into `CCNode` objects,
    so that they may be manipulated properly. In this example, we will wrap two different
    classes and manipulate them onscreen.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 其他 UIKit 类提供了一系列经过时间考验的 UI 功能。Cocos2d 需要使用 UIKit 包装器将 UIKit 对象转换为 `CCNode` 对象，以便正确操作。在这个例子中，我们将包装两个不同的类并在屏幕上操作它们。
- en: '![Wrapping UIKit](img/4002_05_08.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![包装 UIKit](img/4002_05_08.jpg)'
- en: Getting ready
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅项目 *RecipeCollection02* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Execute the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `CCUIViewWrapper` takes any `UIView` object in its main creation class
    method:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`CCUIViewWrapper` 在其主创建类方法中接受任何 `UIView` 对象：'
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This object can be manipulated like a normal `CCSprite` object.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象可以被像正常的 `CCSprite` 对象一样操作。
- en: '`UIButton:`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIButton:`'
- en: The advantages of using UIKit classes are numerous. The `UIButton` class allows
    for the creation of a nifty button with text on it.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 UIKit 类的优点有很多。`UIButton` 类允许创建带有文本的巧妙按钮。
- en: '`UIScrollView:`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIScrollView:`'
- en: In our other example, we create a more complex `UIScrollView` object. Although
    the syntax is somewhat messier than using a built-in Cocos2d class, the slick
    functionality provided by this UIKit view is difficult to duplicate.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的另一个示例中，我们创建了一个更复杂的 `UIScrollView` 对象。尽管语法比使用内置的 Cocos2d 类要混乱一些，但这个 UIKit
    视图提供的流畅功能很难复制。
- en: 'Mixing actions:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合动作：
- en: If you scroll the `UIScrollView` object, you will see that the `UIButton` on
    the right stops spinning. Some UIKit actions take precedence over asynchronous
    Cocos2d actions.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你滚动 `UIScrollView` 对象，你会看到右侧的 `UIButton` 停止旋转。一些 UIKit 动作比异步 Cocos2d 动作具有优先级。
- en: 'Autorotation and the UIKit wrapper:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动旋转和 UIKit 包装器：
- en: 'One limitation of this wrapper is that it does not currently work with Cocos2d
    auto-rotation. If you rotate your device, while using this recipe, you''ll see
    that the elements onscreen do not rotate along with the screen. It is recommended
    that you use the following line in your `GameConfig.h` file:'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个包装器的一个限制是它目前不能与 Cocos2d 自动旋转一起工作。如果你在使用这个配方时旋转设备，你会看到屏幕上的元素并没有随着屏幕一起旋转。建议你在
    `GameConfig.h` 文件中使用以下行：
- en: '[PRE21]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will disable auto-rotation.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将禁用自动旋转。
- en: 'The power of UIKit:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UIKit 的力量：
- en: It is best to use this wrapper as a starting point for experimenting with UIKit
    classes. Cocos2d and UIKit don't always play nice together, but being able to
    leverage a robust UI library like UIKit can help create fancier menus without
    the headaches of writing and testing your own UI code.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最好将此包装器作为实验 UIKit 类的起点。Cocos2d 和 UIKit 并不总是相处融洽，但能够利用像 UIKit 这样的强大 UI 库可以帮助创建更复杂的菜单，而无需编写和测试自己的
    UI 代码。
- en: Creating draggable menu windows
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可拖拽的菜单窗口
- en: Cocos2d is commonly thought of as a game development library and it has been
    treated as such in much of this book. However, Cocos2d is a robust solution for
    any 2D application. That said, draggable windows are a common element in many
    applications. In this example, we will create movable, collapsable menu windows.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d 通常被认为是一个游戏开发库，在这本书的大部分内容中都被这样对待。然而，Cocos2d 是任何 2D 应用程序的强大解决方案。话虽如此，可拖拽窗口是许多应用程序中的常见元素。在这个示例中，我们将创建可移动、可折叠的菜单窗口。
- en: '![Creating draggable menu windows](img/4002_05_09.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![创建可拖拽的菜单窗口](img/4002_05_09.jpg)'
- en: Getting ready
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 *RecipeCollection02* 以获取此配方的完整工作代码。
- en: How to do it...
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Execute the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The windows shown previously can be moved around by touching a title bar and
    then dragging. Pressing the plus/minus symbol expands or collapses the window
    content.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 之前显示的窗口可以通过触摸标题栏然后拖动来移动。按下加减符号可以展开或折叠窗口内容。
- en: 'Creating the title bar:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建标题栏：
- en: The title bar and other parts of each window are created using the colored `blank.png`
    sprite technique. The label used in the title bar is anchored to the left, to
    left-align the text.
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个窗口的标题栏和其他部分都是使用彩色 `blank.png` 精灵技术创建的。标题栏中使用的标签锚定在左侧，以实现文本左对齐。
- en: 'Adding content to a window:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向窗口添加内容：
- en: Nodes can be added to the `content` sprite to add window content. This can include
    text, images, dynamic content, and so on. Please note that, in this example, nodes
    added to the `content` sprite are not clipped and can appear outside the window
    depending on node position.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以将节点添加到 `content` 精灵中，以添加窗口内容。这可以包括文本、图像、动态内容等等。请注意，在这个示例中，添加到 `content` 精灵中的节点不会被裁剪，并且可以根据节点位置出现在窗口之外。
- en: 'Sorting the windows:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序窗口：
- en: 'Before we can properly interact with the windows, they must be sorted by their
    `zOrder` property:'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们能够正确地与窗口交互之前，它们必须按照它们的 `zOrder` 属性进行排序：
- en: '[PRE23]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `NSSortDescriptor` class allows you to sort an `NSArray` container based
    on a common property of the objects being sorted. We specify the key `"self.zOrder"`.
    This re-orders the array according to the `Order`z property. Now, when we iterate
    through the array looking for a touched window, the first one we find will be
    the window that appears on top.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`NSSortDescriptor` 类允许您根据排序对象的公共属性对 `NSArray` 容器进行排序。我们指定键 `"self.zOrder"`。这将根据
    `Order`z 属性重新排序数组。现在，当我们遍历数组寻找被触摸的窗口时，我们找到的第一个窗口将是出现在顶部的窗口。'
- en: Creating a horizontal scrollable menu
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个水平可滚动菜单
- en: Cocos2d provides the rather mundane `CCMenuItemToggle` class to iterate through
    multiple `CCMenuItem` choices. In this example, we'll spice this up with the `LoopingMenu`
    class that mimics the iPod Touch album art shuffling visual technique.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d 提供了相当平凡的 `CCMenuItemToggle` 类来遍历多个 `CCMenuItem` 选择。在这个例子中，我们将使用模仿 iPod
    Touch 专辑艺术随机播放视觉技术的 `LoopingMenu` 类来增加一些趣味。
- en: '![Creating a horizontal scrollable menu](img/4002_05_10.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![创建带有指示器的加载屏幕](img/4002_05_10.jpg)'
- en: Getting ready
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 *RecipeCollection02* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE24]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `LoopingMenu` class inherits the `CCMenu` class. It uses the same basic
    creation method:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoopingMenu` 类继承自 `CCMenu` 类。它使用相同的基本创建方法：'
- en: '[PRE25]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This creates an endlessly scrollable menu using the `CCMenuItem` objects provided.
    In this case, we use `CCMenuItemSprite` objects.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过使用提供的 `CCMenuItem` 对象创建一个无限滚动的菜单。在这种情况下，我们使用 `CCMenuItemSprite` 对象。
- en: 'Caveats:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意事项：
- en: The one caveat with this technique is that the `CCMenuItem` objects are constantly
    rescaled. So, menu items cannot be rescaled before adding them to the `LoopingMenu`
    instance. The full image or label sizes must be used.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种技术的缺点是 `CCMenuItem` 对象会不断缩放。因此，在将菜单项添加到 `LoopingMenu` 实例之前，不能对菜单项进行缩放。必须使用完整图像或标签的大小。
- en: Creating a vertical sliding menu grid
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个垂直滑动菜单网格
- en: Sometimes, you want a large number of menu choices onscreen at once. In this
    example, we see the `SlidingMenuGrid` class in action.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你希望在屏幕上同时显示大量菜单选项。在这个例子中，我们看到 `SlidingMenuGrid` 类在行动。
- en: '![Creating a vertical sliding menu grid](img/4002_05_11.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![创建垂直滑动菜单网格](img/4002_05_11.jpg)'
- en: Getting ready
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 *RecipeCollection02* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE26]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works...
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Largely inspired by the über popular iOS game, Angry Birds, the `SlidingMenuGrid`
    class takes an array of `CCMenuItem` objects and arranges them in rows and columns
    as specified:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 主要受超受欢迎的 iOS 游戏 Angry Birds 的启发，`SlidingMenuGrid` 类接受一个 `CCMenuItem` 对象数组，并将它们按指定的行和列排列：
- en: '[PRE27]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Menu items are divided up into pages depending on how many there are and how
    they fit onscreen.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 根据数量和它们在屏幕上的布局，菜单项被分成页面。
- en: 'Going from page to page:'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一个页面切换到另一个页面：
- en: Sliding vertically across the menu will switch from page to page.
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 垂直滑动菜单将从一个页面切换到另一个页面。
- en: Tweaking `SlidingMenuGrid:`
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '调整 `SlidingMenuGrid`: '
- en: If you inspect `SlidingMenuGrid.h` and `SlidingMenuGrid.mm`, you can see a number
    of variables that determine the behavior of the menu grid, including the distance
    required to 'page' the menu and paging animation speed.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你检查 `SlidingMenuGrid.h` 和 `SlidingMenuGrid.mm`，你可以看到许多变量，这些变量决定了菜单网格的行为，包括需要多少距离来“翻页”菜单以及翻页动画速度。
- en: Creating a loading screen with an indicator
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建带有指示器的加载屏幕
- en: Games with large levels often incur long load times. If level elements can be
    loaded in asynchronous steps, then we can give the user some reassuring feedback
    that the game is still loading and hasn't crashed.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 大型关卡的游戏往往需要较长的加载时间。如果关卡元素可以异步加载，那么我们可以给用户一些令人放心的反馈，表明游戏仍在加载，并未崩溃。
- en: '![Creating a loading screen with an indicator](img/4002_05_12.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![创建带有指示器的加载屏幕](img/4002_05_12.jpg)'
- en: Getting ready
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 *RecipeCollection02* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE28]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works...
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe reads through a JSON file and loads the images specified. For more
    information about loading data from a JSON file, please refer to the recipe entitled
    *Reading JSON data files* located in [Chapter 3](ch03.html "Chapter 3. Files and
    Data"), *Files and Data*. Here, in total, we load 10 images, totaling about 6
    megabytes. Loading time depends on the device the application is running on (the
    simulator, the iPhone 4, the iPad, and so on).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱读取 JSON 文件并加载指定的图像。有关从 JSON 文件加载数据的更多信息，请参阅位于 [第 3 章](ch03.html "第 3 章。文件和数据")、*文件和数据*
    的菜谱 *Reading JSON data files*。在这里，总共加载了 10 张图像，总大小约为 6 兆字节。加载时间取决于应用程序运行的设备（模拟器、iPhone
    4、iPad 等）。
- en: 'Asynchronous texture loading:'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步纹理加载：
- en: 'We can create this loading screen because we have the capability to asynchronously
    load textures using the following method call:'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以创建这个加载屏幕，因为我们有使用以下方法调用来异步加载纹理的能力：
- en: '[PRE29]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Every time the nodeLoaded callback fires, we increment a counter to keep track
    of files loaded. Even though this ignores the variance of file sizes being loaded,
    this gives us a rough estimate of how far along we are in the loading process.
    Displaying this graphically in a bar, gives the user some basic visual feedback
    without going into too much detail.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每当 nodeLoaded 回调触发时，我们增加一个计数器以跟踪已加载的文件。尽管这忽略了正在加载的文件大小的变化，但这给我们提供了一个粗略的估计，了解我们在加载过程中的进度。以条形图的形式图形化显示，给用户一些基本的视觉反馈，而不需要过多细节。
- en: 'Switching to the game scene:'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切换到游戏场景：
- en: Once all the images are loaded asynchronously, we pop the loading scene and
    switch to the main game scene. The JSON file name is passed along so that a second
    pass can be made to actually display the images onscreen. Because these images
    have been pre-loaded, the scene displays immediately.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦所有图像异步加载完成，我们就弹出加载场景并切换到主游戏场景。JSON 文件名被传递过去，以便进行第二次遍历，实际上在屏幕上显示图像。因为这些图像已经预先加载，所以场景立即显示。
- en: 'Unloading textures:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卸载纹理：
- en: 'When we are finished with our game, we unload all loaded textures:'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们完成游戏后，我们卸载所有已加载的纹理：
- en: '[PRE30]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This unloads all loaded textures including ones loaded anywhere else in the
    application. Textures can also be removed manually by calling the `release` method
    on the ones to be removed, and then calling the `removeUnusedTextures` method
    on the `sharedTextureCache` singleton. Keep in mind that `removeUnusedTextures`
    also removes textures added to `CCTextureCache`. It might be safer to remove textures
    individually using one of the following methods:'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将卸载所有已加载的纹理，包括在应用程序的任何其他地方加载的纹理。也可以通过在要删除的纹理上调用 `release` 方法，然后调用 `sharedTextureCache`
    单例的 `removeUnusedTextures` 方法来手动删除纹理。请注意，`removeUnusedTextures` 也会删除添加到 `CCTextureCache`
    的纹理。可能更安全的是使用以下方法之一逐个删除纹理：
- en: '[PRE31]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Creating a minimap
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建最小地图
- en: An engaging and informative in-game HUD is a crucial piece of most games. Mobile
    games, in particular, often blend user input with heads-up information due to
    the small amount of screen real estate available. In this example, we will create
    a **Minimap** to help the player navigate the terrain in the isometric game demo
    from the last chapter.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一个引人入胜且信息丰富的游戏内 HUD 是大多数游戏的关键部分。特别是移动游戏，由于屏幕空间有限，通常会将用户输入与抬头显示信息结合起来。在这个例子中，我们将创建一个
    **最小地图** 来帮助玩家导航上一章中的等距游戏演示中的地形。
- en: '![Creating a minimap](img/4002_05_13.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![创建最小地图](img/4002_05_13.jpg)'
- en: Getting ready
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅项目 *RecipeCollection02* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE32]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works...
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The minimap shown in this example, is basically a simple graphical representation
    of the Box2D world similar to that of the Box2D debug drawing routines. In this
    instance, we have tailored the OpenGL drawing code to fit our needs.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中所示的最小地图基本上是 Box2D 世界的一个简单图形表示，类似于 Box2D 调试绘图例程。在这种情况下，我们调整了 OpenGL 绘图代码以适应我们的需求。
- en: 'Generalizing the minimap:'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小地图的泛化：
- en: The `Minimap` class generalizes physical elements into a number of types and
    then draws these types using specific colors. These include walls, projectiles,
    static objects, and a central actor.
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Minimap` 类将物理元素泛化成多种类型，然后使用特定的颜色绘制这些类型。这包括墙壁、投射物、静态物体和中心演员。'
- en: 'Walls:'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 墙：
- en: Wall vertices are stored in two `NSMutableArray` objects. These are designed
    to be set initially and never updated.
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 墙的顶点存储在两个 `NSMutableArray` 对象中。这些对象被设计为初始设置后不再更新。
- en: 'Projectiles:'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投射物：
- en: Projectile coordinates are stored in a single `NSMutableDictionary` object.
    This allows us to update all projectiles repeatedly by using their `tag` property
    as a key in the dictionary. The implication is that projectiles are in a constant
    state of movement.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 弹道坐标存储在一个单独的 `NSMutableDictionary` 对象中。这使得我们可以通过使用字典中的 `tag` 属性作为键来重复更新所有弹道。这意味着弹道处于持续运动的状态。
- en: 'Static objects:'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态对象：
- en: Static objects in this example are trees. They represent static points on the
    map that do not move. They are drawn with the same color as the walls. Size information
    is not stored as it is assumed that static objects are not very large.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本例中的静态对象是树木。它们代表地图上的静态点，不会移动。它们用与墙壁相同的颜色绘制。大小信息没有存储，因为假设静态对象不是很大。
- en: 'The central actor:'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中心角色：
- en: Finally, a central actor position is shown as a large blue point.
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，中心角色的位置以一个大的蓝色点表示。
- en: 'Customizing the `Minimap` class:'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义 `Minimap` 类：
- en: The `Minimap` class represents a generic template that can be customized for
    any game type or situation. By changing the `scale` property, position information,
    and drawing routine, the `Minimap` can
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Minimap` 类代表一个通用的模板，可以针对任何游戏类型或情况进行自定义。通过更改 `scale` 属性、位置信息和绘制程序，`Minimap`
    可以'
