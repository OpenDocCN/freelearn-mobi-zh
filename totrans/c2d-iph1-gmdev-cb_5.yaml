- en: Chapter 5. Scenes and Menus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Switching scenes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transitioning between scenes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using CCLayerMultiplex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using CCLabel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using CCMenu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating shadowed menu labels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UIKit alert dialogs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping UIKit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating draggable menu windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a horizontal scrollable menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a vertical sliding menu grid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a loading screen with indicator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a minimap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All games have auxillary **Graphical User Interface (GUI)** requirements like
    **menus** and in-game **Heads-Up Displays(HUD)** . In this chapter, we will explain
    the techniques used to create these elements as well as how to incorporate them
    into an underlying structure of scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Switching scenes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **scene** is the basic high-level `CCNode` object. All other nodes are considered
    children of a scene. Only one scene can be running at a time. Scenes are managed
    using a **stack** data structure. In this recipe, we will see how to **push**
    and **pop** scenes onto the stack.
  prefs: []
  type: TYPE_NORMAL
- en: '![Switching scenes](img/4002_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The common convention in Cocos2d is to sub-class `CCLayer` when creating a simple
    scene. This allows us to couple our single `CCScene` to a `CCLayer` using only
    one class. That class inherits `CCLayer`, but it has a class method that returns
    itself packaged inside a `CCScene:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example, our class is named `TreeSceneMenu`. By pressing one of its
    two buttons, you push another scene onto the stack with an appropriate sub-string
    name. This creates a binary tree of possible scene combinations. Popping the root
    scene will kick you back to the main recipe chooser scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'Layers versus scenes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The layer/scene distinction is mostly a formal one. Scenes separate out the
    most basic parts of a game and are treated as such. For example, there are a number
    of transitions that can be used when going between scenes (see the next recipe).
    Layers, on the other hand, are designed to be the only nodes directly added to
    scenes. Layers are where all the action happens. Other nodes are attached to them
    and they implement the `TouchEventsDelegate` protocol to handle input. The only
    difference between scenes and layers is that scenes require a little more memory
    and processor overhead when pushed onto the stack. So, the fewer scenes on the
    stack at any one time, the better.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Transitioning between scenes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the previous recipe, scenes are the root CCNodes and only one
    can be running at a time. When switching between scenes, we can apply transitions
    to make the scene change more explicit and stylish. In this recipe, you can demo
    all of the built-in scene transitions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Transitioning between scenes](img/4002_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `CCTransitionScene` class creates a transition effect, when it is instantiated
    with a regular `CCScene` and then immediately pushed onto the scene stack. This
    is done using the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we are using a ''fade to white'' transition while loading
    the `MyScene` scene. Here is a list of the built-in Cocos2d transition classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CCTransitionFadeTR, CCTransitionJumpZoom, CCTransitionMoveInL, CCTransitionSplitCols,
    CCTransitionSceneOriented. CCTransitionPageTurn, CCTransitionRadialCCW, CCTransitionFade,
    CCTransitionRotoZoom, CCTransitionShrinkGrow, CCTransitionSlideInL`, and `CCTransitionTurnOffTiles`'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to pushing a scene with a transition, you may also pop a scene
    with a transition by adding the following method to the `CCDirector` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This pops the scene with a nice transition effect.
  prefs: []
  type: TYPE_NORMAL
- en: Using CCLayerMultiplex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `CCLayerMultiplex` class provides functionality to seamlessly switch between
    multiple layers. In this example, we have three similar layers assigned to a multiplex
    layer. Each layer displays buttons used to switch to any of the other layers.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using CCLayerMultiplex](img/4002_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This technique offers an alternative style of control flow from that of switching
    between scenes. It allows the instantiation of multiple layers, and the on-the-fly
    activation and suspension of those layers. The multiplex layer is created using
    the following class method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There are many ways to make use of this technique. It provides a flat alternative
    to hierarchically stacking scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Using CCLabel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout this book, we''ve been making use of a number of different label
    types. In this recipe, we will briefly explain the three commonly used label classes:
    `CCLabelAtlas, CCLabelBMFont,` and `CCLabelTTF`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using CCLabel](img/4002_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each label type has advantages and disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: '`CCLabelAtlas:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The simplest way to draw text onto the screen is to use the `CCLabelAtlas` class.
    This allows you to draw fixed-width bitmap fonts. It is a low-tech solution that
    essentially indexes a texture file sequentially using standard ASCII values. The
    only meta information provided is character size and what the first character
    in the map is.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`CCLabelBMFont:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `CCLabelBMFont` class has the speed advantage of bitmap font drawing along
    with many other features. It uses the FNT file format to store non fixed-width
    bitmap fonts. These fonts can be created with a number of editors including **Hiero**,
    which can be found at: [http://www.n4te.com/hiero/hiero.jnlp](http://www.n4te.com/hiero/hiero.jnlp).
    `CCLabelBMFont` treats each character as a CCSprite sub-node. This allows us to
    manipulate them individually.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`CCLabelTTF:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the `CCLabelTTF` class allows drawing of **TrueType** fonts. This allows
    for the convenience of using built-in system fonts as well as other TrueType fonts
    that you can specify. It must be noted that TrueType fonts render slowly and should
    only be used for static text. Bitmap fonts should be used for text that will be
    updated frequently like a score display.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using CCMenu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cocos2d provides menu tools that make the process of creating a simple menu
    very easy. In this example, we will see how to create a simple menu, adjust menu
    alignment, enable/disable menu items, and more.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using CCMenu](img/4002_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `CCMenu` class acts as a container holding a configurable list of `CCMenuItem`
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CCMenuItemFont:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `CCMenuItemFont` class is a helper class designed to quickly create `CCMenuItemLabel`
    objects using TrueType fonts. It provides class methods which act as shortcuts
    to ease the process of creating a menu item label. Font name and size are set
    through class methods:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A `CCMenuItemFont` object is then created through a class method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This class is used throughout the book to create menus item labels.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`CCMenuItemLabel:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For more control over menu item labels, you can use `CCMenuItemLabel` directly:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This allows you to add bitmap fonts using `CCLabelBMFont` and `CCLabelAtlas`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`CCMenuItemSprite:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `CCMenuItemSprite` class creates a tappable button as a menu item instead
    of a textual label:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Two or three sprites are recommended to create a compelling button effect.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`CCMenuItemToggle:` A toggle-able menu item contains a list of menu items to
    iterate through:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The current state can be identified by the `selectedIndex` property on the menu
    item. This is usually handled in the item's callback method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Automatically aligning menu items:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By using the following methods, a `CCMenu` object''s items can be aligned horizontally
    or vertically:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Menus can also be aligned in columns or rows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The list of `NSNumber` objects must total the number of menu items attached
    to the menu for the alignment to process correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Manually aligning menu items:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Menu items can also be manually positioned using the `position` property like
    on any other `CCNode` object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Enabling/disabling menu items:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All menu items can be disabled so as to make them ignore touches. Labels can
    have their `disabledColor` property set to indicate this, while instances of `CCMenuItemSprite`
    have a specific sprite set to indicate this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating shadowed menu labels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a dynamic swirl of colors often in the background, labels can sometimes
    be hard to identify onscreen. To remedy this, we can create labels with dark shadows
    behind them. In this recipe, we will create a few of these labels.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating shadowed menu labels](img/4002_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ShadowLabel` class creates a child `CCMenuItemLabel` object that is positioned
    behind and slightly to the side of its parent. Methods are overriden, so the two
    labels are synchronized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Caveats:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only caveat to this approach is that menus using this class cannot be auto-aligned,
    as the 'shadow' label must also be added as a menu item.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's More...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we set the `tag` property on each `ShadowLabel` so it can be
    properly identified during a callback. This is the same `tag` property that we've
    used in the past; only it has been re-purposed for this role.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding shadows in a font editor:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an alternative to technique used previously, shadows can be added to TrueType
    font using a font editor. The trade-off here is less code and a faster render
    time. But, you must first take time to add the shadows to the font in the editor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: UIKit alert dialogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next two recipes, we will experiment with the black art of integrating
    **UIKit** elements into a Cocos2d game. In this example, we see a UIKit **alert**
    dialog with choices and associated callback methods.
  prefs: []
  type: TYPE_NORMAL
- en: '![UIKit alert dialogs](img/4002_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Showing an alert is fairly straightforward. We instantiate a `UIAlertView` object
    with some basic information and then call the `show` method. This launches our
    alert.
  prefs: []
  type: TYPE_NORMAL
- en: Using `UIAlertViewDelegate:`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `UIAlertViewDelegate` protocol dictates that we handle the following method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This allows us to handle alert responses by inspecting the returned buttonIndex
    variable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Wrapping UIKit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Other UIKit classes offer a wide range of time-tested UI functionality. Cocos2d
    requires the use of a UIKit wrapper to transform UIKit objects into `CCNode` objects,
    so that they may be manipulated properly. In this example, we will wrap two different
    classes and manipulate them onscreen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Wrapping UIKit](img/4002_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `CCUIViewWrapper` takes any `UIView` object in its main creation class
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This object can be manipulated like a normal `CCSprite` object.
  prefs: []
  type: TYPE_NORMAL
- en: '`UIButton:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The advantages of using UIKit classes are numerous. The `UIButton` class allows
    for the creation of a nifty button with text on it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`UIScrollView:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our other example, we create a more complex `UIScrollView` object. Although
    the syntax is somewhat messier than using a built-in Cocos2d class, the slick
    functionality provided by this UIKit view is difficult to duplicate.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Mixing actions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you scroll the `UIScrollView` object, you will see that the `UIButton` on
    the right stops spinning. Some UIKit actions take precedence over asynchronous
    Cocos2d actions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Autorotation and the UIKit wrapper:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One limitation of this wrapper is that it does not currently work with Cocos2d
    auto-rotation. If you rotate your device, while using this recipe, you''ll see
    that the elements onscreen do not rotate along with the screen. It is recommended
    that you use the following line in your `GameConfig.h` file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will disable auto-rotation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The power of UIKit:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is best to use this wrapper as a starting point for experimenting with UIKit
    classes. Cocos2d and UIKit don't always play nice together, but being able to
    leverage a robust UI library like UIKit can help create fancier menus without
    the headaches of writing and testing your own UI code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating draggable menu windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cocos2d is commonly thought of as a game development library and it has been
    treated as such in much of this book. However, Cocos2d is a robust solution for
    any 2D application. That said, draggable windows are a common element in many
    applications. In this example, we will create movable, collapsable menu windows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating draggable menu windows](img/4002_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The windows shown previously can be moved around by touching a title bar and
    then dragging. Pressing the plus/minus symbol expands or collapses the window
    content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating the title bar:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The title bar and other parts of each window are created using the colored `blank.png`
    sprite technique. The label used in the title bar is anchored to the left, to
    left-align the text.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Adding content to a window:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nodes can be added to the `content` sprite to add window content. This can include
    text, images, dynamic content, and so on. Please note that, in this example, nodes
    added to the `content` sprite are not clipped and can appear outside the window
    depending on node position.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Sorting the windows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we can properly interact with the windows, they must be sorted by their
    `zOrder` property:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `NSSortDescriptor` class allows you to sort an `NSArray` container based
    on a common property of the objects being sorted. We specify the key `"self.zOrder"`.
    This re-orders the array according to the `Order`z property. Now, when we iterate
    through the array looking for a touched window, the first one we find will be
    the window that appears on top.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating a horizontal scrollable menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cocos2d provides the rather mundane `CCMenuItemToggle` class to iterate through
    multiple `CCMenuItem` choices. In this example, we'll spice this up with the `LoopingMenu`
    class that mimics the iPod Touch album art shuffling visual technique.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a horizontal scrollable menu](img/4002_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `LoopingMenu` class inherits the `CCMenu` class. It uses the same basic
    creation method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This creates an endlessly scrollable menu using the `CCMenuItem` objects provided.
    In this case, we use `CCMenuItemSprite` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Caveats:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The one caveat with this technique is that the `CCMenuItem` objects are constantly
    rescaled. So, menu items cannot be rescaled before adding them to the `LoopingMenu`
    instance. The full image or label sizes must be used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating a vertical sliding menu grid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you want a large number of menu choices onscreen at once. In this
    example, we see the `SlidingMenuGrid` class in action.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a vertical sliding menu grid](img/4002_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Largely inspired by the über popular iOS game, Angry Birds, the `SlidingMenuGrid`
    class takes an array of `CCMenuItem` objects and arranges them in rows and columns
    as specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Menu items are divided up into pages depending on how many there are and how
    they fit onscreen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going from page to page:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sliding vertically across the menu will switch from page to page.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tweaking `SlidingMenuGrid:`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you inspect `SlidingMenuGrid.h` and `SlidingMenuGrid.mm`, you can see a number
    of variables that determine the behavior of the menu grid, including the distance
    required to 'page' the menu and paging animation speed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating a loading screen with an indicator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Games with large levels often incur long load times. If level elements can be
    loaded in asynchronous steps, then we can give the user some reassuring feedback
    that the game is still loading and hasn't crashed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a loading screen with an indicator](img/4002_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe reads through a JSON file and loads the images specified. For more
    information about loading data from a JSON file, please refer to the recipe entitled
    *Reading JSON data files* located in [Chapter 3](ch03.html "Chapter 3. Files and
    Data"), *Files and Data*. Here, in total, we load 10 images, totaling about 6
    megabytes. Loading time depends on the device the application is running on (the
    simulator, the iPhone 4, the iPad, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'Asynchronous texture loading:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can create this loading screen because we have the capability to asynchronously
    load textures using the following method call:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Every time the nodeLoaded callback fires, we increment a counter to keep track
    of files loaded. Even though this ignores the variance of file sizes being loaded,
    this gives us a rough estimate of how far along we are in the loading process.
    Displaying this graphically in a bar, gives the user some basic visual feedback
    without going into too much detail.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Switching to the game scene:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once all the images are loaded asynchronously, we pop the loading scene and
    switch to the main game scene. The JSON file name is passed along so that a second
    pass can be made to actually display the images onscreen. Because these images
    have been pre-loaded, the scene displays immediately.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Unloading textures:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we are finished with our game, we unload all loaded textures:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This unloads all loaded textures including ones loaded anywhere else in the
    application. Textures can also be removed manually by calling the `release` method
    on the ones to be removed, and then calling the `removeUnusedTextures` method
    on the `sharedTextureCache` singleton. Keep in mind that `removeUnusedTextures`
    also removes textures added to `CCTextureCache`. It might be safer to remove textures
    individually using one of the following methods:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creating a minimap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An engaging and informative in-game HUD is a crucial piece of most games. Mobile
    games, in particular, often blend user input with heads-up information due to
    the small amount of screen real estate available. In this example, we will create
    a **Minimap** to help the player navigate the terrain in the isometric game demo
    from the last chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a minimap](img/4002_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The minimap shown in this example, is basically a simple graphical representation
    of the Box2D world similar to that of the Box2D debug drawing routines. In this
    instance, we have tailored the OpenGL drawing code to fit our needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generalizing the minimap:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Minimap` class generalizes physical elements into a number of types and
    then draws these types using specific colors. These include walls, projectiles,
    static objects, and a central actor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Walls:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wall vertices are stored in two `NSMutableArray` objects. These are designed
    to be set initially and never updated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Projectiles:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Projectile coordinates are stored in a single `NSMutableDictionary` object.
    This allows us to update all projectiles repeatedly by using their `tag` property
    as a key in the dictionary. The implication is that projectiles are in a constant
    state of movement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Static objects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static objects in this example are trees. They represent static points on the
    map that do not move. They are drawn with the same color as the walls. Size information
    is not stored as it is assumed that static objects are not very large.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The central actor:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, a central actor position is shown as a large blue point.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Customizing the `Minimap` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Minimap` class represents a generic template that can be customized for
    any game type or situation. By changing the `scale` property, position information,
    and drawing routine, the `Minimap` can
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
