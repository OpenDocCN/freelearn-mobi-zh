<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Testing RxKotlin Applications</h1>
                </header>
            
            <article>
                
<p>We have covered more than 60% of the book and have learned a lot of concepts. From the first chapter, starting with concepts of reactive programming till the previous chapter about concurrent execution and parallelism. But we cannot complete the application development without introducing a few tests. It is probably the most crucial point in the process of application development.</p>
<p>This chapter is dedicated to testing. As Kotlin itself is relatively new, our first objective would be to learn testing in Kotlin. We will then proceed with testing in RxKotlin. The following are the topics we are going to cover in this chapter:</p>
<ul>
<li>Introduction to unit testing and its importance</li>
<li>Kotlin and JUnit, Kotlin-test</li>
<li>Testing tools in RxKotlin</li>
<li>Blocking subscribers</li>
<li>Blocking operators</li>
<li><kbd>TestObserver</kbd> and <kbd>TestSubscriber</kbd></li>
</ul>
<p>So let's get started.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to unit testing and its importance</h1>
                </header>
            
            <article>
                
<p>While testing is absolute necessary in application development, many novice developers get away with a few basic questions regarding testing. They are:</p>
<ul>
<li>What is unit testing? and why is it a developer's job?</li>
<li>Why is unit testing so important?</li>
<li>And, do we need to write unit tests for each section of our programs?</li>
</ul>
<p>We will start this chapter by answering these basic questions. If you would like to rather start with testing using RxKotlin directly, you can skip the first few sections in this chapter and start from <em>Testing tools in RxKotlin</em>. Though I would encourage you to read the chapter throughout, even if you have previous experience in testing with Kotlin.</p>
<p>Let's start by defining unit testing. Unit testing is a level of software testing where  the individual smallest testable components of a software (aka application), called <strong>units</strong> are tested. The purpose is to validate that each unit of the software performs as it was supposed to.</p>
<p>Unit tests can be done manually, but they are often automated. The sole purpose of automated unit testing is to reduce human error and eliminate any extra bugs/errors caused by them. To explain let's first remember the proverb:</p>
<div class="packt_quote">To err is human</div>
<p>So, if we do the unit tests manually, the chances of additional errors or bugs will rise. Automated unit tests can eliminate this risk as they include minimal human effort.</p>
<p>Also, we need to document the tests we've performed, and we need to perform the same tests again with new ones with each incremental build of our product. Automated unit tests eliminate that extra effort, as you would be required to write the test once and then you can run them any time in the future. Also, automated unit tests also reduce documentation efforts.</p>
<p>Why is it a developer's job? Who would write the code for automated testing other than the developers?</p>
<p>Also, it is not possible for developers to give understanding to tester after completing each small units of an application. Even you may have completed some module, which is not yet on the GUI, so the tester or anyone else than you may not even be able to reach that unit to test. Also, it may not have any direct impact or relation with the UI/UX, it may be a small internal code part.</p>
<p>To summarize, a developer better understands his code and he knows well what exactly he wants from that bunch of code. So the developer is the best person to write unit tests on that module.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Why is unit testing so important?</h1>
                </header>
            
            <article>
                
<p>Let's have a real-life example. Think of an engineer, creating a new motor or device. The engineer will test the functionality after completing each unit of that motor, rather than testing the whole motor at the end (though he / she will test the whole motor at the end, but will also test it repeatedly and incrementally while building it). The main reason behind this behavior is that if he / she doesn't do that, at the end it would take a lot effort to identify the exact problems (if any). While testing incrementally will allow you to fix any problem right away as soon as it arises. The same applies for software (applications) as well.</p>
<p>You should perform unit tests periodically and repeatedly as you develop each module of your application the more you test the better is the out product. And yes, <strong>we should write unit tests for each and every functional section of our applications</strong>.</p>
<div class="packt_infobox">By <strong>functional section</strong> we mean each section that performs any small operation and/or function. We can skip testing a POJO class with just getters and setters, but we must test the code which uses that POJO class to accomplish something.</div>
<p>So, as we've understood the importance of testing, let's start by writing JUnit tests in Kotlin.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing JUnit tests in Kotlin</h1>
                </header>
            
            <article>
                
<p>If you've any experience with Java development, you've heard of or most probably worked with JUnit. It is a testing framework, for Java (as well as Kotlin).</p>
<p>Typically unit tests are created in a separate source folder than real source codes, to keep it separated. The standard Maven/Gradle convention uses <kbd>src/main</kbd> for real codes (Java/Kotlin files or classes) and <kbd>src/test</kbd> for test classes. The following screenshot shows the structure for the project we're using in this book:</p>
<div class="CDPAlignCenter CDPAlign"><img height="218" width="275" src="assets/d1411a8e-1204-4043-b8f0-e45b8c0e3546.jpg"/></div>
<p class="mce-root CDPAlignLeft CDPAlign">Before beginning to write test cases we've to add the following Gradle dependencies:</p>
<pre>    testCompile 'junit:junit:4.12' 
    testCompile "org.mockito:mockito-core:1.9.5" 
    testCompile "org.jetbrains.kotlin:kotlin-test-   <br/>      junit:$kotlin_version" </pre>
<p>We've added a dependency to Mockito as well, which we are going to cover soon.</p>
<p>So, we have got everything ready, let's write our first test case. Please refer to the following code:</p>
<pre>    package com.rivuchk.packtpub.reactivekotlin 
 
    import org.junit.Test 
    import kotlin.test.assertEquals 
 
    class TestClass { 
      @Test//(1) 
      fun `my first test`() {//(2) 
        assertEquals(3,1+2)//(3) 
      } 
    } </pre>
<p>Have a close look at the preceding program. Each JUnit test case should be defined as a function inside a class. The class that contains the JUnit test functions should only be used for testing purposes and should not serve any other purpose. The <kbd>test</kbd> function should be annotated with the <kbd>@Test</kbd> annotation, as we did in comment <kbd>(1)</kbd>. This annotation helps JUnit to detect and execute the tests.</p>
<p>Now, give a cautious look at the line containing comment <kbd>(2)</kbd>. The function name is <kbd>`my first test`()</kbd>. Yes, it contains space within the function name. That is probably the best thing you can get while writing test cases in Kotlin. Kotlin allows you to have functions that have names without spaces, while they aren't good practice while writing codes, they are quite a life saver while writing tests; as you don't need to call the <kbd>test</kbd> functions elsewhere, they actually serve as readable test names.</p>
<p>In comment <kbd>(3)</kbd>, we wrote the actual test. The <kbd>assertEquals</kbd> test checks for equality between <kbd>expected</kbd> and <kbd>actual</kbd> values. The first parameter in this test is the expected value, and the second one is the actual one, which should be equal to the expected one.</p>
<p>If you run the test, you'll get the following output:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/3c3bbc91-307a-4ae7-b942-b154be390075.jpg"/></div>
<p>If we modify the program and pass <kbd>2+3</kbd> instead of <kbd>1+2</kbd> as the actual parameter, then the test would fail and give the following output:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/8089b0b9-8a7b-4f73-8b6d-edaac8af77b2.jpg"/></div>
<p>You can also pass a failure message, that would be shown in case of failure, as follows:</p>
<pre>    class TestClass { 
      @Test//(1) 
      fun `my first test`() {//(2) 
        assertEquals(3,2+3, "Actual value is not equal to the expected <br/>        one.")//(3) 
      } 
    } </pre>
<p>The message would be shown in the error report if the test fails. Have a look at the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d5bb218e-b0ed-4a1b-b1fc-67c9a0f6aacb.jpg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing your code</h1>
                </header>
            
            <article>
                
<p>In the earlier section, we learned how to write test cases, but did we test our code? No. We did the tests with some oblivious values. And we know that is not the purpose of tests. Tests are there to make sure that our functions, classes, and code blocks are working as expected.</p>
<p>We should write the tests on top of our existing code (unless we are following <strong>Test-driven development</strong> (<strong>TDD</strong>)).</p>
<div class="packt_infobox">Test-driven development is a development methodology where tests are written first, and then the actual source code is written that would pass the test cases. Test-driven development is hugely popular among developers and architects and many companies follow TDD as their development process.</div>
<p>The following is a small Kotlin file that contains a few methods for calculations, we would perform tests on top of this file:</p>
<pre>    package com.rivuchk.packtpub.reactivekotlin.chapter8 
 
    fun add(a:Int, b:Int):Int = a+b 
    fun substract(a:Int, b:Int):Int = a-b 
    fun mult(a:Int, b:Int):Int = a*b 
    fun divide(a:Int, b:Int):Int = a/b </pre>
<p>And, following class is with the test cases, go through the code carefully, and then we will describe it:</p>
<pre>    package com.rivuchk.packtpub.reactivekotlin.chapter8//(1) 
 
    import org.junit.Test 
    import kotlin.test.* 
 
    class TestCalculator { 
      @Test 
      fun `addition test`() {//(2) 
        assertEquals(1 + 2, add(1,2)) 
      } 
      @Test 
      fun `substraction test`() {//(3) 
        assertEquals(8-5, substract(8,5)) 
      } 
      @Test 
      fun `multiplication test`() {//(4) 
        assertEquals(4 * 2, mult(4,2)) 
       } 
      @Test 
      fun `division test`() {//(5) 
        assertEquals(8 / 2, divide(8,2)) 
      } 
    } </pre>
<p>Have a look at the package declarations. Both files share the same package name, we deliberately did this, so that we would not have to import the functions.</p>
<p>We used the simplest functions in the source code so that you can understand the code easily. Also notice that we wrote each test case separately, just like a function, we can obviously call multiple test functions within a test case, though. Confused? Let's elaborate, when you're testing multiple aspects of a single function or property you can (and should) group them all inside a test function (a function with an <kbd>@Test</kbd> annotation). Generally, compilers display test results as they encounter test functions, irrespective of how many tests each test function performs. So rest assured that your tests will be performed if you group them inside a single test function, they will however be shown as a single test. However when you're writing tests for separate functions or properties you would obviously want a separate report for all of them, in that case you should write them separately just like the earlier example.</p>
<p>Have a look at the output now:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/15b4f905-d6d2-405b-b7fe-863d5ea03638.jpg"/></div>
<p>But in each of the earlier examples, we used only <kbd>assertEquals</kbd>; seeing this, you may have a question, is <kbd>assertEquals</kbd> the only test function available? The answer is a big no. We've plenty of test functions available with Kotlin. The following are a few test cases with oblivious values, just to have an idea about the most useful test functions in Kotlin. Please refer to the following code:</p>
<pre>    package com.rivuchk.packtpub.reactivekotlin.chapter8 
 
    import org.junit.Test 
    import java.util.* 
    import kotlin.test.* 
 
    class TestFunctions { 
 
      @Test 
      fun <a>`expected block evaluation`()</a> { 
        expect(10,{ 
          val x=5 
          val y=2 
          x*y 
        }) 
      } 
 
      @Test 
      fun `assert illegal value`() { 
        assertNotEquals(-1,Random().nextInt(1)) 
      } 
 
      @Test 
      fun <a>`assert true boolean value`()</a> { 
        assertTrue(true) 
      } 
 
      @Test 
      fun `assert false boolean value`() { 
        assertFalse(false) 
      } 
 
      @Test 
      fun `assert that passed value is null`() { 
        assertNull(null) 
      } 
 
      @Test 
      fun `assert that passed value is not null`() { 
        assertNotNull(null) 
      } 
    } </pre>
<p>Before inspecting the test cases here, let's have a look at the following test output screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/c134e7e5-4609-4fb6-afe2-41b6282adaba.jpg"/></div>
<p>Now, let's try to understand the code. We will start with the <kbd>`expected block evaluation`()</kbd> test. The <kbd>expect</kbd> test function takes the expected value as the first parameter and a block (lambda) as the second parameter, executes the lambda, and checks the return value against the expected value for equality.</p>
<p>The second test case was <kbd>`assert illegal value`()</kbd>, in that test case we are using the <kbd>assertNotEquals()</kbd> test method. This test method does the exact opposite than the <kbd>assertEquals()</kbd>. It fails the test if both parameters are equal. The <kbd>assertNotEquals()</kbd> is especially useful when you've a function that should return any value except a particular one.</p>
<p>In the <kbd>`assert true boolean value`()</kbd> and <kbd>`assert true boolean value`()</kbd> test cases we used <kbd>assertTrue()</kbd> and <kbd>assertFalse()</kbd> respectively. Both test methods takes a <kbd>Boolean</kbd> value as parameter. As the name suggests, <kbd>assertTrue()</kbd> expects the value to be <kbd>true</kbd>, while <kbd>assertFalse()</kbd> expects to be <kbd>false</kbd>.</p>
<p>The next two test cases are for nulls. The first one <kbd>`assert that passed value is null`()</kbd> uses <kbd>assertNull()</kbd>, which expects the passed value to contain <kbd>null</kbd>. The second one uses <kbd>assertNotNull()</kbd> in complete opposite way, expects the value would not be <kbd>null</kbd>.</p>
<p>So, as we got some hands-on idea on writing test cases, let's get started with testing in <strong>RxKotlin</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing in RxKotlin</h1>
                </header>
            
            <article>
                
<p>Now, as you've some hands-on testing in Kotlin and have some idea about RxKotlin as well, you may be wondering how to implement test cases in RxKotlin? It is true that testing in RxKotlin may not seem straightforward; the reason is that ReactiveX defines behavior rather than states, and most testing frameworks, including JUnit and kotlin—test are good for testing states.</p>
<p>To the aid of developers, RxKotlin comes with a set of tools for testing, which you can use with your favorite testing frameworks. In this book, we will cover testing in RxKotlin with JUnit and Kotlin-test.</p>
<p>So, what are we waiting for? Let's get started.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Blocking subscribers</h1>
                </header>
            
            <article>
                
<p>Try to remember the code blocks from previous chapters, where we used <kbd>delay</kbd> to make the main thread wait whenever we used an <kbd>Observable</kbd> or <kbd>Flowable</kbd> that operates on a different thread. A perfect example of this scenario is when we used <kbd>Observable.interval</kbd> as a factory method or when we used the <kbd>subscribeOn</kbd> operator. To get you refreshed, following is such a code example:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      Observable.range(1,10) 
         .subscribeOn(Schedulers.computation()) 
         .subscribe { 
            item -&gt; println("Received $item") 
          } 
      runBlocking { delay(10) } 
    } </pre>
<p>In this example, we switched to <kbd>Schedulers.computation</kbd> for the subscription. Now let's see, how we can test this Observable and check that we received exactly <kbd>10</kbd> emissions:</p>
<pre>    @Test 
    fun `check emissions count` () { 
      val emissionsCount = AtomicInteger()//(1) 
      Observable.range(1,10) 
         .subscribeOn(Schedulers.computation()) 
         .blockingSubscribe {//(2) 
          _ -&gt; emissionsCount.incrementAndGet() 
         } 
 
        assertEquals(10,emissionsCount.get())//(3) 
    } </pre>
<p>Let's have a look at the testing result first before digging into the code:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/01b50387-015c-466c-9a1f-781ddeeee7c0.jpg"/></div>
<p>There are a few things that need explanations in this code. The first one is <kbd>AtomicInteger</kbd>. <kbd>AtomicInteger</kbd> is a wrapper around integer in Java, that allows an <kbd>Int</kbd> value to be updated atomically. Though <kbd>AtomicInteger</kbd> extends <kbd>Number</kbd> to allow uniform access by tools and utilities that deal with numerically-based classes, it cannot be used as a replacement of <kbd>Integer</kbd>. We used <kbd>AtomicInteger</kbd> in this code to ensure atomicity, as the subscription was running in the <kbd>computationScheduler</kbd> (thus in multiple threads).</p>
<p>The line, that demands our attention is where we put comment <kbd>(2)</kbd>. We used <kbd>blockingSubscribe</kbd> instead of just <kbd>subscribe</kbd>. When we subscribe to a producer with the <kbd>subscribe</kbd> operator and the subscription is not in the current thread, the current thread doesn't wait for the subscription to complete and moves to the next line instantly. That's why we used delay to make the current thread wait. Using <kbd>delay</kbd> inside <kbd>tests</kbd> is troublesome. While <kbd>blockingSubscribe</kbd> blocks the current running thread until the subscription finishes up (even if the subscription occurs in a separate thread), that is useful while writing tests.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Blocking operators</h1>
                </header>
            
            <article>
                
<p>While <kbd>blockingSubscribe</kbd> is useful in testing, it cannot always serve your purpose. You might need to test the first, last or all the values of the producer. For that purpose you would need the data in its pure imperative nature.</p>
<p>The set of yet uncovered operators in RxKotlin is at your helm in that scenario. The blocking operators serve as an immediate accessible bridge between the reactive world and the imperative world. They block the current thread and make it wait for the results to be emitted, but returns them in a non-reactive way.</p>
<p>The only similarity between <kbd>blockingSubscribe</kbd> and blocking operators are that both block the declaring thread even if the reactive operations are performed in a different thread.</p>
<p>Other than this one, there are no more similarities. The <kbd>blockingSubscribe</kbd> treats the data as reactive and doesn't return anything. It rather pushes them to the subscriber (or lambda) specified. Whereas blocking operators will return the data in a non-reactive nature.</p>
<p>The following list contains the blocking operators we are going to cover:</p>
<ul>
<li><kbd>blockingFirst()</kbd></li>
<li><kbd>blockingGet()</kbd></li>
<li><kbd>blockingLast()</kbd></li>
<li><kbd>blockingIterable()</kbd></li>
<li><kbd>blockingForEach()</kbd></li>
</ul>
<p>Though we should avoid using them in production as they encourage anti-patterns and reduce the benefits of reactive programming, however we can surely use them for testing purposes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting the first emitted item – blockingFirst()</h1>
                </header>
            
            <article>
                
<p>The first blocking operator we are going discuss is the <kbd>blockingFirst</kbd> operator. This operator blocks the calling thread until the first item is emitted and returns it. The following is an ideal test case for <kbd>blockingFirst()</kbd>, where we are performing a sorting operation on Observable and we are testing it by checking if the first emitted item is the smallest. Please refer to the following code:</p>
<pre>    @Test 
    fun `test with blockingFirst`() { 
      val observable = listOf(2,10,5,6,9,8,7,1,4,3).toObservable() 
            .sorted() 
     
      val firstItem = observable.blockingFirst() 
      assertEquals(1,firstItem) 
    } </pre>
<p>The test result is as follows:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/0690a3d8-3775-42db-85db-ec9f998ee39f.jpg"/></div>
<p>In the program, we created an unsorted list of integers from <kbd>1</kbd> to <kbd>10</kbd> and created an Observable with the list, so the smallest item from that Observable should be <kbd>1</kbd>. We obtained the first item and made the thread to wait till we get it with the help of the <kbd>blockingFirst()</kbd> operator.</p>
<p>Then used the <kbd>assertEquals</kbd> testing function to assert that the first emitted item is <kbd>1</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting the only item from single or maybe - blockingGet</h1>
                </header>
            
            <article>
                
<p>When you're working with <kbd>single</kbd> or <kbd>maybe</kbd>, you just can't use any other blocking operator other than <kbd>blockingGet()</kbd>. The reason is quite simple, both monads can contain only one item.</p>
<p>So, let's create two new test cases by modifying the last test case as follows:</p>
<pre>    @Test 
    fun `test Single with blockingGet`() { 
      val observable = listOf(2,10,5,6,9,8,7,1,4,3).toObservable() 
               .sorted() 
 
      val firstElement:Single&lt;Int&gt; = observable.first(0) 
 
      val firstItem = firstElement.blockingGet() 
      assertEquals(1,firstItem) 
    } 
 
    @Test 
    fun `test Maybe with blockingGet`() { 
      val observable = listOf(2,10,5,6,9,8,7,1,4,3).toObservable() 
               .sorted() 
 
      val firstElement:Maybe&lt;Int&gt; = observable.firstElement() 
 
      val firstItem = firstElement.blockingGet() 
      assertEquals(1,firstItem) 
    } </pre>
<p>In the first test case, we used <kbd>observable.first()</kbd> with a default value, this operator returns a <kbd>Single</kbd>; on the second operator, we used <kbd>observable.firstElement()</kbd> this operator returns a <kbd>Maybe</kbd>. Then we used <kbd>blockingGet</kbd> in both test cases to get the first element as an <kbd>Int</kbd> and execute the test function.</p>
<p>So, following screenshot is the test result:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/67e4d586-4e0d-4a4f-ac14-5a24bec75669.jpg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting the last Item - blockingLast</h1>
                </header>
            
            <article>
                
<p>We have <kbd>blockingFirst</kbd>, so it's quite obvious that we would have <kbd>blockingLast</kbd>. As expected, it gets you the last emitted item while blocking the thread until the source emits it. The following is the code example:</p>
<pre>    @Test 
    fun `test with blockingLast`() { 
      val observable = listOf(2,10,5,6,9,8,7,1,4,3).toObservable() 
               .sorted() 
 
      val firstItem = observable.blockingLast() 
      assertEquals(10,firstItem) 
   } </pre>
<p>As we are expecting the last emitted item, we are checking equality with <kbd>10</kbd>.</p>
<p>Following is the screenshot of the testing result:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/e2f3e782-614c-4c5a-b022-7b33a5d0e0f6.jpg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting all emissions as iterable - blockingIterable operator</h1>
                </header>
            
            <article>
                
<p>So, we fetched the first emitted item, we fetched the last emitted item, but what if we want all the items emitted for testing? The <kbd>blockingIterable</kbd> operator gets you with the same. The <kbd>blockingIterable</kbd> operator works in an interesting way, it passes an emission to the <kbd>Iterable</kbd>, then the <kbd>Iterable</kbd> will keep blocking the iterating thread until the next emission is available. This operator queues up unconsumed values until the <kbd>Iterator</kbd> can consume them, and this can cause <kbd>OutOfMemory</kbd> exceptions.</p>
<p>So following is an example, where we are obtaining the complete list and then we are checking if the emissions were sorted by converting the returned <kbd>Iterable</kbd> to <kbd>List</kbd> and checking equality with the source <kbd>list</kbd> after sorting. Please refer to the following code:</p>
<pre>    @Test 
    fun `test with blockingIterable`() { 
      val list = listOf(2,10,5,6,9,8,7,1,4,3) 
 
      val observable = list.toObservable() 
               .sorted() 
 
     val iterable = observable.blockingIterable() 
     assertEquals(list.sorted(),iterable.toList()) 
   } </pre>
<p>If the emissions were sorted, the <kbd>iterable</kbd>, when converted to <kbd>list</kbd>, should be equal to <kbd>list.sorted()</kbd>.</p>
<p>Following is the screenshot of the test result:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9cab01c7-85d6-47f1-a568-5e47dbd1967a.jpg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Looping through all emissions - blockingForEach</h1>
                </header>
            
            <article>
                
<p>If you want to loop through all the emissions then <kbd>blockingForEach</kbd> is probably a better solution. It's better than <kbd>blockingIterable</kbd> as it will not queue up the emissions. Rather will it block the calling thread and wait for each emission to be processed before allowing the thread to continue.</p>
<p>In the following example, we created an <kbd>Observable</kbd> from a list of <kbd>Int</kbd>. Then applied a filter for even numbers only and then within the <kbd>blockingForEach</kbd> we are testing whether all the received numbers are even:</p>
<pre>    @Test 
    fun `test with blockingForEach`() { 
      val list =  <br/>      listOf(2,10,5,6,9,8,7,1,4,3,12,20,15,16,19,18,17,11,14,13) 
 
      val observable = list.toObservable() 
        .filter { item -&gt; item%2==0 } 
 
      observable.forEach { 
         item-&gt; 
         assertTrue { item%2==0 } 
     } 
   }  </pre>
<p>The result of the test is as follows:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/6a5582fe-8504-46df-a0e2-dec7180b0fd2.jpg"/></div>
<p>We covered the most useful blocking operators up until now. They are useful for simple assertions and can effectively block the code so that we can perform our testing operations.</p>
<p>However, using blocking code does no good in production. While it seems that using blocking code for testing is ok, but it is actually not. It can do significant harm to keep you from the benefits of testing. How? Just think of multiple Observables/Flowables are emitting concurrently for your application, if you put them on the blocking code their complete behavior may change and as a result you'll be deprived from the benefits of unit testing.</p>
<p>So, what is the way out? Let's see.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing TestObserver and TestSubscriber</h1>
                </header>
            
            <article>
                
<p>As you read through this chapter, you may have developed an idea that the only way we can perform tests are through blocking the code, either by using <kbd>blockingSubscribe</kbd> or by using blocking operators. <em>But this is not the case</em>. In fact, there are more comprehensive ways to reactive code, or rather we can say that we can test reactive code reactively.</p>
<p>To say it more precisely, in a Subscriber we have <kbd>onError</kbd> and <kbd>onComplete</kbd> that demands testing along with <kbd>onNext</kbd>, which is not always possible with just blocking. Yes some sort of blocking is necessary, but it cannot alone do all the things and it also needs to be managed reactively.</p>
<p>So, here are your two superheroes to make the developers life easy—<kbd>TestObserver</kbd> and <kbd>TestSubscriber</kbd>. As with <kbd>Subscriber</kbd> and <kbd>Observer</kbd>, you can use <kbd>TestSubscriber</kbd> with <kbd>Flowables</kbd> and <kbd>TestObserver</kbd> with <kbd>Observables</kbd>, everything except that is similar between these two.</p>
<p>So, let's get started with an example:</p>
<pre>    @Test 
    fun `test with TestObserver`() { 
     val list = <br/>     listOf(2,10,5,6,9,8,7,1,4,3,12,20,15,16,19,18,17,11,14,13) 
 
     val observable = list.toObservable().sorted() 
 
     val testObserver = TestObserver&lt;Int&gt;() 
  
     observable.subscribe(testObserver)//(1) 
 
     testObserver.assertSubscribed()//(2) 
 
     testObserver.awaitTerminalEvent()//(3) 
 
     testObserver.assertNoErrors()//(4) 
     testObserver.assertComplete()//(5) 
     testObserver.assertValueCount(20)//(6) 
     testObserver.assertValues<br/>     (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20)//(7) 
    } 
 
    @Test 
    fun `test with TestSubscriber`() { 
     val list = <br/>     listOf(2,10,5,6,9,8,7,1,4,3,12,20,15,16,19,18,17,11,14,13) 
 
     val flowable = list.toFlowable().sorted() 
 
     val testSubscriber = TestSubscriber&lt;Int&gt;() 
 
     flowable.subscribe(testSubscriber)//(1) 
 
     testSubscriber.assertSubscribed()//(2) 
 
     testSubscriber.awaitTerminalEvent()//(3) 
 
     testSubscriber.assertNoErrors()//(4) 
     testSubscriber.assertComplete()//(5) 
     testSubscriber.assertValueCount(20)//(6) 
     testSubscriber.assertValues<br/>     (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20)//(7) 
    } </pre>
<p>So we did perform the same set of tests with <kbd>TestObserver</kbd> and <kbd>TestSubscriber</kbd>. The test result is obviously passed:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/43522289-c0d2-4ebd-8fda-a106f134cf6d.jpg"/></div>
<p>Let's now understand the test cases. On comment <kbd>(1)</kbd>, we are subscribing to the Observable/Flowable. On comment <kbd>(2)</kbd>, we are checking if the Subscription was successful and was only one with the help of the <kbd>assertSubscribed()</kbd> test. On comment <kbd>(3)</kbd>, we are blocking the thread until the Observable/Flowable completes its execution with the <kbd>awaitTerminalEvent()</kbd> method. This terminal event can be <kbd>onComplete</kbd> or <kbd>onError</kbd> as well. On comments <kbd>(4)</kbd> and <kbd>(5)</kbd>, we are checking whether the <kbd>Observable</kbd> and/or <kbd>Flowable</kbd> has completed successfully without any errors, <kbd>assertNoErrors()</kbd> will test whether the Subscription hasn't received any errors and <kbd>assertComplete()</kbd> will test whether the producer has completed successfully . On comment <kbd>(6)</kbd>, we are testing that the total received emission count was <kbd>20</kbd> (there were 20 items in the list), <kbd>assertValuesCount()</kbd> helps us with this objective. On comment <kbd>(6)</kbd>, with the help of <kbd>assertValues()</kbd> we are testing the expected and actual values of each of the emissions in its order.</p>
<p>So it was cool, right? The next thing I'm going to show is probably cooler.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding TestScheduler</h1>
                </header>
            
            <article>
                
<p>Think of an Observable/Flowable created with the <kbd>Observable.interval()</kbd> / <kbd>Flowable.interval()</kbd> factory method. If you have given a long interval (say five minutes) in them and have tested at least say 100 emissions then it would take a long time for testing to complete (500 minutes = 8.3 hours, that is, a complete man-hour just to test a single producer). Now if you have more producers like that with a larger interval and more emissions to test then it would probably take the whole lifetime to test, when would you ship the product then?</p>
<p><kbd>TestScheduler</kbd> is here to save your life. They can effectively simulate time with time-driven producers so that we can do assertions by fast-forwarding it by a specific amount.</p>
<p>So, the following is the respective implementation:</p>
<pre>    @Test 
    fun `test by fast forwarding time`() { 
      val testScheduler = TestScheduler() 
 
      val observable = <br/>      Observable.interval(5,TimeUnit.MINUTES,testScheduler) 
      val testObserver = TestObserver&lt;Long&gt;() 
 
      observable.subscribe(testObserver) 
      testObserver.assertSubscribed() 
      testObserver.assertValueCount(0)//(1) 
 
      testScheduler.advanceTimeBy(100,TimeUnit.MINUTES)//(2) 
      testObserver.assertValueCount(20)//(3) 
 
      testScheduler.advanceTimeBy(400,TimeUnit.MINUTES)//(4) 
      testObserver.assertValueCount(100)//(5) 
    } </pre>
<p>So, here we created an <kbd>Observable</kbd> with <kbd>Observable.interval</kbd> with a <kbd>5</kbd> minute interval and <kbd>TestScheduler</kbd> as its <kbd>Scheduler</kbd>.</p>
<p>On comment <kbd>(1)</kbd>, it should not receive any emissions (as there are still <kbd>5</kbd> minutes before it should receive its first emission) and we are testing it with <kbd>assertValuesCount(0)</kbd>.</p>
<p>We then fast-forwarded the time by <kbd>100</kbd> minutes on comment <kbd>(2)</kbd>, and tested whether we received <kbd>20</kbd> emissions on comment <kbd>(3)</kbd>. <kbd>TestScheduler</kbd> provides us with the <kbd>advanceTimeBy</kbd> method, which takes a timespan and unit as parameters and simulates that for us.</p>
<p>We then fast-forwarded time by another <kbd>400</kbd> minutes and tested if we received a total of 100 emissions on comment <kbd>(4)</kbd> and comment <kbd>(5)</kbd>.</p>
<p>As you would expect, the test passes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>So, in this chapter, we learned about testing in Kotlin. We started with the benefits of testing and then moved on to testing in Kotlin, using JUnit and Kotlin-test.</p>
<p>As we got some hands-on testing experience in Kotlin, we gradually moved to testing in RxKotlin, we learned a few technique to test RxKotlin and learnt about the super-convenient testing tools that RxKotlin provides for us.</p>
<p>As we have built a strong base of knowledge in RxKotlin, in the next chapter—<a href="91fde5b1-29d4-49c0-a7e4-b56db9882d2f.xhtml">Chapter 9</a>,<br/>
<em>Resource Management and Extending RxKotlin</em> we are going to discuss some advanced topics. We will discuss managing resources—how to free allocated memory and prevent memory leaks. We will also learn to create our own custom operators, which can be chained in the RxKotlin logic just like those predefined operators.</p>
<p>So, what are you waiting for? Get started on <a href="91fde5b1-29d4-49c0-a7e4-b56db9882d2f.xhtml">Chapter 9</a>, <em>Resource Management and Extending RxKotlin,</em> right now, and from now on don't forget to test every code you write.</p>


            </article>

            
        </section>
    </body></html>