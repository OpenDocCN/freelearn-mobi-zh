<html><head></head><body>
		<div><h1 id="_idParaDest-162"><em class="italic"><a id="_idTextAnchor267"/>Chapter 9</em>: Fetching and Displaying Data from the Network</h1>
			<p>Most modern applications communicate with a web service. Some apps rely on them heavily, acting as a layer that merely reads data from the web and displays it in app form. Other apps use the web to retrieve and sync data to make it locally available, and others only use the web as backup storage. Of course, there are a lot more reasons to use data from the internet than the ones mentioned.</p>
			<p>In this chapter, you will expand the <strong class="bold">MustC</strong> application, so it uses a web service to retrieve popularity ratings for the movies that family members have added as their favorites. These popularity ratings will be stored in the Core Data database and displayed together with the names of the movies.</p>
			<p>In this chapter, you'll learn about the following topics:</p>
			<ul>
				<li>Fetching data from the web with <code>URLSession</code></li>
				<li>Working with JSON in Swift</li>
				<li>Updating Core Data objects with fetched data</li>
			</ul>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor268"/>Technical requirements</h1>
			<p>The code bundle for this chapter includes a starter project called <code>URLSession.playground</code>.</p>
			<p>You will also need to generate an API key from <a href="https://www.themoviedb.org/">https://www.themoviedb.org/</a>. Create an account on their website and request an API key on your account page. Setting this up should only take a couple of minutes, and if you want to follow along with this chapter, you will need to have your own API key. </p>
			<p>After you have created and validated your account on <a href="http://themoviedb.org">themoviedb.org</a>, you can visit the following link to request an API key: <a href="https://www.themoviedb.org/settings/api/request">https://www.themoviedb.org/settings/api/request</a>.</p>
			<p>The code for this chapter can be found here: <a href="https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition/tree/master/Chapter%209%20-%20Fetching%20from%20Network">https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition/tree/master/Chapter%209%20-%20Fetching%20from%20Network</a>.</p>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor269"/>Fetching data from the web with URLSession</h1>
			<p>Retrieving <a id="_idIndexMarker411"/>data from the web is something that you will often do as an iOS professional. You won't just fetch data from a web service; you'll also send data back to it. For example, you might have to make an HTTP POST request as part of a login flow or to update a user's profile information. Over time, iOS has evolved quite a bit in the web requests department, making it easier to use web services in apps. </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">HTTP (or HTTPS) is a <a id="_idIndexMarker412"/>protocol that almost all web traffic uses for communication between a client, such as an app, and a server. The HTTP protocol supports several methods that signal the request's intent. GET is <a id="_idIndexMarker413"/>used to retrieve information from a server. A POST request<a id="_idIndexMarker414"/> indicates the intention to push new content to a server, such as, for instance, when submitting a form.</p>
			<p>When you want to perform a web request in iOS, you will typically use the <code>URLSession</code> class. The <code>URLSession</code> class makes asynchronous web requests on your behalf. This means that iOS loads data from the web on a background thread, ensuring that the user interface remains responsive throughout the entire request. If a web request is performed synchronously, the user interface is unresponsive for the duration of the network request because a thread can only do one thing at a time, so if it's waiting for a response from the network, it can't respond to touches or any other user input.</p>
			<p>If your user has a slow internet connection, a request could take several seconds. You don't want the interface to freeze for several seconds. Even a couple of milliseconds will create a noticeable drop in its responsiveness and frame rate. This can be easily avoided by using <code>URLSession</code> to perform asynchronous network requests.</p>
			<p>First, you will experiment with basic network requests in a playground. You can create a new playground or use the one provided in this book's code bundle. After you've seen the basics of <code>URLSession</code>, you'll implement a way to fetch movies <a id="_idTextAnchor270"/>from an open source movie database and put this implementation to use in the MustC a<a id="_idTextAnchor271"/>pp.</p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor272"/>Understanding the basics of URLSession</h2>
			<p>Making network calls is <a id="_idIndexMarker415"/>one of the fundamental tasks of every app that needs to fetch, post, or modify remote data. It is one of the most common tasks that a developer faces every day. For this task, Apple provides developers with the <code>URLSession</code> class. The <code>URLSession</code> class helps developers to work with remote data easily and by coordinating a group of related network data-transfer tasks.</p>
			<p>The following code snippet shows a sample network request that loads the <a href="https://apple.com">https://apple.com</a> home page:</p>
			<pre>import Foundation
let url = URL(string: 'https://apple.com')!
let task = URLSession.shared.dataTask(with: url) {
  data, response, error in
  if let data = data {
    print(data)
  }
  if let response = response {
    print(response)
  }
  if let error = error {
    print(error)
  }
}
task.resum<a id="_idTextAnchor273"/>e() </pre>
			<p>This is an elementary example: a URL is created, and then the shared <code>URLSession</code> instance is used to create a new <code>dataTask</code>. This <code>dataTask</code> is an instance of <code>URLSessionDataTask</code> and allows you to load data from a remote server.</p>
			<p>Alternatively, you could use a download task if you're downloading a file, or an upload task if you're uploading files to a web server. After creating the task, you must call <code>resume</code> on the task, because new tasks are always created in a suspended state.</p>
			<p>If you run this sample in an empty playground, you'll find that the example doesn't work. Because the network request is made asynchronously, the playground finishes its execution before the network request is complete. To fix this, you should make sure that the playground <a id="_idIndexMarker416"/>runs indefinitely. Doing so will allow the network request to finish. Add the following lines to the top of the playground source file to enable this behavior:</p>
			<pre>import PlaygroundSupport
PlaygroundPage.current.needsIndefiniteExecution = true</pre>
			<p>Now that the playground runs indefinitely, you'll find that there isn't a lot of useful data printed to the console. In this case, you're not interested in the raw data, HTTP headers, or the fact that the error is nil. When you load data from a URL, you're often most interested in the response's body. The body of a response usually contains the string representation of the data you requested. In the case of the preceding example, the body is the HTML that makes up Apple's home page. Let's see how you can extract this HTML from the response. Replace the data task's completion callback with the following:</p>
			<pre>{ data, response, error in
  guard let data = data, error == nil
    else { return }
  
  let responseString = String(data: data, encoding: .utf8)
  print(responseString as Any)
}</pre>
			<p>The preceding callback closure makes sure that there are no errors returned by the web service and that there is data present. Then, the raw data is converted to a string, and that string is printed to the console. If you use this callback instead of the old one, you'll see the HTML for the Apple home page printed. Simple requests to a web server like the one you just saw are relatively simple to implement with <code>URLSes<a id="_idTextAnchor274"/>sion</code>.</p>
			<p>If you need to customize your network request (for example, to add custom headers) rather than using the simple <code>dataTask</code> function with a URL, you need to create your own <code>URLRequest</code> instance, instead of letting <code>URLSession</code> do it. The example you saw is one where you let <code>URLSession</code> create the <code>URLRequest</code> on your behalf. This is fine if you want to perform a simple HTTP GET request with no custom headers, but if you're going to post data or include specific headers, you will need to have more control over the request that's used. </p>
			<p>Let's take a look at what a GET request with some parameters and a custom header looks like. The following code uses an API key from <a href="https://www.themoviedb.org/">https://www.themoviedb.org/</a>. If you want to try this code example, create an account on their website and request an API key on your<a id="_idIndexMarker417"/> account page. Setting this up should only take a couple of minutes, and if you want to follow along with this chapter, you will need to have your own API key. After you have created and validated your account on <a href="http://themoviedb.org">themoviedb.org</a>, you can visit the following link to request an API key: <a href="https://www.themoviedb.org/settings/api/request">https://www.themoviedb.org/settings/api/request</a>:</p>
			<pre>let api_key = 'YOUR_API_KEY_HERE'
var urlString = 'https://api.themoviedb.org/3/search/movie/'
urlString = urlString.appending('?api_key=\(api_key)')
urlString = urlString.appending('&amp;query=Swift')
let movieURL = URL(string: urlString)!
var urlRequest = URLRequest(url: movieURL)
urlRequest.httpMethod = 'GET'
urlRequest.setValue('application/json', forHTTPHeaderField: 'Accept')
let movieTask = URLSession.shared.dataTask(with: urlRequest) { data, response, error in
  print(response as Any)
}
movieTask.resume()</pre>
			<p>The preceding code is a bit more complicated than the example you saw before. In this example, a more complex URL request is configured that includes some HTTP GET parameters. The <code>httpMethod</code> value for <code>URLRequest</code> is specified, and a custom header is provided to inform the receiver of this request about the type of response it would like to receive.</p>
			<p>The flow for executing this URL request is the same as the one you saw earlier. However, the URL that is loaded responds with a JSON string instead of an HTML document. JSON is used by many APIs as the preferred format to pass data around on the web. In order to<a id="_idIndexMarker418"/> use this response, the raw data must be converted to a useful data structure. In this case, a dictionary will do. If you haven't seen or worked with JSON before, it's a good idea to take a step back and read up on the JSON data format because this chapter will continue under the assumption that you are at least somewhat familiar wit<a id="_idTextAnchor275"/><a id="_idTextAnchor276"/><a id="_idTextAnchor277"/>h JSON.</p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor278"/>Working with JSON in Swift</h1>
			<p>The following <a id="_idIndexMarker419"/>snippet shows how you can convert raw data to a JSON dictionary. Working with JSON in Swift can be a little tedious at times, but overall, it's a generally good experience. Let's look at the following example:</p>
			<pre>guard let data = data, let json = try? JSONSerialization.jsonObject(with: data, options: []) else { return }
print(json)</pre>
			<p>The preceding snippet converts the raw data that is returned by a URL request to a JSON object. The <code>print</code> statement prints a readable version of the response data, but it's not quite ready to be used. Let's see how you gain access to the first available movie in the response.</p>
			<p>If you look at the type of object returned by the <code>jsonObject(with:options:)</code> method, you'll see that it returns <code>Any</code>. This means that you must typecast the returned object to something you can work with, such as an array or a dictionary. When you inspect the JSON response that the API returned, for instance by using <code>print</code> to make it appear in the console as you did with Apple's home page HTML, you'll notice that there's a dictionary that has a key called <code>results</code>. The <code>results</code> object is an array of movies. In other words, it's an array of <code>[String: Any]</code>, because every movie is a dictionary, where strings are the keys and the value can be a couple of different things, such as Strings, Int, or Booleans. With this information, you can access the first movie's title in the<a id="_idIndexMarker420"/> JSON response, as shown in the following code:</p>
			<pre>guard let data = data,
  let json = try? JSONSerialization.jsonObject(with: data,
  options: []),
  let jsonDict = json as? [String: AnyObject],
  let resultsArray = jsonDict['results'] as? [[String: Any]] 
  else { return }
let firstMovie = resultsArray[0]
let movieTitle = firstMovie['title'] as! String print(m<a id="_idTextAnchor279"/>ovieTitle)</pre>
			<p>Working with dictionaries to handle JSON isn't the best experience. Since the JSON object is of the <code>AnyObject</code> type and you need to typecast every element in the dictionary you want to access, there's a lot of boilerplate code you need to add.</p>
			<p>Luckily, Swift has better ways to create instances of objects from the JSON data. The following example shows how you can quickly create an instance of a <code>Movie</code> struct without having to cast all the keys in the JSON dictionary to the correct types for the <code>Movie</code> struct.</p>
			<p>First, let's define two structs, one for the <code>Movie</code> itself, and one for the response that contains the array of <code>Movie</code> instances:</p>
			<pre>struct MoviesResponse: Codable {
  let results: [Movie]
}
struct Movie: Codable {
  let id: Int
  let title: String
  let popularity: Float
}</pre>
			<p>Next, you can <a id="_idIndexMarker421"/>use the following snippet to quickly convert the raw data from a URL request to an instance of <code>MoviesResponse</code>, where all movies are converted to instances of the <code>Movie</code> struct:</p>
			<pre>let decoder = JSONDecoder()
guard let data = data,
let movies = try? decoder.decode(MoviesResponse.self, from: data) else { return }
print(movies.results[0].title)</pre>
			<p>You might notice that both <code>MoviesResponse</code> and <code>Movie</code> conform to the <code>Codable</code> protocol. The <code>Codable</code> protocol was introduced in Swift 4, and it allows you to easily encode and decode data objects. The only requirement is that all properties of a <code>Codable</code> object conform to the <code>Codable</code> protocol. A lot of built-in types, such as <code>Array</code>, <code>String</code>, <code>Int</code>, <code>Float</code>, and <code>Dictionary</code>, conform to <code>Codable</code>. Because of this, you can easily convert an encoded JSON object into a <code>MoviesResponse</code> instance that holds <code>Movie</code> <a id="_idTextAnchor280"/>instances.</p>
			<p>By default, each property name should correspond to the key of the JSON response it is mapped to. However, sometimes you might want to customize this mapping. For instance, the <code>poster_path</code> property in the response we've been working with so far would be best mapped to a <code>posterPath</code> property on the <code>Movie</code> struct, according to the general Swift guidelines for property naming. The following example shows how you would tackle these circumstances:</p>
			<pre>struct Movie: Codable {
  enum CodingKeys: String, CodingKey {
    case id, title, popularity
    case posterPath = 'poster_path'
  }
  let id: Int
  let title: String
  let popularity: Float 
  let posterPath: String?
}</pre>
			<p>By specifying<a id="_idIndexMarker422"/> a <code>CodingKeys</code> enum, you can override how the keys in the JSON response should be mapped to your <code>Codable</code> object. You must cover all keys that are mapped, including the ones you don't want to change. As you've seen, the <code>Codable</code> protocol provides powerful tools for working with data from the network. Custom key mapping makes this protocol even more powerful because it allows you to shape your objects exactly how you want them, instead of having the URL responses dictate the structure to you.</p>
			<p>If the only conversion you need to apply in the coding keys is converting from snake case (<code>poster_path</code>) to camel case (<code>posterPath</code>), you don't have to specify the coding keys yourself. The <code>JSONDecoder</code> object can automatically apply this type of conversion when decoding data if you set its <code>keyDecodingStrategy</code> to <code>.convertFromSnakeCase</code>, as shown in the following code:</p>
			<pre>let decoder = JSONDecoder()
decoder.keyDecodingStrategy = .convertFromSnakeCase</pre>
			<p>By applying these lines of code, the decoder will automatically translate property names such as <code>poster_path</code> into the <code>posterPath</code> syntax. Try implementing this in your playground and remove <code>CodingKeys</code> from the <code>Movie</code> object to ensure your JSON decoding still<a id="_idIndexMarker423"/> works. </p>
			<p>In this section, we have learned how to work with JSON data and how to decode it into our own entities. Now let's move on to storing the fetched data in the Core Da<a id="_idTextAnchor281"/><a id="_idTextAnchor282"/><a id="_idTextAnchor283"/>ta database.</p>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor284"/>Updating Core Data objects with fetched data</h1>
			<p>So far, the only thing you <a id="_idIndexMarker424"/>have stored in Core Data is <a id="_idIndexMarker425"/>movie names. You will expand this functionality by performing a lookup for a certain movie name through the movie database API. The fetched information will be used to display and store a popularity rating for the movies in the Core Data database.</p>
			<p>A task such as this seems straightforward at first; you could come up with a flow such as the one shown in the following steps:</p>
			<ol>
				<li>The user indicates their favorite movie.</li>
				<li>The movie's popularity rating is fetched.</li>
				<li>The movie and its rating are stored in the database.</li>
			</ol>
			<p>The user interface updates with the new movie. At first glance, this is a fine strategy; insert the data when you have it. However, it's important to consider that API calls are typically done asynchronously so the user interface stays responsive. More importantly, API calls can be really slow if your user doesn't have a good internet connection. This means that you would be updating the interface with some very noticeable lag if the preceding steps are executed one by one.</p>
			<p>The following would be a much better approach to implement the feature at hand:</p>
			<ol>
				<li value="1">The user indicates their favorite movie.</li>
				<li>The user stores the movie.</li>
				<li>Update the user interface with the new movie.</li>
				<li>Begin popularity fetching.</li>
				<li>Update the movie in the database.</li>
				<li>Update the user interface with the popularity.</li>
			</ol>
			<p>This approach is somewhat more complex, but it will give the user a responsive experience. The user interface responds to new movies immediately by showing them, and then automatically updates as soon as new data is retrieved. Before you can fetch the data and update the <a id="_idIndexMarker426"/>models, the Core Data model must be modified in order to store the given <a id="_idIndexMarker427"/>movie's po<a id="_idTextAnchor285"/>pularity rating.</p>
			<p>Open the <code>popularity</code>. Select the <code>Double</code> type for this property because <code>popularity</code> is stored as a decimal value. You have to make sure that this property is optional since you won't be able to provide a value for it straight away:</p>
			<div><div><img src="img/B14717_09_01.jpg" alt="Figure 9.1 – Add the popularity attribute to the Movie entity&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – Add the popularity attribute to the Movie entity</p>
			<p>If you've worked with Core Data prior to when iOS 10 was released, this is the part where you expect to read about migrations and how you can orchestrate them.</p>
			<p>However, for simple changes like this, we don't need to manually manage migrations. All you need to do is simply build and run your application to regenerate your model definitions, and for a simple change, such as the one we performed just now, Core Data will automatically manage the migration for us.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">If you want to support iOS versions earlier than 10, make sure you read up on Core Data migrations. Whenever you update your models, you have to make sure that your database can properly migrate from one model version to another. During development, this isn't extremely important: you just reinstall the app whenever your models change. However, app updates will crash on launch if the Core Data model isn't compatible with the previous model.</p>
			<p>Now that the Core Data model is updated, let's figure out how to implement the flow that was des<a id="_idTextAnchor286"/><a id="_idTextAnchor287"/><a id="_idTextAnchor288"/>cribed earlier.</p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor289"/>Implementing the fetch logic</h2>
			<p>The asynchronous nature <a id="_idIndexMarker428"/>of network requests makes certain tasks, such as the one you're about to implement, quite complex. Usually, when you write code, its execution is very predictable. Your app typically runs line by line, sequentially, so any line that comes after the previous one can assume that the line before it has finished executing. This isn't the case with asynchronous code. Asynchronous code is taken off the main thread and runs separately from the rest of your code. This means that your asynchronous code might run in parallel with other code. In the case of a network request, the asynchronous code might execute seconds after the function that initiated the request.</p>
			<p>This means that you need to figure out a way to update and save movies that were added as soon as the rating was retrieved. However, it's important that you're aware of the fact that it's not as straightforward as it may seem at first.</p>
			<p>It's also important that you're aware of the fact that the code you're about to look at is executed on multiple threads. This means that even though all pieces of the code are defined in the same place, they are not executed sequentially. The callback for the network request is executed on a different thread than the code that initiated the network request. You have already learned that Core Data is not thread-safe. This means that you can't safely access a Core Data object on a different thread than the thread it was created on.</p>
			<p>If this confuses you, that's okay. You're supposed to be a bit confused right now. Asynchronous programming is not easy and fooling you into thinking it is will cause frustration once you run into concurrency-related troubles (and you will). Whenever you work with callbacks, closures, and multiple threads, you should be aware that you're doing complex work that isn't straightforward.</p>
			<p>Now that you understand that asynchronous code is hard, let's take a closer look at the feature you're about to implement. It's time to start implementing the network request that fetches popularity ratings for movies. You will abstract the fetching logic into a helper named <code>MovieDBHelper</code>. Go ahead and create a new <code>Helper</code> folder in Xcode and add a new Swift file called <code>MovieDBHel<a id="_idTextAnchor290"/>per.swift</code> to it.</p>
			<p>Abstracting this logic<a id="_idIndexMarker429"/> into a helper has multiple advantages. One of them is simplicity; it will keep our view controller code nice and clean. Another advantage is flexibility. Let's say that you want to combine multiple rating websites, or a different API, or compute the popularity of movies based on the number of family members who added this same title to their list; it will be easier to implement since all the logic for ratings is in a single place.</p>
			<p>Add the following skeleton implementation to the <code>MovieDBHelper</code> file:</p>
			<pre>struct MovieDBHelper {
  typealias MovieDBCallback = (Double?) -&gt; Void
  let apiKey = 'YOUR_API_KEY_HERE'
  func fetchRating(forMovie movie: String, callback: @escaping
  MovieDBCallback) {
  }
  private func url(forMovie movie: String) -&gt; URL? {
    guard let query = 
      movie.addingPercentEncoding(withAllowedCharacters: 
       .urlHostAllowed) else { return nil }
    var urlString = 
    'https://api.themoviedb.org/3/search/movie/'
    urlString = urlString.appending('?api_key=\(apiKey)')
    urlString = urlString.appending('&amp;query=\(query)')
    return URL(string: urlString)
  }
}</pre>
			<p>The preceding code starts off with an interesting line:</p>
			<pre>typealias MovieDBCallback = (Double?) -&gt; Void</pre>
			<p>This line specifies the type that's used for the callback closure that's called when the rating is fetched. This callback will receive an optional <code>Double</code> as its argument. If the network request fails for any reason, the <code>Double</code> will be nil. Otherwise, it contains the rating for the movie that the request was created for.</p>
			<p>The snippet also contains a <code>fetchRating</code> dummy method that performs the fetch; you will implement this method soon. Finally, there's a <code>url(forMovie movie: String)</code> method that builds a URL. This method is private because it's only supposed to be used inside of the<a id="_idIndexMarker430"/> helper struct. Note that the movie is converted to a percent-encoded string. This is required because if your user were to add a movie with spaces in it, you would end up with an invalid URL if the spaces aren't<a id="_idTextAnchor291"/> properly encoded.</p>
			<p>Before you implement <code>fetchRating(forMovie:callback)</code>, add a new file named <code>MovieDBResponse.swift</code> to the <code>Helper</code> folder. This file will be used to define a struct that represents the response we expect to receive from <a href="http://api.themoviedb.org">api.themoviedb.org</a>. Add the following implementation to this file:</p>
			<pre>struct MovieDBLookupResponse: Codable {
  struct MovieDBMovie: Codable {
    let popularity: Double?
  }
  let results: [MovieDBMovie]
}</pre>
			<p>The preceding code uses a nested struct to represent the movie objects that are part of the response. This is similar to what you saw in the playground example in the <em class="italic">Fetching data from the web with URLSession</em> section at the beginning of this chapter. Structuring the response this way makes the intent of this helper very obvious, which usually makes code easier <a id="_idIndexMarker431"/>to reason about. With this struct in place, replace the implementation of <code>fetchRating(forMovie:callback)</code> inside <code>MovieDBHelper</code> with the following:</p>
			<pre>func fetchRating(forMovie movie: String, callback: @escaping MovieDBCallback) {
  guard let searchUrl = url(forMovie: movie) else {
    callback(nil)
    return
  }
  let task = URLSession.shared.dataTask(with: searchUrl) { 
    data, response, error in
    var rating: Double? = nil
    defer {
      callback(rating)
    }
    let decoder = JSONDecoder()
    guard error == nil,
          let data = data,
          let lookupResponse = try? 
          decoder.decode(MovieDBLookupResponse.self, from: 
          data),
          let popularity = 
          lookupResponse.results.first?.popularity
    else { return }
    rating = popularity
  }
  task.resume()
}</pre>
			<p>This implementation looks very similar to what you experimented with earlier in the playground. The URL-building method is used to create a valid URL. If this fails, it makes no sense to attempt requesting the movie's rating, so the callback is called with a <code>nil</code> argument. This will inform the caller of this method that the execution is completed, and no result was retrieved.</p>
			<p>Next, a new data task is<a id="_idIndexMarker432"/> created and <code>resume()</code> is called on this task to kick it off. There is an interesting aspect to how the callback for this data task is called, though. Let's take a look at the following lines of code:</p>
			<pre>    var rating: Double? = nil
    defer {
      callback(rating)
    }</pre>
			<p>A <code>rating optional Double</code> is created here, and it is given an initial value of <code>nil</code>. Then there's a <code>defer</code> block. The code inside of the <code>defer</code> block is called right before exiting the scope. In other words, it's executed right before the code returns from a function or closure.</p>
			<p>Since this <code>defer</code> block is defined inside the callback for the data task, the callback for the <code>fetchRating(forMovie:callback:)</code> method is always called just before the data task callback is exited. This is convenient because all you must do is set the value for the rating to <code>double</code>, and you don't have to manually invoke the callback for each possible way the scope can be exited. This also applies when you return because of unmet requirements. For instance, if there is an error while calling the API, you don't need to invoke the callback. You can simply return from the closure, and the callback is called automatically. This strategy can also be applied if you instantiate or configure objects temporarily and you want to perform some clean-up when the method, function, or closure is done.</p>
			<p>The rest of the code <a id="_idIndexMarker433"/>should be fairly straightforward since most of it is nearly identical to the code used in the playground. Now that you have the networking logic down, let's take a look at how to actually update the <code>movie</code> object with <a id="_idTextAnchor292"/><a id="_idTextAnchor293"/><a id="_idTextAnchor294"/>a popularity rating. </p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor295"/>Updating a movie with a popularity rating</h2>
			<p>To <a id="_idIndexMarker434"/>update the <code>movie</code> object, you will implement the final step of the approach that was outlined earlier. You need to asynchronously fetch a rating from the movie database and then use that rating to update the movie. The following code should be added to <code>MoviesViewController.swift</code>, inside the <code>saveMovie(withName name: String)</code> method right after the <code>familyMember.movies = NSSet(set: newFavorites</code> line:</p>
			<pre>let helper = MovieDBHelper()
helper.fetchRating(forMovie: name) { rating in
  guard let rating = rating else { return }
  moc.persist {
    movie.popularity = rating
  }
}</pre>
			<p>You can see that the helper abstraction provides a nice interface for the view controller. You can simply use the helper and provide it a movie to fetch the rating for with a callback and you're all set. Abstracting code like this can make maintaining your code a lot more fun in the long run.</p>
			<p>The most surprising thing in the preceding snippet is that <code>moc.persist</code> is called again inside of the <code>helper</code> callback. This must be done because this callback is actually executed long after the initial <code>persist</code> has finished. Actually, this callback isn't even executed on the same thread as the code it's surrounded by.</p>
			<p>To see how <a id="_idIndexMarker435"/>your code fails if you don't properly persist your model, try replacing the<code> moc.persist</code> block in the rating retrieval callback with the following code:</p>
			<pre>movie.popularity = rating
do {
  try moc.save()
} cat<a id="_idTextAnchor296"/>ch {
  moc.rollback()
}</pre>
			<p>If you add a new movie now, the rating will still be fetched. However, you will suddenly run into issues when reloading your table view. This is because the managed object context was saved on a background thread. This means that the notification that informs the table view about updates is also sent on a background thread. You could resolve the issue by pushing the <code>reloadData()</code> call onto the main thread as you've done before, but in this case, doing so would only make the problem worse. Your app might work fine for a while, but once your app grows in complexity, using the same managed object context in multiple threads will most certainly cause crashes. Therefore, it's important to always make sure that you access managed objects and their contexts on the correct thread by using a construct, such as the <code>persist</code> method we implemented for this app.</p>
			<p>Now that you have looked at all the code involved, let's see<a id="_idTextAnchor297"/> what all this threading talk mean<a id="_idTextAnchor298"/>s in a more visual way.</p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor299"/>Visualizing multiple threads</h2>
			<p>The<a id="_idIndexMarker436"/> following diagram will help you understa<a id="_idTextAnchor300"/>nd multiple threads:</p>
			<p class="figure"> </p>
			<div><div><img src="img/B14717_09_02.jpg" alt="Figure 9.2 – Threads diagram&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – Threads diagram</p>
			<p>When <code>saveMovie(withName:)</code> is called, the execution is still on the main thread. The persistence block is opened, the movie is created, its name is set, a helper is created, and then <code>fetchRating(forMovie:callback:)</code> is called on the helper. This call itself is still on the main thread. However, the fetching of data is pushed to a background thread. This was discussed earlier when you experimented with fetching data in a playground.</p>
			<p>The callback that's invoked by <code>dataTask</code> is called on the same background thread that the task itself is on. The code will do its thing with the JSON and finally, the callback that was passed to <code>fetchRating(forMovie:callback:)</code> is called. The code inside of this callback is executed on the background thread as well.</p>
			<p>You can see that the set movie-rating step in the update flow is somehow pushed back to the main thread. This is because of the <code>persist</code> method that you added as an extension to the managed object context. The context uses the <code>perform</code> method internally to ensure that any code we execute inside of the <code>persist</code> block is executed on the thread the managed object context is on. Also, since the managed object context was created on the main thread, the movie rating will be set on the main thread.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">If you didn't set the movie rating on the same thread that the managed object belongs to, you would get errors and undefined behavior. Always make sure that you manipulate Core Data objects on the same thread as their managed object context.</p>
			<p>Threading is a <a id="_idIndexMarker437"/>complex subject, but it's essential for building responsive <a id="_idIndexMarker438"/>applications. Network logic is a great example of why multithreading is important. If we didn't perform the networking on a separate thread, the interface would be unresponsive for the duration of the request. If you have other operations that might take a while in your app, consider moving them onto a background thre<a id="_idTextAnchor301"/>ad so they don't block the user interface.</p>
			<p>All of the code is in place, and you have a better understanding of multithreading and how callbacks can be used in a multithreaded environment. Yet, if you build and run your app and add a new movie, the ratin<a id="_idTextAnchor302"/>g won't be displayed yet.</p>
			<p>The following are the three reasons why this is happening:</p>
			<ul>
				<li>The table view cell that shows the movie isn't updated yet.</li>
				<li>The network request doesn't succeed because of <strong class="bold">App Transport Security</strong>.</li>
				<li>Updates to movie obj<a id="_idTextAnchor303"/>ects aren't observed yet.</li>
			</ul>
			<p>Let's solve these issues in order, starting <a id="_idTextAnchor304"/>with the table view cell.</p>
			<h3>Adding the rating to the movie cell</h3>
			<p>Currently, the <a id="_idIndexMarker439"/>movie table view<a id="_idIndexMarker440"/> displays cells that have a title. <code>UITableViewCell</code> has a built-in option to display a title and a subtitle for a cell.</p>
			<p>Open <code>Main.storyboard</code> and select the prototype cell for the movies. In the <code>detailTextLabel</code> on the table view cell. This is where we'll display the movie rating.</p>
			<p>In <code>MoviesViewController</code>, add the following line to <code>tableView(_:cellForRow:atIndexPath:)</code>, right after you set the cell's title:</p>
			<pre>cell.detailTextLabel?.text = 'Rating: \(movie.popularity)'</pre>
			<p>This line will put the movie's popularity rating in a string and assign it as the text for the detail text label.</p>
			<p>If you build<a id="_idIndexMarker441"/> and run your app now, all movies should ha<a id="_idTextAnchor305"/>ve a popularity<a id="_idIndexMarker442"/> of 0.0. Let's fix this by re<a id="_idTextAnchor306"/>solving the networking issue.</p>
			<h3>Understanding App Transport Security</h3>
			<p>With iOS 9, Apple introduced <strong class="bold">App Transport Security</strong> (<strong class="bold">ATS</strong>). ATS makes applications safer and more secure by<a id="_idIndexMarker443"/> prohibiting the use of non-HTTPS resources. This is a great security feature, as it protects your users from a wide range of attacks that can be executed on regular HTTP connections.</p>
			<p>If you paid close attention to the URL that's used to fetch movies, you may have noticed that the URL should be an HTTPS resource, so it should be fine to load this URL. However, the network requests are stil<a id="_idTextAnchor307"/>l blocked by ATS. Why is this?</p>
			<p>Well, Apple has strict requirements. At the time of writing this book, the movie database uses the SHA-1 signing of certificates, whereas Apple requires SHA-2. Because of this, you will need to circumvent ATS for now. Your users should be safe regardless, since the movie database supports HTTPS, just not the version Apple considers to be secure enough.</p>
			<p>To do this, open the <code>Info.plist</code> file and add a new dictionary key named <code>themoviedb.org</code> to this dictionary and add two Booleans to this dictionary. Both should have <strong class="bold">YES</strong> as their values, and they should be named <strong class="bold">NSIncludesSubdomains</strong> and <strong class="bold">NSTemporaryExceptionAllowsInsecureHTTPLoads</strong>. Refer to the following screenshot to make sure that you've set this up correctly:</p>
			<div><div><img src="img/B14717_09_03.jpg" alt="Figure 9.3 – App Transport Security Settings&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.3 – App Transport Security Settings</p>
			<p>If you add a new movie<a id="_idIndexMarker444"/> to a family member now, nothing updates yet. However, if you go back to the family overview and then back to the family member, you'll see that the rating for the most recent movie is updated (make sure you choose a movie whose title is present on <a href="http://themoviedb.org">themoviedb.org</a>). Great! Now, all you need to do is make sure that we observe the managed object contex<a id="_idTextAnchor308"/>t for updates to the movies, so they are rel<a id="_idTextAnchor309"/>oaded if their rating changes.</p>
			<h3>Observing changes to movie ratings</h3>
			<p>You're already <a id="_idIndexMarker445"/>observing the managed object context for changes, but they are only processed if the family member that is shown on the current page has updated. This logic should be replaced so that it will reload the table view if either the family member or their favorite movies change. Update the <code>managedObjectContextDidChange(_:)</code> method in <code>MoviesViewController.swift</code> as follows:</p>
			<pre>@objc func managedObjectContextDidChange(notification: NSNotification) {
  guard let userInfo = notification.userInfo else { return }
  <strong class="bold">if let updatedObjects = userInfo[NSUpdatedObjectsKey] as? </strong>
<strong class="bold">     Set&lt;FamilyMember&gt;,</strong>
<strong class="bold">     let familyMember = self.familyMember, </strong>
<strong class="bold">     updatedObjects.contains(familyMember) {</strong>
<strong class="bold">    tableView.reloadData() </strong>
<strong class="bold">  }</strong>
  <strong class="bold">if let updatedObjects = userInfo[NSUpdatedObjectsKey] as? </strong>
<strong class="bold">  Set&lt;Movie&gt; {</strong>
<strong class="bold">    for object in updatedObjects {</strong>
<strong class="bold">      if object.familyMember == familyMember {</strong>
<strong class="bold">        tableView.reloadData()</strong>
<strong class="bold">        break</strong>
<strong class="bold">      }</strong>
<strong class="bold">    }</strong>
<strong class="bold">  }</strong>
}</pre>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The logic for observing the family member hasn't changed; its conditions simply moved from the <code>guard</code> statement to an <code>if</code> statement. An extra <code>if</code> statement was added for the movies. If the updated object set is a list of movies, we loop through the movies and check whether one of the movies has the current family member as its family member. If so, the table is refreshed immediately, and the loop is exited.</p>
			<p>It's important<a id="_idIndexMarker446"/> that the loop in the second <code>if</code> statement is set up like this because you might have just added a movie for family member A and then switched to family member B while the new movie for family member A was still loading its rating. Also, breaking out of the loop early ensures that you don't loop over any more objects than needed. All you want to do is refresh the table view if one of the current family members' favorite movies is updated.</p>
			<p>Okay, now build and run your app to take it for a spin! You'll notice that everything works as you'd want it to right now. Adding new movies triggers a network request; as soon as it finishes, the UI is updated with the new rating. Sometimes, this update will be done in an instant, but it could take a short while if you have a slow internet connection. Gr<a id="_idTextAnchor310"/>eat! That's it for this feature.</p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor311"/>Summary</h1>
			<p>This chapter was all about adding a small, simple feature to an existing app. We added the ability to load real data from an API. You saw that networking is made pretty straightforward by Apple with <code>URLSession</code> and data tasks. You also learned that this class abstracts away some very complex behavior regarding multithreading, so your apps remain responsive while data is loaded from the network. Next, you implemented a <code>helper</code> struct for networking and updated the Core Data model to store ratings for movies. Once all this was done, you could finally see how multithreading worked in the context of this app. This wasn't everything we needed to do, though. You learned about ATS and how it keeps your users secure. You also learned that you sometimes need to circumvent ATS, and we covered how you can achieve this.</p>
			<p>Even though the feature itself wasn't very complex, the concepts and theory involved could have been quite overwhelming. You suddenly had to deal with code that would be executed asynchronously in the future. And not just that. The code even used multiple threads to make sure that its performance was optimal. The concepts of multithreading and asynchronous programming are arguably two of the more complex aspects of programming. Practice them a lot and try to remember that any time you're passing around a closure, you could be writing some asynchronous code that gets executed on a different thread.</p>
			<p>Now that the list of movies is updated with data from the web, let's take it one s<a id="_idTextAnchor312"/><a id="_idTextAnchor313"/>tep further in the next chapter. You will learn how to make your app smarter by using CoreML and Vision Framework features.</p>
		</div>
	</body></html>