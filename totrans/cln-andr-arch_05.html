<html><head></head><body>
		<div><h1 id="_idParaDest-58"><em class="italic"><a id="_idTextAnchor062"/>Chapter 4</em>: Managing Dependencies in Android Applications</h1>
			<p>In this chapter, we will analyze the concept of <strong class="bold">dependency injection</strong> (<strong class="bold">DI</strong>) and the benefits it provides and look at how this was done in the past in Android applications either through manual injection or using Dagger 2. We will go over some of the libraries used in Android applications, stopping and looking in more detail at the Hilt library and how it simplifies DI for an Android application.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Introduction to DI</li>
				<li>Using Dagger 2 to manage dependencies</li>
				<li>Using Hilt to manage dependencies</li>
			</ul>
			<p>By the end of this chapter, you will be familiar with the DI pattern and libraries such as Dagger and Hilt, which can be used to manage dependencies in Android applications.</p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor063"/>Technical requirements </h1>
			<p>The hardware and software requirements are as follows:</p>
			<ul>
				<li>Android Studio Arctic Fox 2020.3.1 Patch 3</li>
			</ul>
			<p>The code files for this chapter can be found here: <a href="https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter4">https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter4</a>.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/38yFDHz">https://bit.ly/38yFDHz</a></p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor064"/>Introduction to DI</h1>
			<p>In this section, we will look at what DI is, the benefits it provides, and how this concept is applied to an <a id="_idIndexMarker331"/>Android application. We will then look at some DI libraries and how they work.</p>
			<p>When a class depends on functionality from another class, a dependency is created between the two classes. To invoke the functionality on the class you depend on, you will need to instantiate it, as in the following example:</p>
			<pre> class ClassA() {
    private val b: ClassB = ClassB()
    fun executeA() {
        b.executeB()
    }
}
class ClassB() {
    fun executeB() {
        
    }
}</pre>
			<p>In this example, <code>ClassA</code> creates a new instance of <code>ClassB</code>, and then when <code>executeA</code> is invoked, it will invoke <code>executeB</code>. This poses a problem because <code>ClassA</code> will have the extra responsibility of creating <code>ClassB</code>. Let's see what happens if <code>ClassB</code> needs to change to something such as the following:</p>
			<pre>class ClassB(private val myFlag: Boolean) {
    
    fun executeB() {
        if (myFlag) {
            // Do something
        } else {
            // Do something else
        }
    }
}</pre>
			<p>Here, we added the <code>myFlag</code> variable to <code>ClassB</code>, which is used in the <code>executeB</code> method. This <a id="_idIndexMarker332"/>change would cause a compile error because now <code>ClassA</code> will need to be modified to make the code compile.</p>
			<pre>class ClassA() {
    <strong class="bold">private val b: ClassB = ClassB(true)</strong>
    fun executeA() {
        b.executeB()
    }
}</pre>
			<p>Here, we will need to supply a Boolean value when we create <code>ClassB</code>. </p>
			<p>Making these types of changes to an application as its code base increases will make it hard to maintain. A solution to this problem is to separate how we use dependencies and how we create them and delegate the creation to a different object. Continuing from the preceding example, we can rewrite <code>ClassA</code> as the following:</p>
			<pre>class ClassA(<strong class="bold">private val b: ClassB</strong>) {
    fun executeA() {
        b.executeB()
    }
}</pre>
			<p>Here, we removed the instantiation of <code>ClassB</code> and moved the variable in the constructor of <code>ClassA</code>. Now, we can create a class that will be responsible for creating the instances of both classes that looks like the following:</p>
			<pre>class Injector() {
    fun createA(b: ClassB) = ClassA(b)
    fun createB() = ClassB(true)
}</pre>
			<p>Here, we have a new class that will create an instance of <code>ClassA</code> with <code>ClassB</code> as a parameter and a separate method for creating an instance of <code>ClassB</code>. Ideally, when the program <a id="_idIndexMarker333"/>is initialized, we would need to initialize all the dependencies and pass them appropriately:</p>
			<pre>fun main(args : Array&lt;String&gt;) {
    val injector = Injector()
    val b = injector.createB()
    val a = injector.createA(b)
}</pre>
			<p>Here, we created <code>Injector</code>, which is responsible for creating our instances, and then invoked the appropriate methods on <code>Injector</code> to retrieve the appropriate instances of each class. What we have done here is called DI. Instead of <code>ClassA</code> creating the instance of <code>ClassB</code>, it will <a id="_idIndexMarker334"/>have an instance of <code>ClassB</code> injected through the constructor, also known as <em class="italic">constructor injection</em>.</p>
			<p>In <code>ClassB</code>, we have an <code>if-else</code> statement in the <code>executeB</code> method. We can introduce an <a id="_idIndexMarker335"/>abstraction there, so we split the <code>if-else</code> statement into two separate implementations:</p>
			<pre>class ClassA(private val b: ClassB) {
    fun executeA() {
        b.executeB()
    }
}
interface ClassB {
    fun executeB()
}
class ClassB1() : ClassB {
    override fun executeB() {
        // Do something
    }
}
class ClassB2() : ClassB {
    override fun executeB() {
        // Do something else
    }
}</pre>
			<p>Here, <code>ClassA</code> remains the same and <code>ClassB</code> has become an interface with two implementations, called <code>ClassB1</code> and <code>ClassB2</code>, representing the implementations of the <code>if-else</code> branch. Here, we can use the <code>Injector</code> class as well to inject one of the two implementations without requiring any change on <code>ClassA</code>:</p>
			<pre>class Injector() {
    fun createA(b: ClassB) = ClassA(b)
    fun createB() = ClassB1()
}</pre>
			<p>In the <code>createB</code> method, we return an instance of <code>ClassB1</code>, which will then be later injected into <code>ClassA</code>. This represents another benefit of DI, where we can make our code depend on <a id="_idIndexMarker336"/>abstractions rather than concretions and provide different concretions for different purposes. Based on this, we can define the following roles when it comes to DI:</p>
			<ul>
				<li><code>ClassB1</code> and <code>ClassB2</code> in our example)</li>
				<li><code>ClassB</code> in our example)</li>
				<li><code>ClassA</code> in our example)</li>
				<li><code>Injector</code> in our example)</li>
			</ul>
			<div><div><img src="img/Figure_4.01_B18320.jpg" alt="Figure 4.1 – DI class diagram&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – DI class diagram</p>
			<p>The preceding figure shows the class diagram of our example and the DI pattern. We can observe how the <code>Injector</code> class is responsible for creating and injecting the dependencies, <code>ClassA</code> is the client <a id="_idIndexMarker337"/>receiving <a id="_idIndexMarker338"/>a dependency to <code>ClassB</code>, which is the interface, and <code>ClassB1</code> and <code>ClassB2</code> represent the services.</p>
			<p>There are multiple classifications of the types of DI, and they mainly revolve around two ways of injecting dependencies:</p>
			<ul>
				<li><strong class="bold">Constructor injection</strong>: Where <a id="_idIndexMarker339"/>dependencies are passed through the constructor.</li>
				<li><strong class="bold">Field injection</strong>: Where <a id="_idIndexMarker340"/>dependencies are passed through setter methods or by changing the instance variables. This can also be referred to as <strong class="bold">setter injection</strong> and it can <a id="_idIndexMarker341"/>also be expanded to <strong class="bold">interface injection</strong> in which the <a id="_idIndexMarker342"/>setter method is abstracted to an interface.</li>
			</ul>
			<p>Another benefit of DI is the fact that it makes the code more testable. When dependencies are <a id="_idIndexMarker343"/>injected into an object, it makes the class easier to test, because in the test code, we can inject objects that allow us to mimic various behaviors, called <strong class="bold">mocks</strong>. </p>
			<p>In this section, we have introduced the DI pattern, how it works, and the problems it is solving. Developers can manage an application's dependencies and injection manually, by setting up injectors. But as an application grows, it becomes hard to maintain, especially when <a id="_idIndexMarker344"/>we want certain objects to live only as long as other objects and not as long as the application, or handle different instances of the same class. There are various DI frameworks and libraries that can manage all these cases and in Android, one of the most commonly used ones is Dagger 2.</p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor065"/>Using Dagger 2 to manage dependencies</h1>
			<p>In this section, we <a id="_idIndexMarker345"/>will analyze the Dagger 2 library, how <a id="_idIndexMarker346"/>it handles DI, how it works, how it is integrated into an Android application, and what issues it might create. </p>
			<p>The Dagger 2 library relies on code generation based on annotation processing, which will generate the boilerplate code that is required to perform DI. The library is written in Java, and it is used for various projects outside of Android applications. Because it is written in Java, it provides compatibility for apps written in Java, Kotlin, or both. The library is built using <code>@Inject</code>, <code>@Named</code>, <code>@Qualifier</code>, <code>@Scope</code>, and <code>@Singleton</code>). </p>
			<p>When integrating Dagger 2, there are three main concepts that we will need to consider:</p>
			<ul>
				<li><code>@Module</code> annotation for the classes and <code>@Provides</code> for the methods. To avoid many <code>@Module</code> definitions, we can use the <code>@Inject</code> annotation on a constructor, which will provide the object as a dependency.</li>
				<li><code>@Inject</code> annotation.</li>
				<li><code>@Component</code> annotation.</li>
			</ul>
			<p>In order to add <a id="_idIndexMarker348"/>Dagger 2 to an Android application, you will <a id="_idIndexMarker349"/>first need to add the Kotlin annotation processor plugin to the <code>build.gradle</code> file of the module in which Dagger 2 is used: </p>
			<pre>plugins {
    … 
    id 'kotlin-kapt'
    …
}</pre>
			<p>Here, we added the <code>kotlin-kapt</code> plugin to allow Dagger 2 to generate the code necessary for DI. Next, we will need the Dagger 2 dependencies:</p>
			<pre>dependencies {
    …
    implementation 'com.google.dagger:dagger:2.40.5'
    kapt 'com.google.dagger:dagger-compiler:2.40.5'
    …
}</pre>
			<p>Here, we are adding a dependency to the Dagger 2 library and a dependency to the annotation processing library, which has the role of code generation. The library version should ideally be the latest stable one available in the library repository.</p>
			<p>Let's now <a id="_idIndexMarker350"/>re-introduce the example from the <a id="_idIndexMarker351"/>previous section:</p>
			<pre>class ClassA(private val b: ClassB) {
    fun executeA() {
        b.executeB()
    }
}
interface ClassB {
    fun executeB()
}
class ClassB1() : ClassB {
    override fun executeB() {
        // Do something
    }
}
class ClassB2() : ClassB {
    override fun executeB() {
        // Do something else
    }
}</pre>
			<p>Here, we have the same classes with the same dependencies. Instead of defining an <code>Injector</code> class, we can use Dagger 2 to define an <code>@Module</code>:</p>
			<pre>@Module
class ApplicationModule {
    @Provides
    fun provideClassA(b: ClassB): ClassA = ClassA(b)
    @Provides
    fun provideClassB(): ClassB = ClassB1()
}</pre>
			<p>Here, we annotated <a id="_idIndexMarker352"/>the class with <code>@Module</code> and for <a id="_idIndexMarker353"/>each instance, we used the <code>@Provides</code> annotation. We can further simplify this with the <code>@Inject</code> annotation and delete the <code>@Provides</code> methods from <code>ApplicationModule</code>:</p>
			<pre>class ClassA @Inject constructor(private val b: ClassB) {
   …
}
class ClassB1 @Inject constructor() : ClassB {
    …
}
class ClassB2 @Inject constructor() : ClassB {
    …
}</pre>
			<p>In the preceding code, we have added <code>@Inject</code> for each constructor. In the case of <code>ClassA</code>, it will have both the role of injecting <code>ClassB</code> and providing <code>ClassA</code> to other objects as a <a id="_idIndexMarker354"/>dependency. There is, however, an issue <a id="_idIndexMarker355"/>because <code>ClassA</code> has a dependency on the abstraction rather than the concretion, so Dagger will not know which instance to provide to <code>ClassA</code>. We can now add an <code>@Binds</code> annotated method to <code>ApplicationModule</code>, which will connect the abstraction with the implementation:</p>
			<pre>@Module
abstract class ApplicationModule {
    @Binds
    abstract fun bindClassB(b: ClassB1): ClassB
}</pre>
			<p>Here, we added the <code>bindClassB</code> abstract method, which is annotated with <code>@Binds</code>. This method will tell Dagger 2 to connect the <code>ClassB1</code> implementation with the <code>ClassB</code> abstraction. To avoid large <code>@Provides</code> annotations, we should try to use the annotation for dependencies where we cannot modify the code and instead rely on <code>@Inject</code> on the constructors and using <code>@Binds</code> where possible.</p>
			<p>Now, we will need to create the connector:</p>
			<pre>@Singleton
@Component(modules = [ApplicationModule::class])
interface ApplicationComponent</pre>
			<p>Here, we are defining an <code>@Component</code> in which we specify the module the application will use. The <code>@Singleton</code> annotation tells Dagger that all the dependencies in this component will live as long as the application. At this point, we should trigger a build on the application. This will trigger the compilation, which will generate a <code>DaggerApplicationComponent</code> class. This is an implementation of <code>ApplicationComponent</code> that Dagger 2 will handle. This class will be used to create the entire dependency graph. In Android, we need an entry point for this, which is represented by the <code>Application</code> class:</p>
			<pre>class MyApplication : Application() {
    lateinit var component: ApplicationComponent
    override fun onCreate() {
        super.onCreate()
        component = DaggerApplicationComponent.create()
    }
}</pre>
			<p>Here, in the <code>MyApplication</code> class, we are using <code>DaggerApplicationComponent</code> and creating the dependency graph. This will go over all the modules in <a id="_idIndexMarker356"/>the graph and invoke all the <code>@Provides</code> methods. The <code>@Component</code> annotation has another role, which is to define <a id="_idIndexMarker357"/>member injection when constructor injection is not possible. In Android, this situation occurs when dealing with life cycle components such as activities and fragments, because we are not allowed to modify the default constructors of these classes. To do this, we can do the following:</p>
			<pre>@Singleton
@Component(modules = [ApplicationModule::class])
interface ApplicationComponent {
    <strong class="bold">fun inject(mainActivity: MainActivity)</strong>
}</pre>
			<p>In <code>ApplicationComponent</code>, we add a method called <code>inject</code> and the <code>Activity</code> where we want the injection to be performed. In the <code>MainActivity</code> class, we will need to do the following:</p>
			<pre>class MainActivity : AppCompatActivity() {
    @Inject
    lateinit var a: ClassA
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        (application as 
             MyApplication).component.inject(this)
        a.executeA()
    }
}</pre>
			<p>Here, we will need to access the <code>ApplicationComponent</code> instance created in <code>MyApplication</code> and then invoke the <code>inject</code> method from <code>ApplicationComponent</code>. This will then initialize variable <code>a</code> with the instance Dagger 2 created. This approach has a problem, however, because all the dependencies will live as long <a id="_idIndexMarker358"/>as the application. This means that Dagger 2 <a id="_idIndexMarker359"/>will need to keep dependencies in memory when they are not required. Dagger 2 offers a solution for this in the form of scopes and subcomponents. We can create a new Scope, which will tell Dagger 2 to only keep certain dependencies as long as an Activity is alive, and then apply this Scope to a Subcomponent, which will handle a smaller graph of dependencies. </p>
			<pre>@Scope
@MustBeDocumented
@kotlin.annotation.Retention(AnnotationRetention.RUNTIME)
annotation class ActivityScope</pre>
			<p>Here, we created a new <code>@Scope</code> annotation, which will indicate that dependencies will live as long as activities. We will next use <code>@ActivityScope</code> to create an <code>@Subcomponent</code> annotated class:</p>
			<pre>@ActivityScope
@Subcomponent(modules = [ApplicationModule::class])
interface MainSubcomponent {
    fun inject(mainActivity: MainActivity)
} </pre>
			<p>Here, we have <a id="_idIndexMarker360"/>defined a subcomponent <a id="_idIndexMarker361"/>that will use <code>ApplicationModule</code> and has an <code>inject</code> method for field injection into <code>MainActivity</code>. After that, we will need to tell Dagger 2 to create <code>MainSubcomponent</code>, by modifying <code>ApplicationComponent</code>:</p>
			<pre>@Singleton
@Component
interface ApplicationComponent {
    fun createMainSubcomponent(): MainSubcomponent
}</pre>
			<p>Here, we have removed <code>ApplicationModule</code> from <code>@Component</code> and replaced the <code>inject</code> method with a <code>createMainSubcomponent</code> method, which will allow Dagger to create <code>MainSubcomponent</code>. Finally, we will need to access <code>MainSubcomponent</code> in <code>MainActivity</code> and inject the <code>ClassA</code> dependency:</p>
			<pre>class MainActivity : AppCompatActivity() {
    @Inject
    lateinit var a: ClassA
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        (application as MyApplication).component.
            createMainSubcomponent().inject(this)
        a.executeA()
    }
}</pre>
			<p>Here, we <a id="_idIndexMarker362"/>access the <code>ApplicationComponent</code> instance from <code>MyApplication</code>, then create <code>MainSubcomponent</code> and <a id="_idIndexMarker363"/>then inject the <code>ClassA</code> dependency into the <code>a</code> variable. The code generated by Dagger 2 can be seen in the <code>{module}/build/generated/source/kapt/{build type}</code> folder and will look something similar to the following figure:</p>
			<div><div><img src="img/Figure_4.02_B18320.jpg" alt="Figure 4.2 – Generated Dagger Classes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – Generated Dagger Classes</p>
			<p>In the preceding figure, we can see Dagger will generate the implementation for the <code>ApplicationComponent</code> interface as well as the <code>MainSubcomponent</code> implementation. For <a id="_idIndexMarker364"/>dependencies that will need to <a id="_idIndexMarker365"/>be injected, it will generate a <code>Factory</code> class to create the dependency. Where we are injecting through the members, it will create an <code>Injector</code> class, which will be responsible for setting the value on the member variable, like the <code>MainActivity</code> class. </p>
			<p>In this section, we have discussed the Dagger 2 library and how it can be used to provide and inject dependencies. Because it is a library used in other frameworks other than Android, it requires specific workarounds for injecting in activities and fragments, using member injectors and Subcomponents. An attempt at fixing this was through the introduction of the Dagger Android library, which handled the creation of <code>@Subcomponent</code> annotated classes and introduced new annotations to indicate how Subcomponents should be created. More recently, the introduction of the Hilt library was more <a id="_idIndexMarker366"/>effective at solving these problems by further <a id="_idIndexMarker367"/>simplifying the amount of code developers needed to write and providing better compatibility with components such as ViewModel. In the section that follows, we will look at the Hilt library and how it solves these problems.</p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor066"/>Using Hilt to manage dependencies</h1>
			<p>In this section, we <a id="_idIndexMarker368"/>will discuss the Hilt DI library, how <a id="_idIndexMarker369"/>we can use it in an Android application, and the extra features it provides on top of the Dagger 2 library.</p>
			<p>Hilt is a library built on top of Dagger 2 with a specific focus on Android applications. This is to remove the extra boilerplate code that was required to use Dagger 2 in an application. Hilt removes the need to use <code>@Component</code> and <code>@Subcomponent</code> annotated classes and in turn offers new annotations:</p>
			<ul>
				<li>When injecting dependencies in Android classes, we can use <code>@HiltAndroidApp</code> for <code>Application</code> classes, <code>@AndroidEntryPoint</code> for activities, fragments, services, broadcast receivers, and views, and <code>@HiltViewModel</code> for <code>ViewModels</code>.</li>
				<li>When using the <code>@Module</code> annotation, we now have the option to use <code>@InstallIn</code> and specify an <code>@DefineComponent</code> annotated class, which represents the component the module will be added to. Hilt provides a set of useful components to install modules in: <ul><li><code>@SingletonComponent</code>: This will make the dependencies live as long as the application.</li><li><code>@ViewModelComponent</code>: This will make the dependencies live as long as a <code>ViewModel</code>.</li><li><code>@ActivityComponent</code>: This will make the dependencies live as long as an <code>Activity</code>.</li><li><code>@FragmentComponent</code>: This will make the dependencies live as long as a <code>Fragment</code>.</li><li><code>@ServiceComponent</code>: This will make the dependencies live as long as a <code>Service</code>.</li></ul></li>
			</ul>
			<p>In order to <a id="_idIndexMarker370"/>use Hilt in a project, it will require a Gradle plugin, which <a id="_idIndexMarker371"/>will need to be added as a dependency to the root <code>build.gradle</code> file in the project:</p>
			<pre>buildscript {
    repositories {
        …
    }
    dependencies {
        …
        <strong class="bold">classpath 'com.google.dagger:hilt-android-gradle-</strong>
<strong class="bold">            plugin:2.40.5'</strong>
    }
}</pre>
			<p>We will then need to add the annotation processor plugin and the Hilt plugin to the <code>build.gradle</code> file of the Gradle module that we want to use the Hilt library in:</p>
			<pre>plugins {
    …
    id 'kotlin-kapt'
    id 'dagger.hilt.android.plugin'
}</pre>
			<p>The combination of these two plugins is what allows Hilt to generate the necessary source <a id="_idIndexMarker372"/>code for injecting the dependencies. Finally, we <a id="_idIndexMarker373"/>will need to add the dependency to the Hilt library:</p>
			<pre>dependencies {
    …
    implementation 'com.google.dagger:hilt-android:2.40.5'
    kapt 'com.google.dagger:hilt-compiler:2.40.5'
    …
}</pre>
			<p>Here, we need the dependency on the library itself and a dependency on the annotation processor like how it was necessary for Dagger 2.</p>
			<p>Let's now re-introduce the example from the previous section:</p>
			<pre>class ClassA <strong class="bold">@Inject</strong> constructor(private val b: ClassB) {
    fun executeA() {
        b.executeB()
    }
}
interface ClassB {
    fun executeB()
}
class ClassB1 <strong class="bold">@Inject</strong> constructor() : ClassB {
    override fun executeB() {
        // Do something
    }
}
class ClassB2 <strong class="bold">@Inject</strong> constructor() : ClassB {
    override fun executeB() {
        // Do something else
    }
}</pre>
			<p>Here, we <a id="_idIndexMarker374"/>can keep the same structure of our classes and <a id="_idIndexMarker375"/>use the <code>@Inject</code> annotation like previously. The <code>@Module</code> annotated class that will provide these dependencies will look similar to a Dagger 2 Module:</p>
			<pre>@Module
<strong class="bold">@InstallIn(SingletonComponent::class)</strong>
abstract class ApplicationModule {
    @Binds
    abstract fun bindClassB(b: ClassB1): ClassB
}</pre>
			<p>In the <code>ApplicationModule</code> class, we keep the same implementation as before but now we have added the <code>@InstallIn</code> annotation, which will make the dependencies provided by this module live as long as the application will. Next, we will need to trigger the generation of components:</p>
			<pre><strong class="bold">@HiltAndroidApp</strong>
class MyApplication : Application()</pre>
			<p>Here, we no longer need to use <code>DaggerApplicationComponent</code> to manually trigger the <a id="_idIndexMarker376"/>creation of the dependency graph and instead <a id="_idIndexMarker377"/>use <code>@HiltAndroidApp</code>, which will do this for us, as well as providing the ability to inject dependencies into the <code>MyApplication</code> class. Finally, we will need to inject the dependencies into an <code>Activity</code>:</p>
			<pre><strong class="bold">@AndroidEntryPoint</strong>
class MainActivity : AppCompatActivity() {
    @Inject
    lateinit var a: ClassA
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        a.executeA()
    }
}</pre>
			<p>Here, we use the <code>@AndroidEntry</code> point to inform Hilt that we want to inject a dependency into an Activity and then use the <code>@Inject</code> annotation like how it worked in Dagger 2. The code generated by Hilt will look similar to the following figure and can be found in <code>{module}/build/generated/source/kapt/{build type}</code>:</p>
			<div><div><img src="img/Figure_4.03_B18320.jpg" alt="Figure 4.3 – Generated Hilt Classes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – Generated Hilt Classes</p>
			<p>In the preceding figure, we can see <code>Factory</code> classes like the ones that Dagger 2 generates, but <a id="_idIndexMarker378"/>extra classes that Hilt will generate to <a id="_idIndexMarker379"/>handle the boilerplate work that was required to work with Dagger 2, such as handling the injection into activities and fragments or creating the dependency graph in the <code>Application</code> class.</p>
			<p>In this section, we discussed the Hilt library, how we can use it to manage dependencies in an Android application, and how it removes boilerplate code that Dagger 2 required. In the following section, we will look at an exercise on integrating Hilt into an application together with other libraries.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor067"/>Exercise 04.01 – Using Hilt to manage dependencies</h2>
			<p>Modify <em class="italic">Exercise 03.02 – navigating using Jetpack Compose</em> from <a href="B18320_03_ePub.xhtml#_idTextAnchor055"><em class="italic">Chapter 3</em></a><em class="italic">, Understanding Data Presentation on Android</em>, so that it will use Hilt to manage the dependencies across the application.</p>
			<p>To complete <a id="_idIndexMarker380"/>the exercise, you will need to do the <a id="_idIndexMarker381"/>following:</p>
			<ol>
				<li>Add the Hilt library to the project.</li>
				<li>Create a <code>NetworkModule</code> class that will provide the Retrofit dependencies.</li>
				<li>Create a <code>PersistenceModule</code> class that will provide the Room and Data Store dependencies.</li>
				<li>Clean up the <code>MyApplication</code> class, delete the <code>MainViewModelFactory</code> class, and instead use the <code>@HiltViewModel</code> annotation.</li>
				<li>Modify <code>MainActivity</code> to instead obtain an instance of the <code>MainView</code> model from the Hilt Compose Navigation library.</li>
			</ol>
			<p>Follow these steps to complete the exercise:</p>
			<ol>
				<li value="1">Add the Hilt Gradle plugin to the root project <code>build.gradle</code> file:<pre>buildscript {
    repositories {
        …
    }
    dependencies {
        …
        <strong class="bold">classpath 'com.google.dagger:hilt-android-</strong>
<strong class="bold">            gradle-plugin:2.40.5'</strong>
    }
}</pre></li>
				<li>Apply the <a id="_idIndexMarker382"/>Gradle plugin to the <code>build.gradle</code> file in <a id="_idIndexMarker383"/>the app module:<pre>plugins {
    …
    id 'dagger.hilt.android.plugin'
}</pre></li>
				<li>Add the Hilt library dependency to the app module's <code>build.gradle</code> file:<pre>dependencies {
    …
    implementation 'com.google.dagger:hilt-android
        :2.40.5'
    kapt 'com.google.dagger:hilt-compiler:2.40.5'
    implementation 'androidx.hilt:hilt-navigation-
        compose:1.0.0-rc01'
    …
}</pre></li>
			</ol>
			<p>Here, we added a dependency that allows Hilt to work with the Jetpack Compose Navigation library.</p>
			<ol>
				<li value="4">Create a <code>NetworkModule</code> class in which the networking dependencies are provided:<pre>@Module
@InstallIn(SingletonComponent::class)
class NetworkModule {
    @Provides
    fun provideOkHttpClient(): OkHttpClient = 
        OkHttpClient
        .Builder()
        .readTimeout(15, TimeUnit.SECONDS)
        .connectTimeout(15, TimeUnit.SECONDS)
        .build()
    @Provides
    fun provideMoshi(): Moshi = Moshi.Builder().
        add(KotlinJsonAdapterFactory()).build()
    @Provides
    fun provideRetrofit(okHttpClient: OkHttpClient, 
        moshi: Moshi): Retrofit = Retrofit.Builder()
        .baseUrl("https://jsonplaceholder.typicode.com/")
        .client(okHttpClient)
        .addConverterFactory(MoshiConverterFactory.create
    (moshi))
        .build()
    @Provides
    fun provideUserService(retrofit: Retrofit): 
        UserService =
            retrofit.create(UserService::class.java)
}</pre></li>
			</ol>
			<p>Here, we have <a id="_idIndexMarker384"/>moved all the dependencies <a id="_idIndexMarker385"/>for networking and split them into separate methods for <code>OkHttplClient</code>, <code>Moshi</code>, <code>Retrofit</code>, and finally, the <code>UserService</code> class.</p>
			<ol>
				<li value="5">Next, create a <code>PersistenceModule</code> class, which will return all the persistence-related dependencies:<pre>val Context.dataStore: DataStore&lt;Preferences&gt; by preferencesDataStore(name = "my_preferences")
@Module
@InstallIn(SingletonComponent::class)
class PersistenceModule {
    @Provides
    fun provideAppDatabase(@ApplicationContext 
        context: Context): AppDatabase =
        Room.databaseBuilder(
            context,
            AppDatabase::class.java, "my-database"
        ).build()
    @Provides
    fun provideUserDao(appDatabase: AppDatabase): 
        UserDao = appDatabase.userDao()
    @Provides
    fun provideAppDataStore(@ApplicationContext 
        context: Context) = AppDataStore
            (context.dataStore)
}</pre></li>
			</ol>
			<p>Here, we have moved all the Room-related classes and the Data Store classes. For <code>DataStore</code>, we are required to declare the <code>Context.dataStore</code> file at the top level <a id="_idIndexMarker386"/>of the file, so we will need to keep <a id="_idIndexMarker387"/>it here. The usage of <code>@ApplicationContext</code> is meant to denote that the <code>Context</code> object is represented by context of the application and not other Context objects such as an <code>Activity</code> object or <code>Service</code> object. The annotation is a <code>Qualifier</code>, which is meant to distinguish between different instances of the same class (in this case, it's to distinguish between the application context and activity context).</p>
			<ol>
				<li value="6">Add the <code>@Inject</code> annotation to the constructor of the <code>MainTextFormatter</code> class:<pre>class MainTextFormatter <strong class="bold">@Inject constructor(@ApplicationContext</strong> private val applicationContext: Context) {
    fun getCounterText(count: Int) =
        applicationContext.getString(R.string.total_
            request_count, count)
}</pre></li>
			</ol>
			<p>This will let Hilt provide a new instance of <code>MainTextFormatter</code> every time it will be used as a dependency. Here, again, we will need to use the <code>@ApplicationContext</code> annotation to use the application <code>Context</code> object.</p>
			<ol>
				<li value="7">Delete all <a id="_idIndexMarker388"/>the dependencies in the <code>MyApplication</code> class <a id="_idIndexMarker389"/>and add the <code>@HiltAndroidApp</code> annotation:<pre>@HiltAndroidApp
class MyApplication : Application()</pre></li>
				<li>Delete the <code>MainViewModelFactory</code> class.</li>
				<li>Add the <code>@HiltViewModel</code> annotation to the <code>MainViewModel</code> class and <code>@Inject</code> to the constructor:<pre><strong class="bold">@HiltViewModel</strong>
class MainViewModel <strong class="bold">@Inject constructor</strong>(
    private val userService: UserService,
    private val userDao: UserDao,
    private val appDataStore: AppDataStore,
    private val mainTextFormatter: MainTextFormatter
) : ViewModel() {
   …
}</pre></li>
				<li>Delete the reference to <code>MainViewModelFactory</code> in the <code>Users</code> <code>@Composable</code> method in <code>MainActivity</code>:<pre>@Composable
fun Users(
    navController: NavController,
    viewModel: MainViewModel
) {
    …
}</pre></li>
				<li>Change <a id="_idIndexMarker390"/>the <code>@Composable</code> <code>App</code> method <a id="_idIndexMarker391"/>in <code>MainActivity</code> so that it provides a <code>MainViewModel</code> instance when it invokes the <code>Users</code> method:<pre>@Composable
fun App(navController: NavHostController) {
    NavHost(navController, startDestination = AppNavigation.Users.route) {
        composable(route = AppNavigation.Users.route) {
            Users(navController, <strong class="bold">hiltViewModel()</strong>)
        }
        composable(
            route = AppNavigation.User.route,
            arguments = listOf(navArgument
                (AppNavigation.User.argumentName) {
                type = NavType.StringType
            })
        ) {
            User(it.arguments?.getString(AppNavigation.User.
    argumentName).orEmpty())
        }
    }
}</pre></li>
			</ol>
			<p>Here, we are using the <code>hiltViewModel</code> method, which is from the Hilt compatibility library with the Navigation library. </p>
			<ol>
				<li value="12">Add the <code>@AndroidEntryPoint</code> annotation to <code>MainActivity</code>:<pre>@AndroidEntryPoint
class MainActivity : ComponentActivity() {
    …
}</pre></li>
				<li>If you <a id="_idIndexMarker392"/>encounter a <code>Records requires ASM8</code> error <a id="_idIndexMarker393"/>when building the application, then add the following to the root project's <code>gradle.properties</code> file:<pre>android.jetifier.ignorelist=moshi-1.13.0</pre></li>
			</ol>
			<p>This error is caused by an incompatibility that currently exists in the Android build tools and should be resolved when later updates are available.</p>
			<p>If we run the application covered in this exercise, the functionality and user interface should remain the same as before. The role of Hilt here was to simplify how we manage dependencies, shown by how we have simplified the <code>MyApplication</code> class, leaving it with a simple annotation, and the fact that we have removed <code>MainViewModelFactory</code>, which itself had to depend on the <code>MyApplication</code> class. We can also see how easy it is to integrate Hilt with the rest of the libraries we used in the exercise.</p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor068"/>Summary</h1>
			<p>In this chapter, we looked at the DI pattern and some of the more popular libraries that are available to apply this pattern to an Android application. We looked initially at Dagger 2 and how it can be integrated into an application, and then we analyzed the Hilt library, which is built on top of Dagger 2 and solves further problems that are specific to Android development.</p>
			<p>There are other libraries that can be used to manage dependencies, such as Koin, which uses the Service Locator pattern (in which a registry is created and dependencies can be obtained) and is developed for Kotlin development. The exercise in this chapter showed how Hilt can be integrated with other libraries into an Android application. The problem is that the application still has no shape; there isn't anything we can point to that indicates what the use cases are. In the chapters that follow, we will look further into how we can structure our code to give it a shape using the Clean Architecture principles, starting with defining entities and use cases.</p>
		</div>
	</body></html>