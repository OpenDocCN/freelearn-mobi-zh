- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Understanding Animation with SwiftUI
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解使用SwiftUI的动画
- en: In the first chapter, we covered many SwiftUI fundamentals we will see when
    we start building projects. In this chapter, we will look at how animations work,
    including timing curves and animatable properties, which will lay the foundation
    for the projects we build.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们介绍了在开始构建项目时我们将看到的许多SwiftUI基础知识。在本章中，我们将探讨动画的工作原理，包括时间曲线和可动画属性，这将为我们将要构建的项目奠定基础。
- en: 'The following are the key topics we will explore:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将要探讨的关键主题：
- en: What is animation?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是动画？
- en: Understanding timing curves
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解时间曲线
- en: Understanding animation types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解动画类型
- en: Triggering animations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发动画
- en: Exploring animatable properties
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索可动画属性
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the code for this chapter on GitHub in the `Chapter 2` folder:
    [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub的`Chapter 2`文件夹中找到本章的代码：[https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications)。
- en: What is animation?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是动画？
- en: Let’s consider the book’s definition of animation. **Animation** is a series
    of static images displayed in rapid succession to create the illusion of motion.
    The images, or frames, are usually displayed at a rate of 24 or 30 frames per
    second from the beginning to the end, which is fast enough to create the illusion
    of continuous motion. These can be created using a variety of techniques, including
    hand-drawn, computer-generated, and stop-motion animations.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑这本书对动画的定义。**动画**是一系列静态图像以快速连续的方式显示，以产生运动错觉。这些图像，或帧，通常以每秒24或30帧的速率从开始到结束显示，这足以产生连续运动的错觉。这些可以使用各种技术创建，包括手绘、计算机生成和定格动画。
- en: Looking at this definition, we can see that there is a start point and an end
    point to animation, and the images in between are all slightly different; when
    played, our eyes cannot pick out the individual images, which means we perceive
    movement or animation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个定义来看，我们可以看到动画有一个起点和终点，中间的图像都是略有不同的；当播放时，我们的眼睛无法分辨出单个图像，这意味着我们感知到运动或动画。
- en: In SwiftUI, we have to define the start point (where the animation begins) and
    the end point (where the animation ends). However, when we code, we don’t actually
    put a bunch of still images between both end points (though we can); what we usually
    do is use a single image and then animate the properties of that image, such as
    its location on the screen, its opacity, or its color.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在SwiftUI中，我们必须定义起点（动画开始的地方）和终点（动画结束的地方）。然而，当我们编写代码时，我们实际上并没有在两个终点之间放置一大堆静态图像（尽管我们可以这样做）；我们通常使用单个图像，然后动画化该图像的属性，例如其在屏幕上的位置、其不透明度或其颜色。
- en: In addition to images, we can also animate RGB colors by changing their hue
    or the corner radius of shapes, and if we draw a shape, we can animate the individual
    lines (paths) or the strokes around it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 除了图像之外，我们还可以通过改变它们的色调或形状的圆角来动画化RGB颜色，如果我们绘制一个形状，我们可以动画化其单个线条（路径）或周围的描边。
- en: 'It works like this: if we want a rectangle to move from the bottom left to
    the top right of the iPhone or iPad screen, we declare it in code (that declarative
    syntax thing again) by using the `animation` modifier. Then SwiftUI does the magic
    for us, moving the object, or in SwiftUI speak, “transitioning” the object from
    a start point to an end point, filling in all the gaps along the way with whatever
    values we are working with (integers, colors, opacity, etc.). The process of going
    through all the values to create a smooth fluid motion is called **interpolation**.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作原理是这样的：如果我们想让一个矩形从iPhone或iPad屏幕的左下角移动到右上角，我们可以在代码中（又是那种声明式语法）通过使用`animation`修饰符来声明它。然后SwiftUI为我们施展魔法，移动对象，或者用SwiftUI的话说，“过渡”对象从起点到终点，用我们在路上使用的任何值（整数、颜色、不透明度等）填充所有空白。通过遍历所有值来创建平滑流畅运动的过程被称为**插值**。
- en: SwiftUI fills in those gaps for us really well, but it cannot animate every
    property of every view. Only properties considered “animatable” can be animated;
    things such as a view’s color, opacity, rotation, size, position, corner radius,
    and strokes. Nearly all properties that have a numerical value are animatable.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI为我们很好地填补了这些空白，但它不能为每个视图的每个属性进行动画。只有被认为是“可动画”的属性才能进行动画；例如，视图的颜色、不透明度、旋转、大小、位置、圆角和描边。几乎所有具有数值的属性都是可动画的。
- en: SwiftUI includes basic animations with default or custom easing or timing curves
    (a timing curve refers to the speed at the start and end of the animation), as
    well as spring animations. Spring animations have a bouncy effect to them and
    can be adjusted from a slight bounce to a very pronounced bounce, similar to a
    rubber ball bouncing on the floor.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI 包含了基本的动画，默认或自定义缓动或时间曲线（时间曲线指的是动画开始和结束的速度），以及弹簧动画。弹簧动画具有弹跳效果，可以从轻微的弹跳调整到非常明显的弹跳，类似于橡皮球在地面上弹跳。
- en: You can also change many customization options, such as the speed of an animation,
    add a “wait” time before the animation starts, and have an animation repeat itself.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以更改许多自定义选项，例如动画的速度、在动画开始前的“等待”时间，以及使动画重复。
- en: Let’s continue by diving deeper into animation timing curves, seeing what they
    look like and how they affect an animation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续深入探讨动画时间曲线，看看它们看起来像什么以及它们如何影响动画。
- en: Understanding timing curves
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解时间曲线
- en: Animations have what are called curves. A **curve**, or more specifically, a
    **timing curve**, refers to the speed at which the animation starts and how it
    should end.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 动画有所谓的曲线。**曲线**，更具体地说，是**时间曲线**，指的是动画开始和结束的速度。
- en: 'SwiftUI provides several timing curves to choose from that we can use inside
    the `animation` modifier. It’s called a timing curve because if you were to plot
    each point of the animation’s movement from start to finish on a graph, and draw
    a line by connecting those points, most of them would create a curved line, as
    in this illustration:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI 提供了多种时间曲线供我们在 `animation` 修饰符中使用。它被称为时间曲线，因为如果你要在图表上绘制动画从开始到结束的每个点的位置，并通过连接这些点绘制一条线，大多数情况下都会形成曲线，就像这个插图所示：
- en: '![Figure 2.1: The ease timing curves ](img/B18674_02_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1：ease 时间曲线](img/B18674_02_01.jpg)'
- en: 'Figure 2.1: The ease timing curves'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：ease 时间曲线
- en: 'This graph shows three animation timing curves: `easeInOut` timing curve, the
    animation starts slow, speeds up, and then finally slows down before coming to
    a complete stop.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此图显示了三种动画时间曲线：`easeInOut` 时间曲线，动画开始时速度较慢，然后加速，最后在完全停止前再次减速。
- en: 'There is also a linear timing curve. An animation using this curve will have
    the same rate of speed at its beginning as it does at its end. If you were to
    plot it on a graph, it would be a straight line, like so:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个线性时间曲线。使用此曲线的动画在开始和结束时将以相同的速度进行。如果你要在图表上绘制它，它将是一条直线，如下所示：
- en: '![Figure 2.2: The linear timing curve ](img/B18674_02_02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2：线性时间曲线](img/B18674_02_02.jpg)'
- en: 'Figure 2.2: The linear timing curve'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2：线性时间曲线
- en: Timing curves are not complicated – we get to choose the ones we want based
    on how we want the animation to look and perform. If you don’t specify a timing
    curve, you will get the default curve, the `easeInOut` one. We will use some of
    these SwiftUI-provided timing curves in our projects.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 时间曲线并不复杂——我们可以根据自己的需求选择想要的时间曲线。如果你没有指定时间曲线，你将得到默认曲线，即 `easeInOut`。我们将在我们的项目中使用一些这些
    SwiftUI 提供的时间曲线。
- en: 'In the next section, I want to explain the two distinct types of animation
    in SWiftUI: implicit and explicit.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我想解释 SwiftUI 中的两种不同类型的动画：隐式和显式。
- en: Understanding animation types
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解动画类型
- en: 'There are two types of animations in SwiftUI: implicit and explicit. Let’s
    look at what these animation types do and the difference between the two.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SwiftUI 中有两种类型的动画：隐式和显式。让我们看看这些动画类型的作用以及两者之间的区别。
- en: 'An `animation` modifier. Here is an example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `animation` 修饰符。以下是一个示例：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, we use a tap gesture to scale up the size of a circle; when
    tapped, the circle will grow by half its size. The `.animation` modifier uses
    the default animation style, which will animate the circle using an easeInOut
    timing curve by default.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用轻触手势来放大圆圈的大小；当轻触时，圆圈将增长到其大小的一半。`.animation` 修饰符使用默认的动画样式，默认情况下将使用
    `easeInOut` 时间曲线来动画化圆圈。
- en: 'You can also use other animation styles. For example, here, I added a `spring`
    style instead of the default style:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用其他动画样式。例如，在这里，我添加了 `spring` 样式而不是默认样式：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This style will animate the circle and add a springy effect to it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此样式将使圆圈动画并为其添加弹簧效果。
- en: So implicit animations are a convenient way to add basic animations to your
    SwiftUI app without having to write any explicit animation code. The animations
    are applied using the `animation` modifier.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，隐式动画是向您的SwiftUI应用程序添加基本动画的一种方便方式，而无需编写任何显式动画代码。动画是通过`animation`修饰符应用的。
- en: Sometimes though, you may want more from your animation, and implicit animations
    may not give you the degree of control that you are looking for. In this case,
    you can use explicit animations instead.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能希望从动画中获得更多，而隐式动画可能无法提供您所需的控制程度。在这种情况下，您可以使用显式动画。
- en: 'An `withAnimation` function. Here’s an example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`withAnimation`函数。以下是一个示例：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, tapping the button will animate the scale of the text using
    a spring animation. The duration of the animation will be determined by the system’s
    default animation settings, but the curve of the animation will be customized
    using the `interpolatingSpring` function.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，点击按钮将使用弹簧动画来动画化文本的缩放。动画的持续时间将由系统的默认动画设置确定，但动画的曲线将通过`interpolatingSpring`函数进行自定义。
- en: 'Additionally, you can customize the duration of the animation by specifying
    a `duration` parameter in the `interpolatingSpring` function. The following is
    an example of this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以通过在`interpolatingSpring`函数中指定`duration`参数来自定义动画的持续时间。以下是一个示例：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will cause the animation to last for `2.5` seconds.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使动画持续`2.5`秒。
- en: So, the difference when using explicit animations versus implicit animations
    is that they can give you more control over the details of the animation, or when
    you want to animate multiple properties simultaneously; you can put as much code
    into the `withAnimation` block as needed. However, they can be more work to set
    up than implicit animations.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用显式动画与隐式动画的区别在于，它们可以为您提供更多控制动画细节的能力，或者当您想要同时动画化多个属性时；您可以将尽可能多的代码放入`withAnimation`块中。然而，它们可能比隐式动画更难设置。
- en: 'You can also have the animation repeat itself a pre-set number of times or
    indefinitely. Here’s an example of repeating the previous animation forever and
    auto-reversing it:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以让动画重复播放预设的次数或无限期重复。以下是一个将之前的动画永久重复并自动反转的示例：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the previous example, I altered the code in the `withAnimation` function
    to include the `repeatForever` option and set the `autoreverses` parameter to
    `true`. When you run the code, the text will scale up with a springy effect, and
    when it’s done bouncing (about 3 seconds or so), the animation will start over,
    repeating endlessly or until the app is stopped.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我修改了`withAnimation`函数中的代码，以包含`repeatForever`选项并将`autoreverses`参数设置为`true`。当您运行代码时，文本将以弹簧效果放大，当它完成弹跳（大约3秒左右）后，动画将重新开始，无限期重复或直到应用程序停止。
- en: Those are the two types of animations; next is a list of ways to trigger animations.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就是两种类型的动画；接下来是一个触发动画的方法列表。
- en: Triggering animations
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触发动画
- en: 'So, how do we trigger animations? There are several ways to do so in SwiftUI,
    including using the following SwiftUI modifiers, methods, and functions:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何触发动画呢？在SwiftUI中，有几种方法可以做到这一点，包括使用以下SwiftUI修饰符、方法和函数：
- en: 'The `.animation()` modifier: This modifier allows you to specify the type of
    animation used when a view appears or disappears or when its state changes.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.animation()`修饰符：此修饰符允许您指定视图出现或消失或其状态变化时使用的动画类型。'
- en: 'The `withAnimation()` function: This function allows you to wrap a block of
    code that changes the state of a view, and it will automatically animate the changes.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withAnimation()`函数：此函数允许您将一个代码块包裹起来，该代码块会改变视图的状态，并且它会自动动画化这些更改。'
- en: 'A **gesture**: This is a way to interact with a view by performing actions
    such as tapping, dragging, or pinching. You can use a gesture to trigger an animation
    when a certain action is performed on a view.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**手势**：这是一种通过执行诸如点击、拖动或捏合等操作与视图交互的方式。您可以使用手势在视图上执行特定操作时触发动画。
- en: 'A **timer**: This allows you to specify an animation to be performed over a
    certain period of time. You can use a timer to animate the changes to a view’s
    state over a specific duration.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**计时器**：这允许您指定在一定时间内执行动画。您可以使用计时器在特定持续时间内动画化视图状态的更改。
- en: 'The `onAppear()` and `onDisappear()` modifiers: These modifiers allow you to
    specify code to be executed when a view appears or disappears. These modifiers
    can trigger an animation when a view appears or disappears.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Button and other control views: A button, slider, picker, or other control
    type view in SwiftUI can be a trigger for an animation.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other ways to trigger animations, but these are the main ones that
    we will cover here. Whatever you choose will depend on the specific needs of your
    app and the behavior you want to produce. We will explore these different triggers
    when we start building our projects in the coming chapters.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue by looking at various properties that can be animated in SwiftUI.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Exploring animatable properties
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will explore some of the animatable properties. Here is
    a list of the ones that we will look at:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Offset
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hue rotation
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opacity
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scale
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stroke
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trim
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Corner radius
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take a look at them in more detail.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: The offset property
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first property we will look at that is animatable is the `offset` modifier
    that has been placed on a rectangle shape:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After you put that code into your `ContentView` file, your preview will look
    like *Figure 2**.3*. When you press the **Animate** button, the blue rectangle
    will move to the right, and when you press it again, it will return to its original
    starting position.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3: Animating the offset ](img/B18674_02_03.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: Animating the offset'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: This is how the code works. When the `moveRight` variable has its value toggled
    or changed to `true`, and the `offset` modifier has a ternary operator in there
    for its `x` parameter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: A ternary operator is an operator that accepts a Boolean variable and checks
    to see whether it’s `true` or `false`. If the variable is `true`, the value to
    the left of the colon is used, but if the variable is `false`, the value to the
    right of the colon is used. This makes it similar to an if statement but different
    because an `if` statement can check for multiple conditions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: So, if `moveRight` is `true`, then the rounded rectangle is placed `150` points
    to the right; otherwise, if `false`, it is left where it is (the `0` value means
    do nothing). The `animation` modifier also picks up on any change because it has
    the `moveRight` variable in there for the `value` parameter. This `value` parameter
    takes the variable that you are using for the animation. The `animation` modifier
    will then interpolate over the values from the start to the finish point and move
    the object smoothly, creating a nice, fluid animation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a way to really see how the `animation` modifier is working. If you comment
    out the `animation` statement in the code and press the button, you will see that
    the object still moves `150` points to the right, but it does so instantly; there
    is no gliding across the screen now; the object just appears at its new location
    `150` points to the right. To create smooth, fluid animations, we need that `animation`
    modifier and its behind-the-scenes interpolating magic. This is part of the reason
    why we use less code in SwiftUI versus coding animation in UIKit; much of the
    heavy lifting is already done for us in the background with SwiftUI.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'This was an example of animating an object from one point to another by changing
    the numerical value for the `x` parameter in the `offset` modifier. Let’s look
    at another property that’s animatable: `HueRotation`.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Hue rotation
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Hue rotation** is a type of color effect that can be applied to views and
    other components. It’s a modifier that allows you to adjust the hue of a color
    by adding or subtracting a fixed angle from its hue value. You can use hue rotation
    to create a range of related colors.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: The modifier has an `angle` parameter that takes a value in radians or degrees.
    That value is based on a circle, which is 360 degrees and represents a wheel of
    all the colors that we can think of.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an Xcode example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When you add the code into Xcode, your previews will look like *Figure 2**.4*:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4: Animating the hue rotation ](img/B18674_02_04.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: Animating the hue rotation'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'I created two objects in this example: a rounded rectangle and an angular gradient
    circle.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: In the rounded rectangle, I used a ternary operator to check whether the `hueRotate`
    variable is `true`. When it becomes `true` via the **Animate** button being pressed,
    the value to the left of the colon inside the ternary operator is used, 180 degrees.
    Then the animation starts going through the color spectrum and stops halfway through
    to display that color.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Notice the use of the `duration` function just after the timing curve. This
    function allows us to set the duration of the animation; do we want it to happen
    fast, or do we want the animation to happen over a longer period? It has one parameter,
    and that is the amount of time we want the animation to take to complete; for
    that, we use an integer value. I set the value to `2`, so it can slow things down
    a little, taking the animation 2 seconds to complete.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the angular gradient example, I’m using a value of `360` degrees.
    When we press the **Animate** button, the code animates through the entire color
    wheel and stops where it started (360 degrees is one revolution of a circle),
    thus displaying the original color.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking a look at the `hueRotate` variable inside the body of the button, we
    have two ways that we can start the animation. The first is by explicitly setting
    `hueRotate` to `true`, like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Or by using the `toggle` method like we’re doing in the code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The difference between these two ways of starting the animation is that firstly,
    the animation starts and then finishes, but it never reverses itself with subsequent
    button presses. If you’d like the animation to start and finish, and on the next
    button press reverse itself, then use the `toggle` method.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种启动动画的方式之间的区别在于，首先，动画开始并结束，但按下后续按钮时它永远不会反转。如果您希望动画开始并结束，并在下一个按钮按下时反转，请使用 `toggle`
    方法。
- en: What’s also very interesting is that we can animate the colors of shapes and
    other objects, but also animate the colors that make up images, as we will see
    in the upcoming projects.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有趣的现象是，我们可以使形状和其他物体的颜色动起来，也可以使构成图像的颜色动起来，正如我们将在即将到来的项目中看到的那样。
- en: You can also use the `hueRotation()` modifier in combination with other modifiers,
    such as `brightness()` or `saturation()`, to create some complex and interesting
    color adjustments.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将 `hueRotation()` 修饰符与其他修饰符（如 `brightness()` 或 `saturation()`）结合使用，以创建一些复杂且有趣的颜色调整。
- en: Let’s continue looking at the different properties to animate and at a very
    common property, `opacity`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看看可以动画化的不同属性，以及一个非常常见的属性，`opacity`。
- en: Opacity
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不透明度
- en: '`opacity` modifier to make views appear and disappear. When we add animation
    to the opacity, the transition from shown to hidden is interpolated over, so it
    smoothly fades in and out.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `opacity` 修饰符使视图出现和消失。当我们给不透明度添加动画时，从显示到隐藏的过渡是插值过的，所以它平滑地淡入淡出。
- en: 'Here''s an example of adding opacity to an animation:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个向动画添加不透明度的例子：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding code will produce the following results, as shown in *Figure
    2**.5*:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生以下结果，如图 *图 2**.5* 所示：
- en: '![Figure 2.5: Animating the opacity ](img/B18674_02_05.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5：动画化不透明度](img/B18674_02_05.jpg)'
- en: 'Figure 2.5: Animating the opacity'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5：动画化不透明度
- en: In our first example, the animation variable is called `appear`, and it’s set
    to `true` as its default value, which shows the circle. When the `false`, and
    the circle animates itself until it completely disappears. And when the button
    is pressed again, the animation gets set to `true`, and the circle becomes visible
    again. Again, using the `animation` modifier initiates the interpolation over
    the start and end values, so the circle doesn’t just appear or disappear instantly;
    there is a gradual change of state until the end of the animation is reached.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个例子中，动画变量名为 `appear`，其默认值设置为 `true`，这显示了圆圈。当设置为 `false` 时，圆圈会自己动画化直到完全消失。再次按下按钮时，动画被设置为
    `true`，圆圈再次变得可见。再次使用 `animation` 修饰符来初始化从起始值到结束值的插值，所以圆圈不会瞬间出现或消失；直到动画结束时，状态会有一个渐进的变化。
- en: The second example of the two circles overlapping at the bottom of the screen
    demonstrates a unique component of opacity in SwiftUI. When we apply the `opacity`
    modifier to a view that already had its opacity transformed, the modifier will
    multiply the overall effect. For example, the yellow and red circles have their
    opacity set at 50%, overlapping each other. The top red circle allows some of
    the bottom yellow circle to show through, thus multiplying the opacity effect
    so that area is a little darker, and at the same time, mingling the two colors,
    creating orange.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕底部两个圆重叠的第二个例子展示了 SwiftUI 中不透明度的一个独特组件。当我们对一个已经改变不透明度的视图应用 `opacity` 修饰符时，该修饰符会乘以整体效果。例如，黄色和红色圆圈的不透明度设置为
    50%，相互重叠。上面的红色圆圈允许一些下面的黄色圆圈透过来，从而乘以不透明度效果，使得该区域稍微暗一些，同时混合两种颜色，形成橙色。
- en: Next, let’s take a look at animating the size or scale of a view, which we can
    do with the `scaleEffect` modifier.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何使用 `scaleEffect` 修饰符来动画化视图的尺寸或缩放。
- en: Scale
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩放
- en: 'Every view has a specific size, and we can change that size by scaling it up
    or down with animation. We can do this with the `scaleEffect` modifier. Here’s
    an example of how we can animate the scale of a view:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 每个视图都有一个特定的尺寸，我们可以通过缩放动画来改变这个尺寸。我们可以使用 `scaleEffect` 修饰符来做这件事。以下是一个我们如何动画化视图缩放的例子：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding code will produce the following results, as shown in *Figure
    2**.6*:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生以下结果，如图 *图 2**.6* 所示：
- en: '![Figure 2.6: Scaling a shape ](img/B18674_02_06.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6：缩放形状](img/B18674_02_06.jpg)'
- en: 'Figure 2.6: Scaling a shape'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6：缩放形状
- en: You should be starting to recognize much of the code that we’re using; for example,
    we use a `VStack` to hold our views, so they get stacked vertically, and we can
    use the button control as a way to start the animation.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该开始认识到我们使用的许多代码；例如，我们使用`VStack`来持有我们的视图，这样它们就可以垂直堆叠，并且我们可以使用按钮控件作为启动动画的方式。
- en: In the example, I’m creating a simple green circle and using the `scaleEffect`
    modifier, passing in our animating variable. When the state changes to `true`,
    the circle scales down to one-tenth of its size, and when `false`, it goes back
    to its original size.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我创建了一个简单的绿色圆圈，并使用`scaleEffect`修改器，传入我们的动画变量。当状态变为`true`时，圆缩小到其大小的十分之一，而当`false`时，它恢复到原始大小。
- en: We’re using the `animation` modifier again with the default timing curve. The
    default curve is an easeInOut curve, which we discussed earlier in the chapter.
    An easeInOut curve will cause the animation to start slowly, then ramp up to its
    top speed, and then finish by easing out slowly again.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用带有默认时间曲线的`animation`修改器。默认曲线是一个easeInOut曲线，我们之前在本章中讨论过。easeInOut曲线将使动画开始缓慢，然后加速到最高速度，最后再缓慢结束。
- en: 'Let’s look at another example of scaling up and down, but instead of scaling
    a shape that we created using the circle initializer, we’re using a system image
    to show you that you can also scale images:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个缩放上下文的例子，但这次我们不是缩放使用圆初始化器创建的形状，而是使用系统图片来展示您也可以缩放图片：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code will produce the following results, as shown in *Figure
    2**.7*:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码将产生以下结果，如图*图2.7*所示：
- en: '![Figure 2.7: Scaling an image ](img/B18674_02_07.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7：缩放图像](img/B18674_02_07.jpg)'
- en: 'Figure 2.7: Scaling an image'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：缩放图像
- en: 'This particular image is a system image from the *SF Symbols* app. If you don’t
    have this app yet, I highly recommend it. You can download it for free at the
    Apple Developer portal. In it, Apple has given us thousands of images we can use
    in our code. And what’s new in the latest release is that now, many of the images
    can be rendered in multicolor: we have to set the rendering mode to `.original`
    so the image gets shown with colors, instead of just black or white.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这张特定的图片是来自*SF Symbols*应用的一个系统图片。如果您还没有这个应用，我强烈推荐它。您可以在Apple开发者门户免费下载它。在应用中，苹果公司给了我们数千张可以在我们的代码中使用的图片。最新版本的新功能是现在，许多图片可以以多色渲染：我们必须将渲染模式设置为`.original`，这样图片就会以彩色显示，而不是只有黑白。
- en: Note
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Not all images can be colored. Look in the SF Symbols app to see which ones
    can be colored.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有图片都可以着色。查看SF Symbols应用以查看哪些可以着色。
- en: 'Finally, in this third example of a scaling animation, we use the `anchor`
    method, which scales the view by the given amount in both the horizontal and vertical
    directions relative to an anchor point:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在这个缩放动画的第三个例子中，我们使用`anchor`方法，通过相对于锚点在水平和垂直方向上按给定量缩放视图：
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code will produce the following results, as shown in *Figure
    2**.8*:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码将产生以下结果，如图*图2.8*所示：
- en: '![Figure 2.8: Scaling from an anchor point ](img/B18674_02_08.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8：从锚点缩放](img/B18674_02_08.jpg)'
- en: 'Figure 2.8: Scaling from an anchor point'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8：从锚点缩放
- en: 'All views have an anchor point, which is usually in the middle of the view.
    But we can change that anchor point, and have the animation scale the object based
    on where that anchor point is. In the code, I used the `.bottomTrailing` option
    as the anchor point, so when we press the button, the heart image scales down
    and toward the trailing edge (the right side of the screen), rather than scaling
    from the center of the object. However, SwiftUI also gives us the following anchor
    points to choose from:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 所有视图都有一个锚点，通常位于视图的中间。但我们可以改变这个锚点，让动画根据锚点位置缩放对象。在代码中，我使用了`.bottomTrailing`选项作为锚点，所以当我们按下按钮时，心形图片会缩小并向着尾部边缘（屏幕的右侧）缩放，而不是从对象的中心缩放。然而，SwiftUI也给了我们以下可选择的锚点：
- en: '`bottomTrailing`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bottomTrailing`'
- en: '`trailing`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trailing`'
- en: '`bottom`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bottom`'
- en: '`center`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`center`'
- en: '`top`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`top`'
- en: '`bottomLeading`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bottomLeading`'
- en: '`topLeading`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`topLeading`'
- en: '`topTrailing`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`topTrailing`'
- en: '`leading`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`leading`'
- en: 'In this final section, we will look at three more properties that can be animated:
    `stroke`, `trim`, and `cornerRadius`.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后，我们将探讨三个可以动画化的属性：`stroke`、`trim`和`cornerRadius`。
- en: Stroke, trim, and corner radius
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描边、修剪和圆角半径
- en: 'Let’s now look at three more properties we can animate: the stroke of a line,
    the trim of a circle, and the corner radius of a rectangle.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看三个可以动画化的属性：线条的描边、圆的修剪和矩形的圆角半径。
- en: 'The **stroke** of a shape is the outline or border of the shape. It has a particular
    color and width and can have various attributes such as line cap style or line
    join style. Let’s animate the stroke of a rectangle, so it gets thicker or thinner
    with each button press:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 形状的**笔触**是指形状的轮廓或边界。它具有特定的颜色和宽度，并且可以具有各种属性，例如线帽样式或线连接样式。让我们动画化矩形的笔触，使其在每次按钮按下时变粗或变细：
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Either a thick or thin stroke line is created around the rectangle, as shown
    in *Figure 2**.9*:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在矩形周围创建一条粗或细的笔触线，如图 *图 2.9* 所示：
- en: '![Figure 2.9: Animating the stroke ](img/B18674_02_09.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.9：动画化笔触](img/B18674_02_09.jpg)'
- en: 'Figure 2.9: Animating the stroke'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9：动画化笔触
- en: The first thing we do is define our animation variable, setting its initial
    value to `false`. Looking inside the `stroke` modifier, I pass the `animateStroke`
    variable as an argument to the line `width` parameter, so when it does become
    `true`, it changes `stroke` to `25` points (otherwise, it will be `1` point).
    Again, we also use the default timing curve inside the `animation` modifier, and
    when we run this, `stroke` is smoothly modified from a thickness of `25` points,
    then back to `1` point when the button is pressed again.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义我们的动画变量，将其初始值设置为`false`。在`stroke`修饰符内部，我将`animateStroke`变量作为参数传递给`line
    width`参数，因此当它变为`true`时，它将`stroke`更改为`25`点（否则，它将是`1`点）。同样，我们在`animation`修饰符内部也使用了默认的时间曲线，当我们运行这个时，`stroke`会平滑地从`25`点的厚度修改到按下按钮再次时回到`1`点。
- en: 'Here is another example where we are using the `trim` modifier this time:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个例子，这次我们使用了`trim`修饰符：
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `trim` modifier takes two parameters: `from` (meaning what part of the
    circle we want to start trimming from) and `to` (meaning where we want to end
    the trimming). The `from` parameter is set to `0`, which means there will be a
    complete circle on the screen as we are not trimming yet. The code produces the
    following results, a circle that has its line trimmed off and restored when the
    button is pressed, as shown in *Figure 2**.10*:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`trim`修饰符接受两个参数：`from`（表示我们想要从圆的哪一部分开始剪裁）和`to`（表示我们想要在哪里结束剪裁）。`from`参数设置为`0`，这意味着屏幕上将有一个完整的圆，因为我们还没有开始剪裁。代码产生以下结果，一个在按钮按下时剪掉并恢复线条的圆，如图
    *图 2.10* 所示：'
- en: '![Figure 2.10: Animating the trim ](img/B18674_02_10.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.10：动画化剪裁](img/B18674_02_10.jpg)'
- en: 'Figure 2.10: Animating the trim'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10：动画化剪裁
- en: Also, notice we use two `@State` variables to work with the `trim` modifier,
    one called `animateTrim`, to trigger the animation, and one called `circleTrim`,
    which is a numerical value of the `CGFloat` type. This variable will hold the
    amount of circle we want to trim off. Initially, it gets set to `1`, so the whole
    circle is visible.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意我们使用了两个`@State`变量来与`trim`修饰符一起工作，一个称为`animateTrim`，用于触发动画，另一个称为`circleTrim`，它是一个`CGFloat`类型的数值。这个变量将保存我们想要剪掉的圆的量。最初，它被设置为`1`，因此整个圆是可见的。
- en: Note
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A `CGFloat` type is a floating-point number. **CG** stands for **Core Graphics**,
    which is an older coding paradigm was used in Apple’s graphic framework, but is
    still used in SwiftUI.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`CGFloat`类型是一个浮点数。**CG**代表**Core Graphics**，它是一个较老的编码范式，曾用于苹果的图形框架，但现在仍在SwiftUI中使用。'
- en: 'Looking inside the button code, then within the `circleTrim` variable, we’re
    storing one of two values using the ternary operator: either `.25`, or `1`. This
    means that when `animateTrim` toggles to `true`, the code trims off 75% of the
    circle and leaves 25%; when `animateTrim` toggles to `false`, the value of `1`
    is used, which represents 100% of the circle. So, the values in the ternary operator
    represent how much of the circle to keep.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在按钮代码内部查看，然后在`circleTrim`变量中，我们使用三元运算符存储两个值之一：`.25`或`1`。这意味着当`animateTrim`切换到`true`时，代码会剪掉75%的圆并留下25%；当`animateTrim`切换到`false`时，使用的是`1`的值，它代表100%的圆。因此，三元运算符中的值表示要保留圆的多少部分。
- en: If we run the code, we see we have a nice trimming animation of this circle.
    The line of code called `CGLineCap.round` refers to the shape of the line that’s
    drawn at the end points, and it can be `round`, `square`, or `butt` `line cap`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行代码，我们会看到我们有一个漂亮的圆剪裁动画。名为`CGLineCap.round`的代码行指的是绘制在端点的线的形状，它可以是指`round`、`square`或`butt`线帽。
- en: And just to have a little fun here, if we go into the `trim` modifier and change
    the `from` parameter to `0.5` instead of `0`, we now start the drawing halfway
    through the circle. Run the code, and it looks like we’re animating or painting
    a smile and then removing the smile when we press the button again.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在这里有点乐趣，如果我们进入 `trim` 修饰符并将 `from` 参数更改为 `0.5` 而不是 `0`，我们现在开始从圆的一半开始绘制。运行代码，看起来我们正在动画或绘制一个微笑，然后当我们再次按下按钮时移除微笑。
- en: Note
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If this code seems a bit confusing, where you see the `trim` modifier being
    set for the circle, and the `circleTrim` variable being set in the button body,
    then think of the `trim` modifier as the “where” part of the trimming. This means
    where do we want to start and end the trimming? Then, think of the ternary operator
    inside the button as the “how much,” meaning how much do we want to trim off the
    circle and how much of it do we want to keep?
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这段代码看起来有点复杂，你看到为圆形设置了 `trim` 修饰符，并在按钮体中设置了 `circleTrim` 变量，那么将 `trim` 修饰符视为裁剪的“哪里”部分。这意味着我们想要从哪里开始和结束裁剪？然后，将按钮内部的三元运算符视为“多少”，意味着我们想要裁剪掉圆的多少，以及我们想要保留多少？
- en: Let’s now move on to the final example. In this example, we will take a look
    at how you can animate the corner radius of a rectangle. The corner radius refers
    to how sharp you want to make the corners of a rectangle; you can go all the way
    from a 90° angle up to a much higher value to create a smooth, rounded corner.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们继续到最后一个示例。在这个示例中，我们将看看如何动画化矩形的角落半径。角落半径指的是你想要使矩形角落多尖锐；你可以从 90° 角一直调整到一个更高的值，以创建一个平滑、圆滑的角落。
- en: 'All the code is similar to what we’ve used so far except for the use of the
    `cornerRadius` modifier. The following is an example of the code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 所有代码与我们迄今为止使用的代码类似，只是使用了 `cornerRadius` 修饰符。以下是一个代码示例：
- en: '[PRE15]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This code produces the following results: a rectangle with its corner radius
    changed from a 90° angle all the way up to create a circle. So, we’re changing
    a rectangle into a circle and back again when the button is pressed, as shown
    in *Figure 2**.11*:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码产生了以下结果：一个角落半径从 90° 角一直调整到创建一个圆的矩形。所以，当我们按下按钮时，我们正在将矩形变成圆形，然后再变回矩形，如图 *图
    2**.11* 所示：
- en: '![Figure 2.11: Animating the corner radius ](img/B18674_02_11.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.11：动画角落半径](img/B18674_02_11.jpg)'
- en: 'Figure 2.11: Animating the corner radius'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11：动画角落半径
- en: 'In the code, the line that’s doing most of the work is this one:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，做大部分工作的这一行是：
- en: '[PRE16]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `animateCornerRadius` variable gets passed into the `cornerRadius` modifier,
    which then gets checked for the `true` or `false` values; if it is `false`, it
    gets a value of `75` placed into it, which will make the size of this rectangle
    animate into a perfectly round circle. And when toggled back to `true`, the circle
    animates into a rectangle with 90-degree corners by having its corner radius changed
    to `0`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`animateCornerRadius` 变量被传递到 `cornerRadius` 修饰符中，然后检查其 `true` 或 `false` 值；如果它是
    `false`，则将其值设置为 `75`，这将使这个矩形的尺寸动画变为一个完美的圆形。当切换回 `true` 时，通过将其角落半径更改为 `0`，圆形动画变为一个具有
    90 度角落的矩形。'
- en: Note that the reason why the code creates a perfect circle is that we set the
    frame of the rectangle’s width and height to `150` points, thus creating a square,
    and anytime you set a corner radius to half the width or height of a square, you
    will always get a perfect circle.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，代码创建一个完美的圆的原因是我们将矩形的宽度和高度框架设置为 `150` 点，从而创建了一个正方形，并且每次当你将角落半径设置为正方形宽度和高度的一半时，你总是会得到一个完美的圆。
- en: SwiftUI gives us more ways to animate objects in addition to these, and we will
    explore them in the coming chapters when we start building projects.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些之外，SwiftUI 还提供了更多动画对象的方法，我们将在开始构建项目时在接下来的章节中探讨它们。
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we looked at how animations work, the two types of animation
    in SwiftUI, implicit and explicit, and many of the properties that can be animated.
    These include hue rotation, opacity, a view’s position on the screen and size,
    stroke, trim, corner radius, and timing curves.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了动画的工作原理，SwiftUI 中的两种动画类型：隐式和显式，以及许多可以动画化的属性。这些包括色调旋转、不透明度、视图在屏幕上的位置和大小、描边、裁剪、角落半径和计时曲线。
- en: This was an important step needed to guide you along on your SwiftUI animations
    adventure. Remember, if a property is a numerical value, it almost always can
    have an animation applied to it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一步重要的步骤，旨在引导你在 SwiftUI 动画冒险中前进。记住，如果一个属性是数值，它几乎总是可以应用动画。
- en: In the next chapter, we will start working on some projects. For our first project,
    we will create an app similar to Apple’s breathing app (very popular on Apple
    watches) and learn how to combine more than one animation in a view.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始着手一些项目。对于我们的第一个项目，我们将创建一个类似于苹果公司呼吸应用的APP（在苹果手表上非常受欢迎）并学习如何在视图中结合多个动画。
