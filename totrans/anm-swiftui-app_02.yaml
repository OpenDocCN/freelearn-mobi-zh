- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Understanding Animation with SwiftUI
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解使用SwiftUI的动画
- en: In the first chapter, we covered many SwiftUI fundamentals we will see when
    we start building projects. In this chapter, we will look at how animations work,
    including timing curves and animatable properties, which will lay the foundation
    for the projects we build.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们介绍了在开始构建项目时我们将看到的许多SwiftUI基础知识。在本章中，我们将探讨动画的工作原理，包括时间曲线和可动画属性，这将为我们将要构建的项目奠定基础。
- en: 'The following are the key topics we will explore:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将要探讨的关键主题：
- en: What is animation?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是动画？
- en: Understanding timing curves
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解时间曲线
- en: Understanding animation types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解动画类型
- en: Triggering animations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发动画
- en: Exploring animatable properties
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索可动画属性
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the code for this chapter on GitHub in the `Chapter 2` folder:
    [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub的`Chapter 2`文件夹中找到本章的代码：[https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications)。
- en: What is animation?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是动画？
- en: Let’s consider the book’s definition of animation. **Animation** is a series
    of static images displayed in rapid succession to create the illusion of motion.
    The images, or frames, are usually displayed at a rate of 24 or 30 frames per
    second from the beginning to the end, which is fast enough to create the illusion
    of continuous motion. These can be created using a variety of techniques, including
    hand-drawn, computer-generated, and stop-motion animations.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑这本书对动画的定义。**动画**是一系列静态图像以快速连续的方式显示，以产生运动错觉。这些图像，或帧，通常以每秒24或30帧的速率从开始到结束显示，这足以产生连续运动的错觉。这些可以使用各种技术创建，包括手绘、计算机生成和定格动画。
- en: Looking at this definition, we can see that there is a start point and an end
    point to animation, and the images in between are all slightly different; when
    played, our eyes cannot pick out the individual images, which means we perceive
    movement or animation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个定义来看，我们可以看到动画有一个起点和终点，中间的图像都是略有不同的；当播放时，我们的眼睛无法分辨出单个图像，这意味着我们感知到运动或动画。
- en: In SwiftUI, we have to define the start point (where the animation begins) and
    the end point (where the animation ends). However, when we code, we don’t actually
    put a bunch of still images between both end points (though we can); what we usually
    do is use a single image and then animate the properties of that image, such as
    its location on the screen, its opacity, or its color.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在SwiftUI中，我们必须定义起点（动画开始的地方）和终点（动画结束的地方）。然而，当我们编写代码时，我们实际上并没有在两个终点之间放置一大堆静态图像（尽管我们可以这样做）；我们通常使用单个图像，然后动画化该图像的属性，例如其在屏幕上的位置、其不透明度或其颜色。
- en: In addition to images, we can also animate RGB colors by changing their hue
    or the corner radius of shapes, and if we draw a shape, we can animate the individual
    lines (paths) or the strokes around it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 除了图像之外，我们还可以通过改变它们的色调或形状的圆角来动画化RGB颜色，如果我们绘制一个形状，我们可以动画化其单个线条（路径）或周围的描边。
- en: 'It works like this: if we want a rectangle to move from the bottom left to
    the top right of the iPhone or iPad screen, we declare it in code (that declarative
    syntax thing again) by using the `animation` modifier. Then SwiftUI does the magic
    for us, moving the object, or in SwiftUI speak, “transitioning” the object from
    a start point to an end point, filling in all the gaps along the way with whatever
    values we are working with (integers, colors, opacity, etc.). The process of going
    through all the values to create a smooth fluid motion is called **interpolation**.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作原理是这样的：如果我们想让一个矩形从iPhone或iPad屏幕的左下角移动到右上角，我们可以在代码中（又是那种声明式语法）通过使用`animation`修饰符来声明它。然后SwiftUI为我们施展魔法，移动对象，或者用SwiftUI的话说，“过渡”对象从起点到终点，用我们在路上使用的任何值（整数、颜色、不透明度等）填充所有空白。通过遍历所有值来创建平滑流畅运动的过程被称为**插值**。
- en: SwiftUI fills in those gaps for us really well, but it cannot animate every
    property of every view. Only properties considered “animatable” can be animated;
    things such as a view’s color, opacity, rotation, size, position, corner radius,
    and strokes. Nearly all properties that have a numerical value are animatable.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI为我们很好地填补了这些空白，但它不能为每个视图的每个属性进行动画。只有被认为是“可动画”的属性才能进行动画；例如，视图的颜色、不透明度、旋转、大小、位置、圆角和描边。几乎所有具有数值的属性都是可动画的。
- en: SwiftUI includes basic animations with default or custom easing or timing curves
    (a timing curve refers to the speed at the start and end of the animation), as
    well as spring animations. Spring animations have a bouncy effect to them and
    can be adjusted from a slight bounce to a very pronounced bounce, similar to a
    rubber ball bouncing on the floor.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: You can also change many customization options, such as the speed of an animation,
    add a “wait” time before the animation starts, and have an animation repeat itself.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue by diving deeper into animation timing curves, seeing what they
    look like and how they affect an animation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Understanding timing curves
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animations have what are called curves. A **curve**, or more specifically, a
    **timing curve**, refers to the speed at which the animation starts and how it
    should end.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'SwiftUI provides several timing curves to choose from that we can use inside
    the `animation` modifier. It’s called a timing curve because if you were to plot
    each point of the animation’s movement from start to finish on a graph, and draw
    a line by connecting those points, most of them would create a curved line, as
    in this illustration:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1: The ease timing curves ](img/B18674_02_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: The ease timing curves'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'This graph shows three animation timing curves: `easeInOut` timing curve, the
    animation starts slow, speeds up, and then finally slows down before coming to
    a complete stop.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a linear timing curve. An animation using this curve will have
    the same rate of speed at its beginning as it does at its end. If you were to
    plot it on a graph, it would be a straight line, like so:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2: The linear timing curve ](img/B18674_02_02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: The linear timing curve'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Timing curves are not complicated – we get to choose the ones we want based
    on how we want the animation to look and perform. If you don’t specify a timing
    curve, you will get the default curve, the `easeInOut` one. We will use some of
    these SwiftUI-provided timing curves in our projects.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, I want to explain the two distinct types of animation
    in SWiftUI: implicit and explicit.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Understanding animation types
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two types of animations in SwiftUI: implicit and explicit. Let’s
    look at what these animation types do and the difference between the two.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'An `animation` modifier. Here is an example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, we use a tap gesture to scale up the size of a circle; when
    tapped, the circle will grow by half its size. The `.animation` modifier uses
    the default animation style, which will animate the circle using an easeInOut
    timing curve by default.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use other animation styles. For example, here, I added a `spring`
    style instead of the default style:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This style will animate the circle and add a springy effect to it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: So implicit animations are a convenient way to add basic animations to your
    SwiftUI app without having to write any explicit animation code. The animations
    are applied using the `animation` modifier.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，隐式动画是向您的SwiftUI应用程序添加基本动画的一种方便方式，而无需编写任何显式动画代码。动画是通过`animation`修饰符应用的。
- en: Sometimes though, you may want more from your animation, and implicit animations
    may not give you the degree of control that you are looking for. In this case,
    you can use explicit animations instead.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能希望从动画中获得更多，而隐式动画可能无法提供您所需的控制程度。在这种情况下，您可以使用显式动画。
- en: 'An `withAnimation` function. Here’s an example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`withAnimation`函数。以下是一个示例：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, tapping the button will animate the scale of the text using
    a spring animation. The duration of the animation will be determined by the system’s
    default animation settings, but the curve of the animation will be customized
    using the `interpolatingSpring` function.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，点击按钮将使用弹簧动画来动画化文本的缩放。动画的持续时间将由系统的默认动画设置确定，但动画的曲线将通过`interpolatingSpring`函数进行自定义。
- en: 'Additionally, you can customize the duration of the animation by specifying
    a `duration` parameter in the `interpolatingSpring` function. The following is
    an example of this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以通过在`interpolatingSpring`函数中指定`duration`参数来自定义动画的持续时间。以下是一个示例：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will cause the animation to last for `2.5` seconds.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使动画持续`2.5`秒。
- en: So, the difference when using explicit animations versus implicit animations
    is that they can give you more control over the details of the animation, or when
    you want to animate multiple properties simultaneously; you can put as much code
    into the `withAnimation` block as needed. However, they can be more work to set
    up than implicit animations.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用显式动画与隐式动画的区别在于，它们可以为您提供更多控制动画细节的能力，或者当您想要同时动画化多个属性时；您可以将尽可能多的代码放入`withAnimation`块中。然而，它们可能比隐式动画更难设置。
- en: 'You can also have the animation repeat itself a pre-set number of times or
    indefinitely. Here’s an example of repeating the previous animation forever and
    auto-reversing it:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以让动画重复播放预设的次数或无限期重复。以下是一个将之前的动画永久重复并自动反转的示例：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the previous example, I altered the code in the `withAnimation` function
    to include the `repeatForever` option and set the `autoreverses` parameter to
    `true`. When you run the code, the text will scale up with a springy effect, and
    when it’s done bouncing (about 3 seconds or so), the animation will start over,
    repeating endlessly or until the app is stopped.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我修改了`withAnimation`函数中的代码，以包含`repeatForever`选项并将`autoreverses`参数设置为`true`。当您运行代码时，文本将以弹簧效果放大，当它完成弹跳（大约3秒左右）后，动画将重新开始，无限期重复或直到应用程序停止。
- en: Those are the two types of animations; next is a list of ways to trigger animations.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就是两种类型的动画；接下来是一个触发动画的方法列表。
- en: Triggering animations
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触发动画
- en: 'So, how do we trigger animations? There are several ways to do so in SwiftUI,
    including using the following SwiftUI modifiers, methods, and functions:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何触发动画呢？在SwiftUI中，有几种方法可以做到这一点，包括使用以下SwiftUI修饰符、方法和函数：
- en: 'The `.animation()` modifier: This modifier allows you to specify the type of
    animation used when a view appears or disappears or when its state changes.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.animation()`修饰符：此修饰符允许您指定视图出现或消失或其状态变化时使用的动画类型。'
- en: 'The `withAnimation()` function: This function allows you to wrap a block of
    code that changes the state of a view, and it will automatically animate the changes.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withAnimation()`函数：此函数允许您将一个代码块包裹起来，该代码块会改变视图的状态，并且它会自动动画化这些更改。'
- en: 'A **gesture**: This is a way to interact with a view by performing actions
    such as tapping, dragging, or pinching. You can use a gesture to trigger an animation
    when a certain action is performed on a view.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**手势**：这是一种通过执行诸如点击、拖动或捏合等操作与视图交互的方式。您可以使用手势在视图上执行特定操作时触发动画。
- en: 'A **timer**: This allows you to specify an animation to be performed over a
    certain period of time. You can use a timer to animate the changes to a view’s
    state over a specific duration.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**计时器**：这允许您指定在一定时间内执行动画。您可以使用计时器在特定持续时间内动画化视图状态的更改。
- en: 'The `onAppear()` and `onDisappear()` modifiers: These modifiers allow you to
    specify code to be executed when a view appears or disappears. These modifiers
    can trigger an animation when a view appears or disappears.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Button and other control views: A button, slider, picker, or other control
    type view in SwiftUI can be a trigger for an animation.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other ways to trigger animations, but these are the main ones that
    we will cover here. Whatever you choose will depend on the specific needs of your
    app and the behavior you want to produce. We will explore these different triggers
    when we start building our projects in the coming chapters.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue by looking at various properties that can be animated in SwiftUI.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Exploring animatable properties
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will explore some of the animatable properties. Here is
    a list of the ones that we will look at:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Offset
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hue rotation
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opacity
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scale
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stroke
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trim
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Corner radius
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take a look at them in more detail.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: The offset property
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first property we will look at that is animatable is the `offset` modifier
    that has been placed on a rectangle shape:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After you put that code into your `ContentView` file, your preview will look
    like *Figure 2**.3*. When you press the **Animate** button, the blue rectangle
    will move to the right, and when you press it again, it will return to its original
    starting position.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3: Animating the offset ](img/B18674_02_03.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: Animating the offset'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: This is how the code works. When the `moveRight` variable has its value toggled
    or changed to `true`, and the `offset` modifier has a ternary operator in there
    for its `x` parameter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: A ternary operator is an operator that accepts a Boolean variable and checks
    to see whether it’s `true` or `false`. If the variable is `true`, the value to
    the left of the colon is used, but if the variable is `false`, the value to the
    right of the colon is used. This makes it similar to an if statement but different
    because an `if` statement can check for multiple conditions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: So, if `moveRight` is `true`, then the rounded rectangle is placed `150` points
    to the right; otherwise, if `false`, it is left where it is (the `0` value means
    do nothing). The `animation` modifier also picks up on any change because it has
    the `moveRight` variable in there for the `value` parameter. This `value` parameter
    takes the variable that you are using for the animation. The `animation` modifier
    will then interpolate over the values from the start to the finish point and move
    the object smoothly, creating a nice, fluid animation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a way to really see how the `animation` modifier is working. If you comment
    out the `animation` statement in the code and press the button, you will see that
    the object still moves `150` points to the right, but it does so instantly; there
    is no gliding across the screen now; the object just appears at its new location
    `150` points to the right. To create smooth, fluid animations, we need that `animation`
    modifier and its behind-the-scenes interpolating magic. This is part of the reason
    why we use less code in SwiftUI versus coding animation in UIKit; much of the
    heavy lifting is already done for us in the background with SwiftUI.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'This was an example of animating an object from one point to another by changing
    the numerical value for the `x` parameter in the `offset` modifier. Let’s look
    at another property that’s animatable: `HueRotation`.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Hue rotation
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Hue rotation** is a type of color effect that can be applied to views and
    other components. It’s a modifier that allows you to adjust the hue of a color
    by adding or subtracting a fixed angle from its hue value. You can use hue rotation
    to create a range of related colors.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: The modifier has an `angle` parameter that takes a value in radians or degrees.
    That value is based on a circle, which is 360 degrees and represents a wheel of
    all the colors that we can think of.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an Xcode example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When you add the code into Xcode, your previews will look like *Figure 2**.4*:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4: Animating the hue rotation ](img/B18674_02_04.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: Animating the hue rotation'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'I created two objects in this example: a rounded rectangle and an angular gradient
    circle.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: In the rounded rectangle, I used a ternary operator to check whether the `hueRotate`
    variable is `true`. When it becomes `true` via the **Animate** button being pressed,
    the value to the left of the colon inside the ternary operator is used, 180 degrees.
    Then the animation starts going through the color spectrum and stops halfway through
    to display that color.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Notice the use of the `duration` function just after the timing curve. This
    function allows us to set the duration of the animation; do we want it to happen
    fast, or do we want the animation to happen over a longer period? It has one parameter,
    and that is the amount of time we want the animation to take to complete; for
    that, we use an integer value. I set the value to `2`, so it can slow things down
    a little, taking the animation 2 seconds to complete.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the angular gradient example, I’m using a value of `360` degrees.
    When we press the **Animate** button, the code animates through the entire color
    wheel and stops where it started (360 degrees is one revolution of a circle),
    thus displaying the original color.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking a look at the `hueRotate` variable inside the body of the button, we
    have two ways that we can start the animation. The first is by explicitly setting
    `hueRotate` to `true`, like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Or by using the `toggle` method like we’re doing in the code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The difference between these two ways of starting the animation is that firstly,
    the animation starts and then finishes, but it never reverses itself with subsequent
    button presses. If you’d like the animation to start and finish, and on the next
    button press reverse itself, then use the `toggle` method.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: What’s also very interesting is that we can animate the colors of shapes and
    other objects, but also animate the colors that make up images, as we will see
    in the upcoming projects.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the `hueRotation()` modifier in combination with other modifiers,
    such as `brightness()` or `saturation()`, to create some complex and interesting
    color adjustments.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue looking at the different properties to animate and at a very
    common property, `opacity`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Opacity
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`opacity` modifier to make views appear and disappear. When we add animation
    to the opacity, the transition from shown to hidden is interpolated over, so it
    smoothly fades in and out.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of adding opacity to an animation:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding code will produce the following results, as shown in *Figure
    2**.5*:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5: Animating the opacity ](img/B18674_02_05.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: Animating the opacity'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: In our first example, the animation variable is called `appear`, and it’s set
    to `true` as its default value, which shows the circle. When the `false`, and
    the circle animates itself until it completely disappears. And when the button
    is pressed again, the animation gets set to `true`, and the circle becomes visible
    again. Again, using the `animation` modifier initiates the interpolation over
    the start and end values, so the circle doesn’t just appear or disappear instantly;
    there is a gradual change of state until the end of the animation is reached.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: The second example of the two circles overlapping at the bottom of the screen
    demonstrates a unique component of opacity in SwiftUI. When we apply the `opacity`
    modifier to a view that already had its opacity transformed, the modifier will
    multiply the overall effect. For example, the yellow and red circles have their
    opacity set at 50%, overlapping each other. The top red circle allows some of
    the bottom yellow circle to show through, thus multiplying the opacity effect
    so that area is a little darker, and at the same time, mingling the two colors,
    creating orange.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s take a look at animating the size or scale of a view, which we can
    do with the `scaleEffect` modifier.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Scale
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every view has a specific size, and we can change that size by scaling it up
    or down with animation. We can do this with the `scaleEffect` modifier. Here’s
    an example of how we can animate the scale of a view:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding code will produce the following results, as shown in *Figure
    2**.6*:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6: Scaling a shape ](img/B18674_02_06.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: Scaling a shape'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: You should be starting to recognize much of the code that we’re using; for example,
    we use a `VStack` to hold our views, so they get stacked vertically, and we can
    use the button control as a way to start the animation.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: In the example, I’m creating a simple green circle and using the `scaleEffect`
    modifier, passing in our animating variable. When the state changes to `true`,
    the circle scales down to one-tenth of its size, and when `false`, it goes back
    to its original size.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: We’re using the `animation` modifier again with the default timing curve. The
    default curve is an easeInOut curve, which we discussed earlier in the chapter.
    An easeInOut curve will cause the animation to start slowly, then ramp up to its
    top speed, and then finish by easing out slowly again.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at another example of scaling up and down, but instead of scaling
    a shape that we created using the circle initializer, we’re using a system image
    to show you that you can also scale images:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code will produce the following results, as shown in *Figure
    2**.7*:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7: Scaling an image ](img/B18674_02_07.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: Scaling an image'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'This particular image is a system image from the *SF Symbols* app. If you don’t
    have this app yet, I highly recommend it. You can download it for free at the
    Apple Developer portal. In it, Apple has given us thousands of images we can use
    in our code. And what’s new in the latest release is that now, many of the images
    can be rendered in multicolor: we have to set the rendering mode to `.original`
    so the image gets shown with colors, instead of just black or white.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Not all images can be colored. Look in the SF Symbols app to see which ones
    can be colored.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in this third example of a scaling animation, we use the `anchor`
    method, which scales the view by the given amount in both the horizontal and vertical
    directions relative to an anchor point:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code will produce the following results, as shown in *Figure
    2**.8*:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8: Scaling from an anchor point ](img/B18674_02_08.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: Scaling from an anchor point'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'All views have an anchor point, which is usually in the middle of the view.
    But we can change that anchor point, and have the animation scale the object based
    on where that anchor point is. In the code, I used the `.bottomTrailing` option
    as the anchor point, so when we press the button, the heart image scales down
    and toward the trailing edge (the right side of the screen), rather than scaling
    from the center of the object. However, SwiftUI also gives us the following anchor
    points to choose from:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '`bottomTrailing`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trailing`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bottom`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`center`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`top`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bottomLeading`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`topLeading`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`topTrailing`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`leading`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this final section, we will look at three more properties that can be animated:
    `stroke`, `trim`, and `cornerRadius`.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Stroke, trim, and corner radius
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s now look at three more properties we can animate: the stroke of a line,
    the trim of a circle, and the corner radius of a rectangle.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'The **stroke** of a shape is the outline or border of the shape. It has a particular
    color and width and can have various attributes such as line cap style or line
    join style. Let’s animate the stroke of a rectangle, so it gets thicker or thinner
    with each button press:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Either a thick or thin stroke line is created around the rectangle, as shown
    in *Figure 2**.9*:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9: Animating the stroke ](img/B18674_02_09.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9: Animating the stroke'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we do is define our animation variable, setting its initial
    value to `false`. Looking inside the `stroke` modifier, I pass the `animateStroke`
    variable as an argument to the line `width` parameter, so when it does become
    `true`, it changes `stroke` to `25` points (otherwise, it will be `1` point).
    Again, we also use the default timing curve inside the `animation` modifier, and
    when we run this, `stroke` is smoothly modified from a thickness of `25` points,
    then back to `1` point when the button is pressed again.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example where we are using the `trim` modifier this time:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `trim` modifier takes two parameters: `from` (meaning what part of the
    circle we want to start trimming from) and `to` (meaning where we want to end
    the trimming). The `from` parameter is set to `0`, which means there will be a
    complete circle on the screen as we are not trimming yet. The code produces the
    following results, a circle that has its line trimmed off and restored when the
    button is pressed, as shown in *Figure 2**.10*:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10: Animating the trim ](img/B18674_02_10.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.10: Animating the trim'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Also, notice we use two `@State` variables to work with the `trim` modifier,
    one called `animateTrim`, to trigger the animation, and one called `circleTrim`,
    which is a numerical value of the `CGFloat` type. This variable will hold the
    amount of circle we want to trim off. Initially, it gets set to `1`, so the whole
    circle is visible.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: A `CGFloat` type is a floating-point number. **CG** stands for **Core Graphics**,
    which is an older coding paradigm was used in Apple’s graphic framework, but is
    still used in SwiftUI.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking inside the button code, then within the `circleTrim` variable, we’re
    storing one of two values using the ternary operator: either `.25`, or `1`. This
    means that when `animateTrim` toggles to `true`, the code trims off 75% of the
    circle and leaves 25%; when `animateTrim` toggles to `false`, the value of `1`
    is used, which represents 100% of the circle. So, the values in the ternary operator
    represent how much of the circle to keep.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: If we run the code, we see we have a nice trimming animation of this circle.
    The line of code called `CGLineCap.round` refers to the shape of the line that’s
    drawn at the end points, and it can be `round`, `square`, or `butt` `line cap`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: And just to have a little fun here, if we go into the `trim` modifier and change
    the `from` parameter to `0.5` instead of `0`, we now start the drawing halfway
    through the circle. Run the code, and it looks like we’re animating or painting
    a smile and then removing the smile when we press the button again.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: If this code seems a bit confusing, where you see the `trim` modifier being
    set for the circle, and the `circleTrim` variable being set in the button body,
    then think of the `trim` modifier as the “where” part of the trimming. This means
    where do we want to start and end the trimming? Then, think of the ternary operator
    inside the button as the “how much,” meaning how much do we want to trim off the
    circle and how much of it do we want to keep?
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now move on to the final example. In this example, we will take a look
    at how you can animate the corner radius of a rectangle. The corner radius refers
    to how sharp you want to make the corners of a rectangle; you can go all the way
    from a 90° angle up to a much higher value to create a smooth, rounded corner.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'All the code is similar to what we’ve used so far except for the use of the
    `cornerRadius` modifier. The following is an example of the code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This code produces the following results: a rectangle with its corner radius
    changed from a 90° angle all the way up to create a circle. So, we’re changing
    a rectangle into a circle and back again when the button is pressed, as shown
    in *Figure 2**.11*:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11: Animating the corner radius ](img/B18674_02_11.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.11: Animating the corner radius'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code, the line that’s doing most of the work is this one:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `animateCornerRadius` variable gets passed into the `cornerRadius` modifier,
    which then gets checked for the `true` or `false` values; if it is `false`, it
    gets a value of `75` placed into it, which will make the size of this rectangle
    animate into a perfectly round circle. And when toggled back to `true`, the circle
    animates into a rectangle with 90-degree corners by having its corner radius changed
    to `0`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Note that the reason why the code creates a perfect circle is that we set the
    frame of the rectangle’s width and height to `150` points, thus creating a square,
    and anytime you set a corner radius to half the width or height of a square, you
    will always get a perfect circle.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: SwiftUI gives us more ways to animate objects in addition to these, and we will
    explore them in the coming chapters when we start building projects.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how animations work, the two types of animation
    in SwiftUI, implicit and explicit, and many of the properties that can be animated.
    These include hue rotation, opacity, a view’s position on the screen and size,
    stroke, trim, corner radius, and timing curves.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: This was an important step needed to guide you along on your SwiftUI animations
    adventure. Remember, if a property is a numerical value, it almost always can
    have an animation applied to it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start working on some projects. For our first project,
    we will create an app similar to Apple’s breathing app (very popular on Apple
    watches) and learn how to combine more than one animation in a view.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始着手一些项目。对于我们的第一个项目，我们将创建一个类似于苹果公司呼吸应用的APP（在苹果手表上非常受欢迎）并学习如何在视图中结合多个动画。
