- en: Chapter 2. SpriteKit
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：SpriteKit
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Learning the basics of SpriteKit – The FlyingSpaceship tutorial
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 SpriteKit 的基础知识 – 飞船教程
- en: Understanding scenes, nodes, and sprites
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解场景、节点和精灵
- en: Anatomy of game projects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏项目的解剖学
- en: Applying actions on Sprites
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在精灵上应用动作
- en: Adding infinite scrolling
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加无限滚动
- en: Moving characters
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动角色
- en: This chapter explains SpriteKit in detail. We'll start from a discussion on
    the basics of SpriteKit, and then we will be learning about the anatomy of the
    game project. Moving ahead, we will learn about scenes, sprites, and nodes. This
    will provide us a deeper understanding about the basic structure model of the
    SpriteKit. Then we will be exploring the depth of SpriteKit by adding some actions
    to the sprites. Moving ahead, we will be adding infinite scrolling to the game
    that will be created during the chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章详细解释了 SpriteKit。我们将从对 SpriteKit 基础的讨论开始，然后我们将学习游戏项目的解剖学。继续前进，我们将学习场景、精灵和节点。这将为我们提供对
    SpriteKit 基本结构模型的更深入理解。然后我们将通过向精灵添加一些动作来探索 SpriteKit 的深度。继续前进，我们将向本章中创建的游戏添加无限滚动。
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: SpriteKit is a graphics rendering and animation framework with features for
    animating arbitrary textured images called Sprites. It has a rendering loop that
    renders the contents of the frame. As a process, the content of each frame (that
    is, input) is given, processed, and then finally rendered by the rendering loop.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit 是一个图形渲染和动画框架，具有用于动画任意纹理图像（称为 Sprites）的功能。它有一个渲染循环，渲染帧的内容。作为一个过程，每个帧的内容（即输入）被给出，处理，然后最终由渲染循环渲染。
- en: Basically, your game identifies the content of the frame and how the content
    has to be changed in that frame.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，你的游戏识别帧的内容以及在该帧中内容如何改变。
- en: Being a new player in the game industry, SpriteKit is doing really well as it
    has adopted the basics of cocos2d, which is a heavily used game engine for 2D
    games. It's really well written, documented, and deeply integrated with iOS. However,
    if you are new to the game development domain, even then this book will serve
    you as a starter development guide. Each chapter is baked with a recipe to make
    sure that you learn all the concepts of game development.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 作为游戏行业的新手，SpriteKit 表现得非常好，因为它采用了 cocos2d 的基础知识，cocos2d 是一个广泛使用的 2D 游戏引擎。它编写得很好，文档齐全，并且与
    iOS 深度集成。然而，即使你对游戏开发领域不熟悉，这本书也会为你提供一本入门级开发指南。每一章都包含一个食谱，以确保你学习到游戏开发的所有概念。
- en: 'Now here are the two most basic concepts: scenes and sprites. iOS games are
    made up of scenes and scenes in turn hold sprites.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是两个最基本的概念：场景和精灵。iOS 游戏由场景组成，而场景则包含精灵。
- en: To get started with the SpriteKit, we will be creating a small game that will
    guide us to understand all the concepts of the SpriteKit.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 SpriteKit，我们将创建一个小游戏，这将指导我们了解 SpriteKit 的所有概念。
- en: Learning the basics of SpriteKit – The FlyingSpaceship tutorial
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习 SpriteKit 的基础知识 – 飞船教程
- en: In this section we will learn and explore basic concepts of SpriteKit. We will
    also develop a mini game, which will help in understanding the concepts with some
    robust implementation. The best way to learn SpriteKit is to see it in action.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习和探索 SpriteKit 的基本概念。我们还将开发一个迷你游戏，这将有助于通过一些稳健的实现来理解这些概念。学习 SpriteKit
    的最佳方式是看到它在实际中的应用。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To build a SpriteKit game, firstly you need to understand the basic structure
    of a SpriteKit project. You can get started with a starter project having a `SKScene`
    and an `SKNode` placed on it. This would equip you with the setup to build your
    basic game.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建 SpriteKit 游戏，首先你需要了解 SpriteKit 项目的结构。你可以从一个包含 `SKScene` 和 `SKNode` 的起始项目开始。这将为你提供构建基本游戏所需的设置。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: To understand the basic concepts of game programming, let's create a new project
    with the SpriteKit game template with project name `FlyingSpaceship`. The project
    will demonstrate the structure of a SpriteKit project. The end goal of the project
    is that a Spaceship is visible on the screen and in the upcoming topics we can
    make it fly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解游戏编程的基本概念，让我们创建一个名为 `FlyingSpaceship` 的新项目，使用 SpriteKit 游戏模板。该项目将展示 SpriteKit
    项目的结构。项目的最终目标是屏幕上可见一艘飞船，在接下来的主题中我们可以让它飞起来。
- en: 'We will follow some of the same steps we performed in [Chapter 1](part0015_split_000.html#page
    "Chapter 1. iOS Game Development"), *iOS Game Development* and finally add the
    Spaceship to the screen:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循与 [第 1 章](part0015_split_000.html#page "第 1 章. iOS 游戏开发") 中相同的步骤，*iOS 游戏开发*，并最终将飞船添加到屏幕上：
- en: Start your Xcode and navigate to **File** | **New** | **Project**. Then from
    the prompt window navigate to **iOS** | **Application** | **SpriteKit Game** and
    click on **Next**.![How to do it...](img/00016.jpeg)
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Xcode 并导航到 **文件** | **新建** | **项目**。然后从提示窗口导航到 **iOS** | **应用程序** | **SpriteKit
    游戏**，点击 **下一步**。![如何操作...](img/00016.jpeg)
- en: Fill all the project details in the prompt window and provide `FlyingSpaceship`
    as the project name with your **Organization Name**, **Devices** as **iPhone**,
    and **Class Prefix** as `FS`. Click on **Next** as shown in the following screenshot:![How
    to do it...](img/00017.jpeg)
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示窗口中填写所有项目详情，并将项目名称设置为 `FlyingSpaceship`，**组织名称**，**设备**选择 **iPhone**，**类前缀**设置为
    `FS`。点击 **下一步**，如图所示：![如何操作...](img/00017.jpeg)
- en: Select a location on drive to save the project and click on **Create**.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个位置在驱动器上保存项目，并点击 **创建**。
- en: As a result, the `FSViewController` and `FSMyScene` files will be created in
    the project having a `Spaceship.png` file also. The project directory should look
    something similar to the following screenshot:![How to do it...](img/00018.jpeg)
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，项目中将创建 `FSViewController` 和 `FSMyScene` 文件，同时项目目录中也有 `Spaceship.png` 文件。项目目录应类似于以下截图：![如何操作...](img/00018.jpeg)
- en: Go to the **General** tab, uncheck **Portrait** from the device orientation
    so that the final orientation is landscape.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **常规** 选项卡，取消勾选 **纵向** 以便最终方向为横屏。
- en: Cut the code of typecasting `UIView` to `SKView` and presenting `FSMyScene`
    to `SKView` from `(void)viewDidLoad` of `FSViewController`.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类型转换代码 `UIView` 到 `SKView` 以及将 `FSMyScene` 呈现到 `SKView` 从 `FSViewController`
    的 `(void)viewDidLoad` 中删除。
- en: Implement `- (void)viewWillLayoutSubviews` and copy the code from `viewDidLoad`
    to `viewWillLayoutSubviews`.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `- (void)viewWillLayoutSubviews` 并将 `viewDidLoad` 中的代码复制到 `viewWillLayoutSubviews`
    中。
- en: Finally, the code will look like this:![How to do it...](img/00019.jpeg)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终，代码将看起来像这样：![如何操作...](img/00019.jpeg)
- en: Now, let's go to `FSMyScene.m`, remove the default code added in the `init`
    method and also the method for touch detection.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们转到 `FSMyScene.m`，删除在 `init` 方法中添加的默认代码以及触摸检测方法。
- en: 'Make a property for a `SKSpriteNode` called spaceship in the private interface:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在私有接口中为 `SKSpriteNode` 创建一个名为 spaceship 的属性：
- en: '[PRE0]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add this `spaceShipSprite` to the `FSMyScene` file in its `init` method:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `FSMyScene` 文件的 `init` 方法中将此 `spaceShipSprite` 添加到其中：
- en: '[PRE1]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The default `Spaceship.png` provided is appropriate, so delete and add `Spaceship.png`
    provided in the `Resources` folder of the Starter kit.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认提供的 `Spaceship.png` 是合适的，因此删除并添加 Starter kit 的 `Resources` 文件夹中提供的 `Spaceship.png`。
- en: Now if you run the app, the spaceship doesn't look good on a black background,
    so give the sky color background color to `FSMyScene` file in its `init` method.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在如果您运行应用程序，飞船在黑色背景上看起来不好，因此将 `FSMyScene` 文件的背景颜色设置为天空颜色，在它的 `init` 方法中。
- en: '[PRE2]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: So finally we have reached the goal and have placed a spaceship in the sky.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，我们最终达到了目标，将飞船放置到了天空之中。
- en: 'The final `FSMyScene` class looks like this:'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终的 `FSMyScene` 类看起来像这样：
- en: '![How to do it...](img/00020.jpeg)'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00020.jpeg)'
- en: 'In the preceding screenshot, you will observe an `update: method` in the `.m`
    file. This method is automatically invoked while rendering each frame on the screen.
    If the frame rate of the game is 60, then this method will be executed 60 times
    in a second. Any real-time calculations can be performed in this method, so actions
    such as calculating the player''s location in real time can be handled in this
    method.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图，您将在 `.m` 文件中观察到 `update:` 方法。此方法在屏幕上渲染每一帧时自动调用。如果游戏的帧率为 60，则此方法每秒将执行
    60 次。任何实时计算都可以在此方法中执行，因此可以在此方法中处理如计算玩家实时位置等动作。
- en: 'And the starter kit game, `FlyingSpaceship`, looks like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Starter kit 游戏 `FlyingSpaceship` 看起来是这样的：
- en: '![How to do it...](img/00021.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/00021.jpeg)'
- en: How it works...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The structure of SpriteKit is fundamentally derived and inherited from the UIKit
    framework. The operating system offers a smooth transition from UIKit to SpriteKit
    by just typecasting the UIKit view controller's view to a SpriteKit view called
    SKView. After this, you are ready to play with the SpriteKit stuff. As shown in
    the following block diagram, create a scene, add some nodes (that is Sprites as
    players, background stuff, and so on) to it and you have the game environment
    built. You can also make the environment more live by applying some actions (rotate,
    move, scale, and many more) to the nodes added.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit的结构基本上是从UIKit框架继承和派生出来的。操作系统通过将UIKit视图控制器的视图类型转换为SpriteKit视图（称为SKView）来提供从UIKit到SpriteKit的平滑过渡。在此之后，你就可以开始使用SpriteKit了。如图所示，创建一个场景，向其中添加一些节点（即作为玩家的精灵、背景等），你就构建了游戏环境。你还可以通过向节点应用一些动作（旋转、移动、缩放等）来使环境更加生动。
- en: Hence, in combination, this scene has different kinds of nodes with some actions
    applied, that make the basic structure of your SpriteKit and also the game you
    thought of building.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，结合这些，这个场景具有不同类型的节点和一些应用的动作，这构成了你的SpriteKit的基本结构，以及你想要构建的游戏的基本结构。
- en: '![How it works...](img/00022.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/00022.jpeg)'
- en: There's more...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'SpriteKit can be used for game development on iOS and OS X platforms. The available
    graphics hardware of the hosting device is used to render composite 2D images
    at high frame rates. There are several other features of SpriteKit, which support
    the following kinds of content, including:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit可用于iOS和OS X平台上的游戏开发。它使用宿主设备的可用图形硬件以高帧率渲染复合2D图像。SpriteKit还有其他一些功能，支持以下类型的内容，包括：
- en: Sprites that can be of any form such as untextured or textured rectangles
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以是任何形式的精灵，如无纹理或有纹理的矩形
- en: Text
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本
- en: Arbitrary CGPath-based shapes
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于任意CGPath的形状
- en: Video
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视频
- en: If you are curious to know more, then visit Apple's developer link [https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Introduction/Introduction.html](https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Introduction/Introduction.html).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多信息，请访问苹果的开发者链接 [https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Introduction/Introduction.html](https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Introduction/Introduction.html)。
- en: You can also play around with the sample you have just created by trying to
    change the location of the spaceship and applying various colors to its background.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过尝试更改太空船的位置并为其背景应用各种颜色来尝试修改你刚刚创建的示例。
- en: Understanding scenes, nodes, and sprites
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解场景、节点和精灵
- en: The whole game is organized into scenes, which have the content represented
    by `SKScene` objects.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 整个游戏被组织成场景，这些场景由`SKScene`对象表示的内容构成。
- en: A scene is an entity that holds all the content, that is, nodes and sprites
    that are to be rendered. It also implements the setup or anatomy of content processing
    and updating each frame.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 场景是一个包含所有内容的实体，即将要渲染的节点和精灵。它还实现了内容的设置或每一帧的更新结构。
- en: The `SKScene` class is a subclass of SKNode, which is the fundamental building
    block of SpriteKit. Every entity in SpriteKit is inherited or derived from the
    node (SKNode). So `SKScene` is the root node for other nodes, which are used to
    populate the content over a scene.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`SKScene`类是`SKNode`的子类，它是SpriteKit的基本构建块。SpriteKit中的每个实体都是继承或派生自节点（SKNode）。因此，`SKScene`是其他节点的根节点，用于在场景中填充内容。'
- en: Similar to UIKit, each node's position is specified according to the coordinate
    system of its parent. A node also has the basic properties that a content item
    or entity should have such as moving, rotating, scaling, fading out, and many
    more. And most important, all node objects are responder objects that respond
    to the delegates of UIResponder. This is used to detect input touches to the scene
    for moving objects and some other stuff depending on one's gameplay.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与UIKit类似，每个节点的位置是根据其父坐标系统指定的。节点还具有内容项或实体应具备的基本属性，如移动、旋转、缩放、淡出等。最重要的是，所有节点对象都是响应对象，响应`UIResponder`的委托。这用于检测场景中的输入触摸以移动对象以及根据游戏玩法的一些其他内容。
- en: Now, sprites are represented by SKSpriteNode objects. They are nodes with images
    on them. We can specify content or a textured image to them as we have to make
    some player or enemies in a game. SKSpriteNode is also inherited from SKNode.
    Additionally, its content can be changed and animated. The sprites are created
    and added on scenes with some actions to make the game scene more alive.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，精灵由 `SKSpriteNode` 对象表示。它们是带有图像的节点。我们可以指定内容或纹理图像，就像我们必须要制作一些玩家或敌人一样。`SKSpriteNode`
    也继承自 `SKNode`。此外，其内容可以更改和动画化。精灵通过添加一些动作到场景中创建并添加，以使游戏场景更加生动。
- en: Getting ready
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To understand these elements of SpriteKit, we need to create a blank project
    just as we did in the starter project of this chapter. As in this starter kit,
    a basic `SKScene` and `SKNode` are shown. So we will now go through these terminologies
    and their sample code snippets.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解 SpriteKit 的这些元素，我们需要创建一个空白项目，就像我们在本章入门项目中做的那样。正如入门套件中所示，这里有一个基本的 `SKScene`
    和 `SKNode`。因此，我们现在将介绍这些术语及其示例代码片段。
- en: How to do it...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'As we did in the starter kit, follow the same steps to create a `SKScene` and
    add a `SKSpriteNode` method to it:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在入门套件中所做的那样，遵循相同的步骤创建一个 `SKScene` 并向其中添加一个 `SKSpriteNode` 方法：
- en: Create the SpriteKit Game Template from Xcode.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Xcode 创建 SpriteKit 游戏模板。
- en: A default ViewController and scene will be created for you.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将默认的 ViewController 和场景为您创建。
- en: Typecast the ViewController view to `SKView` by enabling the `showsFPS` and
    `showsNodeCount` properties to `YES`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过启用 `showsFPS` 和 `showsNodeCount` 属性为 `YES`，将 ViewController 视图类型转换为 `SKView`。
- en: '[PRE3]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Create a scene using a class method of `SKScene` specifying the size of the
    scene also, and then present that scene on the `SKView` typecasted before.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `SKScene` 的类方法创建一个场景，指定场景的大小，然后将其显示在之前类型转换的 `SKView` 上。
- en: '[PRE4]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: All this should be done in the `- (void)viewWillLayoutSubviews` method.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有这些都应该在 `- (void)viewWillLayoutSubviews` 方法中完成。
- en: Now we have to add some sprite to the scene we created earlier. Create an object
    of SKSpriteNode by calling a class method and specifying an image of the sprite.
    Now assign the location where it has to be placed and lastly add it to the scene.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须向之前创建的场景中添加一些精灵。通过调用类方法创建一个 `SKSpriteNode` 对象，并指定精灵的图像。现在指定它需要放置的位置，最后将其添加到场景中。
- en: '[PRE5]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As explained in the structural block diagram of the *How it works...* section
    of the *Learning the basics of SpriteKit – The FlyingSpaceship tutorial* recipe,
    it''s deeply linked with the UIKit framework. For building a game, we should have
    an environment, which is our scene, and some entities visible over the environment,
    which are the sprites. So to make it work, or should I say to make something visible
    on the screen, an environment (that is, scene) is created and on it entities (that
    is, sprites) are added, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如在 *学习 SpriteKit 基础 – 飞船教程* 菜谱的 *How it works...* 部分的结构块图中所述，它与 UIKit 框架深度关联。为了构建游戏，我们应该有一个环境，即我们的场景，以及一些在环境中可见的实体，即精灵。因此，为了使其工作，或者说为了在屏幕上显示某些内容，我们需要创建一个环境（即场景），并在其上添加实体（即精灵），如下所示：
- en: 'When we typecast UIView in to `SKView`, we enter the arena of SpriteKit:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们将 UIView 转换为 `SKView` 时，我们就进入了 SpriteKit 的领域：
- en: '[PRE6]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For debugging purposes, we enable two Boolean parameters to show FPS (Frames
    per second) and NodesCount (the number of nodes added to the scene):'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了调试目的，我们启用两个布尔参数以显示 FPS（每秒帧数）和 NodesCount（添加到场景中的节点数）：
- en: '[PRE7]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When creating a scene, we need to specify the size of the scene that is exactly
    the content size and the scale mode so that the scene fits in `SKView` (that is,
    scale perspective), here the `SKSceneScaleModeAspectFill` mode is used so that
    it fits as per the aspect ratio of the `SKView`:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建场景时，我们需要指定场景的大小，这正好是内容大小和缩放模式，以便场景适合 `SKView`（即缩放透视），这里使用的是 `SKSceneScaleModeAspectFill`
    模式，以便按照 `SKView` 的宽高比进行适配：
- en: '[PRE8]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To make the scene content visible on the view, we present the scene on `SKView`:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使场景内容在视图中可见，我们需要在 `SKView` 上显示场景：
- en: '[PRE9]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now about how the sprites work. A sprite object is created by a class method
    that instantiates a node having an image as its content:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在关于精灵的工作原理。通过类方法创建一个精灵对象，该对象实例化一个具有图像内容的节点：
- en: '[PRE10]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following line of code specifies the position where exactly the sprite
    needs to be placed:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下代码行指定了精灵需要放置的确切位置：
- en: '[PRE11]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Anatomy of game projects
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏项目的结构
- en: In this section we will see the basics of a game project. This includes understanding
    the basic architecture and work flow of game projects. Here we will learn about
    the scene and layers and their importance in games.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解游戏项目的基础知识。这包括理解游戏项目的基本架构和工作流程。在这里，我们将了解场景和层及其在游戏中的重要性。
- en: Getting ready
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'Complete game development is dependent on three core components: scenes, nodes,
    and sprites mentioned earlier. We need to have a command over these components
    to effectively start on game development.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的游戏开发依赖于前面提到的三个核心组件：场景、节点和精灵。我们需要对这些组件有控制权，才能有效地开始游戏开发。
- en: How to do it...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Internally, the life cycle is executed as per the scenes—nodes are added and
    actions applied on these nodes. It also includes attaching some physics bodies
    to the nodes, support for cropping, applying animation and effects to all or a
    part of the content, detecting forces and collision, drawing in OpenGL, and many
    more things.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，生命周期按照场景执行——节点被添加，并在这些节点上应用动作。它还包括将一些物理体附加到节点上，支持裁剪，将动画和效果应用到内容的所有或部分，检测力与碰撞，在
    OpenGL 中绘制，以及许多其他事情。
- en: Apart from all this, there is an overridden update method in `SKScene`, which
    is called for each frame of the game with the current time interval as a parameter.
    There you can add your actual game logic specifying what to do at what time and
    many more things as it is called by every frame that is rendered.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有这些，`SKScene` 中还有一个覆盖的更新方法，该方法在每个游戏帧中都会被调用，并使用当前时间间隔作为参数。在那里，你可以添加你的实际游戏逻辑，指定在什么时间做什么，以及许多其他事情，因为它是通过每个渲染的帧调用的。
- en: For an example, we can track the difference in time between the current time
    and the last updated time.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以跟踪当前时间和最后更新时间之间的时间差。
- en: As the current time interval is received in the update method, define the properties
    for difference in time and last updated time.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于在更新方法中接收到了当前时间间隔，因此定义时间差和最后更新时间的属性。
- en: '[PRE12]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now calculate difference in time by subtracting the last updated time from the
    current time and updating the lastUpdatedTime to the current time.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过从当前时间减去最后更新时间来计算时间差，并将 lastUpdatedTime 更新为当前时间。
- en: '[PRE13]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'At last the update method looks like this:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，更新方法看起来是这样的：
- en: '[PRE14]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now this is the place where we are going add our maximum game logic—all the
    adding, removing, animating, updating all nodes, sprites, and actions will take
    place inside this method. We can also take the help of `currentTime` to maintain
    some timers simply using float variables (updating them by the `diffTime` and
    firing time events whenever required according to our game design or logic).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这是我们要添加最大游戏逻辑的地方——所有添加、删除、动画化和更新节点、精灵和动作都将在这个方法内部进行。我们还可以利用 `currentTime`
    通过简单的浮点变量来维护一些计时器（通过 `diffTime` 更新它们，并根据我们的游戏设计或逻辑在需要时触发时间事件）。
- en: How it works...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: All that we see running on the screen are just frames added by a time interval,
    which is driven by a `SKScene` added as a child on the `SKView` that serves as
    the main scene of the game.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在屏幕上看到的所有运行内容都只是由时间间隔驱动的帧，这些帧是通过在作为游戏主场景的 `SKView` 上添加子 `SKScene` 来实现的。
- en: 'As shown in the following diagram, a frame circle is present, which depicts
    the execution cycle of the game project for each frame:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下图所示，存在一个帧循环，它描述了每个帧的游戏项目的执行周期：
- en: '![How it works...](img/00023.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/00023.jpeg)'
- en: 'Some of the methods from the preceding diagram are explained as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面图中一些方法的解释：
- en: An update method of `SKScene` is called where we can add, remove, animate, and
    update different kinds of nodes and actions.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `SKScene` 的更新方法中被调用，我们可以添加、删除、动画化和更新不同类型的节点和动作。
- en: '`SKScene` evaluates its actions that are running for the current frame following
    some life cycle calls such as `didEvaluateActions`.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SKScene` 根据一些生命周期调用（如 `didEvaluateActions`）评估当前帧正在运行的动作。'
- en: '`SKScene` has its own physics simulation, so if some bodies are added to it,
    the physics simulation is also evaluated such as collision detection, applying
    forces, and so on.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SKScene` 有自己的物理模拟，因此如果向其中添加了一些物体，物理模拟也会被评估，例如碰撞检测、应用力等。'
- en: All the methods mentioned earlier contribute to the final rendering of SKView,
    which is displayed as a frame to the user. Hence, regular running of these frames
    makes the game appear as an environment.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所提到的所有方法都贡献于最终渲染的 SKView，它被显示为用户看到的帧。因此，这些帧的常规运行使游戏看起来像一个环境。
- en: Applying actions on sprites
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在精灵上应用动作
- en: Sprites are just static images with no life. So actions add that life to the
    sprites that make your game. Actions help in building the gameplay by moving sprites
    and animating them differently. An action is an object that makes the scene look
    alive.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵只是没有生命的静态图像。因此，动作为精灵添加了生命，使你的游戏变得生动。动作通过移动精灵和以不同的方式动画它们来帮助构建游戏玩法。动作是一个使场景看起来生动的对象。
- en: Actions are applied on nodes and sprites, for example, we want to move some
    object that is a sprite, so we create a move action and run it on that sprite.
    SpriteKit automatically changes the sprite's position in a form of animation until
    the action is over.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 动作应用于节点和精灵，例如，我们想要移动一些作为精灵的对象，因此我们创建一个移动动作并在该精灵上运行它。SpriteKit会自动将精灵的位置以动画的形式改变，直到动作完成。
- en: All actions are implemented using a class called `SKAction` and different types
    of actions are instantiated using the class methods of the `SKAction` class provided
    for various animation functionality.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 所有动作都是使用名为`SKAction`的类实现的，不同类型的动作是通过`SKAction`类提供的类方法实例化的，这些方法提供了各种动画功能。
- en: 'Here are the most common actions available in SpriteKit:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是SpriteKit中可用的最常见动作：
- en: Applying transformation (translation, rotation, and scaling)
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用变换（平移、旋转和缩放）
- en: Changing visibility (fading in and fading out)
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变可见性（淡入和淡出）
- en: Changing the content of the sprite
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变精灵的内容
- en: Changing the colors of sprites
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变精灵的颜色
- en: Removing sprites
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除精灵
- en: Calling a block or a selector
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用一个块或选择器
- en: Repeating and sequencing actions
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复和排序动作
- en: Getting ready
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To apply different actions on sprites and see them animating, we need to know
    scenes, sprites, and the overall life cycle of a SpriteKit project. We also need
    to know about some fundamental actions that are applied on any entity such as
    move, rotate, scale, and there are many more special effects to explore.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要在精灵上应用不同的动作并看到它们动画化，我们需要了解场景、精灵以及SpriteKit项目的整体生命周期。我们还需要了解一些应用于任何实体（如移动、旋转、缩放）的基本动作，还有许多其他特殊效果可以探索。
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: There is a wide variety of actions to be applied on nodes and sprites, some
    of which are listed next.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多动作可以应用于节点和精灵，以下列出了一些：
- en: To understand this, we will take the spaceship as a sprite to apply different
    actions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这一点，我们将以宇宙飞船作为精灵来应用不同的动作。
- en: 'There are several individual actions provided by the SpriteKit framework. A
    few of them are explained as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit框架提供了几个单独的动作。以下是一些解释：
- en: '**Move Action**: To move a sprite, call the class method shown below, specifying
    the location where the sprite has to be moved and in what time. And then call
    the `runAction` method on the sprite with the move action created.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动动作**：要移动一个精灵，调用以下所示类方法，指定精灵需要移动的位置和所需时间。然后，在精灵上调用`runAction`方法，使用创建的移动动作。'
- en: '[PRE15]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Rotate Action**: To rotate a sprite, we have to specify an angle in radians,
    which will make the sprite rotate by or to that angle in a specified time. So
    specify the angle in degrees, convert to radians, and then feed it to the function
    thereby applying that action to the sprite.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**旋转动作**：要旋转一个精灵，我们必须指定一个弧度角度，这将使精灵在指定的时间内旋转到或绕该角度旋转。因此，指定角度为度数，将其转换为弧度，然后将其输入到函数中，从而将该动作应用于精灵。'
- en: '[PRE16]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Scale Action**: To scale a sprite, we have to specify a scale factor, which
    will increase or decrease the size of the sprite, depending on the scale factor
    given in a time.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缩放动作**：要缩放一个精灵，我们必须指定一个缩放因子，这将根据缩放因子在一段时间内增加或减小精灵的大小。'
- en: '[PRE17]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Fade Action**: To make a sprite visible or invisible through animation, there
    are methods for fading out and fading in a sprite. For now, fading out is shown
    in the following code, which takes a parameter or the time over which to fadeout.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**淡入淡出动作**：要通过动画使精灵可见或不可见，有淡入和淡出精灵的方法。目前，以下代码展示了淡出，它接受一个参数或淡出的时间。'
- en: '[PRE18]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In SpriteKit, there are many more actions for giving delays, changing content,
    invoking an object or selector, calling blocks, and many special effects.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在SpriteKit中，还有许多其他动作，用于提供延迟、更改内容、调用对象或选择器、调用块以及许多特殊效果。
- en: 'Similar to the individual actions, there are sequence and repeat actions, which
    fall under a different category of actions provided by SpriteKit. The sequence
    action is meant for running actions in a particular sequence we want. As shown
    in the following code, two actions are created—one for fading out and the other
    for fading in the sprite. So, both the actions are fed to the sequence action
    in the order we want and it would run the sequence we asked for:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与单个动作类似，还有序列和重复动作，这些都属于SpriteKit提供的不同类别的动作。序列动作用于按照我们想要的顺序运行动作。如下面的代码所示，创建了两个动作——一个用于精灵淡出，另一个用于淡入。因此，这两个动作按照我们想要的顺序被输入到序列动作中，并运行我们要求的序列：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The repeat action allows actions to be repeated for a fixed number of time or
    to be repeated forever. So using the preceding sequence action, we do both.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 重复动作允许动作在固定的时间数内重复或无限重复。因此，使用前面的序列动作，我们做了这两件事。
- en: 'Animating the sequence for three times regularly:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按规律重复三次动画序列：
- en: '[PRE20]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Animating the sequence repeatedly forever:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无限重复动画序列：
- en: '[PRE21]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Another type of action is the group action. Several times in games we may need
    to repeat a sequence of actions, which means running actions in a particular sequence
    for any interval of time. As shown previously, two actions were created, one for
    fading out and second for fading in the sprite. So, both the actions were fed
    to the sequence action in the order we wanted and it would run the sequence we
    asked for.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种动作类型是组动作。在游戏中，我们可能需要多次重复一系列动作，这意味着在任意时间间隔内以特定顺序运行动作。如前所述，创建了两个动作，一个用于精灵淡出，另一个用于淡入。因此，这两个动作按照我们想要的顺序被输入到序列动作中，并运行我们要求的序列。
- en: 'Group actions are used when we have to run many actions at the same point of
    time. So we can make a group function that moves a sprite by fading out also:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要在同一时间运行多个动作时，使用组动作。因此，我们可以创建一个通过淡出移动精灵的组函数：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'All the actions we have discussed earlier will be working in the same flow.
    Here is the basic anatomy of all actions, which we apply on sprites:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论的所有动作都将按照相同的流程工作。以下是所有动作的基本结构，我们将其应用于精灵上：
- en: Decide the actions we want to apply, in what sequence they are to be executed,
    and whether some action needs to be repeated or not.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定我们想要应用的动作，它们的执行顺序，以及是否需要重复某些动作。
- en: For each action, whatever the type is, specify its respective parameters and
    the time duration for it.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个动作，无论其类型如何，都要指定其相应的参数和持续时间。
- en: After finalizing the action, just call `runAction` on the sprite to be animated
    with the action constructed.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作最终确定后，只需在要动画的精灵上调用`runAction`并使用构建的动作即可。
- en: Adding infinite scrolling
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加无限滚动
- en: Now we are all ready with our spaceship. It's time to add some more in the game.
    So our next target is to add infinite scrolling to the game, so that we can make
    our spaceship move infinitely in space. In this recipe, we will be learning about
    the ways to add infinite scrolling to games.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了我们的飞船。是时候在游戏中添加更多内容了。因此，我们的下一个目标是添加无限滚动，这样我们就可以让我们的飞船在太空中无限移动。在这个菜谱中，我们将学习如何将无限滚动添加到游戏中。
- en: Getting ready
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For an infinite scrolling background you need to know about the anatomy of SpriteKit
    shown earlier. You should be aware of the rendering loop, how in a particular
    frame the update method functions, and how `SKScene` evaluates the actions and
    physics simulation thereby rendering all the stuff in the `SKView`. Now using
    this loop, you implement sky scrolling infinitely giving the feel of a spaceship
    flying.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无限滚动背景，你需要了解之前展示的SpriteKit的结构。你应该了解渲染循环，在特定帧中更新方法是如何工作的，以及`SKScene`如何评估动作和物理模拟，从而在`SKView`中渲染所有内容。现在使用这个循环，你实现天空无限滚动，给人一种飞船飞行的感觉。
- en: How to do it...
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Now is the time for action; perform the following steps to add the infinite
    scrolling background to your game.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是采取行动的时候了；按照以下步骤添加无限滚动背景到你的游戏中。
- en: Import the `SpaceBackground.png` file provided in the `Resources` folder.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`Resources`文件夹中提供的`SpaceBackground.png`文件。
- en: Add a function in `FSMyScene` for initializing the infinite background.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FSMyScene`中添加一个初始化无限背景的功能。
- en: In order to enable scrolling, we have to add two identical background sprite
    nodes one after the other.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了启用滚动，我们必须连续添加两个相同的背景精灵节点。
- en: In the function, run a `for` loop for two background nodes specifying the position,
    a name (tag), and then adding to `SKMyScene`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数中，运行一个`for`循环，为两个背景节点指定位置、一个名称（标签），然后添加到`SKMyScene`。
- en: 'Hence, the `initalizingScrollingBackground` function looks like this:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，`initalizingScrollingBackground`函数看起来是这样的：
- en: '[PRE23]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Add this method into the `init` method and also move the code to add a spaceship
    into a different method called `addSpaceship`.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此方法添加到`init`方法中，并将添加飞船的代码移动到另一个名为`addSpaceship`的不同方法中。
- en: Note
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In game programming, the layers of objects are made by the sequence they are
    added in. So for the preceding example, the Spaceship should be added after `SpaceBackground`
    giving an appearance that the ship is above the background.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在游戏编程中，对象的层是通过它们添加的顺序来制作的。所以对于前面的例子，飞船应该在`SpaceBackground`之后添加，以给人一种飞船在背景之上的外观。
- en: 'The sequence of the views presented on the screen can be changed by altering
    their *z* coordinate; the view having highest *z* coordinate will always be on
    the top. This means we can explicitly define which layer we want to keep on top
    and which we want to keep at the bottom, which is explained in the following steps:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上显示的视图顺序可以通过改变它们的*z*坐标来改变；具有最高*z*坐标的视图将始终位于顶部。这意味着我们可以明确地定义我们希望保持在顶层的哪一层，以及我们希望保持在底层的哪一层，这将在以下步骤中解释：
- en: The initial background is added but it's not scrolling. This could be accomplished
    by the update method discussed in the *Anatomy of game projects* recipe.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始背景已经添加，但它没有滚动。这可以通过在*Anatomy of game projects*配方中讨论的更新方法来实现。
- en: 'For this, some math is required to implement this functionality. Build some
    inline functions and constants to be used for infinitely moving the background.
    This is the code needed:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了做到这一点，需要一些数学来实现这个功能。构建一些内联函数和常量，用于无限移动背景。这是所需的代码：
- en: '[PRE24]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Just add these line of code preceding to the implementation of `FSMyScene`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只需将这些代码行添加到`FSMyScene`的实现之前。
- en: Now the real way to do it is, in the update method, iterate all nodes added
    in `FSMyScene`, identify the `SpaceBackground` node by its name assigned in the
    initialization function, and adjust its position to enable infinite scrolling.
    Do all of this in a function named `moveSpaceBackground`.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在真正的做法是在更新方法中，迭代在`FSMyScene`中添加的所有节点，通过初始化函数中分配的名称识别`SpaceBackground`节点，并调整其位置以启用无限滚动。所有这些都在一个名为`moveSpaceBackground`的函数中完成。
- en: '[PRE25]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Lastly, call this method every time in the update method of the game scene.
    After that, you should see the spaceship flying in the sky with some nice white
    clouds.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在游戏场景的更新方法中每次调用此方法。之后，你应该看到飞船在天空中飞行，有一些漂亮的白色云朵。
- en: How it works...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Implementation of infinite scrolling is divided into three parts. We need to
    follow the following steps to accomplish infinite scrolling for our game:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 无限滚动的实现分为三个部分。为了完成我们游戏的无限滚动，我们需要遵循以下步骤：
- en: 'Initializing the SpaceBackground: Two space backgrounds are added one after
    the other so that they are moved at the same time to give a feel of an infinite
    scrolling background.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化SpaceBackground：连续添加两个空间背景，以便它们同时移动，给人一种无限滚动背景的感觉。
- en: 'SpaceBackground move code: Here, a block method of SKScene is used to iterate
    all nodes of the scene.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SpaceBackground移动代码：在这里，使用SKScene的块方法来迭代场景中的所有节点。
- en: '[PRE26]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this iteration, the SpaceBGNode is identified by its name so that its position
    can be updated.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个迭代中，通过名称识别SpaceBgNode，以便更新其位置。
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The amount of distance to be moved is calculated using the `CGPointMultiplyScalar`
    inline function that is fed with the constant value `SPACE_BG_VELOCITY` and the
    difference of time obtained from the update method in each frame.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`CGPointMultiplyScalar`内联函数计算要移动的距离，该函数使用常量值`SPACE_BG_VELOCITY`和从每一帧的更新方法中获得的时间的差值。
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After that, the calculated distance is added in the current position of SpaceBGNode.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，计算出的距离被添加到SpaceBGNode的当前位置。
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The last but the most important step to enable scrolling, is to set the position
    of `SpaceBGNode` to the right edge of the screen whenever it reaches the left
    edge of the screen.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 启用滚动的最后但最重要的步骤是将`SpaceBGNode`的位置设置为屏幕的右侧，每次它到达屏幕的左侧边缘时。
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The next task is to update each frame to move it infinitely over the scene.
    Now to make it move regularly, the `moveSpaceBackground` method is called in the
    update method of `FSMyScene` in each frame.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个任务是更新每一帧以使其无限地在场景中移动。现在为了使其规律地移动，每个帧在`FSMyScene`的更新方法中调用`moveSpaceBackground`方法。
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The update loop will be executed in every frame. So to move our background in
    every step, we have called the `moveSpaceBackground` method inside the update
    loop. Using this approach of infinite scrolling, we can also implement parallax
    gaming, which is very common nowadays. In parallax scrolling game, there will
    be background and player in separate layers and they will be moving at the same
    time at different speeds. This will give the user a perception of some real-time
    movement of the player against the background.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 更新循环将在每一帧执行。因此，为了在每一步移动我们的背景，我们在更新循环中调用了`moveSpaceBackground`方法。使用这种无限滚动的技术，我们还可以实现视差游戏，这在当今非常常见。在视差滚动游戏中，背景和玩家将在不同的层中，并且它们将以不同的速度同时移动。这将使用户感觉到玩家相对于背景的实时移动。
- en: Moving characters
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动角色
- en: The most interesting part is making some character live, which we are going
    to do in this part. We will be detecting a touch on the screen and then applying
    some cool actions on some nodes, that is, moving the spaceship up and down.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的部分是让某个角色变得生动，这是我们将在本部分做的。我们将检测屏幕上的触摸，然后对一些节点应用一些酷炫的动作，即移动宇宙飞船上下飞行。
- en: Getting ready
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To make the character move, you should know the basic actions (`SKAction`) that
    can be applied on nodes (`SKNode`).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要使角色移动，你应该知道可以应用于节点（`SKNode`）的基本动作（`SKAction`）。
- en: How to do it...
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Now, as we have got the spaceship moving in infinite space, it''s time to add
    some more fun in the game. We will now be adding the up-down motion to our spaceship.
    Perform the following steps to add the up-down motion to the spaceship:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经让宇宙飞船在无限空间中移动，是时候给游戏添加更多乐趣了。我们将现在给我们的宇宙飞船添加上下运动。按照以下步骤给宇宙飞船添加上下运动：
- en: Declare some properties for actions, namely up and down actions in `FSMyScene`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FSMyScene`中声明一些动作属性，即上升和下降动作。
- en: '[PRE32]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Define the distance and over what time the spaceship will move on a screen touch
    just above the implementation of `FSMyScene`.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FSMyScene`的`touchLocation`实现上方定义宇宙飞船在屏幕触摸时移动的距离和所需时间。
- en: '[PRE33]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Assign up and down actions to their respective properties in the `addSpaceShip`
    method as added in the starter kit project.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启动器项目中的`addSpaceShip`方法中，将上升和下降动作分配给相应的属性。
- en: '[PRE34]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now implement a delegate method of `UIResponder`, which detects touches and
    UI Events. The method inputs touches as `NSSet` from which any touch is taken
    and converted into a position with respect to the scene on which the touch event
    occurred.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在实现`UIResponder`的一个代理方法，该方法检测触摸和UI事件。该方法输入`NSSet`形式的触摸，从中取出任何触摸并将其转换为相对于发生触摸事件的场景的位置。
- en: '[PRE35]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, using this `touchLocation` and `SpaceShip` position, the code decides when
    to apply an up or a down action on the spaceship. It also checks the bounds of
    the screen so that the spaceship does not move outside the screen.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用这个`touchLocation`和`SpaceShip`位置，代码决定何时对宇宙飞船应用上升或下降动作。它还检查屏幕边界，以确保宇宙飞船不会移动到屏幕外。
- en: 'This is what the code looks like:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是代码的样子：
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Whenever the user taps on the screen, a delegate method of `UIResponder` is
    called.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户触摸屏幕时，会调用`UIResponder`的一个代理方法。
- en: '[PRE37]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this method, the position of the touch is converted into local coordinates
    of `SKScene`. Based on the location detected, it is compared to the spaceship
    location and up or down action is applied on it.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，触摸的位置被转换为`SKScene`的局部坐标。根据检测到的位置，它与宇宙飞船的位置进行比较，并对其应用上升或下降动作。
- en: Finally, as an outcome of this chapter, you have a small fundamental game with
    an environment of blue sky with white clouds moving with an infinite scroll and
    a spaceship flying up and down in a linear motion.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，作为本章的成果，你拥有一个小型的基本游戏，其环境是一片蓝天白云，背景以无限滚动的方式移动，一艘宇宙飞船在直线运动中上下飞行。
- en: 'This is what the game looks like now:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是游戏现在的样子：
- en: '![How it works...](img/00024.jpeg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/00024.jpeg)'
- en: There's more...
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There can be a lot of other animation that can be used to animate the ship.
    All the previously discussed animation actions can be used over the ship. A consolidated
    result of these actions can be used in several places in the games. In the next
    chapter, we will learn about the animations in more detail and about effects.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 可以有很多其他的动画来动画化飞船。所有之前讨论的动画动作都可以用于飞船。这些动作的整合结果可以在游戏中的几个地方使用。在下一章中，我们将更详细地学习动画和效果。
- en: See also
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The chapter has already given you insights about the animation that can be done
    on sprites and nodes. You can also visit Apple's developer documentation for more
    details. You have learned enough in the chapter to get you started with the animation
    and actions on the sprites.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 本章已经向您介绍了可以在精灵和节点上进行的动画制作。您还可以访问苹果的开发者文档以获取更多详细信息。您在本章中学到的知识已经足够让您开始对精灵进行动画和动作的制作。
