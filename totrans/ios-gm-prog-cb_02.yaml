- en: Chapter 2. SpriteKit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning the basics of SpriteKit – The FlyingSpaceship tutorial
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding scenes, nodes, and sprites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anatomy of game projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying actions on Sprites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding infinite scrolling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter explains SpriteKit in detail. We'll start from a discussion on
    the basics of SpriteKit, and then we will be learning about the anatomy of the
    game project. Moving ahead, we will learn about scenes, sprites, and nodes. This
    will provide us a deeper understanding about the basic structure model of the
    SpriteKit. Then we will be exploring the depth of SpriteKit by adding some actions
    to the sprites. Moving ahead, we will be adding infinite scrolling to the game
    that will be created during the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SpriteKit is a graphics rendering and animation framework with features for
    animating arbitrary textured images called Sprites. It has a rendering loop that
    renders the contents of the frame. As a process, the content of each frame (that
    is, input) is given, processed, and then finally rendered by the rendering loop.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, your game identifies the content of the frame and how the content
    has to be changed in that frame.
  prefs: []
  type: TYPE_NORMAL
- en: Being a new player in the game industry, SpriteKit is doing really well as it
    has adopted the basics of cocos2d, which is a heavily used game engine for 2D
    games. It's really well written, documented, and deeply integrated with iOS. However,
    if you are new to the game development domain, even then this book will serve
    you as a starter development guide. Each chapter is baked with a recipe to make
    sure that you learn all the concepts of game development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now here are the two most basic concepts: scenes and sprites. iOS games are
    made up of scenes and scenes in turn hold sprites.'
  prefs: []
  type: TYPE_NORMAL
- en: To get started with the SpriteKit, we will be creating a small game that will
    guide us to understand all the concepts of the SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: Learning the basics of SpriteKit – The FlyingSpaceship tutorial
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we will learn and explore basic concepts of SpriteKit. We will
    also develop a mini game, which will help in understanding the concepts with some
    robust implementation. The best way to learn SpriteKit is to see it in action.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To build a SpriteKit game, firstly you need to understand the basic structure
    of a SpriteKit project. You can get started with a starter project having a `SKScene`
    and an `SKNode` placed on it. This would equip you with the setup to build your
    basic game.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand the basic concepts of game programming, let's create a new project
    with the SpriteKit game template with project name `FlyingSpaceship`. The project
    will demonstrate the structure of a SpriteKit project. The end goal of the project
    is that a Spaceship is visible on the screen and in the upcoming topics we can
    make it fly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will follow some of the same steps we performed in [Chapter 1](part0015_split_000.html#page
    "Chapter 1. iOS Game Development"), *iOS Game Development* and finally add the
    Spaceship to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: Start your Xcode and navigate to **File** | **New** | **Project**. Then from
    the prompt window navigate to **iOS** | **Application** | **SpriteKit Game** and
    click on **Next**.![How to do it...](img/00016.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill all the project details in the prompt window and provide `FlyingSpaceship`
    as the project name with your **Organization Name**, **Devices** as **iPhone**,
    and **Class Prefix** as `FS`. Click on **Next** as shown in the following screenshot:![How
    to do it...](img/00017.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a location on drive to save the project and click on **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a result, the `FSViewController` and `FSMyScene` files will be created in
    the project having a `Spaceship.png` file also. The project directory should look
    something similar to the following screenshot:![How to do it...](img/00018.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **General** tab, uncheck **Portrait** from the device orientation
    so that the final orientation is landscape.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cut the code of typecasting `UIView` to `SKView` and presenting `FSMyScene`
    to `SKView` from `(void)viewDidLoad` of `FSViewController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement `- (void)viewWillLayoutSubviews` and copy the code from `viewDidLoad`
    to `viewWillLayoutSubviews`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the code will look like this:![How to do it...](img/00019.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's go to `FSMyScene.m`, remove the default code added in the `init`
    method and also the method for touch detection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make a property for a `SKSpriteNode` called spaceship in the private interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add this `spaceShipSprite` to the `FSMyScene` file in its `init` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The default `Spaceship.png` provided is appropriate, so delete and add `Spaceship.png`
    provided in the `Resources` folder of the Starter kit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now if you run the app, the spaceship doesn't look good on a black background,
    so give the sky color background color to `FSMyScene` file in its `init` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So finally we have reached the goal and have placed a spaceship in the sky.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The final `FSMyScene` class looks like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/00020.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'In the preceding screenshot, you will observe an `update: method` in the `.m`
    file. This method is automatically invoked while rendering each frame on the screen.
    If the frame rate of the game is 60, then this method will be executed 60 times
    in a second. Any real-time calculations can be performed in this method, so actions
    such as calculating the player''s location in real time can be handled in this
    method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'And the starter kit game, `FlyingSpaceship`, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The structure of SpriteKit is fundamentally derived and inherited from the UIKit
    framework. The operating system offers a smooth transition from UIKit to SpriteKit
    by just typecasting the UIKit view controller's view to a SpriteKit view called
    SKView. After this, you are ready to play with the SpriteKit stuff. As shown in
    the following block diagram, create a scene, add some nodes (that is Sprites as
    players, background stuff, and so on) to it and you have the game environment
    built. You can also make the environment more live by applying some actions (rotate,
    move, scale, and many more) to the nodes added.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, in combination, this scene has different kinds of nodes with some actions
    applied, that make the basic structure of your SpriteKit and also the game you
    thought of building.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SpriteKit can be used for game development on iOS and OS X platforms. The available
    graphics hardware of the hosting device is used to render composite 2D images
    at high frame rates. There are several other features of SpriteKit, which support
    the following kinds of content, including:'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that can be of any form such as untextured or textured rectangles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arbitrary CGPath-based shapes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Video
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are curious to know more, then visit Apple's developer link [https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Introduction/Introduction.html](https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Introduction/Introduction.html).
  prefs: []
  type: TYPE_NORMAL
- en: You can also play around with the sample you have just created by trying to
    change the location of the spaceship and applying various colors to its background.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding scenes, nodes, and sprites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The whole game is organized into scenes, which have the content represented
    by `SKScene` objects.
  prefs: []
  type: TYPE_NORMAL
- en: A scene is an entity that holds all the content, that is, nodes and sprites
    that are to be rendered. It also implements the setup or anatomy of content processing
    and updating each frame.
  prefs: []
  type: TYPE_NORMAL
- en: The `SKScene` class is a subclass of SKNode, which is the fundamental building
    block of SpriteKit. Every entity in SpriteKit is inherited or derived from the
    node (SKNode). So `SKScene` is the root node for other nodes, which are used to
    populate the content over a scene.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to UIKit, each node's position is specified according to the coordinate
    system of its parent. A node also has the basic properties that a content item
    or entity should have such as moving, rotating, scaling, fading out, and many
    more. And most important, all node objects are responder objects that respond
    to the delegates of UIResponder. This is used to detect input touches to the scene
    for moving objects and some other stuff depending on one's gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: Now, sprites are represented by SKSpriteNode objects. They are nodes with images
    on them. We can specify content or a textured image to them as we have to make
    some player or enemies in a game. SKSpriteNode is also inherited from SKNode.
    Additionally, its content can be changed and animated. The sprites are created
    and added on scenes with some actions to make the game scene more alive.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand these elements of SpriteKit, we need to create a blank project
    just as we did in the starter project of this chapter. As in this starter kit,
    a basic `SKScene` and `SKNode` are shown. So we will now go through these terminologies
    and their sample code snippets.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we did in the starter kit, follow the same steps to create a `SKScene` and
    add a `SKSpriteNode` method to it:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the SpriteKit Game Template from Xcode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A default ViewController and scene will be created for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Typecast the ViewController view to `SKView` by enabling the `showsFPS` and
    `showsNodeCount` properties to `YES`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a scene using a class method of `SKScene` specifying the size of the
    scene also, and then present that scene on the `SKView` typecasted before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All this should be done in the `- (void)viewWillLayoutSubviews` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now we have to add some sprite to the scene we created earlier. Create an object
    of SKSpriteNode by calling a class method and specifying an image of the sprite.
    Now assign the location where it has to be placed and lastly add it to the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As explained in the structural block diagram of the *How it works...* section
    of the *Learning the basics of SpriteKit – The FlyingSpaceship tutorial* recipe,
    it''s deeply linked with the UIKit framework. For building a game, we should have
    an environment, which is our scene, and some entities visible over the environment,
    which are the sprites. So to make it work, or should I say to make something visible
    on the screen, an environment (that is, scene) is created and on it entities (that
    is, sprites) are added, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we typecast UIView in to `SKView`, we enter the arena of SpriteKit:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For debugging purposes, we enable two Boolean parameters to show FPS (Frames
    per second) and NodesCount (the number of nodes added to the scene):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When creating a scene, we need to specify the size of the scene that is exactly
    the content size and the scale mode so that the scene fits in `SKView` (that is,
    scale perspective), here the `SKSceneScaleModeAspectFill` mode is used so that
    it fits as per the aspect ratio of the `SKView`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make the scene content visible on the view, we present the scene on `SKView`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now about how the sprites work. A sprite object is created by a class method
    that instantiates a node having an image as its content:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following line of code specifies the position where exactly the sprite
    needs to be placed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Anatomy of game projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we will see the basics of a game project. This includes understanding
    the basic architecture and work flow of game projects. Here we will learn about
    the scene and layers and their importance in games.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Complete game development is dependent on three core components: scenes, nodes,
    and sprites mentioned earlier. We need to have a command over these components
    to effectively start on game development.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Internally, the life cycle is executed as per the scenes—nodes are added and
    actions applied on these nodes. It also includes attaching some physics bodies
    to the nodes, support for cropping, applying animation and effects to all or a
    part of the content, detecting forces and collision, drawing in OpenGL, and many
    more things.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from all this, there is an overridden update method in `SKScene`, which
    is called for each frame of the game with the current time interval as a parameter.
    There you can add your actual game logic specifying what to do at what time and
    many more things as it is called by every frame that is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: For an example, we can track the difference in time between the current time
    and the last updated time.
  prefs: []
  type: TYPE_NORMAL
- en: As the current time interval is received in the update method, define the properties
    for difference in time and last updated time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now calculate difference in time by subtracting the last updated time from the
    current time and updating the lastUpdatedTime to the current time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At last the update method looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now this is the place where we are going add our maximum game logic—all the
    adding, removing, animating, updating all nodes, sprites, and actions will take
    place inside this method. We can also take the help of `currentTime` to maintain
    some timers simply using float variables (updating them by the `diffTime` and
    firing time events whenever required according to our game design or logic).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All that we see running on the screen are just frames added by a time interval,
    which is driven by a `SKScene` added as a child on the `SKView` that serves as
    the main scene of the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following diagram, a frame circle is present, which depicts
    the execution cycle of the game project for each frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Some of the methods from the preceding diagram are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: An update method of `SKScene` is called where we can add, remove, animate, and
    update different kinds of nodes and actions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SKScene` evaluates its actions that are running for the current frame following
    some life cycle calls such as `didEvaluateActions`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SKScene` has its own physics simulation, so if some bodies are added to it,
    the physics simulation is also evaluated such as collision detection, applying
    forces, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the methods mentioned earlier contribute to the final rendering of SKView,
    which is displayed as a frame to the user. Hence, regular running of these frames
    makes the game appear as an environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying actions on sprites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sprites are just static images with no life. So actions add that life to the
    sprites that make your game. Actions help in building the gameplay by moving sprites
    and animating them differently. An action is an object that makes the scene look
    alive.
  prefs: []
  type: TYPE_NORMAL
- en: Actions are applied on nodes and sprites, for example, we want to move some
    object that is a sprite, so we create a move action and run it on that sprite.
    SpriteKit automatically changes the sprite's position in a form of animation until
    the action is over.
  prefs: []
  type: TYPE_NORMAL
- en: All actions are implemented using a class called `SKAction` and different types
    of actions are instantiated using the class methods of the `SKAction` class provided
    for various animation functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the most common actions available in SpriteKit:'
  prefs: []
  type: TYPE_NORMAL
- en: Applying transformation (translation, rotation, and scaling)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing visibility (fading in and fading out)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the content of the sprite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the colors of sprites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing sprites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling a block or a selector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeating and sequencing actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To apply different actions on sprites and see them animating, we need to know
    scenes, sprites, and the overall life cycle of a SpriteKit project. We also need
    to know about some fundamental actions that are applied on any entity such as
    move, rotate, scale, and there are many more special effects to explore.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a wide variety of actions to be applied on nodes and sprites, some
    of which are listed next.
  prefs: []
  type: TYPE_NORMAL
- en: To understand this, we will take the spaceship as a sprite to apply different
    actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several individual actions provided by the SpriteKit framework. A
    few of them are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Move Action**: To move a sprite, call the class method shown below, specifying
    the location where the sprite has to be moved and in what time. And then call
    the `runAction` method on the sprite with the move action created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Rotate Action**: To rotate a sprite, we have to specify an angle in radians,
    which will make the sprite rotate by or to that angle in a specified time. So
    specify the angle in degrees, convert to radians, and then feed it to the function
    thereby applying that action to the sprite.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Scale Action**: To scale a sprite, we have to specify a scale factor, which
    will increase or decrease the size of the sprite, depending on the scale factor
    given in a time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Fade Action**: To make a sprite visible or invisible through animation, there
    are methods for fading out and fading in a sprite. For now, fading out is shown
    in the following code, which takes a parameter or the time over which to fadeout.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In SpriteKit, there are many more actions for giving delays, changing content,
    invoking an object or selector, calling blocks, and many special effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the individual actions, there are sequence and repeat actions, which
    fall under a different category of actions provided by SpriteKit. The sequence
    action is meant for running actions in a particular sequence we want. As shown
    in the following code, two actions are created—one for fading out and the other
    for fading in the sprite. So, both the actions are fed to the sequence action
    in the order we want and it would run the sequence we asked for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The repeat action allows actions to be repeated for a fixed number of time or
    to be repeated forever. So using the preceding sequence action, we do both.
  prefs: []
  type: TYPE_NORMAL
- en: 'Animating the sequence for three times regularly:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Animating the sequence repeatedly forever:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Another type of action is the group action. Several times in games we may need
    to repeat a sequence of actions, which means running actions in a particular sequence
    for any interval of time. As shown previously, two actions were created, one for
    fading out and second for fading in the sprite. So, both the actions were fed
    to the sequence action in the order we wanted and it would run the sequence we
    asked for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Group actions are used when we have to run many actions at the same point of
    time. So we can make a group function that moves a sprite by fading out also:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All the actions we have discussed earlier will be working in the same flow.
    Here is the basic anatomy of all actions, which we apply on sprites:'
  prefs: []
  type: TYPE_NORMAL
- en: Decide the actions we want to apply, in what sequence they are to be executed,
    and whether some action needs to be repeated or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each action, whatever the type is, specify its respective parameters and
    the time duration for it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After finalizing the action, just call `runAction` on the sprite to be animated
    with the action constructed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding infinite scrolling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we are all ready with our spaceship. It's time to add some more in the game.
    So our next target is to add infinite scrolling to the game, so that we can make
    our spaceship move infinitely in space. In this recipe, we will be learning about
    the ways to add infinite scrolling to games.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For an infinite scrolling background you need to know about the anatomy of SpriteKit
    shown earlier. You should be aware of the rendering loop, how in a particular
    frame the update method functions, and how `SKScene` evaluates the actions and
    physics simulation thereby rendering all the stuff in the `SKView`. Now using
    this loop, you implement sky scrolling infinitely giving the feel of a spaceship
    flying.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now is the time for action; perform the following steps to add the infinite
    scrolling background to your game.
  prefs: []
  type: TYPE_NORMAL
- en: Import the `SpaceBackground.png` file provided in the `Resources` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a function in `FSMyScene` for initializing the infinite background.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to enable scrolling, we have to add two identical background sprite
    nodes one after the other.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the function, run a `for` loop for two background nodes specifying the position,
    a name (tag), and then adding to `SKMyScene`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hence, the `initalizingScrollingBackground` function looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add this method into the `init` method and also move the code to add a spaceship
    into a different method called `addSpaceship`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In game programming, the layers of objects are made by the sequence they are
    added in. So for the preceding example, the Spaceship should be added after `SpaceBackground`
    giving an appearance that the ship is above the background.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The sequence of the views presented on the screen can be changed by altering
    their *z* coordinate; the view having highest *z* coordinate will always be on
    the top. This means we can explicitly define which layer we want to keep on top
    and which we want to keep at the bottom, which is explained in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The initial background is added but it's not scrolling. This could be accomplished
    by the update method discussed in the *Anatomy of game projects* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For this, some math is required to implement this functionality. Build some
    inline functions and constants to be used for infinitely moving the background.
    This is the code needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Just add these line of code preceding to the implementation of `FSMyScene`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now the real way to do it is, in the update method, iterate all nodes added
    in `FSMyScene`, identify the `SpaceBackground` node by its name assigned in the
    initialization function, and adjust its position to enable infinite scrolling.
    Do all of this in a function named `moveSpaceBackground`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Lastly, call this method every time in the update method of the game scene.
    After that, you should see the spaceship flying in the sky with some nice white
    clouds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Implementation of infinite scrolling is divided into three parts. We need to
    follow the following steps to accomplish infinite scrolling for our game:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initializing the SpaceBackground: Two space backgrounds are added one after
    the other so that they are moved at the same time to give a feel of an infinite
    scrolling background.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SpaceBackground move code: Here, a block method of SKScene is used to iterate
    all nodes of the scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this iteration, the SpaceBGNode is identified by its name so that its position
    can be updated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The amount of distance to be moved is calculated using the `CGPointMultiplyScalar`
    inline function that is fed with the constant value `SPACE_BG_VELOCITY` and the
    difference of time obtained from the update method in each frame.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: After that, the calculated distance is added in the current position of SpaceBGNode.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The last but the most important step to enable scrolling, is to set the position
    of `SpaceBGNode` to the right edge of the screen whenever it reaches the left
    edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The next task is to update each frame to move it infinitely over the scene.
    Now to make it move regularly, the `moveSpaceBackground` method is called in the
    update method of `FSMyScene` in each frame.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The update loop will be executed in every frame. So to move our background in
    every step, we have called the `moveSpaceBackground` method inside the update
    loop. Using this approach of infinite scrolling, we can also implement parallax
    gaming, which is very common nowadays. In parallax scrolling game, there will
    be background and player in separate layers and they will be moving at the same
    time at different speeds. This will give the user a perception of some real-time
    movement of the player against the background.
  prefs: []
  type: TYPE_NORMAL
- en: Moving characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most interesting part is making some character live, which we are going
    to do in this part. We will be detecting a touch on the screen and then applying
    some cool actions on some nodes, that is, moving the spaceship up and down.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make the character move, you should know the basic actions (`SKAction`) that
    can be applied on nodes (`SKNode`).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, as we have got the spaceship moving in infinite space, it''s time to add
    some more fun in the game. We will now be adding the up-down motion to our spaceship.
    Perform the following steps to add the up-down motion to the spaceship:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare some properties for actions, namely up and down actions in `FSMyScene`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Define the distance and over what time the spaceship will move on a screen touch
    just above the implementation of `FSMyScene`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Assign up and down actions to their respective properties in the `addSpaceShip`
    method as added in the starter kit project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now implement a delegate method of `UIResponder`, which detects touches and
    UI Events. The method inputs touches as `NSSet` from which any touch is taken
    and converted into a position with respect to the scene on which the touch event
    occurred.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, using this `touchLocation` and `SpaceShip` position, the code decides when
    to apply an up or a down action on the spaceship. It also checks the bounds of
    the screen so that the spaceship does not move outside the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the code looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever the user taps on the screen, a delegate method of `UIResponder` is
    called.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this method, the position of the touch is converted into local coordinates
    of `SKScene`. Based on the location detected, it is compared to the spaceship
    location and up or down action is applied on it.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, as an outcome of this chapter, you have a small fundamental game with
    an environment of blue sky with white clouds moving with an infinite scroll and
    a spaceship flying up and down in a linear motion.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the game looks like now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There can be a lot of other animation that can be used to animate the ship.
    All the previously discussed animation actions can be used over the ship. A consolidated
    result of these actions can be used in several places in the games. In the next
    chapter, we will learn about the animations in more detail and about effects.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The chapter has already given you insights about the animation that can be done
    on sprites and nodes. You can also visit Apple's developer documentation for more
    details. You have learned enough in the chapter to get you started with the animation
    and actions on the sprites.
  prefs: []
  type: TYPE_NORMAL
