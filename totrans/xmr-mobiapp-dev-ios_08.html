<html><head></head><body>
  <div class="book" title="Chapter&#xA0;8.&#xA0;Threading">
    <div class="book">
      <div class="book">
        <div class="book">
          <h1 class="title"><a class="calibre1" id="ch08"/>Chapter 8. Threading</h1>
        </div>
      </div>
    </div>

    <p class="calibre9">iOS is what is known as a multithreading system, and understanding how threads can be used within an app can be advantageous.</p>

    <p class="calibre9">We will be covering the following topics in this chapter:</p>

    <div class="book">
      <ul class="itemizedlist">
        <li class="listitem">A brief introduction to threading</li>

        <li class="listitem">The main UI thread</li>

        <li class="listitem">A Daughter thread</li>

        <li class="listitem">The AppDelegate class</li>
      </ul>
    </div>

    <div class="book" title="Threading Concepts">
      <div class="book">
        <div class="book">
          <div class="book">
            <h1 class="title"><a class="calibre1" id="ch08lvl1sec33"/>Threading Concepts</h1>
          </div>
        </div>
      </div>

      <p class="calibre9">Let's discuss an easy way to learn threading.</p>

      <p class="calibre9">A single-thread environment can <a class="calibre1" id="id783"/>be considered in the same way as going to your local college. There are a number of routes you can take, but you end up there at some point and the process will take a finite amount of time; you set off, you travel, you arrive.</p>

      <p class="calibre9">A multithreaded environment needs to be thought of as the college itself with each thread being a student. All students start off at 9 a.m. and go until 12 p.m. What they do in between that time may or may not interfere with each other; they will all be doing a task or co-operating on a task to speed up the delivery of an answer. Thirty different threads, all working at once and at different speeds, but at 12 p.m., they all manage to converge and terminate their activities with the jobs done. They repeat the process from 1 p.m. to 4 p.m., and again, there is organized chaos between those hours, but at 4 p.m. everything converges. The lecturer is the one controlling who does what, and in terms of the threading model, is the control thread. <span class="strong"><em class="calibre15">Simple!</em></span></p>

      <p class="calibre9">In terms of iOS development, the lecturer would be classed as the UI thread; it is the one that can start new threads and, at the end of the day, the one where all information needs to be fed back.</p>
    </div>
  </div>


  <div class="book" title="The main UI thread">
    <div class="book">
      <div class="book">
        <div class="book">
          <h1 class="title"><a class="calibre1" id="ch08lvl1sec34"/>The main UI thread</h1>
        </div>
      </div>
    </div>

    <p class="calibre9">As the name suggests, the UI thread <a class="calibre1" id="id784"/>controls the UI. It is usually the hungriest in terms of resources and processor time. Not everything runs on the UI thread. For example, if the UI calls a <a class="calibre1" id="id785"/>method and that method cannot be run on the UI thread (such as the SQLite example listed in <a class="calibre1" href="../Text/part0051.html#page" title="Chapter 11. Handling Data">Chapter 11</a>, <span class="strong"><em class="calibre15">Handling Data</em></span>), then that is what will happen. The code is executed and the flow continues once the method has returned.</p>

    <p class="calibre9">The UI thread should not be mistaken as a single task; <span class="strong"><em class="calibre15">it's not</em></span>. A single task would prohibit any other application running, which we know is not the case (for example, you could be playing Angry Worms and still receive a text message).</p>

    <p class="calibre9"><code class="email">Xamarin.iOS</code> allows non-UI calls to simply jump back onto the UI thread.</p>

    <div class="informalexample">
      <pre class="programlisting">InvokeOnMainThread(delegate () {…});</pre>
    </div>

    <p class="calibre9">Or, if a reference to the thread can't be found (such as being out of scope or in a non-UI thread class), use the following line of code:</p>

    <div class="informalexample">
      <pre class="programlisting">using (var pool = new NSAutoreleasePool()) {
  pool.InvokeOnMainThread(delegate() {
    // do something on the UI thread
  });
}</pre>
    </div>

    <div class="book" title="Deadlocking">
      <div class="book">
        <div class="book">
          <div class="book">
            <h2 class="title1"><a class="calibre1" id="ch08lvl2sec42"/>Deadlocking</h2>
          </div>
        </div>
      </div>

      <p class="calibre9">Something may have crossed your mind <a class="calibre1" id="id786"/>over the description of the multithreaded system. <a class="calibre1" id="id787"/>What happens if all the students don't come back when they should? What happens then? It's a good question as it's something that if you're not careful can hit when dealing with a multithreaded environment. It is known as a deadlock and, literally, it can lock the app and potentially the device (though this is rare). Another problem is threads overwriting the same memory location (think of this as two or more people talking to the lecturer at once; only one voice will be remembered).</p>

      <p class="calibre9">In this example, if the two threads are run within a second of each other, they will both have time to grab the first lock before <a class="calibre1" id="id788"/>anyone gets to the inner lock. Without the <code class="email">Sleep()</code> call, one of the threads would most likely have time to get and release both locks before the other thread even got started.</p>

      <div class="informalexample">
        <pre class="programlisting">// thread 1
lock(typeof(int)) {
  Thread.Sleep(1000);
  lock(typeof(float)) {
    Console.WriteLine("Thread 1 got both locks");
  }
}

// thread 2
lock(typeof(float)) {
  Thread.Sleep(1000);
  lock(typeof(int)) {
    Console.WriteLine("Thread 2 got both locks");
  }
}</pre>
      </div>
    </div>

    <div class="book" title="Avoiding deadlocks for synchronized accessors">
      <div class="book">
        <div class="book">
          <div class="book">
            <h2 class="title1"><a class="calibre1" id="ch08lvl2sec43"/>Avoiding deadlocks for synchronized accessors</h2>
          </div>
        </div>
      </div>

      <p class="calibre9">A simple way to avoid this form of <a class="calibre1" id="id789"/>deadlock is for each holding class to have its own private deadlock. The problem along with its solution is described well on MSDN (<a class="calibre1" href="http://msdn.microsoft.com/en-us/library/orm-9780596516109-03-18.aspx">http://msdn.microsoft.com/en-us/library/orm-9780596516109-03-18.aspx</a>).</p>
    </div>
  </div>


  <div class="book" title="Starting a new thread from the main UI thread">
    <div class="book">
      <div class="book">
        <div class="book">
          <h1 class="title"><a class="calibre1" id="ch08lvl1sec35"/>Starting a new thread from the main UI thread</h1>
        </div>
      </div>
    </div>

    <p class="calibre9">A new thread coming <a class="calibre1" id="id790"/>from an existing thread is known as a daughter thread.</p>

    <p class="calibre9">A very simple way to add a daughter <a class="calibre1" id="id791"/>thread on an iOS device is like this. I have first created a simple UI to show what is happening. The top label is called thread 1, the bottom label is called thread 2.</p>

    <div class="mediaobject"><img alt="Starting a new thread from the main UI thread" class="calibre11" src="../Images/00038.jpeg"/></div>

    <p class="calibre12"/>

    <p class="calibre9">The code also <a class="calibre1" id="id792"/>shows <code class="email">InvokeOnMainThread</code> in action—without it the app fails:</p>

    <div class="informalexample">
      <pre class="programlisting">using System.Threading;
...
private int i = 0;

public override void ViewDidLoad() {
  base.ViewDidLoad();
  var first = new Thread(new ThreadStart(firstThread));
  var second = new Thread(new ThreadStart(secondThread));
  btnStart.TouchUpInside += delegate {
    first.Start();
    Thread.Sleep(10);
// causes a 10ms delay between starting the next thread

    second.Start();
  };
}

private void firstThread() {
  string text = string.Empty;
  while (i &lt; 10) {
    text = string.Format("1st thread going i from {0} to {1}",i, ++i);
    InvokeOnMainThread(delegate() {thread1.Text = text;
    });
    Thread.Sleep(100);
  }
}

private void secondThread() {
  string text = string.Empty;
  while (i &lt; 10) {
    text = string.Format("2nd thread going i from {0} to {1}",i, ++i);
    InvokeOnMainThread(delegate() {
      thread2.Text = text;
    });
    Thread.Sleep(100);
  }
}</pre>
    </div>

    <p class="calibre9">And when run, the simulator <a class="calibre1" id="id793"/>gives the following <a class="calibre1" id="id794"/>output:</p>

    <div class="mediaobject"><img alt="Starting a new thread from the main UI thread" class="calibre11" src="../Images/00039.jpeg"/></div>

    <p class="calibre12"/>

    <p class="calibre9">Run this a number of times and you get a number of different results. The threads are performing operations on the UI at different times; this shows the problem with threading quite well. If the UI was waiting for thread 1 to finish but thread 2 finishes, then it's not going to know what is going on.</p>

    <p class="calibre9">In this case, the code can be <a class="calibre1" id="id795"/>sanitized by using a lock.</p>

    <div class="book" title="Using locks">
      <div class="book">
        <div class="book">
          <div class="book">
            <h2 class="title1"><a class="calibre1" id="ch08lvl2sec44"/>Using locks</h2>
          </div>
        </div>
      </div>

      <p class="calibre9">Be careful when using locks is <a class="calibre1" id="id796"/>probably the first thing that needs to be said. A lock is used to <a class="calibre1" id="id797"/>synchronize the threads and obtain a far saner output.</p>

      <div class="informalexample">
        <pre class="programlisting">private int i = 0;
private object lock_i = new object();
public override void ViewDidLoad() {
  base.ViewDidLoad();
  var first = new Thread(new ThreadStart(firstThread));
  var second = new Thread(new ThreadStart(secondThread));
  btnStart.TouchUpInside += delegate {
    first.Start();
    Thread.Sleep(10);
    // causes a 10ms delay between starting the next thread

        second.Start();
  };
}
private void firstThread() {
  string text = string.Empty;
  do {
    lock(this.lock_i) {
      if (i &gt;= 10) return;
      text = string.Format("1st thread going i from {0} to {1}",i, ++i);
      InvokeOnMainThread(delegate() {
        thread1.Text = text;
      });
    }
    Thread.Sleep(100);
  }
  while(true);
}
private void secondThread() {
  string text = string.Empty;
  do {
    lock(this.lock_i) {
      if (i &gt;= 10) return;
      text = string.Format("2nd thread going i from {0} to {1}",i, ++i);
      InvokeOnMainThread(delegate() {
        thread2.Text = text;
      });
    }
    Thread.Sleep(100);
  }
  while(true);
}</pre>
      </div>

      <p class="calibre9">This time when the app is run, the threads <a class="calibre1" id="id798"/>are synchronized and the result is always the same. <a class="calibre1" id="id799"/>Using this locking system, the app is free to use as many threads as it needs to get whatever done off the UI thread.</p>

      <div class="mediaobject"><img alt="Using locks" class="calibre11" src="../Images/00040.jpeg"/></div>

      <p class="calibre12"/>
    </div>
  </div>


  <div class="book" title="The AppDelegate class">
    <div class="book">
      <div class="book">
        <div class="book">
          <h1 class="title"><a class="calibre1" id="ch08lvl1sec36"/>The AppDelegate class</h1>
        </div>
      </div>
    </div>

    <p class="calibre9">It may seem odd having the <a class="calibre1" id="id800"/> <code class="email">AppDelegate</code> class described here, but it fits. The <code class="email">AppDelegate</code> class is known as a singleton class. It's used once and once only with everything coming from it. Consider it as the über thread; without it, nothing else happens.</p>

    <p class="calibre9">I've given the <code class="email">AppDelegate</code> class a more thorough handling in <a class="calibre1" href="../Text/part0031.html#page" title="Chapter 5. UI Controls">Chapter 5</a>, <span class="strong"><em class="calibre15">UI Controls</em></span> and, after reading this chapter, you should have a clearer idea of its importance.</p>
  </div>


  <div class="book" title="Summary">
    <div class="book">
      <div class="book">
        <div class="book">
          <h1 class="title"><a class="calibre1" id="ch08lvl1sec37"/>Summary</h1>
        </div>
      </div>
    </div>

    <p class="calibre9">Threading within an iOS application can make up for a more responsive user experience, but at the same time, for the developer it can be the reason for many a late nights trying to figure out why something is crashing at random times or just seizes up for no real reason. Be careful with threads, they can be both a pain and a pleasure.</p>
  </div>
</body></html>