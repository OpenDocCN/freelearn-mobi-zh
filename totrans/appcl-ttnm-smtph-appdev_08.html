<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Interacting with Native Phone Applications and APIs</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating an Android Options menu</li><li class="listitem" style="list-style-type: disc">Accessing the contacts address book</li><li class="listitem" style="list-style-type: disc">Storing and retrieving data via the clipboard</li><li class="listitem" style="list-style-type: disc">Creating a background service on the iPhone</li><li class="listitem" style="list-style-type: disc">Displaying local notifications on the iPhone</li><li class="listitem" style="list-style-type: disc">Displaying Android notifications using intents</li><li class="listitem" style="list-style-type: disc">Storing your Android app on the device's SD-card</li></ul></div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec01"/>Introduction</h1></div></div></div><p>While Titanium allows you to create native apps that are almost totally cross-platform, it is inevitable that some devices will inherently have operating system and hardware differences that are specific to them (particularly between Android and iOS). For example, anyone who has used both Android and iPhone devices would immediately recognize the very different way the notification systems are set up. However, there are other platform-specific limitations that are very specific to the Titanium API.</p><p>In this chapter, we'll show you how to create and use some of these device-specific components and APIs in your applications. Unlike most chapters in this book, this one does not follow a singular, coherent application. So feel free to read each recipe in whichever order you wish.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec02"/>Creating an Android Options menu</h1></div></div></div><p>Option menus are an important part of the Android user interface. They are the primary collection of menu items for a screen and appear when the user presses the<strong> MENU</strong> button on their device. In this recipe we are going to create an Android Options Menu and add it to our screen, giving each option its own click event with an action.<a id="id288" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec01"/>Getting ready</h2></div></div></div><p>To prepare for this recipe, and all recipes in this chapter, open up Titanium Studio and log in if you have not already done so. You can either use the same application for each of the recipes in this chapter or create a new one, the choice is up to you.<a id="id289" class="indexterm"/>
</p><div><h3 class="title"><a id="note54"/>Note</h3><p>The icons and code for this application is available in the<code class="literal"> Chapter 8/Recipe 1</code> folder.</p><p>Complete source code for this recipe can be found in the<code class="literal"> /Chapter 8/Recipe 1</code> folder.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec02"/>How to do it…</h2></div></div></div><p>Open up the<code class="literal"> app.js</code> file in your IDE and enter in the following code:</p><div><pre class="programlisting">//create the root window
var win1 = Titanium.UI.createWindow({
title: 'Android Options Menu',
backgroundColor: '#ccc'
});
if(Titanium.Platform.osname == 'android')
{
//references the current android activity
var activity = Ti.Android.currentActivity;
//create our menu
activity.onCreateOptionsMenu = function(e) {
var menu = e.menu;
//menu button 1
var menuItem1 = menu.add({ title: "Item 1" });
menuItem1.setIcon("item1.png");
menuItem1.addEventListener("click", function(e) {
alert("Menu item #1 was clicked");
});
//menu button 2
var menuItem2 = menu.add({
title: "Show Item #4",
itemId: 2
});
menuItem2.setIcon("item2.png");
menuItem2.addEventListener("click", function(e) {
menu.findItem(4).setVisible(true);
});
//menu button 3
var menuItem3 = menu.add({ title: "Item 3" });
menuItem3.setIcon("item3.png");
menuItem3.addEventListener("click", function(e) {
alert("Menu item #3 was clicked");
});
//menu button 4 (will be hidden)
var menuItem4 = menu.add({
title: "Hide Item #4",
itemId: 4
});
menuItem4.setIcon("item4.png");
menuItem4.addEventListener("click", function(e) {
menu.findItem(4).setVisible(false);
});
};
//turn off the item #4 by default
activity.onPrepareOptionsMenu = function(e) {
var menu = e.menu;
menu.findItem(4).setVisible(false);
};
}
win1.open();
</pre></div><p>Build and run your application in the Android emulator for the first time. When you press the "menu" button on your device/emulator you should end up seeing a screen that looks just like the following example. Tapping on the first menu item should execute its click event and show you an alert dialog. An example of this can be seen in the following screenshot:<a id="id290" class="indexterm"/>
</p><div><img src="img/3968EXP_08_01.jpg" alt="How to do it…"/></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec03"/>How it works…</h2></div></div></div><p>First, it is important to note that the code in this recipe is applicable to Android only. The iOS platform doesn't have a physical menu button like an Android device, and therefore doesn't have an Option menu. On Android, these menus help to facilitate user actions. We can see this occurring in the<code class="literal"> click</code> event of the first menu item, where we are using an event handler to capture this event and show a simple alert dialog.</p><p>The fourth option in the menu is altered by utilizing the "<strong>onPrepareOptionsMenu</strong>" event, which is executed prior to the menu being added to the screen. You can enable, disable, add, or remove items within this event handler. In this recipe, we are hiding the fourth menu option by setting its<code class="literal"> visible</code> state to<em> false</em>, which we can change again to<em> true</em> within the event handler of the second menu option.<a id="id291" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec04"/>Menu icon sizes for Android devices</h2></div></div></div><p>Your menu icons should be flat, pictured "face on", and greyscale. According to the Android guidelines, all menu icons should use the same color palette and effects in order to maintain consistency. Icon sizes for each of the Android screen density sizes are listed below.<a id="id292" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Menu icon dimensions for high-density (hdpi) screens:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Full Asset: 72 x 72 px</li><li class="listitem" style="list-style-type: disc">Icon: 48 x 48 px</li><li class="listitem" style="list-style-type: disc">Square Icon: 44 x 44 px</li></ul></div></li><li class="listitem" style="list-style-type: disc">Menu icon dimensions for medium-density (mdpi) screens:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Full Asset: 48 x 48 px</li><li class="listitem" style="list-style-type: disc">Icon: 32 x 32 px</li><li class="listitem" style="list-style-type: disc">Square Icon: 30 x 30 px</li></ul></div></li><li class="listitem" style="list-style-type: disc">Menu icon dimensions for low-density (ldpi) screens:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Full Asset: 36 x 36 px</li><li class="listitem" style="list-style-type: disc">Icon: 24 x 24 px</li><li class="listitem" style="list-style-type: disc">Square Icon: 22 x 22</li></ul></div></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec03"/>Accessing the contacts address book</h1></div></div></div><p>There will be times when you want the user to access existing data from their device in order to populate some fields or a database within your own application. Possibly, the best example of this is the utilization of the address book and contact details. For example, if you built an application that primarily was meant for sharing data over e-mail, using the contact address book on the device would allow the user to select contacts they already have from a selection list (as opposed to having to remember or re-enter the data separately).<a id="id293" class="indexterm"/>
</p><p>In this recipe, we'll create a basic interface that accesses our address book and pulls back a contact's details, filling in our interface components including some text fields and an image view as we do so. Before you start, make sure your device or emulator has some contacts available in it by choosing the<em> Contacts</em> icon on iPhone or the<em> People</em> icon on Android and adding at least one entry.<a id="id294" class="indexterm"/>
</p><div><h3 class="title"><a id="note55"/>Note</h3><p>Complete source code for this recipe can be found in the<code class="literal"> /Chapter 8/Recipe 2</code> folder.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec05"/>How to do it…</h2></div></div></div><p>Open up the<code class="literal"> app.js</code> file in your IDE and enter in the following code:</p><div><pre class="programlisting">//create the root window
var win1 = Titanium.UI.createWindow({
title: 'Android Options Menu',
backgroundColor: '#ccc'
});
//add the textfields
var txtName = Titanium.UI.createTextField({
width: 280,
top: 150,
left: 20,
height: 40,
backgroundColor: '#fff',
borderRadius: 3,
hintText: 'Friend\'s name...',
paddingLeft: 3
});
win1.add(txtName);
var txtEmail = Titanium.UI.createTextField({
width: 280,
top: 200,
left: 20,
height: 40,
backgroundColor: '#fff',
borderRadius: 3,
hintText: 'Contact\'s email address...',
paddingLeft: 3,
keyboardType: Titanium.UI.KEYBOARD_EMAIL
});
win1.add(txtEmail);
//this is the user image
var imgView = Titanium.UI.createImageView({
width: 80,
left: 20,
height: 80,
top: 45,
image: 'no_avatar.gif'
});
win1.add(imgView);
var contactButton = Titanium.UI.createButton({
title: 'Select a contact...',
left: 20,
top: 10,
height: 28,
width: 280
});
contactButton.addEventListener('click', function(e){
//
//if array of details is specified, the detail view will be
//shown
//when the contact is selected. this will also trigger
//e.key, and e.index in the success callback
//
Titanium.Contacts.showContacts({
selectedProperty: function(e) {
Ti.API.info(e.type + ' - '+ e.value);
txtEmail.value = e.email;
},
selectedPerson: function(e) {
var person = e.person;
txtEmail.value = person.email.home[0];
if (person.image != null) {
imgView.image = person.image;
}
else {
imgView.image = 'no_avatar.gif';
avatar = 'no_avatar.gif';
}
txtName.value = person.firstName + ' ' + person.lastName;
}
});
});
win1.add(contactButton);
win1.open();
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec06"/>How it works…</h2></div></div></div><p>Access to the address book differs depending on the platform. On the Android operating system you will have read-only access to the contacts list, whereas on the iPhone you will have full read/write privileges. Therefore, it pays to keep in mind that methods such as<code class="literal"> createPerson</code> will not be available for use on Android devices.<a id="id295" class="indexterm"/>
</p><p>All access to the device's contacts are available through the<code class="literal"> Titanium.Contacts</code> namespace. In this recipe, we built a basic screen with some text fields and an image view, which we're populating by loading up the contacts API and choosing an entry from the device's contact list. To do this, we are executing the<code class="literal"> showContacts()</code> method, which has two distinct callback functions:<a id="id296" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem"><code class="literal"> SelectedProperty:</code> This callback is executed when the user chooses a person's property, rather than a singular contact entry<a id="id297" class="indexterm"/></li><li class="listitem"><code class="literal"> SelectedPerson:</code> This call-back is executed when the user chooses a person's entry<a id="id298" class="indexterm"/></li></ol></div><p>In our example recipe, we are utilizing the<code class="literal"> SelectedPerson</code> function and assigning the callback property<code class="literal"> (e)</code> to a new object named<code class="literal"> person</code>. From here we can access the<code class="literal"> field</code> properties of the contact that were chosen from the device's contact list, such as phone, e-mail, name, and contact photograph, and then assign these variables to the relevant fields in our own application. The following screenshots show the contact's screen both empty and filled out after choosing a contact from the device's list:</p><div><img src="img/3968EXP_08_02.jpg" alt="How it works…"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec04"/>Storing and retrieving data via the clipboard</h1></div></div></div><p>The clipboard is used to store textual and object data so it can be utilized between different screens and applications on your device. While both iOS and Android have built-in clipboard capability, Titanium extends this by letting you programmatically access and write data to the clipboard. In this recipe, we will create a screen with two text fields and a series of buttons that allow us to programmatically copy data from one text field and paste it into another.<a id="id299" class="indexterm"/>
</p><div><h3 class="title"><a id="note56"/>Note</h3><p>Complete source code for this recipe can be found in the<code class="literal"> /Chapter 8/Recipe 3</code> folder.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec07"/>How to do it…</h2></div></div></div><p>Open your project's<code class="literal"> app.js</code> file in your IDE and enter in the following code (deleting any existing code). When finished, run your application in the emulator to test it.<a id="id300" class="indexterm"/>
</p><div><pre class="programlisting">var win1 = Titanium.UI.createWindow({
backgroundColor: '#fff',
title: 'Copy and Paste'
});
var txtData1 = Titanium.UI.createTextField({
left: 20,
width: 280,
height: 40,
top: 10,
borderStyle:Titanium.UI.INPUT_BORDERSTYLE_ROUNDED
});
var txtData2 = Titanium.UI.createTextField({
left: 20,
width: 280,
height: 40,
top: 60,
borderStyle:Titanium.UI.INPUT_BORDERSTYLE_ROUNDED
});
var copyButton = Titanium.UI.createButton({
title: 'Copy',
width: 80,
height: 30,
left: 20,
top: 140
});
var pasteButton = Titanium.UI.createButton({
title: 'Paste',
width: 80,
height: 30,
left: 120,
top: 140,
visible: false
});
var clearButton = Titanium.UI.createButton({
title: 'Clear',
width: 80,
height: 30,
right: 20,
top: 140
});
function copyTextToClipboard() {
Ti.UI.Clipboard.setText(txtData1.value);
copyButton.visible = false;
pasteButton.visible = true;
}
function pasteTextFromClipboard() {
txtData2.value = Ti.UI.Clipboard.getText();
txtData1.value = '';
copyButton.visible = true;
pasteButton.visible = false;
}
function clearTextFromClipboard() {
Ti.UI.Clipboard.clearText();
}
copyButton.addEventListener('click', copyTextToClipboard);
pasteButton.addEventListener('click', pasteTextFromClipboard);
clearButton.addEventListener('click', clearTextFromClipboard);
win1.add(txtData1);
win1.add(txtData2);
win1.add(copyButton);
win1.add(pasteButton);
win1.add(clearButton);
win1.open();
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec08"/>How it works…</h2></div></div></div><p>In this recipe we are copying simple strings to and from the clipboard. However, it is important to note that you can also copy objects using the<code class="literal"> Ti.UI.Clipboard.setObject()</code> method. There are two methods we are utilizing in order to copy data to and from the clipboard,<code class="literal"> setText()</code> and<code class="literal"> getText()</code>, which do exactly the function they both describe. We are setting the text in the clipboard from our first text field using the<strong> Copy</strong> button, and then pasting that same text programmatically into the second text field using the<strong> Paste</strong> button. Using the clipboard has many uses, but the most important one is its ability to let users share data provided by your application with other applications on their device (as seen in the following screenshots). As an example, you may provide a "copy" button for an e-mail address that can then be copied and pasted by the user into their local e-mail client, such as Mobile Mail or Google Gmail.<a id="id301" class="indexterm"/>
</p><div><img src="img/3968EXP_08_03.jpg" alt="How it works…"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec05"/>Creating a background service on the iPhone</h1></div></div></div><p>Apple now supports background services in iOS 4 and above, meaning your apps can now run code in the background much like Android apps are able to. In this recipe we are going to create a background service, which will execute a set piece of code from a separate file called<code class="literal"> bg.js</code>. We will also log each stage of the background service cycle to the console so you can understand each process.<a id="id302" class="indexterm"/>
</p><div><h3 class="title"><a id="note57"/>Note</h3><p>Complete source code for this recipe can be found in the<code class="literal"> /Chapter 8/Recipe 4</code> folder.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec09"/>How to do it…</h2></div></div></div><p>Open your project's<code class="literal"> app.js</code> file in your IDE and enter in the following code (deleting any existing code):</p><div><pre class="programlisting">//create root window
var win1 = Titanium.UI.createWindow({
backgroundColor: '#fff',
title: 'Background Services'
});
function validiOSPlatform() {
//add iphone checks
if (Titanium.Platform.osname == 'iphone')
{
var version = Titanium.Platform.version.split(".");
var major = parseInt(version[0],0);
//can only test this support on ios 4+
if (major &gt;= 4) {
return true;
}
}
//either we're not running ios or platform is old
return false;
}
if (validiOSPlatform() == true) {
//register a background service.
//this JS will run when the app is backgrounded
var service =
Ti.App.iOS.registerBackgroundService({url:'bg.js'});
Ti.API.info("registered background service = " + service);
//fired when an app is resuming for suspension
Ti.App.addEventListener('resume',function(e){
Ti.API.info("App is resuming from the background");
});
//fired when an app has resumed
Ti.App.addEventListener('resumed',function(e){
Ti.API.info("App has resumed from the background");
});
//fired when an app is paused
Ti.App.addEventListener('pause',function(e){
Ti.API.info("App was paused from the foreground");
});
}
//finally, open the window
win1.open();
</pre></div><p>Now create a new file called<code class="literal"> bg.js</code> and save it to your project's<code class="literal"> Resources</code> folder, then type in the following code. This is the code we are going to execute via our background service:<a id="id303" class="indexterm"/>
</p><div><pre class="programlisting">Ti.API.info("This line was executed from a background service!");
</pre></div><p>When finished, run your application in the emulator to test it.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec10"/>How it works…</h2></div></div></div><p>There are two major steps being undertaken with this recipe. The first is ensuring that the device we're currently running is indeed an iPhone (iOS) device, and second, that it is running the required iOS 4+ operating system. The<code class="literal"> validiOSPlatform()</code> function performs this task and returns a simple Boolean true/false response which indicates whether to proceed with registering our background service or not.<a id="id304" class="indexterm"/>
</p><p>The second part is registering our background service using the file<code class="literal"> bg.js</code> as the code we wish to execute when the application becomes "backgrounded". In this situation, the code in our background service file will fire and log an information message to the console. All of the application pause and resume event listeners are also handled in this example. Therefore, you can run the application in the emulator, open it, exit it, and re-open it again to see each of the event handler fire, and log the matching message to the console.</p><div><img src="img/3968EXP_08_04.jpg" alt="How it works…"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec06"/>Displaying local notifications on the iPhone</h1></div></div></div><p>Another post iOS 4+ feature was the introduction of local notifications which allowed the developer to create basic notification alerts that looked and acted similar to<strong> Push</strong> notifications, but without the hassle of creating all of the certificates and server-side code necessary for Push to work. In this recipe, we are going to extend the previous code that we wrote for our background service, and create a local notification when the app is pushed to the background of the system.<a id="id305" class="indexterm"/>
</p><div><h3 class="title"><a id="note58"/>Note</h3><p>Complete source code for this recipe can be found in the<code class="literal"> /Chapter 8/Recipe 5</code> folder.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec11"/>How to do it…</h2></div></div></div><p>Open your project's<code class="literal"> bg.js</code> file from the previous recipe, and extend it by adding in the following code:</p><div><pre class="programlisting">var notification = Ti.App.iOS.scheduleLocalNotification({
alertBody: 'Hey, this is a local notification!',
alertAction: "Answer it!",
userInfo: {"Hello": "world"},
date: new Date(new Date().getTime())
});
</pre></div><p>Now in your<code class="literal"> app.js</code> file, create the following event listener and handler. It will execute whenever your<strong> Answer It</strong> confirmation button is pushed during the background process:</p><div><pre class="programlisting">//listen for a local notification event
Ti.App.iOS.addEventListener('notification', function(e)
{
Ti.API.info("Local notification received: "+ JSON.stringify(e));
alert('Your local notification caused this event to fire!');
});
</pre></div><p>When you are finished, run your application in the emulator to test it. You should be able to "background", or pause, the application after it starts running (by pressing the "home" button on your iPhone) and receive a local notification. Tapping on<strong> Answer It</strong> will reload your app and cause our "notification' event listener to fire (as seen in the following screenshots)!<a id="id306" class="indexterm"/>
</p><div><img src="img/3968EXP_08_05.jpg" alt="How to do it…"/></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec12"/>How it works…</h2></div></div></div><p>A local notification consists of a number of parameters, including:<a id="id307" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">alertBody:</code> The message that appears in your alert dialog<a id="id308" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">alertAction:</code> The right-hand button that executes your application<a id="id309" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">userInfo:</code> The data you wish to pass back to your app<a id="id310" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">date:</code> When to execute the notification<a id="id311" class="indexterm"/></li></ul></div><p>Our example is using the current date and time, meaning the notification will appear momentarily after the application has become "backgrounded". When the notification appears, the user can then either cancel it, or use our custom "action" button to re-launch the app and execute our "notification" event handler.<a id="id312" class="indexterm"/>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec07"/>Displaying Android notifications using intents</h1></div></div></div><p>Intents are the Android terminology for an operation that is to be performed on the system. Most significantly, it is used for launching activities. The primary parameters of an intent are:<a id="id313" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem">The "action": A general action to be performed, such as<code class="literal"> ACTION_VIEW</code></li><li class="listitem">The "data": The data to operate the action on, such as database record or contact person data</li></ol></div><p>In this recipe we are going to use intents in conjunction with Android's Notification Manager in order to create a local notification which will appear in our user's Android notification bar.</p><div><h3 class="title"><a id="note59"/>Note</h3><p>Complete source code for this recipe can be found in the<code class="literal"> /Chapter 8/Recipe 6</code> folder.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec13"/>How to do it…</h2></div></div></div><p>You will need the package identifier (in the format of<em> com.yourcompany.yourapp—you</em> can find it on the<strong> Edit</strong> tab in Titanium Studio) and the class name of your Android app. You can find the class name by opening the<code class="literal"> Build/Android</code> folder in your project, and then opening the<code class="literal"> Android.manifest.xml</code> file contained within. Under the<code class="literal"> application</code> node you will find a section that looks like the following:<a id="id314" class="indexterm"/>
</p><div><pre class="programlisting">&lt;activity
android:name=".NativeapisActivity"
android:label="NativeAPIs"
android:theme="@style/Theme.Titanium"
android:configChanges="keyboardHidden|orientation"
&gt;
...
</pre></div><p>Your<code class="literal"> className</code> property is a combination of your application identifier and the<code class="literal"> android:name</code> attribute in the previous XML. In our case, this<code class="literal"> className</code> property is<code class="literal"> com.boydlee.nativeapis.NativeapisActvitity</code>.</p><p>With these two values written down, open your project's<code class="literal"> app.js</code> file in your IDE and enter in the following code (deleting any existing):<a id="id315" class="indexterm"/>
</p><div><pre class="programlisting">//create root window
var win1 = Titanium.UI.createWindow();
if(Titanium.Platform.osname == 'android')
{
var intent = Titanium.Android.createIntent({
action: Titanium.Android.ACTION_MAIN,
className: 'com.boydlee.nativeapis.NativeapisActivity',
packageName: 'com.boydlee.nativeapis'
});
intent.addCategory(Titanium.Android.CATEGORY_LAUNCHER);
var pending = Titanium.Android.createPendingIntent({
activity: Titanium.Android.currentActivity,
intent: intent,
type:
Titanium.Android.PENDING_INTENT_FOR_ACTIVITY,
flags: Titanium.Android.FLAG_ACTIVITY_NEW_TASK
});
var notification =
Titanium.Android.createNotification({
contentIntent: pending,
contentTitle: 'New Notification',
contentText: 'Hey there Titanium Developer!!',
tickerText: 'You have a new Titanium message...',
ledARGB: 1,
number: 1,
when: new Date().getTime()
});
Ti.Android.NotificationManager.notify(1,
notification);
}
//finally, open the window
win1.open();
</pre></div><p>When finished, run your application in the Android emulator to test it. Once your application has launched you should be able to then exit and pull down the Android notification bar to see the results.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec14"/>How it works…</h2></div></div></div><p>In this recipe we are using intents and activities in conjunction with a notification message. The<code class="literal"> notification</code> object itself is relatively simple. It takes in a number of parameters including the title and message of the notification, along with a badge<code class="literal"> number</code> and<code class="literal"> when</code> parameter (the<code class="literal"> datetime</code> that the notification will show, which we have set to the default value 'now'). The<code class="literal"> ledARGB</code> parameter is the color to flash on the device LED, which we have set to the device default.<a id="id316" class="indexterm"/>
</p><p>You'll notice that we also added a category to our intent, using the<code class="literal"> addCategory</code> method, such as<code class="literal"> intent.addCategory(Titanium.Android.CATEGORY_LAUNCHER)</code>;. In our example, we used<code class="literal"> CATEGORY_LAUNCHER</code>, which means that our intent should appear in the Launcher as a top-level application.</p><p>Coupled with our notification is an object called<code class="literal"> pending</code>. This is our<em> intent</em>, and that intent has been written in order to launch an<em> activity</em>. In our case, the activity is to launch our application again. You can also add URL properties to intents so that your application can launch specific code on re-entry.</p><p>The following screenshot shows an example of our notification message in action:</p><div><img src="img/3968EXP_08_06.jpg" alt="How it works…"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec08"/>Storing your Android app on the device's SD card</h1></div></div></div><p>One of the downsides to Titanium is that, due to its compilation process, applications built on the Titanium platform tend to be rather large in file size in comparison to a native app. Most simple apps in Titanium will range from between 4-5 megabytes in size. This is not really a problem for an iPhone, but unfortunately many Android devices utilize SD card memory and do not have much in the way of local phone storage space.<a id="id317" class="indexterm"/>
</p><p>In this recipe, we will show you how to configure your Android application in order for it to run on the SD card, via Android's<strong> Move to SD card</strong> button in the application settings screen.</p><div><h3 class="title"><a id="note60"/>Note</h3><p>Complete source code for this recipe can be found in the<code class="literal"> /Chapter 8/Recipe 7</code> folder.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec15"/>How to do it…</h2></div></div></div><p>Open the<code class="literal"> tiapp.xml</code> file under your project's root directory and find the<code class="literal">&lt;android&gt;</code> node in the XML which will be located near the bottom of the file. Alter the<code class="literal">&lt;android&gt;</code> node so it looks like the following code:<a id="id318" class="indexterm"/>
</p><div><pre class="programlisting">&lt;android &gt;
&lt;tool-api-level&gt;8&lt;/tool-api-level&gt;
&lt;manifest android:installLocation="preferExternal"&gt;
&lt;uses-sdk android:minSdkVersion="7" /&gt;
&lt;/manifest&gt;
&lt;/android&gt;
</pre></div><p>Now build and run your application on your Android device. Note that this may not work in the emulator.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec16"/>How it works…</h2></div></div></div><p>There are a few important parts to understand in relation to this XML configuration. The first is that the<code class="literal">&lt;tool-api-level&gt;</code> node value is actually referring to the minimum version of the Android tools required. Version 8 is the minimum needed to enable the external storage functionality.</p><p>The<code class="literal">&lt;android:installLocation&gt;</code> attribute refers to the initial storage of the application upon installation. Here we are telling the Android OS that we prefer it to be stored externally to an SD card. However, if one is unavailable, the app will be stored directly to the phone memory. You can also use a value of<code class="literal"> internalOnly</code>, which would disallow the app from being installed on external memory.</p><p>Finally, the<code class="literal">&lt;uses-sdk&gt;</code> node refers to the version of Android required. Version 7 in this case refers to Android 2.1 and up, which is required in order to perform the<strong> Copy To SD-Card</strong> action.</p></div></div></body></html>