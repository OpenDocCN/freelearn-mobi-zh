<html><head></head><body>
		<div id="_idContainer028">
			<h1 id="_idParaDest-48"><em class="italic"><a id="_idTextAnchor051"/>Chapter 4</em>: Testing Kotlin Coroutines</h1>
			<p>In the previous chapter, you learned about coroutine cancelations and how you can make your coroutines cancelable. You then learned about coroutine timeouts in milliseconds or <strong class="bold">Duration</strong>. Finally, you learned about exceptions and how you can handle them using <strong class="source-inline">try-catch</strong> and <strong class="source-inline">CoroutineExceptionHandler</strong>.</p>
			<p>Creating tests is an important part of app development. The more code you write, the higher the chance that there will be bugs and errors. With tests, you can ensure your application works as you have programmed it. You can quickly discover issues and fix them immediately. Tests can make development easier, saving you time and resources. They can also help you refactor and maintain your code with confidence.</p>
			<p>In this chapter, you will learn how to test Kotlin coroutines in Android. First, we will update the Android project for testing. We will then proceed with learning the steps to create tests for Kotlin coroutines. </p>
			<p>In this chapter, we are going to cover the following topics:</p>
			<ul>
				<li>Setting up an Android project for testing coroutines</li>
				<li>Unit testing suspending functions</li>
				<li>Testing coroutines</li>
			</ul>
			<p>By the end of this chapter, you will understand coroutine testing. You will be able to write and run unit and integration tests for the coroutines in your Android applications.</p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor052"/>Technical requirements</h1>
			<p>You will need to download and install the latest version of Android Studio. You can find the latest version at <a href="https://developer.android.com/studio">https://developer.android.com/studio</a>. For an optimal learning experience, a computer with the following specifications is recommended: </p>
			<ul>
				<li>Intel Core i5 or equivalent or higher </li>
				<li>4 GB RAM minimum </li>
				<li>4 GB available space</li>
			</ul>
			<p>The code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows/tree/main/Chapter04">https://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows/tree/main/Chapter04</a>.</p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor053"/>Setting up an Android project for testing coroutines</h1>
			<p>In <a id="_idIndexMarker161"/>this section, we will start by looking <a id="_idIndexMarker162"/>at how you can update your Android app to make it ready for adding and running tests. Once your project is properly set up, it will be easy to add unit and integration tests for your coroutines.</p>
			<p>When creating unit tests on Android, you must have the <strong class="bold">JUnit 4</strong> testing framework<a id="_idIndexMarker163"/> in your project. JUnit<a id="_idIndexMarker164"/> is a unit testing framework for Java. It should be automatically included in the <strong class="source-inline">app/build.gradle</strong> dependencies when creating a new Android project in Android Studio. </p>
			<p>If your Android project does not have JUnit 4 yet, you can add it by including the following to your <strong class="source-inline">app/build.gradle</strong> dependencies:</p>
			<pre class="source-code">dependencies {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    testImplementation ‘junit:junit:4.13.2’</pre>
			<pre class="source-code">}</pre>
			<p>This allows you to use the JUnit 4 framework for your unit tests.</p>
			<p>To create mock objects for your tests, you can also use mocking libraries. Mockito is the most popular Java mocking library, and you can use it on Android. To add Mockito to your tests, add the following to the dependencies in your <strong class="source-inline">app/build.gradle</strong> file:</p>
			<pre class="source-code">dependencies {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    testImplementation ‘org.mockito:mockito-core:4.0.0’</pre>
			<pre class="source-code">}</pre>
			<p>Adding this dependency allows you to use Mockito<a id="_idIndexMarker165"/> to create mock objects for your unit tests in your project.</p>
			<p>If you prefer to use Mockito with idiomatic Kotlin code, you can use Mockito-Kotlin. Mockito-Kotlin <a id="_idIndexMarker166"/>is a Mockito library that contains helper functions to make your code more Kotlin-like.</p>
			<p>To use Mockito-Kotlin in your Android unit tests, you can add the following dependency to your <strong class="source-inline">app/build.gradle</strong> file dependencies:</p>
			<pre class="source-code">dependencies {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    testImplementation ‘org.mockito.kotlin:mockito-</pre>
			<pre class="source-code">      kotlin:4.0.0’</pre>
			<pre class="source-code">}</pre>
			<p>This will<a id="_idIndexMarker167"/> enable you to use Mockito to <a id="_idIndexMarker168"/>create mock objects for your tests, using idiomatic Kotlin code.</p>
			<p>If you are using both Mockito (<strong class="source-inline">mockito-core</strong>) and Mockito-Kotlin in your project, you can just add the dependency for Mockito-Kotlin. It already has a dependency to <strong class="source-inline">mockito-core</strong>, which it will automatically import.</p>
			<p>To test Jetpack components such as <strong class="source-inline">LiveData</strong>, add the <strong class="source-inline">androidx.arch.core:core-testing</strong> dependency:</p>
			<pre class="source-code">dependencies {</pre>
			<pre class="source-code">    ... </pre>
			<pre class="source-code">    testImplementation ‘androidx.arch.core:core-</pre>
			<pre class="source-code">      testing:2.1.0’</pre>
			<pre class="source-code">}</pre>
			<p>This dependency contains support for testing Jetpack architecture components. It includes JUnit rules such as <strong class="source-inline">InstantTaskExecutorRule</strong> that you can use to test the <strong class="source-inline">LiveData</strong> objects in your code.</p>
			<p>Testing coroutines is a bit more complicated than the usual testing. This is because coroutines are asynchronous, tasks can run in parallel, and tasks can take a while before finishing. Your tests must be fast and consistent. </p>
			<p>To help you with testing coroutines, you can use the coroutine testing library from the <strong class="source-inline">kotlinx-coroutines-test</strong> package. It contains utility classes to make testing coroutines easier and more efficient. To use it in your Android project, you must add the following to the dependencies in your <strong class="source-inline">app/build.gradle</strong> file:</p>
			<pre class="source-code">dependencies {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    testImplementation ‘org.jetbrains.kotlinx:kotlinx-</pre>
			<pre class="source-code">      coroutines-test:1.6.0’</pre>
			<pre class="source-code">}</pre>
			<p>This will<a id="_idIndexMarker169"/> import the <strong class="source-inline">kotlinx-coroutines-test</strong> dependency<a id="_idIndexMarker170"/> into your Android project. You will then be able to use the utility classes from the Kotlin coroutine testing library to create unit tests for your coroutines.</p>
			<p>If you want to use <strong class="source-inline">kotlinx-coroutines-test</strong> in your Android instrumented tests that will run on an emulator or physical device, you should add the following to your <strong class="source-inline">app/build.gradle</strong> file dependencies:</p>
			<pre class="source-code">dependencies {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    androidTestImplementation</pre>
			<pre class="source-code">      ‘org.jetbrains.kotlinx:kotlinx-coroutines-test:1.6.0’</pre>
			<pre class="source-code">}</pre>
			<p>Adding this to your dependencies will allow you to use <strong class="source-inline">kotlinx-coroutines-test</strong> in your instrumented tests.</p>
			<p>As of version 1.6.0, the coroutine testing library is still labeled as experimental. You may have to<a id="_idIndexMarker171"/> annotate the test classes with the <strong class="source-inline">@ExperimentalCoroutinesApi</strong> annotation, as<a id="_idIndexMarker172"/> shown in the following example:</p>
			<pre class="source-code">@ExperimentalCoroutinesApi</pre>
			<pre class="source-code">class MovieRepositoryUnitTest {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>In this section, you learned how to set up your Android project to add tests. You will learn how to create unit tests for suspending functions in the next section.</p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor054"/>Unit testing suspending functions</h1>
			<p>In this section, we will <a id="_idIndexMarker173"/>focus on how you can unit test your suspending<a id="_idIndexMarker174"/> functions. You can create unit tests for classes such as <strong class="source-inline">ViewModel</strong> that launch a coroutine or have suspending functions.</p>
			<p>Creating a unit test for a suspending function is more difficult to write as a suspending function can only be called from a coroutine or another coroutine. What you can do is use the <strong class="source-inline">runBlocking</strong> coroutine builder and call the suspending function from there. For example, say you have a <strong class="source-inline">MovieRepository</strong> class like the following:</p>
			<pre class="source-code">class MovieRepository (private val movieService:</pre>
			<pre class="source-code">  MovieService) {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    private val movieLiveData =</pre>
			<pre class="source-code">      MutableLiveData&lt;List&lt;Movie&gt;&gt;()</pre>
			<pre class="source-code">    fun fetchMovies() {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        val movies = movieService.getMovies()</pre>
			<pre class="source-code">        movieLiveData.postValue(movies.results)</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>This <strong class="source-inline">MovieRepository</strong> has a suspending function called <strong class="source-inline">fetchMovies</strong>. This function gets the list of movies by calling the <strong class="source-inline">getMovies</strong> suspending function from <strong class="source-inline">movieService</strong>.</p>
			<p>To create a<a id="_idIndexMarker175"/> test for the <strong class="source-inline">fetchMovies</strong> function, you <a id="_idIndexMarker176"/>can use <strong class="source-inline">runBlocking</strong> to call the suspending function, like the following:</p>
			<pre class="source-code">class MovieRepositoryTest {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    @Test</pre>
			<pre class="source-code">    fun fetchMovies() {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        runBlocking {</pre>
			<pre class="source-code">            ...</pre>
			<pre class="source-code">            val movieLiveData =</pre>
			<pre class="source-code">              movieRepository.fetchMovies()</pre>
			<pre class="source-code">            assertEquals(movieLiveData.value, movies)</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Using the <strong class="source-inline">runBlocking</strong> coroutine builder allows you to call suspending functions and do the assertion checks.</p>
			<p>The <strong class="source-inline">runBlocking</strong> coroutine builder is useful for testing. However, there are times when it can be slow because of delays in the code. Your unit tests must ideally be able to run as fast as possible. The coroutine testing library can help you with its <strong class="source-inline">runTest</strong> coroutine builder. It is the same as the <strong class="source-inline">runBlocking</strong> coroutine builder except it runs the suspending function immediately and without delays. </p>
			<p>Replacing <strong class="source-inline">runBlocking</strong> with <strong class="source-inline">runTest</strong> in the previous example would make your test look like the following:</p>
			<pre class="source-code">@ExperimentalCoroutinesApi</pre>
			<pre class="source-code">class MovieRepositoryTest {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    @Test</pre>
			<pre class="source-code">    fun fetchMovies() {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        runTest {</pre>
			<pre class="source-code">            ...</pre>
			<pre class="source-code">            val movieLiveData =</pre>
			<pre class="source-code">              movieRepository.fetchMovies()</pre>
			<pre class="source-code">            assertEquals(movieLiveData.value, movies)</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>The <strong class="source-inline">runTest</strong> function<a id="_idIndexMarker177"/> allows you to call the <strong class="source-inline">movieRepository.fetchMovies()</strong> suspending<a id="_idIndexMarker178"/> function and then check the result of the operation.</p>
			<p>In this section, you learned about writing unit tests for suspending functions in your Android project. In the next section, you will learn about testing coroutines.</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor055"/>Testing coroutines</h1>
			<p>In this section, we<a id="_idIndexMarker179"/> will focus on how you can test your coroutines. You can create tests for classes such as <strong class="source-inline">ViewModel</strong> that launch a coroutine.</p>
			<p>For coroutines launched using <strong class="source-inline">Dispatchers.Main</strong>, your unit tests will fail with the following error message:</p>
			<p class="source-code">java.lang.IllegalStateException: Module with the Main dispatcher had failed to initialize. For tests Dispatchers.setMain from kotlinx-coroutines-test module can be used</p>
			<p>This exception happens because <strong class="source-inline">Dispatchers.Main</strong> uses <strong class="source-inline">Looper.getMainLooper()</strong>, the application’s main thread. This main looper is not available in Android for local unit tests. To make your tests work, you must use the <strong class="source-inline">Dispatchers.setMain</strong> extension function to change the <strong class="source-inline">Main </strong>dispatcher. For example, you can create a function in your test class that will run before your tests:</p>
			<pre class="source-code">@Before</pre>
			<pre class="source-code">fun setUp() {</pre>
			<pre class="source-code">    Dispatchers.setMain(UnconfinedTestDispatcher())</pre>
			<pre class="source-code">}</pre>
			<p>The <strong class="source-inline">setUp</strong> function will run before the tests. It will change the main dispatcher to another dispatcher for your test.</p>
			<p><strong class="source-inline">Dispatchers.setMain</strong> will change all subsequent uses of <strong class="source-inline">Dispatchers.Main</strong>. After the test, you must change the <strong class="source-inline">Main</strong> dispatcher back with a call to <strong class="source-inline">Dispatchers.resetMain()</strong>. You can do something like the following:</p>
			<pre class="source-code">@After</pre>
			<pre class="source-code">fun tearDown() {</pre>
			<pre class="source-code">    Dispatchers.resetMain()</pre>
			<pre class="source-code">}</pre>
			<p>After the tests have run, the <strong class="source-inline">tearDown</strong> function will be called, which will reset the <strong class="source-inline">Main</strong> dispatcher.</p>
			<p>If you have many <a id="_idIndexMarker180"/>coroutines to test, copying and pasting this boilerplate code in each test class is not ideal. You can make a custom JUnit rule instead that you can reuse in your test classes. This JUnit rule must be in the root folder of your test source set, as shown in <em class="italic">Figure 4.01</em>:</p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/Figure_4.1_B17773.jpg" alt="Figure 4.1 – Custom TestCoroutineRule in the root test folder&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Custom TestCoroutineRule in the root test folder</p>
			<p>An example of<a id="_idIndexMarker181"/> a custom JUnit rule that you can write to reuse for automatically setting <strong class="source-inline">Dispatchers.setMain</strong> and <strong class="source-inline">Dispatchers.resetMain</strong> is this <strong class="source-inline">TestCoroutineRule</strong>:</p>
			<pre class="source-code">@ExperimentalCoroutinesApi</pre>
			<pre class="source-code">class TestCoroutineRule(val dispatcher: TestDispatcher =</pre>
			<pre class="source-code">  UnconfinedTestDispatcher()):</pre>
			<pre class="source-code">   TestWatcher() {</pre>
			<pre class="source-code">   override fun starting(description: Description?) {</pre>
			<pre class="source-code">       super.starting(description)</pre>
			<pre class="source-code">       Dispatchers.setMain(dispatcher)</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   override fun finished(description: Description?) {</pre>
			<pre class="source-code">       super.finished(description)</pre>
			<pre class="source-code">       Dispatchers.resetMain()</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>This custom JUnit rule will allow your test to automatically call <strong class="source-inline">Dispatchers.setMain</strong> before the tests and <strong class="source-inline">Dispatchers.resetMain</strong> after the tests.</p>
			<p>You can then use this <strong class="source-inline">TestCoroutineRule</strong> in your test classes by adding the <strong class="source-inline">@get:Rule</strong> annotation:</p>
			<pre class="source-code">@ExperimentalCoroutinesApi</pre>
			<pre class="source-code">class MovieRepositoryTest {</pre>
			<pre class="source-code">    @get:Rule</pre>
			<pre class="source-code">    var coroutineRule = TestCoroutineRule()</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>With this code, you will not need to add the <strong class="source-inline">Dispatchers.setMain</strong> and <strong class="source-inline">Dispatchers.resetMain</strong> function calls every time in your test classes.</p>
			<p>When testing your coroutines, you must replace your coroutine dispatchers with a <strong class="source-inline">TestDispatcher</strong> for testing. To be able to replace your dispatchers, your code should have a<a id="_idIndexMarker182"/> way to change the dispatcher that will be used for the coroutines. For example, this <strong class="source-inline">MovieViewModel</strong> class has a property for setting the dispatcher:</p>
			<pre class="source-code">class MovieViewModel(private val dispatcher:</pre>
			<pre class="source-code">  CoroutineDispatcher = Dispatchers.IO): ViewModel() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    fun fetchMovies() {</pre>
			<pre class="source-code">        viewModelScope.launch(dispatcher) {</pre>
			<pre class="source-code">            ...</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p><strong class="source-inline">MovieViewModel</strong> uses the dispatcher specified in its constructor or the default value (<strong class="source-inline">Dispatchers.IO</strong>) for launching the coroutine.</p>
			<p>In your test, you can then set a different <strong class="source-inline">Dispatcher</strong> for testing purposes. For the preceding <strong class="source-inline">ViewModel</strong>, your test could initialize <strong class="source-inline">ViewModel</strong> with a different dispatcher, as shown in the following example:</p>
			<pre class="source-code">@ExperimentalCoroutinesApi</pre>
			<pre class="source-code">class MovieViewModelTest {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    @Test</pre>
			<pre class="source-code">    fun fetchMovies() {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        runTest {</pre>
			<pre class="source-code">            ...</pre>
			<pre class="source-code">            val viewModel =</pre>
			<pre class="source-code">              MovieViewModel(UnconfinedTestDispatcher())</pre>
			<pre class="source-code">            viewModel.fetchMovies()</pre>
			<pre class="source-code">            ...</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>The <strong class="source-inline">viewModel</strong> in <strong class="source-inline">MovieViewModelTest</strong>’s <strong class="source-inline">fetchMovies</strong> test was initialized with <strong class="source-inline">UnconfinedTestDispatcher</strong> as the coroutine dispatcher for testing purposes.</p>
			<p>In the previous examples, you used <strong class="source-inline">UnconfinedTestDispatcher</strong> as the <strong class="source-inline">TestDispatcher</strong> for the test. There are two available implementations of <strong class="source-inline">TestDispatcher</strong> in<a id="_idIndexMarker183"/> the <strong class="source-inline">kotlinx-coroutines-test</strong> library:</p>
			<ul>
				<li><strong class="source-inline">StandardTestDispatcher</strong>: Does not run coroutines automatically, giving you full control over execution order</li>
				<li><strong class="source-inline">UnconfinedTestDispatcher</strong>: Runs coroutines automatically; offers no control over the order in which the coroutines will be launched</li>
			</ul>
			<p>Both <strong class="source-inline">StandardTestDispatcher</strong> and <strong class="source-inline">UnconfinedTestDispatcher</strong> have constructor properties: <strong class="source-inline">scheduler</strong> for <strong class="source-inline">TestCoroutineScheduler</strong> and <strong class="source-inline">name</strong> for identifying the dispatcher. If you do not specify the scheduler, <strong class="source-inline">TestDispatcher</strong> will create a <strong class="source-inline">TestCoroutineScheduler</strong> by default.</p>
			<p>The <strong class="source-inline">TestCoroutineScheduler</strong> of the <strong class="source-inline">StandardTestDispatcher</strong> controls the execution of the coroutine. <strong class="source-inline">TestCoroutineScheduler</strong> has three functions you can call to control the execution of the tasks:</p>
			<ul>
				<li><strong class="source-inline">runCurrent()</strong>: Runs the tasks that are scheduled until the current virtual time</li>
				<li><strong class="source-inline">advanceUntilIdle()</strong>: Runs all pending tasks</li>
				<li><strong class="source-inline">advanceTimeBy(milliseconds)</strong>: Runs pending tasks until current virtual advances by the specified milliseconds</li>
			</ul>
			<p><strong class="source-inline">TestCoroutineScheduler</strong> also has a <strong class="source-inline">currentTime</strong> property that specifies the current virtual time in milliseconds. When you call functions such as <strong class="source-inline">advanceTimeBy</strong>, it will update the <strong class="source-inline">currentTime</strong> property of the scheduler.</p>
			<p>The <strong class="source-inline">runTest</strong> coroutine builder creates a coroutine with a coroutine scope of <strong class="source-inline">TestScope</strong>. This <strong class="source-inline">TestScope</strong> has a <strong class="source-inline">TestCoroutineScheduler</strong> (<strong class="source-inline">testScheduler</strong>) that you can use to control the execution of tasks. </p>
			<p>This <strong class="source-inline">testScheduler</strong> also has extension property called <strong class="source-inline">currentTime</strong> and the <strong class="source-inline">runCurrent</strong>, <strong class="source-inline">advanceUntilIdle</strong>, and <strong class="source-inline">advanceTimeBy</strong> extension functions, which simplifies calling these functions from the <strong class="source-inline">testScheduler</strong> of the <strong class="source-inline">TestScope</strong>.</p>
			<p>Using <strong class="source-inline">runTest</strong> with a <strong class="source-inline">TestDispatcher</strong> allows you to test cases when there are time delays in the coroutine and you want to test a line of code before moving on to the next ones. For<a id="_idIndexMarker184"/> example, if your <strong class="source-inline">ViewModel</strong> has a <strong class="source-inline">loading</strong> Boolean variable that is set to <strong class="source-inline">true</strong> before a network operation and then is reset to <strong class="source-inline">false</strong> afterward, your test for the <strong class="source-inline">loading</strong> variable could look like this:</p>
			<pre class="source-code">@Test</pre>
			<pre class="source-code">fun loading() {</pre>
			<pre class="source-code">    val dispatcher = StandardTestDispatcher()</pre>
			<pre class="source-code">    runTest() {</pre>
			<pre class="source-code">        val viewModel = MovieViewModel(dispatcher)</pre>
			<pre class="source-code">        viewModel.fetchMovies()</pre>
			<pre class="source-code">        dispatcher.scheduler.advanceUntilIdle()</pre>
			<pre class="source-code">        assertEquals(false, viewModel.loading.value)</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>This test uses <strong class="source-inline">StandardTestDispatcher</strong> so you can control the execution of the tasks. After calling <strong class="source-inline">fetchMovies</strong>, you call <strong class="source-inline">advanceUntilIdle</strong> on the dispatcher’s <strong class="source-inline">scheduler</strong> to <a id="_idIndexMarker185"/>run the task, which will set the <strong class="source-inline">loading</strong> value to <strong class="source-inline">false</strong> after completion.</p>
			<p>In this section, you learned about adding tests for your coroutines. Let's test what we have learned so far by adding some tests to existing coroutines in an Android project.</p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor056"/>Exercise 4.01 – adding tests to coroutines in an Android app</h1>
			<p>For this<a id="_idIndexMarker186"/> exercise, you will be continuing the movie app that you worked on in <em class="italic">Exercise 2.01</em>, <em class="italic">Using coroutines in an Android app</em>. This application displays the movies that are currently playing in cinemas. You will be adding unit tests for the coroutines in the project by following these steps:</p>
			<ol>
				<li>Open the movie app you worked on in <em class="italic">Exercise 2.01</em>, <em class="italic">Using coroutines in an Android app</em>, in Android Studio.</li>
				<li>Go to the <strong class="source-inline">app/build.gradle</strong> file and add the following dependencies, which will be used for the unit test:<p class="source-code">testImplementation ‘org.mockito.kotlin:mockito-</p><p class="source-code">  kotlin:4.0.0’</p><p class="source-code">testImplementation ‘androidx.arch.core:core-</p><p class="source-code">  testing:2.1.0’</p><p class="source-code">testImplementation ‘org.jetbrains.kotlinx:kotlinx-</p><p class="source-code">  coroutines-test:1.6.0’</p></li>
			</ol>
			<p>The first line will add Mockito-Core and Mockito-Kotlin, the second line will add the architecture testing library, and the last line will add the Kotlin coroutine testing library. You will be using these for the unit tests you will add to the Android project.</p>
			<ol>
				<li value="3">In <strong class="source-inline">app/src/test/resources</strong>, create a <strong class="source-inline">mockito-extensions</strong> directory. In <a id="_idIndexMarker187"/>that directory, create a new file named <strong class="source-inline">org.mockito.plugins.MockMaker</strong>, as shown in <em class="italic">Figure 4.2</em>:</li>
			</ol>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/Figure_4.2_B17773.jpg" alt="Figure 4.2 – The file you need to add to the app/src/test/mockito-extensions directory&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – The file you need to add to the app/src/test/mockito-extensions directory</p>
			<ol>
				<li value="4">In the <strong class="source-inline">app/src/test/mockito-extensions/org.mockito.plugins.MockMaker</strong> file, add the following<a id="_idIndexMarker188"/> content:<p class="source-code">mock-maker-inline</p></li>
			</ol>
			<p>This will allow you to create mocks using Mockito for final classes in your code. Without this, your test will fail with the following error message:</p>
			<p class="source-code">Mockito cannot mock/spy because : final class</p>
			<ol>
				<li value="5">You will first add a unit test for the <strong class="source-inline">MovieRepository</strong> class. In <strong class="source-inline">app/src/test</strong>, create a test class called <strong class="source-inline">MovieRepositoryTest</strong> and add the <strong class="source-inline">@OptIn(ExperimentalCoroutinesApi::class)</strong> annotation to this class:<p class="source-code">@OptIn(ExperimentalCoroutinesApi::class)</p><p class="source-code">class MovieRepositoryTest {</p><p class="source-code">    ...</p><p class="source-code">}</p></li>
			</ol>
			<p>This will be the test class for <strong class="source-inline">MovieRepository</strong>. The <strong class="source-inline">ExperimentalCoroutinesApi</strong> <strong class="source-inline">OptIn</strong> annotation was added as some of the classes in the <strong class="source-inline">kotlinx-coroutines-test</strong> library are still marked as experimental.</p>
			<ol>
				<li value="6">Inside<a id="_idIndexMarker189"/> the <strong class="source-inline">MovieRepositoryTest</strong> class, add a JUnit test rule for <strong class="source-inline">InstantTaskExecutorRule</strong>:<p class="source-code">@get:Rule</p><p class="source-code">val rule = InstantTaskExecutorRule()</p></li>
			</ol>
			<p><strong class="source-inline">InstantTaskExecutorRule</strong> allows the test to execute the tasks synchronously. This is needed for the <strong class="source-inline">LiveData</strong> objects in <strong class="source-inline">MovieRepository</strong>.</p>
			<ol>
				<li value="7">Create a test function called <strong class="source-inline">fetchMovies</strong> to test the <strong class="source-inline">fetchMovies</strong> suspending function from <strong class="source-inline">MovieRepository</strong>, successfully retrieving a list of movies:<p class="source-code">@Test</p><p class="source-code">fun fetchMovies() {</p><p class="source-code">    ...</p><p class="source-code">}</p></li>
			</ol>
			<p>This will be the first test for <strong class="source-inline">MovieRepository.fetchMovies</strong>: a success scenario that displays a list of movies. </p>
			<ol>
				<li value="8">In the <strong class="source-inline">MovieRepositoryTest</strong> class' <strong class="source-inline">fetchMovies</strong> function, add the following code to mock <strong class="source-inline">MovieRepository</strong> and <strong class="source-inline">MovieService</strong>:<p class="source-code">@Test</p><p class="source-code">fun fetchMovies() {</p><p class="source-code">    val movies = listOf(Movie(id = 3), Movie(id = 4))</p><p class="source-code">    val response = MoviesResponse(1, movies)</p><p class="source-code"> </p><p class="source-code">    val movieService: MovieService = mock {</p><p class="source-code">        onBlocking { getMovies(anyString()) } doReturn</p><p class="source-code">          response</p><p class="source-code">    }</p><p class="source-code">    val movieRepository =</p><p class="source-code">      MovieRepository(movieService)</p><p class="source-code">}</p></li>
			</ol>
			<p>This will <a id="_idIndexMarker190"/>mock <strong class="source-inline">MovieService</strong> so that when its <strong class="source-inline">getMovies</strong> function is called, it will always return the <strong class="source-inline">movies</strong> list we provided.</p>
			<ol>
				<li value="9">At the end of the <strong class="source-inline">fetchMovies</strong> function of <strong class="source-inline">MovieRepositoryTest</strong>, add the following to test that calling <strong class="source-inline">fetchMovies</strong> from the <strong class="source-inline">MovieRepository</strong> class returns the list of movies we expect it to return:<p class="source-code">@Test</p><p class="source-code">fun fetchMovies() {</p><p class="source-code">    ...</p><p class="source-code"> </p><p class="source-code">    runTest {</p><p class="source-code">        movieRepository.fetchMovies()</p><p class="source-code">        val movieLiveData = movieRepository.movies</p><p class="source-code">        assertEquals(movies, movieLiveData.value)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>This will call the <strong class="source-inline">fetchMovies</strong> function from the <strong class="source-inline">MovieRepository</strong> class, which will call <strong class="source-inline">getMovies</strong> from <strong class="source-inline">MovieService</strong>. We are checking whether it indeed returns the list of movies that we set in the mocked <strong class="source-inline">MovieService</strong> earlier.</p>
			<ol>
				<li value="10">Run the <strong class="source-inline">MovieRepositoryTest</strong> class. <strong class="source-inline">MovieRepositoryTest</strong> should pass and there should be no errors.</li>
				<li>Create <a id="_idIndexMarker191"/>another test function called <strong class="source-inline">fetchMoviesWithError</strong> in the <strong class="source-inline">MovieRepositoryTest</strong> class to test the <strong class="source-inline">fetchMovies</strong> suspending function from the <strong class="source-inline">MovieRepository</strong> failing to retrieve a list of movies:<p class="source-code">@Test</p><p class="source-code">fun fetchMoviesWithError() {</p><p class="source-code">    ...</p><p class="source-code">}</p></li>
			</ol>
			<p>This will test the case when <strong class="source-inline">MovieRepository</strong> fails while retrieving the list of movies. </p>
			<ol>
				<li value="12">In the <strong class="source-inline">MovieRepositoryTest</strong> class' <strong class="source-inline">fetchMoviesWithError</strong> function, add the following:<p class="source-code">@Test</p><p class="source-code">fun fetchMoviesWithError() {</p><p class="source-code">    val exception = “Test Exception” </p><p class="source-code">    val movieService: MovieService = mock {</p><p class="source-code">        onBlocking { getMovies(anyString()) } doThrow</p><p class="source-code">          RuntimeException(exception)</p><p class="source-code">    }</p><p class="source-code">    val movieRepository =</p><p class="source-code">      MovieRepository(movieService)</p><p class="source-code">}</p></li>
			</ol>
			<p>This will mock <strong class="source-inline">MovieService</strong> so that when its <strong class="source-inline">getMovies</strong> function is called, it will always throw an exception with the message <strong class="source-inline">Test Exception</strong>.</p>
			<ol>
				<li value="13">At the <a id="_idIndexMarker192"/>end of the <strong class="source-inline">fetchMoviesWithError</strong> function of <strong class="source-inline">MovieRepositoryTest</strong>, add the following to test that calling <strong class="source-inline">fetchMovies</strong> from the <strong class="source-inline">MovieRepository</strong> class returns the list of movies we expect it to return:<p class="source-code">@Test</p><p class="source-code">fun fetchMovies() {</p><p class="source-code">    ...</p><p class="source-code"> </p><p class="source-code">    runTest {</p><p class="source-code">        movieRepository.fetchMovies()</p><p class="source-code"> </p><p class="source-code">        val movieLiveData = movieRepository.movies</p><p class="source-code">        assertNull(movieLiveData.value)</p><p class="source-code"> </p><p class="source-code">        val errorLiveData = movieRepository.error</p><p class="source-code">        assertNotNull(errorLiveData.value)</p><p class="source-code">        assertTrue(errorLiveData.value.toString()</p><p class="source-code">          .contains(exception))</p><p class="source-code">        }</p><p class="source-code">}</p></li>
			</ol>
			<p>This will call the <strong class="source-inline">fetchMovies</strong> function from the <strong class="source-inline">MovieRepository</strong> class, which will call the <strong class="source-inline">getMovies</strong> from the <strong class="source-inline">MovieService</strong> that will always throw an exception when called. </p>
			<p>In the first assertion, we are checking that <strong class="source-inline">movieLiveData</strong> is null as there were no movies fetched. The second assertion checks that <strong class="source-inline">errorLiveData</strong> is not null as there was an exception. The last assertion checks that <strong class="source-inline">errorLiveData</strong> contains the <strong class="source-inline">Test Exception</strong> message we set in the previous step.</p>
			<ol>
				<li value="14">Run the <strong class="source-inline">MovieRepositoryTest</strong> test. Both the <strong class="source-inline">fetchMovies</strong> and <strong class="source-inline">fetchMoviesWithError</strong> tests should have no errors and both should pass.</li>
				<li>We will<a id="_idIndexMarker193"/> then create a test for <strong class="source-inline">MovieViewModel</strong>. First, we would need to update <strong class="source-inline">MovieViewModel</strong> so that we can change the dispatcher that the coroutine runs on. Open the <strong class="source-inline">MovieViewModel</strong> class and update its constructor by adding a dispatcher property to set the coroutine dispatcher:<p class="source-code">class MovieViewModel(private val movieRepository:</p><p class="source-code">  MovieRepository, private val dispatcher:</p><p class="source-code">  CoroutineDispatcher = Dispatchers.IO) : ViewModel() </p><p class="source-code">  {</p><p class="source-code">    ...</p><p class="source-code">}</p></li>
			</ol>
			<p>This will allow you to change the dispatcher of <strong class="source-inline">MovieViewModel</strong> with another dispatcher, which you will be doing in the tests.</p>
			<ol>
				<li value="16">In the <strong class="source-inline">fetchMovies</strong> function, change the <strong class="source-inline">launch</strong> coroutine builder to use the <strong class="source-inline">dispatcher</strong> from the constructor instead of the hardcoded dispatcher:<p class="source-code">viewModelScope.launch(dispatcher) {</p><p class="source-code">    ...</p><p class="source-code">}</p></li>
			</ol>
			<p>This updates the code to use the <strong class="source-inline">dispatcher</strong> set from the constructor or the default dispatcher (<strong class="source-inline">Dispatchers.IO</strong>). You can now create a unit test for the <strong class="source-inline">MovieViewModel</strong> class.</p>
			<ol>
				<li value="17">In <a id="_idIndexMarker194"/>the <strong class="source-inline">app/src/test</strong> directory, create a test class named <strong class="source-inline">MovieViewModelTest</strong> for <strong class="source-inline">MovieViewModel</strong> and add the <strong class="source-inline">@OptIn(ExperimentalCoroutinesApi::class)</strong> annotation to the class:<p class="source-code">@OptIn(ExperimentalCoroutinesApi::class)</p><p class="source-code">class MovieViewModelTest {</p><p class="source-code">    ...</p><p class="source-code">}</p></li>
			</ol>
			<p>This will be the test class for <strong class="source-inline">MovieViewModel</strong>. The <strong class="source-inline">ExperimentalCoroutinesApi</strong> annotation was added as some of the classes in the <strong class="source-inline">kotlinx-coroutines-test</strong> library are still experimental.</p>
			<ol>
				<li value="18">Inside the <strong class="source-inline">MovieViewModelTest</strong> class, add a JUnit test rule for <strong class="source-inline">InstantTaskExecutorRule</strong>:<p class="source-code">@get:Rule</p><p class="source-code">val rule = InstantTaskExecutorRule()</p></li>
			</ol>
			<p>The <strong class="source-inline">InstantTaskExecutorRule</strong> in the unit test executes the tasks synchronously. This is for the <strong class="source-inline">LiveData</strong> objects in <strong class="source-inline">MovieViewModel</strong>.</p>
			<ol>
				<li value="19">Create a test function called <strong class="source-inline">fetchMovies</strong> to test the <strong class="source-inline">fetchMovies</strong> suspending function from <strong class="source-inline">MovieViewModel</strong>:<p class="source-code">@Test</p><p class="source-code">fun fetchMovies() {</p><p class="source-code">    val expectedMovies =</p><p class="source-code">      MutableLiveData&lt;List&lt;Movie&gt;&gt;()</p><p class="source-code">    expectedMovies.postValue(listOf(Movie</p><p class="source-code">      (title = “Movie”)))</p><p class="source-code"> </p><p class="source-code">    val movieRepository: MovieRepository = mock {</p><p class="source-code">        onBlocking { movies } doReturn expectedMovies</p><p class="source-code">    }</p><p class="source-code"> }</p></li>
			</ol>
			<p>This will<a id="_idIndexMarker195"/> mock <strong class="source-inline">MovieRepository</strong> so that its <strong class="source-inline">movies</strong> property will always return the <strong class="source-inline">expectedMovies</strong> as its value.</p>
			<ol>
				<li value="20">At the end of the <strong class="source-inline">fetchMovies</strong> test of <strong class="source-inline">MovieViewModelTest</strong>, add the following to test that <strong class="source-inline">MovieViewModel</strong>’s movies will be equal to <strong class="source-inline">expectedMovies</strong>:<p class="source-code">@Test</p><p class="source-code">fun fetchMovies() {</p><p class="source-code">    ...</p><p class="source-code"> </p><p class="source-code">    val movieViewModel = </p><p class="source-code">      MovieViewModel(movieRepository)</p><p class="source-code">    assertEquals(expectedMovies.value,</p><p class="source-code">      movieViewModel.movies.value)</p><p class="source-code">}</p></li>
			</ol>
			<p>This creates a <strong class="source-inline">MovieViewModel</strong> using the mocked <strong class="source-inline">MovieRepository</strong>. We are checking that the value of <strong class="source-inline">MovieViewModel</strong>’s <strong class="source-inline">movies</strong> is equal to the <strong class="source-inline">expectedMovies</strong> value we set to the mocked <strong class="source-inline">MovieRepository</strong>.</p>
			<ol>
				<li value="21">Run <strong class="source-inline">MovieViewModelTest</strong> or all the tests (<strong class="source-inline">MovieRepositoryTest</strong> and <strong class="source-inline">MovieViewModelTest</strong>). All tests should pass.</li>
				<li>Create another test function called <strong class="source-inline">loading</strong> in <strong class="source-inline">MovieViewModelTest</strong> to test the <strong class="source-inline">loading</strong> <strong class="source-inline">LiveData</strong> in <strong class="source-inline">MovieViewModel</strong>:<p class="source-code">@Test</p><p class="source-code">fun loading() {</p><p class="source-code">    ...</p><p class="source-code">}</p></li>
			</ol>
			<p>This will<a id="_idIndexMarker196"/> test the <strong class="source-inline">loading</strong> <strong class="source-inline">LiveData</strong> property of <strong class="source-inline">MovieViewModel</strong>. The loading property is <strong class="source-inline">true</strong> while fetching the movies and displays the <strong class="source-inline">ProgressBar</strong>. It becomes <strong class="source-inline">false</strong> and hides the <strong class="source-inline">ProgressBar</strong> after successfully fetching the movies or when an error is encountered.</p>
			<ol>
				<li value="23">In the <strong class="source-inline">loading</strong> test function, add the following to mock <strong class="source-inline">MovieRepository</strong> and initialize a dispatcher that will be used for <strong class="source-inline">MovieViewModel</strong>:<p class="source-code">@Test</p><p class="source-code">fun loading() {</p><p class="source-code">    val movieRepository: MovieRepository = mock()</p><p class="source-code">    val dispatcher = StandardTestDispatcher()</p><p class="source-code"> </p><p class="source-code">    ...</p><p class="source-code">}</p></li>
			</ol>
			<p>This will mock <strong class="source-inline">MovieRepository</strong> and create a dispatcher of the <strong class="source-inline">StandardTestDispatcher</strong> type that will be used for the <strong class="source-inline">MovieViewModel</strong> test. This will allow you to control the execution of the task, which will be used later to check the value of <strong class="source-inline">MovieViewModel</strong>’s <strong class="source-inline">loading</strong> property.</p>
			<ol>
				<li value="24"> At the<a id="_idIndexMarker197"/> end of the <strong class="source-inline">loading</strong> test function, add the following to test the loading <strong class="source-inline">MovieViewModel</strong>’s <strong class="source-inline">loading</strong> property:<p class="source-code">@Test</p><p class="source-code">fun loading() {</p><p class="source-code">    ...</p><p class="source-code"> </p><p class="source-code">    runTest {</p><p class="source-code">        val movieViewModel =</p><p class="source-code">          MovieViewModel(movieRepository, dispatcher)</p><p class="source-code">        </p><p class="source-code">        movieViewModel.fetchMovies()</p><p class="source-code">        assertTrue( movieViewModel.loading.value ==</p><p class="source-code">          true)</p><p class="source-code">        dispatcher.scheduler.advanceUntilIdle()</p><p class="source-code">        assertFalse(movieViewModel.loading.value ==</p><p class="source-code">          true)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>This will create a <strong class="source-inline">MovieViewModel</strong> with the mock <strong class="source-inline">MovieRepository</strong> and <strong class="source-inline">dispatcher</strong> you created in the previous step. Then, <strong class="source-inline">fetchMovies</strong> will be called from <strong class="source-inline">MovieViewModel</strong> to fetch the list of movies.</p>
			<p>The first assertion checks whether the <strong class="source-inline">loading</strong> value is <strong class="source-inline">true</strong>. We then used <strong class="source-inline">advanceUntilIdle</strong> from the dispatcher’s <strong class="source-inline">scheduler</strong> to execute all the tasks. This should change the <strong class="source-inline">loading</strong> value to <strong class="source-inline">false</strong>. The last line checks this indeed happens.</p>
			<ol>
				<li value="25">Run <a id="_idIndexMarker198"/>both <strong class="source-inline">MovieRepositoryTest</strong> and <strong class="source-inline">MovieViewMo<a id="_idTextAnchor057"/>delTest</strong>. All the tests should pass.</li>
			</ol>
			<p>In this exercise, you worked on an Android project that uses coroutines and you have added unit tests for these coroutines.</p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor058"/>Summary</h1>
			<p>This chapter focused on testing coroutines in your Android app. You started with learning how to set up your Android project in preparation for adding tests for your coroutines. The coroutines testing library (<strong class="source-inline">kotlinx-coroutines-test</strong>) helps you to create tests for your coroutines.</p>
			<p>You learned how to add unit tests for your suspending functions. You can use <strong class="source-inline">runBlocking</strong> and <strong class="source-inline">runTest</strong> to test code that calls suspending functions. <strong class="source-inline">runTest</strong> runs the code immediately, without delays. </p>
			<p>Then, you learned how to test coroutines. You can change the dispatcher in your test with a <strong class="source-inline">TestDispatcher</strong> (<strong class="source-inline">StandardTestDispatcher</strong> or <strong class="source-inline">UnconfinedTestDispatcher</strong>). <strong class="source-inline">TestCoroutineScheduler</strong> allows you to control the execution of the coroutine task.</p>
			<p>Finally, you worked on an exercise where you added unit tests for coroutines in an existing Android project.</p>
			<p>In the next chapter, you will explore Kotlin Flows and learn how you can use them for asynchronous programming in Android.</p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor059"/>Further reading</h1>
			<p>This book assumes that you already have knowledge of testing Android applications. If you would like to learn more about Android testing, you can read <em class="italic">Chapter 9</em>, <em class="italic">Unit Tests and Integration Tests with JUnit, Mockito, and Espresso</em>, from the book <em class="italic">How to Build Android Apps with Kotlin (Packt Publishing, 2021, ISBN 9781838984113)</em>. You can also check the Android testing documentation at <a href="https://developer.android.com/training/testing">https://developer.android.com/training/testing</a>.</p>
			<p>As of the time of writing, the coroutine testing library is still marked as experimental. Before the library becomes stable later, there might be some code-breaking changes to the classes. You can check the latest version of the library on GitHub at <a href="https://github.com/Kotlin/kotlinx.coroutines/tree/master/kotlinx-coroutines-test">https://github.com/Kotlin/kotlinx.coroutines/tree/master/kotlinx-coroutines-test</a> to find the latest information about the coroutine testing library.</p>
		</div>
		<div>
			<div id="_idContainer029">
			</div>
		</div>
	</body></html>