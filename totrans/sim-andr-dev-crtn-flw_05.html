<html><head></head><body>
		<div><h1 id="_idParaDest-48"><em class="italic"><a id="_idTextAnchor051"/>Chapter 4</em>: Testing Kotlin Coroutines</h1>
			<p>In the previous chapter, you learned about coroutine cancelations and how you can make your coroutines cancelable. You then learned about coroutine timeouts in milliseconds or <code>try-catch</code> and <code>CoroutineExceptionHandler</code>.</p>
			<p>Creating tests is an important part of app development. The more code you write, the higher the chance that there will be bugs and errors. With tests, you can ensure your application works as you have programmed it. You can quickly discover issues and fix them immediately. Tests can make development easier, saving you time and resources. They can also help you refactor and maintain your code with confidence.</p>
			<p>In this chapter, you will learn how to test Kotlin coroutines in Android. First, we will update the Android project for testing. We will then proceed with learning the steps to create tests for Kotlin coroutines. </p>
			<p>In this chapter, we are going to cover the following topics:</p>
			<ul>
				<li>Setting up an Android project for testing coroutines</li>
				<li>Unit testing suspending functions</li>
				<li>Testing coroutines</li>
			</ul>
			<p>By the end of this chapter, you will understand coroutine testing. You will be able to write and run unit and integration tests for the coroutines in your Android applications.</p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor052"/>Technical requirements</h1>
			<p>You will need to download and install the latest version of Android Studio. You can find the latest version at <a href="https://developer.android.com/studio">https://developer.android.com/studio</a>. For an optimal learning experience, a computer with the following specifications is recommended: </p>
			<ul>
				<li>Intel Core i5 or equivalent or higher </li>
				<li>4 GB RAM minimum </li>
				<li>4 GB available space</li>
			</ul>
			<p>The code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows/tree/main/Chapter04">https://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows/tree/main/Chapter04</a>.</p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor053"/>Setting up an Android project for testing coroutines</h1>
			<p>In <a id="_idIndexMarker161"/>this section, we will start by looking <a id="_idIndexMarker162"/>at how you can update your Android app to make it ready for adding and running tests. Once your project is properly set up, it will be easy to add unit and integration tests for your coroutines.</p>
			<p>When creating unit tests on Android, you must have the <code>app/build.gradle</code> dependencies when creating a new Android project in Android Studio. </p>
			<p>If your Android project does not have JUnit 4 yet, you can add it by including the following to your <code>app/build.gradle</code> dependencies:</p>
			<pre class="source-code">dependencies {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    testImplementation ‘junit:junit:4.13.2’</pre>
			<pre class="source-code">}</pre>
			<p>This allows you to use the JUnit 4 framework for your unit tests.</p>
			<p>To create mock objects for your tests, you can also use mocking libraries. Mockito is the most popular Java mocking library, and you can use it on Android. To add Mockito to your tests, add the following to the dependencies in your <code>app/build.gradle</code> file:</p>
			<pre class="source-code">dependencies {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    testImplementation ‘org.mockito:mockito-core:4.0.0’</pre>
			<pre class="source-code">}</pre>
			<p>Adding this dependency allows you to use Mockito<a id="_idIndexMarker165"/> to create mock objects for your unit tests in your project.</p>
			<p>If you prefer to use Mockito with idiomatic Kotlin code, you can use Mockito-Kotlin. Mockito-Kotlin <a id="_idIndexMarker166"/>is a Mockito library that contains helper functions to make your code more Kotlin-like.</p>
			<p>To use Mockito-Kotlin in your Android unit tests, you can add the following dependency to your <code>app/build.gradle</code> file dependencies:</p>
			<pre class="source-code">dependencies {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    testImplementation ‘org.mockito.kotlin:mockito-</pre>
			<pre class="source-code">      kotlin:4.0.0’</pre>
			<pre class="source-code">}</pre>
			<p>This will<a id="_idIndexMarker167"/> enable you to use Mockito to <a id="_idIndexMarker168"/>create mock objects for your tests, using idiomatic Kotlin code.</p>
			<p>If you are using both Mockito (<code>mockito-core</code>) and Mockito-Kotlin in your project, you can just add the dependency for Mockito-Kotlin. It already has a dependency to <code>mockito-core</code>, which it will automatically import.</p>
			<p>To test Jetpack components such as <code>LiveData</code>, add the <code>androidx.arch.core:core-testing</code> dependency:</p>
			<pre class="source-code">dependencies {</pre>
			<pre class="source-code">    ... </pre>
			<pre class="source-code">    testImplementation ‘androidx.arch.core:core-</pre>
			<pre class="source-code">      testing:2.1.0’</pre>
			<pre class="source-code">}</pre>
			<p>This dependency contains support for testing Jetpack architecture components. It includes JUnit rules such as <code>InstantTaskExecutorRule</code> that you can use to test the <code>LiveData</code> objects in your code.</p>
			<p>Testing coroutines is a bit more complicated than the usual testing. This is because coroutines are asynchronous, tasks can run in parallel, and tasks can take a while before finishing. Your tests must be fast and consistent. </p>
			<p>To help you with testing coroutines, you can use the coroutine testing library from the <code>kotlinx-coroutines-test</code> package. It contains utility classes to make testing coroutines easier and more efficient. To use it in your Android project, you must add the following to the dependencies in your <code>app/build.gradle</code> file:</p>
			<pre class="source-code">dependencies {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    testImplementation ‘org.jetbrains.kotlinx:kotlinx-</pre>
			<pre class="source-code">      coroutines-test:1.6.0’</pre>
			<pre class="source-code">}</pre>
			<p>This will<a id="_idIndexMarker169"/> import the <code>kotlinx-coroutines-test</code> dependency<a id="_idIndexMarker170"/> into your Android project. You will then be able to use the utility classes from the Kotlin coroutine testing library to create unit tests for your coroutines.</p>
			<p>If you want to use <code>kotlinx-coroutines-test</code> in your Android instrumented tests that will run on an emulator or physical device, you should add the following to your <code>app/build.gradle</code> file dependencies:</p>
			<pre class="source-code">dependencies {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    androidTestImplementation</pre>
			<pre class="source-code">      ‘org.jetbrains.kotlinx:kotlinx-coroutines-test:1.6.0’</pre>
			<pre class="source-code">}</pre>
			<p>Adding this to your dependencies will allow you to use <code>kotlinx-coroutines-test</code> in your instrumented tests.</p>
			<p>As of version 1.6.0, the coroutine testing library is still labeled as experimental. You may have to<a id="_idIndexMarker171"/> annotate the test classes with the <code>@ExperimentalCoroutinesApi</code> annotation, as<a id="_idIndexMarker172"/> shown in the following example:</p>
			<pre class="source-code">@ExperimentalCoroutinesApi</pre>
			<pre class="source-code">class MovieRepositoryUnitTest {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>In this section, you learned how to set up your Android project to add tests. You will learn how to create unit tests for suspending functions in the next section.</p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor054"/>Unit testing suspending functions</h1>
			<p>In this section, we will <a id="_idIndexMarker173"/>focus on how you can unit test your suspending<a id="_idIndexMarker174"/> functions. You can create unit tests for classes such as <code>ViewModel</code> that launch a coroutine or have suspending functions.</p>
			<p>Creating a unit test for a suspending function is more difficult to write as a suspending function can only be called from a coroutine or another coroutine. What you can do is use the <code>runBlocking</code> coroutine builder and call the suspending function from there. For example, say you have a <code>MovieRepository</code> class like the following:</p>
			<pre class="source-code">class MovieRepository (private val movieService:</pre>
			<pre class="source-code">  MovieService) {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    private val movieLiveData =</pre>
			<pre class="source-code">      MutableLiveData&lt;List&lt;Movie&gt;&gt;()</pre>
			<pre class="source-code">    fun fetchMovies() {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        val movies = movieService.getMovies()</pre>
			<pre class="source-code">        movieLiveData.postValue(movies.results)</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>This <code>MovieRepository</code> has a suspending function called <code>fetchMovies</code>. This function gets the list of movies by calling the <code>getMovies</code> suspending function from <code>movieService</code>.</p>
			<p>To create a<a id="_idIndexMarker175"/> test for the <code>fetchMovies</code> function, you <a id="_idIndexMarker176"/>can use <code>runBlocking</code> to call the suspending function, like the following:</p>
			<pre class="source-code">class MovieRepositoryTest {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    @Test</pre>
			<pre class="source-code">    fun fetchMovies() {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        runBlocking {</pre>
			<pre class="source-code">            ...</pre>
			<pre class="source-code">            val movieLiveData =</pre>
			<pre class="source-code">              movieRepository.fetchMovies()</pre>
			<pre class="source-code">            assertEquals(movieLiveData.value, movies)</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Using the <code>runBlocking</code> coroutine builder allows you to call suspending functions and do the assertion checks.</p>
			<p>The <code>runBlocking</code> coroutine builder is useful for testing. However, there are times when it can be slow because of delays in the code. Your unit tests must ideally be able to run as fast as possible. The coroutine testing library can help you with its <code>runTest</code> coroutine builder. It is the same as the <code>runBlocking</code> coroutine builder except it runs the suspending function immediately and without delays. </p>
			<p>Replacing <code>runBlocking</code> with <code>runTest</code> in the previous example would make your test look like the following:</p>
			<pre class="source-code">@ExperimentalCoroutinesApi</pre>
			<pre class="source-code">class MovieRepositoryTest {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    @Test</pre>
			<pre class="source-code">    fun fetchMovies() {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        runTest {</pre>
			<pre class="source-code">            ...</pre>
			<pre class="source-code">            val movieLiveData =</pre>
			<pre class="source-code">              movieRepository.fetchMovies()</pre>
			<pre class="source-code">            assertEquals(movieLiveData.value, movies)</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>The <code>runTest</code> function<a id="_idIndexMarker177"/> allows you to call the <code>movieRepository.fetchMovies()</code> suspending<a id="_idIndexMarker178"/> function and then check the result of the operation.</p>
			<p>In this section, you learned about writing unit tests for suspending functions in your Android project. In the next section, you will learn about testing coroutines.</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor055"/>Testing coroutines</h1>
			<p>In this section, we<a id="_idIndexMarker179"/> will focus on how you can test your coroutines. You can create tests for classes such as <code>ViewModel</code> that launch a coroutine.</p>
			<p>For coroutines launched using <code>Dispatchers.Main</code>, your unit tests will fail with the following error message:</p>
			<pre>java.lang.IllegalStateException: Module with the Main dispatcher had failed to initialize. For tests Dispatchers.setMain from kotlinx-coroutines-test module can be used</pre>
			<p>This exception happens because <code>Dispatchers.Main</code> uses <code>Looper.getMainLooper()</code>, the application’s main thread. This main looper is not available in Android for local unit tests. To make your tests work, you must use the <code>Dispatchers.setMain</code> extension function to change the <code>Main </code>dispatcher. For example, you can create a function in your test class that will run before your tests:</p>
			<pre class="source-code">@Before</pre>
			<pre class="source-code">fun setUp() {</pre>
			<pre class="source-code">    Dispatchers.setMain(UnconfinedTestDispatcher())</pre>
			<pre class="source-code">}</pre>
			<p>The <code>setUp</code> function will run before the tests. It will change the main dispatcher to another dispatcher for your test.</p>
			<p><code>Dispatchers.setMain</code> will change all subsequent uses of <code>Dispatchers.Main</code>. After the test, you must change the <code>Main</code> dispatcher back with a call to <code>Dispatchers.resetMain()</code>. You can do something like the following:</p>
			<pre class="source-code">@After</pre>
			<pre class="source-code">fun tearDown() {</pre>
			<pre class="source-code">    Dispatchers.resetMain()</pre>
			<pre class="source-code">}</pre>
			<p>After the tests have run, the <code>tearDown</code> function will be called, which will reset the <code>Main</code> dispatcher.</p>
			<p>If you have many <a id="_idIndexMarker180"/>coroutines to test, copying and pasting this boilerplate code in each test class is not ideal. You can make a custom JUnit rule instead that you can reuse in your test classes. This JUnit rule must be in the root folder of your test source set, as shown in <em class="italic">Figure 4.01</em>:</p>
			<div><div><img src="img/Figure_4.1_B17773.jpg" alt="Figure 4.1 – Custom TestCoroutineRule in the root test folder&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Custom TestCoroutineRule in the root test folder</p>
			<p>An example of<a id="_idIndexMarker181"/> a custom JUnit rule that you can write to reuse for automatically setting <code>Dispatchers.setMain</code> and <code>Dispatchers.resetMain</code> is this <code>TestCoroutineRule</code>:</p>
			<pre class="source-code">@ExperimentalCoroutinesApi</pre>
			<pre class="source-code">class TestCoroutineRule(val dispatcher: TestDispatcher =</pre>
			<pre class="source-code">  UnconfinedTestDispatcher()):</pre>
			<pre class="source-code">   TestWatcher() {</pre>
			<pre class="source-code">   override fun starting(description: Description?) {</pre>
			<pre class="source-code">       super.starting(description)</pre>
			<pre class="source-code">       Dispatchers.setMain(dispatcher)</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   override fun finished(description: Description?) {</pre>
			<pre class="source-code">       super.finished(description)</pre>
			<pre class="source-code">       Dispatchers.resetMain()</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>This custom JUnit rule will allow your test to automatically call <code>Dispatchers.setMain</code> before the tests and <code>Dispatchers.resetMain</code> after the tests.</p>
			<p>You can then use this <code>TestCoroutineRule</code> in your test classes by adding the <code>@get:Rule</code> annotation:</p>
			<pre class="source-code">@ExperimentalCoroutinesApi</pre>
			<pre class="source-code">class MovieRepositoryTest {</pre>
			<pre class="source-code">    @get:Rule</pre>
			<pre class="source-code">    var coroutineRule = TestCoroutineRule()</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>With this code, you will not need to add the <code>Dispatchers.setMain</code> and <code>Dispatchers.resetMain</code> function calls every time in your test classes.</p>
			<p>When testing your coroutines, you must replace your coroutine dispatchers with a <code>TestDispatcher</code> for testing. To be able to replace your dispatchers, your code should have a<a id="_idIndexMarker182"/> way to change the dispatcher that will be used for the coroutines. For example, this <code>MovieViewModel</code> class has a property for setting the dispatcher:</p>
			<pre class="source-code">class MovieViewModel(private val dispatcher:</pre>
			<pre class="source-code">  CoroutineDispatcher = Dispatchers.IO): ViewModel() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    fun fetchMovies() {</pre>
			<pre class="source-code">        viewModelScope.launch(dispatcher) {</pre>
			<pre class="source-code">            ...</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p><code>MovieViewModel</code> uses the dispatcher specified in its constructor or the default value (<code>Dispatchers.IO</code>) for launching the coroutine.</p>
			<p>In your test, you can then set a different <code>Dispatcher</code> for testing purposes. For the preceding <code>ViewModel</code>, your test could initialize <code>ViewModel</code> with a different dispatcher, as shown in the following example:</p>
			<pre class="source-code">@ExperimentalCoroutinesApi</pre>
			<pre class="source-code">class MovieViewModelTest {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    @Test</pre>
			<pre class="source-code">    fun fetchMovies() {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        runTest {</pre>
			<pre class="source-code">            ...</pre>
			<pre class="source-code">            val viewModel =</pre>
			<pre class="source-code">              MovieViewModel(UnconfinedTestDispatcher())</pre>
			<pre class="source-code">            viewModel.fetchMovies()</pre>
			<pre class="source-code">            ...</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>The <code>viewModel</code> in <code>MovieViewModelTest</code>’s <code>fetchMovies</code> test was initialized with <code>UnconfinedTestDispatcher</code> as the coroutine dispatcher for testing purposes.</p>
			<p>In the previous examples, you used <code>UnconfinedTestDispatcher</code> as the <code>TestDispatcher</code> for the test. There are two available implementations of <code>TestDispatcher</code> in<a id="_idIndexMarker183"/> the <code>kotlinx-coroutines-test</code> library:</p>
			<ul>
				<li><code>StandardTestDispatcher</code>: Does not run coroutines automatically, giving you full control over execution order</li>
				<li><code>UnconfinedTestDispatcher</code>: Runs coroutines automatically; offers no control over the order in which the coroutines will be launched</li>
			</ul>
			<p>Both <code>StandardTestDispatcher</code> and <code>UnconfinedTestDispatcher</code> have constructor properties: <code>scheduler</code> for <code>TestCoroutineScheduler</code> and <code>name</code> for identifying the dispatcher. If you do not specify the scheduler, <code>TestDispatcher</code> will create a <code>TestCoroutineScheduler</code> by default.</p>
			<p>The <code>TestCoroutineScheduler</code> of the <code>StandardTestDispatcher</code> controls the execution of the coroutine. <code>TestCoroutineScheduler</code> has three functions you can call to control the execution of the tasks:</p>
			<ul>
				<li><code>runCurrent()</code>: Runs the tasks that are scheduled until the current virtual time</li>
				<li><code>advanceUntilIdle()</code>: Runs all pending tasks</li>
				<li><code>advanceTimeBy(milliseconds)</code>: Runs pending tasks until current virtual advances by the specified milliseconds</li>
			</ul>
			<p><code>TestCoroutineScheduler</code> also has a <code>currentTime</code> property that specifies the current virtual time in milliseconds. When you call functions such as <code>advanceTimeBy</code>, it will update the <code>currentTime</code> property of the scheduler.</p>
			<p>The <code>runTest</code> coroutine builder creates a coroutine with a coroutine scope of <code>TestScope</code>. This <code>TestScope</code> has a <code>TestCoroutineScheduler</code> (<code>testScheduler</code>) that you can use to control the execution of tasks. </p>
			<p>This <code>testScheduler</code> also has extension property called <code>currentTime</code> and the <code>runCurrent</code>, <code>advanceUntilIdle</code>, and <code>advanceTimeBy</code> extension functions, which simplifies calling these functions from the <code>testScheduler</code> of the <code>TestScope</code>.</p>
			<p>Using <code>runTest</code> with a <code>TestDispatcher</code> allows you to test cases when there are time delays in the coroutine and you want to test a line of code before moving on to the next ones. For<a id="_idIndexMarker184"/> example, if your <code>ViewModel</code> has a <code>loading</code> Boolean variable that is set to <code>true</code> before a network operation and then is reset to <code>false</code> afterward, your test for the <code>loading</code> variable could look like this:</p>
			<pre class="source-code">@Test</pre>
			<pre class="source-code">fun loading() {</pre>
			<pre class="source-code">    val dispatcher = StandardTestDispatcher()</pre>
			<pre class="source-code">    runTest() {</pre>
			<pre class="source-code">        val viewModel = MovieViewModel(dispatcher)</pre>
			<pre class="source-code">        viewModel.fetchMovies()</pre>
			<pre class="source-code">        dispatcher.scheduler.advanceUntilIdle()</pre>
			<pre class="source-code">        assertEquals(false, viewModel.loading.value)</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>This test uses <code>StandardTestDispatcher</code> so you can control the execution of the tasks. After calling <code>fetchMovies</code>, you call <code>advanceUntilIdle</code> on the dispatcher’s <code>scheduler</code> to <a id="_idIndexMarker185"/>run the task, which will set the <code>loading</code> value to <code>false</code> after completion.</p>
			<p>In this section, you learned about adding tests for your coroutines. Let's test what we have learned so far by adding some tests to existing coroutines in an Android project.</p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor056"/>Exercise 4.01 – adding tests to coroutines in an Android app</h1>
			<p>For this<a id="_idIndexMarker186"/> exercise, you will be continuing the movie app that you worked on in <em class="italic">Exercise 2.01</em>, <em class="italic">Using coroutines in an Android app</em>. This application displays the movies that are currently playing in cinemas. You will be adding unit tests for the coroutines in the project by following these steps:</p>
			<ol>
				<li>Open the movie app you worked on in <em class="italic">Exercise 2.01</em>, <em class="italic">Using coroutines in an Android app</em>, in Android Studio.</li>
				<li>Go to the <code>app/build.gradle</code> file and add the following dependencies, which will be used for the unit test:<pre>testImplementation ‘org.mockito.kotlin:mockito-
  kotlin:4.0.0’
testImplementation ‘androidx.arch.core:core-
  testing:2.1.0’
testImplementation ‘org.jetbrains.kotlinx:kotlinx-
  coroutines-test:1.6.0’</pre></li>
			</ol>
			<p>The first line will add Mockito-Core and Mockito-Kotlin, the second line will add the architecture testing library, and the last line will add the Kotlin coroutine testing library. You will be using these for the unit tests you will add to the Android project.</p>
			<ol>
				<li value="3">In <code>app/src/test/resources</code>, create a <code>mockito-extensions</code> directory. In <a id="_idIndexMarker187"/>that directory, create a new file named <code>org.mockito.plugins.MockMaker</code>, as shown in <em class="italic">Figure 4.2</em>:</li>
			</ol>
			<div><div><img src="img/Figure_4.2_B17773.jpg" alt="Figure 4.2 – The file you need to add to the app/src/test/mockito-extensions directory&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – The file you need to add to the app/src/test/mockito-extensions directory</p>
			<ol>
				<li value="4">In the <code>app/src/test/mockito-extensions/org.mockito.plugins.MockMaker</code> file, add the following<a id="_idIndexMarker188"/> content:<pre>mock-maker-inline</pre></li>
			</ol>
			<p>This will allow you to create mocks using Mockito for final classes in your code. Without this, your test will fail with the following error message:</p>
			<pre>Mockito cannot mock/spy because : final class</pre>
			<ol>
				<li value="5">You will first add a unit test for the <code>MovieRepository</code> class. In <code>app/src/test</code>, create a test class called <code>MovieRepositoryTest</code> and add the <code>@OptIn(ExperimentalCoroutinesApi::class)</code> annotation to this class:<pre>@OptIn(ExperimentalCoroutinesApi::class)
class MovieRepositoryTest {
    ...
}</pre></li>
			</ol>
			<p>This will be the test class for <code>MovieRepository</code>. The <code>ExperimentalCoroutinesApi</code> <code>OptIn</code> annotation was added as some of the classes in the <code>kotlinx-coroutines-test</code> library are still marked as experimental.</p>
			<ol>
				<li value="6">Inside<a id="_idIndexMarker189"/> the <code>MovieRepositoryTest</code> class, add a JUnit test rule for <code>InstantTaskExecutorRule</code>:<pre>@get:Rule
val rule = InstantTaskExecutorRule()</pre></li>
			</ol>
			<p><code>InstantTaskExecutorRule</code> allows the test to execute the tasks synchronously. This is needed for the <code>LiveData</code> objects in <code>MovieRepository</code>.</p>
			<ol>
				<li value="7">Create a test function called <code>fetchMovies</code> to test the <code>fetchMovies</code> suspending function from <code>MovieRepository</code>, successfully retrieving a list of movies:<pre>@Test
fun fetchMovies() {
    ...
}</pre></li>
			</ol>
			<p>This will be the first test for <code>MovieRepository.fetchMovies</code>: a success scenario that displays a list of movies. </p>
			<ol>
				<li value="8">In the <code>MovieRepositoryTest</code> class' <code>fetchMovies</code> function, add the following code to mock <code>MovieRepository</code> and <code>MovieService</code>:<pre>@Test
fun fetchMovies() {
    val movies = listOf(Movie(id = 3), Movie(id = 4))
    val response = MoviesResponse(1, movies)
 
    val movieService: MovieService = mock {
        onBlocking { getMovies(anyString()) } doReturn
          response
    }
    val movieRepository =
      MovieRepository(movieService)
}</pre></li>
			</ol>
			<p>This will <a id="_idIndexMarker190"/>mock <code>MovieService</code> so that when its <code>getMovies</code> function is called, it will always return the <code>movies</code> list we provided.</p>
			<ol>
				<li value="9">At the end of the <code>fetchMovies</code> function of <code>MovieRepositoryTest</code>, add the following to test that calling <code>fetchMovies</code> from the <code>MovieRepository</code> class returns the list of movies we expect it to return:<pre>@Test
fun fetchMovies() {
    ...
 
    runTest {
        movieRepository.fetchMovies()
        val movieLiveData = movieRepository.movies
        assertEquals(movies, movieLiveData.value)
    }
}</pre></li>
			</ol>
			<p>This will call the <code>fetchMovies</code> function from the <code>MovieRepository</code> class, which will call <code>getMovies</code> from <code>MovieService</code>. We are checking whether it indeed returns the list of movies that we set in the mocked <code>MovieService</code> earlier.</p>
			<ol>
				<li value="10">Run the <code>MovieRepositoryTest</code> class. <code>MovieRepositoryTest</code> should pass and there should be no errors.</li>
				<li>Create <a id="_idIndexMarker191"/>another test function called <code>fetchMoviesWithError</code> in the <code>MovieRepositoryTest</code> class to test the <code>fetchMovies</code> suspending function from the <code>MovieRepository</code> failing to retrieve a list of movies:<pre>@Test
fun fetchMoviesWithError() {
    ...
}</pre></li>
			</ol>
			<p>This will test the case when <code>MovieRepository</code> fails while retrieving the list of movies. </p>
			<ol>
				<li value="12">In the <code>MovieRepositoryTest</code> class' <code>fetchMoviesWithError</code> function, add the following:<pre>@Test
fun fetchMoviesWithError() {
    val exception = “Test Exception” 
    val movieService: MovieService = mock {
        onBlocking { getMovies(anyString()) } doThrow
          RuntimeException(exception)
    }
    val movieRepository =
      MovieRepository(movieService)
}</pre></li>
			</ol>
			<p>This will mock <code>MovieService</code> so that when its <code>getMovies</code> function is called, it will always throw an exception with the message <code>Test Exception</code>.</p>
			<ol>
				<li value="13">At the <a id="_idIndexMarker192"/>end of the <code>fetchMoviesWithError</code> function of <code>MovieRepositoryTest</code>, add the following to test that calling <code>fetchMovies</code> from the <code>MovieRepository</code> class returns the list of movies we expect it to return:<pre>@Test
fun fetchMovies() {
    ...
 
    runTest {
        movieRepository.fetchMovies()
 
        val movieLiveData = movieRepository.movies
        assertNull(movieLiveData.value)
 
        val errorLiveData = movieRepository.error
        assertNotNull(errorLiveData.value)
        assertTrue(errorLiveData.value.toString()
          .contains(exception))
        }
}</pre></li>
			</ol>
			<p>This will call the <code>fetchMovies</code> function from the <code>MovieRepository</code> class, which will call the <code>getMovies</code> from the <code>MovieService</code> that will always throw an exception when called. </p>
			<p>In the first assertion, we are checking that <code>movieLiveData</code> is null as there were no movies fetched. The second assertion checks that <code>errorLiveData</code> is not null as there was an exception. The last assertion checks that <code>errorLiveData</code> contains the <code>Test Exception</code> message we set in the previous step.</p>
			<ol>
				<li value="14">Run the <code>MovieRepositoryTest</code> test. Both the <code>fetchMovies</code> and <code>fetchMoviesWithError</code> tests should have no errors and both should pass.</li>
				<li>We will<a id="_idIndexMarker193"/> then create a test for <code>MovieViewModel</code>. First, we would need to update <code>MovieViewModel</code> so that we can change the dispatcher that the coroutine runs on. Open the <code>MovieViewModel</code> class and update its constructor by adding a dispatcher property to set the coroutine dispatcher:<pre>class MovieViewModel(private val movieRepository:
  MovieRepository, private val dispatcher:
  CoroutineDispatcher = Dispatchers.IO) : ViewModel() 
  {
    ...
}</pre></li>
			</ol>
			<p>This will allow you to change the dispatcher of <code>MovieViewModel</code> with another dispatcher, which you will be doing in the tests.</p>
			<ol>
				<li value="16">In the <code>fetchMovies</code> function, change the <code>launch</code> coroutine builder to use the <code>dispatcher</code> from the constructor instead of the hardcoded dispatcher:<pre>viewModelScope.launch(dispatcher) {
    ...
}</pre></li>
			</ol>
			<p>This updates the code to use the <code>dispatcher</code> set from the constructor or the default dispatcher (<code>Dispatchers.IO</code>). You can now create a unit test for the <code>MovieViewModel</code> class.</p>
			<ol>
				<li value="17">In <a id="_idIndexMarker194"/>the <code>app/src/test</code> directory, create a test class named <code>MovieViewModelTest</code> for <code>MovieViewModel</code> and add the <code>@OptIn(ExperimentalCoroutinesApi::class)</code> annotation to the class:<pre>@OptIn(ExperimentalCoroutinesApi::class)
class MovieViewModelTest {
    ...
}</pre></li>
			</ol>
			<p>This will be the test class for <code>MovieViewModel</code>. The <code>ExperimentalCoroutinesApi</code> annotation was added as some of the classes in the <code>kotlinx-coroutines-test</code> library are still experimental.</p>
			<ol>
				<li value="18">Inside the <code>MovieViewModelTest</code> class, add a JUnit test rule for <code>InstantTaskExecutorRule</code>:<pre>@get:Rule
val rule = InstantTaskExecutorRule()</pre></li>
			</ol>
			<p>The <code>InstantTaskExecutorRule</code> in the unit test executes the tasks synchronously. This is for the <code>LiveData</code> objects in <code>MovieViewModel</code>.</p>
			<ol>
				<li value="19">Create a test function called <code>fetchMovies</code> to test the <code>fetchMovies</code> suspending function from <code>MovieViewModel</code>:<pre>@Test
fun fetchMovies() {
    val expectedMovies =
      MutableLiveData&lt;List&lt;Movie&gt;&gt;()
    expectedMovies.postValue(listOf(Movie
      (title = “Movie”)))
 
    val movieRepository: MovieRepository = mock {
        onBlocking { movies } doReturn expectedMovies
    }
 }</pre></li>
			</ol>
			<p>This will<a id="_idIndexMarker195"/> mock <code>MovieRepository</code> so that its <code>movies</code> property will always return the <code>expectedMovies</code> as its value.</p>
			<ol>
				<li value="20">At the end of the <code>fetchMovies</code> test of <code>MovieViewModelTest</code>, add the following to test that <code>MovieViewModel</code>’s movies will be equal to <code>expectedMovies</code>:<pre>@Test
fun fetchMovies() {
    ...
 
    val movieViewModel = 
      MovieViewModel(movieRepository)
    assertEquals(expectedMovies.value,
      movieViewModel.movies.value)
}</pre></li>
			</ol>
			<p>This creates a <code>MovieViewModel</code> using the mocked <code>MovieRepository</code>. We are checking that the value of <code>MovieViewModel</code>’s <code>movies</code> is equal to the <code>expectedMovies</code> value we set to the mocked <code>MovieRepository</code>.</p>
			<ol>
				<li value="21">Run <code>MovieViewModelTest</code> or all the tests (<code>MovieRepositoryTest</code> and <code>MovieViewModelTest</code>). All tests should pass.</li>
				<li>Create another test function called <code>loading</code> in <code>MovieViewModelTest</code> to test the <code>loading</code> <code>LiveData</code> in <code>MovieViewModel</code>:<pre>@Test
fun loading() {
    ...
}</pre></li>
			</ol>
			<p>This will<a id="_idIndexMarker196"/> test the <code>loading</code> <code>LiveData</code> property of <code>MovieViewModel</code>. The loading property is <code>true</code> while fetching the movies and displays the <code>ProgressBar</code>. It becomes <code>false</code> and hides the <code>ProgressBar</code> after successfully fetching the movies or when an error is encountered.</p>
			<ol>
				<li value="23">In the <code>loading</code> test function, add the following to mock <code>MovieRepository</code> and initialize a dispatcher that will be used for <code>MovieViewModel</code>:<pre>@Test
fun loading() {
    val movieRepository: MovieRepository = mock()
    val dispatcher = StandardTestDispatcher()
 
    ...
}</pre></li>
			</ol>
			<p>This will mock <code>MovieRepository</code> and create a dispatcher of the <code>StandardTestDispatcher</code> type that will be used for the <code>MovieViewModel</code> test. This will allow you to control the execution of the task, which will be used later to check the value of <code>MovieViewModel</code>’s <code>loading</code> property.</p>
			<ol>
				<li value="24"> At the<a id="_idIndexMarker197"/> end of the <code>loading</code> test function, add the following to test the loading <code>MovieViewModel</code>’s <code>loading</code> property:<pre>@Test
fun loading() {
    ...
 
    runTest {
        val movieViewModel =
          MovieViewModel(movieRepository, dispatcher)
        
        movieViewModel.fetchMovies()
        assertTrue( movieViewModel.loading.value ==
          true)
        dispatcher.scheduler.advanceUntilIdle()
        assertFalse(movieViewModel.loading.value ==
          true)
    }
}</pre></li>
			</ol>
			<p>This will create a <code>MovieViewModel</code> with the mock <code>MovieRepository</code> and <code>dispatcher</code> you created in the previous step. Then, <code>fetchMovies</code> will be called from <code>MovieViewModel</code> to fetch the list of movies.</p>
			<p>The first assertion checks whether the <code>loading</code> value is <code>true</code>. We then used <code>advanceUntilIdle</code> from the dispatcher’s <code>scheduler</code> to execute all the tasks. This should change the <code>loading</code> value to <code>false</code>. The last line checks this indeed happens.</p>
			<ol>
				<li value="25">Run <a id="_idIndexMarker198"/>both <code>MovieRepositoryTest</code> and <code>MovieViewMo<a id="_idTextAnchor057"/>delTest</code>. All the tests should pass.</li>
			</ol>
			<p>In this exercise, you worked on an Android project that uses coroutines and you have added unit tests for these coroutines.</p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor058"/>Summary</h1>
			<p>This chapter focused on testing coroutines in your Android app. You started with learning how to set up your Android project in preparation for adding tests for your coroutines. The coroutines testing library (<code>kotlinx-coroutines-test</code>) helps you to create tests for your coroutines.</p>
			<p>You learned how to add unit tests for your suspending functions. You can use <code>runBlocking</code> and <code>runTest</code> to test code that calls suspending functions. <code>runTest</code> runs the code immediately, without delays. </p>
			<p>Then, you learned how to test coroutines. You can change the dispatcher in your test with a <code>TestDispatcher</code> (<code>StandardTestDispatcher</code> or <code>UnconfinedTestDispatcher</code>). <code>TestCoroutineScheduler</code> allows you to control the execution of the coroutine task.</p>
			<p>Finally, you worked on an exercise where you added unit tests for coroutines in an existing Android project.</p>
			<p>In the next chapter, you will explore Kotlin Flows and learn how you can use them for asynchronous programming in Android.</p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor059"/>Further reading</h1>
			<p>This book assumes that you already have knowledge of testing Android applications. If you would like to learn more about Android testing, you can read <em class="italic">Chapter 9</em>, <em class="italic">Unit Tests and Integration Tests with JUnit, Mockito, and Espresso</em>, from the book <em class="italic">How to Build Android Apps with Kotlin (Packt Publishing, 2021, ISBN 9781838984113)</em>. You can also check the Android testing documentation at <a href="https://developer.android.com/training/testing">https://developer.android.com/training/testing</a>.</p>
			<p>As of the time of writing, the coroutine testing library is still marked as experimental. Before the library becomes stable later, there might be some code-breaking changes to the classes. You can check the latest version of the library on GitHub at <a href="https://github.com/Kotlin/kotlinx.coroutines/tree/master/kotlinx-coroutines-test">https://github.com/Kotlin/kotlinx.coroutines/tree/master/kotlinx-coroutines-test</a> to find the latest information about the coroutine testing library.</p>
		</div>
		<div><div></div>
		</div>
	</body></html>