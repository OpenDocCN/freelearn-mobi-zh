<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Getting Started with Gradle and Android Studio</h1></div></div></div><p>When Google introduced Gradle and Android Studio, they had some goals in mind. They wanted to make it easier to reuse code, create build variants, and configure and customize the build process. On top of that, they wanted good IDE integration, but without making the build system dependent on the IDE. Running Gradle from the command line or on a continuous integration server will always yield the same results as running a build from Android Studio.</p><p>We will refer to Android Studio occasionally throughout the book, because it often provides a simpler way of setting up projects, dealing with changes, and so on. If you do not have Android Studio installed yet, you can download it from the Android developer<a id="id0" class="indexterm"/> website (<a class="ulink" href="http://developer.android.com/sdk/index.html">http://developer.android.com/sdk/index.html</a>).</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Getting to know Android Studio</li><li class="listitem" style="list-style-type: disc">Understanding Gradle basics</li><li class="listitem" style="list-style-type: disc">Creating a new project</li><li class="listitem" style="list-style-type: disc">Getting started with the Gradle wrapper</li><li class="listitem" style="list-style-type: disc">Migrating from Eclipse</li></ul></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Android Studio</h1></div></div></div><p>Android Studio <a id="id1" class="indexterm"/>was announced and released (as an early access preview) by Google in May 2013, alongside support for Gradle. Android Studio is based on JetBrains' IntelliJ IDEA, but is designed specifically with Android development in mind. It is available for free for Linux, Mac OS X, and Microsoft Windows.</p><p>Compared to Eclipse, Android Studio has an improved user interface designer, a better memory monitor, a nice editor for string translation, warnings for possible Android-specific issues and a lot more features aimed at Android developers. It also features a special project structure view for Android projects, besides the regular Project view and Packages view that exist in IntelliJ IDEA. This special view groups Gradle scripts, drawables, and other resources in a convenient way. As soon as the stable version 1.0 of Android Studio was released, Google retired the <a id="id2" class="indexterm"/>
<strong>Android Developer Tools</strong> (<strong>ADT</strong>) for Eclipse and recommended all developers to switch to Android Studio. This means that Google will not provide new features for Eclipse anymore, and all IDE-related tool development is now focused on Android Studio. If you are still using Eclipse, it is time to change if you do not want to be left behind.</p><p>This screenshot shows what <a id="id3" class="indexterm"/>Android Studio looks like for a simple Android app project:</p><div><img src="img/B01061_01_01.jpg" alt="Android Studio"/></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Staying up to date</h2></div></div></div><p>There are four different <a id="id4" class="indexterm"/>update channels<a id="id5" class="indexterm"/> for Android Studio:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Canary brings bleeding-edge updates, but might contain some bugs</li><li class="listitem" style="list-style-type: disc">The Dev channel gets an update more or less every month</li><li class="listitem" style="list-style-type: disc">Beta is used feature complete updates that might still contain bugs</li><li class="listitem" style="list-style-type: disc">The Stable channel, which is the default, features thoroughly tested releases that should be bug-free</li></ul></div><p>By default, Android Studio checks every time it starts if there any updates available and notifies you.</p><p>When you launch Android Studio for the first time, it starts a wizard to set up your environment and to make sure you have the latest Android SDK and the necessary Google repositories. It also gives you the option to create an <a id="id6" class="indexterm"/>
<strong>Android Virtual Device</strong> (<strong>AVD</strong>), so you can run apps on the emulator.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Understanding Gradle basics</h1></div></div></div><p>In order for an Android project to be built using Gradle, you need to set up a build script. This will always be called <code class="literal">build.gradle</code>, by convention. You will notice, as we go through the basics, that Gradle<a id="id7" class="indexterm"/> favors convention over configuration and generally <a id="id8" class="indexterm"/>provides default values for settings and properties. This makes it a lot easier to get started with a lot less configuration than that found in systems such as Ant or Maven, which have been the de facto build systems for Android projects for a long time. You do not need to absolutely comply with these conventions though, as it is usually possible to override them if needed.</p><p>Gradle build scripts are not written in the traditional XML, but in a <strong>domain-specific language</strong> (<strong>DSL</strong>)<a id="id9" class="indexterm"/> based on <a id="id10" class="indexterm"/>Groovy, a dynamic language for the <a id="id11" class="indexterm"/>
<strong>Java Virtual Machine</strong> (<strong>JVM</strong>). The team behind Gradle believes that using a declarative, DSL-style approach based on a dynamic language has significant advantages over using the more procedural, free-floating style of Ant, or any XML-based approach used by many other build systems.</p><p>That does not mean you need to know Groovy to get started with your build scripts. It is easy to read, and if you already know Java, the learning curve is not that steep. If you want to start creating your own tasks and plugins (which we will talk about in later chapters), it is useful to have a deeper understanding of Groovy. However, because it is based on the JVM, it is possible to write code for your custom plugins in Java or any other JVM-based language.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Projects and tasks</h2></div></div></div><p>The two most <a id="id12" class="indexterm"/>important concepts in Gradle are projects and tasks. Every build is made <a id="id13" class="indexterm"/>up of at least one project, and every project <a id="id14" class="indexterm"/>contains one or more tasks. Every <code class="literal">build.gradle</code> file represents a project. Tasks <a id="id15" class="indexterm"/>are then simply defined inside the build script. When initializing the build process, Gradle assembles <code class="literal">Project</code> and <code class="literal">Task</code> objects based on the build file. A <code class="literal">Task</code> object consists of a list of <code class="literal">Action</code> objects, in the order they need to be executed. An <code class="literal">Action</code> object is a block of code that is executed, similar to a method in Java.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec09"/>The build lifecycle</h2></div></div></div><p>Executing a <a id="id16" class="indexterm"/>Gradle build is, in its simplest form, just executing actions on <a id="id17" class="indexterm"/>tasks, which are dependent on other tasks. To simplify the build process, the build tools create a dynamic model of the workflow as a <a id="id18" class="indexterm"/>
<strong>Directed Acyclic Graph</strong> (<strong>DAG</strong>). This means all the tasks are processed one after the other and loops are not possible. Once a task has been executed, it will not be called again. Tasks without dependencies will always be run before the others. The dependency graph is generated during the configuration phase of a build. A Gradle<a id="id19" class="indexterm"/> build has three phases:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Initialization</strong>: This is <a id="id20" class="indexterm"/>where the <code class="literal">Project</code> instance is created. If there are multiple modules, each with their own <code class="literal">build.gradle</code> file, multiple projects will be created.</li><li class="listitem" style="list-style-type: disc"><strong>Configuration</strong>: In <a id="id21" class="indexterm"/>this phase, the build scripts are executed, creating and configuring all the tasks for every project object.</li><li class="listitem" style="list-style-type: disc"><strong>Execution</strong>: This is the <a id="id22" class="indexterm"/>phase where Gradle determines which tasks should be executed. Which tasks should be executed depends on the arguments passed for starting the build and what the current directory is.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec10"/>The build configuration file</h2></div></div></div><p>In order to <a id="id23" class="indexterm"/>have Gradle<a id="id24" class="indexterm"/> build a project, there always needs to be a <code class="literal">build.gradle</code> file. A build file for Android has a few required elements:</p><div><pre class="programlisting">buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:1.2.3'
    }
}</pre></div><p>This is where the actual build is configured. In the repositories block, the JCenter repository is configured as a source of dependencies for the build script. JCenter is a preconfigured Maven repository and requires no extra setup; Gradle has you covered. There are several repositories available straight from Gradle and it is easy to add your own, either local or remote.</p><p>The build <a id="id25" class="indexterm"/>script block also defines a dependency <a id="id26" class="indexterm"/>on Android build tools as a classpath Maven artifact. This is where the Android plugin comes from. The Android plugin provides everything needed to build and test applications. Every Android project needs to apply the Android plugin using this line:</p><div><pre class="programlisting">apply plugin: 'com.android.application'</pre></div><p>Plugins are used to extend the capabilities of a Gradle build script. Applying a plugin to a project makes it possible for the build script to define properties and use tasks that are defined in the plugin.</p><div><div><h3 class="title"><a id="note02"/>Note</h3><p>If you are building a library, you need to apply <code class="literal">'com.android.library'</code> instead. You cannot use both in the same module because that would result in a build error. A module can be either an Android application or an Android library, not both.</p></div></div><p>When using the Android plugin, Android-specific conventions can be configured and tasks only applicable to Android will be generated. The Android block in the following snippet is defined by the plugin and can be configured per project:</p><div><pre class="programlisting">android {
    compileSdkVersion 22
    buildToolsVersion "22.0.1"
}</pre></div><p>This is where the Android-specific part of the build is configured. The Android plugin provides a DSL tailored to Android's needs. The only required properties are the compilation target and the build tools. The compilation target, specified by <code class="literal">compileSdkVersion</code>, is the SDK version that should be used to compile the app. It is good practice to use the latest Android API version as the compilation target.</p><p>There are plenty of customizable properties in the <code class="literal">build.gradle</code> file. We will discuss the most important properties in <a class="link" href="ch02.html" title="Chapter 2. Basic Build Customization">Chapter 2</a>, <em>Basic Build Customization</em>, and more possibilities throughout the rest of the book.</p><div><div><div><div><h3 class="title"><a id="ch01lvl1sec1110"/>The project structure</h3></div></div></div><p>Compared to the old<a id="id27" class="indexterm"/> Eclipse projects, the folder structure for Android projects has changed considerably. As mentioned earlier, Gradle favors convention over configuration and this also applies to the folder structure.</p><p>This is the folder structure that Gradle expects for a simple app:</p><div><pre class="programlisting">MyApp
├── build.gradle
├── settings.gradle
└── app
    ├── build.gradle
    ├── build
    ├── libs
    └── src
        └── main
            ├── java
            │   └── com.package.myapp
            └── res
                ├── drawable
                ├── layout
                └── etc.</pre></div><p>Gradle projects usually have an extra level at the root. This makes it easier to add extra modules at a later point. All source code for the app goes into the <code class="literal">app</code> folder. The folder is also the name of the module by default and does not need to be named app. If you use Android Studio to create a project with both a mobile app and an Android Wear smartwatch app, for example, the modules are called application and wearable by default.</p><p>Gradle makes use of a concept called source set. The official Gradle documentation explains that a source set is <em>a group of source files, which are compiled and executed together</em>. For an Android project, <code class="literal">main</code> is the source set that contains all the source code and resources for the default version of the app. When you start writing tests for your Android app, you will put the source code for the tests inside a separate source set called <code class="literal">androidTest</code>, which only contains tests.</p><p>Here is a short overview of the most important folders of an Android app:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Directory</p>
</th><th style="text-align: left" valign="bottom">
<p>Content</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">/src/main/java</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The source code for the app</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">/src/main/res</code>
</p>
</td><td style="text-align: left" valign="top">
<p>These are app-related resources (drawables, layouts, strings, and so on)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">/libs</code>
</p>
</td><td style="text-align: left" valign="top">
<p>These <a id="id28" class="indexterm"/>are external <a id="id29" class="indexterm"/>libraries (<code class="literal">.jar</code> or <code class="literal">.aar</code>)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">/build</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The output of the build process</p>
</td></tr></tbody></table></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Creating a new project</h1></div></div></div><p>You can start a new <a id="id30" class="indexterm"/>project in Android Studio by clicking on <strong>Start a new Android Studio project</strong> on the start screen or by navigating to <strong>File</strong> | <strong>New Project…</strong> in the IDE itself.</p><p>Creating a new project in Android Studio starts with a wizard that helps set everything up. The first screen is for setting up the application name and the company domain. The application name is the name that will be used as the name of the app when it is installed and is used as the toolbar title by default. The company domain is used in combination with the application name to determine the package name, which is the unique identifier for any Android app. If you prefer a different package name, you can still change it by clicking on <strong>Edit</strong>. You can also change the location of the project on your hard drive.</p><div><img src="img/B01061_01_02.jpg" alt="Creating a new project"/></div><p>No files are generated before going through all the steps in the wizard, because the next few steps will define which files need to be created.</p><p>Android does not only <a id="id31" class="indexterm"/>run on phones and tablets, but also supports a broad range of form factors, such as TV, watches, and glasses. The next screen helps you set up all the form factors you want to target in your project. Depending on what you choose here, dependencies and build plugins are included for development. This is where you decide if you just want to make a phone and tablet app or whether you also want to include an Android TV module, an Android Wear module, or a Google Glass module. You can still add these later, but the wizard makes it easy by adding all the necessary files and configurations. This is also where you choose what version of Android you want to support. If you select an API version below 21, the Android Support Library (including the <code class="literal">appcompat</code> library) is automatically added as a dependency.</p><div><img src="img/B01061_01_03.jpg" alt="Creating a new project"/></div><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>
<strong>Downloading the example code</strong>
</p><p>You can download the example code files from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><p>The following screen suggests adding an activity and provides a lot of options, all of which result in generated code that makes it easier to get started. If you choose to have Android Studio generate an activity for you, the next step is to enter a name for the activity class, the layout file and the menu resource, and also to give the activity a title:</p><div><img src="img/B01061_01_04.jpg" alt="Creating a new project"/></div><p>After you go through <a id="id32" class="indexterm"/>the entire wizard, Android Studio generates source code for an activity and a fragment, depending on the choices you made during the wizard. Android Studio also generates the basic Gradle files to make the project build. You will find a file called <code class="literal">settings.gradle</code> and one called <code class="literal">build.gradle</code> on the top level of the project. Inside the app module folder, there is another <code class="literal">build.gradle</code> file. We will go into more detail about the content and the purpose of these files in <a class="link" href="ch02.html" title="Chapter 2. Basic Build Customization">Chapter 2</a>, <em>Basic Build Customization</em>.</p><p>You now have several options to trigger a build from inside Android Studio:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Inside the <strong>Build</strong> menu, you can click on <strong>Make Project</strong>, or you can use the keyboard shortcut, which is <em>Ctrl</em> + <em>F9</em> on a PC and <em>Cmd</em> + <em>F9</em> on Mac OS X</li><li class="listitem" style="list-style-type: disc">The toolbar has a shortcut for the same <strong>Make Project</strong></li><li class="listitem" style="list-style-type: disc">The Gradle tool window, which lists all the available Gradle tasks</li></ul></div><p>In the Gradle tool window, you can try to execute <code class="literal">assembleDebug</code> to build, or <code class="literal">installDebug</code> to install the app on a device or emulator. We will discuss these tasks in the next part of this chapter, which deals with the Gradle wrapper.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Getting started with the Gradle Wrapper</h1></div></div></div><p>Gradle<a id="id33" class="indexterm"/> is a tool that is under constant development, and new versions could potentially break backward compatibility. Using the Gradle Wrapper is a good way to avoid issues and to make sure builds are reproducible.</p><p>The Gradle Wrapper<a id="id34" class="indexterm"/> provides a batch file on Microsoft Windows and a shell script on other operating systems. When you run the script, the required version of Gradle is downloaded (if it is not present yet) and used automatically for the build. The idea behind this is that every developer or automated system that needs to build the app can just run the wrapper, which will then take care of the rest. This way, it is not required to manually install the correct version of Gradle on a developer machine or build server. Therefore, it is also recommended to add the wrapper files to your version control system.</p><p>Running the Gradle Wrapper is not that different from running Gradle directly. You just execute <code class="literal">gradlew</code> on Linux and Mac OS X and <code class="literal">gradlew.bat</code> on Microsoft Windows, instead of the regular <code class="literal">gradle</code> command.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Getting the Gradle Wrapper</h2></div></div></div><p>For your convenience, every <a id="id35" class="indexterm"/>new Android project includes the Gradle Wrapper, so when you create a new project, you do not have to do anything at all to get the necessary files. It is, of course, possible to install Gradle manually on your computer and use it for your project, but the Gradle Wrapper can do the same things and guarantee that the correct version of Gradle is used. There is no good reason not to use the wrapper when working with Gradle outside of Android Studio.</p><p>You can check if the Gradle Wrapper is present in your project by navigating to the project folder and running <code class="literal">./gradlew –v</code> from the terminal or <code class="literal">gradlew.bat –v</code> from Command Prompt. Running this command displays the version of Gradle and some extra information about your setup. If you are converting an Eclipse project, the wrapper will not be present by default. In this case, it is possible to generate it using Gradle, but you will need to install Gradle first to get the wrapper.</p><div><div><h3 class="title"><a id="note03"/>Note</h3><p>The Gradle<a id="id36" class="indexterm"/> download page (<a class="ulink" href="http://gradle.org/downloads">http://gradle.org/downloads</a>) has links to binaries and the source code, and it is possible to use a package manager such as Homebrew if you are on Mac OS X. All the instructions for installation are on the<a id="id37" class="indexterm"/> installation page (<a class="ulink" href="http://gradle.org/installation">http://gradle.org/installation</a>).</p></div></div><p>After you have downloaded and installed Gradle and added it to your <code class="literal">PATH</code>, create a <code class="literal">build.gradle</code> file containing these three lines:</p><div><pre class="programlisting">task wrapper(type: Wrapper) {
    gradleVersion = '2.4'
}</pre></div><p>After that, run <code class="literal">gradle wrapper</code> to generate the wrapper files.</p><p>In recent <a id="id38" class="indexterm"/>versions of Gradle, you can also run the wrapper task without modifying the <code class="literal">build.gradle</code> file, because it is included as a task by default. In that case, you can specify the version with the <code class="literal">--gradle-version</code> parameter, like this:</p><div><pre class="programlisting">
<strong>$ gradle wrapper --gradle-version 2.4</strong>
</pre></div><p>If you do not specify a version number, the wrapper is configured to use the Gradle version that the task is executed with.</p><p>These are all the files generated by the wrapper task:</p><div><pre class="programlisting">myapp/
├── gradlew
├── gradlew.bat
└── gradle/wrapper/
    ├── gradle-wrapper.jar
    └── gradle-wrapper.properties</pre></div><p>You can see here that the Gradle Wrapper has three parts:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A batch file on Microsoft Windows and a shell script on Linux and Mac OS X</li><li class="listitem" style="list-style-type: disc">A JAR file that is used by the batch file and shell script</li><li class="listitem" style="list-style-type: disc">A <code class="literal">properties</code> file</li></ul></div><p>The <code class="literal">gradle-wrapper.properties</code> file is the one that contains the configuration and determines what version of Gradle is used:</p><div><pre class="programlisting">#Sat May 30 17:41:49 CEST 2015
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-2.4-all.zip</pre></div><p>You can change the distribution URL if you want to use a customized Gradle distribution internally. This also means that any app or library that you use could have a different URL for Gradle, so be sure to check whether you can trust the properties before you run the wrapper.</p><p>Android <a id="id39" class="indexterm"/>Studio is kind enough to display a notification when the Gradle version used in a project is not up to date and will suggest automatically updating it for you. Basically, Android Studio changes the configuration in the <code class="literal">gradle-wrapper.properties</code> file and triggers a build, so that the latest version gets downloaded.</p><div><div><h3 class="title"><a id="note04"/>Note</h3><p>Android Studio uses the information in the properties to determine which version of Gradle to use, and it runs the wrapper from the Gradle Wrapper directory inside your project. However, it does not make use of the shell or bash scripts, so you should not customize those.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Running basic build tasks</h2></div></div></div><p>In the terminal or<a id="id40" class="indexterm"/> command prompt, navigate to the project directory and run the Gradle Wrapper with the <code class="literal">tasks</code> command:</p><div><pre class="programlisting">
<strong>$ gradlew tasks</strong>
</pre></div><p>This will print out a list of all the available tasks. If you add the <code class="literal">--all</code> parameter, you will get a more detailed overview with the dependencies for every task.</p><div><div><h3 class="title"><a id="note05"/>Note</h3><p>On Microsoft Windows, you need to run <code class="literal">gradlew.bat</code>, and on Linux and Mac OS X, the full command is <code class="literal">./gradlew</code>. For the sake of brevity, we will just write <code class="literal">gradlew</code> throughout this book.</p></div></div><p>To build the project while you are developing, run the assemble task with the debug configuration:</p><div><pre class="programlisting">
<strong>$ gradlew assembleDebug</strong>
</pre></div><p>This task will create an APK with the debug version of the app. By default, the Android plugin for Gradle saves the APK in the directory <code class="literal">MyApp/app/build/outputs/apk</code>.</p><div><div><h3 class="title"><a id="tip03"/>Tip</h3><p>
<strong>Abbreviated task names</strong>
</p><p>To avoid a lot of typing <a id="id41" class="indexterm"/>in the terminal, Gradle also provides abbreviated Camel case task names as shortcuts. For example, you can execute <code class="literal">assembleDebug</code> by running <code class="literal">gradlew assDeb</code>, or even <code class="literal">gradlew aD</code>, from the command-line interface.</p><p>There is one caveat to this though. It will only work as long as the Camel case abbreviation is unique. As soon as another task has the same abbreviation, this trick does not work anymore for those tasks.</p></div></div><p>Besides <code class="literal">assemble</code>, there are three <a id="id42" class="indexterm"/>other <a id="id43" class="indexterm"/>basic tasks:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">check</code> runs <a id="id44" class="indexterm"/>all the checks, this usually means running tests on a connected device or emulator</li><li class="listitem" style="list-style-type: disc"><code class="literal">build</code><a id="id45" class="indexterm"/> triggers both <code class="literal">assemble</code> and <code class="literal">check</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">clean</code> cleans<a id="id46" class="indexterm"/> the output of the project</li></ul></div><p>We will discuss these tasks in detail in <a class="link" href="ch02.html" title="Chapter 2. Basic Build Customization">Chapter 2</a>, <em>Basic Build Customization</em>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Migrating from Eclipse</h1></div></div></div><p>There are two ways<a id="id47" class="indexterm"/> to take on migration from an Eclipse project to a Gradle-based project:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use the import wizard in Android Studio to handle migration automatically</li><li class="listitem" style="list-style-type: disc">Add a Gradle script to the Eclipse project and set everything up manually</li></ul></div><p>Most projects are simple enough for the import wizard to be able to convert everything automatically. If there is something the wizard cannot figure out, it might even give you hints as to what you need to change for it to work.</p><p>Some projects, though, might be extremely complicated and require a manual conversion. If you have a huge project and you prefer to convert the project in steps, instead of all at once, it is possible to execute Ant tasks, or even entire Ant builds from Gradle. Doing that, you can do the transition at the pace you prefer and convert all the components slowly.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Using the import wizard</h2></div></div></div><p>To start the import <a id="id48" class="indexterm"/>wizard, you need to open Android Studio, click on the <strong>File</strong> menu and then on <strong>Import Project...</strong>, or on the Android Studio start screen, click on <strong>Import Non-Android Studio project</strong>.</p><p>If you convert a project with JAR files or library sources, the import wizard will suggest replacing those with Gradle dependencies. These dependencies can come from local Google repositories (such as the Android Support Library) or even from a known online repository central. If no matching Google or online dependencies are found, the JAR file is used, as it was before. The import wizard creates at least one module for your app. If you have libraries with source code in your project, those are converted to modules as well.</p><p>This is what the import wizard looks like:</p><div><img src="img/B01061_01_05.jpg" alt="Using the import wizard"/></div><p>Studio <a id="id49" class="indexterm"/>creates a new folder to make sure you do not lose anything when you convert, and you can easily compare the outcome of the import wizard with the original. When the conversion is done, Android Studio opens the project and shows an import summary.</p><p>The summary lists any files that the import wizard decided to ignore and did not copy to the new project. If you want to include those anyway, you have to manually copy them to the new project. Right below the ignored files, the summary shows any JAR files that the import wizard was able to replace with Gradle dependencies. Android Studio tries to find those dependencies on JCenter. If you are using the Support Library, it is now included in the Google repository that is downloaded to your machine using the SDK manager, instead of a JAR file. Finally, the summary lists all the files that the import wizard has moved, showing their origin and destination.</p><p>The import wizard also adds three Gradle files: <code class="literal">settings.gradle</code> and <code class="literal">build.gradle</code> on the root, and another <code class="literal">build.gradle</code> in the module.</p><p>If you have any libraries that include source code, the import wizard turns those into Gradle projects as well and links everything together as necessary.</p><p>The project should now build without any issues, but keep in mind that you might need an Internet connection to download some of the necessary dependencies.</p><p>Projects that<a id="id50" class="indexterm"/> are more complicated might require extra work though, so next we will take a look at how to do the conversion manually.</p><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>
<strong>The Eclipse export wizard</strong>
</p><p>There is an export <a id="id51" class="indexterm"/>wizard in Eclipse as well, but it is completely outdated because the Android Tools team at Google stopped working on the Android Developer Tools for Eclipse. Therefore, it is recommended to always use the import wizard in Android Studio instead.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Migrating manually</h2></div></div></div><p>There are multiple <a id="id52" class="indexterm"/>ways to go about manually migrating to a Gradle-based Android project. It is not required to change to the new directory structure, and it is even possible to run Ant scripts from your Gradle scripts. This makes the process of migrating very flexible, and it can make the transition easier for larger projects. We will look at running Ant tasks in <a class="link" href="ch09.html" title="Chapter 9. Advanced Build Customization">Chapter 9</a>, <em>Advanced Build Customization</em>.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Keeping the old project structure</h3></div></div></div><p>If you do not want to move files around, it is possible to keep the Eclipse folder structure in your project. To do that, you need to change the source set configuration. We mentioned source sets earlier when talking about the project structure. Gradle and the Android plugin have their defaults, as usual, but it is possible to override those.</p><p>The first thing you need to do is to create a <code class="literal">build.gradle</code> file in the project directory. This file should apply the Android plugin and define the required properties for Gradle and the Android plugin. In its simplest form, it looks like this:</p><div><pre class="programlisting">buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:1.2.3'
    }
}

apply plugin: 'com.android.application'

android {
    compileSdkVersion 22
    buildToolsVersion "22.0.1"
}</pre></div><p>Then you can start by changing the source set. Usually, overriding the main source set to comply with the Eclipse structure looks like this:</p><div><pre class="programlisting">android {
  sourceSets {
    main {
      manifest.srcFile 'AndroidManifest.xml'
      java.srcDirs = ['src']
      resources.srcDirs = ['src']
      aidl.srcDirs = ['src']
      renderscript.srcDirs = ['src']
      res.srcDirs = ['res']
      assets.srcDirs = ['assets']
    }

  androidTest.setRoot('tests')
  }
}</pre></div><p>In the Eclipse folder structure, all source files will reside in the same folder, so you need to tell Gradle that all these components can be found in the <code class="literal">src</code> folder. You only need to include the components that are in your project, but adding them all does no harm.</p><p>If you have any dependencies on JAR files, you need to tell Gradle where the dependencies are located. Assuming the JAR files are in a folder called <code class="literal">libs</code>, the configuration looks like this:</p><div><pre class="programlisting">dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
}</pre></div><p>This one-liner includes every file with the extension <code class="literal">.jar</code> inside the <code class="literal">libs</code> directory as a dependency.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Converting to the new project structure</h3></div></div></div><p>If you decide to<a id="id53" class="indexterm"/> convert to the new project structure manually, you need to create a few folders and move some files. This table shows an overview of the most important files and folders, and where you need to move them to convert to the new project structure:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Old location</p>
</th><th style="text-align: left" valign="bottom">
<p>New location</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">src/</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">app/src/main/java/</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">res/</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">app/src/main/res/</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">assets/</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">app/src/main/assets/</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">AndroidManifest.xml</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">app/src/main/AndroidManifest.xml</code>
</p>
</td></tr></tbody></table></div><p>If you have any unit tests, you need to move the source code for those to <code class="literal">app/src/test/java/</code> to have Gradle recognize them automatically. Functional tests belong in the <code class="literal">app/src/androidTest/java/</code> folder.</p><p>The next step is to create a <code class="literal">settings.gradle</code> file in the root of the project. This file needs to contain only one line, and its purpose is to tell Gradle to include the <code class="literal">app</code> module in the build:</p><div><pre class="programlisting">include: ':app'</pre></div><p>When that is ready, you need two <code class="literal">build.gradle</code> files for a successful Gradle build. The first one belongs in the root of the project (on the same level as <code class="literal">settings.gradle</code>) and is used to define project-wide settings:</p><div><pre class="programlisting">buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:1.2.3'
    }
}</pre></div><p>This sets up a few properties for all modules in the project. The second <code class="literal">build.gradle</code> goes in the <code class="literal">app</code> folder and contains module-specific settings:</p><div><pre class="programlisting">apply plugin: 'com.android.application'

android {
    compileSdkVersion 22
    buildToolsVersion "22.0.1"
}</pre></div><p>These are the <a id="id54" class="indexterm"/>absolute basics. If you have a simple Android app that does not depend on third-party code, this will suffice. If you have any dependencies, you need to migrate those to Gradle as well.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec03"/>Migrating libraries</h3></div></div></div><p>If you have any libraries in<a id="id55" class="indexterm"/> your project that contain Android-specific code, those also need to use Gradle in order for them to play nice with the app module. The same basics apply, but you need to use the Android library plugin instead of the Android application plugin. The details of this process are discussed in <a class="link" href="ch05.html" title="Chapter 5. Managing Multimodule Builds">Chapter 5</a>, <em>Managing Multimodule Builds</em>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Summary</h1></div></div></div><p>We started the chapter by looking at the advantages of Gradle and why it is more useful than other build systems currently in use. We briefly looked at Android Studio and how it can help us by generating build files.</p><p>After the introduction, we took a look at the Gradle Wrapper, which makes maintenance and sharing projects a lot easier. We created a new project in Android Studio, and you now know how to migrate an Eclipse project to Android Studio and Gradle, both automatically and manually. You are also capable of building projects with Gradle in Android Studio, or straight from the command-line interface.</p><p>In the next few chapters, we will look at ways to customize the build, so you can further automate the build process and make maintenance even easier. We will start by examining all the standard Gradle files, exploring basic build tasks, and customizing parts of the build in the next chapter.</p></div></body></html>