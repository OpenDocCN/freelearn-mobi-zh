<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Streaming Your Data</h1>
                
            
            
                
<p class="calibre2">In this chapter, we'll discuss higher-order functions for collections. For Java developers, they first appeared in Java 8 with the introduction of Stream API. But they were around for much longer in functional languages. </p>
<p class="calibre2">First, since we expect that many of our readers are familiar with Java 8, let's cover what Stream API is in Java briefly.</p>
<p class="calibre2">Streams from Java8 are not to be confused with some of the I/O classes with similar names, such as <kbd class="calibre13">InputStream</kbd> or <kbd class="calibre13">OutputStream</kbd>. While the latter represent data, the former are sequences of elements of the same type.</p>
<p class="calibre2">If those are sequences, and they all have the same type, how are they different from <kbd class="calibre13">Lists</kbd>? Well, streams can be infinite, unlike collections.</p>
<p class="calibre2">There is also a set of actions defined for Java streams. Not only are those actions the same for any kind of stream, they also have familiar names for those that come from totally different languages. There's the <kbd class="calibre13">map()</kbd> function in JavaScript, which does the same as the <kbd class="calibre13">map()</kbd> method in Java.</p>
<p class="calibre2">The idea of making extensive use of small, reusable, and composable functions comes directly from functional programming, which we discussed in the previous chapter. They allow us to write code in a manner that tells <em class="calibre14">what</em> we want to do, instead of <em class="calibre14">how</em> we want to do it.</p>
<p class="calibre2">But in Java, to use those functions, we have to either receive a stream or create a stream from a collection.</p>
<p class="calibre2">In Java, in order to get to all this functional goodness for collections, we can do the following:</p>
<pre class="calibre18">Arrays.asList("a", "b", "c") // Initialize list<br class="title-page-name"/>    .stream() // Convert to stream<br class="title-page-name"/>    .map(...) // Do something functional here   <br class="title-page-name"/>    .toList() // Convert back to list</pre>
<p class="calibre2">In Kotlin, you can do the same:</p>
<pre class="calibre18">listOf("a", "b", "c").stream().map{...}.toList()</pre>
<p class="calibre2">But all those methods and more are available directly on collections:</p>
<pre class="calibre18">listOf("a", "b", "c").map(...) </pre>
<p class="calibre2">That's all; there is no need to convert from the stream and back unless you plan to operate on <em class="calibre14">infinite data</em> in the first place.</p>
<p class="calibre2">Of course, it's not as simple as that, but we cover the differences and pitfalls near the end of this chapter, in the <em class="calibre14">Streams are lazy, collections are not</em> section. Let's start by understanding what those weird functions actually do.</p>
<p class="calibre2">In this chapter, we won't be able to cover all the functions available on collections, but we'll cover the most widely used ones. </p>
<p class="calibre2">The examples will be somewhat boring, mostly lists of numbers, letters, and people. That's to let you focus on how each function actually works. We'll go back to some crazy examples in the next chapter. Stay tuned.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The it notation</h1>
                
            
            
                
<p class="calibre2">We glanced at the notion of <kbd class="calibre13">it</kbd> briefly in previous chapters, but for this chapter, we need to understand it a bit more (pun intended).</p>
<p class="calibre2">Kotlin is all about brevity. First, if our lambda doesn't have an argument, we don't need to specify anything:</p>
<pre class="calibre18">val noParameters = { 1 } // () -&gt; Int implicitly</pre>
<p class="calibre2">But what if we have a function that takes another function as an argument (and doesn't do anything with it for simplicity)? See the following code:</p>
<pre class="calibre18">fun oneParameter(block: (Int)-&gt;Long){ }</pre>
<p class="calibre2">We can specify both the argument name and type explicitly, and wrap them in brackets, like any other function invocation:</p>
<pre class="calibre18">val oneParameterVeryVeryExplicit = oneParameter( {x: Int -&gt; x.toLong() })</pre>
<p class="calibre2">But since the lambda is the last parameter (and the only one, in this case), we can omit the brackets:</p>
<pre class="calibre18">val oneParameterVeryExplicit = oneParameter {x: Int -&gt; x.toLong() }</pre>
<p class="calibre2">And since the compiler can infer the type of parameter, we can omit it too:</p>
<pre class="calibre18">val oneParameterExplicit = oneParameter {x -&gt; x.toLong() }</pre>
<p class="calibre2">And since <kbd class="calibre13">x</kbd> is the only parameter, we can use the implicit name for it, which is <kbd class="calibre13">it</kbd>:</p>
<pre class="calibre18">val oneParameterImplicit = oneParameter { <strong class="calibre1">it</strong>.toLong() }</pre>
<p class="calibre2">We'll use the shortest notation in most of the following examples.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The map() function</h1>
                
            
            
                
<p class="calibre2">One of the most well known higher-order functions on collections is <kbd class="calibre13">map()</kbd>.</p>
<p class="calibre2">Let's say you have a function that receives a list of strings and returns a new list of the same size containing each string concatenated to itself:</p>
<pre class="calibre18">val letters = listOf("a", "b", "c", "d")<br class="title-page-name"/><br class="title-page-name"/>println(repeatAll(letters)) // [aa, bb, cc, dd]</pre>
<p class="calibre2">The task is quite trivial:</p>
<pre class="calibre18">fun repeatAll(letters: List&lt;String&gt;): MutableList&lt;String&gt; {<br class="title-page-name"/>    val repeatedLetters = mutableListOf&lt;String&gt;()<br class="title-page-name"/><br class="title-page-name"/>    for (l in letters) {<br class="title-page-name"/>        repeatedLetters.add(l + l)<br class="title-page-name"/>    }<br class="title-page-name"/>    return repeatedLetters<br class="title-page-name"/>}</pre>
<p class="calibre2">But for such a trivial task, we had to write quite a lot of code. What would we have to change in order to capitalize each string instead of repeating it twice? We would like to change only this line:</p>
<pre class="calibre18">repeatedLetters.add(l + l) ----&gt; repeatedLetters.add(l.toUpperCase())</pre>
<p class="calibre2">But we have to create another function for that.</p>
<p class="calibre2">Of course, in Kotlin, we could pass a function as a second parameter. And since we don't actually care what the type is, as long as it's the same for both input and output, we can use generics:</p>
<pre class="calibre18">fun <strong class="calibre1">&lt;T&gt;</strong> repeatSomething(input: List&lt;<strong class="calibre1">T</strong>&gt;, action: (<strong class="calibre1">T</strong>) -&gt; <strong class="calibre1">T</strong>): MutableList&lt;<strong class="calibre1">T</strong>&gt; {<br class="title-page-name"/>    val result = mutableListOf&lt;<strong class="calibre1">T</strong>&gt;()<br class="title-page-name"/>    <br class="title-page-name"/>    for (i in input) {<br class="title-page-name"/>        result.add(action(i))<br class="title-page-name"/>    }<br class="title-page-name"/>    return result<br class="title-page-name"/>}</pre>
<p class="calibre2">Now we can call our <em class="calibre14">generified</em> function as follows:</p>
<pre class="calibre18">println(repeatSomething(letters) {<br class="title-page-name"/>    it.toUpperCase()<br class="title-page-name"/>})</pre>
<p class="calibre2">And that's almost exactly what <kbd class="calibre13">.map()</kbd> does:</p>
<pre class="calibre18">println(letters.map {<br class="title-page-name"/>    it.toUpperCase()<br class="title-page-name"/>})</pre>
<p class="calibre2">Another variation of <kbd class="calibre13">map()</kbd> is <kbd class="calibre13">mapTo()</kbd>.</p>
<p class="calibre2">In addition to the lambda, it receives the destination where the results should be incorporated.</p>
<p class="calibre2">You could do the following:</p>
<pre class="calibre18">val letters = listOf("a", "B", "c", "D")<br class="title-page-name"/>val results = mutableListOf&lt;String&gt;()<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">results</strong>.addAll(letters.map {<br class="title-page-name"/>    it.toUpperCase()<br class="title-page-name"/>})<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">results</strong>.addAll(letters.map {<br class="title-page-name"/>    it.toLowerCase()<br class="title-page-name"/>})<br class="title-page-name"/><br class="title-page-name"/>println(results)</pre>
<p class="calibre2">But <kbd class="calibre13">mapTo()</kbd> lets you do this:</p>
<pre class="calibre18">val letters = listOf("a", "B", "c", "D")<br class="title-page-name"/>val results = mutableListOf&lt;String&gt;()<br class="title-page-name"/><br class="title-page-name"/>letters.mapTo(<strong class="calibre1">results</strong>) {<br class="title-page-name"/>    it.toUpperCase()<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>letters.mapTo(<strong class="calibre1">results</strong>) {<br class="title-page-name"/>    it.toLowerCase()<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>println(results)</pre>
<p class="calibre2">In the second option, we use the results list as an argument, which allows us to reduce code nesting.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Filter family</h1>
                
            
            
                
<p class="calibre2">Another common task is filtering a collection. You know the drill. You iterate over it and put only values that fit your criteria in a new collection. For example, if given a range of numbers between 1-10, we would like to return only odd ones. Of course, we've already learned this lesson from the previous example, and wouldn't simply create a function called <kbd class="calibre13">filterOdd()</kbd>, as later we would be required to also implement <kbd class="calibre13">filterEven()</kbd>, <kbd class="calibre13">filterPrime()</kbd>, and so on. We'll receive a lambda as the second argument right away:</p>
<pre class="calibre18">fun filter(numbers: List&lt;Int&gt;, check: (Int)-&gt;Boolean): MutableList&lt;Int&gt; {<br class="title-page-name"/>    val result = mutableListOf&lt;Int&gt;()<br class="title-page-name"/><br class="title-page-name"/>    for (n in numbers) {<br class="title-page-name"/>        if (check(n)) {<br class="title-page-name"/>            result.add(n)<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    return result<br class="title-page-name"/>}</pre>
<p class="calibre2">Invoking it will print only odd numbers. How odd:</p>
<pre class="calibre18">println(filter((1..10).toList()) {<br class="title-page-name"/>    it % 2 != 0<br class="title-page-name"/>}) // [1, 3, 5, 7, 9]</pre>
<p class="calibre2">And, of course, we have a built-in function that does exactly that already:</p>
<pre class="calibre18">println((1..10).toList().<strong class="calibre1">filter</strong> {<br class="title-page-name"/>    it % 2 != 0<br class="title-page-name"/>})</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Find family</h1>
                
            
            
                
<p class="calibre2">Say you have an unordered list of objects:</p>
<pre class="calibre18">data class Person(val firstName: String, <br class="title-page-name"/>                  val lastName: String,<br class="title-page-name"/>                  val age: Int)<br class="title-page-name"/>val people = listOf(Person("Jane", "Doe", 19),<br class="title-page-name"/>            Person("John", "Doe", 24),<br class="title-page-name"/>            Person("John", "Smith", 23))</pre>
<p class="calibre2">And would like to find a first object that matches <em class="calibre14">some criteria</em>. Using extension functions, you could write something like this:</p>
<pre class="calibre18">fun &lt;T&gt; List&lt;T&gt;.find(check: (T) -&gt; Boolean): T? {<br class="title-page-name"/>    for (p in this) {<br class="title-page-name"/>        if (check(p)) {<br class="title-page-name"/>            return p<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>    return null<br class="title-page-name"/>}</pre>
<p class="calibre2">And then, when you have a list of objects, you can simply call <kbd class="calibre13">find()</kbd> on it:</p>
<pre class="calibre18">println(people.find {<br class="title-page-name"/>    it.firstName == "John"<br class="title-page-name"/>}) // Person(firstName=John, lastName=Doe)</pre>
<p class="calibre2">Luckily, you don't have to implement anything. This method is already implemented for you in Kotlin.</p>
<p class="calibre2">There's also an accompanying <kbd class="calibre13">findLast()</kbd> method, which does the same, but which starts with the last element of the collection:</p>
<pre class="calibre18">println(people.findLast {<br class="title-page-name"/>    it.firstName == "John"<br class="title-page-name"/>}) // Person(firstName=John, lastName=Smith)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Drop family</h1>
                
            
            
                
<p class="calibre2">OK, this is cool if you have to iterate over all elements in your collection anyway. But with the <kbd class="calibre13">for</kbd> loops in Java, you could do something like this:</p>
<pre class="calibre18">// Skips first two elements<br class="title-page-name"/>for (int i = 2; i &lt; list.size(); i++) {<br class="title-page-name"/>   // Do something here<br class="title-page-name"/>}</pre>
<p class="calibre2">How are you going to achieve that with your funky functions, huh?</p>
<p class="calibre2">Well, for that there's <kbd class="calibre13">drop()</kbd>:</p>
<pre class="calibre18">val numbers = (1..5).toList()<br class="title-page-name"/>println(numbers.drop(2)) // [3, 4, 5]</pre>
<p class="calibre2">Do note that this doesn't modify the original collection in any way:</p>
<pre class="calibre18">println(numbers) // [1, 2, 3, 4, 5]</pre>
<p class="calibre2">If you would like to stop your <em class="calibre14">loop</em> earlier, there's <kbd class="calibre13">dropLast()</kbd> for that:</p>
<pre class="calibre18">println(numbers.dropLast(2)) // [1, 2, 3]</pre>
<p class="calibre2">Another interesting function is <kbd class="calibre13">dropWhile()</kbd>, in which it receives a predicate instead of a number. It skips until the predicate returns true for the first time:</p>
<pre class="calibre18">val readings = listOf(-7, -2, -1, -1, 0, <strong class="calibre1">1, 3, 4</strong>)<br class="title-page-name"/><br class="title-page-name"/>println(readings.dropWhile {<br class="title-page-name"/>    it &lt;= 0<br class="title-page-name"/>}) // [1, 3, 4]</pre>
<p class="calibre2">And there's the accompanying <kbd class="calibre13">dropLastWhile()</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Sort family</h1>
                
            
            
                
<p class="calibre2">Don't worry, we won't have to implement our own sort algorithm. This is not CS 101. </p>
<p class="calibre2">Having the list of people from the preceding <kbd class="calibre13">find()</kbd> example, we would like to sort them by age:</p>
<pre class="calibre18">val people = listOf(Person("Jane", "Doe", 19),<br class="title-page-name"/>        Person("John", "Doe", 24),<br class="title-page-name"/>        Person("John", "Smith", 23))</pre>
<p class="calibre2">It is easily achieved with <kbd class="calibre13">sortedBy()</kbd>:</p>
<pre class="calibre18">println(people.sortedBy { it.age })</pre>
<p class="calibre2">The preceding code prints the following output:</p>
<pre class="calibre18"><strong class="calibre1">[Person(firstName=Jane, lastName=Doe, age=19), Person(firstName=John, lastName=Smith, age=23), Person(firstName=John, lastName=Doe, age=24)]</strong></pre>
<p class="calibre2">There's also <kbd class="calibre13">sortedByDescending()</kbd>, which will reverse the order of the results:</p>
<pre class="calibre18">println(people.sortedByDescending { it.lastName })</pre>
<p class="calibre2">The preceding code prints the following output:</p>
<pre class="calibre18"><strong class="calibre1">[Person(firstName=John, lastName=Smith, age=23), Person(firstName=John, lastName=Doe, age=24), Person(firstName=Jane, lastName=Doe, age=19)]</strong></pre>
<p class="calibre2">And if you want to compare by more than one parameter, use the combination of <kbd class="calibre13">sortedWith</kbd> and <kbd class="calibre13">compareBy</kbd>:</p>
<pre class="calibre18">println(people.sortedWith(compareBy({it.lastName}, {it.age})))</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">ForEach</h1>
                
            
            
                
<p class="calibre2">This is the first <em class="calibre14">terminator</em> we'll see. Terminator functions return something other than a new collection, so you can't chain the result of this call to other calls.</p>
<p class="calibre2">In the case of <kbd class="calibre13">forEach()</kbd>, it returns Unit. So it's like the plain, old <kbd class="calibre13">for</kbd> loop:</p>
<pre class="calibre18">val numbers = (0..5)<br class="title-page-name"/><br class="title-page-name"/>numbers.map { it * it}          // Can continue<br class="title-page-name"/>       .filter { it &lt; 20 }      // Can continue<br class="title-page-name"/>       .sortedDescending()      // Still can<br class="title-page-name"/>       .forEach { println(it) } // Cannot continue</pre>
<p class="calibre2">Do note that <kbd class="calibre13">forEach()</kbd> has some minor performance impacts compared to the traditional <kbd class="calibre13">for</kbd> loop. </p>
<p class="calibre2">There's also <kbd class="calibre13">forEachIndexed()</kbd>, which provides an index in the collection alongside the actual value:</p>
<pre class="calibre18">numbers.map { it * it }<br class="title-page-name"/>        .forEachIndexed { index, value -&gt;<br class="title-page-name"/>    print("$index:$value, ")<br class="title-page-name"/>}<br class="title-page-name"/></pre>
<p class="calibre2">The output for the preceding code will be as follows:</p>
<pre class="calibre18"><strong class="calibre1">0:1, 1:4, 2:9, 3:16, 4:25,</strong> </pre>
<p class="calibre2">Since Kotlin 1.1, there's also the <kbd class="calibre13">onEach()</kbd> function, which is a bit more useful, since it returns the collection again:</p>
<pre class="calibre18">numbers.map { it * it}         <br class="title-page-name"/>       .filter { it &lt; 20 }     <br class="title-page-name"/>       .sortedDescending()     <br class="title-page-name"/>       .onEach { println(it) } // Can continue now<br class="title-page-name"/>       .filter { it &gt; 5 }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Join family</h1>
                
            
            
                
<p class="calibre2">In the previous example, we used the side effect of printing to the console, which is not favorable in terms of functional programming. What's more, we also have this ugly comma at the end of our output as follows:</p>
<pre class="calibre18"><strong class="calibre1">0:1, 1:4, 2:9, 3:16, 4:25,</strong></pre>
<p class="calibre2">There must be a better way.</p>
<p class="calibre2">How many times have you had to actually write code to simply concatenate some list of values into a string? Well, Kotlin has a function for that:</p>
<pre class="calibre18">    val numbers = (1..5)<br class="title-page-name"/><br class="title-page-name"/>    println(numbers.joinToString { "$it"})</pre>
<p class="calibre2">The preceding code will give the following output:</p>
<pre class="calibre18"><strong class="calibre1">1, 2, 3, 4, 5</strong></pre>
<p class="calibre2">Simply beautiful, isn't it? </p>
<p class="calibre2">And if you want to separate it with other characters, or don't want spaces, there's a way to configure it:</p>
<pre class="calibre18">println(numbers.joinToString(separator = "#") { "$it"})</pre>
<p class="calibre2">The output of the preceding code will be as follows:</p>
<pre class="calibre18"><strong class="calibre1">1#2#3#4#5</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Fold/Reduce</h1>
                
            
            
                
<p class="calibre2">Much like <kbd class="calibre13">forEach()</kbd>, both <kbd class="calibre13">fold()</kbd> and <kbd class="calibre13">reduce()</kbd> are terminating functions. But instead of terminating with Unit, which is not useful, they terminate with a single value of the same type. </p>
<p class="calibre2">The most common example of <kbd class="calibre13">reduce</kbd> is, of course, for adding up stuff. With the list of people from the previous example, we can do the following:</p>
<pre class="calibre18">println(people.reduce {p1, p2 -&gt;<br class="title-page-name"/>        Person("Combined", "Age", p1.age + p2.age)<br class="title-page-name"/>    })</pre>
<p class="calibre2">The output of the preceding code will be as follows:</p>
<pre class="calibre18"><strong class="calibre1">Person(firstName=Combined, lastName=Age, age=64)</strong></pre>
<p class="calibre2">Well, combining a lot of people into one doesn't make much sense, unless you're a fan of some horror movies.</p>
<p class="calibre2">But with reduce, we can also compute who's the oldest or the youngest in the list:</p>
<pre class="calibre18">println(people.reduce {p1, p2 -&gt;<br class="title-page-name"/>    if (p1.age &gt; p2.age) { p1 } else { p2 }<br class="title-page-name"/>})</pre>
<p class="calibre2">The second function we're about to discuss, <kbd class="calibre13">fold()</kbd>, is much like <kbd class="calibre13">reduce</kbd>, but it takes another argument, which is the initial value. It's useful when you've already computed something, and now want to use this intermediate result:</p>
<pre class="calibre18">println(people.drop(1) // Skipping first one<br class="title-page-name"/>       .fold(people.first()) // Using first one as initial value<br class="title-page-name"/>             {p1, p2 -&gt;<br class="title-page-name"/>    Person("Combined", "Age", p1.age + p2.age)<br class="title-page-name"/>})</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Flat family</h1>
                
            
            
                
<p class="calibre2">Say you have a list of other lists. You probably got it from different database queries, or maybe from different configuration files:</p>
<pre class="calibre18">val listOfLists = listOf(listOf(1, 2),<br class="title-page-name"/>        listOf(3, 4, 5), listOf(6, 7, 8))<br class="title-page-name"/><br class="title-page-name"/>// [[1, 2], [3, 4, 5], [6, 7, 8]]</pre>
<p class="calibre2">And you want to turn them into a single list such as the following:</p>
<pre class="calibre18">[1, 2, 3, 4, 5, 6, 7, 8]</pre>
<p class="calibre2">One way to merge those lists is to write some imperative code:</p>
<pre class="calibre18">val results = mutableListOf&lt;Int&gt;()<br class="title-page-name"/><br class="title-page-name"/>for (l in listOfLists) {<br class="title-page-name"/>    results.addAll(l)<br class="title-page-name"/>}</pre>
<p class="calibre2">But calling <kbd class="calibre13">flatten()</kbd> will do the same for you:</p>
<pre class="calibre18">listOfLists.flatten()</pre>
<p class="calibre2">You can also control what happens with those results using <kbd class="calibre13">flatMap()</kbd>:</p>
<pre class="calibre18">println(listOfLists.flatMap {<br class="title-page-name"/>    it.asReversed()<br class="title-page-name"/>})</pre>
<p class="calibre2">Note that in this case, it refers to one of the sublists. </p>
<p class="calibre2">You can also decide to use <kbd class="calibre13">flatMap()</kbd> for type conversions:</p>
<pre class="calibre18">println(listOfLists.flatMap {<br class="title-page-name"/>    it.map { it.toDouble() }<br class="title-page-name"/>//  ^        ^<br class="title-page-name"/>// (1)      (2)<br class="title-page-name"/>})</pre>
<p class="calibre2">The preceding code prints the following output:</p>
<pre class="calibre18"><strong class="calibre1">[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]</strong></pre>
<p class="calibre2">We converted all integers to doubles, and then merged them into a single list.</p>
<p class="calibre2">Note how the first <kbd class="calibre13">it</kbd> refers to one of the lists, while the second <kbd class="calibre13">it</kbd> refers to a single item inside the current list.</p>
<p class="calibre2">As far as <kbd class="calibre13">flatten()</kbd> goes, it flattens only one level down. To demonstrate that, we'll use <kbd class="calibre13">Set</kbd> for the first level of nesting, <kbd class="calibre13">List</kbd> for the second level of nesting, and <kbd class="calibre13">Set</kbd> again for the third level of nesting:</p>
<pre class="calibre18">val setOfListsOfSets = setOf(<br class="title-page-name"/>//                     ^<br class="title-page-name"/>//                    (1)<br class="title-page-name"/>        listOf(setOf(1, 2), setOf(3, 4, 5), setOf(6, 7, 8)), <br class="title-page-name"/>//      ^      ^<br class="title-page-name"/>//     (2)    (3)<br class="title-page-name"/>        listOf(setOf(9, 10), setOf(11, 12))<br class="title-page-name"/>//      ^      ^<br class="title-page-name"/>//     (2)    (3)<br class="title-page-name"/>)<br class="title-page-name"/>// Prints [[[1, 2], [3, 4, 5], [6, 7, 8]], [[9, 10], [11, 12]]]</pre>
<p class="calibre2">If we call <kbd class="calibre13">flatten</kbd> once, we receive only the first level flattened:</p>
<pre class="calibre18">println(setOfListsOfSets.flatten())</pre>
<p class="calibre2">The preceding code prints the following output:</p>
<pre class="calibre18"><strong class="calibre1">[[1, 2], [3, 4, 5], [6, 7, 8], [9, 10], [11, 12]]</strong></pre>
<p class="calibre2">To completely flatten the list, we need to call <kbd class="calibre13">flatten()</kbd> twice:</p>
<pre class="calibre18">println(setOfListsOfSets.flatten().flatten())</pre>
<p class="calibre2">The preceding code prints the following output:</p>
<pre class="calibre18"><strong class="calibre1">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</strong></pre>
<p class="calibre2">Kotlin prevents us from calling <kbd class="calibre13">flatten()</kbd> three times, as it recognizes the amount of nesting we have:</p>
<pre class="calibre18">//Won't compile<br class="title-page-name"/>println(setOfListsOfSets.flatten().flatten().flatten())</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Slice</h1>
                
            
            
                
<p class="calibre2">Say we have a list of elements, as follows:</p>
<pre class="calibre18">val numbers = (1..10).toList()<br class="title-page-name"/>// Prints [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</pre>
<p class="calibre2">We can take only part of this list using <kbd class="calibre13">slice()</kbd>:</p>
<pre class="calibre18">println(numbers.slice((0..3)))<br class="title-page-name"/>// Prints [1, 2, 3, 4], last index is included</pre>
<p class="calibre2">We're using Kotlin ranges, which is a nice syntax. </p>
<p class="calibre2">In Java, there's a <kbd class="calibre13">subList()</kbd> method, which is similar, but not inclusive:</p>
<pre class="calibre18">println(numbers.subList(0, 3))<br class="title-page-name"/>// Prints [1, 2, 3], last index is excluded</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Chunked</h1>
                
            
            
                
<p class="calibre2">It's very common to see this chunking logic in production code. </p>
<p class="calibre2">You have a huge list of identifiers that you read from somewhere and you need to check whether your database or some remote service contains them. But there are limitations on how many identifiers you can pass with a single request. Databases, for example, often have limitations of the number of arguments to a query and on the total query length:</p>
<pre class="calibre18">fun dbCall(ids: List&lt;Int&gt;) {<br class="title-page-name"/>    if (ids.size &gt; 1000) {<br class="title-page-name"/>        throw RuntimeException("Can't process more than 1000 ids")<br class="title-page-name"/>    }</pre>
<pre class="calibre18">    // Does something here<br class="title-page-name"/>}</pre>
<p class="calibre2">We can't simply pass an entire list to our function:</p>
<pre class="calibre18">// That will fail at runtime<br class="title-page-name"/>dbCall(hugeList)<br class="title-page-name"/></pre>
<p class="calibre2">So, we write large piles of imperative code:</p>
<pre class="calibre18">val pageSize = 1000<br class="title-page-name"/>val pages = hugeList.size / pageSize<br class="title-page-name"/><br class="title-page-name"/>for (i in 0..pages) {<br class="title-page-name"/>    val from = i * pageSize<br class="title-page-name"/>    val p = (i+1) * pageSize<br class="title-page-name"/>    val to = minOf(p, hugeList.size)<br class="title-page-name"/>    dbCall(hugeList.slice(from until to))<br class="title-page-name"/>}</pre>
<p class="calibre2">Luckily, since Kotlin 1.2, there's the <kbd class="calibre13">chunked()</kbd> function for that:</p>
<pre class="calibre18">hugeList.chunked(pageSize) {<br class="title-page-name"/>    dbCall(it)<br class="title-page-name"/>}</pre>
<p class="calibre2"> </p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Zip/Unzip</h1>
                
            
            
                
<p class="calibre2">Not related to archiving in any way, <kbd class="calibre13">zip()</kbd> allows us to create pairs out of two lists based on their indexes. That may sound confusing, so let's look at an example.</p>
<p class="calibre2">We have two functions, one fetching all active employees, and the other for how many days the employee was employed in our startup:</p>
<pre class="calibre18">val employeeIds = listOf(5, 8, 13, 21, 34, 55, 89)<br class="title-page-name"/>val daysInCompany = listOf(176, 145, 117, 92, 70, 51, 35, 22, 12, 5)</pre>
<p class="calibre2">Calling <kbd class="calibre13">zip()</kbd> between the two of them will produce the following result:</p>
<pre class="calibre18">println(employeeIds.zip(daysInCompany))</pre>
<p class="calibre2">The preceding code prints the following output:</p>
<pre class="calibre18"><strong class="calibre1">[(5, 176), (8, 145), (13, 117), (21, 92), (34, 70), (55, 51), (89, 35)]</strong></pre>
<p class="calibre2">Note that since we had a bug in our second function, and returned the days for the employees that had already left our startup, the length of the two lists wasn't equal, to begin with. Calling <kbd class="calibre13">zip()</kbd> will always produce the shortest list of pairs:</p>
<pre class="calibre18">println(daysInCompany.zip(employeeIds))</pre>
<p class="calibre2">The preceding code prints the following output:</p>
<pre class="calibre18"><strong class="calibre1">[(176, 5), (145, 8), (117, 13), (92, 21), (70, 34), (51, 55), (35, 89)]</strong></pre>
<p class="calibre2">Note that this is not a map, but a list of pairs.</p>
<p class="calibre2">Having such a list, we can also unzip it:</p>
<pre class="calibre18">val employeesToDays = employeeIds.zip(daysInCompany)<br class="title-page-name"/><br class="title-page-name"/>val (employees, days) = employeesToDays.unzip()<br class="title-page-name"/>println(employees)<br class="title-page-name"/>println(days)</pre>
<p class="calibre2">The preceding code prints the following:</p>
<pre class="calibre18"><strong class="calibre1">[5, 8, 13, 21, 34, 55, 89]</strong><br class="title-page-name"/><strong class="calibre1">[176, 145, 117, 92, 70, 51, 35]</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Streams are lazy, collections are not</h1>
                
            
            
                
<p class="calibre2">Be careful with those functions on large collections, though. Most of them will copy the collection for the sake of immutability.</p>
<p class="calibre2">Functions starting with <kbd class="calibre13">as</kbd> won't do that, though:</p>
<pre class="calibre18">// Returns a view, no copy here<br class="title-page-name"/>(1..10).toList().asReversed()<br class="title-page-name"/><br class="title-page-name"/>// Same here<br class="title-page-name"/>(1..10).toList().asSequence()</pre>
<p class="calibre2">To understand the difference, check the following code:</p>
<pre class="calibre18">val numbers = (1..1_000_000).toList()<br class="title-page-name"/>println(measureTimeMillis {<br class="title-page-name"/>    numbers.stream().map {<br class="title-page-name"/>        it * it<br class="title-page-name"/>    }<br class="title-page-name"/>}) // ~2ms<br class="title-page-name"/><br class="title-page-name"/>println(measureTimeMillis {<br class="title-page-name"/>    numbers.map {<br class="title-page-name"/>        it * it<br class="title-page-name"/>    }<br class="title-page-name"/>}) // ~19ms</pre>
<p class="calibre2">You'll notice that code using <kbd class="calibre13">stream()</kbd> actually never executes. Streams, being lazy, wait for a terminating function call. Functions on collections, on the other hand, execute one after the other.</p>
<p class="calibre2">If we add the terminating call though, we'll see totally different numbers:</p>
<pre class="calibre18">println(measureTimeMillis {<br class="title-page-name"/>    numbers.stream().map {<br class="title-page-name"/>        it * it<br class="title-page-name"/>    }.toList()<br class="title-page-name"/>}) // ~70ms</pre>
<p class="calibre2">Converting from the stream back to the list is an expensive operation. Take those points into consideration when deciding which approach to use.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Sequences</h1>
                
            
            
                
<p class="calibre2">Since streams were introduced only in Java 8, but Kotlin is backward-compatible down to Java 6, it needed to provide another solution for the possibility of infinite collections. This solution was named <em class="calibre14">sequenced</em>, so it won't clash with Java streams when they're available.</p>
<p class="calibre2">You can generate an infinite sequence of numbers, starting with <kbd class="calibre13">1</kbd>:</p>
<pre class="calibre18">val seq = generateSequence(1) { it + 1 }</pre>
<p class="calibre2">To take only the first <kbd class="calibre13">100</kbd>, we use the <kbd class="calibre13">take()</kbd> function:</p>
<pre class="calibre18">    seq.take(100).forEach {<br class="title-page-name"/>        println(it)<br class="title-page-name"/>    }</pre>
<p class="calibre2">A finite number of sequences can be created by returning <kbd class="calibre13">null</kbd>:</p>
<pre class="calibre18">val finiteSequence = generateSequence(1) {<br class="title-page-name"/>    if (it &lt; 1000) it + 1 else null<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>finiteSequence.forEach {<br class="title-page-name"/>        println(it)<br class="title-page-name"/>} // Prints numbers up to 1000</pre>
<p class="calibre2">A finite number of sequences can be created from ranges or collections by calling <kbd class="calibre13">asSequence()</kbd>:</p>
<pre class="calibre18">(1..1000).asSequence()</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre2">This chapter was dedicated to practicing functional programming principles and learning the building blocks of functional programming in Kotlin.</p>
<p class="calibre2">Now you should know how to transform your data with <kbd class="calibre13">map()</kbd>/<kbd class="calibre13">mapTo()</kbd>, how to <kbd class="calibre13">filter()</kbd> collections, and <kbd class="calibre13">find()</kbd> elements by criteria.</p>
<p class="calibre2">You should also be familiar with how to <kbd class="calibre13">drop()</kbd> elements to skip them, how to <kbd class="calibre13">sort()</kbd> collections, and how to iterate over them using <kbd class="calibre13">forEach()</kbd> and <kbd class="calibre13">onEach()</kbd>.</p>
<p class="calibre2">Use <kbd class="calibre13">join()</kbd> to stringify collections, <kbd class="calibre13">fold()</kbd> and <kbd class="calibre13">reduce()</kbd> to total collections up, and <kbd class="calibre13">flatten()</kbd> and <kbd class="calibre13">flatTo()</kbd> to reduce collection nesting.</p>
<p class="calibre2"><kbd class="calibre13">slice()</kbd> is a way to get only a portion of a collection, while <kbd class="calibre13">chunked()</kbd> is used to break a collection into even portions.</p>
<p class="calibre2">Finally, <kbd class="calibre13">zip()</kbd> and <kbd class="calibre13">unzip()</kbd> combine two collections into a pair, or split the pair back into two parts.</p>
<p class="calibre2">In the next chapter, we'll discuss how familiarity with those methods helps us to become truly reactive.</p>


            

            
        
    </body></html>