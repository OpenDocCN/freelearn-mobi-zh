<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Cloud Solutions for App Experiments</h1>
                </header>
            
            <article>
                
<p>While an MVP could be something as minimal as a landing page, announcing your app, or a live mock up version of your app, there comes a time that your app should be a little more than that, whether it is to prove your next hypotheses or to see the actual thing in its most basic shape in action. It's about time to create a <strong>Proof of Concept</strong> (<strong>PoC</strong>).</p>
<p>Standalone apps are rare these days. Most apps have functionality to share content on Twitter or Facebook, have leaderboards (if it is a game), let the user post pictures or video, have a chat or otherwise communicate with each other, and so on. For this your app needs to have a backend.</p>
<p>You can of course create your own API or use the API of the many solutions that do exist for this purpose, the so-called <strong>Mobile backend as a Service</strong> (<strong>MBaaS</strong>). These solutions do work like any other <strong>Software as a Service</strong> (<strong>SaaS</strong>) but are specifically intended for this purpose.</p>
<p>In this chapter, we will have a look on MBaaS solutions and will see what it takes to build an Android PoC using Firebase, a popular cloud-based backend.</p>
<p>Specifically, in the chapter we will cover the following topics:</p>
<ul>
<li>Find out if we need to create a backend on our own</li>
<li>Leverage cloud solutions for app experiments</li>
<li>Determine what services are available as MBaaS</li>
<li>Examine an Android PoC app using Firebase</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Do you need to create a backend yourself?</h1>
                </header>
            
            <article>
                
<p>It totally depends on your app's needs, but for most apps there is no reason at all to create a backend yourself, at least not for your <strong>Minimum Viable Product</strong> (<strong>MVP</strong>). There are plenty of readymade backend solutions available.</p>
<p>Most solutions support push notifications, data storage, social sign up and login (sign up or login using your Facebook or Twitter credentials for example) and data synchronization functionality, including offline support for your app.</p>
<p>If you have to program all these things for yourself, it could take up a lot of time and it will probably take even more time to make it error free.</p>
<p>Almost all solutions come as freemium service and most of the time the free options are good enough to build your MVP. Some of them, such as Firebase, come with real-time support, making it a great base for a chat app. Later, we will build a PoC with Firebase, but first let's see what solutions are currently available.</p>
<p>What a MBaaS can do for you is illustrated here. Most solutions offer a web-based <strong>Content Management System</strong> (<strong>CMS</strong>), an <strong>Application Programming Interface</strong> (<strong>API</strong>) and a <strong>Software Development Kit</strong> (<strong>SDK</strong>). Such a solution will take care of storing both remote and local data. In addition, it has support for the synchronization of data (it sends local persisting data to a remote location and vice versa) and for distributing push notifications:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="244" src="assets/142bd4e2-c6cc-4025-b86a-4e04bf332b4e.png" width="323"/></div>
<p>To be more precise, an API is a way for apps to communicate with the data stored at the remote server (cloud solution). Data can often be retrieved through a <strong>Representational State Transfer</strong> (<strong>REST</strong>) interface over http(s). The SDK is a piece of software that you can add to your own app. It will make the usage of the API more convenient. Often the API will take care of things such as obtaining data and data synchronization. The integration of the service will be simplified by using the API, but you can still use the REST interface, for example, to show the same data on the website.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Leverage cloud solutions for app experiments</h1>
                </header>
            
            <article>
                
<p>MBaaS solutions are great for getting things going real quickly. Most solutions come with features that almost any app has in common, such as registration, login, retrieving, saving, and sharing data. Another big advantage of using an MBaaS is its scalability. Right now we are aiming for the development of an MVP and technical scaling issues are luxury problems. However, it is good to know upfront that these problems are easier to resolve using these kinds of third-party solutions. Your app has scalability but does not yet need to scale. If it needs to be scaled up, then you just switch to a bigger plan (from a technical perspective). You will read more about scaling strategies in <a href="d9145149-0f4e-47b6-bc9d-ff46e5e63304.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 15</span></a>, <em>Growing Traction and Improving Retention</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Things to consider</h1>
                </header>
            
            <article>
                
<p>There are some other things to look at, such as pricing. You can start with a free plan, but if you need to scale up your solution, it is important to know how fast the price will increase. Is the service still reasonably priced if you need to deal with high volumes. When that happens money may no longer be a big issue as your business already has grown significantly. It could also be that your strategy is to use the service only for a first MVP. It is all fine as long as you have a strategy and you keep these things in mind.</p>
<p>Another thing to think about is the fact that your user data resides on the server of a third party such as Facebook or Google. You should ask yourself if you should trust third parties to build a solution. Of course a lot depends on the nature of the solution. Anyhow there are things that you would like to know for sure such as "Is your data safe and what is going to happen if the service provider decides to discontinue its services?" Parse server and Firebase have some impressive names in their testimonials, so we <span>can</span> probably assume that in most cases your data is safe indeed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The story of Parse</h1>
                </header>
            
            <article>
                
<p>The second one is more relevant than you might think. A while ago Parse announced they were going to discontinue their services. That announcement made a lot of (independent) developers pretty angry. These developers were totally dependent on Parse services. The discontinuation of Parse made them fearful because they thought they had no other choice but to end their business. Developers had high expectations from the services, also because Parse had been acquired by Facebook. It seemed to be very solid. Apparently, that acquisition perhaps also led to that same announcement. For Facebook, the team <span>was</span> probably more interesting than the service itself.</p>
<p>Fortunately, this fairy tale has a happy end. Parse came with a nice migration plan, which nowadays is known as the open source solution Parse server. You can host it yourself but if you do not want to do that then there is no problem either. A lot of other parties jumped right on it and started to offer Parse server hosting. The server itself does not come with all the features that were available in Parse but parties such as Back4App did a great job adding them all back in.</p>
<p>In short, this story proves that you should not completely depend on services like these. Partners are important but when they become irreplaceable the future of your startup could possibly be uncertain. And while this story is about Parse, the same thing could happen to Firebase, for example. That is not very likely but Google has shut down some services before, so it also is not completely impossible.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Strategic considerations</h1>
                </header>
            
            <article>
                
<p>If you need to make a decision whether to use a cloud-based service or not and if you need to make a choice from the various available services, then there are some strategic considerations that could be important. Using such a service comes with both advantages and disadvantages. A number of them are listed next.</p>
<p>The following are the advantages:</p>
<ul>
<li>The service shortens the development time</li>
<li>Out of the box the service often comes with support for registration and login</li>
<li>Most services can easily be scaled up or down, depending on the amount of traffic that you are expecting</li>
<li>Almost all services support push notifications and media storage</li>
</ul>
<p>The following are the disadvantages:</p>
<ul>
<li>A ready-to-use service is often more expensive. Pricing could be an issue.</li>
<li>The privacy of your (user) data could be an issue. You have to trust that the company, that is offering the service, is taking the right precautions to ensure the security.</li>
<li>There is always the risk that the service will be discontinued.</li>
<li>There is a lock-in risk. It could be difficult to migrate to another service when all your data is residing with a particular provider.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What services are available as MBaaS?</h1>
                </header>
            
            <article>
                
<p>There are a couple of services available that could act as a backend for your app. Given the strategic considerations from the previous paragraph and the specific needs of your app, one service might be more suitable than another.</p>
<p>Some offer real-time data, making it perfect for a chat application. Others are more about persisting data or come with building blocks, such as QuickBlox, allowing you to create your app even faster. Some are pretty dedicated solutions, pretty easy and fast to use but not very flexible. Others are very flexible but come with a steeper learning curve:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="101" src="assets/69fdd9d9-4824-4462-8a81-494055beaf2c.png" width="507"/></div>
<p>Most solutions store data in a document-related database, such as MongoDB. If you need to have a relational type of database for your app, then choosing Azure with SQL Server <span>will</span> probably be the best thing to do. Choose the service that matches most closely with your app needs and your current development skills:</p>
<ul>
<li><strong>Back4App</strong>: The service offers hosted parse servers. The service has support for push notifications, data, and file storage and it supports Cloud code. Cloud code is code, often queries, that run on the Parse server. You can use the common Android and iOS Parse SDKs to communicate with the server.</li>
<li><strong>SashiDo</strong>: Just like Back4App, this is a service that offers a hosted parse server plus a couple of extra things.</li>
<li><strong>Firebase</strong>: It is a scalable real-time backend for web, Android, and iOS. It is perfect for chat and collaboration tools, but is also suitable for other needs. Storing media such as images or video is a bit more complicated when compared with Parse server or Azure, for example.</li>
<li><strong>BaasBox</strong>: This is an open source backend for your mobile app. It has SDKs for iOS, Android, and JavaScript.</li>
<li><strong>QuickBlox</strong>: This service provides building blocks for a backend infrastructure. It offers data storage, push notifications, text and video chat, and many other features. It allows developers to create apps quickly, but is a bit pricy. For this reason, it is most suitable for a PoC and less for a real app.</li>
<li><strong>Azure</strong>: Microsoft Azure comes with support for push notifications and other mobile services. It has become one of Microsoft's core businesses, so you can see Azure as one of the most trustworthy MBaaS solutions. The platform will stay for sure. It <span>is</span> also true that, compared to other MBaaS, the Azure services can sometimes <span>be</span> a little bit confusing. It is less dedicated to MBaaS alone. It can simply do way too many things and it can make the service a bit overwhelming if you just got started. It is very flexible and because of this it has a relatively steep learning curve. For your app needs, you can use table and blob storage (for images, documents, and so on), use the mobile services, the API services, or you can create your own API using .NET or another language. There are Azure client SDKs for Android, iOS, and Windows.</li>
<li><strong>Backendless</strong>: Backendless provides an instant mobile Backend as a Service and overall application development Platform.</li>
<li><strong>remoteStorage</strong>: <a href="https://remotestorage.io/">remoteStorage</a> offers an open protocol for per-user storage. Use a storage account with a provider you trust, or set up your own storage server.</li>
<li><strong>CloudBoost.io</strong>: This is a complete database service that comes with data storage, search, real-time and other stuff.</li>
<li><strong>PubNub</strong>: <a href="https://www.pubnub.com/">PubNub</a> is a real-time network that enables software developers to rapidly build and scale real-time apps by providing the cloud infrastructure, connections, and key building.</li>
<li><strong>Parse server</strong>: The Parse server is an open source solution that you can download and host by yourself. You could <span>also</span>, for example, host it on Heroku or on Azure. The server uses a MongoDB database and utilizes Amazon S3 storage to store files, such as images, audio or video. The Parse SDKs for Android and iOS include all kinds of handy stuff, such as caching data and uploading data or files in the background.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical considerations</h1>
                </header>
            
            <article>
                
<p>Besides strategic considerations, there are also a couple of technical aspects to consider. Before you choose a particular service, you should ask yourself the following questions:</p>
<ul>
<li>Does your app require real-time support?</li>
<li>Does your app handle a lot of media (images, video, and audio)?</li>
<li>How trustworthy should the service provider be?</li>
<li>How good are your current skills that are required to use the chosen service?</li>
<li>How much flexibility do you need and how much time do you have available?</li>
</ul>
<p>In the next paragraph, we will examine an Android MVP that is using Firebase.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Canvapp - an Android MVP app using Firebase</h1>
                </header>
            
            <article>
                
<p>Let's build an Android MVP app using Firebase. For this particular case, we will have an app that allows you to create and share your business model canvas, just by using your phone. Anyone can view or edit each other's canvases so you can gather feedback easily. If you do not remember what the business model canvas looks like, you can have a look at <a href="4846c191-1deb-4452-90d3-2bac5032aa3a.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 2</span></a>, <em>Lean Startup Primer</em> again.</p>
<p>We will be using a wireframing tool, such as SwordSoft Layout as shown in the following example . Let's say that the app should look more or less like this:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="214" src="assets/9fff2520-8ed2-4616-ae9d-8bf84e1fc80f.png" width="446"/></div>
<p>The first view displays a list of business model canvases and it has a sliding menu. The second view is the one that the user will see when he is creating a new canvas or when he chooses a canvas from the list. It displays a number of pages, each containing a title, description, and some hint. Users can swipe back and forward. It is a very basic app. It has only three views, but that will be sufficient to demonstrate how to use Firebase as a backend and we can use it to prove that this app concept does make sense.</p>
<p>For the sake of simplicity, we will just say, for this example, that you have already validated your earliest hypotheses. The hypotheses for this solution are:</p>
<ul>
<li>Startup entrepreneurs want to share their canvases to get feedback from other entrepreneurs.</li>
<li>Startup entrepreneurs want to share their canvases using a smartphone or tablet. This will allow us to focus on the technical implementation of the app.</li>
</ul>
<p>You can find the source for this project at: <a href="https://github.com/mikerworks/packt-lean-saas-canvapp"><span class="URLPACKT">https://github.com/mikerworks/packt-lean-saas-canvapp</span></a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sign up for Firebase</h1>
                </header>
            
            <article>
                
<p>If you want to see things in action, you will have to go to <a href="http://www.firebase.com"><span class="URLPACKT">www.firebase.com</span></a> and sign up. Once you have done that, you can create your first app. The only thing that matters is the endpoint that Firebase will create. You need this endpoint to configure your app. In the following example, the endpoint is <span class="packt_screen">torrid-head-3108.firebaseIO.com</span>:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="240" src="assets/18a20cac-a02d-4876-b52e-ec37d0eed9a2.png" width="443"/></div>
<p>First, download the Android Firebase example from GitHub (<a href="https://github.com/mikerworks/packt-lean-saas-canvapp">https://github.com/mikerworks/packt-lean-saas-canvapp</a>), so we can go through it and see what it is all about. If you prefer, and if you have some time left, you can also build this app from scratch, of course. For now, you can download the readymade app, examine it, and modify it as needed:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="313" src="assets/e41af29c-a353-4bdb-8cbb-8f96eb5f2be0.png" width="272"/></div>
<p>Open the app in Android Studio or another IDE if you prefer. One of the things that you need to modify is the Firebase endpoint in the application. Collapse the <kbd>data</kbd> package node within the app and open the <kbd>FirebaseRepository</kbd> class. Within the <kbd>FirebaseRepository</kbd> class, locate the constructor and adapt the firebase reference so that it matches yours:</p>
<pre>public class FirebaseRepository implements IRemoteRepository {<br/>     private Firebase reference;<br/>     private Context context;<br/>     public FirebaseRepository(Context context){<br/>         Firebase.setAndroidContext(context);<br/>         this.context = context;<br/>         reference = new Firebase("https://&lt;your endpoint here&gt;/canvapp/"); 
    }</pre>
<p>When you run the app and have added a couple of canvases it looks more or less like this. Yeah, it already contains some cool ideas:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="333" src="assets/8519c38b-8cff-4300-a180-2ab17b183bfb.png" width="200"/></div>
<p>When you run the app and have added a couple of canvases it looks more or less like this. Yeah, it already contains some cool ideas. The app will display a list of canvas models residing in Firebase. The title and description for each model will be shown. Anyone can view or edit it by clicking on a model. This will display the edit view, which will contain a swipeable collection of canvas elements. A new canvas can be created through the options in the menu.</p>
<p>For this app, we have created a new project in Android Studio and we chose the <span class="packt_screen">Navigation Drawer</span> to be our first activity. This will give us a nice template with a readymade menu. It is here that the List and New canvas options are going to appear.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Layout</h1>
                </header>
            
            <article>
                
<p>There are a few layout resources in the project (res/layout) that we will describe. These layouts are as follows:</p>
<ul>
<li><strong>The list layout</strong>: This displays a list of canvases</li>
<li><strong>The pager layout</strong>: This shows a swipeable series of elements.</li>
<li><strong>The element layout</strong>: This layout will display a title, description, some hints, and edit box for each element of the Business Model Canvas.</li>
<li><strong>The row layout</strong>: This renders each row in the list of canvases.</li>
</ul>
<p>The layout files are small and contain just some boilerplate code. It is nothing fancy but we need it anyway to create the Android Firebase PoC. You can examine them if you want, but for now let's proceed with the parts of the code that are most relevant.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dependencies</h1>
                </header>
            
            <article>
                
<p>To examine the list of dependencies for the app, open the <kbd>build.gradle</kbd> file within the <kbd>app</kbd> folder. Among other things, you will find the dependencies for Firebase and JSON deserialization here, as listed next:</p>
<pre>dependencies { 
    compile fileTree(dir: 'libs', include: ['*.jar']) 
    testCompile 'junit:junit:4.12' 
    compile 'com.android.support:appcompat-v7:23.3.0' 
    compile 'com.android.support:design:23.3.0' 
    compile 'com.android.support:cardview-v7:23.1.1' 
    compile 'com.android.support:recyclerview-v7:23.3.0' 
    compile 'com.squareup.retrofit:converter-gson:2.0.0-beta2' 
    compile 'com.firebase:firebase-client-android:2.5.2+' 
} </pre>
<p>Within the <kbd>res</kbd> folder raw, you will find the <kbd>canvas.json</kbd> file. The JSON data in this file will be parsed using <kbd>Gson</kbd>. It will act as a template for each new canvas. All the user needs to do is to provide a value for each element.</p>
<p>The JSON object in the file looks like this. It will be processed by the <kbd>LocalRepository</kbd> class:</p>
<pre>{ 
  "ELEMENTS": [ 
    ... 
{ 
  "ID": "PROPOSITIONS", 
  "TITLE": "VALUE PROPOSITIONS", 
  "DESCRIPTION": "what value do you deliver to the customer? Which of your customer's problems are you helping to resolve? What bundles of services are you offering? Which needs do you satisfy?", 
  "HINT": "Enter your proposition here. What are the characteristics of it? What does it make unique? Is it price? Cost or risk reduction? A better design or performance? Is it more convenient? Why?..." 
}, 
{ 
  "ID": "SEGMENTS", 
  "TITLE": "CUSTOMER SEGMENTS", 
  "DESCRIPTION": "For who are you creating value?\nWho are you most important customers?", 
  "HINT": "Describe your customer segments here. Be as specific as possible. A niche market is much better as aiming for 'everybody'. If it is a platform what customers do you want to bring together. Who are your most important customers?..."<br/> }, 
{ 
  "ID": "CHANNELS", 
  "TITLE": "CHANNELS", 
  "DESCRIPTION": "Through which channels do your customer segments want to be reached? How are you reaching them now? How are your channels integrated?\nWhich ones work best?", 
  "HINT": "Describe your channels. How do you raise awareness? How can you help your customers to evaluate the value proposition? How can they purchase your services and how are they delivered?..." 
} </pre>
<div class="packt_infobox">This template implements a particular type of Business Model Canvas. There are some variants as well. Ash Maurya, for example, uses a different and, in my opinion, more suitable canvas. He calls it the Lean Canvas and it has been described in <a href="4846c191-1deb-4452-90d3-2bac5032aa3a.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 2</span></a>, <em>Lean Startup Primer</em>.<br/>
<br/>
Feel free to modify the template or to create a totally different application, derived from this one, for example, for some kind of survey.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Models</h1>
                </header>
            
            <article>
                
<p>A canvas typically has a collection of Canvas elements, each representing a section of the Business Model Canvas. For the sake of simplicity, these classes contain only the most basic information.</p>
<p>The most important models used in the app are the <kbd>Canvas</kbd> and the <kbd>CanvasElement</kbd> models. Both the <kbd>Canvas</kbd> and <kbd>CanvasElement</kbd> classes implement the <kbd>Parcelable</kbd> interface. This will make it easier to pass (complex) objects to each fragment:</p>
<pre> 
public class Canvas implements Parcelable { 
    private String id; 
    public List&lt;CanvasElement&gt; ELEMENTS; 
    public Canvas(){ 
        ELEMENTS = new ArrayList&lt;&gt;(); 
    } 
    public void setId(String value){ 
        this.id= value; 
    } 
    public String getId(){ 
        return this.id; 
    } 
    ... </pre>
<div class="packt_infobox">The <kbd>CanvasElement</kbd> class and the JSON object found in the template file have similar fields. Each element of the canvas has an ID, title, description, and text for the placeholder. The user input will fill the <kbd>value</kbd> field:</div>
<pre>public class CanvasElement implements Parcelable { 
    public String ID; 
    public String TITLE; 
    public String DESCRIPTION; 
    public String VALUE; 
    public String HINT; 
 
    @Override 
    public int describeContents() { 
        return 0; 
    } 
    @Override 
 
    public void writeToParcel(Parcel dest, int flags) { 
        dest.writeString(this.ID); 
        dest.writeString(this.TITLE); 
        dest.writeString(this.DESCRIPTION); 
        dest.writeString(this.VALUE); 
        dest.writeString(this.HINT); 
    } 
... 
    protected CanvasElement(Parcel in) { 
        this.ID = in.readString(); 
        this.TITLE = in.readString(); 
        this.DESCRIPTION = in.readString(); 
        this.VALUE = in.readString(); 
        this.HINT = in.readString(); 
    } 
 
    public static final Parcelable.Creator&lt;CanvasElement&gt; CREATOR = new Parcelable.Creator&lt;CanvasElement&gt;() { 
        @Override 
        public CanvasElement createFromParcel(Parcel source) { 
            return new CanvasElement(source); 
        } 
        @Override 
        public CanvasElement[] newArray(int size) { 
            return new CanvasElement[size]; 
        } 
    }; 
} </pre>
<p>The local repository reads the raw JSON file, which contains the template. It will convert the data to a <kbd>CanvasElementsModel</kbd> class, which, in turn, is nothing but a wrapper around canvas elements:</p>
<pre>public class LocalRepository { 
    ... 
    public static CanvasElementsModel getElements(Context context){ 
        Reader reader = getStreamReaderForRawAsset(context,R.raw.canvas); 
        return new Gson().fromJson(reader, CanvasElementsModel.class); 
    } 
    private static InputStreamReader getStreamReaderForRawAsset(Context context, int resId){ 
        InputStream stream = context.getResources().openRawResource(resId); 
        return new InputStreamReader(stream); 
    } 
} </pre>
<p>Now it is time for some Firebase stuff. The <kbd>IRemoteRepository</kbd> interface has been added to the app. This will avoid a vendor lock in. If you ever want to use another MBaaS or your own API, then all you need to do is change the implementation for the three methods found as follows:</p>
<pre>public interface IRemoteRepository { 
    Canvas createCanvas(); 
    void loadCanvasModels(OnRepositoryResult handler); 
    void saveCanvasModel(Canvas model); 
} </pre>
<p>The <kbd>FirebaseRepository</kbd> class is the Firebase-specific implementation for the <kbd>IRemoteRepository</kbd> interface. The following code snippet shows you what is needed to store and to retrieve canvases. Let's have a look at the constructor first. Here, the reference to a Firebase endpoint is defined. You can modify the reference value to match the endpoint of your own Firebase app:</p>
<pre>public class FirebaseRepository implements IRemoteRepository { 
    private Firebase reference; 
    private Context context; 
    public FirebaseRepository(Context context){ 
        Firebase.setAndroidContext(context); 
        this.context = context; 
        reference = new Firebase("https://torrid-heat-3108.firebaseio.com/canvapp/"); 
    } </pre>
<p>In the <kbd>createCanvas</kbd> method, a new <kbd>Canvas</kbd> object will be created. It will be prefilled with the information we get from the template file through the <kbd>LocalRepository</kbd> class. We change the reference to a child node canvas and a canvas node is being added as a child node of that node. The <kbd>push</kbd> method obtains a unique identifier for the canvas. We will store that ID, created by Firebase, with the <kbd>Canvas</kbd> object. Finally, this method returns the new <kbd>Canvas</kbd> object:</p>
<pre>    @Override 
    public Canvas createCanvas() { 
        Firebase ref = reference.child("canvases"); 
        Canvas canvas = new Canvas() 
        CanvasElementsModel model= LocalRepository.getElements(context); 
        canvas.ELEMENTS= model.ELEMENTS; 
        Firebase postRef = ref.push(); 
        postRef.setValue(canvas); 
        canvas.setId(postRef.getKey()); 
        return canvas; 
    } </pre>
<p>One of the cool things about Firebase is that developers do not need to worry too much about being online or offline. In case the device is offline, this method will succeed anyway. Firebase will take care of persisting the new <kbd>Canvas</kbd> object locally. Once there is an internet connection available again, Firebase will take care of synchronizing the data between your app and the remote repository.</p>
<p>Here is an example of what the app looks like when you start to create a new canvas:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="327" src="assets/0e7ff96c-70aa-4225-aa91-8813660be9a8.png" width="195"/></div>
<p>The <kbd>saveCanvasModel</kbd> method implementation is even smaller. It will update the Firebase data in case the user has made some changes. All you need to do is to call the <kbd>setValue</kbd> method with a given <kbd>Canvas</kbd> object. The method retrieves a reference to the canvas data node. The unique ID we obtained earlier in the <kbd>createCanvas</kbd> method will be used to find the right node. Finally, we only need to call the <kbd>setValue</kbd> method to send the data to Firebase:</p>
<pre>    @Override 
    public void saveCanvasModel(Canvas model) { 
        Firebase ref = reference.child("canvases").child(model.getId()); 
        ref.setValue(model); 
    } </pre>
<p>In the <kbd>loadCanvasModels</kbd> method, we will retrieve all the stored canvases and we will add a listener to the canvases node. Every time data is inserted or when existing data changes, the <kbd>onDataChange</kbd> event will be fired. A snapshot will be provided with each event. It contains the (JSON) data for all child nodes under the canvas's node.</p>
<p>Each child node of the obtained snapshot will be deserialized to a <kbd>Canvas</kbd> object. The <kbd>CanvasList</kbd> fragment will be notified so that it can display or update the list:</p>
<pre>    @Override 
    public void loadCanvasModels(final OnRepositoryResult handler) { 
        Firebase ref = reference.child("canvases"); 
        ref.addValueEventListener(new ValueEventListener() { 
            @Override 
            public void onDataChange(DataSnapshot snapshot) { 
                CanvasListModel model = new CanvasListModel(); 
                for (DataSnapshot canvasSnapshot: snapshot.getChildren()) { 
                    Canvas canvas = canvasSnapshot.getValue(Canvas.class); 
                    canvas.setId(canvasSnapshot.getKey()); 
                    model.canvases.add(canvas); 
                } 
                handler.onResult(model); 
            } 
            @Override 
            public void onCancelled(FirebaseError firebaseError) { 
                System.out.println("The read failed: " + firebaseError.getMessage()); 
            } 
        }); 
    } 
} </pre>
<p>The <kbd>MainActivity</kbd> class is derived from the one that comes with the Navigation Drawer template. It has been slightly modified, so it can display the various fragments. It will also handle the clicks on any of the menu items. The <kbd>onList</kbd> method is triggered if the app starts for the first time or if the user chooses the list option from the menu. The <kbd>onEdit</kbd> method is triggered if the user chooses the <span class="packt_screen">new canvas</span> option from the menu.</p>
<p>The <kbd>onEdit</kbd> method will also be called if the users click on any of the listed Business Model Canvases, as displayed in the <kbd>CanvasList</kbd> fragment. In the <kbd>onEdit</kbd> method, the <kbd>canvas</kbd> parameter will be passed. The <kbd>getRepository</kbd> method returns a class that implements the <kbd>IRemoteRepository</kbd> interface, which in our example is the <kbd>FireBaseRepository</kbd> class. If you want to switch from Firebase to Parse or another MBaaS, then all you need to do is return another repository here:</p>
<pre>public void onList(){ 
    CanvasListFragment fragment = CanvasListFragment.newInstance(); 
    showFragment(fragment); 
} 
public void onEdit(Canvas canvas){ 
    CanvasEditFragment fragment =  CanvasEditFragment.newInstance(canvas); 
    showFragment(fragment);<br/> } 
public void onEdit(){ 
    Canvas canvas = getRepository().createCanvas(); 
    onEdit(canvas); 
} 
private void showFragment(Fragment fragment){ 
    FragmentTransaction ft = getFragmentManager().beginTransaction(); 
    ft.replace(R.id.main_layout_container, fragment, fragment.getClass().toString()); 
    ft.commit(); 
} 
... 
public IRemoteRepository getRepository(){ 
    return new FirebaseRepository(this); 
} 
... </pre>
<p>The app uses three fragments. There is one to display a list of canvases, another one to act as a container for a series of swipeable canvas elements, and there is one for the canvas elements themselves.</p>
<p>The <kbd>CanvasListFragment</kbd> has a <kbd>loadData</kbd> method, which calls the <kbd>loadCanvasModels</kbd> method from the repository:</p>
<pre>public class CanvasListFragment extends Fragment 
        implements OnCardViewClicked, OnRepositoryResult{ 
    private RecyclerView recyclerView; 
    private CanvasListAdapter adapter; 
    private CanvasListModel viewModel; 
 
... 
    @Override 
    public View onCreateView(LayoutInflater inflater, ViewGroup container, 
                             Bundle savedInstanceState) { 
        final View view = inflater.inflate(R.layout.fragment_canvas_list, container, false); 
        recyclerView = (RecyclerView)view.findViewById(R.id.canvas_recycle_view); 
        loadData(); 
        return view; 
    } 
 
    private void loadData(){ 
        recyclerView.setLayoutManager(new LinearLayoutManager(getActivity())); 
        recyclerView.setItemAnimator(new DefaultItemAnimator()); 
        ((MainActivity)getActivity()).getRepository().loadCanvasModels(this); 
            } 
 
    @Override 
    public void onCardClicked(View view, int position) { 
        ((MainActivity)getActivity()).onEdit(viewModel.canvases.get(position)); 
    } </pre>
<p>When the results are retrieved they will be handled in the <kbd>onResult</kbd> method, which will take the result and display list canvases:</p>
<pre>    @Override 
    public void onResult(CanvasListModel result) { 
        viewModel = result; 
        adapter = new CanvasListAdapter(viewModel, R.layout.adapter_canvas_list, getActivity()); 
        adapter.setOnCardViewClicked(this); 
        recyclerView.setAdapter(adapter); 
    } 
} </pre>
<p>The <kbd>CanvasPagerFragment</kbd> is a container fragment. It can hold a number of canvas element fragments, each representing a particular element of the canvas. Users can swipe backward and forward:</p>
<pre>public class CanvasPagerFragment extends Fragment<br/>       implements OnRepositoryResult, View.OnClickListener { 
 
    private static final String ARG_CANVAS = "ARG_CANVAS"; 
    private Canvas canvas; 
    private ViewPager pager; 
    private CanvasElementPageAdapter pagerAdapter; 
 
    public static CanvasPagerFragment newInstance(Canvas canvas) { 
        CanvasPagerFragment fragment = new CanvasPagerFragment(); 
        Bundle bundle = new Bundle(); 
        bundle.putParcelable(ARG_CANVAS, canvas); 
        fragment.setArguments(bundle); 
        return fragment; 
    } 
 
    @Override 
    public void onCreate(Bundle savedInstanceState) { 
        super.onCreate(savedInstanceState); 
        canvas = getArguments().getParcelable(ARG_CANVAS); 
    } 
 
    @Override 
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { 
       final View view = inflater.inflate(R.layout.fragment_canvas_edit, container, false); 
        pager = (ViewPager) view.findViewById(R.id.canvas_edit_pager); 
        view.findViewById(R.id.canvas_edit_save).setOnClickListener(this); 
        loadData(); 
        return view; 
    } </pre>
<p>In the <kbd>loadData</kbd> method, we will create the <kbd>pagerAdapter</kbd> based on the provided <kbd>Canvas</kbd> object:</p>
<div class="packt_infobox">The <kbd>setOffscreenPageLimit</kbd> method is set to <kbd>11</kbd> here (each canvas contains 11 elements, so we need 11 instances of the <kbd>CanvasElementFragment</kbd> class) to make sure we can access all element fragments. This is done for demonstration purposes only and it should be avoided in a real-world app. It may cause memory issues:</div>
<pre>private void loadData(){ 
        MainActivity ma = (MainActivity)getActivity(); 
        pagerAdapter = new CanvasElementPageAdapter( 
         ma.getSupportFragmentManager(),getActivity(),canvas); 
        pager.setOffscreenPageLimit(11); 
        pager.setAdapter(pagerAdapter); 
    } 
 
    @Override 
    public void onClick(View v) { 
        onSaveData(); 
    } </pre>
<p>If the user clicks on the <span class="packt_screen">Save</span> button, the <kbd>onSaveData</kbd> method will be triggered. There we call the <kbd>saveCanvasModel</kbd> method from the repository and pass the updated canvas object. Finally, we will navigate back to the list of canvases:</p>
<pre>    private void onSaveData(){ 
        Canvas canvas = pagerAdapter.getCanvas(); 
        MainActivity activity = (MainActivity)getActivity(); 
        activity.getRepository().saveCanvasModel(canvas); 
        activity.onList(); 
    } 
    ... 
    } 
} </pre>
<p>The <kbd>CanvasElementFragment</kbd> represents an element of the Business Model Canvas. This, for example, could be the card where a user can enter ideas about the value proposition:</p>
<pre>public class CanvasElementFragment extends Fragment { 
    private static final String ARG_ELEMENT = "ARG_ELEMENT"; 
    public static CanvasElementFragment newInstance(CanvasElement element) { 
        CanvasElementFragment fragment = new CanvasElementFragment(); 
        Bundle bundle = new Bundle();<br/>         bundle.putParcelable(ARG_ELEMENT, element); 
        fragment.setArguments(bundle); 
        return fragment; 
    } 
    private CanvasElement element; 
 
    public CanvasElement getElement(){ 
        if (getView() != null) { 
            EditText editValue = (EditText) getView().findViewById(R.id.element_value); 
            element.VALUE = editValue.getText().toString(); 
        } 
        return element; 
    } 
    @Override 
    public void onCreate(Bundle savedInstanceState) { 
        super.onCreate(savedInstanceState); 
        element = getArguments().getParcelable(ARG_ELEMENT); 
    } </pre>
<p>In the <kbd>OnCreateView</kbd> method, we will bind the element object to the view:</p>
<pre>    @Override 
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { 
        final View view = inflater.inflate(R.layout.fragment_canvas_element, container, false); 
        ((TextView)view.findViewById(R.id.element_text_title)).setText(element.TITLE); 
        ((TextView)view.findViewById(R.id.element_text_description)).setText(element.DESCRIPTION); 
        ((TextView) view.findViewById(R.id.element_value)).setHint(element.HINT);<br/>         if (element.VALUE != null){ 
            EditText editValue = (EditText) view.findViewById(R.id.element_value); 
            editValue.setText(element.VALUE); 
        } 
        return view; 
    } 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Firebase dashboard</h1>
                </header>
            
            <article>
                
<p>If you have been playing with the app a little, have added some canvases and then gone to the Firebase dashboard, you will see all the canvases that you have just created appear here. All updates appear here instantly (of course, only if the device you are testing the app on is online).</p>
<p>This also makes Firebase very suitable for chat applications. It works the other way around as well. If you add a new canvas node here, it will appear instantly in the app. Just give it a try, add some nodes, play a bit and adapt the app a bit to test other Firebase functionality as well.</p>
<p>This is what the dashboard may look like.</p>
<div class="packt_infobox">To clarify this example, the title, description and hint fields, that already persist locally, are stored here as well. It makes sense to avoid data redundancy as much as possible and to store only the <kbd>ID</kbd> and <kbd>VALUE</kbd> properties of each element:</div>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="526" src="assets/edafd642-50b0-4e2d-8fe0-ecefc7289f3b.png" width="633"/></div>
<p>With only a little bit of code, you can persist your data in the cloud with Firebase. You do not need to worry about scalability issues, being online or offline and many other cases. Firebase has many more options such as user management (sign up, login), security, limitation, and paging options.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have seen what services we can choose from if we do not want to create the backend for the app ourselves. We learned what could be important for making the right strategic and technical choices and also saw an example app, which is using Firebase as a mobile backend. You can use the app to learn from or you can enhance it and use it as a starter project for your own app idea.</p>
<p>The app that we examined is for Android only. What if you want to have this app built for iOS? Should you create it again, but this time using Swift and Xcode? Are there other options to develop an app just one time but for multiple (mobile) platforms? You can check out the next chapter to learn more about this.</p>


            </article>

            
        </section>
    </body></html>