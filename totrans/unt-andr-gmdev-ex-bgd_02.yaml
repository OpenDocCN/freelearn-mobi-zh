- en: Chapter 2. Looking Good – Graphical Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*In the previous chapter, we covered the features of Unity and Android. We
    also discussed the benefits of using them together. After we finished installing
    a bunch of software and setting up our devices, we created a simple Hello World
    application to confirm that everything was connected correctly.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*This chapter is all about **Graphical User Interface** (**GUI**). We will
    start by creating a simple Tic-tac-toe game, using the basic pieces of GUI that
    Unity provides. Following that we will discuss Unity''s GUI Styles and GUI Skins.
    Using what we learned, we will improve the look of our game. Also, we will explore
    some tips and tricks for handling many different screen sizes of Android devices.
    Finally, we will learn about a much quicker way to put our games on the device,
    which was covered in the previous chapter. With all that said, let''s jump in.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: User preferences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buttons and labels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GUI Skins and GUI Styles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic GUI positioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build and run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will be creating a new project in Unity. The first section
    here will walk you through its creation and setup.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Tic-tac-toe game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The project for this chapter is a simple Tic-tac-toe-style game, similar to
    what any of us might play on paper. As with anything else, there are several ways
    you could make this game. We are going to use Unity's GUI system, in order to
    better understand how to create a GUI for any of our other games.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating Tic-tac-toe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The basic Tic-tac-toe game involves two players and a 3 x 3 grid. The players
    take turns filling X''s and O''s. The player who first fills a line of three squares
    with his/her letter wins the game. If all squares are filled without a player
    achieving a line of three, the game is a tie. Let''s perform the following steps
    to create our game:'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to do is to create a project for this chapter. So, start up
    Unity and we will do just that.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you have been following along so far, Unity should boot up into the last
    project that was open. This isn''t a bad feature, but it can become extremely
    annoying. Think of it like this: you have been working on a project for a while
    and it has grown large. Now you need to quickly open something else, but Unity
    defaults to your huge project. If you wait for it to open before you can work
    on anything else, it can consume a lot of time. To change this feature, go to
    the top of the Unity window and click on **Edit** followed by **Preferences**.
    This is the same place where we changed our script editor''s preferences. This
    time, though, we are going to change settings in the **General** tab. The following
    screenshot shows the options present under the **General** tab:![Time for action
    – creating Tic-tac-toe](img/2014OT_02_01.png.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this moment, the primary concern is the **Always Show Project Wizard** option;
    however, we will still cover all of the options in turn. All the options under
    the **General** tab are explained in detail as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Auto Refresh**: This is one of the best features of Unity. As assets are
    changed outside of Unity, this option lets Unity automatically detect the change
    and refresh the asset inside your project.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Always Show Project Wizard**: This is a great first option to go check whenever
    installing Unity. Instead of opening the last project, Unity opens **Project Wizard**.
    From there, you can open any project of your choice or create a new one. This
    is always a good one to turn on.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compress Assets on Import**: This is the checkbox for automatically compressing
    your game assets when they are first imported to Unity.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Editor Analytics**: This is the checkbox for Unity''s anonymous usage statistics.
    Leave it checked and the Unity Editor sends info occasionally to the Unity source.
    It doesn''t hurt anything to leave it on, and helps the Unity team make the Unity
    Editor better. But it comes down to personal preference.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Show Asset Store search hits**: This setting is only relevant if you are
    planning to use the Asset Store. The Asset Store can be a great source of assets
    and tools for any game; however, since we are not going to use it, the relevance
    to this book is rather limited. It does what the name suggests. When you search
    the Asset Store for something from within the Unity Editor, the number of results
    is displayed based on this checkbox.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Verify Saving Assets**: This is a good one to be left off. If this is on,
    every time you click on **Save** in Unity. A dialog box will pop up so that you
    can make sure you save any and all of the assets that have changed since your
    last save. It is not so much about your models and textures, but concerned with
    Unity''s internal files, the materials, and prefabs. Best to leave it off for
    now.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Skin (Pro Only)**: This option only applies to Unity''s pro users. It gives
    the option to switch between the light and dark versions of the Unity Editor.
    It is purely cosmetic, so go with your gut for this one.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With your preferences set, now go up to **File** and follow it with selecting
    **Open Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Create New Project** tab, followed by the **Browse...** button
    to pick a location and name for the new project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will not be using any of the included packages, so click on **Create** and
    we can get on with it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once Unity finishes initializing the new project, create two new scripts in
    the **Project** panel, just as we did for the *Hello World* project in the previous
    chapter. Name the new scripts as `TicTacToeControl` and `SquareState`. Open them
    and clear out the default functions; again, just as we did in [Chapter 1](ch01.html
    "Chapter 1. Saying Hello to Unity and Android"), *Saying Hello to Unity and Android*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `SquareState` script will hold the possible states of each square of our
    game board. To do that, clear everything out of the script and replace it with
    a simple enumeration. An enumeration is just a list of potential values. This
    one is concerned with the player who controls the square. Do X's control it, O's
    control it, or is it clear because the game board is traditionally clear by default.
    `Clear` becomes the first and therefore the default state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In our other script, `TicTacToeControl`, we start with two variables that will
    largely control the flow of the game. The first defines our game board. Traditionally
    the game is played on a 3 x 3 grid, therefore nine squares. The second line dictates
    whose turn it is. How it is going to change will be made clear in a little bit,
    but for now suffice it to say that if it is X's turn, the value will be true.
    If it is not X's turn, the value will be false.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In Unity, every script by default inherits from the `MonoBehaviour` class. This
    gives our scripts two primary benefits.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: First, it allows us to add our scripts to objects as components. The filename
    of the script also needs to be the exact same as the class name within the script,
    if you plan on adding the script to an object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The second benefit of the `MonoBehaviour` class is the variety of variables
    and functions that come with it. The variables give us access to all the parts
    that make up objects in Unity. The functions provide a number of automatic features
    and access to the game initialization and loop. This is what we are most interested
    in at this particular moment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In order to draw anything in each GUI frame, one needs to utilize the `OnGUI`
    function provided by the `MonoBehaviour` class. That is where we will draw our
    game board. The `OnGUI` function lets us draw our interface every frame. Inside
    it, we will first define the width and height of our board squares.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Following that is a pair of for-loops. Because our board is a 3 x 3 grid, we
    need the loops to count three rows of three squares.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside the loops we must first figure out which square we are currently drawing.
    It becomes hard to play a game, if you don't know which square was touched.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next line of code defines whether the square is going to be drawn as a `Rect`
    class. A `Rect` class is defined in GUI space as x position, y position, width,
    and height. In Unity, GUI space is defined as the top-left corner being (0,0)
    and the bottom-right is `Screen.width`, `Screen.height`. The width and height
    of the screen are the number of pixels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then figure out who controls the square. The following line of code is a
    little complicated, but it is really just a compressed `if` statement. Basically,
    it works like this: first check a condition and if it is true return the first
    value, whatever is between the question mark and the colon. If the condition is
    false, return the value after the colon. Two of these compressed `if` statements
    were combined here; if the square is owned by X, set our owner to X. Otherwise,
    if it is owned by O, set the owner to O. If neither of the conditions is true,
    nobody owns the square and we set our owner to an empty string.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that all the hard work of figuring out where we are is done, we actually
    draw our game board square. This is done through the use of a wonderful little
    function provided by Unity, `GUI.Button`. To use this function in its basic form,
    we must tell the function where the button should be drawn and what text to display,
    hence rect and string. We give it our square and owner variables, it does all
    the hard work of actually drawing on screen, and we are given back a Boolean result,
    whether or not the button was pressed. Therefore, we check it with an `if` statement
    and if true, we send to a new function which square was pressed, letting it handle
    setting the owner. Also, don't forget the extra curly braces to close up the loops
    and the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `SetControl` function is pretty short; it simply sets the owner for whichever
    square is passed to it. It first makes sure that the index given is actually within
    the range for our board. If it is not, we'll exit the function early. The next
    line of code sets control of the board square based on whose turn it is. If it
    is X's turn, set the square to `XControl`; otherwise set control to `OControl`.
    Finally we change whose turn it is. This is done by simply setting our `xTurn`
    Boolean to the opposite of itself, indicating that it is the other person's turn.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are just about ready to play our game. We just need to set up the scene.
    To do this, start by dragging our `TicTacToeControl` script from the **Project**
    pane of the Unity Editor to the **Main Camera** object in the **Hierarchy** pane
    of the Unity Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now save the scene, just as we did in [Chapter 1](ch01.html "Chapter 1. Saying
    Hello to Unity and Android"), *Saying Hello to Unity and Android*, as `TicTacToe`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is possible to play the game at this point. It is also possible to do so
    on a device; just follow the same steps as in [Chapter 1](ch01.html "Chapter 1. Saying
    Hello to Unity and Android"), *Saying Hello to Unity and Android*, but for now
    just perform testing in the Unity Editor. Later in this chapter we will cover
    a much easier way to build to our devices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created the very base of what we need to play Tic-tac-toe. We did this with
    two short and simple scripts. However, while playing the game now, you probably
    noticed a few things about it. For starters, it doesn't look particularly fantastic.
    That is extremely odd, considering it is the point of this chapter, but we will
    address that soon enough. Second, there are no checks to determine whether or
    not somebody already controls a square.
  prefs: []
  type: TYPE_NORMAL
- en: Also, there are no checks to see if anybody won the game. Finally, if you decided
    to build to device, you might have noticed one of the great things about Unity's
    GUI functions. There is no special programming needed to make any of the GUI functions
    work with touch inputs rather than the mouse. A lot of time is saved when you
    don't have to worry about special inputs, especially if you plan on multiplatform
    targeting.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you didn't want to go through the process of building the application and
    putting it on your device, it is still possible for you to try out interacting
    with the buttons, and touching them with your fingers. In [Chapter 1](ch01.html
    "Chapter 1. Saying Hello to Unity and Android"), *Saying Hello to Unity and Android*,
    we installed the application, Unity Remote. Plug the device into your computer
    and start it up; when you click on **Play** in the Unity Editor, you should see
    the game running on your device. If you can see the game playing in the Unity
    Editor but not on the device, just restart Unity. Make sure to save it; it would
    be awful to lose all of your hard work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Undoubtedly the first thing you will notice when using Unity Remote is that
    the game doesn''t look good. It is almost certainly stretched and pixelated. If
    it doesn''t concern you now, don''t worry, it gets worse when the project becomes
    more complicated. Now, before you start freaking out, grumbling about why you
    had to install such a useless program, you must understand the point of Unity
    Remote. We went over it sometime back, but we will dig a little deeper. Unity
    Remote is for testing device inputs: touch screen, tilt, and so on. What it looks
    like is a result of freeing up bandwidth so that the frame rate is the same as
    it is in the Unity Editor.'
  prefs: []
  type: TYPE_NORMAL
- en: There is something you can and should do about the stretching. At the top-left
    corner of the **Game** window of the Unity Editor is a drop-down list. By default
    it is set to **Free Aspect**, which means the window will fill all the space available.
    If you click on it, a variety of aspect ratio options will be presented. Clicking
    through these options, you will see black bars in the **Game** window. This is
    Unity resizing the **Game** window and blacking out the unused space. The options
    change based on what the build target is. In the **Build Settings** window, change
    your platform to Android. In the **Game** window's drop-down menu, find an aspect
    ratio that matches your device. With that selected, your game will no longer appear
    stretched when using Unity Remote.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – finish creating the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us finish the creation of our game by creating an opening screen. We will
    then add some checks to stop players from selecting squares more than once. Follow
    that with a check to see if anyone won and finally display a game over screen.
    With that, the game will be ready for us to make it look great.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps for finishing our game:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will do all this by first creating another script like our `SquareState`
    script. Create the new `GameState` script and clear out the default contents.
    Add the following code snippet and we will have the values needed to track the
    current state of our game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We now need to update our `TicTacToeControl` script. For starters, because we
    want to be able to play multiple games, add the `NewGame` function to the script.
    This function initializes our control variables so that we can start a fresh game
    with a clear board. It will not do very well for players to start a new game and
    have the board already filled in. This function will be used by our main menu,
    which we will be writing shortly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: But first, we need to update our `OnGUI` function. To do that, start by moving
    all of the current contents of `OnGUI` to a new function called `DrawGameBoard`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need to change our cleared `OnGUI` function to the following code snippet
    in order to allow it to check and draw the proper screen based on the current
    game state. A `switch` statement works the same as a bunch of `if` and `else if`
    statements. In our case, we check the game state and call a different function
    based on what it is. For example, if the game state is equal to `GameState.MultiPlayer`,
    we will call the `DrawGameBoard` function, which should now contain what used
    to be in the `OnGUI` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By this point you are probably wondering where that game state variable is
    coming from. If you guessed that it was automatically provided by Unity, you are
    wrong. We have to track our own game state. That is why we created the `GameState`
    script earlier. Add the following line of code to the top of our `TicTacToeControl`
    class, right above where we defined our game board:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we need to create the other two game state screens. Let us start with
    the opening screen. When we draw our opening screen, we start by defining the
    `Rect` class used by our title. We follow that with a quick call to `GUI.Label`.
    By passing it a `Rect` class to position itself by and some text, the text is
    simply drawn on screen. This function is the best way to draw a section of text
    on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The following line of code defines the `Rect` class used by our `New Game` button.
    We want to be sure that it was right under the title, so it starts with the title's
    x position. We then combine the title's y position with its height to find the
    position right underneath it. Next, we used the width from the title so that our
    button will cover the entire position under it. Finally, the height is set to
    `75` because it is a good size for fingers and we don't want it to change based
    on the title. We could have just as easily used all the values from the title
    or just put in the numbers but our title will change later when we start styling
    everything.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we make a call that will draw our button. You may remember our use
    of the `GUI.Button` function from when we drew the game board. If the button is
    pressed, the game state is set to `MultiPlayer` that will start our game. The
    `NewGame` function is also called, which will reset our game board. And of course,
    there is an extra curly brace to finish off the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have one screen left to draw, the game over screen. To do this, we will create
    the function referenced by our `OnGUI` function. However, in order for a game
    to end, there must be a winner, so add the following line of code right under
    our game state variable. We are making extended use of the `SquareState` enumeration.
    If the winner variable is equal to `Clear`, nobody won the game. If it is equal
    to `XControl` or `OControl`, the relevant player has won. Don't worry, it will
    make more sense when we create the game over screen next and the winner check
    system in a little bit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There is nothing particularly new in the `DrawGameOver` function. First, we'll
    define where we are going to write who won the game. We'll then figure out who
    won, using our winner variable. After drawing the winner title, the `Rect` class
    used is shifted down by its height so it can be reused. Finally, we'll draw a
    button that changes our game state back to `Opening`, which is of course our main
    menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To make sure we are not overwriting squares that somebody already controls,
    we need to make a few changes to our `DrawGameBoard` function. First, it would
    be helpful if the players could easily tell whose turn it is. To do this, we'll
    add the following code snippet to the end of the function. This should start to
    become familiar. We'll first define where we want to draw. Then, we'll use our
    `xTurn` Boolean to determine what to write about whose turn it is. Finally, it
    is the `GUI.Label` function to draw it on screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We now need to change the bit where we draw the board square, the `GUI.Button`
    function. We need to only draw that button if the square is clear. The following
    code snippet will do just that by moving the button inside of a new `if` statement.
    It checks whether the board square is clear. If it is, we draw the button. Otherwise,
    we use a label to write the owner to the button's location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last thing we need to do is make a system that checks for a winner. We will
    do this in another function provided by the `MonoBehaviour` class. `LateUpdate`
    is called at the end of every frame, just before things are drawn on the screen.
    You might be wondering to yourself, why don't we just create a function that is
    called at the end of `OnGUI`, which is already called every frame? The reason
    is that the `OnGUI` function gets a little weird when drawing some of the GUI
    elements. It will sometimes be called more than once so that it can draw everything.
    So, for the most part, the functionality should never be controlled by `OnGUI`.
    That is what `Update` and `LateUpdate` are for. `Update` is the normal game loop
    where most of a game's functionality is called from. `LateUpdate` is for things
    that need to happen after the objects' update, such as our check for a game over.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the following `LateUpdate` function to our `TicTacToeControl` class. We'll
    start with a check to make sure we should even be checking for a winner. If the
    game isn't in a state where we are playing, in this case `MultiPlayer`, exit here
    and go no further.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Follow that with a short `for` loop. A victory in this game is a run of three
    matching squares. We start by checking the column that is marked by our loop.
    If the first square is not `Clear`, compare it to the square below; if they match,
    check it against the square below that. Our board is stored as a list but drawn
    as a grid, so we have to add three to go down a square. The `else if` statement
    follows checks of each row. By multiplying our loop value by three, we will skip
    down a row of each loop. We'll again compare the square to `SquareState.Clear`,
    then to the square one to its right, and finally two to the right. If either set
    of conditions is correct, we'll send the first square in the set out to another
    function to change our game state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The following code snippet is largely the same as the `if` statements we just
    wrote previously. However, these lines of code check the diagonals. If the conditions
    are true, again send out to the other function to change game states. You have
    probably also noticed the returns after the function calls. If we have found a
    winner at any point, there is no need to check any more of the board. So, we'll
    exit the `LateUpdate` function early.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is the last little bit for our `LateUpdate` function. If no one has won
    the game, as determined by the previous parts of this function, we have to check
    for a tie. This is done by checking all of the squares of the game board. If any
    one of them is `Clear`, the game has yet to finish and we exit the function. But,
    if we make it through the entire loop without finding a `Clear` square, we go
    set the winner but declare a tie.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Do remember to close the last curly brace. It is needed to close off the `LateUpdate`
    function. If you forget it, some annoying errors will come your way.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, we'll create the `SetWinner` function that is called repeatedly in
    our `LateUpdate` function. Short and sweet, we'll pass to this function that is
    going to win. It sets our winner variable and changes our game state to `GameOver`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action – finish creating the game](img/2014OT_02_02.png.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: That is it. Congratulations! We now have a fully functioning Tic-tac-toe game
    and you survived the process. In the next sections, we will finally get to make
    it all look pretty. That is a good thing because, as the screenshot shows, the
    game does not look great right now.
  prefs: []
  type: TYPE_NORMAL
- en: GUI Skins and GUI Styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GUI Styles are how we change the look and feel of GUI elements, buttons, and
    labels in Unity. A GUI Skin contains several GUI Styles and allows us to change
    the look of the entire GUI without explicitly defining GUI Styles for each element.
    To create a GUI Skin, right-click in the **Project** window of the Unity Editor,
    just as with creating a new script. Go to **Create** but, instead of selecting
    **Script**, go to the bottom and select **GUI skin**. Selecting this option will
    create the new GUI Skin and let us name it to `GameSkin`. By looking at our `GameSkin`
    in the **Inspector** window, you can see what we have to work with.
  prefs: []
  type: TYPE_NORMAL
- en: '![GUI Skins and GUI Styles](img/2014OT_02_03.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At the top is a **Font** attribute. By importing font files to your project
    and placing one here, you can change the default font used by text in the whole
    game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Under that is a long list of GUI elements, including our good friends **Button**
    and **Label**. These are all GUI Styles and coincide with the GUI functions that
    we use to draw things on screen. For example, unless otherwise specified, when
    we use the `Button` function, it will draw using the **Button** GUI Style.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following the list of GUI elements is a **Custom Styles** attribute. This is
    where we can put any extra styles that we want to use. Of our dozen buttons, perhaps
    we want one to have red text. That GUI Style would go here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the bottom is a **Settings** attribute. By expanding it, we can see it is
    fairly short. It includes options for whether or not multiclicks can be used for
    selection, what color of cursor and how fast it should flash when in a text field,
    and what color the highlight on selected words should be. The defaults here are
    just fine. Unless there is a very specific look or need, these values can be ignored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let us go over what it takes to be a GUI Style. Expand the **Button** GUI
    Style from our `GameSkin` example. No matter what the GUI Style is used for, they
    all are made up the same. It may look like there are many attributes that make
    up a GUI Style, but most of them are nearly identical, making it much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: '![GUI Skins and GUI Styles](img/2014OT_02_04.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first attribute is fairly straightforward, but perhaps the most important.
    **Name** is what Unity uses to find GUI Styles and apply them to GUI elements.
    It lets us know what the style is supposed to be; however, if there is a typo
    between it and the code, you will never see your style in the game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next several groups of values describe how the GUI element should look
    when in a particular state. This is where the bulk of your styling will go. The
    primary states of any element are **Normal**, **Hover**, **Active**, and **Focused**.
    Secondary to these are **On Normal**, **On Hover**, **On Active**, and **On Focused**.
    These secondary states only occur as the GUI element transfers into the corresponding
    primary state. Not every GUI element makes use of every state, and you have the
    ability to control which states an element can go into, but we will discuss that
    a little later. Let''s see in detail how these states work:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Normal**: This is the default state of any GUI element. It is always used
    and occurs any time the element is not being interacted with.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hover**: This state is used primarily by buttons and other clickable elements.
    When your mouse is on top of a GUI element, it will enter this state, if it can.
    However, since the focus of this book is touch screens, we do not have a mouse
    to really concern ourselves with. So, we will not be using this state.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Active**: This has to be the second most important state. An element enters
    this state when it is activated. For example, when one presses a button, it is
    active. By clicking on or touching a button, it enters the **Active** state. All
    of the GUI elements that can be interacted with use this state.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Focused**: This is a rarely used state. In terms of Unity''s GUI, focused
    means having keyboard control. The only element that uses it by default is the
    **Text Field**.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you were to expand any of the states, you would see that it has two attributes,
    **Background** and **Text Color**. The **Background** attribute is a texture.
    It can be any texture in your game. The **Text Color** attribute is simply the
    color of any text that appears in the GUI element. Except for the **Normal** state,
    if a state does not have a background texture, it will not be used. This can be
    both good and annoying. If we do not want our buttons to show that they have been
    hovered over, simply remove the texture from the Hover state's **Background**
    attribute. It becomes annoying when we want a GUI element that does not have a
    background image of its own, but we do want the text to change color between states.
    How do we make use of the active state, but not use a texture for the background?
    The answer is that we create a blank image, but it is not quite as simple as saving
    off a 100 percent transparent PNG and using that. The GUI Style is too smart for
    that. It detects that the image is completely blank, making it no different than
    if there was no image. And so, the state still is not used. To get around this,
    create a small, blank PNG image, but take a single pixel and make it 90 percent
    transparent white. This might seem like a hack solution, but it is, unfortunately,
    the only way. At such a low transparency, we can't detect the pixel; though it
    is not actually clear. However, Unity sees that there is a slightly white pixel
    that must be drawn and does so.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, you might be thinking, that's stupid. I'm just going to create images of
    all of my buttons and not worry about the text. It is indeed stupid but the response
    to that is, what if you need to slightly change the text of a button? Or perhaps
    the text on the button is dynamic based on the player's name. In nearly every
    project I have been a part of there has been a need to create the not quite blank
    image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Below the GUI element''s states are **Border**, **Margin**, **Padding**, and
    **Overflow**. These attributes control how an element interacts with its background
    images and contained text. Inside each you will find **Left**, **Right**, **Top**,
    and **Bottom** values. Since every element is drawn as a rectangle, these correspond
    to each side of the said rectangle. They are defined in pixels, just like our
    GUI space. Let''s see all these attributes in detail as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Border**: This lets us define how many pixels from each side should not be
    stretched. When defining a GUI element, the background is normally stretched evenly
    across the space occupied. If you were to create a blue box with red edging and
    rounded corners, these values would keep your edges and corners regular while
    still stretching the blue on the inside.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Margin**: This is only used by Unity''s automatic GUI layout system named
    GUILayout. It is how much extra space should be around the outside of the element.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Padding**: This is the space between the borders of an element and the text
    that it contains. If you want the text of a button left-justified but in slightly,
    you should use **Padding**.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overflow**: This defines an extra space for your background image. When creating
    our buttons, we defined a `Rect` class for how much space the button takes up.
    If we are to use `Overflow`, the button itself would be where the `Rect` class
    is, but the background would extend beyond each edge as dictated by the values.
    This would be useful for buttons with a shadow or glow around them.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The next several values have to do with the text in an element. The **Font**
    attribute is a font that is used specifically by this style. If this value is
    left empty, the font from the GUI Skin is used. **Font Size** is how big the letters
    of the text should be. This works just like your favorite word processor, except
    that a value of zero means to use the default font size defined in the font object.
    **Font Style** also works like your word processor. It lets you choose between
    **Normal**, **Bold**, and **Italic** text. This only makes a difference if it
    is supported by your chosen font.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alignment** defines where to justify the text in the GUI element. Imagine
    splitting your element into a 3 x 3 grid. **Alignment** is the same as the position
    of the grid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Word Wrap** defines whether or not text should split into multiple lines
    if it is too long. It again works on the same principle as your word processor.
    If checked and the line of text would extend beyond the sides of the GUI element,
    the text is split into as many lines as necessary to keep it within the bounds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rich Text** is a fairly new and interesting feature of GUI Styles. It allows
    us to use HTML style markup to control text. You could put the tags `<b>` and
    `</b>` around a word in your Label''s text, and instead of writing those tags,
    Unity will make the words in between bold. We can make use of the bold, italics,
    size, and color tags. This allows for selectively making parts of our text bold
    or italics. We can make certain words larger or smaller. And, the color of any
    part of the text can be altered using hexadecimal values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Text Clipping** became weird in the recent updates. It used to be a nice
    drop-down list of values, but now it is an integer field. Either way, it still
    serves its function. If the text extends beyond the edges of the GUI element,
    this attribute dictates what to do. A value of zero means don''t clip the text,
    let it extend beyond the edges. Any value that is not zero will cause the text
    to be clipped. Any text that extends beyond the borders will simply not be drawn.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Image Position** is used in conjunction with GUIContent. GUIContent is a
    way of passing GUI elements the text, an icon image, and a tool tip. **Image Position**
    describes how the image and text interact. The image can either go to the left
    of the text or above. Or, we can choose to only use either the image or the text.
    Since tool tips aren''t really useful in a touch environment, GUIContent is of
    limited use to us. For that reason, we will not be using it extensively, if at
    all.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Content Offset** adjusts anything contained inside the GUI element by the
    values provided. If all of your text is normally centered in your button, this
    will allow you to move it slightly to the right and up. It is an aesthetic thing,
    for when you need a very specific look.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fixed Width** and **Fixed Height** provides approximately the same function.
    If any value other than zero is provided for these attributes, they will override
    the corresponding values in the `Rect` class used for the GUI element. So, if
    you wanted buttons to always be one hundred pixels wide, no matter where they
    are in the game, you could set **Fixed Width** to one hundred and they will do
    just that.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stretch Width** and **Stretch Height** also serves about the same function.
    They are used by GUILayout for automatic placement of GUI elements. It pretty
    much gives the system permission to make elements wider/skinnier and taller/shorter,
    respectively, in order to satisfy its conditions for a better layout. The way
    GUILayout arranges elements is not always the best. It is good, if you need something
    up quick. But it gets complicated if you want any sort of deeper control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A prettier form of Tic-tac-toe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we get to put what we learned about GUI Skins and GUI Styles into action
    and make our game look better. Or, at least make the game look like it isn't using
    default assets. Whatever your artistic talents, you will need to find or create
    a few images to continue following along.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – styling the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you do not want to look far, the assets used for this chapter are found along
    with the resources for the book. All of the needed images are available, and they
    will work just well, until you have an opportunity to create some of your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need five small textures: `ButtonActive`, `ButtonNormal`, `ONormal`,
    `XNormal`, and `Title`. To create these, you will have to use a separate photo-editing
    program or use the ones supplied with the included projects.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The easiest way to get the images into your Unity project is to simply save
    them into the `Assets` folder that is created when you create a new project. Alternatively,
    you can go up to the top and click on **Assets** followed by **Import New Asset**.
    This will open a file browser and let you navigate to the asset you want. When
    you have found the asset you desire to import and have clicked on the **Import**
    button, a copy of the asset is put in your project. Unity will not move or remove
    files that exist outside of the current project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And now a note about import settings for textures. By default, Unity assumes
    any image files imported to your project are going to be used as game model textures.
    Because of that, Unity compresses them and adjusts them to fit a power of two.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In case you didn't know, in computer graphics it is much faster to render images
    that can be divided in half evenly, down to a single unit. There are deeper reasons,
    but suffice it to say that it is because of the binary switches that actually
    make up a computer.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action – styling the game](img/2014OT_02_05.png.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: Making our images recognized as being for the GUI is quite simple. To the right
    of **Texture Type**, click on **Texture** and select **GUI** from the drop-down
    menu.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You will notice that we were given a new **Filter Mode** drop-down menu. This
    is essentially how much effort Unity will put into making the image look nice
    as it is resized for the various GUI elements. **Trilinear** is the best, **Point**
    is the fastest, and **Bilinear** is in the middle.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the import settings have been changed, be sure to click on **Apply**, or
    Unity will complain when you try to do anything else. If you do not want to commit
    the changes, clicking on **Revert** will discard any changes just made and set
    back the **Import Settings** window to the last configuration that was used.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: So, set all of **Texture Types** for your images to GUI and we will get on with
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let us start with the beginning of the game. Open your `TicTacToeControl` script
    and add the following lines of code at the beginning. These allow us to attach
    references to other assets inside of the Unity Editor. The first will hold our
    `GameSkin`, so we can style all of our GUI elements. The second, as you can see
    in the following lines of code, will hold our fancy title image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now go to the Unity Editor and select **Main Camera** from the **Hierarchy**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every object that you see listed in the **Hierarchy** window is a `GameObject`.
    A `GameObject` is given a purpose and a meaning by the various components that
    are attached to it, for example, our `TicTacToeControl` script.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An empty `GameObject` is just a point in space, as defined by the `Transform`
    component that is always the first component on any `GameObject`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see in the **Inspector** window, the **Main Camera** object has a **Camera**
    component. It gives a purpose to the `GameObject` and controls how the **Camera**
    component functions, just as our `TicTacToeControl` component at the bottom lets
    it control our Tic-tac-toe game.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Inspector** window also lets us see all of the public variables that can
    be changed in the Unity Editor. If they are changed, those values are saved and
    used when the game is played. So, by creating a variable in our script, we can
    add the reference to our `GameSkin` and it will be used in the game. To add the
    reference, simply click-and-drag the object to the desired variable on the component
    in the **Inspector** window.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Drag `GameSkin` to the **GUI Skin** slot and our title image to the **Title
    Image** slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Be sure to save. Saving regularly is the only thing that stands between you
    and premature baldness, the next time your computer decides to die.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Inside of our `TicTacToeControl` script, add the following line of code at the
    beginning of the `OnGUI` function. It first checks to make sure there is a GUI
    Skin available. If it is, it is set into the `GUI.skin` variable. This variable
    controls the GUI Skin that is used in the game. Once set, any GUI elements drawn
    after that will use the new GUI Skin. This could allow you to set one GUI Skin
    and draw half of the GUI, then set a different GUI Skin and draw the other half
    in a completely different style.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you play your game now, it won't look like much. The defaults of a new GUI
    Skin are the exact same as the default GUI Skin that Unity uses. Let us change
    that by selecting our `GameSkin` and expanding **Button** and **Label** in the
    **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For **Button** we created a **ButtonNormal** and **ButtonActive** image. By
    dragging those to the **Background** properties of the respective states, the
    look of the buttons will change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The supplied button images have a yellow background, which will make the white
    text hard to read. So, by clicking on the color next to the **Text Color** property,
    the **Color Picker** window will open and we can select a new color. A navy blue
    for the **Normal** state and a faded blue for the **Active** state works well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, to keep it from looking weird in the Unity Editor, remove the **Hover**
    state. With a touch interface, there is no cursor to hover over buttons; therefore,
    there is no need for a hover state. To remove it, first click on the little circle
    to the right of the **Background** image.![Time for action – styling the game](img/2014OT_02_06.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new window that pops up allows us to select any image that is currently
    in our project. However, since we want nothing to be in there select **None**,
    the first option in the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The borders on the button images are much larger than those of the default buttons.
    So, we need to adjust the **Border** attribute to accommodate them. Values of
    15 for each side works well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The text is also too small, so for the **Font Size** attribute choose a value
    of 40\. This will give us a large and easily readable text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the **Label** element, we are only going to make two changes. First, the
    text is too small. So, it will also get a value of 40 for its font size. Second,
    we want the text to be centered in the GUI elements. That requires setting the
    alignment to middle center.![Time for action – styling the game](img/2014OT_02_07.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play the game now. It is already looking better or at least different. However,
    it is a little difficult to tell at a glance who controls which square. To fix
    this we are going to create two custom GUI Styles. To do this, expand the **Custom
    Styles** attribute of our `GameSkin` in the **Inspector** window. By default,
    one blank style is already in there. We are going to need two, but don't change
    the quantity just yet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the custom GUI Style, by default called `Element 0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On clicking to the right of the **Name** attribute, more or less in the middle
    of the **Inspector** window, will allow us to rename the style. The name is very
    important. Whatever we call it here we need to call it exactly the same in code
    or it won't be used. Give it the name `XSquare` because it will be used to mark
    which squares are controlled by the X player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside of the **Normal** state, add the **XNormal** image to the **Background**
    attribute. The **Text Color** attribute can be left as black. We also need to
    adjust the font size and alignment properties to the same as we did for the **Label**
    element. So, set them to **40** and **MiddleCenter** respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have created the first style, creating the second becomes fast and
    easy. Collapse the **XSquare** style.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the size of the **Custom Styles** attribute to **2**. When increasing the
    size of arrays in the Unity Editor, Unity duplicates whatever was the last item
    in the array to each of the new slots. So, we should now have two `XSquare` GUI
    Styles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the second GUI Style and change its name to `Osquare`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, replace the `XNormal` **Background** image with the `ONormal` image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are having trouble in dragging-and-dropping in the **Inspector** window,
    the `GameSkin` keeps losing focus perhaps; there is a lock at the top of the **Inspector**
    window. Clicking on that will stop the window from changing to anything else when
    a new object is selected. Clicking it again will toggle off this feature.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Just because we have our spiffy new custom GUI Styles, doesn't mean they will
    work automatically. But, just a little bit of coding will make them work. Inside
    our `DrawGameBoard` function of the `TicTacToeControl` script, we need to change
    the line that draws our label by adding a little bit to the end of it. The addition
    of a second string will tell the GUI system to look for a specific GUI Style.
    A little bit earlier in the function, we figure out who owns the square, is it
    X or O. By adding this to `Square` we create the names of our two custom GUI Styles,
    `XSquare` and `OSquare`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you play the game now, you will see that when a player claims control of
    a square, our custom styles appear.![Time for action – styling the game](img/2014OT_02_08.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is one more thing to do to change the look of our Tic-tac-toe game. Do
    you remember the title image that was created and for which we added a variable?
    Now is the time to place that. Inside of `TicTacToeControl` go to the `DrawOpening`
    function. To draw our image, we need to replace the call to `GUI.Label` with a
    call to `GUI.DrawTexture`. Instead of using GUI Styles, this function simply draws
    an image to the screen. It uses a `Rect` class, just as with all of our **Buttons**
    and **Labels**, to define a size and position. The image is, by default, stretched
    to fill the whole `Rect` class. For now, this suits us just fine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can fix the stretching by updating the previous line of code, where we defined
    the `Rect` class for our title to accommodate. As you can see by the following
    code snippet, we use the width and height of `titleImage` to determine the width
    and height of `titleRect`. The `Rect` class now automatically determines how large
    it should be based on the size of our title image. If the `Rect` class is of the
    same size and shape as the image, it won't be stretched. In addition to that,
    because of the way we defined the `Rect` class for our **New Game** button, it
    will still be directly under and just as wide as our title image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That is all there for styling our Tic-tac-toe game. Click on the **Play** button
    and take a look at all your hard work.![Time for action – styling the game](img/2014OT_02_09.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We made our Tic-tac-toe game look great, or at least not like the defaults.
    We achieved this through the use of a handful of images and some custom GUI Skins
    and GUI Styles. With the addition of a special function for drawing textures on
    screen, we also add a unique title image to our opening screen.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – backgrounds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your challenge here is to make a background image and draw it behind the game.
    It also has to cover the whole of the screen. The default blue is great, but we
    could do so much better. As a note, whichever GUI element was drawn last is drawn
    on top, so think carefully about where to call the function to have the image
    drawn in the background. Also, since stretching is only good for exercising and
    rubber bands, take a look at also passing the function a `ScaleMode`, which is
    a special value type that Unity uses to determine how images should stretch. Look
    in the scripting reference or search online to find more information about it.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic positioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are probably thinking that it is all well and good that the game is all
    styled now, but everything is still sitting in the top-left corner of the screen.
    Well then, you are in luck. That is exactly the topic of this section. It is not
    enough to simply adjust the numbers in our `Rects` until our GUI is centered.
    While working with the Android platform and other mobile devices, we have to be
    prepared for a large variety of possibilities. Not every device that our games
    will be played on will have the same screen size. So, you may position your GUI
    to be centered on your tablet, but it will be far off screen on a phone.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – the dynamic GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be covering two excellent ways of dynamically adjusting our GUI to meet
    any screen requirements. The opening screen and the game over screen will both
    be centered. We will stretch the game board to fill the available space. The turn
    indicator text will also be set up to automatically change position based on the
    screen orientation.
  prefs: []
  type: TYPE_NORMAL
- en: Again, let's start with our main menu. Open up the `TicTacToeControl` script
    and go to the `DrawOpening` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To center the menu, we will wrap up the contents as a GUI group by adding the
    following line of code at the beginning of the `DrawOpening` function. Think of
    GUI's grouping as **picture-in-picture** (**PIP**) that some televisions can do.
    Pick a rectangle section on screen and draw some other channel in it. So, first
    we are deciding where to draw our group. We do this by finding the center of the
    screen, `Screen.width` and `Screen.height` is divided by two. But, because GUI
    content is positioned at the top-left corner, we must subtract half our content's
    size to find that corner. For the width, that is simply the width of our title
    image. But the height is a combination of the image and the button below.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `BeginGroup` function of the GUI is what gives us the PIP effect. Any GUI
    elements that are drawn after a call to this function are confined to the `Rect`
    class that was passed to the function. Instead of positions starting from the
    top-left corner of the screen, elements within the group will start at the top-left
    corner of the group `Rect`. Anything that extends beyond the edges of the group
    is also not drawn, just as if it extended beyond the edges of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Before we can see the group in action, we must add a line to the end of our
    `DrawOpening` function. `EndGroup` is the direct counterpart to `BeginGroup`.
    If ever you use `BeginGroup`, there must be a corresponding call to `EndGroup`.
    Should you fail to pair up the function calls, Unity will make no end of complaints
    until the problem is fixed. It is really quite annoying.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that line added, play the game. The main menu will now center itself. It
    will do this no matter the screen size. Also, it will do this whether the screen
    is in landscape or in portrait mode. In this case, the trick to keeping everything
    on screen is to plan for the smallest screen size and make images and GUI elements
    that fit accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Skipping ahead a little, we can use a similar method for centering the game
    over screen. Add the following line of code to the beginning of the `DrawGameOver`
    function. You can see that we are doing the same thing we did a moment ago. Figure
    out where the center of the screen is and subtract half of the total size of our
    content. In this case we supplied solid numbers instead of keying off the size
    of an image. Also, because the math is easy, we already did the divisions to come
    up with `150` and `75`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Be sure to add your `EndGroup` function call to the end of the `DrawGameOver`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After that, find the line where we define the `winnerRect variable` class. We
    need to change it so it is easier to adjust the size and fit the contents, should
    we want to. Because of the way we set up the **winner** label and **main menu**
    button, this will cause each to take up the whole width of the group. They will
    also split the available height evenly; hence the division is by two.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we have the tricky part to do. For the game board, we want it to expand
    evenly so that it fills whichever direction is shortest. The turn indicator should
    be centered in the remaining space. Because the board needs to dynamically expand
    and the turn indicator needs to be either in the right or bottom of the screen,
    based on orientation, we can't get away with using our GUI group functions. Instead,
    we first need to figure out which side of our screen is smaller, the width or
    the height. This is fairly simple with the following lines of code added to the
    beginning of the `DrawGameBoard` function. Recognize the conditional statement,
    our good old friend? First, we create a variable to hold the result of comparing
    the width and height of the screen; we will be using it again later. If the width
    is smaller, obviously the small side is the width; otherwise it is the height.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next we change our width and height definitions. Because the game board is a
    3 x 3 grid, once we have the small side it is a simple matter to figure out how
    big the squares should be to fill the space. The change to the height is to keep
    the board squares actually square. Perhaps you remember from your first geometry
    lessons? The width and height of the sides of a square are equal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Playing the game at this point, we will be able to experience a game board that
    scales with our game screen. Try it out!![Time for action – the dynamic GUI](img/2014OT_02_10.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember when we were connecting Unity Remote? Use the drop-down menu in the
    top-left corner of the **Game** window to select different screen sizes and orientations.
    This does, however, reveal another small error. The turn indicator text sometimes
    appears over the top of our game board. Other times it may be beyond the edges
    of the screen. Or, perhaps you already noticed that one? Either way, to make it
    better we need to find the `Rect` class that will cover the remaining negative
    space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the initial definition of our `turnRect`, add the following code snippet.
    Using our conditional friends, we figured out all we need to place the `Rect`
    class in the negative space. If the width is smaller in portrait mode, the negative
    space starts at the left side of the screen, zero. The y position of the space
    begins where the board ends, the equivalent of the width; it is a square board,
    after all. The total width of the negative space is also equivalent to the width
    of the screen. The height becomes whatever is left over from the difference between
    the height and the width. If we are in landscape mode instead, the height being
    smaller than the width, the positioning is largely determined in the same way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is all well and good. Looks pretty good with the turn text actually positioned
    where it can easily be seen and read. But, in some of those screen sizes there
    is an awful lot of empty space. If only there was some way we could scale the
    text to better fit the space. It just so happens that there is a good way to do
    just that. After we are done messing with the turn indicator's `Rect`, we can
    add the following line of code. This touch of code gets the label GUI Style from
    the current GUI Skin and creates a duplicate. In code, if we ever create a new
    GUI Style and pass another one as the argument, all of the values are copied into
    the new GUI Style. This allows us to cause temporary and dynamic changes without
    ruining the whole GUI Skin being used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the next line of code we'll adjust the font size. To do this we have to figure
    out how much space is left on the long side of the screen after the game board
    is scaled up. Adding the width and height of the screen results in the total amount
    of screen distance available. By subtracting the smaller of the two sides, the
    distance that the game board covers multiplied by two, we are left with the excess
    negative space. Dividing all of that by one hundred, the amount of space that
    we had previously used for our turn indicator, will scale the font size to proportionately
    fit the change in space. It is finally wrapped in an explicit conversion to the
    integer type because the font size value must be defined as an integer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To actually see this dynamic font size in action, we need to make a change to
    the line that draws the turn indicator. We change the call to the `Label` function
    to use the temporary style. Instead of providing the name of the GUI Style to
    GUI functions, we can provide a specific GUI Style. The function will then use
    this style to draw the GUI element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Try it out. By clicking on the **Game window** tab and dragging it into the
    **Game** window, you can undock the window and make it free floating. Changing
    the aspect ratio, that drop-down menu in the top-right corner of the **Game**
    window, to **Free Aspect** allows us to freely re-size the window and witness
    our great work in action.![Time for action – the dynamic GUI](img/2014OT_02_11.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We made our game change dynamically based on the screen of our devices. Both
    of the menu screens will center themselves. We also caused our game board to grow
    and shrink until it fills as much of the screen as it can. We then used a carefully
    applied bit of code magic to make the turn indicator automatically position itself
    and change font size to fill the remaining space.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – scaling menus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second challenge is a little tougher. Continue to use the GUI groups, but
    make the opening screen and the game over screen scale with the screen size. If
    you want a subchallenge with this one, see what you can do about scaling the text
    with it as well. And, don't forget about the text used to indicate control of
    the game board squares.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to prepare for even more devices, change the Rects that we use throughout
    the section. Wherever we used specific numbers for position or size on screen,
    change them to percent. You will have to calculate the pixel size using percent
    and the size of the screen. That calculated amount can then be passed to and used
    in our Rects.
  prefs: []
  type: TYPE_NORMAL
- en: A better way to build to device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now for the part of the build process that everyone itches to learn. There is
    a quicker and easier way to have your game built and playing on your Android device.
    The long and complicated way is still very good to know. Should this shorter method
    fail, and it will at some point, it is helpful to know the long method so you
    can debug any errors. Also, the short path is only good for building to a single
    device. If you have multiple devices and a large project, it will take significantly
    more time to load them all with the short path.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – build and run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With this alternate build method, we can quickly and easily test games on our
    devices as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by opening the **Build Settings** window. Remember, it can be found under
    **File** at the top of the Unity Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Add Current** button to add our current scene, also the only
    scene, to the list of **Scenes In Build**. If this list is empty, there is no
    game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Be sure to change your **Platform** to **Android**, if you haven't already done
    so. It is after all still the point of this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do not forget to set the **Player Settings**. Click on the **Player Settings**
    button to open them up in the **Inspector** window. Do you remember this from
    [Chapter 1](ch01.html "Chapter 1. Saying Hello to Unity and Android"), *Saying
    Hello to Unity and Android*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top, set the **Company Name** and **Product Name** fields. Values of
    `TomPacktAndBegin` and `Ch2 TicTacToe` respectively will match the included completed
    project. Remember, these are seen by the people playing your game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Bundle Identifier** field under **Other Settings** needs to be set as
    well. The format is still `com.CompanyName.ProductName`, so `com.TomPactAndBegin.Ch2.TicTacToe`
    will work well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So that we can see our cool dynamic GUI in action on a device, there is one
    other setting that should be changed. Click on **Resolution** and **Presentation**
    to expand the options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are interested in **Default Orientation**. The default is **Portrait**, but
    this option means the game will be fixed in the portrait display mode. Click on
    the drop-down menu and select **Auto Rotation**. This option tells Unity to automatically
    adjust the game to be upright in whichever orientation the device is being held.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new set of options that popped up when **Auto Rotation** was selected allow
    for the limiting of the orientations that are supported. Perhaps you are making
    a game that needs to be wider and held in landscape orientation. By unchecking
    **Portrait** and **Portrait Upside Down**, Unity will still adjust (but only for
    the remaining orientations). On your Android device, along one of the shorter
    sides, are the controls of some sort usually a home, menu, back, and search set
    of buttons. This side is generally recognized as the bottom of the device and
    it is the position of these buttons that dictates what each orientation is. **Portrait**
    is when those buttons are down relative to the screen. **Landscape Right** is
    when they are to the right. The pattern begins to come clear, does it not?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For now, leave all of the orientation options checked and we will go back to
    **Build Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step (and this is very important) is to connect your device to your
    computer and give it a moment to be recognized. If your device is not first connected
    to your computer, this shorter build path will fail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the bottom-right corner of the **Build Settings** window, click on the **Build
    And Run** button. You will be asked to give the application file, the APK, a relevant
    name and save it to an appropriate location. A name `Ch2_TicTacToe.apk` will be
    fine and it is suitable enough to save the file to the desktop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Save** and sit back to watch the wonderful loading bar that is provided.
    If you paid attention to the loading bar when we built the *Hello World* project
    in [Chapter 1](ch01.html "Chapter 1. Saying Hello to Unity and Android"), *Saying
    Hello to Unity and Android*, you will notice that there is an extra step taken
    this time around. After the application is built, there is a pushing to device
    step. This means the build was successful and Unity is now putting the application
    on your device and installing it. Once done, the game will be started on the device
    and the loading bar will be finished.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just learned about the **Build And Run** button provided by the **Build Settings**
    window. Quick, easy, and free from command prompt pain; isn't the short build
    path wonderful? But if the build process fails for any reason including being
    unable to find the device, the application file will not be saved. You will have
    to sit through the entire build process again, if you want to try installing again.
    This isn't so bad for our simple Tic-tac-toe game, but might consume a lot of
    time for a larger project. Also, you can only have one Android device connected
    to your computer while building. Any more and the build process is a guaranteed
    failure. Unity also doesn't check for multiple devices until after it has gone
    through the rest of the potentially long build process.
  prefs: []
  type: TYPE_NORMAL
- en: Other than those words of caution, the **Build And Run** option is really quite
    nice. Let Unity handle the hard part of getting the game to your device. This
    gives us much more time to focus on testing and making a great game.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – single player mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a tough one. Create a single player mode. You will have to start by
    adding an extra game state. Is the choice of `MultiPlayer` for a game state starting
    to make sense? The opening screen is going to need an extra button for selecting
    the second game mode. Also, any logic for the computer player should go in the
    `Update` function that is provided by the `MonoBehaviour` class. The computer
    needs to take its turn before we check for victory in `LateUpdate`. The `Update`
    function is just the place to do it. Also, take a look at `Random.Range` for randomly
    selecting a square to take control of. Or, you could do a little more work and
    make the computer search for a square where it can win or create a line of two
    matches.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you should be familiar with Unity's GUI system including GUI
    Skins, GUI Styles, and a variety of GUI functions.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learned all about the GUI by creating a Tic-tac-toe game.
    We first became familiar with drawing buttons and the like to the GUI. After delving
    into the depths and gaining understanding of GUI Styles and GUI Skins, we applied
    the knowledge to make our game look even better. The game continued to improve
    when we added some dynamic positioning to our GUI elements. The opening and closing
    screens became centered, while the game board dynamically scaled to fill the screen.
    Finally, we explored an alternative build method for putting our game onto devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will be starting a new and more complex game. The Tank
    Battle game that we will be creating will be used to gain understanding with the
    basic building blocks of any game: meshes, materials, and animations. When all
    is done, we will be able to drive a tank around a colorful city and shoot animated
    targets.'
  prefs: []
  type: TYPE_NORMAL
