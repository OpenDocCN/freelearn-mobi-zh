- en: Chapter 10. Gameplay Scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've come a long way in the past few chapters and have created a great deal
    of our game, but we still need to do a bit of work to implement some of our gameplay
    concepts. In this chapter we'll explore some of the gameplay scripts needed to
    implement the play mechanics of our game.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter we shall learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to add a particle system to our imported models to simulate a weapon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use animation to drive events in the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to handle ragdoll physics on our character and enemies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to keep score and trigger events based on gameplay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these basics we'll have the core of an actual game's play mechanics completed
    and all we'll need to do is add this to the world the characters live in.
  prefs: []
  type: TYPE_NORMAL
- en: Gunplay as gameplay
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As our game is a shooter, one of the primary gameplay mechanics we need to provide
    is a mechanism through which guns can fire projectiles and hit other objects in
    the world. While there are many ways to accomplish gunfire in the game such as
    simulating the gunfire or creating game objects that represent projectiles, the
    more efficient mechanism to represent gunfire is a particle system. By attaching
    a particle system to our gun object, we can easily draw a representation of projectiles
    being fired at objects in the game world.
  prefs: []
  type: TYPE_NORMAL
- en: Particle Systems in Unity support physics, collision, and memory management
    in a way that is particularly efficient for mobile devices. The only issue to
    watch for is that the fill rate (the rate at which the screen can be filled or
    drawn) for mobile devices is not as high as that of their desktop cousins. Similarly,
    if you perform actions such that the engine must redraw certain areas of the screen
    repetitively, you will see the same fill-rate issues. So if you have a lot of
    particles that are taking up large sections of the screen, you will likely have
    a performance issue. We will discuss this in much greater detail during the optimization
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Readying the weapon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this example we will create a new project called gun range so that we can
    easily test our gameplay without having to build and deploy the entire project.
    Whenever you are making a large play mechanic change to your game, it is often
    useful to do this in isolation so that you can be more agile in your development.
    Large projects can get cluttered pretty quickly so it''s best to test in simple
    projects:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project called **GunRange**. Save the scene in the project as **level_0**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import a static gun model and put it in a hierarchy group called **Weapons**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next we need to ensure that the weapon is pointed along the Z-axis. We accomplish
    this by rotating the model so that the business end (that is, the end our projectiles
    will come out of) is pointed along the positive Z-axis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action — Readying the weapon](img/978-1-84969-040-9_10_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we will attach this entire weapon and its gunfire particle system to the
    character as a prefab, we want to make sure that we define everything at this
    point relative to the coordinate system of the prefab. This is so that when it
    is attached to our character, or other object, it behaves properly.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just imported a gun model to our scene and aligned it to the Z-axis. We did
    this relative to the prefabs, coordinate system and not specifically to the game's
    coordinate system. We did this because we want projectiles being fired along the
    prefabs Z-axis regardless of what else is going on in the world's coordinate system.
  prefs: []
  type: TYPE_NORMAL
- en: It doesn't really matter which axis you align the weapon to (so long as you
    adjust your model and scripts), but it makes logical sense to align the weapon
    so that it is pointed down the Z-axis so that when we fire projectiles they are
    going down the positive Z. Why? In the traditional orientation for 3d graphics,
    movement along the positive Z-axis represents things moving away from the camera
    — so it makes sense to use that here.
  prefs: []
  type: TYPE_NORMAL
- en: Firing projectiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have two approaches that we can use to add a particle system to our weapon.
    We can either add it directly to our gun's Game Object or we can add a child Game
    Object to the gun that does the actual emitting. The approach you choose really
    depends on how much flexibility you need versus your desire to have more objects
    in the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: If you add the particle system directly to the gun's Game Object, the particles
    will be emitted from the center of the Game Object and that would not be visually
    correct. The more universal case is to create a Game Object that will serve as
    the emission point and attach that to a point on the weapon. This is the approach
    we will use for our project.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Adding a particle system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create an empty game object from the **GameObject** menu and select **Create
    Empty**.![Time for action — Adding a particle system](img/978-1-84969-040-9_10_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name this game object **MuzzlePoint**.![Time for action — Adding a particle
    system](img/978-1-84969-040-9_10_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **MuzzlePoint** game object in the **Hierarchy** view to bring up
    the components associated with it.![Time for action — Adding a particle system](img/978-1-84969-040-9_10_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Component** menu select **Ellipsoid Particle Emitter** so that it has
    a particle system associated with it.![Time for action — Adding a particle system](img/978-1-84969-040-9_10_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position the **MuzzlePoint** game object on your gun model in Unity to designate
    where the projectiles should be emitted.![Time for action — Adding a particle
    system](img/978-1-84969-040-9_10_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next thing we need to do is have our particle emitter actually emit particles.
    Since we set up our weapon so that it was pointing down the Z-axis, it is pretty
    easy to configure our particle system so that it will send the particles down
    the positive Z-axis as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember that since we've made this particle emitter a child of our gun, we
    want to make sure that the coordinate system we define for it is relative to the
    origin of the gun model. You will need to adjust it from the gun model's origin
    to position it properly on the gun, but realize that the coordinate system for
    the **MuzzlePoint** is relative to that of the gun.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action — Adding a particle system](img/978-1-84969-040-9_10_23.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Since we've made this a child of our gun model, we want to configure it to be
    at the gun models, origin. You may have to adjust this for your particular model,
    but you should make sure you start at the gun model's origin.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we are creating a particle system that represents bullets, we want to
    have all of our projectiles moving along the same axis. To accomplish this with
    an **Ellipsoid Particle Emitter**, we change the Ellipsoid for the emitter to
    only emit particles along one axis, the Z-axis in this case. If we didn't do this,
    we would have particles that would spray along random axes.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action — Adding a particle system](img/978-1-84969-040-9_10_19.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Finally, we need to add a simple script, call it Gunfire, to our **MuzzlePoint**
    game object that is tied to the fire button of our gun and we're done.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Import the soldier model into our scene as done previously.![Time for action
    — Adding a particle system](img/978-1-84969-040-9_10_21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adjust the gun in the soldier's hierarchy such that it is a child of the hand
    so that the soldier is carrying the item and will move in sync with the player
    as they move.![Time for action — Adding a particle system](img/978-1-84969-040-9_10_22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the **Gunfire** script adding a `GUI.Button` to simulate our fire button
    in the real game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the game and press the fire button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just gave our weapon the ability to fire particles that represent bullets.
    We have also attached that weapon to our normal player so that it is an integral
    part of our player and will move as the player animates in the scene. We now have
    one of the fundamental building blocks for a game that involves shooting as a
    primary play mechanic.
  prefs: []
  type: TYPE_NORMAL
- en: Currently our particles have a default appearance, but if we want to change
    that appearance we can simply add a Particle Renderer component to this **MuzzlePoint**
    game object. We can then change the appearance of the particles by providing our
    own texture that is representative of what our bullets will look like.
  prefs: []
  type: TYPE_NORMAL
- en: Let the animation drive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There will often be times where there is a lot of contextual information in
    the animation data that has been given to us by our animators. In our case we
    have an animation where our character will go through a throwing animation to
    represent throwing a grenade, but currently we have no way of actually putting
    a game object into the world that will respond to this. One certainly wouldn't
    want to hard code the frame of animation that the throw represents, as this is
    likely to change throughout the course of the game. We can, fortunately, associate
    any arbitrary part of an animation with a callback in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Animation Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Unity's animation system we have the ability to associate events with arbitrary
    parts of an animation. Unity refers to this capability as Animation Events. With
    an Animation Event we can have the animation system execute scripts and consequently
    drive some of the logic of the game. Animation Events can be added to any Animation
    Clip that you have imported from your modeling environment or any ad hoc animation
    you create using the **Animation** view.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Adding animation events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To add an event to our soldier's animation, select the character and examine
    the **Animation** view.![Time for action — Adding animation events](img/978-1-84969-040-9_10_9.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Above the animation data are two tracks — the top-most track shows all of the
    events added for this animation. The bottom track shows all of the defined key
    frames for our animation data.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Time for action — Adding animation events](img/978-1-84969-040-9_10_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Create a C# script called `GrenadeToss` and make it a child of our soldier object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the `Start()` and `Update()` methods in the class and create a method
    called `TossIt` in the class and add a log statement to it. The `Start()` and
    `Update()` methods are not necessary for our purposes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, scroll through the animation in the **Animation** view until you get to
    the point in the animation where you want to have the throw take place.![Time
    for action — Adding animation events](img/978-1-84969-040-9_10_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Animation Event by clicking on the **Add Animation Event** button.
    You can also accomplish this task by clicking on the event track above the animation
    data. An **Edit Animation Event** dialog will appear that will allow you to configure
    the script function that will be called when that event is reached.![Time for
    action — Adding animation events](img/978-1-84969-040-9_10_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the list box and you will see a list of all of the functions that can be
    called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `TossIt()` function.![Time for action — Adding animation events](img/978-1-84969-040-9_10_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the play button for the animation. If everything is successful, you will
    see the log message printed out when that frame of animation is reached.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a folder called `Grenade` in the `Weapons` folder of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Prefab object called **Grenade** as a simple sphere, stretched
    in one dimension.![Time for action — Adding animation events](img/978-1-84969-040-9_10_24.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the object that we will create when the character reaches the animation
    position for `TossIt().`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Update our `GrenadeToss` script to instantiate a game object when the player
    reaches the `TossIt()` function of our script. Since we want this object to be
    simulated by the physics system, we want to create it as a **Rigidbody**. Accomplish
    this by selecting the Grenade object from the hierarchy and add a **Rigidbody**
    to it.![Time for action — Adding animation events](img/978-1-84969-040-9_10_25.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now every Grenade object we instantiate will be simulated by the physics system.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We also want to instantiate this grenade at the location of the hand when we
    reach this point in the animation. Since all of the parts of our soldier model
    are named, we can use the Transform of that object after we look it up from the
    hierarchy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just added some realism to our game and provided some flexibility to
    our artists. By importing our animation data and then associating an event with
    it we have created a path to drive gameplay behavior entirely based on the scripts.
    We can expand this further by allowing the artists to model weapons behavior in
    animations and as the modeled bullets are ejected from the gun, we can update
    our ammo counter such that it and the animation are in perfect sync.
  prefs: []
  type: TYPE_NORMAL
- en: Further, we have provided functionality for the player to create a new game
    object on demand and put it in the game world, driven by the physics engine.
  prefs: []
  type: TYPE_NORMAL
- en: You are already dead
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a player that can fire a gun, we need to have the projectiles
    fired from that gun to collide with enemies and for those enemies to take damage
    when hit and be destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish this we will add a Particle Collider to our gun system and add
    a damage script to our enemies so they can respond to being hit by projectiles.
  prefs: []
  type: TYPE_NORMAL
- en: World Particle Colliders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The World Particle Collider is what is used to detect collisions between particles
    and other colliders in a scene. The other colliders in the scene can be any one
    of the normal spheres, boxes, capsules, and wheel or mesh colliders that Unity
    can assign to a game object.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Detecting collisions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Import the Target Dummy model from the project assets folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To ensure that your game objects have collision data, be sure to check the **Generate
    Colliders** setting in the Import Settings for your mesh.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In many cases, however, it is less costly and reasonably accurate to use a simple
    sphere or box collider for your enemies. If you want to do location specific damage,
    this is one of the cheaper ways to accomplish the effect on mobile devices.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action — Detecting collisions](img/978-1-84969-040-9_10_2.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Now that we have collision data for our target game objects, we need to add
    a particle collider to the particle system we created earlier. We do this by selecting
    the component in the **Component | Particles** | **World Particle Collider** menu.![Time
    for action — Detecting collisions](img/978-1-84969-040-9_10_3.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By itself this will result in particles colliding with other objects, but what
    we really want is for the game objects to be notified when the collision happens
    so we can have our target react to being hit.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To do this we select the **Send Collision Message** in the **World Particle
    Collider** so that each particle game object and the game object involved in the
    collision receive a collision message.![Time for action — Detecting collisions](img/978-1-84969-040-9_10_4.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can look for this event in scripts that we attach to any object we want to
    receive collision events from the particle system.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a script called `Damage` and attach the collision script to the Test
    Dummy objects that will process the damage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Update the `OnParticleCollision()` method to update the health of the object
    that has been hit by the particle. When the health of that item reaches zero,
    remove the test dummy from the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here we are going to have our Damage script communicate with a `HealthScript`
    , which will define the health of our target dummy objects and remove them when
    they have run out of health.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach the `HealthScript` to the target dummies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here we will simply remove the game object after it has taken enough damage
    by telling the game object that this script is attached to to destroy itself.
    If we wanted this object to explode or take some other behavior we could Instantiate
    an explosion prefab at this game object's location when we destroy the original
    object.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have now handled the other part of our gameplay. The player can fire a weapon,
    the projectiles will be emitted using a particle system and when the particles
    come into contact with another object the damage can be calculated and this object
    removed from the game.
  prefs: []
  type: TYPE_NORMAL
- en: Playing with (rag) dolls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point we have simply removed enemies from the game when they have
    taken damage from our weapons. However, we want the enemies to respond realistically
    to damage from weapons based on the physics properties of the damage. In particular,
    when a grenade impacts an enemy, the force of the blast — something that is not
    currently simulated at all, should toss them around.
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish this we will use Unity's Rag Doll system and assign it to our
    target dummies, so that when they take damage, physics will drive their motion.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Attaching a rag doll
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new scene in the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a ground plane and texture it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the target dummy model into the scene.![Time for action — Attaching a
    rag doll](img/978-1-84969-040-9_10_5.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Ragdoll by selecting **GameObject | Create Other | Ragdoll**![Time
    for action — Attaching a rag doll](img/978-1-84969-040-9_10_6.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next we need to map the skeleton of our target dummy model to the bone hierarchy
    of the rag doll. Unity makes this simple by providing a Ragdoll wizard with which
    we can perform the mapping between the two bone hierarchies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the circle to the right of the Ragdoll item to bring up a list of transforms
    that you can connect it to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop the **soldier (Transform)** onto the **Root** of the item in the
    list for the Ragdoll nodes that are to be mapped.![Time for action — Attaching
    a rag doll](img/978-1-84969-040-9_10_7.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the root of the Soldier model in the **Hierarchy** view so you can see
    the Ragdoll mapped onto the geometry of the soldier.![Time for action — Attaching
    a rag doll](img/978-1-84969-040-9_10_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Examine the scene by pressing the **Play** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will note that the physics system has simulated the various forces on the
    rag doll and it has collapsed, as gravity is the only force on the dummy and there
    is nothing preventing it from falling to the ground plane.
  prefs: []
  type: TYPE_NORMAL
- en: This brings up the first problem that we have to solve — we need our model to
    be rigid until we want it to be impacted by the world of physics. We can accomplish
    this by either turning off physics until the character is in a state where it
    should not be in control of its actions, such as in the case of an explosion,
    or we need to attach the character to some other system that prevents it from
    slumping over.
  prefs: []
  type: TYPE_NORMAL
- en: We have attached rag dolls and rigid body physics systems to our enemies so
    that they can animate properly when hit affected by the physics of explosions
    and other in-world physics simulations. When we turn on the rag dolls, Unity uses
    physics, as opposed to our animation data, to determine what happens to the character.
    This results in a more realistic reflection of the world.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we walked through all of the basic requirements for gameplay
    in our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we covered:'
  prefs: []
  type: TYPE_NORMAL
- en: How to equip a character with weapons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to have the character move through the animations of firing the weapons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to display the projectiles using a particle system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to have the weapons impact enemies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create weapons that have Rigid Body physics and how to assign Rag Dolls
    to objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a better understanding of gameplay scripting knowledge under
    our belt, it's time to look at how to optimize our game for optimal performance
    on the target device. While the scripts provided will work on any platform, as
    we'll see in the next chapter, there are some particular tricks to making them
    perform optimally on the iOS platform.
  prefs: []
  type: TYPE_NORMAL
