- en: Chapter 10. Gameplay Scripting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 游戏脚本
- en: We've come a long way in the past few chapters and have created a great deal
    of our game, but we still need to do a bit of work to implement some of our gameplay
    concepts. In this chapter we'll explore some of the gameplay scripts needed to
    implement the play mechanics of our game.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在过去的几章中，我们已经走了很长的路，并创建了我们游戏的大部分内容，但我们仍然需要做一些工作来实现一些游戏玩法概念。在本章中，我们将探讨实现我们游戏玩法机制所需的一些游戏脚本。
- en: 'In this chapter we shall learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习：
- en: How to add a particle system to our imported models to simulate a weapon
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将粒子系统添加到导入的模型中，以模拟武器
- en: How to use animation to drive events in the game
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用动画来驱动游戏中的事件
- en: How to handle ragdoll physics on our character and enemies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理角色和敌人上的ragdoll物理
- en: How to keep score and trigger events based on gameplay
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何根据游戏玩法来记分和触发事件
- en: With these basics we'll have the core of an actual game's play mechanics completed
    and all we'll need to do is add this to the world the characters live in.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些基础知识的基础上，我们将完成一个实际游戏玩法机制的核心，我们只需要将其添加到角色所在的世界中。
- en: Gunplay as gameplay
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枪战作为游戏玩法
- en: As our game is a shooter, one of the primary gameplay mechanics we need to provide
    is a mechanism through which guns can fire projectiles and hit other objects in
    the world. While there are many ways to accomplish gunfire in the game such as
    simulating the gunfire or creating game objects that represent projectiles, the
    more efficient mechanism to represent gunfire is a particle system. By attaching
    a particle system to our gun object, we can easily draw a representation of projectiles
    being fired at objects in the game world.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的游戏是射击游戏，我们需要提供的主要游戏玩法机制之一是枪械可以发射弹丸并击中世界中的其他物体。虽然游戏中实现枪声的方法有很多，例如模拟枪声或创建代表弹丸的游戏对象，但表示枪声的更有效机制是粒子系统。通过将粒子系统附加到我们的枪械对象上，我们可以轻松地绘制出在游戏世界中向物体发射的弹丸的表示。
- en: Particle Systems in Unity support physics, collision, and memory management
    in a way that is particularly efficient for mobile devices. The only issue to
    watch for is that the fill rate (the rate at which the screen can be filled or
    drawn) for mobile devices is not as high as that of their desktop cousins. Similarly,
    if you perform actions such that the engine must redraw certain areas of the screen
    repetitively, you will see the same fill-rate issues. So if you have a lot of
    particles that are taking up large sections of the screen, you will likely have
    a performance issue. We will discuss this in much greater detail during the optimization
    chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中的粒子系统支持物理、碰撞和内存管理，这在移动设备上尤其高效。唯一需要注意的问题是，移动设备的填充率（屏幕被填充或绘制的速率）并不像它们的桌面版本那么高。同样，如果你执行的动作使得引擎必须重复绘制屏幕的某些区域，你将看到相同的填充率问题。所以，如果你有很多占据屏幕大块区域的粒子，你可能会遇到性能问题。我们将在优化章节中详细讨论这个问题。
- en: Time for action — Readying the weapon
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 — 准备武器
- en: 'For this example we will create a new project called gun range so that we can
    easily test our gameplay without having to build and deploy the entire project.
    Whenever you are making a large play mechanic change to your game, it is often
    useful to do this in isolation so that you can be more agile in your development.
    Large projects can get cluttered pretty quickly so it''s best to test in simple
    projects:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将创建一个名为枪场的项目，这样我们就可以轻松测试我们的游戏玩法，而无需构建和部署整个项目。每次你对游戏进行大的玩法机制更改时，通常都有必要单独进行，这样你就可以在开发中更加敏捷。大型项目可能会很快变得杂乱无章，因此最好在简单的项目中测试：
- en: Create a new project called **GunRange**. Save the scene in the project as **level_0**.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**GunRange**的新项目。将场景保存在项目中，命名为**level_0**。
- en: Import a static gun model and put it in a hierarchy group called **Weapons**.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入一个静态枪械模型并将其放入名为**武器**的层级组中。
- en: Next we need to ensure that the weapon is pointed along the Z-axis. We accomplish
    this by rotating the model so that the business end (that is, the end our projectiles
    will come out of) is pointed along the positive Z-axis.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保武器指向Z轴。我们通过旋转模型来实现这一点，使得枪口（即，我们的弹丸将从中出来的那一端）指向正Z轴。
- en: '![Time for action — Readying the weapon](img/978-1-84969-040-9_10_1.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 — 准备武器](img/978-1-84969-040-9_10_1.jpg)'
- en: As we will attach this entire weapon and its gunfire particle system to the
    character as a prefab, we want to make sure that we define everything at this
    point relative to the coordinate system of the prefab. This is so that when it
    is attached to our character, or other object, it behaves properly.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将把这个整个武器及其枪火粒子系统作为一个预制件附加到角色上，我们想要确保在这个点上定义一切相对于预制件的坐标系。这样做是为了当它附加到我们的角色或其他对象上时，它能正常工作。
- en: What just happened?
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We just imported a gun model to our scene and aligned it to the Z-axis. We did
    this relative to the prefabs, coordinate system and not specifically to the game's
    coordinate system. We did this because we want projectiles being fired along the
    prefabs Z-axis regardless of what else is going on in the world's coordinate system.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚将一个枪模型导入到场景中，并将其与Z轴对齐。我们这样做是相对于预制件坐标系，而不是具体到游戏坐标系。我们这样做是因为我们希望发射的子弹沿着预制件的Z轴发射，而不管世界坐标系中发生什么。
- en: It doesn't really matter which axis you align the weapon to (so long as you
    adjust your model and scripts), but it makes logical sense to align the weapon
    so that it is pointed down the Z-axis so that when we fire projectiles they are
    going down the positive Z. Why? In the traditional orientation for 3d graphics,
    movement along the positive Z-axis represents things moving away from the camera
    — so it makes sense to use that here.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你将武器对齐到哪个轴实际上并不重要（只要调整你的模型和脚本），但将武器对齐到指向Z轴是有逻辑意义的，这样当我们发射子弹时，它们就会沿着正Z轴向下。为什么？在传统的3D图形方向中，沿着正Z轴的运动表示物体远离相机——所以在这里使用它是合理的。
- en: Firing projectiles
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发射子弹
- en: We have two approaches that we can use to add a particle system to our weapon.
    We can either add it directly to our gun's Game Object or we can add a child Game
    Object to the gun that does the actual emitting. The approach you choose really
    depends on how much flexibility you need versus your desire to have more objects
    in the hierarchy.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用两种方法将粒子系统添加到我们的武器上。我们可以直接将粒子系统添加到枪的Game Object中，或者我们可以添加一个子Game Object到枪上，该子Game
    Object执行实际的发射。你选择的方法实际上取决于你需要多少灵活性，以及你希望层次结构中有更多对象的需求。
- en: If you add the particle system directly to the gun's Game Object, the particles
    will be emitted from the center of the Game Object and that would not be visually
    correct. The more universal case is to create a Game Object that will serve as
    the emission point and attach that to a point on the weapon. This is the approach
    we will use for our project.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你直接将粒子系统添加到枪的Game Object中，粒子将从Game Object的中心发射，这在视觉上是不正确的。更通用的做法是创建一个将作为发射点的Game
    Object，并将其附加到武器上的一个点上。这是我们项目将采用的方法。
- en: Time for action — Adding a particle system
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作时间 — 添加粒子系统
- en: Create an empty game object from the **GameObject** menu and select **Create
    Empty**.![Time for action — Adding a particle system](img/978-1-84969-040-9_10_15.jpg)
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**GameObject**菜单创建一个空的游戏对象，并选择**Create Empty**。![动作时间 — 添加粒子系统](img/978-1-84969-040-9_10_15.jpg)
- en: Name this game object **MuzzlePoint**.![Time for action — Adding a particle
    system](img/978-1-84969-040-9_10_16.jpg)
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个游戏对象命名为**MuzzlePoint**。![动作时间 — 添加粒子系统](img/978-1-84969-040-9_10_16.jpg)
- en: Select the **MuzzlePoint** game object in the **Hierarchy** view to bring up
    the components associated with it.![Time for action — Adding a particle system](img/978-1-84969-040-9_10_18.jpg)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Hierarchy**视图中选择**MuzzlePoint**游戏对象，以显示与其关联的组件。![动作时间 — 添加粒子系统](img/978-1-84969-040-9_10_18.jpg)
- en: In the **Component** menu select **Ellipsoid Particle Emitter** so that it has
    a particle system associated with it.![Time for action — Adding a particle system](img/978-1-84969-040-9_10_17.jpg)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Component**菜单中选择**Ellipsoid Particle Emitter**，以便它关联一个粒子系统。![动作时间 — 添加粒子系统](img/978-1-84969-040-9_10_17.jpg)
- en: Position the **MuzzlePoint** game object on your gun model in Unity to designate
    where the projectiles should be emitted.![Time for action — Adding a particle
    system](img/978-1-84969-040-9_10_18.jpg)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity中将**MuzzlePoint**游戏对象放置在枪模型上，以指定子弹应该发射的位置。![动作时间 — 添加粒子系统](img/978-1-84969-040-9_10_18.jpg)
- en: The next thing we need to do is have our particle emitter actually emit particles.
    Since we set up our weapon so that it was pointing down the Z-axis, it is pretty
    easy to configure our particle system so that it will send the particles down
    the positive Z-axis as well.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们需要做的是让我们的粒子发射器实际发射粒子。由于我们设置了武器使其指向Z轴，因此配置我们的粒子系统使其将粒子发送到正Z轴是非常容易的。
- en: Remember that since we've made this particle emitter a child of our gun, we
    want to make sure that the coordinate system we define for it is relative to the
    origin of the gun model. You will need to adjust it from the gun model's origin
    to position it properly on the gun, but realize that the coordinate system for
    the **MuzzlePoint** is relative to that of the gun.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，由于我们已经将这个粒子发射器设置为枪的子节点，我们想要确保为它定义的坐标系相对于枪模型的原点。您可能需要从枪模型的原点进行调整以正确定位它，但请意识到**MuzzlePoint**的坐标系是相对于枪的坐标系。
- en: '![Time for action — Adding a particle system](img/978-1-84969-040-9_10_23.jpg)'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![添加粒子系统的时机](img/978-1-84969-040-9_10_23.jpg)'
- en: Since we've made this a child of our gun model, we want to configure it to be
    at the gun models, origin. You may have to adjust this for your particular model,
    but you should make sure you start at the gun model's origin.
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们已经将其设置为枪模型的子节点，我们希望将其配置为与枪模型的原点对齐。你可能需要根据你的特定模型进行调整，但你应该确保从枪模型的原点开始。
- en: Since we are creating a particle system that represents bullets, we want to
    have all of our projectiles moving along the same axis. To accomplish this with
    an **Ellipsoid Particle Emitter**, we change the Ellipsoid for the emitter to
    only emit particles along one axis, the Z-axis in this case. If we didn't do this,
    we would have particles that would spray along random axes.
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们正在创建一个代表子弹的粒子系统，我们希望所有的弹丸都沿着相同的轴线移动。为了使用**椭球体粒子发射器**实现这一点，我们将发射器的椭球体改为只沿一个轴线发射粒子，在这种情况下是Z轴线。如果我们不这样做，粒子就会沿着随机的轴线喷洒。
- en: '![Time for action — Adding a particle system](img/978-1-84969-040-9_10_19.jpg)'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![添加粒子系统的时机](img/978-1-84969-040-9_10_19.jpg)'
- en: Finally, we need to add a simple script, call it Gunfire, to our **MuzzlePoint**
    game object that is tied to the fire button of our gun and we're done.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要向我们的**MuzzlePoint**游戏对象添加一个简单的脚本，命名为“枪声”，它与枪的射击按钮相关联，这样我们就完成了。
- en: '[PRE0]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Import the soldier model into our scene as done previously.![Time for action
    — Adding a particle system](img/978-1-84969-040-9_10_21.jpg)
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，将士兵模型导入我们的场景中。![添加粒子系统的时机](img/978-1-84969-040-9_10_21.jpg)
- en: Adjust the gun in the soldier's hierarchy such that it is a child of the hand
    so that the soldier is carrying the item and will move in sync with the player
    as they move.![Time for action — Adding a particle system](img/978-1-84969-040-9_10_22.jpg)
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在士兵的层级结构中调整枪的位置，使其成为手的子节点，这样士兵就能携带物品，并且会随着玩家的移动而同步移动。![添加粒子系统的时机](img/978-1-84969-040-9_10_22.jpg)
- en: Update the **Gunfire** script adding a `GUI.Button` to simulate our fire button
    in the real game.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新**枪声**脚本，添加一个`GUI.Button`来模拟真实游戏中的射击按钮。
- en: '[PRE1]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Run the game and press the fire button.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏并按下射击按钮。
- en: What just happened?
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We just gave our weapon the ability to fire particles that represent bullets.
    We have also attached that weapon to our normal player so that it is an integral
    part of our player and will move as the player animates in the scene. We now have
    one of the fundamental building blocks for a game that involves shooting as a
    primary play mechanic.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚赋予了我们的武器发射代表子弹的粒子的能力。我们还将其附加到我们的普通玩家上，使其成为玩家不可分割的一部分，并且会随着玩家在场景中的动画移动。我们现在拥有了涉及射击作为主要游戏机制的游戏的基本构建块之一。
- en: Currently our particles have a default appearance, but if we want to change
    that appearance we can simply add a Particle Renderer component to this **MuzzlePoint**
    game object. We can then change the appearance of the particles by providing our
    own texture that is representative of what our bullets will look like.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们的粒子具有默认的外观，但如果我们想改变外观，我们只需简单地将一个粒子渲染器组件添加到这个**MuzzlePoint**游戏对象中。然后我们可以通过提供代表子弹外观的纹理来改变粒子的外观。
- en: Let the animation drive
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让动画驱动
- en: There will often be times where there is a lot of contextual information in
    the animation data that has been given to us by our animators. In our case we
    have an animation where our character will go through a throwing animation to
    represent throwing a grenade, but currently we have no way of actually putting
    a game object into the world that will respond to this. One certainly wouldn't
    want to hard code the frame of animation that the throw represents, as this is
    likely to change throughout the course of the game. We can, fortunately, associate
    any arbitrary part of an animation with a callback in Unity.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 经常会有很多上下文信息包含在我们动画师给出的动画数据中。在我们的例子中，我们有一个动画，我们的角色将执行一个抛掷动画来表示抛掷手榴弹，但目前我们还没有将游戏对象放入世界中的方法来响应这个动作。当然，没有人希望硬编码表示抛掷的动画帧，因为这很可能会在整个游戏过程中发生变化。幸运的是，我们可以将动画的任意部分与Unity中的回调关联起来。
- en: Animation Events
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画事件
- en: In Unity's animation system we have the ability to associate events with arbitrary
    parts of an animation. Unity refers to this capability as Animation Events. With
    an Animation Event we can have the animation system execute scripts and consequently
    drive some of the logic of the game. Animation Events can be added to any Animation
    Clip that you have imported from your modeling environment or any ad hoc animation
    you create using the **Animation** view.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity的动画系统中，我们有能力将事件与动画的任意部分关联起来。Unity将这种能力称为动画事件。通过动画事件，我们可以让动画系统执行脚本，从而驱动游戏的一些逻辑。动画事件可以添加到从你的建模环境导入的任何动画剪辑，或者使用**动画**视图创建的任何临时动画。
- en: Time for action — Adding animation events
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行动作 — 添加动画事件
- en: To add an event to our soldier's animation, select the character and examine
    the **Animation** view.![Time for action — Adding animation events](img/978-1-84969-040-9_10_9.jpg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将事件添加到我们的士兵动画中，选择角色并检查**动画**视图。![执行动作 — 添加动画事件](img/978-1-84969-040-9_10_9.jpg)
- en: Above the animation data are two tracks — the top-most track shows all of the
    events added for this animation. The bottom track shows all of the defined key
    frames for our animation data.
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在动画数据上方有两个轨道——最上面的轨道显示为这个动画添加的所有事件。下面的轨道显示为我们的动画数据定义的所有关键帧。
- en: '![Time for action — Adding animation events](img/978-1-84969-040-9_10_10.jpg)'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![执行动作 — 添加动画事件](img/978-1-84969-040-9_10_10.jpg)'
- en: Create a C# script called `GrenadeToss` and make it a child of our soldier object.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`GrenadeToss`的C#脚本，并将其作为我们的士兵对象的子对象。
- en: Delete the `Start()` and `Update()` methods in the class and create a method
    called `TossIt` in the class and add a log statement to it. The `Start()` and
    `Update()` methods are not necessary for our purposes.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中删除`Start()`和`Update()`方法，并创建一个名为`TossIt`的方法，并在其中添加一个日志语句。对于我们的目的来说，`Start()`和`Update()`方法是不必要的。
- en: '[PRE2]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, scroll through the animation in the **Animation** view until you get to
    the point in the animation where you want to have the throw take place.![Time
    for action — Adding animation events](img/978-1-84969-040-9_10_12.jpg)
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在**动画**视图中滚动动画，直到你到达动画中你想抛掷发生的点。![执行动作 — 添加动画事件](img/978-1-84969-040-9_10_12.jpg)
- en: Create a new Animation Event by clicking on the **Add Animation Event** button.
    You can also accomplish this task by clicking on the event track above the animation
    data. An **Edit Animation Event** dialog will appear that will allow you to configure
    the script function that will be called when that event is reached.![Time for
    action — Adding animation events](img/978-1-84969-040-9_10_14.jpg)
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**添加动画事件**按钮创建一个新的动画事件。你还可以通过点击动画数据上方的事件轨道来完成此任务。一个**编辑动画事件**对话框将出现，允许你配置当达到该事件时将被调用的脚本函数。![执行动作
    — 添加动画事件](img/978-1-84969-040-9_10_14.jpg)
- en: Open the list box and you will see a list of all of the functions that can be
    called.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开列表框，你会看到所有可以调用的函数列表。
- en: Select the `TossIt()` function.![Time for action — Adding animation events](img/978-1-84969-040-9_10_13.jpg)
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`TossIt()`函数。![执行动作 — 添加动画事件](img/978-1-84969-040-9_10_13.jpg)
- en: Press the play button for the animation. If everything is successful, you will
    see the log message printed out when that frame of animation is reached.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下动画的播放按钮。如果一切顺利，当达到该帧时，你会看到打印出的日志消息。
- en: Create a folder called `Grenade` in the `Weapons` folder of the project.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的`Weapons`文件夹中创建一个名为`Grenade`的文件夹。
- en: Create a new Prefab object called **Grenade** as a simple sphere, stretched
    in one dimension.![Time for action — Adding animation events](img/978-1-84969-040-9_10_24.jpg)
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Prefab 对象，命名为 **Grenade**，作为一个一维拉伸的简单球体。![动作时间 — 添加动画事件](img/978-1-84969-040-9_10_24.jpg)
- en: This is the object that we will create when the character reaches the animation
    position for `TossIt().`
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是我们将在角色达到 `TossIt()` 动画位置时创建的对象。
- en: Update our `GrenadeToss` script to instantiate a game object when the player
    reaches the `TossIt()` function of our script. Since we want this object to be
    simulated by the physics system, we want to create it as a **Rigidbody**. Accomplish
    this by selecting the Grenade object from the hierarchy and add a **Rigidbody**
    to it.![Time for action — Adding animation events](img/978-1-84969-040-9_10_25.jpg)
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新我们的 `GrenadeToss` 脚本，当玩家达到脚本中的 `TossIt()` 函数时实例化一个游戏对象。由于我们希望这个对象由物理系统模拟，我们希望将其创建为
    **Rigidbody**。通过从层次结构中选择 Grenade 对象并为其添加一个 **Rigidbody** 来实现这一点。![动作时间 — 添加动画事件](img/978-1-84969-040-9_10_25.jpg)
- en: Now every Grenade object we instantiate will be simulated by the physics system.
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在每次实例化的 Grenade 对象都将由物理系统进行模拟。
- en: We also want to instantiate this grenade at the location of the hand when we
    reach this point in the animation. Since all of the parts of our soldier model
    are named, we can use the Transform of that object after we look it up from the
    hierarchy.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还希望在这个动画达到这一点时在手的当前位置实例化这个手榴弹。由于我们的士兵模型的所有部分都被命名了，我们可以在从层次结构中查找它之后使用该对象的 Transform。
- en: '[PRE3]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What just happened?
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We have just added some realism to our game and provided some flexibility to
    our artists. By importing our animation data and then associating an event with
    it we have created a path to drive gameplay behavior entirely based on the scripts.
    We can expand this further by allowing the artists to model weapons behavior in
    animations and as the modeled bullets are ejected from the gun, we can update
    our ammo counter such that it and the animation are in perfect sync.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚为我们的游戏增加了一些现实感，并为我们的艺术家提供了一些灵活性。通过导入我们的动画数据并将其与事件关联，我们创建了一个完全基于脚本的驱动游戏行为的路径。我们可以通过允许艺术家在动画中建模武器行为来进一步扩展这一点，当建模的子弹从枪中射出时，我们可以更新我们的弹药计数器，使其与动画完美同步。
- en: Further, we have provided functionality for the player to create a new game
    object on demand and put it in the game world, driven by the physics engine.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还提供了功能，允许玩家根据需要创建一个新的游戏对象并将其放入游戏世界，由物理引擎驱动。
- en: You are already dead
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你已经死了
- en: Now that we have a player that can fire a gun, we need to have the projectiles
    fired from that gun to collide with enemies and for those enemies to take damage
    when hit and be destroyed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可以开枪的玩家，我们需要确保从那把枪发射的投射物能够与敌人碰撞，并且当敌人被击中时受到伤害并被摧毁。
- en: To accomplish this we will add a Particle Collider to our gun system and add
    a damage script to our enemies so they can respond to being hit by projectiles.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将向我们的枪系统添加一个粒子碰撞器，并给我们的敌人添加一个伤害脚本，以便它们能够对被投射物击中做出反应。
- en: World Particle Colliders
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 世界粒子碰撞器
- en: The World Particle Collider is what is used to detect collisions between particles
    and other colliders in a scene. The other colliders in the scene can be any one
    of the normal spheres, boxes, capsules, and wheel or mesh colliders that Unity
    can assign to a game object.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 世界粒子碰撞器用于检测场景中粒子与其他碰撞器之间的碰撞。场景中的其他碰撞器可以是 Unity 可以分配给游戏对象的任何正常球体、盒子、胶囊、轮子或网格碰撞器。
- en: Time for action — Detecting collisions
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作时间 — 检测碰撞
- en: Import the Target Dummy model from the project assets folder.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目资源文件夹中导入 Target Dummy 模型。
- en: To ensure that your game objects have collision data, be sure to check the **Generate
    Colliders** setting in the Import Settings for your mesh.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保你的游戏对象具有碰撞数据，请确保检查你的网格的导入设置中的 **Generate Colliders** 设置。
- en: Note
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In many cases, however, it is less costly and reasonably accurate to use a simple
    sphere or box collider for your enemies. If you want to do location specific damage,
    this is one of the cheaper ways to accomplish the effect on mobile devices.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，在许多情况下，使用简单的球体或盒子碰撞器来模拟敌人更节省成本且相当准确。如果你想在特定位置造成伤害，这是在移动设备上实现该效果的一种更经济的方式。
- en: '![Time for action — Detecting collisions](img/978-1-84969-040-9_10_2.jpg)'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![动作时间 — 检测碰撞](img/978-1-84969-040-9_10_2.jpg)'
- en: Now that we have collision data for our target game objects, we need to add
    a particle collider to the particle system we created earlier. We do this by selecting
    the component in the **Component | Particles** | **World Particle Collider** menu.![Time
    for action — Detecting collisions](img/978-1-84969-040-9_10_3.jpg)
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经有了目标游戏对象的碰撞数据，我们需要将粒子系统中的粒子碰撞器添加到我们之前创建的粒子系统中。我们通过选择**组件 | 粒子** | **世界粒子碰撞器**菜单中的组件来完成此操作。![行动时间
    — 检测碰撞](img/978-1-84969-040-9_10_3.jpg)
- en: By itself this will result in particles colliding with other objects, but what
    we really want is for the game objects to be notified when the collision happens
    so we can have our target react to being hit.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅凭这一点，会导致粒子与其他对象发生碰撞，但我们的真正目的是在碰撞发生时通知游戏对象，以便我们的目标能够对被击中做出反应。
- en: To do this we select the **Send Collision Message** in the **World Particle
    Collider** so that each particle game object and the game object involved in the
    collision receive a collision message.![Time for action — Detecting collisions](img/978-1-84969-040-9_10_4.jpg)
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要做到这一点，我们在**世界粒子碰撞器**中选择**发送碰撞消息**，以便每个粒子游戏对象和参与碰撞的游戏对象都能接收到碰撞消息。![行动时间 — 检测碰撞](img/978-1-84969-040-9_10_4.jpg)
- en: We can look for this event in scripts that we attach to any object we want to
    receive collision events from the particle system.
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在我们想要从粒子系统接收碰撞事件的对象附加的脚本中查找此事件。
- en: Create a script called `Damage` and attach the collision script to the Test
    Dummy objects that will process the damage.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Damage`的脚本，并将碰撞脚本附加到将处理伤害的Test Dummy对象上。
- en: '[PRE4]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Update the `OnParticleCollision()` method to update the health of the object
    that has been hit by the particle. When the health of that item reaches zero,
    remove the test dummy from the game.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`OnParticleCollision()`方法以更新被粒子击中的对象的健康状态。当该物品的健康值达到零时，从游戏中移除测试假人。
- en: '[PRE5]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here we are going to have our Damage script communicate with a `HealthScript`
    , which will define the health of our target dummy objects and remove them when
    they have run out of health.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们将让我们的Damage脚本与`HealthScript`通信，该脚本将定义我们的目标假人对象的健康状态，并在它们耗尽健康时移除它们。
- en: Attach the `HealthScript` to the target dummies.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`HealthScript`附加到目标假人上。
- en: '[PRE6]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here we will simply remove the game object after it has taken enough damage
    by telling the game object that this script is attached to to destroy itself.
    If we wanted this object to explode or take some other behavior we could Instantiate
    an explosion prefab at this game object's location when we destroy the original
    object.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将简单地通过告诉附加了此脚本的游戏对象销毁自己来移除游戏对象，以便在它受到足够伤害后。如果我们想让这个对象爆炸或采取其他行为，我们可以在销毁原始对象时在游戏对象的位置实例化一个爆炸预制体。
- en: What just happened?
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We have now handled the other part of our gameplay. The player can fire a weapon,
    the projectiles will be emitted using a particle system and when the particles
    come into contact with another object the damage can be calculated and this object
    removed from the game.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经处理了游戏玩法中的另一部分。玩家可以开火，弹体将通过粒子系统发射，当粒子接触到另一个对象时，可以计算伤害并将此对象从游戏中移除。
- en: Playing with (rag) dolls
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩（布）娃娃
- en: Up to this point we have simply removed enemies from the game when they have
    taken damage from our weapons. However, we want the enemies to respond realistically
    to damage from weapons based on the physics properties of the damage. In particular,
    when a grenade impacts an enemy, the force of the blast — something that is not
    currently simulated at all, should toss them around.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是在我们的武器造成伤害时从游戏中移除敌人。然而，我们希望敌人能够根据伤害的物理属性对武器造成的伤害做出逼真的反应。特别是，当手榴弹击中敌人时，爆炸的力量——目前根本未进行模拟，应该将它们抛来抛去。
- en: To accomplish this we will use Unity's Rag Doll system and assign it to our
    target dummies, so that when they take damage, physics will drive their motion.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将使用Unity的Rag Doll系统并将其分配给我们的目标假人，这样当它们受到伤害时，物理将驱动它们的运动。
- en: Time for action — Attaching a rag doll
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 — 添加布娃娃
- en: Create a new scene in the project.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中创建一个新的场景。
- en: Create a ground plane and texture it.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个地面平面并为其添加纹理。
- en: Import the target dummy model into the scene.![Time for action — Attaching a
    rag doll](img/978-1-84969-040-9_10_5.jpg)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将目标假人模型导入场景。![行动时间 — 添加布娃娃](img/978-1-84969-040-9_10_5.jpg)
- en: Create a Ragdoll by selecting **GameObject | Create Other | Ragdoll**![Time
    for action — Attaching a rag doll](img/978-1-84969-040-9_10_6.jpg)
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择**GameObject | 创建其他 | Ragdoll**来创建一个Ragdoll![操作时间 — 添加rag doll](img/978-1-84969-040-9_10_6.jpg)
- en: Next we need to map the skeleton of our target dummy model to the bone hierarchy
    of the rag doll. Unity makes this simple by providing a Ragdoll wizard with which
    we can perform the mapping between the two bone hierarchies.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将我们的目标假人模型的骨骼映射到rag doll的骨骼层级。Unity通过提供一个rag doll向导来简化这个过程，我们可以使用它来在两个骨骼层级之间进行映射。
- en: Select the circle to the right of the Ragdoll item to bring up a list of transforms
    that you can connect it to.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Ragdoll项目右侧的圆圈，以显示可以连接到它的变换列表。
- en: Drag and drop the **soldier (Transform)** onto the **Root** of the item in the
    list for the Ragdoll nodes that are to be mapped.![Time for action — Attaching
    a rag doll](img/978-1-84969-040-9_10_7.jpg)
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**soldier (Transform)**拖放到列表中要映射的Ragdoll节点项的**根**上。![操作时间 — 添加rag doll](img/978-1-84969-040-9_10_7.jpg)
- en: Select the root of the Soldier model in the **Hierarchy** view so you can see
    the Ragdoll mapped onto the geometry of the soldier.![Time for action — Attaching
    a rag doll](img/978-1-84969-040-9_10_11.jpg)
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层级**视图中选择Soldier模型的根，这样你就可以看到Ragdoll映射到士兵的几何形状上了。![操作时间 — 添加rag doll](img/978-1-84969-040-9_10_11.jpg)
- en: Examine the scene by pressing the **Play** button.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按**播放**按钮来检查场景。
- en: What just happened?
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: You will note that the physics system has simulated the various forces on the
    rag doll and it has collapsed, as gravity is the only force on the dummy and there
    is nothing preventing it from falling to the ground plane.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到物理系统已经模拟了rag doll上的各种力，它已经坍塌了，因为重力是唯一作用在假人上的力，没有任何东西阻止它落到地面平面上。
- en: This brings up the first problem that we have to solve — we need our model to
    be rigid until we want it to be impacted by the world of physics. We can accomplish
    this by either turning off physics until the character is in a state where it
    should not be in control of its actions, such as in the case of an explosion,
    or we need to attach the character to some other system that prevents it from
    slumping over.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了我们必须解决的第一个问题——我们需要我们的模型在想要它受到物理世界影响之前保持刚性。我们可以通过关闭物理直到角色处于不应该控制其动作的状态，例如在爆炸的情况下，或者我们需要将角色连接到某个其他系统，以防止它倒下。
- en: We have attached rag dolls and rigid body physics systems to our enemies so
    that they can animate properly when hit affected by the physics of explosions
    and other in-world physics simulations. When we turn on the rag dolls, Unity uses
    physics, as opposed to our animation data, to determine what happens to the character.
    This results in a more realistic reflection of the world.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将rag doll和刚体物理系统附加到我们的敌人身上，这样它们在受到爆炸和其他世界内物理模拟的影响时可以正确地动画化。当我们打开rag doll时，Unity使用物理而不是我们的动画数据来确定角色的状态。这导致了对世界的更真实反映。
- en: Summary
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we walked through all of the basic requirements for gameplay
    in our game.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了游戏中游戏玩法的基本要求。
- en: 'Specifically, we covered:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了：
- en: How to equip a character with weapons
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为角色配备武器
- en: How to have the character move through the animations of firing the weapons
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何让角色在开火动画中移动
- en: How to display the projectiles using a particle system
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用粒子系统显示投射物
- en: How to have the weapons impact enemies
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何让武器对敌人造成影响
- en: How to create weapons that have Rigid Body physics and how to assign Rag Dolls
    to objects.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建具有刚体物理的武器以及如何将Rag Doll分配给对象。
- en: Now that we have a better understanding of gameplay scripting knowledge under
    our belt, it's time to look at how to optimize our game for optimal performance
    on the target device. While the scripts provided will work on any platform, as
    we'll see in the next chapter, there are some particular tricks to making them
    perform optimally on the iOS platform.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对游戏玩法脚本知识有了更好的理解，是时候看看如何优化我们的游戏，以便在目标设备上获得最佳性能了。虽然提供的脚本可以在任何平台上运行，正如我们将在下一章中看到的，有一些特定的技巧可以使它们在iOS平台上表现最佳。
