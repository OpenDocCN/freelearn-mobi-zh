["```swift\n//Shaders.metal\n//(1)\n#include <metal_stdlib>\nusing namespace metal;\n//(2)\nvertex float4 basic_vertex(                           \n//(3)\n  const device packed_float3* vertex_array [[ buffer(0) ]], \n//(4)\n  unsigned int vertexID [[ vertex_id ]]) {       \n//(5)          \n  return float4(vertex_array[vertexID], 1.0);              \n}\n//(6)\nfragment half4 basic_fragment() { \n  return half4(1.0);  \n```", "```swift\nimport Metal\nimport QuartzCore\n```", "```swift\n    let device: MTLDevice = MTLCreateSystemDefaultDevice()\n    ```", "```swift\n    let metalLayer = CAMetalLayer()\n    ```", "```swift\n    /*Simple Vertex Data object, an array of floats that draws a simple triangle to the screen */\n    let vertexData:[Float] = [\n      0.0, 1.0, 0.0,\n      -1.0, -1.0, 0.0,\n      1.0, -1.0, 0.0]\n    ```", "```swift\n    //Library objects that reference our shaders we created\n    let library = device.newDefaultLibrary()!\n    //constant where we pass the vertex shader function\n    let vertexFunction = library.newFunctionWithName(\"basic_vertex\")\n    //now the fragment shader \n    let fragmentFunction = library.newFunctionWithName(\"basic_fragment\")\n\n    /*Describes the Render Pipeline and sets the vertex and fragment shaders of the Render Pipeine*/\n    let pipelineStateDescriptor = MTLRenderPipelineDescriptor()\n    //initiates the descriptor's vertex and fragment shader function properties with the constants we created prior\n    pipelineStateDescriptor.vertexFunction = vertexFunction\n    pipelineStateDescriptor.fragmentFunction = fragmentFunction\n\n    //Makes the pixel format an 8bit color format\n    pipelineStateDescriptor.colorAttachments.objectAtIndexedSubscript(0).\n    pixelFormat = .BGRA8Unorm\n\n    /*Checks if we described the Render Pipeline correctly, otherwise, throws an error. */\n    var pipelineError : NSError?\n    pipelineState = device.newRenderPipelineStateWithDescriptor(pipelineStateDescriptor, error: &pipelineError)\n    if pipelineState == nil {\n      println(\"Pipeline state not created, error \\(pipelineError)\")\n    ```", "```swift\n    var commandQueue = device.newCommandQueue()\n    ```", "```swift\n    var timer = CADisplayLink(target: self, selector: Selector(\"gameRenderLoop\"))\n    timer.addToRunLoop(NSRunLoop.mainRunLoop(), forMode: NSDefaultRunLoopMode)\n    ```", "```swift\n    func gameRenderloop() {\n      autoreleasepool {\n        self.render()\n      }\n    ```", "```swift\n    let passDescriptor = MTLRenderPassDescriptor() \n    passDescriptor.colorAttachments[0].texture = drawable.texture\n    passDescriptor.colorAttachments[0].loadAction = .Clear\n    passDescriptor.colorAttachments[0].storeAction = .Store\n    passDescriptor.colorAttachments[0].clearColor = MTLClearColorMake(0.8, 0.0, 0.0, 1.0)\n    ```", "```swift\n    let commandBuffer = commandQueue.commandBuffer()\n    ```", "```swift\n    let renderEncoderOpt = commandBuffer.renderCommandEncoderWithDescriptor(renderPassDescriptor)\n    if let renderEncoder = renderEncoderOpt {\n      renderEncoder.setRenderPipelineState(pipelineState)\n      renderEncoder.setVertexBuffer(vertexBuffer, offset: 0, atIndex: 0)\n      renderEncoder.drawPrimitives(.Triangle, vertexStart: 0, vertexCount: 3, instanceCount: 1)\n      renderEncoder.endEncoding()\n    }\n    ```", "```swift\n    commandBuffer.presentDrawable(drawable) \n    commandBuffer.commit()\n    ```"]