<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Sprites, Camera, Actions!</h1></div></div></div><p>Drawing with SpriteKit is a breeze. We are free to focus on building great gameplay experiences while SpriteKit performs the mechanical work of the<a id="id45" class="indexterm"/> <strong>game loop</strong>. To draw an item to the screen, we create a new instance of a SpriteKit node. These nodes are simple; we attach a child node to our scene, or to existing nodes, for each item we want to draw. Sprites, particle emitters, and text labels are all considered nodes in SpriteKit.</p><div><div><h3 class="title"><a id="note07"/>Note</h3><p>The game loop is a common game design pattern used to constantly update the game many times per second, and to maintain the same gameplay speed on fast or slow hardware.</p><p>SpriteKit wires new nodes into the game loop automatically. As you gain expertise with SpriteKit, you may wish to explore the game loop further to understand what is going on "under the hood".</p></div></div><p>The topics in this chapter include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Preparing your project</li><li class="listitem" style="list-style-type: disc">Drawing your first sprite</li><li class="listitem" style="list-style-type: disc">Animation: movement, scaling, and rotation</li><li class="listitem" style="list-style-type: disc">Working with textures</li><li class="listitem" style="list-style-type: disc">Organizing art into texture atlases</li><li class="listitem" style="list-style-type: disc">Centering the camera on a sprite</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Sharpening our pencils</h1></div></div></div><p>There are four <a id="id46" class="indexterm"/>quick items to take care of before we start drawing:</p><div><ol class="orderedlist arabic"><li class="listitem">Since we will design our game to use landscape screen orientations, we will disable the <a id="id47" class="indexterm"/>portrait view altogether:<div><ol class="orderedlist arabic"><li class="listitem">With your game project open in Xcode, select the overall project folder in the project navigator (the top-most item).</li><li class="listitem">You will see your project settings in the main frame of Xcode. Under <strong>Deployment Info</strong>, find the <strong>Device Orientation</strong> section.</li><li class="listitem">Uncheck the <strong>Portrait</strong> option, as shown in the following screenshot:<div><img src="img/Image_B04532_02_01.jpg" alt="Sharpening our pencils"/></div></li></ol></div></li><li class="listitem">The SpriteKit template generates a visual layout file for arranging sprites in our scene. We will not need it; we will use the SpriteKit visual editor later when we explore level design. To delete this extra file:<div><ol class="orderedlist arabic"><li class="listitem">Right-click on <code class="literal">GameScene.sks</code> in the project navigator and choose <strong>delete</strong>.</li><li class="listitem">Choose <strong>Move to Trash</strong> in the dialog window.</li></ol></div></li><li class="listitem">We need to resize our scene to fit the new landscape view. Follow these steps to resize the scene:<div><ol class="orderedlist arabic"><li class="listitem">Open <code class="literal">GameViewController.swift</code> from the project navigator and locate the <code class="literal">viewDidLoad</code> function inside the <code class="literal">GameViewController</code> class. The <code class="literal">viewDidLoad</code> function is going to fire before the game realizes it is in landscape view, so we need to use a function that fires later in the startup process. Delete <code class="literal">viewDidLoad</code> completely, removing all of its code.</li><li class="listitem">Replace <code class="literal">viewDidLoad</code> with<a id="id48" class="indexterm"/> a new function named <code class="literal">viewWillLayoutSubviews</code>. Do not worry about understanding every line right now; we are just configuring our project. Use this code for <code class="literal">viewWillLayoutSubviews</code>:<div><pre class="programlisting">override func viewWillLayoutSubviews() {
    super.viewWillLayoutSubviews()
    // Create our scene:
    let scene = GameScene()
    // Configure the view:
    let skView = self.view as! SKView
    skView.showsFPS = true
    skView.showsNodeCount = true
    skView.ignoresSiblingOrder = true
    scene.scaleMode = .AspectFill
    // size our scene to fit the view exactly:
    scene.size = view.bounds.size
    // Show the new scene:
    skView.presentScene(scene)
}</pre></div></li><li class="listitem">Lastly, in <code class="literal">GameViewController.swift</code>, find the <code class="literal">supportedInterfaceOrientations</code> function and reduce it to this code:<div><pre class="programlisting">override func supportedInterfaceOrientations() -&gt; Int {
    return Int(
    UIInterfaceOrientationMask.Landscape.rawValue);
}</pre></div><div><div><h3 class="title"><a id="tip03"/>Tip</h3><p>
<strong>Downloading the example code</strong>
</p><p>You can download the example code files from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p><p>Additionally, each chapter provides checkpoint links you can use to download the example project to that point.</p></div></div></li></ol></div></li><li class="listitem">We should double-check that we are ready to move on. Try to run our clean project in the simulator using the toolbar play button or the <em>command</em> + <em>r</em> keyboard shortcut. After loading, the simulator should switch to landscape view with a blank gray background (and with the node and FPS counter in the bottom right). If the project will not run, or you still see "<strong>Hello World</strong>", you will need to retrace your steps from the end of <a class="link" href="ch01.html" title="Chapter 1. Designing Games with Swift">Chapter 1</a>, <em>Designing Games with Swift</em>, to finish your project preparation.</li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Checkpoint 2- A</h1></div></div></div><p>If you want to download my project to this point, you can do so from this URL: <a class="ulink" href="http://www.thinkingswiftly.com/game-development-with-swift/chapter-2">http://www.thinkingswiftly.com/game-development-with-swift/chapter-2</a>
</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Drawing your first sprite</h1></div></div></div><p>It is time to write some <a id="id49" class="indexterm"/>game code – fantastic! Open your <code class="literal">GameScene.swift</code> file and find the <code class="literal">didMoveToView</code> function. Recall that this function fires every time the game switches to this scene. We will use this function to get familiar with the <code class="literal">SKSpriteNode</code> class. You will use <code class="literal">SKSpriteNode</code> extensively in your game, whenever you want to add a new 2D graphic entity.</p><div><div><h3 class="title"><a id="note08"/>Note</h3><p>The term sprite <a id="id50" class="indexterm"/>refers to a 2D graphic or animation that moves around the screen independently from the background. Over time, the term has developed to refer to any game object on the screen in a 2D game. We will create and draw your first sprite in this chapter: a happy little bee.</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec30"/>Building a SKSpriteNode class</h2></div></div></div><p>Let's begin by <a id="id51" class="indexterm"/>drawing a blue square to the screen. The <code class="literal">SKSpriteNode</code> class<a id="id52" class="indexterm"/> can draw both texture graphics and solid blocks of color. It is often helpful to prototype your new game ideas with blocks of color before you spend time with artwork. To draw the blue square, add an instance of <code class="literal">SKSpriteNode</code> to the game:</p><div><pre class="programlisting">override func didMoveToView(view: SKView) {
    // Instantiate a constant, mySprite, instance of SKSpriteNode
    // The SKSpriteNode constructor can set color and size
    // Note: UIColor is a UIKit class with built-in color presets
    // Note: CGSize is a type we use to set node sizes
    let mySprite = SKSpriteNode(color: UIColor.blueColor(), size: 
        CGSize(width: 50, height: 50))
        
    // Assign our sprite a position in points, relative to its 
    // parent node (in this case, the scene)
    mySprite.position = CGPoint(x: 300, y: 300)
        
    // Finally, we need to add our sprite node into the node tree.
    // Call the SKScene's addChild function to add the node
    // Note: In Swift, 'self' is an automatic property
    // on any type instance, exactly equal to the instance itself
    // So in this instance, it refers to the GameScene instance
    self.addChild(mySprite)
}</pre></div><p>Go ahead and<a id="id53" class="indexterm"/> run the project. You should see a similar small blue square appear in your simulator:</p><div><img src="img/Image_B04532_02_02.jpg" alt="Building a SKSpriteNode class"/></div><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>Swift allows you to<a id="id54" class="indexterm"/> define variables as constants, which can be assigned a value only once. For best performance, use <code class="literal">let</code> to declare constants whenever possible. Declare your variables with <code class="literal">var</code> when you need to alter the value later in your code.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec31"/>Adding animation to your Toolkit</h2></div></div></div><p>Before we<a id="id55" class="indexterm"/> dive back in to sprite theory, we should have some fun with our blue square. SpriteKit uses action objects to move sprites around the screen. Consider this example: if our goal is to move the square across the screen, we must first create a new action object to describe the animation. Then, we instruct our sprite node to execute the action. I will illustrate this concept with many examples in the chapter. For now, add this code in the <code class="literal">didMoveToView</code> function, below the <code class="literal">self.addChild(mySprite)</code> line:</p><div><pre class="programlisting">// Create a new constant for our action instance
// Use the moveTo action to provide a goal position for a node
// SpriteKit will tween to the new position over the course of the
// duration, in this case 5 seconds
let demoAction = SKAction.moveTo(CGPoint(x: 100, y: 100), 
    duration: 5)
// Tell our square node to execute the action!
mySprite.runAction(demoAction)</pre></div><p>Run the project. You will see our blue square slide across the screen towards the (100,100) position. This action<a id="id56" class="indexterm"/> is re-usable; any node in your scene can execute this action to move to the (100,100) position. As you can see, SpriteKit does a lot of the heavy lifting for us when we need to animate node properties.</p><div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>Inbetweening, or tweening, uses the engine to animate smoothly between a start frame and an end frame. Our <code class="literal">moveTo</code> animation is a tween; we provide the start frame (the sprite's original position) and the end frame (the new destination position). SpriteKit generates the smooth transition between our values.</p></div></div><p>Let's try some other actions. The <code class="literal">SKAction.moveTo</code> function is only one of many options. Try replacing the <code class="literal">demoAction</code> line with this code:</p><div><pre class="programlisting">let demoAction = SKAction.scaleTo(4, duration: 5)</pre></div><p>Run the project. You will see our blue square grow to four times its original size.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec01"/>Sequencing multiple animations</h3></div></div></div><p>We can execute<a id="id57" class="indexterm"/> actions together simultaneously or one after the each other with action groups and sequences. For instance, we can easily scale our sprite larger and spin it at the same time. Delete all of our action code so far and replace it with this code:</p><div><pre class="programlisting">// Scale up to 4x initial scale
let demoAction1 = SKAction.scaleTo(4, duration: 5)
// Rotate 5 radians
let demoAction2 = SKAction.rotateByAngle(5, duration: 5)
// Group the actions
let actionGroup = SKAction.group([demoAction1, demoAction2])
// Execute the group!
mySprite.runAction(actionGroup)</pre></div><p>When you run the project, you will see a spinning, growing square. Terrific! If you want to run these actions in sequence (rather than at the same time) change <code class="literal">SKAction.group</code> to <code class="literal">SKAction.sequence</code>:</p><div><pre class="programlisting">// Group the actions into a sequence
let actionSequence = <strong>SKAction.sequence</strong>([demoAction1, demoAction2])
        
// Execute the sequence!
mySprite.runAction(actionSequence)</pre></div><p>Run the code and watch as your square first grows and then spins. Good. You are not limited to two actions; we can group or sequence as many actions together as we need.</p><p>We have only used a few actions so far; feel free to explore the <code class="literal">SKAction</code> class and try out different<a id="id58" class="indexterm"/> action combinations before moving on.</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec32"/>Recapping your first sprite</h2></div></div></div><p>Congratulations, you <a id="id59" class="indexterm"/>have learned to draw a non-textured sprite and animate it with SpriteKit actions. Next, we will explore some important positioning concepts, and then add game art to our sprites. Before you move on, make sure your <code class="literal">didMoveToView</code> function matches with mine, and your sequenced animation is firing properly. Here is my code up to this point:</p><div><pre class="programlisting">override func didMoveToView(view: SKView) {
    // Instantiate a constant, mySprite, instance of SKSpriteNode
    let mySprite = SKSpriteNode(color: UIColor.blueColor(), size: 
        CGSize(width: 50, height: 50))
        
    // Assign our sprite a position
    mySprite.position = CGPoint(x: 300, y: 300)
        
    // Add our sprite node into the node tree
    self.addChild(mySprite)
        
    // Scale up to 4x initial scale
    let demoAction1 = SKAction.scaleTo(CGFloat(4), duration: 2)
    // Rotate 5 radians
    let demoAction2 = SKAction.rotateByAngle(5, duration: 2)
        
    // Group the actions into a sequence
    let actionSequence = SKAction.sequence([demoAction1, 
        demoAction2])
        
    // Execute the sequence!
    mySprite.runAction(actionSequence)
}</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>The story on positioning</h1></div></div></div><p>SpriteKit uses a grid of <a id="id60" class="indexterm"/>points to position nodes. In this grid, the bottom left corner of the scene is (0,0), with a positive X-axis to the right and a positive Y-axis to the top.</p><p>Similarly, on the individual sprite level, (0,0) refers to the bottom left corner of the sprite, while (1,1) refers to the top right corner.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec33"/>Alignment with anchor points</h2></div></div></div><p>Each sprite has <a id="id61" class="indexterm"/>an <code class="literal">anchorPoint</code> property, or an origin. The <code class="literal">anchorPoint</code> property<a id="id62" class="indexterm"/> allows you to choose which part of the sprite aligns to the sprite's overall position.</p><div><div><h3 class="title"><a id="note09"/>Note</h3><p>The default anchor point is (0.5,0.5), so a new <code class="literal">SKSpriteNode</code> centers perfectly on its position.</p></div></div><p>To illustrate this, let us examine the blue square sprite we just drew on the screen. Our sprite is 50 pixels wide and 50 pixels tall, and its position is (300,300). Since we have not modified the <code class="literal">anchorPoint</code> property, its anchor point is (0.5,0.5). This means the sprite will be perfectly centered over the (300,300) position on the scene's grid. Our sprite's left edge begins at 275 and the right edge terminates at 325. Likewise, the bottom starts at 275 and the top ends at 325. The following diagram illustrates our block's position on the grid:</p><div><img src="img/Image_B04532_02_03.jpg" alt="Alignment with anchor points"/></div><p>Why do we prefer centered sprites by default? You may think it simpler to position elements by their bottom left corner with an <code class="literal">anchorPoint</code> property setting of (0,0). However, the <a id="id63" class="indexterm"/>centered behavior benefits us when we scale or rotate sprites:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">When we scale a sprite with an <code class="literal">anchorPoint</code> property of (0,0) it will only expand up the y-axis and out the x-axis. Rotation actions will swing the sprite in wide circles around its bottom left corner.</li><li class="listitem" style="list-style-type: disc">A centered sprite, with the default <code class="literal">anchorPoint</code> property of (0.5, 0.5), will expand or <a id="id64" class="indexterm"/>contract equally in all directions when scaled and will spin in place when rotated, which is usually the desired effect.</li></ul></div><p>There are <a id="id65" class="indexterm"/>some cases when you will want to change an anchor point. For instance, if you are drawing a rocket ship, you may want the ship to rotate around the front nose of its cone, rather than its center.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Adding textures and game art</h1></div></div></div><p>You <a id="id66" class="indexterm"/>may want to take a screenshot of your blue box for your own enjoyment later. I absolutely love reminiscing over old screenshots of my finished games when they <a id="id67" class="indexterm"/>were nothing more than simple colored<a id="id68" class="indexterm"/> blocks sliding around the screen. Now it is time to move past that stage and attach some fun artwork to our sprite.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec34"/>Downloading the free assets</h2></div></div></div><p>I am providing a downloadable pack for all of the art assets I <a id="id69" class="indexterm"/>use in this book. I recommend you use these assets so you will have everything you need for our demo game. Alternatively, you are certainly free to create your own art for your game if you prefer.</p><p>These assets come from an outstanding public domain asset pack from Kenney Game Studio. I am providing a small subset of the asset pack that we will use in our game. Download the game art from this URL:</p><p>
<a class="ulink" href="http://www.thinkingswiftly.com/game-development-with-swift/assets">http://www.thinkingswiftly.com/game-development-with-swift/assets</a>
</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec02"/>More exceptional art</h3></div></div></div><p>If <a id="id70" class="indexterm"/>you like the art, you can download over 16,000 game assets in the same style for a small donation at <a class="ulink" href="http://kenney.itch.io/kenney-donation">http://kenney.itch.io/kenney-donation</a>. I do not have an affiliation with Kenney; I just find it admirable that he has released so much public domain artwork for indie game developers.</p><p>As CC0 assets, you can copy, modify, and distribute the art, even for commercial purposes, all without asking permission. You can read the full license here:</p><p>
<a class="ulink" href="https://creativecommons.org/publicdomain/zero/1.0/">https://creativecommons.org/publicdomain/zero/1.0/</a>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec35"/>Drawing your first textured sprite</h2></div></div></div><p>Let us use some of the graphics you just downloaded. We will start by creating a bee sprite. We will add the bee texture to our project, load the image onto a <code class="literal">SKSpriteNode</code> class, and then size the node for optimum sharpness on retina screens.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec03"/>Adding the bee image to your project</h3></div></div></div><p>We need to add the<a id="id71" class="indexterm"/> image files to our Xcode project before we can use them in the game. Once we add the images, we can reference them by name in our code; SpriteKit is smart enough to find and implement the graphics. Follow these steps to add the bee image to the project:</p><div><ol class="orderedlist arabic"><li class="listitem">Right-click on your project in the project navigator and click on <strong>Add Files to "Pierre Penguin Escapes the Antarctic"</strong> (or the name of your game). Refer to this screenshot to find the correct menu item:<div><img src="img/Image_B04532_02_04.jpg" alt="Adding the bee image to your project"/></div></li><li class="listitem">Browse to the asset pack you downloaded and locate the <code class="literal">bee.png</code> image inside the <code class="literal">Enemies</code> folder.</li><li class="listitem">Check <strong>Copy items if needed</strong>, then click <strong>Add</strong>.</li></ol></div><p>You should now see <code class="literal">bee.png</code> in your project navigator.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec04"/>Loading images with SKSpriteNode</h3></div></div></div><p>It is <a id="id72" class="indexterm"/>quite easy to draw images to the screen with <code class="literal">SKSpriteNode</code>. Start by clearing out all of the code we wrote for the blue square inside the <code class="literal">didMoveToView</code> function in <code class="literal">GameScene.swift</code>. Replace <code class="literal">didMoveToView</code> with this code:</p><div><pre class="programlisting">override func didMoveToView(view: SKView) {
    // set the scene's background to a nice sky blue
    // Note: UIColor uses a scale from 0 to 1 for its colors
    self.backgroundColor = UIColor(red: 0.4, green: 0.6, blue: 
        0.95, alpha: 1.0);
        
    // create our bee sprite node
    let bee = SKSpriteNode(imageNamed: "bee.png")
    // size our bee node
    bee.size = CGSize(width: 100, height: 100)
    // position our bee node
    bee.position = CGPoint(x: 250, y: 250)
    // attach our bee to the scene's node tree
    self.addChild(bee)
}</pre></div><p>Run the <a id="id73" class="indexterm"/>project and witness our glorious bee – great work!</p><div><img src="img/Image_B04532_02_05.jpg" alt="Loading images with SKSpriteNode"/></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec05"/>Designing for retina</h3></div></div></div><p>You may<a id="id74" class="indexterm"/> notice that our bee image is quite blurry. To take advantage of retina screens, assets need to be twice the pixel dimensions of their node's size property (for most retina screens), or three times the node size for the iPhone 6 Plus. Ignore the height for a moment; our bee node is 100 points wide but the PNG file is only 56 pixels wide. The PNG file needs to be 300 pixels wide to look sharp on the iPhone 6 Plus, or 200 pixels wide to look sharp on 2x retina devices.</p><p>SpriteKit will <a id="id75" class="indexterm"/>automatically resize textures to fit their nodes, so one approach is to create a giant texture at the highest retina resolution (three times the node size) and let SpriteKit resize the texture down for lower density screens. However, there is a considerable performance penalty, and older devices can even run out of memory and crash from the huge textures.</p><div><div><div><div><h4 class="title"><a id="ch02lvl4sec01"/>The ideal asset approach</h4></div></div></div><p>These <a id="id76" class="indexterm"/>double- and triple-sized retina assets can be confusing to new iOS developers. To solve this issue, Xcode normally lets you provide three image files for each texture. For example, our bee node is currently 100 points wide and 100 points tall. In a perfect world, you would provide the following images to Xcode:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Bee.png</code> (100 pixels by 100 pixels)</li><li class="listitem" style="list-style-type: disc"><code class="literal">Bee@2x.png</code> (200 pixels by 200 pixels)</li><li class="listitem" style="list-style-type: disc"><code class="literal">Bee@3x.png</code> (300 pixels by 300 pixels)</li></ul></div><p>However, there is currently an issue that prevents 3x textures from working correctly with <a id="id77" class="indexterm"/>
<strong>texture atlases</strong>. Texture atlases group textures together and increase rendering performance dramatically (we will implement our first texture atlas in the next section). I hope that Apple will upgrade texture atlases to support 3x textures in Swift 2. For now, we need to choose between texture atlases and 3x assets for the iPhone 6 Plus.</p></div><div><div><div><div><h4 class="title"><a id="ch02lvl4sec02"/>My solution for now</h4></div></div></div><p>In my opinion, texture atlases <a id="id78" class="indexterm"/>and their performance benefits are key features of SpriteKit. I will continue using texture atlases, thus serving 2x images to the iPhone 6 Plus (which still looks fairly sharp). This means that we will not be using any 3x assets in this book.</p><p>Further simplifying matters, Swift only runs on iOS7 and higher. The only non-retina devices that run iOS7 are the aging iPad 2 and iPad mini 1st generation. If these older devices are important for your finished games, you should create both standard and 2x images for your games. Otherwise, you can safely ignore non-retina assets with Swift.</p><div><div><h3 class="title"><a id="note10"/>Note</h3><p>This means that we will only use double-sized images in this book. The images in the downloadable asset bundle forgo the 2x suffix, since we are only using this size. Once Apple updates texture atlases to use 3x assets, I recommend that you switch to the methodology outlined in <em>The ideal asset approach</em> section for your games.</p></div></div></div><div><div><div><div><h4 class="title"><a id="ch02lvl4sec03"/>Hands-on with retina in SpriteKit</h4></div></div></div><p>Our bee image<a id="id79" class="indexterm"/> illustrates how this all works:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Because we set an explicit node size, SpriteKit automatically resizes the bee texture to fit our 100-point wide, 100-point tall sized node. This automatic size-to-fit is very handy, but notice that we have actually slightly distorted the aspect ratio of the image.</li><li class="listitem" style="list-style-type: disc">If we do not set an explicit size, SpriteKit sizes the node (in points) to the match texture's dimensions (in pixels). Go ahead and delete the line that sets the size for our bee node and re-run the project. SpriteKit maintains the aspect ratio automatically, but the smaller bee is still fuzzy. That is because our new node is 56 points by 48 points, matching our PNG file's pixel dimensions of 56 pixels by 48 pixels . . . yet our PNG file needs to be 112 pixels by 96 pixels for a sharp image at this node size on 2x retina screens.</li><li class="listitem" style="list-style-type: disc">We<a id="id80" class="indexterm"/> want a smaller bee anyway, so we will resize the node rather than generate larger artwork in this case. Set the <code class="literal">size</code> property of your bee node, in points, to half the size of the texture's pixel resolution:<div><pre class="programlisting">// size our bee in points:
bee.size = CGSize(width: 28, height: 24)</pre></div></li></ul></div><p>Run the project and you will see a smaller, crystal sharp bee, as in this screenshot:</p><div><img src="img/Image_B04532_02_08.jpg" alt="Hands-on with retina in SpriteKit"/></div><p>Great! The important concept here is to design your art files at twice the pixel resolution of your node point sizes to take advantage of 2x retina screens, or three times the point sizes to take full advantage of the iPhone 6 Plus. Now we will look at organizing and animating multiple sprite frames.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Organizing your assets</h1></div></div></div><p>We will quickly overrun our project<a id="id81" class="indexterm"/> navigator with image files if we add all our textures as we did with our bee. Luckily, Xcode provides several solutions.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec36"/>Exploring Images.xcassets</h2></div></div></div><p>We can<a id="id82" class="indexterm"/> store<a id="id83" class="indexterm"/> images in an <code class="literal">.xcassets</code> file and refer to them easily from our code. This is a good place for our background images:</p><div><ol class="orderedlist arabic"><li class="listitem">Open <code class="literal">Images.xcassets</code> from your project navigator.</li><li class="listitem">We do not need to add any images here now but, in the future, you can drag image files directly into the image list, or right-click, then <strong>Import</strong>.</li><li class="listitem">Notice that the SpriteKit demo's spaceship image is stored here. We do not need it anymore, so we can right-click on it and choose <strong>Removed Selected Items</strong> to delete it.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec37"/>Collecting art into texture atlases</h2></div></div></div><p>We <a id="id84" class="indexterm"/>will use texture atlases for most of our in-game art. Texture atlases organize assets by collecting related artwork together. They also increase performance by optimizing all of the images inside each atlas as if they were one texture. SpriteKit only needs one draw call to render multiple images out of the same texture atlas. Plus, they <a id="id85" class="indexterm"/>are very easy to use! Follow these steps to build your bee texture atlas:</p><div><ol class="orderedlist arabic"><li class="listitem">We need to remove our old bee texture. Right-click on <code class="literal">bee.png</code> in the project navigator and choose <strong>Delete</strong>, then <strong>Move to Trash</strong>.</li><li class="listitem">Using Finder, browse to the asset pack you downloaded and locate the <code class="literal">Enemies</code> folder.</li><li class="listitem">Create a new folder inside <code class="literal">Enemies</code> and name it <code class="literal">bee.atlas</code>.</li><li class="listitem">Locate the <code class="literal">bee.png</code> and <code class="literal">bee_fly.png</code> images inside <code class="literal">Enemies</code> and copy them into your new <code class="literal">bee.atlas</code> folder. You should now have a folder named <code class="literal">bee.atlas</code> containing the two bee PNG files. This is all you need to do to create a new texture atlas – simply place your related images into a new folder with the <code class="literal">.atlas</code> suffix.</li><li class="listitem">Add the atlas to your project. In Xcode, right-click on the project folder in the project navigator and click <strong>Add Files…</strong>, as we did earlier for our single bee texture.</li><li class="listitem">Find the <code class="literal">bee.atlas</code> folder and select the folder itself.</li><li class="listitem">Check <strong>Copy items if needed</strong>, then click <strong>Add</strong>.</li></ol></div><p>The texture atlas<a id="id86" class="indexterm"/> will appear in the project navigator. Good work; we organized our bee assets into one collection and Xcode will automatically create the performance optimizations mentioned earlier.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec06"/>Updating our bee node to use the texture atlas</h3></div></div></div><p>We can <a id="id87" class="indexterm"/>actually run our project right now and see the same bee as before. Our old bee texture was <code class="literal">bee.png</code>, and a new <code class="literal">bee.png</code> exists in the texture atlas. Though we deleted the standalone <code class="literal">bee.png</code>, SpriteKit is smart enough to find the new <code class="literal">bee.png</code> in the texture atlas.</p><p>We should make sure our texture atlas is working, and that we successfully deleted the old individual <code class="literal">bee.png</code>. In <code class="literal">GameScene.swift</code>, change our <code class="literal">SKSpriteNode</code> instantiation line to use the new <code class="literal">bee_fly.png</code> graphic in the texture atlas:</p><div><pre class="programlisting">// create our bee sprite
// notice the new image name: bee_fly.png
let bee = SKSpriteNode(imageNamed: "<strong>bee_fly.png</strong>")</pre></div><p>Run the project again. You should see a different bee image, its wings held lower than before. This is the second frame of the bee animation. Next, we will learn to animate between the two frames to create an animated sprite.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec07"/>Iterating through texture atlas frames</h3></div></div></div><p>We need to <a id="id88" class="indexterm"/>study one more texture atlas technique: we can quickly flip through multiple sprite frames to make our bee come alive with motion. We now have two frames of our bee in flight; it should appear to hover in place if we switch back and forth between these frames.</p><p>Our node will run a new <code class="literal">SKAction</code> to animate between the two frames. Update your <code class="literal">didMoveToView</code> function to match mine (I removed some older comments to save space):</p><div><pre class="programlisting">override func didMoveToView(view: SKView) {
    self.backgroundColor = UIColor(red: 0.4, green: 0.6, blue: 
        0.95, alpha: 1.0)
        
    // create our bee sprite
    // Note: Remove all prior arguments from this line:
    let bee = SKSpriteNode()
    bee.position = CGPoint(x: 250, y: 250)
    bee.size = CGSize(width: 28, height: 24)
    self.addChild(bee)
        
    // Find our new bee texture atlas
    let beeAtlas = SKTextureAtlas(named:"bee.atlas")
    // Grab the two bee frames from the texture atlas in an array
    // Note: Check out the syntax explicitly declaring beeFrames
    // as an array of SKTextures. This is not strictly necessary,
    // but it makes the intent of the code more readable, so I 
    // chose to include the explicit type declaration here:
    let beeFrames:[SKTexture] = [
        beeAtlas.textureNamed("bee.png"), 
        beeAtlas.textureNamed("bee_fly.png")]
    // Create a new SKAction to animate between the frames once
    let flyAction = SKAction.animateWithTextures(beeFrames, 
        timePerFrame: 0.14)
    // Create an SKAction to run the flyAction repeatedly
    let beeAction = SKAction.repeatActionForever(flyAction)
    // Instruct our bee to run the final repeat action:
    bee.runAction(beeAction)
}</pre></div><p>Run the <a id="id89" class="indexterm"/>project. You will see our bee flap its wings back and forth – cool! You have learned the basics of sprite animation with texture atlases. We will create increasingly complicated animations using this same technique later in the book. For now, pat yourself on the back. The result may seem simple, but you have unlocked a major building block towards your first SpriteKit game!</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Putting it all together</h1></div></div></div><p>First, we <a id="id90" class="indexterm"/>learned how to use actions to move, scale, and rotate our sprites. Then, we explored animating through multiple frames, bringing our sprite to life. Let us now<a id="id91" class="indexterm"/> combine these techniques to fly our bee back and forth across the screen, flipping the texture at each turn.</p><p>Add this code at the bottom of the <code class="literal">didMoveToView</code> function, beneath the <code class="literal">bee.runAction(beeAction)</code> line:</p><div><pre class="programlisting">// Set up new actions to move our bee back and forth:
let pathLeft = SKAction.moveByX(-200, y: -10, duration: 2)
let pathRight = SKAction.moveByX(200, y: 10, duration: 2)
// These two scaleXTo actions flip the texture back and forth
// We will use these to turn the bee to face left and right
let flipTextureNegative = SKAction.scaleXTo(-1, duration: 0)
let flipTexturePositive = SKAction.scaleXTo(1, duration: 0)
// Combine actions into a cohesive flight sequence for our bee
let flightOfTheBee = SKAction.sequence([pathLeft, 
    flipTextureNegative, pathRight, flipTexturePositive])
// Last, create a looping action that will repeat forever
let neverEndingFlight = 
    SKAction.repeatActionForever(flightOfTheBee)

// Tell our bee to run the flight path, and away it goes!
bee.runAction(neverEndingFlight)</pre></div><p>Run the project. You will see the bee flying back and forth, flapping its wings. You have officially learned the fundamentals of animation in SpriteKit! We will build on this knowledge to create a rich, animated game world for our players.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Centering the camera on a sprite</h1></div></div></div><p>Games often<a id="id92" class="indexterm"/> require that the camera follows the player sprite as it moves<a id="id93" class="indexterm"/> through space. We definitely want this camera behavior for Pierre, our penguin character, whom we will soon be adding to the game. Since SpriteKit does not come with built-in camera functionality, we will create our own structure to simulate the effect we want.</p><p>One way we could accomplish this is by keeping Pierre in one position and moving every other object past him. This is effective, yet semantically confusing, and can cause errors when you are positioning game objects.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec38"/>Creating a new world</h2></div></div></div><p>I prefer to <a id="id94" class="indexterm"/>create a world node and attach all of our game nodes to it (instead of directly to the scene). We can move Pierre forward through the world and simply reposition the world node so that Pierre is always at the center of our device's viewport. All of our enemies, power-ups, and structures will be children of the world node, and will appear to move past the screen as we scroll through the world.</p><div><div><h3 class="title"><a id="tip06"/>Tip</h3><p>Each sprite node's position is always relative to its direct parent. When you change a node's position, all of its child nodes come along for the ride. This is very handy behavior for simulating our camera.</p></div></div><p>This diagram illustrates a simplified version of this technique with some made-up numbers:</p><div><img src="img/Image_B04532_02_06.jpg" alt="Creating a new world"/></div><p>You can find the<a id="id95" class="indexterm"/> code for our camera functionality in the following code block. Read the comments for a detailed explanation. This is just a quick recap of the changes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Our <code class="literal">didMoveToView</code> function was becoming too crowded. I broke out our flying bee code into a new function named <code class="literal">addTheFlyingBee</code>. Later, we will encapsulate game objects, such as bees, into their own classes.</li><li class="listitem" style="list-style-type: disc">I created two new constants on the <code class="literal">GameScene</code> class: the world node and the bee node.</li><li class="listitem" style="list-style-type: disc">I updated the <code class="literal">didMoveToView</code> function. It adds the world node to the scene's node tree, and calls the new <code class="literal">addTheFlyingBee</code> function.</li><li class="listitem" style="list-style-type: disc">Inside the new bee function, I removed the bee constant, as <code class="literal">GameScene</code> now declares it above as its own property.</li><li class="listitem" style="list-style-type: disc">Inside the new bee function, instead of adding the bee node to the scene, with <code class="literal">self.addChild(bee)</code>, we want to add it to the world, with <code class="literal">world.addChild(bee)</code>.</li><li class="listitem" style="list-style-type: disc">We are implementing a new function: <code class="literal">didSimulatePhysics</code>. SpriteKit calls this function every frame after performing physics calculations and adjusting positions. It is a great place to update our world position. The math to change the world position resides in this new function.</li></ul></div><p>Please update your entire <code class="literal">GameScene.swift</code> file to match mine:</p><div><pre class="programlisting">import SpriteKit

class GameScene: SKScene {
    // Create the world as a generic SKNode
    let world = SKNode()
    // Create our bee node as a property of GameScene so we can 
    // access it throughout the class
    // (Make sure to remove the old bee declaration inside the 
    // didMoveToView function.)
    let bee = SKSpriteNode()
    
    override func didMoveToView(view: SKView) {
        self.backgroundColor = UIColor(red: 0.4, green: 0.6, blue: 
            0.95, alpha: 1.0)
        
        // Add the world node as a child of the scene
        self.addChild(world)
        // Call the new bee function
        self.addTheFlyingBee()
    }
    
    // I moved all of our bee animation code into a new function:
    func addTheFlyingBee() {
        // Position our bee
        bee.position = CGPoint(x: 250, y: 250)
        bee.size = CGSize(width: 28, height: 24)
        // Notice we now attach our bee node to the world node:
        world.addChild(bee)
        
        /*
            all of the same bee animation code remains here,
            I am excluding it in this text for brevity
        */
    }
    
    // A new function
    override func didSimulatePhysics() {
        // To find the correct position, subtract half of the   
        // scene size from the bee's position, adjusted for any  
        // world scaling.
        // Multiply by -1 and you have the adjustment to keep our 
        // sprite centered:
        let worldXPos = -(bee.position.x * world.xScale - 
            (self.size.width / 2))
        let worldYPos = -(bee.position.y * world.yScale - 
            (self.size.height / 2))
        // Move the world so that the bee is centered in the scene
        world.position = CGPoint(x: worldXPos, y: worldYPos)
    }
    
}</pre></div><p>Run the game. You <a id="id96" class="indexterm"/>should see our bee stuck directly at the center of the screen, flipping back and forth every two seconds.</p><div><img src="img/Image_B04532_02_07.jpg" alt="Creating a new world"/></div><p>The bee is actually changing position, just as before, but the world is compensating to keep the bee centered on the screen. When we add more game objects in <a class="link" href="ch03.html" title="Chapter 3. Mix in the Physics">Chapter 3</a>, <em>Mix in the Physics</em>, our bee will appear to fly as the entire world pans past the screen.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Checkpoint 2-B</h1></div></div></div><p>We have made many changes to our project in this chapter. If you would like to download my project to this point, do so here:</p><p>
<a class="ulink" href="http://www.thinkingswiftly.com/game-development-with-swift/chapter-2">http://www.thinkingswiftly.com/game-development-with-swift/chapter-2</a>
</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Summary</h1></div></div></div><p>You have gained foundational knowledge of sprites, nodes, and actions in SpriteKit and already taken huge strides towards your first game with Swift.</p><p>You configured your project for landscape orientation, drew your first sprite, and then made it move, spin, and scale. You added a bee texture to your sprite, created an image atlas, and animated through the frames of flight. Finally, you built a world node to keep the gameplay centered on the player. Terrific work!</p><p>In the next chapter, we will use SpriteKit's physics engine to assign weight and gravity to our world, spawn more flying characters, and create the ground and sky.</p></div></body></html>