<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch12" class="calibre1"/>Chapter 12. Implementing Multiplayer Games</h1></div></div></div><p class="calibre8">In this chapter we will be focusing on the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Creating our TankRace environment</li><li class="listitem">Movement of players</li><li class="listitem">Implementing game play</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch12lvl1sec63" class="calibre1"/>Introduction</h1></div></div></div><p class="calibre8">In the previous chapter, we covered the handshaking of players like connection establishment and assigning a unique identification to the players. Now we shall move forward to exploring more about multiplayer games, and create a multiplayer game called TankRace. We will be implementing the following things while creating the game:</p><div><ul class="itemizedlist"><li class="listitem">Creating a visual game setup, like adding players, backgrounds, and other assets</li><li class="listitem">Implementing movement of players on touching of the screen and also syncing the players across devices</li><li class="listitem">Implementing gameplay, which is the game logic for winning and losing on players actions</li></ul></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch12lvl1sec64" class="calibre1"/>Creating our TankRace environment</h1></div></div></div><p class="calibre8">The name <a id="id465" class="calibre1"/>of the game itself suggests that it's a racing game, where<a id="id466" class="calibre1"/> there will be two players and tanks named the blue tank and the red tank. The tanks will be placed on either side of the screen in the portrait mode on the iPhone and there will be two finishing lines, a blue line and a red line, to be crossed by blue tank (let's say first player) and red tank (let's say second player) respectively. The movement of player will be a touch based behavior and the player whose tank crosses their finish line first will win and the other will lose. We will be creating the environment for the game, TankRace, which will include adding players, game background, and finishing lines.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch12lvl2sec151" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">In the<a id="id467" class="calibre1"/> previous<a id="id468" class="calibre1"/> chapters, you have learned all about adding sprites and backgrounds and updating their attributes like position, rotation, and so on. Now, we will be adding all the assets needed in the game to make it playable.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch12lvl2sec152" class="calibre1"/>How to do it</h2></div></div></div><p class="calibre8">The steps to add all the assets required to be added to the game are as follows:</p><div><ol class="orderedlist"><li class="listitem" value="1">Drag and add the resources provided with the with the code bundle for this chapter, which are: <code class="email">BlueTank.png</code>, <code class="email">RedTank.png</code>, and <code class="email">Background.png</code> to the project, After adding the files, the project navigator will look like this:<div><img src="img/00175.jpeg" alt="How to do it" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="2">Now, here, we will be using GameKit, which is a great framework to create social games. This framework provides various features such ass peer-to-peer connection, game <a id="id469" class="calibre1"/>center, and in-game voice chat. Import <a id="id470" class="calibre1"/>GameKit and declare some enums, structures, properties, and constants to be used in the coming code as shown:<div><ul class="itemizedlist1"><li class="listitem">Import <code class="email">GameKit</code> to use CGPoint for storing data structures:<div><pre class="programlisting">#import &lt;GameKit/GameKit.h&gt;</pre></div></li><li class="listitem">Add two more <code class="email">NetworkPacketCode</code> for players to move and a packet code for when game finishes, for example, a packet for losing a game:<div><pre class="programlisting">typedef enum {
    KNetworkPacketCodePlayerAllotment,
    KNetworkPacketCodePlayerMove,
    KNetworkPacketCodePlayerLost,
} NetworkPacketCode;</pre></div></li><li class="listitem">Declare a structure called <code class="email">TankInfo</code>, which will be used as a data structure for sending the information on tanks; the same structure will be used to sync at the remote player's receiving end.<div><pre class="programlisting">typedef struct {
    CGPoint		tankPreviousPosition;
    CGPoint		tankPosition;
    CGPoint		tankDestination;
    CGFloat		tankRotation;
    CGFloat		tankDirection;
} TankInfo;</pre></div></li><li class="listitem">For the movement of Tanks, add <code class="email">Speed</code> and <code class="email">TurnSpeed</code> constants<div><pre class="programlisting">const float kTankSpeed = 1.0f;
const float kTankTurnSpeed = 0.1f;</pre></div></li><li class="listitem">Change the text of the first and the second player's labels to blue and red respectively<div><pre class="programlisting">// Blue is the First and Red is the Second Player
#define kFirstPlayerLabelText  @"You're Blue"
#define kSecondPlayerLabelText @"You're Red"</pre></div></li><li class="listitem">Add text hash defines for when someone wins or loses.<div><pre class="programlisting">#define kGameWonText           @"You Won"
#define kGameLostText          @"You Lost"</pre></div></li></ul></div></li><li class="listitem" value="3">Add some properties to the private interface of <code class="email">GameScene</code>, like a local data structure of <a id="id471" class="calibre1"/>the tank to be maintained and updated, so that it can be sent to the remote end as well. Also, declare all the <code class="email">SKSpriteNodes</code> and <code class="email">SKShapeNodes</code> to be used in the game.<div><pre class="programlisting">TankInfo tankStatsForLocal;

@property (nonatomic, strong) SKSpriteNode* redTankSprite;
@property (nonatomic, strong) SKSpriteNode* blueTankSprite;
@property (nonatomic, strong) SKShapeNode* blueFinishLine;
@property (nonatomic, strong) SKShapeNode* redFinishLine;
@property (nonatomic, strong) SKSpriteNode* localTankSprite;
@property (nonatomic, strong) SKSpriteNode* remoteTankSprite;</pre></div></li><li class="listitem" value="4">Now, we <a id="id472" class="calibre1"/>shall add some nodes to the scene, hence the GameScene needs to be of the correct size. Click on <code class="email">GameScene.sks</code> and open the right panel from the last icon on the right top bar of Xcode. From there, change the size of the GameScene to <code class="email">320 x 568</code> which is the size of the iPhone 4 inch.<div><img src="img/00176.jpeg" alt="How to do it" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="5">Add a method <code class="email">addGameBackground</code> under the <code class="email">adding assets</code> method's <code class="email">pragma</code> mark in which a <code class="email">SKSpriteNode</code> is created, with the image <code class="email">Background.png</code> added previously in the project. Keep the <em class="calibre9">z</em> position of background as <code class="email">0</code> as it<a id="id473" class="calibre1"/> will be below all other nodes of the game.<div><pre class="programlisting">- (void)addGameBackground
{
    SKSpriteNode *gameBGNode =
    [SKSpriteNode spriteNodeWithImageNamed:@"Background.png"];
    {
        gameBGNode.position =
        CGPointMake(self.frame.size.width/2,self.frame.size.height/2);
        gameBGNode.zPosition = 0;
        [self addChild:gameBGNode];
    }
}</pre></div></li><li class="listitem" value="6">Add two <a id="id474" class="calibre1"/>different methods under the <code class="email">adding assets</code> methods <code class="email">pragma</code> mark for players, namely, blue and red tank with <code class="email">BlueTank.png</code> and <code class="email">RedTank.png</code> images respectively as <code class="email">SpriteNodes</code>.<div><pre class="programlisting">- (void)addBlueTank
{
    self.blueTankSprite = [SKSpriteNode spriteNodeWithImageNamed:@"BlueTank.png"];
    self.blueTankSprite.position = CGPointMake(self.frame.size.width/2,self.frame.size.height * 0.95);
    self.blueTankSprite.zRotation = M_PI;
    self.blueTankSprite.zPosition = 2;
    
    [self addChild:self.blueTankSprite];
}

- (void)addRedTank
{
    self.redTankSprite = [SKSpriteNode spriteNodeWithImageNamed:@"RedTank.png"];
    self.redTankSprite.position = CGPointMake(self.frame.size.width/2,self.frame.size.height * 0.05);
    self.redTankSprite.zRotation = 0.0;
    self.redTankSprite.zPosition = 2;
    	
    [self addChild:self.redTankSprite];
}</pre></div></li><li class="listitem" value="7">Also, create <a id="id475" class="calibre1"/>two methods under the <code class="email">adding assets</code> methods <code class="email">pragma</code> mark for the finishing lines, which both the players will have to reach to win.<div><pre class="programlisting">- (void)addBLueFinishLine
{
    CGRect frame = CGRectMake(0, self.frame.size.height * 0.15, self.frame.size.width, 1);
    
    self.blueFinishLine = [SKShapeNode shapeNodeWithRect:frame];
    {
        self.blueFinishLine.strokeColor = [UIColor blueColor];
        self.blueFinishLine.zPosition = 2;
        [self addChild:self.blueFinishLine];
    }
}

- (void)addRedFinishLine
{
    CGRect frame = CGRectMake(0, self.frame.size.height * 0.85, self.frame.size.width, 1);
    
    self.redFinishLine = [SKShapeNode shapeNodeWithRect:frame];
    {
        self.redFinishLine.strokeColor = [UIColor redColor];
        self.redFinishLine.zPosition = 1;
        [self addChild:self.redFinishLine];
    }
}</pre></div></li><li class="listitem" value="8">Here we <a id="id476" class="calibre1"/>use the <code class="email">SKNodeShape</code> class objects, which are used to draw any required shape on the screen using the core graphics path. We are thus adding the red and blue lines at either end of the game scene.</li><li class="listitem" value="9">To set the tanks in the initial positions both in the data structure and in the <code class="email">GameScene</code>, we will write a method, namely, <code class="email">resetLocalTanksAndInfoToInitialState</code>.<div><pre class="programlisting">#pragma mark - Game Updation Methods

- (void)resetLocalTanksAndInfoToInitialState
{
    if (self.localTankSprite == self.blueTankSprite &amp;&amp; self.remoteTankSprite == self.redTankSprite)
    {
        tankStatsForLocal.tankPosition = CGPointMake(self.frame.size.width/2,self.frame.size.height * 0.95);
        tankStatsForLocal.tankRotation = M_PI;
        self.localTankSprite.position = tankStatsForLocal.tankPosition;
        self.localTankSprite.zRotation = tankStatsForLocal.tankRotation;

        self.remoteTankSprite.position = CGPointMake(self.frame.size.width/2,self.frame.size.height * 0.05);
        self.remoteTankSprite.zRotation = 0.0;
    }
    else if (self.localTankSprite == self.redTankSprite &amp;&amp; self.remoteTankSprite == self.blueTankSprite)
    {
        tankStatsForLocal.tankPosition = CGPointMake(self.frame.size.width/2,self.frame.size.height * 0.05);
        tankStatsForLocal.tankRotation = 0.0;
        self.localTankSprite.position = tankStatsForLocal.tankPosition;
        self.localTankSprite.zRotation = tankStatsForLocal.tankRotation;

        self.remoteTankSprite.position = CGPointMake(self.frame.size.width/2,self.frame.size.height * 0.95);
        self.remoteTankSprite.zRotation = M_PI;
    }
}</pre></div></li><li class="listitem" value="10">In this <a id="id477" class="calibre1"/>method, the<a id="id478" class="calibre1"/> local data structure <code class="email">tankStatsForLocal</code> and the local player's attributes position, <code class="email">zRotation</code> using the only <code class="email">tankStatsForLocal</code> are set to the initial state of the game. The remote player's position and <code class="email">zRotation</code> are hardcoded in the initial state of the game. All this is set on the basis of who out of blue and red is the local and remote tank on the device.</li><li class="listitem" value="11"> To animate the players identity text, add a method <code class="email">hideGameInfoLabelWithAnimation</code>.<div><pre class="programlisting">- (void)hideGameInfoLabelWithAnimation
{
    SKAction* gameInfoLabelHoldAnimationCallBack = [SKAction customActionWithDuration:2.0
         actionBlock:^(SKNode *node,CGFloat elapsedTime)
     {
     }];
    
    SKAction* gameInfoLabelFadeOutAnimation = [SKAction fadeOutWithDuration:1.0];
    
    SKAction* gameInfoLabelRemoveAnimationCallBack = [SKAction customActionWithDuration:0.0actionBlock:^(SKNode *node,CGFloat elapsedTime)
     {
         [node removeFromParent];
         self.gameInfoLabel = nil;
     }];
    
    NSArray* gameLabelAnimationsSequence = [NSArray arrayWithObjects:gameInfoLabelHoldAnimationCallBack,gameInfoLabelFadeOutAnimation,gameInfoLabelRemoveAnimationCallBack, nil];
    SKAction* gameInfoSequenceAnimation = [SKAction sequence:gameLabelAnimationsSequence];
    [self.gameInfoLabel runAction:gameInfoSequenceAnimation];
}</pre></div></li><li class="listitem" value="12">Using<a id="id479" class="calibre1"/> sprite <code class="email">SKAction</code> a sequence of animations<a id="id480" class="calibre1"/> is created, having a delay initially, fading the label and then using a callback to remove it at last. This is done when the users are connected. For fading in and out of the labels, we use the same animation code that we used earlier in <a class="calibre1" title="Chapter 3. Animations and Texture" href="part0025_split_000.html#page">Chapter 3</a>, <em class="calibre9">Animations and Texture</em>.</li><li class="listitem" value="13">Now, edit the <code class="email">didChangeState</code> delegate method of <code class="email">MCSession</code>, when the state changes to connected as shown in the following:<div><pre class="programlisting">- (void)session:(MCSession *)session didReceiveData:(NSData *)data fromPeer:(MCPeerID *)peerID {
    // Data has been received from a peer.
    
   // Do something with the received data, on the main thread
    [[NSOperationQueue mainQueue]  addOperationWithBlock:^{
        
        // Process the data       
      unsigned char *incomingPacket = (unsigned char *)[data bytes];
      int *pIntData = (int *)&amp;incomingPacket[0];
      NetworkPacketCode packetCode = (NetworkPacketCode)pIntData[1];
        
      switch( packetCode ) {
        case KNetworkPacketCodePlayerAllotment:
          {
                NSInteger gameUniqueId = pIntData[2];
               if (gameUniqueIdForPlayerAllocation &gt; gameUniqueId)
                {
                   self.gameInfoLabel.text = kFirstPlayerLabelText;
                    self.localTankSprite = self.blueTankSprite;
                    self.remoteTankSprite = self.redTankSprite;
                }
                else
                {
                    self.gameInfoLabel.text = kSecondPlayerLabelText;
                    self.localTankSprite = self.redTankSprite;
                    self.remoteTankSprite = self.blueTankSprite;
                }
                [self resetLocalTanksAndInfoToInitialState];
                break;
            }
            case KNetworkPacketCodePlayerMove:
            {
                break;
            }
            case KNetworkPacketCodePlayerLost:
            {
                break;
            }
            default:
            break;
        }
    }];
}</pre></div></li><li class="listitem" value="14">In the receiving <code class="email">MCSession</code> method, add all <code class="email">NetworkPacketCode</code> in the <code class="email">switch</code> case and make changes when the <code class="email">KNetworkPacketCodePlayerAllotment</code> packet is received. When allocating the players, set the identity name accordingly and assign the local and remote sprite objects depending on the <code class="email">gameUniqueIdForPlayerAllocation</code>. Finally, call a private method <code class="email">resetLocalTanksAndInfoToInitialState</code>, in which initial states of both local and remote<a id="id481" class="calibre1"/> sprites with their local data structure are set. All these steps will be<a id="id482" class="calibre1"/> executed on both the connected devices in sessions, which will ensure that both the devices are in sync.</li><li class="listitem" value="15">Now once the <code class="email">gameInfoLabel</code> displaying player identity is set, then insert the code to change the state of the game and to animate <code class="email">gameInfoLabel</code> by hiding it in the <code class="email">startGame</code> method of <code class="email">GameScene</code>, called by a delegate method of <code class="email">MCBrowerViewController</code>.<div><pre class="programlisting">- (void)startGame
{
    if (self.gameState == kGameStatePlayerAllotment)
    {
        self.gameState = kGameStatePlaying;
        [self hideGameInfoLabelWithAnimation];
    }
}</pre></div></li><li class="listitem" value="16">When the method is called by the delegate method, it checks if the allotment of the player has been done, then changes the state to playing and animates the hiding of the label on which either <strong class="calibre2">You're blue</strong> or <strong class="calibre2">You're red</strong> is written.</li></ol><div></div><p class="calibre8">After all these asset addition of games, its environment is setup and player's identities or we can say names, have been assigned as blue and red. All this comprises of the starter kit of this chapter.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch12lvl2sec153" class="calibre1"/>How it works</h2></div></div></div><p class="calibre8">The whole section was about using SpriteKit as a way to add game assets and as a part of multiplayer, the players were assigned as blue and red. The working part of the node addition on <code class="email">GameScene</code> has already been explained in <a class="calibre1" title="Chapter 11. Getting Started with Multiplayer Games" href="part0065_split_000.html#page">Chapter 11</a>, <em class="calibre9">Getting Started with Multiplayer Games</em>, and as a result of the outcome of these additions, the game looks like this on both the devices:</p><div><img src="img/00177.jpeg" alt="How it works" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">In the multiplayer <a id="id483" class="calibre1"/>part, when the user presses the <strong class="calibre2">Done</strong> button, the<a id="id484" class="calibre1"/> connection is established and both the players are connected. Also, when the user presses the <strong class="calibre2">Done</strong> button, names have been assigned to the players as blue and red as shown in the following image for both the devices. These labels are on two different devices and will animate on the allocation as well:</p><div><img src="img/00178.jpeg" alt="How it works" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch12lvl1sec65" class="calibre1"/>Movement of players</h1></div></div></div><p class="calibre8">Once the environment for multiplayer is ready, it's time for the actual action: making the player move when a user touches or drags on screen. As it's a multiplayer game the movement is to be synced with the remote device, which a good challenge and a magical thing to experience.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch12lvl2sec154" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">Before <a id="id485" class="calibre1"/>starting with this section we should be aware of the touch methods of <code class="email">SKScene</code> like <code class="email">touchBegan</code>, <code class="email">touchMoved</code>, and <code class="email">touchEnded</code> as all the movement will be done on the basis on touch. Also we should be good at mathematics, as this movement of tanks with its head to be in the direction of touch, has to be done and synced with the remote device. In this section, we will be implementing the movement of tanks and also syncing the movement on other device by sending and receiving network packets.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch12lvl2sec155" class="calibre1"/>How to do it</h2></div></div></div><p class="calibre8">Following are the steps involved in making a tank move on touch and also sync on a remote device by sending and receiving packets:</p><div><ol class="orderedlist"><li class="listitem" value="1">On touching the screen, these methods of <code class="email">SKScene</code> are called, which will be used to move the tank in the local device.<div><pre class="programlisting">-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
-(void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event</pre></div></li><li class="listitem" value="2">The first method has already been implemented. Let's add some updated lines of tank info on touch begins when the game state is <code class="email">kGameStatePlaying</code> as shown in the following: <div><pre class="programlisting">UITouch *thumb = [[event allTouches] anyObject];
CGPoint thumbPoint = [thumb locationInNode:self];
// hold to move, second finger to fire
if(thumb.tapCount==0) {
   tankStatsForLocal.tankDestination = thumbPoint;
   tankStatsForLocal.tankDirection = atan2( thumbPoint.y - tankStatsForLocal.tankPosition.y, thumbPoint.x - tankStatsForLocal.tankPosition.x ) - (M_PI/2.0);
   // keep us 0-359
   if(tankStatsForLocal.tankDirection &lt; 0)
     tankStatsForLocal.tankDirection += (2.0*M_PI);
   else if(tankStatsForLocal.tankDirection &gt; (2.0*M_PI))
     tankStatsForLocal.tankDirection -= (2.0*M_PI)
    
    [self updateLocalTank];
}</pre></div></li><li class="listitem" value="3">In this <a id="id486" class="calibre1"/>piece of code from the event received by the <code class="email">touch</code> method, a <code class="email">UITouch</code> object is fetched and, using that, the location of touch is determined with respect to the <code class="email">GameScene</code>. Then if the touch <code class="email">tapCount</code> is <code class="email">0</code>, that is, the user is dragging the code to move, the player is executed. In this code the <code class="email">tankStatsForLocal</code> is updated on the basis of the position of the touch on screen. The destination is set as the touch location, the direction is calculated by using vector mathematics using the touch point and the current position of tank. To keep the direction angle of the tank between 0 to 359 degrees, extra checks should be put in place once the direction is calculated. After all this, to update the actual position and rotation of the tank, a method called <code class="email">updateLocalTank</code>, which we will be discussing soon, will be implemented.</li><li class="listitem" value="4">Implement the two other touch methods as well, <code class="email">touchMoved</code> and <code class="email">touchEnded</code>, in <code class="email">GameScene</code>.</li><li class="listitem" value="5">In <code class="email">touchesMoved</code>, if the game state is <code class="email">kGameStatePlaying</code> then execute the same code as in <code class="email">touchesBegan</code> method, explained in the preceding point.<div><pre class="programlisting">- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
{
    if (self.gameState == kGameStatePlaying)
    {
        if([touches count] == 1)
        {
            UITouch *thumb = [[event allTouches] anyObject];
            CGPoint thumbPoint = [thumb locationInNode:self];

            tankStatsForLocal.tankDestination = thumbPoint;
            tankStatsForLocal.tankDirection = atan2( thumbPoint.y - tankStatsForLocal.tankPosition.y,
                  thumbPoint.x - tankStatsForLocal.tankPosition.x ) - (M_PI/2.0);

            // keep us 0-359
            if(tankStatsForLocal.tankDirection &lt; 0)
                tankStatsForLocal.tankDirection += (2.0*M_PI);
            else if(tankStatsForLocal.tankDirection &gt; (2.0*M_PI))
                tankStatsForLocal.tankDirection -= (2.0*M_PI);

            [self updateLocalTank];
        }
    }
}</pre></div></li><li class="listitem" value="6">In <code class="email">touchesEnded</code> we must not do what we did in the other two touch methods; here we will <a id="id487" class="calibre1"/>only update the <code class="email">tankDestination</code> and <code class="email">tankDirection</code> with the local data structure and then call the same <code class="email">updateLocalTank</code> method to update the final position and rotation.<div><pre class="programlisting">-(void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event
{
    if (self.gameState == kGameStatePlaying)
    {
        if([touches count] == [[event touchesForView:self.view] count])
        {
            tankStatsForLocal.tankDestination = tankStatsForLocal.tankPosition;
            tankStatsForLocal.tankDirection = tankStatsForLocal.tankRotation;
            
            [self updateLocalTank];
        }
    }
}</pre></div></li><li class="listitem" value="7">In all the touch methods, the <code class="email">updateLocalTank</code> method is called to update the final position and rotation. After updating these attributes for the local tank a network packet is sent to sync with the remote tank player.<div><pre class="programlisting">- (void)updateLocalTank
{    

    if( (fabs(tankStatsForLocal.tankPosition.x - tankStatsForLocal.tankDestination.x)&gt;kTankSpeed) ||
       (fabs(tankStatsForLocal.tankPosition.y - tankStatsForLocal.tankDestination.y)&gt;kTankSpeed) ) {

        // check facing
        float ad = tankStatsForLocal.tankDirection - tankStatsForLocal.tankRotation;
        
        if(fabs(ad) &gt; kTankTurnSpeed) {

            // we need to turn, work out which way (find the closest 180)
            while(ad &gt; M_PI) {
                ad -= (2.0 * M_PI);
            }
            while(ad &lt; -M_PI) {
                ad += (2.0 * M_PI);
            }

            if(ad &lt; 0) {
                tankStatsForLocal.tankRotation -= kTankTurnSpeed;
                if(tankStatsForLocal.tankRotation &lt; 0)
                    tankStatsForLocal.tankRotation += (2.0*M_PI);
            } else if(ad &gt; 0) {
                tankStatsForLocal.tankRotation += kTankTurnSpeed;
                if(tankStatsForLocal.tankRotation &gt; (2.0*M_PI))
             	       tankStatsForLocal.tankRotation -= (2.0*M_PI);
            }
        } else {

            tankStatsForLocal.tankRotation = tankStatsForLocal.tankDirection;
            // if facing move along line towards destination
            float dx = tankStatsForLocal.tankPosition.x - tankStatsForLocal.tankDestination.x;
            float dy = tankStatsForLocal.tankPosition.y - tankStatsForLocal.tankDestination.y;
            float at = atan2( dy, dx );
            // 1.0 is the "speed"
            tankStatsForLocal.tankPosition.x -= kTankSpeed * cos(at);
            tankStatsForLocal.tankPosition.y -= kTankSpeed * sin(at);
        }
    } else {

        tankStatsForLocal.tankPosition.x = tankStatsForLocal.tankDestination.x;
        tankStatsForLocal.tankPosition.y = tankStatsForLocal.tankDestination.y;
    }
    
    tankStatsForLocal.tankPreviousPosition = self.localTankSprite.position;
    
    self.localTankSprite.position = tankStatsForLocal.tankPosition;
    self.localTankSprite.zRotation = tankStatsForLocal.tankRotation;
    
    // Send NetworkPacket for syncing the data at both the players
    
    [self sendNetworkPacketToPeerId:self.gamePeerID
    forPacketCode:KNetworkPacketCodePlayerMove
                           withData:&amp;tankStatsForLocal
                           ofLength:sizeof(TankInfo)
                           reliable:YES];
}</pre></div><p class="calibre15">Initially, check that the destination vector does not have a difference greater than the <code class="email">kTankSpeed</code>. Then, update the position by the <code class="email">tankStatsForLocal</code> destination and if the difference is greater, then write the code for turning around; that is, calculate the angle difference between the tank direction and <code class="email">tankRotation</code>.</p></li><li class="listitem" value="8">Check <a id="id488" class="calibre1"/>if the difference is greater than <code class="email">kTankTurnSpeed</code>, then find the closest 180 degrees to be rotated, and according to that subtract or add the <code class="email">kTankTurnSpeed</code> with the rotation. If the difference is not greater than the facing, move around the line towards the destination. Set the rotation as the direction and calculate the position of the tank using current position, destination, and <code class="email">kTankSpeed</code>.<p class="calibre15">All these calculations should be assigned to the <code class="email">tankStatsForLocaldata</code> structure. After all this, set the <code class="email">tankPreviousPosition</code> of the local data structure as the current position of the local player sprite. Update the position and rotation calculated in the <code class="email">tankStatsForLocalstructure</code>. To sync the player's movement produced in this method, we need to send a packet to the other player with <code class="email">NetworkPacketCode</code> as <code class="email">KNetworkPacketCodePlayerMove</code> data part will be in the structure of <code class="email">tankStatsForLocal</code> and this packet should be sent unreliably because it is been sent very frequently.</p></li><li class="listitem" value="9">In the <a id="id489" class="calibre1"/>delegate method of <code class="email">MCSessiondidReceiveData</code>, the packet for the movement of the player with type <code class="email">KNetworkPacketCodePlayerMove</code> is received.<div><pre class="programlisting">case KNetworkPacketCodePlayerMove:
{
   // received move event from other player, update other player's position/destination info
   TankInfo *ts = (TankInfo *)&amp;incomingPacket[8];
   self.remoteTankSprite.position = ts-&gt;tankPosition;
   self.remoteTankSprite.zRotation = ts-&gt;tankRotation;
   break;
}</pre></div></li><li class="listitem" value="10">Here, <code class="email">TankInfo</code> is the structure that holds all the location and rotation related data of the user. The <code class="email">TankInfo</code> structure is sent over the network to sync both the devices.</li></ol><div></div><p class="calibre8">The data is parsed in a <code class="email">TankInfo</code> variable <code class="email">ts</code>, which contains the sent tank position and rotation. Hence it is the data of the remote tank, so update it with the attributes received. As a result, we will be able to see the tank moving in the remote device, the same as the user driving the tank in the other device.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch12lvl2sec156" class="calibre1"/>How it works</h2></div></div></div><p class="calibre8">The movement of the tanks is done by vector mathematics using the point on which the user has touched, what direction the tank is facing at the time of the touch, and so on. We have finally achieved the multiplayer behavior in our game where a tank moves remotely as per the local tank moves in the device and this can be seen in the following snapshot. Synchronization of remote devices entirely depends on the network. </p><p class="calibre8">If the network is weak, then user may face some lag in sync between devices.</p><div><img src="img/00179.jpeg" alt="How it works" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch12lvl1sec66" class="calibre1"/>Implementing game play</h1></div></div></div><p class="calibre8">It is now <a id="id490" class="calibre1"/>time to implement the game play in which, how the players (tanks) are going to win or lose in the game called TankRace will be determined. The game play is that, whichever player first reaches the finish line on their opposite side, of the same color as their own, wins the race and other loses.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch12lvl2sec157" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">Before we begin, we must know how to detect collision from sprites in the SpriteKit and a little about playing with the labels of SpriteKit. In this section, we will be implementing the game play and also show an alert when there is no connection between the devices.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch12lvl2sec158" class="calibre1"/>How to do it</h2></div></div></div><p class="calibre8">Following are the steps involved for implementing the game play and deciding who wins or loses:</p><div><ol class="orderedlist"><li class="listitem" value="1">We will be detecting the collision in the update method of the <code class="email">GameScene</code> by using a method called <code class="email">CGRectIntersectsRect</code>. In this, we can pass the two frames of nodes and it will check if the two frames intersect with each other or not. With this check, we will only check this for local player collision, and if collision happens update the game state to <code class="email">kGameStateComplete</code> and show the local player <strong class="calibre2">You Won</strong> who has reached the finish line. Also, as the game has ended, to auto start the game, call a method called <code class="email">restartGameAfterSomeTime</code>, which we will understand as we proceed.</li><li class="listitem" value="2">After this, the<a id="id491" class="calibre1"/> local player is shown the correct result and the game is restarted, but as it is a multiplayer game, the reaction of this collision should also be reflected on the other device. So, pass a packet with a <code class="email">NetworkPacketCode</code> named <code class="email">KNetworkPacketCodePlayerLost</code> which will be sent to the other player who has lost the game. Following is the codes to achieve this:<div><pre class="programlisting">#pragma mark - Update Loop Method

-(void)update:(CFTimeInterval)currentTime {
    /* Called before each frame is rendered */
    
    CGRect blueFinishLineFrame =
    CGRectMake(0, self.frame.size.height * 0.15, self.frame.size.width, 1);

    CGRect redFinishLineFrame = CGRectMake(0, self.frame.size.height * 0.85, self.frame.size.width, 1);

    if (self.localTankSprite == self.blueTankSprite &amp;&amp; CGRectIntersectsRect(self.localTankSprite.frame, blueFinishLineFrame))
    {
        self.gameState = kGameStateComplete;

        [self addGameInfoLabelWithText:kGameWonText];

        [self restartGameAfterSomeTime];
        
        [self sendNetworkPacketToPeerId:self.gamePeerID
                        forPacketCode:KNetworkPacketCodePlayerLost
                               withData:nil
                               ofLength:0
                               reliable:YES];
    }
    else if(self.localTankSprite == self.redTankSprite &amp;&amp; CGRectIntersectsRect(self.localTankSprite.frame, redFinishLineFrame))
    {
        self.gameState = kGameStateComplete;

        [self addGameInfoLabelWithText:kGameWonText];
        
        [self restartGameAfterSomeTime];

        [self sendNetworkPacketToPeerId:self.gamePeerID
                          forPacketCode:KNetworkPacketCodePlayerLost
                               withData:nil
                               ofLength:0
                               reliable:YES];
    }
}</pre></div></li><li class="listitem" value="3">When the <a id="id492" class="calibre1"/>preceding game lost packet is sent to the other player, a delegate method of <code class="email">MCSession</code> named <code class="email">didReceiveData</code> is called, with a <code class="email">NetworkPacketCode</code> in the header of the packet named <code class="email">KNetworkPacketCodePlayerLost</code>. When this packet is received, the game state is changed to <code class="email">kGameStateComplete</code> and the game information label is shown as <strong class="calibre2">You Lose</strong> to inform the other user of losing the game. Also, we call a method <code class="email">restartGameAfterSomeTime</code>, which will reset the game to its initial state and the players can restart the game again.<div><pre class="programlisting">case KNetworkPacketCodePlayerLost:
{
   self.gameState = kGameStateComplete;
   [self addGameInfoLabelWithText:kGameLostText];
   [self restartGameAfterSomeTime];
   break;
}</pre></div><p class="calibre15">After using these two block of codes, about one player winning and the other player losing, the game looks like the following image for both devices:</p><div><img src="img/00180.jpeg" alt="How to do it" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="4">As <code class="email">restartGameAfterSomeTime</code> is used at the time of sending and receiving the packet, let <a id="id493" class="calibre1"/>us write this method as shown in the following code:<div><pre class="programlisting">- (void)restartGameAfterSomeTime
{
    [NSTimer scheduledTimerWithTimeInterval:2.0
                          target:self
                          selector:@selector(restartGame)
                          userInfo:nil
                          repeats:NO];
}

- (void)restartGame
{
    gameUniqueIdForPlayerAllocation = arc4random();

    self.gameState = kGameStatePlayerToConnect;
    self.gameInfoLabel.text = kConnectingDevicesText;
    [self resetLocalTanksAndInfoToInitialState];
}</pre></div></li><li class="listitem" value="5">In this method, a <code class="email">NSTimer</code> of 2.0 seconds will be triggered, calling a function <code class="email">restartGame</code> in which, again, the <code class="email">gameUniqueIdFoPlayerAllocation</code> will be generated, the game state set to <code class="email">kGameStatePlayerToConnect</code>, and the label text changed to <strong class="calibre2">Tap to connect</strong>. For visual initial state, we call the method <code class="email">resetLocalTanksAndInfoToInitialState</code> in which the local data structure and the visual attributes of tanks are set.</li><li class="listitem" value="6">Whenever<a id="id494" class="calibre1"/> the game completes the <code class="email">restartGameAfterSomeTime</code> method is called, on both local and remote devices, to set the initial state of game and it looks like this:<div><img src="img/00181.jpeg" alt="How to do it" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="7">Sometimes, due to a weak network, the connection can be lost and the screen gets stuck, thereby showing no message to the user. Thus, we will add an alert, saying that there is a network problem, and to play, restart your app on both the devices, as shown in the following method:<div><pre class="programlisting">- (void)showNetworkDisconnectAlertView
{
    UIAlertView* alertView = [[UIAlertView alloc] initWithTitle:@"Network Disconnected"
             message:@"Sorry due some network problem devices are disconnected. To start game again kill apps in both devices and restart the app!!"
                delegate:self
                cancelButtonTitle:@"OK"
                otherButtonTitles:nil, nil];

    [alertView show];
}

- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex
{
    // do nothing
}</pre></div></li><li class="listitem" value="8">To show<a id="id495" class="calibre1"/> the network has disconnected alert, call the <code class="email">showNetworkDisconnectAlertView</code> when the delegate method of <code class="email">MCSession</code> named <code class="email">didChangeState</code> is called with a change of state as <code class="email">MCSessionStateNotConnected</code>. It should be shown only when the current game state is <code class="email">kGameStatePlaying</code>.<div><pre class="programlisting">else if (state == MCSessionStateNotConnected)
    {
        NSLog(@"state == MCSessionStateNotConnected");
        
        if (self.gameState == kGameStatePlaying)
        {
            [self showNetworkDisconnectAlertView];
        }
    }</pre></div></li><li class="listitem" value="9">Whenever the game is disconnected, <code class="email">showNetworkDisconnectAlertView</code> is called and an alert view is shown as depicted in the following snapshot:<div><img src="img/00182.jpeg" alt="How to do it" class="calibre10"/></div><p class="calibre13"> </p></li></ol><div></div><p class="calibre8">After all <a id="id496" class="calibre1"/>these implementations of game play logic, or we can say the game mechanics, we have accomplished making a multiplayer game and this is the solution kit for this chapter.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch12lvl2sec159" class="calibre1"/>How it works</h2></div></div></div><p class="calibre8">This section was all about the game play and the game mechanics; it had two parts, one detecting the collisions to decide the winner and second resetting the game to the initial state once the game ended.</p><p class="calibre8">To accomplish this, using the intersection of frame method, we detected the collision and declared the local player as winner and the other player as loser by sending a packet. As the game ended here, to help the user restart it again, at the same time as declaration of winner and loser takes place, we also reset the game to its initial state so that the players can restart the game again.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch12lvl2sec160" class="calibre1"/>There's more</h2></div></div></div><p class="calibre8">We have used the Multipeer Connectivity framework whereas we can also use the GameKit framework; you can use the following link for more on the same:</p><p class="calibre8">
<a class="calibre1" href="https://developer.apple.com/library/ios/documentation/GameKit/Reference/GameKit_Collection/index.html">https://developer.apple.com/library/ios/documentation/GameKit/Reference/GameKit_Collection/index.html</a>
</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch12lvl2sec161" class="calibre1"/>See also</h2></div></div></div><p class="calibre8">For better understanding and learning of the Multipeer Connectivity framework you can visit the following link:</p><p class="calibre8">
<a class="calibre1" href="https://developer.apple.com/library/prerelease/ios/documentation/MultipeerConnectivity/Reference/MultipeerConnectivityFramework/index.html">https://developer.apple.com/library/prerelease/ios/documentation/MultipeerConnectivity/Reference/MultipeerConnectivityFramework/index.html</a>
</p></div></div></body></html>