<html><head></head><body>
        

                            
                    <h1 class="header-title">Miscellaneous</h1>
                
            
            
                
<p class="mce-root">In this chapter, we will cover the following recipes:</p>
<ul>
<li class="mce-root">Kotlin and Java interoperability issues</li>
<li>Kotlin and JavaScript interoperability issues</li>
<li>Renaming of generated classes</li>
<li>Decompiling Kotlin code to JVM bytecode</li>
<li>Adding custom names for imports</li>
<li>Wrapping complex type declarations with type aliases</li>
<li>Expressive <kbd>try…catch</kbd> declarations</li>
<li>Safe type-casting</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>This chapter is going to focus on presenting handy solutions to various problems and issues that Kotlin developers deal with on a daily basis. Here, you will find useful tips and solutions for issues related to interoperability with Java and JavaScript and neat tricks that will help you write code more effectively.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Kotlin and Java interoperability</h1>
                
            
            
                
<p>This recipe is going to show how to combine both Java and Kotlin classes together and use them in the same application component. We will declare a Kotlin data class, called <kbd>ColoredText</kbd>, that holds two properties of the <kbd>String</kbd> and <kbd>Color</kbd> types. Apart from the properties, it is also going to expose a utility function inside a companion object responsible for text-processing. We are going to learn how to make use of those properties and how to declare the function from the <kbd>ColoredText</kbd> class to be visible as a JVM static method inside the Java class.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Declare the <kbd>ColoredText</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">data class ColoredText<br/>@JvmOverloads<br/>constructor(<br/>        var text: String = "",<br/>        var color: Color = defaultColor) {<br/><br/>    companion object {<br/>        @JvmField<br/>        val defaultColor = Color.BLUE<br/>    }<br/>}</pre>
<ol start="2">
<li>Implement a static JVM method inside the <kbd>companion</kbd> object:</li>
</ol>
<pre style="padding-left: 60px">data class ColoredText<br/>@JvmOverloads<br/>constructor(<br/>        var text: String = "",<br/>        var color: Color = defaultColor) {<br/><br/>    companion object {<br/>        @JvmField<br/>        val defaultColor = Color.BLUE<br/><br/><strong>        @JvmStatic<br/>        fun processText(text: String): String =</strong><br/><strong>                with(text) {<br/>                    toLowerCase().trim().capitalize()</strong><br/>                <strong>}</strong><br/><br/>    }<br/><br/>}</pre>
<ol start="3">
<li>Add a member function that enables you to print the <kbd>text</kbd> property to the console:</li>
</ol>
<pre style="padding-left: 60px">data class ColoredText<br/>@JvmOverloads<br/>constructor(<br/>        var text: String = "",<br/>        var color: Color = defaultColor) {<br/><br/><strong>    fun printToConsole() = println(text)</strong><br/><br/>    companion object {<br/>        @JvmField<br/>        val defaultColor = Color.BLUE<br/><br/>        @JvmStatic<br/>        fun processText(text: String): String =<br/>                with(text) {<br/>                    toLowerCase().trim().capitalize()<br/>                }<br/>    }<br/>}</pre>
<ol start="4">
<li>Implement a Java class that makes use of Kotlin class functions and properties:</li>
</ol>
<pre style="padding-left: 60px">public class JavaApp {<br/>    public static void main(String... args) {<br/>        String rawText = <br/>              " one Of The Best Programming Skills You Can Have " +<br/>              "Is Knowing When To Walk Away For Awhile. ";<br/>        String text = ColoredText.processText(rawText);<br/>        ColoredText myText =<br/>              new ColoredText(text, ColoredText.defaultColor);<br/>        myText.printToConsole();<br/>    }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As the result, the main function from the <kbd>JavaApp</kbd> Java class is going to print the following wisdom to the console:</p>
<pre><strong>One of the best programming skills you can have is knowing when to walk away for awhile.</strong></pre>
<p>Kotlin and Java interoperability is absolutely painless, thanks to the fact that both Kotlin and Java classes are compiled to the same JVM bytecode included in a common codebase. However, there are a few special cases that require additional attention when we want to make Kotlin declarations available on the Java side in a specific way.</p>
<p class="mce-root"/>
<p>First of all, in the <kbd>ColoredText</kbd> class, we are marking the constructor with the <kbd>@JvmOverloads</kbd> annotation, which tells the compiler to generate multiple instances of the constructor in case there are any default property values declared. Thanks to this, we could instantiate the <kbd>ColoredText</kbd> class in some Java classes without passing the <kbd>text</kbd> and/or <kbd>color</kbd> property values.</p>
<p>Next annotation we are using is <kbd>@JvmField</kbd>, which tells the Kotlin compiler not to generate getter and setter functions for this property and expose it as a field. It provides a cleaner syntax for accessing the values on the Java side when we expose a constant value through Kotlin objects.</p>
<p>Another commonly used annotation is <kbd>@JvmStatic</kbd>. Its aim is to tell the compiler that an additional static method needs to be generated for this function in order to make it available in Java as a direct static function of the outer class. For example, in our case, we are able to access the <kbd>processText()</kbd> function in Java in the following manner, by omitting the <kbd>Companion</kbd> element:</p>
<pre>ColoredText.processText("sample text")</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Kotlin and JavaScript interoperability</h1>
                
            
            
                
<p>In the following recipe, we are going to configure and implement a sample web app project in order to explore how Kotlin can be compiled to JavaScript. We are going to implement a simple web app that will open an alert dialog when the app starts. The following example is going to present a way of combining Kotlin and JavaScript code together and configuring a JavaScript compilation with the Gradle build script.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>In order to set up the project to compile Kotlin files into JavaScript, we need to add the following properties to the module-level Gradle build script. First, we need to apply the Kotlin2Js plugin. We can do it with the following declaration:</p>
<pre>apply plugin: "kotlin2js"</pre>
<p>At this point, whenever we execute the Gradle <kbd>build</kbd> task, the Kotlin2JS compiler is going to generate JavaScript code with the corresponding functions and classes from the Kotlin files and write them under the <kbd>build/classes/kotlin/</kbd> directory to the JS file named after the project name. However, we can modify this default behavior by specifying the output file parameter:</p>
<pre>compileKotlin2Js.kotlinOptions.outputFile = "${projectDir}/web/js/app.js"<br/></pre>
<p>As the result, the output of the Kotlin files' compilation will be available under <kbd>web/js directory</kbd>, in the <kbd>app.js</kbd> file.</p>
<p>However, in order to execute the translated Kotlin code, we need to link the Kotlin JS standard library to it as well. We can modify the Gradle build script to include the required libraries in the <kbd>web/js</kbd> output directory:</p>
<pre>build.doLast {<br/>    configurations.compile.each { File file -&gt;<br/>        copy {<br/>            includeEmptyDirs = false<br/><br/>            from zipTree(file.absolutePath)<br/>            into "${projectDir}/web/js/lib"<br/>            include { fileTreeElement -&gt;<br/>                def path = fileTreeElement.path<br/>                path.endsWith(".js") &amp;&amp; (path.startsWith("META-INF/resources/") || !path.startsWith("META-INF/"))<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p>You can examine the configuration of the Kotlin2JS plugin in the sample project: <a href="https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/tree/master/Kotlin-Samples-JS">https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/tree/master/Kotlin-Samples-JS</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a new kotlin file, <kbd>AlertDialogApp.kt</kbd>, that contains the <kbd>main()</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">fun main(args : Array&lt;String&gt;) {}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<ol start="2">
<li>Declare a reference to the JS <kbd>alert()</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">fun main(args : Array&lt;String&gt;) {}<br/><br/><strong>external fun alert(message: Any?): Unit</strong></pre>
<ol start="3">
<li>Implement the <kbd>showAlert()</kbd> function and invoke it in the <kbd>main()</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">fun main(args : Array&lt;String&gt;) {<br/>    <strong>showAlert()</strong><br/>}<br/><br/><strong>fun showAlert() {</strong><br/><strong>    val number: dynamic = js("Math.floor(Math.random() * 1000)")</strong><br/><strong>    val message = "There were $number viruses found on your computer! \uD83D\uDE31"<br/>    println("showing alert")</strong><br/><strong>    alert(message)</strong><br/><strong>}</strong><br/><br/>external fun alert(message: Any?): Unit</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As you can see, after running the Gradle build task, the <kbd>AlertDialogApp.kt</kbd> file is going to be translated into the <kbd>app.js</kbd> JavaScript code, available under the <kbd>web/js</kbd> directory, along with the <kbd>kotlin.js</kbd> file linked under the <kbd>web/js/lib</kbd> directory. </p>
<p>We can test the JS-generated code by running it in the web browser. In order to do so, we will create a sample HTML file under the project's main directory, named <kbd>test_app.html</kbd>, which is going to link the <kbd>kotlin.js</kbd> standard library file and run the <kbd>app.js</kbd> file that contains the <kbd>main()</kbd> function implementation generated from the <kbd>AlertDialogApp.kt</kbd> file:</p>
<pre>&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>&lt;head&gt;<br/>    &lt;meta charset="UTF-8"&gt;<br/>    &lt;title&gt;Test&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>    &lt;script src="img/kotlin.js"&gt;&lt;/script&gt;<br/>    &lt;script src="img/app.js"&gt;&lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>As the result, when we open the <kbd>test_app.html</kbd> file in a web browser, we are going to encounter the following pop-up dialog:</p>
<div><img src="img/5840543c-882b-48dd-ab51-02c17c8ac10d.png" style="width:32.58em;height:9.33em;"/></div>
<p>Inside the <kbd>showAlert()</kbd> function in the <kbd>AlertDialogApp.kt</kbd> file, we are using the JavaScript <kbd>Math.floor()</kbd> and <kbd>Math.random()</kbd> functions to generate a random integer value from 0-1,000. We are using the <kbd>js()</kbd> function available in the Kotlin standard library to inline JS code in the Kotlin code. As you can see, the result returned by <kbd>js()</kbd> is declared as a <kbd>dynamic</kbd> type.</p>
<p>The <kbd>dynamic</kbd> modifier is used to declare the dynamic type, which is characteristic for every JavaScript object. In Kotlin code, it can be used as an alternative to strongly-typed declarations. It makes sense to use it whenever we are dealing with third-party JS libraries that can return the results of not-specified types.</p>
<p>Next, we are using the random integer value generated using the JS-inlined code to compose the message that is going to be displayed. Finally, we are calling the JS <kbd>alert()</kbd> function and passing it the composed message. This time, we are using the <kbd>external</kbd> modifier, which tells the Kotlin compiler that the corresponding declaration is written in pure JavaScript and it should not generate the implementation for it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>You may wonder whether there is a practical solution to working with <kbd>npm</kbd> JS dependencies within a Gradle-based project. There is a solution that allows you to integrate your Kotlin project with <kbd>npm</kbd> dependencies easily, called the Kotlin Frontend Gradle plugin. You can learn more about it in the official project guide: <a href="https://github.com/Kotlin/kotlin-frontend-plugin">https://github.com/Kotlin/kotlin-frontend-plugin</a>.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Renaming generated functions</h1>
                
            
            
                
<p>In this recipe, we are going to learn how to modify a Kotlin function's name when it is being compiled to the generated JVM bytecode. We need this feature because of the type-erasure that happens when generating the JVM bytecode. However, thanks to the <kbd>@JvmName</kbd> annotation, we can declare a number of different functions, but that has the same name and use their original name in the Kotlin code while keeping their JVM bytecode names distinct to satisfy the compiler.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Declare two functions that have the same names:</li>
</ol>
<pre style="padding-left: 60px">fun List&lt;String&gt;.join(): String {<br/>    return joinToString()<br/>}<br/><br/>fun List&lt;Int&gt;.join(): String =<br/>    map { it.toString() }<br/>            .joinToString()    </pre>
<ol start="2">
<li>Mark the functions with the proper annotations:</li>
</ol>
<pre style="padding-left: 60px"><strong>@JvmName("joinStringList")</strong><br/>fun List&lt;String&gt;.join(): String {<br/>    return joinToString()<br/>}<br/><br/><strong>@JvmName("joinIntList")</strong><br/>fun List&lt;Int&gt;.join(): String =<br/>    map { it.toString() }<br/>            .joinToString()</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Thanks to providing the alternative function names, we were able to compile them to JVM bytecode. However, you can easily test that we can use their original names inside the Kotlin code. That's because the Kotlin compiler is able to recognize them correctly based on their return type and generic type argument value.</p>
<p class="mce-root"/>
<p>You can test this by running the <kbd>join()</kbd> function both on the list of integers and on the list of strings:</p>
<pre>fun main(vararg args: String) {<br/>    println(listOf(1, 2, 3).join())<br/>    println(listOf("a", "b", "c").join())<br/>}</pre>
<p>As the result, the preceding code will print the following text to the console:</p>
<pre><strong>1, 2, 3</strong><br/><strong>a, b, c</strong></pre>
<p>Keep in mind that, when you want to invoke those functions from Java, you will need to use their alternative names: <kbd>joinStringList()</kbd> and <kbd>joinIntList()</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>There is also a corresponding <kbd>@JsName</kbd> annotation, which allows you to change the name of JavaScript functions and classes. You can use it if you are compiling your Kotlin files to JavaScript using the Kotlin2JS plugin. If you'd like to get familiar with the basics of the Kotlin2JS plugin, you can examine the <em>Kotlin and JavaScript interoperability</em> recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>If you'd like to learn how to explore the final JVM bytecode generated from Kotlin files, read the <em>Decompiling Kotlin code to Java and JVM bytecode</em> recipe</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Decompiling Kotlin code to Java and JVM bytecode</h1>
                
            
            
                
<p>In this recipe, we are going to learn how to easily decompile our Kotlin files to see how their corresponding JVM bytecode is implemented and what the bytecode's corresponding Java implementation would look like. This can help you to discover how various Kotlin concepts were implemented under the hood. It can also be helpful for code-debugging and optimization.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Let's create a new Kotlin file, named <kbd>Recipe4.kt</kbd>, that contains the following sample implementation in order to see its bytecode translation:</p>
<pre>data class A(val a: String = "a") {<br/>    companion object {<br/>        @JvmStatic<br/>        fun foo(): String = "Wooo!"<br/>    }    <br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open the <kbd>Recipe4.kt</kbd> file in IntelliJ.</li>
<li>Choose the Show Kotlin Bytecode option from the Tools/Kotlin menu. The box will present the JVM bytecode implementation.</li>
<li>Click the Decompile button in the Kotlin Bytecode view. The corresponding Java implementation will be decompiled from the bytecode and will appear in the new window.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The task of analyzing the Java implementation generated for <kbd>data class A</kbd> is left as an exercise for the reader. You can experiment by removing the <kbd>data</kbd> modifier from the Kotlin class definition and observing the changes in the bytecode and the decompiled Java implementation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding custom names for imports</h1>
                
            
            
                
<p>In this recipe, we are going to explore how to add custom names to the <kbd>import</kbd> declarations. We are going to import the <kbd>java.lang.StringBuilder</kbd> class, add a custom name to it and make use of it in the sample code to demonstrate it in action. </p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li class="mce-root">Import the <kbd>StringBuilder</kbd> class with a custom alias:</li>
</ol>
<pre style="color: black;padding-left: 60px">import java.lang.StringBuilder as builder</pre>
<ol start="2">
<li>Use the custom <kbd>StringBuilder</kbd> name in the sample code:</li>
</ol>
<pre style="padding-left: 60px">import java.lang.StringBuilder as builder<br/><br/><strong>fun main(vararg args: String) {</strong><br/><strong>    val text = builder()</strong><br/><strong>            .append("Code is like humor. ")</strong><br/><strong>            .append("When you have to explain it, ")</strong><br/><strong>            .append("it’s bad.")</strong><br/><strong>            .toString()</strong><br/><strong>    println(text)</strong><br/><strong>}</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As you can see, we were able to use an alternative name instead of the <kbd>StringBuilder</kbd> class. It's a small feature but sometimes can be used to make your code easier to read. Our sample code is going to print the following text to the console:</p>
<pre><strong>Code is like humor. When you have to explain it, it’s bad.</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Wrapping complex type declarations with type aliases</h1>
                
            
            
                
<p>Sometimes we need to deal with long or verbose type declarations. Thankfully, in Kotlin, we are able to assign an alternative name to any existing type and use the shorter alternative name instead. It can also help you to write more understandable and elegant code. This recipe is going to demonstrate how to use type aliases. </p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Let's assume we have the following two classes predefined:</p>
<pre>data class Song(val title: String)<br/>data class Artist(val name: String)</pre>
<p>We are going to define a type alias for the map of <kbd>Song</kbd> type values and a generic key type–<kbd>Map&lt;T, List&lt;Song&gt;&gt;</kbd>. Next, we are going to use it to define a function that will return the most popular <kbd>Artist</kbd> instance for a given <kbd>Map&lt;Artist, List&lt;Song&gt;&gt;</kbd> object.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Declare a generic type alias for the <kbd>Map&lt;T, List&lt;Song&gt;&gt;</kbd> type:</li>
</ol>
<pre style="padding-left: 60px">typealias GrouppedSongs&lt;T&gt; = Map&lt;T, List&lt;Song&gt;&gt;</pre>
<ol start="2">
<li>Implement the <kbd>getMostPopularArtist()</kbd> function using the type alias:</li>
</ol>
<pre style="padding-left: 60px">fun getMostPopularArtist(songs: GrouppedSongs&lt;Artist&gt;) =<br/>    songs.toList().sortedByDescending {it.second.size }.first().first</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Using the type alias, we were able to provide a custom name for the type and we could use it in <kbd>getMostPopularArtist(songs: GrouppedSongs&lt;Artist&gt;)</kbd> instead of <kbd>Map&lt;Artist, List&lt;Song&gt;&gt; type</kbd>, which resulted in a more meaningful declaration. We can test our implementation by invoking <kbd>getMostPopularArtist()</kbd> with sample data:</p>
<pre>val songs: GrouppedSongs&lt;Artist&gt; =<br/>        mapOf(<br/>                Artist("Bob Dylan") to<br/>                        listOf(Song("Blowing In The Wind"),<br/>                               Song("To Fall in Love With You")),<br/><br/>                Artist("Louis Armstrong") to<br/>                        listOf(Song("What A Beautiful World"))<br/>        )<br/><br/>println("${getMostPopularArtist(songs)} is the most popular")</pre>
<p class="mce-root"/>
<p>As a result, we are going to get the following text printed to the console:</p>
<pre><strong>Artist(name=Bob Dylan) is most popular</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Expressive try…catch declarations</h1>
                
            
            
                
<p>Kotlin is advertised as an extremely expressive language. However, it's one of the characteristics of the language that is not obvious in the beginning, especially if you are used to other languages such as Java or JavaScript. In order to present the language style more clearly, in this recipe, we are going to discover how to work with the <kbd>try…catch</kbd> declaration in a Kotlin way, by treating it as an expression.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Let's consider the following Java code:</p>
<pre>int value;<br/>try {<br/>    result = parseInt(input);<br/>} catch (NumberFormatException e) {<br/>} finally {<br/>    result = 0;<br/>}</pre>
<p>It declares an int <kbd>result</kbd> variable. Next, it tries to parse the string value to the integer with the <kbd>Integer.parseInt()</kbd> function, and if it succeeds, it assigns the result to the <kbd>value</kbd> variable. If the <kbd>parseInt()</kbd> fails to parse the string, a default value of <kbd>0</kbd> is assigned to the <kbd>value</kbd> variable.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Invoke the <kbd>parseInt()</kbd> function in the <kbd>try…catch</kbd> declaration:</li>
</ol>
<pre style="padding-left: 60px">try {<br/>    parseInt("fdsaa")<br/>} catch (e: NumberFormatException) {<br/>    0<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="2">
<li>Assign the result of the <kbd>try…catch</kbd> declaration to the <kbd>value</kbd> variable:</li>
</ol>
<pre style="padding-left: 60px">val result = try {<br/>    parseInt("fdsaa")<br/>} catch (e: NumberFormatException) {<br/>    0<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>That's it. The <kbd>try…catch</kbd> declaration in Kotlin can be assigned to a variable. The reason is that it is, in fact, an expression!  In our example, <kbd>try…catch</kbd> returns the result of the <kbd>parseInt()</kbd> function, and when the function throws an exception, it returns <kbd>0</kbd>. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Similarly, we can treat other language declarations as expressions. It's a common practice to assign a variable to the value returned by control flow statements, such as <kbd>if</kbd> and <kbd>when</kbd>. For example, we can use <kbd>when</kbd> as an expression in the following way:</p>
<pre>val result = when(input) {<br/>    is Int -&gt; input<br/>    is String -&gt; parseInt(input)<br/>    else -&gt; 0<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Safe type-casting </h1>
                
            
            
                
<p>Whenever we perform type-casting, we should keep in mind that it is a potential source of exceptions. That's the reason why we should always perform type-checking using the <kbd>is</kbd> modifier or do the casting inside the <kbd>try…catch</kbd> block. However, in Kotlin, we have also a safe casting option that will not throw <kbd>ClassCastException</kbd> but will return <kbd>null</kbd> instead. In this recipe, we are going to test the safe casting in action.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Let's start by defining a function that returns a <kbd>Number</kbd> type of a random <kbd>Double</kbd> value:</li>
</ol>
<pre style="padding-left: 60px">fun getRandomNumber(): Number = Random().nextDouble() * 10</pre>
<ol start="2">
<li>Try to cast the results of the function to different types using the safe-cast operator and print the casted values to the console:</li>
</ol>
<pre style="padding-left: 60px">println(getRandomNumber() as? Int)<br/>println(getRandomNumber() as? Double)<br/>println(getRandomNumber() as? String)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The preceding code will not fail nor throw any exceptions. It will just return the <kbd>null</kbd> value instead. Our casting test code is going to print the following output to the console:</p>
<pre><strong>null</strong><br/><strong>8.802117014997226</strong><br/><strong>null</strong></pre>
<p>Using the safe <kbd>as?</kbd> casting modifier is a neat alternative to the traditional way. You can use it if you are working with nullable types, that is while working with external libraries that don't provide the null safety. However, if you can benefit from the null safety, it's best to use the standard casting operation.</p>


            

            
        
    </body></html>