["```kt\nfun divide(num: Int, den: Int): Int? {\n    return if (num % den != 0) {\n        null\n    } else {\n        num / den\n    }\n}\n\nfun division(a: Int, b: Int, den: Int): Pair<Int, Int>? {\n    val aDiv = divide(a, den)\n    return when (aDiv) {\n        is Int -> {\n            val bDiv = divide(b, den)\n            when (bDiv) {\n                is Int -> aDiv to bDiv\n                else -> null\n            }\n        }\n        else -> null\n    }\n}\n```", "```kt\nimport arrow.core.*\nimport arrow.syntax.option.toOption\n\nfun optionDivide(num: Int, den: Int): Option<Int> = divide(num, den).toOption()\n\nfun optionDivision(a: Int, b: Int, den: Int): Option<Pair<Int, Int>> {\n   val aDiv = optionDivide(a, den)\n   return when (aDiv) {\n      is Some -> {\n         val bDiv = optionDivide(b, den)\n         when (bDiv) {\n            is Some -> Some(aDiv.t to bDiv.t)\n            else -> None\n         }\n      }\n      else -> None\n   }\n}\n```", "```kt\nfun flatMapDivision(a: Int, b: Int, den: Int): Option<Pair<Int, Int>> {\n   return optionDivide(a, den).flatMap { aDiv: Int ->\n      optionDivide(b, den).flatMap { bDiv: Int ->\n         Some(aDiv to bDiv)\n      }\n   }\n}\n```", "```kt\nimport arrow.typeclasses.binding\n\nfun comprehensionDivision(a: Int, b: Int, den: Int): Option<Pair<Int, Int>> {\n   return Option.monad().binding {\n      val aDiv: Int = optionDivide(a, den).bind()\n      val bDiv: Int = optionDivide(b, den).bind()\n      aDiv to bDiv\n   }.ev()\n}\n```", "```kt\nfun comprehensionDivision(a: Int, b: Int, den: Int): Option<Pair<Int, Int>> {\n   return Option.monad().binding {\n      val aDiv: Int = optionDivide(a, den).bind()\n      // start continuation 1\n         val bDiv: Int = optionDivide(b, den).bind()\n          //start continuation 2\n            aDiv to bDiv\n         //end continuation 2\n // end continuation 1\n   }.ev()\n}\n```", "```kt\nclass MyClass<T>() //Valid Kotlin code\n\nclass MyHigherKindedClass<K<T>>() //Not valid kotlin code\n```", "```kt\npackage arrow.core\n\nimport arrow.higherkind\nimport java.util.*\n\n/**\n * Represents optional values. Instances of `Option`\n * are either an instance of $some or the object $none.\n */\n@higherkind\nsealed class Option<out A> : OptionKind<A> {\n  //more code goes here\n\n```", "```kt\npackage arrow.core\n\nclass OptionHK private constructor()\ntypealias OptionKind<A> = arrow.HK<OptionHK, A>\n\n@Suppress(\"UNCHECKED_CAST\", \"NOTHING_TO_INLINE\")\ninline fun <A> OptionKind<A>.ev(): Option<A> =\n  this as Option<A>\n```", "```kt\npackage arrow\n\ninterface HK<out F, out A>\n\ntypealias HK2<F, A, B> = HK<HK<F, A>, B>\n\ntypealias HK3<F, A, B, C> = HK<HK2<F, A, B>, C>\n\ntypealias HK4<F, A, B, C, D> = HK<HK3<F, A, B, C>, D>\n\ntypealias HK5<F, A, B, C, D, E> = HK<HK4<F, A, B, C, D>, E>\n\n```", "```kt\npackage arrow.typeclasses\n\nimport arrow.*\n\n@typeclass\ninterface Functor<F> : TC {\n\n    fun <A, B> map(fa: HK<F, A>, f: (A) -> B): HK<F, B>\n\n}\n\n```", "```kt\nimport arrow.higherkind\n\n@higherkind\nclass Mappable<T>(val t: T) : MappableKind<T> {\n   fun <R> map(f: (T) -> R): Mappable<R> = Mappable(f(t))\n\n   override fun toString(): String = \"Mappable(t=$t)\"\n\n   companion object\n}\n```", "```kt\nimport arrow.instance\nimport arrow.typeclasses.Functor\n\n@instance(Mappable::class)\ninterface MappableFunctorInstance : Functor<MappableHK> {\n   override fun <A, B> map(fa: MappableKind<A>, f: (A) -> B): Mappable<B> {\n      return fa.ev().map(f)\n   }\n}\n```", "```kt\nimport arrow.deriving \n\n@higherkind\n@deriving(Functor::class)\nclass DerivedMappable<T>(val t: T) : DerivedMappableKind<T> {\n   fun <R> map(f: (T) -> R): DerivedMappable<R> = DerivedMappable(f(t))\n\n   override fun toString(): String = \"DerivedMappable(t=$t)\"\n\n   companion object\n}\n```", "```kt\nimport arrow.typeclasses.functor\n\ninline fun <reified F> buildBicycle(mapper: HK<F, Int>,\n                           noinline f: (Int) -> Bicycle,\n                           FR: Functor<F> = functor()): HK<F, Bicycle> = FR.map(mapper, f)\n```", "```kt\nfun main(args: Array<String>) {\n\n   val mappable: Mappable<Bicycle> = buildBicycle(Mappable(3), ::Bicycle).ev()\n   println(\"mappable = $mappable\") //Mappable(t=Bicycle(gears=3))\n\n   val option: Option<Bicycle> = buildBicycle(Some(2), ::Bicycle).ev()\n   println(\"option = $option\") //Some(Bicycle(gears=2))\n\n   val none: Option<Bicycle> = buildBicycle(None, ::Bicycle).ev()\n   println(\"none = $none\") //None\n\n}\n```", "```kt\n@higherkind\nclass NotAFunctor<T>(val t: T) : NotAFunctorKind<T> {\n   fun <R> map(f: (T) -> R): NotAFunctor<R> = NotAFunctor(f(t))\n\n   override fun toString(): String = \"NotAFunctor(t=$t)\"\n}\n```", "```kt\nfun main(args: Array<String>) {\n\n   val not: NotAFunctor<Bicycle> = buildBicycle(NotAFunctor(4), ::Bicycle).ev()\n   println(\"not = $not\")\n\n}\n```", "```kt\nimport arrow.core.Either\nimport arrow.core.Either.Right\nimport arrow.core.Either.Left\n\nfun eitherDivide(num: Int, den: Int): Either<String, Int> {\n   val option = optionDivide(num, den)\n   return when (option) {\n      is Some -> Right(option.t)\n      None -> Left(\"$num isn't divisible by $den\")\n   }\n}\n```", "```kt\nimport arrow.core.Tuple2\n\nfun eitherDivision(a: Int, b: Int, den: Int): Either<String, Tuple2<Int, Int>> {\n   val aDiv = eitherDivide(a, den)\n   return when (aDiv) {\n      is Right -> {\n         val bDiv = eitherDivide(b, den)\n         when (bDiv) {\n            is Right -> Right(aDiv.getOrElse { 0 } toT bDiv.getOrElse { 0 })\n            is Left -> bDiv as Either<String, Nothing>\n         }\n      }\n      is Left -> aDiv as Either<String, Nothing>\n   }\n}\n```", "```kt\nfun flatMapEitherDivision(a: Int, b: Int, den: Int): Either<String, Tuple2<Int, Int>> {\n   return eitherDivide(a, den).flatMap { aDiv ->\n      eitherDivide(b, den).flatMap { bDiv ->\n         Right(aDiv toT bDiv)\n      }\n   }\n}\n```", "```kt\nfun comprehensionEitherDivision(a: Int, b: Int, den: Int): Either<String, Tuple2<Int, Int>> {\n   return Either.monad<String>().binding {\n      val aDiv = eitherDivide(a, den).bind()\n      val bDiv = eitherDivide(b, den).bind()\n\n      aDiv toT bDiv\n   }.ev()\n```", "```kt\nfun main(args: Array<String>) {\n   eitherDivision(3, 2, 4).fold(::println, ::println) //3 isn't divisible by 4\n}\n\n```", "```kt\nobject UserService {\n\n   fun findAge(user: String): Either<String, Option<Int>> {\n       //Magic  \n   }\n}\n```", "```kt\nimport arrow.core.*\nimport arrow.syntax.function.pipe\n\nfun main(args: Array<String>) {\n val anakinAge: Either<String, Option<Int>> = UserService.findAge(\"Anakin\")\n\n anakinAge.fold(::identity, { op ->\n         op.fold({ \"Not found\" }, Int::toString)\n     }) pipe ::println \n}\n```", "```kt\nimport arrow.core.*\nimport arrow.syntax.function.pipe\nimport kotlin.math.absoluteValue\n\nfun main(args: Array<String>) {\n   val anakinAge: Either<String, Option<Int>> = UserService.findAge(\"Anakin\")\n   val padmeAge: Either<String, Option<Int>> = UserService.findAge(\"Padme\")\n\n   val difference: Either<String, Option<Either<String, Option<Int>>>> = anakinAge.map { aOp ->\n      aOp.map { a ->\n         padmeAge.map { pOp ->\n            pOp.map { p ->\n               (a - p).absoluteValue\n            }\n         }\n      }\n   }\n\n   difference.fold(::identity, { op1 ->\n      op1.fold({ \"Not Found\" }, { either ->\n         either.fold(::identity, { op2 -> \n            op2.fold({ \"Not Found\" }, Int::toString) })\n      })\n   }) pipe ::println\n}\n```", "```kt\nimport arrow.core.*\nimport arrow.syntax.function.pipe\nimport arrow.typeclasses.binding\nimport kotlin.math.absoluteValue\n\nfun main(args: Array<String>) {\n   val anakinAge: Either<String, Option<Int>> = UserService.findAge(\"Anakin\")\n   val padmeAge: Either<String, Option<Int>> = UserService.findAge(\"Padme\")\n\n   val difference: Either<String, Option<Option<Int>>> = Either.monad<String>().binding {\n      val aOp: Option<Int> = anakinAge.bind()\n      val pOp: Option<Int> = padmeAge.bind()\n      aOp.map { a ->\n         pOp.map { p ->\n            (a - p).absoluteValue\n         }\n      }\n   }.ev()\n\n   difference.fold(::identity, { op1 ->\n      op1.fold({ \"Not found\" }, { op2 ->\n         op2.fold({ \"Not found\" }, Int::toString) }) }) pipe ::println\n}\n```", "```kt\nfun main(args: Array<String>) {\n   val anakinAge: Either<String, Option<Int>> = UserService.findAge(\"Anakin\")\n   val padmeAge:  Either<String, Option<Int>> = UserService.findAge(\"Padme\")\n\n   val difference: Either<String, Option<Int>> = Either.monad<String>().binding {\n      val aOp: Option<Int> = anakinAge.bind()\n      val pOp: Option<Int> = padmeAge.bind()\n      Option.monad().binding {\n         val a: Int = aOp.bind()\n         val p: Int = pOp.bind()\n         (a - p).absoluteValue\n      }.ev()\n   }.ev()\n\n   difference.fold(::identity, { op ->\n      op.fold({ \"Not found\" }, Int::toString)\n   }) pipe ::println\n}\n```", "```kt\nimport arrow.core.*\nimport arrow.data.OptionT\nimport arrow.data.monad\nimport arrow.data.value\nimport arrow.syntax.function.pipe\nimport arrow.typeclasses.binding\nimport kotlin.math.absoluteValue\n\nfun main(args: Array<String>) {\n   val anakinAge: Either<String, Option<Int>> = UserService.findAge(\"Anakin\")\n   val padmeAge: Either<String, Option<Int>> = UserService.findAge(\"Padme\")\n\n   val difference: Either<String, Option<Int>> = OptionT.monad<EitherKindPartial<String>>().binding {\n      val a: Int = OptionT(anakinAge).bind()\n      val p: Int = OptionT(padmeAge).bind()\n      (a - p).absoluteValue\n   }.value().ev()\n\n   difference.fold(::identity, { op ->\n      op.fold({ \"Not found\" }, Int::toString)\n   }) pipe ::println\n}\n```", "```kt\nimport arrow.data.Try\n\nfun tryDivide(num: Int, den: Int): Try<Int> = Try { divide(num, den)!! }\n```", "```kt\nfun tryDivision(a: Int, b: Int, den: Int): Try<Tuple2<Int, Int>> {\n   val aDiv = tryDivide(a, den)\n   return when (aDiv) {\n      is Success -> {\n         val bDiv = tryDivide(b, den)\n         when (bDiv) {\n            is Success -> {\n               Try { aDiv.value toT bDiv.value }\n            }\n            is Failure -> Failure(bDiv.exception)\n         }\n      }\n      is Failure -> Failure(aDiv.exception)\n   }\n}\n```", "```kt\nfun flatMapTryDivision(a: Int, b: Int, den: Int): Try<Tuple2<Int, Int>> {\n   return tryDivide(a, den).flatMap { aDiv ->\n      tryDivide(b, den).flatMap { bDiv ->\n         Try { aDiv toT bDiv }\n      }\n   }\n}\n```", "```kt\nfun comprehensionTryDivision(a: Int, b: Int, den: Int): Try<Tuple2<Int, Int>> {\n   return Try.monad().binding {\n      val aDiv = tryDivide(a, den).bind()\n      val bDiv = tryDivide(b, den).bind()\n      aDiv toT bDiv\n   }.ev()\n}\n```", "```kt\nfun monadErrorTryDivision(a: Int, b: Int, den: Int): Try<Tuple2<Int, Int>> {\n   return Try.monadError().bindingCatch {\n      val aDiv = divide(a, den)!!\n      val bDiv = divide(b, den)!!\n      aDiv toT bDiv\n   }.ev()\n}\n```", "```kt\nimport arrow.core.Tuple2\nimport arrow.core.toT\nimport arrow.data.State\n\ntypealias PriceLog = MutableList<Tuple2<String, Double>>\n\nfun addVat(): State<PriceLog, Unit> = State { log: PriceLog ->\n    val (_, price) = log.last()\n    val vat = price * 0.2\n    log.add(\"Add VAT: $vat\" toT price + vat)\n    log toT Unit\n}\n```", "```kt\nfun applyDiscount(threshold: Double, discount: Double): State<PriceLog, Unit> = State { log ->\n    val (_, price) = log.last()\n    if (price > threshold) {\n        log.add(\"Applying -$discount\" toT price - discount)\n    } else {\n        log.add(\"No discount applied\" toT price)\n    }\n    log toT Unit\n}\n```", "```kt\nfun finalPrice(): State<PriceLog, Double> = State { log ->\n    val (_, price) = log.last()\n    log.add(\"Final Price\" toT price)\n    log toT price\n}\n```", "```kt\nimport arrow.data.ev\nimport arrow.instances.monad\nimport arrow.typeclasses.binding\n\nfun calculatePrice(threshold: Double, discount: Double) = State().monad<PriceLog>().binding {\n    addVat().bind() //Unit\n    applyDiscount(threshold, discount).bind() //Unit\n    val price: Double = finalPrice().bind()\n    price\n}.ev()\n```", "```kt\nimport arrow.data.run\nimport arrow.data.runA\n\nfun main(args: Array<String>) {\n    val (history: PriceLog, price: Double) = calculatePrice(100.0, 2.0).run(mutableListOf(\"Init\" toT 15.0))\n    println(\"Price: $price\")\n    println(\"::History::\")\n    history\n            .map { (text, value) -> \"$text\\t|\\t$value\" }\n            .forEach(::println)\n\n    val bigPrice: Double = calculatePrice(100.0, 2.0).runA(mutableListOf(\"Init\" toT 1000.0))\n    println(\"bigPrice = $bigPrice\")\n}\n```", "```kt\nfun <T, S> unfold(s: S, f: (S) -> Pair<T, S>?): Sequence<T> {\n   val result = f(s)\n   return if (result != null) {\n      sequenceOf(result.first) + unfold(result.second, f)\n   } else {\n      sequenceOf()\n   }\n}\n```", "```kt\nfun <T, S> unfold(s: S, state: State<S, Option<T>>): Sequence<T> {\n    val (actualState: S, value: Option<T>) = state.run(s)\n    return value.fold(\n            { sequenceOf() },\n            { t ->\n                sequenceOf(t) + unfold(actualState, state)\n            })\n}\n```", "```kt\nfun factorial(size: Int): Sequence<Long> {\n   return sequenceOf(1L) + unfold(1L to 1) { (acc, n) ->\n      if (size > n) {\n         val x = n * acc\n         (x) to (x to n + 1)\n      } else\n         null\n   }\n}\n```", "```kt\nimport arrow.syntax.option.some\n\nfun factorial(size: Int): Sequence<Long> {\n    return sequenceOf(1L) + unfold(1L toT 1, State { (acc, n) ->\n        if (size > n) {\n            val x = n * acc\n            (x toT n + 1) toT x.some()\n        } else {\n            (0L toT 0) toT None\n        }\n    })\n}\n```", "```kt\nfun fib(size: Int): Sequence<Long> {\n   return sequenceOf(1L) + unfold(Triple(0L, 1L, 1)) { (cur, next, n) ->\n      if (size > n) {\n         val x = cur + next\n         (x) to Triple(next, x, n + 1)\n      }\n      else\n         null\n   }\n}\n\n```", "```kt\nimport arrow.syntax.tuples.plus\n\nfun fib(size: Int): Sequence<Long> {\n    return sequenceOf(1L) + unfold((0L toT 1L) + 1, State { (cur, next, n) ->\n        if (size > n) {\n            val x = cur + next\n            ((next toT x) + (n + 1)) toT x.some()\n        } else {\n            ((0L toT 0L) + 0) toT None\n        }\n    })\n}\n```", "```kt\nfun main(args: Array<String>) {\n    factorial(10).forEach(::println)\n    fib(10).forEach(::println)\n}\n```"]