- en: Chapter 9. Performance Enhancement and Extras
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed about adding multiple levels in our game;
    adding multiple levels in a game is a normal functionality in most games. We also
    added the functionality to show the current level of the game by using a level
    label. Apart from this, we added a pause button and the button to access the node
    menu scene from the main menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is one of the most essential chapters in this book; here we are
    going to discuss about performance enhancement tips and tricks. Apart from this,
    we are going to add some really important features in our game. These features
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: The scoring system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sound
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The running animation of the player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sound is an essential part of a game; it greatly enhances the overall gameplay
    experience for the player. The scoring system helps the player to measure his
    or her performance over time. Running texture produces a good animation effect
    in the game, which increases the gameplay experience a lot. We are going to add
    all of these features in this current chapter, along with discussing about some
    of the important performance enhancement techniques for a Sprite Kit game.
  prefs: []
  type: TYPE_NORMAL
- en: Performance enhancement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Running a game requires extensive usage of memory and other resources of the
    device. This leads to accelerated drainage of the battery. We need to optimize
    the usage of the device resources for games. A game requires higher frames per
    second, hence more battery drainage occurs due to the excessive usage of the device
    resources. An optimized game will lead to efficient use of the device resources,
    hence less battery drainage. Following are listed some of the best practices to
    optimize the efficiency of a game:'
  prefs: []
  type: TYPE_NORMAL
- en: Systemizing a game's content in the scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the drawing performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving performance with `SKAction` and constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the physics performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the shapes performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the effects performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the lighting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we are going to discuss each of the previously listed methods in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Systemizing a game's content in the scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we know, scenes are the elementary building blocks in a Sprite Kit game.
    A game can contain multiple scenes according to the requirements. A scene can
    contain multiple nodes, where the nodes can perform particular actions. We have
    a clear idea of how to create scenes, nodes, and actions for nodes. The challenging
    task is designing the game's scene and transition in such a way that it should
    not lower the game's performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing that should be kept in mind is that the scenes do not have a default
    behavior, as the storyboards do in traditional iOS app. Instead, we define and
    implement the behaviors for respective scenes, which may include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: When to create new scenes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the content of the scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining when the transitions between the scenes should occur
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the visual effect for transition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining how the data is transferred from one scene to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance enhancement by preloading textures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is one of the most powerful ways of increasing the performance of a game.
    Sprite Kit provides two methods for the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '`func preloadWithCompletionHandler(completionHandler: () -> Void)`: This method
    uses a function that is responsible for loading the atlas textures into memory,
    which requires the parameter, `completionHandler`, which is called after the task
    is completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func preloadTextureAtlases(textureAtlases: [AnyObject]!,`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`withCompletionHandler completionHandler: (() -> Void)!)`: This method loads
    the textures of multiple atlases into memory and calls a completion handler after
    the task is completed. The completion handler expects two parameters: one is `textureAtlases`,
    which is an array of the `SKTextureAtlas` objects, and the second parameter is
    `completionHandler`, which is a block called after the texture atlases are loaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using texture atlases will reduce draw call, subsequently reducing the usage
    of the device resources. As of now, we have discussed some of the important techniques
    of performance enhancement in a game. Now, it is time to discuss about some essential
    elements of the game, such as scoring system, sounds, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the drawing performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The biggest part of building a node tree is organizing the graphical content
    that needs to be drawn. We should take care of what needs to drawn first and what
    should be drawn in the end. There are two factors which influence the drawing
    performance:'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing order, by which the graphics are submitted to the engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing of resources to accomplish the drawing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With respect to drawing order, you can set the sibling order of the node tree
    to reduce the number of drawings submitted by ignoring the sibling order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can use depth order as the rule to batch them together, and texture maps
    to optimize the batching further.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure to turn on the performance metrics, such as **frames per second**
    (**FPS**), node count, draw count, and quad count. These metrics will help you
    determine the performance of a game. Following are the codes that we can use to
    view the performance metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In reference to the preceding code block, let''s discuss each of the metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: In code `#1`, we are displaying the number of frames per second in the game
    scene. The optimum FPS for a game is `60`. By displaying the FPS in the game,
    it becomes easy to measure the FPS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In code `#2`, we are displaying the number of `SKNodes` in a scene. The lesser
    nodes we have in a scene, the better it performs. A game needs to have nodes in
    order to have elements in the game, but we can measure the FPS and nodes together
    to make sure how many nodes are producing the optimum FPS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In code `#3`, we are displaying the number of batches for the scene count, that
    is, how many batches the scene is going to draw. The lesser draws your game has,
    the better it performs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In code `#4`, we are displaying the quad count. Sprite Kit converts the node
    tree into rendered passes. Each of these rendering passes is rendered using quads.
    The lower the number of quads we have, the better the game performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving performance with SKActions and constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main solution factor to increase the performance is by building the action
    once and using it for the maximum number of times possible. Try to avoid the custom
    animation code from the `update()` method. By using the `SKAction` and `SKConstraint`
    classes, you can optimize the animation effects in a game.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the physics performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever `SKScene` computes a new frame of animation, it simulates the effects
    of forces and collisions on physics bodies connected to the node tree. It computes
    a final position, orientation, and velocity for each physics body.
  prefs: []
  type: TYPE_NORMAL
- en: With respect to improving the performance of the game, the dynamic objects cost
    more than static objects, so if possible, we can set the following property, so
    that the performance will be increased gradually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some guidelines for this are:'
  prefs: []
  type: TYPE_NORMAL
- en: You should use collision masks to group objects for performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use force fields to replace game logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should turn on field debug drawing, if needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before assigning a specified boundary to a physics body, you must consider the
    most efficient shape for your object. The shape of the boundary defines the number
    of calculations/operations required to be performed by the device, costing efficiency.
    The **Circle** is the cheapest, followed by the **Rectangle**, **Polygon**, **Compound**,
    and **Alpha Mask** bodies in the order of increasing cost of computation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Improving the physics performance](img/4201_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The computation cost scale for different shapes of boundaries
  prefs: []
  type: TYPE_NORMAL
- en: Improving shape's performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The shape of an object node plays an important role with respect to game performance.
    Where the performance will be increased if the node requires a lesser number of
    computations.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way as described in the physics performance topic, you can improve
    the efficiency cost of shape nodes. The polygon is the cheapest in terms of performance
    cost, followed by curves, linear stroke, stroked curve, and filled curve in the
    order of increasing costs of computation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Improving shape''s performance](img/4201_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The performance cost scale for shape nodes
  prefs: []
  type: TYPE_NORMAL
- en: Improving effect's performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With respect to effects in Sprite Kit, `SKEffectNodes` are expensive, hence,
    use it sparingly. It does its rendering off-screen and transfers to framebuffer,
    reducing efficiency. It is better to use `SKShaders` when no off-screen pass is
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: If the effects do not change much, it is better to rasterize such effects by
    using the `shouldRasterize` property. If the `shouldRastertize` property is `true`,
    the effect node caches the image for use in future frames.
  prefs: []
  type: TYPE_NORMAL
- en: Improving lighting performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lighting is computed on a per pixel basis, hence the computation cost is proportional
    to the amount of pixels lit. Ambient light does not cost in terms of computation
    power. Computation cost of shadows is proportional to the number of lights, hence
    it is advised to keep the number of shadows low.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring performance with instruments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instruments is a performance measuring and testing tool provided by Apple in
    Xcode for the tracing and profiling of code. Instruments help in analyzing the
    performance of code. There are lot of instruments that can be used for checking
    performance issues, memory leaks, or other problems.
  prefs: []
  type: TYPE_NORMAL
- en: Once any issue gets identified, it becomes easy to rectify the issue. You can
    also see how much our game caches, and based on that, make a decision about the
    assets in the game.
  prefs: []
  type: TYPE_NORMAL
- en: You can access the instruments by navigating to **Xcode** | **Open Developer
    Tool** | **Instruments**. Then, you can choose the appropriate instrument to move
    with. It is better to have a look at the analysis in the initial phase of the
    development process, by this, you can easily understand which inclusion in the
    code was responsible for the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instruments provide you with a list of trace templates. Trace templates are
    groups of preconfigured instruments. Let''s discuss each of the trace templates
    in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Measuring performance with instruments](img/4201_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Activity Monitor**: The **Activity Monitor** is used to monitor the CPU,
    memory, disk, and network usage statistics processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Allocations**: The allocation tool is used to track a process''s anonymous
    virtual memory and heap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This tool also provides the class names and optionally retained/released histories
    for objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Automation**: The automation template executes a script that simulates the
    UI interaction for an iOS application, which is launched from the instruments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cocoa Layout**: The **Cocoa Layout** observes the changes to the `NSLayoutConstraint`
    objects to help in determining when and where a layout constraint went away.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Core Animation**: The **Core Animation** instrument measures application
    graphics performance as well as CPU usage of a process, via time profiling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Core Data**: This instrument template traces the **Core Data** filesystem
    activity, including fetches, cache misses, and saved caches too. This was discussed
    in [Chapter 8](ch08.html "Chapter 8. Handling Multiple Scenes and Levels"), *Handling
    Multiple Scenes and Levels*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Counters**: The **Counters** will collect the **performance monitor counter**
    (**PMC**) events, using time or event-based sampling methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dispatch**: This template will monitor the dispatch queue activity, and record
    block invocations and their durations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Energy Diagnostics**: This template will provide the diagnostics regarding
    energy usage as well as the basic ON/OFF state of major device components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File Activity**: This will monitor the file and directory activity, including
    the file OPEN/CLOSE calls, file permission modifications, directory creation,
    file moves, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GPU Driver**: This template is used to measure the GPU driver statistics
    and it also samples active CPU usage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Leaks**: The **Leaks** will measure the general memory usage; it periodically
    scans if an object is created and not accessed and detects the resulting memory
    loss.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network**: The **Network** analyses, how your applications are using the
    TCP/IP and UDP/IP connections, using the connections instrument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenGL ES Analysis**: This template measures and analyses openGL ES activity
    to detect openGL ES precision and performance problems. It also offers recommendations
    for addressing these problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sudden Termination**: The **Sudden Termination** is used to analyze the sudden
    termination support of a target process, reporting back traces of file system
    accesses and sudden termination enabled/disabled calls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System Trace**: This instrument provides system information such as process
    name, number of threads generated, CPU usage by each thread, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System Usage**: This template is used to record the I/O system activity related
    to files, sockets, and shared memory for a single process launched via instruments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time Profiler**: The **Time Profiler** is used to perform the low-overhead
    time-based sampling, where we can check the status of the processes that are running
    on the system CPUs. Profiling is a means of measuring, by which the output of
    a profiling session gives you an insight on what parts of your code are used most
    often, and tells you which part of the code can be improved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zombies**: If a game has removed an object, but at a later stage tries to
    access that object, it will crash the game. The Zombies instrument keeps removed
    objects as dead, and later on releases it whenever called by the game, hence,
    avoiding a crash. This way, the Zombies instrument points out where the game may
    crash. A debugger cannot pin-point this anomaly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A scoring system in a game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding a scoring or points system in a game makes it more interesting and fun
    to play. Having a scoring system in the game makes it easier for the players to
    measure their performance, making the objective clear for the user.
  prefs: []
  type: TYPE_NORMAL
- en: It always makes sense to display the score somewhere on the main screen, so
    that the player can have a look at the score while playing the game.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a scoring system in our Platformer game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first step of adding a scoring system in our game, we create a label
    node to display the score to the player. The initial variable will be zero.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Score label
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s add the following code snippet in the beginning of the `GameScene` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you are creating an `SKLabelNode` and assigning it to
    the font, `Chalkduster`. Along with this, you are also initializing a variable
    `score` with the value as zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s set the `ScoreText` label created above zero. Also, we can set
    the size and position of the font in an `addScoreLabel()` method and we can call
    this from `didMoveToView()` of `GameScene`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will define the score text to **Score: 0** and the font
    size to `30`. Along with this, we have also defined the position of the `scoreText`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is how the game screen will look after implementing the **Score**
    label:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the Score label](img/4201_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Incrementing the score when required
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to define when we have to increment the score in our game. The
    same should also be displayed in the `scoreText` label we have created.
  prefs: []
  type: TYPE_NORMAL
- en: As our *Platformer* game deals with blocks, which act as an obstacle, it is
    better to reward points to the player when he jumps over a block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following lines of code in the `blockrunner()` method with the condition
    that the blocks should successfully cross the player''s *X* position without colliding
    with him (the first `else` condition):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to save the highest score and the user''s name, we will use a special
    facility provided by iOS to save frequently required data via `NSUserDefaults`,
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is to be added just before the end of the `if` statement,
    `blockStatus.isRunning`. The code will successfully increment score. Now, it is
    time to save the high score.
  prefs: []
  type: TYPE_NORMAL
- en: Saving the high score
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will add a popup screen to save the high score when the user scores a high
    score. To make this happen, firstly, we have to create a new scene, `ScoreList.swift`,
    and call this scene when the player is out, that is, when the game is over.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `didBeginContact()` method, we have the following code line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the preceding lines with the following ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The new lines add the `ScoreList` scene when the player dies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create a new method called `gotoSavePlayerScreen()`, to check
    if the current score is greater than the saved score. Then, the `ScoreList` scene
    should be called, or else the main screen, that is, the `MainMenu` scene. The
    code for the same is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have implemented the method to select the scene to open after game completion.
    Now, let's construct the `ScoreList` scene.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the scene to save the high score
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's create the `ScoreList` scene to display a popup for saving the highest
    score.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, add a label to congratulate the user. Following is the code for same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to add a **CANCEL** button if the user doesn''t want to save the
    score with a name. Add the following code from the `didMoveToView()` method of
    `ScoreList.swift`, where the **CANCEL** button will take you to `MenuScene`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code adds a cancel button in blue color, and tapping on this
    button takes the player to the `MenuScene`. Now, to handle the tapping on the
    **CANCEL** button, add the following code within touches loop, inside the `touchesBegan()`
    method of `ScoreList.swift`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The score list will have been successfully created. We have also added a cancel
    button for the convenience of the user. Now, it is time to add a textbox in which
    the player will add his/her name.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a textbox to save player name
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to display a textbox for the user to enter the player name that is
    to be saved. Add the following code line to insert a textfield inside a frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following method will make the textbox that is to be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add a `textFieldShouldReturn` method of `UITextFieldDelegate`,
    to make the keypad disappear after tapping the return key while entering the player
    name in the textbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, add the `UITextFieldDelegate` delegate to the `Scorelist` class at the
    beginning. This delegate enables the keyboard to appear.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding snippet will successfully make the keyboard disappear once the
    return key is pressed. Now, the next task will be to save the added name.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a textbox to save player name](img/4201_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is how the screen will look when the keyboard is opened
  prefs: []
  type: TYPE_NORMAL
- en: Saving the player name with high score
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We will name the button **ADD PLAYER**. This button will make the name entered
    by the user to get saved with the high score made. Firstly, create the following
    node, named `add-player`, with the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code method to set the properties of the **ADD PLAYER** button.
    Also, make sure to call the same from the `didmoveToView()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines of code in the `touchesBegan()` method of `ScoreList.swift`,
    as in the previous code, to handle the tap of the **ADD PLAYER** button within
    touches loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We are also adding `gotoMenuScene()` to return to the main menu as we know.
    Following is the code for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the work on `SceneList.swift` is complete. Time to work on the high score
    board. The following screenshot shows how the screen will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Saving the player name with high score](img/4201_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating the high score board
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we have saved the name of the player who makes a high score, but we
    have not made a score board to show the high score to the player. It is better
    to have access to the score board right from the main menu, as it makes it convenient.
  prefs: []
  type: TYPE_NORMAL
- en: In our game, we are going to create a high score menu scene with a button on
    the main menu to reach this screen.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, create a scene with the name, `AddScoreScene.swift`, to show the high
    score.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create the method, `showHeightestScorerName()`,to display the name of
    the player who scored the highest score, and also call the same from the `didMoveToView()`
    method in the `AddScoreScene.swift` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We have displayed the name of the player with the highest score, now it is
    time to show the highest score made by the player. For this, create the method,
    `showHeighestScores()`, and also call the same from the `didMoveToView()` method
    in the `AddScoreScene.swift` file. Following is the code to be added in the `showHeighestScores()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it is time to add a back button, which will return the player to the main
    menu. Add the following code to implement the back button functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code has added the back button functionality; now we have to
    handle the touch/tap on the button in the `touchesBegan()` method of `AddScore.swift`,
    as we did earlier. Add the following code in the `touchesBegan()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is how the high score board will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the high score board](img/4201_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, the high score screen is also complete. This concludes the integration
    of a scoring system in our *Platformer* game.
  prefs: []
  type: TYPE_NORMAL
- en: Adding sound into a game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A game can only be complete with different music and sound effects. There can
    be background music in the game along with sound effects at each action, such
    as, when the user taps, we can play a sound, and later, we can play a sound when
    a player hits an obstacle or some other element in the main game. We can also
    have different music at different levels. Sound effects play a vital role in enhancing
    the overall gaming experience, as they indulge the user in a holistic gaming experience.
  prefs: []
  type: TYPE_NORMAL
- en: Adding sounds into a Sprite Kit game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways to add sound effects in a Sprite Kit game:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `SKActions`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `AVFoundation` framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding sound effects using `SKActions` is not efficient, as compared to the
    `AVFoundation` framework. `SKActions` has a lot of limitations, such as that one
    cannot pause or play the sound in the middle of gameplay, and so on. Hence, it
    is advisable to use `AVFoundation`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding sound into our Platformer game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's add sound effects in our *Platformer* game. We will be using the `AVFoundation`
    framework to add sounds.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, add the framework by clicking on your project, and then, under the
    **General** category, go to the **Linked frameworks and Libraries** section and
    add the `AVFoundation` framework.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, add the following code to import the `AVFoundation` framework into our
    `GameScene.swift` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the `AVAudioPlayerDelegate` delegate to use specified properties and methods
    of `AVAudioPlayer` in the `GameScene` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, create an instance of `AVAudioPlayer` for our `GameScene` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are adding two sound files named `game_music.mp3` and `Strong_Punch-Mike_Koenig-574430706.wav`
    into our project (the WAV file format is suitable for short sounds, and MP3 format
    is suitable for longer durational sounds) and assign their names with two string
    variable as shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following method of code to make `AVAudioPlayer` get the specified
    audio file and play the same:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we are passing the sound name and the file format as
    two parameters. The method will then play the sound file. If the user, while playing
    sound on the device, starts the game, this code will stop the earlier playing
    sound and then start the game sound.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As we want the background sound to be always running, we will call the `readFileIntoAVPlayer()`
    method and pass `backgroundSound` and `mp3` as parameters. Add the method in the
    beginning of the `didMoveToView()` method of `GameScene.swift`. Following is the
    line to be added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding line will play the background sound as the game starts.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We have also added another sound file for when the player dies. Now it is time
    to add the code that will play the sound effect when the player dies. Add the
    following lines of code in the beginning of the `didBeginContact()` method of
    `GameScene.swift`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we are stopping the background sound in the player and
    playing a new sound effect for the player's death by calling the same method as
    before, but with different parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Animation frames using SKTexture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have used static images in our game, but if you will see, most of
    the games have animated effects, such as player running effect, car running effect,
    or any other effect that enhances the gameplay and creates a much better experience
    for all.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Run action texture to the player in the Platformer game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We had earlier added an image atlas of the name, `idle.atlas`, which contained
    similar images of the player standing position.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are going to add running texture images for the player, which will make
    it look as though the player is running in the `GameScene`.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, add a texture image set called `bro5_run.atlas`, which we have provided.
    The image atlas contains sets of seven images, which are sometimes also referred
    to as a sprite sheet. In our case, it will be known as the player running sprite
    sheet. These sets of images will be running one after the other at a fast rate
    of time inside texture atlas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s assign the texture image for the player. Add the following line
    of code in the beginning of the `didMoveToView()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next step, we will add a method to create an `SKAction` for adding an
    animated texture for the different textures of `atlasForPlayerRun.atlas`. Add
    the following line of code by creating a `runForwardTexture()` method and call
    it from `didMoveToView()`. Make sure to do this after you have added the texture
    image for the player:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will have successfully implemented the running animation
    for the player. The following screenshot shows how a sprite sheet looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the Run action texture to the player in the Platformer game](img/4201_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The texture atlas for a running animation of the player
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered some important aspects of the game, along with
    reading about performance improvements. Further, you can enhance the performance
    of your game using performance measuring instruments provided by Xcode. We also
    integrated the scoring system, sounds, and player running animation in our platformer
    game.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final chapter of this book, we will discuss each element of
    our *Platformer* game, take an in-depth look at the Game Center provided by Apple,
    and discuss the newest additions in iOS 9 brought to us by Apple.
  prefs: []
  type: TYPE_NORMAL
