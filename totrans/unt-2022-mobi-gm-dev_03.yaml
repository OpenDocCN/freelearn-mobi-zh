- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mobile Input/Touch Controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How players interact with your project is probably one of the most important
    things in it to get right. While player input is added for all projects, no matter
    what platform you are using, this is one area that can make or break your mobile
    game.
  prefs: []
  type: TYPE_NORMAL
- en: If the controls that are implemented don’t fit the game that you’re making,
    or if the controls feel clunky, players will not play your game for long stretches
    of time. While many people consider Rockstar’s *Grand Theft Auto* series of games
    to work well on consoles and PC, playing the games on a mobile device provides
    a larger barrier of entry, due to all of the buttons on the screen and the replacement
    of joysticks with virtual versions that don’t provide haptic feedback in the same
    manner as other platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile and tablet games that tend to do well typically have controls that are
    simple, finding as many ways to streamline the gameplay as possible. Many popular
    games require a single input, such as Dong Nguyen’s *Flappy Bird* and Ketchapp’s
    *Ballz*.
  prefs: []
  type: TYPE_NORMAL
- en: There are various ways for games to interact with a mobile device that are different
    when compared to traditional games such as gestures and pinches, and we will explore
    a number of those in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover the different ways that inputs will work on mobile
    devices. We will start with the input that is already built into our project,
    using the mouse, and then move on to touch events, gestures, the use of the accelerometer,
    and accessing information via the `Touch`class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will be split into a number of topics. It will contain a simple,
    step-by-step process from beginning to end. Here is the outline of our tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Using mouse input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving via touch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Unity Remote
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a gesture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling a player using pinches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an accelerometer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting touch on game objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book utilizes *Unity 2022.1.0b16* and *Unity Hub 3.3.1*, but the steps
    should work with minimal changes in future versions of the editor. If you would
    like to download the exact version used in this book (and there is a new version
    out), you can visit Unity’s download archive at [https://unity3d.com/get-unity/download/archive](https://unity3d.com/get-unity/download/archive).
  prefs: []
  type: TYPE_NORMAL
- en: You can also find the system requirements for Unity at [https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html](https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html)
    under the **Unity Editor system** **requirements** section.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter03](https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: Using mouse input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into mobile-only solutions, I do want to point out that it is
    possible to write input that works on both mobile and PC by using mouse controls.
    Mobile devices support using mouse clicks as taps on the screen, with the position
    of the tap/click being the location where the finger has been pressed. This form
    of input provides just the position where the touch happened and indicates that
    a press has happened; it doesn’t give you all of the features that the mobile-only
    options do. We will discuss all of the features you have using mobile-specific
    input later on in this chapter, but I think it’s important to note how to have
    click events on the desktop as well. I personally use the desktop often for ease
    of testing on both a PC and my device, so I don’t have to deploy to a mobile device
    to test every single change made in a project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use desktop-based mouse click events for the movement of a player, first,
    inside Unity, open up your `PlayerBehaviour` script and update the `FixedUpdate`
    function to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We have added a number of things to the preceding script. First, we check whether
    the mouse button had been held down or not through the use of the `Input.GetMouseButton`
    function. The function will return `true` if the mouse is held down, and `false`
    if it is not. The function takes in a parameter, which is for what mouse button
    we’d like to check, providing `0` for the left button, `1` for the right, and
    `2` for the middle button. For mobile, however, only `0` will be picked up as
    a click.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the `Input.GetMouseButton` function, check out [https://docs.unity3d.com/ScriptReference/Input.GetMouseButton.html](https://docs.unity3d.com/ScriptReference/Input.GetMouseButton.html).
  prefs: []
  type: TYPE_NORMAL
- en: We can get the position that the mouse is at by using the `Input.mousePosition`
    property. However, this value is given to us in screen space. What is screen space?
    Well, let’s first talk about how we traditionally deal with positions in Unity
    by making use of world space.
  prefs: []
  type: TYPE_NORMAL
- en: Screen space versus world space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When dealing with positions in Unity through the **Inspector** window, we have
    the **(0,0,0)** point in the middle of our game’s world, which we call the origin,
    and then we refer to everything else based on an offset from there. We typically
    refer to this method of positioning as **world space**. Assuming that we have
    our camera pointing toward the origin, world spacelooks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – An example of world space](img/B18868_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – An example of world space
  prefs: []
  type: TYPE_NORMAL
- en: The lines are the *x*, *y*, and *z* axes of our world. If I were to move an
    object to the right or left, it would move along the *x* axis positively or negatively
    respectively. When in school, you may have learned about using graphs and points,
    and world space works very much like that.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Children of parented objects use a different system in the **Inspector** window,
    in that they are given positions relative to their parents instead. This system
    is called *local space*.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using mouse input, Unity gives us this information in another space, **screen
    space**. In this space, the position is based on where the camera is and isn’t
    involved with the actual game world. This space is also just in 2D, so there’s
    only an *x* and *y* position, with *z* always being stuck at **0**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – An example of screen space](img/B18868_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – An example of screen space
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding case, the bottom left of the screen would be **(0,0)** and
    the top right would be **(Screen.width, Screen.height)**. *Screen.width*and *Screen.height*are
    values in Unity that will give us the screen size of the screen window in pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could use these values as provided and then compare what side of the screen
    the player pressed, but in our case, I think it’d be better to convert the position
    into an easier space to work with. One such space is the **viewport space**, which
    goes from **(0,0)** to **(1,1)**:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 3.3 – An example of viewport\uFEFF space](img/B18868_03_03.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – An example of viewport space
  prefs: []
  type: TYPE_NORMAL
- en: Instead of searching whether our *x* position is less than half of the screen
    width, I can instead just check whether the value of `viewPos.x` is less than
    `0.5`, which is what we are doing in the preceding code. If the value is less
    than `0.5`, it’s on the left side of the screen, so we return `-1`; otherwise,
    it’s on the right side, so we give `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that some of Unity’s functions will use *Vector3* instead of *Vector2*
    in order to work with 3D spaces as well.
  prefs: []
  type: TYPE_NORMAL
- en: Once we know that, we can then set the horizontal speed variable to move to
    the left or right based on our movement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the script and dive back into Unity, and you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – The current status of the game](img/B18868_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – The current status of the game
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding screenshot, we can now use either the mouse
    (via the `Input.GetMouseButton` function and the `Input.mousePosition` variable)
    or our keyboard (via the `GetAxis` function), as described previously, to move
    our player.
  prefs: []
  type: TYPE_NORMAL
- en: This form of input works well enough for what we’re doing right now, but I’m
    assuming that you’ll want to know how to use the mobile device’s own way of moving,
    so we will go ahead and learn how to replicate the same functionality using touch
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Moving using touch controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity’s Input engine has a property called `Input.touches`, which is an array
    of the `Touch` objects. The `Touch` struct contains information on the touch that
    occurred, with information such as the amount of pressure on the touch and how
    many times you tapped the screen. It also contains the position property, such
    as `Input.mousePosition`, that will tell you what position the tap occurred at,
    in pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the Touch struct, check out [https://docs.unity3d.com/ScriptReference/Touch.html](https://docs.unity3d.com/ScriptReference/Touch.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the steps to use touch instead of mouse inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Adjust our preceding code to look something like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, note that this code looks very similar to what we’ve written in the preceding
    section. With that in mind, instead of copying and pasting the appropriate code
    twice and making changes, as a number of starting programmers would do, we can
    instead take the similarities and make a function. For the differences, we can
    use parameters to change the value instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping that in mind, let’s add the following function to the `PlayerBehaviour`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, instead of using `Input.mousePosition` or the touch position,
    we use a parameter for the function. Also, unlike previous functions we’ve written,
    this one will actually use a return value; in this case, it will give us a floating-point
    value. We will use this value in the `Update` function to set `horiztonalSpeed`
    to a new value when this function is called. Now that the function exists, we
    can call it when appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, update the `Update`function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding example, I am using a `#if` directive based on the platform
    selected. Unity will automatically create `#define`, depending on what has been
    selected as the platform we are deploying for. What this `#if` does, along with
    `#elif` and `#endif`, is allow us to include or exclude code from our project
    based on these directives.
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio, note that if you’re building for iOS or Android, the code
    within the `UNITY_IOS || UNITY_ANDROID`section is grayed out, meaning that it
    won’t be called currently because we are running the game in the *Unity Editor*.
    However, when we export the code to our platform, the appropriate code will be
    used.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To take a look at all of the other platform-dependent `#define` directives,
    check out [https://docs.unity3d.com/Manual/PlatformDependentCompilation.html](https://docs.unity3d.com/Manual/PlatformDependentCompilation.html).
  prefs: []
  type: TYPE_NORMAL
- en: Making use of the aforementioned directives, we can specify the code for different
    versions of our project, which is vital when dealing with multi-platform development.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In addition to Unity’s built-in `#define` directives, you can create your own
    by going to **Edit** | **Project Settings** | **Player**, scrolling down to **Other
    Settings** in the **Inspector** window, and changing **Scripting** **Define Symbols**.
  prefs: []
  type: TYPE_NORMAL
- en: This can be great for targeting specific devices or for showing certain pieces
    of debug information, in addition to a number of other things.
  prefs: []
  type: TYPE_NORMAL
- en: Save the script and dive back into Unity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upon exporting our game to your Android device, note that the controls now work
    correctly using our newly created touch code. This allows us to have something
    that works on mobile as well as PC.
  prefs: []
  type: TYPE_NORMAL
- en: We already know that we can export our game to an Android device, but there
    is another way that we can test our game on a device without having to do a full
    export. This can be done by downloading a special app, which will allow us to
    stream our games from our computer to our mobile device and is what we will be
    discussing next.
  prefs: []
  type: TYPE_NORMAL
- en: Using Unity Remote
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way to check how our game works using mobile devices is through an application
    that Unity has created called the **Unity Remote**. Created with Unity 5, it has
    been a while since the application has been updated, but it still works with the
    current version of Unity; however, it does require us to do some additional work
    and setup.
  prefs: []
  type: TYPE_NORMAL
- en: Android setup For Unity Remote
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to set up a phone to use Unity Remote, we will need to download the
    app and learn how to enable debugging mode, so in this section, we’re going to
    see just how to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, open up the *Google Play* app, and from there in the search bar,
    type in `unity remote`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Searching for the Unity Remote application](img/B18868_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Searching for the Unity Remote application
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Unity Remote 5** app. Afterward, you’ll be brought to the screen
    in order to install it, so click on the **Install** button and wait for it to
    finish downloading.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.6 – The Unity Remote 5 app page on Google Play](img/B18868_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – The Unity Remote 5 app page on Google Play
  prefs: []
  type: TYPE_NORMAL
- en: Once it’s completed, you should see it show up on your phone, ready to be opened.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Application on your device](img/B18868_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Application on your device
  prefs: []
  type: TYPE_NORMAL
- en: Click on the application, and you’ll be brought to a screen that asks you whether
    the application is allowed to take pictures and record video. This is due to the
    features that your games may use, so feel free to choose whether your game can
    use those features.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.8 – The permissions screen](img/B18868_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – The permissions screen
  prefs: []
  type: TYPE_NORMAL
- en: 'Afterward, you should see a screen that looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Running the Unity Remote 5 app](img/B18868_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Running the Unity Remote 5 app
  prefs: []
  type: TYPE_NORMAL
- en: This is the setup screen that you should see before playing your games, but
    if you try to play your project right now, nothing would happen; therefore, there’s
    still a few things that we need to do in preparation.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling developer mode and debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start off with, we’re going to need to change our phone to be in developer
    mode so that we can enable debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: First, in the Unity Editor, go to the **Project Settings** menu and open up
    the **Editor** section. From there, under the **Unity Remote** options, change
    **Device** from **None** to **Any** **Android Device**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Setting the Unity Remote device](img/B18868_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Setting the Unity Remote device
  prefs: []
  type: TYPE_NORMAL
- en: If you have not done so already, connect your phone to your PC via USB. From
    the **Settings** menu, you’ll want to select the **USB accessory connected** notification
    from your notifications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.11 – The notifications window upon plugging in the phone to the
    computer](img/B18868_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – The notifications window upon plugging in the phone to the computer
  prefs: []
  type: TYPE_NORMAL
- en: From the menu that pops up, select the **USB** **tethering** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Changing the mode to USB tethering](img/B18868_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – Changing the mode to USB tethering
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see this on your device, you may look for the **Mobile Hotspot
    and Tethering** section of your phone or using your internet search engine of
    choice to see how to enable USB tethering for your device.
  prefs: []
  type: TYPE_NORMAL
- en: Then, on the device, go to **Settings** | **About phone**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap the **Build number** property seven times to enable *developer mode*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.13 – The About phone menu on my phone](img/B18868_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – The About phone menu on my phone
  prefs: []
  type: TYPE_NORMAL
- en: From there, go to the **Developer options** section. I used the **Settings**
    window’s search function to find the exact location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.14 – The Developer options menu](img/B18868_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – The Developer options menu
  prefs: []
  type: TYPE_NORMAL
- en: From there, scroll down and select the **USB debugging** option. You may see
    a window explaining what USB debugging is for. Click on the **OK** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.15 – Enabling USB debugging](img/B18868_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15 – Enabling USB debugging
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll have a window popup that says **Allow USB debugging?.** Click on
    the **Allow** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, you should be able to return to the *Unity Remote 5* application. Back
    on your PC, click on the **Play** button, and you may see the computer appear
    to freeze for a bit, but after a short period of time, you should see your phone
    change to reflect the gameplay on the PC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.16 – Unity Remote gameplay](img/B18868_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.16 – Unity Remote gameplay
  prefs: []
  type: TYPE_NORMAL
- en: You may see some blurriness or graphical issues when playing the game on your
    device using Unity Remote. This is because Unity is sending an image of what the
    game looks like to the device to interact with; the game is not actually on the
    device. The quality isn’t anywhere near what the game on the actual device would
    be, but it does allow us to check the current state of our game on the actual
    device itself!
  prefs: []
  type: TYPE_NORMAL
- en: The enabling of developer mode and debugging also has the benefit of allowing
    us to deploy our game to our device straight through the build menu, without having
    to install it manually. To do so, go to the **Build Settings** menu, and under
    the **Run Device** option, select your phone.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.17 – Setting a run device](img/B18868_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.17 – Setting a run device
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you select **Build and Run** when the game finishes, the build you
    should see is the game directly running upon opening your phone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.18 – The game installed directly on the device](img/B18868_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.18 – The game installed directly on the device
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve learned how to use Unity Remote on an Android device, we can
    now see how we can set up Unity Remote on an iOS device.
  prefs: []
  type: TYPE_NORMAL
- en: Unity Remote setup for iOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Getting Unity Remote set up on iOS is possible on a Mac computer or a Windows
    computer that has *iTunes* installed. However, the steps will be similar to working
    with Android, aside from not needing to enable debugging. For the purpose of this
    section, I will be using a Mac:'
  prefs: []
  type: TYPE_NORMAL
- en: First, in the Unity Editor, go to the **Project Settings** menu and open up
    the **Editor** section. From there, under the **Unity Remote** options, change
    **Device** from **None** to **Any** **iOS Device**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.19 – Selecting the Any iOS Device option](img/B18868_03_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.19 – Selecting the Any iOS Device option
  prefs: []
  type: TYPE_NORMAL
- en: Then, from your iOS device, open up the App Store and search for `unity remote`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.20 – Searching for the Unity Remote app](img/B18868_03_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.20 – Searching for the Unity Remote app
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the Unity Remote 5 app and install it on your device. Once it has finished
    installing, it should be located on your phone:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.21 – Unity Remote installed](img/B18868_03_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.21 – Unity Remote installed
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the app, and you should see something similar to the following, asking
    you whether you’d like to trust this computer. Go ahead and hit the **Trust**
    button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.22 – The Trust This Computer option](img/B18868_03_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.22 – The Trust This Computer option
  prefs: []
  type: TYPE_NORMAL
- en: 'From your computer, go ahead and play the game. It may take a moment, but you
    should see the game streaming to your device, and you can play as usual:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.23 – Footage of Unity Remote streaming our game](img/B18868_03_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.23 – Footage of Unity Remote streaming our game
  prefs: []
  type: TYPE_NORMAL
- en: As noted when we built the Android version, you may see some blurriness or graphical
    issues when playing the game on your device using Unity Remote. This is because
    Unity is sending an image of what the game looks like to the device to interact
    with; the game is not actually on the device. The quality isn’t anywhere near
    what the game on the actual device would be, but it does allow us to check the
    current state of our game on the actual device itself!
  prefs: []
  type: TYPE_NORMAL
- en: And with that, we can now play our games on our respective devices without having
    to do a build! This can be a great way to quickly check whether things are working
    correctly on your device without having to do a build every time. Now, let’s take
    a look at some of the mobile-specific ways that we can interpret input.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a gesture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another type of input that you’ll find in mobile games is that of a swipe,
    such as in Kiloo’s *Subway Surfers*. This allows us to use the general movement
    of the touch to dictate a direction for us to move in. This is usually used to
    have our players *jump* from one position to another or move quickly in a certain
    direction. So, we’ll go ahead and implement that using the following steps, instead
    of our previous movement system:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `PlayerBehaviour`script, go ahead and add some new variables for us
    to work with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In order to determine whether we are swiping, we will need to first check the
    start and the end of our movement. We will store the starting position in the
    `touchStart``swipeMove``minSwipeDistance` variable, which will make sure that
    the player has moved on the *x* axis a little before actually making the jump
    – in this case, we want the user to move at least a quarter of an inch in order
    for the input to be counted as a swipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also note that the `Header` attribute has been added to the top of the first
    variable. This will add a header to the **Inspector** tab, making it easier to
    break apart different sections of your script. If you were to save the script
    and dive into Unity, you should see that this new attribute has been added when
    you select the player:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.24 – The newly added mobile input/touch controls under Swipe Properties](img/B18868_03_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.24 – The newly added mobile input/touch controls under Swipe Properties
  prefs: []
  type: TYPE_NORMAL
- en: Our next step is to convert the `MinSwipeDistance` value from inches into the
    pixel equivalent, which can be used to see how far the user’s swiping motion moves
    the player’s character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the `PlayerBehaviour``Start`function to add the following highlighted
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Screen.dpi``minSwipeDistance` by `Screen.dpi`, we know how long the movement
    in pixels needs to be for it to be counted as a swipe.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the `Screen.dpi` variable, check out [https://docs.unity3d.com/ScriptReference/Screen-dpi.html](https://docs.unity3d.com/ScriptReference/Screen-dpi.html).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the length of a swipe, we need to add the ability to trigger
    one. As we mentioned before, we have been using the `FixedUpdate``FixedUpdate`,
    which is generally called less often than the `Update` function.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `Input.GetAxis` and `Input.GetMouseButton` functions, which return
    `true` every single frame that the button is held down and will continue to respond
    during `FixedUpdate``FixedUpdate` can miss the start and ending frames where input
    events happen, which is required for swipe events and certain actions, such as
    jumping, in games. If you want something to happen the moment an input starts
    or finishes, you will likely want to utilize the `Update` function instead, and
    that is what we will be doing with our gesture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, back in the `PlayerBehaviour`script, add the following function to the
    project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we added a new behavior called `SwipeTeleport``Touch`event
    and use its properties to move the player if a swipe happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will then create a function to handle this new swiping behavior, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this function, instead of just using the current touch position, we instead
    store the starting position when the touch begins. When the player lifts their
    finger, we get the position as well. We then get the direction of that movement
    and then apply it to the ball, checking whether we’ll collide with something before
    actually causing the movement.
  prefs: []
  type: TYPE_NORMAL
- en: Save your script and dive back into Unity, exporting your project to your mobile
    device or an emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.25 – A visual of the game after performing a swipe](img/B18868_03_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.25 – A visual of the game after performing a swipe
  prefs: []
  type: TYPE_NORMAL
- en: Now, whenever we swipe to the left or right, the player will move accordingly.
    Let’s learn about another action that we can use while playing the game in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling the player using pinches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The concept of using touch events to modify things in the game can also be
    applied to other methods of touch interaction, such as using finger pinches to
    zoom in and out. To see how to do this, let’s adjust the `PlayerBehaviour`script
    so that we can change the player’s scale, using two fingers to pinch or stretch
    out the view:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the `PlayerBehaviour`script and add the following properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Instead of using a single touch event, in this example, we are using two. Using
    both touch events, we can see how the touches have changed over the course of
    the previous frame (the delta). We then use that difference to modify the scale
    of the player. To ensure the ball will always have a valid value, we use the `Mathf.Clamp`
    function to keep the values between what is set in `minScale``maxScale`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to call the function by updating the `Update`function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save your script and return to the Unity editor. Export your game, and you
    should be able to see the player scaling in action – by moving two fingers apart,
    you’ll see the ball expand, and vice versa:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.26 – The result of our pinch gesture in the current state of the
    game](img/B18868_03_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.26 – The result of our pinch gesture in the current state of the game
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For those using LDPlayer, it is possible to replicate a pinch/zoom effect by
    pressing *Ctrl* and then scrolling the mouse wheel.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, this demonstrates the power given by being able to use multi-touch
    and some of the advantages of utilizing touch events, instead of just a single
    mouse click. Next, we will explore another type of input method that PCs don’t
    have.
  prefs: []
  type: TYPE_NORMAL
- en: Using the accelerometer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another type of input that mobile has, but PC doesn’t, is the accelerometer.
    This allows you to move in the game by tilting the physical position of the phone.
    The most popular example of this is likely the movement of the player in games
    such as Lima Sky’s *Doodle Jump* and Gameloft’s *Asphalt* series. To do something
    similar, we can retrieve the acceleration of our device with the `Input.acceleration`
    property and use it to move the player. Let’s look at the steps to do just that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We may want to allow our designers to set whether they want to use the `Accelerometer`
    mode or `ScreenTouch`, which we used previously. With that in mind, let’s create
    a new `enum``PlayerBehaviour`script above the **Swipe** **Properties** header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding script utilizes `enum` to define a custom type called `MobileHorizMovement`,
    which can be one of two values, `Accelerometer``ScreenTouch`. We then create a
    variable of this new type called `horizMovement`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you save the `PlayerBehaviour` script and dive back into the **Inspector**
    tab, you will see we can select one of these two options (**Accelerometer** or
    **Screen Touch**). By using this drop-down menu, the game designer of the project
    can easily select which of the two options we’d like to use, and then we can expand
    to even more if want to in the future (which we will in the next chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.27 – Adjusting the Horiz Movement property from the Inspector](img/B18868_03_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.27 – Adjusting the Horiz Movement property from the Inspector
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s update the `Update``#elif UNITY_IOS || UNITY_ANDROID` block of
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the `horizMovement` variable is set to **Accelerometer**, this new snippet
    of code will use the acceleration of our device instead of touches detected on
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Save your script and export the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.28 – Moving the player via the accelerometer](img/B18868_03_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.28 – Moving the player via the accelerometer
  prefs: []
  type: TYPE_NORMAL
- en: With that, you’ll note that we can now tilt our screen to the right or left,
    and the player will move in the appropriate direction.
  prefs: []
  type: TYPE_NORMAL
- en: In Unity, acceleration is measured in *g*-force values, with 1 being 1 g of
    force. If you hold the device upright (with the home button at the bottom) in
    front of you, the *x* axis is positive along the right, the *y* axis is positive
    upward, and the *z* axis is positive when pointing toward you.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the accelerometer, check out [https://docs.unity3d.com/Manual/MobileInput.html](https://docs.unity3d.com/Manual/MobileInput.html).
  prefs: []
  type: TYPE_NORMAL
- en: It’s great to know that our regular input is working, but you may want to check
    whether a game object in our scene has been touched so that the game can react
    to it. Let’s do that next.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting touch on game objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add something else for our player to do, as well as to demonstrate some
    additional input functionality, we’ll ensure that if the player taps an obstacle,
    it will be destroyed. We will use the following steps to modify our existing code
    to add this new functionality, utilizing the concept of **raycasts**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `PlayerBehaviour`script, add the following new function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we use a different version to determine collisions – a `raycast`. Thisis
    basically an invisible vector leading in a given direction, and we will use it
    to check whether it collides with any object inside of our scenes. This is often
    used in games, such as first-person shooters, to determine whether a player has
    hit an enemy or not without spawning a projectile and moving it there.
  prefs: []
  type: TYPE_NORMAL
- en: 'The version of `Physics.Raycast`that we use here takes in five parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The first specifies what ray to use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second is `hit`, which holds information about the collision if it occurred.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third parameter specifies how far to check for a collision.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth is a layer mask, which dictates with which objects you can collide.
    In our case, we want to collide with all colliders, so we use the bit-wise complement
    operator (`~`) to change `0` into the number possible by flipping all the bits
    used to create the number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, we have an enumeration called `QueryTriggerInteraction`, which we set
    to `Ignore`. This means that the `Tile End`objects with the triggers that we created
    in [*Chapter 1*](B18868_01.xhtml#_idTextAnchor015), *Building Your Game*,will
    not block our touch events, which would happen by default even if we couldn’t
    see them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the bitwise complement operator (`~`), check out [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#bitwise-complement-operator-](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#bitwise-complement-operator-).
  prefs: []
  type: TYPE_NORMAL
- en: For more information on *raycasting*, check out [https://docs.unity3d.com/ScriptReference/Physics.Raycast.html](https://docs.unity3d.com/ScriptReference/Physics.Raycast.html).
  prefs: []
  type: TYPE_NORMAL
- en: If we do hit something, we call a function named `SendMessage`on the object
    that we collided with. This function will attempt to call a function with the
    same name as the first parameter if it exists on any component of the game object.
    The second parameter lets us know whether we should display an error if it doesn’t
    exist.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more info on the `SendMessage`function, check out [https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the `Update``TouchObjects`function and adjust the code so that we can
    test the functionality within the Unity Editor as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the `PlayerBehaviour`script at this point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we call a `PlayerTouch``ObstacleBehaviour`script and add the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function will basically destroy the game object it is attached to, and
    create an explosion that will also destroy itself after `1`second.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to get similar results to what we are writing by making use of
    Unity’s `OnMouseDown` function. As we have already discussed, it is possible to
    use mouse events when developing for mobile. Keep in mind, though, that the use
    of that function is computationally more expensive than the method I’m suggesting
    here.
  prefs: []
  type: TYPE_NORMAL
- en: This is because when you tap the screen, every object that has an `OnMouseDown`
    method will do a `raycast` and 100, and it’s important to keep performance in
    mind when dealing with mobile development. For more information on this, check
    out [http://answers.unity3d.com/questions/1064394/onmousedown-and-mobile.html](http://answers.unity3d.com/questions/1064394/onmousedown-and-mobile.html).
  prefs: []
  type: TYPE_NORMAL
- en: Save the scripts and return to Unity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We haven’t created an explosion particle effect yet. To create this effect,
    we will make use of a *particle system*. We’ll be diving into particle systems
    at a much deeper level in [*Chapter 12*](B18868_12.xhtml#_idTextAnchor347)*, Improving
    Game Feel*, but, for now, we can consider a particle system as a game object that
    is made as simple as possible so that we can spawn many of them on the screen
    at once, without causing the game to slow down too much. This is mostly used for
    things such as smoke or fire, but, in this case, we will have our obstacle explode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following steps to create an explosion particle effect:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a particle system by going to `Explosion` and hit the *Enter* key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the game object in the **Hierarchy** window and then open the **Particle
    System** component in the **Inspector** tab. In there, click on the **Renderer**
    section to expand it, and change **RenderMode** to **Mesh** and **Material** to
    **Default-Material** by clicking on the circle next to the name and selecting
    **Default-Material** from the menu that pops up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.29 – Selecting the Default-Material material](img/B18868_03_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.29 – Selecting the Default-Material material
  prefs: []
  type: TYPE_NORMAL
- en: This will make the particles look like the obstacles that we’ve already created,
    as a box with the default material.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.30 – The visual of the boxes](img/B18868_03_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.30 – The visual of the boxes
  prefs: []
  type: TYPE_NORMAL
- en: Next, under the top **Particle System** section, change the **Gravity Modifier**
    property to **1**. This ensures that objects will fall gradually, much like normal
    objects with rigid bodies do, but with less computation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, under **Start Speed**, move to the right side and click on the downward-facing
    arrow, and from that menu, select **Random Between** **Two Constants**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.31 – Using a random value between two constants](img/B18868_03_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.31 – Using a random value between two constants
  prefs: []
  type: TYPE_NORMAL
- en: This will change the single window to two, signifying the minimum and maximum
    values that can be used for this property. From there, set the two values to `0``8`.
    This makes the objects spawned start at speeds between *0*and *8*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, change **Start Size** to something between **0** and **0.25**. This will
    ensure that we are creating a bunch of cubes that are smaller than the one we
    are planning to replace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change `1`and uncheck the **Looping** option. This ensures that the particle
    system will last only for *1* second, and unchecking looping means that the particle
    system will activate only once by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can still see the effect of each of the changes made, by clicking on the
    **Play** button on the bottom-right menu of the **Scene** window with the **Particle
    System** object selected.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, change the **Start Lifetime** property to **1** to ensure that all
    of the particles will be dead before the game object is destroyed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under the **Emission** section, change **Rate over Time** to **0**. Then, under
    **Bursts**, click on the **+** button and then set **Count** to **50**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.32 – Creating a single burst upon creation](img/B18868_03_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.32 – Creating a single burst upon creation
  prefs: []
  type: TYPE_NORMAL
- en: This means that 50 particles will be spawned right at the beginning of the particle
    system being created, much like an explosion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, check **Size over Lifetime** and click on the text next to the checkmark
    to show more details. From there, change the **Size** property by selecting a
    curve that decreases gradually so that at the end, they’ll all be **0.0**. This
    can be done by first selecting the curve itself and then going to the **Particle
    System Curves** section at the bottom of the **Inspector** window. If you do not
    see the contents shown in the following screenshot, you can click and drag the
    name upward to make it pop out. From there, you can click on the option that has
    the downward-facing curve:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.33 – Setting the Size over Lifetime curve](img/B18868_03_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.33 – Setting the Size over Lifetime curve
  prefs: []
  type: TYPE_NORMAL
- en: This will make the particles smaller gradually, and they will destroy themselves
    only after they become invisible (a scale of **0.0**).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, check the **Collision** property and open it, setting the **Type**
    property to **World**. This will cause the particles to hit the ground.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, make your object a prefab by dragging and dropping it from the **Hierarchy**
    tab into the **Project** tab in the **Assets** | **Prefabs** folder. Once the
    prefab is created (you should see the text on the object in the Hierarchy turn
    blue), remove the original from the scene by selecting it and pressing the *Delete*
    key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, assign the **Explosion** property of **Obstacle Behaviour (Script)**
    in the **Obstacle** prefab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.34 – Assigning the Explosion property in the Obstacle prefab](img/B18868_03_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.34 – Assigning the Explosion property in the Obstacle prefab
  prefs: []
  type: TYPE_NORMAL
- en: 'Save your project and run the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.35 – Exploding obstacles on touch](img/B18868_03_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.35 – Exploding obstacles on touch
  prefs: []
  type: TYPE_NORMAL
- en: Now, when we tap on one of the obstacles, we can see the object gets destroyed
    and an explosion effect is played!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you export the game to your mobile device, you should see the same functionality
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.36 – The current state of the game](img/B18868_03_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.36 – The current state of the game
  prefs: []
  type: TYPE_NORMAL
- en: From now on, whenever we tap on the obstacles on our mobile device, they will
    be destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned the main ways in which games are controlled
    when working on mobile devices. We also learned how we can use mouse inputs, touch
    events, gestures, and the accelerometer to allow players to interact with our
    game.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the other main way that players interact
    with a game by diving into the world of user interfaces and creating menus that
    can be enjoyed, no matter what device a user is playing the game on.
  prefs: []
  type: TYPE_NORMAL
