- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Mobile Input/Touch Controls
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动输入/触摸控制
- en: How players interact with your project is probably one of the most important
    things in it to get right. While player input is added for all projects, no matter
    what platform you are using, this is one area that can make or break your mobile
    game.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家如何与你的项目互动可能是其中最重要的正确做法之一。虽然所有项目都会添加玩家输入，无论你使用什么平台，但这是一个可以使你的移动游戏成功或失败的区域。
- en: If the controls that are implemented don’t fit the game that you’re making,
    or if the controls feel clunky, players will not play your game for long stretches
    of time. While many people consider Rockstar’s *Grand Theft Auto* series of games
    to work well on consoles and PC, playing the games on a mobile device provides
    a larger barrier of entry, due to all of the buttons on the screen and the replacement
    of joysticks with virtual versions that don’t provide haptic feedback in the same
    manner as other platforms.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实施的控制不适合你正在制作的游戏，或者如果控制感觉笨拙，玩家不会长时间地玩你的游戏。虽然许多人认为Rockstar的**《侠盗猎车手》**系列游戏在游戏机和PC上表现良好，但在移动设备上玩游戏由于屏幕上的所有按钮以及摇杆被虚拟版本取代（这些虚拟版本在提供触觉反馈方面与其他平台不同），因此会提供更大的入门障碍。
- en: Mobile and tablet games that tend to do well typically have controls that are
    simple, finding as many ways to streamline the gameplay as possible. Many popular
    games require a single input, such as Dong Nguyen’s *Flappy Bird* and Ketchapp’s
    *Ballz*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通常表现良好的移动和桌面游戏通常具有简单易用的控制，尽可能多地找到简化游戏玩法的方法。许多流行的游戏只需要单一输入，例如Dong Nguyen的*Flappy
    Bird*和Ketchapp的*Ballz*。
- en: There are various ways for games to interact with a mobile device that are different
    when compared to traditional games such as gestures and pinches, and we will explore
    a number of those in this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统游戏（如手势和捏合）相比，游戏与移动设备交互的方式有很多不同，我们将在本章中探讨其中的一些。
- en: In this chapter, we will cover the different ways that inputs will work on mobile
    devices. We will start with the input that is already built into our project,
    using the mouse, and then move on to touch events, gestures, the use of the accelerometer,
    and accessing information via the `Touch`class.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍移动设备上输入的不同工作方式。我们将从已经内置到我们项目中的输入开始，使用鼠标，然后转向触摸事件、手势、使用加速度计以及通过`Touch`类访问信息。
- en: 'This chapter will be split into a number of topics. It will contain a simple,
    step-by-step process from beginning to end. Here is the outline of our tasks:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将分为多个主题。它将包含从开始到结束的简单、分步的过程。以下是我们的任务大纲：
- en: Using mouse input
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用鼠标输入
- en: Moving via touch
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过触摸移动
- en: Using Unity Remote
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Unity Remote
- en: Implementing a gesture
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现手势
- en: Scaling a player using pinches
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用捏合缩放玩家
- en: Using an accelerometer
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加速度计
- en: Detecting touch on game objects
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测游戏对象上的触摸
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This book utilizes *Unity 2022.1.0b16* and *Unity Hub 3.3.1*, but the steps
    should work with minimal changes in future versions of the editor. If you would
    like to download the exact version used in this book (and there is a new version
    out), you can visit Unity’s download archive at [https://unity3d.com/get-unity/download/archive](https://unity3d.com/get-unity/download/archive).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用*Unity 2022.1.0b16*和*Unity Hub 3.3.1*，但步骤应该在未来版本的编辑器中只需进行最小改动即可工作。如果你想要下载本书中使用的确切版本（并且有新版本发布），你可以访问Unity的下载存档[https://unity3d.com/get-unity/download/archive](https://unity3d.com/get-unity/download/archive)。
- en: You can also find the system requirements for Unity at [https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html](https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html)
    under the **Unity Editor system** **requirements** section.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在**Unity编辑器系统** **要求**部分找到Unity的系统要求[https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html](https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html)。
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter03](https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter03).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章中存在的代码文件[https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter03](https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter03)。
- en: Using mouse input
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用鼠标输入
- en: Before we dive into mobile-only solutions, I do want to point out that it is
    possible to write input that works on both mobile and PC by using mouse controls.
    Mobile devices support using mouse clicks as taps on the screen, with the position
    of the tap/click being the location where the finger has been pressed. This form
    of input provides just the position where the touch happened and indicates that
    a press has happened; it doesn’t give you all of the features that the mobile-only
    options do. We will discuss all of the features you have using mobile-specific
    input later on in this chapter, but I think it’s important to note how to have
    click events on the desktop as well. I personally use the desktop often for ease
    of testing on both a PC and my device, so I don’t have to deploy to a mobile device
    to test every single change made in a project.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨仅适用于移动设备的解决方案之前，我想指出，通过使用鼠标控制，可以编写既适用于移动设备又适用于PC的输入。移动设备支持使用鼠标点击作为屏幕上的轻触，轻触/点击的位置是手指按下的地方。这种输入形式仅提供触摸发生的位置，并指示发生了按下；它不提供移动设备独有选项的所有功能。我们将在本章后面讨论使用移动特定输入时你可以使用的所有功能，但我认为重要的是要注意在桌面上也有点击事件。我个人经常使用桌面进行测试，以便在PC和我的设备上轻松测试，因此我无需将每个项目中的每个更改部署到移动设备上进行测试。
- en: 'To use desktop-based mouse click events for the movement of a player, first,
    inside Unity, open up your `PlayerBehaviour` script and update the `FixedUpdate`
    function to the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用基于桌面的鼠标点击事件来移动玩家，首先，在Unity中，打开你的`PlayerBehaviour`脚本，并将`FixedUpdate`函数更新为以下内容：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We have added a number of things to the preceding script. First, we check whether
    the mouse button had been held down or not through the use of the `Input.GetMouseButton`
    function. The function will return `true` if the mouse is held down, and `false`
    if it is not. The function takes in a parameter, which is for what mouse button
    we’d like to check, providing `0` for the left button, `1` for the right, and
    `2` for the middle button. For mobile, however, only `0` will be picked up as
    a click.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在先前的脚本中添加了一些内容。首先，我们通过使用`Input.GetMouseButton`函数来检查鼠标按钮是否被按下。如果鼠标被按下，该函数将返回`true`，如果没有，则返回`false`。该函数接受一个参数，用于指定我们想要检查哪个鼠标按钮，`0`代表左键，`1`代表右键，`2`代表中键。然而，对于移动设备，只有`0`会被识别为点击。
- en: Note
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the `Input.GetMouseButton` function, check out [https://docs.unity3d.com/ScriptReference/Input.GetMouseButton.html](https://docs.unity3d.com/ScriptReference/Input.GetMouseButton.html).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`Input.GetMouseButton`函数的更多信息，请参阅[https://docs.unity3d.com/ScriptReference/Input.GetMouseButton.html](https://docs.unity3d.com/ScriptReference/Input.GetMouseButton.html)。
- en: We can get the position that the mouse is at by using the `Input.mousePosition`
    property. However, this value is given to us in screen space. What is screen space?
    Well, let’s first talk about how we traditionally deal with positions in Unity
    by making use of world space.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`Input.mousePosition`属性来获取鼠标所在的位置。然而，这个值是以屏幕空间给出的。什么是屏幕空间？好吧，让我们先谈谈我们如何通过使用世界空间来在Unity中传统地处理位置。
- en: Screen space versus world space
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 屏幕空间与世界空间
- en: 'When dealing with positions in Unity through the **Inspector** window, we have
    the **(0,0,0)** point in the middle of our game’s world, which we call the origin,
    and then we refer to everything else based on an offset from there. We typically
    refer to this method of positioning as **world space**. Assuming that we have
    our camera pointing toward the origin, world spacelooks like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过**检查器**窗口在Unity中处理位置时，我们有一个位于游戏世界中心的**(0,0,0)**点，我们称之为原点，然后我们根据从这个点开始的偏移来引用其他所有内容。我们通常将这种定位方法称为**世界空间**。假设我们的摄像机指向原点，世界空间看起来是这样的：
- en: '![Figure 3.1 – An example of world space](img/B18868_03_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 世界空间的一个示例](img/B18868_03_01.jpg)'
- en: Figure 3.1 – An example of world space
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 世界空间的一个示例
- en: The lines are the *x*, *y*, and *z* axes of our world. If I were to move an
    object to the right or left, it would move along the *x* axis positively or negatively
    respectively. When in school, you may have learned about using graphs and points,
    and world space works very much like that.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些线代表我们世界的**x**、**y**和**z**轴。如果我要将一个物体向右或向左移动，它将沿着**x**轴正方向或负方向移动。在学校时，你可能已经学过使用图表和点，而世界空间的工作方式与此非常相似。
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Children of parented objects use a different system in the **Inspector** window,
    in that they are given positions relative to their parents instead. This system
    is called *local space*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **检查器** 窗口中，父对象的子对象使用不同的系统，即它们被给予相对于其父对象的位置。这个系统被称为 *局部空间*。
- en: 'When using mouse input, Unity gives us this information in another space, **screen
    space**. In this space, the position is based on where the camera is and isn’t
    involved with the actual game world. This space is also just in 2D, so there’s
    only an *x* and *y* position, with *z* always being stuck at **0**:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用鼠标输入时，Unity 以另一个空间提供这些信息，**屏幕空间**。在这个空间中，位置基于相机位置，并不涉及实际的游戏世界。这个空间也是二维的，所以只有
    *x* 和 *y* 位置，*z* 总是固定在 **0**：
- en: '![Figure 3.2 – An example of screen space](img/B18868_03_02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 屏幕空间示例](img/B18868_03_02.jpg)'
- en: Figure 3.2 – An example of screen space
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 屏幕空间示例
- en: In the preceding case, the bottom left of the screen would be **(0,0)** and
    the top right would be **(Screen.width, Screen.height)**. *Screen.width*and *Screen.height*are
    values in Unity that will give us the screen size of the screen window in pixels.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个案例中，屏幕的左下角是 **(0,0)**，右上角是 **(Screen.width, Screen.height)**。*Screen.width*
    和 *Screen.height* 是 Unity 中的值，将给出屏幕窗口的屏幕大小（以像素为单位）。
- en: 'We could use these values as provided and then compare what side of the screen
    the player pressed, but in our case, I think it’d be better to convert the position
    into an easier space to work with. One such space is the **viewport space**, which
    goes from **(0,0)** to **(1,1)**:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些值作为提供的内容，然后比较玩家按下的屏幕哪一侧，但在我看来，将位置转换为更容易处理的空间会更好。这样一个空间就是 **视口空间**，它从
    **(0,0)** 到 **(1,1)**：
- en: "![Figure 3.3 – An example of viewport\uFEFF space](img/B18868_03_03.jpg)"
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 视口空间示例](img/B18868_03_03.jpg)'
- en: Figure 3.3 – An example of viewport space
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 视口空间示例
- en: Instead of searching whether our *x* position is less than half of the screen
    width, I can instead just check whether the value of `viewPos.x` is less than
    `0.5`, which is what we are doing in the preceding code. If the value is less
    than `0.5`, it’s on the left side of the screen, so we return `-1`; otherwise,
    it’s on the right side, so we give `1`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是搜索我们的 *x* 位置是否小于屏幕宽度的一半，我可以选择直接检查 `viewPos.x` 的值是否小于 `0.5`，这正是我们在前面的代码中所做的。如果值小于
    `0.5`，它就在屏幕的左侧，所以我们返回 `-1`；否则，它就在右侧，所以我们返回 `1`。
- en: Note
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note that some of Unity’s functions will use *Vector3* instead of *Vector2*
    in order to work with 3D spaces as well.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Unity 的一些函数将使用 *Vector3* 而不是 *Vector2* 来处理三维空间。
- en: Once we know that, we can then set the horizontal speed variable to move to
    the left or right based on our movement.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道这一点，我们就可以将水平速度变量设置为根据我们的移动向左或向右移动。
- en: 'Save the script and dive back into Unity, and you will see the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本并返回 Unity，你将看到以下内容：
- en: '![Figure 3.4 – The current status of the game](img/B18868_03_04.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – 游戏当前状态](img/B18868_03_04.jpg)'
- en: Figure 3.4 – The current status of the game
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 游戏当前状态
- en: As you can see in the preceding screenshot, we can now use either the mouse
    (via the `Input.GetMouseButton` function and the `Input.mousePosition` variable)
    or our keyboard (via the `GetAxis` function), as described previously, to move
    our player.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，我们现在可以使用鼠标（通过 `Input.GetMouseButton` 函数和 `Input.mousePosition` 变量）或我们的键盘（通过
    `GetAxis` 函数），如前所述，来移动我们的玩家。
- en: This form of input works well enough for what we’re doing right now, but I’m
    assuming that you’ll want to know how to use the mobile device’s own way of moving,
    so we will go ahead and learn how to replicate the same functionality using touch
    instead.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这种输入方式对我们目前所做的事情来说已经足够好了，但我假设你将想知道如何使用移动设备自己的移动方式，因此我们将继续学习如何使用触摸来复制相同的功能。
- en: Moving using touch controls
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用触摸控制移动
- en: Unity’s Input engine has a property called `Input.touches`, which is an array
    of the `Touch` objects. The `Touch` struct contains information on the touch that
    occurred, with information such as the amount of pressure on the touch and how
    many times you tapped the screen. It also contains the position property, such
    as `Input.mousePosition`, that will tell you what position the tap occurred at,
    in pixels.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 的输入引擎有一个名为 `Input.touches` 的属性，它是一个 `Touch` 对象的数组。`Touch` 结构包含有关发生的触摸的信息，例如触摸的压力量和屏幕点击的次数。它还包含位置属性，如
    `Input.mousePosition`，它将告诉你在像素中触摸发生的位置。
- en: Note
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the Touch struct, check out [https://docs.unity3d.com/ScriptReference/Touch.html](https://docs.unity3d.com/ScriptReference/Touch.html).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Touch 结构体的更多信息，请查看 [https://docs.unity3d.com/ScriptReference/Touch.html](https://docs.unity3d.com/ScriptReference/Touch.html)。
- en: 'Let’s look at the steps to use touch instead of mouse inputs:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用触摸代替鼠标输入的步骤：
- en: 'Adjust our preceding code to look something like the following:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整我们前面的代码，使其看起来像以下这样：
- en: '[PRE1]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, note that this code looks very similar to what we’ve written in the preceding
    section. With that in mind, instead of copying and pasting the appropriate code
    twice and making changes, as a number of starting programmers would do, we can
    instead take the similarities and make a function. For the differences, we can
    use parameters to change the value instead.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请注意，这段代码看起来与我们前面章节中编写的代码非常相似。考虑到这一点，我们不需要复制和粘贴适当的代码两次并做出更改，就像许多初学者程序员会做的那样，我们可以利用相似之处来创建一个函数。对于差异，我们可以使用参数来更改值。
- en: 'Keeping that in mind, let’s add the following function to the `PlayerBehaviour`
    class:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们将以下函数添加到 `PlayerBehaviour` 类中：
- en: '[PRE2]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, instead of using `Input.mousePosition` or the touch position,
    we use a parameter for the function. Also, unlike previous functions we’ve written,
    this one will actually use a return value; in this case, it will give us a floating-point
    value. We will use this value in the `Update` function to set `horiztonalSpeed`
    to a new value when this function is called. Now that the function exists, we
    can call it when appropriate.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们不是使用 `Input.mousePosition` 或触摸位置，而是使用函数的参数。而且，与之前编写的函数不同，这个函数将实际使用返回值；在这种情况下，它将给我们一个浮点数值。我们将在
    `Update` 函数中使用这个值，当调用此函数时将 `horiztonalSpeed` 设置为新值。现在函数已经存在，我们可以在适当的时候调用它。
- en: 'Now, update the `Update`function, as follows:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新 `Update` 函数，如下所示：
- en: '[PRE3]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding example, I am using a `#if` directive based on the platform
    selected. Unity will automatically create `#define`, depending on what has been
    selected as the platform we are deploying for. What this `#if` does, along with
    `#elif` and `#endif`, is allow us to include or exclude code from our project
    based on these directives.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我使用了一个基于所选平台的 `#if` 指令。Unity 会根据我们部署的平台自动创建 `#define`。这个 `#if` 指令，连同
    `#elif` 和 `#endif`，允许我们根据这些指令在我们的项目中包含或排除代码。
- en: In Visual Studio, note that if you’re building for iOS or Android, the code
    within the `UNITY_IOS || UNITY_ANDROID`section is grayed out, meaning that it
    won’t be called currently because we are running the game in the *Unity Editor*.
    However, when we export the code to our platform, the appropriate code will be
    used.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中，请注意，如果您正在为 iOS 或 Android 构建项目，`UNITY_IOS || UNITY_ANDROID`
    部分的代码会被灰色显示，这意味着当前不会调用这部分代码，因为我们正在使用 *Unity 编辑器* 运行游戏。然而，当我们导出代码到我们的平台时，将使用适当的代码。
- en: Note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To take a look at all of the other platform-dependent `#define` directives,
    check out [https://docs.unity3d.com/Manual/PlatformDependentCompilation.html](https://docs.unity3d.com/Manual/PlatformDependentCompilation.html).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有其他平台相关的 `#define` 指令，请查看 [https://docs.unity3d.com/Manual/PlatformDependentCompilation.html](https://docs.unity3d.com/Manual/PlatformDependentCompilation.html)。
- en: Making use of the aforementioned directives, we can specify the code for different
    versions of our project, which is vital when dealing with multi-platform development.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 利用上述指令，我们可以指定我们项目不同版本的代码，这对于处理多平台开发至关重要。
- en: Note
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In addition to Unity’s built-in `#define` directives, you can create your own
    by going to **Edit** | **Project Settings** | **Player**, scrolling down to **Other
    Settings** in the **Inspector** window, and changing **Scripting** **Define Symbols**.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Unity 内置的 `#define` 指令外，您可以通过转到 **编辑** | **项目设置** | **玩家**，在 **检查器** 窗口中向下滚动到
    **其他设置**，并更改 **脚本** **定义符号** 来创建自己的。
- en: This can be great for targeting specific devices or for showing certain pieces
    of debug information, in addition to a number of other things.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于针对特定设备或显示某些调试信息非常有用，还有其他许多用途。
- en: Save the script and dive back into Unity.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本并返回 Unity。
- en: Upon exporting our game to your Android device, note that the controls now work
    correctly using our newly created touch code. This allows us to have something
    that works on mobile as well as PC.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将游戏导出到您的 Android 设备上时，请注意，现在控制台使用我们新创建的触摸代码可以正常工作。这使我们能够在移动设备和 PC 上都使用相同的功能。
- en: We already know that we can export our game to an Android device, but there
    is another way that we can test our game on a device without having to do a full
    export. This can be done by downloading a special app, which will allow us to
    stream our games from our computer to our mobile device and is what we will be
    discussing next.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道我们可以将我们的游戏导出到Android设备，但还有一种方法可以在不进行完整导出的情况下测试我们的游戏。这可以通过下载一个特殊的应用程序来完成，该应用程序将允许我们从计算机流式传输我们的游戏到我们的移动设备，这是我们将在下一节讨论的内容。
- en: Using Unity Remote
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Unity Remote
- en: Another way to check how our game works using mobile devices is through an application
    that Unity has created called the **Unity Remote**. Created with Unity 5, it has
    been a while since the application has been updated, but it still works with the
    current version of Unity; however, it does require us to do some additional work
    and setup.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种通过移动设备检查我们的游戏如何工作的方法是使用Unity创建的应用程序，称为**Unity Remote**。该应用程序是用Unity 5创建的，自从应用程序更新以来已经有一段时间了，但它仍然与当前版本的Unity兼容；然而，它要求我们做一些额外的操作和设置。
- en: Android setup For Unity Remote
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity Remote的Android设置
- en: 'In order to set up a phone to use Unity Remote, we will need to download the
    app and learn how to enable debugging mode, so in this section, we’re going to
    see just how to do that:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置手机使用Unity Remote，我们需要下载应用程序并学习如何启用调试模式，因此在本节中，我们将看到如何进行操作：
- en: 'To start, open up the *Google Play* app, and from there in the search bar,
    type in `unity remote`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开*Google Play*应用程序，然后在搜索栏中输入`unity remote`：
- en: '![Figure 3.5 – Searching for the Unity Remote application](img/B18868_03_05.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 – 搜索Unity Remote应用程序](img/B18868_03_05.jpg)'
- en: Figure 3.5 – Searching for the Unity Remote application
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 搜索Unity Remote应用程序
- en: Select the **Unity Remote 5** app. Afterward, you’ll be brought to the screen
    in order to install it, so click on the **Install** button and wait for it to
    finish downloading.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Unity Remote 5**应用程序。之后，您将被带到安装界面，因此点击**安装**按钮并等待其下载完成。
- en: '![Figure 3.6 – The Unity Remote 5 app page on Google Play](img/B18868_03_06.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6 – Google Play上的Unity Remote 5应用程序页面](img/B18868_03_06.jpg)'
- en: Figure 3.6 – The Unity Remote 5 app page on Google Play
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – Google Play上的Unity Remote 5应用程序页面
- en: Once it’s completed, you should see it show up on your phone, ready to be opened.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，您应该会在手机上看到它显示出来，准备打开。
- en: '![Figure 3.7 – Application on your device](img/B18868_03_07.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图3.7 – 设备上的应用程序](img/B18868_03_07.jpg)'
- en: Figure 3.7 – Application on your device
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – 设备上的应用程序
- en: Click on the application, and you’ll be brought to a screen that asks you whether
    the application is allowed to take pictures and record video. This is due to the
    features that your games may use, so feel free to choose whether your game can
    use those features.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击应用程序，您将被带到询问应用程序是否允许拍照和录制视频的屏幕。这是由于您的游戏可能使用的功能，因此请随意选择您的游戏是否可以使用这些功能。
- en: '![Figure 3.8 – The permissions screen](img/B18868_03_08.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8 – 权限屏幕](img/B18868_03_08.jpg)'
- en: Figure 3.8 – The permissions screen
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – 权限屏幕
- en: 'Afterward, you should see a screen that looks like this:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，您应该会看到一个类似这样的屏幕：
- en: '![Figure 3.9 – Running the Unity Remote 5 app](img/B18868_03_09.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图3.9 – 运行Unity Remote 5应用程序](img/B18868_03_09.jpg)'
- en: Figure 3.9 – Running the Unity Remote 5 app
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – 运行Unity Remote 5应用程序
- en: This is the setup screen that you should see before playing your games, but
    if you try to play your project right now, nothing would happen; therefore, there’s
    still a few things that we need to do in preparation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您在玩游戏之前应该看到的设置屏幕，但如果您现在尝试运行您的项目，什么都不会发生；因此，我们还需要做一些准备工作。
- en: Enabling developer mode and debugging
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用开发者模式和调试
- en: 'To start off with, we’re going to need to change our phone to be in developer
    mode so that we can enable debugging:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将我们的手机设置为开发者模式，以便我们可以启用调试：
- en: First, in the Unity Editor, go to the **Project Settings** menu and open up
    the **Editor** section. From there, under the **Unity Remote** options, change
    **Device** from **None** to **Any** **Android Device**.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在Unity编辑器中，转到**项目设置**菜单并打开**编辑器**部分。从那里，在**Unity Remote**选项下，将**设备**从**无**更改为**任何****Android设备**。
- en: '![Figure 3.10 – Setting the Unity Remote device](img/B18868_03_10.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图3.10 – 设置Unity Remote设备](img/B18868_03_10.jpg)'
- en: Figure 3.10 – Setting the Unity Remote device
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 – 设置Unity Remote设备
- en: If you have not done so already, connect your phone to your PC via USB. From
    the **Settings** menu, you’ll want to select the **USB accessory connected** notification
    from your notifications.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请通过USB将手机连接到您的电脑。从**设置**菜单中，您需要选择通知中的**USB已连接的附件**选项。
- en: '![Figure 3.11 – The notifications window upon plugging in the phone to the
    computer](img/B18868_03_11.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11 – 将手机插入电脑时的通知窗口](img/B18868_03_11.jpg)'
- en: Figure 3.11 – The notifications window upon plugging in the phone to the computer
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 – 将手机插入电脑时的通知窗口
- en: From the menu that pops up, select the **USB** **tethering** option.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从弹出的菜单中选择**USB** **网络共享**选项。
- en: '![Figure 3.12 – Changing the mode to USB tethering](img/B18868_03_12.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图3.12 – 将模式更改为USB网络共享](img/B18868_03_12.jpg)'
- en: Figure 3.12 – Changing the mode to USB tethering
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 – 将模式更改为USB网络共享
- en: If you don’t see this on your device, you may look for the **Mobile Hotspot
    and Tethering** section of your phone or using your internet search engine of
    choice to see how to enable USB tethering for your device.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在设备上没有看到这个选项，您可以在手机的**移动热点和网络共享**部分查找，或者使用您选择的互联网搜索引擎查找如何为您的设备启用USB网络共享。
- en: Then, on the device, go to **Settings** | **About phone**.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在设备上，转到**设置** | **关于手机**。
- en: Tap the **Build number** property seven times to enable *developer mode*.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**构建号**属性七次以启用**开发者模式**。
- en: '![Figure 3.13 – The About phone menu on my phone](img/B18868_03_13.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图3.13 – 我手机上的“关于手机”菜单](img/B18868_03_13.jpg)'
- en: Figure 3.13 – The About phone menu on my phone
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 – 我手机上的“关于手机”菜单
- en: From there, go to the **Developer options** section. I used the **Settings**
    window’s search function to find the exact location.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从那里，转到**开发者选项**部分。我使用了**设置**窗口的搜索功能来找到确切的位置。
- en: '![Figure 3.14 – The Developer options menu](img/B18868_03_14.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图3.14 – 开发者选项菜单](img/B18868_03_14.jpg)'
- en: Figure 3.14 – The Developer options menu
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 – 开发者选项菜单
- en: From there, scroll down and select the **USB debugging** option. You may see
    a window explaining what USB debugging is for. Click on the **OK** button.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从那里，向下滚动并选择**USB调试**选项。您可能会看到一个窗口解释USB调试的作用。点击**确定**按钮。
- en: '![Figure 3.15 – Enabling USB debugging](img/B18868_03_15.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图3.15 – 启用USB调试](img/B18868_03_15.jpg)'
- en: Figure 3.15 – Enabling USB debugging
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15 – 启用USB调试
- en: Next, you’ll have a window popup that says **Allow USB debugging?.** Click on
    the **Allow** button.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您将弹出一个窗口，提示**允许USB调试？**点击**允许**按钮。
- en: 'Now, you should be able to return to the *Unity Remote 5* application. Back
    on your PC, click on the **Play** button, and you may see the computer appear
    to freeze for a bit, but after a short period of time, you should see your phone
    change to reflect the gameplay on the PC:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您应该能够返回到**Unity Remote 5**应用程序。回到您的电脑上，点击**播放**按钮，您可能会看到电脑似乎冻结了一段时间，但经过短暂的时间，您应该看到手机上的画面反映了PC上的游戏：
- en: '![Figure 3.16 – Unity Remote gameplay](img/B18868_03_16.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图3.16 – Unity Remote游戏画面](img/B18868_03_16.jpg)'
- en: Figure 3.16 – Unity Remote gameplay
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.16 – Unity Remote游戏画面
- en: You may see some blurriness or graphical issues when playing the game on your
    device using Unity Remote. This is because Unity is sending an image of what the
    game looks like to the device to interact with; the game is not actually on the
    device. The quality isn’t anywhere near what the game on the actual device would
    be, but it does allow us to check the current state of our game on the actual
    device itself!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用Unity Remote在设备上玩游戏时，可能会看到一些模糊或图形问题。这是因为Unity正在将游戏的外观图像发送到设备以进行交互；游戏实际上并没有在设备上运行。画质远不如实际设备上的游戏，但它确实允许我们检查实际设备上游戏的当前状态！
- en: The enabling of developer mode and debugging also has the benefit of allowing
    us to deploy our game to our device straight through the build menu, without having
    to install it manually. To do so, go to the **Build Settings** menu, and under
    the **Run Device** option, select your phone.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 启用开发者模式和调试还有好处，允许我们通过构建菜单直接将游戏部署到我们的设备上，而无需手动安装。要这样做，请转到**构建设置**菜单，并在**运行设备**选项下选择您的手机。
- en: '![Figure 3.17 – Setting a run device](img/B18868_03_17.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图3.17 – 设置运行设备](img/B18868_03_17.jpg)'
- en: Figure 3.17 – Setting a run device
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.17 – 设置运行设备
- en: 'Now, if you select **Build and Run** when the game finishes, the build you
    should see is the game directly running upon opening your phone:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果游戏结束后选择**构建和运行**，您应该看到的是手机打开时直接运行的游戏：
- en: '![Figure 3.18 – The game installed directly on the device](img/B18868_03_18.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图3.18 – 直接在设备上安装的游戏](img/B18868_03_18.jpg)'
- en: Figure 3.18 – The game installed directly on the device
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.18 – 直接在设备上安装的游戏
- en: Now that we’ve learned how to use Unity Remote on an Android device, we can
    now see how we can set up Unity Remote on an iOS device.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何在Android设备上使用Unity Remote，我们现在可以看看如何在iOS设备上设置Unity Remote。
- en: Unity Remote setup for iOS
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: iOS的Unity Remote设置
- en: 'Getting Unity Remote set up on iOS is possible on a Mac computer or a Windows
    computer that has *iTunes* installed. However, the steps will be similar to working
    with Android, aside from not needing to enable debugging. For the purpose of this
    section, I will be using a Mac:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS上设置Unity Remote可以在装有*iTunes*的Mac电脑或Windows电脑上完成。然而，步骤将与Android相似，除了不需要启用调试。为了本节的目的，我将使用Mac：
- en: First, in the Unity Editor, go to the **Project Settings** menu and open up
    the **Editor** section. From there, under the **Unity Remote** options, change
    **Device** from **None** to **Any** **iOS Device**.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在Unity编辑器中，转到**项目设置**菜单并打开**编辑器**部分。从那里，在**Unity Remote**选项下，将**设备**从**无**更改为**任何****iOS设备**。
- en: '![Figure 3.19 – Selecting the Any iOS Device option](img/B18868_03_19.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图3.19 – 选择“任何iOS设备”选项](img/B18868_03_19.jpg)'
- en: Figure 3.19 – Selecting the Any iOS Device option
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.19 – 选择“任何iOS设备”选项
- en: Then, from your iOS device, open up the App Store and search for `unity remote`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从您的iOS设备上打开App Store并搜索`unity remote`。
- en: '![Figure 3.20 – Searching for the Unity Remote app](img/B18868_03_20.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图3.20 – 搜索Unity Remote应用程序](img/B18868_03_20.jpg)'
- en: Figure 3.20 – Searching for the Unity Remote app
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.20 – 搜索Unity Remote应用程序
- en: 'Select the Unity Remote 5 app and install it on your device. Once it has finished
    installing, it should be located on your phone:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Unity Remote 5应用程序并在您的设备上安装它。一旦安装完成，它应该位于您的手机上：
- en: '![Figure 3.21 – Unity Remote installed](img/B18868_03_21.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图3.21 – 安装好的Unity Remote](img/B18868_03_21.jpg)'
- en: Figure 3.21 – Unity Remote installed
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.21 – 安装好的Unity Remote
- en: 'Open up the app, and you should see something similar to the following, asking
    you whether you’d like to trust this computer. Go ahead and hit the **Trust**
    button:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开应用程序，您应该会看到以下类似内容，询问您是否想信任此计算机。请点击**信任**按钮：
- en: '![Figure 3.22 – The Trust This Computer option](img/B18868_03_22.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图3.22 – “信任此计算机”选项](img/B18868_03_22.jpg)'
- en: Figure 3.22 – The Trust This Computer option
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.22 – “信任此计算机”选项
- en: 'From your computer, go ahead and play the game. It may take a moment, but you
    should see the game streaming to your device, and you can play as usual:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的电脑上，开始玩游戏。可能需要一点时间，但您应该会看到游戏正在流式传输到您的设备，您可以像往常一样玩游戏：
- en: '![Figure 3.23 – Footage of Unity Remote streaming our game](img/B18868_03_23.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图3.23 – Unity Remote流式传输我们的游戏画面](img/B18868_03_23.jpg)'
- en: Figure 3.23 – Footage of Unity Remote streaming our game
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.23 – Unity Remote流式传输我们的游戏画面
- en: As noted when we built the Android version, you may see some blurriness or graphical
    issues when playing the game on your device using Unity Remote. This is because
    Unity is sending an image of what the game looks like to the device to interact
    with; the game is not actually on the device. The quality isn’t anywhere near
    what the game on the actual device would be, but it does allow us to check the
    current state of our game on the actual device itself!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如同我们在构建Android版本时提到的，您可能会在Unity Remote上玩游戏时看到一些模糊或图形问题。这是因为Unity正在向设备发送游戏外观的图像以进行交互；游戏实际上并不在设备上。质量远不及实际设备上的游戏，但它确实允许我们检查实际设备上的游戏当前状态！
- en: And with that, we can now play our games on our respective devices without having
    to do a build! This can be a great way to quickly check whether things are working
    correctly on your device without having to do a build every time. Now, let’s take
    a look at some of the mobile-specific ways that we can interpret input.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们现在可以在各自的设备上玩游戏，而无需进行构建！这可以是一个快速检查设备上是否正确工作的好方法，而无需每次都进行构建。现在，让我们看看一些我们可以用来解释输入的移动特定方法。
- en: Implementing a gesture
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现手势
- en: 'Another type of input that you’ll find in mobile games is that of a swipe,
    such as in Kiloo’s *Subway Surfers*. This allows us to use the general movement
    of the touch to dictate a direction for us to move in. This is usually used to
    have our players *jump* from one position to another or move quickly in a certain
    direction. So, we’ll go ahead and implement that using the following steps, instead
    of our previous movement system:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动游戏中，你还会发现另一种输入类型，即滑动，例如在 Kiloo 的 *Subway Surfers* 中。这允许我们使用触摸的一般移动来为我们指定移动的方向。这通常用于让我们的玩家
    *跳跃* 到另一个位置或快速移动到某个方向。因此，我们将继续使用以下步骤来实现，而不是我们之前的移动系统：
- en: 'In the `PlayerBehaviour`script, go ahead and add some new variables for us
    to work with:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PlayerBehaviour` 脚本中，继续添加一些新的变量供我们使用：
- en: '[PRE4]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In order to determine whether we are swiping, we will need to first check the
    start and the end of our movement. We will store the starting position in the
    `touchStart``swipeMove``minSwipeDistance` variable, which will make sure that
    the player has moved on the *x* axis a little before actually making the jump
    – in this case, we want the user to move at least a quarter of an inch in order
    for the input to be counted as a swipe.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定我们是否在滑动，我们首先需要检查我们的移动的起始和结束位置。我们将起始位置存储在 `touchStart`、`swipeMove`、`minSwipeDistance`
    变量中，这将确保在玩家实际跳跃之前，玩家已经在 *x* 轴上移动了一小段距离——在这种情况下，我们希望用户至少移动四分之一英寸，以便输入被计为一次滑动。
- en: 'Also note that the `Header` attribute has been added to the top of the first
    variable. This will add a header to the **Inspector** tab, making it easier to
    break apart different sections of your script. If you were to save the script
    and dive into Unity, you should see that this new attribute has been added when
    you select the player:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，`Header` 属性已被添加到第一个变量的顶部。这将向 **Inspector** 选项卡添加标题，使拆分脚本的不同部分更容易。如果你保存脚本并进入
    Unity，你应该会在选择玩家时看到这个新属性已被添加：
- en: '![Figure 3.24 – The newly added mobile input/touch controls under Swipe Properties](img/B18868_03_24.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.24 – 在“滑动属性”下新添加的移动输入/触摸控制](img/B18868_03_24.jpg)'
- en: Figure 3.24 – The newly added mobile input/touch controls under Swipe Properties
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.24 – 在“滑动属性”下新添加的移动输入/触摸控制
- en: Our next step is to convert the `MinSwipeDistance` value from inches into the
    pixel equivalent, which can be used to see how far the user’s swiping motion moves
    the player’s character.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步是将 `MinSwipeDistance` 值从英寸转换为像素等效值，这可以用来查看用户的滑动动作移动了玩家角色的多远。
- en: 'Go back to the `PlayerBehaviour``Start`function to add the following highlighted
    code:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 `PlayerBehaviour` 的 `Start` 函数，添加以下突出显示的代码：
- en: '[PRE5]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Screen.dpi``minSwipeDistance` by `Screen.dpi`, we know how long the movement
    in pixels needs to be for it to be counted as a swipe.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `Screen.dpi` 的 `minSwipeDistance`，我们知道移动在像素上的长度需要多长才能被计为一次滑动。
- en: Note
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the `Screen.dpi` variable, check out [https://docs.unity3d.com/ScriptReference/Screen-dpi.html](https://docs.unity3d.com/ScriptReference/Screen-dpi.html).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `Screen.dpi` 变量的更多信息，请参阅 [https://docs.unity3d.com/ScriptReference/Screen-dpi.html](https://docs.unity3d.com/ScriptReference/Screen-dpi.html)。
- en: Now that we know the length of a swipe, we need to add the ability to trigger
    one. As we mentioned before, we have been using the `FixedUpdate``FixedUpdate`,
    which is generally called less often than the `Update` function.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了滑动长度，我们需要添加触发一次滑动的能力。正如我们之前提到的，我们一直在使用 `FixedUpdate`，它通常比 `Update` 函数调用得少。
- en: We use the `Input.GetAxis` and `Input.GetMouseButton` functions, which return
    `true` every single frame that the button is held down and will continue to respond
    during `FixedUpdate``FixedUpdate` can miss the start and ending frames where input
    events happen, which is required for swipe events and certain actions, such as
    jumping, in games. If you want something to happen the moment an input starts
    or finishes, you will likely want to utilize the `Update` function instead, and
    that is what we will be doing with our gesture.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `Input.GetAxis` 和 `Input.GetMouseButton` 函数，这些函数在每个按钮被按下的帧返回 `true`，并且会在
    `FixedUpdate` 期间继续响应，而 `FixedUpdate` 可能会错过输入事件发生的起始和结束帧，这对于滑动事件和某些动作（如跳跃）在游戏中是必需的。如果你想在输入开始或结束时立即发生某些事情，你可能会想利用
    `Update` 函数，这正是我们将要对我们手势所做的事情。
- en: 'Now, back in the `PlayerBehaviour`script, add the following function to the
    project:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，回到 `PlayerBehaviour` 脚本中，为项目添加以下函数：
- en: '[PRE6]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we added a new behavior called `SwipeTeleport``Touch`event
    and use its properties to move the player if a swipe happens.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了一个名为 `SwipeTeleport` 的新行为，并使用其属性在发生滑动时移动玩家。
- en: 'We will then create a function to handle this new swiping behavior, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个函数来处理这种新的滑动行为，如下所示：
- en: '[PRE7]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this function, instead of just using the current touch position, we instead
    store the starting position when the touch begins. When the player lifts their
    finger, we get the position as well. We then get the direction of that movement
    and then apply it to the ball, checking whether we’ll collide with something before
    actually causing the movement.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们不是只使用当前的触摸位置，而是存储触摸开始时的起始位置。当玩家抬起手指时，我们也会获取位置。然后我们获取该移动的方向，并将其应用到球体上，在实际上造成移动之前检查我们是否会与某物发生碰撞。
- en: Save your script and dive back into Unity, exporting your project to your mobile
    device or an emulator.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的脚本并回到 Unity 中，将你的项目导出到你的移动设备或模拟器。
- en: '![Figure 3.25 – A visual of the game after performing a swipe](img/B18868_03_25.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.25 – 执行滑动操作后的游戏视觉](img/B18868_03_25.jpg)'
- en: Figure 3.25 – A visual of the game after performing a swipe
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.25 – 执行滑动操作后的游戏视觉
- en: Now, whenever we swipe to the left or right, the player will move accordingly.
    Let’s learn about another action that we can use while playing the game in the
    next section.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，无论我们向左或向右滑动，玩家都会相应地移动。让我们在下一节学习在玩游戏时可以使用的一种其他动作。
- en: Scaling the player using pinches
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用捏合缩放玩家
- en: 'The concept of using touch events to modify things in the game can also be
    applied to other methods of touch interaction, such as using finger pinches to
    zoom in and out. To see how to do this, let’s adjust the `PlayerBehaviour`script
    so that we can change the player’s scale, using two fingers to pinch or stretch
    out the view:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用触摸事件在游戏中修改事物的概念也可以应用于其他触摸交互方法，例如使用手指捏合来缩放。为了了解如何做到这一点，让我们调整 `PlayerBehaviour`
    脚本，以便我们可以通过捏合或拉伸视图来改变玩家的缩放比例：
- en: 'Open up the `PlayerBehaviour`script and add the following properties:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `PlayerBehaviour` 脚本并添加以下属性：
- en: '[PRE8]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, add the following function:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加以下函数：
- en: '[PRE9]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Instead of using a single touch event, in this example, we are using two. Using
    both touch events, we can see how the touches have changed over the course of
    the previous frame (the delta). We then use that difference to modify the scale
    of the player. To ensure the ball will always have a valid value, we use the `Mathf.Clamp`
    function to keep the values between what is set in `minScale``maxScale`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用单个触摸事件不同，在这个例子中，我们使用了两个。使用这两个触摸事件，我们可以看到触摸在上一帧（delta）中的变化。然后我们使用这个差异来修改玩家的缩放比例。为了确保球体始终有一个有效的值，我们使用
    `Mathf.Clamp` 函数来保持值在 `minScale` 和 `maxScale` 中设置的范围之间。
- en: 'Next, we need to call the function by updating the `Update`function:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要通过更新 `Update` 函数来调用该函数：
- en: '[PRE10]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Save your script and return to the Unity editor. Export your game, and you
    should be able to see the player scaling in action – by moving two fingers apart,
    you’ll see the ball expand, and vice versa:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的脚本并返回到 Unity 编辑器。导出你的游戏，你应该能够看到玩家缩放的效果——通过分开两根手指，你会看到球体膨胀，反之亦然：
- en: '![Figure 3.26 – The result of our pinch gesture in the current state of the
    game](img/B18868_03_26.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.26 – 游戏当前状态下捏合手势的结果](img/B18868_03_26.jpg)'
- en: Figure 3.26 – The result of our pinch gesture in the current state of the game
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.26 – 游戏当前状态下捏合手势的结果
- en: Note
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For those using LDPlayer, it is possible to replicate a pinch/zoom effect by
    pressing *Ctrl* and then scrolling the mouse wheel.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用 LDPlayer 的用户，可以通过按下 *Ctrl* 然后滚动鼠标滚轮来复制捏合/缩放效果。
- en: Hopefully, this demonstrates the power given by being able to use multi-touch
    and some of the advantages of utilizing touch events, instead of just a single
    mouse click. Next, we will explore another type of input method that PCs don’t
    have.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这展示了能够使用多触控和利用触摸事件的一些优势所赋予的力量，而不仅仅是单次鼠标点击。接下来，我们将探索另一种 PC 所没有的输入方法。
- en: Using the accelerometer
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用加速度计
- en: 'Another type of input that mobile has, but PC doesn’t, is the accelerometer.
    This allows you to move in the game by tilting the physical position of the phone.
    The most popular example of this is likely the movement of the player in games
    such as Lima Sky’s *Doodle Jump* and Gameloft’s *Asphalt* series. To do something
    similar, we can retrieve the acceleration of our device with the `Input.acceleration`
    property and use it to move the player. Let’s look at the steps to do just that:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 移动设备有的一种输入类型，而PC没有，就是加速度计。这允许你通过倾斜手机的物理位置在游戏中移动。最流行的例子可能是Lima Sky的*Doodle Jump*和Gameloft的*Asphalt*系列游戏中玩家的移动。为了做类似的事情，我们可以使用`Input.acceleration`属性获取我们设备的加速度，并使用它来移动玩家。让我们看看完成这一点的步骤：
- en: 'We may want to allow our designers to set whether they want to use the `Accelerometer`
    mode or `ScreenTouch`, which we used previously. With that in mind, let’s create
    a new `enum``PlayerBehaviour`script above the **Swipe** **Properties** header:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可能希望允许我们的设计师设置他们是否想要使用`加速度计`模式或`ScreenTouch`，这是我们之前使用的。考虑到这一点，让我们在**滑动****属性**标题上方创建一个新的`enum`类型`PlayerBehaviour`脚本：
- en: '[PRE11]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding script utilizes `enum` to define a custom type called `MobileHorizMovement`,
    which can be one of two values, `Accelerometer``ScreenTouch`. We then create a
    variable of this new type called `horizMovement`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的脚本使用`enum`定义了一个名为`MobileHorizMovement`的自定义类型，它可以有两个值之一，`Accelerometer`或`ScreenTouch`。然后我们创建了一个名为`horizMovement`的新变量。
- en: 'Now, if you save the `PlayerBehaviour` script and dive back into the **Inspector**
    tab, you will see we can select one of these two options (**Accelerometer** or
    **Screen Touch**). By using this drop-down menu, the game designer of the project
    can easily select which of the two options we’d like to use, and then we can expand
    to even more if want to in the future (which we will in the next chapter):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你保存`PlayerBehaviour`脚本并返回到**检查器**标签页，你会看到我们可以选择这两个选项之一（**加速度计**或**屏幕触摸**）。通过使用这个下拉菜单，项目中的游戏设计师可以轻松选择我们想要使用哪个选项，并且如果将来想要的话，我们还可以扩展更多（我们将在下一章中这样做）：
- en: '![Figure 3.27 – Adjusting the Horiz Movement property from the Inspector](img/B18868_03_27.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图3.27 – 从检查器调整水平移动属性](img/B18868_03_27.jpg)'
- en: Figure 3.27 – Adjusting the Horiz Movement property from the Inspector
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.27 – 从检查器调整水平移动属性
- en: 'Next, let’s update the `Update``#elif UNITY_IOS || UNITY_ANDROID` block of
    code:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们更新`Update`#elif UNITY_IOS || UNITY_ANDROID`代码块：
- en: '[PRE12]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If the `horizMovement` variable is set to **Accelerometer**, this new snippet
    of code will use the acceleration of our device instead of touches detected on
    the screen.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`horizMovement`变量设置为**加速度计**，这段新代码将使用我们设备的加速度，而不是屏幕上检测到的触摸。
- en: Save your script and export the project.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的脚本并导出项目。
- en: '![Figure 3.28 – Moving the player via the accelerometer](img/B18868_03_28.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图3.28 – 通过加速度计移动玩家](img/B18868_03_28.jpg)'
- en: Figure 3.28 – Moving the player via the accelerometer
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.28 – 通过加速度计移动玩家
- en: With that, you’ll note that we can now tilt our screen to the right or left,
    and the player will move in the appropriate direction.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，你会注意到我们现在可以倾斜屏幕向右或向左，玩家将向相应的方向移动。
- en: In Unity, acceleration is measured in *g*-force values, with 1 being 1 g of
    force. If you hold the device upright (with the home button at the bottom) in
    front of you, the *x* axis is positive along the right, the *y* axis is positive
    upward, and the *z* axis is positive when pointing toward you.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，加速度以*重力加速度*值来衡量，1代表1 g的力。如果你将设备竖直握在面前（主按钮在底部），则*x*轴沿右侧为正，*y*轴向上为正，*z*轴指向你时为正。
- en: Note
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the accelerometer, check out [https://docs.unity3d.com/Manual/MobileInput.html](https://docs.unity3d.com/Manual/MobileInput.html).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于加速度计的信息，请查看[https://docs.unity3d.com/Manual/MobileInput.html](https://docs.unity3d.com/Manual/MobileInput.html)。
- en: It’s great to know that our regular input is working, but you may want to check
    whether a game object in our scene has been touched so that the game can react
    to it. Let’s do that next.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 知道我们的常规输入正在工作是很不错的，但你可能还想检查场景中的游戏对象是否被触摸，以便游戏可以对其做出反应。让我们接下来做这件事。
- en: Detecting touch on game objects
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测游戏对象上的触摸
- en: 'To add something else for our player to do, as well as to demonstrate some
    additional input functionality, we’ll ensure that if the player taps an obstacle,
    it will be destroyed. We will use the following steps to modify our existing code
    to add this new functionality, utilizing the concept of **raycasts**:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的玩家做些其他事情，以及展示一些额外的输入功能，我们将确保如果玩家点击障碍物，它将被销毁。我们将使用以下步骤修改我们现有的代码以添加此新功能，利用**射线投射**的概念：
- en: 'In the `PlayerBehaviour`script, add the following new function:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PlayerBehaviour`脚本中，添加以下新函数：
- en: '[PRE13]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we use a different version to determine collisions – a `raycast`. Thisis
    basically an invisible vector leading in a given direction, and we will use it
    to check whether it collides with any object inside of our scenes. This is often
    used in games, such as first-person shooters, to determine whether a player has
    hit an enemy or not without spawning a projectile and moving it there.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用不同的版本来确定碰撞——一个`raycast`。这基本上是一个指向给定方向的不可见向量，我们将用它来检查它是否与场景中的任何对象发生碰撞。这通常用于游戏，如第一人称射击游戏，以确定玩家是否击中了敌人，而无需生成并移动一个项目。
- en: 'The version of `Physics.Raycast`that we use here takes in five parameters:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的`Physics.Raycast`版本接受五个参数：
- en: The first specifies what ray to use.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个指定了要使用哪个射线。
- en: The second is `hit`, which holds information about the collision if it occurred.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个是`hit`，它包含有关是否发生碰撞的信息。
- en: The third parameter specifies how far to check for a collision.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数指定了检查碰撞的距离。
- en: The fourth is a layer mask, which dictates with which objects you can collide.
    In our case, we want to collide with all colliders, so we use the bit-wise complement
    operator (`~`) to change `0` into the number possible by flipping all the bits
    used to create the number.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个是层掩码，它决定了你可以与哪些对象发生碰撞。在我们的例子中，我们希望与所有碰撞体发生碰撞，因此我们使用位运算符（`~`）将`0`转换为通过翻转创建该数字所使用的所有位得到的数字。
- en: Lastly, we have an enumeration called `QueryTriggerInteraction`, which we set
    to `Ignore`. This means that the `Tile End`objects with the triggers that we created
    in [*Chapter 1*](B18868_01.xhtml#_idTextAnchor015), *Building Your Game*,will
    not block our touch events, which would happen by default even if we couldn’t
    see them.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们有一个名为`QueryTriggerInteraction`的枚举，我们将其设置为`Ignore`。这意味着我们创建的带有触发器的`Tile
    End`对象不会阻止我们的触摸事件，这在默认情况下会发生，即使我们看不到它们。
- en: Note
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the bitwise complement operator (`~`), check out [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#bitwise-complement-operator-](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#bitwise-complement-operator-).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 关于位运算符（`~`）的更多信息，请查看[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#bitwise-complement-operator-](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#bitwise-complement-operator-)。
- en: For more information on *raycasting*, check out [https://docs.unity3d.com/ScriptReference/Physics.Raycast.html](https://docs.unity3d.com/ScriptReference/Physics.Raycast.html).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 关于*射线投射*的更多信息，请查看[https://docs.unity3d.com/ScriptReference/Physics.Raycast.html](https://docs.unity3d.com/ScriptReference/Physics.Raycast.html)。
- en: If we do hit something, we call a function named `SendMessage`on the object
    that we collided with. This function will attempt to call a function with the
    same name as the first parameter if it exists on any component of the game object.
    The second parameter lets us know whether we should display an error if it doesn’t
    exist.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们击中了某个东西，我们将在我们与之碰撞的对象上调用名为`SendMessage`的函数。如果该函数存在于游戏对象的任何组件上，该函数将尝试调用具有相同名称的第一个参数的函数。第二个参数让我们知道如果它不存在，是否应该显示错误。
- en: Note
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more info on the `SendMessage`function, check out [https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`SendMessage`函数的更多信息，请查看[https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)。
- en: 'Now, in the `Update``TouchObjects`function and adjust the code so that we can
    test the functionality within the Unity Editor as well:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`UpdateTouchObjects`函数中调整代码，以便我们可以在Unity编辑器中测试功能：
- en: '[PRE14]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Save the `PlayerBehaviour`script at this point.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此点保存`PlayerBehaviour`脚本。
- en: 'Finally, we call a `PlayerTouch``ObstacleBehaviour`script and add the following
    code:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们调用`PlayerTouchObstacleBehaviour`脚本并添加以下代码：
- en: '[PRE15]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This function will basically destroy the game object it is attached to, and
    create an explosion that will also destroy itself after `1`second.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能基本上将销毁它附加到的游戏对象，并在1秒后创建一个也会销毁自己的爆炸。
- en: Note
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is possible to get similar results to what we are writing by making use of
    Unity’s `OnMouseDown` function. As we have already discussed, it is possible to
    use mouse events when developing for mobile. Keep in mind, though, that the use
    of that function is computationally more expensive than the method I’m suggesting
    here.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Unity的`OnMouseDown`函数，我们可以得到类似我们正在编写的结果。正如我们已经讨论过的，在为移动设备开发时可以使用鼠标事件。然而，请注意，该函数的计算成本比我在这里建议的方法要高。
- en: This is because when you tap the screen, every object that has an `OnMouseDown`
    method will do a `raycast` and 100, and it’s important to keep performance in
    mind when dealing with mobile development. For more information on this, check
    out [http://answers.unity3d.com/questions/1064394/onmousedown-and-mobile.html](http://answers.unity3d.com/questions/1064394/onmousedown-and-mobile.html).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为当你轻触屏幕时，每个具有`OnMouseDown`方法的对象都会执行`raycast`和100次，因此在处理移动设备开发时，保持性能很重要。有关更多信息，请参阅[http://answers.unity3d.com/questions/1064394/onmousedown-and-mobile.html](http://answers.unity3d.com/questions/1064394/onmousedown-and-mobile.html)。
- en: Save the scripts and return to Unity.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本并返回Unity。
- en: We haven’t created an explosion particle effect yet. To create this effect,
    we will make use of a *particle system*. We’ll be diving into particle systems
    at a much deeper level in [*Chapter 12*](B18868_12.xhtml#_idTextAnchor347)*, Improving
    Game Feel*, but, for now, we can consider a particle system as a game object that
    is made as simple as possible so that we can spawn many of them on the screen
    at once, without causing the game to slow down too much. This is mostly used for
    things such as smoke or fire, but, in this case, we will have our obstacle explode.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有创建爆炸粒子效果。为了创建这种效果，我们将使用一个**粒子系统**。我们将在[*第12章*](B18868_12.xhtml#_idTextAnchor347)“改进游戏感觉”中更深入地探讨粒子系统，但现在，我们可以将粒子系统视为一个尽可能简单的游戏对象，这样我们就可以同时将许多它们放在屏幕上，而不会使游戏速度减慢太多。这主要用于像烟雾或火焰这样的东西，但在这个例子中，我们的障碍物将会爆炸。
- en: 'Use the following steps to create an explosion particle effect:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤创建爆炸粒子效果：
- en: Create a particle system by going to `Explosion` and hit the *Enter* key.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过进入`Explosion`并按*Enter*键来创建一个粒子系统。
- en: 'Select the game object in the **Hierarchy** window and then open the **Particle
    System** component in the **Inspector** tab. In there, click on the **Renderer**
    section to expand it, and change **RenderMode** to **Mesh** and **Material** to
    **Default-Material** by clicking on the circle next to the name and selecting
    **Default-Material** from the menu that pops up:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中选择游戏对象，然后在**检查器**选项卡中打开**粒子系统**组件。在那里，点击**渲染器**部分以展开它，并通过点击名称旁边的圆圈并将菜单中选择**默认材质**来将**RenderMode**更改为**网格**和**材质**为**默认材质**：
- en: '![Figure 3.29 – Selecting the Default-Material material](img/B18868_03_29.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图3.29 – 选择默认材质](img/B18868_03_29.jpg)'
- en: Figure 3.29 – Selecting the Default-Material material
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.29 – 选择默认材质
- en: This will make the particles look like the obstacles that we’ve already created,
    as a box with the default material.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使粒子看起来像我们已经创建的障碍物，即一个带有默认材质的盒子。
- en: '![Figure 3.30 – The visual of the boxes](img/B18868_03_30.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图3.30 – 盒子的视觉效果](img/B18868_03_30.jpg)'
- en: Figure 3.30 – The visual of the boxes
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.30 – 盒子的视觉效果
- en: Next, under the top **Particle System** section, change the **Gravity Modifier**
    property to **1**. This ensures that objects will fall gradually, much like normal
    objects with rigid bodies do, but with less computation.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在顶部的**粒子系统**部分，将**重力修改器**属性更改为**1**。这确保了对象将逐渐下落，就像具有刚体的正常对象一样，但计算量更少。
- en: 'Then, under **Start Speed**, move to the right side and click on the downward-facing
    arrow, and from that menu, select **Random Between** **Two Constants**:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在**开始速度**下，移动到右侧并点击向下箭头，从该菜单中选择**随机介于** **两个常量**：
- en: '![Figure 3.31 – Using a random value between two constants](img/B18868_03_31.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图3.31 – 使用两个常量之间的随机值](img/B18868_03_31.jpg)'
- en: Figure 3.31 – Using a random value between two constants
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.31 – 使用两个常量之间的随机值
- en: This will change the single window to two, signifying the minimum and maximum
    values that can be used for this property. From there, set the two values to `0``8`.
    This makes the objects spawned start at speeds between *0*and *8*.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将使单个窗口变为两个，表示可以用于此属性的最低和最高值。从那里，将两个值设置为`0``8`。这使得生成的对象以*0*到*8*之间的速度开始。
- en: Then, change **Start Size** to something between **0** and **0.25**. This will
    ensure that we are creating a bunch of cubes that are smaller than the one we
    are planning to replace.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将**开始大小**更改为**0**到**0.25**之间的某个值。这将确保我们创建的一堆立方体比我们计划替换的那个要小。
- en: Change `1`and uncheck the **Looping** option. This ensures that the particle
    system will last only for *1* second, and unchecking looping means that the particle
    system will activate only once by default.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`1`改为取消选中**循环**选项。这确保粒子系统只会持续*1*秒，取消选中循环意味着粒子系统默认只激活一次。
- en: Note
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can still see the effect of each of the changes made, by clicking on the
    **Play** button on the bottom-right menu of the **Scene** window with the **Particle
    System** object selected.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在**场景**窗口的右下角菜单中点击**播放**按钮，并选择**粒子系统**对象来查看所做的每个更改的效果。
- en: Finally, change the **Start Lifetime** property to **1** to ensure that all
    of the particles will be dead before the game object is destroyed.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将**开始生命周期**属性更改为**1**，以确保所有粒子在游戏对象被销毁之前都死亡。
- en: 'Under the **Emission** section, change **Rate over Time** to **0**. Then, under
    **Bursts**, click on the **+** button and then set **Count** to **50**:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**发射**部分，将**随时间变化速率**更改为**0**。然后，在**爆发**部分，点击**+**按钮并将**计数**设置为**50**：
- en: '![Figure 3.32 – Creating a single burst upon creation](img/B18868_03_32.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图3.32 – 创建创建时的单个爆发](img/B18868_03_32.jpg)'
- en: Figure 3.32 – Creating a single burst upon creation
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.32 – 创建创建时的单个爆发
- en: This means that 50 particles will be spawned right at the beginning of the particle
    system being created, much like an explosion.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在粒子系统创建的最初时刻将生成50个粒子，就像爆炸一样。
- en: 'Then, check **Size over Lifetime** and click on the text next to the checkmark
    to show more details. From there, change the **Size** property by selecting a
    curve that decreases gradually so that at the end, they’ll all be **0.0**. This
    can be done by first selecting the curve itself and then going to the **Particle
    System Curves** section at the bottom of the **Inspector** window. If you do not
    see the contents shown in the following screenshot, you can click and drag the
    name upward to make it pop out. From there, you can click on the option that has
    the downward-facing curve:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，检查**生命周期大小**并点击复选框旁边的文本以显示更多详细信息。从那里，通过选择一个逐渐减少的曲线来更改**大小**属性，以便在最后，它们都将变为**0.0**。这可以通过首先选择曲线本身，然后转到**检查器**窗口底部的**粒子系统曲线**部分来完成。如果您看不到以下截图所示的內容，您可以点击并拖动名称向上使其突出显示。从那里，您可以点击具有向下曲线的选项：
- en: '![Figure 3.33 – Setting the Size over Lifetime curve](img/B18868_03_33.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图3.33 – 设置生命周期大小曲线](img/B18868_03_33.jpg)'
- en: Figure 3.33 – Setting the Size over Lifetime curve
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.33 – 设置生命周期大小曲线
- en: This will make the particles smaller gradually, and they will destroy themselves
    only after they become invisible (a scale of **0.0**).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这会使粒子逐渐变小，并且它们只有在变得不可见（缩放为**0.0**）后才会自我销毁。
- en: Finally, check the **Collision** property and open it, setting the **Type**
    property to **World**. This will cause the particles to hit the ground.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，检查**碰撞**属性并打开它，将**类型**属性设置为**世界**。这将导致粒子击中地面。
- en: Then, make your object a prefab by dragging and dropping it from the **Hierarchy**
    tab into the **Project** tab in the **Assets** | **Prefabs** folder. Once the
    prefab is created (you should see the text on the object in the Hierarchy turn
    blue), remove the original from the scene by selecting it and pressing the *Delete*
    key.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过将对象从**层次结构**选项卡拖放到**资产** | **预制体**文件夹中的**项目**选项卡来使您的对象成为一个预制体。一旦预制体创建完成（您应该在层次结构中看到对象的文本变为蓝色），通过选择它并按*删除*键来从场景中删除原始对象。
- en: 'Next, assign the **Explosion** property of **Obstacle Behaviour (Script)**
    in the **Obstacle** prefab:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在**障碍物**预制体中分配**障碍物行为（脚本）**的**爆炸**属性：
- en: '![Figure 3.34 – Assigning the Explosion property in the Obstacle prefab](img/B18868_03_34.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图3.34 – 在障碍物预制体中分配爆炸属性](img/B18868_03_34.jpg)'
- en: Figure 3.34 – Assigning the Explosion property in the Obstacle prefab
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.34 – 在障碍物预制体中分配爆炸属性
- en: 'Save your project and run the game:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的项目并运行游戏：
- en: '![Figure 3.35 – Exploding obstacles on touch](img/B18868_03_35.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.35 – 触摸时爆炸的障碍物](img/B18868_03_35.jpg)'
- en: Figure 3.35 – Exploding obstacles on touch
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.35 – 触摸时爆炸的障碍物
- en: Now, when we tap on one of the obstacles, we can see the object gets destroyed
    and an explosion effect is played!
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们点击其中一个障碍物时，我们可以看到物体被摧毁，并且播放了爆炸效果！
- en: 'If you export the game to your mobile device, you should see the same functionality
    as well:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将游戏导出到你的移动设备上，你应该看到相同的功能：
- en: '![Figure 3.36 – The current state of the game](img/B18868_03_36.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.36 – 游戏的当前状态](img/B18868_03_36.jpg)'
- en: Figure 3.36 – The current state of the game
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.36 – 游戏的当前状态
- en: From now on, whenever we tap on the obstacles on our mobile device, they will
    be destroyed.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，无论何时我们在移动设备上点击障碍物，它们都会被摧毁。
- en: Summary
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned the main ways in which games are controlled
    when working on mobile devices. We also learned how we can use mouse inputs, touch
    events, gestures, and the accelerometer to allow players to interact with our
    game.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了在移动设备上工作时控制游戏的主要方式。我们还学习了如何使用鼠标输入、触摸事件、手势和加速度计来允许玩家与我们的游戏互动。
- en: In the next chapter, we will explore the other main way that players interact
    with a game by diving into the world of user interfaces and creating menus that
    can be enjoyed, no matter what device a user is playing the game on.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过深入用户界面世界并创建可享受的菜单，来探索玩家与游戏互动的另一种主要方式，无论用户在什么设备上玩游戏。
