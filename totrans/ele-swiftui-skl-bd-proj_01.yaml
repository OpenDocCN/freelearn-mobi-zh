- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swift and SwiftUI Recap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firstly, I would like to thank you for reading my book, be it bought or borrowed,
    or whether you’re having a sneak peek in the Amazon preview, I thank you.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will recap Swift and SwiftUI. We will first cover the coding standards
    used throughout the book for our upcoming projects and the history of Swift and
    SwiftUI. Then, we will take a look at the requirements for going through the projects
    in this book. Coding standards can be very polarizing for programmers, but they
    really shouldn’t be. If there are any you disagree with, feel free to tweet me
    at `@SonarSystems` and let me know why. But don’t let that detract from the book
    and what you can get from it.
  prefs: []
  type: TYPE_NORMAL
- en: Afterward, we will look at some specific SwiftUI code examples along with previews
    to close off the recap. We will look at how we can use views and controls; these
    are the visual building blocks of your application’s user interface. We will use
    them throughout the book to draw and organize our application’s content on screen.
    Next, we will look at layouts and presentations to learn how we can combine views
    in stacks, create groups and lists of views dynamically, and define view presentations
    and hierarchy. Hope you enjoy the chapter!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have any questions, feel free to join my Discord: [https://discord.gg/7e78FxrgqH](https://discord.gg/7e78FxrgqH).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is Swift?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is SwiftUI?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and implementing views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and implementing layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned the history of Swift and SwiftUI,
    and how to implement basic components from SwiftUI; this will serve as the foundation
    for the projects we will create in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements and standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book requires you to download Xcode version 14 or above from Apple’s App
    Store.
  prefs: []
  type: TYPE_NORMAL
- en: To install Xcode, just search for `Xcode` in the App Store and select and download
    the latest version. Open Xcode and follow any additional installation instructions.
    Once Xcode has opened and launched, you’re ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Version 14 of Xcode has the following features/requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Includes SDKs for iOS 16, iPadOS 16, macOS 12.3, tvOS 16, and watchOS 9.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports on-device debugging in iOS 11 or later, tvOS 11 or later, and watchOS
    4 or later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requires a Mac running macOS Monterey 12.5 or later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Download the sample code from the following GitHub link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Elevate-SwiftUI-Skills-by-Building-Projects](https://github.com/PacktPublishing/Elevate-SwiftUI-Skills-by-Building-Projects)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the hardware requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: You need an Intel or Apple Silicon Mac
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4GB RAM or more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the software requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: macOS 11.3 (Big Sur or later)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Xcode 14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iOS 16 for iPad/iPhone real device testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: watchOS 9.0 for Watch real device testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: tvOS 16.0 for Apple TV real device testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some extra requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Intermediate knowledge of Swift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intermediate knowledge of another object-oriented programming language such
    as C++ or Objective-C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Though you can test the applications in the simulator that Xcode provides, it
    is highly recommended to test them on real devices.
  prefs: []
  type: TYPE_NORMAL
- en: Standards used
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at the coding standards that are used throughout
    this book. It is important to have consistent standards and know what the standards
    are.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need coding standards?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to write good code and good code isn’t just code that runs well
    but code that is easily maintainable and readable. Good code is an art form.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will go through a set of standards that are used
    in the Swift programming language and these will be used throughout this book.
    If you do not fully agree with the standards, that is fine, but I felt it important
    to list the standards used in case you come across something you have never seen
    before, such as Yoda conditions – do any of you use them? If so, tweet me at `@SonarSystems`.
  prefs: []
  type: TYPE_NORMAL
- en: Indentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You should always indent your code to be aligned with other code in the same
    hierarchy level. Use real tabs instead of spaces for indenting code. You can see
    this in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is helpful because you can easily see where in the hierarchy the code belongs.
    Xcode provides a handy little shortcut for indenting code; simply press *^ + I*
    on the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Brace style
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should always use Allman braces (named after *Eric Allman*) when writing
    code for structures, even if it is only one line (one line doesn’t require braces
    in many languages, such as C++, but they should be used for ease of readability).
    If you only have one line of code in the structure, put the braces and code on
    one line. I prefer not to put the opening brace on the structure’s first line.
    The only situation in which I would put the braces on the same line would be if
    there was no code in the structure yet; then, put the opening and closing brace
    on the same line with a space.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows the preferred brace style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is helpful because it helps maintain the code and helps with readability
    when trying to figure out where the structure starts and ends. This is especially
    useful when going through loads of files really fast and trying to figure out
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: Space usage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The use of spaces and lines varies depending on what you are using in your
    code. Remove any trailing whitespace (whitespace at the end of the line). You
    can see this in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Some editors automatically remove trailing whitespace, but some don’t. This
    can cause merge conflicts. You should coordinate with the people you’re working
    with (colleagues and the open source crowd) and what strategy everybody is using
    and make sure you all use the same strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Comma and colon usage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When using commas/colons, put a single space after the comma/colon. You can
    see this in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This makes it easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: Spaces in parenthesis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Put a single space on either side of both the opening and closing parentheses
    for `if`, `else`, `else if`, `for`, `while`, and other control structures (some
    languages may have other control structures, so just apply these standards to
    those structures). You can see this in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: These spaces make it easier to understand, especially at a glance.
  prefs: []
  type: TYPE_NORMAL
- en: Unary operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When using unary operators such as `++` and `–` in a statement, put a single
    space after them. You can see this in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The spaces keep it consistent with the rest of the code and make it easier to
    glance over.
  prefs: []
  type: TYPE_NORMAL
- en: Parentheses spaces for functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When defining a function, put a single space on the inside of the opening and
    closing parentheses. You can see this in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The spaces keep it consistent and easy to read.
  prefs: []
  type: TYPE_NORMAL
- en: Function calling spacing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Calling a function also follows the exact same rules as defining a function.
    You can see this in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It’s easier to read this way, and aesthetically pleasing.
  prefs: []
  type: TYPE_NORMAL
- en: Square bracket spacing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When using square brackets, do not use any spaces on the inside of the opening
    and closing brackets. You can see this in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Although this is different from parentheses, it looks better this way. Line
    lengths should generally be no longer than 80 characters, but if it helps with
    the readability, then exceptions can be made.
  prefs: []
  type: TYPE_NORMAL
- en: Typecasting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When typecasting, always enclose the type in parentheses and not the variable,
    and use a single space inside the parentheses but not outside the closing parenthesis.
    You can see this in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This way, it’s easier to read and aesthetically pleasing. It also makes figuring
    out the association between variables and casts easier when nested.
  prefs: []
  type: TYPE_NORMAL
- en: Naming conventions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section will cover the naming conventions used throughout this book. Always
    use meaningful but not long names. Let the code be self-documenting as much as
    possible but `scoreForThePlayerForLevel1`; instead, use something such as `scorePlayerLevel1`).
  prefs: []
  type: TYPE_NORMAL
- en: '`EpicFunction`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`epicVariable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constants** – ALL LETTERS UPPERCASE'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All variables belonging to an object such as a class should start with an underscore
    – for example, `_localVariable.`
  prefs: []
  type: TYPE_NORMAL
- en: This is helpful because it keeps the code consistent, which improves efficiency,
    readability, and maintenance. It helps others understand your code better. It
    also looks nice.
  prefs: []
  type: TYPE_NORMAL
- en: Yoda conditions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When comparing variables and values, always compare the value to the variable
    and not the variable to the value. You can see this in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is helpful because it prevents you from accidentally assigning a value
    to the variable instead of comparing it and thus results in a true value and makes
    the if statement equate to true.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is an area that most people hate, and a lot of people miss out or leave
    until the end and then come to the realization that it’s a lot of effort at that
    stage, so I would recommend commenting in the code as you go along.
  prefs: []
  type: TYPE_NORMAL
- en: 'When commenting in code, use `//` for single-line comments and `/* */` for
    multiline comments (the way your comment may vary based upon the programming language
    you are using) and all letters should be lowercase. You can see this in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is useful when trying to understand what your code does, especially if
    it is complex and/or you are reading it after a prolonged period of time. It is
    also useful when other people/programmers are trying to understand your code,
    as you may code differently to other people and comments can be crucial to helping
    them understand what is going on.
  prefs: []
  type: TYPE_NORMAL
- en: No magic numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A magic number is a number that looks like it is randomly placed in the code
    and doesn’t have any context or obvious meaning. This is what we would call an
    anti-pattern since reading and understanding code becomes very difficult to maintain.
    It is important that the code is intentional and that, just at a quick glance,
    you are able to understand it; this is fundamental to code quality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use constants and variables. `MAX_COUNT` is used instead of an arbitrary number
    such as 10\. You can see this in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This makes the code base easier to manage and understand.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked at the coding standards I use. I felt it very important
    to explain them not necessarily to persuade you to use the ones that I opt for,
    but so you have a reference point if you see anything in the book that seems different
    from your own normal standards. Above all, else be consistent with your standards
    and consistent with any teammates that are collaborating with you. This is the
    most important thing; the specific standards used are secondary, but the consistency
    is primary.
  prefs: []
  type: TYPE_NORMAL
- en: What is Swift?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will cover what Swift is, its history, and how it works
    on a macro level. If you are an expert and just want to read about SwiftUI, feel
    free to skip this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift is a programming language created by Apple and the open source community.
    It is a general-purpose, compiled, and multi-paradigm programming language. It
    was released in 2014 as a replacement for Apple’s previous language, Objective-C.
    Due to the fact that Objective-C had remained virtually the same since the early
    1980s, it was missing many features that modern languages have. Hence, the creation
    of Swift began; it has taken the Apple developer ecosystem by storm and is a hugely
    popular programming language. It is demanded by companies all over the world with
    excellent remuneration offered to those that know how to leverage its immense
    features. According to the PYPL index seen in the following figure, Swift is in
    the top 10 most popular languages, making it a must-have in any programmer’s arsenal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Popularity of Programming Language index (Source: https://www.stackscale.com/wp-content/uploads/2022/09/PYPL-index-popular-programming-languages-2022.jpg)](img/Figure_1.01_B18783.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1 – Popularity of Programming Language index (Source: [https://www.stackscale.com/wp-content/uploads/2022/09/PYPL-index-popular-programming-languages-2022.jpg](https://www.stackscale.com/wp-content/uploads/2022/09/PYPL-index-popular-programming-languages-2022.jpg))'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift has been used to create many apps, including but not limited to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: LinkedIn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firefox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WordPress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wikipedia
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lyft
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apple’s Cocoa and Cocoa Touch frameworks work with Swift out of the box. Furthermore,
    it works flawlessly with Apple’s previous programming language Objective-C, which
    has been used by developers for decades. This makes it one of the most modern
    but accessible languages around. Gone are the days when you would need to wait
    for frameworks to be released/updated for your chosen language; instead, thousands
    of projects already exist in Objective-C to use in the meantime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift was built using the **Low-Level Virtual Machine** (**LLVM**) compiler
    framework, which is open source, is bundled with Xcode (since version 6), and
    was also released in 2014\. It uses the Objective-C runtime library on Apple devices,
    thus allowing code written in C, Objective-C, C++, and Swift to work together
    in a single application. The following figure explains the relationship between
    programming languages such as Swift, LLVM, and the different architectures from
    a macro level:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – LLVM and language relationship (Source: https://miro.medium.com/max/1024/1*VWogVHhCagxopvAKVFjBeA.jpeg)
    ](img/Figure_1.02_B18783.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – LLVM and language relationship
  prefs: []
  type: TYPE_NORMAL
- en: '(Source: [https://miro.medium.com/max/1024/1*VWogVHhCagxopvAKVFjBeA.jpeg](https://miro.medium.com/max/1024/1*VWogVHhCagxopvAKVFjBeA.jpeg))'
  prefs: []
  type: TYPE_NORMAL
- en: LLVM uses Clang on the frontend, which is a compiler for programming languages
    such as C, C++, CUDA, or swiftc for Swift. This then turns the code into a format
    that LLVM uses to convert into the machine code, which is then run/executed on
    the hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on LLVM, feel free to use the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://llvm.org/](https://llvm.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/LLVM](https://en.wikipedia.org/wiki/LLVM)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/llvm/llvm-project](https://github.com/llvm/llvm-project)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/watch?v=BT2Cv-Tjq7Q&ab_channel=Fireship](https://www.youtube.com/watch?v=BT2Cv-Tjq7Q&ab_channel=Fireship)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/watch?v=IR_L1xf4PrU&ab_channel=tanmaybakshi](https://www.youtube.com/watch?v=IR_L1xf4PrU&ab_channel=tanmaybakshi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/watch?v=ZQds2aGHwDA&ab_channel=LexFridman](https://www.youtube.com/watch?v=ZQds2aGHwDA&ab_channel=LexFridman)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/watch?v=yCd3CzGSte8&ab_channel=LexFridman](https://www.youtube.com/watch?v=yCd3CzGSte8&ab_channel=LexFridman)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To understand the features available to you as a developer in Swift from a
    macro perspective, take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – Swift language reference](img/Figure_1.03_B18783.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – Swift language reference
  prefs: []
  type: TYPE_NORMAL
- en: '(Source: [https://gogeometry.com/software/swift/swift-language-reference-mind-map.jpg](https://gogeometry.com/software/swift/swift-language-reference-mind-map.jpg))'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram is a mind map showing all the high-level features provided
    by Swift and their subfeatures and how they all link together.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we covered what Swift is, how it works, and its popularity.
  prefs: []
  type: TYPE_NORMAL
- en: What is SwiftUI?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will cover what SwiftUI is and the features provided that
    we will leverage throughout this book to create our projects. If you feel comfortable
    with SwiftUI and just want to see projects, then feel free to skip the remainder
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'SwiftUI is a user interface framework built on top of the Swift programming
    language. It provides many components for creating your app’s user interface;
    the following is a macro list of these components:'
  prefs: []
  type: TYPE_NORMAL
- en: Views and controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shapes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layout containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collection containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Presentation containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to the components in the preceding list, SwiftUI provides us with
    event handlers, allowing our apps to react to taps, gestures, and all other types
    of input they may receive from the user. The framework provides tools to manage
    the flow of data from the models to the views and controls that the end user interacts
    with.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will look at the different core features of Swift, including examples
    that you can take away, modify, and use in your own projects.
  prefs: []
  type: TYPE_NORMAL
- en: Views and Controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Views and controls are the foundational blocks of your application’s UI. Using
    views, we can build the UI you want for your app. Its complexity can be whatever
    you desire, simple or immensely complex – it’s totally up to you – and we will
    see this in more detail in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Views can be any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shapes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom drawings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A combination of all of these
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controls enable user interaction with APIs that adapt to the platform and context
    they are used in.
  prefs: []
  type: TYPE_NORMAL
- en: Shapes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Shapes in SwiftUI are 2D objects such as circles and rectangles. Custom paths
    can also be leveraged to set the parameters of your own shape/structure; we will
    see shapes in more detail in the coming sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Shapes provide features to add styling, including but not limited to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Environment-aware color
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rich gradients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Material effects in the foreground
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Outlines for your shapes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layout Containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Layouts have the job of organizing the elements of your app’s UI. Stacks and
    grids are used to update and modify the positions of the child views that are
    within them in response to changes in content or interface dimensions. Layouts
    can be nested within one another; this can be done to as many levels as desired,
    thus allowing you to create complex layouts. Custom layouts can also be designed
    for further flexibility; we will take a look at layout containers in more depth
    later on.
  prefs: []
  type: TYPE_NORMAL
- en: Collection Containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Collections can be used to assemble dynamic views with complex functionality.
    For example, you can create a List view that allows you to scroll through a large
    set of data. The list automatically provides basic functionality, but in addition
    to this, you can add other functionality with minimal configuration, such as swiping,
    double tapping, and pull-to-refresh.
  prefs: []
  type: TYPE_NORMAL
- en: If only a simple grid or stack configuration is required, use a Layout container
    instead; we will look at code examples to further illustrate these.
  prefs: []
  type: TYPE_NORMAL
- en: Presentation Containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Presentation containers are used to provide structure to your app’s UI. This
    provides users with easier navigation for jumping around the app. This is extremely
    useful as the complexity of it increases and it contains more views. For example,
    you can enable navigating backward and forward through a set of views using a
    `NavigationStack`, and choosing which view to display from a tab bar using a `TabView`.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we covered the different features provided by SwiftUI on a
    macro level; we also discussed what sub-features they have and their uses.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and implementing views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at views and how we can implement them in SwiftUI.
    We will also take a look at combining these views.
  prefs: []
  type: TYPE_NORMAL
- en: Views are the fundamental building blocks of an application’s user interface.
    A view object renders content within its rectangle bounds and handles any interactions
    with that content.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will show the source code and examples for each
    type of view. If you would like further information, visit Apple’s documentation
    at [https://developer.apple.com/documentation/uikit/views_and_controls](https://developer.apple.com/documentation/uikit/views_and_controls).
  prefs: []
  type: TYPE_NORMAL
- en: What are text views?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is very common to need to display text in our app, and we do this by using
    a text view, which draws a string. By default, it has a font assigned to it that
    is best for the platform it is being displayed on; however, you can change the
    font using the `font(_:)` view modifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows the code used to implement a text view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The text view was inserted into a `VStack` for padding purposes, but this is
    not a requirement.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code shows how to simply display a string using the Text view
    by passing a string of what you need to display.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – Text view preview](img/Figure_1.04_B18783.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – Text view preview
  prefs: []
  type: TYPE_NORMAL
- en: The next section will cover image views and how to implement them.
  prefs: []
  type: TYPE_NORMAL
- en: What are Image views?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Image views can be used to render images inside your SwiftUI layouts. Images
    are an excellent way of providing more context and improving the overall user
    experience. Image views can load images from your bundle, from system icons, from
    a `UIImage`, and more, but loading from your bundle and system icons will be the
    most commonly used method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows the code used to implement an image view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we implement an Image View with a system icon but you
    can easily specify your own image file. We will do this later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, a system icon was used but the process is similar for using
    your bundle and a `UIImage`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – Image view preview](img/Figure_1.05_B18783.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – Image view preview
  prefs: []
  type: TYPE_NORMAL
- en: The next section will cover the different shape views available to us and the
    code to use them.
  prefs: []
  type: TYPE_NORMAL
- en: What are shape views?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SwiftUI provides us with five primitive shapes that are commonly used. These
    shapes are rectangles, rounded rectangles, circles, ellipses, and capsules. The
    last three are very subtly different in how they behave based on what sizes you
    provide.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how you can simply implement any of the following
    shapes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Rectangle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RoundedRectangle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Capsule`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ellipse`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Circle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s the snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The shapes were inserted into a `VStack` to arrange vertically and have padding
    around them.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code shows how to implement the different shape views and the
    parameters needed for each one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6 – Shape views](img/Figure_1.06_B18783.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.6 – Shape views
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will take a look at how we can use the views we have
    covered to combine and create more complex views.
  prefs: []
  type: TYPE_NORMAL
- en: What are custom and combination views?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For all frontend developers, one of the most crucial aspects of the development
    process is the implementation of the UI. We can create a simple UI with a combination
    of pre-made in-built views that we have leveraged thus far, but this is sometimes
    not enough; there are often cases when developers need to draw custom views programmatically
    to meet UI requirements, and if we are not able to draw those, it creates a problem.
    We are able to leverage the power of SwiftUI to create custom views, which are
    effectively a combination of the other views we learned about previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows us an implementation of multiple views to create our
    own custom view that displays a mini profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows how we can combine views to create custom views and
    how we can combine custom views to create more complex views. This also makes
    the mini views reusable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.7 – Custom view (mini profile)](img/Figure_1.07_B18783.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.7 – Custom view (mini profile)
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked at combining the views from the previous sections
    to make reusable and combinable objects and create more complex views.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will take a look at layouts to help organize the content
    in our app.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and implementing layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will cover how we can arrange our views using layouts for a more
    dynamic user experience.
  prefs: []
  type: TYPE_NORMAL
- en: SwiftUI layouts allow us as developers to arrange views in your app’s interface
    using the layout tools provided. Layouts tell SwiftUI how to place a set of views,
    and how much space it needs to do so to provide the desired layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Layouts can be but are not limited to any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Lazy stacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spacers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ScrollViewReader`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Grids:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PinnedScrollableViews`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we will show you the source code and examples for
    each type of layout.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like further information, visit Apple’s documentation: [https://developer.apple.com/documentation/uikit/view_layout](https://developer.apple.com/documentation/uikit/view_layout).'
  prefs: []
  type: TYPE_NORMAL
- en: What are lazy stacks?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lazy stacks are views that arrange their children in a line that expands vertically,
    creating items only as needed.
  prefs: []
  type: TYPE_NORMAL
- en: SwiftUI provides two different types of lazy stacks, `LazyVStack` and `LazyHStack`.
    By default, `VStack` and `HStack` load all the content upfront, which will be
    slow if you use them inside a scroll view, as these views can contain a lot of
    content. If you want to load content in a lazy fashion, so it is only loaded when
    it appears in the view, and not when the view is generally visible but the content
    is not, you should use `LazyVStack` and `LazyHStack` as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: The word lazy, as explained by Apple, refers to the stack view not creating
    items until they are needed. What this means to you is that the performance of
    these stack views is already optimized by default.
  prefs: []
  type: TYPE_NORMAL
- en: '`LazyVStack` and `LazyHStack` are only available in iOS 14.0+, iPadOS 14.0+,
    macOS 11.0+, Mac Catalyst 14.0+, tvOS 14.0+, and watchOS 7.0+. More information
    can be found at the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LazyVStack` – [https://developer.apple.com/documentation/swiftui/lazyvstack](https://developer.apple.com/documentation/swiftui/lazyvstack)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LazyHStack` – [https://developer.apple.com/documentation/swiftui/lazyhstack](https://developer.apple.com/documentation/swiftui/lazyhstack)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows how we can use a `LazyVStack` to organize views vertically
    while also being efficient with large sums of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code implements a `LazyVStack` with `1000` text views. The text
    views are added using a loop to make it easier and more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.8 – Lazy stacks](img/Figure_1.08_B18783.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.8 – Lazy stacks
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will take a look at spacers, which help us space out
    our content.
  prefs: []
  type: TYPE_NORMAL
- en: What are spacers?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A spacer creates a view that is adaptive with no content that expands as much
    as it can. For example, when placed within an `HStack`, a spacer expands horizontally
    as is allowed by the stack, moving views out of the way, within the size limits
    of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we implement text and spacers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code used a spacer with a height of `64` to separate the two text
    views.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.9 – Spacer preview](img/Figure_1.09_B18783.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.9 – Spacer preview
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at `ScrollViewReader`, which enables us to
    move to any location.
  prefs: []
  type: TYPE_NORMAL
- en: What are ScrollView and ScrollViewReader?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ScrollView` allows users to view content within a scrollable region. The user
    can perform platform-specific scroll gestures to adjust the visible portion of
    the content. `ScrollView` can scroll both horizontally and vertically but does
    not support zooming. If you want to programmatically move `ScrollView` to a specific
    location, you should add a `ScrollViewReader` inside it. This provides a method
    called `scrollTo()`, which moves to any view inside the parent `ScrollView`, simply
    by providing its anchor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All of this can be achieved with a few simple lines of code. You can see this
    code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code implemented `ScrollViewReader` inside `ScrollView`. Inside
    that, we added a button to scroll to the text view, which has an `id` value of
    `45`. We used a loop to display `1000` text views with unique IDs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.10 – ScrollViewReader preview](img/Figure_1.10_B18783.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.10 – ScrollViewReader preview
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at grids, which allow us to organize our content
    in a table-like fashion.
  prefs: []
  type: TYPE_NORMAL
- en: What are grids?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When SwiftUI was first released, it didn’t come with a collection view built
    in. Developers were left with one of two options – either to build their own or
    use a third-party solution. In WWDC 2020, Apple introduced new features for the
    SwiftUI framework. One of them was to address the need for grid views. SwiftUI
    now provides two new components, `LazyVGrid` and `LazyHGrid`. One is for vertical
    grids and the other is for horizontal grids.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how we can implement a grid with two rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we implement a grid of images set over two rows
    using a loop. `GridItem` components were used; Apple says these are descriptions
    of rows or columns in a lazy grid. What does this actually mean? Well, it’s essentially
    a method for specifying how many columns/rows we want, thus setting the layout
    pattern. `LazyGrid` uses this layout pattern when iterating through the items
    that are displayed and positioning them accordingly. If you are coming from a
    web background, you can think of it like the grid systems in responsive websites.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.11 – Grid preview](img/Figure_1.11_B18783.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.11 – Grid preview
  prefs: []
  type: TYPE_NORMAL
- en: The next section will cover `PinnedScrollableViews`, which allow certain views
    to stick on the page as others scroll past them.
  prefs: []
  type: TYPE_NORMAL
- en: What is PinnedScrollableView?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SwiftUI can provide a `PinnedScrollableView` inside a `ScrollView`. Pinned views
    are sticky views and can be applied to either a header or a footer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how we can pin a view to provide context to other
    views as they scroll past it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we implemented a sticky view, which acted as
    the section header as the other views dynamically moved past it, but the sticky
    view moved off the screen when another section was reached, and it had its own
    sticky view.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.12 – PinnedScrollableViews preview](img/Figure_1.12_B18783.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.12 – PinnedScrollableViews preview
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we covered the different layouts we have access to. These allow
    us to organize the data in a more pleasing fashion. In the next section, we will
    look at the different device previews for the projects that we will create throughout
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: Device Previews
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the many hurdles we will overcome is the differences between the four
    main Apple product categories. These categories are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Mac – iMac, Mac Pro, MacBook, anything that runs macOS, even Hackintosh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iPad – Mini, regular, Air, Pro, all of them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iPhone – Mini, Pro, Pro Max, all iPhones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apple Watch – small, big, old, or new
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The obvious thing you will notice is that they get smaller and smaller. They
    naturally have different purposes; an Apple Watch won’t replace a Mac and vice
    versa. That is why the next eight chapters are grouped into pairs, one for each
    product category. We will uncover the design decisions and restrictions we have
    when creating our applications. Let’s take a look at the settings in each product
    category:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mac**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.13 – Mac settings](img/Figure_1.13_B18783.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.13 – Mac settings
  prefs: []
  type: TYPE_NORMAL
- en: '**iPad**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.14 – iPad settings](img/Figure_1.14_B18783.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.14 – iPad settings
  prefs: []
  type: TYPE_NORMAL
- en: '**iPhone**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.15 – iPhone settings](img/Figure_1.15_B18783.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.15 – iPhone settings
  prefs: []
  type: TYPE_NORMAL
- en: '**Apple Watch**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.16 – Apple Watch settings](img/Figure_1.16_B18783.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.16 – Apple Watch settings
  prefs: []
  type: TYPE_NORMAL
- en: At a quick glance, it is immediately apparent that there are differences. These
    are the very differences we will discuss during the remainder of this book. The
    next section will summarize this chapter before heading over to our first project.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the history of Swift and SwiftUI, the features provided
    to us on a macro level, and how Swift and SwiftUI work on a technical level. Then,
    we looked at the difference between Swift and SwiftUI and what features are offered,
    along with code samples for you to take away and use in your own projects. After
    that, we took a look at the requirements necessary for developing applications
    with Swift and SwiftUI. Then, we took a look at the coding standards that are
    used throughout this book, providing a reference point for any coding style that
    is unfamiliar to your own. Then, we looked at the views and controls provided
    by SwiftUI for creating our own user experiences, including custom views by combining
    the fundamentals. Finally, we took a look at how we can organize these views using
    layouts and checked the device previews too.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we’ll take a look at designing our first project, the tax
    calculator app that we will create.
  prefs: []
  type: TYPE_NORMAL
