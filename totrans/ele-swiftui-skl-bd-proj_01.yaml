- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Swift and SwiftUI Recap
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift和SwiftUI回顾
- en: Firstly, I would like to thank you for reading my book, be it bought or borrowed,
    or whether you’re having a sneak peek in the Amazon preview, I thank you.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我想感谢你阅读我的书，无论是购买、借阅，还是你在亚马逊预览中偷看，我都感谢你。
- en: This chapter will recap Swift and SwiftUI. We will first cover the coding standards
    used throughout the book for our upcoming projects and the history of Swift and
    SwiftUI. Then, we will take a look at the requirements for going through the projects
    in this book. Coding standards can be very polarizing for programmers, but they
    really shouldn’t be. If there are any you disagree with, feel free to tweet me
    at `@SonarSystems` and let me know why. But don’t let that detract from the book
    and what you can get from it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将回顾Swift和SwiftUI。我们将首先介绍为即将到来的项目在整个书中使用的编码标准以及Swift和SwiftUI的历史。然后，我们将查看完成本书中项目的要求。编码标准可能会对程序员产生很大的分歧，但它们实际上不应该这样。如果你有任何不同意见，请随时在`@SonarSystems`上发推文并告诉我原因。但不要让这一点影响本书以及你可以从中获得的内容。
- en: Afterward, we will look at some specific SwiftUI code examples along with previews
    to close off the recap. We will look at how we can use views and controls; these
    are the visual building blocks of your application’s user interface. We will use
    them throughout the book to draw and organize our application’s content on screen.
    Next, we will look at layouts and presentations to learn how we can combine views
    in stacks, create groups and lists of views dynamically, and define view presentations
    and hierarchy. Hope you enjoy the chapter!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将查看一些具体的SwiftUI代码示例以及预览，以结束回顾。我们将查看如何使用视图和控制；这些是应用程序用户界面的视觉构建块。我们将贯穿全书使用它们在屏幕上绘制和组织应用程序的内容。接下来，我们将查看布局和展示，了解我们如何将视图组合在堆栈中，动态创建视图的组和列表，以及定义视图展示和层次结构。希望你喜欢这一章！
- en: 'If you have any questions, feel free to join my Discord: [https://discord.gg/7e78FxrgqH](https://discord.gg/7e78FxrgqH).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有任何问题，欢迎加入我的Discord：[https://discord.gg/7e78FxrgqH](https://discord.gg/7e78FxrgqH)。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is Swift?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是Swift？
- en: What is SwiftUI?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是SwiftUI？
- en: Understanding and implementing views
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和实现视图
- en: Understanding and implementing layouts
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和实现布局
- en: By the end of this chapter, you will have learned the history of Swift and SwiftUI,
    and how to implement basic components from SwiftUI; this will serve as the foundation
    for the projects we will create in this book.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学习Swift和SwiftUI的历史，以及如何从SwiftUI实现基本组件；这将为我们在本书中创建的项目奠定基础。
- en: Technical requirements and standards
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求和标准
- en: This book requires you to download Xcode version 14 or above from Apple’s App
    Store.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本书要求您从Apple的App Store下载Xcode 14或更高版本。
- en: To install Xcode, just search for `Xcode` in the App Store and select and download
    the latest version. Open Xcode and follow any additional installation instructions.
    Once Xcode has opened and launched, you’re ready to go.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Xcode，只需在App Store中搜索`Xcode`，选择并下载最新版本。打开Xcode，并遵循任何额外的安装说明。一旦Xcode打开并启动，你就可以开始了。
- en: 'Version 14 of Xcode has the following features/requirements:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的14版本具有以下功能/要求：
- en: Includes SDKs for iOS 16, iPadOS 16, macOS 12.3, tvOS 16, and watchOS 9.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含iOS 16、iPadOS 16、macOS 12.3、tvOS 16和watchOS 9的SDK。
- en: Supports on-device debugging in iOS 11 or later, tvOS 11 or later, and watchOS
    4 or later.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持iOS 11或更高版本、tvOS 11或更高版本和watchOS 4或更高版本在设备上的调试。
- en: Requires a Mac running macOS Monterey 12.5 or later.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要macOS Monterey 12.5或更高版本的Mac。
- en: 'Download the sample code from the following GitHub link:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下GitHub链接下载示例代码：
- en: '[https://github.com/PacktPublishing/Elevate-SwiftUI-Skills-by-Building-Projects](https://github.com/PacktPublishing/Elevate-SwiftUI-Skills-by-Building-Projects)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Elevate-SwiftUI-Skills-by-Building-Projects](https://github.com/PacktPublishing/Elevate-SwiftUI-Skills-by-Building-Projects)'
- en: 'Here are the hardware requirements:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是硬件要求：
- en: You need an Intel or Apple Silicon Mac
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要一个Intel或Apple Silicon Mac
- en: 4GB RAM or more
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4GB RAM或更高
- en: 'Here are the software requirements:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是软件要求：
- en: macOS 11.3 (Big Sur or later)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: macOS 11.3（Big Sur或更高版本）
- en: Xcode 14
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xcode 14
- en: iOS 16 for iPad/iPhone real device testing
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iOS 16用于iPad/iPhone真实设备测试
- en: watchOS 9.0 for Watch real device testing
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: watchOS 9.0用于Watch真实设备测试
- en: tvOS 16.0 for Apple TV real device testing
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: tvOS 16.0用于Apple TV真实设备测试
- en: 'Here are some extra requirements:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些额外的要求：
- en: Intermediate knowledge of Swift
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift的中级知识
- en: Intermediate knowledge of another object-oriented programming language such
    as C++ or Objective-C
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对其他面向对象编程语言（如 C++ 或 Objective-C）的中级知识
- en: Important note
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Though you can test the applications in the simulator that Xcode provides, it
    is highly recommended to test them on real devices.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以在 Xcode 提供的模拟器中测试应用程序，但强烈建议你在真实设备上测试它们。
- en: Standards used
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用的标准
- en: In this section, we will look at the coding standards that are used throughout
    this book. It is important to have consistent standards and know what the standards
    are.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨本书中使用的编码标准。保持一致的标准并了解这些标准很重要。
- en: Why do we need coding standards?
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们为什么需要编码标准？
- en: It is important to write good code and good code isn’t just code that runs well
    but code that is easily maintainable and readable. Good code is an art form.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 编写好的代码很重要，好的代码不仅仅是运行良好的代码，而是易于维护和阅读的代码。好的代码是一种艺术形式。
- en: In the following sections, we will go through a set of standards that are used
    in the Swift programming language and these will be used throughout this book.
    If you do not fully agree with the standards, that is fine, but I felt it important
    to list the standards used in case you come across something you have never seen
    before, such as Yoda conditions – do any of you use them? If so, tweet me at `@SonarSystems`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将介绍在 Swift 编程语言中使用的标准，这些标准将贯穿整本书。如果你不完全同意这些标准，那也无所谓，但我认为列出这些标准很重要，以防你遇到从未见过的内容，比如
    Yoda 条件——你们中有谁使用它们吗？如果是的话，请在 `@SonarSystems` 上给我发推文。
- en: Indentation
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缩进
- en: 'You should always indent your code to be aligned with other code in the same
    hierarchy level. Use real tabs instead of spaces for indenting code. You can see
    this in the following code snippet:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该始终缩进你的代码，使其与同一层级的其他代码对齐。使用实际的制表符进行缩进代码。你可以在以下代码片段中看到这一点：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is helpful because you can easily see where in the hierarchy the code belongs.
    Xcode provides a handy little shortcut for indenting code; simply press *^ + I*
    on the keyboard.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有帮助，因为你可以很容易地看到代码在层次结构中的位置。Xcode 提供了一个方便的快捷键来缩进代码；只需在键盘上按 *^ + I* 即可。
- en: Brace style
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 括号风格
- en: You should always use Allman braces (named after *Eric Allman*) when writing
    code for structures, even if it is only one line (one line doesn’t require braces
    in many languages, such as C++, but they should be used for ease of readability).
    If you only have one line of code in the structure, put the braces and code on
    one line. I prefer not to put the opening brace on the structure’s first line.
    The only situation in which I would put the braces on the same line would be if
    there was no code in the structure yet; then, put the opening and closing brace
    on the same line with a space.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为结构编写代码时，应该始终使用 Allman 括号（以 *Eric Allman* 命名），即使只有一行（在许多语言中，如 C++，一行代码不需要括号，但为了易于阅读，应该使用它们）。如果你在结构中只有一行代码，将括号和代码放在同一行上。我更喜欢不在结构的第
    一行放置开括号。唯一我会将括号放在同一行的情况是，结构中还没有代码；那时，将开括号和闭括号放在同一行，并在它们之间留一个空格。
- en: 'The following code snippet shows the preferred brace style:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了首选的括号风格：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is helpful because it helps maintain the code and helps with readability
    when trying to figure out where the structure starts and ends. This is especially
    useful when going through loads of files really fast and trying to figure out
    problems.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有帮助，因为它有助于维护代码，并在试图弄清楚结构开始和结束的地方时提高可读性。这在快速处理大量文件并试图找出问题时特别有用。
- en: Space usage
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空格使用
- en: 'The use of spaces and lines varies depending on what you are using in your
    code. Remove any trailing whitespace (whitespace at the end of the line). You
    can see this in the following code snippet:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 空格和行的使用取决于你在代码中使用的内容。删除任何尾随空格（行尾的空格）。你可以在以下代码片段中看到这一点：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Some editors automatically remove trailing whitespace, but some don’t. This
    can cause merge conflicts. You should coordinate with the people you’re working
    with (colleagues and the open source crowd) and what strategy everybody is using
    and make sure you all use the same strategy.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编辑器会自动删除尾随空格，但有些不会。这可能会导致合并冲突。你应该与你的同事和开源社区的人协调，了解大家使用的策略，并确保你们都使用相同的策略。
- en: Comma and colon usage
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逗号和冒号的使用
- en: 'When using commas/colons, put a single space after the comma/colon. You can
    see this in the following example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用逗号/冒号时，在逗号/冒号后放置一个空格。你可以在以下示例中看到这一点：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This makes it easier to read.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得阅读更容易。
- en: Spaces in parenthesis
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 括号内的空格
- en: 'Put a single space on either side of both the opening and closing parentheses
    for `if`, `else`, `else if`, `for`, `while`, and other control structures (some
    languages may have other control structures, so just apply these standards to
    those structures). You can see this in the following code snippet:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`、`else`、`else if`、`for`、`while`和其他控制结构（某些语言可能有其他控制结构，因此只需将这些标准应用于这些结构）的左右括号两侧各放置一个空格。您可以在以下代码片段中看到这一点：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These spaces make it easier to understand, especially at a glance.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些空格使理解更容易，尤其是在快速浏览时。
- en: Unary operators
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一元运算符
- en: 'When using unary operators such as `++` and `–` in a statement, put a single
    space after them. You can see this in the following snippet:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当在语句中使用一元运算符，如`++`和`–`时，在其后放置一个空格。您可以在以下代码片段中看到这一点：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The spaces keep it consistent with the rest of the code and make it easier to
    glance over.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些空格使代码保持一致性，并使其更容易浏览。
- en: Parentheses spaces for functions
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数的括号空格
- en: 'When defining a function, put a single space on the inside of the opening and
    closing parentheses. You can see this in the following snippet:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义函数时，在左右括号内部放置一个空格。您可以在以下代码片段中看到这一点：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The spaces keep it consistent and easy to read.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这些空格使代码保持一致且易于阅读。
- en: Function calling spacing
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数调用间距
- en: 'Calling a function also follows the exact same rules as defining a function.
    You can see this in the following code snippet:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 调用一个函数也遵循与定义函数完全相同的规则。您可以在以下代码片段中看到这一点：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It’s easier to read this way, and aesthetically pleasing.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这样读起来更容易，也更美观。
- en: Square bracket spacing
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方括号间距
- en: 'When using square brackets, do not use any spaces on the inside of the opening
    and closing brackets. You can see this in the following code snippet:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用方括号时，在左右括号内部不要使用任何空格。您可以在以下代码片段中看到这一点：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Although this is different from parentheses, it looks better this way. Line
    lengths should generally be no longer than 80 characters, but if it helps with
    the readability, then exceptions can be made.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这与括号不同，但这样看起来更好。行长度通常不应超过80个字符，但如果有助于可读性，则可以例外。
- en: Typecasting
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型转换
- en: 'When typecasting, always enclose the type in parentheses and not the variable,
    and use a single space inside the parentheses but not outside the closing parenthesis.
    You can see this in the following snippet:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行类型转换时，始终将类型放在括号内，而不是变量，并在括号内部使用一个空格，但不在关闭括号外部使用空格。您可以在以下代码片段中看到这一点：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This way, it’s easier to read and aesthetically pleasing. It also makes figuring
    out the association between variables and casts easier when nested.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，它更容易阅读，也更美观。它还使在嵌套时确定变量和类型转换之间的关系更容易。
- en: Naming conventions
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名约定
- en: This section will cover the naming conventions used throughout this book. Always
    use meaningful but not long names. Let the code be self-documenting as much as
    possible but `scoreForThePlayerForLevel1`; instead, use something such as `scorePlayerLevel1`).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍本书中使用的命名约定。始终使用有意义的但不要太长的名称。尽可能让代码自我说明，例如，不要使用`scoreForThePlayerForLevel1`这样的名称，而是使用`scorePlayerLevel1`）。
- en: '`EpicFunction`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EpicFunction`'
- en: '`epicVariable`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`epicVariable`'
- en: '**Constants** – ALL LETTERS UPPERCASE'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常量** - 所有字母大写'
- en: All variables belonging to an object such as a class should start with an underscore
    – for example, `_localVariable.`
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 所有属于对象（如类）的变量都应该以下划线开头 - 例如，`_localVariable.`
- en: This is helpful because it keeps the code consistent, which improves efficiency,
    readability, and maintenance. It helps others understand your code better. It
    also looks nice.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有帮助，因为它使代码保持一致，从而提高效率、可读性和可维护性。它帮助他人更好地理解您的代码。它看起来也很不错。
- en: Yoda conditions
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Yoda 条件
- en: 'When comparing variables and values, always compare the value to the variable
    and not the variable to the value. You can see this in the following code block:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当比较变量和值时，始终将值与变量进行比较，而不是将变量与值进行比较。您可以在以下代码块中看到这一点：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is helpful because it prevents you from accidentally assigning a value
    to the variable instead of comparing it and thus results in a true value and makes
    the if statement equate to true.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有帮助，因为它可以防止您意外地将值分配给变量而不是进行比较，从而得到一个真值，并使if语句等于真。
- en: Comments
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: This is an area that most people hate, and a lot of people miss out or leave
    until the end and then come to the realization that it’s a lot of effort at that
    stage, so I would recommend commenting in the code as you go along.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个大多数人都不喜欢的领域，很多人会错过或者拖到最后一刻才意识到这需要大量的努力，所以我会建议你在编写代码的过程中随时添加注释。
- en: 'When commenting in code, use `//` for single-line comments and `/* */` for
    multiline comments (the way your comment may vary based upon the programming language
    you are using) and all letters should be lowercase. You can see this in the following
    example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中注释时，使用 `//` 进行单行注释，使用 `/* */` 进行多行注释（根据你使用的编程语言，注释的方式可能会有所不同），并且所有字母都应该小写。你可以在下面的示例中看到这一点：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is useful when trying to understand what your code does, especially if
    it is complex and/or you are reading it after a prolonged period of time. It is
    also useful when other people/programmers are trying to understand your code,
    as you may code differently to other people and comments can be crucial to helping
    them understand what is going on.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当试图理解你的代码做了什么时，这很有用，尤其是如果它很复杂，或者你在长时间之后阅读它。当其他人/程序员试图理解你的代码时，这也很有用，因为你的编码方式可能与其他人不同，注释对于帮助他们理解正在发生的事情至关重要。
- en: No magic numbers
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 没有魔法数字
- en: A magic number is a number that looks like it is randomly placed in the code
    and doesn’t have any context or obvious meaning. This is what we would call an
    anti-pattern since reading and understanding code becomes very difficult to maintain.
    It is important that the code is intentional and that, just at a quick glance,
    you are able to understand it; this is fundamental to code quality.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法数字是一个看起来像是随机放置在代码中且没有任何上下文或明显意义的数字。这就是我们所说的反模式，因为阅读和理解代码变得非常困难，难以维护。代码必须是故意的，而且仅仅通过快速浏览，你就能理解它；这是代码质量的基础。
- en: 'Use constants and variables. `MAX_COUNT` is used instead of an arbitrary number
    such as 10\. You can see this in the following code snippet:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用常量和变量。使用 `MAX_COUNT` 而不是像 10 这样的任意数字。你可以在下面的代码片段中看到这一点：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This makes the code base easier to manage and understand.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得代码库更容易管理和理解。
- en: In this section, we looked at the coding standards I use. I felt it very important
    to explain them not necessarily to persuade you to use the ones that I opt for,
    but so you have a reference point if you see anything in the book that seems different
    from your own normal standards. Above all, else be consistent with your standards
    and consistent with any teammates that are collaborating with you. This is the
    most important thing; the specific standards used are secondary, but the consistency
    is primary.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了我在编码中使用的标准。我认为解释它们非常重要，不一定是为了说服你使用我选择的标准，而是为了在你看到书中任何似乎与你的正常标准不同之处时有一个参考点。最重要的是，与其他任何与你协作的队友保持标准的一致性。这是最重要的事情；使用的具体标准是次要的，但一致性是首要的。
- en: What is Swift?
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 Swift？
- en: In this section, we will cover what Swift is, its history, and how it works
    on a macro level. If you are an expert and just want to read about SwiftUI, feel
    free to skip this section.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍 Swift 是什么，它的历史，以及它在宏观层面上的工作方式。如果你是专家，只想阅读关于 SwiftUI 的内容，请随意跳过这一节。
- en: 'Swift is a programming language created by Apple and the open source community.
    It is a general-purpose, compiled, and multi-paradigm programming language. It
    was released in 2014 as a replacement for Apple’s previous language, Objective-C.
    Due to the fact that Objective-C had remained virtually the same since the early
    1980s, it was missing many features that modern languages have. Hence, the creation
    of Swift began; it has taken the Apple developer ecosystem by storm and is a hugely
    popular programming language. It is demanded by companies all over the world with
    excellent remuneration offered to those that know how to leverage its immense
    features. According to the PYPL index seen in the following figure, Swift is in
    the top 10 most popular languages, making it a must-have in any programmer’s arsenal:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 是由苹果公司和开源社区创建的一种编程语言。它是一种通用、编译和多种模式的编程语言。它于 2014 年发布，作为苹果之前语言 Objective-C
    的替代品。由于 Objective-C 自 20 世纪 80 年代初以来几乎保持不变，它缺少了许多现代语言所拥有的功能。因此，Swift 的创建开始了；它席卷了苹果开发者生态系统，成为了一种非常受欢迎的编程语言。全球各地的公司都需要它，并为那些知道如何利用其巨大功能的人提供优厚的报酬。根据以下图表中显示的
    PYPL 指数，Swift 是最受欢迎的 10 种语言之一，因此对于任何程序员来说都是必备的：
- en: '![Figure 1.1 – Popularity of Programming Language index (Source: https://www.stackscale.com/wp-content/uploads/2022/09/PYPL-index-popular-programming-languages-2022.jpg)](img/Figure_1.01_B18783.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – 编程语言流行指数（来源：https://www.stackscale.com/wp-content/uploads/2022/09/PYPL-index-popular-programming-languages-2022.jpg）](img/Figure_1.01_B18783.jpg)'
- en: 'Figure 1.1 – Popularity of Programming Language index (Source: [https://www.stackscale.com/wp-content/uploads/2022/09/PYPL-index-popular-programming-languages-2022.jpg](https://www.stackscale.com/wp-content/uploads/2022/09/PYPL-index-popular-programming-languages-2022.jpg))'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 编程语言流行指数（来源：[https://www.stackscale.com/wp-content/uploads/2022/09/PYPL-index-popular-programming-languages-2022.jpg](https://www.stackscale.com/wp-content/uploads/2022/09/PYPL-index-popular-programming-languages-2022.jpg)）
- en: 'Swift has been used to create many apps, including but not limited to the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 已被用于创建许多应用程序，包括但不限于以下：
- en: LinkedIn
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LinkedIn
- en: Firefox
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firefox
- en: WordPress
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WordPress
- en: Wikipedia
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wikipedia
- en: Lyft
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lyft
- en: Apple’s Cocoa and Cocoa Touch frameworks work with Swift out of the box. Furthermore,
    it works flawlessly with Apple’s previous programming language Objective-C, which
    has been used by developers for decades. This makes it one of the most modern
    but accessible languages around. Gone are the days when you would need to wait
    for frameworks to be released/updated for your chosen language; instead, thousands
    of projects already exist in Objective-C to use in the meantime.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Apple 的 Cocoa 和 Cocoa Touch 框架与 Swift 无缝协作。此外，它还与 Apple 之前的编程语言 Objective-C
    无缝协作，Objective-C 已被开发者使用了几十年。这使得它成为最现代且易于使用的语言之一。那些需要等待框架发布/更新以适应所选语言的年代已经过去了；相反，已经有成千上万的
    Objective-C 项目存在，可以在等待期间使用。
- en: 'Swift was built using the **Low-Level Virtual Machine** (**LLVM**) compiler
    framework, which is open source, is bundled with Xcode (since version 6), and
    was also released in 2014\. It uses the Objective-C runtime library on Apple devices,
    thus allowing code written in C, Objective-C, C++, and Swift to work together
    in a single application. The following figure explains the relationship between
    programming languages such as Swift, LLVM, and the different architectures from
    a macro level:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 是使用 **低级虚拟机** (**LLVM**) 编译器框架构建的，该框架是开源的，自 Xcode 6 版本以来捆绑提供，并于 2014 年发布。它使用
    Apple 设备上的 Objective-C 运行时库，因此允许用 C、Objective-C、C++ 和 Swift 编写的代码在单个应用程序中协同工作。以下图示从宏观层面解释了
    Swift、LLVM 和不同架构之间编程语言的关系：
- en: '![Figure 1.2 – LLVM and language relationship (Source: https://miro.medium.com/max/1024/1*VWogVHhCagxopvAKVFjBeA.jpeg)
    ](img/Figure_1.02_B18783.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – LLVM 和语言关系（来源：https://miro.medium.com/max/1024/1*VWogVHhCagxopvAKVFjBeA.jpeg）](img/Figure_1.02_B18783.jpg)'
- en: Figure 1.2 – LLVM and language relationship
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – LLVM 和语言关系
- en: '(Source: [https://miro.medium.com/max/1024/1*VWogVHhCagxopvAKVFjBeA.jpeg](https://miro.medium.com/max/1024/1*VWogVHhCagxopvAKVFjBeA.jpeg))'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: （来源：[https://miro.medium.com/max/1024/1*VWogVHhCagxopvAKVFjBeA.jpeg](https://miro.medium.com/max/1024/1*VWogVHhCagxopvAKVFjBeA.jpeg)）
- en: LLVM uses Clang on the frontend, which is a compiler for programming languages
    such as C, C++, CUDA, or swiftc for Swift. This then turns the code into a format
    that LLVM uses to convert into the machine code, which is then run/executed on
    the hardware.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 使用 Clang 作为前端，Clang 是 C、C++、CUDA 或 Swift 的 swiftc 编译器。然后它将代码转换为 LLVM 使用的格式，进而将其转换为机器代码，机器代码随后在硬件上运行/执行。
- en: 'For more information on LLVM, feel free to use the following links:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解更多关于 LLVM 的信息，请自由使用以下链接：
- en: '[https://llvm.org/](https://llvm.org/)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://llvm.org/](https://llvm.org/)'
- en: '[https://en.wikipedia.org/wiki/LLVM](https://en.wikipedia.org/wiki/LLVM)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/LLVM](https://en.wikipedia.org/wiki/LLVM)'
- en: '[https://github.com/llvm/llvm-project](https://github.com/llvm/llvm-project)'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/llvm/llvm-project](https://github.com/llvm/llvm-project)'
- en: '[https://www.youtube.com/watch?v=BT2Cv-Tjq7Q&ab_channel=Fireship](https://www.youtube.com/watch?v=BT2Cv-Tjq7Q&ab_channel=Fireship)'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.youtube.com/watch?v=BT2Cv-Tjq7Q&ab_channel=Fireship](https://www.youtube.com/watch?v=BT2Cv-Tjq7Q&ab_channel=Fireship)'
- en: '[https://www.youtube.com/watch?v=IR_L1xf4PrU&ab_channel=tanmaybakshi](https://www.youtube.com/watch?v=IR_L1xf4PrU&ab_channel=tanmaybakshi)'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.youtube.com/watch?v=IR_L1xf4PrU&ab_channel=tanmaybakshi](https://www.youtube.com/watch?v=IR_L1xf4PrU&ab_channel=tanmaybakshi)'
- en: '[https://www.youtube.com/watch?v=ZQds2aGHwDA&ab_channel=LexFridman](https://www.youtube.com/watch?v=ZQds2aGHwDA&ab_channel=LexFridman)'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.youtube.com/watch?v=ZQds2aGHwDA&ab_channel=LexFridman](https://www.youtube.com/watch?v=ZQds2aGHwDA&ab_channel=LexFridman)'
- en: '[https://www.youtube.com/watch?v=yCd3CzGSte8&ab_channel=LexFridman](https://www.youtube.com/watch?v=yCd3CzGSte8&ab_channel=LexFridman)'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.youtube.com/watch?v=yCd3CzGSte8&ab_channel=LexFridman](https://www.youtube.com/watch?v=yCd3CzGSte8&ab_channel=LexFridman)'
- en: 'To understand the features available to you as a developer in Swift from a
    macro perspective, take a look at the following diagram:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从宏观角度理解作为 Swift 开发者可用的功能，请查看以下图表：
- en: '![Figure 1.3 – Swift language reference](img/Figure_1.03_B18783.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – Swift 语言参考](img/Figure_1.03_B18783.jpg)'
- en: Figure 1.3 – Swift language reference
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – Swift 语言参考
- en: '(Source: [https://gogeometry.com/software/swift/swift-language-reference-mind-map.jpg](https://gogeometry.com/software/swift/swift-language-reference-mind-map.jpg))'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: （来源：[https://gogeometry.com/software/swift/swift-language-reference-mind-map.jpg](https://gogeometry.com/software/swift/swift-language-reference-mind-map.jpg)）
- en: The preceding diagram is a mind map showing all the high-level features provided
    by Swift and their subfeatures and how they all link together.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表是一个思维导图，展示了 Swift 提供的所有高级功能及其子功能以及它们如何相互关联。
- en: In this section, we covered what Swift is, how it works, and its popularity.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了 Swift 是什么，它是如何工作的，以及它的流行程度。
- en: What is SwiftUI?
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 SwiftUI？
- en: In this section, we will cover what SwiftUI is and the features provided that
    we will leverage throughout this book to create our projects. If you feel comfortable
    with SwiftUI and just want to see projects, then feel free to skip the remainder
    of this chapter.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍 SwiftUI 是什么，以及我们将利用本书中的哪些功能来创建我们的项目。如果您对 SwiftUI 感到舒适并且只想查看项目，那么请随意跳过本章的其余部分。
- en: 'SwiftUI is a user interface framework built on top of the Swift programming
    language. It provides many components for creating your app’s user interface;
    the following is a macro list of these components:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI 是建立在 Swift 编程语言之上的用户界面框架。它为创建应用程序的用户界面提供了许多组件；以下是对这些组件的宏观列表：
- en: Views and controls
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图和控制
- en: Shapes
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形状
- en: Layout containers
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布局容器
- en: Collection containers
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合容器
- en: Presentation containers
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 呈现容器
- en: In addition to the components in the preceding list, SwiftUI provides us with
    event handlers, allowing our apps to react to taps, gestures, and all other types
    of input they may receive from the user. The framework provides tools to manage
    the flow of data from the models to the views and controls that the end user interacts
    with.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面列表中的组件外，SwiftUI 还为我们提供了事件处理器，允许我们的应用程序对点击、手势以及可能从用户那里接收到的所有类型的输入做出反应。该框架提供了从模型到用户与之交互的视图和控制器的数据流管理的工具。
- en: Now we will look at the different core features of Swift, including examples
    that you can take away, modify, and use in your own projects.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨 Swift 的不同核心功能，包括您可以带走、修改并在自己的项目中使用的示例。
- en: Views and Controls
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图和控制
- en: Views and controls are the foundational blocks of your application’s UI. Using
    views, we can build the UI you want for your app. Its complexity can be whatever
    you desire, simple or immensely complex – it’s totally up to you – and we will
    see this in more detail in the upcoming sections.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 视图和控制是您应用程序 UI 的基础块。使用视图，我们可以构建您希望为应用程序创建的 UI。其复杂性可以是您想要的任何程度，简单或极其复杂——完全取决于您——我们将在接下来的章节中更详细地探讨这一点。
- en: 'Views can be any of the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 视图可以是以下任何一种：
- en: Text
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本
- en: Images
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图片
- en: Shapes
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形状
- en: Custom drawings
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义绘图
- en: A combination of all of these
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有这些的组合
- en: Controls enable user interaction with APIs that adapt to the platform and context
    they are used in.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 控件使用户能够与适应其使用平台和上下文的 API 进行交互。
- en: Shapes
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 形状
- en: Shapes in SwiftUI are 2D objects such as circles and rectangles. Custom paths
    can also be leveraged to set the parameters of your own shape/structure; we will
    see shapes in more detail in the coming sections.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI 中的形状是二维对象，如圆形和矩形。还可以利用自定义路径来设置您自己的形状/结构的参数；我们将在接下来的章节中更详细地探讨形状。
- en: 'Shapes provide features to add styling, including but not limited to the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 形状提供了添加样式的功能，包括但不限于以下内容：
- en: Environment-aware color
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境感知颜色
- en: Rich gradients
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 丰富的渐变
- en: Material effects in the foreground
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前景中的材质效果
- en: Background
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背景
- en: Outlines for your shapes
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形状的轮廓
- en: Layout Containers
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局容器
- en: Layouts have the job of organizing the elements of your app’s UI. Stacks and
    grids are used to update and modify the positions of the child views that are
    within them in response to changes in content or interface dimensions. Layouts
    can be nested within one another; this can be done to as many levels as desired,
    thus allowing you to create complex layouts. Custom layouts can also be designed
    for further flexibility; we will take a look at layout containers in more depth
    later on.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 布局负责组织应用UI的元素。堆叠和网格用于根据内容或界面尺寸的变化更新和修改其中子视图的位置。布局可以嵌套在彼此之中；这可以做到任意多级，从而允许你创建复杂的布局。还可以设计自定义布局以提供更多灵活性；我们将在稍后更深入地探讨布局容器。
- en: Collection Containers
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 收集容器
- en: Collections can be used to assemble dynamic views with complex functionality.
    For example, you can create a List view that allows you to scroll through a large
    set of data. The list automatically provides basic functionality, but in addition
    to this, you can add other functionality with minimal configuration, such as swiping,
    double tapping, and pull-to-refresh.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 收集可以用来组装具有复杂功能的动态视图。例如，你可以创建一个允许你滚动浏览大量数据的List视图。列表自动提供基本功能，但除此之外，你还可以通过最小配置添加其他功能，如滑动、双击和下拉刷新。
- en: If only a simple grid or stack configuration is required, use a Layout container
    instead; we will look at code examples to further illustrate these.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只需要简单的网格或堆叠配置，请使用布局容器；我们将通过代码示例进一步说明这些。
- en: Presentation Containers
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展示容器
- en: Presentation containers are used to provide structure to your app’s UI. This
    provides users with easier navigation for jumping around the app. This is extremely
    useful as the complexity of it increases and it contains more views. For example,
    you can enable navigating backward and forward through a set of views using a
    `NavigationStack`, and choosing which view to display from a tab bar using a `TabView`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 展示容器用于为应用UI提供结构。这使用户能够更容易地导航，在应用中跳转。当其复杂性增加且包含更多视图时，这尤其有用。例如，你可以通过`NavigationStack`启用在一系列视图之间前后导航，以及通过`TabView`选择要显示的视图。
- en: In this section, we covered the different features provided by SwiftUI on a
    macro level; we also discussed what sub-features they have and their uses.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了SwiftUI在宏观层面提供的不同功能；我们还讨论了它们的子功能和用途。
- en: Understanding and implementing views
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和实现视图
- en: In this section, we will look at views and how we can implement them in SwiftUI.
    We will also take a look at combining these views.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨视图以及如何在SwiftUI中实现它们。我们还将查看如何组合这些视图。
- en: Views are the fundamental building blocks of an application’s user interface.
    A view object renders content within its rectangle bounds and handles any interactions
    with that content.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 视图是应用用户界面的基本构建块。视图对象在其矩形边界内渲染内容并处理与该内容的任何交互。
- en: In the following sections, we will show the source code and examples for each
    type of view. If you would like further information, visit Apple’s documentation
    at [https://developer.apple.com/documentation/uikit/views_and_controls](https://developer.apple.com/documentation/uikit/views_and_controls).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下各节中，我们将展示每种类型视图的源代码和示例。如果你需要更多信息，请访问苹果的文档[https://developer.apple.com/documentation/uikit/views_and_controls](https://developer.apple.com/documentation/uikit/views_and_controls)。
- en: What are text views?
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本视图是什么？
- en: It is very common to need to display text in our app, and we do this by using
    a text view, which draws a string. By default, it has a font assigned to it that
    is best for the platform it is being displayed on; however, you can change the
    font using the `font(_:)` view modifier.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用中显示文本是非常常见的，我们通过使用文本视图来实现这一点，它绘制一个字符串。默认情况下，它分配了一个最适合其显示平台的字体；然而，你可以使用`font(_:)`视图修饰符来更改字体。
- en: 'The following snippet shows the code used to implement a text view:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段显示了实现文本视图所使用的代码：
- en: '[PRE13]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The text view was inserted into a `VStack` for padding purposes, but this is
    not a requirement.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 文本视图被插入到`VStack`中用于填充目的，但这不是必需的。
- en: The preceding code shows how to simply display a string using the Text view
    by passing a string of what you need to display.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码展示了如何通过传递一个字符串来使用Text视图简单地显示所需显示的内容。
- en: 'The following figure shows the output of the preceding code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了前面代码的输出：
- en: '![Figure 1.4 – Text view preview](img/Figure_1.04_B18783.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4 – 文本视图预览](img/Figure_1.04_B18783.jpg)'
- en: Figure 1.4 – Text view preview
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – 文本视图预览
- en: The next section will cover image views and how to implement them.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将介绍图片视图及其实现方法。
- en: What are Image views?
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图片视图是什么？
- en: Image views can be used to render images inside your SwiftUI layouts. Images
    are an excellent way of providing more context and improving the overall user
    experience. Image views can load images from your bundle, from system icons, from
    a `UIImage`, and more, but loading from your bundle and system icons will be the
    most commonly used method.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图片视图可以用来在SwiftUI布局中渲染图片。图片是提供更多上下文和改善整体用户体验的绝佳方式。图片视图可以从你的包、系统图标、`UIImage`等加载图片，但最常用的方法是加载从你的包和系统图标。
- en: 'The following snippet shows the code used to implement an image view:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了实现图片视图所使用的代码：
- en: '[PRE14]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, we implement an Image View with a system icon but you
    can easily specify your own image file. We will do this later in this chapter.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用系统图标实现了一个图片视图，但你也可以轻松指定自己的图片文件。我们将在本章后面这样做。
- en: In this example, a system icon was used but the process is similar for using
    your bundle and a `UIImage`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，使用了系统图标，但使用你的包和`UIImage`的过程是类似的。
- en: 'The following figure shows the output of the preceding code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了前面代码的输出：
- en: '![Figure 1.5 – Image view preview](img/Figure_1.05_B18783.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5 – 图片视图预览](img/Figure_1.05_B18783.jpg)'
- en: Figure 1.5 – Image view preview
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 – 图片视图预览
- en: The next section will cover the different shape views available to us and the
    code to use them.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将介绍我们可用的不同形状视图及其使用代码。
- en: What are shape views?
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 形状视图是什么？
- en: SwiftUI provides us with five primitive shapes that are commonly used. These
    shapes are rectangles, rounded rectangles, circles, ellipses, and capsules. The
    last three are very subtly different in how they behave based on what sizes you
    provide.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI为我们提供了五种常用的基本形状。这些形状是矩形、圆角矩形、圆形、椭圆形和胶囊。后三种在行为上非常微妙地不同，这取决于你提供的尺寸。
- en: 'The following code shows how you can simply implement any of the following
    shapes:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何简单地实现以下任何一种形状：
- en: '`Rectangle`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rectangle`'
- en: '`RoundedRectangle`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RoundedRectangle`'
- en: '`Capsule`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Capsule`'
- en: '`Ellipse`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ellipse`'
- en: '`Circle`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Circle`'
- en: 'Here’s the snippet:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码片段：
- en: '[PRE15]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The shapes were inserted into a `VStack` to arrange vertically and have padding
    around them.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这些形状被插入到`VStack`中以垂直排列，并在它们周围添加了填充。
- en: The preceding code shows how to implement the different shape views and the
    parameters needed for each one.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码展示了如何实现不同的形状视图以及每个视图所需的参数。
- en: 'The following figure shows the output of the preceding code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了前面代码的输出：
- en: '![Figure 1.6 – Shape views](img/Figure_1.06_B18783.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图1.6 – 形状视图](img/Figure_1.06_B18783.jpg)'
- en: Figure 1.6 – Shape views
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 – 形状视图
- en: In the next section, we will take a look at how we can use the views we have
    covered to combine and create more complex views.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何使用我们已覆盖的视图来组合和创建更复杂的视图。
- en: What are custom and combination views?
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义和组合视图是什么？
- en: For all frontend developers, one of the most crucial aspects of the development
    process is the implementation of the UI. We can create a simple UI with a combination
    of pre-made in-built views that we have leveraged thus far, but this is sometimes
    not enough; there are often cases when developers need to draw custom views programmatically
    to meet UI requirements, and if we are not able to draw those, it creates a problem.
    We are able to leverage the power of SwiftUI to create custom views, which are
    effectively a combination of the other views we learned about previously.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有前端开发者来说，开发过程中最关键的部分之一是实现用户界面（UI）。我们可以通过组合我们迄今为止利用的预制的内置视图来创建一个简单的UI，但有时这还不够；经常会有开发者需要程序化地绘制自定义视图以满足UI需求，如果我们无法绘制这些视图，就会产生问题。我们能够利用SwiftUI的力量来创建自定义视图，这些视图实际上是之前我们了解的其他视图的组合。
- en: 'The following code shows us an implementation of multiple views to create our
    own custom view that displays a mini profile:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何使用多个视图创建我们自己的自定义视图，该视图显示一个迷你个人资料：
- en: '[PRE16]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code shows how we can combine views to create custom views and
    how we can combine custom views to create more complex views. This also makes
    the mini views reusable.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码展示了如何组合视图来创建自定义视图，以及如何组合自定义视图来创建更复杂的视图。这也使得迷你视图可重用。
- en: 'The following figure shows the output of the preceding code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了前面代码的输出：
- en: '![Figure 1.7 – Custom view (mini profile)](img/Figure_1.07_B18783.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图1.7 – 自定义视图（迷你个人资料）](img/Figure_1.07_B18783.jpg)'
- en: Figure 1.7 – Custom view (mini profile)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – 自定义视图（迷你个人资料）
- en: In this section, we looked at combining the views from the previous sections
    to make reusable and combinable objects and create more complex views.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何将前几节中的视图组合起来，以创建可重用和可组合的对象，并创建更复杂的视图。
- en: In the next section, we will take a look at layouts to help organize the content
    in our app.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨布局，以帮助我们在应用中组织内容。
- en: Understanding and implementing layouts
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和实现布局
- en: This section will cover how we can arrange our views using layouts for a more
    dynamic user experience.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍如何使用布局来安排我们的视图，以实现更动态的用户体验。
- en: SwiftUI layouts allow us as developers to arrange views in your app’s interface
    using the layout tools provided. Layouts tell SwiftUI how to place a set of views,
    and how much space it needs to do so to provide the desired layout.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI布局允许我们作为开发者使用提供的布局工具来安排应用界面的视图。布局告诉SwiftUI如何放置一组视图，以及它需要多少空间来完成这项工作以提供所需的布局。
- en: 'Layouts can be but are not limited to any of the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 布局可以是以下任何一种，但不仅限于：
- en: Lazy stacks
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒加载堆叠
- en: 'Spacers:'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 间隔符：
- en: '`ScrollViewReader`'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScrollViewReader`'
- en: 'Grids:'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格：
- en: '`PinnedScrollableViews`'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PinnedScrollableViews`'
- en: In the following sections, we will show you the source code and examples for
    each type of layout.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下几节中，我们将向您展示每种布局的源代码和示例。
- en: Note
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you would like further information, visit Apple’s documentation: [https://developer.apple.com/documentation/uikit/view_layout](https://developer.apple.com/documentation/uikit/view_layout).'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要更多信息，请访问苹果的文档：[https://developer.apple.com/documentation/uikit/view_layout](https://developer.apple.com/documentation/uikit/view_layout)。
- en: What are lazy stacks?
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是懒加载堆叠？
- en: Lazy stacks are views that arrange their children in a line that expands vertically,
    creating items only as needed.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载堆叠是按行排列其子视图的视图，这些行垂直扩展，仅在需要时创建项目。
- en: SwiftUI provides two different types of lazy stacks, `LazyVStack` and `LazyHStack`.
    By default, `VStack` and `HStack` load all the content upfront, which will be
    slow if you use them inside a scroll view, as these views can contain a lot of
    content. If you want to load content in a lazy fashion, so it is only loaded when
    it appears in the view, and not when the view is generally visible but the content
    is not, you should use `LazyVStack` and `LazyHStack` as appropriate.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI提供了两种不同类型的懒加载堆叠，`LazyVStack`和`LazyHStack`。默认情况下，`VStack`和`HStack`会预先加载所有内容，如果您在滚动视图中使用它们，这将会很慢，因为这些视图可以包含大量内容。如果您想以懒加载的方式加载内容，即仅在内容出现在视图中时才加载，而不是在视图通常可见但内容不可见时加载，您应适当使用`LazyVStack`和`LazyHStack`。
- en: The word lazy, as explained by Apple, refers to the stack view not creating
    items until they are needed. What this means to you is that the performance of
    these stack views is already optimized by default.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 根据苹果的解释，懒指的是堆叠视图只有在需要时才创建项目。这意味着这些堆叠视图的性能默认已经进行了优化。
- en: '`LazyVStack` and `LazyHStack` are only available in iOS 14.0+, iPadOS 14.0+,
    macOS 11.0+, Mac Catalyst 14.0+, tvOS 14.0+, and watchOS 7.0+. More information
    can be found at the following links:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`LazyVStack`和`LazyHStack`仅在iOS 14.0+、iPadOS 14.0+、macOS 11.0+、Mac Catalyst
    14.0+、tvOS 14.0+和watchOS 7.0+中可用。更多信息可以在以下链接中找到：'
- en: '`LazyVStack` – [https://developer.apple.com/documentation/swiftui/lazyvstack](https://developer.apple.com/documentation/swiftui/lazyvstack)'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LazyVStack` – [https://developer.apple.com/documentation/swiftui/lazyvstack](https://developer.apple.com/documentation/swiftui/lazyvstack)'
- en: '`LazyHStack` – [https://developer.apple.com/documentation/swiftui/lazyhstack](https://developer.apple.com/documentation/swiftui/lazyhstack)'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LazyHStack` – [https://developer.apple.com/documentation/swiftui/lazyhstack](https://developer.apple.com/documentation/swiftui/lazyhstack)'
- en: 'The following code shows how we can use a `LazyVStack` to organize views vertically
    while also being efficient with large sums of data:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了我们如何使用`LazyVStack`来垂直组织视图，同时在大数据量下保持高效：
- en: '[PRE17]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding code implements a `LazyVStack` with `1000` text views. The text
    views are added using a loop to make it easier and more efficient.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码实现了一个包含`1000`个文本视图的`LazyVStack`。文本视图通过循环添加，使其更简单、更高效。
- en: 'The following figure shows the output of the preceding code:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了前面代码的输出：
- en: '![Figure 1.8 – Lazy stacks](img/Figure_1.08_B18783.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图1.8 – 懒加载堆叠](img/Figure_1.08_B18783.jpg)'
- en: Figure 1.8 – Lazy stacks
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 – 懒加载堆叠
- en: In the next section, we will take a look at spacers, which help us space out
    our content.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨间隔符，它们帮助我们分散内容。
- en: What are spacers?
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是间隔符？
- en: A spacer creates a view that is adaptive with no content that expands as much
    as it can. For example, when placed within an `HStack`, a spacer expands horizontally
    as is allowed by the stack, moving views out of the way, within the size limits
    of the stack.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 间隔创建了一个无内容的自适应视图，它可以尽可能多地扩展。例如，当放置在 `HStack` 中时，间隔会水平扩展，允许堆栈扩展，将视图移出堆栈，在堆栈的大小限制内。
- en: 'In the following code, we implement text and spacers:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们实现了文本和间隔：
- en: '[PRE18]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding code used a spacer with a height of `64` to separate the two text
    views.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用了一个高度为 `64` 的间隔来分隔两个文本视图。
- en: 'The following figure shows the output of the preceding code:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了前面代码的输出：
- en: '![Figure 1.9 – Spacer preview](img/Figure_1.09_B18783.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.9 – 间隔预览](img/Figure_1.09_B18783.jpg)'
- en: Figure 1.9 – Spacer preview
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9 – 间隔预览
- en: In the next section, we will look at `ScrollViewReader`, which enables us to
    move to any location.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨 `ScrollViewReader`，它使我们能够移动到任何位置。
- en: What are ScrollView and ScrollViewReader?
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ScrollView 和 ScrollViewReader 是什么？
- en: '`ScrollView` allows users to view content within a scrollable region. The user
    can perform platform-specific scroll gestures to adjust the visible portion of
    the content. `ScrollView` can scroll both horizontally and vertically but does
    not support zooming. If you want to programmatically move `ScrollView` to a specific
    location, you should add a `ScrollViewReader` inside it. This provides a method
    called `scrollTo()`, which moves to any view inside the parent `ScrollView`, simply
    by providing its anchor.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScrollView` 允许用户在可滚动区域内查看内容。用户可以通过执行平台特定的滚动手势来调整内容的可见部分。`ScrollView` 可以水平和垂直滚动，但不支持缩放。如果您想以编程方式将
    `ScrollView` 移动到特定位置，您应该在其中添加一个 `ScrollViewReader`。这提供了一个名为 `scrollTo()` 的方法，只需提供其锚点即可移动到父
    `ScrollView` 中的任何视图。'
- en: 'All of this can be achieved with a few simple lines of code. You can see this
    code as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以通过几行简单的代码实现。您可以通过以下方式查看此代码：
- en: '[PRE19]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding code implemented `ScrollViewReader` inside `ScrollView`. Inside
    that, we added a button to scroll to the text view, which has an `id` value of
    `45`. We used a loop to display `1000` text views with unique IDs.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码在 `ScrollView` 中实现了 `ScrollViewReader`。在其中，我们添加了一个按钮来滚动到具有 `id` 值为 `45`
    的文本视图。我们使用循环显示了 `1000` 个具有唯一 ID 的文本视图。
- en: 'The following figure shows the output of the preceding code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了前面代码的输出：
- en: '![Figure 1.10 – ScrollViewReader preview](img/Figure_1.10_B18783.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.10 – ScrollViewReader 预览](img/Figure_1.10_B18783.jpg)'
- en: Figure 1.10 – ScrollViewReader preview
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10 – ScrollViewReader 预览
- en: In the next section, we will look at grids, which allow us to organize our content
    in a table-like fashion.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨网格，它允许我们以表格形式组织我们的内容。
- en: What are grids?
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网格是什么？
- en: When SwiftUI was first released, it didn’t come with a collection view built
    in. Developers were left with one of two options – either to build their own or
    use a third-party solution. In WWDC 2020, Apple introduced new features for the
    SwiftUI framework. One of them was to address the need for grid views. SwiftUI
    now provides two new components, `LazyVGrid` and `LazyHGrid`. One is for vertical
    grids and the other is for horizontal grids.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当 SwiftUI 首次发布时，它没有内置集合视图。开发者只剩下两个选择——要么自己构建，要么使用第三方解决方案。在 2020 年的 WWDC 上，苹果为
    SwiftUI 框架引入了新功能。其中之一是解决网格视图的需求。现在，SwiftUI 提供了两个新的组件，`LazyVGrid` 和 `LazyHGrid`。一个是用于垂直网格，另一个是用于水平网格。
- en: 'The following code shows how we can implement a grid with two rows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何实现两行网格：
- en: '[PRE20]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding code snippet, we implement a grid of images set over two rows
    using a loop. `GridItem` components were used; Apple says these are descriptions
    of rows or columns in a lazy grid. What does this actually mean? Well, it’s essentially
    a method for specifying how many columns/rows we want, thus setting the layout
    pattern. `LazyGrid` uses this layout pattern when iterating through the items
    that are displayed and positioning them accordingly. If you are coming from a
    web background, you can think of it like the grid systems in responsive websites.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用循环实现了一个两行图像网格。使用了 `GridItem` 组件；苹果公司表示这些是懒加载网格中行或列的描述。这实际上意味着什么？嗯，它本质上是一种指定我们想要多少列/行的方法，从而设置布局模式。`LazyGrid`
    在迭代显示的项目并相应地定位它们时使用这种布局模式。如果您有网页背景，您可以将它想象成响应式网站中的网格系统。
- en: 'The following figure shows the output of the preceding code:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了前面代码的输出：
- en: '![Figure 1.11 – Grid preview](img/Figure_1.11_B18783.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.11 – 网格预览](img/Figure_1.11_B18783.jpg)'
- en: Figure 1.11 – Grid preview
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11 – 网格预览
- en: The next section will cover `PinnedScrollableViews`, which allow certain views
    to stick on the page as others scroll past them.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将介绍 `PinnedScrollableViews`，它允许某些视图在页面上的其他视图滚动过它们时保持粘性。
- en: What is PinnedScrollableView?
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 PinnedScrollableView？
- en: SwiftUI can provide a `PinnedScrollableView` inside a `ScrollView`. Pinned views
    are sticky views and can be applied to either a header or a footer.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI 可以在 `ScrollView` 内提供 `PinnedScrollableView`。固定视图是粘性视图，可以应用于头部或底部。
- en: 'The following code shows how we can pin a view to provide context to other
    views as they scroll past it:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了我们如何将视图固定以提供上下文，当其他视图滚动过它时：
- en: '[PRE21]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code snippet, we implemented a sticky view, which acted as
    the section header as the other views dynamically moved past it, but the sticky
    view moved off the screen when another section was reached, and it had its own
    sticky view.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们实现了一个粘性视图，它作为其他视图动态移动过它时的部分标题，但当达到另一个部分时，粘性视图会从屏幕上移除，并且它有自己的粘性视图。
- en: 'The following figure shows the output of the preceding code:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了前面代码的输出：
- en: '![Figure 1.12 – PinnedScrollableViews preview](img/Figure_1.12_B18783.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.12 – PinnedScrollableViews 预览](img/Figure_1.12_B18783.jpg)'
- en: Figure 1.12 – PinnedScrollableViews preview
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12 – PinnedScrollableViews 预览
- en: In this section, we covered the different layouts we have access to. These allow
    us to organize the data in a more pleasing fashion. In the next section, we will
    look at the different device previews for the projects that we will create throughout
    this book.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了我们可访问的不同布局。这些布局使我们能够以更令人愉悦的方式组织数据。在下一节中，我们将查看本书中我们将创建的项目不同设备预览。
- en: Device Previews
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备预览
- en: 'One of the many hurdles we will overcome is the differences between the four
    main Apple product categories. These categories are as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将克服的许多障碍之一是四个主要苹果产品类别之间的差异。这些类别如下：
- en: Mac – iMac, Mac Pro, MacBook, anything that runs macOS, even Hackintosh
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mac – iMac、Mac Pro、MacBook、任何运行 macOS 的设备，甚至是 Hackintosh
- en: iPad – Mini, regular, Air, Pro, all of them
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iPad – 迷你、常规、Air、Pro，所有这些
- en: iPhone – Mini, Pro, Pro Max, all iPhones
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iPhone – 迷你、Pro、Pro Max，所有 iPhone
- en: Apple Watch – small, big, old, or new
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apple Watch – 小型、大型、旧款或新款
- en: 'The obvious thing you will notice is that they get smaller and smaller. They
    naturally have different purposes; an Apple Watch won’t replace a Mac and vice
    versa. That is why the next eight chapters are grouped into pairs, one for each
    product category. We will uncover the design decisions and restrictions we have
    when creating our applications. Let’s take a look at the settings in each product
    category:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 你会立即注意到它们越来越小。它们自然有不同的用途；Apple Watch 不能取代 Mac，反之亦然。这就是为什么接下来的八个章节被分成对，每个产品类别一个。我们将揭示我们在创建应用程序时面临的设计决策和限制。让我们看看每个产品类别的设置：
- en: '**Mac**'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mac**'
- en: '![Figure 1.13 – Mac settings](img/Figure_1.13_B18783.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.13 – Mac 设置](img/Figure_1.13_B18783.jpg)'
- en: Figure 1.13 – Mac settings
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.13 – Mac 设置
- en: '**iPad**'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**iPad**'
- en: '![Figure 1.14 – iPad settings](img/Figure_1.14_B18783.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.14 – iPad 设置](img/Figure_1.14_B18783.jpg)'
- en: Figure 1.14 – iPad settings
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.14 – iPad 设置
- en: '**iPhone**'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**iPhone**'
- en: '![Figure 1.15 – iPhone settings](img/Figure_1.15_B18783.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.15 – iPhone 设置](img/Figure_1.15_B18783.jpg)'
- en: Figure 1.15 – iPhone settings
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.15 – iPhone 设置
- en: '**Apple Watch**:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**Apple Watch**:'
- en: '![Figure 1.16 – Apple Watch settings](img/Figure_1.16_B18783.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.16 – Apple Watch 设置](img/Figure_1.16_B18783.jpg)'
- en: Figure 1.16 – Apple Watch settings
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.16 – Apple Watch 设置
- en: At a quick glance, it is immediately apparent that there are differences. These
    are the very differences we will discuss during the remainder of this book. The
    next section will summarize this chapter before heading over to our first project.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，就可以立即看出它们之间存在差异。这正是我们将在本书剩余部分讨论的差异。下一节将总结本章内容，然后转向我们的第一个项目。
- en: Summary
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we covered the history of Swift and SwiftUI, the features provided
    to us on a macro level, and how Swift and SwiftUI work on a technical level. Then,
    we looked at the difference between Swift and SwiftUI and what features are offered,
    along with code samples for you to take away and use in your own projects. After
    that, we took a look at the requirements necessary for developing applications
    with Swift and SwiftUI. Then, we took a look at the coding standards that are
    used throughout this book, providing a reference point for any coding style that
    is unfamiliar to your own. Then, we looked at the views and controls provided
    by SwiftUI for creating our own user experiences, including custom views by combining
    the fundamentals. Finally, we took a look at how we can organize these views using
    layouts and checked the device previews too.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Swift 和 SwiftUI 的历史，以及我们在宏观层面提供的功能，以及 Swift 和 SwiftUI 在技术层面的工作原理。然后，我们探讨了
    Swift 和 SwiftUI 之间的区别以及提供了哪些功能，并附上了代码示例供您带走并在自己的项目中使用。之后，我们审视了使用 Swift 和 SwiftUI
    开发应用程序所需的必要条件。接着，我们审视了本书中使用的编码标准，为任何您不熟悉的编码风格提供了一个参考点。然后，我们探讨了 SwiftUI 提供的视图和控制，用于创建我们自己的用户体验，包括通过组合基础知识创建的自定义视图。最后，我们探讨了如何使用布局来组织这些视图，并检查了设备预览。
- en: In our next chapter, we’ll take a look at designing our first project, the tax
    calculator app that we will create.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们接下来的章节中，我们将探讨设计我们的第一个项目，即我们将创建的税务计算器应用程序。
