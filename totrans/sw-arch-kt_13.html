<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer110">
			<h1 id="_idParaDest-318" class="chapter-number"><a id="_idTextAnchor418"/>13</h1>
			<h1 id="_idParaDest-319"><a id="_idTextAnchor419"/>Testing</h1>
			<p>Software testing serves as a critical part of the software development life cycle, acting as a safeguard against defects and enhancing the overall quality of software products. Certification from <strong class="bold">Quality Assurance</strong> (<strong class="bold">QA</strong>) is often used as the indicator of whether the software product is ready to <span class="No-Break">go live.</span></p>
			<p>This chapter delves into the fundamental principles of software testing, exploring its significance, methodologies, and <span class="No-Break">best practices.</span></p>
			<p>We will discuss the role of QA and software testers in the industry. We will summarize the understanding of the role and how it might mean something different to <span class="No-Break">different people.</span></p>
			<p>We will explore several types of software testing and the testing pyramid. Additionally, we will discuss automated testing practices, which have gained popularity for their ability to enhance efficiency and ensure consistent <span class="No-Break">test coverage.</span></p>
			<p>We will also run an exercise of strict <strong class="bold">Test-Driven Development</strong> (<strong class="bold">TDD</strong>) using Kotest to gain insights into <span class="No-Break">this methodology.</span></p>
			<p>This chapter aims to provide a comprehensive overview of software testing, equipping you with the knowledge and tools necessary to implement effective testing strategies. This chapter will empower you to contribute to the creation of high-quality software that meets user expectations and stands the test of time. We are going to cover the following topics in <span class="No-Break">the chapter:</span></p>
			<ul>
				<li>The role of QA and its involvement in <span class="No-Break">software development</span></li>
				<li>The <span class="No-Break">testing pyramid</span></li>
				<li>TDD with <span class="No-Break">an exercise</span></li>
				<li><span class="No-Break">BDD</span></li>
				<li>Live testing, A/B testing, <span class="No-Break">and segmentation</span></li>
			</ul>
			<h1 id="_idParaDest-320"><a id="_idTextAnchor420"/>Technical requirements</h1>
			<p>You can find all the code files used in this chapter <span class="No-Break">on GitHub:</span></p>
			<p><a href="https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-13%0D"><span class="No-Break">https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-13</span></a></p>
			<h1 id="_idParaDest-321"><a id="_idTextAnchor421"/>The role of QA and software testers</h1>
			<p>The primary goals of software testing are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>To identify and<a id="_idIndexMarker1138"/> rectify defects before a product reaches the <span class="No-Break">end user</span></li>
				<li>To ensure the software product behaviors meet the functional specifications or <span class="No-Break">business expectations</span></li>
			</ul>
			<p>It is essential even for a startup company or the first product launch by a <span class="No-Break">new company.</span></p>
			<p>The role of QA or software tester can be confusing and is often misunderstood. Like software architect as a role, QA is not necessarily a job title, though you might have seen these titles in the <span class="No-Break">job market:</span></p>
			<ul>
				<li><span class="No-Break">QA</span></li>
				<li><span class="No-Break">QA tester</span></li>
				<li><span class="No-Break">QA engineer</span></li>
				<li><span class="No-Break">Quality engineer</span></li>
				<li><span class="No-Break">Software tester</span></li>
				<li><span class="No-Break">Test engineer</span></li>
				<li><span class="No-Break">Automation tester</span></li>
				<li><strong class="bold">Software Development Engineer in </strong><span class="No-Break"><strong class="bold">Test</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">SDET</strong></span><span class="No-Break">)</span></li>
			</ul>
			<p>Different organizations may<a id="_idIndexMarker1139"/> have different interpretations or expectations for each title. In this chapter, we use the term QA to represent an engineer who is responsible for <span class="No-Break">software quality.</span></p>
			<p>The role of a QA is illustrated in <span class="No-Break"><em class="italic">Figure 13</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<img src="image/B21737_13_1.jpg" alt="Figure 13.1 – The role of QA" width="1326" height="458"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – The role of QA</p>
			<p>It is important to emphasize that QA should be a full-time engagement embedded in the team organized by business functions, as <a id="_idIndexMarker1140"/>described in <a href="B21737_01.xhtml#_idTextAnchor013"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>. QAs, just like other engineers, are involved in understanding business priorities, requirement analysis, test plan creation, and acceptance <span class="No-Break">criteria definitions.</span></p>
			<p>However, from this point onward, QAs have a different focus than the engineers who develop the software for the business. QAs focus on overall testing strategies, test script creation, test processes<a id="_idIndexMarker1141"/> and tools, <strong class="bold">User Acceptance Test</strong> (<strong class="bold">UAT</strong>) planning, and <span class="No-Break">exploratory testing.</span></p>
			<p>The objectives of QAs are like those of the engineers who develop the software. They both want the software to have complete features that are good enough to meet business expectations. QAs do have a different focus and approaches to achieving the objectives though – by ensuring the software is developed to a high standard <span class="No-Break">as required.</span></p>
			<h2 id="_idParaDest-322"><a id="_idTextAnchor422"/>To code or not to code?</h2>
			<p>The question of whether a QA should code often lacks clarity. QAs should leverage all available tools and resources to meet software quality standards. Coding can be essential for creating<a id="_idIndexMarker1142"/> specific test scripts or enhancing tools. Ultimately, the debate about whether QAs should code is somewhat misguided; for many situations, writing code is a necessary part of <span class="No-Break">their role.</span></p>
			<p>Job titles for QA in the industry tend to include the term <em class="italic">engineers</em>  (e.g., QA engineers) when the organization expects the QA person to <span class="No-Break">write code.</span></p>
			<h2 id="_idParaDest-323"><a id="_idTextAnchor423"/>Software quality is everyone’s responsibility</h2>
			<p>It seems obvious to say that software quality is everyone’s responsibility, but it may not be so clear to some organizations. Software quality is best assured when it is embedded in the software development process<a id="_idIndexMarker1143"/> from the beginning to <span class="No-Break">the end.</span></p>
			<p>That includes all the activities during the software development process, starting from clear business priorities to well-written code, and eventually business user signoff and software launch. This involves every member of the team, not <span class="No-Break">just QAs.</span></p>
			<p>QA is the role that ensures software quality is taken care of every step of the way, so the outcome is a high-quality and well-tested <span class="No-Break">software product.</span></p>
			<p>With increasing complexity in software systems and the growing demand for robust applications, effective testing strategies are essential. By adopting a systematic approach to testing, organizations can mitigate risks, reduce costs associated with post-release defects, and foster <span class="No-Break">user trust.</span></p>
			<p>By fostering an environment that prioritizes QA, organizations can not only improve product outcomes but also enhance team collaboration <span class="No-Break">and communication.</span></p>
			<h1 id="_idParaDest-324"><a id="_idTextAnchor424"/>QA’s involvement in the software development life cycle</h1>
			<p>The team, including QAs, understands<a id="_idIndexMarker1144"/> business priorities collectively. Then the team analyzes the requirements together and creates a couple of user stories. Each <a id="_idIndexMarker1145"/>user story represents a unit of work and is a part of the bigger business feature, but each story also brings some value to <span class="No-Break">the business.</span></p>
			<p>A user story needs to be refined to have a set of acceptance criteria that decides whether the story has satisfied the expectations of stakeholders. Every acceptance criterion should be concise <span class="No-Break">and testable.</span></p>
			<p class="callout-heading">The convention of acceptance criteria</p>
			<p class="callout">An acceptance criterion can follow a popular structure of <strong class="bold">given-when-then</strong>. <em class="italic">Given</em> provides the initial context of the state of the system before the action is performed. <em class="italic">When</em> is the action performed given the context. <em class="italic">Then</em> is the expected outcome because of the action performed. An example of an acceptance criterion in given-when-then structure is as follows: <em class="italic">“Given that a household does not exist in the system, when the household creates an account in the system, then the corresponding household record </em><span class="No-Break"><em class="italic">is created.”</em></span></p>
			<p>From the acceptance <a id="_idIndexMarker1146"/>criteria, engineers start their <a id="_idIndexMarker1147"/>technical design on how to make a change to satisfy the conditions. Meanwhile, QAs start creating a test plan on how to verify that the change has satisfied <span class="No-Break">the conditions.</span></p>
			<p>The test plan should be cascaded into actual test scripts. Test scripts are detailed executable scripts describing how the software is tested. It includes setting up the data (the <em class="italic">given</em>), executing the actions (the <em class="italic">when</em>), and verifying the results (the <em class="italic">then</em>). The test scripts can be in any format, such as a document of the steps, an automation script, or even an independently executed program. The content of the testing is more important than <span class="No-Break">the format.</span></p>
			<p>In addition to scripted testing, QAs perform exploratory testing, which emphasizes the testers’ autonomy and creativity. QAs can explore the application freely, learning about it while actively testing it. Often, QAs find inconsistent system behaviors, loopholes, or hidden defects that cannot be discovered with fixed scripts. Exploratory tests are often time-boxed. There will also be a document on the findings, bugs discovered, unusual behaviors, and areas that require further <a id="_idIndexMarker1148"/>investigation. These documents are often hosted in an <strong class="bold">issue tracking system</strong> such as JIRA, Asana, Trello, GitHub Issues, and <span class="No-Break">so on.</span></p>
			<p>QAs are also involved in planning UATs where business testers (stakeholders and potentially real users) are involved. QAs help shape the testing process and are the ones to respond to queries by business testers. This is also an opportunity for QAs to confirm that the requirements are fully captured and to identify any features missed in <span class="No-Break">the scope.</span></p>
			<p>Apart from business delivery-focused testing activities, QAs are also responsible for having an overall testing strategy to align with other teams and share best practices. QAs are also responsible for maintaining test processes and tools. Quite often, QAs enhance existing test frameworks <a id="_idIndexMarker1149"/>and maintain the end-to-end <span class="No-Break">test suite.</span></p>
			<p>Up next, we are going to<a id="_idIndexMarker1150"/> concentrate on the testing methodology, starting with the <span class="No-Break">testing pyramid.</span></p>
			<h1 id="_idParaDest-325"><a id="_idTextAnchor425"/>Testing pyramid</h1>
			<p>The testing pyramid is a conceptual <a id="_idIndexMarker1151"/>framework in which various levels of tests in software development emerge as a hierarchical structure. This concept was made popular by Martin Fowler in 2009 in his <em class="italic">The Testing Pyramid</em> article. The testing pyramid is illustrated in <span class="No-Break"><em class="italic">Figure 13</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer108" class="IMG---Figure">
					<img src="image/B21737_13_2.jpg" alt="Figure 13.2 – Testing pyramid" width="1486" height="1096"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 – Testing pyramid</p>
			<p>In this section, we’ll explore all the levels of the <span class="No-Break">testing pyramid.</span></p>
			<h2 id="_idParaDest-326"><a id="_idTextAnchor426"/>Unit testing</h2>
			<p>The bottom level of the pyramid is unit testing. Unit tests are the foundation of the testing pyramid. They focus on the smallest building blocks that can be tested in isolation. They often<a id="_idIndexMarker1152"/> test the behaviors of functions, and they are executed as a part of the local <span class="No-Break">project build.</span></p>
			<p>Unit tests are comparatively easy to write and execute due to their small size and scope. Unit tests can be run inside the <strong class="bold">Integrated Development Environment</strong> (<strong class="bold">IDE</strong>), which provides the quickest feedback loop. Bugs can be found and reported by unit tests within minutes – if <span class="No-Break">not seconds.</span></p>
			<p>It is common for the local <a id="_idIndexMarker1153"/>project build to fail if any unit tests are unsuccessful. Integrating automated unit tests into the build process helps identify bugs early in development. Testing and fixing bugs is most cost-effective during unit testing because the bugs are smaller in size, require less effort to address, and provide quicker feedback compared to other testing stages. Additionally, a system typically has more unit tests than any other type of test, as unit tests target the smallest components, resulting in a larger quantity compared to <span class="No-Break">larger tests.</span></p>
			<p class="callout-heading">Unit tests should be meaningful</p>
			<p class="callout">While unit tests are the smallest building blocks that can be tested, there are a few cases where a function is too small to be tested. If engineers struggle to explain what the test aims to verify, it is likely that the function is too small to be tested. A private function usually does not <a id="_idIndexMarker1154"/>require a unit test, but a function that’s called by other packages (i.e., a public function) should have a unit test. Functions extracted merely to avoid duplicated code are unlikely to form a meaning that requires testing. To summarize, unit tests should <span class="No-Break">be meaningful.</span></p>
			<p>Here is an example of a unit test in Kotlin powered by the <span class="No-Break">Kotest framework:</span></p>
			<pre class="source-code">
class FindBiggestNumberKtTest : FunSpec({
    test("Find the biggest out of positive numbers") {
        <strong class="bold">findBiggestNumber</strong>(listOf(17, 18, 6)) shouldBe 18
    }
})</pre>			<p>The Kotest framework provides many test templates as specifications. <strong class="source-inline">FunSpec</strong> is the one used in the example. The test cases are passed in as lambda expressions. The <strong class="source-inline">test</strong> function takes the test name as an argument. A lambda expression under the scope of <strong class="source-inline">TestScope</strong> is passed in for the <a id="_idIndexMarker1155"/>actual test. This unit test targets the <strong class="source-inline">findBiggestNumber</strong> function, which is given a list of integers: <strong class="source-inline">17</strong>, <strong class="source-inline">18</strong>, and <strong class="source-inline">6</strong>. The <strong class="source-inline">shouldBe</strong> infix function mimics the natural English language and validates whether the expected result <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">18</strong></span><span class="No-Break">.</span></p>
			<h3>Parameterized testing</h3>
			<p>You might question whether one test case is not enough to thoroughly test this function. The Kotest framework supports<a id="_idIndexMarker1156"/> parameterized testing <a id="_idIndexMarker1157"/><span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class FindBiggestNumberParameterizedTest : FunSpec({
    context("Find the biggest out of positive numbers") {
        withData(
            emptyList&lt;Int&gt;() to null,
            listOf(8) to 8,
            listOf(99, 8) to 99,
            listOf(17, 18, 6) to 18,
            listOf(944, 0, 633) to 944,
            listOf(0, -32, 76) to 76,
            listOf(-11, -32, -102) to -11,
            listOf(-25, -57, 0) to 0,
            listOf(
                Integer.MAX_VALUE + 1,
                Integer.MAX_VALUE,
                0,
                Int.MIN_VALUE,
                -Int.MIN_VALUE - 1,
                -Int.MAX_VALUE,
                Int.MIN_VALUE - 1
            ) to Integer.MAX_VALUE,
        ) { (allNumbers, expectedMax) -&gt;
            findBiggestNumber(allNumbers) shouldBe expectedMax
        }
    }
})</pre>			<p>For a function that takes <a id="_idIndexMarker1158"/>a list of integers and returns the maximum number, there<a id="_idIndexMarker1159"/> are many cases we can <span class="No-Break">think of:</span></p>
			<ul>
				<li><span class="No-Break">Empty lists</span></li>
				<li>Lists of <span class="No-Break">one integer</span></li>
				<li>Lists of <span class="No-Break">two integers</span></li>
				<li>All <span class="No-Break">positive integers</span></li>
				<li>All <span class="No-Break">negative integers</span></li>
				<li>A mixture of zero, positive, and <span class="No-Break">negative integers</span></li>
				<li>Maximum, minimum, maximum plus one, minimum minus one, and the negation of <span class="No-Break">these integers</span></li>
			</ul>
			<p>With parameterized testing, it is possible to test them all with code footprints smaller than if we had to duplicate them into separate <span class="No-Break">test cases.</span></p>
			<p>At this point, you might want to see the source code of the function being tested, to ensure that you have covered all cases, but do you need to? There is no right or wrong answer here because it represents <a id="_idIndexMarker1160"/>two methods of software testing: <strong class="bold">blackbox testing</strong> and <strong class="bold">whitebox testing</strong>. Please note that these two testing styles are <a id="_idIndexMarker1161"/>applicable to all levels of testing in <span class="No-Break">the pyramid.</span></p>
			<p>Before we discuss these two testing styles in detail, let us reveal <span class="No-Break">the implementation:</span></p>
			<pre class="source-code">
fun findBiggestNumber(numbers: List&lt;Int&gt;): Int? = numbers.maxOrNull()</pre>			<p>It is a very simple implementation and uses the built-in <strong class="source-inline">maxOrNull</strong> Kotlin function to find the maximum number in the list or null for an <span class="No-Break">empty list.</span></p>
			<h3>Blackbox testing</h3>
			<p>Blackbox testing evaluates<a id="_idIndexMarker1162"/> the functionality being tested without any knowledge<a id="_idIndexMarker1163"/> of the internal code or structure. Testers focus merely on the inputs, expected outputs, and alleged functionality provided (known as <span class="No-Break">the </span><span class="No-Break"><em class="italic">contract</em></span><span class="No-Break">).</span></p>
			<h3>Whitebox testing</h3>
			<p>Whitebox testing goes in the <a id="_idIndexMarker1164"/>opposite direction. It involves examining the internal implementation of the functionality being tested. Testers have knowledge of the<a id="_idIndexMarker1165"/> code and internal logic, allowing them to design test cases based on the <span class="No-Break">implementation details.</span></p>
			<h3>Comparing blackbox and whitebox testing</h3>
			<p>Blackbox testing focuses <a id="_idIndexMarker1166"/>on the results and functionalities that would affect user experience. Not depending on implementation also enables<a id="_idIndexMarker1167"/> testers to discover any discrepancies between actual and expected behaviors, revealing requirements that may not have been thoroughly defined. It may, however, miss some code branches in the test suite, which potentially hinders complete code coverage. Organizations that have independent QA teams, separated from the development teams, typically use blackbox testing as their <span class="No-Break">default approach.</span></p>
			<p>Whitebox testing enables comprehensive testing of internal logic, leading to the discovery of hidden bugs or vulnerabilities under specific circumstances. Knowing the code also helps testers identify security vulnerabilities and optimization opportunities that would help meet the non-functional requirements. Knowing the code also brings bias in test cases to unknowingly omit test cases that can comprehensively cover external behaviors and <span class="No-Break">user </span><span class="No-Break"><a id="_idIndexMarker1168"/></span><span class="No-Break">experience.</span></p>
			<p>There are also human<a id="_idIndexMarker1169"/> factors in play between the two styles. Once a tester has seen the internal implementation, it is difficult to pretend not to have seen it before and to write bias-free <span class="No-Break">blackbox tests.</span></p>
			<p>Both test styles have their merits and disadvantages. Due to the human factor mentioned, it is recommended to start writing blackbox tests without knowing the implementation first and to focus on testing the external behaviors. Afterward, check the implementation to write whitebox test cases and focus on code branches and <span class="No-Break">non-functional requirements.</span></p>
			<p>This will lead to a topic called TDD, which will be covered later in <span class="No-Break">this chapter.</span></p>
			<h2 id="_idParaDest-327"><a id="_idTextAnchor427"/>Component testing</h2>
			<p>Known as <strong class="bold">module testing</strong>, component testing is one level above unit testing in the pyramid. It focuses on testing the <a id="_idIndexMarker1170"/>higher-order behaviors of self-contained modules. Component<a id="_idIndexMarker1171"/> focuses on the behaviors emerging from the interactions of several units <span class="No-Break">of code.</span></p>
			<p>Component tests are also<a id="_idIndexMarker1172"/> included as part of the local project build. So, if a component test has failed, the local project build fails. It is also often executed from IDE to provide a quick <span class="No-Break">feedback loop.</span></p>
			<p>However, component tests are bigger and require more effort to write. Each test usually involves setting a combination of states before the test. The test itself often involves multiple steps, and there are usually multiple places to verify the results. If there is a problem found, it is not immediately obvious where the problem is, and it would require some time to troubleshoot and debug. So, the cost of testing and fixing bugs is higher than <span class="No-Break">unit testing.</span></p>
			<p>One of the examples of component testing can be found in applications that use modular and layered architecture, as mentioned in <a href="B21737_07.xhtml#_idTextAnchor255"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>. For example, if we use the <strong class="bold">hexagonal architecture</strong>, component<a id="_idIndexMarker1173"/> testing can be conducted at the core layer to verify the pure business logic without coupling technology choices. This is particularly useful if the bounded context of the application belongs to the Core domain, as mentioned in <a href="B21737_08.xhtml#_idTextAnchor289"><span class="No-Break"><em class="italic">Chapter 8</em></span></a><span class="No-Break">.</span></p>
			<p>The core layer of the Core domain is often perceived as the “crown jewel” of the entire system. It serves as the heartbeat around which everything else revolves. It makes the case to use component testing to ensure the central pure business behaviors are intact in every change made in <span class="No-Break">the system.</span></p>
			<p>Component testing<a id="_idIndexMarker1174"/> the core layer of the Core domain with blackbox testing first would become the <strong class="bold">Behavior-Driven Development</strong> (<strong class="bold">BDD</strong>) approach, which will be discussed later in<a id="_idIndexMarker1175"/> <span class="No-Break">this chapter.</span></p>
			<h3>Mocking external resources</h3>
			<p>When writing component tests, it is almost inevitable to encounter situations when the code tries to integrate with external resources such as queues, files, databases, or other applications. These integration <a id="_idIndexMarker1176"/>points put a burden on the testers to prepare the context and increase the effort of writing <span class="No-Break">the test.</span></p>
			<p>Mocking enables testers to isolate the component being tested from external dependencies. There are a few common <span class="No-Break">mocking scenarios:</span></p>
			<ul>
				<li>Verify whether the component has interacted with the external dependencies as expected, such as checking whether the correct API with expected parameters <span class="No-Break">was called</span></li>
				<li>Enable the component test to run without needing external dependencies to be available, for example, <span class="No-Break">the database</span></li>
				<li>Verify whether the component can handle the failures of external dependencies <span class="No-Break">as expected</span></li>
				<li>Maintain states that allow testing different conditions, such as returning different values based on the context of <span class="No-Break">the tests</span></li>
			</ul>
			<p>Here is an example of component testing with mocking, also <span class="No-Break">using Kotest:</span></p>
			<pre class="source-code">
class ExerciseExecutorTest : BehaviorSpec({
    <strong class="bold">Given</strong>("Today is sunny") {
        val exerciseLog = mockk&lt;ExerciseLog&gt;()
        val executor = ExerciseExecutor(exerciseLog)
        <strong class="bold">every</strong> { exerciseLog.record(any(), any()) } <strong class="bold">returns</strong> Unit
        val weather = Weather.SUNNY
        <strong class="bold">When</strong>("doing an exercise") {
            val now = Instant.now()
            <strong class="bold">Then</strong>("running in the park") {
                <strong class="bold">executor.doExercise</strong>(weather, now) shouldBe Exercise.RunInThePark
            }
            <strong class="bold">And</strong>("the exercise is logged") {
                verify { <strong class="bold">exerciseLog.record</strong>(Exercise.RunInThePark, now) }
            }
        }
    }
})</pre>			<p>Firstly, this component test uses the <strong class="source-inline">BehaviorSpec</strong> from Kotest that follows the given-when-then format. It also <a id="_idIndexMarker1177"/>matches the test <a id="_idIndexMarker1178"/>pattern of <strong class="bold">Arrange, Act, </strong><span class="No-Break"><strong class="bold">Assert</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">3A</strong></span><span class="No-Break">).</span></p>
			<p class="callout-heading">The 3A test pattern</p>
			<p class="callout">The 3A test pattern can be used in<a id="_idIndexMarker1179"/> a unit test. It helps engineers and testers to organize tests by dividing them into three distinct sections. As a result, test scripts are easier to read, understand, reason, and maintain. <em class="italic">Arrange</em> is the initialization of preconditions and input data for the test. <em class="italic">Act</em> is the execution of the behaviors being tested. <em class="italic">Assert</em> is the verification of the actual outcome against the <span class="No-Break">expected result.</span></p>
			<p>Secondly, there is an external <strong class="source-inline">ExerciseLog</strong> dependency, which may involve persisting data in files <span class="No-Break">or </span><span class="No-Break"><a id="_idIndexMarker1180"/></span><span class="No-Break">databases:</span></p>
			<pre class="source-code">
interface ExerciseLog {
    fun record(time: Instant, exercise: Exercise)
}</pre>			<p>The function record accepts an <strong class="source-inline">Exercise</strong> object and the corresponding time when the exercise <span class="No-Break">was done:</span></p>
			<pre class="source-code">
enum class Weather {
    SUNNY,
    RAINY,
    CLOUDY,
    STORMY,
}</pre>			<p>As the focus of the test is the logic of <strong class="source-inline">ExerciseExecutor</strong>, not <strong class="source-inline">ExerciseLog</strong>, we use the <strong class="source-inline">mockk</strong> function from the <strong class="bold">Mockk</strong> library to create a mock object that implements the <strong class="source-inline">ExerciseLog</strong> interface. We set up<a id="_idIndexMarker1181"/> the mock object to accept the invocation of the <strong class="source-inline">record</strong> function with any parameters and to return <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">Unit</strong></span><span class="No-Break">.</span></p>
			<p>The primary validation is that when the weather is sunny, the function returns <strong class="source-inline">RunInThePark</strong>, as defined by this <span class="No-Break">sealed class:</span></p>
			<pre class="source-code">
sealed class Exercise {
    data object RunInThePark: Exercise()
    data object GoToGym: Exercise()
}</pre>			<p>The second validation is that <strong class="source-inline">ExerciseExecutor</strong> has passed the correct parameters to <strong class="source-inline">ExerciseLog</strong> to record this exercise. Here is the full implementation <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">ExerciseExecutor</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
class ExerciseExecutor(
    private val log: ExerciseLog
) {
    fun doExercise(
        weather: Weather,
        time: Instant
    ): Exercise {
        val exercise = when (weather) {
            Weather.SUNNY, Weather.CLOUDY -&gt; Exercise.RunInThePark
            Weather.STORMY, Weather.RAINY -&gt; Exercise.GoToGym
        }
        log.record(time, exercise)
        return exercise
    }
}</pre>			<p>Mocks are one of the<a id="_idIndexMarker1182"/> five types of <strong class="bold">test doubles</strong> used in software testing. Here is the <span class="No-Break">full list:</span></p>
			<ul>
				<li><strong class="bold">Mocks</strong>: These are pre-programmed <a id="_idIndexMarker1183"/>with expectations of how they should be used. They are used to verify whether the specific functions are invoked with the <span class="No-Break">expected parameters</span></li>
				<li><strong class="bold">Stubs</strong>: These<a id="_idIndexMarker1184"/> provide pre-defined responses to functions but do not <span class="No-Break">verify interactions.</span></li>
				<li><strong class="bold">Spies</strong>: Spies log the<a id="_idIndexMarker1185"/> parameters used and count the function calls. The actual function is <span class="No-Break">still invoked.</span></li>
				<li><strong class="bold">Fakes</strong>: These allow for a <a id="_idIndexMarker1186"/>simplified implementation of the external dependencies for <span class="No-Break">testing purposes.</span></li>
				<li><strong class="bold">Dummies</strong>: A dummy is a <a id="_idIndexMarker1187"/>simple object used just to satisfy parameter requirements without needing to implement <span class="No-Break">any behavior.</span></li>
			</ul>
			<h2 id="_idParaDest-328"><a id="_idTextAnchor428"/>Contract testing</h2>
			<p>Contract testing focuses on <a id="_idIndexMarker1188"/>the interaction between API producers and consumers. It only aims at the communication protocol and the message content. It should not be used for business case testing because we already have component testing covering it in the lower level of the <span class="No-Break">testing pyramid.</span></p>
			<p>There are two types of <span class="No-Break">contract testing:</span></p>
			<ul>
				<li><strong class="bold">Consumer testing</strong>: This focuses on the service that makes requests to another service. It defines the expectations of the interactions it will have with the producer, typically through a<a id="_idIndexMarker1189"/> contract. It also verifies that the <a id="_idIndexMarker1190"/>consumer service can handle all documented responses to the requests made. Consumer contract testing uses stubs or<a id="_idIndexMarker1191"/> fakes to set up the target service to <span class="No-Break">communicate with.</span></li>
				<li><strong class="bold">Producer testing</strong>: This focuses on the service <a id="_idIndexMarker1192"/>that provides the functionality or data requested by another service. It aims to assert that the producer has fulfilled the API contract and met the <a id="_idIndexMarker1193"/>expectations of its consumers. Producer tests may involve running the actual service, which makes it seem as though it should be higher up in the testing pyramid. It is also possible that producer testing mocks the business logic to produce the message and response defined in the contract. Producer testing is often used to ensure that updates and changes to contracts are <span class="No-Break">backward compatible.</span></li>
			</ul>
			<p>It is, however, important to have contract tests focus on the communication and message content only. For example, the <strong class="bold">OpenAPI</strong> specification document mentioned in <a href="B21737_04.xhtml#_idTextAnchor102"><span class="No-Break"><em class="italic">Chapter 4</em></span></a> is a good target for writing <a id="_idIndexMarker1194"/>contract tests. The contract tests ensure that both consumers and producers behave as specified in the <strong class="source-inline">openapi.yaml</strong> file. This leads to more reliable and maintainable systems, especially in <span class="No-Break">microservices architectures.</span></p>
			<h2 id="_idParaDest-329"><a id="_idTextAnchor429"/>Integration testing</h2>
			<p>Integration testing focuses on the interactions between different components or modules of the application. It is one level up from contract testing in the pyramid as integration tests do not use<a id="_idIndexMarker1195"/> stubs or fakes. They identify issues when integrating various <a id="_idIndexMarker1196"/>parts of the system and verify the parts work together as intended. Integration testing is also a part of the local <span class="No-Break">project build.</span></p>
			<p>Integration testing usually involves databases, file systems, external services, or APIs. The following are the common types of <span class="No-Break">integration testing:</span></p>
			<ul>
				<li><strong class="bold">API integration testing</strong>: Use the<a id="_idIndexMarker1197"/> exposed APIs to interact with the application for the given use case and to verify the result from <span class="No-Break">the response.</span></li>
				<li><strong class="bold">Database integration testing</strong>: Confirm that data is<a id="_idIndexMarker1198"/> correctly processed in the database. This is typically<a id="_idIndexMarker1199"/> related to <strong class="bold">Create, Read, Update, Delete</strong> (<span class="No-Break"><strong class="bold">CRUD</strong></span><span class="No-Break">) operations.</span></li>
				<li><strong class="bold">File system integration testing</strong>: Verify that the application can read from or write to files correctly, and verify the file <a id="_idIndexMarker1200"/>reflects the result of the operations in <span class="No-Break">the test.</span></li>
				<li><strong class="bold">Middleware or external service integration testing</strong>: Verify that the integration of middleware or <a id="_idIndexMarker1201"/>external service connectivity is correctly configured, as well as that the application and middleware or external service can communicate <span class="No-Break">as intended.</span></li>
			</ul>
			<p>Integration tests are bigger <a id="_idIndexMarker1202"/>than component and unit tests due to the required configuration and preparation. Integration tests are also more complex to write and reason about. Integration tests might involve various combinations of configurations, for instance, supporting multiple pluggable databases or message providers, while the business functionality remains <span class="No-Break">the same.</span></p>
			<p>Some tests may become uncertain due to how external resources or external services behave, especially if there is asynchronous processing external to <span class="No-Break">the application.</span></p>
			<p>Referring to component testing, if component testing focuses on the Core layer of a hexagonal architecture application, then integration testing focuses on the <span class="No-Break">adapter layer.</span></p>
			<p>Extending the exercise code example, we are going to write an integration test for an implementation of the <strong class="source-inline">ExerciseLog</strong> interface that appends a line to a file for each invocation. Each line starts with a local date-time using UTC, separated by a colon, and ends with the name of the exercise, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
2024-09-30T18:39:03.353250: GoToGym</pre>			<p>An integration test can be written <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class ExerciseExecutorIntegrationTest : StringSpec({
    "Gym when cloudy and run in the park when rainy as recorded in file log" {
        val file = File.createTempFile("Exer", "cise")
            .apply { deleteOnExit() }
        val exec = ExerciseExecutor(ExerciseFileLog(file))
        val now = Instant.now()
        val fourHoursLater = now.plus(4, HOURS)
        val utc = ZoneId.of("UTC")
        exec.<strong class="bold">doExercise</strong>(RAINY, now)
        exec.<strong class="bold">doExercise</strong>(CLOUDY, fourHoursLater)
        <strong class="bold">FileReader(file).readLines()</strong> shouldBe listOf(
"${now.atZone(utc).toLocalDateTime()}: GoToGym",
"${fourHoursLater.atZone(utc).toLocalDateTime()}: RunInThePark",
        )
    }
})</pre>			<p>The test starts by creating a temporary file that will be deleted on exit. Then a list of two exercise entries is passed<a id="_idIndexMarker1203"/> into the <strong class="source-inline">ExerciseFileLog</strong> object. The verification starts by reading the file line by line and asserts that each line contains the <span class="No-Break">expected content.</span></p>
			<p>The <strong class="source-inline">ExerciseFileLog</strong> class itself <span class="No-Break">is straightforward:</span></p>
			<pre class="source-code">
class ExerciseFileLog(
    private val file: File,
) : ExerciseLog {
    val utc = ZoneId.of("UTC")
    override fun record(
        time: Instant,
        exercise: Exercise,
    ) {
        try {
            val utcDateTime = time.atZone(utc).toLocalDateTime()
            val text = "$utcDateTime: $exercise\n"
            file.appendText(text)
        } catch (e: IOException) {
            println("error writing to the file: $file")
        }
    }
}</pre>			<p>Test scripts should <a id="_idIndexMarker1204"/>mostly be integration tests in the supporting and generic subdomain applications, as discussed in <a href="B21737_08.xhtml#_idTextAnchor289"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>. This is because these subdomains usually do not contain a lot of business logic, or the combination of business cases is simple enough to be covered by <span class="No-Break">integration tests.</span></p>
			<h2 id="_idParaDest-330"><a id="_idTextAnchor430"/>End-to-end and automated GUI testing</h2>
			<p>So far, all the tests we have discussed have focused on either a single backend service or a specific group of software <a id="_idIndexMarker1205"/>components. The next level is end-to-end automated testing, which includes graphical user interface (GUI) testing and contract testing. This <a id="_idIndexMarker1206"/>type of testing evaluates system behavior across multiple services horizontally and across various tiers vertically. Additionally, it <a id="_idIndexMarker1207"/>becomes more transparent to <span class="No-Break">business stakeholders.</span></p>
			<p>End-to-end and automated GUI testing focuses on a user journey that covers multiple services or components in the system. For example, an end-to-end test could involve creating two household records, and then having one household draft a contract with another household. Both households would then negotiate to reach an agreed contract, and finally, each of them would exercise the contract for the service described in <span class="No-Break">the contract.</span></p>
			<p>End-to-end testing uses APIs for communication with various parts of the system, while automated GUI testing simulates human interaction with <span class="No-Break">the system.</span></p>
			<p>Some systems have a suite of public APIs for<a id="_idIndexMarker1208"/> integration with external <strong class="bold">Software-as-a-Service</strong> (<strong class="bold">SaaS</strong>) platforms (as discussed in <a href="B21737_06.xhtml#_idTextAnchor212"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>). In this case, end-to-end testing should ensure that the user journey can be fulfilled by calling the exposed public APIs. The testing of this public API integration, known as headless integration, is as important as visual <span class="No-Break">GUI testing.</span></p>
			<p>The test script for one user<a id="_idIndexMarker1209"/> journey is complex and fragile. It requires multiple services to be operational in an environment, which implies stable infrastructure as well. It is not practical to test all the variations of user journeys, as the test suite takes a<a id="_idIndexMarker1210"/> long time <span class="No-Break">to finish.</span></p>
			<p>Tests at this level typically only cover the<a id="_idIndexMarker1211"/> most crucial and user-facing features. They also usually only cover successful cases. The tests are run periodically, or on demand. If an error is found during the test, it would take a longer time to troubleshoot, and sometimes it could be caused by stability issues in the environment instead of <span class="No-Break">actual bugs.</span></p>
			<h2 id="_idParaDest-331"><a id="_idTextAnchor431"/>Manual and exploratory testing</h2>
			<p>Manual and exploratory testing is <a id="_idIndexMarker1212"/>the highest level in the pyramid. It is not automated, so it is up to the QAs to manually run through the cases. This level of testing is the most time-consuming <a id="_idIndexMarker1213"/><span class="No-Break">and laborious.</span></p>
			<p>If a manual can be automated, QAs will aim to automate it as soon as possible to reduce the cost. There are a few cases where manual testing <span class="No-Break">is necessary:</span></p>
			<ul>
				<li><strong class="bold">Usability testing</strong>: Evaluating user <a id="_idIndexMarker1214"/>experience requires subjective analysis, involving elements such as visual layout, design, and <span class="No-Break">overall satisfaction.</span></li>
				<li><strong class="bold">Short-lived features</strong>: Investment in automating tests may not be justified for <span class="No-Break">short-lived features.</span></li>
				<li><strong class="bold">Context-heavy testing</strong>: Some tests heavily depend on complex workflows, interactions, or context understanding. Automating these tests to be reliable could outweigh the effort of testing <span class="No-Break">them manually.</span></li>
				<li><strong class="bold">Security testing</strong>: Many security assessments, such as penetration testing, rely on the security expertise of humans to<a id="_idIndexMarker1215"/> identify vulnerabilities that automated tests may not catch. Some<a id="_idIndexMarker1216"/> tests require a quick pivot of the next step decided by security experts; these are difficult <span class="No-Break">to automate.</span></li>
			</ul>
			<p>Manual and exploratory testing is often executed on an ad hoc basis; however, some organizations allow QAs to timebox exploratory testing to discover hidden defects and <span class="No-Break">usability issues.</span></p>
			<h2 id="_idParaDest-332"><a id="_idTextAnchor432"/>Benefits of the testing pyramid</h2>
			<p>The testing pyramid serves as a guiding principle for structuring a testing strategy in software development. As testing and bug fixing become more expensive going up each level, it is natural to prioritize unit <a id="_idIndexMarker1217"/>tests, followed by component tests, all the way up to manual tests, so the team can achieve a more efficient and cost-effective <span class="No-Break">QA process.</span></p>
			<p>By putting test cases at their appropriate level in the pyramid, the team not only enhances the overall quality of the software but also allows for a quick iterative feedback loop that incrementally improves software <span class="No-Break">development practices.</span></p>
			<p>So far, all the test case examples in this chapter have only used Kotest. However, there are a few other frameworks that can be considered <span class="No-Break">as well:</span></p>
			<ul>
				<li><span class="No-Break">Atrium: </span><a href="https://github.com/robstoll/atrium%0D"><span class="No-Break">https://github.com/robstoll/atrium</span></a></li>
				<li><span class="No-Break">Kluent: </span><a href="https://markusamshove.github.io/Kluent/%0D"><span class="No-Break">https://markusamshove.github.io/Kluent/</span></a></li>
				<li><span class="No-Break">Spek: </span><a href="https://spekframework.github.io/spek/docs/latest/%0D"><span class="No-Break">https://spekframework.github.io/spek/docs/latest/</span></a></li>
			</ul>
			<p>Up next, we are going to discuss the <span class="No-Break">TDD approach.</span></p>
			<h1 id="_idParaDest-333"><a id="_idTextAnchor433"/>TDD</h1>
			<p>TDD has a history dating back to the 1970s, when the idea of “test-first” programming was discussed. It was not <a id="_idIndexMarker1218"/>popular until TDD became a part<a id="_idIndexMarker1219"/> of <strong class="bold">Extreme Programming</strong> (<strong class="bold">XP</strong>), which was introduced by Kent Beck in <span class="No-Break">the 1990s.</span></p>
			<p class="callout-heading">XP</p>
			<p class="callout">XP is an agile software development methodology that aims to deliver high-quality software, meet evolving user requirements, and reduce risks due to uncertainties in the process. It has five core values — <em class="italic">communication</em>, <em class="italic">simplicity</em>, <em class="italic">feedback</em>, <em class="italic">courage</em>, and <em class="italic">respect</em>. It emphasizes short iterative development cycles and close collaboration between developers and stakeholders, encouraging frequent feedback to adapt to changing requirements. The key practices of XP include pair programming, TDD, continuous integration, and frequent releases of small and <span class="No-Break">incremental changes.</span></p>
			<p>In 2002, Beck published the book <em class="italic">Test-Driven-Development: By Example</em>, which provided detailed guidance on the TDD process and has since significantly influenced a lot of engineering practices, even today. TDD has even become a must-have interview coding practice in <span class="No-Break">some organizations.</span></p>
			<p>TDD uses a simple workflow of writing tests and production code, as shown in <span class="No-Break"><em class="italic">Figure 13</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="image/B21737_13_3.jpg" alt="Figure 13.3 – TDD workflow" width="1426" height="630"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3 – TDD workflow</p>
			<p>The first step of TDD is to write a list of test scenarios. Test scenarios are written in business language that does not involve technical implementation. It describes what the expected behavior of the application is under certain conditions, without knowing how the application <span class="No-Break">achieves it.</span></p>
			<p>A test scenario is picked from the list, and we start writing the test. This part is interesting because the test case code usually does not compile due to requiring an enhancement of current APIs or a new API. This is normal because API contracts should be derived from the needs of the user, not the provider. Designing an API from users’ perspectives naturally <a id="_idIndexMarker1220"/>conforms to the <strong class="bold">Interface Segregation Principle</strong> (<strong class="bold">ISP</strong>), which we discussed in <a href="B21737_02.xhtml#_idTextAnchor045"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>. The test case should set up the preconditions, attempt to execute the steps, and verify <span class="No-Break">the result.</span></p>
			<p>At this moment, you are left with a test case that either does not pass (<strong class="bold">red</strong>) or does not even compile. The next step is to change the code so that the test passes (<strong class="bold">green</strong>). It is important to ensure that<a id="_idIndexMarker1221"/> all other tests pass too. This is exactly what the influential advocator of TDD, Kent Beck, suggested when he said <em class="italic">“fake it till you </em><span class="No-Break"><em class="italic">make it”</em></span><span class="No-Break">.</span></p>
			<p>The test will now pass, but you might not be unsatisfied because the code can be optimized or organized better. This is your <a id="_idIndexMarker1222"/>opportunity to improve quality by refactoring the code while ensuring all tests continue to pass. That is why TDD has another <span class="No-Break">name: </span><span class="No-Break"><strong class="bold">red-green-refactor</strong></span><span class="No-Break">.</span></p>
			<p>There may be more test scenarios that need test cases written, or we may discover missed test scenarios. Nonetheless, the cycle repeats until there are no more test cases <span class="No-Break">to write.</span></p>
			<h2 id="_idParaDest-334"><a id="_idTextAnchor434"/>An exercise on TDD</h2>
			<p>The essence of TDD is best experienced in practice. So, we are going to run through a small exercise <span class="No-Break">on TDD.</span></p>
			<p>The team is asked to develop a feature to allow users to create a household record in the system. There is no code written for <span class="No-Break">this feature.</span></p>
			<h3>Step 1 – write a list of test scenarios</h3>
			<p>The first step for TDD is to write a list of test scenarios. QAs and engineers should ask stakeholders a lot of questions and turn these answers into test scenarios. Here are <span class="No-Break">some examples:</span></p>
			<ul>
				<li>What are the attributes <a id="_idIndexMarker1223"/>of a household record? The answer would be a surname and <span class="No-Break">email address.</span></li>
				<li>Can two different households have the same surname? No, this is a small village where all households have <span class="No-Break">distinct surnames.</span></li>
				<li>Can a household have no <span class="No-Break">surname? No.</span></li>
			</ul>
			<p>This is the first draft list of test scenarios from <span class="No-Break">the answers:</span></p>
			<ul>
				<li>Fail to create a household with an <span class="No-Break">empty surname</span></li>
				<li>Successfully create <span class="No-Break">a household</span></li>
				<li>Fail to create a household if the surname <span class="No-Break">already exists</span></li>
			</ul>
			<p>Now we can pick the first test scenario and write a <span class="No-Break">test case.</span></p>
			<h3>Step 2 – write a test case</h3>
			<p>We want to assert that creating a household record with an empty surname results in failure. Again, we are using <a id="_idIndexMarker1224"/>Kotest framework’s <strong class="source-inline">StringSpec</strong> as the <span class="No-Break">testing style:</span></p>
			<pre class="source-code">
class HouseholdServiceTest : StringSpec({
        "fail to create household of empty surname" {
            val service = HouseholdService()
            service.createHousehold(Household(surname = "")) shouldBe Failure(
                "Surname must be non-empty"
            )
        }
    })</pre>			<p>This test case creates a <strong class="source-inline">HouseholdService</strong> object and then invokes the <strong class="source-inline">createHousehold</strong> function with a <strong class="source-inline">Household</strong> object with an empty surname. The test expects the function to return a <strong class="source-inline">Failure</strong> object that provides an appropriate reason for <span class="No-Break">the failure.</span></p>
			<p>Obviously, the code does not compile. The <strong class="source-inline">HouseholdService</strong> and <strong class="source-inline">Failure</strong> classes are dreamed up <a id="_idIndexMarker1225"/>by the test case. They do not exist. However, writing this test case requires us to consider how the API should be built and what the user’s <span class="No-Break">expectations are.</span></p>
			<h3>Step 3 – make tests pass</h3>
			<p>Your IDE should indicate <a id="_idIndexMarker1226"/>compilation errors for the non-existing classes and functions. Hopefully, your IDE should have a “quick fix” function that creates classes for you. It is recommended to let the IDE first create all classes, then functions, so the IDE has the context to generate functions with new classes. These classes are empty and may look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
class Failure(reason: String) { }
class Household(surname: String) { }
class HouseholdService {
    fun createHousehold(household: Household): Failure {
        TODO("Not yet implemented")
    }
}</pre>			<p>We are ready to run the test. It has failed with <span class="No-Break">this message:</span></p>
			<pre class="console">
kotlin.NotImplementedError: An operation is not implemented: Not yet implemented.</pre>			<p>This is a good start. The test runs and it is red (i.e., it has failed). Now try to <em class="italic">make it green</em> with the <em class="italic">simplest </em><span class="No-Break"><em class="italic">possible implementation</em></span><span class="No-Break">.</span></p>
			<p>Hardcoding the function to return the expected <strong class="source-inline">Failure</strong> object would be the simplest option, wouldn’t it? Most engineers would feel the urge to fix everything and make the classes reasonable. However, the goal here is to write the least amount of code to make the test pass. Here are <span class="No-Break">the changes:</span></p>
			<pre class="source-code">
data class Failure(val reason: String)
class Household(surname: String) { }
class HouseholdService {
    fun createHousehold(household: Household) = Failure("Surname must be non-empty")
}</pre>			<p>The <strong class="source-inline">Failure</strong> class <a id="_idIndexMarker1227"/>has changed to a <strong class="source-inline">data</strong> class so that the test case gets the reason for verification. The <strong class="source-inline">createHousehold</strong> function now returns a hardcoded <strong class="source-inline">Failure</strong> object just to pass the test. The <strong class="source-inline">Household</strong> class has <span class="No-Break">not changed.</span></p>
			<p>At this point, this is only a hack implementation. However, it will evolve with more test cases. Let us pick the next <span class="No-Break">test scenario.</span></p>
			<h3>Step 2 again – a new test case</h3>
			<p>The next test scenario is the<a id="_idIndexMarker1228"/> successful creation of a household record. The surname of the household is no longer empty, and the test expects <strong class="source-inline">HouseholdService</strong> to respond with a successful result that contains the created <strong class="source-inline">Household</strong> record. See the code of the test <span class="No-Break">case here:</span></p>
			<pre class="source-code">
"successfully create a household" {
    val service = HouseholdService()
    val household = Household(surname = Arb.string(minSize = 3).next())
    service.createHousehold(household) shouldBe Success(household)
}</pre>			<p>The test case uses the <strong class="source-inline">Arb</strong> class from the Kotest property module (<strong class="source-inline">io.kotest:kotest-property</strong>) to generate a random surname for the <strong class="source-inline">Household</strong> object. The test case uses a randomly generated string with a minimum size of three as <span class="No-Break">the surname.</span></p>
			<p>Again, the test case does not compile. The <strong class="source-inline">Success</strong> class does not exist, and the <strong class="source-inline">createHousehold</strong> function does not return such <span class="No-Break">a type.</span></p>
			<h3>Step 3 again – make all tests pass</h3>
			<p>Aiming to have two test cases pass is <a id="_idIndexMarker1229"/>going to drive the code’s development. This is quite literally development driven by tests. We can use the IDE feature to generate the <strong class="source-inline">Success</strong> class. It is also easy enough to write <span class="No-Break">one ourselves:</span></p>
			<pre class="source-code">
data class Success(val household: Household)</pre>			<p>The compilation error is resolved. We need to run <em class="italic">all</em> the tests during the TDD cycle. This is to ensure that we do not break existing tests. Test results show that the first test still passes, but the second test fails with the <span class="No-Break">following message:</span></p>
			<pre class="console">
Expected :Success(household=example.tdd.step2_2.Household@1f958876)
Actual   :Failure(reason=Surname must be non-empty)</pre>			<p>We need the <strong class="source-inline">createHousehold</strong> function to return a <strong class="source-inline">Success</strong> object for successful creation or a <strong class="source-inline">Failure</strong> object for failure. The simplest approach is the use of Kotlin’s <strong class="source-inline">sealed</strong> class. Engineers may use other constructs, such as <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">Result4k&lt;Household, String&gt;</strong> from the <strong class="bold">Result4K</strong> library (<a href="https://github.com/fork-handles/forkhandles/tree/trunk/result4k">https://github.com/fork-handles/forkhandles/tree/trunk/result4k</a>), where the left parameter is the type for success<a id="_idIndexMarker1230"/> response, and the right parameter indicates the failure message <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">String</strong></span></li>
				<li><strong class="source-inline">Either&lt;String, Household&gt;</strong> from the <strong class="bold">Arrow</strong> library (<a href="https://arrow-kt.io/">https://arrow-kt.io/</a>), where the left <a id="_idIndexMarker1231"/>parameter indicates the failure message as <strong class="source-inline">String</strong>, and the right parameter is the type for the <span class="No-Break">success response</span></li>
			</ul>
			<p>The <strong class="source-inline">sealed</strong> class approach would look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
sealed class Result {
    data class Success(val household: Household): Result()
    data class Failure(val reason: String): Result()
}</pre>			<p>The <strong class="source-inline">createHousehold</strong> function needs to evolve to handle both test cases. Doing so would require removing the previous hack implementation and implementing actual validation logic. The <strong class="source-inline">Household</strong> class is changed to a <strong class="source-inline">data</strong> class so the function can access the surname to perform <span class="No-Break">the validation:</span></p>
			<pre class="source-code">
data class Household(val surname: String)</pre>			<p>The function has <a id="_idIndexMarker1232"/>changed the return type to <strong class="source-inline">Result</strong>. A simple validation is also added to ensure that only non-blank surnames <span class="No-Break">are accepted:</span></p>
			<pre class="source-code">
fun createHousehold(household: Household): Result =
    if (household.surname.isNotBlank()) {
        Success(household)
    } else {
        Failure("Surname must be non-empty")
    }</pre>			<p>Now all tests have passed. However, the use of the <strong class="source-inline">IsNotBlank</strong> function might get you thinking that non-empty strings filled with spaces or tabs should have resulted in failure, but these cases are <span class="No-Break">not tested.</span></p>
			<h3>Step 4 – refactor code</h3>
			<p>We want to enhance the first test case by parameterizing several blank strings, as well as mixing whitespaces, tabs, and new-line characters. The <strong class="source-inline">DescribeSpec</strong> in Kotest supports this type of parameterization better, so the test class is changed to inherit from <strong class="source-inline">DescribeSpec</strong>. This change<a id="_idIndexMarker1233"/> also affects test case number two, and all test names are <span class="No-Break">updated accordingly:</span></p>
			<pre class="source-code">
class HouseholdServiceTest : DescribeSpec({
  val blankStrings = listOf("", " ", "\t", "\n", "  ", " \t", " \t \n ")
  <strong class="bold">describe("household creation")</strong> {
    blankStrings.forEach { blankString -&gt;
      <strong class="bold">it("ensures surname is not blank")</strong> {
        val service = HouseholdService()
        service.createHousehold(Household(surname = blankString)) shouldBe Failure("Surname must be non-empty")
      }
    }
    <strong class="bold">it("succeeds with non-blank surname")</strong> {
      val service = HouseholdService()
      val household = Household(surname = Arb.string(minSize = 3).next())
      service.createHousehold(household) shouldBe Success(household)
    }
  }
})</pre>			<p>Now we have a parameterized <a id="_idIndexMarker1234"/>setting for the first test, covering multiple combinations of blank strings. We are now satisfied enough to repeat <span class="No-Break">the process.</span></p>
			<h3>Additional steps</h3>
			<p>If this exercise goes further and picks up the next test scenario, “fail to create a household if the surname already exists,” then it involves keeping a created household record somewhere to provide a stateful validation if a household already exists. To drive a persistent implementation, such as saving the household record, we need to add test scenarios such as “retrieve a household record created by another household service instance.” In a way, it encourages us to write better and more test scenarios <span class="No-Break">as well.</span></p>
			<p>Moreover, as we suggest making all tests pass with the simplest possible implementation, we end up with<a id="_idIndexMarker1235"/> the simplest but complete implementation, which fulfills both the <strong class="bold">Keep it simple, stupid!</strong> (<strong class="bold">KISS</strong>) and <strong class="bold">You aren’t gonna need it</strong> (<strong class="bold">YAGNI</strong>) principles, as <a id="_idIndexMarker1236"/>discussed in <a href="B21737_02.xhtml#_idTextAnchor045"><span class="No-Break"><em class="italic">Chapter 2</em></span></a><span class="No-Break">.</span></p>
			<p class="callout-heading">The KISS principle</p>
			<p class="callout">The KISS principle is a design philosophy emphasizing simplicity in both design and implementation. It was first seen in the American newspaper <em class="italic">Minnesota Star Tribune</em> in 1938. The KISS acronym was coined by lead military engineer Kelly Johnson. The KISS principle advocates that systems should be as straightforward as possible, avoiding unnecessary complexity. Simplicity enhances maintainability, reduces the likelihood of errors, and improves <span class="No-Break">user experience.</span></p>
			<p>TDD is meant to be practiced<a id="_idIndexMarker1237"/> as a short and iterative process, as illustrated by the TDD exercise steps explained earlier. Together with the simplest possible implementation during the process, TDD can produce simple implementations that are naturally 100% covered <span class="No-Break">by tests.</span></p>
			<p>TDD is particularly useful if QAs and engineers are learning features as they go because TDD encourages learning and improving both test cases and implementation via <span class="No-Break">short iterations.</span></p>
			<p>However, for well-established systems, a strict TDD approach may not be as effective. The APIs may already be there and there could be only one line of code that’s updated for the behavior change. It may just be simpler to update existing tests to assert the new behavior and make them fail than to update the implementation to make all tests pass. There may not be a need to start <span class="No-Break">from nothing.</span></p>
			<p>Coming next, we are going to discuss a sibling of TDD – <span class="No-Break">BDD.</span></p>
			<h1 id="_idParaDest-335"><a id="_idTextAnchor435"/>BDD</h1>
			<p>BDD evolved from TDD with the goal of addressing some of the limitations of TDD, such as test case classes filled with<a id="_idIndexMarker1238"/> technical syntax that non-technical stakeholders would find difficult <span class="No-Break">to read.</span></p>
			<p>The concept of BDD was introduced by Dan North in 2003 during the discussions on improvement collaboration between technical and non-technical team members. This is also the year when he started<a id="_idIndexMarker1239"/> the development of the <strong class="bold">JBehave</strong> framework as a replacement <a id="_idIndexMarker1240"/>for the <strong class="bold">JUnit</strong> framework, emphasizing behaviors rather <span class="No-Break">than tests.</span></p>
			<p>The <strong class="bold">Gherkin</strong> language was created in the <a id="_idIndexMarker1241"/>year after that, as a domain-specific language that is close to the natural English language. The language aims to bring non-technical stakeholders closer to technical <span class="No-Break">team members.</span></p>
			<p>The test scenario we have <a id="_idIndexMarker1242"/>worked on during the TDD exercise can be expressed in the Gherkin language <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
Feature: Household creation
  Scenario: Creation of households with non-empty surnames
    Given the household surname is non-empty
    When the user requests to create the household
    Then the household is created</pre>			<p>Gherkin uses a simple structured syntax to define test scenarios. The primary keywords include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Feature</strong>: A feature of <span class="No-Break">the application</span></li>
				<li><strong class="bold">Scenario</strong>: A specific situation <span class="No-Break">or example</span></li>
				<li><strong class="bold">Given</strong>: Conditions before the <span class="No-Break">test starts</span></li>
				<li><strong class="bold">When</strong>: Action or event that <span class="No-Break">triggers behavior</span></li>
				<li><strong class="bold">Then</strong>: <span class="No-Break">Expected outcome</span></li>
				<li><strong class="bold">And/But</strong>: Add additional steps, conditions, or <span class="No-Break">expected outcome</span></li>
			</ul>
			<p>A test scenario written in the Gherkin language needs to be translated into programming languages to be <a id="_idIndexMarker1243"/>executed. <strong class="bold">Cucumber</strong> (<a href="https://github.com/cucumber">https://github.com/cucumber</a>) is the first major tool for BDD, and it was developed around 2005. It can translate test scenarios in Gherkin language to test scripts into multiple programming languages, such as Ruby, Rust, Java, Go, JavaScript, <span class="No-Break">and Kotlin.</span></p>
			<h2 id="_idParaDest-336"><a id="_idTextAnchor436"/>Specification by Example (SBE)</h2>
			<p>BDD has a close<a id="_idIndexMarker1244"/> relationship with <strong class="bold">Specification by Example</strong> (<strong class="bold">SBE</strong>). The term SBE was made popular by <em class="italic">Gojko Adzic</em> in his <a id="_idIndexMarker1245"/>book <em class="italic">Specification by Example</em>, which was published <span class="No-Break">in 2011.</span></p>
			<p>SBE advocates using concrete examples in real-world scenarios to clarify specifications and to communicate with non-technical stakeholders. This has influenced the conventional format of user stories as follows: <em class="italic">“As a [user], I want to [feature], so that [business values]”</em>. This ensures clear and testable specifications based on <span class="No-Break">real examples.</span></p>
			<p>A user story is further expanded to have acceptance criteria to determine whether the feature is completed to the user’s satisfaction. These acceptance criteria are reflected in the test scenarios, possibly in the Gherkin language as a <span class="No-Break">BDD practice.</span></p>
			<p>Adopting SBE and BDD has several implications. The test scenarios are written in Gherkin language and the vocabulary used should align with Ubiquitous Language, as discussed in <a href="B21737_08.xhtml#_idTextAnchor289"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>. Secondly, human-readable test scenarios strongly suggest blackbox testing as the <span class="No-Break">major approach.</span></p>
			<p>Finally, many teams using Agile methodologies would even use SBE and BDD to improve their requirement gathering and testing processes. In a way, the concrete examples from SBE and test scenarios from BDD become the de facto agreement with non-technical stakeholders on the <a id="_idIndexMarker1246"/>understanding of <span class="No-Break">the feature.</span></p>
			<h2 id="_idParaDest-337"><a id="_idTextAnchor437"/>BDD adoption in Kotlin</h2>
			<p>BDD is still actively adopted <a id="_idIndexMarker1247"/>by many teams nowadays. Many <a id="_idIndexMarker1248"/>Kotlin engineers are still using Cucumber as their BDD tool. However, there are reasons why some teams make a conscious decision not to use the Gherkin language to define <span class="No-Break">test scenarios.</span></p>
			<p>The Kotlin language is concise and less verbose than its predecessor, Java. Kotlin provides a lot of innate syntactic support and syntactic sugar to simplify the code for <span class="No-Break">better readability.</span></p>
			<p>With modern testing frameworks such as Kotest, Spek (<a href="https://www.spekframework.org">https://www.spekframework.org</a>), and Kluent (<a href="https://github.com/MarkusAmshove/Kluent">https://github.com/MarkusAmshove/Kluent</a>), it is possible to have<a id="_idIndexMarker1249"/> readable Kotlin-based test scripts<a id="_idIndexMarker1250"/> that mimic the Gherkin format for test scenarios to a <span class="No-Break">good extent.</span></p>
			<p>It diminishes the need to introduce a translation layer, which can sometimes introduce bugs during testing. It is also a balanced act between the benefits of reading test scenarios and the cost of translating Gherkin test scripts <span class="No-Break">to Kotlin.</span></p>
			<p>However, having BDD and SBE in mind in the agile development process is always beneficial, as it elicits meaningful conversations with non-technical stakeholders in the endeavor of understanding <span class="No-Break">user requirements.</span></p>
			<p>There are a few types of testing that are conducted in production environments. There are justifications for why they need to run in customer-facing environments, and we are going to explore the reasons <span class="No-Break">behind them.</span></p>
			<h1 id="_idParaDest-338"><a id="_idTextAnchor438"/>Live testing, A/B testing, and segmentation</h1>
			<p>Live tests are no replacement for <a id="_idIndexMarker1251"/>other types of tests conducted in lower environments. Each type of live testing serves a unique purpose in that it can only be executed in a <span class="No-Break">live environment.</span></p>
			<h2 id="_idParaDest-339"><a id="_idTextAnchor439"/>Post-release testing</h2>
			<p>Some systems integrate with <a id="_idIndexMarker1252"/>external systems that do not provide a lower environment for testing. Engineers would normally mitigate this risk by having a simulator running in lower environments. The simulator is a fake component that runs simplified logic just to act like the target external system. Engineers rely on documentation or information from the third-party company to implement <span class="No-Break">the simulator.</span></p>
			<p>This approach is not ideal, but it is better than having nothing to detect defects in lower environments. Several risks come with <span class="No-Break">this approach:</span></p>
			<ul>
				<li>The simulator logic needs to closely follow the steps of external system changes. Otherwise, it creates a time gap <span class="No-Break">of discrepancies.</span></li>
				<li>The external system may release its changes without informing the team, resulting in malfunctioning of the system and <span class="No-Break">requiring hotfixes.</span></li>
				<li>Engineers must ensure that the simulator never runs in production environments to create false data. Data damage and remediation come at a <span class="No-Break">huge cost.</span></li>
				<li>Having all safety measures in place, the external system may simply be unavailable after release. Thus, the system is only <span class="No-Break">partially operational.</span></li>
			</ul>
			<p>Regardless of whether there is a test environment for external system integration, some mission-critical systems, such as financial trading systems, would perform a “test trade” with a minimal amount to<a id="_idIndexMarker1253"/> ensure that the crucial features are operational and the corresponding data <span class="No-Break">is correct.</span></p>
			<h2 id="_idParaDest-340"><a id="_idTextAnchor440"/>A/B testing and segmentation</h2>
			<p>Some tests are run in production for a longer period for reasons other than QA. A/B testing and segmentation<a id="_idIndexMarker1254"/> are executed to discover needs and opportunities in <span class="No-Break">the market.</span></p>
			<p>Some organizations would <a id="_idIndexMarker1255"/>segment their users into at least two groups. The segmentation can be done in the <span class="No-Break">following ways:</span></p>
			<ul>
				<li>A <span class="No-Break">stateless algorithm</span></li>
				<li>User data, such as demographics <span class="No-Break">or preferences</span></li>
				<li>Signed up voluntarily <span class="No-Break">by users</span></li>
				<li>Random and <span class="No-Break">sticky assignments</span></li>
				<li>Manually assigned to <span class="No-Break">small groups</span></li>
			</ul>
			<p>Each group has a different user experience, and metrics are in place to measure business metrics such as page landing counts, purchase statistics, and customer satisfaction. This is a typical <span class="No-Break">segmentation setup:</span></p>
			<ul>
				<li><strong class="bold">Control group</strong>: The original <a id="_idIndexMarker1256"/>experience; the baseline <span class="No-Break">for comparisons</span></li>
				<li><strong class="bold">Variant groups</strong>: The <span class="No-Break">modified </span><span class="No-Break"><a id="_idIndexMarker1257"/></span><span class="No-Break">experiences</span></li>
			</ul>
			<p>By conducting A/B testing, the organization can gather useful information about users and the market. The data collected provides a quantitative perspective on which user experiences lead to a better outcome. This provides insights on real-user behaviors using empirical evidence, and it fosters a culture of hypothesis testing and <span class="No-Break">data-driven decision-making.</span></p>
			<p>Some A/B tests could run only for a limited time just to collect enough data for analysis, while some could run for a very long time for continuous improvements. Some organizations would even run multiple A/B tests at the same time, but this comes at the cost of exponential complexity when performing <span class="No-Break">statistical analysis.</span></p>
			<h1 id="_idParaDest-341"><a id="_idTextAnchor441"/>Summary</h1>
			<p>In this chapter, we discussed the role and involvement of QA in the software development cycle. We covered the testing pyramid in depth, explored each layer with code examples, and mentioned some of the techniques used in test scripts such as blackbox and whitebox testing, mocking, and <span class="No-Break">parameterized testing.</span></p>
			<p>We explored the concepts of TDD. We ran through an exercise of TDD with small and frequent iterations, using <span class="No-Break">real-life examples.</span></p>
			<p>We discussed BDD, a close relative of TDD. We elaborated on its history and how it evolved from TDD. We also introduced SBE, which works closely with BDD practices. Finally, we briefly discussed the modern adoption of BDD <span class="No-Break">in Kotlin.</span></p>
			<p>We also briefly introduced some types and examples of testing that are executed in live environments and the reasons <span class="No-Break">behind them.</span></p>
			<p>The next chapter will cover an important aspect of software systems – <span class="No-Break">security.</span></p>
		</div>
	</div></div></body></html>