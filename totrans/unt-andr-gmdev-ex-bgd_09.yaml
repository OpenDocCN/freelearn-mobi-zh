- en: Chapter 9. Optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*In the previous chapter, we learned about special effects for our games. We
    added background music to our Space Fighter game. We also created engine trails
    for our ship. Combining both audio effects and particle systems, we created some
    explosions and gun blasts. Together, this rounds out the game experience and gives
    us a very complete-looking game.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this chapter, we explore our options for optimization. We start by looking
    at the application footprint, and how to reduce it. We move on to look at the
    game''s performance. We look at the tools that Unity provides and create another
    one ourselves. With the use of occlusion culling, we can improve the game''s performance
    even further. Finally, we will explore some key areas that can cause lag and how
    to minimize their effects.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Minimizing the application footprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimizing lag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Occlusion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be working on both our Space Fighter and Tank Battle games, for this
    chapter. Start by opening the Space Fighter project.
  prefs: []
  type: TYPE_NORMAL
- en: Minimizing the application footprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the keys to a successful game is the size of the game itself. Many users
    will quickly uninstall any application that appears to be unnecessarily large.
    Also, all of the mobile app stores have limits to how your game will be supplied
    to users based on the size of the application itself. Becoming familiar with the
    options you have for minimizing the size of your game is the key to control how
    your game will be distributed.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to note when working to minimize the footprint is how Unity
    handles assets as it builds the game. Only assets that are used somewhere in one
    of the scenes for the build are actually included in the game. If it is not in
    the scene itself or referenced by an asset that is in the scene, it will not be
    included. This means you could have test versions of assets, or incomplete versions;
    as long as they are not referenced, they will not affect the final build size
    of your game.
  prefs: []
  type: TYPE_NORMAL
- en: Unity also allows you to keep your assets in the format you need for working
    on them. When the final build is made, all assets are converted to an appropriate
    version for their type. This means you can keep models in the format native to
    your modeling program. Or keep your images as Photoshop files, or any other format
    you work in, and they will be converted to `JPG` or `PNG` appropriately when the
    game is built.
  prefs: []
  type: TYPE_NORMAL
- en: Editor log
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you are finally ready to work with the footprint of your game, it is possible
    to find out exactly what is causing your game to be larger than desired. In the
    top-right corner of the **Console** window is a drop-down menu button. Inside
    this menu is **Open Editor Log**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Editor log](img/2014OT_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The editor log is the location where Unity outputs information while it is running.
    This includes information about the current version, license checks, and any asset
    importing. The log will also contain detailed information about the file size
    and assets included in the game, after it has been built.
  prefs: []
  type: TYPE_NORMAL
- en: '![Editor log](img/2014OT_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see a breakdown of the aspects of the final build. Every asset category
    has a size and percentage of the total build size. We are also supplied with a
    list of every asset that is actually included in the game, organized by their
    file size before being added to the build. This information becomes very useful
    when looking for assets that can stand to be made smaller.
  prefs: []
  type: TYPE_NORMAL
- en: Asset compression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inside the **Import Settings** for models, textures, and audio there are options
    that affect the size and quality of imported assets. In general, the affected
    change is a reduction in quality. However, especially when working on mobile devices,
    asset quality can be reduced well below the levels required for a computer before
    the difference is noticeable on the device. Once you understand the options available
    for each type of asset, you will be able to make optimal decisions regarding the
    quality of your game. When working with any of these options, look for a setting
    that minimizes the size before introducing undesired artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: Models
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No matter what program or method you use to create your models, ultimately they
    are always a list of vertex positions and triangles, with a few references to
    textures. Most of the file size of a model comes from the list of vertex positions.
    To make sure the models in your game are of the highest quality, start in the
    modeling program of your choice. Delete any and all extra vertexes and faces.
    Not only will this result in a smaller file when building your final game, it
    will also reduce the import time when working in the editor.
  prefs: []
  type: TYPE_NORMAL
- en: The **Import Settings** for models consists of three pages, resulting in more
    options to adjust the quality. Each page tab corresponds to the relevant part
    of the model, allowing us to fine-tune each one of them.
  prefs: []
  type: TYPE_NORMAL
- en: Model tab
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On the **Model** tab, we are able to affect how the mesh is imported. When
    it comes to optimizing our use of the models, there are many options here that
    are key to success. Once your game is looking and playing the way you want it
    to, we should have a good look at the settings shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Model tab](img/2014OT_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The settings available under the **Model** tab are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mesh Compression**: This option lets us select how much compression should
    be applied to the model. The effect amounts to combining vertexes to reduce the
    overall amount of detail that has to be stored for the mesh. This setting is likely
    to introduce undesired oddities in the mesh. So, always pick the highest setting
    that does not introduce any artifacts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Read/Write Enabled**: This option is only useful when you want to manipulate
    the mesh while the game is running, through the script. If you never touch the
    mesh with any of your scripts, uncheck this box. While not affecting the final
    build size, this will affect how much memory is required to run your game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimize Mesh**: This option causes Unity to reorder the triangles list that
    describes the model. This is always a good one to leave checked. The only reason
    you might want to uncheck it is if you are manipulating the game or mesh based
    on the specific order of the triangles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generate Colliders**: This option is almost always a candidate to leave off.
    This option will add Mesh Collider components to every mesh in your model. These
    are relatively expensive to calculate when working with physics in your game.
    If possible, you should always use a group of the significantly simpler Box Colliders
    and Sphere Colliders.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generate Lightmap UVs**: This option should only be used when working with
    objects that need static shadows. If the object does not, it will introduce excess
    vertex information and bloat the asset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Normals**: This option is used by materials for determining which direction
    a vertex faces and how lighting should affect it. If the mesh never uses a material
    needing **Normals** information, be sure to set this to **None**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tangents**: This option is used by materials for faking detail with bump
    maps and similar special effects. Just as with the **Normals** setting, if you
    don''t need them, don''t import them. If **Normals** is set to **None**, this
    setting will automatically be grayed out and no longer imported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rig tab
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is a screenshot that displays the **Rig** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rig tab](img/2014OT_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are really only two things to keep in mind when working to optimize your
    animation rig. The first is, if the asset does not animate, then don't import
    it. By setting **Animation Type** to **None**, Unity will not try to import the
    rig or any useless animations. The second thing to keep in mind is to remove any
    unnecessary bones. Once imported to Unity, delete any and all objects from the
    rig that do not actually have an effect on the animation or character. Unity converts
    any inverse kinematics that you might use for animating into forward kinematics,
    so the guides used for it can be deleted once in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Animations tab
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with with the **Rig** tab, if the model does not animate, do not import animations.
    Unchecking the **Import Animation** box, when first importing the asset, will
    avoid any extra components being added to your GameObjects in Unity. Also, if
    any extra animations get added to your final build accidentally, they can quickly
    make your application over-sized.
  prefs: []
  type: TYPE_NORMAL
- en: '![Animations tab](img/2014OT_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The settings available under the **Animations** tab are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Anim. Compression**: This option adjusts how Unity handles excess keyframes
    in your animations. For most situations, the default option works well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Off**: This option should only be used if you need a high-precision animation.
    This is the largest and most costly setting to choose.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keyframe Reduction**: This option will reduce the number of keyframes used
    by the animation based on the Error settings that follow. Essentially, if a keyframe
    does not have a noticeable effect upon the animation, it is ignored.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keyframe Reduction and Compression**: This option does the same as the previous
    option but additionally compresses the file size of the animations. At runtime,
    though, the animation will still require the same amount of processor resources
    to calculate as the previous option.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rotation Error**: This option is the number of degrees different between
    keyframes that will be ignored when performing keyframe reduction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Position Error**: This option is the movement distance that will be ignored
    between keyframes when performing the keyframe reduction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scale Error**: This option is the amount of size adjustment in the animation
    that will be ignored between keyframes when performing the keyframereduction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Textures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with textures in computer graphics, it is always better to work
    in **Powers of 2**. A Power of 2 is any value where it and its subsequent halves
    can be evenly divided by two until one is reached. This is important because they
    are faster for the computer to calculate and process. By default, Unity will convert
    any textures that do not meet this requirement by scaling them to the nearest
    Power of 2.
  prefs: []
  type: TYPE_NORMAL
- en: '![Textures](img/2014OT_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The various **Texture** settings available in Unity are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Texture Type**: This option affects what type of texture this image will
    be treated as. It is always best to select the type most appropriate for the intended
    use of the image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Texture**: This option is the most common and default setting. This should
    be used for your normal model textures.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Normal Map**: This option is used for special effects such as bump maps.
    Materials using this type of texture will also need the normal and tangent information
    from the model import settings.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GUI**: This option should be used if the image is going to appear in the
    GUI and not on any models.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reflection**: These textures are used for creating cube maps that imitate
    the reflective properties of real objects.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cookie**: These textures are used on lights, changing how the light is emitted
    from the light object.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advanced**: This option gives full control over all of the settings concerned
    with importing images. You will only need this setting if you have special purposes
    for your textures.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When the **Texture Type** option is set to **Advanced**, the **Read / Write
    Enabled** box becomes available. This should only be left checked if you plan
    on manipulating the texture from your scripts while the game is running. If unchecked,
    Unity does not maintain a copy of the data in the CPU, freeing memory for other
    parts of the game.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Generate Mip Maps**: This option is another **Advanced** setting that lets
    you control the creation of smaller versions of the texture. These are then used
    when the texture is small on the screen, reducing the amount of processing needed
    to draw the texture and the object using it on the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filter Mode**: This option is available for all of the texture types. It
    affects how the image will look when you are very close to it. **Point** will
    make the image look blocky, while **Bilinear** and **Trilinear** will blur the
    pixels. In general, **Point** is the fastest; **Trilinear** is the slowest but
    gives the best looking effect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Max Size**: This option adjusts how large the image can be when it is used
    in the game. This allows you to work with images that are very large but import
    them to Unity in an appropriately small size. In general, values greater than
    **1024** are poor choices; not just because of the increased memory requirement,
    but also because the video cards on most mobile devices cannot handle textures
    that are any larger. Choosing the smallest size possible will have a great effect
    on the footprint size of the textures in your final build.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Format**: This option adjusts how the image should be imported and how much
    detail each pixel can hold. **Compressed** is the smallest, while **Truecolor**
    provides the most detail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Audio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Giving a game quality sound always adds a lot to the final size of the game.
    It is one of those assets that a game cannot do without, but can be hard to include
    at a suitable level. When working on them in your audio program, keep them as
    short as possible to minimize their size. The audio import settings all have an
    effect on either their footprint in the build size, or the memory required to
    run the game.
  prefs: []
  type: TYPE_NORMAL
- en: '![Audio](img/2014OT_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The various **Audio** settings available in Unity are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Audio Format**: This setting changes how the file will be stored in your
    game. **Native** offers higher quality while **Compressed** results in a smaller
    file size. As a special feature of mobile platforms, compressed audio can be retrieved
    relatively faster than on other platforms because of some special hardware in
    the mobile devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3D Sound**: This setting dictates whether or not the file will be affected
    by its position in the game relative to the **Audio Listener**. If this is unchecked,
    some calculations can be avoided, reducing the processing required in each frame
    of your game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Force to mono**: This setting converts stereo audio into mono. While most
    devices are technically capable of playing stereo sounds, they do not always have
    the multiple speakers required for it to make a difference. Checking this box
    can significantly reduce the file size of the audio, by removing that extra audio
    channel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load type**: This setting affects how much of the system''s memory is used,
    while the game is running, to handle loading audio files. **Decompress on load**
    uses the most memory, and is best for small, short sounds. **Compressed in memory**
    only decompresses the file while it is playing, using a medium amount of memory,
    and is best for medium-sized files. **Stream from disc** means that only the part
    of the file currently being played is stored in the runtime memory. This is like
    streaming video or music from the Internet. This option is best for large files
    but should only be used by a few at one time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compression (kbps)**: This setting adjusts the amount of detail in the audio
    file. A smaller value will reduce the file size, but also reduce quality. A larger
    value will result in a larger file size and greater quality. If the amount of
    compression already applied by your audio is smaller than the value here, the
    setting will have no effect on the sound. In general, it is best to pick the smallest
    size while maintaining the desired level of quality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Player settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open your game's **Player Settings** by going to Unity's toolbar and navigating
    to **Edit** | **Project Settings** | **Player**. In the **Per-Platform Settings**,
    for Android, we have another few options under **Other Settings** that will affect
    the final size and speed of our game.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is the screenshot that displays the **Rendering** settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering](img/2014OT_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The various **Rendering** settings available in Unity are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When we worked with making lightmaps, we had to set some objects as static.
    This told Unity that the objects will never be moving and allows them to be lightmapped.
    It also allows Unity Pro users to utilize **Static Batching** that allows Unity
    to significantly speed up rendering times by grouping identical objects. For each
    group it then renders one object in multiple places, rather than each object individually.
    Potentially, this setting can add some extra girth to your final build size, because
    Unity will need to save extra information about your static objects to make it
    work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic Batching** works the same as **Static Batching**, with two major
    differences. First, it is available to both Unity Pro and Basic users. Second,
    it groups objects that are not marked as static.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Optimization** settings are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Optimization](img/2014OT_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The various **Optimization** settings available in Unity are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Api Compatibility Level**: This setting determines which set of the .Net
    functions to include in the final build. **.Net 2.0** will include all of the
    available functions, making the largest footprint. **.Net 2.0 Subset** is a smaller
    portion of the functions, including only those that your programming is most likely
    to use. Unless you need some special functionality, **.Net 2.0 Subset** should
    always be the option you choose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Stripping Level**: This setting is a Unity Pro only feature. It allows
    you to reduce the size of your final build by removing all of the excess code
    before compiling it. System functions are grouped into what are called libraries
    for easy reference. **Strip Assemblies** removes the unused libraries from the
    final build. The **Use micro mscorlib** option performs the same function as the
    previous option, but utilizes a minimized form of the libraries. While significantly
    smaller, this library possesses fewer functions for your code to use. However,
    unless your game is complex, it should not make a difference.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimize Mesh Data**: This setting will remove extra information from all
    of your meshes that are not being used by any materials applied to them. This
    includes the **Normals**, **Tangents**, and a few other bits of information. Unless
    you have a very special case, this is a good box to always check.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity provides us with many tools that allow us to determine how well our game
    is running. The first we will be covering is readily available for both Unity
    Pro and Basic users. However, the information is rather limited, though still
    useful. The second is only available to Unity Pro users. It provides significantly
    more detail and information on performance. Finally, we will create our own tool,
    allowing us to view the performance of our scripts in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Editor statistics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the top-right of the **Game** window, there is a button labeled **Stats**.
    Clicking on this button will open a window, giving us information about how the
    game is running. There is little bit of information about how fast the game is
    running. Most of the information in this window concerns how well the game is
    being rendered, largely amounting to how many objects are currently on the screen,
    how many are animating, and how much memory they take up.
  prefs: []
  type: TYPE_NORMAL
- en: '![Editor statistics](img/2014OT_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The various statistics in Unity Editor are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: At the top-right of the Unity Editor **Statistics** window is the current **FPS**
    (**Frames Per Second**) and the time in milliseconds that the last frame took
    to render. These values are unaffected by the rendering of the rest of the Unity
    Editor, though there is a slight performance hit by running the game in the Editor.
    In general, if you can keep your game running at more than 60 FPS, your game will
    run pretty well on your target platform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Main Thread** statistic provides us with the time in milliseconds that
    it took to run through the code for the frame and render everything to the screen.
    This is the total amount of time it takes to process a single frame of your game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To the right of **Main Thread**, we have **Renderer**. This statistic is the
    number of milliseconds the rendering of the frame alone took. This time is already
    included in the **Main Thread** statistic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Draw Calls** statistic is the number of unique objects that had to be
    drawn on screen. This is roughly equal to the number of objects that are currently
    visible to the camera. So, things behind the camera are not drawn and do not add
    to this value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Saved by batching** statistic is closely related to the number of **Draw
    Calls**. We will learn more about batching later. But, suffice it to say for now,
    batching is a special grouping process that reduces the number of **Draw Calls**,
    making the game render faster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ultimately, every model in 3D graphics is made from a series of triangles. **Tris**
    is the total number of triangles seen and being rendered by the camera.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the information in a model file is concerned with the position of each
    vertex. **Verts** is the total number of vertexes seen and rendered by the camera.
    The lower the number of vertexes for each model, the faster it will be rendered
    to the screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first number for the **Used Textures** statistic is the total number of
    unique textures that are being used in this frame. The second is the total amount
    of memory they take up. By reducing texture quality or by combining textures,
    this statistic can be reduced, allowing the game to run faster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Render Textures** statistic is a special type of texture used for special
    effects such as security cameras and real-time reflections. This statistic displays
    the total number visible and the amount of memory needed for them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **switches** statistic essentially amounts to how much work the **Render
    Textures** statistic is doing. Fewer **Render Textures** and simpler materials
    will reduce this number and the resulting cost to rendering time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Screen** is the current width and height, in pixels, of the **Game** window.
    It also displays the amount of memory needed for rendering at that size. A smaller
    size results in less detail for your game, but also makes the game easier to render.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **VRAM usage** statistic gives the approximate minimum and maximum video
    memory currently being used. It also provides the current total amount of video
    memory available in parentheses. With this statistic and knowing the amount of
    video memory available in your target device, you can determine whether graphics
    of your game are simple enough to run on that device.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **VBO Total** statistic is the total number of unique meshes currently being
    rendered by your game. Every distinct model you might use will add to this statistic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Shadow Casters** statistic is used when making use of real-time shadows.
    Real-time shadows are expensive. If possible, they should not be used on mobile
    devices. But, if you have to have them, minimize the number of objects that cast
    those shadows. Limit it to moving objects that are large enough for the user to
    see the shadow. Small, static objects especially do not need to cast shadows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Visible Skinned Meshes** statistic is the total number of rigged objects
    currently in the view of the camera. **Skinned Meshes** are most often going to
    be your characters and just about anything else that animates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Animations** statistic provides the current total number of animations
    playing in the scene.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Network** group of statistics only becomes visible when connected to other
    players in a multiplayer game. The information generally amounts to how many people
    the game is connected to and how fast those connections are.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Profiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Profiler** window, found in Unity's toolbar under **Window** | **Profiler**,
    is a great tool for analyzing how your game is running. It gives us a colorful
    breakdown of each part of our system and how much work it is doing. The only really
    unfortunate part of this tool is that it is only available for Unity Pro users.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Profiler](img/2014OT_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By first opening the **Profiler** window, we can then play our game in the window
    and watch the tool give us a fairly detailed breakdown of what is going on. We
    can click on any point and see detailed information about that frame in the bottom
    of the window. The information provided is specific to the lane that you clicked
    on, **CPU Usage**, **Rendering**, **Memory**, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The **CPU Usage** information is particularly useful when trying to find parts
    of our game that are taking too long to process. Spikes in processing cost stand
    out pretty easily. By clicking on a spike, we can see the breakdown of what each
    part of the game played in making that frame expensive. For most of these parts
    we can dig down to the exact object or function that is causing the issue. However,
    we can only get down to the function level. Just because we know where an issue
    in the code generally is, the Profiler will not tell us exactly which part of
    that function is causing the issue.
  prefs: []
  type: TYPE_NORMAL
- en: In order to actually work, the Profiler needs to hook into every part of your
    game. This introduces a little extra cost in the speed of your game. Therefore,
    when analyzing the information provided, it is best to consider the relative costs
    rather than hold each cost as an exact value.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking script performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of these tools that Unity provides are great, but not always the right solution.
    The Unity Basic user does not have access to the Profiler. Also, both the Profiler
    and the Editor Statistics are fairly generalized. We can get a little more detail
    with the Profiler, but not always enough. In this next part, we will be creating
    a special script capable of tracking the performance of specific parts of any
    script. It should definitely become a regular piece of your developer kit.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – tracking scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be creating this script in the Space Fighter game:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we will need a special class that will keep track of our performance
    statistics. Create a new script and name it `TrackerStat`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To begin this script, we first need to change the class definition line. We
    do not want or need to extend the `MonoBehaviour` class. So, find the following
    line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And, change it to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This script starts with four variables. The first will be used as an ID, allowing
    us to track multiple scripts at once by supplying different key values. The second
    will keep track of the average amount of time that the tracked bits of code are
    taking. The third is just the total number of times the tracked code has been
    called. The fourth is the longest time the code has taken to execute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we have two more variables. These will do the work of actually tracking
    how long the script takes to execute. The first is the time when the tracking
    starts. The second is a flag marking that tracking has started.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first function for this script is `Open`. This function is called when we
    want to start tracking a bit of code. It first checks to see if the code is already
    being tracked. It uses `Debug.LogWarning` to send a warning to the **Console**
    window, if it is. Next, it sets the flag marking that code is being tracked. Finally,
    the function tracks the time it was called by using `Time.realtimeSinceStartup`,
    which is the actual number of seconds since the game started.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next function, `Close`, acts as the opposite of the previous one. It is
    called when we have reached the end of the code we want to track. The time when
    the tracking should stop is passed to it. This is done to minimize the amount
    of excess code being executed. As with the previous function, it checks to see
    if tracking is being done, sending out another warning and exiting early if it
    is not. Next, the `isOpen` flag is cleared by setting it to `false`. Finally,
    the amount of time since tracking was opened is calculated and the `AddValue`
    function is called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This last function for this script is `AddValue`. This function is passed `callLength`,
    the length of time that the tracked bit of code took. It then uses some math to
    add the value to `averageTime`. Next, the function compares the current `longestCall`
    with the new value and selects the longest. Finally, the function increments `totalCalls`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we need to create another new script and name it `ScriptTracker`. This
    script will allow us to do actual performance tracking.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This script starts off with a single variable. This variable maintains all of
    the stats that are currently being tracked. Note the use of `static` here; it
    allows us to easily update the list from anywhere in the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first function for this script, `Open`, allows us to start tracking the
    code execution. It uses the `static` flag, so the function can be called easily
    by any script. A `key` value is passed to the function, allowing us to group track
    calls. The function starts by creating a variable to hold the `index` of the stat
    to start tracking. Next, it loops through the current set of `stats` to find a
    matching `key` value. If one is found, the `index` variable is updated with the
    value and the loop is exited.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Open` function continues by checking if a stat was found. The `index` variable
    will only be less than zero if we make it through the whole loop of current `stats`
    and are unable to find a matching `key`. If one is not found, we call `AddNewStat`,
    which will be created shortly, to create the new stat for tracking. The `index`
    is then set to that of the new stat. Finally, the stat is triggered to start tracking
    by using the stat's `Open` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `AddNewStat` function is passed the `key` of the stat that is to be created.
    It starts by storing the list of `stats` in a temporary variable and increasing
    the size of the `stats` list by one. Each value is then transferred from the `temp`
    list to the larger `stats` list. Finally, a new stat is created, it is assigned
    to the last slot in the `stats` list, and the `key` is set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we have the `Close` function. This function is passed the `key` value
    of the stat to be closed. It starts by finding the time that the function was
    called, minimizing the amount of excess code being tracked. It continues by looping
    through the list of `stats` to find a matching `key`. If one is found, the stat's
    `Close` function is called and the function is exited. If a match is not found,
    `Debug.LogError` is called to send an error message to the **Console** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last static function for this script is `Clear`. It only empties the stats
    list, making it ready for fresh tracking.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last step for the script is the `OnGUI` function. This function will let
    us see our statistics while the game is playing. In it we make heavy use of the
    `GUILayout` class and its functions. `GUILayout` automatically arranges the various
    GUI elements, allowing us to spend less time arranging and more time analyzing.
    We first use `BeginVertical` to start a vertical list of elements. `BeginHorizontal`
    is used to start a horizontal list of elements. The `Label` function is then used
    to create titles for each row of our statistics. We are using the `GUILayout.Width`
    function to give each label a specific width, making the layout look much nicer.
    Next, `EndHorizontal` is called to close the horizontal list. Every call to `BeginHorizontal`
    must be paired with an `EndHorizontal` else Unity will make many complaints.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we loop through our list of stats. For each, we create a horizontal list
    and use `Label` to draw each stat on the screen. The `ToString` function is used
    to convert the numbers to strings, needed by the labels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `OnGUI` function finishes by creating a button, that calls upon the `Clear`
    function when clicked. And finally, the `EndVertical` function is called to end
    the vertical list of elements. Every call to `BeginVertical` must be paired with
    a call to `EndVertical`, just as the horizontal lists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To test these scripts, open up your `PlayerShip` script. To the beginning of
    the `Rotate` function, add the following line to start tracking how long it takes
    to run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Towards the end of the `Rotate` function, we need to call the `Close` function
    with the same key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, create an empty game object and add your `ScriptTracker` script to
    it. Start the game and take a look at the results.![Time for action – tracking
    scripts](img/2014OT_09_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a tool for testing specific parts of code. By wrapping any bit of
    code in calls to the functions and sending a unique ID, we can determine how long
    it takes to execute the code. By averaging out the calls to the script, and wrapping
    different parts of code, we can determine exactly which parts of a script are
    taking the longest to complete. We can also find out if the parts of code have
    been called too many times. Both cases are ideal points to start looking at for
    minimizing processing and lag.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to remove any references to this tool before you deploy your game. If
    left in the final levels, it can add an unnecessary amount of load on the CPU.
    This adverse effect on the game could make the game unplayable. Always remember
    to clear out any uses of tools that are exclusively for Editor debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Minimizing lag
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lag is one of those nebulous ideas used to describe an application performing
    slower than expected. As developers, we constantly fight against providing the
    highest quality experience we can, while maintaining the speeds and responsiveness
    that users expect. It essentially amounts to whether or not the processor on the
    user's device can handle the cost of providing the game experience. A few, simple
    objects in your game will result in fast processing. Several complex objects will
    cost the most processing.
  prefs: []
  type: TYPE_NORMAL
- en: Occlusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Occlusion is great for games with a lot of objects. In its basic form, anything
    off to the sides or behind the camera is not seen and therefore not drawn. In
    Unity Pro, we are able to set up occlusion culling. This will calculate what can
    actually be seen by the camera, not drawing anything that is blocked from view.
    There is a balance that has to be achieved when using these tools. The cost of
    calculating what can not be seen needs to be less than the cost of just drawing
    those objects anyway. As a rule of thumb, if you have many smaller objects that
    are regularly blocked from view by larger objects, occlusion culling is the right
    choice.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – occluding tanks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will add occlusion culling to the Tank Battle game, because it is the only
    one with anything large enough to block objects from view:'
  prefs: []
  type: TYPE_NORMAL
- en: So, open up the Tank Battle game now. If you completed the challenges and added
    the extra debris and obstacles, this section will be particularly effective for
    you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Occlusion window by going to Unity's toolbar and navigate to **Window**
    | **Occlusion Culling**. This window is your primary point of access for modifying
    the various settings associated with occlusion in your game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to the **Bake** page and we can take a look at the options associated
    with occlusion culling.![Time for action – occluding tanks](img/2014OT_09_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Technique**: This setting will determine what method to use when setting
    up occlusion culling.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PVS Only**: This setting will only calculate the static objects of your scene
    to have occlusion culling applied. This option is the least intensive for the
    processor but is only good if there are very few moving objects in the scene.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**PVS and dynamic objects**: This setting will precompute what objects can
    be seen by the camera. For dynamic objects, the system will create portals. They
    are used to cull objects that are on opposite sides of the portals from the camera.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Automatic Portal Generation**: This setting will cull both static and dynamic
    objects based on portals. While giving the most accuracy, this option also has
    the highest cost for the processor.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**View Cell Size**: This setting sets how detailed the occlusion calculations
    are. Smaller values will result in better culling but will cause the file size
    to increase to store the extra information.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Near Clip Plane** and **Far Clip Plane**: These settings are used by the
    system to estimate what a camera can see at any point in space. They should be
    set to the smallest **Near Clip Plane** and largest **Far Clip Plane** of all
    the cameras in your game.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Memory Limit**: This setting is used when either of the **PVS Techniques**
    have been chosen. It helps guide how much detail can be put into the calculation.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Select **PVS and dynamic objects** for **Technique** and `5` for **View Cell
    Size**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to make the occlusion system work with dynamic objects, we need to
    set up a number of occlusion areas. To create them, create an empty **GameObject**
    and add an **Occlusion Area** component, found in Unity's toolbar under **Component**
    | **Rendering** | **Occlusion Area**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They need to cover the area where any dynamic objects will be located. Create
    and position enough areas to cover the streets of our game. Their size can be
    edited just as when working with **Box Collider** components. Be sure to make
    them tall enough to cover all of your targets.![Time for action – occluding tanks](img/2014OT_09_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hit **Bake** at the bottom of the **Occlusion** window. A progress bar will
    appear at the bottom-right of the Unity Editor, telling you how much longer the
    calculations will take. This process usually takes a good amount of time, especially
    as your game becomes more and more complex.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the baking process has completed, the **Occlusion** window should have
    switched to the **Visualization** tab and the camera should be selected in your
    **Scene** window. If not, select them now. In the **Scene** view, Unity will give
    us a preview of how occlusion culling is working. Only those objects that can
    be seen will be visible while the rest are turned off.![Time for action – occluding
    tanks](img/2014OT_09_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We went through the basic process for setting up occlusion culling. We took
    a look at the **Occlusion** window and learned about the settings available there.
    Occlusion culling is great for reducing the number of draw calls in a scene. However,
    that reduction needs to be balanced against the cost of storing and retrieving
    the occlusion calculations. This balance is achieved by selecting a proper **Technique**
    and an appropriate **View Cell Size**. Play around with the different values now,
    finding a cell size that gives the appropriate amount of detail without supplying
    too much information.
  prefs: []
  type: TYPE_NORMAL
- en: Points to remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is a list of tips for dealing with and avoiding lag in your games.
    Not all of them will apply to every game you make, but they are good to keep in
    mind for every project:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid the transparent shaders, if possible, when creating your materials. They
    are a little more expensive to render. And, you can save yourself a world of headaches
    dealing with depth sorting, if you avoid them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use one material per object. The greater the number of draw calls in your game,
    the longer each frame will take to render. Every mesh is drawn once per material
    on it, even if the material doesn't appear to do anything. By keeping to one material
    per object, especially on mobile platforms, you minimize the number of draw calls
    and maximize your rendering speed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combine textures when possible. Not every texture you make will utilize the
    whole of the image. Whenever possible, combine the textures of objects that are
    in the same scene. This maximizes your efficient use of the images, while reducing
    the final build size and amount of memory needed to utilize those textures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Group objects in your **Hierarchy** using empty GameObjects. Though not specific
    to minimizing lag, it will make your project easier to work with. Especially with
    large and complex levels, you will be able to spend less time searching through
    the objects in your scene and more time making a great game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Console** window is your friend. Before worrying about your game not working,
    first take a look at the **Console** window or the bar at the bottom in Unity.
    Both will display any complaints that Unity might have about the way your game
    is currently set up. The messages here are great for pointing you in the right
    direction to fixing any problems. If you are ever unsure what the messages are
    trying to tell you, perform a Google search for the message and you should be
    able to easily find a solution from one of the many other Unity users. If your
    code ever appears to not be working and Unity isn't complaining about it, use
    the `Debug.Log` function to print messages to the **Console**. This will let you
    find places that your code might be exiting unexpectedly, or values that are not
    what they should be.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Device testing is important. Working in the Editor is great, but there is nothing
    quite like testing on the target device. You can get a much better feel for how
    your game is performing when it is on the device. The Editor always introduces
    a small amount of additional processing overhead. Also, the computer you are working
    on will always be more powerful than the mobile devices you might intend on deploying
    to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about our options for optimization in Unity. We
    first took a look at the various settings, for the assets used in our games, used
    to keep their file size down while maintaining quality. Next, we learned about
    some settings that affect the overall game. After that, we explored options for
    tracking the performance of the game. We first looked at some tools provided by
    Unity for tracking that performance. Then, we created a tool of our own for tracking
    script performance in detail. We then took a look at some options for minimizing
    lag in our games, including utilizing occlusion culling. Now that we know about
    all of these tools and options, go through the games we created and optimize them.
    Make them the best they can be.
  prefs: []
  type: TYPE_NORMAL
- en: In this book we learned a whole lot. We started with learning about Unity, Android,
    and how to make them work together. Our journey continued with an exploration
    of Unity's GUI system and the creation of a Tic-tac-toe game. We then learned
    about the basic assets needed for any game, while starting the creation of a Tank
    Battle game. Our Tank Battle game then expanded with the addition of a few special
    camera effects and some lighting. We concluded the creation of the Tank Battle
    game by introducing some enemies and making them chase the player. The creation
    of our Space Fighter game taught us about the touch and tilt controls that we
    can utilize in our game. A short break from that game saw the creation of an Angry
    Birds clone while learning about physics and the possibilities of a 2D game in
    Unity. We then returned to the Space Fighter game to add some polish with the
    addition of sound and particle effects. Finally, our journey concluded by learning
    about optimizing our games. Thank you for reading this book. Enjoy your experiences
    with Unity and creating the awesome games you have always dreamed about.
  prefs: []
  type: TYPE_NORMAL
