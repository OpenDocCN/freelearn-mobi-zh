- en: '*Chapter 10*: Test Your App with UI and Unit Tests'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, one of our main focuses was to have a testable architecture.
    We tried to achieve that by decoupling different components from each other.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, because of the architecture we put in place, we will see how
    easy it is to test in isolation different parts of the Restaurants app.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Exploring the fundamentals of testing* section, we will be understanding
    the benefits of testing and exploring various types of tests. In the *Learning
    the basics of testing your Compose UI* section, we will learn how to test our
    Compose UI.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the *Covering the basics of unit-testing your core logic* section,
    we will learn how to test the core functionality of your Restaurants app.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, in this chapter we will be covering the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the fundamentals of testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the basics of testing your Compose UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Covering the basics of unit-testing your core logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before jumping in, let's set up the technical requirements for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building Compose-based Android projects for this chapter usually requires your
    day-to-day tools. However, to follow along smoothly, make sure you also have the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer
    Android Studio version or even Canary builds but note that the IDE interface and
    other generated code files might differ from the ones used throughout this book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Kotlin 1.6.10 or newer plugin installed in Android Studio.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Restaurants app code from the previous chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The starting point for this chapter is represented by the Restaurants app developed
    in the previous chapter. If you haven't followed the implementation from the previous
    chapter, access the starting point for this chapter by navigating to the `Chapter_09`
    directory of the repository and import the Android project entitled `chapter_9_restaurants_app`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the solution code for this chapter, navigate to the `Chapter_10`
    directory: [https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_10/chapter_10_restaurants_app](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_10/chapter_10_restaurants_app)'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the fundamentals of testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will briefly cover the basics of testing. More precisely,
    we will be doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the benefits of testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the types of tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with the benefits of testing!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the benefits of testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing our code is essential. Through tests, we ensure that our app's functional
    behavior is correct and as expected, while also making sure that it's usable,
    just as it was designed. By performing tests, we can release stable and functional
    apps to end users.
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, if we develop an app and then test it consistently, we ensure
    that new updates with new functionality won't break the existing functionality,
    and no bugs will arise. This is often referred to as **regression testing**.
  prefs: []
  type: TYPE_NORMAL
- en: You can test your app manually by navigating through it on your device or emulator
    and making sure that every piece of data is displayed correctly, while also being
    able to interact correctly with every UI component.
  prefs: []
  type: TYPE_NORMAL
- en: However, manual testing is neither efficient nor fast. With manual testing,
    you must traverse every user flow, generate every user interaction, and verify
    the integrity of data displayed at any moment. Also, you must do this, consistently,
    on every application update. Moreover, manual testing scales poorly, as with every
    new update that contains a new functionality, the manual workload of testing the
    entire application increases.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, manual testing becomes a burden for medium- and large-sized applications.
    Also, manual testing involves a human tester, which generates a human factor –
    this basically means that a tester may or may not in some circumstances overlook
    some bugs.
  prefs: []
  type: TYPE_NORMAL
- en: To alleviate these issues, in this chapter, we will be writing automated tests.
    Practically, we will define some scripted tests and then allow tools to run them,
    automatically. This approach is faster, consistent, and more efficient, as it
    scales better with the size of the project.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, we will write other chunks of code that will test the code of
    our application. While this might sound weird, the approach of having automated
    tests is much more productive and reliable, and less time-consuming than manual
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, let's cover the different types of tests that we can write.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring types of tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To better understand how to write tests, we must first decide *what exactly
    can be tested* in our apps. From this perspective, let''s cover the most important
    types of tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functional tests**: Is the app doing what is expected? We already touched
    upon functional tests and their benefits in the *Understanding the benefits of
    testing* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compatibility tests**: Is the app working correctly on all devices and Android
    API levels? The Android ecosystem makes this particularly difficult if you consider
    the variety of devices and manufacturers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance tests**: Is the app fast or efficient enough? Sometimes, apps
    can suffer from bottlenecks and UI stutters that can be identified via performance
    benchmarks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Accessibility tests**: Is the app working well with accessibility services?
    Such services are used to assist users with disabilities in using our Android
    application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will be mainly focusing on functional tests in an attempt
    to ensure the functional integrity of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, apart from deciding what has to be tested, we must also think about the
    *scope or size of the tests*. The scope indicates the size of the app''s portion
    we''re testing. From the perspective of the scope of the tests, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit tests**: Often referred to as small tests, these test the functional
    behavior of methods, classes, or groups of classes in an isolated environment.
    Usually, unit tests target small portions of the app without interacting with
    the real-world environment; hence, they are more reliable than tests that depend
    on external input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration tests**: Often referred to as medium tests, these test whether
    multiple units interact and function correctly together.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**End-to-end tests**: Often referred to as big tests, these test large portions
    of the application, from multiple screens to entire user flows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on the size of the tests, each type has a degree of isolation. The
    **degree of isolation** is tightly related to the scope of the tests, as it measures
    how dependent the component we're testing is on other components. As the size
    of the test increases, from small to big, the isolation level of the tests decreases.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be mainly focusing on unit tests, as they are fast,
    with the simplest setup, and most reliable in helping us validate the functionality
    of our application. These traits are tightly related to the higher isolation level
    of unit tests from external components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we must also classify tests based on the system they will be running
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Local tests**: Run on your workstation or development system (used in practices
    such as **Continuous Integration** (**CI**)) without the need of an Android device
    or emulator. They are usually small and fast, isolating the component under test
    from the rest of the application. Most of the time, unit tests are local tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instrumented tests**: Run on an Android device, be it a physical device or
    emulator. Most of the time, UI tests are considered instrumented tests, since
    they allow the automated testing of an application on an Android device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, our unit tests will be local when we will be testing the core
    logic of some components in isolation and instrumented when we will be performing
    UI unit tests for a specific screen in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: Let's proceed with local UI tests first!
  prefs: []
  type: TYPE_NORMAL
- en: Learning the basics of testing your Compose UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UI tests allow us to evaluate the behavior of our Compose code against what
    is expected to be correct. This way, we can catch bugs early in our UI development
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test our UI, we must first decide what we are aiming to evaluate. To keep
    it simple, in this section, we will unit-test our UI in an isolated environment.
    In other words, we want to test the following:'
  prefs: []
  type: TYPE_NORMAL
- en: That our composable screens consume the received state as expected. We want
    to make sure that the UI correctly represents the different state values that
    it can receive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For our composable screens, that user-generated events are correctly forwarded
    to the caller of the composable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To keep our tests simple, we will define these tests as unit tests and try to
    isolate screen composables from their `ViewModel` or from other screen composables;
    otherwise, our test will become an integration or an end-to-end test.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, we will test separately each screen, with total disregard of
    anything outside of their composable function definition. Even though our tests
    will run on an Android device, they will be testing only one unit – a screen composable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Some UI tests can also be considered unit tests, as long as they are testing
    only one part of the UI of your application, as we will do in this section.
  prefs: []
  type: TYPE_NORMAL
- en: For starters, we need to test the first screen of our application, represented
    by the `RestaurantsScreen()` composable. Let's begin!
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the following testing dependencies inside the `dependencies` block
    of the app-level `build.gradle` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These dependencies will allow us to run our Compose UI tests on an Android device.
  prefs: []
  type: TYPE_NORMAL
- en: After updating the `build.gradle` file, make sure to sync your project with
    its Gradle files. You can do that by pressing on the **File** menu option and
    then by selecting **Sync Project with Gradle Files**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before creating a test class, locate the `androidTest` package that is suited
    for instrumented tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Observing the androidTest package for UI tests'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17788_10_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.1 – Observing the androidTest package for UI tests
  prefs: []
  type: TYPE_NORMAL
- en: In Android projects, this directory stores source files for UI tests. Also note
    that the pre-built `ExampleInstrumentedTest` class resides in this directory.
  prefs: []
  type: TYPE_NORMAL
- en: Create an empty Kotlin class named `RestaurantsScreenTest` inside the `androidTest`
    package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside this class, we will define a method for each independent test. Behind
    the scenes, every method will become a standalone UI test that can pass or fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before creating our first test method, inside the `RestaurantsScreenTest` class,
    add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To run our Compose UI tests, we are using the JUnit testing framework that will
    allow us to write repeatable unit tests in an isolated environment with the help
    of a test rule. **Test rules** allow us to add functionality to all the tests
    within a test class.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we need to test Compose UI in every test method, so we had to use
    a special `ComposeContentTestRule` object. To access this rule, we have previously
    imported a special JUnit rule dependency so that our test class now defines a
    `testRule` variable and instantiates it by using the `createComposeRule()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '`ComposeContentTestRule` will not only allow us to set the Compose UI under
    test but also host tests on an Android device, while also giving us the ability
    to interact with the composables under test or perform UI assertions.'
  prefs: []
  type: TYPE_NORMAL
- en: Before writing our first test method though, we need to clearly understand what
    behavior we are trying to test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at how our `RestaurantsScreen()` composable consumes a `RestaurantsScreenState`
    instance from its `state` parameter, and how it forwards events to its caller
    through the `onItemClick` and `onFavoriteClick` function parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: By looking at the previous snippet, we see that we can test how the `onItemClick`
    and `onFavoriteClick` functions are called, based on different UI interactions,
    and also that we can test whether the state is consumed correctly or not. Yet
    we can't infer very well the possible values of the state that our composable
    is receiving.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get an overview of the possible states that we want to feed into our `RestaurantsScreen()`
    so that we can test its behavior, we need to have a look at its state producer,
    `RestaurantsViewModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can say that our screen should have three possible states:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewModel` class in the initialization of the `_state` variable, where the
    `restaurants` parameter of `RestaurantsScreenState` is set to `emptyList()` and
    the `isLoading` parameter is set to `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getRestaurants()` method where we mutated the initial state and set the `isLoading`
    parameter to `false`, while also passing the list of restaurants to the `restaurants`
    parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CoroutineExceptionHandler` where the `isLoading` parameter is set to `false`
    to reset the loading status, while also passing the message of `Exception` to
    the `error` parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know what behavior the `RestaurantsScreen` composable should exhibit
    and what input we should pass to it in order to produce such a behavior, it's
    time to actually put our composable screen under test.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin by verifying whether the `RestaurantsScreen` composable correctly
    renders the first state – that is, the initial loading state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `RestaurantsScreenTest` class, add an empty test function named
    `initialState_isRendered()` that will later test whether our `RestaurantsScreen()`
    composable properly renders the initial state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To tell the JUnit testing library to run an individual test for this method,
    we've annotated it with the `@Test` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that we named this method around the specific behavior it's trying
    to test, going from what we're testing (the initial state) to how it's supposed
    to behave (to be rendered correctly), while separating these two with an underscore.
    For unit tests, there are a lot of naming conventions, yet we will try to stick
    to the simple version mentioned before.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Each test method annotated with `@Test` should focus on only one specific behavior,
    just as `initialState_isRendered()` will test whether the `RestaurantsScreen()`
    properly renders the initial state, and no other pieces. This allows us to focus
    on only one behavior on each test method so that we can better identify later
    which specific behavior is no longer working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepare the `initialState_isRendered()` method to set the Compose UI by calling
    `testRule.setContent()`, just as our `MainActivity` did with its own `setContent()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside the block of code exposed by the `setContent()` method, we must pass
    the **unit under test**, which is nothing else than the composable we're trying
    to test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our case, we will pass the `RestaurantsScreen()` composable, not before
    wrapping it inside the `RestaurantsAppTheme()` theme function so that the Compose
    UI that is under test mimics what our app is actually displaying in the production
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you have named your app name differently, then the theme composable might
    have a different definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the `RestaurantsScreen()` composable is expecting a `RestaurantsScreenState`
    object into its `state` parameter and two functions for its `onFavoriteClick()`
    and `onItemClick()` parameters. Let''s add these while also passing the expected
    initial state from the screen''s `ViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since we're looking to test whether `RestaurantsScreen()` is correctly rendering
    the initial state, we have passed an instance of `RestaurantsScreenState` that
    had the `restaurants` parameter set to `emptyList()`, and the `isLoading` parameter
    is set to `true` while the `error` parameter is by default set to `null`.
  prefs: []
  type: TYPE_NORMAL
- en: We have now finished setting up the `RestaurantsScreen()` composable and fed
    it with the expected initial state. It's time to perform the assertion of whether
    our composable is correctly consuming this initial state or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `RestaurantsScreen()` composable, the initial state is a state mainly
    defined by the loading indicator that expresses how the app is waiting for content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: That's why we can check whether the `CircularProgressIndicator()` is visible
    on the screen. But how can we assert whether this composable is visible or not?
  prefs: []
  type: TYPE_NORMAL
- en: Compose provides us with several testing APIs to help us find elements, verify
    their attributes, and even perform user actions. For UI tests with Compose, we
    consider pieces of UI as **nodes** that we can identify with the help of semantics.
    **Semantics** give meaning to a UI element, and for an entire composable hierarchy,
    a semantics tree is generated to describe it.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, we should be able to identify anything that is described on
    the screen with the help of its exposed semantics.
  prefs: []
  type: TYPE_NORMAL
- en: To give an example, a `Text` composable that displays a `String` object such
    as `"Hello"` will become a node in the semantics tree that we can identify by
    its `text` property value – `"Hello"`. Similarly, composables such as `Image`
    expose a mandatory `contentDescription` parameter whose value will allow us to
    identify the corresponding node in the semantics tree inside our tests. Don't
    worry – we'll see a practical example of this in a second.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: While the semantics attributes are mainly used for accessibility purposes (`contentDescription`,
    for example, is a parameter that allows people with disabilities to better understand
    what the visual element it describes is about), it's also a great tool that exposes
    semantics used to identify nodes in our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have briefly covered how we can use semantics information to identify
    UI elements as nodes, it's time to get back to our test, which should validate
    if, upon an initial state consumed by `RestaurantsScreen()`, its `CircularProgressIndicator()`
    is visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we look again at the usage of `CircularProgressIndicator()`, we
    can see that it exposes no semantics that we can use to identify it later in our
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There is no `contentDescription` parameter and no visual text displayed. To
    be able to identify the node of `CircularProgressIndicator()` we must manually
    add a semantics `contentDescription` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a moment, let''s head out of the `androidTest` directory and go back inside
    the main package where our production code resides. Inside the `presentation`
    package, create a new `object` class named `Description` and define a constant
    description `String` variable for our loading composable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `RestaurantsScreen()` composable, pass a `semantics` modifier to
    the `CircularProgressIndicator()` composable and set its `contentDescription`
    property to the previously defined `RESTAURANTS_LOADING`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we will be able to identify the node represented by the `CircularProgressIndicator()`
    composable inside our UI tests by using the `contentDescription` semantics property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go back inside the `androidTest` directory and navigate to the `RestaurantsScreenTest`
    class, and in the `initialState_isRendered()` test method, use the `testRule`
    variable to identify the node with the `RESTAURANT_LOADING` content description
    with the help of the `onNodeWithContentDescription()` method, and finally, verify
    that the node is displayed with the `assertIsDisplayed()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside the `RestaurantsScreenTest` class and select **Run RestaurantsScreenTest**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This command will run all the tests inside this class (only one in our case)
    on an Android device (either your physical Android device or your emulator).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we switch to the `RestaurantsScreen()` was rendered correctly has passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Observing the UI tests that have passed'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17788_10_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.2 – Observing the UI tests that have passed
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Although we have defined a test where UI elements are identified via semantic
    properties, it's also possible to match a piece of UI by making it incorporate
    a `testTag` modifier that is later identified via the `hasTestTag()` matcher.
    However, you should avoid this practice, as you will be polluting your Compose
    UI production code with testing identifiers used only for tests.
  prefs: []
  type: TYPE_NORMAL
- en: While your test ran on an Android device or emulator, you might have noticed
    that no UI was shown on its screen. This happens because the UI tests are really
    fast. If you want to see the UI that you're testing, you can add a `Thread.sleep()`
    call at the end of the test method; however, you should avoid such a practice
    in your production test code.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to test whether the `RestaurantsScreen()` composable is rendering
    another state correctly – the state with content. In this state, the restaurants
    have arrived, so we reset the loading status to `false` and render the restaurants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `RestaurantsScreenTest` class, add another test function named `stateWithContent_isRendered()`,
    which should test whether the state with content is rendered correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside this test method, we have set the `RestaurantsScreen()` composable with
    a state whose `isLoading` field is `false` (as the restaurants have arrived) but
    haven't passed a list of restaurants yet. We need to create a dummy list of restaurants
    to mimic some restaurants from our data layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a moment, let''s head out of the `androidTest` directory and go back inside
    the main package where our production code resides. Inside the `restaurants` package,
    create a new `object` class named `DummyContent`, and inside this class, add a
    `getDomainRestaurants()` method that will return a dummy array list of `Restaurant`
    objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, go back inside the `androidTest` directory and navigate to the `RestaurantsScreenTest`
    class. Inside the `stateWithContent_isRendered()` method, declare a `restaurants`
    variable that will hold the dummy restaurants from the `DummyContent` class and
    pass it to the `restaurants` parameter of `RestaurantsScreenState`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have finished the setup part of this test method, it''s time to
    perform our assertions. Since we are testing that `RestaurantsScreen()` is correctly
    rendering the state that contains restaurants, let''s have another quick look
    at the composable under test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can deduct that the two conditions we can assert are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The restaurants from `RestaurantsScreenState` are displayed on the screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CircularProgressIndicator()` composable is not rendered, so its node is
    not visible on the screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start off with the first assertion. Instead of relying on the `contentDescription`
    semantic property, we can use another semantic property that is more obvious –
    the text displayed on the screen. Since `LazyColumn` will render a list of `RestaurantItem()`
    composables, each one will call a `Text` composable that will render the title
    and the description of the restaurant passed to its `text` parameter. With the
    help of our `ComposeContentTestRule`, we can identify a node with a certain text
    value by calling the `onNodeWithText()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Back in the `stateWithContent_isRendered()` method, let's assert that `title`
    of the first `Restaurant` object from our dummy list is visible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Do that by passing the title of the first element from the `restaurants` variable
    to the `onNodeWithText()` method, thereby identifying its corresponding node.
    Finally, call the `assertIsDisplayed()` method to verify whether this node is
    displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, to assert whether the node of the title of the first restaurant
    from our dummy list is displayed, verify whether the node of the description of
    the first restaurant is displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You might be wondering why we aren't asserting whether `title` or `description`
    of all the elements from the `DummyContent` class is visible. It's important to
    understand that our test is asserting whether some nodes are displayed on the
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: That's why, if our `restaurants` list contained 10 or 15 elements and we tested
    whether all titles and description nodes are visible, we could have had this test
    method pass on tall devices, since all the restaurants would fit and would be
    *composed* on the screen, but it could have failed if the test device was small
    and only some of the restaurants fitted on the screen and were composed.
  prefs: []
  type: TYPE_NORMAL
- en: This would have made our test flaky. To prevent our test from being flaky, we
    only asserted whether the first restaurant is visible, therefore minimizing the
    chance of having the test run and fail on an incredibly small screen.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting tactic that you can employ in order to test that content
    is correctly rendered would be to emulate a scroll action inside your test to
    the bottom of the list and check whether the last element is visible. This, however,
    is more complex, so we will proceed with the simpler version that we have implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, let''s assert that the node corresponding to the `CircularProgressIndicator()`
    composable does not exist, therefore ensuring that the app is not loading anything
    anymore. Do that by calling the `assertDoesNotExist()` method on the node with
    the `RESTAURANTS_LOADING` content description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have finished writing our second test method asserting whether the
    `RestaurantsScreen()` composable is correctly rendering the state with content,
    inside the `RestaurantsScreenTest` class and select **Run RestaurantsScreenTest**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The tests should run and pass.
  prefs: []
  type: TYPE_NORMAL
- en: Assignment
  prefs: []
  type: TYPE_NORMAL
- en: Try writing a test method on your own that asserts whether the `RestaurantsScreen()`
    composable renders the error state correctly. As a hint, you should be passing
    an error text to the `error` parameter of the `RestaurantsScreen()`, and then
    you should be asserting whether a node with that particular text is visible, while
    also verifying that the node corresponding to the `CircularProgressIndicator()`
    composable does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s write a test method where we can verify whether upon clicking
    on a restaurant element from our dummy list, the correct callback is exposed by
    the parent `RestaurantsScreen()` composable:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `RestaurantsScreenTest` class, add another test function named `stateWithContent_ClickOnItem_isRegistered()`.
    Inside this method, store the dummy list inside a `restaurants` variable, and
    then store the first restaurant that we will click upon inside the `targetRestaurant`
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, set `RestaurantsScreen()` under test and feed it with a state with content
    by passing the contents of the `restaurants` variable to the `restaurants` parameter
    of `RestaurantsScreenState`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, identify the node that contains the `title` text of `targetRestaurant`
    and then simulate a user click on this node by calling the `performClick()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have simulated a user-click interaction, let''s assert that the
    `id` value from the `onItemClick` callback exposed by the `RestaurantsScreen()`
    composable matches with the `id` value of the restaurant we have clicked on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside the `RestaurantsScreenTest` class and select **Run RestaurantsScreenTest**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The three tests should run and pass.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that we haven't given any attention to testing how the
    UI updates when a user toggles a restaurant as a favorite or not a favorite. The
    only way we could have done that is by adding a dedicated semantic property to
    the heart icon of each restaurant from the list and then testing the value of
    that property. However, we would have tested a semantic property value and not
    the UI – for such cases, it's better to look into **screenshot testing** strategies.
    Screenshot testing is a UI testing practice that generates screenshots of your
    app, which are then compared to the initially defined *correct* versions.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we briefly covered UI testing with Compose, it's time to unit-test
    our app's behind-the-scenes functionality!
  prefs: []
  type: TYPE_NORMAL
- en: Covering the basics of unit-testing your core logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from testing our UI layer, we must also test the core logic of our application.
    This means that we should try to verify as much behavior as possible in terms
    of presentation logic (testing `ViewModel` classes), business logic (testing `UseCase`
    classes), or even data logic (testing `Repository` classes).
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way of validating such logic is by writing unit tests for each class
    or group of classes whose behavior we're trying to verify.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will be writing unit tests for the `RestaurantsViewModel`
    class and the `ToggleRestaurantUseCase` class. Since these components don't interact
    directly with the UI, their unit tests will run directly on your local workstation's
    **Java Virtual Machine** (**JVM**), rather than running on an Android device,
    as our UI tests did.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, in this section, we will be doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing the functionality of a `ViewModel` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the functionality of a `UseCase` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's begin by testing the `RestaurantsViewModel` class!
  prefs: []
  type: TYPE_NORMAL
- en: Testing the functionality of a ViewModel class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want to test the functionality of our `RestaurantsViewModel` so that we can
    make sure that it's correctly performing the role of state producer for the `RestaurantsScreen()`
    composable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve that, we will write unit tests for this `ViewModel` class in isolation.
    Let''s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, locate the `test` package that is suited for regular unit tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Observing the test package used for regular unit tests'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17788_10_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.3 – Observing the test package used for regular unit tests
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that the pre-built `ExampleUnitTest` class resides inside this package.
  prefs: []
  type: TYPE_NORMAL
- en: Create an empty Kotlin class named `RestaurantsViewModelTest` inside the `test`
    package. Inside this class, we will define a method for each independent test.
    Behind the scenes, every method will become a standalone unit test that can pass
    or fail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before starting to write our first test method, let''s have another look at
    our `RestaurantsViewModel` class so that we can remind ourselves which cases we''re
    looking to test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can say that our `RestaurantsViewModel` should produce the exact three states
    that we fed to the `RestaurantsScreen()` composable in its own UI tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewModel` class in the initialization of the `_state` variable, where the
    `restaurants` parameter of `RestaurantsScreenState` is set to `emptyList()` and
    the `isLoading` parameter is set to `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getRestaurants()` method, where we mutated the initial state and set the `isLoading`
    parameter to `false` while also passing the list of restaurants to the `restaurants`
    parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CoroutineExceptionHandler`, where the `isLoading` parameter is set to `false`
    to reset the loading status while also passing the message of `Exception` to the
    `error` parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the end, what we basically have to do is assert that the value of the `state`
    variable (of type `RestaurantsScreenState`), which is exposed to the UI, evolves
    correctly over time, from the initial state to all possible states.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin with a test method that asserts whether the initial state is produced
    as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `RestaurantsViewModelTest` class, add an empty test function named
    `initialState_isProduced()` that will later test whether our `RestaurantsViewModel`
    class properly produces the initial state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As with the UI tests, we will make use of the JUnit testing library to define
    and run individual unit tests for each method annotated with the `@Test` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Again similar to the UI tests, we named this method around the specific behavior
    it's trying to test, going from what we're testing (the initial state) to what
    should happen (the state being correctly produced).
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `initialState_isProduced()` method, we must create an instance of
    the subject under test – that is, `RestaurantsViewModel`. Define a `viewModel`
    variable and instantiate it with the value returned by the `getViewModel()` method,
    which we will define in a second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still inside the `RestaurantsViewModelTest` class, define the `getViewModel()`
    method, which will return an instance of `RestaurantsViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The problem now is that the `RestaurantsViewModel` constructor needs an instance
    of `GetInitialRestaurantsUseCase` and `ToggleRestaurantsUseCase`. In turn, these
    two classes also have other dependencies that we must instantiate. Let''s have
    a clearer look at what classes we need to instantiate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Observing the direct and transitive dependencies of RestaurantsViewModel'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17788_10_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.4 – Observing the direct and transitive dependencies of RestaurantsViewModel
  prefs: []
  type: TYPE_NORMAL
- en: We can see that both `GetInitialRestaurantsUseCase` and `ToggleRestaurantsUseCase`
    depend on `GetSortedRestaurantsUseCase` and `RestaurantsRepository`. The latter
    then depends on two library interfaces – `RestaurantsApiService` and `RestaurantsDao`.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, we must instantiate all these classes to test our `RestaurantsViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `RestaurantsViewModelTest` class, refactor the `getViewModel()`
    method to construct all the necessary dependencies of `RestaurantsViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you read the previous snippet from bottom to top, you will notice that we
    were able to construct all the dependencies of the `RestaurantsViewModel`, and
    their dependencies, and so on until we hit `RestaurantsRepository`. This depends
    on two library interfaces, `RestaurantsApiService` and `RestaurantsDao`, whose
    implementations are provided by the Retrofit and Room libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our production code, these two interfaces cross the boundary to the *real
    world* because their implementations, provided by the Retrofit and Room libraries,
    communicate with a real Firebase REST API and a real Room local database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Observing the real-world boundary crossed by the transitive'
  prefs: []
  type: TYPE_NORMAL
- en: dependencies of RestaurantsViewModel
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17788_10_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.5 – Observing the real-world boundary crossed by the transitive dependencies
    of RestaurantsViewModel
  prefs: []
  type: TYPE_NORMAL
- en: If we were to use the existing implementations of these two interfaces provided
    by Retrofit and Room in our test code, the `RestaurantsViewModel` instance will
    communicate with the external world and our tests won't be isolated. Instead,
    our test code will be slow and not reliable because it will be dependent on our
    web REST API and a real local database.
  prefs: []
  type: TYPE_NORMAL
- en: Yet how can we make our `RestaurantsViewModel` tests isolated, fast, and reliable?
    We can simply make sure that instead of having Retrofit and Room provide the implementations
    for `RestaurantsApiService` and `RestaurantsDao`, we define dummy implementations
    for these interfaces that won't communicate with the real world.
  prefs: []
  type: TYPE_NORMAL
- en: These dummy implementations are often called fakes. **Fakes** are simplified
    implementations of the interfaces that we're looking to interact with in our tests.
    Such implementations mimic the behavior of the production implementations in a
    very simplified manner, often by returning dummy data. Fakes will only be used
    in our tests, so we can ensure that our testing environment is isolated.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from fakes, to mimic the functionality of components that cross the boundary
    to the real world, you can also use mocks. **Mocks** are objects that also simulate
    the behavior of a real object; however, you can configure their output on the
    fly without any additional classes.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will only focus on fakes, since most of the time, to create
    mocks, you need to use special mocking frameworks. Also, fakes tend to be more
    practical and can be reused across tests, whereas mocks tend to clutter your tests,
    as they bring a lot of boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you have a component that interacts with the *real world*, be it a
    web API, local database, or other production systems, you should define an interface
    for it. This way, in your production code, your other components interact with
    a real implementation of that interface, while your tests interact with a fake
    implementation of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can implement fakes. In our case, `RestaurantsRepository`
    needs fake implementations of the `RestaurantsApiService` and `RestaurantsDao`
    interfaces. Let''s begin with a fake implementation of the `RestaurantsApiService`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a fake for the `RestaurantsApiService` interface, we must define
    a class that will implement the interface and simulate the functionality of a
    REST API. Inside the `test` package, create a Kotlin class named `FakeApiService`
    that implements the `RestaurantsApiService` interface and add the following code
    inside:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our `FakeApiService` overrides the required methods and returns some dummy restaurants
    from the `DummyContent` class. In the `getRestaurants()` method, we also call
    a coroutine-based `delay()` function of 1,000 milliseconds to better simulate
    an asynchronous response. Since we will not be using the `getRestaurant()` method
    in our tests right now, we haven't added any implementation inside it.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to the dummy content that is returned, note that the `getRestaurants()`
    method must return a list of `RemoteRestaurant` objects, so we called a non-existent
    `getRemoteRestaurants()` method on the `DummyContent` class. Let's define this
    method up next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Head back inside the main source set where our production code resides. Inside
    the `DummyContent` class, add a new method called `getRemoteRestaurants()` that
    maps the list of `Restaurant` objects returned by the `getDomainRestaurants()`
    method to `RemoteRestaurant` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, head back inside the `test` package. We''ve created a fake for the `RestaurantsApiService`
    interface, but we must also create one fake for the `RestaurantsDao` interface
    that will implement the interface and simulate the functionality of a local database.
    Inside the `test` package, create a Kotlin class named `FakeRoomDao` that implements
    the `RestaurantsDao` interface and add the following code inside:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our `FakeRoomDao` class mimics the functionality of a real Room database, yet
    instead of storing restaurants in the local SQL database, it stores them in memory
    in the `restaurants` variable. We will not cover each method implementation of
    `FakeRoomDao`.
  prefs: []
  type: TYPE_NORMAL
- en: However, we will conclude that each method simulates the interaction with a
    persistent storage service. Additionally, as our `FakeRoomDao` simulates interaction
    with a real local database, each of its actions will cause a delay triggered by
    the pre-built suspending `delay()` function.
  prefs: []
  type: TYPE_NORMAL
- en: However, our `FakeRoom` class makes use of an `updateRestaurant()` method that
    we haven't defined so far. Let's do that now.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the body of the `FakeRoom` class, add the missing `updateRestaurant()`
    method that toggles the value of the `isFavorite` field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have finished implementing the fakes for our `RestaurantsApiService`
    and `RestaurantsDao` interfaces, it's time to pass them where we need them in
    our tests. Remember that the last missing piece was to provide fake implementations
    of the `RestaurantsRepository` dependencies so that our test is isolated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Head back inside the `RestaurantsViewModelTest` class and update the `getViewModel()`
    function to pass instances of the `FakeApiService` and `FakeRoomDao` classes to
    `RestaurantsRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the `getViewModel()` method is able to return an instance of `RestaurantsViewModel`
    that we can easily test, let''s get back to our `initialState_isProduced()` test
    method, which currently looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the scope of this test method is to verify that when our `RestaurantsViewModel`
    is initialized, it produces a correct initial state. Let's do that now.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, inside the `initialState_isProduced()` test method, store the initial
    state inside an `initialState` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, by using the built-in `assert()` function, verify whether the content
    of `initialState` is as expected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this test method, we're asserting whether the value of the `initialState`
    variable is a `RestaurantsScreenState` object with a `false` `isLoading` field
    and an `emptyList()` value inside the `restaurants` field. Additionally, we're
    testing that there is no value stored inside the `error` field.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have defined our first test method, it's time to run the test!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `RestaurantsViewModelTest` class and select **Run RestaurantsViewModelTest**.
    This command will run all the tests inside this class (only one in our case) directly
    on your local JVM, rather than running on an Android device, as our UI tests did.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you switch to the **Run** tab, you will see that our test has failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Observing how the test inside the RestaurantsViewModelTest
    class has failed'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17788_10_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.6 – Observing how the test inside the RestaurantsViewModelTest class
    has failed
  prefs: []
  type: TYPE_NORMAL
- en: This exception is thrown because our Restaurants app handles asynchronous work
    with the help of coroutines, and our test code doesn't know how to interact with
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, our `RestaurantsViewModel` launches coroutines that call several
    suspend functions, and all of these happen on `viewModelScope`, which has the
    `Dispatchers.Main` dispatcher set by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The main issue here is that our coroutines are launched on the Main thread on
    our local JVM, which can't work with the UI thread.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `Dispatchers.Main` dispatcher uses the Android `Looper.getMainLooper()`
    function to run code in the UI thread. That method is available in UI tests but
    not in the regular unit tests that run on our JVM.
  prefs: []
  type: TYPE_NORMAL
- en: To make our testing code compliant with the usage of coroutines, we need to
    use the Kotlin coroutines testing library, which will provide us with scopes and
    dispatchers that are dedicated to testing coroutines. If our test code is run
    from coroutines that are built with these dedicated scopes and dispatchers, our
    test will no longer fail.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add the Kotlin coroutines testing library!
  prefs: []
  type: TYPE_NORMAL
- en: 'In the app-level `build.gradle` file, add a `testImplementation` dependency
    to the Kotlin coroutines testing package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Synchronize your project with its Gradle files by clicking on the **Sync your
    project with Gradle files** button in Android Studio or by pressing on the **File**
    menu option and then by selecting **Sync Project with Gradle Files**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Head back inside the `RestaurantsViewModelTest` class and define a variable
    for a `StandardTestDispatcher` object and a variable for a `TestScope` object
    based on the previously defined dispatcher:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Additionally, we've added the `@ExperimentalCoroutinesApi` annotation to the
    `RestaurantsViewModelTest` class, since these testing APIs are still experimental.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, make sure that all the code from within the body of the `initialState_isProduced()`
    test method is run inside a test-specific coroutine. To do that, launch a coroutine
    that wraps this method''s body by calling the `runTest()` coroutine builder on
    our `scope` variable of type `TestScope`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the `RestaurantsViewModelTest` class. If you switch to the **Run** tab,
    you will see that our test has failed again, with the same exception as before.
    Since we wrapped the body of our test method inside a test coroutine, our test
    code still throws an exception, telling us that we still need to change the dispatcher
    of the coroutine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we have another look at `RestaurantsViewModel`, we can note that both the
    coroutines launched with `viewModelScope` have no dispatcher set, so they''re
    using `Dispatchers.Main` behind the scenes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: However, in our test, all coroutines that are launched should use `StandardTestDispatcher`
    defined in our test class. So, how can we pass a test dispatcher to the coroutines
    launched in our `RestaurantsViewModel`?
  prefs: []
  type: TYPE_NORMAL
- en: We can inject the dispatcher inside the `RestaurantsViewModel` class by using
    its constructor and making it accept a `CoroutineDispatcher` object, which will
    be passed to all the coroutines that are launched.
  prefs: []
  type: TYPE_NORMAL
- en: This way, in our production code, `RestaurantsViewModel` will receive and use
    the `Dispatchers.Main` dispatcher, and inside our test code, it will receive and
    use the `StandardTestDispatcher` dispatcher.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The practice of injecting dispatchers into our coroutine-based classes is encouraged,
    as it allows us to have better isolation and control over the testing environment
    of our unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Head back inside the main source set where our production code resides. Inside
    `RestaurantsViewModel`, add a `dispatcher` constructor parameter of type `CoroutineDispatcher`
    and pass it to the `viewModelScope()` calls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: However, if we build the project now, we will get an error because Hilt doesn't
    know how to provide an instance of `CoroutineDispatcher` to `RestaurantsViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: To instruct Hilt on how to provide our `ViewModel` with the dispatcher it needs
    (that is, `Dispatchers.Main`), we must create a Hilt module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `di` package, create a new class called `DispatcherModule` and add
    the following code that tells Hilt how to provide any `CoroutineDispatcher` dependencies
    with `Dispatchers.Main`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: However, right now, Hilt will always provide `Dispatchers.Main` to any `CoroutineDispatcher`
    dependencies. What if we need later to obtain a dispatcher different than `Dispatchers.Main`?
    Let's see how we can prepare for that.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the body of `DispatcherModule`, define an annotation class called
    `MainDispatcher` annotated with the `@Qualifier` annotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `@Qualifier` annotation allows us to provide different dispatchers to the
    `CoroutineDispatcher` dependencies. In our case, we defined that a `@MainDispatcher`
    annotation will provide the `Dispatchers.Main` dispatcher.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `@MainDispatcher` annotation to the `providesMainDispatcher()` method
    so that Hilt will know what dispatcher to provide when such an annotation is used
    on a dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, inside `RestaurantsViewModel`, annotate the `dispatcher` parameter with
    the newly created `@MainDispatcher` annotation so that Hilt will provide us with
    the `Dispatchers.Main` dispatcher:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that the `RestaurantsViewModel` uses the `Dispatcher.Main` dispatcher in
    our production code, head back inside the `test` source set and inside the `RestaurantsViewModelTest`
    class, update its `getViewModel()` method by passing the `dispatcher` member field
    to the `RestaurantsViewModel` constructor call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, in our test code, `RestaurantsViewModel` will use the `StandardTestDispatcher`
    dispatcher for all the launched coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the `RestaurantsViewModelTest` class again. If you switch to the **Run**
    tab, you will see that our test has now passed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Observing how the test inside the RestaurantsViewModelTest
    class has succeeded'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17788_10_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.7 – Observing how the test inside the RestaurantsViewModelTest class
    has succeeded
  prefs: []
  type: TYPE_NORMAL
- en: Since our test uses the `runTest()` coroutine builder, any `delay()` calls in
    our fake implementations are skipped, making our test run fast, in just a few
    hundred milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have tested whether our `ViewModel` produces a correct initial state,
    it's time to test the state that comes after this initial state – the state with
    content. This state is produced when the restaurants have arrived (from our data
    layer), so the `isLoading` field should be reset to `false`, while the `restaurants`
    field should contain a list of restaurants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new testing method inside `RestaurantsViewModelTest` called `stateWithContent_isProduced()`
    that asserts whether the state with restaurants is produced as expected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since the `FakeApiService` returns the dummy list of `RemoteRestaurant` from
    the `DummyContent` class, it's only natural that we're expecting to get the same
    content in `ViewModel` but in the shape of the `Restaurant` objects – so we're
    asserting that the `restaurants` field of `currentState` contains the restaurants
    from `DummyContent`.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, if we run the `RestaurantsViewModelTest` class, the `stateWithContent_isProduced()`
    test will fail, telling us that `currentState` has the `isLoading` field's value
    of `true` and there are no restaurants inside the `restaurants` field.
  prefs: []
  type: TYPE_NORMAL
- en: This issue makes sense because we're basically obtaining the initial state and
    expecting it to be the state with content, which, in fact, comes later on. Because
    there are several `delay()` calls in our `FakeApiService` and `FakeRoomDao` implementations,
    we must allow time to pass so that `ViewModel` produces the second state – the
    one with restaurants. But how can we do that?
  prefs: []
  type: TYPE_NORMAL
- en: Inside a test, to immediately execute all pending tasks (such as the launched
    coroutine to get restaurants in our `ViewModel`) and to advance the virtual clock
    until after the last delay, we can call the `advanceUntilIdle()` function exposed
    by the coroutines test library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `stateWithContent_isProduced()` test method, after `RestaurantsViewModel`
    is instantiated but before our assertion, add the `advanceUntilIdle()` method
    call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we call `advanceUntilIdle()` inside our `scope` variable of type `TestScope`,
    we're advancing the virtual clock of `TestCoroutineScheduler` featured in the
    `StandardTestDispatcher` that we've initially passed to our `scope`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, run the `RestaurantsViewModelTest` class again. If you switch to the `stateWithContent_isProduced()`
    test still failed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The main issue here is that while we're trying to advance the virtual clock
    of our test by leveraging the fact that our test instance of `RestaurantsViewModel`
    now launches its coroutines on the `StandardTestDispatcher` instance that we've
    passed to it, we have another class that is passing its own `CoroutineDispatcher`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have a closer look inside our `RestaurantsRepository`, we can see that
    it''s passing a production-use `Dispatchers.IO` dispatcher to all its `withContext()`
    calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Because the `RestaurantsRepository` instance that our `RestaurantsViewModel`
    indirectly depends on uses the `Dispatchers.IO` dispatcher and not the `StandardTestDispatcher`
    one, the virtual clock of our test is not advanced as expected. Let's fix this
    issue by injecting the dispatcher in the `RestaurantsRepository`, just as we did
    for `RestaurantsViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: However, before performing the injection, we must first define a new type of
    `CoroutineDispatcher` that Hilt should know how to inject – the `Dispatchers.IO`
    dispatcher.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Head inside the `DispatchersModule` class and, just as we did for the `Dispatchers.Main`
    dispatcher, instruct Hilt on how to provide us with the `Dispatchers.IO` dispatcher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Head back inside the main source set where our production code resides. Inside
    the `RestaurantsRepository` class, inject `CoroutineDispatcher`, annotate it with
    the `@IoDispatcher` qualifier, and then pass the injected `dispatcher` to all
    the `withContext()` calls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, heading back inside our `test` package, inside the `RestaurantsViewModelTest`
    class, update the `getViewModel()` method to pass our `dispatcher` field of type
    `StandardTestDispatcher` to the `RestaurantsRepository` constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, run the `RestaurantsViewModelTest` class again. If you switch to the `RestaurantsViewModel`
    is correctly producing an error state. As a tip, make sure to throw an instance
    of the `Exception` class inside `FakeApiService` but just for this specific test
    method where you're verifying the error state. To achieve that, you can configure
    a constructor parameter in `FakeApiService` so that it can throw an exception
    if needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we tested how `RestaurantsViewModel` is producing the UI state, let's
    briefly have a look at how we could test a business component.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the functionality of a UseCase class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Aside from unit-testing the presentation layer of our application, it's very
    important to also test the business rules present in the app. In our Restaurants
    app, the business logic is encapsulated in `UseCase` classes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see say that we want to test `ToggleRestaurantUseCase`. Essentially, we
    want to make sure that when we execute this `UseCase` class for a specific restaurant,
    the business logic of negating the `isFavorite` field of the `Restaurant` is working.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, if one restaurant was not marked as favorite, after executing
    `ToggleRestaurantUseCase` for that specific restaurant, its `isFavorite` field
    should become `true`. While this business logic is indeed slim, in medium to large-sized
    applications, such business logic can become much more complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how a unit test for `ToggleRestaurantUseCase` would look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This unit test is similar to the ones we wrote for `RestaurantsViewModel` in
    the sense that it's also using `StandardTestDispatcher` and `TestScope`, simply
    because the `invoke()` operator of `ToggleRestaurantUseCase` is a `suspending`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure of the test is split into three parts, delimited by the suggestive
    comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ToggleRestaurantUseCase` instance and its direct and transitive dependencies,
    while passing our test dispatcher to the dependencies that need it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ToggleRestaurantUseCase` to be able to execute its business logic on a specific
    restaurant, we first had to make sure that our `RestaurantsRepository` instance
    had loaded the dummy restaurants. We then called `advancedUntilIdle()`, allowing
    any suspending (blocking) work related to obtaining and caching dummy restaurants
    to finish.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isFavorite` field we want to toggle as `targetItem`, obtained its current
    `isFavorite` field value, and executed `ToggleRestaurantUseCase`, storing the
    resultant restaurants inside the `updatedRestaurants` variable. Since this operation
    refreshes and re-obtains the restaurants from the fake local database, we then
    called `advancedUntilIdle()`, allowing any suspending work to finish.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isFavorite` field. Finally, we asserted that the resultant `updatedRestaurants`
    list is the same as the one we would expect to be correct – that is, `restaurants`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you run this test, it should pass.
  prefs: []
  type: TYPE_NORMAL
- en: Assignment
  prefs: []
  type: TYPE_NORMAL
- en: Try testing the behaviour of other Use Case classes such as `GetSortedRestaurantsUseCase`
    or even classes from the data layer such as `RestaurantsRepository`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we first had a look at the benefits of testing and classified
    tests based on different aspects. Afterward, we took a shot at testing our Compose-based
    UI and learned how to write UI unit tests by leveraging the power of the semantics
    modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned how to write regular – non-UI – unit tests in order to validate
    the core functionality of our application. In this part, we learned how to test
    our coroutine-based code and how important it is to inject the `CoroutineDispatcher`
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're steering away from the architectural side of Android
    development, and we will be incorporating data pagination with the help of yet
    another interesting library called Jetpack Paging.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ve briefly covered the basics of UI and unit testing,
    so the core concepts taught here should give you a solid starting point. However,
    there are several other topics that you might need while you continue your testing
    adventure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For UI tests, we used semantics modifiers to identify UI elements from our
    node hierarchy. When testing Compose UI, you should also be aware of the merged
    and unmerged semantics tree. Learn more about this topic by reading the official
    docs: [https://developer.android.com/jetpack/compose/semantics](https://developer.android.com/jetpack/compose/semantics).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With UI tests, we only scratched the surface in terms of testing APIs. Make
    sure to check out this official testing cheat sheet: [https://developer.android.com/jetpack/compose/testing-cheatsheet](https://developer.android.com/jetpack/compose/testing-cheatsheet).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our unit tests are based on the JUnit testing framework. To discover the power
    and flexibility of Junit, check out its official docs: [https://junit.org/junit4/](https://junit.org/junit4/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In your coroutine-based tests, apart from the `advanceUntilIdle()` API, you
    can also use the `advancetimeBy()` API to fast-forward the virtual clock of the
    test by a certain amount. Learn more about this function from the official Coroutines
    docs: [https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-delay-controller/advance-time-by.html](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-delay-controller/advance-time-by.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Your unit tests must be deterministic in the sense that every run of one test
    for the same revision of code should always yield the same result. Learn more
    about deterministic and non-deterministic tests from Martin Fowler: [https://martinfowler.com/articles/nonDeterminism.html](https://martinfowler.com/articles/nonDeterminism.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
