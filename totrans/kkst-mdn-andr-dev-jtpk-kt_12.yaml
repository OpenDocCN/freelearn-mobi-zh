- en: '*Chapter 10*: Test Your App with UI and Unit Tests'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：使用UI和单元测试测试您的应用'
- en: In the previous chapters, one of our main focuses was to have a testable architecture.
    We tried to achieve that by decoupling different components from each other.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们主要关注的是拥有可测试的架构。我们试图通过解耦不同的组件来实现这一点。
- en: In this chapter, because of the architecture we put in place, we will see how
    easy it is to test in isolation different parts of the Restaurants app.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，由于我们实施的架构，我们将看到测试餐厅应用的不同部分是多么容易进行隔离。
- en: In the *Exploring the fundamentals of testing* section, we will be understanding
    the benefits of testing and exploring various types of tests. In the *Learning
    the basics of testing your Compose UI* section, we will learn how to test our
    Compose UI.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在*探索测试基础*部分，我们将了解测试的好处并探索各种测试类型。在*学习测试Compose UI的基础*部分，我们将学习如何测试我们的Compose UI。
- en: Finally, in the *Covering the basics of unit-testing your core logic* section,
    we will learn how to test the core functionality of your Restaurants app.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在*覆盖单元测试核心逻辑的基础*部分，我们将学习如何测试餐厅应用的核心功能。
- en: 'To summarize, in this chapter we will be covering the following sections:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本章中，我们将涵盖以下部分：
- en: Exploring the fundamentals of testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索测试的基础
- en: Learning the basics of testing your Compose UI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习测试您的Compose UI的基础
- en: Covering the basics of unit-testing your core logic
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖单元测试核心逻辑的基础
- en: Before jumping in, let's set up the technical requirements for this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入之前，让我们为本章设置技术要求。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Building Compose-based Android projects for this chapter usually requires your
    day-to-day tools. However, to follow along smoothly, make sure you also have the
    following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为本章构建基于Compose的Android项目通常需要您日常使用的工具。然而，为了顺利跟进，请确保您还具备以下条件：
- en: The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer
    Android Studio version or even Canary builds but note that the IDE interface and
    other generated code files might differ from the ones used throughout this book.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arctic Fox 2020.3.1版本的Android Studio。您也可以使用更新的Android Studio版本或Canary构建，但请注意，IDE界面和其他生成的代码文件可能与本书中使用的不同。
- en: The Kotlin 1.6.10 or newer plugin installed in Android Studio.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装在Android Studio中的Kotlin 1.6.10或更新的插件。
- en: The Restaurants app code from the previous chapter.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前一章中餐厅应用的代码。
- en: The starting point for this chapter is represented by the Restaurants app developed
    in the previous chapter. If you haven't followed the implementation from the previous
    chapter, access the starting point for this chapter by navigating to the `Chapter_09`
    directory of the repository and import the Android project entitled `chapter_9_restaurants_app`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的起点是前一章中开发的餐厅应用。如果您没有跟随前一章的实现，可以通过导航到存储库的`Chapter_09`目录并导入名为`chapter_9_restaurants_app`的Android项目来访问本章的起点。
- en: 'To access the solution code for this chapter, navigate to the `Chapter_10`
    directory: [https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_10/chapter_10_restaurants_app](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_10/chapter_10_restaurants_app)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本章的解决方案代码，请导航到`Chapter_10`目录：[https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_10/chapter_10_restaurants_app](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_10/chapter_10_restaurants_app)
- en: Exploring the fundamentals of testing
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索测试的基础
- en: 'In this section, we will briefly cover the basics of testing. More precisely,
    we will be doing the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要介绍测试的基础。更确切地说，我们将做以下几件事：
- en: Understanding the benefits of testing
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解测试的好处
- en: Exploring the types of tests
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索测试类型
- en: Let's start with the benefits of testing!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从测试的好处开始吧！
- en: Understanding the benefits of testing
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解测试的好处
- en: Testing our code is essential. Through tests, we ensure that our app's functional
    behavior is correct and as expected, while also making sure that it's usable,
    just as it was designed. By performing tests, we can release stable and functional
    apps to end users.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 测试我们的代码是至关重要的。通过测试，我们确保我们的应用功能行为是正确的，符合预期，同时确保它可用，就像它被设计的那样。通过执行测试，我们可以向最终用户发布稳定且功能齐全的应用。
- en: More importantly, if we develop an app and then test it consistently, we ensure
    that new updates with new functionality won't break the existing functionality,
    and no bugs will arise. This is often referred to as **regression testing**.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，如果我们开发了一个应用并持续对其进行测试，我们就能确保新的更新（带有新功能）不会破坏现有功能，并且不会出现新的错误。这通常被称为**回归测试**。
- en: You can test your app manually by navigating through it on your device or emulator
    and making sure that every piece of data is displayed correctly, while also being
    able to interact correctly with every UI component.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在您的设备或模拟器上导航应用并确保每条数据都正确显示，同时能够正确与每个UI组件交互，来手动测试您的应用。
- en: However, manual testing is neither efficient nor fast. With manual testing,
    you must traverse every user flow, generate every user interaction, and verify
    the integrity of data displayed at any moment. Also, you must do this, consistently,
    on every application update. Moreover, manual testing scales poorly, as with every
    new update that contains a new functionality, the manual workload of testing the
    entire application increases.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，手动测试既不高效也不快速。使用手动测试，您必须遍历每个用户流程，生成每个用户交互，并验证在任何时刻显示的数据的完整性。此外，您必须在每次应用更新时持续这样做。此外，手动测试的扩展性较差，因为每当包含新功能的每个新更新时，测试整个应用的手动工作量都会增加。
- en: Over time, manual testing becomes a burden for medium- and large-sized applications.
    Also, manual testing involves a human tester, which generates a human factor –
    this basically means that a tester may or may not in some circumstances overlook
    some bugs.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，手动测试对于中大型应用来说变得负担沉重。此外，手动测试涉及人工测试员，这会产生人为因素——这基本上意味着测试员在某些情况下可能会忽略一些错误。
- en: To alleviate these issues, in this chapter, we will be writing automated tests.
    Practically, we will define some scripted tests and then allow tools to run them,
    automatically. This approach is faster, consistent, and more efficient, as it
    scales better with the size of the project.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了缓解这些问题，在本章中，我们将编写自动化测试。实际上，我们将定义一些脚本测试，然后让工具自动运行它们。这种方法更快、更一致、更高效，因为它可以更好地适应项目规模。
- en: In other words, we will write other chunks of code that will test the code of
    our application. While this might sound weird, the approach of having automated
    tests is much more productive and reliable, and less time-consuming than manual
    testing.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们将编写其他代码块来测试我们应用中的代码。虽然这听起来可能有些奇怪，但拥有自动化测试的方法更加高效、可靠，并且比手动测试节省时间。
- en: Next up, let's cover the different types of tests that we can write.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来了解我们可以编写的不同类型的测试。
- en: Exploring types of tests
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索测试类型
- en: 'To better understand how to write tests, we must first decide *what exactly
    can be tested* in our apps. From this perspective, let''s cover the most important
    types of tests:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解如何编写测试，我们首先必须决定在我们的应用中*确切可以测试什么*。从这个角度来看，让我们来了解一下最重要的测试类型：
- en: '**Functional tests**: Is the app doing what is expected? We already touched
    upon functional tests and their benefits in the *Understanding the benefits of
    testing* section.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能测试**：应用是否在按预期工作？我们已经在“理解测试的好处”部分提到了功能测试及其优势。'
- en: '**Compatibility tests**: Is the app working correctly on all devices and Android
    API levels? The Android ecosystem makes this particularly difficult if you consider
    the variety of devices and manufacturers.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**兼容性测试**：应用是否在所有设备和Android API级别上都能正确工作？如果你考虑到设备的多样性和制造商，Android生态系统使得这一点尤其困难。'
- en: '**Performance tests**: Is the app fast or efficient enough? Sometimes, apps
    can suffer from bottlenecks and UI stutters that can be identified via performance
    benchmarks.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能测试**：应用是否足够快或高效？有时，应用可能会遭受瓶颈和UI卡顿，这些可以通过性能基准测试来识别。'
- en: '**Accessibility tests**: Is the app working well with accessibility services?
    Such services are used to assist users with disabilities in using our Android
    application.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可访问性测试**：应用是否与可访问性服务配合良好？这些服务用于帮助有障碍的用户使用我们的Android应用。'
- en: In this chapter, we will be mainly focusing on functional tests in an attempt
    to ensure the functional integrity of our application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将主要关注功能测试，以确保我们应用的功能完整性。
- en: 'Now, apart from deciding what has to be tested, we must also think about the
    *scope or size of the tests*. The scope indicates the size of the app''s portion
    we''re testing. From the perspective of the scope of the tests, we have the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，除了决定要测试什么之外，我们还必须考虑**测试的范围或大小**。范围表示我们正在测试的应用程序部分的大小。从测试范围的角度来看，我们有以下内容：
- en: '**Unit tests**: Often referred to as small tests, these test the functional
    behavior of methods, classes, or groups of classes in an isolated environment.
    Usually, unit tests target small portions of the app without interacting with
    the real-world environment; hence, they are more reliable than tests that depend
    on external input.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：通常被称为小型测试，这些测试在隔离环境中测试方法、类或类组的函数行为。通常，单元测试针对应用程序的小部分，不与真实世界环境交互；因此，它们比依赖于外部输入的测试更可靠。'
- en: '**Integration tests**: Often referred to as medium tests, these test whether
    multiple units interact and function correctly together.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：通常被称为中等测试，这些测试是否多个单元相互作用并正确地一起工作。'
- en: '**End-to-end tests**: Often referred to as big tests, these test large portions
    of the application, from multiple screens to entire user flows.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端到端测试**：通常被称为大型测试，这些测试覆盖了应用程序的大面积，从多个屏幕到整个用户流程。'
- en: Depending on the size of the tests, each type has a degree of isolation. The
    **degree of isolation** is tightly related to the scope of the tests, as it measures
    how dependent the component we're testing is on other components. As the size
    of the test increases, from small to big, the isolation level of the tests decreases.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 根据测试的大小，每种类型都有一定程度的隔离。**隔离程度**与测试范围紧密相关，因为它衡量了我们正在测试的组件对其他组件的依赖程度。随着测试大小的增加，从小到大，测试的隔离级别会降低。
- en: In this chapter, we will be mainly focusing on unit tests, as they are fast,
    with the simplest setup, and most reliable in helping us validate the functionality
    of our application. These traits are tightly related to the higher isolation level
    of unit tests from external components.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将主要关注单元测试，因为它们运行速度快，设置简单，并且最可靠地帮助我们验证应用程序的功能。这些特性与单元测试从外部组件的高隔离级别紧密相关。
- en: 'Lastly, we must also classify tests based on the system they will be running
    on:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还必须根据它们将要运行的系统对测试进行分类：
- en: '**Local tests**: Run on your workstation or development system (used in practices
    such as **Continuous Integration** (**CI**)) without the need of an Android device
    or emulator. They are usually small and fast, isolating the component under test
    from the rest of the application. Most of the time, unit tests are local tests.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地测试**：在您的工作站或开发系统上运行（用于**持续集成**（**CI**）等实践），无需使用Android设备或模拟器。它们通常很小且运行速度快，将测试的组件与其他应用程序部分隔离开来。大多数情况下，单元测试都是本地测试。'
- en: '**Instrumented tests**: Run on an Android device, be it a physical device or
    emulator. Most of the time, UI tests are considered instrumented tests, since
    they allow the automated testing of an application on an Android device.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仪器化测试**：在Android设备上运行，无论是物理设备还是模拟器。大多数情况下，UI测试被认为是仪器化测试，因为它们允许在Android设备上自动测试应用程序。'
- en: In this chapter, our unit tests will be local when we will be testing the core
    logic of some components in isolation and instrumented when we will be performing
    UI unit tests for a specific screen in isolation.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，当我们将测试某些组件的核心逻辑并隔离时，我们的单元测试将是本地的；当我们对特定屏幕进行UI单元测试并隔离时，它们将是仪器化的。
- en: Let's proceed with local UI tests first!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从本地UI测试开始！
- en: Learning the basics of testing your Compose UI
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习测试Compose UI的基础知识
- en: UI tests allow us to evaluate the behavior of our Compose code against what
    is expected to be correct. This way, we can catch bugs early in our UI development
    process.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: UI测试使我们能够评估我们的Compose代码的行为是否符合预期。这样，我们可以在UI开发过程的早期阶段捕捉到错误。
- en: 'To test our UI, we must first decide what we are aiming to evaluate. To keep
    it simple, in this section, we will unit-test our UI in an isolated environment.
    In other words, we want to test the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试我们的UI，我们首先必须决定我们想要评估什么。为了简化，在本节中，我们将在一个隔离环境中对UI进行单元测试。换句话说，我们想要测试以下内容：
- en: That our composable screens consume the received state as expected. We want
    to make sure that the UI correctly represents the different state values that
    it can receive.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的composable屏幕按预期消耗接收到的状态。我们想确保UI正确地表示它可以接收的不同状态值。
- en: For our composable screens, that user-generated events are correctly forwarded
    to the caller of the composable.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于我们的可组合屏幕，用户生成的事件被正确地转发到可组合的调用者。
- en: To keep our tests simple, we will define these tests as unit tests and try to
    isolate screen composables from their `ViewModel` or from other screen composables;
    otherwise, our test will become an integration or an end-to-end test.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持我们的测试简单，我们将定义这些测试为单元测试，并尝试将屏幕可组合组件与其`ViewModel`或其他屏幕可组合组件隔离；否则，我们的测试将变成集成测试或端到端测试。
- en: In other words, we will test separately each screen, with total disregard of
    anything outside of their composable function definition. Even though our tests
    will run on an Android device, they will be testing only one unit – a screen composable.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们将分别测试每个屏幕，完全不考虑其可组合功能定义之外的内容。即使我们的测试将在Android设备上运行，它们也只会测试一个单元——一个屏幕可组合组件。
- en: Note
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Some UI tests can also be considered unit tests, as long as they are testing
    only one part of the UI of your application, as we will do in this section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一些UI测试也可以被认为是单元测试，只要它们只测试您应用程序UI的一个部分，就像我们在这个部分将要做的那样。
- en: For starters, we need to test the first screen of our application, represented
    by the `RestaurantsScreen()` composable. Let's begin!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要测试我们应用程序的第一个屏幕，由`RestaurantsScreen()`可组合组件表示。让我们开始吧！
- en: 'First, add the following testing dependencies inside the `dependencies` block
    of the app-level `build.gradle` file:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在app级别的`build.gradle`文件的`dependencies`块中添加以下测试依赖项：
- en: '[PRE0]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These dependencies will allow us to run our Compose UI tests on an Android device.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些依赖项将允许我们在Android设备上运行我们的Compose UI测试。
- en: After updating the `build.gradle` file, make sure to sync your project with
    its Gradle files. You can do that by pressing on the **File** menu option and
    then by selecting **Sync Project with Gradle Files**.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新`build.gradle`文件后，请确保将您的项目与其Gradle文件同步。您可以通过点击**文件**菜单选项，然后选择**同步项目与Gradle文件**来完成此操作。
- en: 'Before creating a test class, locate the `androidTest` package that is suited
    for instrumented tests:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建测试类之前，找到适合仪器测试的`androidTest`包：
- en: '![Figure 10.1 – Observing the androidTest package for UI tests'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1 – 观察UI测试的androidTest包]'
- en: '](img/B17788_10_01.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17788_10_01.jpg]'
- en: Figure 10.1 – Observing the androidTest package for UI tests
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1 – 观察UI测试的androidTest包]'
- en: In Android projects, this directory stores source files for UI tests. Also note
    that the pre-built `ExampleInstrumentedTest` class resides in this directory.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android项目中，此目录存储UI测试的源文件。此外，请注意预构建的`ExampleInstrumentedTest`类位于此目录中。
- en: Create an empty Kotlin class named `RestaurantsScreenTest` inside the `androidTest`
    package.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`androidTest`包内创建一个名为`RestaurantsScreenTest`的空Kotlin类。
- en: Inside this class, we will define a method for each independent test. Behind
    the scenes, every method will become a standalone UI test that can pass or fail.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们将为每个独立的测试定义一个方法。幕后，每个方法都将成为一个独立的UI测试，它可以成功或失败。
- en: 'Before creating our first test method, inside the `RestaurantsScreenTest` class,
    add the following code:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建我们的第一个测试方法之前，在`RestaurantsScreenTest`类内部添加以下代码：
- en: '[PRE1]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To run our Compose UI tests, we are using the JUnit testing framework that will
    allow us to write repeatable unit tests in an isolated environment with the help
    of a test rule. **Test rules** allow us to add functionality to all the tests
    within a test class.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行我们的Compose UI测试，我们使用JUnit测试框架，它将允许我们在隔离环境中使用测试规则编写可重复的单元测试。**测试规则**允许我们在测试类中的所有测试中添加功能。
- en: In our case, we need to test Compose UI in every test method, so we had to use
    a special `ComposeContentTestRule` object. To access this rule, we have previously
    imported a special JUnit rule dependency so that our test class now defines a
    `testRule` variable and instantiates it by using the `createComposeRule()` method.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们需要在每个测试方法中测试Compose UI，因此我们必须使用一个特殊的`ComposeContentTestRule`对象。为了访问此规则，我们之前已经导入了一个特殊的JUnit规则依赖项，因此我们的测试类现在定义了一个`testRule`变量，并通过使用`createComposeRule()`方法对其进行实例化。
- en: '`ComposeContentTestRule` will not only allow us to set the Compose UI under
    test but also host tests on an Android device, while also giving us the ability
    to interact with the composables under test or perform UI assertions.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`ComposeContentTestRule`不仅允许我们设置要测试的Compose UI，还可以在Android设备上运行测试，同时让我们能够与测试中的可组合组件交互或执行UI断言。'
- en: Before writing our first test method though, we need to clearly understand what
    behavior we are trying to test.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写我们的第一个测试方法之前，我们需要清楚地了解我们试图测试的行为。
- en: 'Let''s have a look at how our `RestaurantsScreen()` composable consumes a `RestaurantsScreenState`
    instance from its `state` parameter, and how it forwards events to its caller
    through the `onItemClick` and `onFavoriteClick` function parameters:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的`RestaurantsScreen()`可组合组件是如何从其`state`参数中消费`RestaurantsScreenState`实例的，以及它是如何通过`onItemClick`和`onFavoriteClick`函数参数将事件传递给调用者的：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By looking at the previous snippet, we see that we can test how the `onItemClick`
    and `onFavoriteClick` functions are called, based on different UI interactions,
    and also that we can test whether the state is consumed correctly or not. Yet
    we can't infer very well the possible values of the state that our composable
    is receiving.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看前面的代码片段，我们可以看到我们可以测试`onItemClick`和`onFavoriteClick`函数是如何根据不同的UI交互被调用的，以及我们可以测试状态是否被正确消费。然而，我们无法很好地推断出我们的可组合组件接收到的状态的可能值。
- en: 'To get an overview of the possible states that we want to feed into our `RestaurantsScreen()`
    so that we can test its behavior, we need to have a look at its state producer,
    `RestaurantsViewModel`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解我们想要输入到`RestaurantsScreen()`中以测试其行为的可能状态，我们需要查看其状态生成器，`RestaurantsViewModel`：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can say that our screen should have three possible states:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说，我们的屏幕应该有三个可能的状态：
- en: '`ViewModel` class in the initialization of the `_state` variable, where the
    `restaurants` parameter of `RestaurantsScreenState` is set to `emptyList()` and
    the `isLoading` parameter is set to `true`.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`ViewModel`类的初始化中，`_state`变量，其中`RestaurantsScreenState`的`restaurants`参数设置为`emptyList()`，而`isLoading`参数设置为`true`。
- en: '`getRestaurants()` method where we mutated the initial state and set the `isLoading`
    parameter to `false`, while also passing the list of restaurants to the `restaurants`
    parameter.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`getRestaurants()`方法中，我们修改了初始状态，将`isLoading`参数设置为`false`，同时将餐厅列表传递给`restaurants`参数。
- en: '`CoroutineExceptionHandler` where the `isLoading` parameter is set to `false`
    to reset the loading status, while also passing the message of `Exception` to
    the `error` parameter.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`CoroutineExceptionHandler`中，将`isLoading`参数设置为`false`以重置加载状态，同时将`Exception`的消息传递给`error`参数。
- en: Now that we know what behavior the `RestaurantsScreen` composable should exhibit
    and what input we should pass to it in order to produce such a behavior, it's
    time to actually put our composable screen under test.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道`RestaurantsScreen`可组合组件应该表现出什么行为以及我们应该传递什么输入来产生这种行为，那么现在是时候实际上对我们的可组合屏幕进行测试了。
- en: Let's begin by verifying whether the `RestaurantsScreen` composable correctly
    renders the first state – that is, the initial loading state.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先验证`RestaurantsScreen`可组合组件是否正确渲染了第一个状态——即初始加载状态。
- en: 'Inside the `RestaurantsScreenTest` class, add an empty test function named
    `initialState_isRendered()` that will later test whether our `RestaurantsScreen()`
    composable properly renders the initial state:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RestaurantsScreenTest`类内部，添加一个名为`initialState_isRendered()`的空测试函数，稍后它将测试我们的`RestaurantsScreen()`可组合组件是否正确渲染初始状态：
- en: '[PRE4]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To tell the JUnit testing library to run an individual test for this method,
    we've annotated it with the `@Test` annotation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让JUnit测试库运行此方法的单个测试，我们已使用`@Test`注解对其进行注解。
- en: Also, note that we named this method around the specific behavior it's trying
    to test, going from what we're testing (the initial state) to how it's supposed
    to behave (to be rendered correctly), while separating these two with an underscore.
    For unit tests, there are a lot of naming conventions, yet we will try to stick
    to the simple version mentioned before.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我们围绕该方法试图测试的具体行为来命名这个方法，从我们要测试的内容（初始状态）到它应该如何表现（正确渲染），同时用下划线将这两个状态分开。对于单元测试，有许多命名约定，但我们将尝试坚持之前提到的简单版本。
- en: Note
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Each test method annotated with `@Test` should focus on only one specific behavior,
    just as `initialState_isRendered()` will test whether the `RestaurantsScreen()`
    properly renders the initial state, and no other pieces. This allows us to focus
    on only one behavior on each test method so that we can better identify later
    which specific behavior is no longer working as expected.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 每个带有`@Test`注解的测试方法都应该只关注一个特定的行为，就像`initialState_isRendered()`将测试`RestaurantsScreen()`是否正确渲染初始状态，而不涉及其他部分。这使我们能够专注于每个测试方法上的单一行为，以便我们可以在以后更好地识别哪些具体行为不再按预期工作。
- en: 'Prepare the `initialState_isRendered()` method to set the Compose UI by calling
    `testRule.setContent()`, just as our `MainActivity` did with its own `setContent()`
    method:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备`initialState_isRendered()`方法，通过调用`testRule.setContent()`来设置Compose UI，就像我们的`MainActivity`使用自己的`setContent()`方法一样：
- en: '[PRE5]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Inside the block of code exposed by the `setContent()` method, we must pass
    the **unit under test**, which is nothing else than the composable we're trying
    to test.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setContent()`方法暴露的代码块内部，我们必须传递**被测单元**，这实际上就是我们试图测试的可组合组件。
- en: 'In our case, we will pass the `RestaurantsScreen()` composable, not before
    wrapping it inside the `RestaurantsAppTheme()` theme function so that the Compose
    UI that is under test mimics what our app is actually displaying in the production
    code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们将传递`RestaurantsScreen()`可组合组件，而不是在将其包裹在`RestaurantsAppTheme()`主题函数之前，这样被测试的Compose
    UI将模仿我们的实际生产代码中显示的内容：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you have named your app name differently, then the theme composable might
    have a different definition.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你给你的应用命名不同，那么主题可组合组件可能有不同的定义。
- en: 'Now, the `RestaurantsScreen()` composable is expecting a `RestaurantsScreenState`
    object into its `state` parameter and two functions for its `onFavoriteClick()`
    and `onItemClick()` parameters. Let''s add these while also passing the expected
    initial state from the screen''s `ViewModel`:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`RestaurantsScreen()`可组合组件正在期待一个`RestaurantsScreenState`对象作为其`state`参数，以及两个函数用于其`onFavoriteClick()`和`onItemClick()`参数。让我们添加这些，同时传递屏幕`ViewModel`中预期的初始状态：
- en: '[PRE7]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Since we're looking to test whether `RestaurantsScreen()` is correctly rendering
    the initial state, we have passed an instance of `RestaurantsScreenState` that
    had the `restaurants` parameter set to `emptyList()`, and the `isLoading` parameter
    is set to `true` while the `error` parameter is by default set to `null`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在测试`RestaurantsScreen()`是否正确渲染初始状态，我们传递了一个`RestaurantsScreenState`实例，其中`restaurants`参数设置为`emptyList()`，而`isLoading`参数设置为`true`，而`error`参数默认设置为`null`。
- en: We have now finished setting up the `RestaurantsScreen()` composable and fed
    it with the expected initial state. It's time to perform the assertion of whether
    our composable is correctly consuming this initial state or not.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了`RestaurantsScreen()`可组合组件的设置，并提供了预期的初始状态。现在是时候执行断言，以确定我们的可组合组件是否正确消费了这个初始状态。
- en: 'In the `RestaurantsScreen()` composable, the initial state is a state mainly
    defined by the loading indicator that expresses how the app is waiting for content:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RestaurantsScreen()`可组合组件中，初始状态主要由表示应用等待内容的加载指示器定义：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That's why we can check whether the `CircularProgressIndicator()` is visible
    on the screen. But how can we assert whether this composable is visible or not?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，我们才能检查屏幕上是否可见`CircularProgressIndicator()`。但我们是怎样断言这个可组合组件是否可见的呢？
- en: Compose provides us with several testing APIs to help us find elements, verify
    their attributes, and even perform user actions. For UI tests with Compose, we
    consider pieces of UI as **nodes** that we can identify with the help of semantics.
    **Semantics** give meaning to a UI element, and for an entire composable hierarchy,
    a semantics tree is generated to describe it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Compose为我们提供了几个测试API，帮助我们查找元素、验证它们的属性，甚至执行用户操作。对于使用Compose的UI测试，我们将UI的各个部分视为**节点**，我们可以借助语义来识别。**语义**为UI元素赋予意义，而对于整个可组合组件层次结构，会生成一个语义树来描述它。
- en: In other words, we should be able to identify anything that is described on
    the screen with the help of its exposed semantics.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们应该能够借助其暴露的语义来识别屏幕上描述的任何内容。
- en: To give an example, a `Text` composable that displays a `String` object such
    as `"Hello"` will become a node in the semantics tree that we can identify by
    its `text` property value – `"Hello"`. Similarly, composables such as `Image`
    expose a mandatory `contentDescription` parameter whose value will allow us to
    identify the corresponding node in the semantics tree inside our tests. Don't
    worry – we'll see a practical example of this in a second.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个`Text`可组合组件为例，它显示一个`String`对象，例如`"Hello"`，它将成为语义树中的一个节点，我们可以通过其`text`属性值——“Hello”来识别。同样，`Image`等可组合组件暴露了一个强制性的`contentDescription`参数，其值将允许我们在测试中识别语义树中的相应节点。不用担心——我们将在下一秒看到一个实际例子。
- en: Note
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While the semantics attributes are mainly used for accessibility purposes (`contentDescription`,
    for example, is a parameter that allows people with disabilities to better understand
    what the visual element it describes is about), it's also a great tool that exposes
    semantics used to identify nodes in our tests.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然语义属性主要用于辅助功能目的（例如，`contentDescription`是一个参数，它允许残疾人更好地理解它所描述的视觉元素），但它也是一个很好的工具，它暴露了用于在测试中识别节点所使用的语义。
- en: Now that we have briefly covered how we can use semantics information to identify
    UI elements as nodes, it's time to get back to our test, which should validate
    if, upon an initial state consumed by `RestaurantsScreen()`, its `CircularProgressIndicator()`
    is visible.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们简要介绍了如何使用语义信息来识别UI元素作为节点，现在是时候回到我们的测试了，该测试应该验证在由`RestaurantsScreen()`消耗的初始状态下，其`CircularProgressIndicator()`是否可见。
- en: 'However, if we look again at the usage of `CircularProgressIndicator()`, we
    can see that it exposes no semantics that we can use to identify it later in our
    test:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们再次审视`CircularProgressIndicator()`的使用，我们可以看到它没有暴露任何语义，我们可以在之后的测试中用来识别它：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There is no `contentDescription` parameter and no visual text displayed. To
    be able to identify the node of `CircularProgressIndicator()` we must manually
    add a semantics `contentDescription` property.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 没有提供`contentDescription`参数，也没有显示任何视觉文本。为了能够识别`CircularProgressIndicator()`的节点，我们必须手动添加一个语义`contentDescription`属性。
- en: 'For a moment, let''s head out of the `androidTest` directory and go back inside
    the main package where our production code resides. Inside the `presentation`
    package, create a new `object` class named `Description` and define a constant
    description `String` variable for our loading composable:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们暂时离开`androidTest`目录，回到我们的生产代码所在的主包内部。在`presentation`包内部，创建一个名为`Description`的新`object`类，并定义一个常量描述`String`变量用于我们的加载组合：
- en: '[PRE10]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Inside the `RestaurantsScreen()` composable, pass a `semantics` modifier to
    the `CircularProgressIndicator()` composable and set its `contentDescription`
    property to the previously defined `RESTAURANTS_LOADING`:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RestaurantsScreen()`组合内部，将`semantics`修饰符传递给`CircularProgressIndicator()`组合，并将其`contentDescription`属性设置为之前定义的`RESTAURANTS_LOADING`：
- en: '[PRE11]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, we will be able to identify the node represented by the `CircularProgressIndicator()`
    composable inside our UI tests by using the `contentDescription` semantics property.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将能够通过使用`contentDescription`语义属性来识别UI测试中由`CircularProgressIndicator()`组合表示的节点。
- en: 'Now, go back inside the `androidTest` directory and navigate to the `RestaurantsScreenTest`
    class, and in the `initialState_isRendered()` test method, use the `testRule`
    variable to identify the node with the `RESTAURANT_LOADING` content description
    with the help of the `onNodeWithContentDescription()` method, and finally, verify
    that the node is displayed with the `assertIsDisplayed()` method:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，回到`androidTest`目录内部，导航到`RestaurantsScreenTest`类，并在`initialState_isRendered()`测试方法中，使用`testRule`变量通过`onNodeWithContentDescription()`方法识别具有`RESTAURANT_LOADING`内容描述的节点，并最终使用`assertIsDisplayed()`方法验证节点是否显示：
- en: '[PRE12]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Inside the `RestaurantsScreenTest` class and select **Run RestaurantsScreenTest**.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RestaurantsScreenTest`类内部选择**运行RestaurantsScreenTest**。
- en: This command will run all the tests inside this class (only one in our case)
    on an Android device (either your physical Android device or your emulator).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在该类内部运行所有测试（在我们的例子中只有一个）在Android设备上（无论是你的物理Android设备还是你的模拟器）。
- en: 'If we switch to the `RestaurantsScreen()` was rendered correctly has passed:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们切换到`RestaurantsScreen()`是否正确渲染并通过了测试：
- en: '![Figure 10.2 – Observing the UI tests that have passed'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.2 – 观察已通过的UI测试'
- en: '](img/B17788_10_02.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_10_02.jpg)'
- en: Figure 10.2 – Observing the UI tests that have passed
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 观察已通过的UI测试
- en: Note
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Although we have defined a test where UI elements are identified via semantic
    properties, it's also possible to match a piece of UI by making it incorporate
    a `testTag` modifier that is later identified via the `hasTestTag()` matcher.
    However, you should avoid this practice, as you will be polluting your Compose
    UI production code with testing identifiers used only for tests.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经定义了一个通过语义属性识别UI元素的测试，但也可以通过使UI元素包含一个`testTag`修饰符来匹配一个UI元素，该修饰符稍后可以通过`hasTestTag()`匹配器识别。然而，你应该避免这种做法，因为这将使你的Compose
    UI生产代码被仅用于测试的测试标识符所污染。
- en: While your test ran on an Android device or emulator, you might have noticed
    that no UI was shown on its screen. This happens because the UI tests are really
    fast. If you want to see the UI that you're testing, you can add a `Thread.sleep()`
    call at the end of the test method; however, you should avoid such a practice
    in your production test code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的测试在 Android 设备或模拟器上运行时，你可能会注意到其屏幕上没有显示任何 UI。这是因为 UI 测试非常快。如果你想看到你正在测试的 UI，你可以在测试方法末尾添加一个
    `Thread.sleep()` 调用；然而，你应该避免在生产测试代码中这样做。
- en: Now, it's time to test whether the `RestaurantsScreen()` composable is rendering
    another state correctly – the state with content. In this state, the restaurants
    have arrived, so we reset the loading status to `false` and render the restaurants.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候测试 `RestaurantsScreen()` 组件是否正确渲染另一个状态了——带有内容的州。在这个状态下，餐厅已经到达，因此我们将加载状态重置为
    `false` 并渲染餐厅。
- en: 'Inside the `RestaurantsScreenTest` class, add another test function named `stateWithContent_isRendered()`,
    which should test whether the state with content is rendered correctly:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RestaurantsScreenTest` 类内部，添加另一个名为 `stateWithContent_isRendered()` 的测试函数，该函数应测试带有内容的州是否正确渲染：
- en: '[PRE13]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Inside this test method, we have set the `RestaurantsScreen()` composable with
    a state whose `isLoading` field is `false` (as the restaurants have arrived) but
    haven't passed a list of restaurants yet. We need to create a dummy list of restaurants
    to mimic some restaurants from our data layer.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试方法内部，我们已经将 `RestaurantsScreen()` 组件的状态设置为 `isLoading` 字段为 `false`（因为餐厅已经到达），但还没有传递餐厅列表。我们需要创建一个模拟餐厅列表来模拟数据层的一些餐厅。
- en: 'For a moment, let''s head out of the `androidTest` directory and go back inside
    the main package where our production code resides. Inside the `restaurants` package,
    create a new `object` class named `DummyContent`, and inside this class, add a
    `getDomainRestaurants()` method that will return a dummy array list of `Restaurant`
    objects:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们暂时离开 `androidTest` 目录，回到我们的生产代码所在的主包内部。在 `restaurants` 包内部，创建一个名为 `DummyContent`
    的新 `object` 类，并在该类内部添加一个 `getDomainRestaurants()` 方法，该方法将返回一个包含 `Restaurant` 对象的模拟数组列表：
- en: '[PRE14]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, go back inside the `androidTest` directory and navigate to the `RestaurantsScreenTest`
    class. Inside the `stateWithContent_isRendered()` method, declare a `restaurants`
    variable that will hold the dummy restaurants from the `DummyContent` class and
    pass it to the `restaurants` parameter of `RestaurantsScreenState`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，回到 `androidTest` 目录，导航到 `RestaurantsScreenTest` 类。在 `stateWithContent_isRendered()`
    方法内部，声明一个 `restaurants` 变量，该变量将保存来自 `DummyContent` 类的模拟餐厅，并将其传递给 `RestaurantsScreenState`
    的 `restaurants` 参数：
- en: '[PRE15]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now that we have finished the setup part of this test method, it''s time to
    perform our assertions. Since we are testing that `RestaurantsScreen()` is correctly
    rendering the state that contains restaurants, let''s have another quick look
    at the composable under test:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了这个测试方法的设置部分，是时候执行我们的断言了。由于我们正在测试 `RestaurantsScreen()` 是否正确渲染包含餐厅的状态，让我们快速查看一下正在测试的组件：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can deduct that the two conditions we can assert are as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以推断出我们可以断言的两个条件如下：
- en: The restaurants from `RestaurantsScreenState` are displayed on the screen.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 `RestaurantsScreenState` 的餐厅显示在屏幕上。
- en: The `CircularProgressIndicator()` composable is not rendered, so its node is
    not visible on the screen.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CircularProgressIndicator()` 组件没有被渲染，因此其节点在屏幕上不可见。'
- en: Let's start off with the first assertion. Instead of relying on the `contentDescription`
    semantic property, we can use another semantic property that is more obvious –
    the text displayed on the screen. Since `LazyColumn` will render a list of `RestaurantItem()`
    composables, each one will call a `Text` composable that will render the title
    and the description of the restaurant passed to its `text` parameter. With the
    help of our `ComposeContentTestRule`, we can identify a node with a certain text
    value by calling the `onNodeWithText()` method.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个断言开始。我们不必依赖于 `contentDescription` 语义属性，而可以使用另一个更明显的语义属性——屏幕上显示的文本。由于
    `LazyColumn` 将渲染一个 `RestaurantItem()` 组件的列表，每个组件都会调用一个 `Text` 组件，该组件将渲染传递给其 `text`
    参数的餐厅标题和描述。借助我们的 `ComposeContentTestRule`，我们可以通过调用 `onNodeWithText()` 方法来识别具有特定文本值的节点。
- en: Back in the `stateWithContent_isRendered()` method, let's assert that `title`
    of the first `Restaurant` object from our dummy list is visible.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到 `stateWithContent_isRendered()` 方法，让我们断言从我们的模拟列表中第一个 `Restaurant` 对象的 `title`
    是可见的。
- en: 'Do that by passing the title of the first element from the `restaurants` variable
    to the `onNodeWithText()` method, thereby identifying its corresponding node.
    Finally, call the `assertIsDisplayed()` method to verify whether this node is
    displayed:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`restaurants`变量中第一个元素的标题传递给`onNodeWithText()`方法，从而识别其对应的节点。最后，调用`assertIsDisplayed()`方法来验证此节点是否显示：
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Similarly, to assert whether the node of the title of the first restaurant
    from our dummy list is displayed, verify whether the node of the description of
    the first restaurant is displayed:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，为了断言我们模拟列表中第一家餐厅的标题节点是否显示，验证第一家餐厅的描述节点是否显示：
- en: '[PRE18]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You might be wondering why we aren't asserting whether `title` or `description`
    of all the elements from the `DummyContent` class is visible. It's important to
    understand that our test is asserting whether some nodes are displayed on the
    screen.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们不断言`DummyContent`类中所有元素的`title`或`description`是否可见。重要的是要理解，我们的测试是断言屏幕上是否显示了某些节点。
- en: That's why, if our `restaurants` list contained 10 or 15 elements and we tested
    whether all titles and description nodes are visible, we could have had this test
    method pass on tall devices, since all the restaurants would fit and would be
    *composed* on the screen, but it could have failed if the test device was small
    and only some of the restaurants fitted on the screen and were composed.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们的`restaurants`列表包含10或15个元素，并且我们测试所有标题和描述节点是否可见，那么在设备较高的设备上，这个测试方法可能会通过，因为所有餐厅都会适应屏幕并显示，但如果测试设备较小，只有一些餐厅适应屏幕并显示，那么测试可能会失败。
- en: This would have made our test flaky. To prevent our test from being flaky, we
    only asserted whether the first restaurant is visible, therefore minimizing the
    chance of having the test run and fail on an incredibly small screen.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这会使我们的测试变得不可靠。为了防止测试变得不可靠，我们只断言第一家餐厅是否可见，因此最小化了测试在极小屏幕上运行失败的可能性。
- en: Another interesting tactic that you can employ in order to test that content
    is correctly rendered would be to emulate a scroll action inside your test to
    the bottom of the list and check whether the last element is visible. This, however,
    is more complex, so we will proceed with the simpler version that we have implemented.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试内容是否正确渲染，你可以采取的一个有趣的策略是在测试中模拟滚动动作到底部，并检查最后一个元素是否可见。然而，这更复杂，所以我们将继续使用我们已实现的简单版本。
- en: 'Lastly, let''s assert that the node corresponding to the `CircularProgressIndicator()`
    composable does not exist, therefore ensuring that the app is not loading anything
    anymore. Do that by calling the `assertDoesNotExist()` method on the node with
    the `RESTAURANTS_LOADING` content description:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们断言对应于`CircularProgressIndicator()`可组合组件的节点不存在，从而确保应用不再加载任何内容。通过在具有`RESTAURANTS_LOADING`内容描述的节点上调用`assertDoesNotExist()`方法来完成此操作：
- en: '[PRE19]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now that we have finished writing our second test method asserting whether the
    `RestaurantsScreen()` composable is correctly rendering the state with content,
    inside the `RestaurantsScreenTest` class and select **Run RestaurantsScreenTest**.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经完成了编写第二个测试方法，断言`RestaurantsScreen()`可组合组件是否正确渲染了带有内容的界面状态，在`RestaurantsScreenTest`类中并选择**运行
    RestaurantsScreenTest**。
- en: The tests should run and pass.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应该运行并通过。
- en: Assignment
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 作业
- en: Try writing a test method on your own that asserts whether the `RestaurantsScreen()`
    composable renders the error state correctly. As a hint, you should be passing
    an error text to the `error` parameter of the `RestaurantsScreen()`, and then
    you should be asserting whether a node with that particular text is visible, while
    also verifying that the node corresponding to the `CircularProgressIndicator()`
    composable does not exist.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试自己编写一个测试方法，断言`RestaurantsScreen()`可组合组件是否正确渲染了错误状态。作为一个提示，你应该将错误文本传递给`RestaurantsScreen()`的`error`参数，然后你应该断言具有该特定文本的节点是否可见，同时验证对应于`CircularProgressIndicator()`可组合组件的节点不存在。
- en: 'Finally, let''s write a test method where we can verify whether upon clicking
    on a restaurant element from our dummy list, the correct callback is exposed by
    the parent `RestaurantsScreen()` composable:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们编写一个测试方法，其中我们可以验证点击我们模拟列表中的餐厅元素时，父`RestaurantsScreen()`可组合组件是否暴露了正确的回调：
- en: 'Inside the `RestaurantsScreenTest` class, add another test function named `stateWithContent_ClickOnItem_isRegistered()`.
    Inside this method, store the dummy list inside a `restaurants` variable, and
    then store the first restaurant that we will click upon inside the `targetRestaurant`
    variable:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RestaurantsScreenTest` 类中，添加另一个名为 `stateWithContent_ClickOnItem_isRegistered()`
    的测试函数。在这个方法中，将模拟列表存储在 `restaurants` 变量中，然后将我们将要点击的第一个餐厅存储在 `targetRestaurant`
    变量中：
- en: '[PRE20]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, set `RestaurantsScreen()` under test and feed it with a state with content
    by passing the contents of the `restaurants` variable to the `restaurants` parameter
    of `RestaurantsScreenState`:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将 `RestaurantsScreen()` 设置为测试对象，并通过将 `restaurants` 变量的内容传递给 `RestaurantsScreenState`
    的 `restaurants` 参数来提供具有内容的状态：
- en: '[PRE21]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, identify the node that contains the `title` text of `targetRestaurant`
    and then simulate a user click on this node by calling the `performClick()` method:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，识别包含 `targetRestaurant` 的 `title` 文本的节点，然后通过调用 `performClick()` 方法模拟用户点击此节点：
- en: '[PRE22]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now that we have simulated a user-click interaction, let''s assert that the
    `id` value from the `onItemClick` callback exposed by the `RestaurantsScreen()`
    composable matches with the `id` value of the restaurant we have clicked on:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经模拟了用户点击交互，让我们断言由 `RestaurantsScreen()` 组合函数暴露的 `onItemClick` 回调中的 `id`
    值与我们所点击的餐厅的 `id` 值相匹配：
- en: '[PRE23]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Inside the `RestaurantsScreenTest` class and select **Run RestaurantsScreenTest**.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RestaurantsScreenTest` 类中，选择**运行 RestaurantsScreenTest**。
- en: The three tests should run and pass.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个测试应该运行并通过。
- en: Note
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You might have noticed that we haven't given any attention to testing how the
    UI updates when a user toggles a restaurant as a favorite or not a favorite. The
    only way we could have done that is by adding a dedicated semantic property to
    the heart icon of each restaurant from the list and then testing the value of
    that property. However, we would have tested a semantic property value and not
    the UI – for such cases, it's better to look into **screenshot testing** strategies.
    Screenshot testing is a UI testing practice that generates screenshots of your
    app, which are then compared to the initially defined *correct* versions.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们没有关注测试当用户切换餐厅为收藏或非收藏时 UI 如何更新。我们能够做到这一点的方法是为列表中每个餐厅的心形图标添加一个专门的语义属性，然后测试该属性的值。然而，我们会测试一个语义属性值而不是
    UI – 对于此类情况，最好考虑**截图测试**策略。截图测试是一种 UI 测试实践，它生成应用程序的截图，然后将其与最初定义的*正确*版本进行比较。
- en: Now that we briefly covered UI testing with Compose, it's time to unit-test
    our app's behind-the-scenes functionality!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们简要介绍了使用 Compose 的 UI 测试，是时候对应用程序的后台功能进行单元测试了！
- en: Covering the basics of unit-testing your core logic
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖单元测试核心逻辑的基础
- en: Apart from testing our UI layer, we must also test the core logic of our application.
    This means that we should try to verify as much behavior as possible in terms
    of presentation logic (testing `ViewModel` classes), business logic (testing `UseCase`
    classes), or even data logic (testing `Repository` classes).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除了测试我们的 UI 层之外，我们还必须测试应用程序的核心逻辑。这意味着我们应该尽可能多地验证表示逻辑（测试 `ViewModel` 类）、业务逻辑（测试
    `UseCase` 类）或甚至数据逻辑（测试 `Repository` 类）的行为。
- en: The easiest way of validating such logic is by writing unit tests for each class
    or group of classes whose behavior we're trying to verify.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 验证此类逻辑最简单的方法是为我们试图验证的每个类或类组编写单元测试。
- en: In this section, we will be writing unit tests for the `RestaurantsViewModel`
    class and the `ToggleRestaurantUseCase` class. Since these components don't interact
    directly with the UI, their unit tests will run directly on your local workstation's
    **Java Virtual Machine** (**JVM**), rather than running on an Android device,
    as our UI tests did.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写 `RestaurantsViewModel` 类和 `ToggleRestaurantUseCase` 类的单元测试。由于这些组件不直接与
    UI 交互，它们的单元测试将直接在本地工作站的 **Java 虚拟机**（**JVM**）上运行，而不是像我们的 UI 测试那样在 Android 设备上运行。
- en: 'To summarize, in this section, we will be doing the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本节中，我们将执行以下操作：
- en: Testing the functionality of a `ViewModel` class
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 `ViewModel` 类的功能
- en: Testing the functionality of a `UseCase` class
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 `UseCase` 类的功能
- en: Let's begin by testing the `RestaurantsViewModel` class!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从测试 `RestaurantsViewModel` 类开始！
- en: Testing the functionality of a ViewModel class
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 `ViewModel` 类的功能
- en: We want to test the functionality of our `RestaurantsViewModel` so that we can
    make sure that it's correctly performing the role of state producer for the `RestaurantsScreen()`
    composable.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要测试 `RestaurantsViewModel` 的功能，以确保它正确地执行了 `RestaurantsScreen()` 组合组件的状态生产者角色。
- en: 'To achieve that, we will write unit tests for this `ViewModel` class in isolation.
    Let''s begin:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将为这个 `ViewModel` 类单独编写单元测试。让我们开始：
- en: 'First, locate the `test` package that is suited for regular unit tests:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，找到适合常规单元测试的 `test` 包：
- en: '![Figure 10.3 – Observing the test package used for regular unit tests'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.3 – 观察用于常规单元测试的测试包'
- en: '](img/B17788_10_03.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B17788_10_03.jpg)'
- en: Figure 10.3 – Observing the test package used for regular unit tests
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 观察用于常规单元测试的测试包
- en: Also, note that the pre-built `ExampleUnitTest` class resides inside this package.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，预构建的 `ExampleUnitTest` 类位于这个包内。
- en: Create an empty Kotlin class named `RestaurantsViewModelTest` inside the `test`
    package. Inside this class, we will define a method for each independent test.
    Behind the scenes, every method will become a standalone unit test that can pass
    or fail.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `test` 包内创建一个名为 `RestaurantsViewModelTest` 的空 Kotlin 类。在这个类中，我们将为每个独立的测试定义一个方法。幕后，每个方法都将成为一个独立的单元测试，它可以通过或失败。
- en: 'Before starting to write our first test method, let''s have another look at
    our `RestaurantsViewModel` class so that we can remind ourselves which cases we''re
    looking to test:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写我们的第一个测试方法之前，让我们再次查看 `RestaurantsViewModel` 类，以便我们可以提醒自己我们要测试哪些情况：
- en: '[PRE24]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can say that our `RestaurantsViewModel` should produce the exact three states
    that we fed to the `RestaurantsScreen()` composable in its own UI tests:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说，我们的 `RestaurantsViewModel` 应该产生我们提供给 `RestaurantsScreen()` 组合组件的精确的三种状态，这些状态在其自己的
    UI 测试中：
- en: '`ViewModel` class in the initialization of the `_state` variable, where the
    `restaurants` parameter of `RestaurantsScreenState` is set to `emptyList()` and
    the `isLoading` parameter is set to `true`.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `ViewModel` 类的初始化中 `_state` 变量，其中 `RestaurantsScreenState` 的 `restaurants`
    参数设置为 `emptyList()`，而 `isLoading` 参数设置为 `true`。
- en: '`getRestaurants()` method, where we mutated the initial state and set the `isLoading`
    parameter to `false` while also passing the list of restaurants to the `restaurants`
    parameter.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getRestaurants()` 方法，其中我们修改了初始状态，并将 `isLoading` 参数设置为 `false`，同时将餐厅列表传递给 `restaurants`
    参数。'
- en: '`CoroutineExceptionHandler`, where the `isLoading` parameter is set to `false`
    to reset the loading status while also passing the message of `Exception` to the
    `error` parameter.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CoroutineExceptionHandler`，其中 `isLoading` 参数设置为 `false` 以重置加载状态，同时将 `Exception`
    的消息传递给 `error` 参数。'
- en: In the end, what we basically have to do is assert that the value of the `state`
    variable (of type `RestaurantsScreenState`), which is exposed to the UI, evolves
    correctly over time, from the initial state to all possible states.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们基本上必须断言暴露给 UI 的 `state` 变量（类型为 `RestaurantsScreenState`）的值随时间正确演变，从初始状态到所有可能的状态。
- en: 'Let''s begin with a test method that asserts whether the initial state is produced
    as expected:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从断言初始状态是否按预期产生的测试方法开始：
- en: 'Inside the `RestaurantsViewModelTest` class, add an empty test function named
    `initialState_isProduced()` that will later test whether our `RestaurantsViewModel`
    class properly produces the initial state:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RestaurantsViewModelTest` 类中，添加一个名为 `initialState_isProduced()` 的空测试函数，稍后它将测试我们的
    `RestaurantsViewModel` 类是否正确地产生了初始状态：
- en: '[PRE25]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As with the UI tests, we will make use of the JUnit testing library to define
    and run individual unit tests for each method annotated with the `@Test` annotation.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 UI 测试一样，我们将使用 JUnit 测试库来定义和运行每个带有 `@Test` 注解的方法的单独单元测试。
- en: Again similar to the UI tests, we named this method around the specific behavior
    it's trying to test, going from what we're testing (the initial state) to what
    should happen (the state being correctly produced).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 同样类似于 UI 测试，我们根据这个方法试图测试的具体行为给它命名，从我们要测试的内容（初始状态）到应该发生的事情（正确产生状态）。
- en: 'Inside the `initialState_isProduced()` method, we must create an instance of
    the subject under test – that is, `RestaurantsViewModel`. Define a `viewModel`
    variable and instantiate it with the value returned by the `getViewModel()` method,
    which we will define in a second:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `initialState_isProduced()` 方法内部，我们必须创建被测试主题的实例 – 那就是说，`RestaurantsViewModel`。定义一个
    `viewModel` 变量，并用 `getViewModel()` 方法返回的值来实例化它，我们将在稍后定义这个方法：
- en: '[PRE26]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Still inside the `RestaurantsViewModelTest` class, define the `getViewModel()`
    method, which will return an instance of `RestaurantsViewModel`:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在`RestaurantsViewModelTest`类内部，定义`getViewModel()`方法，它将返回一个`RestaurantsViewModel`实例：
- en: '[PRE27]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The problem now is that the `RestaurantsViewModel` constructor needs an instance
    of `GetInitialRestaurantsUseCase` and `ToggleRestaurantsUseCase`. In turn, these
    two classes also have other dependencies that we must instantiate. Let''s have
    a clearer look at what classes we need to instantiate:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是`RestaurantsViewModel`构造函数需要一个`GetInitialRestaurantsUseCase`和`ToggleRestaurantsUseCase`的实例。反过来，这两个类也有其他依赖项，我们必须实例化。让我们更清楚地看看我们需要实例化哪些类：
- en: '![Figure 10.4 – Observing the direct and transitive dependencies of RestaurantsViewModel'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.4 – 观察RestaurantsViewModel的直接和传递依赖关系](img/B17788_10_04.jpg)'
- en: '](img/B17788_10_04.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.4 – 观察RestaurantsViewModel的直接和传递依赖关系](img/B17788_10_04.jpg)'
- en: Figure 10.4 – Observing the direct and transitive dependencies of RestaurantsViewModel
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 观察RestaurantsViewModel的直接和传递依赖关系
- en: We can see that both `GetInitialRestaurantsUseCase` and `ToggleRestaurantsUseCase`
    depend on `GetSortedRestaurantsUseCase` and `RestaurantsRepository`. The latter
    then depends on two library interfaces – `RestaurantsApiService` and `RestaurantsDao`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`GetInitialRestaurantsUseCase`和`ToggleRestaurantsUseCase`都依赖于`GetSortedRestaurantsUseCase`和`RestaurantsRepository`。后者随后依赖于两个库接口
    – `RestaurantsApiService`和`RestaurantsDao`。
- en: Essentially, we must instantiate all these classes to test our `RestaurantsViewModel`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，我们必须实例化所有这些类来测试我们的`RestaurantsViewModel`。
- en: 'Inside the `RestaurantsViewModelTest` class, refactor the `getViewModel()`
    method to construct all the necessary dependencies of `RestaurantsViewModel`:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RestaurantsViewModelTest`类内部，重构`getViewModel()`方法以构建`RestaurantsViewModel`的所有必要依赖项：
- en: '[PRE28]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you read the previous snippet from bottom to top, you will notice that we
    were able to construct all the dependencies of the `RestaurantsViewModel`, and
    their dependencies, and so on until we hit `RestaurantsRepository`. This depends
    on two library interfaces, `RestaurantsApiService` and `RestaurantsDao`, whose
    implementations are provided by the Retrofit and Room libraries.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从上一个代码片段的底部向上阅读，你会注意到我们能够构建`RestaurantsViewModel`的所有依赖项，以及它们的依赖项，等等，直到我们遇到`RestaurantsRepository`。这依赖于两个库接口`RestaurantsApiService`和`RestaurantsDao`，它们的实现由Retrofit和Room库提供。
- en: 'In our production code, these two interfaces cross the boundary to the *real
    world* because their implementations, provided by the Retrofit and Room libraries,
    communicate with a real Firebase REST API and a real Room local database:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的生产代码中，这两个接口跨越到*真实世界*的边界，因为它们的实现，由Retrofit和Room库提供，与真实的Firebase REST API和真实的Room本地数据库通信：
- en: '![Figure 10.5 – Observing the real-world boundary crossed by the transitive'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.4 – 观察RestaurantsViewModel的直接和传递依赖关系](img/B17788_10_04.jpg)'
- en: dependencies of RestaurantsViewModel
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: RestaurantsViewModel的依赖项
- en: '](img/B17788_10_05.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.5 – 观察RestaurantsViewModel传递依赖关系跨越的真实世界边界](img/B17788_10_05.jpg)'
- en: Figure 10.5 – Observing the real-world boundary crossed by the transitive dependencies
    of RestaurantsViewModel
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – 观察RestaurantsViewModel的传递依赖关系跨越的真实世界边界
- en: If we were to use the existing implementations of these two interfaces provided
    by Retrofit and Room in our test code, the `RestaurantsViewModel` instance will
    communicate with the external world and our tests won't be isolated. Instead,
    our test code will be slow and not reliable because it will be dependent on our
    web REST API and a real local database.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在测试代码中使用Retrofit和Room提供的这两个接口的现有实现，`RestaurantsViewModel`实例将与外部世界通信，我们的测试将不会隔离。相反，我们的测试代码将会慢且不可靠，因为它将依赖于我们的Web
    REST API和真实的本地数据库。
- en: Yet how can we make our `RestaurantsViewModel` tests isolated, fast, and reliable?
    We can simply make sure that instead of having Retrofit and Room provide the implementations
    for `RestaurantsApiService` and `RestaurantsDao`, we define dummy implementations
    for these interfaces that won't communicate with the real world.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们如何使我们的`RestaurantsViewModel`测试变得隔离、快速和可靠呢？我们可以简单地确保，而不是让Retrofit和Room为`RestaurantsApiService`和`RestaurantsDao`提供实现，我们为这些接口定义了不会与真实世界通信的模拟实现。
- en: These dummy implementations are often called fakes. **Fakes** are simplified
    implementations of the interfaces that we're looking to interact with in our tests.
    Such implementations mimic the behavior of the production implementations in a
    very simplified manner, often by returning dummy data. Fakes will only be used
    in our tests, so we can ensure that our testing environment is isolated.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这些占位实现通常被称为伪造对象。**伪造对象**是我们希望在测试中与之交互的接口的简化实现。这些实现以非常简化的方式模拟生产实现的行为，通常是通过返回占位数据。伪造对象将仅用于我们的测试，这样我们就可以确保我们的测试环境是隔离的。
- en: Apart from fakes, to mimic the functionality of components that cross the boundary
    to the real world, you can also use mocks. **Mocks** are objects that also simulate
    the behavior of a real object; however, you can configure their output on the
    fly without any additional classes.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 除了伪造对象外，为了模拟跨越真实世界边界的组件的功能，你还可以使用模拟对象。**模拟对象**是模拟真实对象行为的对象；然而，你可以动态配置它们的输出，而无需任何额外的类。
- en: In this chapter, we will only focus on fakes, since most of the time, to create
    mocks, you need to use special mocking frameworks. Also, fakes tend to be more
    practical and can be reused across tests, whereas mocks tend to clutter your tests,
    as they bring a lot of boilerplate code.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将只关注伪造对象，因为大多数情况下，要创建模拟对象，你需要使用特殊的模拟框架。此外，伪造对象通常更实用，可以在多个测试中重复使用，而模拟对象则可能导致测试变得杂乱，因为它们会引入大量的模板代码。
- en: Note
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Whenever you have a component that interacts with the *real world*, be it a
    web API, local database, or other production systems, you should define an interface
    for it. This way, in your production code, your other components interact with
    a real implementation of that interface, while your tests interact with a fake
    implementation of it.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你有一个与真实世界交互的组件，无论是网络 API、本地数据库还是其他生产系统，你都应该为它定义一个接口。这样，在你的生产代码中，其他组件与该接口的真实实现交互，而你的测试则与该接口的伪造实现交互。
- en: 'Let''s see how we can implement fakes. In our case, `RestaurantsRepository`
    needs fake implementations of the `RestaurantsApiService` and `RestaurantsDao`
    interfaces. Let''s begin with a fake implementation of the `RestaurantsApiService`
    interface:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何实现伪造对象。在我们的例子中，`RestaurantsRepository` 需要伪造的 `RestaurantsApiService`
    和 `RestaurantsDao` 接口的实现。让我们从 `RestaurantsApiService` 接口的伪造实现开始：
- en: 'To create a fake for the `RestaurantsApiService` interface, we must define
    a class that will implement the interface and simulate the functionality of a
    REST API. Inside the `test` package, create a Kotlin class named `FakeApiService`
    that implements the `RestaurantsApiService` interface and add the following code
    inside:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要为 `RestaurantsApiService` 接口创建一个伪造对象，我们必须定义一个将实现该接口并模拟 REST API 功能的类。在 `test`
    包内，创建一个名为 `FakeApiService` 的 Kotlin 类，实现 `RestaurantsApiService` 接口，并在其中添加以下代码：
- en: '[PRE29]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Our `FakeApiService` overrides the required methods and returns some dummy restaurants
    from the `DummyContent` class. In the `getRestaurants()` method, we also call
    a coroutine-based `delay()` function of 1,000 milliseconds to better simulate
    an asynchronous response. Since we will not be using the `getRestaurant()` method
    in our tests right now, we haven't added any implementation inside it.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `FakeApiService` 覆盖了所需的方法，并从 `DummyContent` 类返回一些占位餐厅信息。在 `getRestaurants()`
    方法中，我们还调用了一个基于协程的 `delay()` 函数，持续时间为 1,000 毫秒，以更好地模拟异步响应。由于我们现在不会在测试中使用 `getRestaurant()`
    方法，所以我们还没有在它内部添加任何实现。
- en: Going back to the dummy content that is returned, note that the `getRestaurants()`
    method must return a list of `RemoteRestaurant` objects, so we called a non-existent
    `getRemoteRestaurants()` method on the `DummyContent` class. Let's define this
    method up next.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 回到返回的占位内容，请注意，`getRestaurants()` 方法必须返回一个 `RemoteRestaurant` 对象的列表，因此我们在 `DummyContent`
    类上调用了一个不存在的 `getRemoteRestaurants()` 方法。接下来，让我们定义这个方法。
- en: 'Head back inside the main source set where our production code resides. Inside
    the `DummyContent` class, add a new method called `getRemoteRestaurants()` that
    maps the list of `Restaurant` objects returned by the `getDomainRestaurants()`
    method to `RemoteRestaurant` objects:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到主源集，我们的生产代码就在那里。在 `DummyContent` 类中，添加一个名为 `getRemoteRestaurants()` 的新方法，该方法将
    `getDomainRestaurants()` 方法返回的 `Restaurant` 对象列表映射到 `RemoteRestaurant` 对象：
- en: '[PRE30]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, head back inside the `test` package. We''ve created a fake for the `RestaurantsApiService`
    interface, but we must also create one fake for the `RestaurantsDao` interface
    that will implement the interface and simulate the functionality of a local database.
    Inside the `test` package, create a Kotlin class named `FakeRoomDao` that implements
    the `RestaurantsDao` interface and add the following code inside:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，回到`test`包中。我们已经为`RestaurantsApiService`接口创建了一个模拟，但我们也必须为`RestaurantsDao`接口创建一个模拟，该模拟将实现接口并模拟本地数据库的功能。在`test`包内部，创建一个名为`FakeRoomDao`的Kotlin类，该类实现`RestaurantsDao`接口，并在其中添加以下代码：
- en: '[PRE31]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Our `FakeRoomDao` class mimics the functionality of a real Room database, yet
    instead of storing restaurants in the local SQL database, it stores them in memory
    in the `restaurants` variable. We will not cover each method implementation of
    `FakeRoomDao`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`FakeRoomDao`类模仿了真实Room数据库的功能，但不是将餐厅存储在本地SQL数据库中，而是将它们存储在内存中的`restaurants`变量中。我们不会涵盖`FakeRoomDao`的每个方法实现。
- en: However, we will conclude that each method simulates the interaction with a
    persistent storage service. Additionally, as our `FakeRoomDao` simulates interaction
    with a real local database, each of its actions will cause a delay triggered by
    the pre-built suspending `delay()` function.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将得出结论，每个方法都模拟了与持久存储服务的交互。此外，由于我们的`FakeRoomDao`模拟与真实本地数据库的交互，它的每个操作都会由预构建的挂起`delay()`函数触发的延迟。
- en: However, our `FakeRoom` class makes use of an `updateRestaurant()` method that
    we haven't defined so far. Let's do that now.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的`FakeRoom`类使用了我们尚未定义的`updateRestaurant()`方法。让我们现在就定义它。
- en: 'At the end of the body of the `FakeRoom` class, add the missing `updateRestaurant()`
    method that toggles the value of the `isFavorite` field:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FakeRoom`类的末尾，添加缺失的`updateRestaurant()`方法，该方法切换`isFavorite`字段的值：
- en: '[PRE32]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now that we have finished implementing the fakes for our `RestaurantsApiService`
    and `RestaurantsDao` interfaces, it's time to pass them where we need them in
    our tests. Remember that the last missing piece was to provide fake implementations
    of the `RestaurantsRepository` dependencies so that our test is isolated.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经实现了`RestaurantsApiService`和`RestaurantsDao`接口的模拟，是时候在我们的测试中传递它们所需的位置了。记住，最后缺失的部分是提供`RestaurantsRepository`依赖项的模拟实现，以便我们的测试是隔离的。
- en: 'Head back inside the `RestaurantsViewModelTest` class and update the `getViewModel()`
    function to pass instances of the `FakeApiService` and `FakeRoomDao` classes to
    `RestaurantsRepository`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`RestaurantsViewModelTest`类中，并更新`getViewModel()`函数，将`FakeApiService`和`FakeRoomDao`类的实例传递给`RestaurantsRepository`：
- en: '[PRE33]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now that the `getViewModel()` method is able to return an instance of `RestaurantsViewModel`
    that we can easily test, let''s get back to our `initialState_isProduced()` test
    method, which currently looks like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`getViewModel()`方法能够返回一个`RestaurantsViewModel`实例，我们可以轻松地进行测试，让我们回到`initialState_isProduced()`测试方法，它目前看起来是这样的：
- en: '[PRE34]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Remember that the scope of this test method is to verify that when our `RestaurantsViewModel`
    is initialized, it produces a correct initial state. Let's do that now.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这个测试方法的范围是验证当我们的`RestaurantsViewModel`初始化时，它产生一个正确的初始状态。让我们现在就做这件事。
- en: 'First, inside the `initialState_isProduced()` test method, store the initial
    state inside an `initialState` variable:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`initialState_isProduced()`测试方法中，将初始状态存储在`initialState`变量中：
- en: '[PRE35]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, by using the built-in `assert()` function, verify whether the content
    of `initialState` is as expected:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用内置的`assert()`函数，验证`initialState`的内容是否符合预期：
- en: '[PRE36]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this test method, we're asserting whether the value of the `initialState`
    variable is a `RestaurantsScreenState` object with a `false` `isLoading` field
    and an `emptyList()` value inside the `restaurants` field. Additionally, we're
    testing that there is no value stored inside the `error` field.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试方法中，我们断言`initialState`变量的值是否是一个具有`false` `isLoading`字段和`emptyList()`值在`restaurants`字段中的`RestaurantsScreenState`对象。此外，我们还测试`error`字段中没有存储任何值。
- en: Now that we have defined our first test method, it's time to run the test!
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的第一个测试方法，是时候运行测试了！
- en: Inside the `RestaurantsViewModelTest` class and select **Run RestaurantsViewModelTest**.
    This command will run all the tests inside this class (only one in our case) directly
    on your local JVM, rather than running on an Android device, as our UI tests did.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RestaurantsViewModelTest`类中，选择**运行RestaurantsViewModelTest**。此命令将直接在您的本地JVM上运行此类中的所有测试（在我们的情况下只有一个），而不是在Android设备上运行，就像我们的UI测试那样。
- en: 'If you switch to the **Run** tab, you will see that our test has failed:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你切换到 **运行** 选项卡，你会看到我们的测试失败了：
- en: '![Figure 10.6 – Observing how the test inside the RestaurantsViewModelTest
    class has failed'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.6 – 观察RestaurantsViewModelTest类中的测试失败'
- en: '](img/B17788_10_06.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_10_06.jpg)'
- en: Figure 10.6 – Observing how the test inside the RestaurantsViewModelTest class
    has failed
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – 观察RestaurantsViewModelTest类中的测试失败
- en: This exception is thrown because our Restaurants app handles asynchronous work
    with the help of coroutines, and our test code doesn't know how to interact with
    them.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这个异常被抛出，是因为我们的餐厅应用通过协程帮助处理异步工作，而我们的测试代码不知道如何与它们交互。
- en: 'For instance, our `RestaurantsViewModel` launches coroutines that call several
    suspend functions, and all of these happen on `viewModelScope`, which has the
    `Dispatchers.Main` dispatcher set by default:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的 `RestaurantsViewModel` 启动了调用多个挂起函数的协程，所有这些都在 `viewModelScope` 上发生，该作用域默认设置了
    `Dispatchers.Main` 分派器：
- en: '[PRE37]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The main issue here is that our coroutines are launched on the Main thread on
    our local JVM, which can't work with the UI thread.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这里主要的问题是，我们的协程是在本地 JVM 的主线程上启动的，这无法与 UI 线程协同工作。
- en: Note
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `Dispatchers.Main` dispatcher uses the Android `Looper.getMainLooper()`
    function to run code in the UI thread. That method is available in UI tests but
    not in the regular unit tests that run on our JVM.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dispatchers.Main` 分派器使用 Android 的 `Looper.getMainLooper()` 函数在 UI 线程上运行代码。该方法在
    UI 测试中可用，但在我们 JVM 上运行的常规单元测试中不可用。'
- en: To make our testing code compliant with the usage of coroutines, we need to
    use the Kotlin coroutines testing library, which will provide us with scopes and
    dispatchers that are dedicated to testing coroutines. If our test code is run
    from coroutines that are built with these dedicated scopes and dispatchers, our
    test will no longer fail.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的测试代码符合协程的使用，我们需要使用 Kotlin 协程测试库，它将为我们提供专门用于测试协程的范围和分派器。如果我们的测试代码是从使用这些专用范围和分派器构建的协程中运行的，我们的测试将不再失败。
- en: Let's add the Kotlin coroutines testing library!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加 Kotlin 协程测试库！
- en: 'In the app-level `build.gradle` file, add a `testImplementation` dependency
    to the Kotlin coroutines testing package:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用级别的 `build.gradle` 文件中，向 Kotlin 协程测试包添加一个 `testImplementation` 依赖项：
- en: '[PRE38]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Synchronize your project with its Gradle files by clicking on the **Sync your
    project with Gradle files** button in Android Studio or by pressing on the **File**
    menu option and then by selecting **Sync Project with Gradle Files**.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 Android Studio 中单击 **与 Gradle 文件同步项目** 按钮，或通过按 **文件** 菜单选项然后选择 **与 Gradle
    文件同步项目** 来同步你的项目与 Gradle 文件：
- en: 'Head back inside the `RestaurantsViewModelTest` class and define a variable
    for a `StandardTestDispatcher` object and a variable for a `TestScope` object
    based on the previously defined dispatcher:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 `RestaurantsViewModelTest` 类中，定义一个 `StandardTestDispatcher` 对象的变量和一个基于之前定义的分派器的
    `TestScope` 对象的变量：
- en: '[PRE39]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Additionally, we've added the `@ExperimentalCoroutinesApi` annotation to the
    `RestaurantsViewModelTest` class, since these testing APIs are still experimental.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还在 `RestaurantsViewModelTest` 类上添加了 `@ExperimentalCoroutinesApi` 注解，因为这些测试
    API 仍然是实验性的。
- en: 'Next up, make sure that all the code from within the body of the `initialState_isProduced()`
    test method is run inside a test-specific coroutine. To do that, launch a coroutine
    that wraps this method''s body by calling the `runTest()` coroutine builder on
    our `scope` variable of type `TestScope`:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，确保 `initialState_isProduced()` 测试方法体内的所有代码都在一个特定于测试的协程中运行。为此，通过在 `TestScope`
    类型的 `scope` 变量上调用 `runTest()` 协程构建器来启动一个封装此方法体的协程：
- en: '[PRE40]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Run the `RestaurantsViewModelTest` class. If you switch to the **Run** tab,
    you will see that our test has failed again, with the same exception as before.
    Since we wrapped the body of our test method inside a test coroutine, our test
    code still throws an exception, telling us that we still need to change the dispatcher
    of the coroutine.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `RestaurantsViewModelTest` 类。如果你切换到 **运行** 选项卡，你会看到我们的测试再次失败，与之前的异常相同。由于我们在测试方法的主体内部封装了一个测试协程，我们的测试代码仍然抛出异常，告诉我们我们仍然需要更改协程的分派器。
- en: 'If we have another look at `RestaurantsViewModel`, we can note that both the
    coroutines launched with `viewModelScope` have no dispatcher set, so they''re
    using `Dispatchers.Main` behind the scenes:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次查看 `RestaurantsViewModel`，我们可以注意到，使用 `viewModelScope` 启动的所有协程都没有设置分派器，因此它们在幕后使用
    `Dispatchers.Main`：
- en: '[PRE41]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: However, in our test, all coroutines that are launched should use `StandardTestDispatcher`
    defined in our test class. So, how can we pass a test dispatcher to the coroutines
    launched in our `RestaurantsViewModel`?
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的测试中，所有启动的协程都应该使用在测试类中定义的`StandardTestDispatcher`。那么，我们如何将测试调度器传递给在`RestaurantsViewModel`中启动的协程？
- en: We can inject the dispatcher inside the `RestaurantsViewModel` class by using
    its constructor and making it accept a `CoroutineDispatcher` object, which will
    be passed to all the coroutines that are launched.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用构造函数并在其中接受一个`CoroutineDispatcher`对象来将调度器注入到`RestaurantsViewModel`类中，该对象将被传递给所有启动的协程。
- en: This way, in our production code, `RestaurantsViewModel` will receive and use
    the `Dispatchers.Main` dispatcher, and inside our test code, it will receive and
    use the `StandardTestDispatcher` dispatcher.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，在我们的生产代码中，`RestaurantsViewModel`将接收并使用`Dispatchers.Main`调度器，而在我们的测试代码中，它将接收并使用`StandardTestDispatcher`调度器。
- en: Note
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The practice of injecting dispatchers into our coroutine-based classes is encouraged,
    as it allows us to have better isolation and control over the testing environment
    of our unit tests.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 将调度器注入到基于协程的类中是一种推荐的做法，因为它允许我们更好地隔离和控制单元测试的测试环境。
- en: 'Head back inside the main source set where our production code resides. Inside
    `RestaurantsViewModel`, add a `dispatcher` constructor parameter of type `CoroutineDispatcher`
    and pass it to the `viewModelScope()` calls:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到主要源集，其中包含我们的生产代码。在`RestaurantsViewModel`内部，添加一个类型为`CoroutineDispatcher`的`dispatcher`构造函数参数，并将其传递给`viewModelScope()`调用：
- en: '[PRE42]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: However, if we build the project now, we will get an error because Hilt doesn't
    know how to provide an instance of `CoroutineDispatcher` to `RestaurantsViewModel`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们现在构建项目，将会得到一个错误，因为Hilt不知道如何为`RestaurantsViewModel`提供`CoroutineDispatcher`的实例。
- en: To instruct Hilt on how to provide our `ViewModel` with the dispatcher it needs
    (that is, `Dispatchers.Main`), we must create a Hilt module.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指导Hilt如何为我们提供的`ViewModel`提供所需的调度器（即`Dispatchers.Main`），我们必须创建一个Hilt模块。
- en: 'Inside the `di` package, create a new class called `DispatcherModule` and add
    the following code that tells Hilt how to provide any `CoroutineDispatcher` dependencies
    with `Dispatchers.Main`:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`di`包内部，创建一个名为`DispatcherModule`的新类，并添加以下代码，告诉Hilt如何使用`Dispatchers.Main`提供任何`CoroutineDispatcher`依赖项：
- en: '[PRE43]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: However, right now, Hilt will always provide `Dispatchers.Main` to any `CoroutineDispatcher`
    dependencies. What if we need later to obtain a dispatcher different than `Dispatchers.Main`?
    Let's see how we can prepare for that.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，目前Hilt将始终为任何`CoroutineDispatcher`依赖项提供`Dispatchers.Main`。如果我们以后需要获取不同于`Dispatchers.Main`的调度器怎么办？让我们看看我们如何为此做好准备。
- en: 'At the top of the body of `DispatcherModule`, define an annotation class called
    `MainDispatcher` annotated with the `@Qualifier` annotation:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DispatcherModule`类的主体部分，定义一个名为`MainDispatcher`的注解类，并使用`@Qualifier`注解进行标注：
- en: '[PRE44]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `@Qualifier` annotation allows us to provide different dispatchers to the
    `CoroutineDispatcher` dependencies. In our case, we defined that a `@MainDispatcher`
    annotation will provide the `Dispatchers.Main` dispatcher.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Qualifier`注解允许我们为`CoroutineDispatcher`依赖项提供不同的调度器。在我们的例子中，我们定义了一个`@MainDispatcher`注解将提供`Dispatchers.Main`调度器。'
- en: 'Add the `@MainDispatcher` annotation to the `providesMainDispatcher()` method
    so that Hilt will know what dispatcher to provide when such an annotation is used
    on a dependency:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`@MainDispatcher`注解添加到`providesMainDispatcher()`方法中，这样当这样的注解用于依赖项时，Hilt将知道提供哪个调度器：
- en: '[PRE45]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, inside `RestaurantsViewModel`, annotate the `dispatcher` parameter with
    the newly created `@MainDispatcher` annotation so that Hilt will provide us with
    the `Dispatchers.Main` dispatcher:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`RestaurantsViewModel`内部，使用新创建的`@MainDispatcher`注解标注`dispatcher`参数，这样Hilt就会为我们提供`Dispatchers.Main`调度器：
- en: '[PRE46]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now that the `RestaurantsViewModel` uses the `Dispatcher.Main` dispatcher in
    our production code, head back inside the `test` source set and inside the `RestaurantsViewModelTest`
    class, update its `getViewModel()` method by passing the `dispatcher` member field
    to the `RestaurantsViewModel` constructor call:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，由于`RestaurantsViewModel`在我们的生产代码中使用`Dispatcher.Main`调度器，返回到`test`源集，并在`RestaurantsViewModelTest`类内部，通过将`dispatcher`成员字段传递给`RestaurantsViewModel`构造函数调用，更新其`getViewModel()`方法：
- en: '[PRE47]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now, in our test code, `RestaurantsViewModel` will use the `StandardTestDispatcher`
    dispatcher for all the launched coroutines.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的测试代码中，`RestaurantsViewModel`将使用在测试类中定义的`StandardTestDispatcher`调度器来启动所有协程。
- en: 'Now, run the `RestaurantsViewModelTest` class again. If you switch to the **Run**
    tab, you will see that our test has now passed:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次运行 `RestaurantsViewModelTest` 类。如果你切换到 **运行** 选项卡，你会看到我们的测试现在已经通过了：
- en: '![Figure 10.7 – Observing how the test inside the RestaurantsViewModelTest
    class has succeeded'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.7 – 观察RestaurantsViewModelTest类中的测试是否成功'
- en: '](img/B17788_10_07.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_10_07.jpg)'
- en: Figure 10.7 – Observing how the test inside the RestaurantsViewModelTest class
    has succeeded
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – 观察RestaurantsViewModelTest类中的测试是否成功
- en: Since our test uses the `runTest()` coroutine builder, any `delay()` calls in
    our fake implementations are skipped, making our test run fast, in just a few
    hundred milliseconds.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的测试使用 `runTest()` 协程构建器，我们伪造实现中的任何 `delay()` 调用都将被跳过，这使得我们的测试运行得很快，只需几百毫秒。
- en: Now that we have tested whether our `ViewModel` produces a correct initial state,
    it's time to test the state that comes after this initial state – the state with
    content. This state is produced when the restaurants have arrived (from our data
    layer), so the `isLoading` field should be reset to `false`, while the `restaurants`
    field should contain a list of restaurants.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经测试了我们的 `ViewModel` 是否产生了一个正确的初始状态，现在是时候测试这个初始状态之后的状态——具有内容的状态了。这个状态是在餐厅到达（来自我们的数据层）时产生的，因此
    `isLoading` 字段应该重置为 `false`，而 `restaurants` 字段应该包含餐厅列表。
- en: 'Add a new testing method inside `RestaurantsViewModelTest` called `stateWithContent_isProduced()`
    that asserts whether the state with restaurants is produced as expected:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RestaurantsViewModelTest` 中添加一个新的测试方法，名为 `stateWithContent_isProduced()`，断言是否产生了预期的包含餐厅的状态：
- en: '[PRE48]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Since the `FakeApiService` returns the dummy list of `RemoteRestaurant` from
    the `DummyContent` class, it's only natural that we're expecting to get the same
    content in `ViewModel` but in the shape of the `Restaurant` objects – so we're
    asserting that the `restaurants` field of `currentState` contains the restaurants
    from `DummyContent`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `FakeApiService` 从 `DummyContent` 类返回 `RemoteRestaurant` 的模拟列表，因此我们自然期望在
    `ViewModel` 中得到相同的内容，但以 `Restaurant` 对象的形式——因此我们断言 `currentState` 的 `restaurants`
    字段包含 `DummyContent` 中的餐厅。
- en: Unfortunately, if we run the `RestaurantsViewModelTest` class, the `stateWithContent_isProduced()`
    test will fail, telling us that `currentState` has the `isLoading` field's value
    of `true` and there are no restaurants inside the `restaurants` field.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果我们运行 `RestaurantsViewModelTest` 类，`stateWithContent_isProduced()` 测试将失败，告诉我们
    `currentState` 的 `isLoading` 字段的值为 `true`，并且 `restaurants` 字段中没有餐厅。
- en: This issue makes sense because we're basically obtaining the initial state and
    expecting it to be the state with content, which, in fact, comes later on. Because
    there are several `delay()` calls in our `FakeApiService` and `FakeRoomDao` implementations,
    we must allow time to pass so that `ViewModel` produces the second state – the
    one with restaurants. But how can we do that?
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题是有意义的，因为我们基本上获取了初始状态并期望它是具有内容的状态，但实际上这个状态会在稍后出现。因为我们的 `FakeApiService` 和
    `FakeRoomDao` 实现中有几个 `delay()` 调用，我们必须允许时间过去，以便 `ViewModel` 产生第二个状态——包含餐厅的状态。但我们如何做到这一点呢？
- en: Inside a test, to immediately execute all pending tasks (such as the launched
    coroutine to get restaurants in our `ViewModel`) and to advance the virtual clock
    until after the last delay, we can call the `advanceUntilIdle()` function exposed
    by the coroutines test library.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，为了立即执行所有挂起的任务（例如在 `ViewModel` 中获取餐厅启动的协程）并推进虚拟时钟直到最后一个延迟之后，我们可以调用协程测试库公开的
    `advanceUntilIdle()` 函数。
- en: 'Inside the `stateWithContent_isProduced()` test method, after `RestaurantsViewModel`
    is instantiated but before our assertion, add the `advanceUntilIdle()` method
    call:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `stateWithContent_isProduced()` 测试方法中，在 `RestaurantsViewModel` 实例化之后但在我们的断言之前，添加
    `advanceUntilIdle()` 方法调用：
- en: '[PRE49]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: When we call `advanceUntilIdle()` inside our `scope` variable of type `TestScope`,
    we're advancing the virtual clock of `TestCoroutineScheduler` featured in the
    `StandardTestDispatcher` that we've initially passed to our `scope`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在类型为 `TestScope` 的 `scope` 变量内部调用 `advanceUntilIdle()` 时，我们正在推进 `StandardTestDispatcher`
    中 `TestCoroutineScheduler` 的虚拟时钟，这是我们最初传递给 `scope` 的。
- en: Now, run the `RestaurantsViewModelTest` class again. If you switch to the `stateWithContent_isProduced()`
    test still failed.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次运行 `RestaurantsViewModelTest` 类。如果你切换到 `stateWithContent_isProduced()`
    测试仍然失败。
- en: The main issue here is that while we're trying to advance the virtual clock
    of our test by leveraging the fact that our test instance of `RestaurantsViewModel`
    now launches its coroutines on the `StandardTestDispatcher` instance that we've
    passed to it, we have another class that is passing its own `CoroutineDispatcher`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要问题是，当我们试图通过利用我们的测试实例`RestaurantsViewModel`现在在其传递给它的`StandardTestDispatcher`实例上启动协程的事实来推进测试的虚拟时钟时，我们还有一个传递它自己的`CoroutineDispatcher`的类。
- en: 'If we have a closer look inside our `RestaurantsRepository`, we can see that
    it''s passing a production-use `Dispatchers.IO` dispatcher to all its `withContext()`
    calls:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更仔细地查看我们的`RestaurantsRepository`，我们可以看到它正在将一个用于生产的`Dispatchers.IO`分发器传递给所有的`withContext()`调用：
- en: '[PRE50]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Because the `RestaurantsRepository` instance that our `RestaurantsViewModel`
    indirectly depends on uses the `Dispatchers.IO` dispatcher and not the `StandardTestDispatcher`
    one, the virtual clock of our test is not advanced as expected. Let's fix this
    issue by injecting the dispatcher in the `RestaurantsRepository`, just as we did
    for `RestaurantsViewModel`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的`RestaurantsViewModel`间接依赖的`RestaurantsRepository`实例使用的是`Dispatchers.IO`分发器，而不是`StandardTestDispatcher`，所以测试的虚拟时钟并没有像预期的那样推进。让我们通过在`RestaurantsRepository`中注入分发器来解决这个问题，就像我们对`RestaurantsViewModel`所做的那样。
- en: However, before performing the injection, we must first define a new type of
    `CoroutineDispatcher` that Hilt should know how to inject – the `Dispatchers.IO`
    dispatcher.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，在进行注入之前，我们必须首先定义一个新的`CoroutineDispatcher`类型，让Hilt知道如何注入——即`Dispatchers.IO`分发器。
- en: 'Head inside the `DispatchersModule` class and, just as we did for the `Dispatchers.Main`
    dispatcher, instruct Hilt on how to provide us with the `Dispatchers.IO` dispatcher:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 进入`DispatchersModule`类中，就像我们为`Dispatchers.Main`分发器所做的那样，指导Hilt如何为我们提供`Dispatchers.IO`分发器：
- en: '[PRE51]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Head back inside the main source set where our production code resides. Inside
    the `RestaurantsRepository` class, inject `CoroutineDispatcher`, annotate it with
    the `@IoDispatcher` qualifier, and then pass the injected `dispatcher` to all
    the `withContext()` calls:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到主源集，我们的生产代码就位于其中。在`RestaurantsRepository`类中，注入`CoroutineDispatcher`，用`@IoDispatcher`注解它，然后将注入的`dispatcher`传递给所有的`withContext()`调用：
- en: '[PRE52]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, heading back inside our `test` package, inside the `RestaurantsViewModelTest`
    class, update the `getViewModel()` method to pass our `dispatcher` field of type
    `StandardTestDispatcher` to the `RestaurantsRepository` constructor:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，回到我们的`test`包中，在`RestaurantsViewModelTest`类中，更新`getViewModel()`方法，将我们的`StandardTestDispatcher`类型的`dispatcher`字段传递给`RestaurantsRepository`构造函数：
- en: '[PRE53]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now, run the `RestaurantsViewModelTest` class again. If you switch to the `RestaurantsViewModel`
    is correctly producing an error state. As a tip, make sure to throw an instance
    of the `Exception` class inside `FakeApiService` but just for this specific test
    method where you're verifying the error state. To achieve that, you can configure
    a constructor parameter in `FakeApiService` so that it can throw an exception
    if needed.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次运行`RestaurantsViewModelTest`类。如果你切换到`RestaurantsViewModel`，它正确地生成了一个错误状态。作为一个提示，确保在`FakeApiService`内部抛出一个`Exception`类的实例，但仅针对这个特定的测试方法，你正在验证错误状态。为了实现这一点，你可以在`FakeApiService`中配置一个构造函数参数，以便在需要时抛出异常。
- en: Now that we tested how `RestaurantsViewModel` is producing the UI state, let's
    briefly have a look at how we could test a business component.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经测试了`RestaurantsViewModel`如何生成UI状态，让我们简要地看看我们如何测试一个业务组件。
- en: Testing the functionality of a UseCase class
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试`UseCase`类的功能
- en: Aside from unit-testing the presentation layer of our application, it's very
    important to also test the business rules present in the app. In our Restaurants
    app, the business logic is encapsulated in `UseCase` classes.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对应用程序的表现层进行单元测试之外，测试应用程序中存在的业务规则也非常重要。在我们的餐厅应用程序中，业务逻辑封装在`UseCase`类中。
- en: Let's see say that we want to test `ToggleRestaurantUseCase`. Essentially, we
    want to make sure that when we execute this `UseCase` class for a specific restaurant,
    the business logic of negating the `isFavorite` field of the `Restaurant` is working.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要测试`ToggleRestaurantUseCase`。本质上，我们想要确保当我们为特定的餐厅执行这个`UseCase`类时，否定`Restaurant`的`isFavorite`字段的业务逻辑是正常工作的。
- en: In other words, if one restaurant was not marked as favorite, after executing
    `ToggleRestaurantUseCase` for that specific restaurant, its `isFavorite` field
    should become `true`. While this business logic is indeed slim, in medium to large-sized
    applications, such business logic can become much more complex.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果一家餐厅没有被标记为收藏夹，在执行针对该特定餐厅的`ToggleRestaurantUseCase`之后，其`isFavorite`字段应该变为`true`。虽然这个业务逻辑确实很简单，但在中到大型的应用程序中，这样的业务逻辑可能会变得更加复杂。
- en: 'Let''s see how a unit test for `ToggleRestaurantUseCase` would look:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`ToggleRestaurantUseCase`的单元测试将如何进行：
- en: '[PRE54]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This unit test is similar to the ones we wrote for `RestaurantsViewModel` in
    the sense that it's also using `StandardTestDispatcher` and `TestScope`, simply
    because the `invoke()` operator of `ToggleRestaurantUseCase` is a `suspending`
    function.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单元测试与我们在`RestaurantsViewModel`上编写的测试类似，因为它也使用了`StandardTestDispatcher`和`TestScope`，仅仅是因为`ToggleRestaurantUseCase`的`invoke()`操作符是一个`suspending`函数。
- en: 'The structure of the test is split into three parts, delimited by the suggestive
    comments:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的结构分为三个部分，由提示性注释分隔：
- en: '`ToggleRestaurantUseCase` instance and its direct and transitive dependencies,
    while passing our test dispatcher to the dependencies that need it.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ToggleRestaurantUseCase`实例及其直接和间接依赖项，同时将我们的测试分发器传递给需要它的依赖项。'
- en: '`ToggleRestaurantUseCase` to be able to execute its business logic on a specific
    restaurant, we first had to make sure that our `RestaurantsRepository` instance
    had loaded the dummy restaurants. We then called `advancedUntilIdle()`, allowing
    any suspending (blocking) work related to obtaining and caching dummy restaurants
    to finish.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使`ToggleRestaurantUseCase`能够在特定餐厅上执行其业务逻辑，我们首先必须确保我们的`RestaurantsRepository`实例已加载了模拟餐厅。然后我们调用了`advancedUntilIdle()`，允许与获取和缓存模拟餐厅相关的任何挂起（阻塞）工作完成。
- en: '`isFavorite` field we want to toggle as `targetItem`, obtained its current
    `isFavorite` field value, and executed `ToggleRestaurantUseCase`, storing the
    resultant restaurants inside the `updatedRestaurants` variable. Since this operation
    refreshes and re-obtains the restaurants from the fake local database, we then
    called `advancedUntilIdle()`, allowing any suspending work to finish.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要切换的`isFavorite`字段作为`targetItem`，获取其当前的`isFavorite`字段值，并执行`ToggleRestaurantUseCase`，将结果餐厅存储在`updatedRestaurants`变量中。由于这个操作刷新并重新从模拟本地数据库中获取餐厅，所以我们随后调用了`advancedUntilIdle()`，允许任何挂起的工作完成。
- en: '`isFavorite` field. Finally, we asserted that the resultant `updatedRestaurants`
    list is the same as the one we would expect to be correct – that is, `restaurants`.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们断言结果`updatedRestaurants`列表与我们预期正确的结果相同——即`restaurants`。
- en: If you run this test, it should pass.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个测试，它应该通过。
- en: Assignment
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 作业
- en: Try testing the behaviour of other Use Case classes such as `GetSortedRestaurantsUseCase`
    or even classes from the data layer such as `RestaurantsRepository`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试测试其他用例类（如`GetSortedRestaurantsUseCase`）或数据层中的类（如`RestaurantsRepository`）的行为。
- en: Summary
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we first had a look at the benefits of testing and classified
    tests based on different aspects. Afterward, we took a shot at testing our Compose-based
    UI and learned how to write UI unit tests by leveraging the power of the semantics
    modifiers.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先探讨了测试的好处，并根据不同方面对测试进行了分类。之后，我们尝试测试基于Compose的UI，并学习了如何利用语义修饰符的强大功能编写UI单元测试。
- en: Finally, we learned how to write regular – non-UI – unit tests in order to validate
    the core functionality of our application. In this part, we learned how to test
    our coroutine-based code and how important it is to inject the `CoroutineDispatcher`
    objects.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了如何编写常规的——非UI——单元测试，以验证我们应用程序的核心功能。在本部分中，我们学习了如何测试基于协程的代码，以及注入`CoroutineDispatcher`对象的重要性。
- en: In the next chapter, we're steering away from the architectural side of Android
    development, and we will be incorporating data pagination with the help of yet
    another interesting library called Jetpack Paging.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从Android开发的架构方面转向，我们将借助另一个有趣的库Jetpack Paging来实现数据分页。
- en: Further reading
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'In this chapter, we''ve briefly covered the basics of UI and unit testing,
    so the core concepts taught here should give you a solid starting point. However,
    there are several other topics that you might need while you continue your testing
    adventure:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要介绍了UI和单元测试的基础知识，因此这里教授的核心概念应该为你提供一个坚实的起点。然而，在你继续测试冒险的过程中，你可能还需要了解几个其他主题：
- en: 'For UI tests, we used semantics modifiers to identify UI elements from our
    node hierarchy. When testing Compose UI, you should also be aware of the merged
    and unmerged semantics tree. Learn more about this topic by reading the official
    docs: [https://developer.android.com/jetpack/compose/semantics](https://developer.android.com/jetpack/compose/semantics).'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 UI 测试，我们使用语义修饰符来识别节点层次结构中的 UI 元素。在测试 Compose UI 时，您还应该了解合并和未合并的语义树。通过阅读官方文档了解更多关于这个主题的信息：[https://developer.android.com/jetpack/compose/semantics](https://developer.android.com/jetpack/compose/semantics)。
- en: 'With UI tests, we only scratched the surface in terms of testing APIs. Make
    sure to check out this official testing cheat sheet: [https://developer.android.com/jetpack/compose/testing-cheatsheet](https://developer.android.com/jetpack/compose/testing-cheatsheet).'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 UI 测试，我们在测试 API 方面只是触及了表面。请务必查看这份官方测试速查表：[https://developer.android.com/jetpack/compose/testing-cheatsheet](https://developer.android.com/jetpack/compose/testing-cheatsheet)。
- en: 'Our unit tests are based on the JUnit testing framework. To discover the power
    and flexibility of Junit, check out its official docs: [https://junit.org/junit4/](https://junit.org/junit4/).'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的单元测试基于 JUnit 测试框架。要了解 JUnit 的强大和灵活性，请查看其官方文档：[https://junit.org/junit4/](https://junit.org/junit4/)。
- en: 'In your coroutine-based tests, apart from the `advanceUntilIdle()` API, you
    can also use the `advancetimeBy()` API to fast-forward the virtual clock of the
    test by a certain amount. Learn more about this function from the official Coroutines
    docs: [https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-delay-controller/advance-time-by.html](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-delay-controller/advance-time-by.html).'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您基于协程的测试中，除了 `advanceUntilIdle()` API 之外，您还可以使用 `advancetimeBy()` API 来通过一定量快速前进测试的虚拟时钟。从官方协程文档中了解更多关于此功能的信息：[https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-delay-controller/advance-time-by.html](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-delay-controller/advance-time-by.html)。
- en: 'Your unit tests must be deterministic in the sense that every run of one test
    for the same revision of code should always yield the same result. Learn more
    about deterministic and non-deterministic tests from Martin Fowler: [https://martinfowler.com/articles/nonDeterminism.html](https://martinfowler.com/articles/nonDeterminism.html).'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的单元测试必须在确定性方面是确定的，即对于代码的同一版本，每次运行同一测试都应该总是产生相同的结果。从马丁·福勒那里了解更多关于确定性和非确定性测试的信息：[https://martinfowler.com/articles/nonDeterminism.html](https://martinfowler.com/articles/nonDeterminism.html)。
