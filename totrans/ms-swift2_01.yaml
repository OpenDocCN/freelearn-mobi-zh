- en: Chapter 1. Taking the First Steps with Swift
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. 使用 Swift 的第一步
- en: Ever since I was 12 years old and wrote my first program in the basic programming
    language, programming has been a passion for me. Even as programming became my
    career, it always remained more of a passion than a job, but over the past few
    years, that passion has waned. I was unsure why I was losing that passion. I attempted
    to recapture it with some of my side projects, but nothing really brought back
    the excitement that I used to have. Then, something wonderful happened! Apple
    announced Swift. Swift is such an exciting and progressive language that it has
    brought a lot of that passion back and made programming fun for me again.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自从我 12 岁时用基本编程语言编写我的第一个程序以来，编程一直是我的一项热情。即使编程成为了我的职业，它始终更多的是一种热情，而不是工作，但过去几年，这种热情已经减弱。我不确定为什么我会失去这种热情。我试图通过一些我的副项目来重新找回它，但没有什么真正能让我找回曾经拥有的那种兴奋。然后，发生了一件美妙的事情！苹果宣布了
    Swift。Swift 是如此令人兴奋且进步的语言，它重新激发了许多那种热情，并让我再次享受编程的乐趣。
- en: 'In this chapter, you will learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习：
- en: What Swift is
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 Swift
- en: Some of the features of Swift
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift 的一些特性
- en: What Playgrounds are
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是游乐场
- en: How to use Playgrounds
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用游乐场
- en: What the basic syntaxes of the Swift language are
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift 语言的基本语法是什么
- en: What is Swift?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 Swift？
- en: Swift is Apple's new programming language that was introduced at the Worldwide
    Developers Conference (WWDC) in 2014 alongside the integrated development environment
    Xcode 6 and iOS 8\. Swift was arguably the most significant announcement at WWDC
    2014 and very few people, including Apple insiders, were aware of the project's
    existence prior to it being announced.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 是苹果在 2014 年的全球开发者大会（WWDC）上推出的新编程语言，与 Xcode 6 和 iOS 8 一起推出。Swift 可以说是 WWDC
    2014 上最具影响力的公告，在此之前，包括苹果内部人士在内的很少有人知道这个项目的存在。
- en: It was amazing, even by Apple's standards, that they were able to keep Swift
    a secret for as long as they could and that no one suspected they were going to
    announce a new development language. At WWDC 2015, Apple made another big splash
    when they announced Xcode 7 and Swift 2\. Swift 2 is a major enhancement to the
    Swift language. During that conference, Chris Lattner said that a lot of the enhancements
    were based on direct feedback that Apple received from the development community.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 即使按照苹果的标准来看，他们能够将 Swift 保密这么长时间，而且没有人怀疑他们将要宣布一种新的开发语言，这本身就是令人难以置信的。在 2015 年的
    WWDC 上，苹果再次引起轰动，当他们宣布了 Xcode 7 和 Swift 2。Swift 2 是 Swift 语言的重大增强。在这次会议上，克里斯·拉特纳表示，许多增强都是基于苹果从开发社区直接收到的反馈。
- en: Swift can be thought of as Objective-C reimagined using modern concepts and
    safe programming patterns. In Apple's own words, Swift is like Objective-C without
    the C. Chris Lattner, the creator of Swift, said Swift took language ideas from
    Objective-C, Rust, Haskell, Ruby, Python, C#, CLU, and far too many others to
    list. At WWDC 2014, Apple really stressed that Swift was safe by default. Swift
    was designed to eliminate many common programming errors, making applications
    more secure and less prone to bugs. Swift 2 added two additional core features
    to the language—availability and error handling—which are designed to make it
    even easier to write safe code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 可以被看作是使用现代概念和安全编程模式重新构思的 Objective-C。用苹果自己的话说，Swift 就是没有 C 的 Objective-C。Swift
    的创造者克里斯·拉特纳说，Swift 从 Objective-C、Rust、Haskell、Ruby、Python、C#、CLU 以及太多其他语言中汲取了语言理念。在
    2014 年的 WWDC 上，苹果强调 Swift 默认是安全的。Swift 被设计用来消除许多常见的编程错误，使应用程序更加安全，更不容易出现错误。Swift
    2 为语言增加了两个额外的核心功能——可用性和错误处理，这些功能旨在使编写安全代码变得更加容易。
- en: The development of Swift started in 2010 by Chris. He implemented much of the
    basic language structure with only a few people being aware of its existence.
    It wasn't until late 2011 that other developers began to really contribute to
    Swift and in July of 2013, it became a major focus of the Apple Developer Tools
    group.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 的发展始于 2010 年，由克里斯发起。他仅用少数人意识到其存在的情况下，实现了大部分基本语言结构。直到 2011 年晚些时候，其他开发者才开始真正为
    Swift 做出贡献，并在 2013 年 7 月，它成为了苹果开发者工具组的主要关注点。
- en: Chris started working at Apple in the summer of 2005\. He has held several positions
    in the Developers Tools group, and is currently the director and architect of
    that group. On his home page ([http://www.nondot.org/sabre/](http://www.nondot.org/sabre/)),
    he notes that Xcode's Playgrounds (read more on Playgrounds a little later in
    this chapter) became a personal passion of his because it makes programming more
    interactive and approachable. We will be using Playgrounds a lot in the book as
    a test and experimentation platform.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 克里斯于 2005 年夏天开始在苹果公司工作。他在开发者工具组中担任过多个职位，目前是该组的总监和架构师。在他的主页（[http://www.nondot.org/sabre/](http://www.nondot.org/sabre/））上，他提到
    Xcode 的 Playgrounds（本章稍后将对 Playgrounds 进行更多介绍）成为了他个人的热情所在，因为它使编程更加互动和易于接近。本书中将大量使用
    Playgrounds 作为测试和实验平台。
- en: There are a lot of similarities between Swift and Objective-C. Swift adopts
    the readability of Objective-C's named parameters and dynamic object model. When
    we refer to Swift as having a dynamic object model, we are referring to the ability
    for types to change at runtime. This includes adding new (custom) types and changing/extending
    the existing types.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 和 Objective-C 之间有很多相似之处。Swift 采用了 Objective-C 的命名参数和动态对象模型的可读性。当我们说 Swift
    拥有动态对象模型时，我们指的是类型在运行时可以改变的能力。这包括添加新的（自定义）类型以及修改/扩展现有类型。
- en: Swift also provides seamless access to the existing Cocoa and Cocoa Touch frameworks.
    This gives Objective-C developers a certain amount of familiarity when they begin
    to learn Swift because how these frameworks functioned with Objective-C is how
    they function with Swift.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 还提供了对现有 Cocoa 和 Cocoa Touch 框架的无缝访问。这使得 Objective-C 开发者在开始学习 Swift 时感到一定的熟悉感，因为这些框架与
    Objective-C 的功能方式与它们与 Swift 的功能方式相同。
- en: While there are a lot of similarities between Swift and Objective-C, there are
    significant differences between them as well. Swift's syntax and formatting are
    a lot closer to Python than Objective-C, but Apple did keep the curly braces.
    I know Python people would disagree with me, and that is all right because we
    all have different opinions, but I like the curly braces. Swift actually makes
    the curly braces required for control statements, such as `if` and `while`, which
    eliminates bugs, such as the `goto fail`, in Apple's SSL library.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Swift 和 Objective-C 之间有很多相似之处，但它们之间也存在一些显著的区别。Swift 的语法和格式与 Python 相比更接近，但苹果公司仍然保留了花括号。我知道
    Python 的人可能会不同意我，这完全可以，因为我们都持有不同的观点，但我喜欢花括号。Swift 实际上要求控制语句（如 `if` 和 `while`）使用花括号，这消除了像苹果
    SSL 库中的 `goto fail` 这样的错误。
- en: Swift was also built to be fast. At WWDC 2014, Apple showed a number of benchmarks,
    which proved that Swift significantly outperformed Objective-C. Swift uses the
    LLVM compiler, which is included with Xcode 7 to transform the Swift code into
    highly optimized native code that is tuned to get the most out of Apple's modern
    hardware.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 还被设计成快速。在 2014 年的 WWDC 上，苹果展示了一系列基准测试，证明了 Swift 在性能上显著优于 Objective-C。Swift
    使用 LLVM 编译器，该编译器包含在 Xcode 7 中，将 Swift 代码转换为高度优化的本地代码，以充分利用苹果的现代硬件。
- en: 'If you are an iOS or OS X developer and you are still not convinced that learning
    Swift is a good idea, then maybe this one paragraph from Apple''s Swift page ([https://developer.apple.com/swift/](https://developer.apple.com/swift/))
    will help convince you:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名 iOS 或 OS X 开发者，并且你仍然没有确信学习 Swift 是一个好主意，那么苹果 Swift 页面（[https://developer.apple.com/swift/](https://developer.apple.com/swift/））上的这一段话可能会帮助你信服：
- en: '*"Swift is a successor to the C and Objective-C languages. It includes low-level
    primitives such as types, flow control, and operators. It also provides object-oriented
    features such as classes, protocols, and generics, giving Cocoa and Cocoa Touch
    developers the performance and power they demand."*'
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"Swift 是 C 和 Objective-C 语言的继承者。它包括低级原语，如类型、流程控制和运算符。它还提供了面向对象的功能，如类、协议和泛型，为
    Cocoa 和 Cocoa Touch 开发者提供了他们所需求的高性能和强大功能。"*'
- en: The first line in that paragraph, which says that Swift is a successor to the
    C and Objective-C languages, is the most important line. This line and other Apple
    documentation tell us that Apple sees the Swift language as its application and
    systems programming language of the future. While Objective-C is not going away
    anytime soon, it sounds like it will be taking a backseat to Swift in the very
    near future.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 那段话的第一行，说 Swift 是 C 和 Objective-C 语言的继承者，是最重要的一行。这一行和其他苹果公司的文档告诉我们，苹果公司认为 Swift
    语言是其未来的应用程序和系统编程语言。虽然 Objective-C 在不久的将来不会消失，但它听起来在不久的将来将让位给 Swift。
- en: Swift features
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Swift 功能
- en: When Apple said that Swift is Objective-C without the C, they were really only
    telling us half of the story. Objective-C is a superset of C and provides object-oriented
    capabilities and a dynamic runtime to the C language. This meant that Apple needed
    to maintain compatibility with C, which limited the enhancements it could make
    to the Objective-C language. As an example, Apple could not change how the `switch`
    statement functioned and still maintains the C compatibility.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当苹果公司说 Swift 是没有 C 的 Objective-C 时，他们实际上只告诉我们了一半的故事。Objective-C 是 C 的超集，并为 C
    语言提供了面向对象的能力和动态运行时。这意味着苹果公司需要与 C 语言保持兼容性，这限制了它对 Objective-C 语言的增强。例如，苹果公司不能改变
    `switch` 语句的功能，同时还要保持与 C 的兼容性。
- en: Since Swift did not need to maintain the same C compatibility as Objective-C,
    Apple was free to add any feature/enhancement to the language. This allowed Apple
    to include the best features from many of today's most popular and modern languages,
    such as Objective-C, Python, Java, Ruby, C#, Haskell, and many others.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Swift 不需要像 Objective-C 那样保持相同的 C 兼容性，苹果公司可以自由地向语言添加任何功能/增强。这使得苹果公司能够包含当今许多最受欢迎和现代语言的最佳功能，例如
    Objective-C、Python、Java、Ruby、C#、Haskell 以及许多其他语言。
- en: 'The following chart shows a list of some of the most exciting enhancements
    that Swift includes:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了 Swift 包含的一些最令人兴奋的增强功能列表：
- en: '| Swift feature | Description |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| Swift 功能 | 描述 |'
- en: '| --- | --- |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Type inference | Swift can automatically deduce the type of the variable
    or constant, based on the initial value. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 类型推断 | Swift 可以根据初始值自动推断变量或常量的类型。|'
- en: '| Generics | Generics allow us to write code only once to perform identical
    tasks for different types of objects. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 泛型 | 泛型允许我们只编写一次代码，为不同类型的对象执行相同任务。|'
- en: '| Collection mutability | Swift does not have separate objects for mutable
    or non-mutable containers. Instead, you define mutability by defining the container
    as a constant or variable. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 集合可变性 | Swift 没有为可变或不可变容器提供单独的对象。相反，你通过定义容器为常量或变量来定义可变性。|'
- en: '| Closure syntax | Closures are self-contained blocks of functionality that
    can be passed around and used in our code. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 闭包语法 | 闭包是包含功能性的自包含块，可以在我们的代码中传递和使用。|'
- en: '| Optionals | Optionals define a variable that might not have a value. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 可选类型 | 可选类型定义了一个可能没有值的变量。|'
- en: '| Switch statement | The Switch statement has been drastically improved. This
    is one of my favorite improvements. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| Switch 语句 | Switch 语句得到了大幅改进。这是我最喜欢的改进之一。|'
- en: '| Multiple return types | Functions can have multiple return types using tuples.
    |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 多重返回类型 | 函数可以使用元组来拥有多个返回类型。|'
- en: '| Operator overloading | Classes can provide their own implementation of the
    existing operators. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 运算符重载 | 类可以提供现有运算符的自己的实现。|'
- en: '| enums with Associated values | In Swift, we can do a lot more than just defining
    a group of related values with enumerations. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 带关联值的枚举 | 在 Swift 中，我们可以使用枚举做很多不仅仅是定义一组相关值的事情。|'
- en: There is one feature that I did not mention in the preceding chart because it
    is technically not a feature of Swift; it is a feature of Xcode and the compiler.
    This feature is **Mix and Match**, which allows us to create applications that
    contain both Objective-C and Swift files. It also allows us to systematically
    update the current Objective-C applications with Swift classes and use current
    Objective-C libraries/frameworks in our Swift applications.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，我没有提到的一个功能是因为它从技术上讲不是 Swift 的功能；它是 Xcode 和编译器的功能。这个功能是 **混合匹配**，它允许我们创建包含
    Objective-C 和 Swift 文件的应用程序。它还允许我们系统地使用 Swift 类更新当前的 Objective-C 应用程序，并在我们的 Swift
    应用程序中使用当前的 Objective-C 库/框架。
- en: Tip
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Mix and Match lets Objective-C and Swift files coexist in the same project.
    This allows us to begin using Swift without throwing away our existing Objective-C
    code base or projects.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 混合匹配让 Objective-C 和 Swift 文件可以在同一个项目中共存。这允许我们开始使用 Swift，而无需丢弃现有的 Objective-C
    代码库或项目。
- en: Before we begin our journey into the wonderful world of Swift development, let's
    take a detour and visit a place that I have loved ever since I was a kid—the playground.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始探索 Swift 开发的奇妙世界之前，让我们绕道访问一个自从我还是个孩子就喜欢的地点——操场。
- en: Playgrounds
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Playgrounds
- en: When I was a kid, the best part of the school day was going to the playground.
    It really did not matter what we were playing; as long as we were on the playground,
    I knew it would be fun. When Apple introduced Playgrounds as part of Xcode 6,
    I was excited just by the name, but I wondered if Apple could make its Playground
    as fun as the playgrounds from my youth. While Apple's Playgrounds might not be
    as fun as playing kickball when I was 9 years old, it definitely brings a lot
    of fun back to experimenting and playing with code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当我还是个孩子的时候，学校一天中最美好的时光就是去操场。我们玩什么并不重要；只要我们在操场上，我就知道那会很有趣。当苹果公司在 Xcode 6 中引入
    Playgrounds 作为其一部分时，单是这个名字就让我兴奋不已，但我怀疑苹果能否让它的 Playgrounds 和我童年的操场一样有趣。虽然苹果的 Playgrounds
    可能不如我 9 岁时踢足球那么有趣，但它确实让实验和代码玩耍变得很有趣。
- en: Getting started with Playgrounds
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用 Playgrounds
- en: Playgrounds are interactive work environments that let us write code and see
    the results immediately. As changes are made to the code, the results also change
    in real time. This means that Playgrounds are a great way to learn and experiment
    with Swift.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Playgrounds 是交互式的工作环境，让我们能够编写代码并立即看到结果。随着代码的更改，结果也会实时更改。这意味着 Playgrounds 是学习和实验
    Swift 的绝佳方式。
- en: Playgrounds also make it incredibly easy to try out the new APIs, prototype
    new algorithms, and demonstrate how code works. We will be using Playgrounds throughout
    this book to show how our sample code works. Therefore, before we really get into
    Swift development, let's spend some time learning about and getting comfortable
    with Playgrounds.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Playgrounds 还使得尝试新的 API、原型化新的算法以及展示代码的工作方式变得极其简单。我们将在这本书中使用 Playgrounds 来展示我们的示例代码是如何工作的。因此，在我们真正开始
    Swift 开发之前，让我们花些时间学习和熟悉 Playgrounds。
- en: Do not worry if the Swift code does not make a lot of sense right now, as we
    go through the book, this code will begin to make sense. We are simply trying
    to get a feel of Playgrounds right now.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在 Swift 代码看起来没有太多意义，请不要担心，随着我们阅读本书，这段代码将会变得有意义。我们只是现在试图对 Playgrounds 有一个感觉。
- en: 'A Playground can have several sections, but the three that we will be using
    in this book are:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Playgrounds 可以有多个部分，但在这本书中我们将使用的是以下三个：
- en: '**Coding Area**: This is where you enter your Swift code.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编码区域**：这是你输入 Swift 代码的地方。'
- en: '**Results Sidebar**: This is where the results of your code are shown. Each
    time you type in a new line of code, the results are re-evaluated and the results''
    sidebar is updated with the new results.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结果侧边栏**：这是显示你代码结果的地方。每次你输入一行新代码时，结果都会重新评估，并且结果侧边栏会更新为新结果。'
- en: '**Debug Area**: This area displays the output of the code, and it can be very
    useful for debugging.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试区域**：这个区域显示代码的输出，这对于调试非常有用。'
- en: 'The following screenshot shows how the sections are arranged in a Playground:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了 Playgrounds 中部分的排列方式：
- en: '![Getting started with Playgrounds](img/B05115_01_01.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用 Playgrounds](img/B05115_01_01.jpg)'
- en: 'Let''s start a new Playground. The first thing we need to do is to start Xcode.
    Once Xcode has started, we can select the **Get started with a playground** option,
    as shown in the following screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始一个新的 Playgrounds。我们首先需要做的是启动 Xcode。一旦 Xcode 启动，我们可以选择**开始使用 Playgrounds**选项，如下面的截图所示：
- en: '![Getting started with Playgrounds](img/B05115_01_02.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用 Playgrounds](img/B05115_01_02.jpg)'
- en: 'Alternatively, we can navigate to the Playground by going to **File** | **New**
    from the top menu bar, as shown in the following screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以通过从顶部菜单栏的**文件** | **新建**进入 Playgrounds，如下面的截图所示：
- en: '![Getting started with Playgrounds](img/B05115_01_03.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用 Playgrounds](img/B05115_01_03.jpg)'
- en: Next, we should see a screen similar to the following screenshot that lets us
    name our Playground and select whether the Playground is an **iOS** or **OS X**
    Playground.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该看到一个类似于以下截图的屏幕，允许我们命名我们的 Playgrounds 并选择它是一个**iOS**还是**OS X** Playgrounds。
- en: 'For most of the examples in this book, it is safe to assume that you can select
    either **iOS** or **OS X** unless it is otherwise noted:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的大部分示例中，除非另有说明，否则可以安全地假设你可以选择**iOS**或**OS X**：
- en: '![Getting started with Playgrounds](img/B05115_01_04.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用Playgrounds](img/B05115_01_04.jpg)'
- en: 'Finally, we are asked for the location to save our Playground. After we select
    the location, the Playground will open up and look similar to the following screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们会询问保存Playground的位置。在选择了位置之后，Playground将打开并看起来类似于以下屏幕截图：
- en: '![Getting started with Playgrounds](img/B05115_01_05.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用Playgrounds](img/B05115_01_05.jpg)'
- en: In the preceding screenshot, we can see that the coding area of the Playground
    looks similar to the coding area for an Xcode project. What is different here
    is the sidebar on the right-hand side. This sidebar is where the results of our
    code are shown. The code in the previous screenshot imports iOS' UIKit framework
    and sets a variable named `str` to the string, `Hello, playground`. You can see
    the content of the `str` string in the sidebar to the right of the code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到Playground的编码区域看起来与Xcode项目的编码区域相似。这里不同的是右侧的侧边栏。这个侧边栏是我们代码结果显示的地方。前一个屏幕截图中的代码导入了iOS的UIKit框架，并将一个名为`str`的变量设置为字符串`Hello,
    playground`。你可以在代码右侧的侧边栏中看到`str`字符串的内容。
- en: By default, a new Playground does not open the debug area. You can open it manually
    by pressing the *shift* + *command* + *Y* keys together. Later in the chapter,
    we will see why the debug area is so useful.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，新的Playground不会打开调试区域。你可以通过同时按下*shift* + *command* + *Y*键来手动打开它。在章节的后面，我们将看到为什么调试区域如此有用。
- en: iOS and OS X Playgrounds
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: iOS和OS X Playgrounds
- en: When you start a new iOS Playground, the Playground imports UIKit (Cocoa Touch).
    This gives us access to the UIKit framework that provides the core infrastructure
    for iOS applications. When we start a new OS X Playground, the Playground imports
    Cocoa. This gives us access to the OS X Cocoa framework.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动一个新的iOS Playground时，Playground会导入UIKit（Cocoa Touch）。这使我们能够访问为iOS应用程序提供核心基础设施的UIKit框架。当我们启动一个新的OS
    X Playground时，Playground会导入Cocoa。这使我们能够访问OS X Cocoa框架。
- en: What the last paragraph means is if we want to experiment with the specific
    features of either UIKit or Cocoa, we will need to open the correct Playground.
    As an example, if we have an iOS Playground open and we want to create an object
    that represents a color, we would use a `UIColor` object. If we had an OS X playground
    open, we would use an `NSColor` object to represent a color.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一段的意思是，如果我们想实验UIKit或Cocoa的特定功能，我们需要打开正确的Playground。例如，如果我们有一个iOS Playground打开，并且我们想创建一个表示颜色的对象，我们会使用一个`UIColor`对象。如果我们有一个OS
    X playground打开，我们会使用一个`NSColor`对象来表示颜色。
- en: Showing images in a Playground
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Playground中显示图片
- en: As you will see throughout this book, Playgrounds are great at showing the results
    of code as text in the results sidebar. However, they can also do a lot more than
    just text, such as images, graphs, and display views. Let's take a look at how
    we would show an image in a Playground. The first thing we need to do is to load
    the image into the resource directory of our Playground.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在整本书中看到的那样，Playgrounds擅长在结果侧边栏中以文本形式显示代码的结果。然而，它们还能做很多不仅仅是文本的事情，比如图片、图表和显示视图。让我们看看如何在Playground中显示一个图片。首先，我们需要做的是将图片加载到Playground的资源目录中。
- en: 'The following steps show how to load an image into the resource directory:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了如何将图片加载到资源目录中：
- en: Let's begin by showing the project navigator sidebar. To do this, in the top
    menu bar, navigate to **View** | **Navigators** | **Show Project Navigator** or
    use the *command* + *1* keyboard shortcut. The project navigator looks similar
    to this:![Showing images in a Playground](img/B05115_01_06.jpg)
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从显示项目导航器侧边栏开始。要做到这一点，在顶部菜单栏中，导航到**视图** | **导航器** | **显示项目导航器**或使用*command*
    + *1*键盘快捷键。项目导航器看起来像这样：![在Playground中显示图片](img/B05115_01_06.jpg)
- en: Once we have the Project Navigator open, we can drag the image into the `Resources`
    folder so that we can access it from our code. Once we drag the image file over
    it and drop it, it will appear in the `Resources` folder, as shown here:![Showing
    images in a Playground](img/B05115_01_07.jpg)
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们打开了项目导航器，我们可以将图片拖入`Resources`文件夹，这样我们就可以在代码中访问它。一旦我们将图片文件拖到上面并放下，它就会出现在`Resources`文件夹中，如图所示：![在Playground中显示图片](img/B05115_01_07.jpg)
- en: Now, we can access the image that is in our `Resources` folder within our code.
    The following screenshot shows how we would do this. The actual code that we use
    to access the image is not as important at this time as knowing how to access
    resources within a playground:![Showing images in a Playground](img/B05115_01_08.jpg)
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以访问代码中 `Resources` 文件夹内的图片。以下截图显示了如何进行操作。我们使用来访问图片的实际代码在此阶段并不那么重要，重要的是要知道如何在沙盒中访问资源：![在沙盒中显示图片](img/B05115_01_08.jpg)
- en: To view the image, we need to hover our cursor in the results sidebar over the
    section that shows the width and height of the image. In our example, the width
    and height section shows **w 256 h 256**. Once we hover the mouse pointer over
    the width and height, we should see two symbols, as shown in the following screenshot:![Showing
    images in a Playground](img/B05115_01_09.jpg)
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看图片，我们需要将鼠标光标悬停在结果侧边栏中显示图片宽度和高度的章节上。在我们的例子中，宽度和高度部分显示为 **w 256 h 256**。一旦我们将鼠标指针悬停在宽度和高度上，我们应该看到两个符号，如下面的截图所示：![在沙盒中显示图片](img/B05115_01_09.jpg)
- en: We can press either of the symbols to show the image. The one that is shaped
    like a circle with a plus sign in it will display the image within the playground's
    code section, while the one that looks like an eye will pop the image up outside
    the playground. The following screenshot shows what it shows if we press the circle
    with a plus sign in it:![Showing images in a Playground](img/B05115_01_10.jpg)
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以按任意一个符号来显示图片。形状像带加号的圆圈的符号将在沙盒的代码部分显示图片，而看起来像眼睛的符号则会在沙盒外部弹出图片。以下截图显示了按下带加号的圆圈时显示的内容：![在沙盒中显示图片](img/B05115_01_10.jpg)
- en: Having the ability to create and display graphs can be very useful when we want
    to see the progression of our code. Let's look at how we can create and display
    graphs in a playground.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要看到代码的进展时，能够创建和显示图表非常有用。让我们看看如何在沙盒中创建和显示图表。
- en: Creating and displaying graphs in Playgrounds
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在沙盒中创建和显示图表
- en: We can also graph the value of numeric variables over time. This feature is
    really useful when we are prototyping new algorithms because it allows us to see
    the value of the variable throughout the course of the calculations.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在时间上绘制数值变量的值。当我们在原型设计新算法时，这个特性非常有用，因为它允许我们查看变量在整个计算过程中的值。
- en: 'To see how graphing works, take a look at the following Playground:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解图表是如何工作的，请查看以下沙盒：
- en: '![Creating and displaying graphs in Playgrounds](img/B05115_01_11.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![在沙盒中创建和显示图表](img/B05115_01_11.jpg)'
- en: In this playground, we set the variable `j` to `1`. Next, we create a `for`
    loop that assigns numbers `1` through `5` to the variable `i`. At each step in
    the `for` loop, we set the value of the variable `j` to the current value of `j`
    multiplied by `i`. The graph shows the values of the variable `j` at each step
    of the `for` loop. We will be covering `for` loops in detail later in this book.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个沙盒中，我们将变量 `j` 设置为 `1`。接下来，我们创建一个 `for` 循环，将数字 `1` 到 `5` 分配给变量 `i`。在 `for`
    循环的每个步骤中，我们将变量 `j` 的值设置为当前 `j` 的值乘以 `i`。图表显示了 `for` 循环每个步骤中变量 `j` 的值。我们将在本书的后面详细讲解
    `for` 循环。
- en: To bring up the graph, click on the symbol that is shaped like a circle with
    a dot in it. We can then move the timeline slider to see the values of variable
    `j` at each step of the `for` loop.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示图表，请点击形状像带点的圆圈的符号。然后我们可以移动时间轴滑块来查看变量 `j` 在 `for` 循环的每个步骤的值。
- en: What Playgrounds are not
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是沙盒不是
- en: There is a lot more that we can do with Playgrounds, and we have only scratched
    the surface in our quick introduction here. As we proceed through the book, we
    will be using Playgrounds for almost all of the sample code and demonstrate other
    features of Playgrounds as they are used.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用沙盒做很多事情，而我们在这里的快速介绍中只是触及了皮毛。随着我们继续阅读本书，我们将几乎在所有示例代码中使用沙盒，并展示沙盒的其他功能，正如它们被使用时一样。
- en: 'Before we leave this brief introduction, let''s take a look at what Playgrounds
    are not so that we can understand when not to use Playgrounds:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束这个简短的介绍之前，让我们看看沙盒不是什么，这样我们就可以了解何时不使用沙盒：
- en: 'Playgrounds should not be used for performance testing: The performance you
    see from any code that is run in a Playground is not representative of how fast
    the code will run when it is in your projects'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沙盒不应该用于性能测试：在沙盒中运行的任何代码的性能并不能代表代码在项目中的运行速度
- en: 'Playgrounds do not support user interaction: Users cannot interact with code
    that is run in a Playground'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Playgrounds不支持用户交互：用户不能与在Playground中运行的代码进行交互
- en: 'Playgrounds do not support on-device execution: You cannot run the code that
    is present in a Playground as an external application or on an external device'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Playgrounds不支持设备上的执行：你不能将Playground中存在的代码作为外部应用程序或在外部设备上运行
- en: Swift language syntax
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Swift语言语法
- en: If you are an Objective-C developer, and you are not familiar with modern languages
    such as Python or Ruby, the code in the previous screenshots may have looked pretty
    strange. The Swift language syntax is a huge departure from Objective-C, which
    was based largely on Smalltalk and C.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个Objective-C开发者，并且你对现代语言如Python或Ruby不熟悉，那么之前截图中的代码可能看起来相当奇怪。Swift语言的语法与基于Smalltalk和C的Objective-C有很大的不同。
- en: The Swift language uses very modern concepts and syntax to create very concise
    and readable code. There was also a heavy emphasize on eliminating common programming
    mistakes. Before we get into the Swift language itself, let's take a look at some
    of the basic syntax of the Swift language.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Swift语言使用非常现代的概念和语法来创建非常简洁和可读的代码。还非常强调消除常见的编程错误。在我们深入了解Swift语言本身之前，让我们看看Swift语言的一些基本语法。
- en: Comments
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释
- en: Writing comments in Swift code is a little different from writing comments in
    Objective-C code. We still use the double slash `//` for single line comments
    and the `/*` and `*/` for multiline comments.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift代码中编写注释与在Objective-C代码中编写注释略有不同。我们仍然使用双斜杠`//`进行单行注释，使用`/*`和`*/`进行多行注释。
- en: What has changed is how we document the parameters and the return value. To
    document any parameter, we use the `:parm:` field, and for the return value, we
    use the `:return:` field.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 发生变化的是我们如何记录参数和返回值。要记录任何参数，我们使用`:parm:`字段，而对于返回值，我们使用`:return:`字段。
- en: 'The following Playground shows examples of both single line and multiline comments
    to properly comment a function:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的Playground展示了如何正确注释函数的示例，包括单行和多行注释：
- en: '![Comments](img/B05115_01_12.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![注释](img/B05115_01_12.jpg)'
- en: To write good comments, I would recommend using single line comments within
    a function to give quick one-line explanations of your code. We will then use
    the multiline comments outside of functions and classes to explain what the function
    and class does. The preceding Playground shows a good use of comments. By using
    proper documentation, as we did in the preceding screenshot, we can use the documentation
    feature within Xcode. If we hold down the *option* key and then click on the function
    name anywhere in our code, Xcode will display a popup with the description of
    the function.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写好的注释，我建议在函数内部使用单行注释，以快速给出代码的一行解释。然后我们将使用函数和类外部多行注释来解释函数和类的作用。前面的Playground展示了注释的良好使用。通过使用适当的文档，就像我们在前面的截图中所做的那样，我们可以在Xcode中使用文档功能。如果我们按住*option*键然后点击代码中的任何地方的功能名，Xcode将显示一个弹出窗口，显示函数的描述。
- en: 'This next screenshot shows what that popup would look similar to:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个截图显示了该弹出窗口可能看起来类似的样子：
- en: '![Comments](img/B05115_01_13.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![注释](img/B05115_01_13.jpg)'
- en: 'This screenshot shows the documentation feature of Xcode if we hold down the
    `option` key and then click on the `myAdd()` method. We can see that the documentation
    contains five fields. These fields are:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这张截图显示了如果我们按住`option`键然后点击`myAdd()`方法，Xcode的文档功能。我们可以看到文档包含五个字段。这些字段是：
- en: '**Declaration**: This is the function''s declaration'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明**：这是函数的声明'
- en: '**Description**: This is the description of the function as it appears in the
    comments'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**：这是函数在注释中出现的描述'
- en: '**Parameters**: The parameter descriptions are prefixed with the `:param:`
    tag in the comment section'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数**：参数描述在注释部分以`:param:`标签开头'
- en: '**Returns**: The return description is prefixed with the `:return:` tag in
    the comment section'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回**：返回描述在注释部分以`:return:`标签开头'
- en: '**Declared In**: This is the file that the function is declared in so that
    we can easily find it'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明于**：这是函数声明的文件，这样我们就可以轻松找到它'
- en: Semicolons
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分号
- en: 'You may have probably noticed, from the code samples so far, that we are not
    using semicolons at the end of lines. The semicolons are optional in Swift; therefore,
    both lines in the following Playground are valid in Swift. You can see the results
    of the code in the results sidebar, as shown in the following screenshot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了，到目前为止的代码示例中，我们没有在行尾使用分号。在 Swift 中，分号是可选的；因此，以下 Playground 中的两行在 Swift
    中都是有效的。你可以在结果侧边栏中看到代码的结果，如下面的截图所示：
- en: '![Semicolons](img/B05115_01_14.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![分号](img/B05115_01_14.jpg)'
- en: For style purposes, it is strongly recommended that you do not use semicolons
    in your Swift code. If you are really set on using semicolons in your code, then
    be consistent and use them on every line of code; however, Swift will not warn
    you if you forget them. I will stress again, that it is recommended that you do
    not use semicolons in Swift.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了风格上的考虑，强烈建议你在 Swift 代码中不要使用分号。如果你真的想在代码中使用分号，那么请保持一致性，并在每一行代码中使用它们；然而，Swift
    不会警告你如果忘记了分号。我再次强调，建议你在 Swift 中不要使用分号。
- en: Parentheses
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 括号
- en: 'In Swift, parentheses around conditional statements are optional, for example,
    both `if` statements in the following Playground are valid. You can see the results
    of the code in the sidebar, as shown in the following screenshot:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，条件语句周围的括号是可选的，例如，以下 Playground 中的两个 `if` 语句都是有效的。你可以在侧边栏中看到代码的结果，如下面的截图所示：
- en: '![Parentheses](img/B05115_01_15.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![括号](img/B05115_01_15.jpg)'
- en: For style purposes, it is recommended that you do not include the parentheses
    in your code unless you have multiple conditional statements on the same line.
    For readability purposes, it is good practice to put parentheses around the individual
    conditional statements that are on the same line.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了风格上的考虑，建议你除非在同一行上有多个条件语句，否则不要在代码中包含括号。为了可读性，将括号放在同一行上的单个条件语句周围是一个好的做法。
- en: 'See the following Playground for samples:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下 Playground 中的示例：
- en: '![Parentheses](img/B05115_01_16.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![括号](img/B05115_01_16.jpg)'
- en: Curly braces
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大括号
- en: In Swift, unlike most other languages, the curly bracket is required after statements.
    This is one of the safety features that are built into Swift. Arguably, there
    have been numerous security bugs that may have been prevented if the developer
    would have used curly braces. A good example of this is Apple's `goto fail` bug.
    These bugs could also have been prevented by other means such as unit testing
    and code reviews, but requiring developers to use curly braces, in my opinion,
    is a good security standard.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，与大多数其他语言不同，语句后面需要大括号。这是 Swift 中内置的安全特性之一。可以说，如果开发者使用了大括号，可能已经避免了无数的安全漏洞。一个很好的例子是苹果的
    `goto fail` 漏洞。这些漏洞也可以通过其他方式预防，例如单元测试和代码审查，但在我看来，要求开发者使用大括号是一个好的安全标准。
- en: 'The following Playground shows you what error you get if you forget to include
    the curly braces:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 Playground 显示了如果你忘记包含大括号会得到什么错误：
- en: '![Curly braces](img/B05115_01_17.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![大括号](img/B05115_01_17.jpg)'
- en: An assignment operator does not return a value
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值运算符不返回值
- en: 'In most other languages, the following line of code is valid, but it probably
    is not what the developer meant to do:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数其他语言中，以下代码行是有效的，但这可能不是开发者想要执行的操作：
- en: '[PRE0]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你购买的所有 Packt 出版物书籍的账户中下载示例代码文件。[http://www.packtpub.com](http://www.packtpub.com)。如果你在其他地方购买了这本书，你可以访问
    [http://www.packtpub.com/support](http://www.packtpub.com/support) 并注册以直接将文件通过电子邮件发送给你。
- en: 'In Swift, this statement is not valid. Using an assignment operator (`=`) in
    a conditional statement (`if` and `while`) will throw an error. This is another
    safety feature built into Swift. It prevents the developer from forgetting the
    second equals sign (`=`) in a comparison statement. This error is shown in the
    following Playground:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，这个语句是无效的。在条件语句（`if` 和 `while`）中使用赋值运算符（`=`）会引发错误。这是 Swift 中内置的另一个安全特性。它防止开发者忘记比较语句中的第二个等号（`=`）。以下
    Playground 中显示了此错误：
- en: '![An assignment operator does not return a value](img/B05115_01_18.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![赋值运算符不返回值](img/B05115_01_18.jpg)'
- en: Spaces are optional in conditional and assignment statements
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件语句和赋值语句中的空白是可选的
- en: 'For both conditional (`if` and `while`) and assignment (`=`) statements, the
    white spaces are optional. Therefore, in the following Playground, both `The i
    block` and `The j block` of code are valid:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于条件（`if`和`while`）和赋值（`=`）语句，空白是可选的。因此，在下面的Playground中，代码的`The i block`和`The
    j block`都是有效的：
- en: '![Spaces are optional in conditional and assignment statements](img/B05115_01_19.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![条件语句和赋值语句中的空白是可选的](img/B05115_01_19.jpg)'
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For style purposes, I would recommend adding the white spaces (such as `The
    j block` for readability purposes), but as long as you pick one style and be consistent,
    either style should be acceptable.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了风格上的考虑，我建议添加空白（例如，为了可读性，添加`The j block`），但只要您选择一种风格并保持一致，任何风格都应该是可以接受的。
- en: Hello World
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello World
- en: All good computer books that are written to teach a computer language have a
    section that shows a user how to write a Hello World application. This book is
    no exception. In this section, we will show you how to write two different Hello
    World applications.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 所有旨在教授计算机语言的优秀计算机书籍都有一个部分，展示了用户如何编写Hello World应用程序。这本书也不例外。在本节中，我们将向您展示如何编写两个不同的Hello
    World应用程序。
- en: Our fist Hello World application will be the traditional Hello World application
    that simply prints Hello World to the console. Let's begin by creating a new Playground
    and naming it `Chapter_1_Hello_World`. The Playground can be either an iOS or
    an OS X Playground.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一款Hello World应用程序将是传统的Hello World应用程序，它只是简单地打印Hello World到控制台。让我们首先创建一个新的Playground，并将其命名为`Chapter_1_Hello_World`。这个Playground可以是iOS或OS
    X的Playground。
- en: 'In Swift, to print a message to the console, we use the `print()` function.
    The `print()` function has been greatly enhanced in Swift 2\. Prior to Swift 2,
    we had two separate print functions: `print()` and `println()`. Now both of these
    functions have been combined into the single `print()` function.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，要将消息打印到控制台，我们使用`print()`函数。`print()`函数在Swift 2中得到了极大的增强。在Swift 2之前，我们有两个独立的print函数：`print()`和`println()`。现在这两个函数都被合并成了单个`print()`函数。
- en: 'In the most basic form, to print out a single message, we would use the print
    function as shown in the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的形式中，要打印一条单独的消息，我们会使用如下所示的print函数：
- en: '[PRE1]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Usually, when we use the `print()` function, we want to print more than just
    static text. We can include the value of variables and/or constants using a special
    sequence of characters, `\( )`, or by separating the values within the `print()`
    function with commas. The following code shows how to do this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们使用`print()`函数时，我们不仅想打印静态文本。我们可以使用特殊的字符序列`\( )`，或者通过在`print()`函数中用逗号分隔值，来包含变量的值和/或常量。以下代码展示了如何做到这一点：
- en: '[PRE2]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can also define two parameters in the print function that change how the
    message is displayed in the console. These parameters are the **separator** and
    **terminator** parameters. The separator parameter defines a string that is used
    to separate the values of the variables/constant in the `print()` function. By
    default, the `print()` function separates each variable/constant with a space.
    The terminator parameter defines what character is put at the end of the line.
    By default, the newline character is added at the end of the line.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在print函数中定义两个参数，这两个参数会改变消息在控制台中的显示方式。这些参数是**分隔符**和**终止符**参数。分隔符参数定义了一个字符串，用于在`print()`函数中分隔变量/常量的值。默认情况下，`print()`函数使用空格分隔每个变量/常量。终止符参数定义了在行尾放置的字符。默认情况下，会在行尾添加换行符。
- en: 'The following code shows how we would create a comma-separated list that does
    not have a newline character at the end:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何创建一个没有换行符结尾的逗号分隔列表：
- en: '[PRE3]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There is one other parameter that we can add to our `print()` function. This
    is the **toStream** parameter. This parameter will let us redirect the output
    of the `print()` function. In the following example, we redirect the output to
    a variable named `line`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以向我们的`print()`函数添加另一个参数。这是**toStream**参数。这个参数将允许我们将`print()`函数的输出重定向。在以下示例中，我们将输出重定向到名为`line`的变量：
- en: '[PRE4]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `print()` function use to simply be a useful tool for basic debugging, but
    now with the new enhanced `print()` function, we can use it for a lot more.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`print()`函数过去只是一个有用的基本调试工具，但现在随着新的增强`print()`函数，我们可以用它做更多的事情。'
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we showed you how to start and use Playgrounds to experiment
    with Swift programming. We also covered the basic Swift language syntax and discussed
    proper language styles. The chapter concluded with two Hello World examples.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您展示了如何启动和使用 Playgrounds 来进行 Swift 编程的实验。我们还介绍了 Swift 语言的基本语法，并讨论了合适的语言风格。本章以两个“Hello
    World”示例结束。
- en: In the next chapter, we will see how to use variables and constants in Swift.
    We will also look at the various data types and how to use operators in Swift.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解如何在 Swift 中使用变量和常量。我们还将探讨各种数据类型以及如何在 Swift 中使用运算符。
