["```swift\n    import SpriteKit\n\n    class HUD: SKNode {\n        var textureAtlas:SKTextureAtlas = \n            SKTextureAtlas(named:\"hud.atlas\")\n        // An array to keep track of the hearts:\n        var heartNodes:[SKSpriteNode] = []\n        // An SKLabelNode to print the coin score:\n        let coinCountText = SKLabelNode(text: \"000000\")\n    }\n    ```", "```swift\n    func createHudNodes(screenSize:CGSize) {\n        // --- Create the coin counter ---\n        // First, create and position a bronze coin icon:\n        let coinTextureAtlas:SKTextureAtlas = \n            SKTextureAtlas(named:\"goods.atlas\")\n        let coinIcon = SKSpriteNode(texture: \n            coinTextureAtlas.textureNamed(\"coin-bronze.png\"))\n        // Size and position the coin icon:\n        let coinYPos = screenSize.height - 23\n        coinIcon.size = CGSize(width: 26, height: 26)\n        coinIcon.position = CGPoint(x: 23, y: coinYPos)\n        // Configure the coin text label:\n        coinCountText.fontName = \"AvenirNext-HeavyItalic\"\n        coinCountText.position = CGPoint(x: 41, y: coinYPos)\n        // These two properties allow you to align the text\n        // relative to the SKLabelNode's position:\n        coinCountText.horizontalAlignmentMode = \n            SKLabelHorizontalAlignmentMode.Left\n        coinCountText.verticalAlignmentMode = \n            SKLabelVerticalAlignmentMode.Center\n        // Add the text label and coin icon to the HUD:\n        self.addChild(coinCountText)\n        self.addChild(coinIcon)\n\n        // Create three heart nodes for the life meter:\n        for var index = 0; index < 3; ++index {\n            let newHeartNode = SKSpriteNode(texture: \n                textureAtlas.textureNamed(\"heart-full.png\"))\n            newHeartNode.size = CGSize(width: 46, height: 40)\n            // Position the hearts below the coin counter:\n            let xPos = CGFloat(index * 60 + 33)\n            let yPos = screenSize.height - 66\n            newHeartNode.position = CGPoint(x: xPos, y: yPos)\n            // Keep track of nodes in an array property:\n            heartNodes.append(newHeartNode)\n            // Add the heart nodes to the HUD:\n            self.addChild(newHeartNode)\n        }\n    }\n    ```", "```swift\n    func setCoinCountDisplay(newCoinCount:Int) {\n        // We can use the NSNumberFormatter class to pad\n        // leading 0's onto the coin count:\n        let formatter = NSNumberFormatter()\n        formatter.minimumIntegerDigits = 6\n        if let coinStr = formatter.stringFromNumber(newCoinCount) {\n            // Update the label node with the new coin count:\n            coinCountText.text = coinStr\n        }\n    }\n    ```", "```swift\n    func setHealthDisplay(newHealth:Int) {\n        // Create a fade SKAction to fade out any lost hearts:\n        let fadeAction = SKAction.fadeAlphaTo(0.2, \n            duration: 0.3)\n        // Loop through each heart and update its status:\n        for var index = 0; index < heartNodes.count; ++index {\n            if index < newHealth {\n                // This heart should be full red:\n                heartNodes[index].alpha = 1\n            }\n            else {\n                // This heart should be faded:\n                heartNodes[index].runAction(fadeAction)\n            }\n        }\n    }\n    ```", "```swift\n    let hud = HUD()\n    ```", "```swift\n    // Create the HUD's child nodes:\n    hud.createHudNodes(self.size)\n    // Add the HUD to the scene:\n    self.addChild(hud)\n    // Position the HUD above any other game element\n    hud.zPosition = 50\n    ```", "```swift\n    case PhysicsCategory.ground.rawValue:\n        player.takeDamage()\n     hud.setHealthDisplay(player.health)\n    case PhysicsCategory.enemy.rawValue:\n        player.takeDamage()\n     hud.setHealthDisplay(player.health)\n\n    ```", "```swift\n    case PhysicsCategory.coin.rawValue:\n        // Try to cast the otherBody's node as a Coin:\n        if let coin = otherBody.node as? Coin {\n            coin.collect()\n            self.coinsCollected += coin.value\n     hud.setCoinCountDisplay(self.coinsCollected)\n        }\n    ```", "```swift\nimport SpriteKit\n\nclass Background: SKSpriteNode {\n    // movementMultiplier will store a float from 0-1 to indicate\n    // how fast the background should move past.\n    // 0 is full adjustment, no movement as the world goes past\n    // 1 is no adjustment, background passes at normal speed\n    var movementMultiplier = CGFloat(0)\n    // jumpAdjustment will store how many points of x position\n    // this background has jumped forward, useful for calculating\n    // future seamless jump points:\n    var jumpAdjustment = CGFloat(0)\n    // A constant for background node size:\n    let backgroundSize = CGSize(width: 1000, height: 1000)\n\n    func spawn(parentNode:SKNode, imageName:String, \n        zPosition:CGFloat, movementMultiplier:CGFloat) {\n        // Position from the bottom left:\n        self.anchorPoint = CGPointZero\n        // Start backgrounds at the top of the ground (y: 30)\n        self.position = CGPoint(x: 0, y: 30)\n        // Control the order of the backgrounds with zPosition:\n        self.zPosition = zPosition\n        // Store the movement multiplier:\n        self.movementMultiplier = movementMultiplier\n        // Add the background to the parentNode:\n        parentNode.addChild(self)\n\n        // Build three child node instances of the texture,\n        // Looping from -1 to 1 so the backgrounds cover both\n        // forward and behind the player at position zero.\n        // closed range operator: \"...\" includes both endpoints:\n        for i in -1...1 {\n            let newBGNode = SKSpriteNode(imageNamed: imageName)\n            // Set the size for this node from constant: \n            newBGNode.size = backgroundSize\n            // Position these nodes by their lower left corner:\n            newBGNode.anchorPoint = CGPointZero\n            // Position this background node:\n            newBGNode.position = CGPoint(\n                x: i * Int(backgroundSize.width), y: 0)\n            // Add the node to the Background:\n            self.addChild(newBGNode)\n        }\n    }\n\n    // We will call updatePosition every frame to\n    // reposition the background:\n    func updatePosition(playerProgress:CGFloat) {\n        // Calculate a position adjustment after loops and \n        // parallax multiplier:\n        let adjustedPosition = jumpAdjustment + playerProgress * \n            (1 - movementMultiplier)\n        // Check if we need to jump the background forward:\n        if playerProgress - adjustedPosition > \n            backgroundSize.width {\n            jumpAdjustment += backgroundSize.width\n        }\n        // Adjust this background forward as the world \n        // moves back so the background appears slower:\n        self.position.x = adjustedPosition\n    }\n}\n```", "```swift\n    var backgrounds:[Background] = []\n    ```", "```swift\n    // Instantiate four Backgrounds to the backgrounds array:\n    for i in 0...3 {\n        backgrounds.append(Background())\n    }\n    // Spawn the new backgrounds:\n    backgrounds[0].spawn(world, imageName: \"Background-1\", zPosition: -5, movementMultiplier: 0.75)\n    backgrounds[1].spawn(world, imageName: \"Background-2\", zPosition: -10, movementMultiplier: 0.5)\n    backgrounds[2].spawn(world, imageName: \"Background-3\", zPosition: -15, movementMultiplier: 0.2)\n    backgrounds[3].spawn(world, imageName: \"Background-4\", zPosition: -20, movementMultiplier: 0.1)\n    ```", "```swift\n    // Position the backgrounds:\n    for background in self.backgrounds {\n        background.updatePosition(playerProgress)\n    }\n    ```", "```swift\n// Instantiate a SKEmitterNode with the PierrePath design:\nlet dotEmitter = SKEmitterNode(fileNamed: \"PierrePath.sks\")\n// Place the particle zPosition behind the penguin:\ndotEmitter.particleZPosition = -1\n// By adding the emitter node to the player, the emitter will move \n// with the penguin and emit new dots wherever the player moves\nself.addChild(dotEmitter)\n// However, the particles themselves should attach to the world,\n// so they trail behind as the player moves forward.\n// (Note that self.parent refers to the world node)\ndotEmitter.targetNode = self.parent\n```", "```swift\n// Grant a momentary reprieve from gravity:\nself.physicsBody?.affectedByGravity = false\n// Add some slight upward velocity:\nself.physicsBody?.velocity.dy = 50\n// Create a SKAction to start gravity after a small delay:\nlet startGravitySequence = SKAction.sequence([\n    SKAction.waitForDuration(0.6),\n    SKAction.runBlock {\n        self.physicsBody?.affectedByGravity = true\n    }])\nself.runAction(startGravitySequence)\n```"]