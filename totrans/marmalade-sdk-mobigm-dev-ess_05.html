<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Animating 3D Graphics</h1></div></div></div><p>We've now seen how to create a 3D model and display it on the screen, but we're currently limited to non-animated models. Sure, we can rotate or scale to our heart's content, but that really doesn't cut it when you want to animate something more complex than a cube, say for example a human figure.</p><p>In this chapter we will be looking at the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A quick overview of the concepts involved in 3D animation</li><li class="listitem" style="list-style-type: disc">Exporting animations from a 3D modeling package</li><li class="listitem" style="list-style-type: disc">Loading and rendering an exported 3D animation in a Marmalade project</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec30"/>A quick 3D animation primer</h1></div></div></div><p>Let's start by<a id="id663" class="indexterm"/> looking at the ways in which animation of 3D models can be achieved.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec70"/>Animating with model matrices</h2></div></div></div><p>By far the simplest and <a id="id664" class="indexterm"/>most obvious way of animating a 3D model is to alter its position, orientation, and size. All three of these properties can be specified using the model matrix set at the time of rendering the model.</p><p>We could store a matrix in our game class, and for each frame multiply it by a second matrix representing the change in position, rotation, and scale; but this approach is generally not reliable. Over time the matrix starts to degrade due to the cumulative effect of precision errors in the multiplications and additions involved. The matrix will often end up becoming non-orthogonal (that is, its three axes are no longer at right angles to each other), which yields a shearing effect on the 3D model. The scale can also be affected by these precision errors, causing the 3D model to gradually shrink in size!</p><p>A far more reliable way is to store the translation, rotation, and scale separately, and calculate a fresh <a id="id665" class="indexterm"/>matrix for every frame. How this can be achieved is described in the following sections.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec59"/>Animating by translation</h3></div></div></div><p>Our game <a id="id666" class="indexterm"/>class simply needs to maintain a position vector containing the current world position of the object. We can move an in-game object around the world by adding a velocity vector that indicates how far the game object has moved in this frame and in what direction, with reference to the stored position vector.</p><p>To generate the final model matrix all we need to do is copy the position vector into the translation part of the matrix. We normally do this as the last step, as the act of multiplying matrices together when generating the rotation and scale will affect the translation of the matrix.</p><div><pre class="programlisting">// lTimeStep is the time elapsed since the last frame (here we're
// setting it to the time interval required to run at 30 frames
// per second).
float lTimeStep = 1.0f / 30.0f;

// Calculate how far we've moved this frame and update position
CIwFVec3 lVelocityStep = mVelocity * lTimeStep;
mPosition += lVelocityStep;

// Copy the position into the matrix used to render the model
mModelMatrix.t = mPosition;</pre></div></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec60"/>Animating by rotation</h3></div></div></div><p>The top left <a id="id667" class="indexterm"/>3 x 3 section of the model matrix specifies the rotation at which we want the model to be drawn. Our game object stores the required rotation and updates it on a frame-by-frame basis. When it is time to render, we just use the stored rotation to calculate the rotation matrix.</p><p>There are a number of ways in which the rotation of the object might be stored. Three of the most common ways are shown in the following section.</p><div><div><div><div><h4 class="title"><a id="ch05lvl4sec07"/>Rotation using Euler angles</h4></div></div></div><p>
<strong>Euler angles</strong> <a id="id668" class="indexterm"/>consist <a id="id669" class="indexterm"/>of the required angle of rotation in the x, y, and z axes, which we would normally store using a vector. If rotation is not desired around every axis, you may choose to store only those rotation values that you require.</p><p>Euler angles are quite easy to both visualize and implement, which is why they are used so often. To convert a set of Euler angles into a rotation matrix, all we need to do is generate three matrices for the rotations around each of the axes and then multiply them together.</p><p>However, this is <a id="id670" class="indexterm"/>
<a id="id671" class="indexterm"/>where the problem with Euler angles lies. Matrix multiplication yields different results depending on the order in which you multiply the matrices; so when using Euler angles, it is vital that you choose the order of multiplication carefully, depending on what you are trying to achieve. The following diagram shows an example to illustrate this:</p><div><img src="img/3363OT_05_01.jpg" alt="Rotation using Euler angles"/></div><p>In the diagram, we are rotating an arrow that points straight along the positive y axis. In the first row we rotate by 90 degrees around the z axis and then by 90 degrees around the y axis. The arrow ends up pointing along the z axis.</p><p>In the second row of the diagram, we take the same original arrow but apply the rotations in the opposite order. As you can see, this time the arrow finishes in the direction of the x axis.</p><p>The following code snippet shows how you can build up a complete rotation matrix for Euler angles <a id="id672" class="indexterm"/>
<a id="id673" class="indexterm"/>applied in the order XYZ:</p><div><pre class="programlisting">CIwFMat lMatXYZ;
lMatXYZ.SetRotX(xAngle);
lMatXYZ.PostRotateY(yAngle);
lMatXYZ.PostRotateZ(zAngle);</pre></div><div><div><h3 class="title"><a id="note33"/>Note</h3><p>All angles used in Marmalade are specified in radians, not degrees.</p></div></div></div><div><div><div><div><h4 class="title"><a id="ch05lvl4sec08"/>Rotation using axis-angle pairs</h4></div></div></div><p>The <strong>axis-angle</strong> method<a id="id674" class="indexterm"/>
<a id="id675" class="indexterm"/> of representing a rotation requires a direction vector and an angle of rotation to be stored. The vector represents the direction in which we want an object to be orientated, while the angle allows the object to be rotated around that axis.</p><p>We might find this way of specifying a rotation useful when dealing with player characters. For example, to orient a human character we might specify the direction vector as being the positive y axis, which then allows the angle of rotation to be used to change the heading of the character.</p><p>Marmalade allows us to convert an axis-angle pair into a matrix for rendering, as follows:</p><div><pre class="programlisting">CIwFVec3 lDir(0.0f, 1.0f, 0.0f);
float lAngle = PI / 2.0f;
CIwFMat lMat;
lMat.SetAxisAngle(lDir, lAngle);</pre></div></div><div><div><div><div><h4 class="title"><a id="ch05lvl4sec09"/>Rotation using quaternions</h4></div></div></div><p>A <strong>quaternion</strong> <a id="id676" class="indexterm"/>is yet another method of representing three-dimensional rotations, and is a concept that, when you first come across it, seems a little mind-blowing. Instead of going on about four dimensional hyperspheres and making parts of your brain melt, I'm just going to provide a quick guide to what you need to know in order to use quaternions. If you want to learn more about them, I suggest you search for "quaternions" on Google!</p><p>A quaternion consists of four <a id="id677" class="indexterm"/>components: x, y, z, and w. A 3D rotation is represented<a id="id678" class="indexterm"/> as a <strong>unit quaternion</strong>, which, in a similar manner to vectors, just means that the magnitude of the sum of the squares of all four components is one.</p><p>Multiplying two unit quaternions is similar to multiplying two rotation matrices together. The result represents the first orientation rotated by the second, and the result is different depending on the order in which you perform the multiplication.</p><p>The big problem with quaternions is that they are almost impossible to visualize. If given a set of Euler angles or an axis-angle pair, most people can form an image in their mind of what that rotation would look like, but the same can't be said of quaternions.</p><p>Quaternions <a id="id679" class="indexterm"/>
<a id="id680" class="indexterm"/>can however be created fairly easily from both a rotation matrix (and therefore Euler angles) and an axis-angle pair. The following diagram shows the relationship between the axis-angle pairs and quaternions:</p><div><img src="img/3363OT_05_02.jpg" alt="Rotation using quaternions"/></div><p>Quaternions really come into their own for 3D animation of boned characters, a topic we will be coming to later in this chapter. This is a technique that requires an awful lot of rotations to be calculated every time you want to update the animation frame, and luckily quaternions make this far more efficient in terms of both memory usage and execution speed.</p><p>While the theory behind quaternions may be a little scary for us mere mortals, there is really little need to worry about the math, as Marmalade provides us with a quaternion class,<a id="id681" class="indexterm"/> <code class="literal">CIwFQuat</code>, that we can use. As an example, creating a quaternion from an axis-angle pair and then producing a rotation matrix from it can be done as follows:</p><div><pre class="programlisting">CIwFQuat lQuat;
lQuat.SetAxisAngle(1.0f, 0.0f, 0.0f, PI / 2.0f);
CIwFMat lMat(lQuat);</pre></div></div></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec61"/>Animating by scaling</h3></div></div></div><p>The scaling <a id="id682" class="indexterm"/>factor is normally stored either as a vector containing the required size in the x, y, and z axes, or alternatively as a single scale value which is applied equally to each axis. Often the latter is sufficient, as models tend to look odd when they are not scaled uniformly in each axis.</p><p>A scaling matrix is very simple to create, as all you have to do is place the scaling factors required for the x, y, and z axes in the diagonal going from the top left to the bottom right of the 3 x 3 rotation part of the matrix. All the other cells are left as zero.</p><p>Since creating a scaling matrix is so simple, the<a id="id683" class="indexterm"/> <code class="literal">CIwFMat</code> class does not include any methods for creating a general scaling matrix. It does however provide some shortcut methods that make it easy to scale a matrix by the same scaling factor on each axis. The following code snippet provides an example:</p><div><pre class="programlisting">CIwFMat lMat;
lMat.SetRotX(PI / 2.0f);
lMat.ScaleRot(2.0f);</pre></div><p>This code will create a rotation matrix of 90 degrees around the x axis and then scale up just the rotation part of the matrix by a factor of two. You can also choose to scale up just the translation part of the matrix or both the rotation and translation by using the<a id="id684" class="indexterm"/> <code class="literal">ScaleTrans</code> and<a id="id685" class="indexterm"/> <code class="literal">Scale</code> methods respectively.</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec71"/>3D model animation</h2></div></div></div><p>Model matrix <a id="id686" class="indexterm"/>animation is, of course, extremely important, as without it we would be unable to orient and move our 3D models in the game world; but on its own it doesn't make for the most exciting looking game.</p><p>Most games require more than this. For example, we might want a human or animal character to walk, run, jump, or perform some other type of motion. Ideally, we need a way of making the overall shape of our 3D model change over time.</p><p>The following sections explain how we can achieve this.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec62"/>Using morph targets</h3></div></div></div><p>A simple approach to 3D model animation is to use <strong>morph targets</strong>
<a id="id687" class="indexterm"/>. For this <a id="id688" class="indexterm"/>
<a id="id689" class="indexterm"/>we alter the vertex positions of our 3D model to yield <strong>key frames</strong>
<a id="id690" class="indexterm"/> of the animation. A key frame is just a particular set of vertex positions for the model that are an important part of the overall animation, such as the various positions a character's legs move through as they walk. The key frame also has a time associated with it.</p><p>The following diagram shows a very simple example of a stick man raising his arm. <strong>Key Frame 1</strong> at time index <strong>0</strong> seconds has the arm in a lowered position, while <strong>Key Frame 2</strong> at time index <strong>2</strong> seconds has it raised. Each of these key frames can be thought of as an individually exported 3D model.</p><div><img src="img/3363OT_05_03.jpg" alt="Using morph targets"/></div><p>If we want to play <a id="id691" class="indexterm"/>
<a id="id692" class="indexterm"/>back this animation, we could just draw the relevant 3D model at the correct time, but this would yield very jerky results akin to 2D bitmap animation. Instead, we can calculate an <strong>Interpolated Frame</strong> for any time index between <strong>0</strong> and <strong>2</strong> seconds to give a much smoother result.</p><p>Calculating the interpolated frame is simple enough. We work out a <strong>delta vector</strong>
<a id="id693" class="indexterm"/> from each vertex in the first key frame to the corresponding vertex in the second key frame. We then scale the delta vector by the ratio of the time index we want to calculate for, divided by the total time between the two key frames, and add the scaled result on to the position of the vertex in the first key frame.</p><p>In the diagram, we want to calculate an interpolated frame at time index <strong>1</strong> second, so we would scale the delta vectors by a factor of half. The end result will be the frame shown where the arm is half raised.</p><p>This approach<a id="id694" class="indexterm"/>
<a id="id695" class="indexterm"/> may be easy to implement, but ultimately we find that there are a few problems with it, as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Accuracy of resultant animation: Take a good look at the interpolated frame of the stick man in the previous diagram and you will see that the stick man's arm has actually shrunk. This is because we are interpolating the vertex positions in a straight line, whereas we really need the end vertices to be rotated around the shoulder point.</li><li class="listitem" style="list-style-type: disc">Number of key frames required: In order to produce a good quality animation we need to store a good number of key frames. In the example of our stick man animation, we could provide additional key frames that would then minimize the arm shortening effect. However, since we need to store the position of every vertex in the model, whether it has moved or not, this soon becomes a large amount of data.</li><li class="listitem" style="list-style-type: disc">The need to ensure that the vertex order does not change between key frames: The only way we can reliably implement morph target animation is if every vertex in the model is in the same position in the vertex stream for every key frame. When exporting a 3D model from a modeling package, the vertex stream order can end up changing between frames, which would then cause our animation to behave incorrectly as vertices interpolate between completely wrong positions.</li></ul></div><p>For the reasons listed, Marmalade does not support morph target animations, though it is fairly trivial to implement such an approach if you so wish. Morph targets can still be extremely useful for tasks such as facial animation, which, with the increasing power of mobile devices, may soon be a more common feature in mobile games.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec63"/>Using boned animations</h3></div></div></div><p>Most 3D video games will implement <a id="id696" class="indexterm"/>the animation of 3D models using a boned animation system. This method works by allowing an animator to set up a skeleton of virtual bones, which can then be used to deform the vertices of a 3D model. The 3D model itself often gets referred to as the <strong>skin</strong> for purposes of animation.</p><p>To set up a<a id="id697" class="indexterm"/>
<a id="id698" class="indexterm"/> boned animation, the first step is to use a 3D modeling package to create the 3D model you want to animate in its <a id="id699" class="indexterm"/> <strong>bind pose</strong>. The bind pose is normally chosen to be a position in which it is easy to access every polygon in the model for texturing and coloring purposes, as well as for laying out the skeleton. For a human character this often means a pose where the arms are held outstretched horizontally from the body and the feet are spaced a short distance apart.</p><p>With the bind <a id="id700" class="indexterm"/>
<a id="id701" class="indexterm"/>pose created, the animator then starts the <a id="id702" class="indexterm"/> <strong>rigging</strong> process. This involves adding the skeleton to the model by placing bones in relevant places. The bones are linked together to form a <strong>hierarchy</strong>; so whenever a bone is moved, all the bones which are linked to it as children will move too. Ultimately there will be one top-level parent bone in the hierarchy and this is called the <a id="id703" class="indexterm"/> <strong>root bone</strong>.</p><p>For performance reasons it is good to keep the number of bones to a minimum, but this must be balanced against having enough to allow good quality animation. The following diagram shows what the 3D skier character used in our example game project looks like after being rigged:</p><div><img src="img/3363_05_04.jpg" alt="Using boned animations"/></div><p>Once the bones have been laid out, the next step is to bind the skin (in other words, the mesh of polygons) to the skeleton. This is done by allowing each vertex of the 3D model to be modified by one or more bones.</p><p>If a vertex is <a id="id704" class="indexterm"/>
<a id="id705" class="indexterm"/>mapped to more than one bone, a weight is also defined for each bone that determines how much of an effect it will have on the vertex. Weights range from zero to one and the sum of all the weights for a particular vertex should add up to one.</p><p>Most 3D modeling packages will have a good first attempt at doing the binding process automatically, but normally the animator will need to make some adjustments to the binding so that the skin animates correctly when the bones of the skeleton are moved.</p><p>With all that done, the animator can then make the character do whatever they want simply by rotating and moving the bones around to define the required key frame positions, just like with morph targets. The boned system will produce much better quality in the final animation, and the amount of memory required to store the key frames is normally not too large, since all that needs to be stored is the orientation and position of each bone.</p><p>The Marmalade <a id="id706" class="indexterm"/>
<a id="id707" class="indexterm"/>SDK comes complete with a boned animation system, which we will be learning about in the rest of this chapter. The system is very flexible and there are very few limitations to it.</p><p>The main things to be aware of are that you can only have a single root bone, a maximum of 256 bones in total, and each vertex can only be affected by a maximum of four bones. In most cases these limitations are unlikely to cause you any problems.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec31"/>Using a 3D modeling package to create animation data</h1></div></div></div><p>Entire books <a id="id708" class="indexterm"/>
<a id="id709" class="indexterm"/>have been written explaining how best to create a 3D animated character; so, unsurprisingly, we won't be looking at how to actually produce an animated 3D model here. Indeed, my warning in the previous chapter about "programmer art" probably goes double for "programmer animation". For evidence to back this statement up, look no further than the graphics accompanying the example programs of this book, which are all examples of "programmer art" made by yours truly. I really should heed my own advice.</p><p>Anyway, with that tip hopefully now rammed home, let's see how we can export animation data from a 3D modeling package.</p><p>Exporting an animation requires a number of new file types to be exported. These will be discussed in detail later, but in short they are files that represent the skeleton, the skin, and the actual animations themselves. The following sections will show how to export this data.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec72"/>Exporting animations using the Marmalade 3D exporter plugins</h2></div></div></div><p>If you are using <a id="id710" class="indexterm"/>
<a id="id711" class="indexterm"/>3DS Max or Maya to create your animations, the required animation files are exported using the Marmalade exporter plugin. To refresh your memory, the exporter plugin window is shown in the following screenshot:</p><div><img src="img/3363_05_05.jpg" alt="Exporting animations using the Marmalade 3D exporter plugins"/></div><p>To export an animation, just load it into your modeling package and follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Set up the <a id="id712" class="indexterm"/><a id="id713" class="indexterm"/>export options in the same way as we did for exporting a static model. Please look at the steps listed in <a class="link" href="ch04.html" title="Chapter 4. 3D Graphics Rendering">Chapter 4</a>, <em>3D Graphics Rendering</em>, if you've forgotten what the various options are for. We'll now take a look at the additional animation-specific options.</li><li class="listitem">Ensure that just the <strong>geometry</strong>, <strong>skeleton</strong>, and <strong>exportgroup</strong> checkboxes are ticked in the group labeled <strong>Enable export of</strong>.</li><li class="listitem">You can now click on the <strong>Export!</strong> button to write out the GEO, MTL, and GROUP files for the model. Two new file types will also be exported, the SKEL and SKIN files, which as you can probably guess represent the skeleton and skin information for the model.</li></ol></div><p>The files exported in these steps are necessary in order to animate the model, but they don't actually contain any animation data as such. Here's how we get hold of the data that will describe how the model is actually animated:</p><div><ol class="orderedlist arabic"><li class="listitem">Go back to the exporter plugin window and click on the button to the right of the <strong>Export Type</strong> combobox. A pop-up menu should appear from which you should select the <strong>anim</strong> option.</li><li class="listitem">The checkboxes in the <strong>Enable export of</strong> section should change so that only the <strong>animation</strong> checkbox is ticked.</li><li class="listitem">In the <strong>Export Flags</strong> section, the <strong>multianim</strong> checkbox can be selected if you have several animations in the scene to export. Note that each animation should be for the same 3D model.</li><li class="listitem">The <strong>Anim Range Type</strong> option can take one of three possible values. The default is <strong>Visible Range</strong>, which will export only the range of frames that are currently visible on the animation track bar in the modeling package. The next option is <strong>Individual Anim Range</strong>, which will only export animation data between the first and last key frame of each animation. The final option, <strong>Full Range</strong>, is only available in Maya. It will export the entire animation regardless of whether a range of frames has been set on the animation track bar or not.<div><img src="img/3363_05_06.jpg" alt="Exporting animations using the Marmalade 3D exporter plugins"/></div></li><li class="listitem">The <strong>Anims Ranges</strong> option<a id="id714" class="indexterm"/> allows you to split one big animation sequence up into several smaller animations. If you click on the <strong>Edit…</strong> button, the dialog box just seen will be displayed. Use the <strong>Add</strong> button to create a new <a id="id715" class="indexterm"/><a id="id716" class="indexterm"/>animation range, use the <strong>Name</strong> textbox to name the animation, and then drag the sliders to set the <strong>Start</strong> and <strong>End</strong> frames for the animation. Use the <strong>Delete</strong> button to delete an animation range from the list. The <strong>Done</strong> button will close the dialog and accept any changes made, while the <strong>Cancel</strong> button will discard any changes made before closing the dialog.</li><li class="listitem">The final option that affects animation export is the <strong>Sub Anim Root</strong> textbox. You can enter the name of one of the bones in the skeleton and the animation data will only be exported for that bone and its children. We'll learn more about sub-animations later in this chapter.</li><li class="listitem">With all the animation-related options in the exporter now set up, just click on the <strong>Export!</strong> button to output one or more ANIM files. The number of files exported depends on how many animations were in the scene, the status of the <strong>multianim</strong> checkbox, and whether the <strong>Anims Ranges</strong> option was used.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec73"/>Exporting animations using the Blender plugin</h2></div></div></div><p>You can also export <a id="id717" class="indexterm"/>
<a id="id718" class="indexterm"/>animations using the Blender plugin. The terminology used in Blender for animations is a little unusual, as Blender calls the skeleton an <a id="id719" class="indexterm"/> <strong>armature</strong>, but aside from that the approach to animation is the same.</p><div><img src="img/3363_05_07.jpg" alt="Exporting animations using the Blender plugin"/></div><p>Here are the steps you should follow to export an animated model from Blender:</p><div><ol class="orderedlist arabic"><li class="listitem">Load the animation you wish to export into Blender and then go to <strong>File</strong> | <strong>Export</strong> | <strong>Marmalade Cross-platform Apps (.group)</strong> to display the export options screen. As a reminder, the export options are shown in the previous screenshot, but please refer to the steps listed in <a class="link" href="ch04.html" title="Chapter 4. 3D Graphics Rendering">Chapter 4</a>, <em>3D Graphics Rendering</em>, for more information about the standard model export settings.</li><li class="listitem">To tell the exporter to write out all the different animation file types, ensure that the <strong>Export Armatures</strong> checkbox is selected.</li><li class="listitem">The <strong>Animations Frames</strong> combobox contains three options. <strong>None</strong> will export no animation data, <strong>Keyframes Only</strong> will export just the data for the key frames of the animation (this is the option you would normally want to select), and <strong>Full Animation</strong> will export data for every frame regardless of whether it is a key frame or not (this is often referred to as "baking" the animation and means you get the exact animation seen in the modeling package at the expense of an increase in animation memory footprint).</li><li class="listitem">The <strong>Animations Actions</strong> combobox contains two settings. <strong>Default Animation</strong> will export only the animation that has been selected as the default for the armature. The other option is <strong>All Animations</strong>, which will export all the animations currently defined for the armature.</li><li class="listitem">The final <a id="id720" class="indexterm"/><a id="id721" class="indexterm"/>setting is the <strong>Animation FPS</strong> value. This dictates the playback speed in frames per second for the animation, so it is possible to speed up or slow down an animation by changing this value without the need to alter all the key frame timings.</li><li class="listitem">To export the data, ensure that you have a file location and name entered in the boxes at the top of the screen and then click on the <strong>Export Marmalade</strong> button.</li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec32"/>The Marmalade 3D animation file formats</h1></div></div></div><p>We can now export the <a id="id722" class="indexterm"/>animation data from the 3D modeling package of our choice, but before we actually make use of them, let's take a quick look at the new file types that we've just generated.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec74"/>The SKEL file</h2></div></div></div><p>A <strong>SKEL file</strong> <a id="id723" class="indexterm"/>contains <a id="id724" class="indexterm"/>all the information pertaining to the skeleton of our animation. The file first defines an instance of a<a id="id725" class="indexterm"/> <code class="literal">CIwAnimSkel</code> class, which is a wrapper for a number of <code class="literal">CIwAnimBone</code> instances.</p><p>The <code class="literal">CIwAnimSkel</code> instance is derived from the <code class="literal">CIwResource</code> class <a id="id726" class="indexterm"/>and therefore has a name associated with it so that it can be looked up in the resource manager. The name of the instance is taken from the filename of a SKEL file, which in turn comes from the name of the root bone of the skeleton.</p><p>Each of the <code class="literal">CIwAnimBone</code> instances have a name, position, and rotation associated with it, which defines the bind pose of the animation. The position is just a vector in model space, while the rotation is stored as a quaternion. Except for the first bone, which is the root bone, each bone will also list its parent bone, thus building up the skeletal hierarchy.</p><p>The SKEL file gets<a id="id727" class="indexterm"/>
<a id="id728" class="indexterm"/> exported into the <code class="literal">models</code> sub-directory alongside the GEO and MTL files. An example of a SKEL file is as follows:</p><div><pre class="programlisting">CIwAnimSkel
{
  numBones 12
  CIwAnimBone
  {
    name "FlagPoleBase"
    pos {-0.38309,-1.27709,0}
    rot {0.70711,0,0,0.70711}
  }
  CIwAnimBone
  {
    name "PoleA"
    parent "FlagPoleBase"
    pos {258.20248,0.00000,0}
    rot {1,0,0,0}
  }
  CIwAnimBone
  {
    name "PoleB"
    parent "PoleA"
    pos {255.88675,0.00000,0}
    rot {1.00000,0,0,-0.00200}
  }
  CIwAnimBone
  {
    name "PoleC"
    parent "PoleB"
    pos {257.60138,-0.00000,0}
    rot {0.00000,0.99998,0.00615,0.00000}
  }
  CIwAnimBone
  {
    name "PoleD"
    parent "PoleC"
    pos {255.08751,-0.00000,-0.00000}
    rot {0.00000,0.99998,0.00621,0.00000}
  }
  CIwAnimBone
  {
    name "PoleE"
    parent "PoleD"
    pos {257.19775,0.00000,-0.00000}
    rot {1.00000,0,0,0.00206}
  }
  CIwAnimBone
  {
    name "FlagStart"
    parent "PoleE"
    pos {152.41219,0.00000,-0.00000}
    rot {0.61894,0,0,-0.78544}
  }
  CIwAnimBone
  {
    name "FlagA"
    parent "FlagStart"
    pos {85.99931,-0.00000,-0.00000}
    rot {0.99505,0,0,0.09934}
  }
  CIwAnimBone
  {
    name "FlagB"
    parent "FlagA"
    pos {57.19376,0.00000,-0.00000}
    rot {1.00000,0,0,0.00128}
  }
  CIwAnimBone
  {
    name "FlagC"
    parent "FlagB"
    pos {61.42473,0.00000,-0.00000}
    rot {0.99996,0,0,0.00846}
  }
  CIwAnimBone
  {
    name "FlagD"
    parent "FlagC"
    pos {60.33911,0,-0.00000}
    rot {0.99996,0,0,-0.00877}
  }
  CIwAnimBone
  {
    name "FlagE"
    parent "FlagD"
    pos {60.36695,-0.00000,-0.00000}
    rot {0.99985,0,0,0.01754}
  }
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec75"/>The SKIN file</h2></div></div></div><p>The <strong>SKIN file</strong>
<a id="id729" class="indexterm"/> is the <a id="id730" class="indexterm"/>bridge between the skeleton and the vertices of the 3D model in its bind pose. It contains all the data representing which vertices are influenced by which bones.</p><p>The file starts by defining an instance of the<a id="id731" class="indexterm"/> <code class="literal">CIwAnimSkin</code> class. This instance contains references to the <code class="literal">CIwAnimSkel</code> instance that defines the bones of the required skeleton, and also the <code class="literal">CIwModel</code> instance that will be used for rendering the model once the new vertex positions have been calculated. As with the SKEL file, the name given to the <code class="literal">CIwAnimSkin</code> instance is derived from the filename of the SKIN file.</p><p>The file then contains a number of instances of the<a id="id732" class="indexterm"/> <code class="literal">CIwAnimSkinSet</code> class, which indicates which vertices are modified by which bones. This is achieved by first listing the bones, up to a maximum of four, then the number of vertices in the set. The bone weights are then specified for each vertex by providing the index of the vertex in the model vertex stream, followed by a weight value for each bone. The sum of the weight values for each vertex must total to one.</p><p>The SKIN file is also exported to the <code class="literal">models</code> subdirectory and the following code provides a partial example of one. These files tend to be quite large due to the sheer amount of data required for even a simple animation, so an extract should provide enough of a flavor of what these files look like.</p><div><pre class="programlisting">CIwAnimSkin
{
  skeleton "FlagPoleBase"
  model "Flag"
  CIwAnimSkinSet
  {
    useBones { FlagPoleBase }
    numVerts 16
    vertWeights {0,1}
    vertWeights {1,1}
    vertWeights {2,1}
    vertWeights {3,1}
    vertWeights {4,1}
    vertWeights {35,1}
    vertWeights {58,1}
    vertWeights {60,1}
    vertWeights {62,1}
    vertWeights {64,1}
    vertWeights {65,1}
    vertWeights {90,1}
    vertWeights {91,1}
    vertWeights {92,1}
    vertWeights {93,1}
    vertWeights {94,1}
  }
  CIwAnimSkinSet
  {
    useBones { FlagPoleBase PoleA }
    numVerts 10
    vertWeights {5,0.50170,0.49830}
    vertWeights {6,0.50251,0.49749}
    vertWeights {7,0.50177,0.49823}
    vertWeights {8,0.50116,0.49884}
    vertWeights {9,0.50114,0.49886}
    vertWeights {57,0.50251,0.49749}
    vertWeights {59,0.50177,0.49823}
    vertWeights {61,0.50116,0.49884}
    vertWeights {63,0.50114,0.49886}
    vertWeights {66,0.50170,0.49830}
  }

// Several more CIwAnimSkinSet instances would have been
// defined here but they have been left out to avoid
// filling the book with boring numbers!

  CIwAnimSkinSet
  {
    useBones { FlagA FlagB FlagC FlagD }
    numVerts 8
    vertWeights {39,0.15992,0.33285,0.33292,0.17431}
    vertWeights {44,0.15632,0.33444,0.33462,0.17462}
    vertWeights {49,0.17817,0.32895,0.32812,0.16476}
    vertWeights {54,0.18163,0.32749,0.32638,0.16450}
    vertWeights {106,0.15632,0.33444,0.33462,0.17462}
    vertWeights {112,0.17817,0.32895,0.32812,0.16476}
    vertWeights {120,0.18163,0.32749,0.32638,0.16450}
    vertWeights {121,0.15992,0.33285,0.33292,0.17431}
  }
  CIwAnimSkinSet
  {
    useBones { FlagB FlagC FlagD FlagE }
    numVerts 20
    vertWeights {40,0.14751,0.34532,0.34603,0.16114}
    vertWeights {41,0.02763,0.13480,0.41879,0.41879}
    vertWeights {45,0.14368,0.34743,0.34842,0.16046}
    vertWeights {46,0.02625,0.13072,0.42151,0.42151}
    vertWeights {50,0.16232,0.34459,0.34444,0.14865}
    vertWeights {51,0.03730,0.16777,0.39776,0.39717}
    vertWeights {55,0.16581,0.34255,0.34229,0.14936}
    vertWeights {56,0.03875,0.17110,0.39544,0.39471}
    vertWeights {102,0.02763,0.13480,0.41879,0.41879}
    vertWeights {103,0.02625,0.13072,0.42151,0.42151}
    vertWeights {107,0.14368,0.34743,0.34842,0.16046}
    vertWeights {108,0.02625,0.13072,0.42151,0.42151}
    vertWeights {109,0.03730,0.16777,0.39776,0.39717}
    vertWeights {113,0.16232,0.34459,0.34444,0.14865}
    vertWeights {114,0.03730,0.16777,0.39776,0.39717}
    vertWeights {115,0.03875,0.17110,0.39544,0.39471}
    vertWeights {122,0.16581,0.34255,0.34229,0.14936}
    vertWeights {123,0.14751,0.34532,0.34603,0.16114}
    vertWeights {124,0.03875,0.17110,0.39544,0.39471}
    vertWeights {125,0.02763,0.13480,0.41879,0.41879}
  }
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec76"/>The ANIM file</h2></div></div></div><p>The final file type we need to consider is the <a id="id733" class="indexterm"/>
<a id="id734" class="indexterm"/> <strong>ANIM file</strong>, which as its name suggests is the file that actually defines a particular animation.</p><p>The file first declares an instance of the <code class="literal">CIwAnim</code> class, which, as with the other animation class types, will be given a resource name derived from the filename.</p><p>The skeleton that this animation will be applied to is the first thing that the <code class="literal">CIwAnim</code> instance will specify. This is then followed by a number of <code class="literal">CIwAnimKeyFrame</code> declarations that detail the positions and orientations of each affected bone at a particular time index.</p><p>Key frames do not need to list the orientation and position of each bone in the skeleton. If a bone has not moved relative to its parent, its position will remain as it was at the previous key frame.</p><p>The exporters will create an <code class="literal">anims</code> sub-directory to hold all the ANIM files. An example of an ANIM file is provided in the following code; but as with the SKIN file, this is just a partial example so as to <a id="id735" class="indexterm"/>
<a id="id736" class="indexterm"/>not fill the pages of this book with lots of numbers:</p><div><pre class="programlisting">CIwAnim
{
  skeleton "FlagPoleBase"
  // Keyframe# 1
  CIwAnimKeyFrame
  {
    time 0
    bone "FlagPoleBase"
    pos {-0.38309,-1.27709,0}
    rot {0.70711,0,0,0.70711}
    
    bone "PoleA"
    pos {258.20248,0.00000,0}
    rot {1,0,0,0}
    
    bone "PoleB"
    pos {255.88675,0.00000,0}
    rot {1.00000,0,0,-0.00200}
    
    bone "PoleC"
    pos {257.60138,-0.00000,0}
    rot {0.00000,0.99998,0.00615,0.00000}
    
    bone "PoleD"
    pos {255.08751,-0.00000,-0.00000}
    rot {0.00000,0.99998,0.00621,0.00000}
    
    bone "PoleE"
    pos {257.19775,0.00000,-0.00000}
    rot {1.00000,0,0,0.00206}
    
    bone "FlagStart"
    pos {152.41219,0.00000,-0.00000}
    rot {0.61894,0,0,-0.78544}
    
    bone "FlagA"
    pos {85.99931,-0.00000,-0.00000}
    rot {0.99505,0,0,0.09934}
    
    bone "FlagB"
    pos {57.19376,0.00000,-0.00000}
    rot {1.00000,0,0,0.00128}
    
    bone "FlagC"
    pos {61.42473,0.00000,-0.00000}
    rot {0.99996,0,0,0.00846}
    
    bone "FlagD"
    pos {60.33911,0,-0.00000}
    rot {0.99996,0,0,-0.00877}
    
    bone "FlagE"
    pos {60.36695,-0.00000,-0.00000}
    rot {0.99985,0,0,0.01754}
    
  }
  // Keyframe# 5
  CIwAnimKeyFrame
  {
    time 0.16667
    bone "FlagPoleBase"
    pos {-0.38309,-1.27709,0}
    rot {0.73026,0,0,0.68317}
    
    bone "PoleA"
    pos {258.20248,0.00000,0}
    rot {0.99889,0,0,-0.04716}
    
    bone "PoleB"
    pos {255.88675,0.00000,0}
    rot {0.99864,0,0,-0.05222}
    
    bone "PoleC"
    pos {257.60138,-0.00000,0}
    rot {0.00000,0.99857,-0.05338,0.00000}
    
    bone "PoleD"
    pos {255.08751,-0.00000,-0.00000}
    rot {0.00000,0.99624,0.08662,-0.00000}
    
    bone "PoleE"
    pos {257.19775,0.00000,-0.00000}
    rot {0.99483,0,0,-0.10158}
    
  }
  // Keyframe# 15
  CIwAnimKeyFrame
  {
    time 0.58333
    bone "FlagPoleBase"
    pos {-0.38309,-1.27709,0}
    rot {0.70668,0,0,0.70754}
    
    bone "PoleA"
    pos {258.20248,0.00000,0}
    rot {0.99873,0,0,0.05033}
    
    bone "PoleB"
    pos {255.88675,0.00000,0}
    rot {0.99775,0,0,0.06711}
    
    bone "PoleC"
    pos {257.60138,-0.00000,0}
    rot {0.00000,0.99951,0.03144,-0.00000}
    
    bone "PoleD"
    pos {255.08751,-0.00000,-0.00000}
    rot {0.00000,0.99996,0.00868,0.00000}
    
    bone "PoleE"
    pos {257.19775,0.00000,-0.00000}
    rot {0.99853,0,0,0.05420}
    
  }
  // Further key frames follow to define the remainder of the
  // animation but these have been removed to avoid including
  // large amounts of datafile in the pages of this book
}</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec33"/>Loading and rendering an exported 3D animation</h1></div></div></div><p>We're now in a position to <a id="id737" class="indexterm"/>
<a id="id738" class="indexterm"/>start rendering a 3D animation, and as with rendering a static 3D model it's also surprisingly easy to do.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec77"/>Adding the IwAnim API to a project</h2></div></div></div><p>Before we can use <a id="id739" class="indexterm"/>
<a id="id740" class="indexterm"/>Marmalade's animation functionality, we first need to add the IwAnim API to our project. This API builds on top of the IwGraphics API required for rendering static 3D models.</p><p>As with all such Marmalade APIs, we add support for IwAnim to a project by listing <code class="literal">iwanim</code> in the <code class="literal">subprojects</code> section of the MKB file. We must then call <code class="literal">IwAnimInit</code> after <code class="literal">IwGraphicsInit</code> has <a id="id741" class="indexterm"/>
<a id="id742" class="indexterm"/>been called, and at shutdown time we need to call <code class="literal">IwAnimTerminate</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec78"/>Loading and accessing a 3D animation</h2></div></div></div><p>The GROUP file format comes <a id="id743" class="indexterm"/>
<a id="id744" class="indexterm"/>to our rescue once again in order to get animation data loaded into memory. The export process will have created a GROUP file for us already that will include the GEO, MTL, SKEL, and SKIN files, so we just need to add entries for the ANIM files that we want to use.</p><p>With everything referenced in the GROUP file, we just need to load it into memory using the resource manager, and then access the resources in the same way as we do for any other resource.</p><p>The following code snippet illustrates how we might load a GROUP file and then access the resources needed for rendering an animated 3D model:</p><div><pre class="programlisting">CIwResGroup* lpFlagGroup = IwGetResManager()-&gt;
  LoadGroup("Flag/Flag.group");
CIwModel* lpFlag = static_cast&lt;CIwModel*&gt;(lpFlagGroup-&gt;
  GetResNamed("Flag", "CIwModel"));
CIwAnimSkel* lpSkel = static_cast&lt;CIwAnimSkel*&gt;(lpFlagGroup-&gt;
  GetResNamed("FlagPoleBase", "CIwAnimSkel"));
CIwAnimSkin* lpSkin = static_cast&lt;CIwAnimSkin*&gt;(lpFlagGroup-&gt;
  GetResNamed("Flag", "CIwAnimSkin"));
CIwAnim* lpFlagWobble = static_cast&lt;CIwAnim*&gt;(lpFlagGroup-&gt;
  GetResNamed("FlagWobble", "CIwAnim"));</pre></div><p>Right, now that we have the resources in memory, we need to do something with them.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec79"/>Playing back a 3D animation</h2></div></div></div><p>In order to play back an <a id="id745" class="indexterm"/>animation, we need to let Marmalade know which animation we want to play, how fast it should be played back, and whether we want it to be a one shot or looping animation. All this and more is provided by the<a id="id746" class="indexterm"/> <code class="literal">CIwAnimPlayer</code> class.</p><p>After creating a new instance of <code class="literal">CIwAnimPlayer</code>, we must provide it with a pointer to the skeleton instance for animation. This is done as follows:</p><div><pre class="programlisting">CIwAnimPlayer* lpAnimPlayer = new CIwAnimPlayer;
lpAnimPlayer-&gt;SetSkel(lpSkel);</pre></div><p>The player object is now ready to start animating, so we just need to pass it details about the animation we want to play. This can be done with just a single line of code:</p><div><pre class="programlisting">lpAnimPlayer-&gt;PlayAnim(lpFlagWobble, 1.0f,
                       CIwAnimBlendSource::LOOPING_F, 0.0f);</pre></div><p>The <code class="literal">PlayAnim</code> method<a id="id747" class="indexterm"/> first takes a pointer to the <code class="literal">CIwAnim</code> instance we wish to play. It then expects to see a playback speed, some control flags, and a blending interval.</p><p>The playback speed is specified so that a value of <code class="literal">1</code> yields the normal exported animation speed. Doubling this value will play the animation back at twice the speed, and so on.</p><p>The function's third parameter is a set of control flags that are primarily used to indicate whether the animation should loop when it reaches the last key frame. If looping is desired, the flag <code class="literal">CIwAnimBlendSource::LOOPING_F</code> should be used.</p><p>There are a number of other values defined by <code class="literal">CIwAnimBlendSource</code>, but most of these are intended for read-only status flags and the <code class="literal">CIwAnimPlayer</code> class provides other methods that should be used to determine the current status. Therefore, the only other flag that will be used in this method is <code class="literal">CIwAnimBlendSource::RESET_IF_SAME_F</code>, which will force the animation player to restart the specified animation if it is already the current animation. If an animation that is already being played is passed in to the<a id="id748" class="indexterm"/> <code class="literal">PlayAnim</code> method, the request will be ignored unless this flag is used.</p><p>The animation <a id="id749" class="indexterm"/>player is now initialized, so the final thing that must be done is instruct it to calculate the required animation frame. This is done by calling the <code class="literal">Update</code> method of the <code class="literal">CIwAnimPlayer</code> instance on every iteration of the main game loop, as shown in the following code:</p><div><pre class="programlisting">lpAnimPlayer-&gt;Update(lTimeStep);</pre></div><p>The <code class="literal">lTimeStep</code> parameter<a id="id750" class="indexterm"/> is a <code class="literal">float</code> value indicating the amount of time (in seconds) by which the current animation state should be advanced. When this call completes, a copy of the skeleton will have been created with all the bones positioned and rotated correctly in order to render the current frame of animation.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec80"/>Rendering a 3D animation</h2></div></div></div><p>With the animation<a id="id751" class="indexterm"/> player now merrily updating away, the final step is to render the animated model. This is possibly the easiest part of the entire process, as the following code demonstrates:</p><div><pre class="programlisting">IwGxSetViewMatrix(&amp;lViewMatrix);
IwGxSetModelMatrix(&amp;lModelMatrix);

IwAnimSetSkelContext(lpAnim-&gt;GetSkel());
IwAnimSetSkinContext(lpSkin);

lpFlag-&gt;Render();

IwAnimSetSkelContext(NULL);
IwAnimSetSkinContext(NULL);</pre></div><p>Hopefully most of this already looks familiar to you. The first step is to set the view and model matrices we want to use for rendering. We then need to provide some information about the frame of animation, namely the animated skeleton and the skin data.</p><p>The skeleton information is maintained by the <code class="literal">CIwAnimPlayer</code> instance and can be retrieved using the<a id="id752" class="indexterm"/> <code class="literal">GetSkel</code> method. The skin is just the <code class="literal">CIwAnimSkin</code> instance as loaded by the resource manager. We use the <code class="literal">IwAnimSetSkelContext</code> <a id="id753" class="indexterm"/>and <code class="literal">IwAnimSetSkinContext</code> functions <a id="id754" class="indexterm"/>to provide this data to the rendering engine.</p><p>To render the animated<a id="id755" class="indexterm"/> model to the screen, all we have to do is call the <code class="literal">Render</code> method on <code class="literal">lpFlag</code>, which is a pointer to a <code class="literal">CIwModel</code> instance, just as we would if we were rendering the model without any animation.</p><p>After rendering, we clear the skin and skeleton contexts so that future model rendering calls won't try and use incorrect data during rendering. This is a good habit to get into as determining why an unanimated model has suddenly started deforming wildly could be a tricky bug to track down.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec34"/>Exploring 3D animation further</h1></div></div></div><p>Congratulations! You're now able<a id="id756" class="indexterm"/> to render fully animated 3D models! While this is a pretty cool achievement, the functionality we've seen so far has only scratched the surface of what the IwAnim API allows us to do. The following sections describe some of the other features that we have at our disposal.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec81"/>Playing an animation backwards</h2></div></div></div><p>There are some occasions<a id="id757" class="indexterm"/>
<a id="id758" class="indexterm"/> when it is useful to be able to play an animation backwards. As an example, imagine a character kneeling down to examine an object. Rather than create a whole new animation to enable them to stand up again, we could just play the kneeling animation backwards instead.</p><p>Playing an animation backwards is achieved simply by passing a negative animation speed into the <a id="id759" class="indexterm"/>
<a id="id760" class="indexterm"/>call to <code class="literal">PlayAnim</code>, so a value of <code class="literal">-1</code> will play the animation backwards at normal speed.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec82"/>Blending between animations</h2></div></div></div><p>When transitioning <a id="id761" class="indexterm"/>
<a id="id762" class="indexterm"/>between two animations, we often don't want to just snap straight to the beginning of the new sequence, as this can result in a noticeable jump between the current frame of animation and the first frame of the new animation. We can solve this problem by blending between animations.</p><p>We touched on how to achieve this earlier, when we first introduced the <code class="literal">PlayAnim</code> method<a id="id763" class="indexterm"/>. The final parameter in this method is the blending time, which is specified as a value in seconds using a floating point number.</p><p>By specifying a non-zero blending interval, the animation player will calculate the frames of animation required for both the old and new animations, then generate a third transition frame by interpolating between these two frames over the specified time. The transition frame is what is then used to draw the 3D model. Once the blend interval is over, the original animation will stop being calculated as it is no longer required.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec83"/>Detecting animation playback events</h2></div></div></div><p>Being able to detect when <a id="id764" class="indexterm"/>
<a id="id765" class="indexterm"/>an animation has looped or has finished playing is important because we can start to link animations together or prevent the user from performing a task until an animation has completed. For instance, imagine a player has to reload a weapon and an animation is played to show this happening. We need to know when the animation has completed so we can allow the player to start attacking again.</p><p>The <code class="literal">CIwAnimPlayer</code> class<a id="id766" class="indexterm"/> allows us to detect when a one shot animation has completed, by calling the <code class="literal">IsCurrentAnimComplete</code> method<a id="id767" class="indexterm"/> that will return <code class="literal">true</code> when the animation has finished.</p><p>There is also the <code class="literal">IsCurrentBlendComplete</code> method<a id="id768" class="indexterm"/> that will return <code class="literal">true</code> when the animation player has finished blending between two animations.</p><p>Detecting when an animation has looped is also possible, although <code class="literal">CIwAnimPlayer</code> does not provide us with a quick shortcut way of detecting this event. Instead, we have to do a little manual flag testing.</p><p>At any time, the animation player can be updating two main animations: current animation (defined as the animation that was last specified using the <code class="literal">PlayAnim</code> method) and the previous animation (the one that was playing at the time <code class="literal">PlayAnim</code> was last called with a blending interval).</p><p>The current status of these two animations are stored in instances of the<a id="id769" class="indexterm"/> <code class="literal">CIwAnimBlendSource</code> class, which we can access using the <code class="literal">CIwAnimPlayer</code> class' methods named <code class="literal">GetSourceCurr</code> and <code class="literal">GetSourcePrev</code>. The <code class="literal">CIwAnimBlendSource</code> class has a method called <code class="literal">GetFlags</code> that returns playback status information as a bitmask. To detect if the animation has looped, we just need to see if the flag <code class="literal">CIwAnimBlendSource::LOOPED_F</code> is set. The following source code shows this in action:</p><div><pre class="programlisting">if (lpAnimPlayer-&gt;GetSourceCurr()-&gt;GetFlags() &amp;
                      CIwAnimBlendSource::LOOPED_F)
{
  // Animation has looped!
}</pre></div><p>If you prefer this <a id="id770" class="indexterm"/>
<a id="id771" class="indexterm"/>approach, you can also use the flag <code class="literal">CIwAnimBlendSource::COMPLETE_F</code> to detect when a single shot animation has finished.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec84"/>Optimizing animation playback</h2></div></div></div><p>Do you remember <a id="id772" class="indexterm"/>that we calculated the current animation frame by <a id="id773" class="indexterm"/>calling the <code class="literal">Update</code> method of <code class="literal">CIwAnimPlayer</code>? This method has to do quite a lot of work, some of which we might not actually need to do on a frame-by-frame basis. For example, if an in-game character is currently not visible on the screen, we might want to ensure that we still step through its animation; but calculating the bone positions for the current frame of animation is a waste of processor time as we won't be rendering the animation.</p><p>The <code class="literal">Update</code> method<a id="id774" class="indexterm"/> is actually implemented by calling three other methods of <code class="literal">CIwAnimPlayer</code>, which we can call independently if we so wish.</p><p>The first method is<a id="id775" class="indexterm"/> <code class="literal">UpdateParameters</code>, which takes the time increment we need to update the animation by as its sole parameter. This method will update the current time indexes of all the animations currently in use by the animation player and set flags to indicate whether those animations have completed or looped.</p><p>The<a id="id776" class="indexterm"/> <code class="literal">UpdateSources</code> method takes no parameters and is used to work out the current bone orientations for each animation, applying any blending between animations as required.</p><p>Finally there is the<a id="id777" class="indexterm"/> <code class="literal">UpdateMatrices</code> method, which again takes no parameters. This performs the final step of converting all the positions and orientations of each bone into a matrix that will be used to update the vertex stream of the 3D model during rendering.</p><p>These methods <a id="id778" class="indexterm"/>
<a id="id779" class="indexterm"/>need to be called in the order presented previously, but there is no need to call all three methods in every frame if we do not need the results of that method to be calculated.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec85"/>Playing sub-animations</h2></div></div></div><p>
<strong>Sub-animations</strong> <a id="id780" class="indexterm"/>allow us to animate only a part of the entire skeleton, which can be useful when we want an in-game character to be able to perform two different actions at once. For example, a character might be able to wield several different weapons while moving around the game world. The main animation applied to the character would be an animation for walking, running, or just standing still. Sub-animations can then be overlaid on top of the main animation to show the player holding, firing, or reloading the different weapon types.</p><p>In order to <a id="id781" class="indexterm"/>
<a id="id782" class="indexterm"/>export a sub-animation, all we need to do is specify the name of the bone that is the root of the sub-animation in the <strong>Sub Anim Root</strong> field of the Marmalade exporter plugin. In the example situation given previously, you might choose to export the sub-animation starting at a bone that has the two arm bones as children.</p><p>The Blender plugin does not currently support this feature unfortunately, though you could potentially export the entire animation and then delete by hand any references to bones higher in the hierarchy than the sub-animation root bone in the ANIM file.</p><p>With the sub-animation exported, all we have to do to play it back is call the <code class="literal">PlaySubAnim</code> method<a id="id783" class="indexterm"/> of <code class="literal">CIwAnimPlayer</code>. An example of how to use this function is as follows:</p><div><pre class="programlisting">lpAnimPlayer-&gt;PlaySubAnim(0, lpFlagWave, 1.0f,
CIwAnimBlendSource::LOOPING_F, 0.0f);</pre></div><p>As you can see, it is almost identical in structure to the <code class="literal">PlayAnim</code> method. The only difference is an extra initial parameter, which is the sub-animation index number. The animation player can support two different sub-animations at the same time and the index number should be <code class="literal">0</code> or <code class="literal">1</code> to indicate which sub-animation you wish to change.</p><p>To detect the current playback status of a sub-animation, we can get hold of the <code class="literal">CIwAnimBlendSource</code> instance using the <code class="literal">GetSourceSub</code> method of <code class="literal">CIwAnimPlayer</code>. This method<a id="id784" class="indexterm"/>
<a id="id785" class="indexterm"/> takes a single parameter, which is the index number of the sub-animation required.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec86"/>Offset animations</h2></div></div></div><p>When dealing <a id="id786" class="indexterm"/>with animations that cause a game character to move, such as walking, running, or making an attacking move, it is desirable to update the position of the character with respect to the animation being played so that the character's feet do not appear to slip on the ground.</p><p>Marmalade provides a method of doing this by way of an <a id="id787" class="indexterm"/> <strong>offset animation</strong>, which is an animation that consists of a single bone whose position and rotation can be used to move an object around the game world. Offset animations are exported using the same export process as any other animation.</p><p>To use an offset animation, we use the <code class="literal">PlayOfsAnim</code> method of <code class="literal">CIwAnimPlayer</code>, as shown in the following code:</p><div><pre class="programlisting">lpAnimPlayer-&gt;PlayOfsAnim(lpMovementAnim, 1.0f, 0);</pre></div><p>The parameters of this function are pointers to the offset animation instance, the speed of playback (again a value of <code class="literal">1</code> will play back at normal speed), and the required animation flags; so it is possible to play back offset animations as one shot or looped.</p><p>To find the current status of the offset animation, we can use the <code class="literal">GetSourceOfs</code> method on <code class="literal">CIwAnimPlayer</code> to retrieve the <code class="literal">CIwAnimBlendSource</code> instance that maintains it.</p><p>We can also find out position and rotation information for the start, end, and current offsets using the methods <code class="literal">GetMatOfsInitial</code>, <code class="literal">GetMatOfsFinal</code>, and <code class="literal">GetMatOfs</code> of <code class="literal">CIwAnimPlayer</code>. Each of these methods allows access to a <code class="literal">CIwFMat</code> object representing the current orientation of the offset. We can then use this information to allow us to update the position of a game character accordingly, so that other game functions such as collision detection continue to work correctly.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec87"/>Obtaining bone positions and rotations</h2></div></div></div><p>When discussing sub-animations <a id="id788" class="indexterm"/>
<a id="id789" class="indexterm"/>earlier, we presented the example of a character being able to hold a variety of different weapons. Sub-animations will, of course, only provide half the solution to this problem, as they will move the character's arms to the correct pose; but, because the weapon is not part of the source 3D model, the character will just appear to be clutching at thin air.</p><p>We need some way of drawing a further model depicting the weapon, but how can we get it positioned in the correct place?</p><p>The answer is to ask the animation player to provide us with the current orientation and position of a bone that is located at the point where the weapon model would need to be drawn. We can do this by calling the <code class="literal">GetBoneNamed</code> method of <code class="literal">CIwAnimPlayer</code>, which will return a pointer to a <code class="literal">CIwAnimBone</code> instance representing the current orientation of the requested bone.</p><p>The position and rotation of the bone can be found using the <code class="literal">GetPos</code> and <code class="literal">GetRot</code> methods of <code class="literal">CIwAnimBone</code>, which allow us to generate a matrix in model space, or alternatively the <code class="literal">GetMat</code> method will return a model space matrix representing both the position and rotation of the bone if it has been calculated during the update of the <code class="literal">CIwAnimPlayer</code> instance.</p><p>Using the bone<a id="id790" class="indexterm"/>
<a id="id791" class="indexterm"/> information, we can easily calculate a model matrix for rendering the weapon model in the correct place. First we use the bone information to generate a matrix in model space, we then multiply this by any rotation matrix needed to orient the character in the game world. Finally, add the world position of the character and the weapon model can be rendered in the character's hand.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec35"/>Example code</h1></div></div></div><p>The following sections give an overview of the sample projects accompanying this chapter.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec88"/>The Flag project</h2></div></div></div><p>This example <a id="id792" class="indexterm"/>demonstrates playing back both a main and sub-animation. A flag is rendered waving in a virtual breeze. Every few seconds the flagpole will wobble around but the flag on the end of the pole will continue to flap around. A screen grab can be seen in the following figure:</p><div><img src="img/3363_05_08.jpg" alt="The Flag project"/></div><p>The animation of the flag waving is achieved as a looping sub-animation, while the flagpole wobble is the main animation, which is started every five seconds as a one-shot animation.</p><p>One of the problems with this approach is that the sub-animation will only play if there is a main animation currently in progress. Rather than create a one frame animation of the flagpole standing still, a cunning trick has been employed.</p><p>The flag<a id="id793" class="indexterm"/>pole wobble animation is actually playing continuously, but at zero speed. Since the first frame of the wobble animation is of the pole in an upright position, we have achieved our aim of a static animation frame.</p><p>Every five seconds the wobble animation is then restarted as a one-shot animation. When the wobble animation has completed, we return to playing it at zero speed to hold the flagpole steady again.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec89"/>The Skiing project</h2></div></div></div><p>The changes to the <a id="id794" class="indexterm"/>Skiing project for this chapter really make it seem like much more of a game. The following screenshot and the following sections highlight the new bits and pieces that have been added:</p><div><img src="img/3363_05_09.jpg" alt="The Skiing project"/></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec64"/>New gameplay features</h3></div></div></div><p>Previously, there <a id="id795" class="indexterm"/>was not a great deal of actual gameplay to be had in the game. We could steer the little skier left and right, but aside from crashing into a tree there wasn't actually an awful lot to do.</p><p>To combat this, gates consisting of a couple of flags have been added. The player must steer the skier through these in order to increase their score, which is now displayed at the bottom of the screen.</p><p>To implement the gates, a new class called <code class="literal">Flag</code> has been created. The <code class="literal">ModeGame</code> class picks a random position across the course and spawns a flag a short distance left and right of that position. The flags scroll up the screen, and when they scroll off the top a new random position is chosen for them at the bottom of the game world.</p><p>The <code class="literal">ModeGame</code> class maintains pointers to the two instances of <code class="literal">Flag</code> so that it can be detected when they have scrolled offscreen and need repositioning, plus we can also use these pointers to work out when the player has moved between them.</p><p>Randomly placed rocks have also been introduced, which must be avoided because colliding with them ends the game, just like steering into the trees does. These are represented by another new class called <code class="literal">Rock</code>. This class is very similar to the existing <code class="literal">Tree</code> class, the main difference being that when the rock scrolls off the top of the screen it is replaced at the bottom with a new horizontal position.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec65"/>Animations added</h3></div></div></div><p>Given the <a id="id796" class="indexterm"/>subject matter of this chapter, it's fairly obvious that adding animations to the game would be one of the changes made.</p><p>Our little skier character has been given a looping animation, so the little chap now pushes himself along using his skiing poles. If the player collides with a tree or rock, the poor little fellow will also now take a tumble and end up in a heap on the ground. Ouch!</p><p>The other animation added to the game has been for the flag. It is the same animation structure demonstrated in this chapter's other example project. A sub-animation plays to make the flag wave in the wind, while the main animation is of the flagpole wobbling about.</p><p>Rather than wobbling at set time intervals, the animation is instead triggered when the player skis too close to the flag.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec36"/>Summary</h1></div></div></div><p>We've covered the topic of 3D animation quite extensively in this chapter. We can now move, rotate, and scale our 3D models in the game world, and we can make the actual shape of the model change using boned animations to make characters walk, run, jump, dance, or whatever we require them to do.</p><p>We've also looked at some more advanced topics, such as blending between animations, applying sub-animations on top of a main animation, and retrieving bone position and orientation information from an in-progress animation to allow us to find the location of a particular part of a model.</p><p>In the next chapter we'll return to just two dimensions, as we look at how we can make the user interface of our games look a little prettier than just using badly laid out debug fonts.</p></div></body></html>