- en: Chapter 10. Scene Management with Scene Graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the first scene using a scene graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding local and relative transformations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding parent-child support in the scene graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating complex models with a transformation graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing picking with the ray trace technique
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing 2D textured button widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating the scene with a camera system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the scene with multiple views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In all our previous chapters, we programed various recipes in a modeled centric
    way where we have an engine manager (renderer) that does all the required rendering
    activities for models. This approach is great for learning purposes, but in a
    real use case, we need scalability and manageability where multiple complex scenes
    can be handled easily. This chapter will introduce the scene-graph paradigm that
    allows you to program and manage complex scenes efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scene graph-based architecture**: The present design we used in existing
    recipes contains a renderer engine, which works in conjunction with other helper
    classes to render programed models. This simple architecture is wonderful for
    quick prototyping purposes. This has already been demonstrated in all the recipes
    in previous chapters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The modern 3D graphics use cases are not only limited to render a few chunks
    of objects in the 3D space, but the real-time challenge is to produce a state-of-the-art
    graphics engine that meets all modern graphical requirements. These include optimized
    rendering of complex scenes that involve a hierarchy of nodes, particles, mesmerizing
    shading effects, states, semantic logics, level of details, event handling, geospatial
    services, and so on. To meet these requirements, a modern 3D graphics application
    uses a scene graph-based architecture. The scene graph architecture encapsulates
    the hierarchical structure of a complete 3D scene, which has mainly two aspects:
    semantics and rendering. The semantic aspect works like a database, which manages
    the visual representation and state management. Think of it like a visual database
    that tells the graphical system the scene that''s going to come and the scene
    that''s not in use so that it can be released along with its resources for better
    optimization and memory management. On the other hand, the rendering aspect deals
    with the life cycle management of drawable entities or a model, which includes
    initialization, deinitialization, processing, control management and displaying
    them on screen.'
  prefs: []
  type: TYPE_NORMAL
- en: The scene graph is a big and evolving topic. Covering all its (requirement)
    aspects is out of the scope of this title. In this chapter, we will create a small
    architecture that allows you to manage multiple scenes; each scene can consist
    of multiple lights, cameras, and models. Complex models can be created using the
    parent-child relationships, with the help of local and relative transformations.
    Models can be applied to predefined materials dynamically and all this will be
    done outside the graphics engine in a separate C++ file. This will keep the scene-graph
    hierarchy logic preserved at a single place so that it can be managed easily.
  prefs: []
  type: TYPE_NORMAL
- en: '**Difference with the existing design**: This chapter uses the knowledge of
    our existing rendering engine to produce the scene graph-based architecture. The
    existing design mainly consists of a renderer and model classes. The former is
    responsible for managing models, creating a single view, and processing events.
    On the other hand, the latter contains lights, material, performs the event handling
    process, and renders 3D objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For real-time 3D applications, we need to extend our design to meet the requirements
    of the scene graph architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hierarchical relationship**: Various modules of the system can be arranged
    in a hierarchical fashion. For example, the `Application` module contains the
    `Renderer` module inside and the application works in a singleton fashion. However,
    it can produce many threads to run one renderer instance in each. Each `Renderer`
    instance contains a `Scene` module, which contains the `Model` and `Camera`. The
    scene module can create different views from various cameras to visualize the
    rendering of models on screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Objects with parent-child relationship**: The objects of the similar type
    must support a parent-child relationship. In the parent-child relationship, a
    parent manages all its children automatically. This way, semantics and rendering
    can be managed in an optimized way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transforming graphs**: Each renderable object in a system stores the transformation
    with respect to its parent. In order to understand this, let''s take an example
    of a simple 3D model car that comprises of four tires, four doors, and a car body.
    If we want to translate this car by 2 units in the *x* axis direction, then using
    the existing design, we need to move all the nine parts of the car by 2 units.
    However, if we make the doors and tires as the children of the body of the car,
    then we do not need to worry about moving all nine parts; only the parent part
    (car body) will be enough to move all the related parts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiple scene management**: In the existing design, creating multiple scenes
    is not possible; in fact, everything is drawn as a single scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Separating semantic and rendering**: The rendering of objects must be loosely
    coupled with semantics. The rendering output can be affected by a number of factors,
    such as change in state, user input, or both. The design should be flexible enough
    to manage states and events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Level of Detail** (**LOD**): LOD uses the computed information of an object
    and reveals how far it is from the camera view or an observer. If the object is
    outside the viewing frustum, then it can be ignored before it consumes vital resources
    of the system. The object in the frustum view, which are far away from the camera,
    can be rendered at a lower fidelity in which a fewer polygons and small textures
    can be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State encapsulation**: It''s important that each node or object in the system
    contains a state that is able to reveal the nature of the object. This way several
    similar types of objects can be clubbed together by traversing the parent-child
    hierarchy; this will be highly efficient in avoiding random state switches, for
    example, texture loading and binding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This chapter will take us through a systematic approach to develop scene graphs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementing the first scene in the scene graph** (**recipe 1**): This recipe
    will build the foundation of scene graph, in which it will support scene, model,
    light and the material module. The modeling will be done outside the rendering
    engine in the `NativeTemplate.cpp`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adding local and relative transformation** (**recipe 2**): This recipe will
    introduce the local and the relative transformation concept to the existing scene
    graph. Local transformation is only applicable within the renderable object, whereas
    relative transformation is received from a parent and propagated to its children.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adding parent-child support in the scene graph** (**recipe 3**): This recipe
    builds the parent-child relationship between similar types of objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Creating complex models using a transformation graph** (**recipe 4**): This
    recipe will make use of previous recipe concepts and demonstrate how to build
    complex animated models, such as a revolving windmill.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implementing picking using the ray trace technique** (**recipe 5**): This
    recipe will add the support of events to the scene graph and help in implementing
    the ray trace-based picking technique that allows you to select 3D objects in
    a scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implementing 2D textured button widgets** (**recipe 6**): Implementing 2D
    widgets uses the screen coordinate system. This recipe contains another subrecipe,
    which implements clicking on the button widget.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Navigating a scene with the camera system** (**recipe 7**): This recipe will
    implement the camera support to the scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implementing a scene using multiple views** (**recipe 8**): This recipe enables
    scene graphics to render multiple views to a single scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the first scene using a scene graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by looking at the block diagram of the existing engine (left) with
    the new expected scene graph (right) design. This design is segregated into many
    simpler reusable modules, where each module is self-explanatory in the image itself.
    The `Object` module is a base class for most of the other modules. These modules
    exhibit the parent-child relationship. Similarly, modules that support the event
    handling process must be inherited from the `Event`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the first scene using a scene graph](img/5527OT_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the following image, you can see the hierarchical relationship among different
    modules in the scene graph. The `Renderer` is a graphics engine that contains
    various scenes. These scenes can be added to and removed from the rendering engine
    dynamically. A scene contains one or more cameras as per its requirements; it
    also contains models that the scene needs to render.
  prefs: []
  type: TYPE_NORMAL
- en: 'Transformation is managed in the model-view-projection analogy, where the modeling
    transformation is carried out in the `Model` module and the projection and viewing
    transformation is calculated in the `Camera` module. As we are aware, any renderable
    object must be derived from the `Model` class, which exhibits a parent-child relationship,
    where the parent is fully responsible for managing the life cycle of their children.
    The events in the system flow in the top-down direction and the native application
    receives the events and passes them on to the `Renderer`, which further propagates
    the event to the scene. The scene detects the view to which the event belongs
    to and the events are sent to all corresponding Model''s derived classes in the
    view where it''s finally handled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the first scene using a scene graph](img/5527OT_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This first recipe will implement the basic structure of the scene graph architecture
    described previously in the introduction section. For this recipe, we will implement
    the `Renderer`, `Scene`, `Light`, and `Material` modules. For the `Model` class,
    the changes are very minor. In the scene graph approach, the `Renderer` has simplified
    with the addition of other modules. As we move on to subsequent recipes, we will
    break down the complexity further into simpler modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/5527OT_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will understand the step-by-step procedure to implement
    our first scene. This recipe builds the foundation class of the scene graph, where
    we will describe the class structure and the definition of important member functions.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Coding the definition of all functions may not be possible in this recipe. We
    will suggest our readers to follow the `SG1_withSceneLightMaterial` recipe provided
    with the sample code of this chapter to view the full source.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the steps to implement the scene graph architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The new `Renderer` class is created in `RendererEx.h`; this new version has
    very less code compared to the older version. It manages all the scenes contained
    in it and takes care of the life cycle, such as initialization and rendering:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the member functions of `RendererEx.cpp`, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `Light` class in `Light.h`/`.cpp` and implement it, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, create `Material.h`/`.cpp` and implement the `Material` class as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define some common material types. For more information, refer to the sample
    code of this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: All float data type (`GLfloat` or `float`) variables should be declared explicitly
    with the additional `f` sign in the end. Otherwise, during assignment, the variables
    will be treated as double and casted to the floating type, which will drastically
    decrease the performance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a scene class in `Scene.h`. This manages the models it contains inside.
    Currently, it does not contain any camera in it. We will add the camera later
    in this chapter. The scene provides many services to models, such as managing
    shader programs, transformation services, rendering of models, and so on. Each
    scene can be recognized with a unique name. While rendering each model, the scene
    maintains the reference of the current rendering model in the `currentModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A scene contains multiple lights and models; these models and lights are added
    to the scene using the `addModel` and `addLight` function defined in the `Scene.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `Model` class in `ModelEx.h`. This new version of the `Model` class
    contains the material and parent scene object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As the `ObjLoader` class is also a derivative of the `Model` class, it must
    also contain the reference of the scene under which it will execute. Modify the
    `ObjLoader` constructor to hold the scene reference and create two new functions
    (`ApplyLight`, `ApplyMaterial`) to apply the light and material information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The new method to apply light and materials must be applied before rendering
    the mesh object to the `ObjLoader::render` method, as given in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `NativeTemplate.cpp`, create a scene in the `GraphicsInit` function and
    add a light and mesh object to it. Execute the scene by adding these objects to
    the engine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, the `GraphicsRender` function renders the mesh model and updates
    the scene and related modules. In this recipe, it applies various predefined material
    types on the mesh model for every one second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Renderer` class in the scene graph model is highly simplified compared
    to the earlier overloaded version; `Scenes` are a containment of the `Renderer`
    class. A scene must be created dynamically and added to the rendering engine.
    Similarly, it can be removed from the engine, which allows you to save vital memory
    resources and CPU cycles. Every scene has a unique name that can be used to retrieve
    the scene from the engine; the scene has a containment relationship with lights
    and models. Each scene can have multiple lights. However, the present implementation
    only supports a single light; the models retrieve the light information from their
    respective scenes. The implementation of a Model class has not changed much except
    for the fact that from now onwards the materials can be applied at runtime using
    the light information from the scene. The scene graph allows sharing the models
    from one scene to another without any overhead, thus making it highly flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to differentiate the `Renderer` and `Model` classes of the older graphics
    engine with the scene graph architecture, the filenames of the newer class are
    suffixed with `Ex` (`RendererEx.h`/`.cpp`, `ModelEx.h`/`.cpp`).
  prefs: []
  type: TYPE_NORMAL
- en: The scene graph architecture allows you to create modeling of the scenes and
    the control logic outside the engine; this is a more generic and expected way
    of programming. This recipe uses `NativeTemplate.cpp` as an external file for
    modeling and rendering purposes. In this file, the initialization scene is done
    in the `GraphicsInit()`. First, the `graphicsEngine` rendering engine object is
    created. This engine is set to the `Scene's` object called `scene1` and the parameterized
    constructor of the `Scene` contains its name and the parent object of the rendering
    engine in which it resides. The scene contains a white light source, which is
    situated 10 units away in the *z* direction.
  prefs: []
  type: TYPE_NORMAL
- en: The `Model` object, namely, `Suzzane,` is created using the parameterized constructor
    of `ObjLoader` and is applied to the predefined copper colored material type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The scene is controlled in `GraphicsRender()`. In this function, various types
    of materials are applied at runtime after a regular interval of one second, as
    shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/5527OT_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Building prototypes using the GLPI framework* recipe in [Chapter
    2](ch02.html "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES 3.0 Essentials*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding local and relative transformations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Transformation can be divided into two types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Local transformation**: This type of transformation is only applicable to
    an object; it does not affect its child objects. For example, if two objects are
    in a parent-child relationship, then applying the local scale transformation will
    not scale the child object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Relative transformation**: This type of transformation is applied with respect
    to the parent of the object. Here, the transformation of the parent is propagated
    to the children, thereby affecting the geometrical vertex positions in the 3D
    space. For example, in this case, the scaling transformation to the parent object
    will scale all its children and their children.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If an object does not have a parent (called the `root` object), then the OpenGL
    ES coordinate system will be considered its parent. The next recipe will discuss
    more about the parent-child relationship.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This recipe will create two mesh objects (`Torus`, `Suzzane`) and produce an
    effect similar to the moon's (`Suzzane`) revolution around the `Earth` (`Torus`).
    The moon not only revolves around Earth, but also revolves around its own axis
    at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on the internals of the 3D transformation, you can refer
    to *Implementing scene with the model, view, and projection analogies* recipe
    in [Chapter 2](ch02.html "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES 3.0
    Essentials*. This topic covers various types of transformation, transformation
    matrix conventions, homogenous coordinates, and transformation operations, such
    as translation, scaling, and rotation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires the first recipe as a prerequisite; you are advised to
    understand the implementation of the first recipe. You can locate the source of
    the current recipe (`SG2_withSG1+Transformation`) that is provided with the sample
    code in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the steps to implement local- and relative-transformation in the existing
    scene graph architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `ModelEx.h`, add the following member variables in `Model` class. These
    variables are responsible for storing the local and relative transformation matrix.
    It also has a center of the origin around which the transformation will be applied:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Go to `ModelEx.cpp` and implement the local transformation function and the
    relative transformation function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This step is extremely important; it provides the thumb rule to apply local
    and relative transformation in the `Model` functions derivative classes. For more
    information, see the implementation of the `Render()` function in the `ObjLoader.cpp`
    and add the following member functions to the respective variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `NativeTemplate.cpp`, edit the `GraphicsInit()` function, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the same file and edit the `GraphicsRender()` function to apply the relative
    and local transformation on `Suzzane`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The transformation of each `Model` object is stored locally in the transformation
    and transformationLocal variable. These variables store the translate, rotate,
    and scaling information. The former variable accumulates all the transformation
    applied to the parent and its ancestors; each parent object propagates its transformation
    information to its children. The latter variable only stores the transformation
    information that is applied to the current object locally; it never passes this
    transformation to its children. The mechanism that differentiates between relative
    and local transformation needs to be implemented by a developer in the `Model`
    derived class in the `Render` function (see step three in the previous section):'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/5527OT_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the current recipe, Torus will act as a reference to the center point of
    the parent OpenGL ES coordinate system. More specifically, the Torus will render
    to the OpenGL ES origin, which is (0.0, 0.0, and 0.0). The model is also scaled
    down and it appears like a center point. The `Suzzane` performs two types of rotations
    in order to demonstrate the relative and local transformation. In the former transformation,
    the `Suzzane` will be placed 3 units away from the origin and also set with a
    center (0.0, 0.0, and -3.0) so that it can revolve around the new origin (center).
    However, in the latter transformation, `Suzzane` rotates around its own axis.
    In the `GraphicsRender` function, `Suzzane` is rotated by one degree on each frame
    locally and relatively, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/5527OT_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Adding parent-child support in the scene graph*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding parent-child support in the scene graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe is a very important milestone in the architecture of scene graphs;
    needless to say, a scene graph is all about the hierarchical connectivity. In
    the current concept, we maintain the parent-child relationship among similar types
    of objects. This recipe contains two subrecipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a simple parent-child relationship among renderable objects
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understanding the concept of a dummy parent
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The parent-child relationship is applicable to all renderable objects (derived
    from the `Model` class) and logical engine entities, such as scenes, renderer,
    and so on. In the present scene graph architecture, this relationship is achieved
    through the `Object` class. This class allows you to add/remove children dynamically;
    each object can be recognized with a user-defined name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Make use of the last recipe that we implemented in this chapter and the following
    steps to add the support of the parent-child relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `Object.h` and edit the following code. Each object of this class has
    a name, a parent, and one of more children stored in the child list. The parent''s
    information is set in the constructor. This class provides high level functions
    for retrieving the parent or child information, which can be added or removed
    at fly time. The function of each name is self-explanatory to describe the kind
    of job it performs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create `Object.cpp` and define high level methods that cannot be defined inline
    in the header file. The constructor accepts the name and the parent (`parentObj`)
    of the object; the `RemoveParent` removes the parent of an object and ensures
    that none of the children exists in the parent `childList`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `setVisible` and propagate the visibility of the children based
    on the last parameter: `applyToChildren`, if applicable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Derive the `Renderer`, `Scene`, and `Model` class from the `Object` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the derived version for `Model` classes, handle the object visibility, as
    given in the following code. For more information, refer to `ObjLoader::Render`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the rendering of child models:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `NativeTemplate.cpp` and add implement the parent-child modeling:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any renderable (`Model` and `derivatives`) or nonrenderable entities (`Renderer`,
    `Scene`, and `derivative`) can be derived from the `Object` class in order to
    achieve the parent-child relationship. The `Object` class stores the parent's
    information in the parent variable and child information in a vector list called
    `childList`; any other class object can access the parent and child information
    using the `GetParent()` and `GetChildren()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each parent is responsible for taking care of its children's execution life
    cycle. For example, a parent scene will automatically load the children scenes
    one by one. Similarly, a `Model` loads its children and manages their initialization
    to load the required shaders, propagating parent's transformation to children
    and rendering of each child model.
  prefs: []
  type: TYPE_NORMAL
- en: 'This recipe contains seven models (five sphere (one big, four small), two cubes),
    as shown in the following left-hand side image. The parent-child relationship
    is shown in the following right-hand side image in which the yellow sphere is
    the parent of two copper colored cubes and each cube has two silver color sphere
    attached to it. The yellow sphere rotates around the *y* axis; this makes all
    children elements to rotate around the yellow sphere, while the cubes revolve
    around the *y* axis. At the same time, they revolve around their own *x* axis,
    one in a clockwise direction and another in an anticlockwise direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/5527OT_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Refer to *Create complex models with a transformation graph* recipe. This recipe
    guides you to create a windmill model using the parent-child relationship and
    local/relative transformation.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Look at the following image and try to figure out how we can solve it with the
    existing parent-child relationship approach.
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem statement**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A set of semi-circumferences (created from cubes) are arranged in a concentric
    fashion, where each semi-circumference rotates in the opposite direction with
    respect to its neighboring semi-circumference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/5527OT_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the present situation, we have eight concentric semi-circumferences. Considering
    the innermost semi-circumference as the parent of others, one really has to scratch
    one's head to solve it (give it a try).
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, there are complex parent-child situations that can be solved easily.
    As a solution to this problem, we can create eight parents, apply transformations
    as required, create two parent objects (innermost), and add children, based on
    the direction of the rotation. Finally, move one parent clockwise and another
    anticlockwise. This recipe uses the previous solution with the dummy parent, which
    is described ahead.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have seen the all parent of the renderable entities, which are also
    renderable. This is where dummy parent concepts come into the picture. This allows
    you to create a parent, which does not have any geometry. Therefore, it cannot
    be rendered and provides a logical parent-child relationship. The `Render` method
    does not render anything and is only used to apply transformation. The local transformation
    here does not make any sense as the object''s geometry does not exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating complex models with transformation graph*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating complex models with a transformation graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A transformation graph is a forest of semantic transformations in which each
    node represents a tree of models. Combining all of these tree models produces
    a complex 3D model structure. The following image on the left-hand side shows
    a semantic model of the transformation. The right-hand side image shows a tree
    structure represented by each of the nodes in the semantic transformation graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating complex models with a transformation graph](img/5527OT_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Transformation graphs use the parent-child relationship extensively. Without
    this, the transform graph hierarchy is very difficult to manage. A transformation
    graph represents node hierarchies, in which each child node contains the transformation
    information (translate, scale, and rotate) with respect to its parent.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe is the hybrid of the previous two recipes. It will use the parent-child
    relationship and the local and relative transformation to produce a semantic transformation
    graph. In this recipe, you will learn how to create a complex windmill model with
    basic mesh models, such as cube, cylinder, and sphere.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe does not require any special changes in the scene-graph engine.
    Use `NativeTemplate.cpp` and edit the `GraphicsInit` and `GraphicsRender`, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The windmill model comprises of a total of 24 parts: one base, one stand, one
    motor shaft, one motor engine, and 20 fan blades. The base, motor shaft, and fan
    blades are made up of cube meshes, whereas the stand and motor engine is made
    up of cylinder and sphere meshes respectively. All these parts must be arranged
    in the correct parent-child order and at the same time applied to correct placement,
    using the local and relative transformation in the 3D space. A picture is worth
    a thousand words, by looking at the following image, you must have got the idea
    on how a complete model is woven part by part.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand the working of this windmill. In the `GraphicsInit()`, the
    first thing that we need is the base of the windmill, which is created using a
    perfect cube (**A**). This cube is locally scaled in order to produce a shape
    depicted by (**B**). Next, the stand is made from a cylinder and translated to
    four units (**C**) before the origin and then scaled (**D**) so that it perfectly
    expands in the vertical direction to fit in to the base. The base here is the
    parent of the stand. The motor shaft is also made up of the (**E**) cube, which
    translates into four units (**F**). This model is scaled locally in order to give
    it the (**G**) shape.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every transformation that we apply is with respect to its parent. Therefore,
    in the present case, four units in the vertical direction are with respect to
    the stand, which is the parent of the `MotorShaft`.
  prefs: []
  type: TYPE_NORMAL
- en: Create a sphere in order to produce a `MotorEngine` (**H**) and render it to
    the **+Z** direction by two units (**I**). The final part is to create the fan
    blade. Each fan blade is made up of a cube (**J**). This cube needs to render
    away from the parent center by four units in the vertical direction (**K**). The
    translate blade is then applied to the local scaling in order to create a blade
    like shape (**L**). Similarly, this process of producing blades is repeated 20
    times to build the complete fan (**M**, **N**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, once the geometry is created, the parent node (base) of the windmill
    is added to the scene. Why haven''t the other models been added to the scene?
    In previous recipes, we mentioned that each parent model takes care of its children.
    As the base is added to the scene, it takes care of its child elements. The same
    rule is applicable to all child elements, which are themselves parents of other
    items:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/5527OT_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The windmill fan blades rotate by three degrees around the *z* axis of each
    frame. This transformation can be simply achieved by applying the rotation on
    the sphere, which is the parent of all blades. Similarly, in order to revolve
    the whole model around the *y* axis, apply a one degree rotation on the base in
    the `GraphicsRender()`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Adding parent-child support in the scene graph*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Adding local and relative transformations*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing picking with the ray trace technique
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Picking is a process of selecting objects in the 3D space contained in a scene
    by user inputs. This is a very common requirement in 3D graphic applications,
    where you may be interested in an object tapped by an end user. The tapped point
    contains position in the screen coordinate system, which is a reference to the
    viewport. This reference point can be used in various picking techniques to detect
    the tapped object. In the present recipe, we will use a very versatile picking
    technique called "ray picking" or "ray trace pick".
  prefs: []
  type: TYPE_NORMAL
- en: In this technique, a ray is simulated using the tapped point in the scene. When
    the ray intersects with an object, it's assumed to be clicked on. The ray can
    be intersected with multiple objects in a given scene; the selected objects can
    be collected and sorted according to the distance from the viewpoint in order
    to become the closest selected object. In this recipe, we will implement the ray
    trace picking technique, which is highly accurate in pinpointing 3D objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps provide an overview of implementing ray tracing picking:'
  prefs: []
  type: TYPE_NORMAL
- en: Detect the tapped point on screen (Sx, Sy).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use (Sx, Sy) and find unprojected coordinates on the near (Nx, Ny) and far plane
    (Fx, Fy).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a ray from (Nx, Ny) and (Fx, Fy) unprojected coordinates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consider each triangle of the mesh geometry and perform the ray triangle intersection.
    The test can be optimized using a low polygon mesh.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the steps to implement ray-trace picking:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an interface class called `GestureEvent` derived from `Event` in a new
    file called `Event.h`/`.cpp`. This will provide the necessary interfaces for touch
    screen events. Classes that want to utilize the benefits of gesturing must be
    derived from the `GestureEvent` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Renderer`, `Scene`, and `Model` class need to be inherited with `GestureEvent`
    in order to support touch events. Include the `Event.h` header file in their respective
    classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Propagate gesture events to all scenes in the `Renderer` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement gesture interfaces in the `Scene` class and propagate the received
    touch events from renderer to all the models contained in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement gesture interfaces in the `Model` and apply them to each child:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `Ray.h`/`.cpp` file and define the `Ray` class, as given in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function called `IntersectWithRay` in the base `Model` class and implement
    in the `ObjLoader` derived class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function called `IntersectWithRay` in the base `Model` class and implement
    it in the derived version classes, such as `ObjLoader`, in the present scenario:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `GestureEvent` class receives the tap event (Sx, Sy) in the screen coordinate
    system from the main application in Renderer and passes it to Model classes via
    the respective parent scene. These coordinates are then used to calculate unprojected
    coordinates on the near and far plane. In the present recipe, we have used the
    `glm::unproject` API:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `win` | Components *x*, *y* specify screen coordinates. The *z* with value
    zero and one specify the near and far plane respectively. |'
  prefs: []
  type: TYPE_TB
- en: '| `modelView` | This specifies the product of the view and model matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| `proj` | This specifies the project matrix of the current scene. |'
  prefs: []
  type: TYPE_TB
- en: '| `viewport` | This specifies the current dimension of the viewport region.
    |'
  prefs: []
  type: TYPE_TB
- en: 'The unproject inverts the operation of projection calculation in which world
    coordinates are used to calculate screen coordinate in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '![How it works...](img/5527OT_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Unprojected coordinates on the near plane (Nx, Ny) and the far plane (Fx, Fy)
    are used to shoot a ray from the near to the far plane, as shown in the preceding
    image (**B**). When this ray hits a 3D object, it is considered to be picked.
    Mathematically, this picking is performed by taking the intersection of mesh polygons
    and ray produced. For the sake of simplicity, we used the line and triangle intersection
    in the present recipe, as shown in image (**A**). The mesh is iterated for each
    triangle in it and intersected by the ray using the `IntersectWithRay` function,
    which is inherited from `Model`. This function must be overridden in the derived
    version in order to perform the intersection test. The `ObjLoader` class overrides
    this function and calculates the ray-triangle intersection using the `glm::intersectLineTriangle`
    API. This recipe paints all the selected 3D mesh objects with ambient red, which
    are intersected by the ray. In order to find the closest selected object, sort
    the entire selected item and choose the closest one from the camera view.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Implementing 2D textured button widgets*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing 2D textured button widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenGL ES does not provide built-in UI components, such as buttons, radio box,
    checkbox, and so on. In general, these components are called 2D widgets and are
    laid out in the HUD in the screen coordinate system, where the *z* component is
    either zero or not at all used. This recipe will guide us to design and lay out
    2D widgets on the screen coordinate system using OpenGL ES.
  prefs: []
  type: TYPE_NORMAL
- en: 'This recipe contains two recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: The first recipe allows you to create the geometry of a simple button. Geometrical
    coordinates are specified in the local screen coordinate system, which is useful
    in designing the layout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second recipe is implemented in the *There's more...* section of this recipe,
    where we used the ray-picking technique, making the button clickable. Selecting
    the button will change its color.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next image shows the output of the first recipe. It contains six buttons
    of 32 x 32 dimensions. Each button is scaled by a factor of two, resulting in
    the final dimension of 64 x 64\. The extreme left hand-side button (up button)
    is the parent of all the remaining buttons. This means any property applied to
    the parent will be propagated to all its children.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the steps to implement this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `Button.h`/`.cpp` and define the `Button` class derived from the `Model`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Button` class renders the geometry of the button. A button geometry has
    four vertices on which a texture is pasted, with the help of texture coordinates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up the heads up display using the orthographic projection system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `NativeTemplate.cpp`, edit the `GraphicsInit()` function, as given in the
    following code. This function lays out buttons on the screen coordinate system.
    These buttons accept geometrical vertices and texture coordinates as an input,
    which are optional parameters. If these parameters are not supplied. The dimension
    of the button will be equal to the image size. The texture coordinate has default
    values (0.0, 0.0) and (1.0, 1.0) as the bottom-left and top-right respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The geometry of the 2D button widget is created using four vertices, which are
    specified in the screen coordinate system. This geometry is textured with the
    specified image with the help of texture coordinates on the geometry. OpenGL ES
    works in the Cartesian system, where the origin exists in the center of the viewport
    dimension in the logical coordinate system. Viewport also has the same coordinate
    system and works in the pixel coordinate system, but the origin in this case exists
    in the bottom-left corner as shown in the following image. In contrast, the 2D
    widget is designed in the device coordinate system, where the origin is considered
    as the top-left corner (see the following image).
  prefs: []
  type: TYPE_NORMAL
- en: Now, head-up-display is a mechanism in which we can formulate the device coordinate
    system by using the OpenGL ES coordinate system and the viewport. For this, we
    need to render the projection system of the scene with an orthographic view where
    the origin is shifted in the top-right corner in the `setUpProjection` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The button class objects are created in `NativeTemplate.cpp` in the `GraphicsInit()`
    function, where six buttons are created with different images on it. Each button
    is given a unique name so that it can be used later in the camera recipe. The
    following image shows these buttons on the right-hand side. In order to make the
    job simpler for placement of icons in the 2D HUD screen space, we made the first
    button (up direction) as the parent of other buttons. This way, we all buttons
    can be resized and moved by applying a single operation on the parent itself.
    Finally, render these buttons to the HUD using `GraphicsRender()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/5527OT_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike how we implemented the picking technique in the last recipe, this time
    we will implement the picking technique in the button class, which will help us
    to know which button has been clicked on so that a user can perform the appropriate
    action in response to it. Refer to the next recipe in order to see how these buttons
    control the camera moved in a scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Button` class must be derived from the `GestureEvent` class and implemented
    to virtual gesture functions, such as `TouchEventDown` and `TouchEventRelease`
    in order to handle the gesture event and propagate them to child member objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This class must override the `IntersectWithRay` function. In this, it performs
    a line and triangle intersection with two triangles that contains the button geometry.
    The following image shows the change in the color of the button when the touch
    down event occurs. The button gets restored to the original color when the touch
    release event fires:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/5527OT_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Refer to the Rendering text on Head Up Display recipe in [Chapter 8](ch08.html
    "Chapter 8. Font Rendering"), Font Rendering*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating the scene with a camera system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 3D graphics, a camera allows you to navigate through the 3D space; it can
    be used to perform the rotation and displacement on any arbitrary axis. In OpenGL
    ES, there is nothing such as a camera. This has to be implemented programmatically.
    Implementing a camera is extremely simple. In fact, we do not require any specific
    OpenGL ES APIs for this and it's all about manipulating matrices. In this recipe,
    we will simulate a first person camera.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Reuse the last implement recipe and perform the following steps to implement
    the camera system:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Camera.h`/`.cpp` file and define a `Camera` class derived from `Object`.
    This class contains three unit vectors: `Left`, `Up`, and `Forward`, which store
    directional unit vectors in the 3D space along the *x*, *y*, and *z* axis respectively.
    The `Position` specifies the location of the camera and Target specifies the location
    of the camera view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the rotation of the camera, as given in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make the camera move along the three axes using the move function, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Camera::Render()` sets up the projection matrix in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Combine the two scenes that we created in previous recipes. The first scene
    contains the windmill. The second scene contains pick buttons. The former scene
    will be rendered to the perspective camera. However, the latter will make use
    of the HUD camera:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A camera contains three orientation unit vectors: the forward (0.0, 0.0, and
    -1.0), right (1.0, 0.0, and 0.0), and up vector (0.0, 1.0, and 0.0). The first
    vector points to a direction where the camera is heading. For example, in the
    present case, the camera will move in the negative *z* axis direction. Similarly,
    the right vector specifies the direction of the movement in the *x* axis and the
    up vector in the *y* axis. The up vector can also be understood like a head, which
    specifies whether the camera is viewing a scene in the upside (0.0, 1.0, and 0.0)
    or upside down (0.0, -1.0, and 0.0) direction.'
  prefs: []
  type: TYPE_NORMAL
- en: Using these vectors, the camera can be moved along any of the three axes. For
    example, if you want to move the camera five units ahead, then the product of
    `|5| *` forward will place your camera at (0.0, 0.0, or -5.0) looking in the same
    direction, whereas moving the camera right by four units places the camera at
    (4.0, 0.0, or -5.0). Again, the camera still looks in the negative *z* direction.
    In the present recipe, the camera's current position is translated using functions,
    such as `MoveForwards`, `StrafeRightSide`, `StrafeUpSide`, and so on. The orientation
    of the camera along *x*, *y*, or *z* axis can be changed using the `Rotate` function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The camera displacement on any arbitrary axis specified by the forward, right,
    and up unit vector does not affect the orientation of the camera. The orientation
    remains unchanged and the camera will continue to look in the same direction specified
    by the forward vector. The orientation of the camera can only be effected when
    the camera rotates along any of the arbitrary axis.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/5527OT_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding image (part **1**) shows the effect of rotation on the forward
    (**OC**), right (**OA**), and up (**OB**) vectors, when the rotation of 45 degree
    is performed along the *z* axis. This results (image part **2**) in the new right
    (**OE**) and new up (**OF**) vector. The forward vector has no changes as it rotates
    along the *z* axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/5527OT_10_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The current recipe contains two cameras for each scene. The first camera renders
    the perspective projection system. The second camera renders the scene to the
    head-up-display in the orthographic projection view. The `Camera` class that we
    implemented in the last recipe cannot be programmed for HUD camera requirements.
    Therefore, we need a new `Camera` derivative class called `CameraHUD` to implement
    HUD.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the implementation of the HUD camera. The `Render`
    function is overridden. This function queries the current viewport dimensions
    and maps it to the orthographic left-right and top-bottom parameters in such a
    way that the origin shifts from center to the top-left, same as the device screen
    coordinate system. For more information on HUD, refer to the *See also* subsection
    in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Refer to the Rendering text on Head Up Display recipe in [Chapter 8](ch08.html
    "Chapter 8. Font Rendering"), Font Rendering*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the scene with multiple views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most common requirements for real time 3D applications is to render
    a scene to multiple view windows simultaneously. For example, a CAD/CAM-based
    application renders a scene to four types of views: perspective, orthographic
    front, side, and top view. In the scene graph architecture, multiple views are
    achieved with the help of rendering a scene to two or more cameras.'
  prefs: []
  type: TYPE_NORMAL
- en: This recipe extends the last recipe to supporting multiple cameras, where each
    camera has different viewport region (which could be overlapped) and can have
    separate clear colors (depending on the requirement).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the steps to implement this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now on, the screen clear color and buffer clearing will be applied within the
    Camera view itself. Remove the clear code from `Renderer::render()`. Define a
    `vec4` type variable called `clearColor` to store the clear color information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Apply the clear color information and framebuffers in `Camera::render()`. In
    the same function, make sure that `glViewPort` and `glScissor` are passed on with
    exactly same dimensions. The `glScissor()` works if the scissor test is enabled.
    It defines a rectangular screen space region in the screen coordinate system beyond
    which nothing will be drawn:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `NativeTemplate.cpp`, edit the `GraphicsInit()` function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `GraphicsResize()` and define the viewport size for all the four cameras
    defined in the preceding code. Specify the clear color information for each camera
    in order to paint the background of view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A multiview scene has multiple cameras rendering the present scene to different
    parts of screen regions. Each different region is specified by the viewport dimension
    specified in the camera. In order to support multiple views in the scene graph,
    we need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Specify the viewport region. This will produce screen coordinates from the world
    coordinates of the scene with respect to the specified viewport dimension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clear the color. This is the color used to clear the color buffer each time
    framebuffer is drawn.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a clear command is specified, it clears the complete framebuffer. As a
    consequence, you may not be able to see different views at all because the last
    camera's clear command has cleared the existing drawing in the framebuffer. This
    unexpected clearing of the color buffer can be avoided using the scissor test.
    In OpenGL ES 3.0, you can scissor a framebuffer region using the `glScissor` command,
    which defines a rectangular screen space region in the screen coordinate system
    beyond which nothing will be drawn.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following command needs to the specified in order to achieve multiple cameras
    before using any model, view, and projection matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '![How it works...](img/5527OT_10_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `glScissor()` will only work if the scissor test is enabled; `glScissor`
    defines a rectangle and calls the scissor box in window coordinates. The first
    two arguments: `x` and `y` specify the lower-left corner of the box. The width
    and height specifies the dimensions of the box.'
  prefs: []
  type: TYPE_NORMAL
- en: To enable and disable the scissor test, call [https://www.khronos.org/opengles/sdk/docs/man/xhtml/glEnable.xml](https://www.khronos.org/opengles/sdk/docs/man/xhtml/glEnable.xml)
    and [https://www.khronos.org/opengles/sdk/docs/man/xhtml/glDisable.xml](https://www.khronos.org/opengles/sdk/docs/man/xhtml/glDisable.xml)
    with the `GL_SCISSOR_TEST` argument. This test is initially disabled. When the
    scissor test is enabled, only pixels that lie within the scissor box can be modified
    by drawing commands. Window coordinates have integer values at the shared corners
    of framebuffer pixels.
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '| Variables | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `x`, `y` | This specifies the lower-left corner of the scissor box. The initial
    value of `x`, `y` is (`0`, `0`). |'
  prefs: []
  type: TYPE_TB
- en: '| `width`, `height` | This specifies the `width` and `height` of the scissor
    box. When a GL context is first attached to a window, the width and height are
    set to the dimensions of that window. |'
  prefs: []
  type: TYPE_TB
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Refer to the Rendering text on Head Up Display recipe in [Chapter 8](ch08.html
    "Chapter 8. Font Rendering"), Font Rendering*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
