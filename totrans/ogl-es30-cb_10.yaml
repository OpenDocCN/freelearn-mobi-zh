- en: Chapter 10. Scene Management with Scene Graphs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 使用场景图进行场景管理
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Implementing the first scene using a scene graph
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用场景图实现第一个场景
- en: Adding local and relative transformations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加局部和相对变换
- en: Adding parent-child support in the scene graph
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在场景图中添加父子支持
- en: Creating complex models with a transformation graph
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变换图创建复杂模型
- en: Implementing picking with the ray trace technique
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用光线追踪技术实现拾取
- en: Implementing 2D textured button widgets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现二维纹理按钮小部件
- en: Navigating the scene with a camera system
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用相机系统导航场景
- en: Implementing the scene with multiple views
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现具有多个视图的场景
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In all our previous chapters, we programed various recipes in a modeled centric
    way where we have an engine manager (renderer) that does all the required rendering
    activities for models. This approach is great for learning purposes, but in a
    real use case, we need scalability and manageability where multiple complex scenes
    can be handled easily. This chapter will introduce the scene-graph paradigm that
    allows you to program and manage complex scenes efficiently.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的所有章节中，我们都是以模型为中心的方式编写各种食谱，其中有一个引擎管理器（渲染器）负责为模型执行所有必要的渲染活动。这种方法对于学习目的来说很棒，但在实际应用中，我们需要可扩展性和可管理性，以便轻松处理多个复杂场景。本章将介绍场景图范式，它允许您有效地编程和管理复杂场景。
- en: '**Scene graph-based architecture**: The present design we used in existing
    recipes contains a renderer engine, which works in conjunction with other helper
    classes to render programed models. This simple architecture is wonderful for
    quick prototyping purposes. This has already been demonstrated in all the recipes
    in previous chapters.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于场景图的架构**：我们在现有食谱中使用的当前设计包含一个渲染引擎，它与其他辅助类协同工作以渲染程序模型。这种简单的架构非常适合快速原型设计。这一点已经在之前章节的所有食谱中得到了证明。'
- en: 'The modern 3D graphics use cases are not only limited to render a few chunks
    of objects in the 3D space, but the real-time challenge is to produce a state-of-the-art
    graphics engine that meets all modern graphical requirements. These include optimized
    rendering of complex scenes that involve a hierarchy of nodes, particles, mesmerizing
    shading effects, states, semantic logics, level of details, event handling, geospatial
    services, and so on. To meet these requirements, a modern 3D graphics application
    uses a scene graph-based architecture. The scene graph architecture encapsulates
    the hierarchical structure of a complete 3D scene, which has mainly two aspects:
    semantics and rendering. The semantic aspect works like a database, which manages
    the visual representation and state management. Think of it like a visual database
    that tells the graphical system the scene that''s going to come and the scene
    that''s not in use so that it can be released along with its resources for better
    optimization and memory management. On the other hand, the rendering aspect deals
    with the life cycle management of drawable entities or a model, which includes
    initialization, deinitialization, processing, control management and displaying
    them on screen.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现代三维图形应用不仅限于在三维空间中渲染少量对象块，真正的挑战是产生一个顶级的图形引擎，以满足所有现代图形要求。这包括优化渲染涉及节点层次结构的复杂场景，包括迷人的着色效果、状态、语义逻辑、细节级别、事件处理、地理空间服务等等。为了满足这些要求，现代三维图形应用使用基于场景图的架构。场景图架构封装了完整三维场景的层次结构，主要包含两个方面：语义和渲染。语义方面就像一个数据库，它管理视觉表示和状态管理。想象一下，它就像一个视觉数据库，告诉图形系统即将出现的场景和未使用的场景，以便它可以与其资源一起释放，以实现更好的优化和内存管理。另一方面，渲染方面处理可绘制实体或模型的生命周期管理，包括初始化、反初始化、处理、控制管理和在屏幕上显示它们。
- en: The scene graph is a big and evolving topic. Covering all its (requirement)
    aspects is out of the scope of this title. In this chapter, we will create a small
    architecture that allows you to manage multiple scenes; each scene can consist
    of multiple lights, cameras, and models. Complex models can be created using the
    parent-child relationships, with the help of local and relative transformations.
    Models can be applied to predefined materials dynamically and all this will be
    done outside the graphics engine in a separate C++ file. This will keep the scene-graph
    hierarchy logic preserved at a single place so that it can be managed easily.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 场景图是一个庞大且不断发展的主题。涵盖其所有（要求）方面超出了本标题的范围。在本章中，我们将创建一个小的架构，允许你管理多个场景；每个场景可以包含多个灯光、相机和模型。可以使用父子关系以及局部和相对变换来创建复杂模型。模型可以动态地应用于预定义的材料，所有这些操作都将在外部图形引擎的单独C++文件中完成。这将保持场景图层次逻辑在单一位置，以便易于管理。
- en: '**Difference with the existing design**: This chapter uses the knowledge of
    our existing rendering engine to produce the scene graph-based architecture. The
    existing design mainly consists of a renderer and model classes. The former is
    responsible for managing models, creating a single view, and processing events.
    On the other hand, the latter contains lights, material, performs the event handling
    process, and renders 3D objects.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**与现有设计的区别**：本章利用我们现有的渲染引擎知识来产生基于场景图的架构。现有设计主要包含渲染器和模型类。前者负责管理模型、创建单个视图和处理事件。另一方面，后者包含灯光、材料，执行事件处理过程，并渲染3D对象。'
- en: 'For real-time 3D applications, we need to extend our design to meet the requirements
    of the scene graph architecture:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实时3D应用程序，我们需要扩展我们的设计以满足场景图架构的要求：
- en: '**Hierarchical relationship**: Various modules of the system can be arranged
    in a hierarchical fashion. For example, the `Application` module contains the
    `Renderer` module inside and the application works in a singleton fashion. However,
    it can produce many threads to run one renderer instance in each. Each `Renderer`
    instance contains a `Scene` module, which contains the `Model` and `Camera`. The
    scene module can create different views from various cameras to visualize the
    rendering of models on screen.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层次关系**：系统的各个模块可以以层次化的方式排列。例如，`Application`模块内部包含`Renderer`模块，并且应用程序以单例模式运行。然而，它可以产生许多线程以运行每个渲染器实例。每个`Renderer`实例包含一个`Scene`模块，该模块包含`Model`和`Camera`。场景模块可以从不同的相机创建不同的视图，以可视化屏幕上模型的渲染。'
- en: '**Objects with parent-child relationship**: The objects of the similar type
    must support a parent-child relationship. In the parent-child relationship, a
    parent manages all its children automatically. This way, semantics and rendering
    can be managed in an optimized way.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**父子关系对象**：类似类型的对象必须支持父子关系。在父子关系中，父对象自动管理所有子对象。这样，语义和渲染可以以优化的方式进行管理。'
- en: '**Transforming graphs**: Each renderable object in a system stores the transformation
    with respect to its parent. In order to understand this, let''s take an example
    of a simple 3D model car that comprises of four tires, four doors, and a car body.
    If we want to translate this car by 2 units in the *x* axis direction, then using
    the existing design, we need to move all the nine parts of the car by 2 units.
    However, if we make the doors and tires as the children of the body of the car,
    then we do not need to worry about moving all nine parts; only the parent part
    (car body) will be enough to move all the related parts.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变换图**：系统中的每个可渲染对象都存储了相对于其父对象的变换。为了理解这一点，让我们以一个简单的3D模型汽车为例，该汽车由四个轮胎、四个车门和车身组成。如果我们想在*x*轴方向上平移这个汽车2个单位，那么使用现有设计，我们需要将汽车的九个部分都移动2个单位。然而，如果我们将车门和轮胎作为汽车车身的子对象，那么我们就不需要担心移动所有九个部分；只需要移动父部分（车身）就足够了。'
- en: '**Multiple scene management**: In the existing design, creating multiple scenes
    is not possible; in fact, everything is drawn as a single scene.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多个场景管理**：在现有设计中，创建多个场景是不可能的；实际上，所有内容都被绘制为一个单独的场景。'
- en: '**Separating semantic and rendering**: The rendering of objects must be loosely
    coupled with semantics. The rendering output can be affected by a number of factors,
    such as change in state, user input, or both. The design should be flexible enough
    to manage states and events.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分离语义和渲染**：对象的渲染必须与语义松散耦合。渲染输出可能受到许多因素的影响，例如状态变化、用户输入或两者兼有。设计应该足够灵活，以管理状态和事件。'
- en: '**Level of Detail** (**LOD**): LOD uses the computed information of an object
    and reveals how far it is from the camera view or an observer. If the object is
    outside the viewing frustum, then it can be ignored before it consumes vital resources
    of the system. The object in the frustum view, which are far away from the camera,
    can be rendered at a lower fidelity in which a fewer polygons and small textures
    can be used.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**细节级别**（**LOD**）：LOD 使用对象的计算信息，并揭示它距离摄像机视图或观察者的距离。如果对象位于视锥体之外，则可以在消耗系统关键资源之前忽略它。视锥体视图中的对象，如果远离摄像机，则可以以较低的保真度渲染，可以使用较少的多边形和小纹理。'
- en: '**State encapsulation**: It''s important that each node or object in the system
    contains a state that is able to reveal the nature of the object. This way several
    similar types of objects can be clubbed together by traversing the parent-child
    hierarchy; this will be highly efficient in avoiding random state switches, for
    example, texture loading and binding.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态封装**：在系统中，每个节点或对象包含一个能够揭示对象本质的状态是很重要的。这样可以通过遍历父子层次结构将几种类似类型的对象组合在一起；这将非常高效地避免随机状态切换，例如，纹理加载和绑定。'
- en: 'This chapter will take us through a systematic approach to develop scene graphs:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将带我们通过一种系统的方法来开发场景图：
- en: '**Implementing the first scene in the scene graph** (**recipe 1**): This recipe
    will build the foundation of scene graph, in which it will support scene, model,
    light and the material module. The modeling will be done outside the rendering
    engine in the `NativeTemplate.cpp`.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在场景图中实现第一个场景**（**菜谱 1**）：本菜谱将构建场景图的基础，其中它将支持场景、模型、灯光和材质模块。建模将在渲染引擎之外的 `NativeTemplate.cpp`
    中完成。'
- en: '**Adding local and relative transformation** (**recipe 2**): This recipe will
    introduce the local and the relative transformation concept to the existing scene
    graph. Local transformation is only applicable within the renderable object, whereas
    relative transformation is received from a parent and propagated to its children.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加局部和相对变换**（**菜谱 2**）：本菜谱将局部和相对变换概念引入现有的场景图中。局部变换仅适用于可渲染对象内部，而相对变换则从父对象接收并传播到其子对象。'
- en: '**Adding parent-child support in the scene graph** (**recipe 3**): This recipe
    builds the parent-child relationship between similar types of objects.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在场景图中添加父子支持**（**菜谱 3**）：本菜谱将在类似类型的对象之间建立父子关系。'
- en: '**Creating complex models using a transformation graph** (**recipe 4**): This
    recipe will make use of previous recipe concepts and demonstrate how to build
    complex animated models, such as a revolving windmill.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用变换图创建复杂模型**（**菜谱 4**）：本菜谱将利用之前的菜谱概念，并演示如何构建复杂的动画模型，例如旋转的风车。'
- en: '**Implementing picking using the ray trace technique** (**recipe 5**): This
    recipe will add the support of events to the scene graph and help in implementing
    the ray trace-based picking technique that allows you to select 3D objects in
    a scene.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用光线追踪技术实现拾取**（**菜谱 5**）：本菜谱将为场景图添加事件支持，并帮助实现基于光线追踪的拾取技术，允许你在场景中选择 3D 对象。'
- en: '**Implementing 2D textured button widgets** (**recipe 6**): Implementing 2D
    widgets uses the screen coordinate system. This recipe contains another subrecipe,
    which implements clicking on the button widget.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现 2D 纹理按钮小部件**（**菜谱 6**）：实现 2D 小部件使用屏幕坐标系。本菜谱包含另一个子菜谱，该子菜谱实现了在按钮小部件上点击。'
- en: '**Navigating a scene with the camera system** (**recipe 7**): This recipe will
    implement the camera support to the scene.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用摄像机系统导航场景**（**菜谱 7**）：本菜谱将实现摄像机对场景的支持。'
- en: '**Implementing a scene using multiple views** (**recipe 8**): This recipe enables
    scene graphics to render multiple views to a single scene.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用多个视图实现场景**（**菜谱 8**）：本菜谱使场景图形能够将多个视图渲染到单个场景中。'
- en: Implementing the first scene using a scene graph
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用场景图实现第一个场景
- en: Let's start by looking at the block diagram of the existing engine (left) with
    the new expected scene graph (right) design. This design is segregated into many
    simpler reusable modules, where each module is self-explanatory in the image itself.
    The `Object` module is a base class for most of the other modules. These modules
    exhibit the parent-child relationship. Similarly, modules that support the event
    handling process must be inherited from the `Event`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看现有引擎的块图（左侧）和新的预期场景图设计（右侧）开始。此设计被划分为许多更简单的可重用模块，其中每个模块在图像本身中都是自解释的。`Object`模块是大多数其他模块的基类。这些模块表现出父子关系。同样，支持事件处理过程的模块必须从`Event`继承。
- en: '![Implementing the first scene using a scene graph](img/5527OT_10_01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![使用场景图实现第一个场景](img/5527OT_10_01.jpg)'
- en: In the following image, you can see the hierarchical relationship among different
    modules in the scene graph. The `Renderer` is a graphics engine that contains
    various scenes. These scenes can be added to and removed from the rendering engine
    dynamically. A scene contains one or more cameras as per its requirements; it
    also contains models that the scene needs to render.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图像中，您可以看到场景图中不同模块之间的层次关系。`Renderer`是一个包含各种场景的图形引擎。这些场景可以动态地添加到和从渲染引擎中移除。根据需要，场景包含一个或多个相机；它还包含场景需要渲染的模型。
- en: 'Transformation is managed in the model-view-projection analogy, where the modeling
    transformation is carried out in the `Model` module and the projection and viewing
    transformation is calculated in the `Camera` module. As we are aware, any renderable
    object must be derived from the `Model` class, which exhibits a parent-child relationship,
    where the parent is fully responsible for managing the life cycle of their children.
    The events in the system flow in the top-down direction and the native application
    receives the events and passes them on to the `Renderer`, which further propagates
    the event to the scene. The scene detects the view to which the event belongs
    to and the events are sent to all corresponding Model''s derived classes in the
    view where it''s finally handled:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 变换在模型-视图-投影类比中管理，其中建模变换在`Model`模块中执行，而投影和视图变换在`Camera`模块中计算。正如我们所知，任何可渲染的对象都必须从`Model`类派生，它表现出父子关系，其中父类完全负责管理其子类的生命周期。系统中的事件按自上而下的方向流动，原生应用程序接收事件并将它们传递给`Renderer`，然后`Renderer`进一步将事件传播到场景。场景检测事件属于哪个视图，并将事件发送到所有相应的模型派生类，在那里最终处理：
- en: '![Implementing the first scene using a scene graph](img/5527OT_10_02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![使用场景图实现第一个场景](img/5527OT_10_02.jpg)'
- en: Getting ready
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This first recipe will implement the basic structure of the scene graph architecture
    described previously in the introduction section. For this recipe, we will implement
    the `Renderer`, `Scene`, `Light`, and `Material` modules. For the `Model` class,
    the changes are very minor. In the scene graph approach, the `Renderer` has simplified
    with the addition of other modules. As we move on to subsequent recipes, we will
    break down the complexity further into simpler modules:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个配方将实现介绍部分中先前描述的场景图架构的基本结构。对于这个配方，我们将实现`Renderer`、`Scene`、`Light`和`Material`模块。对于`Model`类，更改非常小。在场景图方法中，由于添加了其他模块，`Renderer`已经简化。随着我们继续到后续的配方，我们将进一步将复杂性分解为更简单的模块：
- en: '![Getting ready](img/5527OT_10_03.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/5527OT_10_03.jpg)'
- en: In the next section, we will understand the step-by-step procedure to implement
    our first scene. This recipe builds the foundation class of the scene graph, where
    we will describe the class structure and the definition of important member functions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解实现第一个场景的逐步过程。这个配方构建了场景图的基类，我们将描述类结构和重要成员函数的定义。
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Coding the definition of all functions may not be possible in this recipe. We
    will suggest our readers to follow the `SG1_withSceneLightMaterial` recipe provided
    with the sample code of this chapter to view the full source.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，可能无法编写所有函数的定义。我们将建议读者遵循本章示例代码中提供的`SG1_withSceneLightMaterial`配方来查看完整的源代码。
- en: How to do it...
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Here are the steps to implement the scene graph architecture:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 实现场景图架构的步骤如下：
- en: 'The new `Renderer` class is created in `RendererEx.h`; this new version has
    very less code compared to the older version. It manages all the scenes contained
    in it and takes care of the life cycle, such as initialization and rendering:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RendererEx.h` 中创建新的 `Renderer` 类；与旧版本相比，这个新版本有非常少的代码。它管理它包含的所有场景，并负责生命周期，如初始化和渲染：
- en: '[PRE0]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Define the member functions of `RendererEx.cpp`, as shown in the following
    code:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `RendererEx.cpp` 的成员函数，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create the `Light` class in `Light.h`/`.cpp` and implement it, as shown in
    the following code:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Light.h`/`.cpp` 中创建 `Light` 类并实现它，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Similarly, create `Material.h`/`.cpp` and implement the `Material` class as
    follows:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，创建 `Material.h`/`.cpp` 并实现 `Material` 类，如下所示：
- en: '[PRE3]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Define some common material types. For more information, refer to the sample
    code of this recipe:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一些常见的材料类型。有关更多信息，请参阅本菜谱的示例代码：
- en: '[PRE4]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All float data type (`GLfloat` or `float`) variables should be declared explicitly
    with the additional `f` sign in the end. Otherwise, during assignment, the variables
    will be treated as double and casted to the floating type, which will drastically
    decrease the performance.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有浮点数据类型（`GLfloat` 或 `float`）变量都应明确声明，并在末尾带有额外的 `f` 标志。否则，在赋值时，变量将被视为双精度类型，并转换为浮点类型，这将极大地降低性能。
- en: 'Create a scene class in `Scene.h`. This manages the models it contains inside.
    Currently, it does not contain any camera in it. We will add the camera later
    in this chapter. The scene provides many services to models, such as managing
    shader programs, transformation services, rendering of models, and so on. Each
    scene can be recognized with a unique name. While rendering each model, the scene
    maintains the reference of the current rendering model in the `currentModel`:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Scene.h` 中创建一个场景类。它管理其内部包含的模型。目前，它内部不包含任何相机。我们将在本章后面添加相机。场景为模型提供许多服务，例如管理着色器程序、转换服务、模型的渲染等。每个场景都可以通过一个独特的名称来识别。在渲染每个模型时，场景在
    `currentModel` 中维护当前渲染模型的引用：
- en: '[PRE5]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A scene contains multiple lights and models; these models and lights are added
    to the scene using the `addModel` and `addLight` function defined in the `Scene.cpp`:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 场景包含多个光源和模型；这些模型和光源是通过在 `Scene.cpp` 中定义的 `addModel` 和 `addLight` 函数添加到场景中的：
- en: '[PRE6]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create the `Model` class in `ModelEx.h`. This new version of the `Model` class
    contains the material and parent scene object:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ModelEx.h` 中创建 `Model` 类。这个 `Model` 类的新版本包含了材料和父场景对象：
- en: '[PRE7]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As the `ObjLoader` class is also a derivative of the `Model` class, it must
    also contain the reference of the scene under which it will execute. Modify the
    `ObjLoader` constructor to hold the scene reference and create two new functions
    (`ApplyLight`, `ApplyMaterial`) to apply the light and material information:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 `ObjLoader` 类也是 `Model` 类的派生类，它也必须包含它将执行的场景的引用。修改 `ObjLoader` 构造函数以保留场景引用，并创建两个新函数
    (`ApplyLight`，`ApplyMaterial`) 来应用光照和材料信息：
- en: '[PRE8]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The new method to apply light and materials must be applied before rendering
    the mesh object to the `ObjLoader::render` method, as given in the following code:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将网格对象渲染到 `ObjLoader::render` 方法之前，必须应用新的光照和材料应用方法，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In `NativeTemplate.cpp`, create a scene in the `GraphicsInit` function and
    add a light and mesh object to it. Execute the scene by adding these objects to
    the engine:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `NativeTemplate.cpp` 中，在 `GraphicsInit` 函数中创建一个场景，并向其中添加一个光源和网格对象。通过将这些对象添加到引擎中来执行场景：
- en: '[PRE10]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Similarly, the `GraphicsRender` function renders the mesh model and updates
    the scene and related modules. In this recipe, it applies various predefined material
    types on the mesh model for every one second:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，`GraphicsRender` 函数渲染网格模型并更新场景和相关模块。在本菜谱中，它每秒对网格模型应用各种预定义的材料类型：
- en: '[PRE11]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Renderer` class in the scene graph model is highly simplified compared
    to the earlier overloaded version; `Scenes` are a containment of the `Renderer`
    class. A scene must be created dynamically and added to the rendering engine.
    Similarly, it can be removed from the engine, which allows you to save vital memory
    resources and CPU cycles. Every scene has a unique name that can be used to retrieve
    the scene from the engine; the scene has a containment relationship with lights
    and models. Each scene can have multiple lights. However, the present implementation
    only supports a single light; the models retrieve the light information from their
    respective scenes. The implementation of a Model class has not changed much except
    for the fact that from now onwards the materials can be applied at runtime using
    the light information from the scene. The scene graph allows sharing the models
    from one scene to another without any overhead, thus making it highly flexible.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与早期重载版本相比，场景图模型中的`Renderer`类高度简化；`Scenes`是`Renderer`类的容器。场景必须动态创建并添加到渲染引擎中。同样，它可以从引擎中移除，这允许您节省重要的内存资源和CPU周期。每个场景都有一个唯一名称，可以用于从引擎中检索场景；场景与灯光和模型具有包含关系。每个场景可以有多个灯光。然而，当前实现仅支持单个灯光；模型从它们各自的场景中检索灯光信息。模型类的实现没有太大变化，除了从现在开始，材质可以使用场景的灯光信息在运行时应用。场景图允许在没有任何开销的情况下从一个场景共享模型到另一个场景，从而使其非常灵活。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In order to differentiate the `Renderer` and `Model` classes of the older graphics
    engine with the scene graph architecture, the filenames of the newer class are
    suffixed with `Ex` (`RendererEx.h`/`.cpp`, `ModelEx.h`/`.cpp`).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了区分旧版图形引擎中基于场景图架构的`Renderer`和`Model`类，新类文件名后缀为`Ex`（`RendererEx.h`/`.cpp`，`ModelEx.h`/`.cpp`）。
- en: The scene graph architecture allows you to create modeling of the scenes and
    the control logic outside the engine; this is a more generic and expected way
    of programming. This recipe uses `NativeTemplate.cpp` as an external file for
    modeling and rendering purposes. In this file, the initialization scene is done
    in the `GraphicsInit()`. First, the `graphicsEngine` rendering engine object is
    created. This engine is set to the `Scene's` object called `scene1` and the parameterized
    constructor of the `Scene` contains its name and the parent object of the rendering
    engine in which it resides. The scene contains a white light source, which is
    situated 10 units away in the *z* direction.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 场景图架构允许您在引擎外部创建场景建模和控制逻辑；这是一种更通用和预期的编程方式。此配方使用`NativeTemplate.cpp`作为建模和渲染的外部文件。在此文件中，初始化场景在`GraphicsInit()`中完成。首先，创建`graphicsEngine`渲染引擎对象。此引擎设置为名为`scene1`的`Scene`对象，`Scene`的参数化构造函数包含其名称和它所在的渲染引擎的父对象。场景包含一个位于*z*方向10个单位处的白色光源。
- en: The `Model` object, namely, `Suzzane,` is created using the parameterized constructor
    of `ObjLoader` and is applied to the predefined copper colored material type.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Model`对象，即`Suzzane`，是使用`ObjLoader`的参数化构造函数创建的，并应用于预定义的铜色材质类型。'
- en: 'The scene is controlled in `GraphicsRender()`. In this function, various types
    of materials are applied at runtime after a regular interval of one second, as
    shown in the following image:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 场景在`GraphicsRender()`中控制。在此函数中，各种类型的材质在每秒正常间隔后运行时应用，如下所示：
- en: '![How it works...](img/5527OT_10_04.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/5527OT_10_04.jpg)'
- en: See also
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Building prototypes using the GLPI framework* recipe in [Chapter
    2](ch02.html "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES 3.0 Essentials*
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[第2章](ch02.html "第2章。OpenGL ES 3.0 基础")中的*使用GLPI框架构建原型*配方，*OpenGL ES 3.0
    基础*。
- en: Adding local and relative transformations
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加局部和相对变换
- en: 'Transformation can be divided into two types:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 变换可以分为两种类型：
- en: '**Local transformation**: This type of transformation is only applicable to
    an object; it does not affect its child objects. For example, if two objects are
    in a parent-child relationship, then applying the local scale transformation will
    not scale the child object.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**局部变换**：此类变换仅适用于对象本身；它不会影响其子对象。例如，如果两个对象之间存在父子关系，那么应用局部缩放变换将不会缩放子对象。'
- en: '**Relative transformation**: This type of transformation is applied with respect
    to the parent of the object. Here, the transformation of the parent is propagated
    to the children, thereby affecting the geometrical vertex positions in the 3D
    space. For example, in this case, the scaling transformation to the parent object
    will scale all its children and their children.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相对变换**：此类变换相对于对象的父对象应用。在这里，父对象的变换被传播到子对象，从而影响3D空间中的几何顶点位置。例如，在本例中，对父对象的缩放变换将缩放所有子对象及其子对象。'
- en: Note
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If an object does not have a parent (called the `root` object), then the OpenGL
    ES coordinate system will be considered its parent. The next recipe will discuss
    more about the parent-child relationship.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果一个对象没有父对象（称为`root`对象），则OpenGL ES坐标系将被视为其父对象。下一个配方将讨论更多关于父子关系的内容。
- en: This recipe will create two mesh objects (`Torus`, `Suzzane`) and produce an
    effect similar to the moon's (`Suzzane`) revolution around the `Earth` (`Torus`).
    The moon not only revolves around Earth, but also revolves around its own axis
    at the same time.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方将创建两个网格对象（`Torus`，`Suzzane`）并产生类似于月亮（`Suzzane`）围绕地球（`Torus`）公转的效果。月亮不仅围绕地球公转，同时也在围绕自己的轴旋转。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the internals of the 3D transformation, you can refer
    to *Implementing scene with the model, view, and projection analogies* recipe
    in [Chapter 2](ch02.html "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES 3.0
    Essentials*. This topic covers various types of transformation, transformation
    matrix conventions, homogenous coordinates, and transformation operations, such
    as translation, scaling, and rotation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 关于3D变换内部机制的更多信息，您可以参考[第2章](ch02.html "第2章。OpenGL ES 3.0 基础")中“使用模型、视图和投影类比实现场景”的配方，*OpenGL
    ES 3.0 基础*。本主题涵盖了各种类型的变换、变换矩阵约定、齐次坐标以及变换操作，如平移、缩放和旋转。
- en: Getting ready
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe requires the first recipe as a prerequisite; you are advised to
    understand the implementation of the first recipe. You can locate the source of
    the current recipe (`SG2_withSG1+Transformation`) that is provided with the sample
    code in this chapter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方需要第一个配方作为先决条件；建议您理解第一个配方的实现。您可以在本章提供的示例代码中找到当前配方（`SG2_withSG1+Transformation`）的源代码。
- en: How to do it...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Here are the steps to implement local- and relative-transformation in the existing
    scene graph architecture:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是实现现有场景图架构中局部和相对变换的步骤：
- en: 'In `ModelEx.h`, add the following member variables in `Model` class. These
    variables are responsible for storing the local and relative transformation matrix.
    It also has a center of the origin around which the transformation will be applied:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ModelEx.h`中，向`Model`类中添加以下成员变量。这些变量负责存储局部和相对变换矩阵。它还有一个变换的原点中心：
- en: '[PRE12]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Go to `ModelEx.cpp` and implement the local transformation function and the
    relative transformation function:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`ModelEx.cpp`并实现局部变换函数和相对变换函数：
- en: '[PRE13]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This step is extremely important; it provides the thumb rule to apply local
    and relative transformation in the `Model` functions derivative classes. For more
    information, see the implementation of the `Render()` function in the `ObjLoader.cpp`
    and add the following member functions to the respective variables:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此步骤非常重要；它提供了在`Model`函数派生类中应用局部和相对变换的拇指规则。更多信息，请参阅`ObjLoader.cpp`中`Render()`函数的实现，并将以下成员函数添加到相应的变量中：
- en: '[PRE14]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In `NativeTemplate.cpp`, edit the `GraphicsInit()` function, as shown in the
    following code:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NativeTemplate.cpp`中，编辑`GraphicsInit()`函数，如下所示：
- en: '[PRE15]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Use the same file and edit the `GraphicsRender()` function to apply the relative
    and local transformation on `Suzzane`, as shown in the following code:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的文件并编辑`GraphicsRender()`函数，以在`Suzzane`上应用相对和局部变换，如下所示：
- en: '[PRE16]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works…
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The transformation of each `Model` object is stored locally in the transformation
    and transformationLocal variable. These variables store the translate, rotate,
    and scaling information. The former variable accumulates all the transformation
    applied to the parent and its ancestors; each parent object propagates its transformation
    information to its children. The latter variable only stores the transformation
    information that is applied to the current object locally; it never passes this
    transformation to its children. The mechanism that differentiates between relative
    and local transformation needs to be implemented by a developer in the `Model`
    derived class in the `Render` function (see step three in the previous section):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Model`对象的变换存储在本地变换和变换Local变量中。这些变量存储平移、旋转和缩放信息。前一个变量累积应用于父及其祖先的所有变换；每个父对象将其变换信息传播给其子对象。后一个变量仅存储应用于当前对象的本地变换信息；它永远不会将此变换传递给其子对象。区分相对变换和本地变换的机制需要由开发者在`Render`函数中实现的`Model`派生类中实现（参见前一小节中的第三步）：
- en: '![How it works…](img/5527OT_10_05.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/5527OT_10_05.jpg)'
- en: 'In the current recipe, Torus will act as a reference to the center point of
    the parent OpenGL ES coordinate system. More specifically, the Torus will render
    to the OpenGL ES origin, which is (0.0, 0.0, and 0.0). The model is also scaled
    down and it appears like a center point. The `Suzzane` performs two types of rotations
    in order to demonstrate the relative and local transformation. In the former transformation,
    the `Suzzane` will be placed 3 units away from the origin and also set with a
    center (0.0, 0.0, and -3.0) so that it can revolve around the new origin (center).
    However, in the latter transformation, `Suzzane` rotates around its own axis.
    In the `GraphicsRender` function, `Suzzane` is rotated by one degree on each frame
    locally and relatively, as shown in the following image:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前配方中，Torus将作为父OpenGL ES坐标系统中心点的参考。更具体地说，Torus将渲染到OpenGL ES原点，即(0.0, 0.0, 0.0)。模型也被缩小了，看起来像是一个中心点。`Suzzane`执行两种类型的旋转以演示相对和本地变换。在前一种变换中，`Suzzane`将被放置在原点3个单位之外，并且设置中心为(0.0,
    0.0, -3.0)，以便它可以围绕新的原点（中心）旋转。然而，在后一种变换中，`Suzzane`围绕其自身轴旋转。在`GraphicsRender`函数中，`Suzzane`在每个帧上本地和相对旋转一度，如图所示：
- en: '![How it works…](img/5527OT_10_06.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/5527OT_10_06.jpg)'
- en: See also
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见：
- en: '*Adding parent-child support in the scene graph*'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在场景图中添加父子关系支持*'
- en: Adding parent-child support in the scene graph
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在场景图中添加父子关系支持
- en: 'This recipe is a very important milestone in the architecture of scene graphs;
    needless to say, a scene graph is all about the hierarchical connectivity. In
    the current concept, we maintain the parent-child relationship among similar types
    of objects. This recipe contains two subrecipes:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方是场景图架构中的一个非常重要的里程碑；不用说，场景图全部关于层次连接性。在当前的概念中，我们维护相似类型对象之间的父子关系。这个配方包含两个子配方：
- en: Building a simple parent-child relationship among renderable objects
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在可渲染对象之间构建简单的父子关系
- en: Understanding the concept of a dummy parent
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 理解虚拟父的概念
- en: Note
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The parent-child relationship is applicable to all renderable objects (derived
    from the `Model` class) and logical engine entities, such as scenes, renderer,
    and so on. In the present scene graph architecture, this relationship is achieved
    through the `Object` class. This class allows you to add/remove children dynamically;
    each object can be recognized with a user-defined name.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 父子关系适用于所有可渲染对象（从`Model`类派生）和逻辑引擎实体，如场景、渲染器等。在当前的场景图架构中，这种关系是通过`Object`类实现的。这个类允许你动态地添加/删除子对象；每个对象都可以通过用户定义的名称来识别。
- en: How to do it...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Make use of the last recipe that we implemented in this chapter and the following
    steps to add the support of the parent-child relationship:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 利用本章中我们实现的最后一个配方以及以下步骤来添加父子关系的支持：
- en: 'Create `Object.h` and edit the following code. Each object of this class has
    a name, a parent, and one of more children stored in the child list. The parent''s
    information is set in the constructor. This class provides high level functions
    for retrieving the parent or child information, which can be added or removed
    at fly time. The function of each name is self-explanatory to describe the kind
    of job it performs:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `Object.h` 并编辑以下代码。这个类的每个对象都有一个名称、一个父对象，以及存储在子列表中的一个或多个子对象。父对象的信息在构造函数中设置。这个类提供了高级功能来检索父或子信息，这些信息可以在运行时添加或删除。每个名称的功能都是不言自明的，用来描述它执行的工作类型：
- en: '[PRE17]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create `Object.cpp` and define high level methods that cannot be defined inline
    in the header file. The constructor accepts the name and the parent (`parentObj`)
    of the object; the `RemoveParent` removes the parent of an object and ensures
    that none of the children exists in the parent `childList`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `Object.cpp` 并定义在头文件中无法内联定义的高级方法。构造函数接受对象的名称和父对象（`parentObj`）；`RemoveParent`
    方法移除对象的父对象，并确保父对象的 `childList` 中不存在任何子对象：
- en: '[PRE18]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Implement the `setVisible` and propagate the visibility of the children based
    on the last parameter: `applyToChildren`, if applicable:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `setVisible` 并根据最后一个参数 `applyToChildren`（如果适用）传播子对象的可见性：
- en: '[PRE19]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Derive the `Renderer`, `Scene`, and `Model` class from the `Object` class.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Object` 类派生出 `Renderer`、`Scene` 和 `Model` 类。
- en: 'In the derived version for `Model` classes, handle the object visibility, as
    given in the following code. For more information, refer to `ObjLoader::Render`:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在派生的 `Model` 类版本中，处理对象的可见性，如下代码所示。更多信息，请参考 `ObjLoader::Render`：
- en: '[PRE20]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Implement the rendering of child models:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现子模型的渲染：
- en: '[PRE21]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Use `NativeTemplate.cpp` and add implement the parent-child modeling:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `NativeTemplate.cpp` 并添加实现父子建模：
- en: '[PRE22]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Any renderable (`Model` and `derivatives`) or nonrenderable entities (`Renderer`,
    `Scene`, and `derivative`) can be derived from the `Object` class in order to
    achieve the parent-child relationship. The `Object` class stores the parent's
    information in the parent variable and child information in a vector list called
    `childList`; any other class object can access the parent and child information
    using the `GetParent()` and `GetChildren()` function.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可渲染的实体（`Model` 及其派生类）或不可渲染的实体（`Renderer`、`Scene` 及其派生类）都可以从 `Object` 类派生出来，以实现父子关系。`Object`
    类在父变量中存储父对象信息，在名为 `childList` 的向量列表中存储子对象信息；任何其他类对象都可以使用 `GetParent()` 和 `GetChildren()`
    函数访问父和子信息。
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Each parent is responsible for taking care of its children's execution life
    cycle. For example, a parent scene will automatically load the children scenes
    one by one. Similarly, a `Model` loads its children and manages their initialization
    to load the required shaders, propagating parent's transformation to children
    and rendering of each child model.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 每个父对象都负责照顾其子对象的执行生命周期。例如，父场景将自动逐个加载子场景。同样，`Model` 加载其子对象并管理它们的初始化，加载所需的着色器，将父对象的转换传播到子对象，并渲染每个子模型。
- en: 'This recipe contains seven models (five sphere (one big, four small), two cubes),
    as shown in the following left-hand side image. The parent-child relationship
    is shown in the following right-hand side image in which the yellow sphere is
    the parent of two copper colored cubes and each cube has two silver color sphere
    attached to it. The yellow sphere rotates around the *y* axis; this makes all
    children elements to rotate around the yellow sphere, while the cubes revolve
    around the *y* axis. At the same time, they revolve around their own *x* axis,
    one in a clockwise direction and another in an anticlockwise direction:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方包含七个模型（五个球体（一个大的，四个小的），两个立方体），如下左图所示。父子关系如下右图所示，其中黄色球体是两个铜色立方体的父对象，每个立方体都连接有两个银色球体。黄色球体绕
    *y* 轴旋转；这使得所有子元素围绕黄色球体旋转，而立方体则绕 *y* 轴旋转。同时，它们还绕自己的 *x* 轴旋转，一个顺时针方向，另一个逆时针方向：
- en: '![How it works...](img/5527OT_10_07.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/5527OT_10_07.jpg)'
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Refer to *Create complex models with a transformation graph* recipe. This recipe
    guides you to create a windmill model using the parent-child relationship and
    local/relative transformation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 参考使用转换图创建复杂模型的配方。这个配方指导你使用父子关系和局部/相对转换创建风车模型。
- en: There's more...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Look at the following image and try to figure out how we can solve it with the
    existing parent-child relationship approach.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的图片，尝试弄清楚我们如何使用现有的父子关系方法来解决这个问题。
- en: '**Problem statement**:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题陈述**：'
- en: 'A set of semi-circumferences (created from cubes) are arranged in a concentric
    fashion, where each semi-circumference rotates in the opposite direction with
    respect to its neighboring semi-circumference:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一组半圆（由立方体创建）以同心方式排列，其中每个半圆相对于其相邻半圆旋转方向相反：
- en: '![There''s more...](img/5527OT_10_08.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/5527OT_10_08.jpg)'
- en: In the present situation, we have eight concentric semi-circumferences. Considering
    the innermost semi-circumference as the parent of others, one really has to scratch
    one's head to solve it (give it a try).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前情况下，我们有八个同心半圆。将最内层的半圆视为其他半圆的父级，解决它（尝试一下）确实需要动脑筋。
- en: Sometimes, there are complex parent-child situations that can be solved easily.
    As a solution to this problem, we can create eight parents, apply transformations
    as required, create two parent objects (innermost), and add children, based on
    the direction of the rotation. Finally, move one parent clockwise and another
    anticlockwise. This recipe uses the previous solution with the dummy parent, which
    is described ahead.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，存在一些复杂的父子关系问题可以轻松解决。作为对这个问题的解决方案，我们可以创建八个父级，根据需要应用变换，创建两个父级对象（最内层），并根据旋转方向添加子级。最后，将一个父级顺时针移动，另一个逆时针移动。这个配方使用了前面描述的带有虚拟父级的解决方案。
- en: 'So far, we have seen the all parent of the renderable entities, which are also
    renderable. This is where dummy parent concepts come into the picture. This allows
    you to create a parent, which does not have any geometry. Therefore, it cannot
    be rendered and provides a logical parent-child relationship. The `Render` method
    does not render anything and is only used to apply transformation. The local transformation
    here does not make any sense as the object''s geometry does not exist:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了所有可渲染实体的父级，这些实体也是可渲染的。这就是虚拟父级概念出现的地方。这允许你创建一个没有几何形状的父级。因此，它不能被渲染，并提供了一个逻辑上的父子关系。`Render`
    方法不渲染任何内容，仅用于应用变换。这里的局部变换没有意义，因为对象的几何形状不存在：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: See also
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Creating complex models with transformation graph*'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用变换图创建复杂模型*'
- en: Creating complex models with a transformation graph
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用变换图创建复杂模型
- en: 'A transformation graph is a forest of semantic transformations in which each
    node represents a tree of models. Combining all of these tree models produces
    a complex 3D model structure. The following image on the left-hand side shows
    a semantic model of the transformation. The right-hand side image shows a tree
    structure represented by each of the nodes in the semantic transformation graph:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 变换图是一棵语义变换的森林，其中每个节点代表一个模型树。结合所有这些树模型产生了一个复杂的3D模型结构。左侧的图像显示了变换的语义模型。右侧的图像显示了由语义变换图中的每个节点表示的树结构：
- en: '![Creating complex models with a transformation graph](img/5527OT_10_09.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![使用变换图创建复杂模型](img/5527OT_10_09.jpg)'
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Transformation graphs use the parent-child relationship extensively. Without
    this, the transform graph hierarchy is very difficult to manage. A transformation
    graph represents node hierarchies, in which each child node contains the transformation
    information (translate, scale, and rotate) with respect to its parent.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 变换图广泛使用父子关系。没有它，变换图层次结构很难管理。变换图表示节点层次结构，其中每个子节点包含相对于其父节点的变换信息（平移、缩放和旋转）。
- en: This recipe is the hybrid of the previous two recipes. It will use the parent-child
    relationship and the local and relative transformation to produce a semantic transformation
    graph. In this recipe, you will learn how to create a complex windmill model with
    basic mesh models, such as cube, cylinder, and sphere.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方是前两个配方的混合体。它将使用父子关系和局部和相对变换来生成语义变换图。在这个配方中，你将学习如何使用基本的网格模型（如立方体、圆柱体和球体）创建复杂的风车模型。
- en: How to do it...
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'This recipe does not require any special changes in the scene-graph engine.
    Use `NativeTemplate.cpp` and edit the `GraphicsInit` and `GraphicsRender`, as
    shown in the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方不需要对场景图引擎进行任何特殊更改。使用 `NativeTemplate.cpp` 并编辑 `GraphicsInit` 和 `GraphicsRender`，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The windmill model comprises of a total of 24 parts: one base, one stand, one
    motor shaft, one motor engine, and 20 fan blades. The base, motor shaft, and fan
    blades are made up of cube meshes, whereas the stand and motor engine is made
    up of cylinder and sphere meshes respectively. All these parts must be arranged
    in the correct parent-child order and at the same time applied to correct placement,
    using the local and relative transformation in the 3D space. A picture is worth
    a thousand words, by looking at the following image, you must have got the idea
    on how a complete model is woven part by part.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 风车模型由总共24个部分组成：一个底座、一个支架、一个电机轴、一个电机引擎和20个风扇叶片。底座、电机轴和风扇叶片由立方网格制成，而支架和电机引擎则分别由圆柱和球体网格制成。所有这些部分必须按照正确的父子顺序排列，并且同时应用正确的放置，使用3D空间中的局部和相对变换。一图胜千言，通过查看以下图片，你一定能对如何逐部分编织完整模型有所了解。
- en: Let's understand the working of this windmill. In the `GraphicsInit()`, the
    first thing that we need is the base of the windmill, which is created using a
    perfect cube (**A**). This cube is locally scaled in order to produce a shape
    depicted by (**B**). Next, the stand is made from a cylinder and translated to
    four units (**C**) before the origin and then scaled (**D**) so that it perfectly
    expands in the vertical direction to fit in to the base. The base here is the
    parent of the stand. The motor shaft is also made up of the (**E**) cube, which
    translates into four units (**F**). This model is scaled locally in order to give
    it the (**G**) shape.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解这个风车的工作原理。在`GraphicsInit()`中，我们首先需要的是风车的底座，它使用一个完美的立方体（**A**）创建。这个立方体在局部缩放以产生由（**B**）表示的形状。接下来，支架由一个圆柱体制成，并平移到原点前四个单位（**C**），然后进行缩放（**D**），以便在垂直方向上完美扩展以适应底座。这里的底座是支架的父节点。电机轴也由（**E**）立方体组成，它平移到四个单位（**F**）。此模型在局部缩放以获得（**G**）形状。
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Every transformation that we apply is with respect to its parent. Therefore,
    in the present case, four units in the vertical direction are with respect to
    the stand, which is the parent of the `MotorShaft`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用的每个变换都是相对于其父节点。因此，在当前情况下，垂直方向上的四个单位是相对于支架，它是`MotorShaft`的父节点。
- en: Create a sphere in order to produce a `MotorEngine` (**H**) and render it to
    the **+Z** direction by two units (**I**). The final part is to create the fan
    blade. Each fan blade is made up of a cube (**J**). This cube needs to render
    away from the parent center by four units in the vertical direction (**K**). The
    translate blade is then applied to the local scaling in order to create a blade
    like shape (**L**). Similarly, this process of producing blades is repeated 20
    times to build the complete fan (**M**, **N**).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个球体以产生一个`MotorEngine`（**H**），并将其渲染到**+Z**方向两个单位（**I**）。最后一部分是创建风扇叶片。每个风扇叶片由一个立方体（**J**）组成。这个立方体需要垂直方向上远离父节点中心四个单位进行渲染（**K**）。然后将平移叶片应用于局部缩放，以创建类似叶片的形状（**L**）。同样，这个过程重复20次以构建完整的风扇（**M**，**N**）。
- en: 'Finally, once the geometry is created, the parent node (base) of the windmill
    is added to the scene. Why haven''t the other models been added to the scene?
    In previous recipes, we mentioned that each parent model takes care of its children.
    As the base is added to the scene, it takes care of its child elements. The same
    rule is applicable to all child elements, which are themselves parents of other
    items:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦创建了几何形状，风车的父节点（底座）就被添加到场景中。为什么其他模型没有被添加到场景中？在之前的菜谱中，我们提到每个父模型都会照顾其子模型。由于底座被添加到场景中，它就会照顾其子元素。同样的规则适用于所有子元素，它们本身也是其他项目的父节点：
- en: '![How it works...](img/5527OT_10_10.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/5527OT_10_10.jpg)'
- en: The windmill fan blades rotate by three degrees around the *z* axis of each
    frame. This transformation can be simply achieved by applying the rotation on
    the sphere, which is the parent of all blades. Similarly, in order to revolve
    the whole model around the *y* axis, apply a one degree rotation on the base in
    the `GraphicsRender()`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 风车风扇叶片围绕每个帧的*z*轴旋转三个度。这种变换可以通过在所有叶片的父节点球体上应用旋转来简单地实现。同样，为了使整个模型围绕*y*轴旋转，在`GraphicsRender()`中在底座上应用一度旋转。
- en: See also
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Adding parent-child support in the scene graph*'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在场景图中添加父子支持*'
- en: '*Adding local and relative transformations*'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*添加局部和相对变换*'
- en: Implementing picking with the ray trace technique
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用光线追踪技术实现拾取
- en: Picking is a process of selecting objects in the 3D space contained in a scene
    by user inputs. This is a very common requirement in 3D graphic applications,
    where you may be interested in an object tapped by an end user. The tapped point
    contains position in the screen coordinate system, which is a reference to the
    viewport. This reference point can be used in various picking techniques to detect
    the tapped object. In the present recipe, we will use a very versatile picking
    technique called "ray picking" or "ray trace pick".
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 拾取是通过用户输入在场景中3D空间选择对象的过程。这是3D图形应用中非常常见的需求，您可能对最终用户点击的对象感兴趣。点击点包含屏幕坐标系中的位置，这是视口的参考。此参考点可用于各种拾取技术来检测点击的对象。在本例中，我们将使用一种非常通用的拾取技术，称为“光线拾取”或“光线追踪拾取”。
- en: In this technique, a ray is simulated using the tapped point in the scene. When
    the ray intersects with an object, it's assumed to be clicked on. The ray can
    be intersected with multiple objects in a given scene; the selected objects can
    be collected and sorted according to the distance from the viewpoint in order
    to become the closest selected object. In this recipe, we will implement the ray
    trace picking technique, which is highly accurate in pinpointing 3D objects.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在此技术中，使用场景中的点击点模拟一条光线。当光线与对象相交时，假设它被点击。光线可以与给定场景中的多个对象相交；可以选择的对象可以根据从视点的距离进行收集和排序，以成为最近的选中对象。在本例中，我们将实现光线追踪拾取技术，该技术在高精度定位3D对象方面非常准确。
- en: 'The following steps provide an overview of implementing ray tracing picking:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤概述了实现光线追踪拾取的过程：
- en: Detect the tapped point on screen (Sx, Sy).
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检测屏幕上的点击点（Sx, Sy）。
- en: Use (Sx, Sy) and find unprojected coordinates on the near (Nx, Ny) and far plane
    (Fx, Fy).
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用（Sx, Sy）并找到近平面（Nx, Ny）和远平面（Fx, Fy）上的未投影坐标。
- en: Create a ray from (Nx, Ny) and (Fx, Fy) unprojected coordinates.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从（Nx, Ny）和（Fx, Fy）未投影坐标创建一条光线。
- en: Consider each triangle of the mesh geometry and perform the ray triangle intersection.
    The test can be optimized using a low polygon mesh.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑网格几何形状中的每个三角形并执行光线与三角形的交点测试。可以使用低多边形网格优化此测试。
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Here are the steps to implement ray-trace picking:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 实现光线追踪拾取的步骤如下：
- en: 'Create an interface class called `GestureEvent` derived from `Event` in a new
    file called `Event.h`/`.cpp`. This will provide the necessary interfaces for touch
    screen events. Classes that want to utilize the benefits of gesturing must be
    derived from the `GestureEvent` class:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为`Event.h`/`.cpp`的新文件中创建一个从`Event`派生的接口类`GestureEvent`。这将提供触摸屏事件所需的接口。希望利用手势优势的类必须从`GestureEvent`类派生：
- en: '[PRE25]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `Renderer`, `Scene`, and `Model` class need to be inherited with `GestureEvent`
    in order to support touch events. Include the `Event.h` header file in their respective
    classes:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Renderer`、`Scene`和`Model`类需要继承`GestureEvent`以支持触摸事件。在各自的类中包含`Event.h`头文件：'
- en: '[PRE26]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Propagate gesture events to all scenes in the `Renderer` class:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Renderer`类中将手势事件传播到所有场景：
- en: '[PRE27]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Implement gesture interfaces in the `Scene` class and propagate the received
    touch events from renderer to all the models contained in the following code:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Scene`类中实现手势界面，并将接收到的触摸事件从renderer传播到以下代码中包含的所有模型：
- en: '[PRE28]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Implement gesture interfaces in the `Model` and apply them to each child:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Model`中实现手势界面并将其应用于每个子项：
- en: '[PRE29]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create a `Ray.h`/`.cpp` file and define the `Ray` class, as given in the following
    code:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Ray.h`/`.cpp`的文件并定义`Ray`类，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a function called `IntersectWithRay` in the base `Model` class and implement
    in the `ObjLoader` derived class:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在基类`Model`中创建一个名为`IntersectWithRay`的函数，并在`ObjLoader`派生类中实现：
- en: '[PRE31]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create a function called `IntersectWithRay` in the base `Model` class and implement
    it in the derived version classes, such as `ObjLoader`, in the present scenario:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在基类`Model`中创建一个名为`IntersectWithRay`的函数，并在当前场景中的派生版本类（如`ObjLoader`）中实现：
- en: '[PRE32]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works...
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The `GestureEvent` class receives the tap event (Sx, Sy) in the screen coordinate
    system from the main application in Renderer and passes it to Model classes via
    the respective parent scene. These coordinates are then used to calculate unprojected
    coordinates on the near and far plane. In the present recipe, we have used the
    `glm::unproject` API:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`GestureEvent`类从Renderer中的主应用程序接收屏幕坐标系中的点击事件（Sx, Sy），并通过相应的父场景传递给Model类。然后，这些坐标用于计算近平面和远平面上的未投影坐标。在本例中，我们使用了`glm::unproject`
    API：'
- en: '**Syntax**:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：'
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '| Variable | Description |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `win` | Components *x*, *y* specify screen coordinates. The *z* with value
    zero and one specify the near and far plane respectively. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `win` | 组件 *x*、*y* 指定屏幕坐标。值为零和一的 *z* 分别指定近平面和远平面。 |'
- en: '| `modelView` | This specifies the product of the view and model matrix. |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `modelView` | 这指定了视图和模型矩阵的乘积。 |'
- en: '| `proj` | This specifies the project matrix of the current scene. |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `proj` | 这指定了当前场景的投影矩阵。 |'
- en: '| `viewport` | This specifies the current dimension of the viewport region.
    |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `viewport` | 这指定了视口区域的当前维度。 |'
- en: 'The unproject inverts the operation of projection calculation in which world
    coordinates are used to calculate screen coordinate in the following order:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 反投影操作反转了投影计算的操作，其中使用世界坐标来计算屏幕坐标的顺序如下：
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![How it works...](img/5527OT_10_11.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/5527OT_10_11.jpg)'
- en: Unprojected coordinates on the near plane (Nx, Ny) and the far plane (Fx, Fy)
    are used to shoot a ray from the near to the far plane, as shown in the preceding
    image (**B**). When this ray hits a 3D object, it is considered to be picked.
    Mathematically, this picking is performed by taking the intersection of mesh polygons
    and ray produced. For the sake of simplicity, we used the line and triangle intersection
    in the present recipe, as shown in image (**A**). The mesh is iterated for each
    triangle in it and intersected by the ray using the `IntersectWithRay` function,
    which is inherited from `Model`. This function must be overridden in the derived
    version in order to perform the intersection test. The `ObjLoader` class overrides
    this function and calculates the ray-triangle intersection using the `glm::intersectLineTriangle`
    API. This recipe paints all the selected 3D mesh objects with ambient red, which
    are intersected by the ray. In order to find the closest selected object, sort
    the entire selected item and choose the closest one from the camera view.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在近平面（Nx, Ny）和远平面（Fx, Fy）上的未投影坐标用于从近平面向远平面发射一条射线，如图中所示（**B**）。当这条射线击中一个 3D 对象时，它被认为是已选中。从数学上讲，这种选择是通过取网格多边形和产生的射线的交点来执行的。为了简化，我们在本配方中使用了线和三角形的交点，如图（**A**）所示。网格迭代每个三角形，并使用从
    `Model` 继承的 `IntersectWithRay` 函数与射线相交。此函数必须在派生版本中重写，以便执行交点测试。`ObjLoader` 类重写了此函数，并使用
    `glm::intersectLineTriangle` API 计算射线-三角形交点。此配方将所有选中的 3D 网格对象用环境红色绘制，这些对象与射线相交。为了找到最近的选中对象，对整个选中项进行排序，并从摄像机视图中选择最近的那个。
- en: See also
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Implementing 2D textured button widgets*'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现二维纹理按钮小部件*'
- en: Implementing 2D textured button widgets
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现二维纹理按钮小部件
- en: OpenGL ES does not provide built-in UI components, such as buttons, radio box,
    checkbox, and so on. In general, these components are called 2D widgets and are
    laid out in the HUD in the screen coordinate system, where the *z* component is
    either zero or not at all used. This recipe will guide us to design and lay out
    2D widgets on the screen coordinate system using OpenGL ES.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES 不提供内置的 UI 组件，例如按钮、单选框、复选框等。通常，这些组件被称为 2D 小部件，并在屏幕坐标系中的 HUD 中布局，其中
    *z* 分量要么为零，要么根本不使用。此配方将指导我们使用 OpenGL ES 在屏幕坐标系上设计和布局 2D 小部件。
- en: 'This recipe contains two recipes:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方包含两个配方：
- en: The first recipe allows you to create the geometry of a simple button. Geometrical
    coordinates are specified in the local screen coordinate system, which is useful
    in designing the layout.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个配方允许你创建一个简单按钮的几何形状。几何坐标是在局部屏幕坐标系中指定的，这在设计布局时非常有用。
- en: The second recipe is implemented in the *There's more...* section of this recipe,
    where we used the ray-picking technique, making the button clickable. Selecting
    the button will change its color.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个配方在配方的 *还有更多...* 部分实现，其中我们使用了射线选择技术，使按钮可点击。选择按钮将改变其颜色。
- en: The next image shows the output of the first recipe. It contains six buttons
    of 32 x 32 dimensions. Each button is scaled by a factor of two, resulting in
    the final dimension of 64 x 64\. The extreme left hand-side button (up button)
    is the parent of all the remaining buttons. This means any property applied to
    the parent will be propagated to all its children.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图像显示了第一个配方的输出。它包含六个 32 x 32 维度的按钮。每个按钮都按比例因子二进行缩放，最终尺寸为 64 x 64。最左边的按钮（向上按钮）是所有剩余按钮的父按钮。这意味着应用于父按钮的任何属性都将传播到所有子按钮。
- en: How to do it...
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Here are the steps to implement this recipe:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是实现此配方的步骤：
- en: 'Create `Button.h`/`.cpp` and define the `Button` class derived from the `Model`
    class:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Button.h`/`.cpp`并定义从`Model`类派生的`Button`类：
- en: '[PRE35]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `Button` class renders the geometry of the button. A button geometry has
    four vertices on which a texture is pasted, with the help of texture coordinates:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Button`类渲染按钮的几何形状。按钮几何形状有四个顶点，在这些顶点上粘贴了纹理，借助纹理坐标：'
- en: '[PRE36]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Set up the heads up display using the orthographic projection system:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用正交投影系统设置抬头显示：
- en: '[PRE37]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In `NativeTemplate.cpp`, edit the `GraphicsInit()` function, as given in the
    following code. This function lays out buttons on the screen coordinate system.
    These buttons accept geometrical vertices and texture coordinates as an input,
    which are optional parameters. If these parameters are not supplied. The dimension
    of the button will be equal to the image size. The texture coordinate has default
    values (0.0, 0.0) and (1.0, 1.0) as the bottom-left and top-right respectively:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NativeTemplate.cpp`中，编辑`GraphicsInit()`函数，如下面的代码所示。此函数在屏幕坐标系上布局按钮。这些按钮接受几何顶点和纹理坐标作为输入，这些是可选参数。如果未提供这些参数，按钮的尺寸将与图像大小相等。纹理坐标具有默认值（0.0，0.0）和（1.0，1.0），分别对应左下角和右上角：
- en: '[PRE38]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works...
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The geometry of the 2D button widget is created using four vertices, which are
    specified in the screen coordinate system. This geometry is textured with the
    specified image with the help of texture coordinates on the geometry. OpenGL ES
    works in the Cartesian system, where the origin exists in the center of the viewport
    dimension in the logical coordinate system. Viewport also has the same coordinate
    system and works in the pixel coordinate system, but the origin in this case exists
    in the bottom-left corner as shown in the following image. In contrast, the 2D
    widget is designed in the device coordinate system, where the origin is considered
    as the top-left corner (see the following image).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 2D按钮小部件的几何形状使用四个顶点创建，这些顶点在屏幕坐标系中指定。这个几何形状通过几何形状上的纹理坐标使用指定的图像进行纹理化。OpenGL ES在笛卡尔坐标系中工作，其中原点存在于逻辑坐标系中视口维度的中心。视口也有相同的坐标系，并在像素坐标系中工作，但在这个情况下，原点位于左下角，如以下图像所示。相比之下，2D小部件是在设备坐标系中设计的，其中原点被认为是左上角（见以下图像）。
- en: Now, head-up-display is a mechanism in which we can formulate the device coordinate
    system by using the OpenGL ES coordinate system and the viewport. For this, we
    need to render the projection system of the scene with an orthographic view where
    the origin is shifted in the top-right corner in the `setUpProjection` function.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，抬头显示是一种机制，我们可以通过使用OpenGL ES坐标系统和视口来制定设备坐标系统。为此，我们需要使用`setUpProjection`函数中的正交视图渲染场景的投影系统，其中原点在右上角移动。
- en: 'The button class objects are created in `NativeTemplate.cpp` in the `GraphicsInit()`
    function, where six buttons are created with different images on it. Each button
    is given a unique name so that it can be used later in the camera recipe. The
    following image shows these buttons on the right-hand side. In order to make the
    job simpler for placement of icons in the 2D HUD screen space, we made the first
    button (up direction) as the parent of other buttons. This way, we all buttons
    can be resized and moved by applying a single operation on the parent itself.
    Finally, render these buttons to the HUD using `GraphicsRender()`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮类对象在`NativeTemplate.cpp`中的`GraphicsInit()`函数中创建，其中创建了六个按钮，每个按钮上都有不同的图像。每个按钮都被赋予一个独特的名称，以便以后在相机配方中使用。以下图像显示了这些按钮在右侧。为了简化在2D抬头显示屏幕空间中放置图标的工作，我们将第一个按钮（向上方向）作为其他按钮的父级。这样，我们都可以通过在父级上应用单个操作来调整所有按钮的大小和位置。最后，使用`GraphicsRender()`将这些按钮渲染到抬头显示中：
- en: '![How it works...](img/5527OT_10_12.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/5527OT_10_12.jpg)'
- en: There's more...
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: Unlike how we implemented the picking technique in the last recipe, this time
    we will implement the picking technique in the button class, which will help us
    to know which button has been clicked on so that a user can perform the appropriate
    action in response to it. Refer to the next recipe in order to see how these buttons
    control the camera moved in a scene.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在上一个配方中实现的选择技术不同，这次我们将实现按钮类中的选择技术，这将帮助我们了解哪个按钮被点击，以便用户可以对其执行适当的操作。请参考下一个配方，以了解这些按钮是如何控制场景中相机移动的。
- en: 'The `Button` class must be derived from the `GestureEvent` class and implemented
    to virtual gesture functions, such as `TouchEventDown` and `TouchEventRelease`
    in order to handle the gesture event and propagate them to child member objects:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`Button`类必须从`GestureEvent`类派生，并实现虚拟手势函数，例如`TouchEventDown`和`TouchEventRelease`，以便处理手势事件并将它们传播到子成员对象：'
- en: '[PRE39]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This class must override the `IntersectWithRay` function. In this, it performs
    a line and triangle intersection with two triangles that contains the button geometry.
    The following image shows the change in the color of the button when the touch
    down event occurs. The button gets restored to the original color when the touch
    release event fires:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类必须重写`IntersectWithRay`函数。在这个函数中，它执行了包含按钮几何形状的两个三角形的线和三角形交点。以下图像显示了当触摸事件发生时按钮颜色的变化。当触摸释放事件触发时，按钮将恢复到原始颜色：
- en: '![There''s more...](img/5527OT_10_13.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/5527OT_10_13.jpg)'
- en: 'Let''s take a look at the following code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码：
- en: '[PRE40]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: See also
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Refer to the Rendering text on Head Up Display recipe in [Chapter 8](ch08.html
    "Chapter 8. Font Rendering"), Font Rendering*'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*请参阅第8章中关于抬头显示渲染文本的食谱[第8章](ch08.html "第8章。字体渲染")，字体渲染*'
- en: Navigating the scene with a camera system
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用摄像头系统导航场景
- en: In 3D graphics, a camera allows you to navigate through the 3D space; it can
    be used to perform the rotation and displacement on any arbitrary axis. In OpenGL
    ES, there is nothing such as a camera. This has to be implemented programmatically.
    Implementing a camera is extremely simple. In fact, we do not require any specific
    OpenGL ES APIs for this and it's all about manipulating matrices. In this recipe,
    we will simulate a first person camera.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D图形中，摄像头允许你在3D空间中导航；它可以用于在任意轴上进行旋转和位移。在OpenGL ES中，没有摄像头这样的东西。这必须通过编程实现。实现摄像头非常简单。实际上，我们不需要任何特定的OpenGL
    ES API来完成这个任务，这完全关乎矩阵的操作。在本食谱中，我们将模拟一个第一人称摄像头。
- en: How to do it...
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Reuse the last implement recipe and perform the following steps to implement
    the camera system:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 重新使用上一个实现食谱，并执行以下步骤以实现摄像头系统：
- en: 'Create a `Camera.h`/`.cpp` file and define a `Camera` class derived from `Object`.
    This class contains three unit vectors: `Left`, `Up`, and `Forward`, which store
    directional unit vectors in the 3D space along the *x*, *y*, and *z* axis respectively.
    The `Position` specifies the location of the camera and Target specifies the location
    of the camera view:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Camera.h`/`.cpp`文件，并定义一个从`Object`派生的`Camera`类。这个类包含三个单位向量：`Left`、`Up`和`Forward`，它们分别存储沿*x*、*y*和*z*轴在3D空间中的方向单位向量。`Position`指定摄像头的位置，而`Target`指定摄像头视图的位置：
- en: '[PRE41]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Define the rotation of the camera, as given in the following code:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义摄像头的旋转，如下代码所示：
- en: '[PRE42]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Make the camera move along the three axes using the move function, as shown
    in the following code:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用移动函数使摄像头沿着三个轴移动，如下代码所示：
- en: '[PRE43]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `Camera::Render()` sets up the projection matrix in the following code:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码设置了`Camera::Render()`中的投影矩阵：
- en: '[PRE44]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Combine the two scenes that we created in previous recipes. The first scene
    contains the windmill. The second scene contains pick buttons. The former scene
    will be rendered to the perspective camera. However, the latter will make use
    of the HUD camera:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结合我们在之前的食谱中创建的两个场景。第一个场景包含风车。第二个场景包含选择按钮。前一个场景将被渲染到透视摄像头。然而，后一个将使用HUD摄像头：
- en: '[PRE45]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A camera contains three orientation unit vectors: the forward (0.0, 0.0, and
    -1.0), right (1.0, 0.0, and 0.0), and up vector (0.0, 1.0, and 0.0). The first
    vector points to a direction where the camera is heading. For example, in the
    present case, the camera will move in the negative *z* axis direction. Similarly,
    the right vector specifies the direction of the movement in the *x* axis and the
    up vector in the *y* axis. The up vector can also be understood like a head, which
    specifies whether the camera is viewing a scene in the upside (0.0, 1.0, and 0.0)
    or upside down (0.0, -1.0, and 0.0) direction.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 摄像头包含三个方向单位向量：前向（0.0, 0.0, 和 -1.0）、右向（1.0, 0.0, 和 0.0）和上向量（0.0, 1.0, 和 0.0）。第一个向量指向摄像头前进的方向。例如，在本例中，摄像头将沿着负*z*轴方向移动。同样，右向量指定*x*轴上的移动方向，上向量指定*y*轴上的移动方向。上向量也可以理解为头部，它指定摄像头是向上（0.0,
    1.0, 和 0.0）还是向下（0.0, -1.0, 和 0.0）观看场景。
- en: Using these vectors, the camera can be moved along any of the three axes. For
    example, if you want to move the camera five units ahead, then the product of
    `|5| *` forward will place your camera at (0.0, 0.0, or -5.0) looking in the same
    direction, whereas moving the camera right by four units places the camera at
    (4.0, 0.0, or -5.0). Again, the camera still looks in the negative *z* direction.
    In the present recipe, the camera's current position is translated using functions,
    such as `MoveForwards`, `StrafeRightSide`, `StrafeUpSide`, and so on. The orientation
    of the camera along *x*, *y*, or *z* axis can be changed using the `Rotate` function.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些向量，相机可以沿三个轴中的任何一个移动。例如，如果你想将相机向前移动五个单位，那么`|5| *`向前的乘积将使你的相机位于（0.0，0.0，或-5.0）并朝相同方向看，而将相机向右移动四个单位则将相机放置在（4.0，0.0，或-5.0）。再次强调，相机仍然朝向负*z*方向。在当前配方中，使用诸如`MoveForwards`、`StrafeRightSide`、`StrafeUpSide`等函数来转换相机的当前位置。相机的*x*、*y*或*z*轴方向可以使用`Rotate`函数来改变。
- en: Note
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The camera displacement on any arbitrary axis specified by the forward, right,
    and up unit vector does not affect the orientation of the camera. The orientation
    remains unchanged and the camera will continue to look in the same direction specified
    by the forward vector. The orientation of the camera can only be effected when
    the camera rotates along any of the arbitrary axis.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在任意轴上由前向、右向和上向单位向量指定的相机位移不会影响相机的方向。方向保持不变，相机将继续朝由前向向量指定的相同方向看。只有当相机沿任意轴旋转时，相机的方向才能受到影响。
- en: '![How it works...](img/5527OT_10_14.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/5527OT_10_14.jpg)'
- en: 'The preceding image (part **1**) shows the effect of rotation on the forward
    (**OC**), right (**OA**), and up (**OB**) vectors, when the rotation of 45 degree
    is performed along the *z* axis. This results (image part **2**) in the new right
    (**OE**) and new up (**OF**) vector. The forward vector has no changes as it rotates
    along the *z* axis:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图像（部分**1**）显示了在*z*轴上执行45度旋转时，旋转对前向（**OC**）、右向（**OA**）和上向（**OB**）向量的影响。这导致（图像部分**2**）新的右向（**OE**）和新的上向（**OF**）向量。前向向量在*z*轴上旋转时没有变化：
- en: '![How it works...](img/5527OT_10_15.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/5527OT_10_15.jpg)'
- en: There's more...
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The current recipe contains two cameras for each scene. The first camera renders
    the perspective projection system. The second camera renders the scene to the
    head-up-display in the orthographic projection view. The `Camera` class that we
    implemented in the last recipe cannot be programmed for HUD camera requirements.
    Therefore, we need a new `Camera` derivative class called `CameraHUD` to implement
    HUD.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当前配方为每个场景包含两个相机。第一个相机渲染透视投影系统。第二个相机以正交投影视图渲染场景到抬头显示。我们在上一个配方中实现的`Camera`类不能用于满足HUD相机的要求。因此，我们需要一个新的`Camera`派生类，称为`CameraHUD`，来实现HUD。
- en: 'The following code shows the implementation of the HUD camera. The `Render`
    function is overridden. This function queries the current viewport dimensions
    and maps it to the orthographic left-right and top-bottom parameters in such a
    way that the origin shifts from center to the top-left, same as the device screen
    coordinate system. For more information on HUD, refer to the *See also* subsection
    in this recipe:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了HUD相机的实现。重写了`Render`函数。此函数查询当前视口尺寸并将其映射到正交投影的左右和上下参数，这样原点从中心移动到左上角，与设备屏幕坐标系相同。有关HUD的更多信息，请参阅本配方中的“参考以下内容”子节：
- en: '[PRE46]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: See also
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: '*Refer to the Rendering text on Head Up Display recipe in [Chapter 8](ch08.html
    "Chapter 8. Font Rendering"), Font Rendering*'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*请参阅[第8章](ch08.html "第8章。字体渲染")中的“抬头显示渲染文本”配方，字体渲染*'
- en: Implementing the scene with multiple views
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现具有多个视图的场景
- en: 'One of the most common requirements for real time 3D applications is to render
    a scene to multiple view windows simultaneously. For example, a CAD/CAM-based
    application renders a scene to four types of views: perspective, orthographic
    front, side, and top view. In the scene graph architecture, multiple views are
    achieved with the help of rendering a scene to two or more cameras.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 实时3D应用中最常见的需求之一是同时将场景渲染到多个视图窗口中。例如，基于CAD/CAM的应用程序将场景渲染到四种类型的视图中：透视、正交前视图、侧视图和俯视图。在场景图架构中，通过将场景渲染到两个或更多相机中来实现多个视图。
- en: This recipe extends the last recipe to supporting multiple cameras, where each
    camera has different viewport region (which could be overlapped) and can have
    separate clear colors (depending on the requirement).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱扩展了上一个食谱，以支持多个相机，其中每个相机具有不同的视口区域（可能重叠），并且可以具有不同的清除颜色（根据需求）。
- en: How to do it...
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here are the steps to implement this recipe:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 实施此食谱的步骤如下：
- en: 'Now on, the screen clear color and buffer clearing will be applied within the
    Camera view itself. Remove the clear code from `Renderer::render()`. Define a
    `vec4` type variable called `clearColor` to store the clear color information:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从现在开始，屏幕清除颜色和缓冲区清除将在相机视图中应用。从 `Renderer::render()` 中删除清除代码。定义一个名为 `clearColor`
    的 `vec4` 类型变量来存储清除颜色信息：
- en: '[PRE47]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Apply the clear color information and framebuffers in `Camera::render()`. In
    the same function, make sure that `glViewPort` and `glScissor` are passed on with
    exactly same dimensions. The `glScissor()` works if the scissor test is enabled.
    It defines a rectangular screen space region in the screen coordinate system beyond
    which nothing will be drawn:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Camera::render()` 中应用清除颜色信息和帧缓冲区。在同一个函数中，确保 `glViewPort` 和 `glScissor` 以完全相同的尺寸传递。如果启用了裁剪测试，`glScissor()`
    将生效。它定义了一个在屏幕坐标系中的矩形屏幕空间区域，在此区域之外将不会绘制任何内容：
- en: '[PRE48]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In `NativeTemplate.cpp`, edit the `GraphicsInit()` function as follows:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `NativeTemplate.cpp` 中，按照以下方式编辑 `GraphicsInit()` 函数：
- en: '[PRE49]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Use `GraphicsResize()` and define the viewport size for all the four cameras
    defined in the preceding code. Specify the clear color information for each camera
    in order to paint the background of view:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `GraphicsResize()` 并为前面代码中定义的所有四个相机定义视口大小。为每个相机指定清除颜色信息，以便绘制视图的背景：
- en: '[PRE50]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How it works...
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'A multiview scene has multiple cameras rendering the present scene to different
    parts of screen regions. Each different region is specified by the viewport dimension
    specified in the camera. In order to support multiple views in the scene graph,
    we need to:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 多视图场景具有多个相机将当前场景渲染到屏幕的不同区域。每个不同的区域由相机中指定的视口维度指定。为了在场景图中支持多个视图，我们需要：
- en: Specify the viewport region. This will produce screen coordinates from the world
    coordinates of the scene with respect to the specified viewport dimension.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定视口区域。这将根据指定的视口维度从场景的世界坐标生成屏幕坐标。
- en: Clear the color. This is the color used to clear the color buffer each time
    framebuffer is drawn.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除颜色。这是每次绘制帧缓冲区时用于清除颜色缓冲区的颜色。
- en: When a clear command is specified, it clears the complete framebuffer. As a
    consequence, you may not be able to see different views at all because the last
    camera's clear command has cleared the existing drawing in the framebuffer. This
    unexpected clearing of the color buffer can be avoided using the scissor test.
    In OpenGL ES 3.0, you can scissor a framebuffer region using the `glScissor` command,
    which defines a rectangular screen space region in the screen coordinate system
    beyond which nothing will be drawn.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当指定清除命令时，它将清除整个帧缓冲区。因此，您可能根本看不到不同的视图，因为最后一个相机的清除命令已经清除了帧缓冲区中的现有绘制。可以通过裁剪测试避免这种意外的颜色缓冲区清除。在
    OpenGL ES 3.0 中，您可以使用 `glScissor` 命令裁剪帧缓冲区区域，该命令在屏幕坐标系中定义了一个矩形屏幕空间区域，在此区域之外将不会绘制任何内容。
- en: 'The following command needs to the specified in order to achieve multiple cameras
    before using any model, view, and projection matrix:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用任何模型、视图和投影矩阵之前，需要指定以下命令以实现多个相机：
- en: '[PRE51]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '![How it works...](img/5527OT_10_16.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/5527OT_10_16.jpg)'
- en: There's more...
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `glScissor()` will only work if the scissor test is enabled; `glScissor`
    defines a rectangle and calls the scissor box in window coordinates. The first
    two arguments: `x` and `y` specify the lower-left corner of the box. The width
    and height specifies the dimensions of the box.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当裁剪测试启用时，`glScissor()` 才会工作；`glScissor` 定义一个矩形并在窗口坐标中调用裁剪框。前两个参数：`x` 和 `y`
    指定框的左下角。宽度和高度指定框的尺寸。
- en: To enable and disable the scissor test, call [https://www.khronos.org/opengles/sdk/docs/man/xhtml/glEnable.xml](https://www.khronos.org/opengles/sdk/docs/man/xhtml/glEnable.xml)
    and [https://www.khronos.org/opengles/sdk/docs/man/xhtml/glDisable.xml](https://www.khronos.org/opengles/sdk/docs/man/xhtml/glDisable.xml)
    with the `GL_SCISSOR_TEST` argument. This test is initially disabled. When the
    scissor test is enabled, only pixels that lie within the scissor box can be modified
    by drawing commands. Window coordinates have integer values at the shared corners
    of framebuffer pixels.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用和禁用裁剪测试，请使用带有`GL_SCISSOR_TEST`参数的[https://www.khronos.org/opengles/sdk/docs/man/xhtml/glEnable.xml](https://www.khronos.org/opengles/sdk/docs/man/xhtml/glEnable.xml)和[https://www.khronos.org/opengles/sdk/docs/man/xhtml/glDisable.xml](https://www.khronos.org/opengles/sdk/docs/man/xhtml/glDisable.xml)调用。此测试最初是禁用的。当裁剪测试被启用时，只有位于裁剪框内的像素可以被绘图命令修改。窗口坐标在帧缓冲区像素的共享角落具有整数值。
- en: '**Syntax**:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE52]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '| Variables | Description |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `x`, `y` | This specifies the lower-left corner of the scissor box. The initial
    value of `x`, `y` is (`0`, `0`). |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| `x`, `y` | 这指定了裁剪框的左下角。`x`，`y`的初始值是(`0`, `0`)。 |'
- en: '| `width`, `height` | This specifies the `width` and `height` of the scissor
    box. When a GL context is first attached to a window, the width and height are
    set to the dimensions of that window. |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| `width`, `height` | 这指定了裁剪框的宽度和高度。当一个GL上下文首次附加到窗口时，宽度和高度被设置为该窗口的尺寸。 |'
- en: See also
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Refer to the Rendering text on Head Up Display recipe in [Chapter 8](ch08.html
    "Chapter 8. Font Rendering"), Font Rendering*'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*参考[第8章](ch08.html "第8章。字体渲染")中的“在抬头显示上渲染文本”配方，字体渲染*'
