<html><head></head><body><div><h1 class="header-title">Installation and Working with Environment</h1>
                
            
            
                
<p>The following recipes will be covered in this chapter:</p>
<ul>
<li>Creating Kotlin Android project</li>
<li>How to use Gradle to run Kotlin code</li>
<li>How to run a Kotlin compiled class</li>
<li>How to build a self-executable jar with Gradle and Kotlin</li>
<li>Reading console input in Kotlin</li>
<li>Converting Java code to Kotlin and vice versa</li>
<li>How to write an idiomatic logger with Kotlin</li>
<li>Escaping for Java identifiers that are keywords in Kotlin</li>
<li>Disambiguating using the "as" keyword to locally rename the clashing entity</li>
<li>Doing bit manipulations in Kotlin</li>
<li>Parsing String to Long, Double, or Int</li>
<li>Using String templates in Kotlin</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Introduction</h1>
                
            
            
                
<p>Android apps are a fascinating piece of technology. The apps developed on Android have worldwide appeal and audience. However, that has posed serious challenges for developers. The challenge is with updating APIs, platforms, and varied device capabilities. For example, if you are an Android developer, you have to rely on Java 6 if you want to support all API levels in Android. Java 6 is obsolete now, so much so that even its successor, Java 7, is kind of obsolete today. There was a great need for modern language for Android, which has built a trillion dollar industry around it and has influenced billions of lives. True, we have Java 8 now, but we can only use it if we are developing Android apps for API level 24 and above. However, that’s equivalent to targeting only 9% of Android devices as of 2017; clearly, this isn’t the way to go.</p>
<p>All is not lost though, and thanks to the JVM, we can write Android apps using any language that produces JVM compatible bytecode on compilation. So theoretically, we can use Clojure, Groovy, Scala, and Kotlin, but Kotlin is the best alternative among all, why? It's because in April 2017, Google announced Kotlin as an official language for Android development.</p>
<p>Some of the biggest tech companies such as Pinterest, Uber, Atlassian, Coursera, and Evernote are now using Kotlin in their Android apps. This wide adoption by them already speaks a huge volume for Kotlin. The 100% interoperability with Android and Java has helped Kotlin in its adoption. Kotlin is much easier to work with than Java and, apart from Android apps, you can also build web-apps with it. So, this chapter will introduce you to Kotlin and help you get started with this awesome piece of technology.</p>
<p>In this chapter, we will first see how to set up the environment to begin working with Kotlin.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Creating Kotlin Android project</h1>
                
            
            
                
<p>Getting started with Kotlin is really easy, especially after Google has added official support for the language. You can use Kotlin directly with Android Studio 3. Android Studio 3 is still in Beta version at the time of writing this book. The best thing about using Kotlin for Android is that it is interoperable with your existing code, be it Java or C++. While working with Kotlin, you will realize that code in Kotlin is concise, extensible, and powerful. It really makes Android development more fun. Let's see how we can start working in Kotlin by first creating a Kotlin project in Android Studio 3.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>To get started with this recipe, you will need Android Studio installed on your computer. Android Studio has both Android SDK and Android Virtual device in it. Ensure that you have Java Development Kit installed on your system. You will need an android phone or Emulator for debugging your project. You will also need at least one Android Virtual Device installed, of your desired specifications if you are not using an Android phone.</p>
<p>So basically, here's the checklist of the things that need to be installed before you move on to the next section:</p>
<ul>
<li style="font-weight: 400">Java Development Kit (use the latest)</li>
<li style="font-weight: 400">Android Studio 3+</li>
<li style="font-weight: 400">Android phone or emulator</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Creating a project in Android Studio is very simple and to create it in Kotlin just requires one extra click. Here's a step-by-step process of doing it:</p>
<ol>
<li>In Android Studio, in the menu, click on File | New | New Project. Alternatively, if you've just opened Android Studio and see the Welcome to Android Studio window, click on Start a new Android Studio project.</li>
</ol>
<ol start="2">
<li>In the wizard, add your Application name and Company domain, and simply check the box that says Include Kotlin support. Click on Next:</li>
</ol>
<div><img height="672" width="907" src="img/e23ddc9d-c1b0-4248-8e32-bf979557e1ce.png"/></div>
<ol start="3">
<li>On the next screen, you will be asked to choose your target devices and the minimum SDK support. So basically, it asks things like, "Do you want the application to run on both phone and android wear?" and "Do you want to support from Jelly Bean up or KitKat and up?":</li>
</ol>
<div><img height="672" width="906" src="img/5d8bb3e1-e242-4760-ba2f-f20abf887a58.png"/></div>
<ol start="4">
<li> On the next screen, you will be prompted to Add an Activity to the project. You can also skip this step and add an activity later, but for now, just click on a Basic Activity and click on Next. If you have also chosen Wear or any other option, you will be prompted to add activity for those components as well:</li>
</ol>
<div><img height="671" width="905" src="img/0f91044d-30db-4b81-8ea1-68c51d218031.png"/></div>
<ol start="5">
<li>Next, you will be prompted to <strong>Configure the Activity</strong> you added. Basically, what you have to do is to provide <strong>Activity Name, Layout Name,</strong> and <strong>Title</strong>. After this, click on Finish, because you are done with creating your first project in Kotlin.</li>
<li>Run project on your device: You need to follow these steps:
<ol>
<li>Connect your device to your development machine with a USB cable.</li>
<li>Enable USB debugging on your device by going to Settings | Developer options.</li>
</ol>
</li>
</ol>
<p>On Android 4.2 and newer, Developer options are hidden by default. To make it available, go to Settings | About phone and tap on Build number seven times. Return to the previous screen to find Developer options.</p>
<p>Now in your Android Studio, click on the app module in the Project window and then select Run (or click on Run in the toolbar).</p>
<p>In the Select Deployment Target window, select your device, and click on OK. After a while, you will see the application running on your mobile or an emulator.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more...</h1>
                
            
            
                
<p>After clicking on the Finish button in the Create New Project window, Android Studio will configure things and create your project. If you added an activity as mentioned in Step 4, you will be greeted with the boilerplate code of the activity. It looks something like this:</p>
<div><img src="img/0776d959-584c-41fd-aef4-f9e92cdade26.png" width="1307" height="742"/></div>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">How to use Gradle to run Kotlin code</h1>
                
            
            
                
<p><strong>Gradle</strong> has now become the de facto build tool for Android, and it is very powerful. It’s great for automating tasks without compromising on maintainability, usability, flexibility, extensibility, or performance. In this recipe, we will see how to use Gradle to run Kotlin code.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We will be using IntelliJ IDEA because it provides great integration of Gradle with Kotlin, and it is a really great IDE to work on. You can also use Android Studio for it.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>In the following steps, we will be creating a Kotlin project with the Gradle build system. First, we will select the Create New Project option from the menu. Then, follow these steps:</p>
<div><img height="494" width="779" src="img/3f365cbe-4d7e-4147-9b7c-8ab6cb9e8958.png"/></div>
<ol>
<li>Create the project with the Gradle build system:</li>
</ol>
<div><img height="747" width="742" src="img/31bbd90b-193b-4c21-8e2c-0ff266d2f928.png"/></div>
<ol start="2">
<li>After you have created the project, you will have the <kbd>build.gradle</kbd> file, which will look something like the following:</li>
</ol>
<pre style="padding-left: 60px">version '1.0-SNAPSHOT'<br/><br/>buildscript {<br/>  ext.kotlin_version = '1.1.4-3'<br/><br/>  repositories {<br/>      mavenCentral()<br/>  }<br/>  dependencies {<br/>      classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"<br/>  }<br/>}<br/><br/>apply plugin: 'java'<br/>apply plugin: 'kotlin'<br/><br/>sourceCompatibility = 1.8<br/><br/>repositories {<br/>  mavenCentral()<br/>}<br/><br/>dependencies {<br/>  compile "org.jetbrains.kotlin:kotlin-stdlib-jre8:$kotlin_version"<br/>  testCompile group: 'junit', name: 'junit', version: '4.12'<br/>}<br/><br/>compileKotlin {<br/>  kotlinOptions.jvmTarget = "1.8"<br/>}<br/>compileTestKotlin {<br/>  kotlinOptions.jvmTarget = "1.8"<br/>}</pre>
<ol start="3">
<li>Now we will create a <kbd>HelloWorld</kbd> class, which will have a simple main function:</li>
</ol>
<div><img height="582" width="672" src="img/297f7877-9347-49c1-9d96-2049609d8a66.png"/></div>
<ol start="4">
<li>Now, it would be really cool to run this code directly. To do so, we will use the <kbd>gradle run</kbd> command. However, before that, we need to enable the application plugin, which will allow us to directly run this code. We need to add two lines in the <kbd>build.gradle</kbd> file to set it up:</li>
</ol>
<pre style="padding-left: 60px">apply plugin: 'application'<br/>mainClassName = "HelloWorldKt"</pre>
<ol start="5">
<li>After this, you can type <kbd>gradle run</kbd> in the terminal to execute this file, and you will see the output of the method, as shown:</li>
</ol>
<div><img height="700" width="1269" src="img/96d5b511-9231-47b9-92de-750161d4a402.png"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more...</h1>
                
            
            
                
<p>The default structure of the project, when you create a new project in IntelliJ, is as illustrated:</p>
<pre style="padding-left: 60px">project<br/>   - src<br/>       - main (root)<br/>           - kotlin<br/>           - java</pre>
<p>If you want to have a different structure of the project, you should declare it in <kbd>build.gradle</kbd>. You can do it by adding the following lines in <kbd>build.gradle</kbd>.</p>
<p>The corresponding <kbd>sourceSets</kbd> property should be updated if not using the default convention:</p>
<pre style="padding-left: 60px">sourceSets {<br/>   main.kotlin.srcDirs += 'src/main/myKotlin'<br/>   main.java.srcDirs += 'src/main/myJava'<br/>}</pre>
<p>Though you can keep Kotlin and Java files under the same package, it’s a good practice to keep them separated.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">See also</h1>
                
            
            
                
<p>Check out the <em>How to build a self-executable jar with Gradle and Kotlin</em> recipe in this chapter.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to run a Kotlin compiled class</h1>
                
            
            
                
<p>Working with the command-line compiler for any language is one of the first steps to get a better understanding of the language, and this knowledge comes handy at a lot of times. In this recipe, we will run a Kotlin program using the command line, and we will also play a bit with the interactive shell of Kotlin.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>To be able to perform this recipe, you need a Kotlin compiler installed on your development machine. Every Kotlin release ships with a standalone compiler. You can find the latest release at <a href="https://github.com/JetBrains/kotlin/releases">https://github.com/JetBrains/kotlin/releases</a>.</p>
<p>To manually install the compiler, unzip the standalone compiler into a directory and optionally, add the bin directory to the system path. The bin directory contains the scripts needed to compile and run Kotlin on Windows, OS X, and Linux.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Now we are ready to run our first program using the command line. First, we will create a simple application that displays Hello World! and then compile it:</p>
<ol>
<li>Create a file with the name <kbd>hello.kt</kbd> and add the following lines of code in that file:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    println("Hello, World!")<br/> }</pre>
<ol start="2">
<li>Now we compile the file using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ kotlinc hello.kt -include-runtime -d hello.jar</strong></pre>
<ol start="3">
<li>Now we run the application using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ java -jar hello.jar</strong></pre>
<ol start="4">
<li>Suppose you want to create a library that can be used with other Kotlin applications; we can simply compile the Kotlin application in question into <kbd>.jar</kbd> executable without the <kbd>-include-runtime</kbd> option, that is, the new command will be as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ kotlinc hello.kt -d hello.jar</strong></pre>
<ol start="5">
<li>Now, let's check out the Kotlin interactive shell. Just run the Kotlin compiler without any parameters to have an interactive shell. Here's how it looks:</li>
</ol>
<div><img src="img/094ab1d4-fbc5-4ca7-99a6-ec234218c153.png" width="635" height="379"/></div>
<p>Hopefully, you must have noticed the information I am always guilty of ignoring, that is, the command to quit interactive shell is <kbd>:quit</kbd> and for help, it is <kbd>:help</kbd>.</p>
<p>You can run any valid Kotlin code in the interactive shell. For example, try some of the following commands:</p>
<ul>
<li><kbd>3*2+(55/5)</kbd></li>
<li style="font-weight: 400"><kbd>println("yo")</kbd></li>
<li style="font-weight: 400"><kbd>println("check this out ${3+4}")</kbd></li>
</ul>
<p>Here's a screenshot of running the preceding code:</p>
<div><img src="img/49cfe315-be64-4674-92d7-315f31743215.png" width="637" height="366"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>-include-runtime</kbd> option makes the resulting <kbd>.jar</kbd> file self-contained and runnable by including the Kotlin runtime library in it. Then, we use Java to run the <kbd>.jar</kbd> file generated.</p>
<p>The <kbd>-d</kbd> option in the command indicates what we want the output of the compiler to be called and maybe either a directory name for class files or a <kbd>.jar</kbd> filename.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Kotlin can also be used for writing shell scripts. A shell script has top-level executable code.</p>
<p>Kotlin script files have the <kbd>.kts</kbd> extension as opposed to the usual <kbd>.kt</kbd> for Kotlin applications.</p>
<p>To run a script file, just pass the <kbd>-script</kbd> option to the compiler:</p>
<pre style="padding-left: 60px"><strong>$ kotlinc -script kotlin_script_file_example.kts</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How to build a self-executable JAR with Gradle and Kotlin</h1>
                
            
            
                
<p>Kotlin is great for creating small command-line utilities, which can be packaged and distributed as normal JAR files. In this recipe, we will see how to do it using Gradle build system. Gradle build system is one of the most sophisticated build systems out there. It is the default build tool for Android and is designed to ease scripting of complex, multilanguage builds with a lot of dependencies (typical of big projects). It achieves the goal of automating your project without compromising on maintainability, usability, flexibility, extensibility, or performance. We will be using Gradle build system to create a self-extracting JAR file. This JAR file can be distributed to and run on any platform supporting Java.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You need an IDE (preferably IntelliJ or Android Studio), and you need to tell it where your Kotlin files are present. You can do so by specifying it in the <kbd>build.gradle</kbd> file by adding the following:</p>
<pre style="padding-left: 60px">sourceSets {<br/>   main.java.srcDirs += 'src/main/kotlin/'<br/>}</pre>
<p>The preceding lines are required if you have your Kotlin files separated from Java packages. This is optional, and you can continue working with Kotlin files under Java packages, but it’s a good practice to keep them separated.</p>
<p>We’ll be creating a very simple function that just prints <kbd>Hello World!</kbd> when executed. Since it’ll be a simple function, I am just adding it as a top-level <kbd>main()</kbd> function.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Let's go through these steps, with which we can create a self-executable JAR:</p>
<ol>
<li>We’ll create a simple class <kbd>HelloWorld.kt</kbd> having the main function, which just prints out “Hello world!”:</li>
</ol>
<pre style="padding-left: 60px">fun main(args:Array&lt;String&gt;){<br/>   println("Hello world")<br/>}</pre>
<ol start="2">
<li>Now we need to configure a <kbd>jar</kbd> task, which Gradle build goes through to inform it of our entry to our project. In a Java project, this will be the path to the class where our <kbd>main()</kbd> function resides, so you will need to add this <kbd>jar</kbd> task in <kbd>build.gradle</kbd>:</li>
</ol>
<pre style="padding-left: 60px">jar {<br/>   manifest {<br/>       attributes 'Main-Class': 'HelloWorldKt'<br/>   }<br/>   from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } }<br/>}</pre>
<ol start="3">
<li>After adding the preceding snippet to <kbd>build.gradle</kbd>, you need to run the following gradle command to create the jar file:</li>
</ol>
<pre style="padding-left: 60px"><strong>./gradlew clean jar</strong></pre>
<ol start="4">
<li>The created jar file can be found in the <kbd>build/libs</kbd> folder. Now you can just run the <kbd>java -jar demo.jar</kbd> command to run the JAR file.</li>
</ol>
<p>After you do that, you can see the output in the console:</p>
<div><img height="83" width="504" src="img/58fe47ee-58b4-4d16-b62f-2510892deaa4.png"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>To make self-executable JARs, we need a manifest file called <kbd>MANIFEST.MF</kbd> in the <kbd>META-INF</kbd> directory. For our purposes here, we just need to specify the name of the Java class that contains the Java-based extractor program's <kbd>main()</kbd> method.</p>
<p>One might argue that even though we don’t have top-level class declaration, we are specifying it as <kbd>HelloWorldKt</kbd> in the code for the jar task:</p>
<pre>manifest {<br/>       attributes 'Main-Class': 'HelloWorldKt'<br/>   }</pre>
<p>The reason for putting the preceding code block in the jar task is that Kotlin compiler adds all top-level functions to respective classes for back-compatibility with JVM. So, the class generated by Kotlin compiler will have the filename, plus the <kbd>Kt</kbd> suffix, which makes it <kbd>HelloWorldKt</kbd>.</p>
<p>Also, the reason we added <kbd>from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } }</kbd> in jar task is because we want Gradle to copy all of a JAR’s dependencies. The reason for doing so is that, by default, when Gradle (as well as Maven) packs some Java class files into a JAR file, it assumes that this JAR file will be referenced by an application, where all of its dependencies are also accessible in the classpath of the loading application. So, by specifying the preceding lines in jar task, we are telling gradle to take all of this JAR’s referenced dependencies and copy them as part of the JAR itself. In the Java community, this is known as a <strong>fat JAR</strong>. In a fat JAR, all the dependencies end up within the classpath of the loading application, so the code can be executed without problems. The only downside to creating fat JARs is their growing file size (which kind of explains the name), though it is not a big concern in most situations.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Reading console input in Kotlin</h1>
                
            
            
                
<p>In many applications, user interaction is a very important part, and the most basic way of doing that is reading input entered by the user and giving output based on it. In this recipe, we will understand different ways of reading input and also provide output in the console.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You need to install a preferred development environment that compiles and runs Kotlin. You can also use the command line to compile and run your Kotlin code, for which you need Kotlin compiler installed along with JDK.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Let's go through the following steps by which we can read console input in Kotlin:</p>
<ol>
<li>We will start simple and move to more advanced logic as we move forward. First, let's start with simply printing a line as output in the console:</li>
</ol>
<pre style="padding-left: 60px">println("Just a line")</pre>
<ol start="2">
<li>Now we will try to take String input from the console and output it again:</li>
</ol>
<pre style="padding-left: 60px">println("Input your first name")<br/>var first_name = readLine()<br/>println("Your first name: $first_name")</pre>
<ol start="3">
<li>Okay, how about we repeat the process with Int:</li>
</ol>
<pre style="padding-left: 60px">println("Hi $first_name, let us have a quick math test. Enter two numbers separated by space.")<br/>val (a, b) = readLine()!!.split(' ').map(String::toInt)<br/>println("$a + $b = ${a+b}")</pre>
<ol start="4">
<li>Now, let's try a complicated code and then start with the explanations:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>   println("Input your first name")<br/>   var first_name = readLine()<br/>   println("Input your last name")<br/>   var last_name = readLine()<br/>   println("Hi $first_name $last_name, let us have a quick math test. Enter two numbers separated by space.")<br/>   val (a, b) = readLine()!!.split(' ').map(String::toInt)<br/>  println("what is $a + $b ?")<br/>  println("Your answer is ${if (readLine()!!.toInt() == (a+b)) "correct" else "incorrect"}")<br/>   println("Correct answer = ${a+b}")<br/> println("what is $a * $b ?")<br/>   println("Your answer is ${if (readLine()!!.toInt() == (a*b)) "correct" else "incorrect"}")<br/>   println("Correct answer = ${a*b}")<br/>   println("Thanks for participating :)")<br/>}</pre>
<p>Here's a screenshot of compiling and running the preceding code:</p>
<div><img src="img/f7173076-e6a6-40dc-8193-85622cacf09f.png" width="647" height="309"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Let's try to understand the methods by which we were able to read input in Kotlin.</p>
<p>Behind the scenes, <kbd>Kotlin.io</kbd> uses <kbd>java.io</kbd> for the input-output. So <kbd>println</kbd> is basically <kbd>System.out.println</kbd>, but with additional power by Kotlin to use String templates and <kbd>inline</kbd> functions, which makes writing extremely simple and concise.</p>
<p>This is a part of the actual code from Kotlin <kbd>stdlib</kbd> used for Console IO:</p>
<pre style="padding-left: 60px">/** Prints the given message and newline to the standard output stream. */<br/>@kotlin.internal.InlineOnly<br/>public inline fun println(message: Any?) {<br/>   System.out.println(message)<br/>}</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Converting Java code to Kotlin and vice versa</h1>
                
            
            
                
<p>The best part about Kotlin is its interoperability with Java. Also, with IntelliJ-based IDE, we can directly convert our Java code to Kotlin. In this recipe, we will see how to do it.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe needs IntelliJ-based IDE installed, which compiles and runs Kotlin and Java.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Let's see the steps to convert a Kotlin file to a Java file:</p>
<ol>
<li>In your IntelliJ IDE, open the Java file that you want to convert to Kotlin.</li>
<li>Note that it has a <kbd>.java</kbd> extension. Now, in the main menu, click on Code menu and choose the Convert Java File to Kotlin File option. Your Java file will be converted into Kotlin, and the extension will now be <kbd>.kt</kbd>.</li>
</ol>
<p>Shown here is an example of a Java file:</p>
<div><img height="573" width="848" src="img/59c2bb9a-cd5e-48d9-9d2a-6b08f5e0c991.png"/></div>
<p style="padding-left: 30px">After converting to Kotlin, this is what we have:</p>
<div><img height="229" width="778" src="img/77c5efac-a454-4522-9b4d-42f2f6a789d2.png"/></div>
<ol start="3">
<li>A Kotlin file can be converted into Java, but it's better if you can avoid it or find an alternative way to do it. If you have to absolutely convert your Kotlin code to Java, click on Tools | Kotlin | Show Kotlin Bytecode in the menu:</li>
</ol>
<div><img height="449" width="683" src="img/074a57e3-c2e3-4d03-a6d7-ac39528d9c5f.png"/></div>
<ol start="4">
<li>After clicking on Show Kotlin Bytecode, a window will open with the title Kotlin Bytecode:</li>
</ol>
<div><img height="768" width="968" src="img/a11d5e08-d724-4c33-ad89-20f01060d707.png"/></div>
<ol start="5">
<li>Click on Decompile and a <kbd>.java</kbd> file will be generated, containing a  decompiled Java bytecode from Kotlin code:</li>
</ol>
<div><img height="668" width="937" src="img/f6636f42-ca0c-40fc-b957-425c4710445a.png"/></div>
<p>Yes, it has a lot of unnecessary code that was not present in the original Java code, but that is the case with decompiled bytecode. At the moment, this is the only way to convert Kotlin code to Java. Copy the decompiled file into a <kbd>.java</kbd> file and remove the unnecessary code.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Kotlin is a statically-typed programming language that works on Java Virtual Machine and compiles into JVM compatible bytecode. This is the reason we can convert Java code to Kotlin and mix Java and Kotlin code together.  This is also the reason why you can, in a way, get Java code back from Kotlin (although the output is not completely desired).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to write an idiomatic logger in Kotlin</h1>
                
            
            
                
<p>Kotlin has some great powerful features packed in it that we should be making use of to improve our code. This involves rethinking on our old best practices of coding. Many of our old coding practices can be replaced by better alternatives from Kotlin. One of them is how we write our logger. Though there are a lot of libraries out there that provide logging functionality, we will try to create our own logger in this recipe, just by using idiomatic Kotlin.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We will be using IntelliJ IDE to write and execute our code.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Let's go through the given steps to create an idiomatic logger in Kotlin:</p>
<ol>
<li>First, let's see how it was done in Java. In Java, SLF4J is used and considered de-facto, so much that logging seems like a solved problem in Java language. Here's what a Java implementation would look like:</li>
</ol>
<pre style="padding-left: 60px">private static final Logger logger = LoggerFactory.getLogger(CurrentClass.class);<br/>…<br/>logger.info(“Hi, {}”, name);</pre>
<ol start="2">
<li>It also works fine with Kotlin, obviously with minor modifications:</li>
</ol>
<pre style="padding-left: 60px">val logger = LoggerFactory.getLogger(CurrentClass::class)<br/>…<br/>logger.info(“Hi, {}”, name)</pre>
<p>However, apart from this, we can utilize the power of Kotlin using <strong>Delegates</strong> for the logger. In this case, we will be creating the logger using the <kbd>lazy</kbd> keyword. This way, we will create the object only when we access it. Delegates are a great way to postpone object creation until we use it. This improves startup time (which is much needed and appreciated in Android). So let us explore a method using lazy delegates in Kotlin:</p>
<ol>
<li>We'll use <kbd>java.util.Logging</kbd> internally, but this works for any Logging library of your choice. So let’s use the Kotlin’s lazy delegate to get our logger:</li>
</ol>
<pre style="padding-left: 60px">public fun &lt;R : Any&gt; R.logger(): Lazy&lt;Logger&gt; {<br/>   return lazy { Logger.getLogger(this.javaClass.name) }<br/>}</pre>
<ol start="2">
<li>Now in our class, we can simply call the method to get our logger and use it:</li>
</ol>
<pre style="padding-left: 60px">class SomeClass {<br/>  companion object { val log by logger() }<br/><br/>  fun do_something() {<br/>      log.info("Did Something")<br/>  }<br/>}</pre>
<p>When you run the code, you can see the following output:</p>
<pre style="padding-left: 60px" class="mce-root"><strong>Sep 25, 2017 10:49:00 PM packageA.SomeClass do_something</strong><br/><strong>INFO: Did Something</strong></pre>
<p>So, as we can see in the output, we get the class name and method name too (if you are accessing logger inside a method).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Here, one thing to note is that we have put our logger inside a companion object. The reason for this is quite straightforward because we want to have only one instance of logger per class.</p>
<p>Also, <kbd>logger()</kbd> returns a delegate object, which means that the object will be created on its first access and will return the same value (object) on subsequent accesses.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Anko is an Android library that uses Kotlin and makes Android development easier with the help of extension functions. It provides <strong>Anko-logger</strong>, which you can use if you don’t want to write your own logger. It is included in <em>anko-commons</em>, which also has a lot of interesting things to make it worthwhile to include it in your Android projects that use Kotlin.</p>
<p>In Anko, a standard implementation of logger will look something like this:</p>
<pre style="padding-left: 60px">class SomeActivity : Activity(), AnkoLogger {<br/>   private fun someMethod() {<br/>       info("London is the capital of Great Britain")<br/>       debug(5) // .toString() method will be executed<br/>       warn(null) // "null" will be printed<br/>   }<br/>}</pre>
<p>As you can see, you just need to implement <kbd>AnkoLogger</kbd> and you are done.</p>
<p>Each method has two versions: plain and lazy (inlined):</p>
<pre style="padding-left: 60px">info("String " + "concatenation")</pre>
<pre style="padding-left: 60px">info { "String " + "concatenation" }</pre>
<p>The lambda result will be calculated only if <kbd>Log.isLoggable(tag, Log.INFO)</kbd> is true.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">See also</h1>
                
            
            
                
<p>To know more about delegated properties, refer to the <strong>Working with delegated Properties</strong> recipe in <a href="https://www.safaribooksonline.com/library/view/kotlin-programming-cookbook/9781788472142/9cdf4de5-7577-4bd5-ba2d-2bd38740957a.xhtml">Chapter 3</a>, <em>Classes and Objects</em>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Escaping for Java identifiers that are keywords in Kotlin</h1>
                
            
            
                
<p>Kotlin was designed with <em>interoperability</em> in mind. The existing code in Java can be called from Kotlin code smoothly, but since Java has different keywords than Kotlin, we sometimes run into issues when we call Java method with a name similar to Kotlin keyword. There is a workaround in Kotlin, which allows a method to be called having a name representing a Kotlin keyword.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Ensure that you have access to a code editor where you can write and run the code.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Create a Java class with a method name equal to any Kotlin keyword. I am using <kbd>is</kbd> as the method name, so my Java class looks as follows:</p>
<pre style="padding-left: 60px">public class ASimpleJavaClass {<br/>   static void is(){<br/>       System.out.print("Nothing fancy here");<br/>   }<br/>}</pre>
<p>Now try calling that method from Kotlin code. If you are using any code editor with the autocomplete feature, it automatically encloses the method name in backticks (<kbd>` `</kbd>):</p>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>   ASimpleJavaClass.`is`()   <br/>}</pre>
<p>Similar is the case with other keywords in Kotlin that are qualified identifiers in Java.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>According to Kotlin’s documentation, some of the Kotlin keywords are valid identifiers in Java: <kbd>in</kbd>, <kbd>object</kbd>, <kbd>is</kbd>, and so on. If a Java library uses a Kotlin keyword for a method, you can still call the method, escaping it with the backtick (<kbd>`</kbd>) character.</p>
<p>The following are the keywords in Kotlin:</p>
<table>
<tbody>
<tr>
<td>package</td>
<td>as</td>
<td>typealias</td>
<td>class</td>
<td>this</td>
<td>super</td>
<td>val</td>
</tr>
<tr>
<td>var</td>
<td>fun</td>
<td>for</td>
<td>null</td>
<td>true</td>
<td>false</td>
<td>is</td>
</tr>
<tr>
<td>in</td>
<td>throw</td>
<td>return</td>
<td>break</td>
<td>continue</td>
<td>object</td>
<td>if</td>
</tr>
<tr>
<td>try</td>
<td>else</td>
<td>while</td>
<td>do</td>
<td>when</td>
<td>interface</td>
<td>typeof</td>
</tr>
</tbody>
</table>


            

            
        
    </div>



  
<div><h1 class="header-title">Disambiguating using the "as" keyword to locally rename the clashing entity</h1>
                
            
            
                
<p>Disambiguation refers to the removal of ambiguity by making something clear. Importing a library or a class in code is a daily routine of a programmer. It’s pretty easy to import files into the code in every language, thanks to the great code editors nowadays.</p>
<p>However, what happens if you try to import two classes into a file? Though you should always try to have different names for different classes, sometimes it’s unavoidable. For example, in the case of different libraries having the same name for their classes. In Java, there is a workaround; you have to use the full qualifier, which looks something like this:</p>
<pre style="padding-left: 60px">class X {<br/>   com.very.very.long.prefix.bar.Foo a;<br/>   org.other.very.very.long.prefix.baz.Foo b;<br/>   ...<br/>}</pre>
<p>Dirty, isn’t it? Now, let’s see how Kotlin addresses it gracefully.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Ensure that you have a code editor on which you can write and run the code. To test things out, you can create two classes with the same name but under different packages. Refer to the example here:</p>
<div><img height="117" width="231" src="img/34cb1dc3-38b1-47dd-ac11-5a20d76d0d2b.png"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>In the following steps and examples, we will see how we can disambiguate classes of the similar name using Kotlin's keyword.</p>
<ol>
<li>In Kotlin, you can disambiguate using the <kbd>as</kbd> keyword to locally rename the clashing entity. So in Kotlin, it will look as shown:</li>
</ol>
<pre style="padding-left: 60px">import foo.Bar // Bar is accessible<br/>import bar.Bar as bBar // bBar stands for 'bar.Bar'</pre>
<ol start="2">
<li>Then, access their methods like this:</li>
</ol>
<pre style="padding-left: 60px">Bar.methodOfFooBar()<br/>bBar.methodOfBarBar()</pre>
<p>For example, let's see the use of the <kbd>as</kbd> keyword to disambiguate two classes having the same name (<kbd>SomeClass.kt</kbd>), but in different packages:</p>
<p><kbd>SameClass.kt (packageA)</kbd></p>
<pre style="padding-left: 60px">package packageA<br/>class SameClass {<br/>  companion object {<br/>      fun methodA(){<br/>          println("Method a")<br/>      }<br/>  }<br/>}</pre>
<p><kbd>SameClass.kt (packageB)</kbd></p>
<pre style="padding-left: 60px">package packageB<br/>class SameClass {<br/>  companion object {<br/>      fun methodB(){<br/>          println("Method b")<br/>      }<br/>  }<br/>}</pre>
<p><kbd>HelloWorld.kt</kbd> is the class that uses classes with similar names:</p>
<pre style="padding-left: 60px">import packageA.SameClass as anotherSameClass<br/>import packageB.SameClass<br/>fun main(args: Array&lt;String&gt;) {<br/>   anotherSameClass.methodA()<br/>   SameClass.methodB()<br/><br/>}</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Doing bit manipulations in Kotlin</h1>
                
            
            
                
<p>Kotlin provides several functions (in infix form) to perform bitwise and bit shift operations. In this section, we will learn to perform bit-level operation in Kotlin with the help of examples.</p>
<p>Bitwise and bit shift operators are used on only two integral types—Int and Long—to perform bit-level operations.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Here's the complete list of bitwise operations (available for Int and Long only):</p>
<ul>
<li><kbd>shr(bits)</kbd>: signed shift right (Java's &gt;&gt;)</li>
<li><kbd>ushr(bits)</kbd>: unsigned shift right (Java's &gt;&gt;&gt;)</li>
<li><kbd>and(bits)</kbd>: bitwise and</li>
<li><kbd>or(bits)</kbd>: bitwise or</li>
<li><kbd>xor(bits)</kbd>: bitwise xor</li>
<li><kbd>inv()</kbd>: bitwise inversion</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Let's check out a few examples to understand the bitwise operations.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Or</h1>
                
            
            
                
<p>The <kbd>or</kbd> function compares the corresponding bits of two values. If either of the two bits is 1, it gives 1, and it gives 0 if not.</p>
<p>Consider this example:</p>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>  val a=2<br/>  val b=3<br/>  print(a or b)<br/>}<br/><br/></pre>
<p>The following is the output:</p>
<pre style="padding-left: 60px"> 3</pre>
<p>Here's the explanation of the preceding example:</p>
<p style="padding-left: 60px">2 = 10 (Binary format)</p>
<p style="padding-left: 60px">3 = 11 (Binary format)</p>
<p style="padding-left: 60px"> Bitwise <kbd>OR</kbd> of 2 and 3 that is</p>
<p style="padding-left: 60px">in binary </p>
<p style="padding-left: 60px"> 10 <kbd>OR</kbd> 11</p>
<p style="padding-left: 60px"> 11 = 3 (Decimal format)</p>


            

            
        
    </div>



  
<div><h1 class="header-title">and</h1>
                
            
            
                
<p>The <kbd>and</kbd> function compares the corresponding bits of two values. If either of the two bits is 0, it gives 0, if not and both bits are 1, it gives 1.</p>
<p>Consider this example:</p>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>  val a=2<br/>  val b=3<br/>  print(a and b)<br/>}</pre>
<p class="mce-root"/>
<p>This is the output:</p>
<pre style="padding-left: 60px"> 2</pre>
<p>Let's look at the explanation:</p>
<p style="padding-left: 60px">2 = 10 (Binary format)</p>
<p style="padding-left: 60px">3 = 11 (Binary format)</p>
<p style="padding-left: 60px">Bitwise <kbd>AND</kbd> of 2 and 3</p>
<p>              in binary</p>
<p style="padding-left: 60px">10 <kbd>AND</kbd> 11</p>
<p style="padding-left: 60px">10 = 2 (Decimal format)</p>


            

            
        
    </div>



  
<div><h1 class="header-title">xor</h1>
                
            
            
                
<p>The <kbd>xor</kbd> function compares the corresponding bits of two values. If the corresponding bits are the same, it gives 0, and if they are different, it gives 1.</p>
<p>Look at this example:</p>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>  val a=2<br/>  val b=3<br/>  print(a xor b)<br/>}</pre>
<p>Given is the output:</p>
<pre style="padding-left: 60px"> 1</pre>
<p>Here's the explanation:</p>
<p style="padding-left: 90px">2 = 10 (Binary format)</p>
<p style="padding-left: 90px">3 = 11 (Binary format)</p>
<p style="padding-left: 90px">Bitwise <kbd>XOR</kbd> of 2 and 3</p>
<p>                    in binary</p>
<p style="padding-left: 90px">10 <kbd>XOR</kbd> 11</p>
<p style="padding-left: 90px">01 = 1 (Decimal format)</p>


            

            
        
    </div>



  
<div><h1 class="header-title">inv</h1>
                
            
            
                
<p>The <kbd>inv</kbd> function simply inverts the bit patterns. If the bit is 1, it makes it 0 and vice versa.</p>
<p>Here's an example:</p>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    val a=2<br/>   print(a.inv())}</pre>
<p>This is the output:</p>
<pre style="padding-left: 60px"> -3</pre>
<p>The following is the explanation:</p>
<p style="padding-left: 60px">2 = 10 (Binary format)</p>
<p style="padding-left: 60px">Bitwise complement of 2 = 01, but the compiler shows 2’s complement of that number, which is the negative notation of the binary number.</p>
<p style="padding-left: 60px">2’s complement of an integer <em>n</em> is equal to -(<em>n</em>+1).</p>
<p> </p>


            

            
        
    </div>



  
<div><h1 class="header-title">shl</h1>
                
            
            
                
<p>The <kbd>shl</kbd> function shifts the bit pattern to the left by the specified number of bits.</p>
<p>Consider this example:</p>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>       println( 5 shl 0)<br/>       println( 5 shl 1)<br/>       println( 5 shl 2)<br/>}</pre>
<p>This is the output:</p>
<pre style="padding-left: 60px">5<br/>10<br/>20</pre>
<p>Here's the explanation:</p>
<p style="padding-left: 60px">5 = 101 (Binary format)</p>
<p style="padding-left: 60px">101 Shift left by 0 bits = 101</p>
<p style="padding-left: 60px">101 Shift left by 1 bits = 1010 (10 in Decimal)</p>
<p style="padding-left: 60px">101 Shift left by 2 bits = 10100 (20 in Decimal)</p>
<p> </p>


            

            
        
    </div>



  
<div><h1 class="header-title">shr</h1>
                
            
            
                
<p>The <kbd>shr</kbd> function shifts the bit pattern to the right by the specified number of bits.</p>
<p>Take this example into consideration:</p>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>       println( 5 shr 0)<br/>       println( 5 shr 1)<br/>       println( 5 shr 2)<br/>}</pre>
<p>Given here is the output:</p>
<pre style="padding-left: 60px">5<br/>2<br/>1</pre>
<p>The following is the explanation:</p>
<p style="padding-left: 60px">5 = 101 (Binary format)</p>
<p style="padding-left: 60px">101 Shift right by 0 bits = 101</p>
<p style="padding-left: 60px">101 Shift right by 1 bits = 010 (2 in Decimal)</p>
<p style="padding-left: 60px">101 Shift right by 2 bits = 001 (1 in Decimal)</p>


            

            
        
    </div>



  
<div><h1 class="header-title">ushr</h1>
                
            
            
                
<p>The <kbd>ushr</kbd> function shifts the bit pattern to the right by the specified number of bits, filling the leftmost with 0s.</p>
<p>Here's an example:</p>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>       println( 5 ushr 0)<br/>       println( 5 ushr 1)<br/>       println( 5 ushr 2)<br/>}</pre>
<p>This will output the following:</p>
<pre style="padding-left: 60px">5<br/>2<br/>1</pre>
<p>This is its explanation:</p>
<p style="padding-left: 60px">5 = 101 (Binary format)</p>
<p style="padding-left: 60px">101 Shift right by 0 bits = 101</p>
<p style="padding-left: 60px">101 Shift right by 1 bits = 010 (2 in Decimal)</p>
<p style="padding-left: 60px">101 Shift right by 2 bits = 001 (1 in Decimal)</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The bitwise operators in Kotlin aren’t built-in operators like in Java, but they can still be used as an operator. Why? Look at its implementation:</p>
<pre style="padding-left: 60px">public infix fun shr(bitCount: Int): Int</pre>
<p>You can see that the method has the <kbd>infix</kbd> notation, which enables it to be called as an <kbd>infix</kbd> expression.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Parsing String to Long, Double, or Int</h1>
                
            
            
                
<p>Kotlin makes it really easy to parse String into other data types, such as Long, Integer, or Double.</p>
<p>In JAVA, <kbd>Long.parseLong()</kbd>, or the <kbd>Long.valueOf()</kbd> static method is used, which parses the string argument as a signed decimal long and returns a long value, and similarly for other data types such as Int, Double, and Boolean. Let’s see how to achieve it in Kotlin.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You just need a Kotlin editor to write and run your code. We’ll use conversion of Long as an example to discuss parsing with string. Conversion to other data types is quite similar.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To parse the string to a Long data type, we use the <kbd>.toLong()</kbd> method with the string. It parses the string as a Long number and returns the result. It throws <kbd>NumberFormatException</kbd> if the string is not a valid representation of a number. Later, we will see examples for this.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Converting String to Long</h1>
                
            
            
                
<p>Here's an example that shows parsing of string to Long:</p>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>  val str="123"<br/>  print(str.toLong())<br/>}</pre>
<p>When you run the preceding code, you will see this output:</p>
<pre style="padding-left: 60px">123</pre>
<p>If you don’t want to deal with the exceptions, you can use <kbd>.toLongOrNull()</kbd>. This method parses the string as a Long and returns the result, or null if the string is not a valid representation of a number.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Converting string to Long using string.toLongOrNull()</h1>
                
            
            
                
<p>In this example, we will see how we can parse a string using the <kbd>.toLongOrNull()</kbd> method:</p>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>  val str="123.4"<br/>  val str2="123"<br/>  println(str.toLongOrNull())<br/>  println(str2.toLongOrNull())<br/>}</pre>
<p>On running the preceding program, the following output is generated:</p>
<pre style="padding-left: 60px"> null 123</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Converting with special radix</h1>
                
            
            
                
<p>All the preceding examples use the base (radix) 10. There are cases when we wish to convert a String to Long but using another base. Both <kbd>string.toLong()</kbd> and <kbd>string.toLongOrNull()</kbd> can receive a custom radix to be used in the conversion. Let's take a look at its implementation:</p>
<ul>
<li style="font-weight: 400"><kbd>string.toLong(radix)</kbd>:
<ul>
<li style="font-weight: 400">This parses the string as a <kbd>[Long]</kbd> number and returns the result</li>
<li style="font-weight: 400"><kbd>@throws NumberFormatException</kbd> if the string is not a valid representation of a number</li>
<li style="font-weight: 400"><kbd>@throws IllegalArgumentException</kbd> when <kbd>[radix]</kbd> is not a valid radix for string to number conversion</li>
</ul>
</li>
<li style="font-weight: 400"><kbd>string.toLongOrNull(radix)</kbd>:
<ul>
<li style="font-weight: 400">This parses the string as a <kbd>[Long]</kbd> number and returns the result or null if the string is not a valid representation of a number</li>
<li style="font-weight: 400"><kbd>@throws IllegalArgumentException</kbd> when <kbd>[radix]</kbd> is not a valid radix for string to number conversion</li>
</ul>
</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Parsing string to Long with special radix</h1>
                
            
            
                
<p>In the preceding examples, we were parsing strings with radix 10, that is, decimals. By default, the radix is taken as 10, but there are certain situations where we need different radix. For example, in case of parsing a string into a binary or octal number. So now, we will see how to work with radix other than the decimal. Though you can use any valid radix, we will show examples that are most commonly used, such as binary and octal.</p>
<ul>
<li style="font-weight: 400"><strong>Binary</strong>: Since a binary number is made from 0 and 1, the radix used is 2:</li>
</ul>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>       val str="11111111"<br/>       print(str.toLongOrNull(2))   }</pre>
<p style="padding-left: 60px">On running the preceding program, the following output is generated:</p>
<pre style="padding-left: 60px"> 255</pre>
<ul>
<li style="font-weight: 400"><strong>Octal</strong>: The octal numeral system, or oct for short, is the base-8 number system and uses the digits 0 to 7. Hence, we will use 8 as a radix:</li>
</ul>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>      val str="377"<br/>       print(str.toLongOrNull(8))<br/>   }</pre>
<p style="padding-left: 60px">On running the preceding program, this output is generated:</p>
<pre style="padding-left: 60px"> 255</pre>
<ul>
<li style="font-weight: 400"><strong>Decimal</strong>: The decimal system has 10 numbers in it (0-9); hence, we will use 10 as radix. Note that radix as 10 is used by default in the methods without the radix arguments (<kbd>.toLong() , .toLongOrNull()</kbd>):</li>
</ul>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>      val str="255"<br/>       print(str.toLongOrNull(10))<br/>   }</pre>
<p style="padding-left: 60px">On running the preceding program, the following output is generated:</p>
<pre style="padding-left: 60px"> 255</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Kotlin uses String’s extension functions such as <kbd>.toLong()</kbd> and <kbd>toLongOrNull()</kbd> to make things easier. Let’s dive into their implementation.</p>
<ul>
<li style="font-weight: 400">For <kbd>Long</kbd>, use this:</li>
</ul>
<pre style="padding-left: 60px">public inline fun String.toLong(): Long = java.lang.Long.parseLong(this)</pre>
<p>As you can see, internally, it also calls the <kbd>Long.parseLong(string)</kbd> Java static method, and it is similar to the other data types.</p>
<ul>
<li style="font-weight: 400">For <kbd>Short</kbd>, it's the following:</li>
</ul>
<pre style="padding-left: 60px">public inline fun String.toShort(): Short = java.lang.Short.parseShort(this)</pre>
<ul>
<li style="font-weight: 400">Use this for <kbd>Int</kbd>:</li>
</ul>
<pre style="padding-left: 60px">public inline fun String.toInt(): Int = java.lang.Integer.parseInt(this)</pre>
<ul>
<li style="font-weight: 400">For parsing with Radix, use the following:</li>
</ul>
<pre style="padding-left: 60px">public inline fun String.toLong(radix: Int): Long = java.lang.Long.parseLong(this, checkRadix(radix))</pre>
<p>The <kbd>checkRadix</kbd> method checks whether the given <kbd>[radix]</kbd> is valid radix for string to number and number to string conversion.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Let’s quickly see a few other extension functions provided by Kotlin to parse String:</p>
<ul>
<li style="font-weight: 400"><kbd>toBoolean()</kbd>: Returns <kbd>`true`</kbd> if the content of this string is equal to the word <em>true</em>, ignoring case, and <kbd>`false`</kbd> otherwise.</li>
<li style="font-weight: 400"><kbd>toShort()</kbd>: Parses the string as a <kbd>[Short]</kbd> number and returns the result. Also, it throws <kbd>NumberFormatException</kbd> if the string is not a valid representation of a number.</li>
<li style="font-weight: 400"><kbd>toShort(radix)</kbd>: Parses the string as a <kbd>[Short]</kbd> number and returns the result, throws <kbd>NumberFormatException</kbd> if the string is not a valid representation of a number, and throws <kbd>IllegalArgumentException</kbd> when <kbd>[radix]</kbd> is not a valid radix for the string to number conversion.</li>
<li style="font-weight: 400"><kbd>toInt()</kbd>: Parses the string as an <kbd>[Int]</kbd> number and returns the result and throws <kbd>NumberFormatException</kbd> if the string is not a valid representation of a number.</li>
<li style="font-weight: 400"><kbd>toIntOrNull()</kbd>: Parses the string as an <kbd>[Int]</kbd> number and returns the result or <kbd>`null`</kbd> if the string is not a valid representation of a number.</li>
<li style="font-weight: 400"><kbd>toIntOrNull(radix)</kbd>: Parses the string as an <kbd>[Int]</kbd> number and returns the result or <kbd>`null`</kbd> if the string is not a valid representation of a number, or <kbd>@throws IllegalArgumentException</kbd> when <kbd>[radix]</kbd> is not a valid radix for string to number conversion.</li>
<li style="font-weight: 400"><kbd>toFloat()</kbd>: Parses the string as a <kbd>[Float]</kbd> number and returns the result, and <kbd>@throws NumberFormatException</kbd> if the string is not a valid representation of a number.</li>
<li><kbd>toDouble()</kbd> : Parses the string as a <kbd>[Double]</kbd> number and returns the result, and <kbd>@throws NumberFormatException</kbd> if the string is not a valid representation of a number.</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Using String templates in Kotlin</h1>
                
            
            
                
<p>Kotlin packs great features with commonly used data type String. One of the really cool features is String templates. This feature allows Strings to contain template expression.</p>
<p>In Java, you had to use <strong>StrSubstitutor</strong> (<a href="https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/StrSubstitutor.html">https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/StrSubstitutor.html</a>) and a map to go with it. A template expression in Java will look as follows:</p>
<pre style="padding-left: 60px">Map&lt;String, String&gt; valuesMap = new HashMap&lt;String, String&gt;();<br/>valuesMap.put("city", "Paris");<br/>valuesMap.put("monument", "Eiffel Tower");<br/>String templateString ="Enjoyed ${monument} in ${city}.";<br/>StrSubstitutorsub=newStrSubstitutor(valuesMap);<br/>String resolvedString =sub.replace(templateString);</pre>
<p>Kotlin eases out the pain in writing template expressions and makes it fun, concise, and a lot less verbose.</p>
<p>Using String templates, you can embed a variable or expression inside a string without string concatenation. So, let’s get started!</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>In the following steps, we will learn how to use String templates:</p>
<ol>
<li>In Kotlin, the template expression starts with a <kbd>$</kbd> sign.</li>
<li>The syntax of string templates is as follows:</li>
</ol>
<pre style="padding-left: 60px">$variableName</pre>
<p style="padding-left: 60px">Alternatively, it is this:</p>
<pre style="padding-left: 60px">${expression}</pre>
<ol start="3">
<li>Let's check out a few examples:</li>
</ol>
<ul>
<li>Consider the example of a String template with variable:</li>
</ul>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    val foo = 5;<br/>    val myString = "foo = $foo"<br/>    println(myString)<br/> }</pre>
<p style="padding-left: 60px">The output of the preceding code will be <kbd>foo = 5</kbd>.</p>
<ul>
<li>Consider the example of a String template with expression:</li>
</ul>
<pre style="padding-left: 60px">fun main(arr: Array&lt;String&gt;){<br/>  val lang = "Kotlin"<br/>  val str = "The word Kotlin has ${lang.length} characters."<br/>  println(str)<br/>}</pre>
<ul>
<li>Consider the example of a String template with raw string:
<ul>
<li><strong>Raw string</strong>: A string consisting of newlines without writing <kbd>\n</kbd> and arbitrary string. It's a raw string and is placed in triple quotes (<kbd>"""</kbd>):</li>
</ul>
</li>
</ul>
<pre style="padding-left: 120px">fun main(args: Array&lt;String&gt;) {<br/>    val a = 5<br/>    val b = 6<br/> <br/>    val myString = """<br/>    ${if (a &gt; b) a else b}<br/> """<br/>    println("Bigger number is: ${myString.trimMargin()}")<br/> }</pre>
<p>When you run the program, the output will be <kbd>Bigger number is: 6</kbd>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The use of String template with a variable name is quite straightforward. Earlier, we used to concatenate the strings, but now we can just specify the variable with the <kbd>$</kbd>  symbol before it.</p>
<p>When the string template is used as an expression, the expression inside the <kbd>${..}</kbd> is evaluated first and the value is concatenated with the string. In the preceding example (String template with raw string), the <kbd>${if (a &gt; b) a else b}</kbd> expression is evaluated and its value, that is 6, is printed with the string.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There’s more...</h1>
                
            
            
                
<p>String templates also come in handy with String properties and functions. Here's an example:</p>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>      val str1="abcdefghijklmnopqrs"<br/>       val str2="tuvwxyz"<br/>       println("str1 equals str2 ? = ${str1.equals(str2)}")<br/>       println("subsequence is ${str1.subSequence(1,4)}")<br/>       println("2nd character is ${str1.get(1)}")<br/>   }</pre>
<p>Here's the output:</p>
<pre style="padding-left: 60px">str1 equals str2 ? = false<br/>subsequence is bcd<br/>2nd character is b</pre>


            

            
        
    </div>



  </body></html>