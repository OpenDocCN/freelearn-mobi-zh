<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Threads and Coroutines</h1>
                
            
            
                
<p class="calibre2">In this chapter, we'll discuss how our application can efficiently serve thousands of requests per second. In the previous chapter, we already had one glimpse at it—<strong class="calibre5">reactive streams</strong> use a number of different threads (exposed by the <kbd class="calibre13">Schedulers</kbd> API), and we even had to create a thread once or twice with the <kbd class="calibre13">thread()</kbd> function. But before we dive into nuances, let's first discuss what kind of problems threads are able to solve.</p>
<p class="calibre2">In your laptop, you have a CPU with multiple cores, probably four of them. That means that it can do four different computations <em class="calibre14">in parallel</em>, which is pretty amazing, considering that 10 years ago, a single-core CPU was the default and even two cores were only for enthusiasts.</p>
<p class="calibre2">But even back then, you were not actually limited to doing only a single task at a time, right? You could listen to music and browse the internet at the same time, even on a single-core CPU. How does your CPU manage to pull that off? Well, the same way your brain does. It juggles tasks. When you're reading a book while listening to your friend talking, part of the time you're not really reading and part of the time you're not really listening. That is until we get at least two cores in our brains.</p>
<p class="calibre2">The servers you run your code on have pretty much the same CPU. Which still means they can serve four requests simultaneously. But what if you have 10,000 requests per second? You can't serve them in parallel, because you don't have 10,000 CPU cores. But you can try and serve them concurrently.</p>
<p class="calibre2">In this chapter, we will cover the following topics:</p>
<ul class="calibre11">
<li class="calibre12">Threads</li>
<li class="calibre12">Coroutines</li>
<li class="calibre12">Channels</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Threads</h1>
                
            
            
                
<p class="calibre2">The most basic concurrency model is provided by JVM threads. Threads allow us to run code concurrently (but not necessarily in parallel), making better use of multiple CPU cores, for example. They are more lightweight than processes. One process may spawn hundreds of threads. Unlike processes, sharing data between threads is easy. But that also introduces a lot of problems, as we'll see later.</p>
<p class="calibre2">Let's see how we create two threads in Java first:</p>
<pre class="calibre18">new Thread(() -&gt; {<br class="title-page-name"/>   for (int i = 0; i &lt; 100; i++) {<br class="title-page-name"/>      System.out.println("T1: " + i);<br class="title-page-name"/>   }<br class="title-page-name"/>}).start();<br class="title-page-name"/><br class="title-page-name"/>new Thread(() -&gt; {<br class="title-page-name"/>   for (int i = 0; i &lt; 100; i++) {<br class="title-page-name"/>      System.out.println("T2: " + i);<br class="title-page-name"/>   }<br class="title-page-name"/>}).start();</pre>
<p class="calibre2">The output will look something like this:</p>
<pre class="calibre18"><strong class="calibre1">...</strong><br class="title-page-name"/><strong class="calibre1">T2: 12</strong><br class="title-page-name"/><strong class="calibre1">T2: 13</strong><br class="title-page-name"/><strong class="calibre1">T1: 60</strong><br class="title-page-name"/><strong class="calibre1">T2: 14</strong><br class="title-page-name"/><strong class="calibre1">T1: 61</strong><br class="title-page-name"/><strong class="calibre1">T2: 15</strong><br class="title-page-name"/><strong class="calibre1">T2: 16</strong><br class="title-page-name"/><strong class="calibre1">...</strong></pre>
<p class="calibre2">Note that the output will vary between executions, and at no point is it guaranteed to be interleaved.</p>
<p class="calibre2">The same code in Kotlin would look as follows:</p>
<pre class="calibre18">val t1 = thread {<br class="title-page-name"/>    for (i in 1..100) {<br class="title-page-name"/>        println("T1: $i")<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>val t2 = thread {<br class="title-page-name"/>    for (i in 1..100) {<br class="title-page-name"/>        println("T2: $i")<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">In Kotlin, there's less boilerplate, because there's a function that helps us create a new thread. Notice that unlike Java, we don't need to call <kbd class="calibre13">start()</kbd> to launch the thread. It starts by default. If we would like to postpone it for later, we can set the <kbd class="calibre13">start</kbd> parameter to <kbd class="calibre13">false</kbd>:</p>
<pre class="calibre18">val t2 = thread<strong class="calibre1">(start = false)</strong> {<br class="title-page-name"/>    for (i in 1..100) {<br class="title-page-name"/>        println("T2: $i")<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/>...<br class="title-page-name"/>// Later<br class="title-page-name"/><strong class="calibre1">t2.start()</strong></pre>
<p class="calibre2">Another useful concept from Java is <em class="calibre14">daemon threads</em>. These threads don't prevent JVM from exiting and are very good for non-critical background tasks.</p>
<p class="calibre2">In Java, the API is not fluent, so we'll have to assign our thread to a variable, set it to be a daemon thread, and then start it:</p>
<pre class="calibre18">Thread t1 = new Thread(() -&gt; {<br class="title-page-name"/>    for (int i = 0; i &lt; 100; i++) {<br class="title-page-name"/>        System.out.println("T1: " + i);<br class="title-page-name"/>    }<br class="title-page-name"/>});<br class="title-page-name"/><strong class="calibre1">t1.setDaemon(true)</strong><strong class="calibre1">;</strong><br class="title-page-name"/>t1.start();</pre>
<p class="calibre2">In Kotlin, this is much simpler:</p>
<pre class="calibre18">val t3 = thread<strong class="calibre1">(isD</strong><strong class="calibre1">aemon</strong><strong class="calibre1"> =</strong><strong class="calibre1"> t</strong><strong class="calibre1">rue)</strong> {<br class="title-page-name"/>    for (i in 1..1_000_000) {<br class="title-page-name"/>        println("T3: $i")<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Notice that although we asked this thread to print numbers up to one million, it prints only a few hundred. That's because it's a daemon thread. When the parent thread stops, it stops too.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Thread safety</h1>
                
            
            
                
<p class="calibre2">There are many books written about thread safety and there are good reasons for that. Concurrency bugs that are caused by lack of thread safety are the ones hardest to track. They're hard to reproduce, because you'll usually need a lot of threads competing on the same resource for an actual race to happen. Because this book is about Kotlin and not thread safety in general, we'll only scratch the surface of this topic. If you're interested in the topic of thread safety in the JVM language, you should check out the book <em class="calibre14">Java Concurrency in Practice</em> by Brian Goetz.</p>
<p class="calibre2">We'll start with the following example, which creates 100,000 threads to increment a counter:</p>
<pre class="calibre18">var counter = 0<br class="title-page-name"/>val latch = CountDownLatch(100_000)<br class="title-page-name"/>for (i in 1..100_000) {<br class="title-page-name"/>    thread {<br class="title-page-name"/>        counter++<br class="title-page-name"/>        latch.countDown()<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>latch.await()<br class="title-page-name"/>println("Counter $counter")</pre>
<p class="calibre2">If you have a bit of experience with concurrent programming, you'll understand right away why this code prints a number that is less than 100,000. The reason is the <kbd class="calibre13">++</kbd> operation is not atomic. So the more threads that try to increment our counter, the more chances for data races. </p>
<p class="calibre2">But, unlike Java, there's no <kbd class="calibre13">synchronized</kbd> keyword in Kotlin. The reason is that Kotlin designers believe that a language shouldn't be tailored to a particular concurrency model. Instead, there's a <kbd class="calibre13">synchronized()</kbd> function:</p>
<pre class="calibre18">var counter = 0<br class="title-page-name"/>val latch = CountDownLatch(100_000)<br class="title-page-name"/>for (i in 1..100_000) {<br class="title-page-name"/>    thread{<br class="title-page-name"/>        <strong class="calibre1">synchronized(latch)</strong> {<br class="title-page-name"/>            counter++<br class="title-page-name"/>            latch.countDown()<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>latch.await()<br class="title-page-name"/>println("Counter $counter")</pre>
<p class="calibre2">Now our code prints <kbd class="calibre13">100000</kbd>, as expected.</p>
<p class="calibre2">If you really miss the synchronized methods from Java, there's the <kbd class="calibre13">@Synchronized</kbd> annotation in Kotlin. There's also no <kbd class="calibre13">volatile</kbd> keyword, but the <kbd class="calibre13">@Volatile</kbd> annotation instead.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Threads are expensive</h1>
                
            
            
                
<p class="calibre2">There is a price to pay whenever we create a new thread. Each thread needs a new memory stack.</p>
<p class="calibre2">What if we simulate some work inside each thread by putting it to sleep?</p>
<p class="calibre2">In the following piece of code, we'll attempt to create 10,000 threads, each sleeping for a relatively short period of time:</p>
<pre class="calibre18">val counter = AtomicInteger()<br class="title-page-name"/>try {<br class="title-page-name"/>    for (i in 0..10_000) {<br class="title-page-name"/>        thread {<br class="title-page-name"/>            counter.incrementAndGet()<br class="title-page-name"/>            Thread.sleep(100)<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>} catch (oome: OutOfMemoryError) {<br class="title-page-name"/>    println("Spawned ${counter.get()} threads before crashing")<br class="title-page-name"/>    System.exit(-42)<br class="title-page-name"/>}</pre>
<p class="calibre2">Depending on your operation system, this will result in either <kbd class="calibre13">OutOfMemoryError</kbd> or the entire system becoming very slow. Of course, there are ways to limit how many threads are run at once, using the <strong class="calibre5">executors API</strong> from Java 5.</p>
<p class="calibre2">We create a new thread pool of a specified size:</p>
<pre class="calibre18">// Try setting this to 1, number of cores, 100, 2000, 3000 and see what happens<br class="title-page-name"/>val pool = Executors.newFixedThreadPool(100)</pre>
<p class="calibre2">Now we would like to submit a new task. We're doing this by calling <kbd class="calibre13">pool.submit()</kbd>:</p>
<pre class="calibre18"><br class="title-page-name"/><br class="title-page-name"/>val counter = AtomicInteger(0)<br class="title-page-name"/><br class="title-page-name"/>val start = System.currentTimeMillis()<br class="title-page-name"/>for (i in 1..10_000) {<br class="title-page-name"/>    pool.submit {<br class="title-page-name"/>        // Do something<br class="title-page-name"/>        counter.incrementAndGet()<br class="title-page-name"/><br class="title-page-name"/>        // Simulate wait on IO<br class="title-page-name"/>        Thread.sleep(100)<br class="title-page-name"/><br class="title-page-name"/>        // Do something again<br class="title-page-name"/>        counter.incrementAndGet()<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Then we need to make sure that the pool terminates, by using the following lines:</p>
<pre class="calibre18"><strong class="calibre1">pool.awaitTermination</strong>(20, TimeUnit.SECONDS)<br class="title-page-name"/><strong class="calibre1">pool.shutdown</strong>()<br class="title-page-name"/><br class="title-page-name"/>println("Took me ${System.currentTimeMillis() - start} millis to complete ${counter.get() / 2} tasks")</pre>
<p class="calibre2">Notice that it took us 20 seconds to complete. That's because a new task cannot begin until previous tasks <em class="calibre14">woke up</em> and completed their job. </p>
<p class="calibre2">And that's exactly what happens in multithreaded systems, which is not concurrent enough.</p>
<p class="calibre2">In the next section, we'll discuss how coroutines try to solve this problem.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Coroutines</h1>
                
            
            
                
<p class="calibre2">In addition to the threading model provided by Java, Kotlin also introduces a coroutines model. Coroutines might be considered lightweight threads, and we’ll see what advantages they provide over an existing model of threads shortly.</p>
<p class="calibre2">The first thing you need to know is that coroutines are not part of the language. They are simply another library provided by JetBrains. For that reason, if we want to use them, we need to specify so in our Gradle configuration file, <kbd class="calibre13">build.gradle</kbd>:</p>
<pre class="calibre18">dependencies {<br class="title-page-name"/>    ...<br class="title-page-name"/>    compile "<strong class="calibre1">org.jetbrains.kotlinx:kotlinx-coroutines-core</strong>:0.21"<br class="title-page-name"/>    ...<br class="title-page-name"/>}</pre>
<p class="calibre2">As of Kotlin 1.2, coroutines are still considered experimental. This doesn't mean that they don't work well, though, as some might think. It only means that some parts of the API may still change in the next versions.</p>
<p class="calibre2">What could change? For example, in 0.18, an Actor, which we'll discuss later in this chapter, exposed a channel member. In 0.21, this member was made private and a method was added instead. So instead of calling <kbd class="calibre13">actor.channel.send()</kbd>, you would call <kbd class="calibre13">actor.send()</kbd>.</p>
<p>It's fine if you're not aware what <em class="calibre22">actor</em> or <em class="calibre22">channel</em> mean at this point. We'll cover those terms in the following sections shortly.</p>
<p class="calibre2">For that reason, after you add this dependency and start using them, you may get warnings during compilation or in your IDE:</p>
<pre class="calibre18">The feature "coroutines" is experimental</pre>
<p class="calibre2">You can hide those warnings with the following Gradle configuration:</p>
<pre class="calibre18">kotlin {<br class="title-page-name"/>    experimental {<br class="title-page-name"/>        coroutines 'enable'<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, let's get started with coroutines.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Starting coroutines</h1>
                
            
            
                
<p class="calibre2">We've already seen how to start a new thread in Kotlin. Now let's start a new coroutine instead.</p>
<p class="calibre2">We'll create almost the same example we did with threads. Each coroutine will increment some counter, sleep for a while to emulate some kind of IO, and then increment it again:</p>
<pre class="calibre18">val latch = CountDownLatch(10_000)<br class="title-page-name"/>val c = AtomicInteger()<br class="title-page-name"/><br class="title-page-name"/>val start = System.currentTimeMillis()<br class="title-page-name"/>for (i in 1..10_000) {<br class="title-page-name"/>    <strong class="calibre1">launch(CommonPool)</strong> {<br class="title-page-name"/>        c.incrementAndGet()<br class="title-page-name"/>        <strong class="calibre1">delay</strong>(100)<br class="title-page-name"/>        c.incrementAndGet()<br class="title-page-name"/>        latch.countDown()<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>latch.await(10, TimeUnit.SECONDS)<br class="title-page-name"/><br class="title-page-name"/>println("Executed ${c.get() / 2} coroutines in ${System.currentTimeMillis() - start}ms")</pre>
<p class="calibre2">The first way of starting a new coroutine is by using the <kbd class="calibre13">launch()</kbd> function. Again, note that this is simply another function and not a language construct. </p>
<p class="calibre2">This function receives one argument: <kbd class="calibre13">context: CoroutineContext</kbd>.</p>
<p class="calibre2">Under the hood, coroutines still use a thread pool. For that reason, we can specify which thread pool to use. <kbd class="calibre13">CommonPool</kbd> is a singleton provided by the library out of the box. </p>
<p class="calibre2">Another interesting point here is called to the <kbd class="calibre13">delay()</kbd> function we use to simulate some IO bound work, like fetching something from a database or over the network.</p>
<p class="calibre2">Like the <kbd class="calibre13">Thread.sleep()</kbd> method, it puts the current coroutine to sleep. But unlike <kbd class="calibre13">Thread.sleep()</kbd>, other coroutines can work while this one sleeps soundly. This is due to the fact that <kbd class="calibre13">delay()</kbd> is marked with a suspend keyword, which we'll discuss in the section <em class="calibre14">Waiting for coroutines</em>.</p>
<p class="calibre2">If you run this code, you'll see that the task takes about 200 ms with coroutines, while with threads it either took 20 seconds or ran out of memory. And we didn't have to change our code that much. That's all thanks to the fact that coroutines are highly concurrent in their nature. They can be suspended without blocking the thread that runs them. Not blocking a thread is great, because we can use less OS threads (which are expensive) to do more work.</p>
<p class="calibre2">But of course, they're not magical. Let's create a <strong class="calibre5">Factory</strong> for our coroutines, which will be able to produce either a short-running or long-running coroutine:</p>
<pre class="calibre18">object CoroutineFactory {<br class="title-page-name"/>    fun greedyLongCoroutine(index: Int) = async {<br class="title-page-name"/>        var uuid = UUID.randomUUID()<br class="title-page-name"/>        for (i in 1..100_000) {<br class="title-page-name"/>            val newUuid = UUID.randomUUID()<br class="title-page-name"/><br class="title-page-name"/>            if (newUuid &lt; uuid) {<br class="title-page-name"/>                uuid = newUuid<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/><br class="title-page-name"/>        println("Done greedyLongCoroutine $index")<br class="title-page-name"/>        latch.countDown()<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    fun shortCoroutine(index: Int) = async {<br class="title-page-name"/>        println("Done shortCoroutine $index!")<br class="title-page-name"/>        latch.countDown()<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">We don't actually need the <strong class="calibre5">Factory Method</strong> design pattern here, but it's a nice reminder. You'll understand why the long-running coroutine is called <strong class="calibre5">greedy</strong> very soon.</p>
<p class="calibre2">If you don't remember what the Factory Method is about, you should check <a href="part0054.html#1JFUC0-6704093aa34748cfa77c54bdc1a20dc7" class="calibre10">Chapter 2</a>, <em class="calibre14">Working with Creational Patterns</em>, section <em class="calibre14">Factory method</em> again. In short, it's a method that returns an object. Which object does it return in our case? It's a job representing a coroutine, of course! We'll explain what job is for shortly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Jobs</h1>
                
            
            
                
<p class="calibre2">The result of running an asynchronous task is called a job. Much like the <kbd class="calibre13">Thread</kbd> object represents an actual OS thread, the <kbd class="calibre13">job</kbd> object represents an actual coroutine. A job has a simple lifecycle.</p>
<p class="calibre2">It can be either as follows:</p>
<ul class="calibre11">
<li class="calibre12">New: Created, but not started yet.</li>
<li class="calibre12">Active: Just created by <kbd class="calibre13">launch()</kbd> function, for example. This is the default state.</li>
<li class="calibre12">Completed: Everything went well.</li>
<li class="calibre12">Canceled: Something went wrong.</li>
</ul>
<p class="calibre2">There are two more states relevant to jobs that have child jobs:</p>
<ul class="calibre11">
<li class="calibre12">Completing: Waiting to finish executing children before completing</li>
<li class="calibre12">Canceling: Waiting to finish executing children before canceling</li>
</ul>
<p class="calibre2">If you want to understand more about parent and child jobs, just jump to the <em class="calibre14">Parent jobs</em> section in this chapter.</p>
<p class="calibre2">Job also has some useful methods, which we'll discuss in the following sections.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Coroutine starvation</h1>
                
            
            
                
<p class="calibre2">We'll call both the <kbd class="calibre13">greedyLongCoroutine()</kbd> and <kbd class="calibre13">shortCoroutine()</kbd> methods 10 times each and wait until they finish:</p>
<pre class="calibre18">val latch = CountDownLatch(10 * 2)<br class="title-page-name"/>fun main(args: Array&lt;String&gt;) {<br class="title-page-name"/><br class="title-page-name"/>    for (i in 1..10) {<br class="title-page-name"/>        CoroutineFactory.greedyLongCoroutine(i)<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    for (i in 1..10) {<br class="title-page-name"/>        CoroutineFactory.shortCoroutine(i)<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    latch.await(10, TimeUnit.SECONDS)<br class="title-page-name"/>}</pre>
<p class="calibre2">It's obvious that since coroutines are asynchronous, we'll see first 10 lines of the short coroutine then 10 lines of the long coroutine:</p>
<pre class="calibre18"><strong class="calibre1">Done greedyLongCoroutine 2</strong><br class="title-page-name"/><strong class="calibre1">Done greedyLongCoroutine 4</strong><br class="title-page-name"/><strong class="calibre1">Done greedyLongCoroutine 3</strong><br class="title-page-name"/><strong class="calibre1">Done greedyLongCoroutine 5</strong><br class="title-page-name"/><strong class="calibre1">Done shortCoroutine 1! &lt;= You should have finished long ago!</strong><br class="title-page-name"/><strong class="calibre1">Done shortCoroutine 2!</strong><br class="title-page-name"/><strong class="calibre1">Done shortCoroutine 3!</strong><br class="title-page-name"/><strong class="calibre1">Done shortCoroutine 4!</strong><br class="title-page-name"/><strong class="calibre1">Done shortCoroutine 5!</strong><br class="title-page-name"/><strong class="calibre1">Done shortCoroutine 6!</strong><br class="title-page-name"/><strong class="calibre1">Done shortCoroutine 7!</strong><br class="title-page-name"/><strong class="calibre1">Done shortCoroutine 8!</strong><br class="title-page-name"/><strong class="calibre1">Done shortCoroutine 9!</strong><br class="title-page-name"/><strong class="calibre1">Done shortCoroutine 10!</strong><br class="title-page-name"/><strong class="calibre1">Done greedyLongCoroutine 6</strong><br class="title-page-name"/><strong class="calibre1">Done greedyLongCoroutine 7</strong><br class="title-page-name"/><strong class="calibre1">Done greedyLongCoroutine 1</strong><br class="title-page-name"/><strong class="calibre1">Done greedyLongCoroutine 8</strong><br class="title-page-name"/><strong class="calibre1">Done greedyLongCoroutine 9</strong><br class="title-page-name"/><strong class="calibre1">Done greedyLongCoroutine 10</strong></pre>
<p class="calibre2">Oops... That's not what you would expect. It seems like the long coroutines block the short coroutines somehow.</p>
<p class="calibre2">The reason for this behavior is that there is still an <em class="calibre14">event loop</em> based on the <em class="calibre14">thread pool</em> behind the coroutines. Since the CPU of my laptop has four cores, four long coroutines took all its resources, and until they finish their CPU-bound task, no other coroutine can start. To understand this better, let's dive deeper into how coroutines work. </p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Coroutines under the hood</h1>
                
            
            
                
<p class="calibre2">So, we've mentioned a couple of times the following facts:</p>
<ul class="calibre11">
<li class="calibre12">Coroutines are like light-weight threads. They need less resources that regular threads, so you can create more of them.</li>
<li class="calibre12">Coroutines use thread pool behind the scenes.</li>
<li class="calibre12">Instead of blocking an entire thread, coroutine suspends.</li>
</ul>
<p class="calibre2">But how does that actually work?</p>
<p class="calibre2">Let's see an abstract example. How would we compose a user profile?</p>
<pre class="calibre18">fun profile(id: String): Profile {<br class="title-page-name"/>    val bio = fetchBioOverHttp(id) // takes 1s<br class="title-page-name"/>    val picture = fetchPictureFromDB(id) // takes 100ms<br class="title-page-name"/>    val friends = fetchFriendsFromDB(id) // takes 500ms<br class="title-page-name"/>    return Profile(bio, picture)<br class="title-page-name"/>}</pre>
<p class="calibre2">Summing up, our function now takes around 1.6 seconds to complete.</p>
<p class="calibre2">But we've learned about threads. Let's refactor this function to use them instead!</p>
<pre class="calibre18">fun profile(id: String): Profile {<br class="title-page-name"/>    val bio = fetchBioOverHttpThread(id) // still takes 1s<br class="title-page-name"/>    val picture = fetchPictureFromDBThread(id) // still takes 100ms<br class="title-page-name"/>    val friends = fetchFriendsFromDBThread(id) // still takes 500ms<br class="title-page-name"/>    return Profile(bio, picture)<br class="title-page-name"/>}</pre>
<p class="calibre2">Now our function takes on average 1 second, the slowest of the three requests. But since we created a thread for each request, our memory footprint is three times larger. And we risk running out of memory quickly.</p>
<p class="calibre2">So, let's use a thread pool to limit the memory footprint:</p>
<pre class="calibre18">fun profile(id: String): Profile {<br class="title-page-name"/>    val bio = fetchBioOverHttpThreadPool()<br class="title-page-name"/>    val picture = fetchPictureFromDBThreadPool()<br class="title-page-name"/>    val friends = fetchFriendsFromDBThreadPool()<br class="title-page-name"/>    return Profile(bio, picture)<br class="title-page-name"/>}</pre>
<p class="calibre2">But what happens if we call this function 100 times now? If we have a thread pool of 10 threads, the first 10 requests will get into the pool and the 11th will get stuck until the first one finishes. That means we can serve three users simultaneously, and the fourth one will wait until the first one gets his/her results.</p>
<p class="calibre2">How is that different with coroutines? Coroutines break your methods into even smaller methods. </p>
<p class="calibre2">Let's dive deeper into one of the functions to understand how it's done:</p>
<pre class="calibre18">fun fetchBioOverHttp(id: String): Bio {<br class="title-page-name"/>    doSomething() // 50ms<br class="title-page-name"/>    val result = httpCall() // 900ms<br class="title-page-name"/>    return Bio(result) // 50ms<br class="title-page-name"/>}</pre>
<p class="calibre2">That's one function that will take 1 second to execute.</p>
<p class="calibre2">What we can do, though, is mark <kbd class="calibre13">httpCall()</kbd> with the <kbd class="calibre13">suspend</kbd> keyword:</p>
<pre class="calibre18"><strong class="calibre1">suspend</strong> fun httpCall(): Result { <br class="title-page-name"/>    ...<br class="title-page-name"/>}</pre>
<p class="calibre2">When Kotlin compiler sees this keyword, it knows it can split and rewrite the function into two like this:</p>
<pre class="calibre18">fun fetchBioOverHttp(id: String): Bio {<br class="title-page-name"/>   doSomething() // 50ms<br class="title-page-name"/>   httpCall() { // It was marked as suspend, so I can rewrite it!<br class="title-page-name"/>      callback(it)<br class="title-page-name"/>   } // Thread is released after 50ms<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// This will be called after 950ms<br class="title-page-name"/>fun callback(httpResult: Result) {<br class="title-page-name"/>   return Bio(httpResult) <br class="title-page-name"/>}</pre>
<p class="calibre2">By doing that rewrite, we are able to release the thread that executes coroutines much sooner.  </p>
<p class="calibre2">For a single user, that doesn't matter much. He will still get the results after 1 second.</p>
<p class="calibre2">But looking at the bigger picture, it means that by using the same amount of threads, we can serve 20 times more users, all thanks to the smart way Kotlin has rewritten our code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Fixing starvation</h1>
                
            
            
                
<p class="calibre2">Let's add another method to our Factory using the extension methods:</p>
<pre class="calibre18">fun CoroutineFactory.longCoroutine(index: Int) = launch {<br class="title-page-name"/>    var uuid = UUID.randomUUID()<br class="title-page-name"/>    for (i in 1..100_000) {<br class="title-page-name"/>        val newUuid = UUID.randomUUID()<br class="title-page-name"/><br class="title-page-name"/>        if (newUuid &lt; uuid) {<br class="title-page-name"/>            uuid = newUuid<br class="title-page-name"/>        }<br class="title-page-name"/><br class="title-page-name"/>        if (i % 100 == 0) {<br class="title-page-name"/>            <strong class="calibre1">yield</strong>()<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    println("Done longCoroutine $index")<br class="title-page-name"/>    latch.countDown()<br class="title-page-name"/>}</pre>
<p class="calibre2">We call this method instead in the first loop:</p>
<pre class="calibre18">...<br class="title-page-name"/>for (i in 1..10) {<br class="title-page-name"/>    CoroutineFactory.longCoroutine(i)<br class="title-page-name"/>}<br class="title-page-name"/>...</pre>
<p class="calibre2">And when we run it now, we get the output we expected in the first place:</p>
<pre class="calibre18"><strong class="calibre1">Done shortCoroutine 0!</strong><br class="title-page-name"/><strong class="calibre1">Done shortCoroutine 1!</strong><br class="title-page-name"/><strong class="calibre1">Done shortCoroutine 2!</strong><br class="title-page-name"/><strong class="calibre1">Done shortCoroutine 3!</strong><br class="title-page-name"/><strong class="calibre1">Done shortCoroutine 5!</strong><br class="title-page-name"/><strong class="calibre1">Done shortCoroutine 6!</strong><br class="title-page-name"/><strong class="calibre1">Done shortCoroutine 7!</strong><br class="title-page-name"/><strong class="calibre1">Done shortCoroutine 8!</strong><br class="title-page-name"/><strong class="calibre1">Done shortCoroutine 9!</strong><br class="title-page-name"/><strong class="calibre1">Done shortCoroutine 4!</strong><br class="title-page-name"/><strong class="calibre1">Done longCoroutine 4 &lt;= That makes more sense</strong><br class="title-page-name"/><strong class="calibre1">Done longCoroutine 2</strong><br class="title-page-name"/><strong class="calibre1">Done longCoroutine 3</strong><br class="title-page-name"/><strong class="calibre1">Done longCoroutine 9</strong><br class="title-page-name"/><strong class="calibre1">Done longCoroutine 5</strong><br class="title-page-name"/><strong class="calibre1">Done longCoroutine 1</strong><br class="title-page-name"/><strong class="calibre1">Done longCoroutine 10</strong><br class="title-page-name"/><strong class="calibre1">Done longCoroutine 6</strong><br class="title-page-name"/><strong class="calibre1">Done longCoroutine 7</strong><br class="title-page-name"/><strong class="calibre1">Done longCoroutine 8</strong></pre>
<p class="calibre2">Now let's understand what actually happened. We used a new function: <kbd class="calibre13">yield()</kbd>. We could have called <kbd class="calibre13">yield()</kbd> on every loop iteration, but decided to do that every 100th one. It <em class="calibre14">asks</em> the pool whether there is anybody else that wants to do some work. If there's nobody else, the execution of the current coroutine will resume. Otherwise, another coroutine will start or resume from the point where it stopped earlier.</p>
<p class="calibre2">Note that without the <kbd class="calibre13">suspend</kbd> keyword on our function or a coroutine generator, such as <kbd class="calibre13">launch()</kbd>, we can't call <kbd class="calibre13">yield()</kbd>. That's true for any function marked with <kbd class="calibre13">suspend</kbd>: it should be called either from another <kbd class="calibre13">suspend</kbd> function or from a coroutine.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Waiting for a coroutine</h1>
                
            
            
                
<p class="calibre2">Up until now, to let our asynchronous code complete, we've used either <kbd class="calibre13">Thread.sleep()</kbd> or <kbd class="calibre13">CountDownLatch</kbd>. But there are better options with threads and coroutines. Much like Thread, a job has the <kbd class="calibre13">join()</kbd> function. By invoking it, we can wait for the execution of the coroutine to complete.</p>
<p class="calibre2">Take a look at the following code:</p>
<pre class="calibre18">val j = launch(CommonPool) {<br class="title-page-name"/>    for (i in 1..10_000) {<br class="title-page-name"/>        if (i % 1000 == 0) {<br class="title-page-name"/>            println(i)<br class="title-page-name"/>            yield()<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Although it should have printed 10 lines, it doesn't print anything, actually. That's because our main thread terminates before giving a coroutine a chance to start.</p>
<p class="calibre2">By adding the following lines, our example will print the expected results:</p>
<pre class="calibre18">runBlocking {<br class="title-page-name"/>    j.<strong class="calibre1">join()</strong><br class="title-page-name"/>}</pre>
<p class="calibre2">What about this <kbd class="calibre13">runBlocking</kbd>, you ask? Remember that we could call <kbd class="calibre13">yield()</kbd> only from another coroutine because it's a <em class="calibre14">suspending function</em>? The same is true for <kbd class="calibre13">join()</kbd>. Since our main method is not a coroutine, we need to have a <strong class="calibre5">bridge</strong> between our regular code, that is not a suspending function and coroutines. This function does exactly that.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Canceling a coroutine</h1>
                
            
            
                
<p class="calibre2">If you are a Java developer, you may know that stopping a thread is quite complicated.</p>
<p class="calibre2">For example, the <kbd class="calibre13">Thread.stop()</kbd> method is deprecated. There's <kbd class="calibre13">Thread.interrupt()</kbd>, but not all threads are checking this flag, not to mention setting your own <kbd class="calibre13">volatile</kbd> flag, which is often suggested but is very cumbersome.</p>
<p class="calibre2">If you're using a thread pool, you'll get <kbd class="calibre13">Future</kbd>, which has the <kbd class="calibre13">cancel(boolean mayInterruptIfRunning)</kbd> method. In Kotlin, the <kbd class="calibre13">launch()</kbd> function returns a job.</p>
<p class="calibre2">This job can be canceled. The same rules as the previous example apply, though. If your coroutine never calls another <kbd class="calibre13">suspend</kbd> method or yields, it will disregard <kbd class="calibre13">cancel()</kbd>.</p>
<p class="calibre2">To demonstrate that, we'll create one <em class="calibre14">nice</em> coroutine that yields once in a while:</p>
<pre class="calibre18">val cancellable = launch {<br class="title-page-name"/>    try {<br class="title-page-name"/>        for (i in 1..1000) {<br class="title-page-name"/>            println("Cancellable: $i")<br class="title-page-name"/>            computeNthFibonacci(i)<br class="title-page-name"/>            yield()<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>    catch (e: CancellationException) {<br class="title-page-name"/>        e.printStackTrace()<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">And another one that doesn't yield:</p>
<pre class="calibre18">val notCancellable = launch {<br class="title-page-name"/>    for (i in 1..1000) {<br class="title-page-name"/>        println("Not cancellable $i")<br class="title-page-name"/>        computeNthFibonacci(i)<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">We'll try to cancel both:</p>
<pre class="calibre18">println("Canceling cancellable")<br class="title-page-name"/>cancellable.cancel()<br class="title-page-name"/>println("Canceling not cancellable")<br class="title-page-name"/>notCancellable.cancel()</pre>
<p class="calibre2">And wait for the results:</p>
<pre class="calibre18">runBlocking {<br class="title-page-name"/>    cancellable.join()<br class="title-page-name"/>    notCancellable.join()<br class="title-page-name"/>}</pre>
<p class="calibre2">A few interesting points:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Canceling the <em class="calibre25">nice</em> coroutine doesn't happen immediately. It may still print a line or two before getting canceled.</li>
<li value="2" class="calibre12">We can catch <kbd class="calibre13">CancellationException</kbd>, but our coroutine will be marked as canceled anyway. </li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Returning results</h1>
                
            
            
                
<p class="calibre2">Calling <kbd class="calibre13">launch()</kbd> is much like calling a function that returns <kbd class="calibre13">Unit</kbd>. But most of our functions return some kind of result. For that purpose, we have the <kbd class="calibre13">async()</kbd> function. It also launches a coroutine, but instead of returning a job, it returns <kbd class="calibre13">Deferred&lt;T&gt;</kbd>, where <kbd class="calibre13">T</kbd> is the type you expect to get later.</p>
<p class="calibre2">Think of a situation where you would like to fetch the user's profile from one source and their history from another. It may be two DB queries, or a network call to two remote services, or any combination. </p>
<p class="calibre2">You must show both the profile and the history, but you don't know which returns first. Usually, retrieving the profile is faster. But sometimes there may be a delay, since profiles are updated often and the history will return first.</p>
<p class="calibre2">We run one coroutine that will return the user's profile string in our case:</p>
<pre class="calibre18">val userProfile = async {<br class="title-page-name"/>    delay(Random().nextInt(100))<br class="title-page-name"/>    "Profile"<br class="title-page-name"/>}</pre>
<p class="calibre2">We'll run another to return the history. For simplicity, we'll just return a list of Ints:</p>
<pre class="calibre18">val userHistory = async {<br class="title-page-name"/>    delay(Random().nextInt(200))<br class="title-page-name"/>    listOf(1, 2, 3)<br class="title-page-name"/>}</pre>
<p class="calibre2">To wait for the results, we use the <kbd class="calibre13">await()</kbd> function:</p>
<pre class="calibre18">runBlocking {<br class="title-page-name"/>    println("User profile is ${userProfile.<strong class="calibre1">await(</strong><strong class="calibre1">)</strong>} and his history is ${userHistory.await()}")<br class="title-page-name"/>}<br class="title-page-name"/></pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Setting timeouts</h1>
                
            
            
                
<p class="calibre2">What if, as happens in some cases, fetching the user's profile takes too long? What if we decided that if the profile takes more than 0.5 seconds to return, we'll just show <em class="calibre14">no profile</em>?</p>
<p class="calibre2">This can be achieved using the <kbd class="calibre13">withTimeout()</kbd> function:</p>
<pre class="calibre18"> val coroutine = async {<br class="title-page-name"/>    <strong class="calibre1">withTimeout</strong>(500, TimeUnit.MILLISECONDS) {<br class="title-page-name"/>        try {<br class="title-page-name"/>            val time = Random().nextInt(1000)<br class="title-page-name"/><br class="title-page-name"/>            println("It will take me $time to do")<br class="title-page-name"/><br class="title-page-name"/>            delay(time)<br class="title-page-name"/><br class="title-page-name"/>            println("Returning profile")<br class="title-page-name"/>            "Profile"<br class="title-page-name"/>        }<br class="title-page-name"/>        catch (e: TimeoutCancellationException) {<br class="title-page-name"/>            e.printStackTrace()<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">We set the timeout to be 500 milliseconds, and our coroutine will delay for between 0 and 1,000 milliseconds, giving it a 50 percent chance to fail.</p>
<p class="calibre2">We'll await results from the coroutine and see what happens:</p>
<pre class="calibre18">val result = try {<br class="title-page-name"/>    coroutine.await()<br class="title-page-name"/>}<br class="title-page-name"/>catch (e: TimeoutCancellationException) {<br class="title-page-name"/>    "No Profile"<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>println(result)</pre>
<p class="calibre2">Here we benefit from the fact that <kbd class="calibre13">try</kbd> is an expression in Kotlin. So we can return a result immediately from it.</p>
<p class="calibre2">If the coroutine manages to return before the timeout, the value of <kbd class="calibre13">result</kbd> becomes <em class="calibre14">profile</em>. Otherwise, we receive <kbd class="calibre13">TimeoutCancellationException</kbd>, and set the value of <kbd class="calibre13">result</kbd> to <em class="calibre14">no profile</em>. </p>
<p class="calibre2">The interesting part is that our coroutine always receives <kbd class="calibre13">TimeoutCancellationException</kbd>, which we can handle. And in case of a timeout, <em class="calibre14">returning profile</em> will never be printed. </p>
<p class="calibre2">A combination of timeouts and try-catch expressions is a really powerful tool that allows us to create robust interactions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Parent jobs</h1>
                
            
            
                
<p class="calibre2">What if we want to cancel more than one coroutine at the same time? That's where parent jobs come into play. Remember that <kbd class="calibre13">launch()</kbd> receives <kbd class="calibre13">CoroutineContext</kbd>, that's usually <kbd class="calibre13">CommonPool</kbd>? It can also receive other parameters, which will see shortly.</p>
<p class="calibre2">We'll start with a suspending function that works for some time:</p>
<pre class="calibre18">suspend fun produceBeautifulUuid(): String {<br class="title-page-name"/>    try {<br class="title-page-name"/>        val uuids = List(1000) {<br class="title-page-name"/>            yield()<br class="title-page-name"/>            UUID.randomUUID()<br class="title-page-name"/>        }<br class="title-page-name"/><br class="title-page-name"/>        println("Coroutine done")<br class="title-page-name"/>        return uuids.sorted().first().toString()<br class="title-page-name"/>    } catch (t: CancellationException) {<br class="title-page-name"/>        println("Got cancelled")<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    return ""<br class="title-page-name"/>}</pre>
<p class="calibre2">We would like to launch 10 of these and cancel them after only 100 ms.</p>
<p class="calibre2">For that, we'll use a parent job:</p>
<pre class="calibre18"><strong class="calibre1">val parentJob = Job()</strong><br class="title-page-name"/><br class="title-page-name"/>List(10) {<br class="title-page-name"/>    <strong class="calibre1">async(CommonPool + parentJob)</strong> {<br class="title-page-name"/>        produceBeautifulUuid()<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>delay(100)<br class="title-page-name"/>parentJob.cancel()<br class="title-page-name"/>delay(1000) // Wait some more time</pre>
<p class="calibre2">As you can see, a parent job is simply a job. We pass it to the <kbd class="calibre13">async()</kbd> function. We can use the <kbd class="calibre13">+</kbd> sign due to the fact that <kbd class="calibre13">CoroutineContext</kbd> has overloaded the <kbd class="calibre13">plus()</kbd> function. You can also specify it using named arguments: </p>
<pre class="calibre18">async(CommonPool, <strong class="calibre1">parent= parentJob</strong>)</pre>
<p class="calibre2">Once we invoke <kbd class="calibre13">cancel()</kbd> on parent job, all of its children are canceled too.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Channels</h1>
                
            
            
                
<p class="calibre2">Up until now, we learned how to spawn coroutines and control them. But what if two coroutines need to communicate with each other?</p>
<p class="calibre2">In Java, threads communicate either by using the <kbd class="calibre13">wait()</kbd>/<kbd class="calibre13">notify()</kbd>/<kbd class="calibre13">notifyAll()</kbd> pattern or by using one of the rich set of classes from the java.util.concurrent package. For example: <kbd class="calibre13">BlockingQueue</kbd> or <kbd class="calibre13">Exchanger</kbd>.</p>
<p class="calibre2">In Kotlin, as you may have noticed, there are no <kbd class="calibre13">wait()</kbd>/<kbd class="calibre13">notify()</kbd> methods. But there are channels, which are very similar to <kbd class="calibre13">BlockingQueue</kbd>. But instead of blocking a thread, channels suspend a coroutine, which is a lot cheaper.</p>
<p class="calibre2">To understand channels better, let's create a simple game of two players that will throw random numbers at each other. If your number is greater, you win. Otherwise, you lose the round:</p>
<pre class="calibre18">fun player(name: String,<br class="title-page-name"/>           input: Channel&lt;Int&gt;,<br class="title-page-name"/>           output: Channel&lt;Int&gt;) = launch {<br class="title-page-name"/>    for (m in input) {<br class="title-page-name"/>        val d = Random().nextInt(100)<br class="title-page-name"/>        println("$name got $m, ${if (d &gt; m) "won" else "lost" }")<br class="title-page-name"/><br class="title-page-name"/>        delay(d)<br class="title-page-name"/>        output.<strong class="calibre1">send</strong>(d)<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Each player has two channels. One is used to receive data, the other to send it. </p>
<p class="calibre2">We can iterate over a channel with a regular for-loop, which will suspend until the next value is received.</p>
<p class="calibre2">When we want to send our results to the other player, we simply use the <kbd class="calibre13">send()</kbd> method.</p>
<p class="calibre2">Now let's play this game for one second:</p>
<pre class="calibre18">fun main(vararg args: String) {<br class="title-page-name"/>    val p1p2 = Channel&lt;Int&gt;()<br class="title-page-name"/>    val p2p1 = Channel&lt;Int&gt;()<br class="title-page-name"/><br class="title-page-name"/>    val player1 = player("Player 1", p2p1, p1p2)<br class="title-page-name"/>    val player2 = player("Player 2", p1p2, p2p1)<br class="title-page-name"/><br class="title-page-name"/>    runBlocking {<br class="title-page-name"/>        p2p1.send(0)<br class="title-page-name"/>        delay(1000)<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Our output may look something like this:</p>
<pre class="calibre18"><strong class="calibre1">...</strong><br class="title-page-name"/><strong class="calibre1">Player 1 got 62, won</strong><br class="title-page-name"/><strong class="calibre1">Player 2 got 65, lost</strong><br class="title-page-name"/><strong class="calibre1">Player 1 got 29, lost</strong><br class="title-page-name"/><strong class="calibre1">Player 2 got 9, won</strong><br class="title-page-name"/><strong class="calibre1">Player 1 got 46, won</strong><br class="title-page-name"/><strong class="calibre1">Player 2 got 82, lost</strong><br class="title-page-name"/><strong class="calibre1">Player 1 got 81, lost</strong><br class="title-page-name"/><strong class="calibre1">...</strong></pre>
<p class="calibre2">As you can see, channels are a convenient and type-safe way to communicate between different coroutines. But we had to define the channels manually, and pass them in the correct order. In the next two sections, we'll see how this can be further simplified.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Producers</h1>
                
            
            
                
<p class="calibre2">In <a href="part0176.html#57R300-6704093aa34748cfa77c54bdc1a20dc7" class="calibre10">Chapter 7</a>, <em class="calibre14">Staying Reactive</em>, which was dedicated to reactive programming, we discussed <kbd class="calibre13">Observable</kbd> and <kbd class="calibre13">subject</kbd> that were producing streams of values. Much in the same way, Kotlin provides us with the <kbd class="calibre13">produce()</kbd> function. </p>
<p class="calibre2">This function creates coroutine is backed up by <kbd class="calibre13">ReceiveChannel&lt;T&gt;</kbd>, where <kbd class="calibre13">T</kbd> is the type the coroutine produces:</p>
<pre class="calibre18">val publisher: <strong class="calibre1">ReceiveChannel</strong>&lt;Int&gt; = <strong class="calibre1">produce</strong> {<br class="title-page-name"/>        for (i in 2018 downTo 1970) { // Years back to Unix<br class="title-page-name"/>            <strong class="calibre1">send</strong>(i)<br class="title-page-name"/>            delay(20)<br class="title-page-name"/>        }<br class="title-page-name"/>}</pre>
<p class="calibre2">In Rx there's the <kbd class="calibre13">onNext()</kbd> method that we covered in <a href="part0176.html#57R300-6704093aa34748cfa77c54bdc1a20dc7" class="calibre10">Chapter 7</a>, <em class="calibre14">Staying Reactive</em>.</p>
<p class="calibre2">Producers have a  <kbd class="calibre13">send()</kbd> function, which is very similar.</p>
<p class="calibre2">Much like the Rx <kbd class="calibre13">Observable</kbd> that provided the <kbd class="calibre13">subscribe()</kbd> method, this channel, has the <kbd class="calibre13">consumeEach()</kbd> function:</p>
<pre class="calibre18">publisher.consumeEach {<br class="title-page-name"/>    println("Got $it")<br class="title-page-name"/>}</pre>
<p class="calibre2">It prints the following:</p>
<pre class="calibre18"><strong class="calibre1">Got 35</strong><br class="title-page-name"/><strong class="calibre1">Got 34</strong><br class="title-page-name"/><strong class="calibre1">Got 33</strong><br class="title-page-name"/><strong class="calibre1">Got 32</strong><br class="title-page-name"/><strong class="calibre1">Got 31</strong><br class="title-page-name"/><strong class="calibre1">Got 30</strong><br class="title-page-name"/><strong class="calibre1">Got 29</strong></pre>
<p class="calibre2">Another great ability that channels provide is <kbd class="calibre13">select()</kbd>.</p>
<p class="calibre2">If we have more than one producer, we can <kbd class="calibre13">subscribe</kbd> to their channels, and take the first result available:</p>
<pre class="calibre18">val firstProducer = produce&lt;String&gt; {<br class="title-page-name"/>    delay(Random().nextInt(100))<br class="title-page-name"/>    send("First")<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>val secondProducer = produce&lt;String&gt; {<br class="title-page-name"/>    delay(Random().nextInt(100))<br class="title-page-name"/>    send("Second")<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>val winner = select&lt;String&gt; {<br class="title-page-name"/>    firstProducer.onReceive {<br class="title-page-name"/>        it.toLowerCase()<br class="title-page-name"/>    }<br class="title-page-name"/>    secondProducer.onReceive {<br class="title-page-name"/>        it.toUpperCase()<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>println(winner)</pre>
<p class="calibre2">This will randomly print <kbd class="calibre13">First</kbd> or <kbd class="calibre13">Second</kbd>.</p>
<p class="calibre2">Note that <kbd class="calibre13">select()</kbd> happens only once. A common mistake is to have select on two coroutines that produce a stream of data, without wrapping it in a loop:</p>
<pre class="calibre18">// Producer 1<br class="title-page-name"/>val firstProducer = produce {<br class="title-page-name"/>    for (c in 'a'..'z') {<br class="title-page-name"/>        delay(Random().nextInt(100))<br class="title-page-name"/>        send(c.toString())<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Producer 2<br class="title-page-name"/>val secondProducer = produce {<br class="title-page-name"/>    for (c in 'A'..'Z') {<br class="title-page-name"/>        delay(Random().nextInt(100))<br class="title-page-name"/>        send(c.toString())<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Receiver<br class="title-page-name"/>println(select&lt;String&gt; {<br class="title-page-name"/>    firstProducer.onReceive {<br class="title-page-name"/>        it<br class="title-page-name"/>    }<br class="title-page-name"/>    secondProducer.onReceive {<br class="title-page-name"/>        it<br class="title-page-name"/>    }<br class="title-page-name"/>})</pre>
<p class="calibre2">Instead of printing the alphabet, this will only print either "a" or "A," and then exit. Make sure your <kbd class="calibre13">select()</kbd> is wrapped in a loop.</p>
<p class="calibre2">This will print the first 10 characters it receives:</p>
<pre class="calibre18">// Receiver<br class="title-page-name"/>for (i in 1..10) {<br class="title-page-name"/>    println(select&lt;String&gt; {<br class="title-page-name"/>        firstProducer.onReceive {<br class="title-page-name"/>            it<br class="title-page-name"/>        }<br class="title-page-name"/>        secondProducer.onReceive {<br class="title-page-name"/>            it<br class="title-page-name"/>        }<br class="title-page-name"/>    })<br class="title-page-name"/>}</pre>
<p class="calibre2">Another option is to signal using the <kbd class="calibre13">close()</kbd> function:</p>
<pre class="calibre18">// Producer 2<br class="title-page-name"/>val secondProducer = produce {<br class="title-page-name"/>    for (c in 'A'..'Z') {<br class="title-page-name"/>        delay(Random().nextInt(100))<br class="title-page-name"/>        send(c.toString())<br class="title-page-name"/>    }<br class="title-page-name"/>    <strong class="calibre1">close()</strong><br class="title-page-name"/>}</pre>
<p class="calibre2">And use <kbd class="calibre13">onReceiveOrNull()</kbd> inside the receiver:</p>
<pre class="calibre18">// Receiver<br class="title-page-name"/>while(true) {<br class="title-page-name"/>    val result = select&lt;String?&gt; {<br class="title-page-name"/>        firstProducer.<strong class="calibre1">onReceiveOrNull</strong> {<br class="title-page-name"/>            it<br class="title-page-name"/>        }<br class="title-page-name"/>        secondProducer.<strong class="calibre1">onReceiveOrNull</strong> {<br class="title-page-name"/>            it<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    if (result == null) {<br class="title-page-name"/>        break<br class="title-page-name"/>    }<br class="title-page-name"/>    else {</pre>
<pre class="calibre18">        println(result)<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">This option will print characters until the first of the producers decide to close the channel.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Actors</h1>
                
            
            
                
<p class="calibre2">The last <em class="calibre14">building block</em> introduced in this chapter is actors. Similar to <kbd class="calibre13">producer()</kbd>, <kbd class="calibre13">actor()</kbd> is a coroutine bound to a channel. But instead of a channel going <em class="calibre14">out</em> of the coroutine, there's a channel going <em class="calibre14">into</em> the coroutine. If you think that was too academic, read on for another explanation.</p>
<p class="calibre2">So what is an actor, anyway? Let's look at an interaction between Michael and me, an imaginary product manager, who happens to be a canary, as you may remember from <a href="part0112.html#3APV00-6704093aa34748cfa77c54bdc1a20dc7" class="calibre10">Chapter 4</a>, <em class="calibre14">Getting Familiar with Behavioral Patterns</em>. Michael has a list of tasks that need to be completed before the end of the sprint/week/month. And he simply throws them at me, in the hope that I'll do my magic and translate some vague specifications into a working code. He's not waiting for my response. He just expects that eventually, it will happen—and sooner rather than later. For Michael, I'm an actor. Not because I attended an acting school, but because I act upon his request.</p>
<p class="calibre2">If you've worked with Scala, or some other programming language that has actors, you may be familiar with a slightly different actor model from what we've described. In some implementations, actors have both inbound and outbound channels (often called mailboxes). But it Kotlin, an actor has only an inbound mailbox.</p>
<p class="calibre2">To create a new actor, we use the <kbd class="calibre13">actor()</kbd> function:</p>
<pre class="calibre18">data class Task (val description: String)<br class="title-page-name"/>val me = actor&lt;Task&gt; {<br class="title-page-name"/>    while (!<strong class="calibre1">isClosedForReceive</strong>) {<br class="title-page-name"/>        println(receive().description.repeat(10))<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Note that the same way that <kbd class="calibre13">select()</kbd> works, unless we wrap an actor's <kbd class="calibre13">receive()</kbd> into some kind of loop, it will execute only once. If you'll attempt to send it to a closed channel, you get <kbd class="calibre13">ClosedSendChannelException</kbd>.</p>
<p class="calibre2">You communicate with actors using <kbd class="calibre13">send()</kbd>:</p>
<pre class="calibre18">// Imagine this is Michael the PM<br class="title-page-name"/>fun michael(actor: SendChannel&lt;Task&gt;) {<br class="title-page-name"/>    <br class="title-page-name"/>    runBlocking {<br class="title-page-name"/>        // He has some range of tasks<br class="title-page-name"/>        for (i in 'a'..'z') {<br class="title-page-name"/>            // That he's sending to me<br class="title-page-name"/>            actor.send(Task(i.toString()))<br class="title-page-name"/>        }<br class="title-page-name"/>        // And when he's done with the list, he let's me know<br class="title-page-name"/>        actor.close()<br class="title-page-name"/>        // That doesn't mean I'm done working on it, though<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// And he's calling me<br class="title-page-name"/>michael(me)</pre>
<p class="calibre2">Another pattern for an actor is to use the <kbd class="calibre13">receiveOrNull()</kbd> function:</p>
<pre class="calibre18">val meAgain = actor&lt;Task&gt; {<br class="title-page-name"/>    var next = <strong class="calibre1">receiveOrNull</strong>()<br class="title-page-name"/><br class="title-page-name"/>    while (next != null) {<br class="title-page-name"/>        println(next.description.toUpperCase())<br class="title-page-name"/>        next = <strong class="calibre1">receiveOrNull</strong>()<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Michael still can call me in the same manner<br class="title-page-name"/>michael(meAgain)<br class="title-page-name"/></pre>
<p class="calibre2">As you can see, instead of checking whether the actor's channel has been closed, our cue is receiving null on the channel. This approach may be preferable, if the actor receives tasks from many <em class="calibre14">managers</em>.</p>
<p class="calibre2">The third option, which is the most preferable one usually, is to iterate over the channel:</p>
<pre class="calibre18">val meWithRange = actor&lt;Task&gt; {<br class="title-page-name"/>    for (t in channel) {<br class="title-page-name"/>        println(t.description)<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    println("Done everything")</pre>
<pre class="calibre18">}<br class="title-page-name"/><br class="title-page-name"/>michael(meWithRange)</pre>
<p class="calibre2">As you can see, this is the cleanest implementation of the three.</p>
<p class="calibre2">Actors are a very useful for background tasks that need to maintain some kind of state. For example, you could create an actor that would generate reports. It will receive what kind of report to generate, and will make sure that only one report is generated at the same time:</p>
<pre class="calibre18">data class ReportRequest(val name: String,<br class="title-page-name"/>                                 val from: LocalDate,<br class="title-page-name"/>                                 val to: LocalDate)<br class="title-page-name"/>val reportsActor = actor&lt;ReportRequest&gt;(<strong class="calibre1">capacity=100</strong>) {<br class="title-page-name"/>    for (req in this) {<br class="title-page-name"/>        generateReport(req)<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">It is often a good idea to limit the capacity of messages the actor can receive.</p>
<p class="calibre2">Then we can send this actor what type of report to produce:</p>
<pre class="calibre18">reportsActor.send(ReportRequest("Monthly Report",<br class="title-page-name"/>        LocalDate.of(2018, 1, 1),<br class="title-page-name"/>        LocalDate.of(2018, 1, 31)))</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre2">In this chapter, we covered how to create threads and coroutines in Kotlin, and the benefits of coroutines.</p>
<p class="calibre2">Kotlin has simplified syntax for creating threads, compared to Java. But they still have the overhead of memory and often performance. Coroutines are able to solve these issues; use coroutines whenever you need to execute some code concurrently.</p>
<p class="calibre2">If you want to communicate between two coroutines, use channels.</p>
<p class="calibre2">Kotlin also offers actors with the <kbd class="calibre13">actor()</kbd> function, which also spins a coroutine that has an inbound stream attached to it to process events. And if you need to create a stream of values, you can use the <kbd class="calibre13">produce()</kbd> function.</p>
<p class="calibre2">In the next chapter, we'll discuss how we can use these concurrency primitives to create scalable and robust systems that suit our needs.</p>


            

            
        
    </body></html>