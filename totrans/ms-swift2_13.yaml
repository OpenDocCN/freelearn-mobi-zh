- en: Chapter 13. Using Mix and Match
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When Apple first introduced Swift at WWDC 2014, my first thought was how much
    work it would be for developers to rewrite their apps, which were already written
    in Objective-C, in Swift. I also wondered why a developer would rewrite their
    apps in Swift. A lot of these applications are pretty complex and would take a
    pretty large effort to rewrite them. Somewhere in the Swift presentation, Apple
    spoke about mix and match, which allows Swift and Objective-C to interact within
    the same project. Mix and match sure sounded like an ideal solution because developers
    could rewrite sections of their code in Swift as they needed to do updates, instead
    of having to rewrite their whole application. My big question was how well mix
    and match would actually work, and I was very surprised; not only does it work
    well but it is also easy to implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is mix and match
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use Swift and Objective-C together in the same project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to add Swift to an Objective-C project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use Objective-C in a Swift project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is mix and match
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swift's compatibility with Objective-C allows us to create a project in either
    language and include files written in the other language. This feature is called
    **mix and match**. It was arguably one of the most important features that came
    out with Swift.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why this feature is so important is that there are, well, over a
    million apps written in Objective-C in Apple's App Store, and it would not be
    feasible for developers to spend the resources required for converting those apps
    from Objective-C to Swift. Without mix and match, the adaptation of the Swift
    language would be very slow. With mix and match, developers can begin to use Swift
    in their present apps that are written in Objective-C without having to convert
    the entire code base to Swift.
  prefs: []
  type: TYPE_NORMAL
- en: With mix and match, we can update our current Objective-C project using Swift.
    We can also use any framework written in Objective-C within our Swift projects
    and use newer frameworks written in Swift in our Objective-C projects.
  prefs: []
  type: TYPE_NORMAL
- en: For developers that have been using Apple products for a long time, they might
    find a similarity between mix and match and Rosetta, which Apple started including
    with OS X 10.4.4 Tiger. OS X 10.4.4 was the first version of Apple's operating
    system that was released with Apple's first Intel-based machines. Rosetta was
    written to allow many PowerPC applications to run seamlessly on the new Intel-based
    machines.
  prefs: []
  type: TYPE_NORMAL
- en: For those developers who are new to Apple products, you might not have heard
    of Rosetta. This is because Rosetta was not included or supported as of OS X 10.7
    Lion. The reason this is mentioned is because if mix and match takes a similar
    path as Rosetta, it might not be a part of the language forever and from what
    Apple has said, Swift is the future. It also makes sense from a technological
    standpoint that as the Swift language evolves and matures, Apple will not want
    to maintain compatibility with Objective-C.
  prefs: []
  type: TYPE_NORMAL
- en: If you maintain legacy apps written in Objective-C, it might be a good idea
    to take advantage of mix and match to slowly upgrade your code base to Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how Swift and Objective-C can interact together. For this, we
    will be creating a very basic iOS project whose language will be Objective-C,
    and then we will add some Swift code for the project to use. In the downloadable
    code for this book, we have included an Objective-C project that consists of Swift
    code and a Swift project that includes Objective-C code. One thing to keep in
    mind is that it does not matter if our project is an Objective-C or a Swift project;
    interaction between Swift and Objective-C works the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Using Swift and Objective-C together in the same project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be walking through how to add Swift to an Objective-C
    project. The same steps can also be used to add the Objective-C code to a Swift
    project. In the downloadable code for this book, you will find both Objective-C
    and Swift projects. These projects demonstrate how to add the Swift code to an
    Objective-C project and how to add Objective-C code to a Swift project. In those
    projects, we can see that mix and match functions exactly the same, no matter
    what type of project we are using.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s begin by creating an iOS project to work with. When we first start Xcode,
    we should see a screen that looks similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the project](img/B05115_13_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From this menu, we will want to select the **Create a new Xcode project** option.
    This option will walk us though creating a new Xcode project. Once this option
    is selected, Xcode will start up and we will see the following menu. As a shortcut,
    if we do not see this menu, we can also navigate to **File** | **New** | **Project**
    in the top menu bar, which will display the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the project](img/B05115_13_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This menu lets us select the type of project we will be creating and also what
    platform we are targeting (iOS or OS X). For this example, we will be targeting
    the iOS platform and creating a simple Single View Application. Once we make our
    selection, we should see the following menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the project](img/B05115_13_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On this menu, we will define several properties about our project. The two properties
    we need to focus on are the language of the project and product name. For this
    particular project, we will select Objective-C as the language and name it `ObjectiveCProject`.
    Once we have all of the properties defined, we can click on the **Next** button.
    On the last menu, we select where we wish to save the project files, and once
    we have done that, Xcode creates the project template files for us, and we can
    begin.
  prefs: []
  type: TYPE_NORMAL
- en: The application that we will be creating will let the user enter a name and
    will then respond with a personal message to them. The user interface will consist
    of a `UITextField` field that the user can enter their name into, a `UIButton`
    that the user will press after they have entered their name, and a `UITextView`
    that will display the personalized message. Since this book is about Swift programming,
    we will not go into how the user interface is laid out. Full working applications
    are available as part of the book's downloadable source code.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are walking through the Objective-C project, the user interface and
    the `Messages` class, which will generate a message, will be written in Objective-C.
    The message builder, which will personalize the message, will be written in Swift.
    This will show us how to access a Swift class from the Objective-C code as well
    as Objective-C resources from our Swift code within an Objective-C project.
  prefs: []
  type: TYPE_NORMAL
- en: Let's summarize the Objective-C to Swift interaction. The backend for the user
    interface, which is written in Objective-C, will call the `getPersonalizedMessage()`
    method of the `MessageBuilder` class written in Swift. The `getPersonalizedMessage()`
    method of the `MessageBuilder` class will call the `getMessage()` function of
    the `Messages` class written in Objective-C.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Swift file to the Objective-C project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s begin by creating the Swift `MessageBuilder` class. This class will
    be used to build the personalized message for the user. Within Objective-C projects,
    I usually create a separate group called `SwiftFiles` to hold the Swift files
    in. This allows me to very easily see what files are written in Swift and what
    are written in Objective-C. To add a Swift file to our project, right-click on
    the group icon that we want to add the file to and we should see the following
    menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding Swift file to the Objective-C project](img/B05115_13_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From this menu, select the **New File…** option. This option will walk us through
    creating a new file for our project. Once you select that option, you should see
    the following menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding Swift file to the Objective-C project](img/B05115_13_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This menu lets us choose what type of file we will be adding to our project.
    In this case, we will want to add a Swift file to our project; therefore, we will
    select the **Swift File** option. Once we select this option, we should see the
    following menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding Swift file to the Objective-C project](img/B05115_13_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This menu lets us name the file and define some of the properties, such as
    where we will save the file and what group it will be in. In this case, we name
    the file `MessageBuilder`. Once we have finished, we will click on the **Create**
    button. If this is the first Swift file added to an Objective-C project (or the
    first Objective-C file added to a Swift project), we should see the following
    menu pop up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding Swift file to the Objective-C project](img/B05115_13_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This popup offers to create the bridging header file for use. Select **Create
    Bridging Header** to create the file.
  prefs: []
  type: TYPE_NORMAL
- en: The Objective-C bridging header file – part 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to expose our Objective-C files to our Swift code, we rely on an Objective-C
    header file. The first time we add an Objective-C file to a Swift project or a
    Swift file to an Objective-C project, Xcode offers to create this file for us.
    It is easier to let Xcode create and configure this file rather than doing it
    manually, so it is recommended to select **Yes** when Xcode offers to create it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If for some reason we need to create the Objective-C bridging header file manually,
    the following steps show how we would do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Objective-C header file in our project using the **New File…** option
    we saw earlier. The recommended naming convention for this file is `[MyProjectName]-Bridging-Header.h`,
    where `[MyProjectName]` is the name of our project. This will be the header file
    where we import any Objective-C header files for any Objective-C classes that
    we want our Swift code to access.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the project's **Build Settings**, find the **Swift Compiler – Code Generation**
    section. In this section, locate the setting, titled **Objective-C Bridging Header**.
    We will want to set this to the path for the bridging header we created in step
    1\. The path will be from the project root.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **Objective-C Bridging Header** setting for the present project that we
    are working on looks similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Objective-C bridging header file – part 1](img/B05115_13_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Even though the bridging header is located in the `SwiftFiles` group, we can
    see in the settings that the file itself is located at the root of the project.
    If we want to put the header file in another directory within the project, all
    we would need to do is change the path in this setting.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Objective-C file to the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have our Objective-C bridging header file and the `MessageBuilder`
    Swift file, let''s create the Objective-C class that will generate a generic message
    to the user. We will name this class `Messages`. To create this file, right-click
    on the group folder that we want to add the file to, and we should see the following
    menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the Objective-C file to the project](img/B05115_13_08a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From this menu, select the **New File…** option. This option will walk us through
    creating a new file for our project. Once you select that option, you should see
    the following menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the Objective-C file to the project](img/B05115_13_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Previously, when we added the `MessageBuilder` Swift file, we selected **Swift
    File** on this menu. This time, we will be adding an Objective-C file, so we will
    select the **Cocoa Touch Class** option. Once we select that option, we should
    see a screen similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the Objective-C file to the project](img/B05115_13_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On this menu, we can enter the class name and also the language for the class.
    Make sure that the language is set to Objective-C. Finally, we click on the **Next**
    button, which will take us to a menu that will let us select where we want to
    save our Objective-C files. Once we select the location to save our files, both
    the header and implementation files will be added to our project.
  prefs: []
  type: TYPE_NORMAL
- en: Now that all of our files have been created, let's begin writing our code and
    getting Swift and Objective-C to work together. We will begin by adding the code
    to the Objective-C **Messages** header and implementation files.
  prefs: []
  type: TYPE_NORMAL
- en: The Messages Objective-C class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Messages` Objective-C class will contain an array of messages and will
    expose one method named `getMessage`, which will return one randomly picked message
    from the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the `Messages` header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this header file, we expose one method named `getMessage` that will return
    a message when called. The following code shows the implementation file for the
    `Messages` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we created the `NSArray` object that contains a number of messages.
    We also created the `getMessage` method that randomly picks one of the messages
    from the `NSArray` object and returns it.
  prefs: []
  type: TYPE_NORMAL
- en: The `Messages` class that we just created in Objective-C will need to be accessed
    by the `MessageBuilder` class that we are going to write in Swift. To access an
    Objective-C class from the Swift code, we need to edit the `Objective-C Bridging
    Header` file.
  prefs: []
  type: TYPE_NORMAL
- en: The Objective-C bridging header file – part 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have created the `Messages` Objective-C class, we will need to
    expose it to our Swift code. Those who are familiar with Objective-C (or any C-based
    language), will know that we need to import the class header using the `#import`
    or `#include` directive, prior to using it within another class. In that same
    context, we need to import the header file of any Objective-C class, in the Objective-C
    header file, prior to using that class in our Swift code. Therefore, to allow
    our Swift code to access the `Messages` Objective-C class, we need to add the
    following line to the Objective-C bridging header file that Xcode created for
    us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Yep, that is it. Pretty simple. Now, let's look at how we would write the `MessageBuilder`
    Swift class that will use the `Messages` Objective-C class.
  prefs: []
  type: TYPE_NORMAL
- en: The MessageBuilder Swift class – accessing Objective-C code from Swift
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `MessageBuilder` Swift class will contain one method named `getPersonalizedMessage()`.
    This method will use the `getMessage()` method from the `Messages` Objective-C
    class to retrieve a message and will then customize that message prior to returning
    it to the function that called it. Here is the code for the `MessageBuiler` Swift
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When we define this class, we create it as a subclass of the `NSObject` class.
    If a Swift class will be accessed from the Objective-C code, that class needs
    to be a subclass of the `NSObject` class. If we forget to do this, we will receive
    the `Use of undeclared identifier'{Class Name}` error when we try to access the
    class in the Objective-C code.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at how we created an instance of the `Messages` Objective-C
    class in our Swift code. The following line creates the instances, `let messages
    = Messages()`. As we can see, we create the instance of the `Messages` Objective-C
    class, exactly as we would create an instance of any Swift class. We then access
    the `getMessages()` method of the `Messages` class like we would access a method
    of any Swift class.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from this code, Objective-C classes are both initiated and used
    as if they were written in Swift when we access them from a class written in Swift.
    This allows us to access our Objective-C and Swift types in a consistent way.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created the `MessageBuilder` Swift class, we need a way to
    call the `getPersonalizedMessage()` method, from the `ViewController` Objective-C
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The Objective-C class – accessing Swift code from Objective-C
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the user enters their name and presses the **Get Message** button, we will
    create an instance of the `MessageBuilder` Swift class, in Objective-C, and call
    the `getPersonlizedMessage()` method to generate the message to be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we access Swift code from Objective-C, we rely on an Xcode-generated header
    file to expose the Swift classes. This automatically generated header file declares
    the interface for the Swift classes. The name for this header file is the name
    of your project, followed by `–Swift.h`. So, the name of the header file for our
    project is `ObjectiveCProject-Swift.h`. Therefore, the first step to access the
    Swift code from Objective-C is to import this header file, as shown in the following
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have imported the header file to expose our Swift classes, we can
    use the `MessageBuilder` Swift class within the Objective-C code. We create an
    instance of the `MessageBuilder` Swift class exactly like we would create an instance
    of any standard Objective-C class. We also call the method and properties of a
    Swift class exactly like we would call the method and properties from an Objective-C
    class. The following example shows how we would create an instance of the `MessageBuilder`
    Swift class, and also how we would call the `getPersonalizedMessage()` method
    of that class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from this code sample, Swift classes are treated as if they were
    Objective-C classes when we access them from Objective-C. Once again, this allows
    us to access both our Objective-C and Swift types in a consistent manner.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in this chapter, Apple has made mix and match very easy and convenient
    to use. In order to access Swift classes from our Objective-C code, all we need
    to do is import the Xcode-generated header file that exposes the Swift classes.
    While we do not see this header file as part of our code, Xcode automatically
    creates it for mixed language projects. The name of this header file takes the
    format of `{Project Name}-Swift.h`, where `{Project Name}` is the name of our
    project.
  prefs: []
  type: TYPE_NORMAL
- en: It is also very easy to use Objective-C classes within our Swift code. To expose
    Objective-C classes to our Swift code, all we need to do is add the Objective-C
    header file to the Objective-C bridging header file. Xcode can create this bridging
    header file for us the first time we add an Objective-C file to a Swift project,
    or the first time we add a Swift file to an Objective-C project.
  prefs: []
  type: TYPE_NORMAL
- en: While Apple has said that the future of application development for iOS and
    OS X platforms is in Swift, mix and match can be used to slowly migrate our current
    Objective-C code base to Swift. Mix and match also lets us use Objective-C frameworks
    in our Swift projects or Swift frameworks in our Objective-C projects.
  prefs: []
  type: TYPE_NORMAL
