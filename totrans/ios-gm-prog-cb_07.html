<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;7.&#xA0;Adding Reality to Games"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07" class="calibre1"/>Chapter 7. Adding Reality to Games</h1></div></div></div><p class="calibre8">In this chapter, we will cover the following recipes:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Creating physics bodies in the world</li><li class="listitem">Physics joints</li><li class="listitem">Detecting contact and collisions</li></ul></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Adding Reality to Games">
<div class="book" title="Introduction"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch07lvl1sec39" class="calibre1"/>Introduction</h1></div></div></div><p class="calibre8">In the previous chapters, you learned about the anatomy of physics simulation in games. We have explored various sections of the Physics engine, including its integration with games and playing with the basics of the game engine. You have learned the ways to create static and dynamic bodies as well. Now, in this chapter, our major focus will be on adding some more reality to games by the advanced level of physics integration. This includes playing with lots of physics bodies tied together with joints. You will also learn the ways to detect the collision between two physics bodies. The overall agenda will be to create a mini game in the chapter, which will hold together all the recipes and will help in better understanding of these sections. The game will be divided into three the following parts:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Creating the game holding a physics world with some physics bodies</li><li class="listitem">Then we will move forward and join those physics bodies with various types of joints</li><li class="listitem">Then, finally, you will learn various ways to detect the collision and contact between the various physics bodies in the world</li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Creating physics bodies in the world"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec40" class="calibre1"/>Creating physics bodies in the world</h1></div></div></div><p class="calibre8">In this recipe, we <a id="id275" class="calibre1"/>will be creating a fresh game project and will set it up to be used in all the recipes. The game project will hold together the creation of a physics world along with some physics body objects. We will be using these physics objects to add joints between them.</p></div>

<div class="book" title="Creating physics bodies in the world">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec102" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">To develop a mini <a id="id276" class="calibre1"/>game using the physics engine, start by creating a new project. Open Xcode and go to <span class="strong"><strong class="calibre2">File</strong></span> | <span class="strong"><strong class="calibre2">New</strong></span> | <span class="strong"><strong class="calibre2">Project</strong></span> and navigate to <span class="strong"><strong class="calibre2">iOS</strong></span> | <span class="strong"><strong class="calibre2">Application</strong></span> | <span class="strong"><strong class="calibre2">SpriteKit Game</strong></span>. In the popup, provide the product name as <code class="email">Physics Joints</code> and navigate to <span class="strong"><strong class="calibre2">Devices</strong></span> | <span class="strong"><strong class="calibre2">iPhone</strong></span> and click on <span class="strong"><strong class="calibre2">Next</strong></span> as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00106.jpeg" alt="Getting ready" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Click on <span class="strong"><strong class="calibre2">Next</strong></span> and save the project on your hard drive.</p><p class="calibre8">Once the project is saved, you should be able to see project settings. In this project settings page, just uncheck the <span class="strong"><strong class="calibre2">Portrait</strong></span> from the <span class="strong"><strong class="calibre2">Device Orientation</strong></span> section as we are supporting only landscape mode for this game. The final screen should look something similar to following screenshot:</p><div class="mediaobject"><img src="../images/00107.jpeg" alt="Getting ready" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div class="book" title="Creating physics bodies in the world">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec103" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8">Now our project template<a id="id277" class="calibre1"/> is ready to hold together some advanced physics behaviors. To accommodate these behaviors, we also need to tweak some code in the project. Perform the following steps to update the project as per our requirements:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Open the <code class="email">GameScene.m</code> file available with the code bundle of this chapter; this class creates a scene that will be plugged into the game. Remove all the code from this class and just add the following function:<div class="informalexample"><pre class="programlisting">-(id)initWithSize:(CGSize)size {
    if (self = [super initWithSize:size]) {
        self.backgroundColor = [SKColor colorWithRed:0.15 green:0.15 blue:0.3 alpha:1.0];
    }
    return self;
}</pre></div><p class="calibre15">This <code class="email">initWithSize</code> method creates an empty scene with specified size. The code written inside the <code class="email">init</code> function changes the background color of the scene. We can tweak the rgb to get the desired background color.</p></li><li class="listitem" value="2">Now<a id="id278" class="calibre1"/> open <code class="email">GameViewController.m</code>. Remove all the code from this file and add the following function:<div class="informalexample"><pre class="programlisting">-(void)viewWillLayoutSubviews {
    [super viewWillLayoutSubviews];
    
    // Configure the view.
    SKView * skView = (SKView *)self.view;
    if (!skView.scene) {
        skView.showsFPS = YES;
        skView.showsNodeCount = YES;
        
        // Create and configure the scene.
        GameScene * scene = [GameScene sceneWithSize:skView.bounds.size];
        scene.scaleMode = SKSceneScaleModeAspectFill;
        
        // Present the scene.
        [skView presentScene:scene];
    }
}</pre></div></li><li class="listitem" value="3">Now compile and run the app. You should be able to see the background color correctly. This will look something similar to following screenshot:<div class="mediaobject"><img src="../images/00108.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="4">Now we have the background color in place, so let's add the gravity to the world. Open <code class="email">GameScene.m</code> and add the following line of code in the end of the <code class="email">initWithSize</code> method:<div class="informalexample"><pre class="programlisting">self.physicsWorld.gravity = CGVectorMake(0.0f, -0.5f);</pre></div><p class="calibre15">This line of code will set the gravity of the world to -0.5, which means all the physics objects will experience a force towards the ground in the game scene.</p></li><li class="listitem" value="5">Now we have <a id="id279" class="calibre1"/>applied some gravitational force to make the objects pulled towards the ground. So it's important to make some boundary to the world, which will hold all the objects of the world and prevent them from going off the screen. Add the following line of code to add the invisible boundary around the screen to hold the physics objects:<div class="informalexample"><pre class="programlisting">self.PhysicsBody = [SKPhysicsBody bodyWithEdgeLoopFromRect:self.frame];
self.physicsBody.friction = 0.0f;</pre></div></li><li class="listitem" value="6">In the first line, we are creating an edge-based physics boundary object with a screen-size frame. This type of physics body does not have any mass or volume and they also remain unaffected by forces and impulses. Then we associate the object with the physics body of the scene. In the last line, we change the friction of the body to 0, to make interaction between objects and the boundary surface lossless.</li><li class="listitem" value="7">Now we are all set to create physics bodies in the world. Add the following method just after the <code class="email">initWithSize</code> method:<div class="informalexample"><pre class="programlisting">-(void)update:(CFTimeInterval)currentTime {
    /* Called before each frame is rendered */
}</pre></div><p class="calibre15">This is the update method that will be called in each frame of the game execution. So all the actions that need regular updates will be coded inside this method.</p></li><li class="listitem" value="8">It's time to create physics objects in the world. All the physics objects are referred to as bodies. Now add the following method to create the bodies in the physics world.<div class="informalexample"><pre class="programlisting">-(void)createPhysicsBodiesOnScene:(SKScene*)scene
{
    //Adding Rectangle
    SKSpriteNode* backBone = [[SKSpriteNode alloc] initWithColor:[UIColor whiteColor] size:CGSizeMake(20, 200)];
    backBone.position = CGPointMake(CGRectGetWidth(self.frame)/2.0, CGRectGetHeight(self.frame)/2.0);
    backBone.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:backBone.size];
    [scene addChild:backBone];
    
    
    //Adding Square
    SKSpriteNode* head = [[SKSpriteNode alloc] initWithColor:[SKColor grayColor] size:CGSizeMake(40, 40)];
    head.position = CGPointMake(backBone.position.x, backBone.position.y-40);
    head.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:head.size];
    [scene addChild:head];
    
}</pre></div><p class="calibre15">The preceding code will create two physics bodies, one rectangle and one square. We have adjusted the bodies' positions relative to each other. </p></li><li class="listitem" value="9">Now, add<a id="id280" class="calibre1"/> the following line of code at the end of the <code class="email">initWithSize</code> method to add the physics bodies in the game scene:<div class="informalexample"><pre class="programlisting">[self createPhysicsBodiesOnScene:self];</pre></div><p class="calibre15">Here we are creating the bodies by calling the instance method inside <code class="email">initWithSize</code>.</p></li><li class="listitem" value="10">Now, compile and run the app. You should be able to see the two physics bodies created in the world and they will fall to the ground because of gravity. This will look something similar to following screenshot:<div class="mediaobject"><img src="../images/00109.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre13"> </p></li></ol><div class="calibre14"/></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Physics joints"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec41" class="calibre1"/>Physics joints</h1></div></div></div><p class="calibre8">We have <a id="id281" class="calibre1"/>already seen lots of interesting features of the physics engine. However, we can make our games even more interesting by connecting the physics bodies with each other using joints. All the physics simulation and forces will be applied on the bodies after considering the way they are joined together.</p></div>

<div class="book" title="Physics joints">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec104" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">There are various ways of joining two physics bodies together. They vary based on the places and the location of the bodies that are joined. Joints are divided into the following types based on the ways they connect bodies with each other:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">Pin Joint</strong></span>: This <a id="id282" class="calibre1"/>type of joint joins/pins two physics <a id="id283" class="calibre1"/>together such that they both can independently rotate around their anchor point. The joint will look something similar to following diagram:<div class="mediaobject"><img src="../images/00110.jpeg" alt="Getting ready" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem"><span class="strong"><strong class="calibre2">Limit Joint</strong></span>: In this <a id="id284" class="calibre1"/>type of joints the bodies <a id="id285" class="calibre1"/>always maintain the fix maximum distance from each other. This is something like the bodies are connected to each other with a rote with a fixed maximum distance which is the length of the rope.<div class="mediaobject"><img src="../images/00111.jpeg" alt="Getting ready" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem"><span class="strong"><strong class="calibre2">Spring Joint</strong></span>: This<a id="id286" class="calibre1"/> type of joint attaches two bodies as<a id="id287" class="calibre1"/> if they were connected to each other with a spring. This makes them behave in a perfectly elastic manner. The length of the spring can be defined by the initial distance between two bodies.<div class="mediaobject"><img src="../images/00112.jpeg" alt="Getting ready" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem"><span class="strong"><strong class="calibre2">Sliding Joint</strong></span>: This <a id="id288" class="calibre1"/>type of joint allows to bodies to slide<a id="id289" class="calibre1"/> with respect to each other. The sliding axis can be explicitly defined by the user.<div class="mediaobject"><img src="../images/00113.jpeg" alt="Getting ready" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem"><span class="strong"><strong class="calibre2">Fixed Joint</strong></span>: This <a id="id290" class="calibre1"/>type of joint fuses the two physics <a id="id291" class="calibre1"/>bodies with each other through a provided reference point. These joints can be used to create complex objects, which can be broken<a id="id292" class="calibre1"/> into pieces later.<div class="mediaobject"><img src="../images/00114.jpeg" alt="Getting ready" class="calibre10"/></div><p class="calibre13"> </p></li></ul></div></div></div>

<div class="book" title="Physics joints">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec105" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre8">Now we will open our <a id="id293" class="calibre1"/>working project again to integrate and implement all types of joints in our project. The following steps will provide the step-by-step ways to implement the joints and understand them in more depth.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">To implement<a id="id294" class="calibre1"/> the pin joint, open the <code class="email">GameScene.m</code> file and add the following function in it:<div class="informalexample"><pre class="programlisting">-(void)createPinJointOnScene:(SKScene*)scene
{
    //Adding Rectangle
    SKSpriteNode* backBone = [[SKSpriteNode alloc] initWithColor:[UIColor whiteColor] size:CGSizeMake(20, 200)];
    backBone.position = CGPointMake(CGRectGetWidth(self.frame)/2.0, CGRectGetHeight(self.frame)/2.0);
    backBone.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:backBone.size];
    backBone.physicsBody.categoryBitMask = GFPhysicsCategoryRectangle;
    backBone.physicsBody.collisionBitMask = GFPhysicsCategoryWorld;
    [scene addChild:backBone];
    
    //Adding Square
    SKSpriteNode* head = [[SKSpriteNode alloc] initWithColor:[SKColor grayColor] size:CGSizeMake(40, 40)];
    head.position = CGPointMake(backBone.position.x+5, backBone.position.y-40);
    head.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:head.size];
    head.physicsBody.categoryBitMask = GFPhysicsCategorySquare;
    head.physicsBody.collisionBitMask = GFPhysicsCategoryWorld;
    [scene addChild:head];
    
    //Pinning Rectangle and Square
    NSLog(@"Head position %@", NSStringFromCGPoint(head.position));
    SKPhysicsJointPin* pin =[SKPhysicsJointPin jointWithBodyA:backBone.physicsBody bodyB:head.physicsBody anchor:CGPointMake(head.position.x-5, head.position.y)];
    [scene.physicsWorld addJoint:pin];
}</pre></div><p class="calibre15">In the first five lines of code, we are creating a rectangular sprite with a physics body. We have also specified the collision and the category mask for this sprite.</p><p class="calibre15">Similarly, in the following lines of code, we will create square sprite with the physics body attached. For this sprite also, we are specifying the category and the collision masks.</p><p class="calibre15">Then, finally, in last three lines of code, we are attaching the two bodies to each other through a pin joint. We've created an object of the <code class="email">SKPhysicsJointPin</code> class and provided both the rectangle and square bodies to it along with the anchor point from which they will be rotating around each other.</p></li><li class="listitem" value="2">Now, replace<a id="id295" class="calibre1"/> the <code class="email">createPhysicsBodiesOnScene</code> function call with <code class="email">createPinJointOnScene</code>. Add the following code at the end of the <code class="email">init</code> function:<div class="informalexample"><pre class="programlisting">[self createPinJointOnScene:self];</pre></div><p class="calibre15">The final function should look something similar to following screenshot:</p><div class="mediaobject"><img src="../images/00115.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="3">Now, compile <a id="id296" class="calibre1"/>and run the project and you should be able to see both the physics bodies attached with the pin joint. You can see them attached to each other through the anchor point.<div class="mediaobject"><img src="../images/00116.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="4">Now we will<a id="id297" class="calibre1"/> implement the fixed joint; open the <code class="email">GameScene.m</code> file, and add the following function to implement the fixed joint:<div class="informalexample"><pre class="programlisting">-(void)createFixedJointOnScene:(SKScene*)scene
{
    //Adding Rectangle
    SKSpriteNode* backBone = [[SKSpriteNode alloc] initWithColor:[UIColor whiteColor] size:CGSizeMake(20, 200)];
    backBone.position = CGPointMake(CGRectGetWidth(self.frame)/2.0, CGRectGetHeight(self.frame)/2.0);
    backBone.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:backBone.size];backBone.physicsBody.categoryBitMask = GFPhysicsCategoryRectangle;
    backBone.physicsBody.collisionBitMask = GFPhysicsCategoryWorld;
    [scene addChild:backBone];
    
    
    //Adding Square
    SKSpriteNode* head = [[SKSpriteNode alloc] initWithColor:[SKColor grayColor] size:CGSizeMake(40, 40)];
    head.position = CGPointMake(backBone.position.x+5, backBone.position.y-40);
    head.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:head.size];
    head.physicsBody.categoryBitMask = GFPhysicsCategorySquare;
    head.physicsBody.collisionBitMask = GFPhysicsCategoryWorld;
    [scene addChild:head];
    
    //Pinning Rectangle and Square
    NSLog(@"Head position %@", NSStringFromCGPoint(head.position));
    SKPhysicsJointFixed* pin =[SKPhysicsJointFixed jointWithBodyA:backBone.physicsBody bodyB:head.physicsBody anchor:CGPointMake(head.position.x-5, head.position.y)];
    [scene.physicsWorld addJoint:pin];
}</pre></div><p class="calibre15">Now, we have attached two physics bodies together with a fixed joint. In the last function, we have provided two bodies and the anchor point to which they are attached.</p></li><li class="listitem" value="5">Now, replace <a id="id298" class="calibre1"/>the <code class="email">createPinJointOnScene</code> function call with <code class="email">createFixedJointOnScene</code>. Add the following code in the end of the <code class="email">init</code> function:<div class="informalexample"><pre class="programlisting">[self createFixedJointOnScene:self];</pre></div></li><li class="listitem" value="6">Now, compile and run the project and you should be able to see both the physics bodies attached by the fixed joint. You will observe that the bodies are attached together with the  specified anchor point.<div class="mediaobject"><img src="../images/00117.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="7">Now, to implement the <a id="id299" class="calibre1"/>sliding joint in our sample project, open the <code class="email">GameScene.m</code> file and add the following function at the end:<div class="informalexample"><pre class="programlisting">-(void)createSlidingJointOnScene:(SKScene*)scene {
    //Adding Rectangle
    SKSpriteNode* backBone = [[SKSpriteNode alloc] initWithColor:[UIColor whiteColor] size:CGSizeMake(20, 200)];
    backBone.position = CGPointMake(CGRectGetWidth(self.frame)/2.0, CGRectGetHeight(self.frame)/2.0);
    backBone.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:backBone.size];
    backBone.physicsBody.categoryBitMask = GFPhysicsCategoryRectangle;
    backBone.physicsBody.collisionBitMask = GFPhysicsCategoryWorld;
    backBone.physicsBody.affectedByGravity = NO;
    backBone.physicsBody.allowsRotation = NO;
    [scene addChild:backBone];
    
    //Adding Square
    SKSpriteNode* head = [[SKSpriteNode alloc] initWithColor:[SKColor grayColor] size:CGSizeMake(40, 40)];
    head.position = CGPointMake(backBone.position.x, backBone.position.y-40);
    head.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:head.size];
    head.physicsBody.categoryBitMask = GFPhysicsCategorySquare;
    head.physicsBody.collisionBitMask = GFPhysicsCategoryWorld;
    [scene addChild:head];
    
    //Pinning Rectangle and Square
    NSLog(@"Head position %@", NSStringFromCGPoint(head.position));
    SKPhysicsJointSliding* pin =[SKPhysicsJointSliding jointWithBodyA:backBone.physicsBody bodyB:head.physicsBody anchor:head.position axis:CGVectorMake(0, 1)];
    pin.shouldEnableLimits = YES;
    pin.upperDistanceLimit = 200;
    pin.lowerDistanceLimit = -100;
    
    [scene.physicsWorld addJoint:pin];
}</pre></div></li><li class="listitem" value="8">Now you<a id="id300" class="calibre1"/> will observe that we are creating two physics bodies and in the last section we are joining both of them using the slide joint. However, to see slide joint in action, we will have to apply impulses on the square body. Add the following function to apply an impulse:<div class="informalexample"><pre class="programlisting">-(void)applyImpulseUpwards:(NSTimer*)timer {
    NSDictionary* dict = [timer userInfo];
    SKPhysicsBody* body = dict[@"body"];
    
    CGVector impulse = CGVectorMake(0, [dict[@"impulse"] intValue]);
    
    [body applyImpulse:impulse];
}</pre></div></li><li class="listitem" value="9">To add the impulse implementation, we will have to add the following line of code at the end of the <code class="email">createSlidingJointOnScene</code> function.<div class="informalexample"><pre class="programlisting">[NSTimer scheduledTimerWithTimeInterval:5 target:self selector:@selector(applyImpulseUpwards:) userInfo:@{@"body":head.physicsBody,@"impulse":@(25)} repeats:YES];</pre></div><p class="calibre15">Now the square body will experience the impulse every 5 seconds.</p></li><li class="listitem" value="10">Now, replace the <code class="email">createFixedJointOnScene</code> function call with <code class="email">createSlidingJointOnScene</code>. Add the following code at the end of the <code class="email">init</code> function:<div class="informalexample"><pre class="programlisting">[self createSlidingJointOnScene:self];</pre></div></li><li class="listitem" value="11">Now, compile and<a id="id301" class="calibre1"/> run the project and you should be able to see both the physics bodies sliding over each other.<div class="mediaobject"><img src="../images/00118.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="12">Now we will head towards implementing the<a id="id302" class="calibre1"/> spring joint in our sample project. Open the <code class="email">GameScene.m</code> file and add the following function at the end of the file:<div class="informalexample"><pre class="programlisting">-(void)createSpringJointOnScene:(SKScene*)scene
{
    SKSpriteNode* backBone = [[SKSpriteNode alloc] initWithColor:[UIColor whiteColor] size:CGSizeMake(20, 200)];
    backBone.position = CGPointMake(CGRectGetWidth(self.frame)/2.0, CGRectGetHeight(self.frame)/2.0);
    backBone.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:backBone.size];
    backBone.physicsBody.categoryBitMask = GFPhysicsCategoryRectangle;
    backBone.physicsBody.collisionBitMask = GFPhysicsCategoryWorld;
    [scene addChild:backBone];
    
    
    //Adding Square
    SKSpriteNode* head = [[SKSpriteNode alloc] initWithColor:[SKColor grayColor] size:CGSizeMake(40, 40)];
    head.position = CGPointMake(backBone.position.x, backBone.position.y+backBone.size.height/2.0+40);
    head.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:head.size];
    head.physicsBody.categoryBitMask = GFPhysicsCategorySquare;
    head.physicsBody.collisionBitMask = GFPhysicsCategoryWorld;
    [scene addChild:head];
    
    //Pinning Rectangle and Square
    NSLog(@"Head position %@", NSStringFromCGPoint(head.position));
    SKPhysicsJointSpring* pin =[SKPhysicsJointSpring jointWithBodyA:backBone.physicsBody bodyB:head.physicsBody anchorA:head.position anchorB:CGPointMake(backBone.position.x, backBone.position.y+backBone.size.height/2.0)];
    pin.damping = 0.5;
    pin.frequency = 0.5;
    [scene.physicsWorld addJoint:pin];
}</pre></div><p class="calibre15">To apply a spring joint between two physics bodies, we have provided two physics bodies along with two anchor points as the function parameters. We can also provide additional parameters such as damping and frequencies.</p></li><li class="listitem" value="13">Now, replace<a id="id303" class="calibre1"/> the <code class="email">createSlidingJointOnScene</code> function call with <code class="email">createSpringJointOnScene</code>. Add the following code at the end of the <code class="email">init</code> function:<div class="informalexample"><pre class="programlisting">[self createSpringJointOnScene:self];</pre></div></li><li class="listitem" value="14">Now compile and run the project and you should be able to see both the physics bodies sliding over each other.<div class="mediaobject"><img src="../images/00119.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="15">Our next type <a id="id304" class="calibre1"/>of joint is the limit joint in our sample project. Now open the <code class="email">GameScene.m</code> file and add the following function at the end of the file:<div class="informalexample"><pre class="programlisting">-(void)createLimitJointOnScene:(SKScene*)scene {
    SKLabelNode* label = [SKLabelNode labelNodeWithFontNamed:@"Futura-Medium"];
    label.text = @"An upward impulse is applied to the square every few seconds.";
    label.fontSize = 14;
    label.position = CGPointMake(220, scene.view.frame.size.height-100);
    [scene addChild:label];
    
    SKSpriteNode* backBone = [[SKSpriteNode alloc] initWithColor:[UIColor whiteColor] size:CGSizeMake(20, 200)];
    backBone.position = CGPointMake(CGRectGetWidth(self.frame)/2.0, CGRectGetHeight(self.frame)/2.0);
    backBone.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:backBone.size];
    backBone.physicsBody.categoryBitMask = GFPhysicsCategoryRectangle;
    backBone.physicsBody.collisionBitMask = GFPhysicsCategoryWorld;
    [scene addChild:backBone];
    
    //Adding Square
    SKSpriteNode* head = [[SKSpriteNode alloc] initWithColor:[SKColor grayColor] size:CGSizeMake(40, 40)];
    head.position = CGPointMake(backBone.position.x, backBone.position.y+backBone.size.height/2.0+40);
    head.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:head.size];
    head.physicsBody.categoryBitMask = GFPhysicsCategorySquare;
    head.physicsBody.collisionBitMask = GFPhysicsCategoryWorld;
    [scene addChild:head];
    
    //Pinning Rectangle and Square
    NSLog(@"Head position %@", NSStringFromCGPoint(head.position));
    SKPhysicsJointLimit* pin =[SKPhysicsJointLimit jointWithBodyA:backBone.physicsBody bodyB:head.physicsBody anchorA:head.position anchorB:CGPointMake(backBone.position.x, backBone.position.y+backBone.size.height/2.0)];
    pin.maxLength = 100;
    [scene.physicsWorld addJoint:pin];
    
    [NSTimer scheduledTimerWithTimeInterval:5 target:self selector:@selector(applyImpulseUpwards:) userInfo:@{@"body":head.physicsBody,@"impulse":@(50)} repeats:YES];
}</pre></div><p class="calibre15">In the second last section, we are applying the limit joint on both the physics bodies that we have created. To apply a limit joint, we have to pass both the bodies along with the anchor points that create the joint. Now, when the joint object is initialized, we can add the joint to the physics world.</p><p class="calibre15">As we have seen earlier in sliding joint, an extra impulse has been applied on one of the bodies. Similarly, here also we have to apply the impulse on the square body to test the limit joint behavior.</p></li><li class="listitem" value="16">Now, replace <a id="id305" class="calibre1"/>the <code class="email">createSpringJointOnScene</code> function call with <code class="email">createLimitJointOnScene</code>. Add the following code at the end of the <code class="email">init</code> function:<div class="informalexample"><pre class="programlisting">[self createLimitJointOnScene:self];</pre></div></li><li class="listitem" value="17">Now compile and run the project and you should be able to see both the physics bodies sliding <a id="id306" class="calibre1"/>over each other.<div class="mediaobject"><img src="../images/00120.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre13"> </p></li></ol><div class="calibre14"/></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Detecting contact and collisions"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec42" class="calibre1"/>Detecting contact and collisions</h1></div></div></div><p class="calibre8">We apply physics <a id="id307" class="calibre1"/>simulation to the bodies by adding the <code class="email">SKPhysicsBody</code> function to a node. While the scene processes each frame, it performs all the physics-related calculations for all the bodies in the scene. It also calculates all the custom forces that are applied on any body in the scene, which eventually gives the realistic effects in the game. Collision detection is an important part while <a id="id308" class="calibre1"/>developing any game in the real world because in almost all games we check for the collision of two bodies. For example, in any warfare game, we may need to check whether a bullet has collided with the player.</p></div>

<div class="book" title="Detecting contact and collisions">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec106" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">There are various shapes for the physics bodies that can be used to apply physics to a scene. These shapes are defined as the personal space of the node. When the shape of one node intersects with the shape of another node, the <code class="email">-didBeginContact</code> method is invoked and physics may be applied. Now, to implement the collision detection, we will have to understand the following properties of the physics bodies:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">categoryBitMask</code>: This <a id="id309" class="calibre1"/>property defines the category of the physics body. We can have custom categories depending on our requirement. For example, in a warfare game, we can have player, bullets, and enemies as the categories. All the physics bodies can be based on these categories. </li><li class="listitem"><code class="email">collisionBitMask</code>: This <a id="id310" class="calibre1"/>property adds a mask that defines which physics bodies can collide with this physics body. This will help the physics engine to evaluate and throw only the required results in the delegate methods. For example, the bullets can only collide with enemies, not with any player.</li><li class="listitem"><code class="email">contactTestBitMask</code>: This<a id="id311" class="calibre1"/> property defines the mask to specify which categories of physics bodies cause intersection notifications with this physics body.</li></ul></div></div></div>

<div class="book" title="Detecting contact and collisions">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec107" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre8">Now, we will open our working project again to implement an example dealing with collision and contact detection. The following steps will provide the step-by-step ways to implement and understand collision detection in our project:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">To implement <a id="id312" class="calibre1"/>the collision detection, open the <code class="email">GameScene.m</code> file and add the following function at the end of the file:<div class="informalexample"><pre class="programlisting">- (void)createCollisionDetectionOnScene:(SKScene*)scene {
    collisionLabel = [SKLabelNode labelNodeWithFontNamed:@"Futura-Medium"];
    collisionLabel.text = @"Collision detected";
    collisionLabel.fontSize = 18;
    collisionLabel.fontColor = [SKColor whiteColor];
    collisionLabel.position = CGPointMake(CGRectGetWidth(self.frame)/2.0, CGRectGetHeight(self.frame)/1.2);
    collisionLabel.alpha = 0.0f;
    [scene addChild:collisionLabel];
    
    SKSpriteNode* backBone = [[SKSpriteNode alloc] initWithColor:[UIColor whiteColor] size:CGSizeMake(20, 200)];
    backBone.position = CGPointMake(CGRectGetWidth(self.frame)/2.0, CGRectGetHeight(self.frame)/2.0);
    backBone.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:backBone.size];
    backBone.physicsBody.categoryBitMask = GFPhysicsCategoryRectangle;
    backBone.physicsBody.collisionBitMask = GFPhysicsCategorySquare;
    backBone.physicsBody.contactTestBitMask = GFPhysicsCategorySquare;
    backBone.physicsBody.dynamic = YES;
    [scene addChild:backBone];
    
    //Adding Square
    SKSpriteNode* head = [[SKSpriteNode alloc] initWithColor:[SKColor grayColor] size:CGSizeMake(40, 40)];
    head.position = CGPointMake(backBone.position.x, backBone.position.y+backBone.size.height/2.0+40);
    head.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:head.size];
    head.physicsBody.categoryBitMask = GFPhysicsCategorySquare;
    head.physicsBody.collisionBitMask = GFPhysicsCategoryRectangle;
    head.physicsBody.contactTestBitMask = GFPhysicsCategoryRectangle;
    head.physicsBody.dynamic = YES;
    [scene addChild:head];
    
    [NSTimer scheduledTimerWithTimeInterval:5 target:self selector:@selector(applyImpulseUpwards:) userInfo:@{@"body":head.physicsBody,@"impulse":@(50)} repeats:YES];
}</pre></div><p class="calibre15">Now we <a id="id313" class="calibre1"/>are familiar with code in this function. We will create two physics bodies and add them on the scene. Finally, in the last section, we will apply an impulse every 5 seconds on the physics body.</p><p class="calibre15">Here we are updating three additional parameters for each of the physics bodies. We are updating <code class="email">categoryBitMask</code>, <code class="email">collisionBitMask</code>, and <code class="email">contactTestBitMask</code> for the bodies. As explained, we are updating <code class="email">categoryBitMask</code> to provide the specific categories to the physics bodies. Along with that, we provide the information to define which bodies it can detect collision with.</p></li><li class="listitem" value="2">Now we have to add the delegate method, which will be invoked when both the bodies collide with each other. We have added logs to check the bodies that are colliding. We can identify bodies using their <code class="email">categoryBitMask</code>.<div class="mediaobject"><img src="../images/00121.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="3">Now, replace the <code class="email">createLimitJointOnScene</code> function call with <code class="email">createCollisionDetectionOnScene</code>. Add the following code at the end of the <code class="email">init</code> function:<div class="informalexample"><pre class="programlisting">[self createCollisionDetectionOnScene:self];</pre></div></li><li class="listitem" value="4">Also we have<a id="id314" class="calibre1"/> to subscribe to the delegate callbacks for contact detection. To subscribe, add the following line of code:<div class="informalexample"><pre class="programlisting">self.physicsWorld.contactDelegate = self;</pre></div></li><li class="listitem" value="5">We will also have to declare the contact delegate in the interface file. So open <code class="email">GameScene.h</code> and add the following code at the end of interface declaration line:<div class="informalexample"><pre class="programlisting">&lt;SKPhysicsContactDelegate&gt;</pre></div></li><li class="listitem" value="6">The final code file should look something similar to following screenshot:<div class="mediaobject"><img src="../images/00122.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="7">Now compile and run the project and you should be able to see both the physics bodies on the screen and logs on the Xcode debug window. You can see that the collision has been detected and printed in the logs. You can also notice that the collision has been detected between the bodies with category mask as <code class="email">2</code> and <code class="email">4</code>. We have a rectangular body with mask as <code class="email">2</code> and square body with mask as <code class="email">4</code>, which are colliding with each other.<div class="mediaobject"><img src="../images/00123.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="8">Now we will <a id="id315" class="calibre1"/>make the collision detection more intuitive. For this, let's add a label on the screen, which will blink when the bodies collide with each other. To do this, add the following line of code at the top just before the <code class="email">@implementation</code> GameScene code:<div class="informalexample"><pre class="programlisting">SKLabelNode* collisionLabel;</pre></div></li><li class="listitem" value="9">Now, add the following lines of code at the start of the <code class="email">createCollisionDetectionOnScene</code> function:<div class="informalexample"><pre class="programlisting">collisionLabel = [SKLabelNode labelNodeWithFontNamed:@"Futura-Medium"];
collisionLabel.text = @"Collision detected";
collisionLabel.fontSize = 18;
collisionLabel.fontColor = [SKColor whiteColor];
collisionLabel.position = CGPointMake(CGRectGetWidth(self.frame)/2.0, CGRectGetHeight(self.frame)/1.2);
collisionLabel.alpha = 0.0f;
[scene addChild:collisionLabel];</pre></div></li><li class="listitem" value="10">Now, for fade-in and fade-out of the label on collision, add the following line of code at the end of the <code class="email">didBeginContact</code> method:<div class="informalexample"><pre class="programlisting">SKSpriteNode *firstNode, *secondNode;

firstNode = (SKSpriteNode *)contact.bodyA.node;
secondNode = (SKSpriteNode *) contact.bodyB.node;

if (firstNode.physicsBody.categoryBitMask == GFPhysicsCategoryRectangle &amp;&amp; secondNode.physicsBody.categoryBitMask == GFPhysicsCategorySquare) {
    
    SKAction *fadeIn = [SKAction fadeAlphaTo:1.0f duration:0.2];
    SKAction *fadeOut = [SKAction fadeAlphaTo:0.0f duration:0.2];
    [collisionLabel runAction:fadeIn completion:^{
        [collisionLabel runAction:fadeOut];
    }];
}</pre></div></li><li class="listitem" value="11">Here we are <a id="id316" class="calibre1"/>checking for the rectangular and square bodies. Once we get a callback for the collision of these two bodies, we can fade in the label for a fraction of a second and then fade it out again. This will give a nice effect to show when the bodies have collided with each other.</li><li class="listitem" value="12">Now compile and run the project and you should be able to see both the physics bodies attached with the pin joint. You can see them attached to each other through the anchor point.<div class="mediaobject"><img src="../images/00124.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre13"> </p></li></ol><div class="calibre14"/></div></div></div></body></html>