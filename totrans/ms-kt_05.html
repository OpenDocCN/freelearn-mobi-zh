<html><head></head><body><div><div><div><h1 id="_idParaDest-61" class="chapter-number"><a id="_idTextAnchor067"/>5</h1>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor068"/>Architect Your App</h1>
			<p>The process of developing apps needs to be scalable in such a way that you can maintain the app over a long time and easily hand over the development of it to other developers or teams. To be able to do this, we need to properly think about the architecture of our apps. We will be looking at how to build our apps in this chapter.</p>
			<p>In this chapter, we will build on what we’ve learned from the previous chapters. We are going to look at the different architectures available for Android projects. We’ll dive deep into <strong class="bold">MVVM architecture</strong> and its different layers and how to use some of the Jetpack libraries within their architecture. Additionally, we’ll learn how to use advanced architecture features, such as dependency injection and Kotlin Gradle DSL, as well as version catalogs to define dependencies.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>Introduction to app architecture</li>
				<li>MVVM deep dive</li>
				<li>Jetpack libraries</li>
				<li>Dependency injection</li>
				<li>Migrating to Kotlin Gradle DSL and using version catalogs</li>
			</ul>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor069"/>Technical Requirements</h1>
			<p><a id="_idTextAnchor070"/>To follow the instructions in this chapter, you will need to have Android Studio Hedgehog or later (<a href="https://developer.android.com/studio">https://developer.android.com/studio</a>) downloaded. </p>
			<p>You can find the code for this chapter at <a href="https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfive">https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfive</a>.</p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor071"/>Introduction to app architecture</h1>
			<p>So far, we have learned how to create apps and designed beautiful UIs with Material 3 and Jetpack Compose. We haven’t yet started adopting any architecture for our apps. In this section, we will look at some of the app architectures that we can use to build our apps. We will also look at some of the best practices that we can follow when building our apps. First, let’s see some of the benefits of using an app architecture:</p>
			<ul>
				<li><strong class="bold">Separation of concerns</strong>: Using an architecture allows us to separate our code into different layers. Each<a id="_idIndexMarker207"/> layer only does one thing. This makes it easy to separate and group our code into different layers. Each layer has its responsibility. This prevents things from being mixed up and makes it easier to maintain our code.</li>
				<li><strong class="bold">Easy testing</strong>: Using an architecture makes it easy to test our code. We can easily test each layer of our code in isolation since things are not tightly coupled.</li>
				<li><strong class="bold">Easy to maintain</strong>: Using an architecture makes it easy to maintain our code. We can easily make changes to our code without affecting other parts of our code. This makes it easy to maintain our code over the long term. We can also swap in and out different parts of the code, and since we have tests, we can test the different implementations and ensure that nothing breaks.</li>
				<li><strong class="bold">Easy to scale</strong>: Using an architecture makes it easy to scale our code. We can easily add new features to our code without affecting other parts of our code.</li>
				<li><strong class="bold">Easy to work in teams</strong>: Using an architecture makes it easy to work in teams. Each team member or team can work on a different layer of the code. It makes it possible to work concurrently on different parts of the codebase.</li>
				<li><strong class="bold">Promotes reusability</strong>: Over time, we can place some of the commonly used code across the projects in common packages or modules, which can then be re-used across the project without having to repeat the code.</li>
			</ul>
			<p>When it comes to choosing an architecture for our apps, there are a lot of options that we can choose from. There isn’t a particular architecture that fits all the use cases, so it’s always recommended that we discuss things with our teams and see which architecture fits the use case. Each architecture has its pros and cons, and we or the whole team have to evaluate which one<a id="_idIndexMarker208"/> has more pros than cons. We can architect our app either by feature or by layers. When we architect by feature, we have layers that represent a feature. When we architect by layers, we have layers that represent a layer of our app. An example of architecting by feature is shown in the following points:</p>
			<ul>
				<li>Home feature</li>
				<li>Profile feature</li>
				<li>Settings feature</li>
			</ul>
			<p>The preceding example shows how we can architect our app by feature. We have the <strong class="bold">Home</strong>, <strong class="bold">Profile</strong>, and <strong class="bold">Settings</strong> features. Each feature has its layers and all the code related to that feature.</p>
			<p>Some of the architectures that we can use to build our apps are the following:</p>
			<ul>
				<li><strong class="bold">Model, View, and ViewModel</strong> (<strong class="bold">MVVM</strong>): This is the most commonly used architecture and is even <a id="_idIndexMarker209"/>recommended by Google to use with our apps. The app has the <strong class="bold">Model</strong> <strong class="bold">View</strong> and <strong class="bold">ViewModel</strong> layers. The Model layer is responsible for holding the data. The View layer is responsible for displaying the data. The ViewModel layer is responsible for holding the state of the data. It is also responsible for communicating with the <a id="_idIndexMarker210"/>Model and View layers. MMVM promotes the clear separation of concerns between the different layers. It also <a id="_idIndexMarker211"/>supports <strong class="bold">data binding</strong>, which makes it easy to update the UI when the data change. It also supports testing since the different layers are not tightly coupled. It also has less boilerplate code when compared to other architectures. However, it has its downsides, one of them being a large learning curve at times and this can become complex very easily, especially with lots of features.</li>
				<li><strong class="bold">Model View Intent</strong> (<strong class="bold">MVI</strong>): This has three key layers. The <strong class="bold">Model</strong> layer is responsible for holding the data. The <strong class="bold">View</strong> layer is responsible for displaying the data. The <strong class="bold">Intent</strong> layer represents <a id="_idIndexMarker212"/>user actions or events that are dispatched to<a id="_idIndexMarker213"/> the model to update a state. MVI promotes unidirectional <strong class="bold">data flow</strong>, where data flow in the same direction.</li>
				<li><strong class="bold">Model View Controller</strong> (<strong class="bold">MVC</strong>): This architecture has three layers. The <strong class="bold">Model</strong> layer represents the business logic and holds the data. The <strong class="bold">View</strong> layer is responsible for displaying the data. The <strong class="bold">Controller</strong> layer is responsible for and acts as an intermediary<a id="_idIndexMarker214"/> between the model and the view. It takes care of the user input and updates the view and the model. MVC is very straightforward, especially when starting out, and enables quick iterations and a showcase of app architecture. Its only problem is that it has a tight coupling between the layers, making it hard to test and scale.</li>
				<li><strong class="bold">Model View Presenter</strong> (<strong class="bold">MVP</strong>): This architecture has three layers. The <strong class="bold">Model</strong> layer represents the business logic and holds the data. The <strong class="bold">View</strong> layer displays the data and UI components<a id="_idIndexMarker215"/> and observes user interactions. The views delegate all UI-related logic to the presenters. The <strong class="bold">Presenter</strong> layer contains presentation logic and acts as an intermediary between the<a id="_idIndexMarker216"/> model and the view. It processes the user input and updates the view and the model. MVP has a good separation of concerns, and the code is easily testable. However, it has a lot of boilerplate code since every view must have its own presenter. It also has a large learning curve and can become complex very easily.</li>
			</ul>
			<p>Now that we understand the different architectures, let us look at MVVM and how we can use it in our apps.</p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor072"/>Deep Diving into MVVM</h1>
			<p>We have already seen the MVVM layers and their pros and cons. In this section, we are going to implement the MMVM architecture in our app step by step. We will start with the model layer, going upwards. Since we all love to have the company of our pets, we are going to use different <a id="_idIndexMarker217"/>types of pets as our data.</p>
			<p>Let us start by creating a <code>com.packt.chapterfive</code> package; then, we select <code>data</code>. Inside this <code>data</code> package, let us create a <code>Pet</code> data class that will represent our pets:</p>
			<pre class="source-code">
data class Pet(
    val id: Int,
    val name: String,
    val species: String
)</pre>			<p>The <code>Pet</code> data class holds all the data for our pets. Next, we will create a repository interface and its implementation that allows us to get these pets. Create a new file named <code>PetsRepository</code> inside the <code>data</code> package with the following code:</p>
			<pre class="source-code">
interface PetsRepository {
    fun getPets(): List&lt;Pet&gt;
}</pre>			<p>This is an interface with one method that returns <code>List&lt;Pet&gt;</code>. Next, let us create the implementation class for our interface. While still inside the <code>data</code> package, create a new file named <code>PetsRepositoryImpl</code> with the following code:</p>
			<pre class="source-code">
class PetsRepositoryImpl: PetsRepository {
    override fun getPets(): List&lt;Pet&gt; {
        return listOf(
            Pet(1, "Bella", "Dog"),
            Pet(2, "Luna", "Cat"),
            Pet(3, "Charlie", "Dog"),
            Pet(4, "Lucy", "Cat"),
            Pet(5, "Cooper", "Dog"),
            Pet(6, "Max", "Cat"),
            Pet(7, "Bailey", "Dog"),
            Pet(8, "Daisy", "Cat"),
            Pet(9, "Sadie", "Dog"),
            Pet(10, "Lily", "Cat"),
        )
    }
}</pre>			<p>To explain what the preceding<a id="_idIndexMarker218"/> code does, please see the following:</p>
			<ul>
				<li>We created a class named <code>PetsRepositoryImpl</code>, which implements the <code>PetsRepository</code> interface</li>
				<li>We override the <code>getPets()</code> method and return a list of pets. Our list has 10 pets with <strong class="bold">ID</strong>, <strong class="bold">name</strong>, and <strong class="bold">species</strong></li>
			</ul>
			<p>We have used a pattern <a id="_idIndexMarker219"/>called the <strong class="bold">repository pattern</strong> to get our pets. The repository pattern is a pattern that allows us to abstract the data layer from the rest of the app. It allows us to get data from different sources without affecting the rest of the app. For example, we can get data from a local database or a remote server. The class is responsible for merging the data from the two sources and maintaining the source of truth for our data. The repository pattern also allows us to easily test our code since we can easily mock the repository and test the different layers of our app in isolation. Since our app is very simple at the moment, we have already completed the data/model layer of our architecture.</p>
			<p>Let us now create a <code>ViewModel</code> class for our <code>ViewModel</code> layer. Start by creating a <code>ViewModel</code> package inside the <code>com.packt.chapterfive</code> package. Inside this <code>ViewModel</code> package, create a <a id="_idIndexMarker220"/>new file named <code>PetsViewModel</code> with the following code:</p>
			<pre class="source-code">
class PetsViewModel: ViewModel() {
    private val petsRepository: PetsRepository = PetsRepositoryImpl()
    fun getPets() = petsRepository.getPets()
}</pre>			<p>To explain what the preceding code does, please see the following:</p>
			<ul>
				<li>We created a class named <code>PetsViewModel</code> that extends the <code>ViewModel</code> class. This is a class <a id="_idIndexMarker221"/>from the <strong class="bold">Jetpack libraries</strong>. It helps data persist across configuration changes. It also acts as the intermediary between the View and the Model layers. We use it to expose data to our views, act on user interactions, and update the data in the Model layer.</li>
				<li>We created a private property named <code>petsRepository</code> of type <code>PetsRepository</code> and initialized it with an instance of <code>PetsRepositoryImpl</code>. This is the repository we created earlier.</li>
				<li>We created a method named <code>getPets()</code> that returns a list of pets. We called the <code>getPets()</code> method from the <code>petsRepository</code> property and returned the result.</li>
			</ul>
			<p>With this, our <code>ViewModel</code> layer is ready to expose data to our views. Our <code>getPets()</code> method returns a list of pets. To <a id="_idIndexMarker222"/>display the list in <code>LazyColumn</code> composable. <code>LazyColumn</code> follows a lazy-loading approach, meaning that only the items currently visible<a id="_idIndexMarker223"/> on the screen are actively composed, reducing resource usage and improving performance. Let us see how a <code>LazyColumn</code> works under the hood.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor073"/>How LazyColumn works</h2>
			<p>This is how a <code>LazyColumn</code> works:</p>
			<ul>
				<li><code>LazyColumn</code> composes only the visible items on the screen. As the user<a id="_idIndexMarker224"/> scrolls, it dynamically composes and recomposes items, ensuring that only the necessary elements <a id="_idIndexMarker225"/>are rendered at any given time.</li>
				<li><code>RecyclerView</code>, <code>LazyColumn</code> reuses composables that move in and out of the viewport, minimizing memory usage and preventing unnecessary recomposition.</li>
				<li><code>LazyColumn</code> optimizes the rendering process, making it well-suited for displaying large datasets without consuming excessive resources.</li>
			</ul>
			<p>Now that we know how <code>LazyColumn</code> works, let’s see the benefits of using <code>LazyColumn</code>.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor074"/>Benefits of LazyColumn</h2>
			<p>Some of the <a id="_idIndexMarker226"/>benefits of <code>LazyColumn</code> are the following:</p>
			<ul>
				<li><code>LazyColumn</code> efficiently manages memory by composing only the visible items, ensuring that the app does not unnecessarily store and render all items in a list at once. This is particularly beneficial for long lists or lists with complex UI elements.</li>
				<li><strong class="bold">Improved rendering performance</strong>: The lazy-loading mechanism significantly improves rendering performance, especially when dealing with extensive datasets. It avoids the overhead of rendering and managing all items simultaneously, resulting in smoother scrolling and reduced lag.</li>
				<li><code>LazyColumn</code>, allows us to express UI logic concisely. The code to create and manage large lists becomes <a id="_idIndexMarker227"/>more straightforward and readable compared to traditional Android View approaches.</li>
				<li><code>LazyColumn</code> automatically recomposes only the affected items, reducing the need for manual interventions to update the UI.</li>
				<li><code>LazyColumn</code> adapts well to different screen sizes and resolutions, offering a consistent and responsive user experience across various devices.</li>
			</ul>
			<p>Now, we’re going to create a composable that displays pets.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor075"/>Creating a composable</h2>
			<p>Follow these steps to <a id="_idIndexMarker228"/>create a composable:</p>
			<ol>
				<li>Create a new<a id="_idIndexMarker229"/> package named <code>views</code> inside the <code>com.packt.chapterfive</code> package.</li>
				<li>Inside this <code>views</code> package, create a new file named <code>PetsList</code> with the following code:<pre class="source-code">
@Composable
fun PetList(modifier: Modifier) {
    val petsViewModel: PetsViewModel = viewModel()
    LazyColumn(
        modifier = modifier
    ) {
        items(petsViewModel.getPets()) { pet -&gt;
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(10.dp),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text(text = "Name: ${pet.name}")
                Text(text = "Species: ${pet.species}")
            }
        }
    }
}</pre><p class="list-inset">Here, we have created a composable named <code>PetList</code> that takes a modifier as a parameter. We then <a id="_idIndexMarker230"/>create an instance of <code>PetsViewModel</code> using the <code>viewModel()</code> function from the lifecycle utility library for <code>ViewModel</code> in compose. It helps us easily <a id="_idIndexMarker231"/>create an instance of our <code>PetsViewModel</code>. We then use the <code>LazyColumn</code> composable to display the pets. We pass the list of pets from the <code>ViewModel</code> to the <code>items</code> parameter of the <code>LazyColumn</code>. We then use the <code>Row</code> composable to display the name and species of each pet. We have now completed the view layer of our architecture.</p></li>				<li>To finally display our pets, we need to call our <code>PetList</code> composable inside the <code>setContent</code> block<a id="_idIndexMarker232"/> of our <code>MainActivity</code> class:<pre class="source-code">
ChapterFiveTheme {
    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                   Text(text = "Pets")
                },
                colors =  TopAppBarDefaults.smallTopAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                )
            )
        },
        content =  { paddingValues -&gt;
            PetList(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues)
            )
        }
    )
}</pre><p class="list-inset">We are using the <code>Scaffold</code> composable, which we are already familiar with. In our <code>Scaffold</code>, we are passing<a id="_idIndexMarker233"/> in a <code>TopAppBar</code> and our <code>PetList</code> composable. We are also passing in <code>paddingValues</code> to our <code>PetList</code> composable. This is because we are using <code>paddingValues</code> to add padding to our <code>PetList</code> composable. We<a id="_idIndexMarker234"/> have now completed the MVVM architecture in our app. Let’s run the app and see the result:</p></li>			</ol>
			<div><div><img src="img/B19779_05_01.jpg" alt="Figure 5.1 – Pet list" width="493" height="657"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Pet list</p>
			<p>As seen from the preceding image, we have our list of pets with their name and species displayed in a list.</p>
			<p>We have mentioned <strong class="bold">Jetpack libraries</strong> a lot in this<a id="_idIndexMarker235"/> section but have not explained what they are. In the next section, we are going to look at Jetpack libraries in detail.</p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor076"/>Jetpack libraries</h1>
			<p>Jetpack Libraries are a collection of libraries and APIs from Google that help us developers create better apps using less code. They are normally created to address some pain points we, as <a id="_idIndexMarker236"/>developers, face while creating our apps. Let’s look at some of these pain points and some of the Jetpack libraries that were created to address them:</p>
			<ul>
				<li><strong class="bold">Storing data locally and observing changes to the data</strong>: We had to use <strong class="bold">SQLite</strong> to store data locally. Even for simple <strong class="bold">Create</strong>, <strong class="bold">Read</strong>, <strong class="bold">Update</strong>, and <strong class="bold">Delete</strong> (<strong class="bold">CRUD</strong>) operations, we had to write a lot of boilerplate code. We also had to write a lot of code to<a id="_idIndexMarker237"/> observe changes to the data. This is <a id="_idIndexMarker238"/>a lot of work for a simple task. Jetpack libraries, such as <strong class="bold">Room</strong> and <strong class="bold">LiveData</strong>, were created to address this pain point. Room is a library that allows us to easily store data locally. It also allows us to easily observe changes to the data. LiveData is a library that allows us to observe changes to data easily. It is also lifecycle-aware. This means it automatically stops observing data changes when the lifecycle of the component observing the data ends. This helps us avoid memory leaks in our apps. Room<a id="_idIndexMarker239"/> also has support for <strong class="bold">Kotlin Coroutines</strong>, which we will be looking at deeply in <a href="B19779_06.xhtml#_idTextAnchor084"><em class="italic">Chapter 6</em></a>. This makes it easy to store and access data locally with less boilerplate code.</li>
				<li><strong class="bold">Navigation was a challenging thing to achieve perfectly in our apps</strong>: Lots of open-source libraries were created to solve this pain point. It also required a lot of boilerplate code to navigate between activities and fragments and maintain consistent and predictable<a id="_idIndexMarker240"/> back behavior. <strong class="bold">Jetpack Navigation</strong> was created to address this pain point. It allows us to navigate between screens in our app easily. It also allows us to easily maintain consistent and predictable back behavior. It also allows us to pass data between screens in our app. It also has support for Jetpack <a id="_idIndexMarker241"/>Compose and functions, such as deep links, which are supposed to open a specific screen in our app when a user clicks on a link.</li>
				<li><strong class="bold">Handling lifecycle in activities and fragments</strong>: In Android, both activities and fragments have their own lifecycle, and it is particularly important for us to be aware of these lifecycles so that we can be able to do operations in the right lifecycle. For example, we should be observing data in our views when the lifecycle is in the started state and free up resources when the lifecycle is either in the stopped or destroyed state. Doing this was harder and required a lot of code, which could be bug-prone. The team at Google came up with the <strong class="bold">lifecycle</strong> library to help us manage lifecycles in our activities and fragments. Additionally, we have classes, such as the <strong class="bold">ViewModel</strong>, which we created earlier on, that allow your data to persist across configuration changes. Most of the Jetpack libraries are also lifecycle-aware, which makes it easy to use them in our apps. Taking the ViewModel as an example, it survives beyond the lifecycle of the activity or fragment that created it. This makes it easy for data to persist across configuration changes. It also makes it easy to share data between fragments and activities.</li>
				<li><strong class="bold">Loading infinite lists</strong>: Most apps that we developers work on have a list of items that we want to show to our users. Often, this list of items can be large, and we cannot display all of them at once. We are supposed to display them in batches, which is called <strong class="bold">pagination</strong>. To achieve this by ourselves, we had to do several workarounds, such as<a id="_idIndexMarker242"/> observing the scroll position and fetching the next or previous batch of items when a user reaches the top or bottom of the list. Again, this was quite a bit of work, and the team at Google introduced the <strong class="bold">Paging</strong> library to <a id="_idIndexMarker243"/>help us achieve this. It allows us to load data in batches easily and display it to our users. It also has support for Jetpack Compose and Kotlin Coroutines. It makes it easy to display infinite lists in our apps.</li>
				<li><strong class="bold">Handling background jobs</strong>: Performing lengthy background tasks for apps proved to be somewhat challenging. The common issue was that some of the background jobs did <a id="_idIndexMarker244"/>not run due to the different restrictions that phone manufacturers add to the phones to improve their performance of the phone. The team at Google introduced the <strong class="bold">WorkManager</strong> library to<a id="_idIndexMarker245"/> help us achieve this. It allows us to schedule background jobs in our apps easily. It also supports periodic background jobs and ensures that our jobs run irrespective of the phone brand that the user is using.</li>
				<li><strong class="bold">Performance</strong>: There was no clear guidance on how best we developers can improve the performance of our apps. That is not the case anymore; we have several Jetpack libraries to help us detect performance issues and improve the performance of our apps. A good<a id="_idIndexMarker246"/> example of this is the <strong class="bold">baseline profiles</strong>, which help improve app start-up time and make app interactions much smoother.</li>
			</ul>
			<p>There are a lot of Jetpack libraries. You can explore all the available Jetpack libraries here: <a href="https://developer.android.com/jetpack/androidx/explorer">https://developer.android.com/jetpack/androidx/explorer</a>. The following are some of the benefits of using Jetpack libraries:</p>
			<ul>
				<li>We can follow the best practices</li>
				<li>We can write less boilerplate code</li>
				<li>We reduce fragmentation</li>
				<li>The APIs work well together</li>
			</ul>
			<p>We have already seen how to use a <code>ViewModel</code> class in this chapter. We will also be using other Jetpack libraries in the later chapters of this book.</p>
			<p>We have looked at how the Jetpack Libraries fit in with the different layers of our architecture. In the next section, we <a id="_idIndexMarker247"/>are looking at an important topic in architecture, which is <strong class="bold">dependency injection</strong>.</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor077"/>Dependency injection</h1>
			<p>Dependency injection is a <a id="_idIndexMarker248"/>way for us to manage and provide dependencies that a class needs to do its work without the class having to create the dependencies itself. In this book, we will be using Koin (<a href="https://insert-koin.io/">https://insert-koin.io/</a>) as our dependency injection library.</p>
			<p>Our <code>PetsViewModel</code> class creates the <code>PetsRepository</code> class by itself. This is a suitable candidate for dependency injection. We will be refactoring this to use dependency injection. Let’s start by adding the Koin dependency to our app. Open the <code>build.gradle</code> file for the app module and add the following dependency:</p>
			<pre class="source-code">
implementation 'io.insert-koin:koin-core:3.4.3'
implementation 'io.insert-koin:koin-android:3.4.3'
implementation 'io.insert-koin:koin-androidx-compose:3.4.6'</pre>			<p>We are adding the Koin <code>core</code>, <code>android,</code> and <code>compose</code> dependencies as well, which will be used in our project to provide the dependencies.</p>
			<p>After adding this to our project and syncing<a id="_idIndexMarker249"/> the project, we need to create Koin <code>PetsRepository</code> class. Create a new package named <code>di</code> inside the <code>com.packt.chapterfive</code> package. Inside this <code>di</code> package, create a new file named <code>Modules</code> and add the follo<a id="_idTextAnchor078"/>wing code:</p>
			<pre class="source-code">
val appModules = module {
    single&lt;PetsRepository&gt; { PetsRepositoryImpl() }
}</pre>			<p>In the preceding code above, we are creating a new variable named <code>appModules</code> of the type module. We are using the <code>module</code> function from the Koin library to create a module. We are using the <code>single</code> function to create a single instance of the <code>PetsRepository</code> class. Koin has dependency injection scopes, such as <code>single</code>, <code>factory</code>, and <code>scoped</code>, that govern the lifecycle and visibility of dependency instances within the container. The <code>single</code> scope creates singleton instances that persist throughout the entire application, making it suitable for objects requiring a globally shared state, such as database instances. <code>Factory</code> scope generates new instances each time they are requested, fitting stateless utility classes or objects that don’t need to maintain a persistent state. The <code>scoped</code> scope ties instances to specific contexts, such as activity or fragment lifecycles, allowing them to be shared within a designated scope but recreated for different contexts. The <code>single</code> scope is particularly useful for managing global or long-lived dependencies efficiently, ensuring a single instance is shared consistently across various components of the application, thereby optimizing resource usage and<a id="_idIndexMarker250"/> maintaining a unified state. This is why we are using <code>single</code> to create an instance of our <code>PetsRepository</code> class. We are using the <code>PetsRepositoryImpl</code> class as the implementation of the <code>PetsRepository</code> interface.</p>
			<p>Next, we will refactor our <code>PetsViewModel</code> class to use dependency injection. Open the <code>PetsViewModel</code> class and update it as shown in the following code snippet:</p>
			<pre class="source-code">
class PetsViewModel(
    private val petsRepository: PetsRepository
): ViewModel() {
    fun getPets() = petsRepository.getPets()
}</pre>			<p>In the preceding code, we have removed the instantiation of the <code>PetsRepository</code> class from the <code>PetsViewModel</code> class. We have, instead, added a <code>constructor</code> that takes a <code>PetsRepository</code> parameter. We also need to create a new dependency for <code>ViewModel</code>, just below the <code>PetsRepository</code> dependency in our <code>appModules</code> variable. Let us add the following code:</p>
			<pre class="source-code">
single { PetsViewModel(get()) }</pre>			<p>Here, we are creating a <code>single</code> instance of the <code>PetsViewModel</code> class. We are using the <code>get()</code> function to get the <code>PetsRepository</code> dependency. We are passing it to the constructor of the <code>PetsViewModel</code> class. With this, our app is ready to use these dependencies. We will also change the way we create the <code>PetsViewModel</code> instance in our <code>PetList</code> composable. Open the <code>PetList</code> composable and update the initialization of <code>PetsViewModel</code>, as shown here:</p>
			<pre class="source-code">
val petsViewModel: PetsViewModel = koinViewModel()</pre>			<p>Instead of using the <code>ViewModel()</code> function from the lifecycle library, we are using the <code>koinViewModel()</code> function from the Koin library. This function helps us create an instance of the <code>PetsViewModel</code> class. This now returns an instance of <code>PetsViewModel</code> that has the <code>PetsRepository</code> dependency injected.</p>
			<p>The last step in ensuring our <a id="_idIndexMarker251"/>app has dependency injection setup is to initialize Koin in our app. We will create a class that extends the <code>Application</code> class and initialize Koin in the <code>onCreate()</code> method. Create a new file named <code>ChapterFiveApplication</code> and add the following code:</p>
			<pre class="source-code">
class ChapterFiveApplication: Application() {
    override fun onCreate() {
        super.onCreate()
        startKoin {
            modules(appModules)
        }
    }
}</pre>			<p>Our <code>ChapterFiveApplication</code> class extends the <code>Application</code> class. We are overriding the <code>onCreate()</code> method and calling the <code>startKoin()</code> function. We are using the <code>modules</code> parameter to pass in the <code>appModules</code> variable that we created earlier on. This initializes Koin in our app. We also need to update the <code>AndroidManifest.xml</code> file to use our <code>ChapterFiveApplication</code> class. Open the <code>AndroidManifest.xml</code> file and update the application tag with the name attribute, as shown here:</p>
			<pre class="source-code">
android:name=".ChapterFiveApplication"</pre>			<p>We are passing the name of our <code>ChapterFiveApplication</code> class to the name attribute. Now, if you run <a id="_idIndexMarker252"/>the app, it still runs as before, but this time, it uses dependency injection.</p>
			<p>Now that we understand what dependency injection is and how to use it in our apps, let us look at <strong class="bold">Kotlin Gradle DSL</strong> and how we can use <strong class="bold">version catalogs</strong> to manage our dependencies.</p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor079"/>Migrating to Kotlin Gradle DSL and using version catalogs</h1>
			<p>In <a href="B19779_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, one of the<a id="_idIndexMarker253"/> advantages of using Kotlin that we listed is that we can also write our Gradle files in Kotlin. In this section, we will look at how we can migrate our Gradle files to Kotlin Gradle DSL. We will also look at how we can use a version catalog to manage our dependencies.</p>
			<p>Before we migrate, let’s see some of the benefits we get from using Kotlin Gradle DSL:</p>
			<ul>
				<li><strong class="bold">Code autocompletion</strong>: We<a id="_idIndexMarker254"/> get hints about the completion of our code in Gradle files as we are using Kotlin.</li>
				<li><strong class="bold">Type safety</strong>: We get compile time errors when we make mistakes in our Gradle files.</li>
				<li><strong class="bold">Function calls and variable assignments</strong>: We can use functions and variables in our Gradle files the same way we use them in our Kotlin code. It makes it even easier for us to write and understand.</li>
				<li><strong class="bold">Compile time errors</strong>: We get errors at compile time when we make mistakes in our Gradle files. This helps us avoid runtime errors when building our apps.</li>
				<li><strong class="bold">Official Android Studio Support</strong>: From Android Studio Giraffe onwards, Kotlin Gradle DSL is the recommended way of creating our Gradle files. It is also the default way of <a id="_idIndexMarker255"/>creating our Gradle files in Android Studio Giraffe onwards.</li>
			</ul>
			<p>So many benefits, right? Let’s now migrate our app so as to use Kotlin Gradle DSL.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor080"/>Migrating our app to Kotlin Gradle DSL</h2>
			<p class="callout-heading">Important note</p>
			<p class="callout">If your apps already use Kotlin Gradle DSL, you can skip this section.</p>
			<p>Follow these steps to <a id="_idIndexMarker256"/>migrate your app to Kotlin Gradle DSL:</p>
			<ol>
				<li>First, we have to rename all our Gradle files to have a <code>.kts</code> extension, which allows our IDE to recognize them as Kotlin Gradle files. Rename the <code>build.gradle(Project : chapterfive)</code>, <code>build.gradle(Module: app)</code>, and <code>settings.gradle</code> files to <code>build.gradle.kts(Project: chapterfive)</code>, <code>build.gradle.kts(Module: app)</code>, and <code>settings.gradle.kts</code>, respectively. This allows us to use Kotlin in our Gradle files now.</li>
				<li>After renaming the files, we have to update their content to use Kotlin Gradle DSL. Let’s start with the <code>settings.gradle.kts</code> file. Open the <code>settings.gradle.kts</code> file and update it, as shown in the following code:<pre class="source-code">
pluginManagement {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
    }
}
rootProject.name = "chapterfive"
include(":app")</pre></li>				<li>Next, update the <code>build.gradle.kts(Module: app)</code> file, as shown in the following <a id="_idIndexMarker257"/>code:<pre class="source-code">
plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
}
android {
    namespace = "com.packt.chapterfive"
    compileSdk = 33
    defaultConfig {
        applicationId = "com.packt.chapterfive"
        minSdk = 24
        targetSdk = 33
        versionCode = 1
        versionName = "1.0"
        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
        vectorDrawables {
            useSupportLibrary = true
        }
    }
    buildTypes {
        release {
            isMinifyEnabled = false
            setProguardFiles(
                listOf(
                    getDefaultProguardFile("proguard-android.txt"),
                    "proguard-rules.pro"
                )
            )
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
    }
    kotlinOptions {
        jvmTarget = "1.8"
    }
    buildFeatures {
        compose = true
    }
    composeOptions {
        kotlinCompilerExtensionVersion = "1.4.6"
    }
    packagingOptions {
        resources {
            pickFirsts.add("META-INF/AL2.0")
            pickFirsts.add("META-INF/LGPL2.1")
        }
    }
}
dependencies {
    implementation("androidx.core:core-ktx:1.10.1")
    implementation(platform("org.jetbrains.kotlin:kotlin-bom:1.8.0"))
    implementation("androidx.lifecycle:lifecycle-runtime-ktx:2.6.1")
    implementation("androidx.activity:activity-compose:1.7.2")
    implementation(platform("androidx.compose:compose-bom:2022.10.00"))
    implementation("androidx.compose.ui:ui")
    implementation("androidx.compose.ui:ui-graphics")
    implementation("androidx.compose.ui:ui-tooling-preview")
    implementation("androidx.compose.material3:material3")
    implementation("androidx.lifecycle:lifecycle-viewmodel-compose")
    implementation("io.insert-koin:koin-core:3.4.3")
    implementation("io.insert-koin:koin-android:3.4.3")
    implementation("io.insert-koin:koin-androidx-compose:3.4.6")
    testImplementation("junit:junit:4.13.2")
    androidTestImplementation("androidx.test.ext:junit:1.1.5")
    androidTestImplementation("androidx.test.espresso:espresso-core:3.5.1")
    androidTestImplementation(platform("androidx.compose:compose-bom:2022.10.00"))
    androidTestImplementation("androidx.compose.ui:ui-test-junit4")
    debugImplementation("androidx.compose.ui:ui-tooling")
    debugImplementation("androidx.compose.ui:ui-test-manifest")
}</pre></li>				<li>Lastly, update the <code>build.gradle.kts(Project: chapterfive)</code> file, as shown in the following snippet:<pre class="source-code">
plugins {
    id("com.android.application") version "8.1.0" apply false
    id("com.android.library") version "8.1.0" apply false
    id("org.jetbrains.kotlin.android") version "1.8.20" apply false
}</pre></li>			</ol>
			<p>After updating the files, we have to sync the project. We can do this by clicking on the Sync prompt that appears in the top right corner of the IDE. After syncing the project, we can now run the app, and it should run as before. We have now successfully migrated our app to use Kotlin<a id="_idIndexMarker258"/> Gradle DSL. You can also see that the syntax highlighting and the colors of the functions, methods, and variables change to reflect the Kotlin syntax. Some key changes about this migration to highlight are the following:</p>
			<ul>
				<li>To assign values to properties, we have to use the <code>=</code> operator specifically. For example, <code>minSdk 24</code> changes to <code>minSdk = </code><code>24</code>.</li>
				<li>In our <code>android</code> config block, <code>namespace 'com.packt.chapterfive'</code> changes to  <code>namespace = "com.packt.chapterfive"</code>. In Kotlin, we define strings using double quotes; that’s why we have to change the single quotes to double quotes in all the places we have strings.</li>
				<li>In defining our dependencies, we have to use double quotes too. For example,  <code>implementation 'androidx.activity:activity-compose:1.7.2'</code>  changes to <code>implementation("androidx.activity:activity-compose:1.7.2")</code>.</li>
				<li>Similarly, defining our plugins in the <code>plugins</code> block changes. For example, <code>id 'org.jetbrains.kotlin.android'</code> changes to <code>id("org.jetbrains.kotlin.android")</code>.</li>
			</ul>
			<p>Our project had minimal Gradle configurations, so if you have a complex project, you might need to do <a id="_idIndexMarker259"/>more migration; you can have a look at the Migrate to Kotlin DSL official documentation (<a href="https://developer.android.com/build/migrate-to-kotlin-dsl">https://developer.android.com/build/migrate-to-kotlin-dsl</a>) for more examples.</p>
			<p>We have now migrated our app to use Kotlin Gradle DSL. In the next subsection, let’s look at how we can use a <strong class="bold">versions catalog</strong> to manage our dependencies.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor081"/>Using a versions catalog</h2>
			<p>Quoting from the official documentation (<a href="https://docs.gradle.org/current/userguide/platforms.html">https://docs.gradle.org/current/userguide/platforms.html</a>), a version catalog is a list of dependencies, represented as dependency co-ordinates, that a user can pick from when declaring<a id="_idIndexMarker260"/> dependencies in a build script. It helps us easily manage our <a id="_idIndexMarker261"/>dependencies and their versions in one central place. Currently, you can see that we define all our dependencies and their versions in our app-level <code>build.gradle.kts</code> file. Over time, and as you add more modules to your app, it becomes hard to share these dependencies, and we can find ourselves in situations where different modules have different versions of a similar dependency. This is where version catalogs come in to help us. Let’s see all the benefits that they offer:</p>
			<ul>
				<li>They provide a central place to manage all our dependencies and their versions. They make it easier to share the dependencies across the project</li>
				<li>They have a simple and easy-to-use syntax</li>
				<li>They show hints for dependencies that need to be updated</li>
				<li>They make it easier to make changes, and these changes do not recompile the whole project, meaning the builds are faster</li>
				<li>We can bundle dependencies together and share them across the project</li>
				<li>They have official support and are recommended by Google to be used from Android Studio Giraffe going forward</li>
			</ul>
			<p>Let’s now see how we can use a version catalog in our app. In the <code>gradle</code> folder, create a new file named <code>libs.versions.toml</code>. In this file, here are some basic rules that we will follow:</p>
			<ul>
				<li>We can use separators, such as -, _v, and . , that will be normalized by Gradle to “.” in the Catalog, allowing<a id="_idIndexMarker262"/> us to create subsections.</li>
				<li>We define variables using **CamelCase**.</li>
				<li>For libraries, we normally check if we can add them to any existing bundles. For new libraries that are <a id="_idIndexMarker263"/>normally used together, we can create a new bundle for them.</li>
			</ul>
			<p>We will start by defining the versions for our dependencies as follows:</p>
			<pre class="source-code">
[versions]
coreKtx = "1.10.1"
lifecycle = "2.6.1"
activity = "1.7.2"
composeBom = "2022.10.00"
koin = "3.4.3"
koinCompose = "3.4.6"
junit = "4.13.2"
junitExt = "1.1.5"
espresso = "3.5.1"</pre>			<p>Here, we are defining all the versions for the libraries that are in our app. We use the <strong class="bold">versions</strong> keyword to define the<a id="_idIndexMarker264"/> versions. We then define the versions for each library. As we edit this file, you will notice that the IDE prompts you to do a Gradle sync for our changes to be added to the project. For now, we can ignore this and continue editing the file. Next, we will <a id="_idIndexMarker265"/>define the bundles for our<a id="_idIndexMarker266"/> dependencies:</p>
			<pre class="source-code">
[libraries]
core-ktx = { module = "androidx.core:core-ktx", version.ref = "coreKtx" }
lifecycle = { module = "androidx.lifecycle:lifecycle-runtime-ktx", version.ref = "lifecycle" }
activity-compose = { module = "androidx.activity:activity-compose", version.ref = "activity" }
compose-bom = { group = "androidx.compose", name = "compose-bom", version.ref = "composeBom" }
compose-ui = { group = "androidx.compose.ui", name = "ui" }
compose-ui-graphics = { group = "androidx.compose.ui", name = "ui-graphics" }
compose-ui-tooling = { group = "androidx.compose.ui", name = "ui-tooling" }
compose-material3 = { group = "androidx.compose.material3", name = "material3" }
compose-manifest = { group = "androidx.compose.ui", name = "ui-test-manifest" }
compose-viewmodel = { module = "androidx.lifecycle:lifecycle-viewmodel-compose", version.ref = "lifecycle" }
koin-core = { module = "io.insert-koin:koin-core", version.ref = "koin" }
koin-android = { module = "io.insert-koin:koin-android", version.ref = "koin" }
koin-android-compose = { module = "io.insert-koin:koin-androidx-compose", version.ref = "koinCompose" }
test-junit = { module = "junit:junit", version.ref = "junit" }
test-junitExt = { module = "androidx.test.ext:junit", version.ref = "junitExt" }
test-espresso = { module = "androidx.test.espresso:espresso-core", version.ref = "espresso" }
test-compose-junit4 = { group = "androidx.compose.ui:ui-test-junit4", name = "ui-test-junit4" }</pre>			<p>Here, we <a id="_idTextAnchor082"/>have defined all the <a id="_idIndexMarker267"/>dependencies in our project using<a id="_idIndexMarker268"/> the <strong class="bold">libraries</strong> keyword.</p>
			<p>Next, let’s use the <strong class="bold">bundles</strong> keyword to <a id="_idIndexMarker269"/>create a bundle for Koin and compose dependencies as<a id="_idIndexMarker270"/> follows:</p>
			<pre class="source-code">
[bundles]
compose = ["compose.ui", "compose.ui.graphics", "compose.ui.tooling", "compose.material3", "compose.viewmodel"]
koin = ["koin-core", "koin-android", "koin-android-compose"]</pre>			<p>The <code>bundles</code> keyword allows us to group dependencies and use them as one. Now, we can sync the project. The last step is to update our app-level <code>build.gradle.kts</code> file to use the version catalog. Open the app-level <code>build.gradle.kts</code> file and update the dependencies block as follows:</p>
			<pre class="source-code">
dependencies {
    implementation(libs.core.ktx)
    implementation(libs.lifecycle)
    implementation(libs.activity.compose)
    implementation(platform(libs.compose.bom))
    implementation(libs.bundles.compose)
    implementation(libs.bundles.koin)
    testImplementation(libs.test.junit)
    androidTestImplementation(libs.test.junitExt)
    androidTestImplementation(libs.test.espresso)
    androidTestImplementation(platform(libs.compose.bom))
    androidTestImplementation(libs.test.compose.junit4)
    debugImplementation(libs.compose.ui.tooling)
    debugImplementation(libs.compose.manifest)
}</pre>			<p>We can now access the <a id="_idIndexMarker271"/>dependencies from our versions catalog file. Notice we must start with the <strong class="bold">libs</strong> keyword, and the next part is the names of the bundles or the dependencies, as per<a id="_idIndexMarker272"/> our version <a id="_idIndexMarker273"/>catalog. After adding these changes, we can now do Gradle sync. Build and run the app. The app displays a list of pets, as before, and nothing changes since we were only refactoring the dependencies.</p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor083"/>Summary</h1>
			<p>In this chapter, we have built on what we learned from the previous chapters. We looked at the different architectures available for Android projects. We dived deep into MVVM architecture and its different layers and how to use some of the Jetpack libraries in this architecture. Additionally, we learned how to use advanced architecture features such as dependency injection and Kotlin Gradle DSL, as well as using Gradle version catalogs to define our dependencies.</p>
			<p>As we were creating the MVVM architecture, we used dummy pet data for our data layer. In the next chapter, we are going to learn how to make network calls to fetch data and display it in our app.</p>
		</div>
	</div></div></body></html>