<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer080">
			<h1 id="_idParaDest-61" class="chapter-number"><a id="_idTextAnchor067"/>5</h1>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor068"/>Architect Your App</h1>
			<p>The process of developing apps needs to be scalable in such a way that you can maintain the app over a long time and easily hand over the development of it to other developers or teams. To be able to do this, we need to properly think about the architecture of our apps. We will be looking at how to build our apps in <span class="No-Break">this chapter.</span></p>
			<p>In this chapter, we will build on what we’ve learned from the previous chapters. We are going to look at the different architectures available for Android projects. We’ll dive deep into <strong class="bold">MVVM architecture</strong> and its different layers and how to use some of the Jetpack libraries within their architecture. Additionally, we’ll learn how to use advanced architecture features, such as dependency injection and Kotlin Gradle DSL, as well as version catalogs to <span class="No-Break">define dependencies.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Introduction to <span class="No-Break">app architecture</span></li>
				<li>MVVM <span class="No-Break">deep dive</span></li>
				<li><span class="No-Break">Jetpack libraries</span></li>
				<li><span class="No-Break">Dependency injection</span></li>
				<li>Migrating to Kotlin Gradle DSL and using <span class="No-Break">version catalogs</span></li>
			</ul>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor069"/>Technical Requirements</h1>
			<p><a id="_idTextAnchor070"/>To follow the instructions in this chapter, you will need to have Android Studio Hedgehog or later (<a href="https://developer.android.com/studio">https://developer.android.com/studio</a>) downloaded. </p>
			<p>You can find the code for this chapter <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfive"><span class="No-Break">https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfive</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor071"/>Introduction to app architecture</h1>
			<p>So far, we have learned how to create apps and designed beautiful UIs with Material 3 and Jetpack Compose. We haven’t yet started adopting any architecture for our apps. In this section, we will look at some of the app architectures that we can use to build our apps. We will also look at some of the best practices that we can follow when building our apps. First, let’s see some of the benefits of using an <span class="No-Break">app architecture:</span></p>
			<ul>
				<li><strong class="bold">Separation of concerns</strong>: Using an architecture allows us to separate our code into different layers. Each<a id="_idIndexMarker207"/> layer only does one thing. This makes it easy to separate and group our code into different layers. Each layer has its responsibility. This prevents things from being mixed up and makes it easier to maintain <span class="No-Break">our code.</span></li>
				<li><strong class="bold">Easy testing</strong>: Using an architecture makes it easy to test our code. We can easily test each layer of our code in isolation since things are not <span class="No-Break">tightly coupled.</span></li>
				<li><strong class="bold">Easy to maintain</strong>: Using an architecture makes it easy to maintain our code. We can easily make changes to our code without affecting other parts of our code. This makes it easy to maintain our code over the long term. We can also swap in and out different parts of the code, and since we have tests, we can test the different implementations and ensure that <span class="No-Break">nothing breaks.</span></li>
				<li><strong class="bold">Easy to scale</strong>: Using an architecture makes it easy to scale our code. We can easily add new features to our code without affecting other parts of <span class="No-Break">our code.</span></li>
				<li><strong class="bold">Easy to work in teams</strong>: Using an architecture makes it easy to work in teams. Each team member or team can work on a different layer of the code. It makes it possible to work concurrently on different parts of <span class="No-Break">the codebase.</span></li>
				<li><strong class="bold">Promotes reusability</strong>: Over time, we can place some of the commonly used code across the projects in common packages or modules, which can then be re-used across the project without having to repeat <span class="No-Break">the code.</span></li>
			</ul>
			<p>When it comes to choosing an architecture for our apps, there are a lot of options that we can choose from. There isn’t a particular architecture that fits all the use cases, so it’s always recommended that we discuss things with our teams and see which architecture fits the use case. Each architecture has its pros and cons, and we or the whole team have to evaluate which one<a id="_idIndexMarker208"/> has more pros than cons. We can architect our app either by feature or by layers. When we architect by feature, we have layers that represent a feature. When we architect by layers, we have layers that represent a layer of our app. An example of architecting by feature is shown in the <span class="No-Break">following points:</span></p>
			<ul>
				<li><span class="No-Break">Home feature</span></li>
				<li><span class="No-Break">Profile feature</span></li>
				<li><span class="No-Break">Settings feature</span></li>
			</ul>
			<p>The preceding example shows how we can architect our app by feature. We have the <strong class="bold">Home</strong>, <strong class="bold">Profile</strong>, and <strong class="bold">Settings</strong> features. Each feature has its layers and all the code related to <span class="No-Break">that feature.</span></p>
			<p>Some of the architectures that we can use to build our apps are <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Model, View, and ViewModel</strong> (<strong class="bold">MVVM</strong>): This is the most commonly used architecture and is even <a id="_idIndexMarker209"/>recommended by Google to use with our apps. The app has the <strong class="bold">Model</strong> <strong class="bold">View</strong> and <strong class="bold">ViewModel</strong> layers. The Model layer is responsible for holding the data. The View layer is responsible for displaying the data. The ViewModel layer is responsible for holding the state of the data. It is also responsible for communicating with the <a id="_idIndexMarker210"/>Model and View layers. MMVM promotes the clear separation of concerns between the different layers. It also <a id="_idIndexMarker211"/>supports <strong class="bold">data binding</strong>, which makes it easy to update the UI when the data change. It also supports testing since the different layers are not tightly coupled. It also has less boilerplate code when compared to other architectures. However, it has its downsides, one of them being a large learning curve at times and this can become complex very easily, especially with lots <span class="No-Break">of features.</span></li>
				<li><strong class="bold">Model View Intent</strong> (<strong class="bold">MVI</strong>): This has three key layers. The <strong class="bold">Model</strong> layer is responsible for holding the data. The <strong class="bold">View</strong> layer is responsible for displaying the data. The <strong class="bold">Intent</strong> layer represents <a id="_idIndexMarker212"/>user actions or events that are dispatched to<a id="_idIndexMarker213"/> the model to update a state. MVI promotes unidirectional <strong class="bold">data flow</strong>, where data flow in the <span class="No-Break">same direction.</span></li>
				<li><strong class="bold">Model View Controller</strong> (<strong class="bold">MVC</strong>): This architecture has three layers. The <strong class="bold">Model</strong> layer represents the business logic and holds the data. The <strong class="bold">View</strong> layer is responsible for displaying the data. The <strong class="bold">Controller</strong> layer is responsible for and acts as an intermediary<a id="_idIndexMarker214"/> between the model and the view. It takes care of the user input and updates the view and the model. MVC is very straightforward, especially when starting out, and enables quick iterations and a showcase of app architecture. Its only problem is that it has a tight coupling between the layers, making it hard to test <span class="No-Break">and scale.</span></li>
				<li><strong class="bold">Model View Presenter</strong> (<strong class="bold">MVP</strong>): This architecture has three layers. The <strong class="bold">Model</strong> layer represents the business logic and holds the data. The <strong class="bold">View</strong> layer displays the data and UI components<a id="_idIndexMarker215"/> and observes user interactions. The views delegate all UI-related logic to the presenters. The <strong class="bold">Presenter</strong> layer contains presentation logic and acts as an intermediary between the<a id="_idIndexMarker216"/> model and the view. It processes the user input and updates the view and the model. MVP has a good separation of concerns, and the code is easily testable. However, it has a lot of boilerplate code since every view must have its own presenter. It also has a large learning curve and can become complex <span class="No-Break">very easily.</span></li>
			</ul>
			<p>Now that we understand the different architectures, let us look at MVVM and how we can use it in <span class="No-Break">our apps.</span></p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor072"/>Deep Diving into MVVM</h1>
			<p>We have already seen the MVVM layers and their pros and cons. In this section, we are going to implement the MMVM architecture in our app step by step. We will start with the model layer, going upwards. Since we all love to have the company of our pets, we are going to use different <a id="_idIndexMarker217"/>types of pets as <span class="No-Break">our data.</span></p>
			<p>Let us start by creating a <strong class="bold">data</strong> package for our project. We’ll do this by right-clicking the <strong class="source-inline">com.packt.chapterfive</strong> package; then, we select <strong class="bold">New | Package</strong> and name it <strong class="source-inline">data</strong>. Inside this <strong class="source-inline">data</strong> package, let us create a <strong class="source-inline">Pet</strong> data class that will represent <span class="No-Break">our pets:</span></p>
			<pre class="source-code">
data class Pet(
    val id: Int,
    val name: String,
    val species: String
)</pre>			<p>The <strong class="source-inline">Pet</strong> data class holds all the data for our pets. Next, we will create a repository interface and its implementation that allows us to get these pets. Create a new file named <strong class="source-inline">PetsRepository</strong> inside the <strong class="source-inline">data</strong> package with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
interface PetsRepository {
    fun getPets(): List&lt;Pet&gt;
}</pre>			<p>This is an interface with one method that returns <strong class="source-inline">List&lt;Pet&gt;</strong>. Next, let us create the implementation class for our interface. While still inside the <strong class="source-inline">data</strong> package, create a new file named <strong class="source-inline">PetsRepositoryImpl</strong> with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
class PetsRepositoryImpl: PetsRepository {
    override fun getPets(): List&lt;Pet&gt; {
        return listOf(
            Pet(1, "Bella", "Dog"),
            Pet(2, "Luna", "Cat"),
            Pet(3, "Charlie", "Dog"),
            Pet(4, "Lucy", "Cat"),
            Pet(5, "Cooper", "Dog"),
            Pet(6, "Max", "Cat"),
            Pet(7, "Bailey", "Dog"),
            Pet(8, "Daisy", "Cat"),
            Pet(9, "Sadie", "Dog"),
            Pet(10, "Lily", "Cat"),
        )
    }
}</pre>			<p>To explain what the preceding<a id="_idIndexMarker218"/> code does, please see <span class="No-Break">the following:</span></p>
			<ul>
				<li>We created a class named <strong class="source-inline">PetsRepositoryImpl</strong>, which implements the <span class="No-Break"><strong class="source-inline">PetsRepository</strong></span><span class="No-Break"> interface</span></li>
				<li>We override the <strong class="source-inline">getPets()</strong> method and return a list of pets. Our list has 10 pets with <strong class="bold">ID</strong>, <strong class="bold">name</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="bold">species</strong></span></li>
			</ul>
			<p>We have used a pattern <a id="_idIndexMarker219"/>called the <strong class="bold">repository pattern</strong> to get our pets. The repository pattern is a pattern that allows us to abstract the data layer from the rest of the app. It allows us to get data from different sources without affecting the rest of the app. For example, we can get data from a local database or a remote server. The class is responsible for merging the data from the two sources and maintaining the source of truth for our data. The repository pattern also allows us to easily test our code since we can easily mock the repository and test the different layers of our app in isolation. Since our app is very simple at the moment, we have already completed the data/model layer of <span class="No-Break">our architecture.</span></p>
			<p>Let us now create a <strong class="source-inline">ViewModel</strong> class for our <strong class="source-inline">ViewModel</strong> layer. Start by creating a <strong class="source-inline">ViewModel</strong> package inside the <strong class="source-inline">com.packt.chapterfive</strong> package. Inside this <strong class="source-inline">ViewModel</strong> package, create a <a id="_idIndexMarker220"/>new file named <strong class="source-inline">PetsViewModel</strong> with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
class PetsViewModel: ViewModel() {
    private val petsRepository: PetsRepository = PetsRepositoryImpl()
    fun getPets() = petsRepository.getPets()
}</pre>			<p>To explain what the preceding code does, please see <span class="No-Break">the following:</span></p>
			<ul>
				<li>We created a class named <strong class="source-inline">PetsViewModel</strong> that extends the <strong class="source-inline">ViewModel</strong> class. This is a class <a id="_idIndexMarker221"/>from the <strong class="bold">Jetpack libraries</strong>. It helps data persist across configuration changes. It also acts as the intermediary between the View and the Model layers. We use it to expose data to our views, act on user interactions, and update the data in the <span class="No-Break">Model layer.</span></li>
				<li>We created a private property named <strong class="source-inline">petsRepository</strong> of type <strong class="source-inline">PetsRepository</strong> and initialized it with an instance of <strong class="source-inline">PetsRepositoryImpl</strong>. This is the repository we <span class="No-Break">created earlier.</span></li>
				<li>We created a method named <strong class="source-inline">getPets()</strong> that returns a list of pets. We called the <strong class="source-inline">getPets()</strong> method from the <strong class="source-inline">petsRepository</strong> property and returned <span class="No-Break">the result.</span></li>
			</ul>
			<p>With this, our <strong class="source-inline">ViewModel</strong> layer is ready to expose data to our views. Our <strong class="source-inline">getPets()</strong> method returns a list of pets. To <a id="_idIndexMarker222"/>display the list in <strong class="bold">Jetpack Compose</strong>, we use a <strong class="source-inline">LazyColumn</strong> composable. <strong class="source-inline">LazyColumn</strong> follows a lazy-loading approach, meaning that only the items currently visible<a id="_idIndexMarker223"/> on the screen are actively composed, reducing resource usage and improving performance. Let us see how a <strong class="source-inline">LazyColumn</strong> works under <span class="No-Break">the hood.</span></p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor073"/>How LazyColumn works</h2>
			<p>This is how a <span class="No-Break"><strong class="source-inline">LazyColumn</strong></span><span class="No-Break"> works:</span></p>
			<ul>
				<li><strong class="bold">On-demand composing</strong>: <strong class="source-inline">LazyColumn</strong> composes only the visible items on the screen. As the user<a id="_idIndexMarker224"/> scrolls, it dynamically composes and recomposes items, ensuring that only the necessary elements <a id="_idIndexMarker225"/>are rendered at any <span class="No-Break">given time.</span></li>
				<li><strong class="bold">Recycling items</strong>: Similar to the recycling mechanism in <strong class="source-inline">RecyclerView</strong>, <strong class="source-inline">LazyColumn</strong> reuses composables that move in and out of the viewport, minimizing memory usage and preventing <span class="No-Break">unnecessary recomposition.</span></li>
				<li><strong class="bold">Optimized for performance</strong>: By lazily loading and recycling items, <strong class="source-inline">LazyColumn</strong> optimizes the rendering process, making it well-suited for displaying large datasets without consuming <span class="No-Break">excessive resources.</span></li>
			</ul>
			<p>Now that we know how <strong class="source-inline">LazyColumn</strong> works, let’s see the benefits of <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">LazyColumn</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor074"/>Benefits of LazyColumn</h2>
			<p>Some of the <a id="_idIndexMarker226"/>benefits of <strong class="source-inline">LazyColumn</strong> are <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Efficient memory usage</strong>: <strong class="source-inline">LazyColumn</strong> efficiently manages memory by composing only the visible items, ensuring that the app does not unnecessarily store and render all items in a list at once. This is particularly beneficial for long lists or lists with complex <span class="No-Break">UI elements.</span></li>
				<li><strong class="bold">Improved rendering performance</strong>: The lazy-loading mechanism significantly improves rendering performance, especially when dealing with extensive datasets. It avoids the overhead of rendering and managing all items simultaneously, resulting in smoother scrolling and <span class="No-Break">reduced lag.</span></li>
				<li><strong class="bold">Simplified UI code</strong>: The declarative nature of Jetpack Compose, coupled with <strong class="source-inline">LazyColumn</strong>, allows us to express UI logic concisely. The code to create and manage large lists becomes <a id="_idIndexMarker227"/>more straightforward and readable compared to traditional Android <span class="No-Break">View approaches.</span></li>
				<li><strong class="bold">Automatic recomposition</strong>: As the data source changes, <strong class="source-inline">LazyColumn</strong> automatically recomposes only the affected items, reducing the need for manual interventions to update <span class="No-Break">the UI.</span></li>
				<li><strong class="bold">Adaptable for various screen sizes</strong>: <strong class="source-inline">LazyColumn</strong> adapts well to different screen sizes and resolutions, offering a consistent and responsive user experience across <span class="No-Break">various devices.</span></li>
			</ul>
			<p>Now, we’re going to create a composable that <span class="No-Break">displays pets.</span></p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor075"/>Creating a composable</h2>
			<p>Follow these steps to <a id="_idIndexMarker228"/>create <span class="No-Break">a composable:</span></p>
			<ol>
				<li>Create a new<a id="_idIndexMarker229"/> package named <strong class="source-inline">views</strong> inside the <span class="No-Break"><strong class="source-inline">com.packt.chapterfive</strong></span><span class="No-Break"> package.</span></li>
				<li>Inside this <strong class="source-inline">views</strong> package, create a new file named <strong class="source-inline">PetsList</strong> with the <span class="No-Break">following code:</span><pre class="source-code">
@Composable
fun PetList(modifier: Modifier) {
    val petsViewModel: PetsViewModel = viewModel()
    LazyColumn(
        modifier = modifier
    ) {
        items(petsViewModel.getPets()) { pet -&gt;
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(10.dp),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text(text = "Name: ${pet.name}")
                Text(text = "Species: ${pet.species}")
            }
        }
    }
}</pre><p class="list-inset">Here, we have created a composable named <strong class="source-inline">PetList</strong> that takes a modifier as a parameter. We then <a id="_idIndexMarker230"/>create an instance of <strong class="source-inline">PetsViewModel</strong> using the <strong class="source-inline">viewModel()</strong> function from the lifecycle utility library for <strong class="source-inline">ViewModel</strong> in compose. It helps us easily <a id="_idIndexMarker231"/>create an instance of our <strong class="source-inline">PetsViewModel</strong>. We then use the <strong class="source-inline">LazyColumn</strong> composable to display the pets. We pass the list of pets from the <strong class="source-inline">ViewModel</strong> to the <strong class="source-inline">items</strong> parameter of the <strong class="source-inline">LazyColumn</strong>. We then use the <strong class="source-inline">Row</strong> composable to display the name and species of each pet. We have now completed the view layer of <span class="No-Break">our architecture.</span></p></li>				<li>To finally display our pets, we need to call our <strong class="source-inline">PetList</strong> composable inside the <strong class="source-inline">setContent</strong> block<a id="_idIndexMarker232"/> of our <span class="No-Break"><strong class="source-inline">MainActivity</strong></span><span class="No-Break"> class:</span><pre class="source-code">
ChapterFiveTheme {
    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                   Text(text = "Pets")
                },
                colors =  TopAppBarDefaults.smallTopAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                )
            )
        },
        content =  { paddingValues -&gt;
            PetList(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues)
            )
        }
    )
}</pre><p class="list-inset">We are using the <strong class="source-inline">Scaffold</strong> composable, which we are already familiar with. In our <strong class="source-inline">Scaffold</strong>, we are passing<a id="_idIndexMarker233"/> in a <strong class="source-inline">TopAppBar</strong> and our <strong class="source-inline">PetList</strong> composable. We are also passing in <strong class="source-inline">paddingValues</strong> to our <strong class="source-inline">PetList</strong> composable. This is because we are using <strong class="source-inline">paddingValues</strong> to add padding to our <strong class="source-inline">PetList</strong> composable. We<a id="_idIndexMarker234"/> have now completed the MVVM architecture in our app. Let’s run the app and see <span class="No-Break">the result:</span></p></li>			</ol>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/B19779_05_01.jpg" alt="Figure 5.1 – Pet list" width="493" height="657"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Pet list</p>
			<p>As seen from the preceding image, we have our list of pets with their name and species displayed in <span class="No-Break">a list.</span></p>
			<p>We have mentioned <strong class="bold">Jetpack libraries</strong> a lot in this<a id="_idIndexMarker235"/> section but have not explained what they are. In the next section, we are going to look at Jetpack libraries <span class="No-Break">in detail.</span></p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor076"/>Jetpack libraries</h1>
			<p>Jetpack Libraries are a collection of libraries and APIs from Google that help us developers create better apps using less code. They are normally created to address some pain points we, as <a id="_idIndexMarker236"/>developers, face while creating our apps. Let’s look at some of these pain points and some of the Jetpack libraries that were created to <span class="No-Break">address them:</span></p>
			<ul>
				<li><strong class="bold">Storing data locally and observing changes to the data</strong>: We had to use <strong class="bold">SQLite</strong> to store data locally. Even for simple <strong class="bold">Create</strong>, <strong class="bold">Read</strong>, <strong class="bold">Update</strong>, and <strong class="bold">Delete</strong> (<strong class="bold">CRUD</strong>) operations, we had to write a lot of boilerplate code. We also had to write a lot of code to<a id="_idIndexMarker237"/> observe changes to the data. This is <a id="_idIndexMarker238"/>a lot of work for a simple task. Jetpack libraries, such as <strong class="bold">Room</strong> and <strong class="bold">LiveData</strong>, were created to address this pain point. Room is a library that allows us to easily store data locally. It also allows us to easily observe changes to the data. LiveData is a library that allows us to observe changes to data easily. It is also lifecycle-aware. This means it automatically stops observing data changes when the lifecycle of the component observing the data ends. This helps us avoid memory leaks in our apps. Room<a id="_idIndexMarker239"/> also has support for <strong class="bold">Kotlin Coroutines</strong>, which we will be looking at deeply in <a href="B19779_06.xhtml#_idTextAnchor084"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>. This makes it easy to store and access data locally with less <span class="No-Break">boilerplate code.</span></li>
				<li><strong class="bold">Navigation was a challenging thing to achieve perfectly in our apps</strong>: Lots of open-source libraries were created to solve this pain point. It also required a lot of boilerplate code to navigate between activities and fragments and maintain consistent and predictable<a id="_idIndexMarker240"/> back behavior. <strong class="bold">Jetpack Navigation</strong> was created to address this pain point. It allows us to navigate between screens in our app easily. It also allows us to easily maintain consistent and predictable back behavior. It also allows us to pass data between screens in our app. It also has support for Jetpack <a id="_idIndexMarker241"/>Compose and functions, such as deep links, which are supposed to open a specific screen in our app when a user clicks on <span class="No-Break">a link.</span></li>
				<li><strong class="bold">Handling lifecycle in activities and fragments</strong>: In Android, both activities and fragments have their own lifecycle, and it is particularly important for us to be aware of these lifecycles so that we can be able to do operations in the right lifecycle. For example, we should be observing data in our views when the lifecycle is in the started state and free up resources when the lifecycle is either in the stopped or destroyed state. Doing this was harder and required a lot of code, which could be bug-prone. The team at Google came up with the <strong class="bold">lifecycle</strong> library to help us manage lifecycles in our activities and fragments. Additionally, we have classes, such as the <strong class="bold">ViewModel</strong>, which we created earlier on, that allow your data to persist across configuration changes. Most of the Jetpack libraries are also lifecycle-aware, which makes it easy to use them in our apps. Taking the ViewModel as an example, it survives beyond the lifecycle of the activity or fragment that created it. This makes it easy for data to persist across configuration changes. It also makes it easy to share data between fragments <span class="No-Break">and activities.</span></li>
				<li><strong class="bold">Loading infinite lists</strong>: Most apps that we developers work on have a list of items that we want to show to our users. Often, this list of items can be large, and we cannot display all of them at once. We are supposed to display them in batches, which is called <strong class="bold">pagination</strong>. To achieve this by ourselves, we had to do several workarounds, such as<a id="_idIndexMarker242"/> observing the scroll position and fetching the next or previous batch of items when a user reaches the top or bottom of the list. Again, this was quite a bit of work, and the team at Google introduced the <strong class="bold">Paging</strong> library to <a id="_idIndexMarker243"/>help us achieve this. It allows us to load data in batches easily and display it to our users. It also has support for Jetpack Compose and Kotlin Coroutines. It makes it easy to display infinite lists in <span class="No-Break">our apps.</span></li>
				<li><strong class="bold">Handling background jobs</strong>: Performing lengthy background tasks for apps proved to be somewhat challenging. The common issue was that some of the background jobs did <a id="_idIndexMarker244"/>not run due to the different restrictions that phone manufacturers add to the phones to improve their performance of the phone. The team at Google introduced the <strong class="bold">WorkManager</strong> library to<a id="_idIndexMarker245"/> help us achieve this. It allows us to schedule background jobs in our apps easily. It also supports periodic background jobs and ensures that our jobs run irrespective of the phone brand that the user <span class="No-Break">is using.</span></li>
				<li><strong class="bold">Performance</strong>: There was no clear guidance on how best we developers can improve the performance of our apps. That is not the case anymore; we have several Jetpack libraries to help us detect performance issues and improve the performance of our apps. A good<a id="_idIndexMarker246"/> example of this is the <strong class="bold">baseline profiles</strong>, which help improve app start-up time and make app interactions <span class="No-Break">much smoother.</span></li>
			</ul>
			<p>There are a lot of Jetpack libraries. You can explore all the available Jetpack libraries here: <a href="https://developer.android.com/jetpack/androidx/explorer">https://developer.android.com/jetpack/androidx/explorer</a>. The following are some of the benefits of using <span class="No-Break">Jetpack libraries:</span></p>
			<ul>
				<li>We can follow the <span class="No-Break">best practices</span></li>
				<li>We can write less <span class="No-Break">boilerplate code</span></li>
				<li>We <span class="No-Break">reduce fragmentation</span></li>
				<li>The APIs work <span class="No-Break">well together</span></li>
			</ul>
			<p>We have already seen how to use a <strong class="source-inline">ViewModel</strong> class in this chapter. We will also be using other Jetpack libraries in the later chapters of <span class="No-Break">this book.</span></p>
			<p>We have looked at how the Jetpack Libraries fit in with the different layers of our architecture. In the next section, we <a id="_idIndexMarker247"/>are looking at an important topic in architecture, which is <span class="No-Break"><strong class="bold">dependency injection</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor077"/>Dependency injection</h1>
			<p>Dependency injection is a <a id="_idIndexMarker248"/>way for us to manage and provide dependencies that a class needs to do its work without the class having to create the dependencies itself. In this book, we will be using Koin (<a href="https://insert-koin.io/">https://insert-koin.io/</a>) as our dependency <span class="No-Break">injection library.</span></p>
			<p>Our <strong class="source-inline">PetsViewModel</strong> class creates the <strong class="source-inline">PetsRepository</strong> class by itself. This is a suitable candidate for dependency injection. We will be refactoring this to use dependency injection. Let’s start by adding the Koin dependency to our app. Open the <strong class="source-inline">build.gradle</strong> file for the app module and add the <span class="No-Break">following dependency:</span></p>
			<pre class="source-code">
implementation 'io.insert-koin:koin-core:3.4.3'
implementation 'io.insert-koin:koin-android:3.4.3'
implementation 'io.insert-koin:koin-androidx-compose:3.4.6'</pre>			<p>We are adding the Koin <strong class="source-inline">core</strong>, <strong class="source-inline">android,</strong> and <strong class="source-inline">compose</strong> dependencies as well, which will be used in our project to provide <span class="No-Break">the dependencies.</span></p>
			<p>After adding this to our project and syncing<a id="_idIndexMarker249"/> the project, we need to create Koin <strong class="bold">modules</strong> for our dependencies. Modules are used to declare dependencies. We will create a module for our <strong class="source-inline">PetsRepository</strong> class. Create a new package named <strong class="source-inline">di</strong> inside the <strong class="source-inline">com.packt.chapterfive</strong> package. Inside this <strong class="source-inline">di</strong> package, create a new file named <strong class="source-inline">Modules</strong> and add the <span class="No-Break">follo<a id="_idTextAnchor078"/>wing code:</span></p>
			<pre class="source-code">
val appModules = module {
    single&lt;PetsRepository&gt; { PetsRepositoryImpl() }
}</pre>			<p>In the preceding code above, we are creating a new variable named <strong class="source-inline">appModules</strong> of the type module. We are using the <strong class="source-inline">module</strong> function from the Koin library to create a module. We are using the <strong class="source-inline">single</strong> function to create a single instance of the <strong class="source-inline">PetsRepository</strong> class. Koin has dependency injection scopes, such as <strong class="source-inline">single</strong>, <strong class="source-inline">factory</strong>, and <strong class="source-inline">scoped</strong>, that govern the lifecycle and visibility of dependency instances within the container. The <strong class="source-inline">single</strong> scope creates singleton instances that persist throughout the entire application, making it suitable for objects requiring a globally shared state, such as database instances. <strong class="source-inline">Factory</strong> scope generates new instances each time they are requested, fitting stateless utility classes or objects that don’t need to maintain a persistent state. The <strong class="source-inline">scoped</strong> scope ties instances to specific contexts, such as activity or fragment lifecycles, allowing them to be shared within a designated scope but recreated for different contexts. The <strong class="source-inline">single</strong> scope is particularly useful for managing global or long-lived dependencies efficiently, ensuring a single instance is shared consistently across various components of the application, thereby optimizing resource usage and<a id="_idIndexMarker250"/> maintaining a unified state. This is why we are using <strong class="source-inline">single</strong> to create an instance of our <strong class="source-inline">PetsRepository</strong> class. We are using the <strong class="source-inline">PetsRepositoryImpl</strong> class as the implementation of the <span class="No-Break"><strong class="source-inline">PetsRepository</strong></span><span class="No-Break"> interface.</span></p>
			<p>Next, we will refactor our <strong class="source-inline">PetsViewModel</strong> class to use dependency injection. Open the <strong class="source-inline">PetsViewModel</strong> class and update it as shown in the following <span class="No-Break">code snippet:</span></p>
			<pre class="source-code">
class PetsViewModel(
    private val petsRepository: PetsRepository
): ViewModel() {
    fun getPets() = petsRepository.getPets()
}</pre>			<p>In the preceding code, we have removed the instantiation of the <strong class="source-inline">PetsRepository</strong> class from the <strong class="source-inline">PetsViewModel</strong> class. We have, instead, added a <strong class="source-inline">constructor</strong> that takes a <strong class="source-inline">PetsRepository</strong> parameter. We also need to create a new dependency for <strong class="source-inline">ViewModel</strong>, just below the <strong class="source-inline">PetsRepository</strong> dependency in our <strong class="source-inline">appModules</strong> variable. Let us add the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
single { PetsViewModel(get()) }</pre>			<p>Here, we are creating a <strong class="source-inline">single</strong> instance of the <strong class="source-inline">PetsViewModel</strong> class. We are using the <strong class="source-inline">get()</strong> function to get the <strong class="source-inline">PetsRepository</strong> dependency. We are passing it to the constructor of the <strong class="source-inline">PetsViewModel</strong> class. With this, our app is ready to use these dependencies. We will also change the way we create the <strong class="source-inline">PetsViewModel</strong> instance in our <strong class="source-inline">PetList</strong> composable. Open the <strong class="source-inline">PetList</strong> composable and update the initialization of <strong class="source-inline">PetsViewModel</strong>, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
val petsViewModel: PetsViewModel = koinViewModel()</pre>			<p>Instead of using the <strong class="source-inline">ViewModel()</strong> function from the lifecycle library, we are using the <strong class="source-inline">koinViewModel()</strong> function from the Koin library. This function helps us create an instance of the <strong class="source-inline">PetsViewModel</strong> class. This now returns an instance of <strong class="source-inline">PetsViewModel</strong> that has the <strong class="source-inline">PetsRepository</strong> <span class="No-Break">dependency injected.</span></p>
			<p>The last step in ensuring our <a id="_idIndexMarker251"/>app has dependency injection setup is to initialize Koin in our app. We will create a class that extends the <strong class="source-inline">Application</strong> class and initialize Koin in the <strong class="source-inline">onCreate()</strong> method. Create a new file named <strong class="source-inline">ChapterFiveApplication</strong> and add the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
class ChapterFiveApplication: Application() {
    override fun onCreate() {
        super.onCreate()
        startKoin {
            modules(appModules)
        }
    }
}</pre>			<p>Our <strong class="source-inline">ChapterFiveApplication</strong> class extends the <strong class="source-inline">Application</strong> class. We are overriding the <strong class="source-inline">onCreate()</strong> method and calling the <strong class="source-inline">startKoin()</strong> function. We are using the <strong class="source-inline">modules</strong> parameter to pass in the <strong class="source-inline">appModules</strong> variable that we created earlier on. This initializes Koin in our app. We also need to update the <strong class="source-inline">AndroidManifest.xml</strong> file to use our <strong class="source-inline">ChapterFiveApplication</strong> class. Open the <strong class="source-inline">AndroidManifest.xml</strong> file and update the application tag with the name attribute, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
android:name=".ChapterFiveApplication"</pre>			<p>We are passing the name of our <strong class="source-inline">ChapterFiveApplication</strong> class to the name attribute. Now, if you run <a id="_idIndexMarker252"/>the app, it still runs as before, but this time, it uses <span class="No-Break">dependency injection.</span></p>
			<p>Now that we understand what dependency injection is and how to use it in our apps, let us look at <strong class="bold">Kotlin Gradle DSL</strong> and how we can use <strong class="bold">version catalogs</strong> to manage <span class="No-Break">our dependencies.</span></p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor079"/>Migrating to Kotlin Gradle DSL and using version catalogs</h1>
			<p>In <a href="B19779_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, one of the<a id="_idIndexMarker253"/> advantages of using Kotlin that we listed is that we can also write our Gradle files in Kotlin. In this section, we will look at how we can migrate our Gradle files to Kotlin Gradle DSL. We will also look at how we can use a version catalog to manage <span class="No-Break">our dependencies.</span></p>
			<p>Before we migrate, let’s see some of the benefits we get from using Kotlin <span class="No-Break">Gradle DSL:</span></p>
			<ul>
				<li><strong class="bold">Code autocompletion</strong>: We<a id="_idIndexMarker254"/> get hints about the completion of our code in Gradle files as we are <span class="No-Break">using Kotlin.</span></li>
				<li><strong class="bold">Type safety</strong>: We get compile time errors when we make mistakes in our <span class="No-Break">Gradle files.</span></li>
				<li><strong class="bold">Function calls and variable assignments</strong>: We can use functions and variables in our Gradle files the same way we use them in our Kotlin code. It makes it even easier for us to write <span class="No-Break">and understand.</span></li>
				<li><strong class="bold">Compile time errors</strong>: We get errors at compile time when we make mistakes in our Gradle files. This helps us avoid runtime errors when building <span class="No-Break">our apps.</span></li>
				<li><strong class="bold">Official Android Studio Support</strong>: From Android Studio Giraffe onwards, Kotlin Gradle DSL is the recommended way of creating our Gradle files. It is also the default way of <a id="_idIndexMarker255"/>creating our Gradle files in Android Studio <span class="No-Break">Giraffe onwards.</span></li>
			</ul>
			<p>So many benefits, right? Let’s now migrate our app so as to use Kotlin <span class="No-Break">Gradle DSL.</span></p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor080"/>Migrating our app to Kotlin Gradle DSL</h2>
			<p class="callout-heading">Important note</p>
			<p class="callout">If your apps already use Kotlin Gradle DSL, you can skip <span class="No-Break">this section.</span></p>
			<p>Follow these steps to <a id="_idIndexMarker256"/>migrate your app to Kotlin <span class="No-Break">Gradle DSL:</span></p>
			<ol>
				<li>First, we have to rename all our Gradle files to have a <strong class="source-inline">.kts</strong> extension, which allows our IDE to recognize them as Kotlin Gradle files. Rename the <strong class="source-inline">build.gradle(Project : chapterfive)</strong>, <strong class="source-inline">build.gradle(Module: app)</strong>, and <strong class="source-inline">settings.gradle</strong> files to <strong class="source-inline">build.gradle.kts(Project: chapterfive)</strong>, <strong class="source-inline">build.gradle.kts(Module: app)</strong>, and <strong class="source-inline">settings.gradle.kts</strong>, respectively. This allows us to use Kotlin in our Gradle <span class="No-Break">files now.</span></li>
				<li>After renaming the files, we have to update their content to use Kotlin Gradle DSL. Let’s start with the <strong class="source-inline">settings.gradle.kts</strong> file. Open the <strong class="source-inline">settings.gradle.kts</strong> file and update it, as shown in the <span class="No-Break">following code:</span><pre class="source-code">
pluginManagement {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
    }
}
rootProject.name = "chapterfive"
include(":app")</pre></li>				<li>Next, update the <strong class="source-inline">build.gradle.kts(Module: app)</strong> file, as shown in the <span class="No-Break">following </span><span class="No-Break"><a id="_idIndexMarker257"/></span><span class="No-Break">code:</span><pre class="source-code">
plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
}
android {
    namespace = "com.packt.chapterfive"
    compileSdk = 33
    defaultConfig {
        applicationId = "com.packt.chapterfive"
        minSdk = 24
        targetSdk = 33
        versionCode = 1
        versionName = "1.0"
        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
        vectorDrawables {
            useSupportLibrary = true
        }
    }
    buildTypes {
        release {
            isMinifyEnabled = false
            setProguardFiles(
                listOf(
                    getDefaultProguardFile("proguard-android.txt"),
                    "proguard-rules.pro"
                )
            )
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
    }
    kotlinOptions {
        jvmTarget = "1.8"
    }
    buildFeatures {
        compose = true
    }
    composeOptions {
        kotlinCompilerExtensionVersion = "1.4.6"
    }
    packagingOptions {
        resources {
            pickFirsts.add("META-INF/AL2.0")
            pickFirsts.add("META-INF/LGPL2.1")
        }
    }
}
dependencies {
    implementation("androidx.core:core-ktx:1.10.1")
    implementation(platform("org.jetbrains.kotlin:kotlin-bom:1.8.0"))
    implementation("androidx.lifecycle:lifecycle-runtime-ktx:2.6.1")
    implementation("androidx.activity:activity-compose:1.7.2")
    implementation(platform("androidx.compose:compose-bom:2022.10.00"))
    implementation("androidx.compose.ui:ui")
    implementation("androidx.compose.ui:ui-graphics")
    implementation("androidx.compose.ui:ui-tooling-preview")
    implementation("androidx.compose.material3:material3")
    implementation("androidx.lifecycle:lifecycle-viewmodel-compose")
    implementation("io.insert-koin:koin-core:3.4.3")
    implementation("io.insert-koin:koin-android:3.4.3")
    implementation("io.insert-koin:koin-androidx-compose:3.4.6")
    testImplementation("junit:junit:4.13.2")
    androidTestImplementation("androidx.test.ext:junit:1.1.5")
    androidTestImplementation("androidx.test.espresso:espresso-core:3.5.1")
    androidTestImplementation(platform("androidx.compose:compose-bom:2022.10.00"))
    androidTestImplementation("androidx.compose.ui:ui-test-junit4")
    debugImplementation("androidx.compose.ui:ui-tooling")
    debugImplementation("androidx.compose.ui:ui-test-manifest")
}</pre></li>				<li>Lastly, update the <strong class="source-inline">build.gradle.kts(Project: chapterfive)</strong> file, as shown in the <span class="No-Break">following snippet:</span><pre class="source-code">
plugins {
    id("com.android.application") version "8.1.0" apply false
    id("com.android.library") version "8.1.0" apply false
    id("org.jetbrains.kotlin.android") version "1.8.20" apply false
}</pre></li>			</ol>
			<p>After updating the files, we have to sync the project. We can do this by clicking on the Sync prompt that appears in the top right corner of the IDE. After syncing the project, we can now run the app, and it should run as before. We have now successfully migrated our app to use Kotlin<a id="_idIndexMarker258"/> Gradle DSL. You can also see that the syntax highlighting and the colors of the functions, methods, and variables change to reflect the Kotlin syntax. Some key changes about this migration to highlight are <span class="No-Break">the following:</span></p>
			<ul>
				<li>To assign values to properties, we have to use the <strong class="source-inline">=</strong> operator specifically. For example, <strong class="source-inline">minSdk 24</strong> changes to <strong class="source-inline">minSdk = </strong><span class="No-Break"><strong class="source-inline">24</strong></span><span class="No-Break">.</span></li>
				<li>In our <strong class="source-inline">android</strong> config block, <strong class="source-inline">namespace 'com.packt.chapterfive'</strong> changes to  <strong class="source-inline">namespace = "com.packt.chapterfive"</strong>. In Kotlin, we define strings using double quotes; that’s why we have to change the single quotes to double quotes in all the places we <span class="No-Break">have strings.</span></li>
				<li>In defining our dependencies, we have to use double quotes too. For example,  <strong class="source-inline">implementation 'androidx.activity:activity-compose:1.7.2'</strong>  changes <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">implementation("androidx.activity:activity-compose:1.7.2")</strong></span><span class="No-Break">.</span></li>
				<li>Similarly, defining our plugins in the <strong class="source-inline">plugins</strong> block changes. For example, <strong class="source-inline">id 'org.jetbrains.kotlin.android'</strong> changes <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">id("org.jetbrains.kotlin.android")</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>Our project had minimal Gradle configurations, so if you have a complex project, you might need to do <a id="_idIndexMarker259"/>more migration; you can have a look at the Migrate to Kotlin DSL official documentation (<a href="https://developer.android.com/build/migrate-to-kotlin-dsl">https://developer.android.com/build/migrate-to-kotlin-dsl</a>) for <span class="No-Break">more examples.</span></p>
			<p>We have now migrated our app to use Kotlin Gradle DSL. In the next subsection, let’s look at how we can use a <strong class="bold">versions catalog</strong> to manage <span class="No-Break">our dependencies.</span></p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor081"/>Using a versions catalog</h2>
			<p>Quoting from the official documentation (<a href="https://docs.gradle.org/current/userguide/platforms.html">https://docs.gradle.org/current/userguide/platforms.html</a>), a version catalog is a list of dependencies, represented as dependency co-ordinates, that a user can pick from when declaring<a id="_idIndexMarker260"/> dependencies in a build script. It helps us easily manage our <a id="_idIndexMarker261"/>dependencies and their versions in one central place. Currently, you can see that we define all our dependencies and their versions in our app-level <strong class="source-inline">build.gradle.kts</strong> file. Over time, and as you add more modules to your app, it becomes hard to share these dependencies, and we can find ourselves in situations where different modules have different versions of a similar dependency. This is where version catalogs come in to help us. Let’s see all the benefits that <span class="No-Break">they offer:</span></p>
			<ul>
				<li>They provide a central place to manage all our dependencies and their versions. They make it easier to share the dependencies across <span class="No-Break">the project</span></li>
				<li>They have a simple and <span class="No-Break">easy-to-use syntax</span></li>
				<li>They show hints for dependencies that need to <span class="No-Break">be updated</span></li>
				<li>They make it easier to make changes, and these changes do not recompile the whole project, meaning the builds <span class="No-Break">are faster</span></li>
				<li>We can bundle dependencies together and share them across <span class="No-Break">the project</span></li>
				<li>They have official support and are recommended by Google to be used from Android Studio Giraffe <span class="No-Break">going forward</span></li>
			</ul>
			<p>Let’s now see how we can use a version catalog in our app. In the <strong class="source-inline">gradle</strong> folder, create a new file named <strong class="source-inline">libs.versions.toml</strong>. In this file, here are some basic rules that we <span class="No-Break">will follow:</span></p>
			<ul>
				<li>We can use separators, such as -, _v, and . , that will be normalized by Gradle to “.” in the Catalog, allowing<a id="_idIndexMarker262"/> us to <span class="No-Break">create subsections.</span></li>
				<li>We define variables <span class="No-Break">using **CamelCase**.</span></li>
				<li>For libraries, we normally check if we can add them to any existing bundles. For new libraries that are <a id="_idIndexMarker263"/>normally used together, we can create a new bundle <span class="No-Break">for them.</span></li>
			</ul>
			<p>We will start by defining the versions for our dependencies <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
[versions]
coreKtx = "1.10.1"
lifecycle = "2.6.1"
activity = "1.7.2"
composeBom = "2022.10.00"
koin = "3.4.3"
koinCompose = "3.4.6"
junit = "4.13.2"
junitExt = "1.1.5"
espresso = "3.5.1"</pre>			<p>Here, we are defining all the versions for the libraries that are in our app. We use the <strong class="bold">versions</strong> keyword to define the<a id="_idIndexMarker264"/> versions. We then define the versions for each library. As we edit this file, you will notice that the IDE prompts you to do a Gradle sync for our changes to be added to the project. For now, we can ignore this and continue editing the file. Next, we will <a id="_idIndexMarker265"/>define the bundles for <span class="No-Break">our</span><span class="No-Break"><a id="_idIndexMarker266"/></span><span class="No-Break"> dependencies:</span></p>
			<pre class="source-code">
[libraries]
core-ktx = { module = "androidx.core:core-ktx", version.ref = "coreKtx" }
lifecycle = { module = "androidx.lifecycle:lifecycle-runtime-ktx", version.ref = "lifecycle" }
activity-compose = { module = "androidx.activity:activity-compose", version.ref = "activity" }
compose-bom = { group = "androidx.compose", name = "compose-bom", version.ref = "composeBom" }
compose-ui = { group = "androidx.compose.ui", name = "ui" }
compose-ui-graphics = { group = "androidx.compose.ui", name = "ui-graphics" }
compose-ui-tooling = { group = "androidx.compose.ui", name = "ui-tooling" }
compose-material3 = { group = "androidx.compose.material3", name = "material3" }
compose-manifest = { group = "androidx.compose.ui", name = "ui-test-manifest" }
compose-viewmodel = { module = "androidx.lifecycle:lifecycle-viewmodel-compose", version.ref = "lifecycle" }
koin-core = { module = "io.insert-koin:koin-core", version.ref = "koin" }
koin-android = { module = "io.insert-koin:koin-android", version.ref = "koin" }
koin-android-compose = { module = "io.insert-koin:koin-androidx-compose", version.ref = "koinCompose" }
test-junit = { module = "junit:junit", version.ref = "junit" }
test-junitExt = { module = "androidx.test.ext:junit", version.ref = "junitExt" }
test-espresso = { module = "androidx.test.espresso:espresso-core", version.ref = "espresso" }
test-compose-junit4 = { group = "androidx.compose.ui:ui-test-junit4", name = "ui-test-junit4" }</pre>			<p>Here, we <a id="_idTextAnchor082"/>have defined all the <a id="_idIndexMarker267"/>dependencies in our project using<a id="_idIndexMarker268"/> the <span class="No-Break"><strong class="bold">libraries</strong></span><span class="No-Break"> keyword.</span></p>
			<p>Next, let’s use the <strong class="bold">bundles</strong> keyword to <a id="_idIndexMarker269"/>create a bundle for Koin and compose dependencies <span class="No-Break">as</span><span class="No-Break"><a id="_idIndexMarker270"/></span><span class="No-Break"> follows:</span></p>
			<pre class="source-code">
[bundles]
compose = ["compose.ui", "compose.ui.graphics", "compose.ui.tooling", "compose.material3", "compose.viewmodel"]
koin = ["koin-core", "koin-android", "koin-android-compose"]</pre>			<p>The <strong class="source-inline">bundles</strong> keyword allows us to group dependencies and use them as one. Now, we can sync the project. The last step is to update our app-level <strong class="source-inline">build.gradle.kts</strong> file to use the version catalog. Open the app-level <strong class="source-inline">build.gradle.kts</strong> file and update the dependencies block <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
dependencies {
    implementation(libs.core.ktx)
    implementation(libs.lifecycle)
    implementation(libs.activity.compose)
    implementation(platform(libs.compose.bom))
    implementation(libs.bundles.compose)
    implementation(libs.bundles.koin)
    testImplementation(libs.test.junit)
    androidTestImplementation(libs.test.junitExt)
    androidTestImplementation(libs.test.espresso)
    androidTestImplementation(platform(libs.compose.bom))
    androidTestImplementation(libs.test.compose.junit4)
    debugImplementation(libs.compose.ui.tooling)
    debugImplementation(libs.compose.manifest)
}</pre>			<p>We can now access the <a id="_idIndexMarker271"/>dependencies from our versions catalog file. Notice we must start with the <strong class="bold">libs</strong> keyword, and the next part is the names of the bundles or the dependencies, as per<a id="_idIndexMarker272"/> our version <a id="_idIndexMarker273"/>catalog. After adding these changes, we can now do Gradle sync. Build and run the app. The app displays a list of pets, as before, and nothing changes since we were only refactoring <span class="No-Break">the dependencies.</span></p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor083"/>Summary</h1>
			<p>In this chapter, we have built on what we learned from the previous chapters. We looked at the different architectures available for Android projects. We dived deep into MVVM architecture and its different layers and how to use some of the Jetpack libraries in this architecture. Additionally, we learned how to use advanced architecture features such as dependency injection and Kotlin Gradle DSL, as well as using Gradle version catalogs to define <span class="No-Break">our dependencies.</span></p>
			<p>As we were creating the MVVM architecture, we used dummy pet data for our data layer. In the next chapter, we are going to learn how to make network calls to fetch data and display it in <span class="No-Break">our app.</span></p>
		</div>
	</div></div></body></html>