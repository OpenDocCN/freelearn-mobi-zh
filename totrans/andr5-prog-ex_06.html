<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Notifications and the Action Bar</h1></div></div></div><p>The vertically scrolling <code class="literal">RecyclerView</code>, which we have been dealing with in the previous chapters, is a great device for negotiating long, simple lists where there is either not much data in each item or where each item only displays a small part of the whole. There are, of course, times when we will want to display a full screen of information and still have this as a part of a list. This is where the <code class="literal">ViewPager</code> comes in as it allows us to chain together full-page, mini Activities called <strong>Fragments</strong> in such a way that we can navigate through them with <a id="id226" class="indexterm"/>simple, intuitive horizontal swipe gestures.</p><p>Along with making use of the variety of views and widgets available to us, there are often times when we would wish to inform our user of some event even when they are not focused on our app. Smartphones generally provide some form of notification area, and Android is no exception <a id="id227" class="indexterm"/>with its <strong>notification bar</strong> at the top of the screen. Issuing notifications to the user is a very simple process, and Android has added two new features in Lollipop so that it is now possible to add display notifications on the lock screen and produce floating, heads-up notifications.</p><p>To demonstrate these features, we will build a small weather forecast app (using fake data) that will issue warnings in the form of notifications to the user when the weather is severe.</p><p>In this chapter, you will learn how to:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Construct a screen slide with <code class="literal">ViewPager</code></li><li class="listitem" style="list-style-type: disc">Use Fragments instead of Activities</li><li class="listitem" style="list-style-type: disc">Create a <code class="literal">ViewPager</code> and <code class="literal">PagerAdapter</code></li><li class="listitem" style="list-style-type: disc">Add tabs to the action bar</li><li class="listitem" style="list-style-type: disc">Issue notifications to the user</li><li class="listitem" style="list-style-type: disc">Manage a back stack</li><li class="listitem" style="list-style-type: disc">Design icons for the notification bar</li><li class="listitem" style="list-style-type: disc">Produce heads-up notifications</li><li class="listitem" style="list-style-type: disc">Create expanded notifications</li><li class="listitem" style="list-style-type: disc">Configure lock screen notifications</li><li class="listitem" style="list-style-type: disc">Set notification priority and visibility</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec30"/>Constructing a ViewPager</h1></div></div></div><p>The <code class="literal">ViewPager</code> and its variants are extended from the <code class="literal">ViewGroup</code> class and can be thought of as a kind of layout manager that takes care of placing and navigation through the pages. <code class="literal">ViewPagers</code> work in conjunction with <code class="literal">PagerAdapters</code>, which populate each page with the <a id="id228" class="indexterm"/>appropriate data.</p><p>The code behind the pages of our <code class="literal">ViewPager</code> is contained within a new class, the <code class="literal">Fragment</code>. Fragments are very similar in structure and purpose to Activities, but can be contained and combined within Activities and, to all intents and purposes, can be thought of as sub-Activities.</p><p>As always, we need to consider the layout and appearance of our app before we begin programming. Here, we will need layouts for the <code class="literal">ViewPager</code> and <code class="literal">Fragment</code>. The steps in the following section show how to set up our layout and resource files for this project.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec30"/>Creating the layout</h2></div></div></div><p>Once created, this <a id="id229" class="indexterm"/>project will require two layout files and, to take advantage of some Material Design features, we will edit the styles resource. The following steps explain how this is done:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new project in Android Studio.</li><li class="listitem">Name it <code class="literal">Weather Forecast</code> and start it with the <strong>Blank Activity</strong> template.</li><li class="listitem">Open the <code class="literal">build.gradle (Module: app)</code> file.</li><li class="listitem">Add the following dependencies:<div><pre class="programlisting">compile 'com.android.support:support-v4:21.0.+'
compile 'com.android.support:cardview-v7:21.0.+'</pre></div></li><li class="listitem">If you have not downloaded the project files, locate five suitable images of approximately 400 x 400 px with the following names and place them in the project <code class="literal">drawable</code> directory:<div><img src="img/B04321_06_01.jpg" alt="Creating the layout"/></div></li><li class="listitem">Open the <code class="literal">res/values-v21/styles.xml</code> file.</li><li class="listitem">Add the<a id="id230" class="indexterm"/> following color items inside the <code class="literal">&lt;style&gt;</code> tag:<div><pre class="programlisting">&lt;item name="android:colorPrimary"&gt;#2b2&lt;/item&gt;
&lt;item name="android:colorPrimaryDark"&gt;#080&lt;/item&gt;
&lt;item name="android:colorAccent"&gt;#8f8&lt;/item&gt;
&lt;item name="android:textColorPrimary"&gt;#004&lt;/item&gt;
&lt;item name="android:textColorSecondary"&gt;#448&lt;/item&gt;</pre></div></li><li class="listitem">Open the <code class="literal">activity_main.xml</code> file.</li><li class="listitem">Replace its contents with this code:<div><pre class="programlisting">&lt;android.support.v4.view.ViewPager
    
    android:id="@+id/pager"
    android:layout_width="match_parent"
    android:layout_height="match_parent"/&gt;</pre></div></li><li class="listitem">Create a new layout file called <code class="literal">fragment_layout.xml</code>.</li><li class="listitem">Create a <code class="literal">ViewGroup</code> hierarchy to match the one shown here:<div><img src="img/B04321_06_02.jpg" alt="Creating the layout"/></div></li><li class="listitem">Using <a id="id231" class="indexterm"/>images from the <code class="literal">drawable</code> folder and text as placeholders, recreate the layout (with the inner two layouts highlighted), as shown here, selecting margins and other visual attributes as you see fit:<div><img src="img/B04321_06_03.jpg" alt="Creating the layout"/></div></li><li class="listitem">The <code class="literal">CardView</code> element should look like this:<div><pre class="programlisting">&lt;android.support.v7.widget.CardView 
  
  android:id="@+id/card_view"
  android:layout_width="match_parent"
  android:layout_height="wrap_content"
  card_view:cardCornerRadius="4dp"
  card_view:cardElevation="4dp"&gt;</pre></div></li><li class="listitem">To achieve the correct text coloring, set <code class="literal">android:textAppearance</code> to apply the <code class="literal">textColors</code> we set in the <code class="literal">styles.xml</code> file with <code class="literal">textColorPrimary</code> being applied to views and with <code class="literal">textAppearance</code> set to <code class="literal">"?android:attr/textAppearanceLarge"</code>.</li></ol></div><p>We <a id="id232" class="indexterm"/>added a <strong>support library (v4)</strong> to our gradle script along with <code class="literal">CardView</code> support, which <a id="id233" class="indexterm"/>we will use later. Support libraries provide features that are unavailable in the standard SDK and backward-compatibility for many others.</p><p>That's all the layout and resource work we need to do. By applying custom colors in the style file, we allow the system to decide which colors to apply to which screen components as always; here, however, it applies our own personal scheme. These colors are displayed throughout the app; not only this method is a good way to ensure that our apps are distinctive but it also gives them a consistent feel for very little effort on our behalf.</p><div><div><h3 class="title"><a id="tip16"/>Tip</h3><p>When dealing with large layout files, the process can be tidied up somewhat with the use of <code class="literal">&lt;include layout="@layout/some_layout"/&gt;</code> where <code class="literal">some_layout</code> will be inserted in place of the include tag on inflation.</p></div></div><p>With the layout, theme and style set up, we can now continue with writing some code.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec31"/>Adding a ViewPager and FragmentPagerAdapter</h2></div></div></div><p>As briefly <a id="id234" class="indexterm"/>mentioned already, a <code class="literal">ViewPager</code> is a layout manager for horizontally<a id="id235" class="indexterm"/> scrolling screens. The work of filling these pages is undertaken by a <code class="literal">PagerAdapter</code>, or more specifically in this case <code class="literal">FragmentPagerAdapter</code>, which fulfills the same function but with Fragments rather than Activities.</p><p>Including a small dataset, we will require a total of four classes to implement our <code class="literal">ViewPager</code>. Here is how it's done:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">MainActivity</code> class.</li><li class="listitem">Include the following imports:<div><pre class="programlisting">import android.support.v4.app.FragmentActivity;
import android.support.v4.app.NotificationCompat;
import android.support.v4.app.TaskStackBuilder;
import android.support.v4.view.ViewPager;</pre></div></li><li class="listitem">Extend the class like this:<div><pre class="programlisting"> public class MainActivity extends FragmentActivity{</pre></div></li><li class="listitem">Add this class field:<div><pre class="programlisting">private ViewPager viewPager;</pre></div></li><li class="listitem">Add the<a id="id236" class="indexterm"/> following three lines to the <code class="literal">onCreate()</code> method to<a id="id237" class="indexterm"/> initiate our <code class="literal">ViewPager</code>:<div><pre class="programlisting">viewPager = (ViewPager) findViewById(R.id.pager);
FragmentAdapter adapter = new FragmentAdapter(getSupportFragmentManager());
viewPager.setAdapter(adapter);</pre></div></li><li class="listitem">Create a new class called <code class="literal">FragmentAdapter.java</code>.</li><li class="listitem">Include the following imports:<div><pre class="programlisting">import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentPagerAdapter;</pre></div></li><li class="listitem">Complete the class, as shown here:<div><pre class="programlisting">public class FragmentAdapter extends FragmentPagerAdapter {

    public FragmentAdapter(FragmentManager m) {
        super(m);
    }

    @Override
    public Fragment getItem(int index) {
        Fragment fragment = new WeatherFragment();
        Bundle args = new Bundle();
        args.putInt("day", index);
        fragment.setArguments(args);
        return fragment;
    }

    @Override
    public int getCount() {
        return 5;
    }
}</pre></div></li><li class="listitem">Create a new class called <code class="literal">WeatherFragment.java</code>.</li><li class="listitem">Add this<a id="id238" class="indexterm"/> import:<div><pre class="programlisting">import android.support.v4.app.Fragment;</pre></div></li><li class="listitem">Fill out<a id="id239" class="indexterm"/> the class like this:<div><pre class="programlisting">public class WeatherFragment extends Fragment {

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
      View rootView = inflater.inflate(R.layout.fragment_layout, container, false);
      Bundle args = getArguments();
      int i = args.getInt("day");

      TextView textOutlook = ((TextView) rootView.findViewById(R.id.text_outlook));
      ImageView symbolView = ((ImageView) rootView.findViewById(R.id.image_symbol));
      TextView tempsView = ((TextView) rootView.findViewById(R.id.text_temp));
      TextView windView = ((TextView) rootView.findViewById(R.id.text_min));
      TextView realFeelView = ((TextView) rootView.findViewById(R.id.text_real_feel));

      textOutlook.setText(WeatherData.outlookArray[i]);
      symbolView.setImageResource(WeatherData.symbolArray[i]);
      tempsView.setText(WeatherData.tempsArray[i] + "°c");
      windView.setText(("Min " + WeatherData.minArray[i] + "°c"));
      realFeelView.setText("Real feel " + WeatherData.realFeelArray[i] + "°c");

      return rootView;
    }
}</pre></div></li><li class="listitem">Create a last class called <code class="literal">WeatherData.java</code> and complete it like following:<div><pre class="programlisting">public class WeatherData {
  static String[] outlookArray = {"Developing snow storms", "Partly sunny and breezy", "Mostly sunny", "Afternoon storms", "Increasing cloudiness"};
  static Integer[] symbolArray = {R.drawable.snowy, R.drawable.partly_sunny, R.drawable.sunny, R.drawable.stormy, R.drawable.cloudy};
  static Integer[] tempsArray = {0, 1, 3, 2, 4};
  static Integer[] minArray = {-5,-3,-2,0,2};
  static Integer[] realFeelArray = {-1, 2, 0, 1, 3};
}</pre></div></li><li class="listitem">You can now run and test the app on a handset or emulator.</li></ol></div><p>You may be <a id="id240" class="indexterm"/>wondering why instructions on which libraries to<a id="id241" class="indexterm"/> import were included in this section as you probably have Auto Import configured in the settings. This feature works perfectly in almost all situations and is a great time-saver. If you have not already enabled it, it can be found at <code class="literal">File | Settings... | IDE Settings | Editor | Auto Import</code>. It is only useful when a support library contains imports that have the same name as the standard libraries. Had we not imported these libraries first, we would have encountered something similar to the following screenshot when we tried to enter the code:</p><div><img src="img/B04321_06_04.jpg" alt="Adding a ViewPager and FragmentPagerAdapter"/></div><p>When this occurs, it is still perfectly possible to import the correct libraries by simply selecting the v4 version from the list the editor offers.</p><p>The <code class="literal">MainActivity</code> code is remarkably short as most of the work is done elsewhere. <code class="literal">ViewPagers</code> requires an ID, which is the XML-defined <code class="literal">ViewPager</code> as set in our <code class="literal">activity_main.xml</code> file. The <code class="literal">PagerAdapter</code> is implemented in the next class; here, all we do is to connect the two.</p><p>The <code class="literal">FragmentAdapter</code> class is also quite straightforward. All we need to do is pass the index of the selected page to our <code class="literal">Fragment</code> class, which we do with the Bundle object. The fragment then takes care of laying out the views with the appropriate data. It is important to point out that we did not use a <code class="literal">PagerAdapter</code> directly, but rather one of its variants, the <code class="literal">FragmentPagerAdapter</code>, which is designed to work with fragments There is also the <code class="literal">FragmentSatePagerAdapter</code>, which does an identical job, but is better suited to longer lists. The reason for this is the way the framework handles those pages that are not directly visible to the user. For short lists, such as ours, the best performance can be obtained with <code class="literal">FragmentPagerAdapter</code>.</p><p>The <code class="literal">Fragment</code> class we created is also very simple to understand as it does little more than inflating <a id="id242" class="indexterm"/>our <code class="literal">fragment_layout</code>, associating and setting our <a id="id243" class="indexterm"/>views in a way that is, by now, very familiar to us. Fragments are very similar to Activities as they each have their own life cycle, which can be intercepted at various points with callback methods, such as <code class="literal">onCreate()</code> and <code class="literal">onPause()</code> in the same way as we do with Activities. Here, we chose to use the <code class="literal">onCreateView()</code> method as it provides access to the instances we need to inflate the fragment along with the page index stored in a Bundle by the adapter and is also called when the view is created.</p><p>
<code class="literal">ViewPagers</code> provides a lot of functionality with very little effort. Once connected to an adapter, we can create a screen slide without worrying about implementing touch listeners and having to pay much attention to which page has been selected at any given time.</p><p>As it stands, our app does very little, and we need to provide more functionality, which we will do by firstly adding tabs to the action bar so that we can associate each page with an actual date, and secondly by programming a notification builder to issue weather alerts via the system notification area. We will begin by adding tabs with dates.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec31"/>Adding tabs and dates</h1></div></div></div><p>A weather <a id="id244" class="indexterm"/>forecasting app is of no use if the user does not know when to expect the <a id="id245" class="indexterm"/>weather predicted. We could easily add another view to our fragment layout, but we will attach our pages to the tabs on the action bar, and access calendar and date format classes to populate them.</p><p>To intercept changes between the pages, we will need an <code class="literal">OnPageChangeListener</code>, which is called whenever the page changes, and to redefine the class declaration so that it implements an <code class="literal">ActionBar.TabListener</code>. We will use Java's own <code class="literal">Calendar</code> and <code class="literal">SimpleDateFormat</code> objects to calculate and format our dates.</p><p>Everything we need to do to add tabs to our action bar can be done from within our <code class="literal">MainActivity</code> class by following these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">MainActivity.java</code> file.</li><li class="listitem">Edit the declaration like this:<div><pre class="programlisting">public class MainActivity extends FragmentActivity implements ActionBar.TabListener</pre></div></li><li class="listitem">Select the error this generates, follow the editor's recommendation, and implement the three methods suggested.</li><li class="listitem">Edit the <code class="literal">onTabSelected()</code> method to match the following:<div><pre class="programlisting">@Override
public void onTabSelected(ActionBar.Tab tab, FragmentTransaction ft) {
  viewPager.setCurrentItem(tab.getPosition());
}</pre></div></li><li class="listitem">Include the following class field:<div><pre class="programlisting">private ActionBar actionBar;</pre></div></li><li class="listitem">Add the<a id="id246" class="indexterm"/> following<a id="id247" class="indexterm"/> lines to the <code class="literal">onCreate()</code> method:<div><pre class="programlisting">Calendar calendar = Calendar.getInstance();
String weekDay;
SimpleDateFormat dayFormat;
dayFormat = new SimpleDateFormat("EEEE", Locale.getDefault());

actionBar = getActionBar();
actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);
actionBar.addTab(actionBar.newTab().setText("Today").setTabListener(this));

for (int i = 1; i &lt; 5; i++) {
  calendar.add(Calendar.DAY_OF_WEEK, 1);
  weekDay = dayFormat.format(calendar.getTime());
  actionBar.addTab(actionBar.newTab().setText(weekDay).setTabListener(this));
}</pre></div></li><li class="listitem">Still within <code class="literal">onCreate()</code>, include the following listener to detect page changes:<div><pre class="programlisting">viewPager.setOnPageChangeListener(new ViewPager.OnPageChangeListener() {

  @Override
  public void onPageScrolled(int i, float v, int i2) {
  }

  @Override
  public void onPageSelected(int position) {
    actionBar.setSelectedNavigationItem(position);
  }

  @Override
  public void onPageScrollStateChanged(int i) {
  }
});</pre></div></li><li class="listitem">You can now run the project on a device or AVD.</li></ol></div><p>The tabbed <a id="id248" class="indexterm"/>action bar is a familiar sight on many Android applications and <a id="id249" class="indexterm"/>the <code class="literal">ActionBar.TabListener</code> is an interface that is called whenever a tab is selected, added, or removed. Here, we use its selection to inform our <code class="literal">ViewPager</code> of the change. The <code class="literal">ViewPager</code> layout also provides a good opportunity to see how the colors we defined earlier are applied to the various components of the UI, such as the colored hint that appears when the user attempts to scroll beyond either end of the list.</p><div><img src="img/B04321_06_05.jpg" alt="Adding tabs and dates"/></div><p>The <code class="literal">Calendar</code> and <code class="literal">SimpleDateFormat</code> classes are not hard to follow. The date formatting<a id="id250" class="indexterm"/> follows <strong>Unicode Technical Standards</strong> (<strong>UTS</strong>) #35, the<a id="id251" class="indexterm"/> details of which can be found at <a class="ulink" href="http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns">http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns</a>. Here, we applied a stand-alone day-of-week format with <code class="literal">"cccc"</code>. We could have been more creative and used something like <code class="literal">"c LLL d"</code> to have something like <strong>Tue Mar 15</strong> or even taken advantage of the system's built-in formatting by changing the <code class="literal">dayFormat</code> assignation to <code class="literal">dayFormat = (SimpleDateFormat) new SimpleDateFormat().getDateInstance();</code>, as seen here:</p><div><img src="img/B04321_06_06.jpg" alt="Adding tabs and dates"/></div><p>The final part of the puzzle is put into place with the <code class="literal">ViewPager.OnPageChangeListener</code>, which we use to inform the action bar when a new page is selected with a swipe rather than a tab.</p><p>With both <a id="id252" class="indexterm"/>forms of navigation in place and connected, we can now move on and <a id="id253" class="indexterm"/>program our app to issue notifications.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec32"/>Programming notifications</h1></div></div></div><p>Android 5 provides<a id="id254" class="indexterm"/> a more flexible notification framework than the previous versions. In addition to being able to issue standard notifications to the notification bar, we can now expand notifications to include more detail than before, and are able to notify the user when they are using a full-screen app, or even when their screen is<a id="id255" class="indexterm"/> locked, with <strong>heads-up notifications</strong> that float above the screen for a moment.</p><p>When using notifications, it is important to be sensitive to our user's needs and not issue too many <a id="id256" class="indexterm"/>notifications or give them too great a level <a id="id257" class="indexterm"/>of importance. It is for this reason that notifications can be assigned <strong>priority and visibility</strong> settings. With that said, it is now time to proceed with adding notifications to our app.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec32"/>Adding a standard notification and icon</h2></div></div></div><p>Assuming the notification we wish to deliver is neither important nor personal, and all we wish to do<a id="id258" class="indexterm"/> is to inform the user of some event<a id="id259" class="indexterm"/> and offer them the opportunity to open our app, we need to<a id="id260" class="indexterm"/> issue a standard notification so that a small icon appears <a id="id261" class="indexterm"/>on the notification bar and, when the drawer is opened, a small card appears with some brief text and an icon. This, if clicked on, will open our app. Notifications require a particular type of icon for display on the bar. We will begin with this and then continue to implement a notification. Complete the following steps to set this up on our weather app:</p><div><ol class="orderedlist arabic"><li class="listitem">If you have not downloaded the project files, you will need a small icon of a single color against a transparent background (like the one you see here) called <code class="literal">small_icon.png</code>, and stored in the <code class="literal">drawable</code> directory:<div><img src="img/B04321_06_07.jpg" alt="Adding a standard notification and icon"/></div></li><li class="listitem">Open<a id="id262" class="indexterm"/> the MainActivity Java file.</li><li class="listitem">Add this<a id="id263" class="indexterm"/> class field:<div><pre class="programlisting">private static int notificationId;</pre></div></li><li class="listitem">In the <code class="literal">onCreate()</code> method, add the following clause:<div><pre class="programlisting">if (notificationId == 0) {
    postAlert(0);
}</pre></div></li><li class="listitem">Create<a id="id264" class="indexterm"/> the <code class="literal">postAlert()</code> method and complete<a id="id265" class="indexterm"/> it like this:<div><pre class="programlisting">private void postAlert(int i) {
  NotificationCompat.Builder builder = new NotificationCompat.Builder(this);
  builder.setContentTitle("Weather Alert!")
    .setContentText(WeatherData.outlookArray[i])
    .setSmallIcon(R.drawable.small_icon)
    .setAutoCancel(true)
    .setTicker("Wrap up warm!");

    Intent intent = new Intent(this, MainActivity.class);
    TaskStackBuilder stackBuilder = TaskStackBuilder.create(this);
    stackBuilder.addParentStack(MainActivity.class).addNextIntent(intent);
    PendingIntent pendingIntent = stackBuilder.getPendingIntent(0, PendingIntent.FLAG_UPDATE_CURRENT);
    builder.setContentIntent(pendingIntent);

    NotificationManager notificationManager = (NotificationManager) this.getSystemService(Context.NOTIFICATION_SERVICE);
    notificationManager.notify(notificationId, builder.build());

    notificationId++;
}</pre></div></li><li class="listitem">The <a id="id266" class="indexterm"/>application can now be tested<a id="id267" class="indexterm"/> on an emulator or device, and opening<a id="id268" class="indexterm"/> the notification drawer should produce the <a id="id269" class="indexterm"/>following result:<div><img src="img/B04321_06_08.jpg" alt="Adding a standard notification and icon"/></div></li></ol></div><p>There are quite a few things going on here. Firstly, there was the <strong>notification icon</strong>. This is required by the builder and has to be of a specific format. Apart from being small, the icon needs to be a simple design on a transparent background. The color of the image is immaterial as only the alpha channel is considered by the system. For this reason, colors with intermediate alpha levels are strongly discouraged.</p><p>Before getting to the rest of the code, it would be amiss not to point out that there is an alternative to <a id="id270" class="indexterm"/>using the small icon on the notification <a id="id271" class="indexterm"/>pop-down, which, although suitable for the minimal <a id="id272" class="indexterm"/>space on the bar, does not always look great in the<a id="id273" class="indexterm"/> circular icon to the left of the larger view. Add the following setting to our builder:</p><div><pre class="programlisting">.setLargeIcon(BitmapFactory.decodeResource(getResources(), WeatherData.symbolArray[i]))</pre></div><p>Running the app now produces an icon like this:</p><div><img src="img/B04321_06_09.jpg" alt="Adding a standard notification and icon"/></div><p>We used <code class="literal">NotificationCompat</code> to construct our builder. <code class="literal">NotificationCompat</code> is a helper class provided by the support libraries we imported earlier. The <code class="literal">Builder</code> itself has three required parameters: <code class="literal">ContentTitle</code>, <code class="literal">ContentText</code>, and <code class="literal">SmallIcon</code>. There are many others, which we will get to, but only these three are mandatory. I have also set <code class="literal">AutoCancel</code> to true as this is extremely helpful because it automatically closes the notification once it has been selected from the drawer. The purpose of setting <code class="literal">Builder.Ticker</code> would have become apparent when the app was run.</p><p>Because of their available position, notifications can be viewed and triggered when other apps have the focus. This can lead to confusing results for the user when they press the back key. We want the navigation keys to behave as if the app had been launched in the usual way. This is the<a id="id274" class="indexterm"/> function of the <strong>TaskStackBuilder</strong>, which takes <a id="id275" class="indexterm"/>an <strong>Intent</strong> in this case to launch our MainActivity, and places it onto the recent activities back stack and the PendingIntent makes it available outside our app.</p><p>The actual <a id="id276" class="indexterm"/>notification is called with the <code class="literal">NotificationManager.notify()</code> call. The use of an ID was not strictly necessary here as our <a id="id277" class="indexterm"/>app only issues one notification at a time. However, not <a id="id278" class="indexterm"/>only is it a useful way to keep track of multiple <a id="id279" class="indexterm"/>notifications, but can also be used, as we did here, to ensure that a notification is issued only once.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec33"/>Expanding a notification</h2></div></div></div><p>The <code class="literal">NotificationCompat</code> class provides us with three built-in styles. Here, we will use <code class="literal">BigPictureStyle</code>. Before we start, you will need an image to use as the "big picture". Find a<a id="id280" class="indexterm"/> suitable image of around 640 x 480 px, place it in your <code class="literal">drawable</code> folder, and name it <code class="literal">snow_scene</code> or change the reference in the following code. Once your image is in place, follow these short steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">MainActivity.java</code> class.</li><li class="listitem">Add the following code to the <code class="literal">onCreate()</code> method, just before our Intent is declared:<div><pre class="programlisting">  NotificationCompat.BigPictureStyle bigStyle = new NotificationCompat.BigPictureStyle();
  bigStyle.bigPicture(BitmapFactory.decodeResource(getResources(), R.drawable.snow_scene));
  builder.setStyle(bigStyle);</pre></div></li><li class="listitem">That's it! Run the app on your handset or emulator and open the notification drawer.<div><img src="img/B04321_06_10.jpg" alt="Expanding a notification"/></div></li></ol></div><p>The <code class="literal">NotificationCompat.Style</code> objects are very handy to add details to our notifications, and<a id="id281" class="indexterm"/> simple to understand and use. Along with <code class="literal">BigPictureStyle</code>, there is <code class="literal">BigTextStyle</code> for headline type notifications and <code class="literal">InboxStyle</code> for lists.</p><p>This leaves us with two other new notification features: heads-up notifications and lock screen notifications. Neither of these requires any additional coding as such, but they are triggered by adjusting certain privacy and priority settings of the existing notifications. The next and <a id="id282" class="indexterm"/>final section of this chapter demonstrates how this is done.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec34"/>Issuing heads-up and lock screen notifications</h2></div></div></div><p>Heads-up <a id="id283" class="indexterm"/>and lock screen notifications<a id="id284" class="indexterm"/> are created in the same way<a id="id285" class="indexterm"/> as the standard notifications. The difference depends<a id="id286" class="indexterm"/> on the <code class="literal">VISIBILTY</code> and <code class="literal">PRIORITY</code> properties of our <code class="literal">NotificationCompat.Builder</code> class. The following are the steps to do this:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">MainActivity</code> class.</li><li class="listitem">Give our builder instance the following properties:<div><pre class="programlisting">.setPriority(Notification.PRIORITY_HIGH)
.setVisibility(Notification.VISIBILITY_PUBLIC)
.setVibrate(new long[]{100, 50, 100, 50, 100})
.setCategory(Notification.CATEGORY_ALARM)</pre></div></li><li class="listitem">When the app is run, it will now display heads-up and lock screen notifications.<div><div><h3 class="title"><a id="tip17"/>Tip</h3><p>The screen can be locked on an emulator by pressing <em>F7</em>.</p></div></div></li></ol></div><p>Here, the <code class="literal">setPriority()</code> method is how we decide whether a notification is important enough to consider using a heads-up message that may intrude on some other task they are performing more than the standard version. Priority must be set to <code class="literal">PRIORITY_HIGH</code> or <code class="literal">PRIORITY_MAX</code> and the notification must be set to trigger a vibration for notifications to appear in this manner. The other priorities are <code class="literal">MIN</code>, <code class="literal">LOW</code>, and <code class="literal">DEFAULT</code>.</p><div><div><h3 class="title"><a id="tip18"/>Tip</h3><p>If you do not wish for your notification to set off a vibration, but still appear in a heads-up fashion, you can use the following line instead:</p><div><pre class="programlisting">builder.setVibrate(0);</pre></div></div></div><p>Although there are more intricate ways to configure a vibration, the constructor used here will suit most purposes. The array of longs represents alternating times in milliseconds, representing pulses of vibration and silence alternatively so that, in the example here, the device would buzz three times for 100 ms with pauses of 50 ms in between.</p><p>Unlike other notifications, the user can choose, via settings, whether or not the device displays lock screen messages. As developers, however, we can decide how much, if any, information is displayed on the user's lock screen.</p><p>Setting the visibility of a notification to <code class="literal">PUBLIC</code> will cause both content title and content text <a id="id287" class="indexterm"/>to<a id="id288" class="indexterm"/> be <a id="id289" class="indexterm"/>displayed, setting it to <code class="literal">PRIVATE</code> will <a id="id290" class="indexterm"/>display only the title, and <code class="literal">SECRET</code> will display nothing at all.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec33"/>Summary</h1></div></div></div><p>In this chapter, we explored an alternative to the vertically scrolling <code class="literal">RecyclerView</code> with the <code class="literal">ViewPager</code>. We used Fragments instead of Activities, and saw some of the things we can do with the Action Bar. We learnt how to issue notifications of all kinds and how to manage the back stack so as to provide consistent navigation back through our app for the user. In most cases, notifications are sent when our app is not even actively running; to do this, we will need to use Services, which are a kind of background Activity.</p><p>In the next chapter, we will take a look at how to include Google Maps into our apps and make them location-aware. This involves having to register our app for an API key and employing a <code class="literal">LocationListener</code> to keep our app updated with current location data; as this can be resource hungry, we will also see how to optimize this process.</p></div></body></html>