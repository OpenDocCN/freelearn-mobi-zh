<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch13"/>Chapter 13. Using Mix and Match</h1></div></div></div><p>When Apple first introduced Swift at WWDC 2014, my first thought was how much work it would be for developers to rewrite their apps, which were already written in Objective-C, in Swift. I also wondered why a developer would rewrite their apps in Swift. A lot of these applications are pretty complex and would take a pretty large effort to rewrite them. Somewhere in the Swift presentation, Apple spoke about mix and match, which allows Swift and Objective-C to interact within the same project. Mix and match sure sounded like an ideal solution because developers could rewrite sections of their code in Swift as they needed to do updates, instead of having to rewrite their whole application. My big question was how well mix and match would actually work, and I was very surprised; not only does it work well but it is also easy to implement.</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What is mix and match</li><li class="listitem" style="list-style-type: disc">How to use Swift and Objective-C together in the same project</li><li class="listitem" style="list-style-type: disc">How to add Swift to an Objective-C project</li><li class="listitem" style="list-style-type: disc">How to use Objective-C in a Swift project</li></ul></div><div><div><div><div><h1 class="title"><a id="ch13lvl1sec85"/>What is mix and match</h1></div></div></div><p>Swift's compatibility with Objective-C allows us to create a project in either language and include files written in the other language. This feature is called <strong>mix and match</strong>. It was arguably one of the most important features that came out with Swift.</p><p>The reason <a class="indexterm" id="id528"/>why this feature is so important is that there are, well, over a million apps written in Objective-C in Apple's App Store, and it would not be feasible for developers to spend the resources required for converting those apps from Objective-C to Swift. Without mix and match, the adaptation of the Swift language would be very slow. With mix and match, developers can begin to use Swift in their present apps that are written in Objective-C without having to convert the entire code base to Swift.</p><p>With mix and match, we can update our current Objective-C project using Swift. We can also use any framework written in Objective-C within our Swift projects and use newer frameworks written in Swift in our Objective-C projects.</p><p>For developers that have been using Apple products for a long time, they might find a similarity between mix and match and Rosetta, which Apple started including with OS X 10.4.4 Tiger. OS X 10.4.4 was the first version of Apple's operating system that was released with Apple's first Intel-based machines. Rosetta was written to allow many PowerPC applications to run seamlessly on the new Intel-based machines.</p><p>For those developers who are new to Apple products, you might not have heard of Rosetta. This is because Rosetta was not included or supported as of OS X 10.7 Lion. The reason this is mentioned is because if mix and match takes a similar path as Rosetta, it might not be a part of the language forever and from what Apple has said, Swift is the future. It also makes sense from a technological standpoint that as the Swift language evolves and matures, Apple will not want to maintain compatibility with Objective-C.</p><p>If you maintain legacy apps written in Objective-C, it might be a good idea to take advantage of mix and match to slowly upgrade your code base to Swift.</p><p>Let's look at how Swift and Objective-C can interact together. For this, we will be creating a very basic iOS project whose language will be Objective-C, and then we will add some Swift code for the project to use. In the downloadable code for this book, we have included an Objective-C project that consists of Swift code and a Swift project that includes Objective-C code. One thing to keep in mind is that it does not matter if our project is an Objective-C or a Swift project; interaction between Swift and Objective-C works the same way.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec86"/>Using Swift and Objective-C together in the same project</h1></div></div></div><p>In this section, we will be walking through how to add Swift to an Objective-C project. The same steps <a class="indexterm" id="id529"/>can also be used to add the Objective-C code to a Swift project. In the downloadable code for this book, you will find both Objective-C and <a class="indexterm" id="id530"/>Swift projects. These projects <a class="indexterm" id="id531"/>demonstrate how to add the Swift code to an Objective-C project and how to add Objective-C code to a Swift project. In those projects, we can see that mix and match functions exactly the same, no matter what type of project we are using.</p><div><div><div><div><h2 class="title"><a id="ch13lvl2sec118"/>Creating the project</h2></div></div></div><p>Let's begin by <a class="indexterm" id="id532"/>creating an iOS project to work with. When we first start Xcode, we should see a screen that looks similar to the following screenshot:</p><div><img alt="Creating the project" src="img/B05115_13_01.jpg"/></div><p>From this menu, we will want to select the <strong>Create a new Xcode project</strong> option. This option will walk us though creating a new Xcode project. Once this option is selected, Xcode will start up and we will see the following menu. As a shortcut, if we do not see this menu, we can also navigate to <strong>File</strong> | <strong>New</strong> | <strong>Project</strong> in the top menu bar, which will display the following screen:</p><div><img alt="Creating the project" src="img/B05115_13_02.jpg"/></div><p>This menu lets<a class="indexterm" id="id533"/> us select the type of project we will be creating and also what platform we are targeting (iOS or OS X). For this example, we will be targeting the iOS platform and creating a simple Single View Application. Once we make our selection, we should see the following menu:</p><div><img alt="Creating the project" src="img/B05115_13_03.jpg"/></div><p>On this menu, we will define several properties about our project. The two properties we need to focus on are the language of the project and product name. For this particular project, we will select Objective-C as the language and name it <code class="literal">ObjectiveCProject</code>. Once we have all of the properties defined, we can click on the <strong>Next</strong> button. On the last menu, we select where we wish to save the project files, and once we have done that, Xcode creates the project<a class="indexterm" id="id534"/> template files for us, and we can begin.</p><p>The application that we will be creating will let the user enter a name and will then respond with a personal message to them. The user interface will consist of a <code class="literal">UITextField</code> field that the user can enter their name into, a <code class="literal">UIButton</code> that the user will press after they have entered their name, and a <code class="literal">UITextView</code> that will display the personalized message. Since this book is about Swift programming, we will not go into how the user interface is laid out. Full working applications are available as part of the book's downloadable source code.</p><p>Since we are walking through the Objective-C project, the user interface and the <code class="literal">Messages</code> class, which will generate a message, will be written in Objective-C. The message builder, which will personalize the message, will be written in Swift. This will show us how to access a Swift class from the Objective-C code as well as Objective-C resources from our Swift code within an Objective-C project.</p><p>Let's summarize the Objective-C to Swift interaction. The backend for the user interface, which is written in Objective-C, will call the <code class="literal">getPersonalizedMessage()</code> method of the <code class="literal">MessageBuilder</code> class<a class="indexterm" id="id535"/> written in Swift. The <code class="literal">getPersonalizedMessage()</code> method of the <code class="literal">MessageBuilder</code> class will call the <code class="literal">getMessage()</code> function of the <code class="literal">Messages</code> class written in Objective-C.</p></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec119"/>Adding Swift file to the Objective-C project</h2></div></div></div><p>Let's begin by creating the Swift <code class="literal">MessageBuilder</code> class. This class will be used to build the personalized message<a class="indexterm" id="id536"/> for the user. Within Objective-C projects, I usually create a separate group called <code class="literal">SwiftFiles</code> to hold the<a class="indexterm" id="id537"/> Swift files in. This allows me to very easily see what files are written in Swift and what are written in Objective-C. To add a Swift file to our project, right-click on the group icon that we want to add the file to and we should see the following menu:</p><div><img alt="Adding Swift file to the Objective-C project" src="img/B05115_13_04.jpg"/></div><p>From this menu, select the <strong>New File…</strong> option. This option will walk us through creating a new file for our project. Once you select that option, you should see the following menu:</p><div><img alt="Adding Swift file to the Objective-C project" src="img/B05115_13_05.jpg"/></div><p>This menu lets us<a class="indexterm" id="id538"/> choose what type of file<a class="indexterm" id="id539"/> we will be adding to our project. In this case, we will want to add a Swift file to our project; therefore, we will select the <strong>Swift File</strong> option. Once we select this option, we should see the following menu:</p><div><img alt="Adding Swift file to the Objective-C project" src="img/B05115_13_06.jpg"/></div><p>This menu lets us <a class="indexterm" id="id540"/>name the file and define some <a class="indexterm" id="id541"/>of the properties, such as where we will save the file and what group it will be in. In this case, we name the file <code class="literal">MessageBuilder</code>. Once we have finished, we will click on the <strong>Create</strong> button. If this is the first Swift file added to an Objective-C project (or the first Objective-C file added to a Swift project), we should see the following menu pop up:</p><div><img alt="Adding Swift file to the Objective-C project" src="img/B05115_13_07.jpg"/></div><p>This popup offers to<a class="indexterm" id="id542"/> create the bridging header file for use. Select <strong>Create Bridging Header</strong> to create the file.</p></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec120"/>The Objective-C bridging header file – part 1</h2></div></div></div><p>In order to expose our Objective-C files to our Swift code, we rely on an Objective-C header file. The first time we add an Objective-C file to a Swift project or a Swift file to an Objective-C project, Xcode offers to create this file for us. It is easier to let Xcode create and configure this<a class="indexterm" id="id543"/> file rather than doing it manually, so it is recommended to select <strong>Yes</strong> when Xcode offers to create it.</p><p>If for some reason we need to<a class="indexterm" id="id544"/> create the Objective-C bridging header file manually, the following steps show how we would do this:</p><div><ol class="orderedlist arabic"><li class="listitem">Create an Objective-C header file in our project using the <strong>New File…</strong> option we saw earlier. The recommended naming convention for this file is <code class="literal">[MyProjectName]-Bridging-Header.h</code>, where <code class="literal">[MyProjectName]</code> is the name of our project. This will be the header file where we import any Objective-C header files for any Objective-C classes that we want our Swift code to access.</li><li class="listitem">In the project's <strong>Build Settings</strong>, find the <strong>Swift Compiler – Code Generation</strong> section. In this section, locate the setting, titled <strong>Objective-C Bridging Header</strong>. We will want to set this to the path for the bridging header we created in step 1. The path will be from the project root.</li></ol></div><p>The <strong>Objective-C Bridging Header</strong> setting for the present project that we are working on looks similar to the following screenshot:</p><div><img alt="The Objective-C bridging header file – part 1" src="img/B05115_13_08.jpg"/></div><p>Even though the bridging header is located in the <code class="literal">SwiftFiles</code> group, we can see in the settings that the file itself is located at the root of the project. If we want to put the header file in another directory<a class="indexterm" id="id545"/> within the <a class="indexterm" id="id546"/>project, all we would need to do is change the path in this setting.</p></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec121"/>Adding the Objective-C file to the project</h2></div></div></div><p>Now that we have <a class="indexterm" id="id547"/>our Objective-C bridging <a class="indexterm" id="id548"/>header file and the <code class="literal">MessageBuilder</code> Swift file, let's create the Objective-C class that will generate a generic message to the user. We will name this class <code class="literal">Messages</code>. To create this file, right-click on the group folder that we want to add the file to, and we should see the following menu:</p><div><img alt="Adding the Objective-C file to the project" src="img/B05115_13_08a.jpg"/></div><p>From this <a class="indexterm" id="id549"/>menu, select the <strong>New File…</strong> option. This option will walk us through creating a new file for our project. Once <a class="indexterm" id="id550"/>you select that option, you should see the following menu:</p><div><img alt="Adding the Objective-C file to the project" src="img/B05115_13_09.jpg"/></div><p>Previously, when<a class="indexterm" id="id551"/> we added the <code class="literal">MessageBuilder</code> Swift file, we selected <strong>Swift File</strong> on this menu. This time, we will be adding <a class="indexterm" id="id552"/>an Objective-C file, so we will select the <strong>Cocoa Touch Class</strong> option. Once we select that option, we should see a screen similar to this:</p><div><img alt="Adding the Objective-C file to the project" src="img/B05115_13_10.jpg"/></div><p>On this menu, we can enter the class name and also the language for the class. Make sure that the language is set to Objective-C. Finally, we click on the <strong>Next</strong> button, which will take us to a menu that will let us select where we want to save our Objective-C files. Once we select the location to save our files, both the header and implementation files will be added to<a class="indexterm" id="id553"/> our project.</p><p>Now that all of our<a class="indexterm" id="id554"/> files have been created, let's begin writing our code and getting Swift and Objective-C to work together. We will begin by adding the code to the Objective-C <strong>Messages</strong> header and implementation files.</p></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec122"/>The Messages Objective-C class</h2></div></div></div><p>The <code class="literal">Messages</code> Objective-C class <a class="indexterm" id="id555"/>will contain an array of messages and will expose one method named <code class="literal">getMessage</code>, which will <a class="indexterm" id="id556"/>return one randomly picked message from the array.</p><p>The following code shows the <code class="literal">Messages</code> header file:</p><div><pre class="programlisting">#import &lt;Foundation/Foundation.h&gt;

@interface Messages : NSObject

-(NSString *)getMessage;
@end</pre></div><p>In this header file, we expose one method named <code class="literal">getMessage</code> that will return a message when called. The <a class="indexterm" id="id557"/>following code<a class="indexterm" id="id558"/> shows the implementation file for the <code class="literal">Messages</code> class:</p><div><pre class="programlisting">#import "Messages.h"

@implementation Messages

NSMutableArray *theMessages;

-(id)init {
  if ( self = [super init] ) {
    theMessages = [NSMutableArray new];
    [theMessages addObject:@"You should learn from your mistakes"];
    [theMessages addObject:@"It is in the now that we must live"];
    [theMessages addObject:@"The greatest risk is not taking 
      one"];
    [theMessages addObject:@"You will be a Swift programmer"];
  }
    return self;
}

-(NSString *)getMessage {
  int num = arc4random() % theMessages.count;

  return theMessages[num];
}
@end</pre></div><p>In this code, we created the <code class="literal">NSArray</code> object that contains a number of messages. We also created the <code class="literal">getMessage</code> method that randomly picks one of the messages from the <code class="literal">NSArray</code> object and returns it.</p><p>The <code class="literal">Messages</code> class that we just created in Objective-C will need to be accessed by the <code class="literal">MessageBuilder</code> class that we are going to write in Swift. To access an Objective-C class from the Swift code, we need to edit the <code class="literal">Objective-C Bridging Header</code> file.</p></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec123"/>The Objective-C bridging header file – part 2</h2></div></div></div><p>Now that we <a class="indexterm" id="id559"/>have created the <code class="literal">Messages</code> Objective-C class, we will need to expose it to our Swift code. Those who are familiar with Objective-C (or any C-based language), will know that we need to import the class header using the <code class="literal">#import</code> or <code class="literal">#include</code> directive, prior to using it within another <a class="indexterm" id="id560"/>class. In that same context, we need to import the header file of any Objective-C class, in the Objective-C header file, prior to using that class in our Swift code. Therefore, to allow our Swift code to access the <code class="literal">Messages</code> Objective-C class, we need to add the following line to the Objective-C bridging header file that Xcode created for us:</p><div><pre class="programlisting">#import "Messages.h"</pre></div><p>Yep, that is it. Pretty simple. Now, let's look at how we would write the <code class="literal">MessageBuilder</code> Swift <a class="indexterm" id="id561"/>class that will use the <code class="literal">Messages</code> Objective-C class.</p></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec124"/>The MessageBuilder Swift class – accessing Objective-C code from Swift</h2></div></div></div><p>The <code class="literal">MessageBuilder</code> Swift class<a class="indexterm" id="id562"/> will contain one method named <code class="literal">getPersonalizedMessage()</code>. This method will use the <code class="literal">getMessage()</code> method from the <code class="literal">Messages</code> Objective-C class<a class="indexterm" id="id563"/> to retrieve a message and will then customize that message prior to returning it to the function <a class="indexterm" id="id564"/>that called it. Here is the code for the <code class="literal">MessageBuiler</code> Swift class:</p><div><pre class="programlisting">import Foundation

class MessageBuilder: NSObject {
  
  func getPersonalizedMessage(name: String) -&gt; String {
    let messages = Messages()
    let retMessage = "To: " + name + ", " + messages.getMessage()
    
    return retMessage;
  }
}</pre></div><p>When we define this class, we create it as a subclass of the <code class="literal">NSObject</code> class. If a Swift class will be accessed from the Objective-C code, that class needs to be a subclass of the <code class="literal">NSObject</code> class. If we forget to do this, we will receive the <code class="literal">Use of undeclared identifier'{Class Name}</code> error when we try to access the class in the Objective-C code.</p><p>Now, let's look at how we created an instance of the <code class="literal">Messages</code> Objective-C class in our Swift code. The following line creates the instances, <code class="literal">let messages = Messages()</code>. As we can see, we create the instance of the <code class="literal">Messages</code> Objective-C class, exactly as we would create an instance of any Swift class. We then access the <code class="literal">getMessages()</code> method of the <code class="literal">Messages</code> class like we would access a method of any Swift class.</p><p>As we can see from this code, Objective-C classes are both initiated and used as if they were written in Swift <a class="indexterm" id="id565"/>when we access them from a class written in Swift. This allows us to access our Objective-C and <a class="indexterm" id="id566"/>Swift types in a consistent way.</p><p>Now that we have <a class="indexterm" id="id567"/>created the <code class="literal">MessageBuilder</code> Swift class, we need a way to call the <code class="literal">getPersonalizedMessage()</code> method, from the <code class="literal">ViewController</code> Objective-C class.</p></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec125"/>The Objective-C class – accessing Swift code from Objective-C</h2></div></div></div><p>Once the user enters their <a class="indexterm" id="id568"/>name and presses the <strong>Get Message</strong> button, we will create an instance of the <code class="literal">MessageBuilder</code> Swift class, in Objective-C, and call the <code class="literal">getPersonlizedMessage()</code> method to generate the message<a class="indexterm" id="id569"/> to be displayed.</p><p>When we access Swift code from Objective-C, we rely on an Xcode-generated header file to expose the Swift classes. This automatically generated header file declares the interface for the Swift classes. The name for this header file is the name of your project, followed by <code class="literal">–Swift.h</code>. So, the name of the header file for our project is <code class="literal">ObjectiveCProject-Swift.h</code>. Therefore, the first step to access the Swift code from Objective-C is to import this header file, as shown in the following line of code:</p><div><pre class="programlisting">#import "ObjectiveCProject-Swift.h"</pre></div><p>Now that we have imported the header file to expose our Swift classes, we can use the <code class="literal">MessageBuilder</code> Swift class within the Objective-C code. We create an instance of the <code class="literal">MessageBuilder</code> Swift class exactly like we would create an instance of any standard Objective-C class. We also call the method and properties of a Swift class exactly like we would call the method and properties from an Objective-C class. The following example shows how we would create an instance of the <code class="literal">MessageBuilder</code> Swift class, and also how we would call the <code class="literal">getPersonalizedMessage()</code> method of that class:</p><div><pre class="programlisting">MessageBuilder *mb = [[MessageBuilder alloc] init];
self.messageView.text = [mb getPersonalizedMessage:@"Jon"];</pre></div><p>As we can see from this code sample, Swift classes are treated as if they were Objective-C classes when we access them from Objective-C. Once again, this allows us to access both our Objective-C and <a class="indexterm" id="id570"/>Swift types in a consistent manner.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec87"/>Summary</h1></div></div></div><p>As we saw in this chapter, Apple has made mix and match very easy and convenient to use. In order to access Swift classes from our Objective-C code, all we need to do is import the Xcode-generated header file that exposes the Swift classes. While we do not see this header file as part of our code, Xcode automatically creates it for mixed language projects. The name of this header file takes the format of <code class="literal">{Project Name}-Swift.h</code>, where <code class="literal">{Project Name}</code> is the name of our project.</p><p>It is also very easy to use Objective-C classes within our Swift code. To expose Objective-C classes to our Swift code, all we need to do is add the Objective-C header file to the Objective-C bridging header file. Xcode can create this bridging header file for us the first time we add an Objective-C file to a Swift project, or the first time we add a Swift file to an Objective-C project.</p><p>While Apple has said that the future of application development for iOS and OS X platforms is in Swift, mix and match can be used to slowly migrate our current Objective-C code base to Swift. Mix and match also lets us use Objective-C frameworks in our Swift projects or Swift frameworks in our Objective-C projects.</p></div></body></html>