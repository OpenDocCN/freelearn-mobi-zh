<html><head></head><body>
        

                            
                    <h1 class="header-title">A First Look at OpenGL ES</h1>
                
            
            
                
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Setting up the OpenGL ES environment</li>
<li>Drawing shapes on GLSurfaceView</li>
<li>Applying the projection and camera view while drawing</li>
<li>Moving the triangle with rotation</li>
<li>Rotating the triangle with user input</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>As we saw in the previous chapter, Android offers many tools for handling graphics and animations. Although the canvas and drawable objects are designed for custom drawing, when you need high-performance graphics, especially 3D gaming graphics, Android also supports OpenGL ES. <strong>Open Graphics Library for Embedded Systems</strong> (<strong>OpenGL ES</strong>), is targeted at embedded systems. (Embedded systems include consoles and phones.)</p>
<p>This chapter is meant to serve as an introduction to using OpenGL ES on Android. As usual, we'll provide the steps and explain how things work, but we aren't going to be digging into the math or technical details of OpenGL. If you are already familiar with OpenGL ES from other platforms, such as iOS, this chapter should get you up and running quickly. If you are new to OpenGL, hopefully these recipes will help you decide whether this is an area you want to pursue.</p>
<p>Android supports the following versions of OpenGL:</p>
<ul>
<li><strong>OpenGL ES 1.0</strong>: Android 1.0</li>
<li><strong>OpenGL ES 2.0</strong>: Introduced in Android 2.2 (API 8)</li>
<li><strong>OpenGL ES 3.0</strong>: Introduced in Android 4.3 (API 18)</li>
<li><strong>OpenGL ES 3.1</strong>: Introduced in Android 5.0 (API 21)</li>
</ul>
<p>The recipes in this chapter are introductory and target OpenGL ES 2.0 and higher. OpenGL ES 2.0 is available for nearly all devices currently available. Unlike OpenGL ES 2.0 and lower, OpenGL 3.0 and higher require driver implementation from the hardware manufacturer. This means that, even if your application is running on Android 5.0, OpenGL 3.0 and higher may not be available. Therefore, it's a good programming practice to check the available OpenGL versions at runtime. Alternatively, if your application requires 3.0 and higher features, you can add a <kbd>&lt;uses-feature/&gt;</kbd> element to your Android manifest. (We'll discuss this in the first recipe that follows.)</p>
<p>Unlike the other chapters in this book, this chapter is written more as a tutorial, with each recipe building on lessons learned from the previous recipe. The <em>Getting ready</em> section of each recipe will clarify the prerequisites.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up the OpenGL ES environment</h1>
                
            
            
                
<p>Our first recipe will start by showing the steps to set up an activity to use an OpenGL <kbd>GLSurfaceView</kbd>. Similar to the canvas, the <kbd>GLSurfaceView</kbd> is where you will do your OpenGL drawing. As this is the starting point, the other recipes will refer to this recipe as the base step when they need a <kbd>GLSurfaceView</kbd> created.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>SetupOpenGL</kbd>. Use the default Phone &amp; Tablet options and select Empty Activity when prompted for Activity Type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We'll start by indicating the application's use of OpenGL in the Android Manifest, and then we'll add the OpenGL classes to the activity. Here are the steps:</p>
<ol>
<li>Open the Android Manifest and add the following XML:</li>
</ol>
<pre style="padding-left: 60px">&lt;uses-feature android:glEsVersion="0x00020000" android:required="true" /&gt; </pre>
<ol start="2">
<li>Open <kbd>MainActivity.java</kbd> and add the following global variables:</li>
</ol>
<pre style="padding-left: 60px">private GLSurfaceView mGLSurfaceView;</pre>
<ol start="3">
<li>Add the following inner class to the <kbd>MainActivity</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">class GLRenderer implements GLSurfaceView.Renderer {<br/>    public void onSurfaceCreated(GL10 unused, EGLConfig config) {<br/>        GLES20.glClearColor(0.5f, 0.5f, 0.5f, 1.0f);<br/>    }<br/>    public void onDrawFrame(GL10 unused) {<br/>        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);<br/>    }<br/>    public void onSurfaceChanged(GL10 unused, int width, int height) {<br/>        GLES20.glViewport(0, 0, width, height);<br/>    }<br/>}</pre>
<ol start="4">
<li>Add another inner class to the <kbd>MainActivity</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">class CustomGLSurfaceView extends GLSurfaceView {<br/><br/>    private final GLRenderer mGLRenderer;<br/><br/>    public CustomGLSurfaceView(Context context){<br/>        super(context);<br/>        setEGLContextClientVersion(2);<br/>        mGLRenderer = new GLRenderer();<br/>        setRenderer(mGLRenderer);<br/>    }<br/>}</pre>
<ol start="5">
<li>Modify the existing <kbd>onCreate()</kbd> method as follows:</li>
</ol>
<pre style="padding-left: 60px">@Override<br/>protected void onCreate(Bundle savedInstanceState) {<br/>    super.onCreate(savedInstanceState);<br/>    mGLSurfaceView = new CustomGLSurfaceView(this);<br/>    setContentView(mGLSurfaceView);<br/>}</pre>
<ol start="6">
<li>You're ready to run the application on a device or emulator.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>If you ran the preceding application, you saw the activity created and the background set to gray. Since these are the basic steps for setting up OpenGL, you'll be reusing this code for the other recipes in this chapter as well. The following explains the process detail.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Declaring OpenGL in the Android Manifest</h1>
                
            
            
                
<p>We start by declaring our requirement to use OpenGL ES version 2.0 in the Android Manifest with the following line:</p>
<pre>&lt;uses-feature android:glEsVersion="0x00020000" android:required="true" /&gt; </pre>
<p>If we were using version 3.0, we would use this:</p>
<pre>&lt;uses-feature android:glEsVersion="0x00030000" android:required="true" /&gt; </pre>
<p>For version 3.1, use this:</p>
<pre>&lt;uses-feature android:glEsVersion="0x00030001" android:required="true" /&gt; </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Extending the GLSurfaceView class</h1>
                
            
            
                
<p>Create a custom OpenGL <kbd>SurfaceView</kbd> class by extending <kbd>GLSurfaceView</kbd>, as we do in this code:</p>
<pre>class CustomGLSurfaceView extends GLSurfaceView {<br/><br/>    private final GLRenderer mGLRenderer;<br/><br/>    public CustomGLSurfaceView(Context context){<br/>        super(context);<br/>        setEGLContextClientVersion(2);<br/>        mGLRenderer = new GLRenderer();<br/>        setRenderer(mGLRenderer);<br/>    }<br/>}</pre>
<p>Here, we instantiate an OpenGL rendered class and pass it to the <kbd>GLSurfaceView</kbd> class with the <kbd>setRenderer()</kbd> method. The OpenGL <kbd>SurfaceView</kbd> provides a surface for our OpenGL drawing, similar to the <kbd>Canvas</kbd> and <kbd>SurfaceView</kbd> objects. The actual drawing is done in the <kbd>Renderer</kbd>, which we'll create next.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating an OpenGL rendered class</h1>
                
            
            
                
<p>The last step is to create the <kbd>GLSurfaceView.Renderer</kbd> class and implement the following three callbacks:</p>
<ul>
<li><kbd>onSurfaceCreated()</kbd></li>
<li><kbd>onDrawFrame()</kbd></li>
<li><kbd>onSurfaceChanged()</kbd></li>
</ul>
<p>Following is the code:</p>
<pre>class GLRenderer implements GLSurfaceView.Renderer {<br/>    public void onSurfaceCreated(GL10 unused, EGLConfig config) {<br/>        GLES20.glClearColor(0.5f, 0.5f, 0.5f, 1.0f);<br/>    }<br/>    public void onDrawFrame(GL10 unused) {<br/>        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);<br/>    }<br/>    public void onSurfaceChanged(GL10 unused, int width, int height) {<br/>        GLES20.glViewport(0, 0, width, height);<br/>    }<br/>}</pre>
<p>Right now, all we're doing with this class is setting up the callbacks and clearing the screen using the color we specify with <kbd>glClearColor()</kbd> (gray in this case).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>With the OpenGL environment set up, we'll continue to the next recipe where we'll actually draw on the view.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Drawing shapes on GLSurfaceView</h1>
                
            
            
                
<p>The previous recipe set up the activity to use OpenGL. This recipe will continue by showing how to draw on <kbd>OpenGLSurfaceView</kbd>.</p>
<p>First, we need to define the shape. With OpenGL, it is important to realize that the order in which the vertices of a shape are defined is very important, as they determine the front (face) and back of the shape. It's customary (and the default behavior) to define vertices counterclockwise. (Although this behavior can be changed, it requires additional code and is not standard practice.)</p>
<p>It's also important to understand the OpenGL screen coordinate system, as it differs from the Android canvas. The default coordinate system defines (<kbd>0,0,0</kbd>) as the center of the screen. The four edge points are as follows:</p>
<ul>
<li><strong>Top left</strong>: (<kbd>-1.0, 1.0, 0</kbd>)</li>
<li><strong>Top right</strong>: (<kbd>1.0, 1.0, 0</kbd>)</li>
<li><strong>Bottom left</strong>: (<kbd>-1.0, -1.0, 0</kbd>)</li>
<li><strong>Bottom right</strong>: (<kbd>1.0, -1.0, 0</kbd>)</li>
</ul>
<p>The <em>Z</em> axis comes straight out of the screen or straight behind.</p>
<p>We're going to create a <kbd>Triangle</kbd> class since it is the base shape. In OpenGL, you generally use a collection of triangles to create objects. To draw a shape with OpenGL, we need to define the following:</p>
<ul>
<li><strong>Vertex shader</strong>: This is to draw the shape</li>
<li><strong>Fragment shader</strong>: This is to color the shape</li>
<li><strong>Program</strong>: This is an OpenGL ES object for the preceding shaders</li>
</ul>
<p>The shaders are defined using <strong>OpenGL Shading Language</strong> (<strong>GLSL</strong>), and then compiled and added to the OpenGL program object.</p>
<p>Following are two screenshots showing the triangle in portrait orientation:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/89b183c4-e729-4e93-8a6e-e55f7c531575.png" style="width:17.42em;height:33.33em;"/></p>
<p>Here is the same image when the orientation is rotated to landscape:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/54be5673-709e-445f-a85a-c0bb8b4e8e3f.png" style="width:42.08em;height:22.00em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>ShapesWithOpenGL</kbd>. Use the default Phone &amp; Tablet options and select Empty Activity when prompted for Activity Type.</p>
<p>This recipe uses the OpenGL environment created in the previous recipe, <em>Setting up the Open GL environment</em>. Refer to the previous recipe if you have not already completed those steps.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>As indicated previously, we'll be using the OpenGL environment created in the previous recipe. The steps that follow will walk you through creating a class for the triangle shape and drawing it on the GLSurfaceView:</p>
<ol>
<li>Create a new Java class called <kbd>Triangle</kbd>.</li>
</ol>
<ol start="2">
<li>Add the following global declarations to the <kbd>Triangle</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">private final String vertexShaderCode = "attribute vec4 vPosition;" +<br/>                "void main() {" +<br/>                "  gl_Position = vPosition;" +<br/>                "}";<br/><br/>private final String fragmentShaderCode = "precision mediump float;" +<br/>                "uniform vec4 vColor;" +<br/>                "void main() {" +<br/>                "  gl_FragColor = vColor;" +<br/>                "}";<br/><br/>final int COORDS_PER_VERTEX = 3;<br/>float triangleCoords[] = {<br/>        0.0f,  0.66f, 0.0f,<br/>        -0.5f, -0.33f, 0.0f,<br/>        0.5f, -0.33f, 0.0f<br/>};<br/><br/>float color[] = { 0.63f, 0.76f, 0.22f, 1.0f };<br/><br/>private final int mProgram;<br/>private FloatBuffer vertexBuffer;<br/>private int mPositionHandle;<br/>private int mColorHandle;<br/>private final int vertexCount = triangleCoords.length / COORDS_PER_VERTEX;<br/>private final int vertexStride = COORDS_PER_VERTEX * 4;</pre>
<ol start="3">
<li>Add the following <kbd>loadShader()</kbd> method to the <kbd>Triangle</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">public int loadShader(int type, String shaderCode){<br/>     int shader = GLES20.glCreateShader(type);<br/>     GLES20.glShaderSource(shader, shaderCode);<br/>     GLES20.glCompileShader(shader);<br/>     return shader; 
} </pre>
<ol start="4">
<li>Add the <kbd>Triangle</kbd> constructor, as shown here:</li>
</ol>
<pre style="padding-left: 60px">public Triangle() {<br/>     int vertexShader = loadShader(<br/>             GLES20.GL_VERTEX_SHADER,<br/>             vertexShaderCode);<br/>     int fragmentShader = loadShader(<br/>             GLES20.GL_FRAGMENT_SHADER,<br/>             fragmentShaderCode);<br/>     mProgram = GLES20.glCreateProgram();<br/>     GLES20.glAttachShader(mProgram, vertexShader);<br/>     GLES20.glAttachShader(mProgram, fragmentShader);<br/>     GLES20.glLinkProgram(mProgram);<br/><br/>     ByteBuffer bb = ByteBuffer.allocateDirect(<br/>             triangleCoords.length * 4);<br/>     bb.order(ByteOrder.nativeOrder());<br/><br/>     vertexBuffer = bb.asFloatBuffer();<br/>     vertexBuffer.put(triangleCoords);<br/>     vertexBuffer.position(0); 
} </pre>
<ol start="5">
<li>Add the <kbd>draw()</kbd> method as follows:</li>
</ol>
<pre style="padding-left: 60px">public void draw() {<br/>     GLES20.glUseProgram(mProgram);<br/>     mPositionHandle = GLES20.glGetAttribLocation(mProgram, "vPosition");<br/>     GLES20.glEnableVertexAttribArray(mPositionHandle);<br/>     GLES20.glVertexAttribPointer(mPositionHandle, <br/>             COORDS_PER_VERTEX,<br/>             GLES20.GL_FLOAT, false,<br/>             vertexStride, vertexBuffer);<br/>     mColorHandle = GLES20.glGetUniformLocation(mProgram, "vColor");<br/>     GLES20.glUniform4fv(mColorHandle, 1, color, 0);<br/>     GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, vertexCount);<br/>     GLES20.glDisableVertexAttribArray(mPositionHandle); 
} </pre>
<ol start="6">
<li>Now, open <kbd>MainActivity.java</kbd> and add a <kbd>Triangle</kbd> variable to the <kbd>GLRenderer</kbd> class as follows:</li>
</ol>
<pre style="padding-left: 60px">private Triangle mTriangle; </pre>
<ol start="7">
<li>Initialize the <kbd>Triangle</kbd> variable in the <kbd>onSurfaceCreated()</kbd> callback as follows:</li>
</ol>
<pre style="padding-left: 60px">mTriangle = new Triangle();</pre>
<ol start="8">
<li>In the <kbd>onDrawFrame()</kbd> callback, call the <kbd>Triangle</kbd> <kbd>draw()</kbd> method after glClear is called:</li>
</ol>
<pre style="padding-left: 60px">mTriangle.draw(); </pre>
<ol start="9">
<li>You're ready to run the application on a device or emulator.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As mentioned in the introduction, to draw with OpenGL we first have to define the shaders, which we do with the following code:</p>
<pre>private final String vertexShaderCode = "attribute vec4 vPosition;" +<br/>        "void main() {" +<br/>        "  gl_Position = vPosition;" +<br/>        "}";<br/><br/>private final String fragmentShaderCode = "precision mediump float;" +<br/>        "uniform vec4 vColor;" +<br/>        "void main() {" +<br/>        "  gl_FragColor = vColor;" +<br/>        "}";</pre>
<p>Since this is uncompiled <strong>OpenGL Shading Language</strong> (<strong>OpenGLSL</strong>), the next step is to compile and attach it to our OpenGL object, which we do with the following two OpenGL ES methods:</p>
<ul>
<li><kbd>glAttachShader()</kbd></li>
<li><kbd>glLinkProgram()</kbd></li>
</ul>
<p>After setting up the shaders, we create <kbd>ByteBuffer</kbd> to store the triangle vertices, which are defined in <kbd>triangleCoords</kbd>. The <kbd>draw()</kbd> method is where the actual drawing occurs using the GLES20 library calls, which is called from the <kbd>onDrawFrame()</kbd> callback.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>From the screenshots in the introduction, you may have noticed that the triangles in the portrait and landscape do not look identical to each other. As you can see from the code, we make no distinction in terms of orientation when drawing. We'll explain why this is happening and show how to correct this issue in the next recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<p>For more information on the OpenGL Shading Language, refer to the following link: <a href="https://www.opengl.org/documentation/glsl/">https://www.opengl.org/documentation/glsl/</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Applying the projection and camera view while drawing</h1>
                
            
            
                
<p>As we saw in the previous recipe, when we draw our shape on the screen, the shape is skewed by the screen orientation. The reason for this is because, by default, OpenGL assumes a perfectly square screen. As we mentioned before, the default screen coordinates for the top right are (<kbd>1,1,0</kbd>) and (<kbd>-1,-1,0</kbd>) for the bottom left.</p>
<p>Since most device screens are not perfectly square, we need to map the display coordinates to match our physical device. In OpenGL, we do this with p<em>rojection</em>. This recipe will show how to use projection to match the GLSurfaceView coordinates with the device coordinates. Along with the projection, we'll also show how to set the Camera View. Following is a screenshot showing the final result:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/d3734a37-5c26-46da-8476-ad9941368990.png" style="width:19.50em;height:37.25em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>ProjectionAndCamera</kbd>. Use the default Phone &amp; Tablet options and select Empty Activity when prompted for Activity Type.</p>
<p>This recipe builds on the previous recipe, <em>Drawing shapes on GLSurfaceView</em>. If you don't already have the previous recipe, start there before starting these steps.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>As stated previously, this recipe will build on the previous recipe, so complete those steps before starting. We will be modifying the previous code to add the projection and camera view to the drawing calculations. Here are the steps:</p>
<ol>
<li>Open the <kbd>Triangle</kbd> class and add the following global declaration to the existing declarations:</li>
</ol>
<pre style="padding-left: 60px">private int mMVPMatrixHandle; </pre>
<ol start="2">
<li>Add a matrix variable to <kbd>vertexShaderCode</kbd> and use it in the position calculation. Here is the final result:</li>
</ol>
<pre style="padding-left: 60px">private final String vertexShaderCode = "attribute vec4 vPosition;" +<br/>                "uniform mat4 uMVPMatrix;" +<br/>                "void main() {" +<br/>                "  gl_Position = uMVPMatrix * vPosition;" +<br/>                "}";</pre>
<ol start="3">
<li>Change the <kbd>draw()</kbd> method to pass in a matrix parameter as follows:</li>
</ol>
<pre style="padding-left: 60px">public void draw(float[] mvpMatrix) {</pre>
<ol start="4">
<li>To use the transformation matrix, add the following code to the <kbd>draw()</kbd> method just before the <kbd>GLES20.glDrawArrays()</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">mMVPMatrixHandle = GLES20.glGetUniformLocation(mProgram, "uMVPMatrix"); 
GLES20.glUniformMatrix4fv(mMVPMatrixHandle, 1, false, mvpMatrix, 0);</pre>
<ol start="5">
<li>Open <kbd>MainActivity.java</kbd> and add the following class variables to the <kbd>GLRenderer</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">private final float[] mMVPMatrix = new float[16]; 
private final float[] mProjectionMatrix = new float[16]; 
private final float[] mViewMatrix = new float[16]; </pre>
<ol start="6">
<li>Modify the <kbd>onSurfaceChanged()</kbd> callback to calculate the position matrix as follows:</li>
</ol>
<pre style="padding-left: 60px">public void onSurfaceChanged(GL10 unused, int width, int height) { 
    GLES20.glViewport(0, 0, width, height); 
    float ratio = (float) width / height; 
    Matrix.frustumM(mProjectionMatrix, 0, -ratio, ratio, -1, 1, 3, 7); 
} </pre>
<ol start="7">
<li>Modify the <kbd>onDrawFrame()</kbd> callback to calculate the Camera View as follows:</li>
</ol>
<pre style="padding-left: 60px">public void onDrawFrame(GL10 unused) { 
    Matrix.setLookAtM(mViewMatrix, 0, 0, 0, -3, 0f, 0f, 0f, 0f, <br/>         1.0f, 0.0f);    Matrix.multiplyMM(mMVPMatrix, 0, mProjectionMatrix, 0, <br/>         mViewMatrix, 0); 
    GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT); 
    mTriangle.draw(mMVPMatrix); 
} </pre>
<ol start="8">
<li>You're ready to run the application on a device or emulator.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>First, we modify the <kbd>vertexShaderCode</kbd> to include a matrix variable. We calculate the matrix in the <kbd>onSurfaceChanged()</kbd> callback using the height and width, which are passed in as parameters. We pass the transformation matrix to the <kbd>draw()</kbd> method to use it when calculating the position to draw.</p>
<p>Before we call the <kbd>draw()</kbd> method, we calculate the camera view. These two lines of code calculate the camera view:</p>
<pre>Matrix.setLookAtM(mViewMatrix, 0, 0, 0, -3, 0f, 0f, 0f, 0f, 1.0f, 0.0f);<br/> Matrix.multiplyMM(mMVPMatrix, 0, mProjectionMatrix, 0, mViewMatrix, 0);</pre>
<p>Without this code, there would actually be no triangle drawn as the camera perspective would not "see" our vertices. (This goes back to our discussion on how the order of the vertices dictates the front and back of the image.)</p>
<p>When you run the program now, you'll see the output shown in the <em>Introduction</em>. Notice that we now have an equilateral triangle (all sides equal), even when the display is rotated.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>In the next recipe, we will start showing the power of OpenGL by rotating the triangle.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Moving the triangle with rotation</h1>
                
            
            
                
<p>What we've demonstrated so far with OpenGL would probably be easier using the traditional canvas or drawable objects. This recipe will show a bit of the power of OpenGL by rotating the triangle. Not that we can't create movement with the other drawing methods, but how easily can we do this with OpenGL?</p>
<p>This recipe will demonstrate how to rotate the triangle, as the following screenshot shows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/eb0bb8c5-e7c9-4e42-a3ec-bd3d9122c297.png" style="width:21.33em;height:40.67em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>CreatingMovement</kbd>. Use the default Phone &amp; Tablet options and select Empty Activity when prompted for Activity Type.</p>
<p>This recipe builds on the previous recipe, <em>Applying the projection and camera view while drawing</em>. Refer to the previous recipe if you have not already completed those steps.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Since we are continuing from the previous recipe, we have very little work to do. Open <kbd>MainActivity.java</kbd> and follow these steps:</p>
<ol>
<li>Add a Matrix to the <kbd>GLRendered</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">private float[] mRotationMatrix = new float[16]; </pre>
<ol start="2">
<li>In the <kbd>onDrawFrame()</kbd> callback, replace the existing <kbd>mTriangle.draw(mMVPMatrix);</kbd> statement with the following code:</li>
</ol>
<pre style="padding-left: 60px">float[] tempMatrix = new float[16]; 
long time = SystemClock.uptimeMillis() % 4000L; 
float angle = 0.090f * ((int) time); 
Matrix.setRotateM(mRotationMatrix, 0, angle, 0, 0, -1.0f); 
Matrix.multiplyMM(tempMatrix, 0, mMVPMatrix, 0, mRotationMatrix, 0); 
mTriangle.draw(tempMatrix); </pre>
<ol start="3">
<li>You're ready to run the application on a device or emulator.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We're using the <kbd>Matrix.setRotateM()</kbd> method to calculate a new rotation matrix based on the angle we pass in. For this example, we're using the system uptime to calculate an angle. We can use whatever method we want to derive an angle, such as a sensor reading or touch events.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Using the system clock provides the added benefit of creating continuous movement, which certainly looks better for demonstration purposes. The next recipe will demonstrate how to use user input to derive an angle for rotating the triangle.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The render mode</h1>
                
            
            
                
<p>OpenGL offers a <kbd>setRenderMode()</kbd> option to draw only when the view is dirty. This can be enabled by adding the following code to the <kbd>CustomGLSurfaceView()</kbd> constructor just below the <kbd>setRenderer()</kbd> call:</p>
<pre>setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY); </pre>
<p>This will cause the display to update just once, then wait until we request an update with <kbd>requestRender()</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Rotating the triangle with user input</h1>
                
            
            
                
<p>The previous example demonstrated rotating the triangle based on the system clock. This created a continuously rotating triangle, depending on the render mode we used. But what if you wanted to respond to the input from the user?</p>
<p>In this recipe, we'll show how to respond to user input by overriding the <kbd>onTouchEvent()</kbd> callback from <kbd>GLSurfaceView</kbd>. We'll still rotate the triangle using the <kbd>Matrix.setRotateM()</kbd> method, but instead of deriving an angle from the system time, we'll calculate an angle based on the touch location.</p>
<p>Here's a screenshot showing this recipe running on a physical device (to highlight the touch, the Show touches developer option is enabled):</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/3405c31e-8deb-4491-b3bf-5f7418a7d4f7.png" style="width:18.58em;height:32.75em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>RotateWithUserInput</kbd>. Use the default Phone &amp; Tablet options and select Empty Activity when prompted for Activity Type.</p>
<p>This recipe demonstrates an alternative approach to the previous recipe and therefore will be based on the <em>Applying the projection and camera view while drawing</em> (the same starting point as the previous recipe.)</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>As stated previously, we will continue, not from the previous recipe, but from the <em>Applying the projection and camera view while drawing</em> recipe. Open <kbd>MainActivity.java</kbd> and follow these steps:</p>
<ol>
<li>Add the following global variables to the <kbd>MainActivity</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">private float mCenterX=0; 
private float mCenterY=0; </pre>
<ol start="2">
<li>Add the following code to the <kbd>GLRendered</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">private float[] mRotationMatrix = new float[16];<br/>public volatile float mAngle;<br/>public void setAngle(float angle) {<br/>    mAngle = angle;<br/>}</pre>
<ol start="3">
<li>In the same class, modify the <kbd>onDrawFrame()</kbd> method by replacing the existing <kbd>mTriangle.draw(mMVPMatrix);</kbd> statement with the following code:</li>
</ol>
<pre style="padding-left: 60px">float[] tempMatrix = new float[16];<br/>Matrix.setRotateM(mRotationMatrix, 0, mAngle, 0, 0, -1.0f);<br/>Matrix.multiplyMM(tempMatrix, 0, mMVPMatrix, 0, mRotationMatrix, 0);<br/>mTriangle.draw(tempMatrix);</pre>
<ol start="4">
<li>Add the following code to the <kbd>onSurfaceChanged()</kbd> callback:</li>
</ol>
<pre style="padding-left: 60px">mCenterX=width/2; 
mCenterY=height/2; </pre>
<ol start="5">
<li>Add the following code to the <kbd>CustomGLSurfaceView</kbd> constructor, which is below <kbd>setRenderer()</kbd>:</li>
</ol>
<pre style="padding-left: 60px">setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY); </pre>
<ol start="6">
<li>Add the following <kbd>onTouchEvent()</kbd> to the <kbd>CustomGLSurfaceView</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">@Override<br/>public boolean onTouchEvent(MotionEvent e) {<br/>    float x = e.getX();<br/>    float y = e.getY();<br/>    switch (e.getAction()) {<br/>        case MotionEvent.ACTION_MOVE:<br/>            double angleRadians = Math.atan2(y-mCenterY,x-mCenterX);<br/>            mGLRenderer.setAngle((float)Math.toDegrees<br/>                    (-angleRadians));<br/>            requestRender();<br/>    }<br/>    return true;<br/>}</pre>
<ol start="7">
<li>You're ready to run the application on a device or emulator.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The obvious difference between this example and the previous recipe lies in how we derive the angle to pass to the <kbd>Matrix.setRotateM()</kbd> call. We also changed the <kbd>GLSurfaceView</kbd> render mode using <kbd>setRenderMode()</kbd> to only draw on request. We made the request using <kbd>requestRender()</kbd> after calculating a new angle in the <kbd>onTouchEvent()</kbd> callback.</p>
<p>We also demonstrated the importance of deriving our own <kbd>GLSurfaceView</kbd> class. Without our <kbd>CustomGLSurfaceView</kbd> class, we would not have a way to override the <kbd>onTouchEvent</kbd> callback or any other callbacks from <kbd>GLSurfaceView</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>This concludes the OpenGL ES recipes, but we've only just touched upon the power of OpenGL. If you're serious about learning OpenGL, see the links in the next section and check out one of the many books written on OpenGL. There are also many frameworks available, both 2D and 3D, for graphics and game development.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li><strong>OpenGL</strong>: The Industry Standard for High-Performance Graphics: <a href="https://www.opengl.org/">https://www.opengl.org/</a></li>
<li><strong>OpenGL ES</strong>: The Standard for Embedded Accelerated 3D Graphics: <a href="https://www.khronos.org/opengles/">https://www.khronos.org/opengles/</a></li>
<li><strong>Unreal Engine</strong>: Android Quick Start: <a href="https://docs.unrealengine.com/latest/INT/Platforms/Android/GettingStarted/index.html">https://docs.unrealengine.com/latest/INT/Platforms/Android/GettingStarted/index.html</a></li>
<li><strong>libGDX</strong>: Cross-platform Java game development framework based on OpenGL: <a href="https://github.com/libgdx/libgdx">https://github.com/libgdx/libgdx</a></li>
</ul>


            

            
        
    </body></html>