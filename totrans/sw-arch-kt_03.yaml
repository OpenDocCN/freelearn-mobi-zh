- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polymorphism and Alternatives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to take a real-life example and solve the problem
    by implementing various solutions using different approaches. We will use **polymorphism**
    as a baseline for the solution. Afterward, we will use other approaches that are
    powered by the Kotlin language. Finally, we will compare them and try to understand
    which one is suitable under which circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Why Kotlin?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-life example – revisited
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphic solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sealed class solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delegation solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparison and summary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find all the code files used in this chapter on GitHub: [https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-3](https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Why Kotlin?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kotlin is chosen to be the primary programming language for all the examples
    in this book. There are several reasons for this choice:'
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin has gained significant popularity since it was released in 2011
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be used for both frontend and backend applications, which allows for
    a wide range of architecture topics to be illustrated with the same language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a concise, readable, and expressive syntax that helps us understand the
    implementation without a deep understanding of the language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is interoperable with Java so code examples can leverage existing numerous
    libraries in both Java and Kotlin if applicable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-life example – revisited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are using the same real-life example as in *Chapters 1* and *2*. This example
    is as follows. In a village, households provide services to and receive services
    from other households. To provide clarity to the exchange of services among households,
    software was created to keep records of the contract for exchanged services (the
    “contract”).
  prefs: []
  type: TYPE_NORMAL
- en: 'After both households have agreed on the services to be exchanged in the contract,
    each household will need to perform the service. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Repairing a piece of furniture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a dress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Babysitting a toddler for *x* hours
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing a trick at a party
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Donating a used piece of clothing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing food and drinks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleaning *n* rooms in the house
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need to be able to capture the details of these services and to be able
    to verify that the service has been performed. Once both services in a contract
    have been performed, the contract is concluded and reaches its terminal state.
    Let us focus on one scenario, in which Household A performed a service for Household
    B and Household B confirmed that Household A performed the service as per the
    contract. The sequence of interactions can be briefly described in the following
    UML sequence diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Revisiting the real-time example](img/B21737_03_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Revisiting the real-time example
  prefs: []
  type: TYPE_NORMAL
- en: Inside the **Exchange Service**, we need to provide two functions. One function
    is provided for a household performing a service for the other household. Another
    function is provided for a household to confirm that the service was performed
    by the other household as per the contract. The problem is that distinct types
    of services would require different ways to claim and confirm completion.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the service is to repair an item, then it only takes the repairer
    household to acknowledge that the item has been repaired. The receiver household
    would confirm that the item was repaired. If the service is to babysit a toddler,
    then the babysitter household may instead log the hours spent babysitting to confirm
    that the service was performed. Sometimes, the service is an aggregation of multiple
    sub-services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Minimally, there should be two functions to perform a service and to check
    whether a service was performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For this exercise, let us assume that we need to support three types of services:
    plumbing, babysitting, and room cleaning:'
  prefs: []
  type: TYPE_NORMAL
- en: The plumbing service requires the plumber household to report the service as
    started and completed; the other household then confirms this
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The babysitting service requires the babysitter household to log the start of
    the session and track it until the other household picks up the toddler and logs
    the total duration of the service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The room cleaning service requires the cleaner household to log the start of
    the service and the rooms cleaned, then the other household to confirm that all
    rooms, as per the contract, have been cleaned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us start by solving this exercise with a polymorphic approach.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphic solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In object-oriented programming, polymorphism provides a powerful way to abstract
    an interface of many forms. Polymorphism literally means *many forms* in Greek.
  prefs: []
  type: TYPE_NORMAL
- en: 'The common interface of the households contains a function called `performService`
    to signal the start of the service, as well as a function called `wasServicePerformed`
    to return true if the service was performed as per the agreement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This solution can be illustrated in the following UML class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Polymorphic solution](img/B21737_03_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Polymorphic solution
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Plumbing` class is relatively simple. It provides a function for the household
    to start the service, a function to report the service completed, and a function
    for the other household to confirm that the service has been performed. Meanwhile,
    timestamps are recorded that indicate when the service was performed, completed,
    and confirmed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Babysitting` class is different because the completion criterion is based
    on the duration of the service. The class’s constructor takes an agreed number
    of hours to determine whether the service has been completed. There is one function
    for the babysitter household to start the job and another for the other household
    to confirm the end of the job. If the duration is the same as or longer than the
    agreed hours, the service is considered performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RoomCleaning` class has performed the service when all the rooms in agreement
    have been cleaned. The constructor takes a `Set` of room names, which is later
    used to check whether all of the rooms in the agreement have been cleaned. It
    has one function for the cleaner to start the job and another for the other household
    to confirm whether each room has been cleaned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a `main` function to have all these households perform the service
    and the results are printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The program should print something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The plumbing service starts with a timestamp. Then it is completed with a timestamp
    after two hours. After three minutes, it is then confirmed as complete with a
    timestamp. Since all three timestamps exist, the service has been performed.
  prefs: []
  type: TYPE_NORMAL
- en: The babysitting service has a duration of three hours in the agreement. It started
    with a timestamp and ended time with a timestamp three hours later. The duration
    is exactly three hours. This matches the agreed hours, so the service has been
    performed.
  prefs: []
  type: TYPE_NORMAL
- en: The room-cleaning service lists both the kitchen and the bathroom in the agreement.
    Only the kitchen was reported to be cleaned with a timestamp, so the service has
    not been performed yet.
  prefs: []
  type: TYPE_NORMAL
- en: This approach results in a homogeneous yet polymorphic style and facilitates
    three different services that have certain shared behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Sealed class solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kotlin language has a feature called **sealed class**, which restricts the
    class hierarchy and requires that all subclasses be defined at compile time. All
    subclasses need to be in the same package and module where the sealed class is
    defined. This also means that no third-party classes can be inherited from sealed
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few observations from the polymorphic solution mentioned previously.
    Firstly, all subclasses have a `startedAt` field and an implementation of the
    `performService` function that sets the `startedAt` field. So, the sealed class
    solution can be modified from the polymorphic solution. The interface can be changed
    to a sealed class with the `startedAt` field and the `performService` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The subclasses can be simplified by using the sealed class implementation as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `performService` function has been implemented by the `Service` superclass,
    so there is no need to implement it in the subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The same simplification applies to the `RoomCleaning` subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The sealed `Service` class has the `startedAt` field and the `performService`
    function to facilitate the starting of the service, while the subclasses have
    their own variations to complete it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The power of the Kotlin sealed classes is not the restriction of having all
    subclasses known at compile time. The power lies in what the compiler does with
    the restriction. If we use the `when` construct together with sealed classes,
    we can reduce our program to be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As the `Service` class has the implementation of the `wasServicePerformed`
    function using the `when` construct, the subclasses do not need to implement this
    function at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Like the `Plumbing` subclass, other subclasses will now only contain the body
    of functions related to completing the service in various forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The compiler enforces that all subclasses are included in branches of the `when`
    construct. If they are not, it will not compile. In addition, the `this` instance
    is automatically cast (**smart cast**) to the specific subclass in each branch,
    so we can directly access the fields defined in the subclass.
  prefs: []
  type: TYPE_NORMAL
- en: In this implementation, all variations of the check for services performed are
    grouped together in the `when` construct as branches. It is better than an `enum`
    implementation because you will not overlook a subclass, given that we do not
    use `else` as a branch.
  prefs: []
  type: TYPE_NORMAL
- en: Also, as these are subclasses of a sealed class, all the subclasses are known
    and we can easily compare the variations in a single function.
  prefs: []
  type: TYPE_NORMAL
- en: However, this pattern is useful only when there are a small number of subclasses
    and they have similar implementations. Also, this pattern does not support the
    extension of functionality outside the package.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Delegation** is often considered an alternative to the polymorphic solution.
    In this approach, an extension of a function is implemented by delegating part
    of the responsibility to other classes and then extending its behaviors. As a
    result, there is no mandatory requirement to create a subclass. There are several
    reasons for that:'
  prefs: []
  type: TYPE_NORMAL
- en: Loose coupling and high cohesion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separation of concerns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy substitution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring to the delegation solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loose coupling and high cohesion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using delegation, code can be reused and composed only for the parts that are
    needed. It is more flexible than inheriting a class that is likely to give the
    subclasses more than it needs. This results in looser coupling to the reused code
    while still maintaining high cohesion within the class.
  prefs: []
  type: TYPE_NORMAL
- en: Separation of concerns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the use of delegation, classes can be broken into small classes (sub-classes)
    that only have a single responsibility. These classes are only delegated on demand.
    As a result, each class has a clear focus and responsibility. Classes are therefore
    easier to maintain, test, and understand.
  prefs: []
  type: TYPE_NORMAL
- en: We are also able to break away from any change of superclass in unrelated implementation
    that may cause unintended changes in behaviors. We simply separate unrelated implementations
    from what is really needed.
  prefs: []
  type: TYPE_NORMAL
- en: Easy substitution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we need to have a different behavior, it is easier to swap the delegate object
    than to swap an inherited superclass. Not only are there fewer functions to implement
    in delegate objects than a different superclass but it is also possible to swap
    to delegate objects at runtime dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: As long as the subclasses conform to the **Liskov Substitution Principle** (**LSP**),
    there is no behavioral change in substituting subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring to the delegation solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To refactor to the delegation solution, we will break down responsibilities
    into smaller interfaces. We will have an interface that starts a service and another
    interface that checks whether a service was performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Plumbing, babysitting, and room cleaning are three services that are completed
    very differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'The plumbing service has three phases: *Started*, *Completed*, and *Confirmed*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – A three-phase service](img/B21737_03_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – A three-phase service
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be expressed as a `ThreePhaseService` that is also a `ServiceStarter`
    and `ServiceChecker`. However, we already have the concrete `Started` class as
    an implementation of `ServiceStarter`, so we can use the Kotlin delegation feature
    to specify that the implementation of `ServiceStarter` is realized by the `started`
    field provided in the constructor with a `Started` default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, `Plumbing` is merely a specialization of `ThreePhaseServiceImpl` that
    we can define as a one-liner by Kotlin delegation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The babysitting service has only two phases: *Started* and *Ended*. The duration,
    or the amount of time between the start and end times, determines whether the
    service has been performed. Here is a simple UML state diagram to capture the
    phase transition.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Hourly service phase transition](img/B21737_03_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Hourly service phase transition
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be expressed as an `HourlyService`. Again, we can make use of the Kotlin
    delegation to avoid code duplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, `Babysitting` is declared as a one-liner delegated class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, the room cleaning service is repeated in a loop until all agreed items
    have been completed. Here is a simple UML state diagram to capture the phase transition.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Itemized service phase transition](img/B21737_03_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Itemized service phase transition
  prefs: []
  type: TYPE_NORMAL
- en: 'We can treat each room as an item that is completed individually in the name
    of `ItemizedService`. We also use the generic `T` type to make it flexible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`RoomCleaning` can now be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This example of a delegation solution can be illustrated by the following UML
    class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – A delegation solution](img/B21737_03_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – A delegation solution
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting them all together, we need to modify a bit of the `main` function only
    because the function names are different. The program behaves in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: From this example, we can see how easy it is to reuse the code. For example,
    if there is another service that needs to run for an agreed hour, we can reuse
    the `HourlyService` using delegation without the need to implement the same logic
    again. We also need not write the same test.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern reduces duplicated code and testing. It also promotes each class
    to be more specific and focused on its responsibility. It makes any extension
    of existing features easier, since it does not impose inheriting a concrete superclass.
  prefs: []
  type: TYPE_NORMAL
- en: Functional solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Functional programming** uses a completely different mindset in approaching
    the problem. The fundamental elements can be categorized into **immutable data
    structures** and **pure functions**.'
  prefs: []
  type: TYPE_NORMAL
- en: Immutable data structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An immutable data structure cannot be changed once it has been created. If a
    new value is needed to capture a change, new data structure instances are created
    and usually transformed from the existing ones. This approach makes data reliable
    and thread-safe.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin provides the `toString`, `hashcode`, and `equals` for free. Combined
    with the use of the `val` keyword and exclusive refereces to other immutable data,
    we can easily create an immutable data structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the equivalent data structures for the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It is worth noting that all fields are declared with `val`, so the references
    cannot be changed. Also, the `Instant` class that is used in many fields is also
    immutable.
  prefs: []
  type: TYPE_NORMAL
- en: The `Set` interface has no mutable functions declared. Although a mutable concrete
    implementation could be injected that makes the data class not strictly immutable,
    if we only use the functions declared in the interface and the concrete implementation
    conforms to the LSP, there should be no behavioral change.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the fields that may have a different value in another instance come with
    either a nullable declaration (?) or default values. Kotlin constructors can provide
    these values if they are not specified during invocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin provides a `copy` function for data classes to be mutable as a separate
    instance. For example, a plumbing service can be started by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: However, merely using the `copy` function may seem too low-level and does not
    help communicate the intent of the code. It may be better to have a function with
    a better name such as `start` that invokes `copy` to make the intent obvious.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions are said to be pure if, when they are given the same input, they always
    produce the same output and have no side effects. To achieve this, the function
    does not mutate any external data or state. It does not use any randomization
    or system clock functions either. It does not invoke any function that creates
    side effects, such as making a database update or calling an external system remotely.
    It is deterministic, predictable, testable, and thread-safe.
  prefs: []
  type: TYPE_NORMAL
- en: In the real-life example of the households used in this chapter, all three services
    need to start the service despite all of them having different forms. Also, we
    want to have a better function name to communicate intent. Kotlin supports `start`
    function can work with multiple types. In addition, we use **lambda expressions**
    so that each type can specify its own way to create a new instance of new values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `start` function looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It declares a generic `T` type as the function receiver so we can invoke the
    function in the style of `T.start` as an `T` type to create a new instance of
    `T` with the `startAt` time. This is an example of the invocation of the `start`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`Plumbing()` creates a new instance of `Plumbing` without a `startAt` time.
    Then the `start` function is invoked by supplying an `Instant` object and a lambda
    expression specifying the creation of a new `Plumbing` instance with a `startedAt`
    field set using the `copy` function.'
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Other functions that are specific to the types of services can be declared
    separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note that it is not mandatory to use extension functions for the preceding functions.
    They can be declared inside the body of their corresponding data classes. Declaring
    them as extension functions, however, does provide flexibility in that they can
    be in a different package than the data classes.
  prefs: []
  type: TYPE_NORMAL
- en: The functions to determine whether the service was performed are also different
    for each type of service.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, the `main` function looks different from other solutions, mainly because
    every change in the service would end up in a new instance when using the main
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Since every function uses the data class or the generic type as the receiver,
    the calls can be chained in the sense that the output of the current function
    is the input of the next.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code could end up like the `Babysitting` object can be refactored to look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Comparing all the solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All these solutions are valid, though their styles vary a lot. It is important
    to understand the pros and cons of each approach so we can make an informed decision
    to apply the solution wherever appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Extensibility**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Polymorphic**: Extensible outside package and module'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sealed classes**: Not extensible outside package or module'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delegation**: Extensible outside package and module'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional**: Extensible outside package and module'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Readability and** **code cleanness**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Polymorphic**: Subclasses may inherit unnecessary features from superclasses,
    creating noise while reading code; classes can be big'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sealed classes**: All subclasses are known at compile time; no missing branches;
    not suitable for too many subclasses'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delegation**: Small interfaces; multiple behavioral delegations can be complicated;
    promotes single responsibility per interface; only delegates behaviors on demand'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional**: Small classes and functions; easy to reason about immutable
    data and pure functions; not so easy readable when it uses recursion, monads,
    and higher-level abstractions'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testability**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Polymorphic**: Each subclass would require testing of all behaviors to ensure
    it behaves like its superclass, that is, that it conforms to the LSP; also, each
    subclass would require testing on subclass-specific logic'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sealed classes**: Behaviors implemented in superclass only need to be tested
    once; any when clause and subclass-specific logic need to be tested'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delegation**: Each small behavioral unit can be tested individually and need
    not repeat in its delegation'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional**: All small classes and functions can be tested individually
    without the need for repetition; each test would only need to verify the output
    given the input'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Thread safety**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Polymorphic**: Not thread-safe by nature'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sealed classes**: Not thread-safe by nature'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delegation**: Not thread-safe by nature'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional**: Thread-safe due to immutable data classes and pure functions'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We used the example of three types of services (plumbing, babysitting, and room
    cleaning) that households can perform for each other, focusing on the start, completion,
    confirmation, and checks for whether the service was performed.
  prefs: []
  type: TYPE_NORMAL
- en: We presented a solution that uses traditional polymorphism in object-oriented
    programming. An interface was defined and implemented by three subclasses, one
    for each type of service. The `main` function uses these subclasses in a homogeneous
    yet polymorphic manner.
  prefs: []
  type: TYPE_NORMAL
- en: We then used the Kotlin sealed class feature to restrict all subclasses to be
    known. A further variation was that the sealed class was used together with the
    `when` construct to handle all branches within the `when` block. It resulted in
    a function containing all variations of the service check behaviors suitable for
    a small and fixed number of subclasses in a package.
  prefs: []
  type: TYPE_NORMAL
- en: We presented an alternative solution that uses Kotlin delegation over polymorphism.
    We defined smaller interfaces for each responsibility and identified a service
    starter class. Then we created three classes that use the service starter class
    by delegation. Plumbing, babysitting, and room cleaning services were then declared
    as one-liners using delegation. This style allowed us to reuse code without inheriting
    a superclass that might have provided more than the subclasses needed.
  prefs: []
  type: TYPE_NORMAL
- en: Then we used the functional approach to create immutable data classes for each
    type of service. We used parametric polymorphism and lambda expressions to create
    a `start` function for shared behavior among the three types of services. We declared
    several extension functions with the service as the receiver to enable chains
    of calls in the `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we compared all the solutions in terms of extensibility, code readability,
    testability, and thread safety. We also briefly mentioned when a particular solution
    is suitable and when it is not.
  prefs: []
  type: TYPE_NORMAL
- en: In the coming chapters, we will go through several architectural patterns commonly
    used in today’s industry. We will group similar patterns together and compare
    them so you will be able to customize them to solve real-life problems.
  prefs: []
  type: TYPE_NORMAL
