<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Kotlin – Data Types, Objects, and Classes</h1>
                </header>
            
            <article>
                
<p>In this chapter, we'll cover Kotlin's type system, <strong>object-oriented programming</strong> (<strong>OOP</strong>) with Kotlin, modifiers, destructuring declarations, and more.</p>
<p>Kotlin is, primarily, an OOP language with some functional features. When we use OOP languages to resolve problems, we try to model the objects that are a part of our problem in an abstract way with the information that is relevant to the problem.</p>
<p>If we're designing an HR module for our company, we'll model employees with state or data (name, date of birth, social security number, and others) and behavior (pay salary, transfer to another division, and others). Because a person can be very complex, there is information that isn't relevant for our problem or domain. For example, the employee's favorite style of bicycle isn't relevant for our HR system, but it is very relevant for an online cycling shop.</p>
<p>Once we identify the objects (with data and behavior) and the relationship with other objects of our domain, we can start developing and writing the code that we'll make a part of our software solution. We'll use language constructs (construct is a fancy way to say allowed syntax) to write the objects, categories, relationships, and so on.</p>
<p>Kotlin has many constructs that we can use to write our programs and, in this chapter, we'll cover many of those constructs, such as:</p>
<ul>
<li>Classes</li>
<li>Inheritance</li>
<li>Abstract classes</li>
<li>Interfaces</li>
<li>Objects</li>
<li>Generics</li>
<li>Type alias</li>
<li>Null types</li>
<li>Kotlin's type system</li>
<li>Other types</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Classes</h1>
                </header>
            
            <article>
                
<p><strong>Classes</strong> are the foundational type in Kotlin. In Kotlin, a class is a template that provides a state, a behavior, and a type to instances (more on that later).</p>
<p>To define a class, only a name is required:</p>
<pre>class VeryBasic</pre>
<p><kbd>VeryBasic</kbd> is not very useful, but is still a valid Kotlin syntax.</p>
<p>The <kbd>VeryBasic</kbd><span> class</span> doesn't have any state or behavior; nonetheless, you can declare values of type <kbd>VeryBasic</kbd>, as shown in the following code:</p>
<pre><span>fun main(args: Array&lt;String&gt;) {<br/></span><span>    val basic: VeryBasic = VeryBasic()<br/></span><span>}</span></pre>
<p>As you can see, the <kbd>basic</kbd> value has a <kbd>VeryBasic</kbd> type. To express it differently, <kbd>basic</kbd> is an instance of <kbd>VeryBasic</kbd>.</p>
<p>In Kotlin, types can be inferred; so, the previous example is equivalent to the following code:</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>basic <span>= </span><span>VeryBasic</span><span>()<br/></span><span>}</span></pre>
<p>By being a <kbd>VeryBasic</kbd> instance, <kbd>basic</kbd> has a copy of the <kbd>VeryBasic</kbd> type's state and behavior, namely, none. So sad.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Properties</h1>
                </header>
            
            <article>
                
<p>As discussed previously, classes can have a state. In Kotlin, a class's state is represented by <strong>properties</strong>. Let's have a look at the blueberry cupcake example:</p>
<pre>class BlueberryCupcake {<br/>  var flavour = "Blueberry"<br/>}</pre>
<p>The  <kbd>BlueberryCupcake</kbd> <span>class has an </span><em>has-a</em> property <kbd>flavour</kbd> of type <kbd>String</kbd>.</p>
<p>Of course, we can have instances of the <kbd>BlueberryCupcake</kbd> class:</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>myCupcake <span>= </span><span>BlueberryCupcake</span><span>()<br/></span><span>    </span><span>println</span><span>(</span><span>"My cupcake has </span><span>${</span>myCupcake<span>.</span>flavour<span>}</span><span>"</span><span>)<br/></span><span>}</span></pre>
<p>Now, because we declare the <kbd>flavour</kbd> property as a variable, its internal value can be changed at runtime:</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>myCupcake <span>= </span><span>BlueberryCupcake</span><span>()<br/></span><span>    </span>myCupcake<span>.</span>flavour <span>= </span><span>"Almond"<br/></span><span>    </span><span>println</span><span>(</span><span>"My cupcake has </span><span>${</span>myCupcake<span>.</span>flavour<span>}</span><span>"</span><span>)<br/></span><span>}</span></pre>
<p>That is impossible in real life. Cupcakes do not change their flavor (unless they become stale). If we change the <kbd>flavour</kbd> property to a value, it cannot be modified:</p>
<pre><span>class </span><span>BlueberryCupcake </span><span>{<br/></span><span>    </span><span>val </span>flavour <span>= </span><span>"Blueberry"<br/></span><span>}<br/></span><span><br/></span><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>myCupcake <span>= </span><span>BlueberryCupcake</span><span>()<br/></span><span>    </span>myCupcake<span>.</span>flavour <span>= </span><span>"Almond" </span><span>//Compilation error: Val cannot be reassigned<br/></span><span>    </span><span>println</span><span>(</span><span>"My cupcake has </span><span>${</span>myCupcake<span>.</span>flavour<span>}</span><span>"</span><span>)<br/></span><span>}</span></pre>
<p>Let's declare a new class for almond cupcakes:</p>
<pre><span>class </span><span>AlmondCupcake </span><span>{<br/></span><span>    </span><span>val </span>flavour <span>= </span><span>"Almond"<br/></span><span>}<br/></span><span><br/></span><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>mySecondCupcake <span>= </span><span>AlmondCupcake</span><span>()<br/></span><span>    </span><span>println</span><span>(</span><span>"My second cupcake has </span><span>${</span>mySecondCupcake<span>.</span>flavour<span>}</span><span> flavour"</span><span>)<br/></span><span>}</span></pre>
<p>There is something fishy here. <kbd>BlueberryCupcake</kbd> and <kbd>AlmondCupcake</kbd> are identical in structure; only an internal value is changed.</p>
<p>In real life, you don't have different baking tins for different cupcake flavors. The same good quality baking tin can be used for various flavors. In the same way, a well-designed <kbd>Cupcake</kbd> class can be used for different instances:</p>
<pre>class Cupcake(flavour: String) { <br/>  val flavour = flavour<br/>}</pre>
<p>The <kbd>Cupcake</kbd> class has a constructor with a parameter, <kbd>flavour</kbd>, that is assigned to a <kbd>flavour</kbd> value.</p>
<p>Because this is a very common idiom, Kotlin has a little syntactic sugar to define it more succinctly:</p>
<pre>class Cupcake(val flavour: String)</pre>
<p>Now, we can define several instances with different flavors:</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>myBlueberryCupcake <span>= </span><span>Cupcake</span><span>(</span><span>"Blueberry"</span><span>)<br/></span><span>    </span><span>val </span>myAlmondCupcake <span>= </span><span>Cupcake</span><span>(</span><span>"Almond"</span><span>)<br/></span><span>    </span><span>val </span>myCheeseCupcake <span>= </span><span>Cupcake</span><span>(</span><span>"Cheese"</span><span>)<br/></span><span>    </span><span>val </span>myCaramelCupcake <span>= </span><span>Cupcake</span><span>(</span><span>"Caramel"</span><span>)<br/></span><span>}</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Methods</h1>
                </header>
            
            <article>
                
<p>In Kotlin, a class's behavior is defined by methods. Technically, a <strong>method</strong> is a member function, so, anything that we learn about functions in the following chapters also applies to the methods:</p>
<pre>class Cupcake(val flavour: String) {<br/>  fun eat(): String {<br/>    return "nom, nom, nom... delicious $flavour cupcake"<br/>  }<br/>}</pre>
<p>The <kbd>eat()</kbd> method returns a <kbd>String</kbd> value. Now, let's call the <kbd>eat()</kbd> method, as shown in the following code:</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>myBlueberryCupcake <span>= </span><span>Cupcake</span><span>(</span><span>"Blueberry"</span><span>)<br/></span><span>    </span><span>println</span><span>(</span>myBlueberryCupcake<span>.</span><span>eat</span><span>())<br/></span><span>}</span></pre>
<p>The following expression is the output of the preceding code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="26" width="309" src="assets/bb269540-7a2c-44fa-806b-ddf52f7597cf.png"/></div>
<p>Nothing mind-blowing, but this is our first method. Later on, we'll do more interesting stuff.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Inheritance</h1>
                </header>
            
            <article>
                
<p>As we continue modelling our domain in Kotlin, we realize that specific objects are quite similar. If we go back to our HR example, an employee and a contractor are quite similar; both have a name, a date of birth, and so on; they also have some differences. For example, a contractor has a daily rate, while an employee has a monthly salary. It is obvious that they are similar—both of them are people; people is a superset where both contractor and employee belong. As such, both have their own specific features that make them different enough to be classified into different subsets.</p>
<p>This is what inheritance is all about, there are groups and subgroups and there are relationships between them. In an inheritance hierarchy, if you go up in the hierarchy, you will see more general features and behaviors, and if you go down, you will see more specific ones. A burrito and a microprocessor are both objects, but they have very different purposes and uses. </p>
<p>Let's introduce a new <kbd>Biscuit</kbd> class:</p>
<pre>class Biscuit(val flavour: String) { <br/>  fun eat(): String { <br/>    return "nom, nom, nom... delicious $flavour biscuit" <br/>  } <br/>}</pre>
<p>Again, this class looks almost exactly same as <kbd>Cupcake</kbd>. We could refactor these classes to reduce code duplication:</p>
<pre>open class BakeryGood(val flavour: String) { <br/>  fun eat(): String { <br/>    return "nom, nom, nom... delicious $flavour bakery good" <br/>  } <br/>} <br/><br/>class Cupcake(flavour: String): BakeryGood(flavour) <br/>class Biscuit(flavour: String): BakeryGood(flavour)</pre>
<p>We introduced a new <kbd>BakeryGood</kbd> class, with the shared behavior and state of both <kbd>Cupcake</kbd> and <kbd>Biscuit</kbd> classes and we made both classes extend <kbd>BakeryGood</kbd>. By doing so, <kbd>Cupcake</kbd> (and <kbd>Biscuit</kbd>) has an <em>is-a</em> relationship with <kbd>BakeryGood</kbd> now; on the other hand, <kbd>BakeryGood</kbd> is the <kbd>Cupcake</kbd> class's super or parent class.</p>
<p><span>Note that </span><kbd>BakeryGood</kbd><span> is marked as </span><kbd>open</kbd><span>. This means that we specifically design this class to be extended. In Kotlin, you can't extend a class that isn't </span><kbd>open</kbd><span>.</span></p>
<p>The process of moving common behaviors and states to a parent class is called <strong>generalisation</strong>. Let's have a look at the following code:</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>myBlueberryCupcake: <span>BakeryGood </span><span>= </span><span>Cupcake</span><span>(</span><span>"Blueberry"</span><span>)<br/></span><span>    </span><span>println</span><span>(</span>myBlueberryCupcake<span>.</span><span>eat</span><span>())<br/></span><span>}</span></pre>
<p>Let's try out our new code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="19" width="377" src="assets/068015b9-405f-4a9d-b1a6-77986d9fbfd4.png"/></div>
<p>Bummer, not what we were expecting. We need to refract it more:</p>
<pre>open class BakeryGood(val flavour: String) { <br/>  fun eat(): String { <br/>    return "nom, nom, nom... delicious $flavour ${name()}" <br/>  } <br/><br/>  open fun name(): String { <br/>    return "bakery good" <br/>  } <br/>} <br/><br/>class Cupcake(flavour: String): BakeryGood(flavour) { <br/>  override fun name(): String { <br/>    return "cupcake" <br/>  } <br/>} <br/><br/>class Biscuit(flavour: String): BakeryGood(flavour) { <br/>  override fun name(): String { <br/>    return "biscuit" <br/>  } <br/>}</pre>
<p>It works! Let's have a look at the output:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="27" width="321" src="assets/b658a569-6f48-4c67-8ddb-d491338b4481.png"/></div>
<p>We declared a new method, <kbd>name()</kbd>; it should be marked as <kbd>open</kbd>, because we designed it to be optionally altered in its subclasses.</p>
<p>Modifying a method's definition on a subclass is called <strong>override</strong> and that is why the <kbd>name()</kbd> method in both subclasses is marked as <kbd>override</kbd>.</p>
<p>The process of extending classes and overriding behavior in a hierarchy is called <strong>specialisation</strong>.</p>
<div class="packt_tip"><span class="packt_screen">Rule of thumb<br/>
<br/></span> Put general states and behaviors at the top of the hierarchy (generalisation), and specific states and behaviors in subclasses (specialisation).</div>
<p>Now, we can have more bakery goods! Let's have a look at the following code:</p>
<pre>open class Roll(flavour: String): BakeryGood(flavour) { <br/>  override fun name(): String { <br/>    return "roll" <br/>  } <br/>} <br/><br/>class CinnamonRoll: Roll("Cinnamon")</pre>
<p>Subclasses can be extended too. They just need to be marked as <kbd>open</kbd>:</p>
<pre><span>open class </span><span>Donut</span><span>(</span>flavour: <span>String</span><span>, </span><span>val </span>topping: <span>String</span><span>) </span>: <span>BakeryGood</span><span>(</span>flavour<span>)<br/>{<br/></span><span>    </span><span>override fun </span><span>name</span><span>()</span>: <span>String </span><span>{<br/></span><span>        </span><span>return </span><span>"donut with </span><span>$</span>topping<span> topping"<br/></span><span>    </span><span>}<br/></span><span>}<br/></span><span><br/></span><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>myDonut <span>= </span><span>Donut</span><span>(</span><span>"Custard"</span><span>, </span><span>"Powdered sugar"</span><span>)<br/></span><span>    </span><span>println</span><span>(</span>myDonut<span>.</span><span>eat</span><span>())<br/></span><span>}</span></pre>
<p>We can also create classes with more properties and methods.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Abstract classes</h1>
                </header>
            
            <article>
                
<p>So far, so good. Our bakery looks good. However, we have a problem with our current model. Let's look at the following code:</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>anyGood <span>= </span><span>BakeryGood</span><span>(</span><span>"Generic flavour"</span><span>)<br/></span><span>}</span></pre>
<p>We can instantiate the <kbd>BakeryGood</kbd> class directly, which is too generic. To correct this situation, we can mark <kbd>BakeryGood</kbd> as <kbd>abstract</kbd>:</p>
<pre>abstract class BakeryGood(val flavour: String) { <br/>  fun eat(): String { <br/>    return "nom, nom, nom... delicious $flavour ${name()}" <br/>  }<br/> <br/>  open fun name(): String { <br/>    return "bakery good" <br/>  } <br/>}</pre>
<p>An <strong>abstract class</strong> is a class designed solely to be extended. An abstract class can't be instantiated, which fixes our problem.</p>
<p>What makes <kbd>abstract</kbd> different from <kbd>open</kbd>?</p>
<p>Both modifiers let us extend a class, but <kbd>open</kbd> lets us instantiate while <kbd>abstract</kbd> does not.</p>
<p>Now that we can't instantiate, our <kbd>name()</kbd> method in the <kbd>BakeryGood</kbd> class isn't that useful anymore, and all our subclasses, except for <kbd>CinnamonRoll</kbd>, override it anyway (<kbd>CinnamonRoll</kbd> relays on the <kbd>Roll</kbd> implementation):</p>
<pre>abstract class BakeryGood(val flavour: String) { <br/>  fun eat(): String { <br/>    return "nom, nom, nom... delicious $flavour ${name()}" <br/>  } <br/>  <br/>  abstract fun name(): String <br/>}</pre>
<p>A method marked as <kbd>abstract</kbd> doesn't have a body, just the signature declaration (a method signature is a way to identify a method). In Kotlin, a signature is composed of the method's name, its number, the type of parameters, and the return type.</p>
<p>Any class that extends <kbd>BakeryGood</kbd> directly must override the <kbd>name()</kbd> method. The technical term for overriding an abstract method is <strong>implement</strong> and, from now on, we will use it. So, the <kbd>Cupcake</kbd> class implements the <kbd>name()</kbd> method (Kotlin doesn't have a keyword for method implementation; both cases, method implementation, and method overriding, use the keyword <kbd>override</kbd>).</p>
<p>Let's introduce a new class, <kbd>Customer</kbd>; a bakery needs customers anyway:</p>
<pre><span>class </span><span>Customer</span><span>(</span><span>val </span>name: <span>String</span><span>) {<br/></span><span>  </span><span>fun </span><span>eats</span><span>(</span>food: <span>BakeryGood</span><span>) {<br/></span><span>    </span><span>println</span><span>(</span><span>"</span><span>$</span>name<span> is eating... </span><span>${</span>food<span>.</span><span>eat</span><span>()</span><span>}</span><span>"</span><span>)<br/></span><span>  }<br/></span><span>}<br/></span><span><br/></span><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>myDonut <span>= </span><span>Donut</span><span>(</span><span>"Custard"</span><span>, </span><span>"Powdered sugar"</span><span>)<br/></span><span>    </span><span>val </span>mario <span>= </span><span>Customer</span><span>(</span><span>"Mario"</span><span>)<br/></span><span>    </span>mario<span>.</span><span>eats</span><span>(</span>myDonut<span>)</span><span><br/></span><span>}</span></pre>
<p>The <kbd>eats(food: BakeryGood)</kbd> method takes a <kbd>BakeryGood</kbd> parameter, so any instance of any class that extends the <kbd>BakeryGood</kbd> parameter, it doesn't matter how many hierarchy levels. Just remember that we can instantiate <kbd>BakeryGood</kbd> directly.</p>
<p>What happens if we want a simple <kbd>BakeryGood</kbd>? For example, testing.</p>
<p>There is an alternative, an anonymous subclass:</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>mario <span>= </span><span>Customer</span><span>(</span><span>"Mario"</span><span>)<br/></span><span><br/></span><span>    </span>mario<span>.</span><span>eats</span><span>(</span><span>object </span>: <span>BakeryGood</span><span>(</span><span>"TEST_1"</span><span>) {<br/></span><span>        </span><span>override fun </span><span>name</span><span>()</span>: <span>String </span><span>{<br/></span><span>            </span><span>return </span><span>"TEST_2"<br/></span><span>        </span><span>}<br/></span><span>    })<br/></span><span>}</span></pre>
<p>A new keyword is introduced here, <kbd>object</kbd>. Later on, we'll cover <kbd>object</kbd> in more detail, but for now, it is enough to know that this is an <strong>object expression</strong>. An object expression defines an instance of an anonymous class that extends a type.</p>
<p>In our example, the object expression (technically, the <strong>anonymous class</strong>) must override the <kbd>name()</kbd> method and pass a value as the parameter for the <kbd>BakeryGood</kbd> constructor, exactly as a standard class would do.</p>
<p>Remember that an <kbd>object</kbd> expression is an instance, so it can be used to declare values:</p>
<pre>val food: BakeryGood = object : BakeryGood("TEST_1") { <br/>  override fun name(): String { <br/>    return "TEST_2" <br/>  } <br/>} <br/><br/>mario.eats(food)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interfaces</h1>
                </header>
            
            <article>
                
<p>The open and abstract classes are great for creating hierarchies, but sometimes they aren't enough. Some subsets can span between apparently unrelated hierarchies, for example, birds and great apes are bipedal, and both are animals and vertebrates, but they not directly related. That is why we need a different construct and Kotlin gives us interfaces (other languages deal with this problem differently).</p>
<p>Our bakery goods are great, but we need to cook them first:</p>
<pre>abstract class BakeryGood(val flavour: String) { <br/>  fun eat(): String { <br/>    return "nom, nom, nom... delicious $flavour ${name()}" <br/>  } <br/><br/>  fun bake(): String { <br/>    return "is hot here, isn't??" <br/>  } <br/><br/>  abstract fun name(): String <br/>}</pre>
<p>With our new <kbd>bake()</kbd> <span>method </span>, it will cook all our amazing products, but wait, donuts aren't baked, but fried.</p>
<p>What if we could move the  <kbd>bake()</kbd> <span>method</span> to a second abstract class, <kbd>Bakeable</kbd>? Let's try it in the following code:</p>
<pre>abstract class Bakeable { <br/>  fun bake(): String { <br/>    return "is hot here, isn't??" <br/>  } <br/>} <br/><br/>class Cupcake(flavour: String) : BakeryGood(flavour), Bakeable() { //Compilation error: Only one class may appear in a supertype list <br/>  override fun name(): String { <br/>    return "cupcake" <br/>  } <br/>}</pre>
<p>Wrong! In Kotlin, a class can't extend two classes at the same time. Let's have a look at the following code:</p>
<pre>interface Bakeable { <br/>  fun bake(): String { <br/>    return "is hot here, isn't??" <br/>  } <br/>} <br/><br/>class Cupcake(flavour: String) : BakeryGood(flavour), Bakeable { <br/>  override fun name(): String { <br/>    return "cupcake" <br/>  } <br/>}</pre>
<p>However, it can extend many interfaces. An <strong>interface</strong> is a type that defines a behavior; in the <kbd>Bakeable</kbd> interface's case, that is the <kbd>bake()</kbd> method.</p>
<p>So, what are the differences between an open/abstract class and an interface?</p>
<p>Let's start with the following similarities:</p>
<ul>
<li>Both are types. In our example, <kbd>Cupcake</kbd> has an <em>is-a</em> relationship with <kbd>BakeryGood</kbd> and has an <em>is-a</em> relationship with <kbd>Bakeable</kbd>.</li>
<li>Both define behaviors as methods.</li>
<li>Although open classes can be instantiated directly, neither abstract classes nor interfaces can.</li>
</ul>
<p>Now, let's look at the following differences:</p>
<ul>
<li>A class can extend just one class (open or abstract), but can extend many interfaces.</li>
<li>An open/abstract class can have constructors.</li>
<li>An open/abstract class can initialize its own values. An interface's values must be initialized in the classes that extend the interface.</li>
<li>An open class must declare the methods that can be overridden as open. An abstract class could have both open and abstract methods.</li>
</ul>
<p>In an interface, all methods are open and a method with no implementation doesn't need an abstract modifier:</p>
<pre>interface Fried { <br/>  fun fry(): String <br/>} <br/><br/>open class Donut(flavour: String, val topping: String) : BakeryGood(flavour), Fried { <br/>  override fun fry(): String { <br/>    return "*swimming on oil*" <br/>  } <br/><br/>  override fun name(): String { <br/>    return "donut with $topping topping" <br/>  } <br/>}</pre>
<p>When should you use one or the other?:</p>
<ul>
<li>Use open class when:
<ul>
<li>The class should be extended and instantiated</li>
</ul>
</li>
<li>Use abstract class when:
<ul>
<li>The class can't be instantiated</li>
<li>A constructor is needed it</li>
<li>There is initialization logic (using <kbd>init</kbd> blocks)</li>
</ul>
</li>
</ul>
<p>Let's have a look at the following code:</p>
<pre style="padding-left: 60px">abstract class BakeryGood(val flavour: String) {<br/>  init { <br/>    println("Preparing a new bakery good") <br/>  } <br/><br/>  fun eat(): String { <br/>    return "nom, nom, nom... delicious $flavour ${name()}" <br/>  } <br/><br/>  abstract fun name(): String <br/>}</pre>
<ul>
<li>Use interface when:
<ul>
<li>Multiple inheritances must be applied</li>
<li>No initialized logic is needed</li>
</ul>
</li>
</ul>
<div class="packt_tip">My recommendation is that you should always start with an interface. Interfaces are more straightforward and cleaner; they also allow a more modular design. In the case that data initialization/constructors are needed, move to abstract/open.</div>
<p>As with abstract classes, object expressions can be used with interfaces:</p>
<pre>val somethingFried = object : Fried { <br/>  override fun fry(): String { <br/>    return "TEST_3" <br/>  } <br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Objects</h1>
                </header>
            
            <article>
                
<p>We already covered object expressions, but there is more on objects. <strong>Objects</strong> are natural singletons (by natural, I mean to come as language features and not as behavior pattern implementations, as in other languages). A <strong>singleton</strong> is a type that has just one and only one instance and every object in Kotlin is a singleton. That opens a lot of interesting patterns (and also some bad practices). Objects as singletons are useful for coordinating actions across the system, but can also be dangerous if they are used to keep global state.</p>
<p>Object expressions don't need to extend any type:</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>expression <span>= object </span><span>{<br/></span><span>        </span><span>val </span>property <span>= </span><span>""<br/></span><span><br/></span><span>        </span><span>fun </span><span>method</span><span>()</span>: <span>Int </span><span>{<br/></span><span>            </span><span>println</span><span>(</span><span>"from an object expressions"</span><span>)<br/></span><span>            </span><span>return </span><span>42<br/></span><span>        </span><span>}<br/></span><span>    }<br/></span><span><br/></span><span>    </span><span>val </span>i <span>= </span><span>"</span><span>${</span>expression<span>.</span><span>method</span><span>()</span><span>} ${</span>expression<span>.</span>property<span>}</span><span>"<br/></span><span>    </span><span>println</span><span>(</span>i<span>)<br/></span><span>}</span></pre>
<p>In this case, the <kbd>expression</kbd> value is an object that doesn't have any specific type. We can access its properties and functions.</p>
<p>There is one restriction—object expressions without type can be used only locally, inside a method, or privately, inside a class:</p>
<pre><span>class </span><span>Outer </span><span>{<br/></span><span>    </span><span>val </span>internal <span>= object </span><span>{<br/></span><span>        </span><span>val </span>property <span>= </span><span>""<br/></span><span>    </span><span>}<br/></span><span>}<br/></span><span><br/></span><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>outer <span>= </span><span>Outer</span><span>()<br/></span><span><br/></span><span>    </span>println<span>(</span>outer<span>.</span>internal<span>.</span>property<span>) </span><span>// Compilation error: Unresolved reference: property<br/></span><span>}</span></pre>
<p>In this case, the <kbd>property</kbd> value can't be accessed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Object declarations</h1>
                </header>
            
            <article>
                
<p>An object can also have a name. This kind of object is called an <strong>object declaration</strong>:</p>
<pre><span>object </span><span>Oven </span><span>{<br/></span><span>  </span><span>fun </span><span>process</span><span>(</span>product: <span>Bakeable</span><span>) {<br/></span><span>    </span><span>println</span><span>(</span>product<span>.</span><span>bake</span><span>())<br/></span><span>  }<br/></span><span>}<br/></span><span><br/></span><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>myAlmondCupcake <span>= </span><span>Cupcake</span><span>(</span><span>"Almond"</span><span>)<br/></span><span>    </span><span>Oven</span><span>.</span><span>process</span><span>(</span>myAlmondCupcake<span>)<br/></span><span>}</span></pre>
<p>Objects are singletons; you don't need to instantiate <kbd>Oven</kbd> to use it. Objects also can extend other types:</p>
<pre><span>interface </span><span>Oven </span><span>{<br/></span><span>  </span><span>fun </span><span>process</span><span>(</span>product: <span>Bakeable</span><span>)<br/></span><span>}<br/></span><span><br/></span><span>object </span><span>ElectricOven</span>: <span>Oven </span><span>{<br/></span><span>  </span><span>override fun </span><span>process</span><span>(</span>product: <span>Bakeable</span><span>) {<br/></span><span>    </span><span>println</span><span>(</span>product<span>.</span><span>bake</span><span>())<br/></span><span>  }<br/></span><span>}<br/></span><span><br/></span><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>myAlmondCupcake <span>= </span><span>Cupcake</span><span>(</span><span>"Almond"</span><span>)<br/></span><span>    </span><span>ElectricOven</span><span>.</span><span>process</span><span>(</span>myAlmondCupcake<span>)<br/></span><span>}</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Companion objects</h1>
                </header>
            
            <article>
                
<p>Objects declared inside a class/interface can be marked as companion objects. Observe the use of companion objects in the following code:</p>
<pre>class Cupcake(flavour: String) : BakeryGood(flavour), Bakeable {<br/>  override fun name(): String { <br/>    return "cupcake" <br/>  } <br/>  <br/>  companion object { <br/>    fun almond(): Cupcake { <br/>      return Cupcake("almond") <br/>    } <br/><br/>    fun cheese(): Cupcake { <br/>      return Cupcake("cheese") <br/>    } <br/>  } <br/>}</pre>
<p>Now, methods inside the companion object can be used directly, using the class name without instantiating it:</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>myBlueberryCupcake: <span>BakeryGood </span><span>= </span><span>Cupcake</span><span>(</span><span>"Blueberry"</span><span>)<br/></span><span>    </span><span>val </span>myAlmondCupcake <span>= </span><span>Cupcake</span><span>.</span><span>almond</span><span>()<br/></span><span>    </span><span>val </span>myCheeseCupcake <span>= </span><span>Cupcake</span><span>.</span><span>cheese</span><span>()<br/></span><span>    </span><span>val </span>myCaramelCupcake <span>= </span><span>Cupcake</span><span>(</span><span>"Caramel"</span><span>)<br/></span><span>}</span></pre>
<p>Companion object's methods can't be used from instances:</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>myAlmondCupcake <span>= </span><span>Cupcake</span><span>.</span><span>almond</span><span>()<br/></span><span>    </span><span>val </span>myCheeseCupcake <span>= </span>myAlmondCupcake<span>.</span>cheese<span>() </span><span>//Compilation error: Unresolved reference: cheese<br/></span><span>}</span></pre>
<p>Companion objects can be used outside the class as values with the name <kbd>Companion</kbd>:</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>factory: <span>Cupcake</span><span>.</span><span>Companion </span><span>= </span><span>Cupcake</span><span>.</span><span>Companion<br/></span><span>}</span></pre>
<p>Alternatively, a <kbd>Companion</kbd> object can have a name:</p>
<pre><span>class </span><span>Cupcake</span><span>(</span>flavour: <span>String</span><span>) </span>: <span>BakeryGood</span><span>(</span>flavour<span>), </span><span>Bakeable </span><span>{<br/></span><span>    </span><span>override fun </span><span>name</span><span>()</span>: <span>String </span><span>{<br/></span><span>        </span><span>return </span><span>"cupcake"<br/></span><span>    </span><span>}<br/></span><span><br/></span><span>    </span><span>companion object </span><span>Factory </span><span>{<br/></span><span>        </span><span>fun </span><span>almond</span><span>()</span>: <span>Cupcake </span><span>{<br/></span><span>            </span><span>return </span><span>Cupcake</span><span>(</span><span>"almond"</span><span>)<br/></span><span>        }<br/></span><span><br/></span><span>        </span><span>fun </span><span>cheese</span><span>()</span>: <span>Cupcake </span><span>{<br/></span><span>            </span><span>return </span><span>Cupcake</span><span>(</span><span>"cheese"</span><span>)<br/></span><span>        }<br/></span><span>    }<br/></span><span>}<br/></span><span><br/></span><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>factory: <span>Cupcake</span><span>.</span><span>Factory </span><span>= </span><span>Cupcake</span><span>.</span><span>Factory<br/></span><span>}</span></pre>
<p>They can also be used without a name, as shown in the following code:</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>factory: <span>Cupcake</span><span>.</span><span>Factory </span><span>= </span><span>Cupcake<br/></span><span>}</span></pre>
<p>Don't be confused by this syntax. The <kbd>Cupcake</kbd> value without parenthesis is the companion object; <kbd>Cupcake()</kbd> is an instance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generics</h1>
                </header>
            
            <article>
                
<p>This section is just a short introduction to generics; later, we'll cover it in detail.</p>
<p><strong>Generic programming</strong> is a style programming that focuses on creating algorithms (and collaterally, data structures) that work on general problems.</p>
<p>The Kotlin way to support generic programming is using type parameters. In a few words, we wrote our code with type parameters and, later on, we pass those types as parameters when we use them. </p>
<p>Let's take, for example, our <kbd>Oven</kbd> interface:</p>
<pre>interface Oven {<br/>  fun process(product: Bakeable)<br/>}</pre>
<p>An oven is a machine, so we could generalize it more:</p>
<pre>interface Machine&lt;T&gt; {<br/>  fun process(product: T)<br/>}</pre>
<p>The <kbd>Machine&lt;T&gt;</kbd> interface defines a type parameter <kbd>T</kbd> and a method <kbd>process(T)</kbd>.</p>
<p>Now, we can extend it with <kbd>Oven</kbd>:</p>
<pre>interface Oven: Machine&lt;Bakeable&gt;</pre>
<p>Now, <kbd>Oven</kbd> is extending <kbd>Machine</kbd> with the <kbd>Bakeable</kbd> type parameter, so the <kbd>process</kbd> method now takes <kbd>Bakeable</kbd> as a parameter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Type alias</h1>
                </header>
            
            <article>
                
<p><strong>Type alias</strong> provides a way to define names of types that already exist. Type alias can help to make complex types easier to read, and can also provide other hints.</p>
<p>The <kbd>Oven</kbd> interface is, in some sense, just a name, for a <kbd>Machine&lt;Bakeable&gt;</kbd>:</p>
<pre>typealias Oven = Machine&lt;Bakeable&gt;</pre>
<p>Our new type alias, <kbd>Oven</kbd>, is exactly like our good old <kbd>Oven</kbd> interface. It can be extended and have the values of the type <kbd>Oven</kbd>.</p>
<p>Types alias also can be used to enhance information on types, providing meaningful names related to your domain:</p>
<pre>typealias Flavour = String<br/><br/>abstract class BakeryGood(val flavour: Flavour) {</pre>
<p>It can also be used on collections:</p>
<pre>typealias OvenTray = List&lt;Bakeable&gt;</pre>
<p>It can also be used with objects:</p>
<pre>typealias CupcakeFactory = Cupcake.Companion</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Nullable types</h1>
                </header>
            
            <article>
                
<p>One of the main features of Kotlin is nullable types. <strong>Nullable types</strong> allow us to define if a value can contain or being null explicitly:</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>myBlueberryCupcake: <span>Cupcake </span><span>= null </span><span>//Compilation error: Null can not be a value of a non-null type Cupcake<br/></span><span>}</span></pre>
<p>This isn't valid in Kotlin; the <kbd>Cupcake</kbd> type doesn't allow null values. To allow null values, <kbd>myBlueberryCupcake</kbd> must have a different type:</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>myBlueberryCupcake: <span>Cupcake</span>? <span>= null<br/></span><span>}</span></pre>
<p>In essence, <kbd>Cupcake</kbd> is a non-null type and <kbd>Cupcake?</kbd> is a nullable type.</p>
<p>In the hierarchical structure, <kbd>Cupcake</kbd> is a subtype of <kbd>Cupcake?</kbd>. So, in any situation where <kbd>Cupcake?</kbd> is defined, <kbd>Cupcake</kbd> can be used, but not the other way around:</p>
<pre><span>fun </span><span>eat</span><span>(</span>cupcake: <span>Cupcake</span>?<span>){<br/></span><span>//  something happens here    <br/></span><span>}<br/></span><span><br/></span><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>myAlmondCupcake <span>= </span><span>Cupcake</span><span>.</span><span>almond</span><span>()<br/></span><span>    <br/></span><span>    </span><span>eat</span><span>(</span>myAlmondCupcake<span>)<br/></span><span>    <br/></span><span>    </span><span>eat</span><span>(</span><span>null</span><span>)<br/></span><span>}</span></pre>
<p>Kotlin's compiler makes a distinction between instances of nullable and non-null types.</p>
<p>Let's take these values, for example:</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>cupcake: <span>Cupcake </span><span>= </span><span>Cupcake</span><span>.</span><span>almond</span><span>()</span><span><br/></span><span>    </span><span>val </span>nullabeCupcake: <span>Cupcake</span>? <span>= </span><span>Cupcake</span><span>.</span><span>almond</span><span>()<br/></span><span>}</span></pre>
<p>Next, we will invoke the <kbd>eat()</kbd> method on both nullable and non-null types:</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>cupcake: <span>Cupcake </span><span>= </span><span>Cupcake</span><span>.</span><span>almond</span><span>()<br/></span><span>    </span><span>val </span>nullableCupcake: <span>Cupcake</span>? <span>= </span><span>Cupcake</span><span>.</span><span>almond</span><span>()<br/></span><span><br/></span><span>    </span>cupcake<span>.</span><span>eat</span><span>() </span><span>// Happy days<br/></span><span>    </span>nullableCupcake<span>.</span><span>eat</span><span>() </span><span>//Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type Cupcake?<br/></span><span>}</span></pre>
<p class="mce-root">Calling the <kbd>eat()</kbd> method on <kbd>cupcake</kbd> is easy as pie; calling <kbd>eat()</kbd> on <kbd>nullableCupcake</kbd> is a compilation error.</p>
<p>Why? For Kotlin, calling a method from a nullable value is dangerous, a potential <kbd>NullPointerException</kbd> (<strong>NPE</strong> from now on) could be thrown. So, to be safe, Kotlin marks this as a compilation error.</p>
<p>What happens if we really want to invoke a method or access a property from a nullable value?</p>
<p>Well, Kotlin provides you options to deal with nullable values, with a catch—all are explicit. In some sense, Kotlin is telling you, <em>Show me that you know what you are doing</em>.</p>
<p>Let's review some options (there are more options that we'll cover in the following chapters).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Checking for null</h1>
                </header>
            
            <article>
                
<p>Check for null as a condition in the <kbd>if</kbd> block:</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>nullableCupcake: <span>Cupcake</span>? <span>= </span><span>Cupcake</span><span>.</span><span>almond</span><span>()<br/><br/></span><span>    </span><span>if </span><span>(</span>nullableCupcake <span>!= null</span><span>) {<br/></span><span>      </span>nullableCupcake<span>.</span><span>eat</span><span>()<br/></span><span>    }<br/></span><span>}</span></pre>
<p>Kotlin will do a smart cast. Inside the <kbd>if</kbd> block, <kbd>nullableCupcake</kbd> is a <kbd>Cupcake</kbd>, not a <kbd>Cupcake?</kbd>; so, any method or property can be accessed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Checking for non-null types</h1>
                </header>
            
            <article>
                
<p>This is similar to the previous one, but it checks directly for the type:</p>
<pre>if (nullableCupcake is Cupcake) {<br/>  nullableCupcake.eat()<br/>}</pre>
<p>It also works with <kbd>when</kbd>:</p>
<pre>when (nullableCupcake) {<br/>  is Cupcake -&gt; nullableCupcake.eat()<br/>}</pre>
<p>Both options, checking for null and non-null types, are a little bit verbose. Let's check other options.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Safe calls</h1>
                </header>
            
            <article>
                
<p><strong>Safe calls</strong> let you access methods and properties of nullable values if the value isn't null (under the hood, at the bytecode level, a safe call is transformed into <kbd>if(x != null)</kbd>):</p>
<pre>nullableCupcake?.eat()</pre>
<p>But, what if you use it in an expression?</p>
<pre>val result: String? = nullableCupcake?.eat()</pre>
<p>It will return null if our value is null, so <kbd>result</kbd> must have a <kbd>String?</kbd> type.</p>
<p>That opens up the chance to use safe calls on a chain, as follows:</p>
<pre>val length: Int? = nullableCupcake?.eat()?.length</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Elvis (?:) operator</h1>
                </header>
            
            <article>
                
<p>The Elvis operator (<kbd><span>?:</span></kbd>) returns an alternative value if a null value is used in an expression:</p>
<pre>val result2: String = nullableCupcake?.eat() ?: ""</pre>
<p>If <kbd>nullabluCupcake?.eat()</kbd> is <kbd>null</kbd>, the <kbd>?:</kbd> operator will return the alternative value <kbd>""</kbd>.</p>
<p>Obviously, the Elvis operator can be used with a chain of safe calls:</p>
<pre>val length2: Int = nullableCupcake?.eat()?.length ?: 0</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The (!!) operator</h1>
                </header>
            
            <article>
                
<p>Instead of a <kbd>null</kbd> value, the <kbd>!!</kbd> operator will throw an NPE:</p>
<pre>val result: String = nullableCupcake!!.eat()</pre>
<p>If you can deal with an NPE, the <kbd>!!</kbd> operator gives you a pretty convenient feature, a free smart cast:</p>
<pre>val result: String = nullableCupcake!!.eat()<br/><br/>val length: Int = nullableCupcake.eat().length</pre>
<p>If <kbd>nullableCupcake!!.eat()</kbd> doesn't throw an NPE, Kotlin will change its type from <kbd>Cupcake?</kbd> to <kbd>Cupcake</kbd> from the next line and onwards.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Kotlin's type system</h1>
                </header>
            
            <article>
                
<p><strong>Type systems</strong> are a set of rules that determine the type of a language construct.</p>
<p>A (good) type system will help you with:</p>
<ul>
<li>Making sure that the constituent parts of your program are connected in a consistent way</li>
<li>Understanding your program (by reducing your cognitive load)</li>
<li>Expressing business rules</li>
<li>Automatic low-level optimizations</li>
</ul>
<p>We have already covered enough ground to understand Kotlin's type system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Any type</h1>
                </header>
            
            <article>
                
<p>All types in Kotlin extend from the <kbd>Any</kbd> type (hold on a second, actually this isn't true but for the sake of the explanation, bear with me).</p>
<p>Every class and interface that we create implicitly extends <kbd>Any</kbd>. So, if we write a method that takes <kbd>Any</kbd> as a parameter, it will receive any value:</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    <br/></span><span>    </span><span>val </span>myAlmondCupcake <span>= </span><span>Cupcake</span><span>.</span><span>almond</span><span>()<br/></span><span>    <br/></span><span>    </span><span>val </span>anyMachine <span>= object </span>: <span>Machine</span><span>&lt;</span><span>Any</span><span>&gt; </span><span>{<br/></span><span>      </span><span>override fun </span><span>process</span><span>(</span>product: <span>Any</span><span>) {<br/></span><span>        </span><span>println</span><span>(</span>product<span>.</span><span>toString</span><span>())<br/></span><span>      }<br/></span><span>    }<br/></span><span>    <br/></span><span>    </span>anyMachine<span>.</span><span>process</span><span>(</span><span>3</span><span>)<br/></span><span>    <br/></span><span>    </span>anyMachine<span>.</span><span>process</span><span>(</span><span>""</span><span>)<br/></span><span>    <br/></span><span>    </span>anyMachine<span>.</span><span>process</span><span>(</span>myAlmondCupcake<span>)    <br/></span><span>}</span></pre>
<p>What about a nullable value? Let's have a look at it:</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    <br/></span><span>    </span><span>val </span>anyMachine <span>= object </span>: <span>Machine</span><span>&lt;</span><span>Any</span><span>&gt; </span><span>{<br/></span><span>      </span><span>override fun </span><span>process</span><span>(</span>product: <span>Any</span><span>) {<br/></span><span>        </span><span>println</span><span>(</span>product<span>.</span><span>toString</span><span>())<br/></span><span>      }<br/></span><span>    }<br/></span><span><br/></span><span>    </span><span>val </span>nullableCupcake: <span>Cupcake</span>? <span>= </span><span>Cupcake</span><span>.</span><span>almond</span><span>()<br/></span><span><br/></span><span>    </span>anyMachine<span>.</span><span>process</span><span>(</span>nullableCupcake<span>) </span><span>//Error:(32, 24) Kotlin: Type mismatch: inferred type is Cupcake? but Any was expected<br/></span><span>}</span></pre>
<p><kbd>Any</kbd> is the same as any other type and also has a nullable counterpart, <kbd>Any?</kbd>.  <kbd>Any</kbd> extends from <kbd>Any?</kbd>. So, in the end, <kbd>Any?</kbd> is the top class of Kotlin's type system hierarchy.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Minimum common types</h1>
                </header>
            
            <article>
                
<p>Due to its type inference and expression evaluation, sometimes there are expressions in Kotlin where it is not clear which type is being returned. Most languages resolve this problem by returning the minimum common type between the possible type options. Kotlin takes a different route.</p>
<p>Let's take a look at an example of an ambiguous expression:</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>nullableCupcake: <span>Cupcake</span>? <span>= </span><span>Cupcake</span><span>.</span><span>almond</span><span>()<br/></span><span><br/></span><span>    </span><span>val </span>length <span>= </span>nullableCupcake<span>?.</span><span>eat</span><span>()</span><span>?.</span>length ?: <span>""<br/></span><span>}</span></pre>
<p>What type does <kbd>length</kbd> have? <kbd>Int</kbd> or <kbd>String</kbd>? No, <kbd>length</kbd> value's type is <kbd>Any</kbd>. Pretty logical. The minimum common type between <kbd>Int</kbd> and <kbd>String</kbd> is <kbd>Any</kbd>. So far, so good. Let's look at the following code now:</p>
<pre>val length = nullableCupcake?.eat()?.length ?: 0.0</pre>
<p>Following that logic, in this case, <kbd>length</kbd> should have the <kbd>Number</kbd> <span>type </span>(the common type between <kbd>Int</kbd> and <kbd>Double</kbd>), shouldn't it?</p>
<p>Wrong, <kbd>length</kbd> is still <kbd>Any</kbd>. Kotlin doesn't search for the minimum common type in these situations. If you want a specific type, it must be explicitly declared:</p>
<pre>val length: Number = nullableCupcake?.eat()?.length ?: 0.0</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Unit type</h1>
                </header>
            
            <article>
                
<p>Kotlin doesn't have methods with <kbd>void</kbd> return (as Java or C do). Instead, a method (or, to be precise, an expression) could have a <kbd>Unit</kbd> type.</p>
<p>A <kbd>Unit</kbd> type means that the expression is called for its side effects, rather than its return. The classic example of a <kbd>Unit</kbd> expression is <kbd>println()</kbd>, a method invoked just for its side effects.</p>
<p><kbd>Unit</kbd>, like any other Kotlin type, extends from <kbd>Any</kbd> and could be nullable. <kbd>Unit?</kbd> looks strange and unnecessary, but is needed to keep consistency with the type system. Having a consistent type system have several advantages, including better compilation times and tooling:</p>
<pre>anyMachine.process(Unit)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Nothing type</h1>
                </header>
            
            <article>
                
<p><kbd>Nothing</kbd> is the type that sits at the bottom of the entire Kotlin hierarchy. <kbd>Nothing</kbd> extends all Kotlin types, including <kbd>Nothing?</kbd>.</p>
<p>But, why do we need a <kbd>Nothing</kbd> and <kbd>Nothing?</kbd> types?</p>
<p><kbd>Nothing</kbd> represents an expression that can't be executed (basically throwing exceptions):</p>
<pre>val result: String = nullableCupcake?.eat() ?: throw RuntimeException() // equivalent to nullableCupcake!!.eat()</pre>
<p>On one hand of the Elvis operator, we have a <kbd>String</kbd>. On the other hand, we have <kbd>Nothing</kbd>. Because the common type between <kbd>String</kbd> and <kbd>Nothing</kbd> is <kbd>String</kbd> (instead of <kbd>Any</kbd>), the value <kbd>result</kbd> is a <kbd>String</kbd>.</p>
<p><kbd>Nothing</kbd> also has a special meaning for the compiler. Once a <kbd>Nothing</kbd> type is returned on an expression, the lines after that are marked as unreachable.</p>
<p><kbd>Nothing?</kbd> is the type of a null value:</p>
<pre>val x: Nothing? = null<br/><br/>val nullsList: List&lt;Nothing?&gt; = listOf(null)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other types</h1>
                </header>
            
            <article>
                
<p>Classes, interfaces, and objects are a good starting point for an OOP type system, but Kotlin offers more constructs, such as data classes, annotations, and enums (there is an additional type, named sealed class, that we'll cover later).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data classes</h1>
                </header>
            
            <article>
                
<p>Creating classes whose primary purpose is to hold data is a common pattern in Kotlin (is a common pattern in other languages too, think of JSON or Protobuff).</p>
<p>Kotlin has a particular kind of class for this purpose:</p>
<pre>data class Item(val product: BakeryGood,<br/>  val unitPrice: Double,<br/>  val quantity: Int)</pre>
<p>To declare <kbd>data class</kbd>, there are some restrictions:</p>
<ul>
<li>The primary constructor should have at least one parameter</li>
<li>The primary constructor's parameters must be <kbd>val</kbd> or <kbd>var</kbd></li>
<li>Data classes can't be abstract, open, sealed, or inner</li>
</ul>
<p>With these restrictions, data classes give a lot of benefits.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Canonical methods</h1>
                </header>
            
            <article>
                
<p><strong>Canonical methods</strong> are the methods declared in <kbd>Any</kbd>. Therefore, all instances in Kotlin have them.</p>
<p>For data classes, Kotlin creates correct implementations of all canonical methods.</p>
<p>The methods are as follows:</p>
<ul>
<li><kbd>equals(other: Any?): Boolean</kbd>: This method compares value equivalence, rather than reference.</li>
<li><kbd>hashCode(): Int</kbd>: A hash code is a numerical representation of an instance. When <kbd>hashCode()</kbd> is invoked several times in the same instance, it should always return the same value. Two instances that return true when they are compared with <kbd>equals</kbd> must have the same <kbd>hashCode()</kbd>.</li>
<li><kbd>toString(): String</kbd>: A <kbd>String</kbd> representation of an instance. This method will be invoked when an instance is concatenated to a <kbd>String</kbd>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The copy() method</h1>
                </header>
            
            <article>
                
<p>Sometimes, we want to reuse values from an existing instance. The <kbd>copy()</kbd> method lets us create new instances of a data class, overriding the parameters that we want:</p>
<pre>val myItem = Item(myAlmondCupcake, 0.40, 5)<br/><br/>val mySecondItem = myItem.copy(product = myCaramelCupcake) //named parameter</pre>
<p>In this case, <kbd>mySecondItem</kbd> copies <kbd>unitPrice</kbd> and <kbd>quantity</kbd> from <kbd>myItem</kbd>, and replaces the <kbd>product</kbd> property.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Destructuring methods</h1>
                </header>
            
            <article>
                
<p>By convention, any instance of a class that has a series of methods named <kbd>component1()</kbd>, <kbd>component2()</kbd> and so on can be used in a destructuring declaration.</p>
<p>Kotlin will generate these methods for any data class:</p>
<pre>val (prod: BakeryGood, price: Double, qty: Int) = mySecondItem</pre>
<p>The <kbd>prod</kbd> value is initialized with the return of <kbd>component1()</kbd>, <kbd>price</kbd> with the return of <kbd>component2()</kbd> , and so on. Although the preceding example use explicit types, those aren't needed:</p>
<pre>val (prod, price, qty) = mySecondItem</pre>
<p>In some circumstances, not all values are needed. All unused values can be replaced by (<kbd>_</kbd>):</p>
<pre>val (prod, _, qty) = mySecondItem</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Annotations</h1>
                </header>
            
            <article>
                
<p>Annotations are a way to attach meta info to your code (such as documentation, configuration, and others).</p>
<p>Let's look at the following example code:</p>
<pre>annotation class Tasty</pre>
<p>An <kbd>annotation</kbd> itself can be annotated to modify its behavior:</p>
<pre>@Target(AnnotationTarget.CLASS)<br/>@Retention(AnnotationRetention.RUNTIME)<br/>annotation class Tasty</pre>
<p>In this case, the <kbd>Tasty</kbd> annotation can be set on classes, interfaces, and objects, and it can be queried at runtime.</p>
<p>For a complete list of options, check the Kotlin documentation.</p>
<p>Annotations can have parameters with one limitation, they can't be nullable:</p>
<pre>@Target(AnnotationTarget.CLASS)<br/>@Retention(AnnotationRetention.RUNTIME)<br/>annotation class Tasty(val tasty:Boolean = true)<br/><br/>@Tasty(false)<br/>object ElectricOven : Oven {<br/>  override fun process(product: Bakeable) {<br/>    println(product.bake())<br/>  }<br/>}<br/><br/>@Tasty<br/>class CinnamonRoll : Roll("Cinnamon")<br/><br/>@Tasty<br/>interface Fried {<br/>  fun fry(): String<br/>}</pre>
<p>To query annotation values at runtime, we must use the reflection API (<kbd>kotlin-reflect.jar</kbd> must be in your classpath):</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>annotations: <span>List</span><span>&lt;</span><span>Annotation</span><span>&gt; = </span><span>ElectricOven</span>::<span>class</span><span>.</span>annotations<br/><br/>    <span>for </span><span>(</span>annotation <span>in </span>annotations<span>) {<br/></span><span>        </span><span>when </span><span>(</span>annotation<span>) {<br/></span><span>            </span><span>is </span><span>Tasty </span><span>-&gt; </span><span>println</span><span>(</span><span>"Is it tasty? </span><span>${</span>annotation<span>.</span>tasty<span>}</span><span>"</span><span>)<br/></span><span>            </span><span>else </span><span>-&gt; </span><span>println</span><span>(</span>annotation<span>)<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enum</h1>
                </header>
            
            <article>
                
<p>Enum in Kotlin is a way to define a set of constant values. Enums are very useful, but not limited, as configuration values:</p>
<pre>enum class Flour {<br/>  WHEAT, CORN, CASSAVA<br/>}</pre>
<p>Each element is an object that extends the <kbd>Flour</kbd> class.</p>
<p>Like any object, they can extend interfaces:</p>
<pre>interface Exotic {<br/>  fun isExotic(): Boolean<br/>}<br/><br/>enum class Flour : Exotic {<br/>  WHEAT {<br/>    override fun isExotic(): Boolean {<br/>      return false <br/>    }<br/>  },<br/><br/>  CORN {<br/>    override fun isExotic(): Boolean {<br/>      return false<br/>    }<br/>  },<br/><br/>  CASSAVA {<br/>    override fun isExotic(): Boolean {<br/>      return true<br/>    }<br/>  }<br/>}</pre>
<p>Enum can also have abstract methods:</p>
<pre>enum class Flour: Exotic {<br/>  WHEAT {<br/>    override fun isGlutenFree(): Boolean {<br/>      return false<br/>    }<br/><br/>    override fun isExotic(): Boolean {<br/>      return false<br/>    }<br/>  },<br/><br/>  CORN {<br/>    override fun isGlutenFree(): Boolean {<br/>      return true<br/>    }<br/><br/>    override fun isExotic(): Boolean {<br/>      return false<br/>    }<br/>  },<br/><br/>  CASSAVA {<br/>    override fun isGlutenFree(): Boolean {<br/>      return true<br/>    }<br/><br/>    override fun isExotic(): Boolean {<br/>      return true<br/>    }<br/>  };<br/> <br/>  abstract fun isGlutenFree(): Boolean<br/>}</pre>
<p>Any method definition must be declared after the (<kbd>;</kbd>) separating the last element.</p>
<p>When enums are used with <kbd>when</kbd> expressions, Kotlin's compiler checks that all cases are covered (individually or with an <kbd>else</kbd>):</p>
<pre>fun flourDescription(flour: Flour): String {<br/>  return when(flour) { // error<br/>    Flour.CASSAVA -&gt; "A very exotic flavour"<br/>  }<br/>}</pre>
<p>In this case, we're only checking for <kbd>CASSAVA</kbd> and not the other elements; therefore, it fails:</p>
<pre>fun flourDescription(flour: Flour): String {<br/>  return when(flour) {<br/>    Flour.CASSAVA -&gt; "A very exotic flavour"<br/>    else -&gt; "Boring"<br/>  }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered the basics of OOP and how Kotlin supports it. We learned how to use classes, interfaces, objects, data classes, annotations, and enums. We also explored the Kotlin type system and saw how it helps us to write better and safer code.</p>
<p>In the next chapter, we will start with an introduction to functional programming.</p>


            </article>

            
        </section>
    </body></html>