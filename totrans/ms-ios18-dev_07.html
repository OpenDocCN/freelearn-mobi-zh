<html><head></head><body>
		<div id="_idContainer046">
			<h1 id="_idParaDest-129" class="chapter-number"><a id="_idTextAnchor239"/><st c="0">7</st></h1>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor240"/><st c="2">Improving Feature Exploration with TipKit</st></h1>
			<p><st c="43">In the previous chapter, we learned about SwiftUI animations. </st><st c="106">We know now that SwiftUI animations are a great way to teach users how to use </st><span class="No-Break"><st c="184">our app.</st></span></p>
			<p><st c="192">However, sometimes, it’s not enough, and we need more than fancy animations. </st><st c="270">This is where TipKit comes in. </st><st c="301">TipKit’s goal is to provide a solution for another important topic: feature exploration. </st><st c="390">Feature exploration affects our app users’ engagement and usage, eventually affecting user satisfaction </st><span class="No-Break"><st c="494">and experience.</st></span></p>
			<p><st c="509">In this chapter, we will cover the </st><span class="No-Break"><st c="545">following topics:</st></span></p>
			<ul>
				<li><st c="562">Learning the importance of tips in a </st><span class="No-Break"><st c="600">mobile app</st></span></li>
				<li><st c="610">Adding a new tip – inline </st><span class="No-Break"><st c="637">and popover</st></span></li>
				<li><st c="648">Customizing our tip’s feel </st><span class="No-Break"><st c="676">and look</st></span></li>
				<li><st c="684">Supporting </st><span class="No-Break"><st c="696">tip actions</st></span></li>
				<li><st c="707">Defining display rules for </st><span class="No-Break"><st c="735">our tips</st></span></li>
				<li><st c="743">Grouping tips </st><span class="No-Break"><st c="758">using TipGroup</st></span></li>
				<li><st c="772">Adjusting </st><span class="No-Break"><st c="783">display frequency</st></span></li>
			</ul>
			<p><st c="800">Now, let’s start with the fundamental question – why do we </st><span class="No-Break"><st c="860">need TipKit?</st></span></p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor241"/><st c="872">Technical requirements</st></h1>
			<p><st c="895">For this chapter, it’s essential to download Xcode version 16.0 or higher from the </st><span class="No-Break"><st c="979">App Store.</st></span></p>
			<p><st c="989">Ensure that you’re operating on the most recent version of macOS (Ventura or newer). </st><st c="1075">Just search for Xcode in the App Store, choose the latest version, and proceed with the download. </st><st c="1173">Open Xcode and complete any further setup instructions that appear. </st><st c="1241">After Xcode is completely up and running, you </st><span class="No-Break"><st c="1287">can begin.</st></span></p>
			<p><st c="1297">Download the sample code from the following GitHub </st><span class="No-Break"><st c="1349">link: </st></span><a href="https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%207"><span class="No-Break"><st c="1355">https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%207</st></span></a></p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor242"/><st c="1440">Learning the importance of tips</st></h1>
			<p><st c="1472">One of the challenges of creating an app for a small screen, such as a smartphone screen, is to provide ways for the user to explore valuable features. </st><st c="1625">Making users use more features is part of improving user engagement – measuring how much the user is actively involved and connected to </st><span class="No-Break"><st c="1761">our product.</st></span></p>
			<p><st c="1773">That feature exploration is a real challenge. </st><st c="1820">On the one hand, we aim to create a clean and straightforward user interface and, on the other hand, we aim to add more features that can be extremely useful to </st><span class="No-Break"><st c="1981">our users.</st></span></p>
			<p><st c="1991">Every product manager struggles with this challenge – sometimes, the solution is to create a </st><strong class="bold"><st c="2085">What’s new</st></strong><st c="2095"> popup, send a marketing email, or add more information to the in-app </st><span class="No-Break"><st c="2165">FAQ screen.</st></span></p>
			<p><st c="2176">One of the most valuable techniques is to provide a tip – a small text box that pops up in the right place at the right time to explain a new feature and can even add an action to help the user </st><span class="No-Break"><st c="2371">use it.</st></span></p>
			<p><st c="2378">Let’s try to drill down a bit and discuss the basics of tips in Apple’s </st><span class="No-Break"><st c="2451">TipKit framework.</st></span></p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor243"/><st c="2468">Understanding the basics of TipKit</st></h1>
			<p><st c="2503">Some may </st><a id="_idIndexMarker341"/><st c="2513">think that the primary challenge with displaying tips is creating views that contain relevant information and </st><span class="No-Break"><st c="2623">presenting it.</st></span></p>
			<p><st c="2637">However, if that were the case, we wouldn’t need a whole framework. </st><st c="2706">Instead, we should consider TipKit a </st><span class="No-Break"><st c="2743">complete system.</st></span></p>
			<p><st c="2759">Let’s look at </st><span class="No-Break"><em class="italic"><st c="2774">Figure 7</st></em></span><span class="No-Break"><em class="italic"><st c="2782">.1</st></em></span><span class="No-Break"><st c="2784">:</st></span></p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/B21795_07_1.jpg" alt="Figure 7.1: Tip infrastructure"/><st c="2786"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="2906">Figure 7.1: Tip infrastructure</st></p>
			<p><span class="No-Break"><em class="italic"><st c="2936">Figure 7</st></em></span><em class="italic"><st c="2945">.1</st></em><st c="2947"> presents the essential components of the structure of TipKit in iOS. </st><st c="3017">First, there is the </st><strong class="bold"><st c="3037">tip center</st></strong><st c="3047">, a singleton that manages all the tips’ appearances in the app. </st><st c="3112">The tip </st><a id="_idIndexMarker342"/><st c="3120">center has </st><span class="No-Break"><st c="3131">several responsibilities:</st></span></p>
			<ul>
				<li><st c="3156">Ensures that a tip stops appearing once invalidated or dismissed by </st><span class="No-Break"><st c="3225">the user</st></span></li>
				<li><st c="3233">Triggers the tips such that tips don’t overlay </st><span class="No-Break"><st c="3281">each other</st></span></li>
				<li><st c="3291"> Displays tips according to </st><span class="No-Break"><st c="3319">specific rules</st></span></li>
			</ul>
			<p><st c="3333">Right after the tip center, we have the </st><strong class="bold"><st c="3374">tip model</st></strong><st c="3383"> – a structure representing a specific tip declaration. </st><st c="3439">Based on the tip model, we can create and display an instance using a </st><strong class="bold"><st c="3509">tip view</st></strong><st c="3517"> – a visual representation of </st><span class="No-Break"><st c="3547">the tip.</st></span></p>
			<p><st c="3555">The TipKit infrastructure looks more complex than it is – many iOS frameworks work with some framework center, models, and views.</st><a id="_idTextAnchor244"/><a id="_idTextAnchor245"/><st c="3685"> However, the idea here is to show you that while TipKit provides visual components, its core functionality lies in the rules that determine when and where </st><span class="No-Break"><st c="3841">they appear.</st></span></p>
			<p><st c="3853">Now, enough of the theoretical introduction. </st><st c="3899">Let’s see what tips </st><span class="No-Break"><st c="3919">look like!</st></span></p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor246"/><st c="3929">What do tips look like?</st></h2>
			<p><st c="3953">The result </st><a id="_idIndexMarker343"/><st c="3965">of adding a tip is a view that shows the new feature to the user (</st><span class="No-Break"><em class="italic"><st c="4031">Figure 7</st></em></span><span class="No-Break"><em class="italic"><st c="4040">.2</st></em></span><span class="No-Break"><st c="4042">):</st></span></p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/B21795_07_2.jpg" alt="Figure 7.2: Two different ways to display tips in TipKit"/><st c="4045"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="4591">Figure 7.2: Two different ways to display tips in TipKit</st></p>
			<p><st c="4647">Based on </st><span class="No-Break"><em class="italic"><st c="4657">Figure 7</st></em></span><em class="italic"><st c="4665">.2</st></em><st c="4667">, we can </st><a id="_idIndexMarker344"/><st c="4676">see that there are two ways of displaying </st><span class="No-Break"><st c="4718">a tip:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="4724">Inline tip</st></strong><st c="4735">: Inline tips </st><a id="_idIndexMarker345"/><st c="4750">embed themselves as part of the screen layout, and their appearance modifies and pushes the other views accordingly. </st><st c="4867">Inline tips </st><a id="_idIndexMarker346"/><st c="4879">are a great fit in </st><strong class="bold"><st c="4898">VStacks</st></strong><st c="4905"> or </st><strong class="bold"><st c="4909">Lists</st></strong><st c="4914">, and we can view them without </st><a id="_idIndexMarker347"/><st c="4945">interfering with the </st><span class="No-Break"><st c="4966">screen interaction.</st></span></li>
				<li><strong class="bold"><st c="4985">Popover tip</st></strong><st c="4997">: Unlike </st><a id="_idIndexMarker348"/><st c="5007">inline tips, popover tips appear above the current screen, mostly linked to a button or another control. </st><st c="5112">With popover tips, the user must dismiss the tip or perform its action to continue with the app. </st><st c="5209">Also, we cannot display multiple popover tips at the </st><span class="No-Break"><st c="5262">same time.</st></span></li>
			</ul>
			<p><st c="5272">At first glance, the two ways to display tips are just a matter of design. </st><st c="5348">Showing a popover tip is not only a different experience but also a different use case. </st><st c="5436">In the inline tip, we include the view in a non-intrusive way that allows the user to discover new features gradually. </st><st c="5555">In contrast, the popover tip is excellent for contextual help or complex features </st><a id="_idIndexMarker349"/><st c="5637">requiring guidance. </st><st c="5657">Remember that adding more views to our device’s small screen can sometimes be overwhelming, and we must make this </st><span class="No-Break"><st c="5771">decision carefully.</st></span></p>
			<p><st c="5790">Let’s add our first tip and convince users to use our new </st><strong class="bold"><st c="5849">mark as </st></strong><span class="No-Break"><strong class="bold"><st c="5857">favorite</st></strong></span><span class="No-Break"><st c="5865"> feature.</st></span></p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor247"/><st c="5874">Adding our first tip</st></h2>
			<p><st c="5895">Even though we are excited and can’t wait to add our first tip, we still need to do a small amount </st><a id="_idIndexMarker350"/><st c="5995">of preparation first, and that’s setting up our persistent store for the </st><span class="No-Break"><st c="6068">tips state.</st></span></p>
			<p><st c="6079">Why do we need to set up a persistent store? </st><st c="6125">TipKit needs to manage the tips’ state over time, even after we close our app. </st><st c="6204">This is because we don’t want our tips to show up again if the user (or the app) decides to </st><span class="No-Break"><st c="6296">dismiss them.</st></span></p>
			<p><st c="6309">We can set up the persistent store using a static function </st><span class="No-Break"><st c="6369">called </st></span><span class="No-Break"><strong class="source-inline"><st c="6376">configure()</st></strong></span><span class="No-Break"><st c="6387">:</st></span></p>
			<pre class="source-code"><st c="6389">
import TipKit
@main
struct MyApp: App {
    init() {
</st><strong class="bold"><st c="6439">        try? </st><st c="6444">Tips.configure()</st></strong><st c="6460">
    }
}</st></pre>			<p><st c="6464">In our code example, we can see that we call the </st><strong class="source-inline"><st c="6514">configure</st></strong><st c="6523"> function part of the app initialization process because we need TipKit to have all its information once the first screen </st><span class="No-Break"><st c="6645">is loaded.</st></span></p>
			<p><st c="6655">We can also share the tips’ states store with more of our apps and extensions by defining it in a </st><span class="No-Break"><st c="6754">group container:</st></span></p>
			<pre class="source-code"><st c="6770">
try? </st><st c="6776">Tips.configure([
  .</st><strong class="bold"><st c="6794">datastoreLocation</st></strong><st c="6812">(.groupContainer(identifier:
    "MyAppGroupContainer"))])</st></pre>			<p><st c="6867">In this </st><a id="_idIndexMarker351"/><st c="6876">example, we configured the tips’ state data store in a group container called </st><strong class="source-inline"><st c="6954">MyAppGroupContainer</st></strong><st c="6973">. Don’t worry – from the app’s perspective, the user experience will stay </st><span class="No-Break"><st c="7047">the same.</st></span></p>
			<p class="callout-heading"><st c="7056">What is a group container?</st></p>
			<p class="callout"><st c="7083">A group </st><a id="_idIndexMarker352"/><st c="7092">container is a directory shared among multiple apps and extensions within the same app group. </st><st c="7186">It allows us to share data between </st><span class="No-Break"><st c="7221">our apps.</st></span></p>
			<p><st c="7230">Our next step is to define our </st><span class="No-Break"><strong class="source-inline"><st c="7262">T</st><a id="_idTextAnchor248"/><a id="_idTextAnchor249"/><st c="7263">ip</st></strong></span><span class="No-Break"><st c="7265"> model.</st></span></p>
			<h3><st c="7272">Defining our Tip model</st></h3>
			<p><st c="7295">The </st><strong class="source-inline"><st c="7300">Tip</st></strong><st c="7303"> model (based </st><a id="_idIndexMarker353"/><st c="7317">on the </st><strong class="bold"><st c="7324">Tip protocol</st></strong><st c="7336">) defines our tip’s behavior </st><span class="No-Break"><st c="7366">and appearance.</st></span></p>
			<p><st c="7381">Let’s see </st><a id="_idIndexMarker354"/><st c="7392">a simple </st><span class="No-Break"><st c="7401">tip declaration:</st></span></p>
			<pre class="source-code"><st c="7417">
struct MarkAsFavoriteTip: Tip</st><a id="_idTextAnchor250"/><a id="_idTextAnchor251"/><st c="7447"> {
    var id: String { "InlineTipView</st><a id="_idTextAnchor252"/><a id="_idTextAnchor253"/><st c="7481">"}
    var title: Text {
        Text("Save as a Favorite")
    }
    var message: Text? </st><st c="7551">{
        Text("You can mark items as Favorite and add them
          to your favorites list.")
    }
    var image: Image? </st><st c="7649">{
        Image(systemName: "star")
    }
}</st></pre>			<p><st c="7680">In this code example, we declared a struct named </st><strong class="source-inline"><st c="7730">MarkAsFavoriteTip</st></strong><st c="7747">, which conforms </st><a id="_idIndexMarker355"/><st c="7764">to the </st><strong class="source-inline"><st c="7771">Tip</st></strong><st c="7774"> protocol. </st><st c="7785">We can see that </st><strong class="source-inline"><st c="7801">MarkAsFavoriteTip</st></strong><st c="7818"> has several properties. </st><st c="7843">The title, message, and image define the content of the tip view, as we can see in </st><span class="No-Break"><em class="italic"><st c="7926">Figure 7</st></em></span><span class="No-Break"><em class="italic"><st c="7934">.3</st></em></span><span class="No-Break"><st c="7936">:</st></span></p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/B21795_07_3.jpg" alt="Figure 7.3: The Save as a Favorite tip view"/><st c="7938"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="8027">Figure 7.3: The Save as a Favorite tip view</st></p>
			<p><st c="8070">In </st><span class="No-Break"><em class="italic"><st c="8074">Figure 7</st></em></span><em class="italic"><st c="8082">.3</st></em><st c="8084">, we can see the tip view with all the content we declared in </st><strong class="source-inline"><st c="8146">MarkAsFavoriteTip</st></strong><st c="8163">. Now, let’s see how we add this tip to our </st><span class="No-Break"><st c="8207">SwiftUI view:</st></span></p>
			<pre class="source-code"><st c="8220">
struct InlineTipView: View {
</st><strong class="bold"><st c="8250">    var tip = MarkAsFavoriteTip()</st></strong><st c="8279">
    var body: some View {
        VStack {
</st><strong class="bold"><st c="8311">            TipView(tip)</st></strong><st c="8323">
            List(workouts) { workout in
                WorkoutView(workout: workout)
            }
        }
    }
}</st></pre>			<p><st c="8389">This code example has a SwiftUI view that presents a list of workouts. </st><st c="8461">To display a tip on top of </st><a id="_idIndexMarker356"/><st c="8488">the list, we created an instance of the </st><strong class="source-inline"><st c="8528">MarkAsFavoriteTip</st></strong><st c="8545"> structure from earlier and then a </st><strong class="source-inline"><st c="8580">TipView</st></strong><st c="8587"> view, passing that </st><span class="No-Break"><st c="8607">tip instance.</st></span></p>
			<p><span class="No-Break"><em class="italic"><st c="8620">Figure 7</st></em></span><em class="italic"><st c="8629">.4</st></em><st c="8631"> shows what it </st><span class="No-Break"><st c="8646">looks like:</st></span></p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/B21795_07_4.jpg" alt="Figure 7.4: A workout list with an inline tip view"/><st c="8657"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="9058">Figure 7.4: A workout list with an inline tip view</st></p>
			<p><span class="No-Break"><em class="italic"><st c="9108">Figure 7</st></em></span><em class="italic"><st c="9117">.4</st></em><st c="9119"> shows how the tip fits nicely on the screen, pushing the list down the </st><strong class="source-inline"><st c="9191">VStack</st></strong><st c="9197"> view. </st><st c="9204">Tapping on the tip’s close button removes the tip from the screen and pushes the list up to take </st><span class="No-Break"><st c="9301">its place.</st></span></p>
			<p><st c="9311">Pretty simple, huh? </st><st c="9332">Now, let’s see how to add a </st><span class="No-Break"><st c="9360">popover tip.</st></span></p>
			<h3><st c="9372">Adding a popover tip</st></h3>
			<p><st c="9393">As mentioned, a popover tip serves different use cases than an inline tip. </st><st c="9469">It blocks the user’s interaction </st><a id="_idIndexMarker357"/><st c="9502">with other elements on the screen and is more contextual. </st><st c="9560">In a popover tip, we link the popover view to a specific control on the screen – usually a button or </st><span class="No-Break"><st c="9661">a toggle.</st></span></p>
			<p><st c="9670">The way we add a popover tip is by using a view modifier called </st><strong class="source-inline"><st c="9735">popoverTip</st></strong><st c="9745">, passing our tip instance (</st><strong class="source-inline"><st c="9773">tip</st></strong><st c="9777">) (just like in an inline tip) and an optional </st><span class="No-Break"><st c="9825">arrow direction:</st></span></p>
			<pre class="source-code"><st c="9841">
struct PopoverTipView: View {
    </st><strong class="bold"><st c="9872">var tip = PopoverTip()</st></strong><st c="9894">
    var body: some View {
        List {
            // some list information
        }
        .navigationTitle("Popover Tip")
        .toolbar(content: {
            Button("Settings", systemImage: "gearshape") {
            }
            .buttonStyle(.plain)
            </st><strong class="bold"><st c="10073">.popoverTip(tip, arrowEdge: .top)</st></strong><st c="10106">
        })
    }
}</st></pre>			<p><st c="10113">Our code example shows a similar pattern to the one we saw in the inline tip. </st><st c="10192">We create a tip instance, and this time, we add the tip to our screen by using a view modifier attached to the screen toolbar button. </st><span class="No-Break"><em class="italic"><st c="10326">Figure 7</st></em></span><em class="italic"><st c="10334">.5</st></em><st c="10336"> shows how </st><span class="No-Break"><st c="10347">it looks:</st></span></p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/B21795_07_5.jpg" alt="Figure 7.5: A popover tip"/><st c="10356"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="10484">Figure 7.5: A popover tip</st></p>
			<p><st c="10509">What’s nice </st><a id="_idIndexMarker358"/><st c="10522">about the popover tip is that we don’t need to care about things such as positioning, depth, or creating the popover pointer – this is all done for us, similar to the popover </st><span class="No-Break"><st c="10697">view modifier.</st></span></p>
			<p><st c="10711">We see that both inline and popover tips have a close button. </st><st c="10774">Let’s discuss it further because this is where we start to reveal the tip’s real </st><span class="No-Break"><st c="10855">added value.</st></span></p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor254"/><st c="10867">Dismissing tips</st></h2>
			<p><st c="10883">You are probably wondering how dismissing a tip view is related to the tip’s </st><span class="No-Break"><st c="10961">added value.</st></span></p>
			<p><st c="10973">We discussed </st><a id="_idIndexMarker359"/><st c="10987">that the real power of tips is not the UI layer but its presentation logic. </st><st c="11063">Whenever we dismiss a tip, TipKit marks it as invalidated and won’t show it again. </st><st c="11146">TipKit also stores the invalidation status permanently, meaning it won’t be displayed after the </st><span class="No-Break"><st c="11242">app relaunch.</st></span></p>
			<p><st c="11255">Another way to dismiss a tip, besides closing it, is to invalidate it in code. </st><st c="11335">Let’s look at the inline tip from the code example earlier again (under </st><em class="italic"><st c="11407">Defining our Tip Model</st></em><st c="11429">). </st><st c="11433">The tip in that example helps the user explore the app’s favorites feature. </st><st c="11509">It also means that whenever the user marks one of the workouts as a favorite, we can assume that the tip is no longer needed and invalidate </st><span class="No-Break"><st c="11649">it ourselves.</st></span></p>
			<p><st c="11662">To invalidate a tip, we need to call the tip’s </st><span class="No-Break"><strong class="source-inline"><st c="11710">invalidate()</st></strong></span><span class="No-Break"> </span><span class="No-Break"><st c="11722">function:</st></span></p>
			<pre class="source-code"><st c="11732">
List(workouts) { workout in
                WorkoutView(workout: workout,
                  onFavoriteButtonTap: {
                    </st><strong class="bold"><st c="11814">tip.invalidate(reason:</st></strong>
<strong class="bold"><st c="11836">                      .actionPerformed)</st></strong><st c="11853">
                })
            }</st></pre>			<p><st c="11858">In this code example, we call the </st><strong class="source-inline"><st c="11893">invalidate()</st></strong><st c="11905"> function whenever the user taps the </st><span class="No-Break"><st c="11942">favorite button.</st></span></p>
			<p><st c="11958">Remember </st><a id="_idIndexMarker360"/><st c="11968">that SwiftUI is a declarative framework – the tip status is part of the view state, and SwiftUI refreshes the screen after </st><span class="No-Break"><st c="12091">a change.</st></span></p>
			<p><st c="12100">Another thing we can see in that code example is the reason for invalidation. </st><st c="12179">In this case, we send </st><strong class="source-inline"><st c="12201">actionPerformed</st></strong><st c="12216"> because this is precisely what happened – the user performed the action suggested by </st><span class="No-Break"><st c="12302">the tip.</st></span></p>
			<p><st c="12310">Another question may arise at this point: how does TipKit know whether that specific tip has already been shown? </st><st c="12424">Also, is there a way to reset the persistent data and show the </st><span class="No-Break"><st c="12487">tip again?</st></span></p>
			<p><st c="12497">That’s where the tip ID </st><span class="No-Break"><st c="12522">comes in.</st></span></p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor255"/><st c="12531">Defining the tip ID</st></h2>
			<p><st c="12551">If you went </st><a id="_idIndexMarker361"/><st c="12564">over the code example under the </st><em class="italic"><st c="12596">Defining our tip model</st></em><st c="12618"> section, you may have noticed the </st><a id="_idTextAnchor256"/><a id="_idTextAnchor257"/><span class="No-Break"><st c="12653">following line:</st></span></p>
			<pre class="source-code"><st c="12668">
var id: String { "InlineTipView"}</st></pre>			<p><st c="12702">The </st><strong class="source-inline"><st c="12707">id</st></strong><st c="12709"> variable is part of the </st><strong class="source-inline"><st c="12734">Tip</st></strong><st c="12737"> protocol; we use that property to define a specific identifier for each tip. </st><st c="12815">TipKit uses that identifier to manage the different </st><span class="No-Break"><st c="12867">tip statuses.</st></span></p>
			<p><st c="12880">You can do a small experiment: create a small app with a tip (or use the code examples in our GitHub repository) and invalidate the tip. </st><st c="13018">Relaunch the app and see that the tip doesn’t show again. </st><st c="13076">Now, modify the tip identifier to have a different name. </st><st c="13133">Relaunch the app, and you’ll see that the tip is visible again. </st><st c="13197">Also, reinstalling the app (after deletion) will reset the local </st><span class="No-Break"><st c="13262">persistent store.</st></span></p>
			<p><st c="13279">Another way to reset the local persistent store is to call the static </st><strong class="source-inline"><st c="13350">resetDatastore</st></strong><st c="13364"> function on </st><span class="No-Break"><st c="13377">app launch:</st></span></p>
			<pre class="source-code"><st c="13388">
struct MyApp: App {
    init() {
        </st><strong class="bold"><st c="13418">try? </st><st c="13423">Tips.resetDatastore()</st></strong><st c="13444">
        try? </st><st c="13450">Tips.configure()
    }
}</st></pre>			<p><st c="13470">Notice that </st><a id="_idIndexMarker362"/><st c="13483">we call the </st><strong class="source-inline"><st c="13495">resetDatastore</st></strong><st c="13509"> function before the </st><span class="No-Break"><strong class="source-inline"><st c="13530">configure</st></strong></span><span class="No-Break"><st c="13539"> function.</st></span></p>
			<p><st c="13549">The tip identifier is part of the </st><strong class="source-inline"><st c="13584">Tip</st></strong><st c="13587"> protocol, and in this example, the identifier is shared across all the </st><span class="No-Break"><st c="13659">struct instances:</st></span></p>
			<pre class="source-code"><st c="13676">
var id: String { "InlineTipView"}</st></pre>			<p><st c="13710">Since the identifier is shared, all the tip views based on the </st><strong class="source-inline"><st c="13774">struct</st></strong><st c="13780"> instances will be dismissed once you invalidate one </st><span class="No-Break"><st c="13833">of them.</st></span></p>
			<p><st c="13841">In most cases, that’s considered normal behavior and best practice. </st><st c="13910">If the user marks a specific row as a favorite, they already know about this feature, even if it appears on </st><span class="No-Break"><st c="14018">another screen.</st></span></p>
			<p><st c="14033">However, that’s not always the case, so plan </st><span class="No-Break"><st c="14079">identifiers accordingly.</st></span></p>
			<p><st c="14103">Now we know how to present a tip, both inline and popover. </st><st c="14163">We also know how to dismiss it and even reset the persistent state. </st><st c="14231">However, TipKit provides even more than that. </st><st c="14277">Let’s see how we can customize </st><span class="No-Break"><st c="14308">our tips.</st></span></p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor258"/><st c="14317">Customizing our tips</st></h1>
			<p><st c="14338">So, TipKit provides </st><a id="_idIndexMarker363"/><st c="14359">an excellent infrastructure for presenting persistence-based tips in our app. </st><st c="14437">However, the TipKit framework’s developers knew that handling tips requires more thought than just invalidating an ordinary view with an image and </st><span class="No-Break"><st c="14584">two texts.</st></span></p>
			<p><st c="14594">Let’s see how we can customize tips to our own needs. </st><st c="14649">We’ll start with </st><span class="No-Break"><st c="14666">their appearance.</st></span></p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor259"/><st c="14683">Customizing our tips’ appearance</st></h2>
			<p><st c="14716">Unlike many other UI-based frameworks Apple has provided, TipKit lets us customize the tip views nicely. </st><st c="14822">This may be because SwiftUI is a declarative framework, and expressing visual content </st><a id="_idIndexMarker364"/><st c="14908">becomes more natural. </st><st c="14930">However, in the case of TipKit, Apple understood developers’ need to align the TipKit design with </st><span class="No-Break"><st c="15028">their apps.</st></span></p>
			<p><st c="15039">There are two ways to customize our tip’s appearance. </st><st c="15094">The first is to modify the tip’s properties and apply basic changes without changing the tip’s layout </st><span class="No-Break"><st c="15196">and components.</st></span></p>
			<p><st c="15211">The second way is to implement a new tip view style, which allows you to fully control the tip’s feel and look. </st><st c="15324">Let’s start with the first way: modifying the </st><span class="No-Break"><st c="15370">tip properties.</st></span></p>
			<h3><st c="15385">Modifying the tip properties</st></h3>
			<p><st c="15414">As I mentioned earlier, one of the great things about SwiftUI is its expressive framework, and we </st><a id="_idIndexMarker365"/><st c="15513">can use view modifiers to adjust the tip’s appearance to </st><span class="No-Break"><st c="15570">our style.</st></span></p>
			<p><st c="15580">Let’s look at the tip’s </st><strong class="source-inline"><st c="15605">title</st></strong> <span class="No-Break"><st c="15610">property again:</st></span></p>
			<pre class="source-code"><st c="15626">
var title: Text { Text("Save as a Favorite") }</st></pre>			<p><st c="15673">Notice that we are not returning a </st><strong class="source-inline"><st c="15709">String</st></strong><st c="15715"> but a </st><strong class="source-inline"><st c="15722">Text</st></strong><st c="15726"> value, which is a SwiftUI view. </st><st c="15759">This means we can modify its look to look like any other </st><span class="No-Break"><st c="15816">SwiftUI view.</st></span></p>
			<p><st c="15829">For example, we can change the title text color by applying the </st><strong class="source-inline"><st c="15894">foregroundStyle</st></strong> <span class="No-Break"><st c="15909">view modifier:</st></span></p>
			<pre class="source-code"><st c="15924">
var title: Text {
        Text("Save as a Favorite")
            </st><strong class="bold"><st c="15970">.foregroundStyle(.red)</st></strong><st c="15992">
    }</st></pre>			<p><st c="15994">The code example is straightforward: we took the text view and changed its look. </st><st c="16075">Moreover, because we can build a </st><strong class="source-inline"><st c="16108">Text</st></strong><st c="16112"> view by compounding multiple text views, we can mix styles </st><span class="No-Break"><st c="16172">and colors:</st></span></p>
			<pre class="source-code"><st c="16183">
 var title: Text {
        Text("Save as a ")
            </st><strong class="bold"><st c="16221">.fontWeight(.light)</st></strong><st c="16240"> +
        Text("Favorite")
            </st><strong class="bold"><st c="16260">.fontWeight(.bold)</st></strong>
<strong class="bold"><st c="16278">            .foregroundStyle(.red)</st></strong><st c="16300">
    }</st></pre>			<p><st c="16302">In </st><a id="_idIndexMarker366"/><st c="16305">this example, we took our </st><strong class="source-inline"><st c="16331">Save as a Favorite</st></strong><st c="16349"> text and changed the </st><strong class="source-inline"><st c="16371">Favorite</st></strong><st c="16379"> text to be red and bold to distinguish it from the rest of </st><span class="No-Break"><st c="16439">the title.</st></span></p>
			<p><st c="16449">We can also perform changes to the </st><strong class="source-inline"><st c="16485">Image</st></strong><st c="16490"> property, such as changing its colors or </st><span class="No-Break"><st c="16532">rendering mode:</st></span></p>
			<pre class="source-code"><st c="16547">
var image: Image? </st><st c="16566">{
        Image(systemName:
          "externaldrive.fill.badge.icloud")
            </st><strong class="bold"><st c="16621">.symbolRenderingMode(.multicolor)</st></strong><st c="16654">
    }</st></pre>			<p><st c="16656">In </st><a id="_idTextAnchor260"/><a href="B21795_06.xhtml#_idTextAnchor212"><span class="No-Break"><em class="italic"><st c="16659">Chapter 6</st></em></span></a><st c="16668">, we learned that SF symbols have multiple layers so that we can apply different colors to different layers. </st><st c="16777">In this example, we changed the rendering mode for our symbol </st><span class="No-Break"><st c="16839">to </st></span><span class="No-Break"><strong class="source-inline"><st c="16842">multicolor</st></strong></span><span class="No-Break"><st c="16852">.</st></span></p>
			<p><st c="16853">Modifying the tip properties is a great way to add a basic touch to our tip view user interface. </st><st c="16951">However, we know how crucial design is in iOS apps, and sometimes, changing colors and font style just isn’t enough. </st><st c="17068">For this reason, we can use </st><strong class="source-inline"><st c="17096">TipViewStyle</st></strong><st c="17108"> for </st><span class="No-Break"><st c="17113">further customization.</st></span></p>
			<h3><st c="17135">Using TipViewStyle</st></h3>
			<p><st c="17154">The given tip view design only works if we need a different UI layout or an even more complex tip view. </st><st c="17259">So, we must consider a different design pattern to meet </st><span class="No-Break"><st c="17315">that requirement.</st></span></p>
			<p><st c="17332">One of </st><a id="_idIndexMarker367"/><st c="17340">the most critical development principles I love to mention is the separation of concerns principle – the idea that different components should have </st><span class="No-Break"><st c="17488">other responsibilities.</st></span></p>
			<p><st c="17511">Some responsibilities are mixed up when we look at how the </st><strong class="source-inline"><st c="17571">Tip</st></strong><st c="17574"> protocol works. </st><st c="17591">On the one hand, the Tip protocol structure defines the content of our tip – the title, message, and image. </st><st c="17699">On the other hand, the structure also defines its design, which may be a </st><span class="No-Break"><st c="17772">different responsibility.</st></span></p>
			<p><st c="17797">The fact that these responsibilities are mixed also limits how we design our tips – we can’t define a new layout as part of </st><span class="No-Break"><st c="17922">the structure.</st></span></p>
			<p><st c="17936">However, content and design are part of SwiftUI’s nature and one of its strengths as a declarative language. </st><st c="18046">Fortunately, we have a solution for that: </st><strong class="bold"><st c="18088">View Styles</st></strong><st c="18099">. A View Style is a </st><a id="_idIndexMarker368"/><st c="18119">way to define the appearance of a </st><span class="No-Break"><st c="18153">view component.</st></span></p>
			<p><st c="18168">Here’s an example of defining a </st><span class="No-Break"><st c="18201">bordered button:</st></span></p>
			<pre class="source-code"><st c="18217">
Button("Sign In", action: signIn)
</st><strong class="bold"><st c="18252">.buttonStyle(.bordered)</st></strong></pre>			<p><st c="18275">In this code example, we stay with the same view (</st><strong class="source-inline"><st c="18326">Button</st></strong><st c="18333">) but apply a </st><span class="No-Break"><st c="18348">specific style.</st></span></p>
			<p><st c="18363">In TipKit, we can also define our tip appearance by applying a custom </st><span class="No-Break"><st c="18434">view style:</st></span></p>
			<pre class="source-code"><st c="18445">
struct ImageAtTheCornerViewStyle: TipViewStyle {
</st><strong class="bold"><st c="18495">    func makeBody(configuration: Configuration) -&gt; some</st></strong>
<strong class="bold"><st c="18546">      View</st></strong><st c="18551"> {
        VStack {
            if let title = configuration.title, let message
              = configuration.message {
                title
                    .multilineTextAlignment(.center)
                    .font(.title2)
</st><strong class="bold"><st c="18691">                Divider()</st></strong><st c="18700">
                message
                    .multilineTextAlignment(.leading)
                    .font(.body)
            }
            HStack {
                Spacer()
                Image(systemName: "star")
            }
            .padding()
        }
    }
}</st></pre>			<p><st c="18820">The View </st><a id="_idIndexMarker369"/><st c="18830">Style we just created takes a </st><strong class="source-inline"><st c="18860">Tip</st></strong><st c="18863"> view and returns a new view with the same content but a different layout and design. </st><st c="18949">It even adds a new view component, such as a </st><strong class="source-inline"><st c="18994">Divider</st></strong><st c="19001"> and </st><strong class="source-inline"><st c="19006">Spacer</st></strong><st c="19012"> component. </st><st c="19024">The magic happens in the </st><strong class="source-inline"><st c="19049">makeBody</st></strong><st c="19057"> function, which receives a </st><strong class="source-inline"><st c="19085">Configuration</st></strong><st c="19098"> parameter that contains all the </st><span class="No-Break"><st c="19131">tip information.</st></span></p>
			<p><st c="19147">To apply our new View Style on a tip, we can use the </st><span class="No-Break"><strong class="source-inline"><st c="19201">tipViewStyle</st></strong></span><span class="No-Break"><st c="19213"> method:</st></span></p>
			<pre class="source-code"><st c="19221">
TipView(t</st><a id="_idTextAnchor261"/><a id="_idTextAnchor262"/><st c="19231">ip)
</st><strong class="bold"><st c="19236">      .tipViewStyle(ImageAtTheCornerViewStyle())</st></strong></pre>			<p><st c="19278">Now, our </st><strong class="source-inline"><st c="19288">TipView</st></strong><st c="19295"> view has our new custom style and layout, and it looks like this (</st><span class="No-Break"><em class="italic"><st c="19362">Figure 7</st></em></span><span class="No-Break"><em class="italic"><st c="19371">.6</st></em></span><span class="No-Break"><st c="19373">):</st></span></p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/B21795_07_6.jpg" alt="Figure 7.6: Customizing our tip with TipViewStyle"/><st c="19376"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="19466">Figure 7.6: Customizing our tip with TipViewStyle</st></p>
			<p><st c="19515">It is a </st><a id="_idIndexMarker370"/><st c="19524">good practice to name the </st><strong class="source-inline"><st c="19550">TipViewStyle</st></strong><st c="19562"> protocol with a generic and descriptive name such as </st><strong class="source-inline"><st c="19616">ImageAtTheCornerViewStyle</st></strong><st c="19641">, so it will be easier to share it with the rest of </st><span class="No-Break"><st c="19693">our tips.</st></span></p>
			<p><st c="19702">Up to now, we’ve learned how to define a tip, present it in different places, and design it however we want. </st><st c="19812">However, our journey with enriching our tips doesn’t end here, as we can also add some user interactions by </st><span class="No-Break"><st c="19920">adding </st></span><span class="No-Break"><strong class="bold"><st c="19927">actions</st></strong></span><span class="No-Break"><st c="19934">.</st></span></p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor263"/><st c="19935">Adding actions</st></h2>
			<p><st c="19950">Actions are very valuable additions to tips. </st><st c="19996">In many cases, our tips suggest that the user take </st><a id="_idIndexMarker371"/><st c="20047">an action – go to the settings screen, add a new task, or enter our app’s new edit mode, for example. </st><st c="20149">What’s better than adding a button that performs that specific action inside the </st><span class="No-Break"><st c="20230">tip view?</st></span></p>
			<p><st c="20239">Besides the title, message, and image, the tip protocol also contains an actions property – an array of structures describing the buttons our tip </st><span class="No-Break"><st c="20386">will display.</st></span></p>
			<p><st c="20399">Let’s see that property in </st><span class="No-Break"><st c="20427">an example:</st></span></p>
			<pre class="source-code"><st c="20438">
struct ChangeEmailTip: Tip {
    </st><strong class="bold"><st c="20468">var actions: [Action] {</st></strong>
<strong class="bold"><st c="20491">        Action(id: "go-to-settings", title: "Go to</st></strong>
<strong class="bold"><st c="20534">          settings")</st></strong>
<strong class="bold"><st c="20545">        Action(id: "change-now", title: "Change email now")</st></strong>
<strong class="bold"><st c="20597">    }</st></strong><st c="20599">
}</st></pre>			<p><st c="20601">The code example shows a </st><strong class="source-inline"><st c="20626">ChangeEmailTip</st></strong><st c="20640"> structure with two actions. </st><st c="20669">(Notice that this tip is partial; assume that we already implemented the rest of the properties, such as </st><strong class="source-inline"><st c="20774">title</st></strong> <span class="No-Break"><st c="20779">and </st></span><span class="No-Break"><strong class="source-inline"><st c="20784">message</st></strong></span><span class="No-Break"><st c="20791">.)</st></span></p>
			<p><st c="20793">Each action initialization function has two parameters: </st><strong class="source-inline"><st c="20850">title</st></strong><st c="20855"> and </st><strong class="source-inline"><st c="20860">id</st></strong><st c="20862">. The </st><strong class="source-inline"><st c="20868">title</st></strong><st c="20873"> parameter </st><a id="_idIndexMarker372"/><st c="20884">represents the title that appears on the button. </st><st c="20933">The </st><strong class="source-inline"><st c="20937">id</st></strong><st c="20939"> parameter describes the goal of this action, and we use it to determine which button the </st><span class="No-Break"><st c="21029">user tapped.</st></span></p>
			<p><span class="No-Break"><em class="italic"><st c="21041">Figure 7</st></em></span><em class="italic"><st c="21050">.7</st></em><st c="21052"> shows how the actions look in a </st><span class="No-Break"><st c="21085">popover tip:</st></span></p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/B21795_07_7.jpg" alt="Figure 7.7: Two actions in a popover tip view"/><st c="21097"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="21222">Figure 7.7: Two actions in a popover tip view</st></p>
			<p><st c="21267">Like the rest of the properties, TipKit decides what layout to present the actions in and how the </st><span class="No-Break"><st c="21366">buttons look.</st></span></p>
			<p><st c="21379">Now that we have defined and presented the actions, let’s see how we respond to user selection. </st><st c="21476">Responding to an action is easy now that we have an ID for each action. </st><st c="21548">The </st><strong class="source-inline"><st c="21552">popoverTip</st></strong><st c="21562"> view modifier we discussed in the </st><em class="italic"><st c="21597">Adding a popover tip</st></em><st c="21617"> section has an additional closure that handles action selection. </st><st c="21683">Let’s see a code example </st><span class="No-Break"><st c="21708">for that:</st></span></p>
			<pre class="source-code"><st c="21717">
Button("Settings", systemImage: "gearshape") {
                gotoSettings = true
            }
            .buttonStyle(.plain)
            .popoverTip(tip, arrowEdge: .top) </st><strong class="bold"><st c="21842">{ action in</st></strong>
<strong class="bold"><st c="21853">                if action.id == "go-to-settings" {</st></strong>
<strong class="bold"><st c="21888">                    gotoSettings = true</st></strong>
<strong class="bold"><st c="21908">                }</st></strong>
<strong class="bold"><st c="21910">            }</st></strong></pre>			<p><st c="21912">This code example shows the exact popover tip implementation, now with the closure that handles </st><a id="_idIndexMarker373"/><st c="22008">the selected action. </st><st c="22029">Within the closure, we check for the action ID and perform the desired action (for example, navigate to the </st><span class="No-Break"><st c="22137">settings screen).</st></span></p>
			<p><st c="22154">It’s much nicer to add these ids in static constants </st><span class="No-Break"><st c="22208">for clarity:</st></span></p>
			<pre class="source-code"><st c="22220">
struct ChangeEmailTip: Tip {
    // rest of the tip
var actions: [Action] {
        Action(id: </st><strong class="bold"><st c="22304">ChangeEmailTip.goToSettingsAction</st></strong><st c="22337">,
          title: "Go to settings")
        Action(id: ChangeEmailTip.changeEmailAction, title:
          "Change email now")
    }
</st><strong class="bold"><st c="22438">    static let goToSettingsAction = "go-to-settings"</st></strong><st c="22486">
    static let changeEmailAction = "change-now"
}
…
.popoverTip(tip, arrowEdge: .top) { action in
                if action.id ==
                  </st><strong class="bold"><st c="22597">ChangeEmailTip.goToSettingsAction</st></strong><st c="22630"> {
                    gotoSettings = true
                }
            }</st></pre>			<p><st c="22656">This code example shows how beautiful Swift can be when applying </st><span class="No-Break"><st c="22722">best practices!</st></span></p>
			<p><st c="22737">Speaking </st><a id="_idIndexMarker374"/><st c="22747">of beautiful, we discussed how to design our tips using </st><strong class="source-inline"><st c="22803">TipViewStyle</st></strong><st c="22815">, so we can also design our actions using the </st><span class="No-Break"><st c="22861">same technique:</st></span></p>
			<pre class="source-code"><st c="22876">
List(</st><strong class="bold"><st c="22882">configuration.actions</st></strong><st c="22904">) { action in
                Button(action:{
                    // perform action
                }) {
                    action.label()
                }
            }</st></pre>			<p><st c="22976">In this code example, we create a list of buttons, each handling a different action. </st><st c="23062">We need to add that code snippet to the </st><strong class="source-inline"><st c="23102">makeBody</st></strong><st c="23110"> function we learned about in the </st><em class="italic"><st c="23144">Using </st></em><span class="No-Break"><em class="italic"><st c="23150">TipViewStyle</st></em></span><span class="No-Break"><st c="23162"> section.</st></span></p>
			<p><st c="23171">At this point, we’ve learned so much about tips! </st><st c="23221">The good news is that we have more surprises up our sleeves. </st><st c="23282">Let’s reveal them and discuss the </st><span class="No-Break"><strong class="bold"><st c="23316">rules</st></strong></span><span class="No-Break"><st c="23321"> feature.</st></span></p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor264"/><st c="23330">Adding tips rules</st></h1>
			<p><st c="23348">Throughout this chapter, we have focused mainly on the UI side of displaying tips so far. </st><st c="23439">However, we already know that tips are more than just nice views – they must correspond </st><a id="_idIndexMarker375"/><st c="23527">to some app logic or states. </st><st c="23556">For example, maybe there are tips that we present when the user is logged in. </st><st c="23634">In a photo app, we can show a tip suggesting adding an album after the user takes a certain number </st><span class="No-Break"><st c="23733">of photos.</st></span></p>
			<p><st c="23743">Tips must often be </st><em class="italic"><st c="23763">made aware</st></em><st c="23773"> of users’ flows and states. </st><st c="23802">That’s why TipKit also contains a feature </st><span class="No-Break"><st c="23844">called rules.</st></span></p>
			<p><st c="23857">There are two </st><span class="No-Break"><st c="23872">rule types:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="23883">Based on state</st></strong><st c="23898">: Show or hide the tip based on a specific state. </st><st c="23949">The user logged in, performed a particular action, </st><span class="No-Break"><st c="24000">and more.</st></span></li>
				<li><strong class="bold"><st c="24009">Events tracking</st></strong><st c="24025">: Show or hide the tip based on the number of events the user performed. </st><st c="24099">For example, if the user entered a specific screen in the settings a few times in the past week, we could offer for them to create a shortcut for </st><span class="No-Break"><st c="24245">that screen.</st></span></li>
			</ul>
			<p><st c="24257"> Let’s start with adding a rule based on </st><span class="No-Break"><st c="24298">a state.</st></span></p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor265"/><st c="24306">Adding a rule based on a state</st></h2>
			<p><st c="24337">Creating rules </st><a id="_idIndexMarker376"/><st c="24353">based on a state is the common way to establish </st><a id="_idIndexMarker377"/><st c="24401">tip display logic. </st><st c="24420">What is a state? </st><st c="24437">A state can be an authentication state (is the user logged in?), unlocking goods, features usage, </st><span class="No-Break"><st c="24535">and more.</st></span></p>
			<p><st c="24544">There are three steps for implementing a rule that is based on </st><span class="No-Break"><st c="24608">a state:</st></span></p>
			<ol>
				<li><strong class="bold"><st c="24616">Adding a parameter</st></strong><st c="24635">: We need to add a variable on which the rule will </st><span class="No-Break"><st c="24687">be based.</st></span></li>
				<li><strong class="bold"><st c="24696">Define the rule</st></strong><st c="24712">: The rules are defined inside the tip and should consider the parameter </st><span class="No-Break"><st c="24786">we discussed.</st></span></li>
				<li><strong class="bold"><st c="24799">Connect the parameter to the app logic</st></strong><st c="24838">: If we want the rule to be based on our app’s real state, we need to maintain and synchronize it with the </st><span class="No-Break"><st c="24946">app state.</st></span></li>
			</ol>
			<p><st c="24956">Believe it or not, implementing a rule-based tip is even easier than it looks! </st><st c="25036">Let’s try to build a tip encouraging our users to use a premium-only feature such as changing the </st><span class="No-Break"><st c="25134">app theme.</st></span></p>
			<h3><st c="25144">Adding a parameter</st></h3>
			<p><st c="25163">The rule needs to rely on persistent data that the app can easily modify to track an app state. </st><st c="25260">To do </st><a id="_idIndexMarker378"/><st c="25266">that, we use the </st><strong class="source-inline"><st c="25283">@parameter</st></strong><st c="25293"> macro to add a tracking state variable to </st><span class="No-Break"><st c="25336">our tip.</st></span></p>
			<p class="callout-heading"><st c="25344">What is a macro?</st></p>
			<p class="callout"><st c="25361">A macro is </st><a id="_idIndexMarker379"/><st c="25373">a Swift feature that helps the compiler generate code based on the current code and parameters. </st><st c="25469">You can read about macros in </st><a href="B21795_10.xhtml#_idTextAnchor329"><span class="No-Break"><em class="italic"><st c="25498">Chapter 10</st></em></span></a><span class="No-Break"><st c="25508">.</st></span></p>
			<p><st c="25509">Let’s add a parameter called </st><strong class="source-inline"><st c="25539">isPremiumUser</st></strong><st c="25552"> to track </st><span class="No-Break"><st c="25562">premium eligibility:</st></span></p>
			<pre class="source-code"><st c="25582">
struct ChangeAppThemeTip: Tip {
    // rest of the tip implementation
    </st><strong class="bold"><st c="25649">@Parameter</st></strong><st c="25659">
    static var isPremiumUser: Bool = false
}</st></pre>			<p><st c="25700">Expanding the macro reveals a </st><span class="No-Break"><st c="25731">simple implementation:</st></span></p>
			<pre class="source-code"><st c="25753">
static var $isPremiumUser: Tips.Parameter&lt;Bool&gt; =
  Tips.Parameter(Self.self, "+isPremiumUser", false)
  {
    get {
            $isPremiumUser.wrappedValue
    }
    set {
            $isPremiumUser.wrappedValue = newValue
    }
}</st></pre>			<p><st c="25941">Let’s delve into the macro implementation. </st><st c="25985">Since TipKit wants to work with a generic type, the macro creates another variable called </st><strong class="source-inline"><st c="26075">$isPremiumUser</st></strong><st c="26089"> of the </st><strong class="source-inline"><st c="26097">Tips. </st><st c="26103">Parameter</st></strong><st c="26112"> type (based on </st><strong class="source-inline"><st c="26128">Bool</st></strong><st c="26132">) and a default value of </st><strong class="source-inline"><st c="26158">false</st></strong><st c="26163"> (as initially defined in our </st><span class="No-Break"><st c="26193">static variable).</st></span></p>
			<p><st c="26210">The macro </st><a id="_idIndexMarker380"/><st c="26221">also creates a </st><strong class="bold"><st c="26236">getter</st></strong><st c="26242"> and a </st><strong class="bold"><st c="26249">setter</st></strong><st c="26255"> so our tip can respond to app </st><span class="No-Break"><st c="26286">state changes.</st></span></p>
			<p><st c="26300">However, the macro handles another thing that helps us: making our parameter value </st><strong class="bold"><st c="26384">persistent</st></strong><st c="26394">. In this case, the answer to the question “Is the user premium?” is probably persistent anyway. </st><st c="26491">However, there are cases where it’s not that obvious. </st><st c="26545">For example, feature usage tracking is not </st><span class="No-Break"><st c="26588">normally persistent.</st></span></p>
			<p><st c="26608">Now that we have a parameter let’s add our first </st><span class="No-Break"><st c="26658">display rule.</st></span></p>
			<h3><st c="26671">Defining our display rules</st></h3>
			<p><st c="26698">Are we defining display “rules”, </st><span class="No-Break"><st c="26732">in plural?</st></span></p>
			<p><st c="26742">Yes! </st><st c="26748">TipKit </st><a id="_idIndexMarker381"/><st c="26755">supports multiple display rules to support more complex situations. </st><st c="26823">However, first, let’s start with </st><span class="No-Break"><st c="26856">one tip:</st></span></p>
			<pre class="source-code"><st c="26864">
struct ChangeAppThemeTip: Tip {
    @Parameter
    static var isPremiumUser: Bool = false
    </st><strong class="bold"><st c="26947">var rules: [Rule] {</st></strong>
<strong class="bold"><st c="26966">        [</st></strong>
<strong class="bold"><st c="26968">            #Rule(Self.$isPremiumUser) {</st></strong>
<strong class="bold"><st c="26997">                $0 == true</st></strong>
<strong class="bold"><st c="27008">            }</st></strong>
<strong class="bold"><st c="27010">        ]</st></strong>
<strong class="bold"><st c="27012">    }</st></strong><st c="27014">
}</st></pre>			<p><st c="27016">In this code example, we use a macro to build a data type called </st><strong class="source-inline"><st c="27081">Rule</st></strong><st c="27085"> that contains a predicate expression. </st><st c="27124">That predicate expression compares the given type to a </st><span class="No-Break"><st c="27179">specific value.</st></span></p>
			<p><st c="27194">In this case, we compare the </st><strong class="source-inline"><st c="27224">$isPremiumUser</st></strong><st c="27238"> value </st><span class="No-Break"><st c="27245">to </st></span><span class="No-Break"><strong class="source-inline"><st c="27248">true</st></strong></span><span class="No-Break"><st c="27252">.</st></span></p>
			<p><st c="27253">Now, let’s go </st><a id="_idIndexMarker382"/><st c="27268">back to the </st><strong class="source-inline"><st c="27280">rules</st></strong><st c="27285"> variable. </st><st c="27296">We can add more rules that support our tip display logic. </st><st c="27354">TipKit performs an </st><strong class="source-inline"><st c="27373">AND</st></strong><st c="27376"> operator between the different tips, and if the result is true, then the tip is displayed (unless the user or the app dismisses </st><span class="No-Break"><st c="27505">it, obviously).</st></span></p>
			<p><st c="27520">How can we modify the value the rule is based on? </st><span class="No-Break"><st c="27571">Let’s see.</st></span></p>
			<h3><st c="27581">Connecting the parameter to our app logic</st></h3>
			<p><st c="27623">We need to connect the tip parameters to our app logic to finalize our work. </st><st c="27701">Notice that the parameter </st><a id="_idIndexMarker383"/><st c="27727">is a static variable. </st><st c="27749">This means that we can modify it from anywhere in our app, even if we don’t have a reference for the </st><span class="No-Break"><st c="27850">tip instance.</st></span></p>
			<p><st c="27863">Let’s see an essential </st><span class="No-Break"><st c="27887">parameter modification:</st></span></p>
			<pre class="source-code"><st c="27910">
    let tip = ChangeAppThemeTip()
    var body: some View {
        VStack {
            Button("Change isPremium parameter") {
</st><strong class="bold"><st c="28011">                ChangeAppThemeTip.isPremiumUser.toggle()</st></strong><st c="28051">
            }
            TipView(tip)
        }
    }</st></pre>			<p><st c="28070">This code example shows a basic UI with a button that toggles the static </st><strong class="source-inline"><st c="28144">isPremiumUser</st></strong><st c="28157"> variable, which we created in our tip earlier. </st><st c="28205">Toggling that value also shows and hides the </st><strong class="source-inline"><st c="28250">TipView</st></strong><st c="28257"> view down </st><span class="No-Break"><st c="28268">the VStack.</st></span></p>
			<p><st c="28279">However, adding a button that toggles a tip is not a real-world example of using a rule parameter. </st><st c="28379">A more practical example would be connecting it directly to the user’s premium state using a </st><strong class="source-inline"><st c="28472">Combine</st></strong><st c="28479"> stream – something like the </st><span class="No-Break"><st c="28508">following code:</st></span></p>
			<pre class="source-code"><st c="28523">
let premiumManager = PremiumPurchaseManager()
let premiumStatusSubscription =
  premiumManager.premiumPurchasePublisher
    </st><strong class="bold"><st c="28642">.assign(to: \.isPremiumUser, on:</st></strong>
<strong class="bold"><st c="28674">      ChangeAppThemeTip.self)</st></strong></pre>			<p><st c="28698">In this </st><a id="_idIndexMarker384"/><st c="28707">code example, we have a premium purchase publisher and we assign its output to our tip’s </st><strong class="source-inline"><st c="28796">isPremiumUser</st></strong><st c="28809"> parameter. </st><st c="28821">This is a more elegant way to link the rule logic to </st><span class="No-Break"><st c="28874">our app.</st></span></p>
			<p><st c="28882">Now let’s discuss the other type of rules – </st><span class="No-Break"><st c="28927">events.</st></span></p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor266"/><st c="28934">Adding a rule based on events</st></h2>
			<p><st c="28964">When we display a tip based on a state, it’s usually only displayed when the user can use a particular </st><a id="_idIndexMarker385"/><st c="29068">feature. </st><st c="29077">However, there are cases when we want to display </st><a id="_idIndexMarker386"/><st c="29126">a tip when we think the user is ready to take our app to the following </st><span class="No-Break"><st c="29197">usage level.</st></span></p>
			<p><st c="29209">For example, if we create a music app and the user adds a few songs, maybe it’s a good idea to tell them about making a playlist. </st><st c="29340">Or, if we are working on a dating app, maybe it is worth suggesting modifying the search filter if the user hasn’t chosen any of the </st><span class="No-Break"><st c="29473">profiles viewed.</st></span></p>
			<p><st c="29489">For these types of tips, we can create a rule based on tracking events. </st><st c="29562">The idea is to define an event representing the user’s relevant action. </st><st c="29634">For example, I can add a task, view a profile, and more. </st><st c="29691">Afterward, we create a rule based on the number of events tracked within a time frame </st><span class="No-Break"><st c="29777">or generally.</st></span></p>
			<p><st c="29790">Let’s see a code example for a tip suggesting the user add a list of to-dos. </st><st c="29868">We’ll start by defining </st><span class="No-Break"><st c="29892">our tip:</st></span></p>
			<pre class="source-code"><st c="29900">
struct AddListTip: Tip {
    </st><strong class="bold"><st c="29926">static let didAddATaskEvent = Event(id:</st></strong>
<strong class="bold"><st c="29965">      "didAddATaskEvent")</st></strong><st c="29985">
    var rules: [Rule] {
        </st><strong class="bold"><st c="30006">#Rule(Self.didAddATaskEvent) {</st></strong>
<strong class="bold"><st c="30036">            $0.donations.count &gt; 3</st></strong>
<strong class="bold"><st c="30059">        }</st></strong><st c="30061">
    }
}</st></pre>			<p><st c="30065">The tip goal is to suggest the user add to a list of to-dos. </st><st c="30127">We create an event called </st><strong class="source-inline"><st c="30153">didAppTaskEvent</st></strong><st c="30168"> that helps us track the number of times the user adds a </st><span class="No-Break"><st c="30225">new to-do.</st></span></p>
			<p><st c="30235">The second thing </st><a id="_idIndexMarker387"/><st c="30253">we do here is to create a new rule that returns </st><strong class="source-inline"><st c="30301">true</st></strong><st c="30305"> if the number of tracked events </st><span class="No-Break"><st c="30338">exceeds three.</st></span></p>
			<p><st c="30352">This is a different </st><a id="_idIndexMarker388"/><st c="30373">rule constructor that handles event tracking instead of </st><span class="No-Break"><st c="30429">a state.</st></span></p>
			<p><st c="30437">The last piece of the puzzle shows the tip and track of </st><span class="No-Break"><st c="30494">an event:</st></span></p>
			<pre class="source-code"><st c="30503">
struct EventRuleTipExample: View {
    let tip = AddListTip()
    @State var todos: [Todo] = []
    var body: some View {
        VStack {
            TipView(tip)
            List(todos) { todo in
                Text(todo.title)
            }
            Spacer()
            Button("Add task") {
                todos.append(Todo(title: "New Task"))
                </st><strong class="bold"><st c="30745">Task{ await</st></strong>
<strong class="bold"><st c="30756">                  AddListTip.didAddATaskEvent.donate()}</st></strong>
<strong class="bold"><st c="30794">            }</st></strong><st c="30796">
        }
    }
}</st></pre>			<p><st c="30802">The event </st><a id="_idIndexMarker389"/><st c="30813">tracking operation is referred to as </st><strong class="source-inline"><st c="30850">donate()</st></strong><st c="30858">, while the </st><a id="_idIndexMarker390"/><st c="30870">total number of tracked events is known </st><span class="No-Break"><st c="30910">as </st></span><span class="No-Break"><strong class="bold"><st c="30913">donations</st></strong></span><span class="No-Break"><st c="30922">.</st></span></p>
			<p><st c="30923">We can also </st><a id="_idIndexMarker391"/><st c="30936">check for events tracked in a specific </st><span class="No-Break"><st c="30975">time range:</st></span></p>
			<pre class="source-code"><st c="30986">
$0.donations.donatedWithin(.days(3)).count &gt; 3
$0.donations.donatedWithin(.week).count &lt; 3</st></pre>			<p><st c="31077">This example checks whether the number of events exceeds three in the last three days or </st><span class="No-Break"><st c="31167">one week.</st></span></p>
			<p><st c="31176">Now, it’s important to distinguish between the number of events tracked and just checking the database for the number </st><span class="No-Break"><st c="31295">of to-dos.</st></span></p>
			<p><st c="31305">We could easily check the user’s number of to-dos in their database and change that to a state-based rule. </st><st c="31413">However, this solves a different use case – not the number of times the user added a task with the app, but rather the number of tasks the user has </st><span class="No-Break"><st c="31561">in general.</st></span></p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor267"/><st c="31572">Grouping tips with TipGroup</st></h2>
			<p><st c="31600">When our app becomes more extensive and feature-rich, handling a large set of tips can become </st><a id="_idIndexMarker392"/><st c="31695">cumbersome. </st><st c="31707">Trying to coordinate all these tips using rules can lead to a situation wherein tips appear outside the intended order and </st><span class="No-Break"><st c="31830">even together.</st></span></p>
			<p><st c="31844">To address that, we can use the </st><strong class="source-inline"><st c="31877">TipGroup</st></strong><st c="31885"> class to group tips and present them individually in a </st><span class="No-Break"><st c="31941">particular order.</st></span></p>
			<p><st c="31958">Let’s see an example for a </st><strong class="source-inline"><st c="31986">TipGroup</st></strong> <span class="No-Break"><st c="31994">class usage:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="32007">@State var tips = TipGroup(.ordered) {</st></strong>
<strong class="bold"><st c="32046">        FirstTip()</st></strong>
<strong class="bold"><st c="32057">        SecondTip()</st></strong>
<strong class="bold"><st c="32069">    }</st></strong><st c="32071">
    var body: some View {
        Button("Settings") {
        }.popoverTip(</st><strong class="bold"><st c="32128">tips.currentTip</st></strong><st c="32144">)
    }</st></pre>			<p><st c="32148">In this example, we created a state variable called </st><strong class="source-inline"><st c="32201">tips</st></strong><st c="32205"> of the TipGroup type. </st><st c="32228">We passed </st><strong class="source-inline"><st c="32238">.ordered</st></strong><st c="32246"> for its priority parameter and added two tips using its builder. </st><st c="32312">In the code itself, we attached our </st><strong class="source-inline"><st c="32348">TipGroup</st></strong><st c="32356"> instance to a button using the </st><strong class="source-inline"><st c="32388">popoverTip</st></strong><st c="32398"> view modifier, passing the group’s </st><span class="No-Break"><st c="32434">current tip.</st></span></p>
			<p><st c="32446">Using the .</st><strong class="source-inline"><st c="32458">ordered</st></strong><st c="32466"> parameter ensures that the tips will appear in the order in which we added them to the builder. </st><st c="32563">TipKit will show the next tip once all the previous tips have </st><span class="No-Break"><st c="32625">been invalidated.</st></span></p>
			<p><st c="32642">The other parameter we can use is </st><strong class="source-inline"><st c="32677">firstAvailable</st></strong><st c="32691">, which shows the next tip that is eligible </st><span class="No-Break"><st c="32735">for display.</st></span></p>
			<p><st c="32747">Grouping tips together can help manage a large collection of tips in our project. </st><st c="32830">However, looking at the code example again, we can see that there might be a problem with the way we implemented the TipGroup in the view. </st><st c="32969">Imagine we have a TipGroup with a </st><strong class="source-inline"><st c="33003">SettingsTip</st></strong><st c="33014"> type and a </st><strong class="source-inline"><st c="33026">ProfileTip</st></strong><st c="33036"> type. </st><st c="33043">When using the TipGroup for settings and profile buttons, we can’t control which tip </st><span class="No-Break"><st c="33128">appears where.</st></span></p>
			<p><st c="33142">To solve </st><a id="_idIndexMarker393"/><st c="33152">that, we can cast the </st><strong class="source-inline"><st c="33174">currentTip</st></strong><st c="33184"> variable to the desired tip type. </st><st c="33219">Let’s see that in the </st><span class="No-Break"><st c="33241">following code:</st></span></p>
			<pre class="source-code"><st c="33256">
    @State var tips = TipGroup(.ordered) {
        SettingsTip()
        ProfileTip()
    }
    var body: some View {
        Button("Settings") {
        }.popoverTip(</st><strong class="bold"><st c="33381">tips.currentTip as? </st><st c="33402">SettingsTip</st></strong><st c="33413">)
        Button("Profile") {
        }.popoverTip(</st><strong class="bold"><st c="33449">tips.currentTip as? </st><st c="33470">ProfileTip</st></strong><st c="33480">)
    }</st></pre>			<p><st c="33484">In this code example, we have a TipGroup with two tips – for the settings button and for the </st><span class="No-Break"><st c="33578">profile button.</st></span></p>
			<p><st c="33593">When we use the </st><strong class="source-inline"><st c="33610">popoverTip</st></strong><st c="33620"> view builder, we cast the </st><strong class="source-inline"><st c="33647">currentTip</st></strong><st c="33657"> instance to the corresponding type according to the button. </st><st c="33718">This technique takes advantage of how the </st><strong class="source-inline"><st c="33760">popoverTip</st></strong> <span class="No-Break"><st c="33770">signature looks:</st></span></p>
			<pre class="source-code"><st c="33787">
public func popoverTip(_ tip: (any Tip)?...)</st></pre>			<p><st c="33832">Since </st><strong class="source-inline"><st c="33839">popoverTip</st></strong><st c="33849"> accepts </st><strong class="source-inline"><st c="33858">nil</st></strong><st c="33861"> as an argument, we can ensure that only relevant tips will appear from </st><span class="No-Break"><st c="33933">the TipGroup.</st></span></p>
			<p><st c="33946">Rules are only one aspect of defining the appearance logic. </st><st c="34007">Another crucial element is determining its frequency. </st><st c="34061">Let’s see how to customize that </st><span class="No-Break"><st c="34093">as well.</st></span></p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor268"/><st c="34101">Customizing display frequency</st></h1>
			<p><st c="34131">I</st><a id="_idTextAnchor269"/><a id="_idTextAnchor270"/><st c="34133">n the previous section, we discussed creating display logic for our tips using rules and tip groups. </st><st c="34234">However, tips can overwhelm users; there’s a fine line between helping the user and </st><a id="_idIndexMarker394"/><st c="34318">disturbing them. </st><st c="34335">Adjusting all the rules to set a reasonable limit on the number of tips the user sees can be challenging. </st><st c="34441">For that problem, we can manage the frequency at which our </st><span class="No-Break"><st c="34500">tips display.</st></span></p>
			<p><st c="34513">Let’s start with setting the max display count for </st><span class="No-Break"><st c="34565">a tip.</st></span></p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor271"/><st c="34571">Setting the max display count for a specific tip</st></h2>
			<p><st c="34620">The first and essential thing we can do is set the maximum number of a specific tip type that can </st><span class="No-Break"><st c="34719">be displayed.</st></span></p>
			<p><st c="34732">We do </st><a id="_idIndexMarker395"/><st c="34739">that by adding a new variable to our tip </st><span class="No-Break"><st c="34780">called </st></span><span class="No-Break"><strong class="source-inline"><st c="34787">options</st></strong></span><span class="No-Break"><st c="34794">:</st></span></p>
			<pre class="source-code"><st c="34796">
struct AddListTip: Tip {
    var options: [TipOption] {
</st><strong class="bold"><st c="34849">        Tips.MaxDisplayCount(2)</st></strong><st c="34872">
    }
}</st></pre>			<p><st c="34876">In this code example, we use the </st><strong class="source-inline"><st c="34910">MaxDisplayCount</st></strong><st c="34925"> static function of the </st><strong class="source-inline"><st c="34949">Tips</st></strong><st c="34953"> namespace. </st><st c="34965">That definition means that the tip will be displayed a maximum of two times, and afterward, it will be invalidated, overriding the rest of the rule’s logic. </st><st c="35122">That’s a great way to ensure that a specific tip doesn’t </st><span class="No-Break"><st c="35179">overwhelm users.</st></span></p>
			<p><st c="35195">However, there’s another excellent way to ensure a calmer user experience: </st><span class="No-Break"><st c="35271">display frequency.</st></span></p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor272"/><st c="35289">Setting our tips’ display frequency</st></h2>
			<p><st c="35325">We just learned how to limit a particular tip to a certain number of appearances. </st><st c="35408">Another </st><a id="_idIndexMarker396"/><st c="35416">way to handle tip appearance is to define </st><span class="No-Break"><st c="35458">its frequency.</st></span></p>
			<p><st c="35472">Let’s look at the </st><span class="No-Break"><st c="35491">following code:</st></span></p>
			<pre class="source-code"><st c="35506">
struct MyApp: App {
    init() {
</st><strong class="bold"><st c="35536">        try? </st><st c="35541">Tips.configure([.displayFrequency(.daily)])</st></strong><st c="35584">
    }
}</st></pre>			<p><st c="35588">The code example shows how we can limit the total number of tips displayed to one </st><span class="No-Break"><st c="35671">per day.</st></span></p>
			<p><st c="35679">The</st><strong class="source-inline"><st c="35683">.displayFrequency(.daily)</st></strong><st c="35708"> expression means that TipKit will show no more than one tip per day. </st><st c="35778">Obviously, we have additional frequency options: hourly, weekly, monthly, </st><span class="No-Break"><st c="35852">and immediate.</st></span></p>
			<p><st c="35866">We can configure specific tips to ignore the system </st><span class="No-Break"><st c="35919">display frequency:</st></span></p>
			<pre class="source-code"><st c="35937">
struct AddListTip: Tip {
    var options: [TipOption] {
        </st><strong class="bold"><st c="35990">Tips.IgnoresDisplayFrequency(true)</st></strong><st c="36024">
    }
}</st></pre>			<p><st c="36028">In this code example, the </st><strong class="source-inline"><st c="36055">AddListTip</st></strong><st c="36065"> tip ignores the system definition for general </st><span class="No-Break"><st c="36112">display frequency.</st></span></p>
			<p><st c="36130">Setting the max display count for a specific tip and defining a display frequency for all tips is a great way to fine-tune the user’s </st><span class="No-Break"><st c="36265">tips experience.</st></span></p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor273"/><st c="36281">Summary</st></h1>
			<p><st c="36289">In this chapter, we discussed the importance of TipKit, added our first tip, customized its design and behavior, learned how to manage tips better by grouping them, and minimized their appearance by setting their display frequency. </st><st c="36522">By now, we are fully prepared to implement TipKit in </st><span class="No-Break"><st c="36575">our apps.</st></span></p>
			<p><st c="36584">TipKit touches on a severe app aspect: engagement and feature exploration. </st><st c="36660">It looks like it supports many </st><span class="No-Break"><st c="36691">product requirements!</st></span></p>
			<p><st c="36712">In the next chapter, we’ll discuss how to work seamlessly with one of our most important data sources: </st><span class="No-Break"><st c="36816">the network.</st></span></p>
		</div>
	<div id="charCountTotal" value="36828"/></body></html>