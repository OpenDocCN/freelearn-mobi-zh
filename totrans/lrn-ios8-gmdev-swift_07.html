<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Advanced SpriteKit</h1></div></div></div><p>In this chapter, we will cover some advanced features that are present in SpriteKit, such as lighting and physics, that will make the process of game development easier and will make our game looking prettier. With lighting, we can create a light source and make certain objects in the scene cast shadows and get affected by the light. Using a physics engine, we can make the game objects automatically get affected by gravity and forces applied externally.</p><p>We will also look at how to import classes, which are written in Objective-C, so that if you have already written some classes for the SpriteKit Objective-C, we can easily bring them into Swift without the need to rewrite the code again.</p><p>Using this new knowledge of importing Objective-C classes, we will look at tools such as Glyph Designer and Spine. With Glyph Designer, we can have custom fonts that take up less space and processing power than regular labels, and with Spine, we can create skeletal-based animation, which is a better optimized way of creating animations.</p><p> The topics covered in this chapter are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Lighting and shadows</li><li class="listitem" style="list-style-type: disc">Sprite Illuminator</li><li class="listitem" style="list-style-type: disc">Physics</li><li class="listitem" style="list-style-type: disc">Objective-C in Swift</li><li class="listitem" style="list-style-type: disc">Glyph Designer</li><li class="listitem" style="list-style-type: disc">Skeletal animations</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec64"/>Lighting and shadows</h1></div></div></div><p>We can create light sources in SpriteKit using a <a id="id519" class="indexterm"/>
<strong>LightNode</strong>. The LightNode can be placed in the scene like a sprite node by adding it to the scene.</p><p>To create a<a id="id520" class="indexterm"/> light source, open the <code class="literal">MainMenuScene</code> class and add the following after we added the background to the scene:</p><div><pre class="programlisting">let lightNode = SKLightNode()
lightNode.position = CGPoint(x: viewSize.width * 0.5, y: viewSize.height * 0.75)
lightNode.categoryBitMask = 1
lightNode.falloff = 0.25
lightNode.ambientColor = UIColor.whiteColor()
lightNode.lightColor = UIColor(red: 1.0, green: 1.0, blue: 0.0, alpha: 0.5)
lightNode.shadowColor = UIColor(red: 0.0, green: 0.0, blue: 0.0, alpha: 0.3)
addChild(lightNode)</pre></div><p>Similar to how <a id="id521" class="indexterm"/>we create an SKSpriteNode, we create an SKLightNode to create lights in Swift. We position it by centering it along the width and placing it at three quarters the height of the screen.</p><p>If you build and <a id="id522" class="indexterm"/>run the game now, you will see that there is no change to the scene. This is because we have to tell the scene specifically which objects should be affected by the light source. This is done by assigning a category bitmask to the light source so that we can later go to the object and tell it to be affected by the light of a certain bitmask. Here, we assign the bitmask as <code class="literal">1</code>. Since the bitmask takes a UINT32, there can be 32 light sources in total in a scene at a time, as there are 32 bits or 4 bytes in an integer.</p><p>By setting the bitmask category of the LightNode to <code class="literal">1</code>, we are saying the first bit is switched ON for this light source. So, while assigning categories, you won't use general integer numbers to define a category. So, the category of a light should be 1, 2, 4, 8, 16, and so on. Here, <code class="literal">1</code> means that the first bit is ON, <code class="literal">2</code> means that the second bit is ON, and <code class="literal">4</code> means that the third bit is ON, and so on. Do not use general numbers such as 1, 2, 3, 4, and 5 and so on for defining categories, as it would lead to unexpected results.</p><p>While creating light sources, we also need to provide other information regarding the light source, such as falloff. Like all light sources, it has maximum intensity at the source, and the more you move away from the source, the weaker and weaker the intensity becomes. Falloff determines how quickly the light source loses its intensity. A value of <code class="literal">1</code> means that it will never lose its value of intensity and <code class="literal">0</code> means that it will lose it immediately.</p><p>Along with bitmask and falloff, we also need to provide the color of the light source, the ambient light, and the color of the shadows<a id="id523" class="indexterm"/>. For the light and shadow color, we give white and black. Note that in the shadow color, we reduced the value of the opacity as otherwise the shadows will be completely black. For the ambient color, we reduced the blue variable to zero, as there is enough blue from the sky in the background. Then, we add the light to the scene.</p><p>To actually make an object get affected by the light source, we have to assign the <code class="literal">lightBitMask</code> property of that object to the category bitmask of the light source we assigned earlier.</p><p>So, to make the BG get <a id="id524" class="indexterm"/>affected by the light source, add the following in the code after where we added the BG to the scene and run the game to see the result, as shown in the following image:</p><div><pre class="programlisting">BG.lightingBitMask = 1</pre></div><div><img src="img/B04014_07_01.jpg" alt="Lighting and shadows"/></div><p>Wow! Isn't that pretty? Here I <a id="id525" class="indexterm"/>changed the color of the font to blue so that the light source is easily visible. This can be done by adding the following highlighted line in <code class="literal">myLabel</code>:</p><div><pre class="programlisting">let myLabel = SKLabelNode(fontNamed:"Chalkduster")
myLabel.text = "Ms.TinyBazooka"
myLabel.fontSize = 65
myLabel.position = CGPoint(x: viewSize.width/2, y: viewSize.height * 0.8)
<strong>myLabel.fontColor = UIColor.blueColor()</strong>
self.addChild(myLabel)</pre></div><p>Now to cast<a id="id526" class="indexterm"/> shadows, all we have to do is call <code class="literal">shadowCastBitMask</code> on <a id="id527" class="indexterm"/>the object that you want to cast shadows. Assign the category bitmask of the light source to it so that shadows can be cast.</p><p>We will ask the play button sprite image to cast a shadow, so after adding the play button to the scene, add the following code:</p><div><pre class="programlisting">self.addChild(playBtn) 
playBtn.name = "playBtn"
        
<strong>playBtn.shadowCastBitMask = 1</strong>
</pre></div><p>Now, the play button will cast a shadow depending upon where the light source is.</p><p>There are a few things to keep in mind while creating light sources and shadows in a scene. Only sprites can cast shadows in a SpriteKit scene. I tried applying it to the label and it wasn't able to create shadows from the text.</p><p>If you are making an object get affected by the light, make sure that it is never deleted and then added back into the scene. If the object is removed, the light source has to recalculate the lighting in the scene, and this process is done again once the object is added back into the scene. This will cause a flicker while recalculating the light and shadows in the scene.</p><div><div><h3 class="title"><a id="note12"/>Note</h3><p>It's is better to add shadows to objects that you know won't get deleted in the future.</p><p>Also, in <code class="literal">GameViewController</code>, change <code class="literal">ignoreSiblingOrder</code> to <code class="literal">false</code>:</p><div><pre class="programlisting"><strong>skView.ignoresSiblingOrder = false</strong>
</pre></div></div></div><p>With that said, let us run the scene to see the shadow in action, as shown in the following image:</p><div><img src="img/B04014_07_02.jpg" alt="Lighting and shadows"/></div><p>This is awesome. But <a id="id528" class="indexterm"/>wouldn't it be great if we could add some moving clouds that cast <a id="id529" class="indexterm"/>shadows in the scene? Also, since the cloud is moving, we can use the parallax sprite class to make the BG scroll like we did in the previous chapter. We can also add a sprite for the sun and make it spin.</p><p>To do this for this chapter, we will create a separate sprite for the sky and change the BG sprite to not include clouds, as we will be adding a new cloud sprite and moving it using the moving sprite class and making it loop around the scene. So, go to the resources folder of this chapter, go into the lighting directory, and get the sky, sun, cloud, and the new BG images. Create image assets called sky, sun, and cloud. Replace the old BG sprite with the new ones.</p><p>In the <code class="literal">MainMenuScene</code> class, add the sky sprite first as follows:</p><div><pre class="programlisting">let sky = SKSpriteNode(imageNamed: "sky", normalMapped: true)
sky.position = CGPoint(x: viewSize.width/2, y: viewSize.height/2)
self.addChild(sky)</pre></div><p>Then, add the sun sprite to the scene as follows:</p><div><pre class="programlisting">let sun = SKSpriteNode(imageNamed: "sun")
sun.position = CGPoint(x: viewSize.width * 0.5,y: viewSize.height * 0.75)
addChild(sun)
sun.lightingBitMask = 1
        
sun.runAction(SKAction.repeatActionForever(SKAction.rotateByAngle(1, duration: 1)))</pre></div><p>After adding the sun to the scene, make it get affected by the light. Then, we create a new <code class="literal">repeatActionForever</code> variable on it so that it will rotate the sun sprite by one degree every second forever.</p><p>Next, at the top of the <code class="literal">MainMenuScene</code> class, add the following global variables:</p><div><pre class="programlisting">var scrollingBg:ParallaxSprite!
var cloud:MovingSprite!
var cloudNode:SKSpriteNode!</pre></div><p>As we want to call the <a id="id530" class="indexterm"/>update methods on the <code class="literal">scrollingBg</code>, <code class="literal">cloudNode</code>, and cloud <a id="id531" class="indexterm"/>objects in the <code class="literal">update</code> function, we want them to be global variables.</p><p>Now, initiate the classes and variables in the <code class="literal">didMoveToView</code> method.</p><p>First create <code class="literal">cloudNode</code> as follows:</p><div><pre class="programlisting">cloudNode = SKSpriteNode(imageNamed:"cloud");
cloudNode.position = CGPoint(x: viewSize.width/2, y: viewSize.height * 0.9)
addChild(cloudNode)</pre></div><p>Next, initiate the <code class="literal">shadowcaste</code> property on <code class="literal">cloudNode</code> and add it to the cloud moving sprite variable so that we can update its position later:</p><div><pre class="programlisting">cloudNode.shadowCastBitMask = 1
cloud = MovingSprite(sprite: cloudNode, speed: CGPointMake(-3.0, 0.0))</pre></div><p>We make the cloud move slowly when compared to the background since the background is moving at speed of <code class="literal">–5.0</code>. If we make both of them move at the same speed, then it will look as if the background and cloud are one image and moving together.</p><p>Below this, add the light source.</p><p>After this, initiate the <code class="literal">scrollingBg</code> class by creating two sprite images called <code class="literal">BG1</code> and <code class="literal">BG2</code>. Add them to the scene and initiate <code class="literal">lightingBitMask</code> on both the background sprites.</p><p>Next, initiate the <code class="literal">scrollingBg</code> class by passing in the background sprites, the <code class="literal">viewsize</code>, and the speed as follows:</p><div><pre class="programlisting">let BG1 = SKSpriteNode(imageNamed: "BG")
self.addChild(BG1)
        
let BG2 = SKSpriteNode(imageNamed: "BG")
self.addChild(BG2)
        
BG1.lightingBitMask = 1        
BG2.lightingBitMask = 1
       
scrollingBg = ParallaxSprite(sprite1: BG1, sprite2: BG2, viewSize: viewSize, speed: -5.0)</pre></div><p>Next, we have to update the<a id="id532" class="indexterm"/> position of <code class="literal">scrollingBg</code>, the cloud, and the cloud node <a id="id533" class="indexterm"/>objects. So, add an update function and add the following:</p><div><pre class="programlisting">override func update(currentTime: CFTimeInterval) {
   /* Called before each frame is rendered */
        
   scrollingBg.update()
   cloud.moveSprite()
        
   if((cloudNode.position.x + cloudNode.size.width/2) &lt; 0){
        
       cloudNode.position.x = viewSize.width + cloudNode.size.width/2
   }
}</pre></div><p>Here we call the <code class="literal">update</code> and <code class="literal">moveSprite</code> functions of <code class="literal">scrollingBg</code> and cloud objects. We also update the position of the <code class="literal">cloudNode</code> sprite by settings its <code class="literal">X</code> position to the right of the screen once the image has gone beyond the left, as shown in the following image:</p><div><img src="img/B04014_07_03.jpg" alt="Lighting and shadows"/></div><p>We have to be careful with the<a id="id534" class="indexterm"/> order in which the objects were added to the scene to make<a id="id535" class="indexterm"/> sure the shadows are cast properly. The order is as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">sky</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">sun</code></li><li class="listitem" style="list-style-type: disc">Cloud (<code class="literal">cloudNode</code>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">lightNode</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">scrollingBg</code> (<code class="literal">BG1</code> and <code class="literal">BG2</code>)</li></ul></div><p>This is important since the shadow is cast in the same depth as the light source and not at the depth of the object.</p><div><div><h3 class="title"><a id="tip10"/>Tip</h3><p>In the preceding image, though we ask the light to cast on the play button, we don't see a shadow as we saw in the earlier screenshot since the background layer is above that. If you bring <code class="literal">lightNode</code> to the top-most layer, you will see the play button cast a shadow, but then even though the clouds are behind the background layer, their shadows will be seen over the trees in the background layer, which is odd. So, it is important at which layer you add the light source.</p><p>One more thing you have to be careful about is the size of the image that you want the light to get affected by. You will see that that I didn't enable the <code class="literal">lightBitMask</code> property on the sky image, as it brought down the FPS of the game to 45 and everything was running slowly on my iPadMini Retina. So I disabled lighting on the sky layer and just kept it on the run and background sprites. But this was still causing stutter and slowdown on iPad3, so I had to completely disable lighting on all the images to have a consistent 60 FPS.</p><p>Adding lighting and shadows is very hardware and processor intensive, so make sure you do enough testing on all the devices while implementing them in your game so that, irrespective of which device the game is running on, it runs at a smooth FPS.</p></div></div><p>This is all for<a id="id536" class="indexterm"/> lighting; we will move to the <code class="literal">GameplayScene</code> class to look at<a id="id537" class="indexterm"/> physics and see how to implement it. We will return to <code class="literal">MainMenuScene</code> when we look at Glyph Designer and Spine later in this chapter.</p><p>In the next section, we will see how to add physics by replacing the small physics engine we created earlier, which was used to create gravity to pull the player down or bump the player up.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec65"/>Sprite Illuminator</h1></div></div></div><p>Although SpriteKit adds a <a id="id538" class="indexterm"/>normal map on its own, you can also specify your own normal maps for better results. To download Sprite Illuminator, go <a id="id539" class="indexterm"/>to <a class="ulink" href="https://www.codeandweb.com/spriteilluminator">https://www.codeandweb.com/spriteilluminator</a> and download the DMG file.</p><p>Once Sprite Illuminator has been downloaded, double-click on the DMG file and copy the application to the <strong>Applications</strong> folder. Go to the Launchpad and start the application. Once the application launches, you should see the window as in the following screenshot:</p><div><img src="img/B04014_07_04.jpg" alt="Sprite Illuminator"/></div><p>Let us look at the interface in detail.</p><p>On the left, we have the <strong>Sprites</strong> panel. The middle panel is the <strong>Preview</strong> panel, in which you can see a preview of all the changes as you make them. The panel on the right is called the <strong>Tools</strong> panel. We will drill down further into each of these panels.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec65"/>The Sprites panel</h2></div></div></div><p>In the <strong>Sprites</strong> panel, you can <a id="id540" class="indexterm"/>modify the sprite, global light, and display mode as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Sprite</strong>: Here<a id="id541" class="indexterm"/> we can add or remove the sprites for which we want the normal map to be created.</li><li class="listitem" style="list-style-type: disc"><strong>Global light</strong>: We can change<a id="id542" class="indexterm"/> the property of the global light source by affecting its <code class="literal">Z</code> position, brightness, light color, and ambient color. This is just for visualization purposes, in the game, we will have to add a light source and change its properties in SpriteKit.</li><li class="listitem" style="list-style-type: disc"><strong>Display mode</strong>: By default, the<a id="id543" class="indexterm"/> <strong>Lit texture</strong> mode is ON. This gives a preview of how the image will look with lighting and normal map enabled. Texture mode will just show the texture without lighting and normal map. Lit surface will show the image with the light source but without the normal map. The <strong>Normal map</strong> mode will show only the normal map that you have created for an image.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec66"/>The Preview panel</h2></div></div></div><p>The <strong>Preview</strong> panel <a id="id544" class="indexterm"/>will show the<a id="id545" class="indexterm"/> preview of the image depending upon the mode you select in the <strong>Display mode</strong> section.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec67"/>The Tools panel</h2></div></div></div><p>We will be <a id="id546" class="indexterm"/>spending most of the time in <a id="id547" class="indexterm"/>the tools panel. This is where we will be creating the height map for any image. The <strong>Tools</strong> panel includes <strong>Effects</strong> and <strong>Brushes and Tools</strong>:</p><p>Under <a id="id548" class="indexterm"/>
<strong>Effects</strong>, using the <strong>Bevel</strong> and <strong>Emboss</strong> tool<a id="id549" class="indexterm"/> we can add height or depth to the map. This works exactly how the same tools work in Photoshop.</p><p>Under <strong>Brushes,</strong> five brushes are included. The brushes included are <strong>Height</strong>, <strong>Angle</strong>, <strong>Structure</strong>, <strong>Smoothen</strong>, and <strong>Erase</strong>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Height</strong>: This can be <a id="id550" class="indexterm"/>added to an area that you wish to make appear to be protruding from the image. You can specify the values for <strong>Brush Size</strong>, <strong>Height</strong>, <strong>Hardness</strong>, <strong>Contour</strong>, and <strong>Direction</strong> for it.</li><li class="listitem" style="list-style-type: disc"><strong>Angle</strong>: This can be <a id="id551" class="indexterm"/>added to an area which might be at a particular angle to the direction of the light. This is most useful while developing isometric tile maps. Apart from specifying the values for <strong>Brush Size</strong>, <strong>Opacity</strong>, and <strong>Hardness</strong>, we can specify the direction of the surface by selecting the area around the sphere.</li><li class="listitem" style="list-style-type: disc"><strong>Structure</strong>: This <a id="id552" class="indexterm"/>brush is used to add some rough texture to an area. You can modify the brush size, density, height, and direction.</li><li class="listitem" style="list-style-type: disc"><strong>Smoothness</strong>: This<a id="id553" class="indexterm"/> brush is used to smoothen an area. The brush size and smoothness can be controlled by the slider.</li><li class="listitem" style="list-style-type: disc"><strong>Erase</strong>: If we wish to<a id="id554" class="indexterm"/> erase an effect or brush we can do so by using the erase brush</li></ul></div><p>There are a couple of <strong>selection tools</strong><a id="id555" class="indexterm"/> that are provided that can make the selection process a little simpler. So, if you want to apply a brush or an effect in a particular area, you can isolate that area using the selection tool and apply the effect in just that area:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Wand/Color</strong>: This<a id="id556" class="indexterm"/> tool is like the wand tool in Photoshop. You can also adjust the tolerance level.</li><li class="listitem" style="list-style-type: disc"><strong>Polygon</strong>: You can <a id="id557" class="indexterm"/>create a closed polygon loop around the area of an image with this tool.</li><li class="listitem" style="list-style-type: disc"><strong>Move</strong>: You <a id="id558" class="indexterm"/>can move the image with this tool.</li></ul></div><p>Once you are happy with your<a id="id559" class="indexterm"/> creation, you can click on the <strong>Publish</strong> button and a normal map will be created for your image. The normal map will be a PNG file with the same file name as your original file suffixed with <code class="literal">_n</code>.</p><p>Using Sprite Illuminator, I have created a normal map for the hero sprite (shown in the following screenshot). The file and resources are included in the <code class="literal">Resources</code> folder of this chapter.</p><div><img src="img/B04014_07_05.jpg" alt="The Tools panel"/></div><p>In the <code class="literal">Sprite Illuminator</code> folder in the <code class="literal">Resources</code> directory, I have created the two versions of the<a id="id560" class="indexterm"/> regular image and normal map for both the sizes. I have also renamed the files to avoid any name conflicts. Drag these four files into the project.</p><p>To use these assets in the <code class="literal">GamePlayScene.swift</code> file, comment out the old code for adding and animating the hero sprite, and add the following highlighted code instead.</p><p>Here, instead of loading the hero file in the image set, we are assigning the <code class="literal">heroSI</code> and <code class="literal">heroSI_n</code> texture to the hero variable.</p><p>Also, we set the <code class="literal">lightBitmask</code> property of the hero to <code class="literal">1</code> so that the light source affects it.</p><div><pre class="programlisting">//hero = SKSpriteNode(imageNamed: "hero");
//hero.position = CGPoint(x: viewSize.width/4, y: viewSize.height/2)
//self.addChild(hero)
        
    
<strong>hero = SKSpriteNode(texture: SKTexture(imageNamed: "heroSI"), normalMap: SKTexture(imageNamed: "heroSI_n"));</strong>
<strong>hero.position = CGPoint(x: viewSize.width/4, y: viewSize.height/2)</strong>
<strong>self.addChild(hero)</strong>
<strong>        </strong>
<strong>hero.lightingBitMask = 1</strong>
        
/*
let heroAtlas = heroAnim()
let heroIdleAnimArray = heroAtlas.hero_Idle_()
let animaiton = SKAction.animateWithTextures(heroIdleAnimArray, timePerFrame: 0.2)
let animate = SKAction.repeatActionForever(animaiton)
hero.runAction(animate)
*/ </pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec66"/>Physics</h1></div></div></div><p>In other frameworks, you <a id="id561" class="indexterm"/>will most probably have to import a physics engine library of your choice, such as Box2d, or chipmunk would configure it to make it work properly. You would also have to write custom code for making collision detection work. In SpriteKit, every scene has physics running in the background as soon as the scene is created. You are not required to do anything else to make it work. So, in the gameplay scene, we will disable the physics engine we created and replace it with SpriteKit's inbuilt physics engine.</p><p>Open up the <code class="literal">gameplayScene.swift</code> file and comment out the <code class="literal">updateHero</code> function in the <code class="literal">update</code> function. As you might remember, the <code class="literal">updateHero</code> function took care of making the hero get affected by gravity, making sure the hero was inside the screen at all times and also making sure thrust is applied when the player taps the left half of the screen. Using the inbuilt physics engine, we will see how we can make it do all the work for us.</p><p>As I said earlier, the physics is already active, meaning that there is already some gravity that is acting on the scene. So, let us make the hero get affected by gravity.</p><p>In the <code class="literal">init</code> function, right after we added the hero sprite to the scene, add the following line:</p><div><pre class="programlisting">hero.physicsBody = SKPhysicsBody(rectangleOfSize: hero.size)</pre></div><p>This is all we have to do to tell the hero to get affected by physics. The <code class="literal">physicsBody</code> property of any sprite will assign a body to the sprite, making it behave like a solid object, meaning that now this sprite will have physics properties like any object in real life. It will have a density, respond to friction, be bouncy, and get affected by other bodies. Now we can apply force to it or make it move with a certain velocity. If some moving body hits this body, as Newton said, it would react to that hit and move.</p><p>When we assign a body, we <a id="id562" class="indexterm"/>have the option of giving shape to the body. Here we are giving a rectangle with the same dimensions as the sprite. If we wish, we could have given the body the shape of a circle or we could also use a custom shape.</p><p>If we build and run the game now, we will see that the hero will just fall through the bottom of the screen. This is because nothing is preventing the hero from going through. To counter this downward motion, we have to create a body around the scene to prevent the hero from falling down.</p><p>In the <code class="literal">init</code> function, add the following code:</p><div><pre class="programlisting">self.physicsBody = SKPhysicsBody(
                           edgeLoopFromRect: CGRect(x: 0,
                                                    y: 0,
                                         width: viewSize.width,
                                         height: viewSize.height))</pre></div><p>Previously, we attached a physics body to the hero, and now we are initiating the physics body property of the scene itself. The difference here is that it is an <code class="literal">edgeLoop</code> body type. An edge loop is different from a regular body type in that the former doesn't have volume. So, it doesn't have mass, density, friction, and so on, and you can't apply force or make it move with a velocity. But other bodies will get affected by it, meaning that if a regular body is moving and gets obstructed by an <code class="literal">edgeLoop</code>, then the regular body will stop moving.</p><div><img src="img/B04014_07_06.jpg" alt="Physics"/></div><p>While creating an edge loop, we <a id="id563" class="indexterm"/>have to pass in the shape of the loop, so here we are giving the shape of a rectangle starting from the origin that is the bottom left of the screen, which is (0, 0), and the size of the view by passing in the width and height of the screen.</p><p>Now, if you build and run, you will see that the hero stops. In fact, the hero not only stops but also bounces a bit once she hits the bottom of the screen. You can set the mass, density, friction, and restitution values depending upon how heavy or bouncy you need your character to be by changing the values, as shown in the following. The values range from <code class="literal">0</code> to <code class="literal">1</code> in all cases: <code class="literal">0</code> being less bouncy, dense, affected by friction, and so on, and <code class="literal">1</code> being the opposite end of the spectrum.</p><div><pre class="programlisting">hero.physicsBody?.restitution = 0
hero.physicsBody?.friction = 0
hero.physicsBody?.density = 0
hero.physicsBody?.mass = 0  </pre></div><p>You can also change the value of the gravity in the scene so if you wanted to make a level set on the moon, you can change the default gravity to 1/6th of its original value to give that effect.</p><p>One important thing to note about the physics engine is that it is not in pixels but in real-world values. For example, the default value of gravity is actually 9.8 meters/(second * second). All the values, which are actually pixels, are converted to meters, and SpriteKit does the conversion from pixels to meters internally.</p><div><img src="img/B04014_07_07.jpg" alt="Physics"/></div><div><div><h3 class="title"><a id="note13"/>Note</h3><p>To have moon like gravity, access the gravity property of the physics world property of the scene and change gravity to 1/6th of 9.8 as follows:</p><p>
<em>self.physicsWorld.gravity = CGVector(dx: 0, dy: -1.64)</em>
</p><p>The <code class="literal">gravity</code> property expects a <code class="literal">CGVector</code> value since we want the gravity to exert a downward force, the value of <code class="literal">x</code> is zero and <code class="literal">y</code> is kept at <code class="literal">–1.64</code> from the default value of <code class="literal">–9.8</code> as this is what gravity would be on the moon. You can change it back to <code class="literal">–9.8</code> for a more Earthy feeling.</p></div></div><p>We can now add a <a id="id564" class="indexterm"/>force on the hero such that we can thrust her up in the air. So, in the <code class="literal">touchesBegan</code> function, we can remove the code that we previously added to push the hero up in the air and apply a physics force in the upward direction. But before we add the force, we have to set the velocity of the hero zero since the hero would have to overcome the downward velocity to move upward. If the velocity in the negative <em>y</em> direction is too big, then, irrespective of how much force you apply upward, it will all be nullified by the downward gravitational force acting on the hero. First make the downward velocity of the hero zero and then apply the force upward. Take the following thrust code:</p><div><pre class="programlisting">//thrust.y = 15.0</pre></div><p>Replace this with the following code:</p><div><pre class="programlisting">hero.physicsBody?.velocity = CGVectorMake(0, 0)
hero.physicsBody?.applyImpulse(CGVectorMake(0, 300))</pre></div><p>Here we set the hero's velocity to <code class="literal">0</code>. Since there is no velocity acting in the <em>x</em> direction, it doesn't matter if we set just the <code class="literal">Y</code> value to <code class="literal">0</code> or both the <code class="literal">X</code> and <code class="literal">Y</code> values to <code class="literal">0</code>.</p><p>Next, we apply an <strong>impulse</strong><a id="id565" class="indexterm"/> in the <em>y</em> direction with an <code class="literal">X</code> value of <code class="literal">0</code> and <code class="literal">Y</code> value equal to <code class="literal">300</code>. But wait!</p><div><div><h3 class="title"><a id="note14"/>Note</h3><p>
<strong>What is this impulse thing?</strong>
</p><p>All this time we were talking about applying force and now we are actually applying an impulse. In the physics engine, there is a separate property called force and how it works is that once you apply a force to a body, the force will be constantly applied to the body. We just want the force to be applied once after we tap the left half of the screen. So, we apply an impulse and not force. If we wanted the player to keep moving up once we tap the screen, we should use the force property instead of impulse. So, be sure how you want your object to behave and apply either a force or an impulse on your physics object accordingly.</p></div></div><p>And that is all. Now you have the player behaving exactly as we did with our own homegrown physics engine previously. Run the game and test it.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec67"/>Objective-C in Swift</h1></div></div></div><p>Let us now look at how to<a id="id566" class="indexterm"/> import Objective-C classes into Swift and use them. We will then use this to use tools such as Glyph Designer and Spine, which have implementations in Objective-C but don't have specific classes in Swift.</p><p>For making Objective-C classes work with Swift, you will need to create a bridging header file. The file is usually named with the convention <code class="literal">&lt;ProjectName&gt;-Bridging-Header.h</code>, and then you will need to add the file location into <strong>Objective-C Bridging Header</strong> under <strong>Swift Compiler – Code Generation</strong> in the project <code class="literal">Build Settings</code>.</p><div><div><h3 class="title"><a id="note15"/>Note</h3><p>If you are using the code provided along with this book, you might need to modify the path to avoid compilation errors.</p></div></div><p>Usually, if you create a new header file in a swift project, you will be greeted with the following window asking to treat the current file created as the bridging header file, and Xcode will automatically add the location of the file in <strong>Build Settings</strong>. In case it doesn't pop up, we will have to walk through the steps to make sure Xcode knows where to look for the bridging header file manually.</p><div><img src="img/B04014_07_08.jpg" alt="Objective-C in Swift"/></div><p>For creating the <a id="id567" class="indexterm"/>bridging header file for the current project, go to <strong>File</strong> | <strong>New</strong> | <strong>File</strong> and then select <strong>Source</strong> under <strong>iOS</strong> and select the header file with an "H" on it. Name the file <strong>skGame-Bridging-Header</strong> and click on <strong>Create</strong>.</p><p>Now, go to <strong>Build Settings</strong> and in the search type <code class="literal">bridging</code>, as shown in the following screenshot. Double-click to the right of <strong>Objective–C Bridging Header</strong> and drag-and-drop the bridging header file that we just created from the project onto the box. Hit <em>Enter</em>. Now, the project knows the location of the bridging header file. We can use this file to call the header files of Objective-C classes so that they can be shared with Swift.</p><div><img src="img/B04014_07_09.jpg" alt="Objective-C in Swift"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec68"/>Glyph Designer</h1></div></div></div><p>Glyph Designer <a id="id568" class="indexterm"/>is an application that can be used to make fonts that can be used in the game. But don't we already have an SKLabel for that? That is true. But SKLabel takes the font from the system, and converts the font files into an image at run time and then displays it onto the screen. So, whenever the score needs to be incremented, the system will need to convert the font into an image and then display that on the screen. This is very similar to the problem we faced with sprites earlier and used Texture Packer to get around it.</p><p>Although you can use system fonts for bigger games, it is better to use a Bitmap font, a font in which the letters and numbers are already converted to images rather than converting them every time. So, with Glyph Designer, we can create a Bitmap font and use it to better optimize the game.</p><p>Bitmap fonts are similar to <a id="id569" class="indexterm"/>a spritesheet and will have an image with all the letters, numbers, and symbols in it, and this image file will be accompanied with a data file that has the locations and size of the symbols and letters. Whenever a letter needs to be displayed on the screen, the data file will be checked for the location of the letter, which will be retrieved and then displayed on screen.</p><p>The trial version <a id="id570" class="indexterm"/>of the application can be downloaded from <a class="ulink" href="https://71squared.com/glyphdesigner">https://71squared.com/glyphdesigner</a>.</p><div><img src="img/B04014_07_10.jpg" alt="Glyph Designer"/></div><p>After downloading the application, you can open it and it will create a new untitled project. On the left panel, you will see a list of all the fonts that are present in the system. The center view shows the spritesheet of the file that will be created. This is a preview window and will dynamically change according to the changes you make.</p><p>The right panel is <a id="id571" class="indexterm"/>where you will be making most of the changes after selecting the font that you want to modify on the left. On the right panel, you will find the following headings (as shown in the following screenshot):</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Glyph Info</strong></li><li class="listitem" style="list-style-type: disc"><strong>Texture Atlas</strong></li><li class="listitem" style="list-style-type: disc"><strong>Glyph Fill</strong></li><li class="listitem" style="list-style-type: disc"><strong>Glyph Stroke</strong></li><li class="listitem" style="list-style-type: disc"><strong>Glyph Shadow</strong></li><li class="listitem" style="list-style-type: disc"><strong>Included Glyphs</strong></li></ul></div><div><img src="img/B04014_07_11.jpg" alt="Glyph Designer"/></div><p>You should be mostly<a id="id572" class="indexterm"/> concerned with <strong>Glyph Fill</strong>, <strong>Stroke</strong>, and <strong>Shadow</strong>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Glyph Fill</strong>: We can select the type of fill, that is <strong>Solid</strong>, <strong>Gradient</strong>, or <strong>Image</strong>. So, basically we can select the color of the font here.</li><li class="listitem" style="list-style-type: disc"><strong>Glyph Stroke</strong>: This will create a new stroke effect around the letter. You can select the color and the size of the stroke here.</li><li class="listitem" style="list-style-type: disc"><strong>Glyph Shadow</strong>: Here we can select the color and direction of the shadows. There are two types of shadows: inner and outer. This effect will give the letters a bit of depth.</li></ul></div><p>Once you are satisfied with the changes, click on the <strong>Export</strong> button and select the format. You can select the <code class="literal">skf @2</code> version or the normal <code class="literal">skf</code> version for generating the files for <strong>2x</strong> and <strong>1x</strong> resolutions.</p><div><img src="img/B04014_07_12.jpg" alt="Glyph Designer"/></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec68"/>Implementing a Bitmap font</h2></div></div></div><p>Make sure you select <code class="literal">.skf</code> in the export type. This will create a folder with <code class="literal">.atlas</code> at the end with all the <a id="id573" class="indexterm"/>characters and symbols in it and a <code class="literal">.skf</code> file that<a id="id574" class="indexterm"/> is the data file associated with the font.</p><p>Drag both the <code class="literal">.atlas</code> folder and the <code class="literal">.skf</code> file into the project.</p><p>Now we are ready to implement the Bitmap font in the game:</p><div><ol class="orderedlist arabic"><li class="listitem">For making Glyph Designer work with SpriteKit, we will need the universal static library created by <a id="id575" class="indexterm"/>71Squared. Go to <a class="ulink" href="https://71squared.zendesk.com/hc/en-us/articles/200037472-Using-Glyph-Designer-1-8-with-Sprite-Kit">https://71squared.zendesk.com/hc/en-us/articles/200037472-Using-Glyph-Designer-1-8-with-Sprite-Kit</a> and download the <code class="literal">libSSBitmapFont.zip</code> file from the bottom of the page.</li><li class="listitem">After the file is downloaded, extract it and drag the <code class="literal">SSBitmapFont.h</code> and <code class="literal">SSBitmapFontLableNode.h</code> files into the project. Don't drag the folder containing the files, but just the individuals files themselves. Also, drag the <code class="literal">libSSBitmapFont.a</code> file into the project.</li><li class="listitem">Go to the bridged header file we created earlier and import the two header <code class="literal">SSBitmapFont.h</code> and <code class="literal">SSBitmapFontLabelNode.h</code> files in the bridged header file as follows:<div><pre class="programlisting">#ifndef skGame_skGame_Bridging_Header_h
#define skGame_skGame_Bridging_Header_h

#endif

<strong>#import "SSBitmapFont.h"</strong>
<strong>#import "SSBitmapFontlabelNode.h"</strong>
</pre></div><p>Now we can access the files anywhere in our Swift project.</p></li><li class="listitem">To make sure everything works correctly, just build the project to make sure that there aren't any errors popping up.</li><li class="listitem">In the <code class="literal">MainMenuScene</code> class, we will use the Bitmap font to display the name of the game instead of <code class="literal">SKLabelNode</code>. Open the <code class="literal">MainMenuScene</code> class. At the top of the class, add the following code. This is similar to what we did to get the <code class="literal">bgMusic.mp3</code> file in the <code class="literal">GameViewController</code> class. But here we will get the SKF file from the main bundle location of the project.<div><pre class="programlisting">var bmFontFile = SSBitmapFont(file: NSBundle.mainBundle().URLForResource("skGame_font", withExtension: "skf"), error: nil)</pre></div></li><li class="listitem">Here we create a new variable called <code class="literal">bmFontFile</code>, and using the <code class="literal">SSBitmapFont</code> class we imported from Objective-C, we get the name of the <code class="literal">skGame_font</code> font file from the project location. Along with the name, we also need to provide the extension of the <code class="literal">skf</code> file.</li><li class="listitem">Since we <a id="id576" class="indexterm"/>have the <code class="literal">bmFont</code> file saved, we can<a id="id577" class="indexterm"/> use this file to create new text or a label by passing in the text and assigning the position, and adding it to the scene. So, we replace the code of <code class="literal">SKLabelNode</code> that we had added previously with the following code to see the Bitmap font in action:<div><pre class="programlisting">let bmFontText = bmFontFile.nodeFromString("Ms.TinyBazooka")
bmFontText.position  = CGPoint(x: viewSize.width/2,
   y: viewSize.height * 0.8)
addChild(bmFontText)</pre></div></li><li class="listitem">We create a new constant called <code class="literal">bmFontText</code> and use the <code class="literal">nodeFromString</code> property of <code class="literal">bmFontFile</code> to assign the <code class="literal">Ms.TinyBazooka</code> text to it. We set the position as usual and add the <code class="literal">bmFontText</code> to the scene:<div><img src="img/B04014_07_13.jpg" alt="Implementing a Bitmap font"/></div></li></ol></div><p>You can<a id="id578" class="indexterm"/> immediately see that the Bitmap font is a lot sharper<a id="id579" class="indexterm"/> than the text created with <code class="literal">SKLableNode</code>. So, it is no surprise that these days, games made by both professional companies both independent developers use Bitmap fonts instead.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec69"/>Skeletal animation</h1></div></div></div><p>In an earlier chapter, we saw how to<a id="id580" class="indexterm"/> make animations in the game using frame-based animation, in which we imported a series of images and created an animation by cycling through the frames. Although frame-based animations are good, they can be tedious to make. The artist has to draw each frame and you can't have too many frames if you want to keep the bundle size low. As a result, the animations don't look very fluid. Moreover, if you want to make some changes to the character, then it is back to the drawing board for the artist, as he has to go through all the frames of the animations and redo them.</p><p>Using the skeletal animation technique instead of making the individual frames for animation, we import individual parts of the character and make a spritesheet, as shown in the following:</p><div><img src="img/B04014_07_14.jpg" alt="Skeletal animation"/></div><p>Using an application, we <a id="id581" class="indexterm"/>position the parts of the character and then create an animation. This way we can create different animations such as walking, running, jumping, attacking, and so on, from the body parts. All the animations are exported as a data file.</p><p>When the data file and character parts are brought into the game, the data file will be referred to place parts of the character to form the posture of the character. Later, when we call an animation to play on the character, the data file will be referred to again to create the movement dynamically. Lets us see how to create skeletal animations.</p><p>For creating the animations, we will be using an application called <strong>Spine</strong><a id="id582" class="indexterm"/> by Esoteric Software. You can download the trial <a id="id583" class="indexterm"/>version from their website at <a class="ulink" href="http://esotericsoftware.com/">http://esotericsoftware.com/</a>.</p><div><img src="img/B04014_07_15.jpg" alt="Skeletal animation"/></div><p>The trial version won't <a id="id584" class="indexterm"/>allow you to save the project but I have included the project file with the resources for this chapter so that you can open it in the trial version and play around with it.</p><p>After downloading the DMG file from the site, double-click on it to install it. Once the installation is complete, click on the spine logo on the top left side of the screen to create a new project, as shown in the following screenshot.</p><p>Next we have to bring in the parts of the character so that we can pose the character properly for animation. This phase is called the character setup.</p><p>In the resources for this chapter in the spine folder, you will find a folder called <code class="literal">heroParts</code>, copy this folder onto the desktop.</p><p>When you open Spine, the default project will be loaded. For creating a new project, click on the Spine icon on the top left and then select <strong>New Project</strong>.</p><div><img src="img/B04014_07_16.jpg" alt="Skeletal animation"/></div><p>On the <strong>Tree</strong> panel on the <a id="id585" class="indexterm"/>right-hand side, in the <strong>Hierarchy</strong> panel, select the <strong>Images</strong> folder, as in the preceding screenshot. At the bottom you will now be able to select the path to the <code class="literal">heroParts</code> folder. Click on <strong>Browse</strong> and point it to the other <code class="literal">heroParts</code> folder on the desktop.</p><p>All the parts will appear under the <strong>Images</strong> tab. Next, drag all the parts onto the checked view panel. You can click on the individual parts and use the rotate and translate button in the <strong>Transform</strong> panel on the bottom to place the parts of the hero. If some parts need to be in front of others, then click on the triangle next to <strong>Draw Order</strong> in the <strong>Hierarchy</strong> panel and drag an image to make it appear above or below any other object.</p><p>The small plus at the center of the view panel is the root node. Move this node to the middle of the character by locking the images by clicking on the <strong>Images</strong> button in the <strong>Compensate</strong> panel on the bottom of the screen. You can rename the root node by clicking on it. Rename it to <code class="literal">hip</code> for the sake of convenience.</p><p>Once the character is set up properly, it should look like the following image. Refer to the following screenshot for checking the <strong>Draw Order</strong>:</p><div><img src="img/B04014_07_17.jpg" alt="Skeletal animation"/></div><p>Next we will draw the bones. Bones work very similarly to human bones. You can attach one or more parts of the character to a bone, and then when you move or rotate the bone, the character part will move or rotate accordingly.</p><p>First, we will create bones<a id="id586" class="indexterm"/> for the legs. To create bones, click on the <strong>Create</strong> button with the bones icon on it on the <strong>Tools</strong> panel on the bottom of the screen. Now we will create a bone from the hip to the left foot. Left click on <strong>hip</strong> to start creating a bone. While still holding the left mouse button, move the mouse toward the left-foot image. Press the <em>Shift</em> key on the keyboard while over the left foot. Once the left foot is highlighted, release the mouse button and <em>Shift</em> key.</p><p>Now do the process again for the other foot. Start from the hip and press the <em>Shift</em> key, and when the other foot is highlighted, release the mouse and <em>Shift</em> key. It is OK if the bone is not perfectly aligned with the foot.</p><p>Again, from the hip, create a bone to the body so that it is closer to the start of the hand, but make sure the body is highlighted and not the hand. Name this bone <code class="literal">body</code> in the <strong>Hierarchy</strong> panel. Now, from the end of this newly created bone, create one bone for the hand and another for the head of the character.</p><p>You will notice that the bazooka is still attached to the hip or the root bone. In the <strong>Hierarchy</strong> panel, move the bazooka node under the hand bone. This way, the bazooka will move along with the hand bone. The following screenshot shows the bone hierarchy after completion:</p><div><img src="img/B04014_07_18.jpg" alt="Skeletal animation"/></div><p>Now you can click on the<a id="id587" class="indexterm"/> individual bones, rotate them, and when you rotate the bone, the body part also rotates along with it. Here is the character in different poses.</p><div><div><h3 class="title"><a id="note16"/>Note</h3><p>Make sure the rotate button is clicked on in the <strong>Transpose</strong> panel and the images are not locked.</p></div></div><div><img src="img/B04014_07_19.jpg" alt="Skeletal animation"/></div><p>Now, the character is <a id="id588" class="indexterm"/>setup and ready to be animated. Click on the <strong>Setup</strong> button on the <strong>View</strong> panel. You are now in <strong>Animation</strong> mode. A new panel will open up below called <strong>DopeSheet</strong>. Click on the <strong>Animations</strong> heading under the <strong>Hierarchy</strong> panel and click on <strong>NewAnimations</strong> at the bottom of the screen. A new window will open, asking for a name, enter <code class="literal">walk</code> here and Click on <strong>OK</strong>.</p><p>Apart from the new <strong>Dopesheet</strong> panel, you will see that the <strong>Transformation</strong> panel has also changed a bit. If you click on any bone, a green key symbol appears next to the <strong>Rotate</strong>, <strong>Translate</strong>, and <strong>Scale</strong> buttons, as shown in the following screenshot:</p><div><img src="img/B04014_07_20.jpg" alt="Skeletal animation"/></div><p>These keys record the changes made in the <strong>Rotation</strong>, <strong>Translation</strong>, and <strong>Scale</strong> buttons of that bone. Green signifies that no changes have been recorded. Click on the three green buttons in the <strong>Transform</strong> panel at the 0th frame. Now, the values have been recorded as the keys have changed from green to red. Now, move the time line slider in blue from the 0th frame in the dopesheet to the 5th frame. Again the keys are green. Rotate the leg back a little bit and once again click on all three keys to make them red.</p><p>If you move the timeline slider between the 0th and 5th frames, you will see the leg rotating back and forth. Click on the play button to see the animation in action. Click on the loop button to the right end of the play button to loop the animation. This is how an animation is created.</p><p>We will create a simple walk<a id="id589" class="indexterm"/> cycle animation that we will later import in the game and play the animation. Undo all the actions to go back to the original pose.</p><p>For creating the walk cycle, we record the position, rotation, and scale of all the bones in the 0th, 6th, 12th, 18th, and 24th frames. The pose on the 0th and 24th frames is the same. The pose in the 12th frame is the opposite of that in the 0th frame, as the position of the feet will be interchanged, meaning the foot that was previously at the back in the 0th frame will be at the front and vice versa. At the 6th and 18th frames, the feet will be brought back together and the character will be raised by moving the hip/root.</p><p>The following screenshot shows the poses at different frames. Starting from the left, the first pose is for the 0th and 24th frames. So, rotate the leg bones apart, and select all the bones and create a key by clicking on all three green key buttons. Keeping the same pose, move the time slider to the 24th frame and click on the key buttons again.</p><p>The middle image shows the pose for the 12th frame where the legs are switched. So, once again, rotate the legs and move the time slider to the 12th frame and click on the key buttons.</p><p>The image on the right shows the pose for the 6th and 18th frames. Here, move the legs closer and raise the character by moving the hip bone up. Move the time slider to the 6th frame and create a key frame. To create the key frame for the 18th frame, no changes are made to the pose. Just move the time slider to the 18th frame and create a new key frame. That's it; your walk cycle is ready. Click on the play button and enjoy!</p><p>Make sure all the bones were selected when clicking on the green button to record the frame.</p><div><img src="img/B04014_07_21.jpg" alt="Skeletal animation"/></div><p>Now, if you have the <a id="id590" class="indexterm"/>essential or pro version of Spine, you can export the data file by clicking on the Spine icon on the top left and then clicking on <strong>Export</strong>.</p><p>The exported data type will be of type <code class="literal">.json</code>. Select the location where you want the data file to be exported and leave the other values as default. Click on the <strong>Export</strong> button to export the JSON data file.</p><p>When you export the file, you will notice that the data file is named skeleton. Rename the file to <code class="literal">player</code> manually, as every time the file is named skeleton by default and we don't want this file to be overwritten while creating JSON files for other characters.</p><p>To create the atlas for the images for the spine animation, create a folder called <code class="literal">player.atlas</code> and copy all the character parts from the <code class="literal">heroParts</code> folder into it.</p><p>Now drag the <code class="literal">player.atlas</code> and <code class="literal">player.json</code> files into the project.</p><p>For animating the character, we require the Spine runtime. Similar to Glyph Designer, it is written in Objective-C, but as we did earlier, we will import the header file in the bridging header file and make the Objective-C classes accessible in Swift.</p><p>To get the header files, go to <a class="ulink" href="https://github.com/mredig/SGG_SKSpineImport">https://github.com/mredig/SGG_SKSpineImport</a>, and download the ZIP file and extract it. From the extracted folder, go to the <code class="literal">SpineImporter</code> folder and drag all the files in the folder to the Swift project.</p><p>In the <code class="literal">Bridging Header</code> file, add the <code class="literal">SpineImport.h</code> file as follows:</p><div><pre class="programlisting">#import "SSBitmapFont.h"
#import "SSBitmapFontlabelNode.h"
<strong>#import "SpineImport.h"</strong>
</pre></div><p>In the <code class="literal">MainMenuScene</code> class, we will add the player animation. At the top of the class, create a global variable hero and assign the <code class="literal">SGG_Spine</code> class to it as follows:</p><div><pre class="programlisting">  var hero = SGG_Spine()</pre></div><p>Now, add the following code right after where we added <code class="literal">BG1</code> and <code class="literal">BG2</code> to the scene:</p><div><pre class="programlisting">hero.skeletonFromFileNamed("player",
                            andAtlasNamed: "player",
                            andUseSkinNamed: nil)

hero.position = CGPoint(x: viewSize.width/4, y: viewSize.height * 0.25)
hero.xScale = 1.25; hero.yScale = 1.25;        
hero.runAnimation("walk", andCount: -1)
addChild(hero)</pre></div><p>We provide the name of<a id="id591" class="indexterm"/> the JSON data file and the name of the atlas in the <code class="literal">skeletonFromFile</code> property of the hero. Since we didn't use any skins in the game, the third parameter is kept <code class="literal">nill</code>.</p><p>We, then, position the hero variable and increase the scale a bit.</p><p>To tell which animation to start playing, we use the <code class="literal">runAnimation</code> property of the hero and assign the walk animation we created in spine.</p><p>Finally, we add the hero to the scene. Build and run the game to see the final result, as shown in the following screenshot:</p><p> </p><div><img src="img/B04014_07_22.jpg" alt="Skeletal animation"/></div><p>
</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec70"/>Summary</h1></div></div></div><p>In this chapter, you saw how to add lighting and shadows to our game without much effort. Since Apple included it with SpriteKit, you can be sure the code to create the effect is well optimized. In other frameworks, this effect has to be written by a developer, and the developer needs to have good experience to make an optimized lighting and shadow effect.</p><p>We also had a brief introduction to SpriteKit's physics engine and replaced our homemade physics engine with it. Here we have barely even scratched the surface of the possibilities with the physics engine. With good knowledge and experience, we can make our own Angry Birds clone.</p><p>Apart from SpriteKit's Lighting and Physics engines, we also saw how to bring Objective-C code into Swift and make use of it to implement tools such as Glyph Designer and Spine. Both Glyph Designer and Spine are professional tools that are an absolute must for game developers and designers. They really help in optimizing and simplifying the game development process by a lot.</p><p>It is time to say goodbye to Ms. TinyBazooka, for, in the next two chapters, we will be entering the world of 3D game development. But we will return to SpriteKit in <a class="link" href="ch10.html" title="Chapter 10. Publishing and Distribution">Chapter 10</a>, <em>Publishing and Distribution</em>, where we will see how to publish this game to the App Store.</p></div></body></html>