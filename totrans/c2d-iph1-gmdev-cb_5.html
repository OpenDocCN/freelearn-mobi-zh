<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Scenes and Menus"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Scenes and Menus</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Switching scenes</li><li class="listitem" style="list-style-type: disc">Transitioning between scenes</li><li class="listitem" style="list-style-type: disc">Using CCLayerMultiplex</li><li class="listitem" style="list-style-type: disc">Using CCLabel</li><li class="listitem" style="list-style-type: disc">Using CCMenu</li><li class="listitem" style="list-style-type: disc">Creating shadowed menu labels</li><li class="listitem" style="list-style-type: disc">UIKit alert dialogs</li><li class="listitem" style="list-style-type: disc">Wrapping UIKit</li><li class="listitem" style="list-style-type: disc">Creating draggable menu windows</li><li class="listitem" style="list-style-type: disc">Creating a horizontal scrollable menu</li><li class="listitem" style="list-style-type: disc">Creating a vertical sliding menu grid</li><li class="listitem" style="list-style-type: disc">Creating a loading screen with indicator</li><li class="listitem" style="list-style-type: disc">Creating a minimap</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec01"/>Introduction</h1></div></div></div><p>All games have auxillary<span class="strong"><strong> Graphical User Interface (GUI)</strong></span> requirements like<span class="strong"><strong> menus</strong></span> and in-game<span class="strong"><strong> Heads-Up Displays(HUD)</strong></span> . In this chapter, we will explain the techniques used to create these elements as well as how to incorporate them into an underlying structure of scenes.<a id="id337" class="indexterm"/>
</p></div></div>
<div class="section" title="Switching scenes"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec02"/>Switching scenes</h1></div></div></div><p>A<span class="strong"><strong> scene</strong></span> is the basic high-level<code class="literal"> CCNode</code> object. All other nodes are considered children of a scene. Only one scene can be running at a time. Scenes are managed using a<span class="strong"><strong> stack</strong></span> data structure. In this recipe, we will see how to<span class="strong"><strong> push</strong></span> and<span class="strong"><strong> pop</strong></span> scenes onto the stack.<a id="id338" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/4002_05_01.jpg" alt="Switching scenes"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec01"/>Getting ready</h2></div></div></div><p>Please refer to the project<span class="emphasis"><em> RecipeCollection02</em></span> for full working code of this recipe.
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec02"/>How to do it...</h2></div></div></div><p>Execute the following code:</p><div class="informalexample"><pre class="programlisting">// TreeSceneMenu
// The node for our binary tree of scenes
@interface TreeSceneMenu : CCLayer {
NSString *name;
}
+(id) sceneWithString:(NSString*)str;
-(id) initWithString:(NSString*)str;
-(void) goToScene1:(id)sender;
-(void) goToScene2:(id)sender;
-(void) back:(id)sender;
@end
@implementation TreeSceneMenu
+(id) sceneWithString:(NSString*)str {
//Initialize our scene
CCScene *s = [CCScene node];
TreeSceneMenu *node = [[TreeSceneMenu alloc] initWithString:str];
[s addChild:node z:0 tag:0];
return s;
}
-(id) initWithString:(NSString*)str {
if( (self=[super init] )) {
//Set scene name
name = [NSString stringWithFormat:@"%@",str];
[name retain];
/* CODE OMITTED */
//Buttons to push new scenes onto the stack
CCMenuItemFont *scene1Item = [CCMenuItemFont itemFromString:[NSString stringWithFormat:@"Scene %@.1",name] target:self selector:@selector(goToScene1:)];
CCMenuItemFont *scene2Item = [CCMenuItemFont itemFromString:[NSString stringWithFormat:@"Scene %@.2",name] target:self selector:@selector(goToScene2:)];
//If we are at the root we "Quit" instead of going "Back"
NSString *backStr = @"Back";
if([str isEqualToString:@"1"]){
backStr = @"Quit";
}
CCMenuItemFont *backItem = [CCMenuItemFont itemFromString:backStr target:self selector:@selector(back:)];
//Add menu items
CCMenu *menu = [CCMenu menuWithItems: scene1Item, scene2Item, backItem, nil];
[menu alignItemsVertically];
[self addChild:menu];
}
return self;
}
//Push scene 1
-(void) goToScene1:(id)sender {
[[CCDirector sharedDirector] pushScene:[TreeSceneMenu sceneWithString:[NSString stringWithFormat:@"%@.1",name]]];
}
//Push scene 2
-(void) goToScene2:(id)sender {
[[CCDirector sharedDirector] pushScene:[TreeSceneMenu sceneWithString:[NSString stringWithFormat:@"%@.2",name]]];
}
//Pop scene
-(void) back:(id)sender {
[[CCDirector sharedDirector] popScene];
}
@end
//Our Base Recipe
@interface Ch5_SwitchingScenes : Recipe{}
-(CCLayer*) runRecipe;
-(void) goToScene1:(id)sender;
@end
@implementation Ch5_SwitchingScenes
-(CCLayer*) runRecipe {
[super runRecipe];
//Go to our initial scene
CCMenuItemFont *goToScene1 = [CCMenuItemFont itemFromString:@"Go To Scene 1" target:self selector:@selector(goToScene1:)];
CCMenu *menu = [CCMenu menuWithItems: goToScene1, nil];
[menu alignItemsVertically];
[self addChild:menu];
return self;
}
scenesswitching//Push initial scene
-(void) goToScene1:(id)sender {
[[CCDirector sharedDirector] pushScene:[TreeSceneMenu sceneWithString:@"1"]];
}
@end
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec03"/>How it works...</h2></div></div></div><p>The common convention in Cocos2d is to sub-class<code class="literal"> CCLayer</code> when creating a simple scene. This allows us to couple our single<code class="literal"> CCScene</code> to a<code class="literal"> CCLayer</code> using only one class. That class inherits<code class="literal"> CCLayer</code>, but it has a class method that returns itself packaged inside a<code class="literal"> CCScene:</code>
</p><div class="informalexample"><pre class="programlisting">+(id) sceneWithString:(NSString*)str {
//Initialize our scene
CCScene *s = [CCScene node];
TreeSceneMenu *node = [[TreeSceneMenu alloc] initWithString:str];
[s addChild:node z:0 tag:0];
return s;
}
</pre></div><p>In this example, our class is named<code class="literal"> TreeSceneMenu</code>. By pressing one of its two buttons, you push another scene onto the stack with an appropriate sub-string name. This creates a binary tree of possible scene combinations. Popping the root scene will kick you back to the main recipe chooser scene.
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Layers versus scenes:<p>The layer/scene distinction is mostly a formal one. Scenes separate out the most basic parts of a game and are treated as such. For example, there are a number of transitions that can be used when going between scenes (see the next recipe). Layers, on the other hand, are designed to be the only nodes directly added to scenes. Layers are where all the action happens. Other nodes are attached to them and they implement the <code class="literal">TouchEventsDelegate</code> protocol to handle input. The only difference between scenes and layers is that scenes require a little more memory and processor overhead when pushed onto the stack. So, the fewer scenes on the stack at any one time, the better.
<a id="id340" class="indexterm"/>
</p></li></ul></div></div></div>
<div class="section" title="Transitioning between scenes"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec03"/>Transitioning between scenes</h1></div></div></div><p>As mentioned in the previous recipe, scenes are the root CCNodes and only one can be running at a time. When switching between scenes, we can apply transitions to make the scene change more explicit and stylish. In this recipe, you can demo all of the built-in scene transitions.<a id="id341" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/4002_05_02.jpg" alt="Transitioning between scenes"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec04"/>Getting ready</h2></div></div></div><p>Please refer to the project<span class="emphasis"><em> RecipeCollection02</em></span> for full working code of this recipe.
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec05"/>How to do it...</h2></div></div></div><p>Execute the following code:</p><div class="informalexample"><pre class="programlisting">@implementation TransSceneMenu
+(id) sceneWithString:(NSString*)str withCurrentTransition:(int)ct {
//Create scene
CCScene *s = [CCScene node];
TransSceneMenu *node = [[TransSceneMenu alloc] initWithString:str withCurrentTransition:ct];
[s addChild:node z:0 tag:0];
return s;
}
-(id) initWithString:(NSString*)str withCurrentTransition:(int)ct {
if( (self=[super init] )) {
name = str;
currentTransition = ct;
/* CODE OMITTED */
}
return self;
}
-(void) prevScene:(id)sender {
currentTransition--;
if(currentTransition &lt; 0){
currentTransition = numTransitionTypes-1;
}
[self loadNewScene];
}
-(void) nextScene:(id)sender {
currentTransition++;
if(currentTransition &gt;= numTransitionTypes){
currentTransition = 0;
}
[self loadNewScene];
}
-(void) randomScene:(id)sender {
currentTransition = arc4random()%numTransitionTypes;
[self loadNewScene];
}
-(void) loadNewScene {
[[CCDirector sharedDirector] popScene];
NSString *className = [NSString stringWithFormat:@"%@",transitionTypes[currentTransition]];
Class clazz = NSClassFromString (className);
[[CCDirector sharedDirector] pushScene: [clazz transitionWithDuration:1.2f scene:[TransSceneMenu sceneWithString:className withCurrentTransition:currentTransition]]];
}
-(void) quit:(id)sender {
[[CCDirector sharedDirector] popScene];
}
@end
//Our Base Recipe
@interface Ch5_SceneTransitions : Recipe{}
-(CCLayer*) runRecipe;
-(void) viewTransitions:(id)sender;
@end
@implementation Ch5_SceneTransitions
-(CCLayer*) runRecipe {
[super runRecipe];
CCMenuItemFont *viewTransitions = [CCMenuItemFont itemFromString:@"View Transitions" target:self selector:@selector(viewTransitions:)];
CCMenu *menu = [CCMenu menuWithItems: viewTransitions, nil];
[menu alignItemsVertically];
[self addChild:menu];
return self;
}
-(void) viewTransitions:(id)sender {
[[CCDirector sharedDirector] pushScene:[TransSceneMenu sceneWithString:@"" withCurrentTransition:0]];
}
@end
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec06"/>How it works...</h2></div></div></div><p>The<code class="literal"> CCTransitionScene</code> class creates a transition effect, when it is instantiated with a regular<code class="literal"> CCScene</code> and then immediately pushed onto the scene stack. This is done using the following lines:<a id="id342" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">[[CCDirector sharedDirector] pushScene: [CCTransitionFade transitionWithDuration:1.2f scene:[MyScene scene] withColor:ccWHITE]];
</pre></div><p>In this example, we are using a 'fade to white' transition while loading the<code class="literal"> MyScene</code> scene. Here is a list of the built-in Cocos2d transition classes:
</p><p>
<code class="literal">CCTransitionFadeTR, CCTransitionJumpZoom, CCTransitionMoveInL, CCTransitionSplitCols, CCTransitionSceneOriented. CCTransitionPageTurn, CCTransitionRadialCCW, CCTransitionFade, CCTransitionRotoZoom, CCTransitionShrinkGrow, CCTransitionSlideInL</code>, and<code class="literal"> CCTransitionTurnOffTiles</code>
</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec07"/>There's more...</h2></div></div></div><p>In addition to pushing a scene with a transition, you may also pop a scene with a transition by adding the following method to the<code class="literal"> CCDirector</code> class:<a id="id343" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">//CCDirector.h
- (void) popSceneWithTransition: (Class)transitionClass duration:(ccTime)t;
//CCDirector.m
-(void) popSceneWithTransition: (Class)transitionClass duration:(ccTime)t {
NSAssert( runningScene_ != nil, @"A running Scene is needed");
[scenesStack_ removeLastObject];
NSUInteger c = [scenesStack_ count];
if( c == 0 ) {
[self end];
} else {
CCScene* scene = [transitionClass transitionWithDuration:t scene:[scenesStack_ objectAtIndex:c-1]];
[scenesStack_ replaceObjectAtIndex:c-1 withObject:scene];
nextScene_ = scene;
}
}
</pre></div><p>This pops the scene with a nice transition effect.</p></div></div>
<div class="section" title="Using CCLayerMultiplex"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec04"/>Using CCLayerMultiplex</h1></div></div></div><p>The<code class="literal"> CCLayerMultiplex</code> class provides functionality to seamlessly switch between multiple layers. In this example, we have three similar layers assigned to a multiplex layer. Each layer displays buttons used to switch to any of the other layers.<a id="id344" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/4002_05_03.jpg" alt="Using CCLayerMultiplex"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec08"/>Getting ready</h2></div></div></div><p>Please refer to the project<span class="emphasis"><em> RecipeCollection02</em></span> for full working code of this recipe.
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec09"/>How to do it...</h2></div></div></div><p>Execute the following code:</p><div class="informalexample"><pre class="programlisting">@interface MultiplexLayerMenu : CCLayer {}
+(id) layerWithLayerNumber:(int)layerNumber;
-(id) initWithLayerNumber:(int)layerNumber;
-(void) goToLayer:(id)sender;
@end
@implementation MultiplexLayerMenu
+(id) layerWithLayerNumber:(int)layerNumber {
return [[[MultiplexLayerMenu alloc] initWithLayerNumber:layerNumber] autorelease];
}
CCLayerMultiplexusing-(id) initWithLayerNumber:(int)layerNumber {
if( (self=[super init] )) {
//Random background color
CCSprite *bg = [CCSprite spriteWithFile:@"blank.png"];
bg.position = ccp(240,160);
[bg setTextureRect:CGRectMake(0,0,480,320)];
[bg setColor:ccc3(arc4random()%150,arc4random()%150,arc4random()%150)];
[self addChild:bg];
//Layer number as message
CCLabelBMFont *message = [CCLabelBMFont labelWithString:[NSString stringWithFormat:@"Layer %i",layerNumber+1] fntFile:@"eurostile_30.fnt"];
message.position = ccp(160,270);
message.scale = 0.75f;
[message setColor:ccc3(255,255,255)];
[self addChild:message z:10];
//Buttons to go to different layers
CCMenuItemFont *goToLayer1 = [CCMenuItemFont itemFromString:@"Go To Layer 1" target:self selector:@selector(goToLayer:)];
CCMenuItemFont *goToLayer2 = [CCMenuItemFont itemFromString:@"Go To Layer 2" target:self selector:@selector(goToLayer:)];
CCMenuItemFont *goToLayer3 = [CCMenuItemFont itemFromString:@"Go To Layer 3" target:self selector:@selector(goToLayer:)];
goToLayer1.tag = 0; goToLayer2.tag = 1; goToLayer3.tag = 2;
//Add menu items
CCMenu *menu = [CCMenu menuWithItems: goToLayer1, goToLayer2, goToLayer3, nil];
[menu alignItemsVertically];
[self addChild:menu];
}
return self;
}
//Switch to a different layer
-(void) goToLayer:(id)sender {
CCMenuItemFont *item = (CCMenuItemFont*)sender;
[(CCLayerMultiplex*)parent_ switchTo:item.tag];
}
@end
@interface Ch5_UsingCCLayerMultiplex : Recipe{}
-(CCLayer*) runRecipe;
@end
@implementation Ch5_UsingCCLayerMultiplex
-(CCLayer*) runRecipe {
[super runRecipe];
//Create our multiplex layer with three MultiplexLayerMenu objects
CCLayerMultiplex *layer = [CCLayerMultiplex layerWithLayers: [MultiplexLayerMenu layerWithLayerNumber:0], [MultiplexLayerMenu layerWithLayerNumber:1],
[MultiplexLayerMenu layerWithLayerNumber:2], nil];
[self addChild: layer z:0];
return self;
}
@end
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec10"/>How it works...</h2></div></div></div><p>This technique offers an alternative style of control flow from that of switching between scenes. It allows the instantiation of multiple layers, and the on-the-fly activation and suspension of those layers. The multiplex layer is created using the following class method:<a id="id346" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">+(id) layerWithLayers: (CCLayer*) layer, ... NS_REQUIRES_NIL_TERMINATION;
</pre></div><p>There are many ways to make use of this technique. It provides a flat alternative to hierarchically stacking scenes.</p></div></div>
<div class="section" title="Using CCLabel"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec05"/>Using CCLabel</h1></div></div></div><p>Throughout this book, we've been making use of a number of different label types. In this recipe, we will briefly explain the three commonly used label classes:<code class="literal"> CCLabelAtlas, CCLabelBMFont,</code> and<code class="literal"> CCLabelTTF</code>.<a id="id347" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/4002_05_04.jpg" alt="Using CCLabel"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec11"/>Getting ready</h2></div></div></div><p>Please refer to the project<span class="emphasis"><em> RecipeCollection02</em></span> for full working code of this recipe.
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec12"/>How to do it...</h2></div></div></div><p>Execute the following code:</p><div class="informalexample"><pre class="programlisting">@implementation Ch5_UsingCCLabel
-(CCLayer*) runRecipe {
[super runRecipe];
//CCLabelAtlas for fixed-width bitmap fonts
CCLabelAtlas *labelAtlas = [CCLabelAtlas labelWithString:@"Atlas Label Test" charMapFile:@"tuffy_bold_italic-charmap.png" itemWidth:48 itemHeight:65 startCharMap:' '];
[self addChild:labelAtlas z:0];
labelAtlas.anchorPoint = ccp(0.5f,0.5f);
labelAtlas.scale = 0.5f;
labelAtlas.position = ccp(240,220);
[labelAtlas setColor:ccc3(0,255,0)];
[labelAtlas runAction:[CCRepeatForever actionWithAction: [CCSequence actions: [CCScaleTo actionWithDuration:1.0f scale:0.5f], [CCScaleTo actionWithDuration:1.0f scale:0.25f], nil]]];
//CCLabelBMFont for variable-width bitmap fonts using FNT files
CCLabelBMFont *labelBMFont = [CCLabelBMFont labelWithString:@"Bitmap Label Test" fntFile:@"eurostile_30.fnt"];
[self addChild:labelBMFont z:0];
labelBMFont.position = ccp(240,160);
for(id c in labelBMFont.children){
CCSprite *child = (CCSprite*)c;
[child setColor:ccc3(arc4random()%255,arc4random()%255,arc4random()%255)];
[child runAction:[CCRepeatForever actionWithAction:
[CCSequence actions: [CCScaleTo actionWithDuration:arc4random()%2+1 scale:1.75f], [CCScaleTo actionWithDuration:arc4random()%2+1 scale:0.75f], nil]
]];
}
//CCLabelTTF for true-type fonts
CCLabelTTF *labelTTF = [CCLabelTTF labelWithString:@"True-Type Label Test" fontName:@"arial_narrow.otf" fontSize:32];
[self addChild:labelTTF z:0];
labelTTF.position = ccp(240,100);
[labelTTF runAction:[CCRepeatForever actionWithAction: [CCSequence actions: [CCScaleTo actionWithDuration:2.0f scale:1.5f], [CCScaleTo actionWithDuration:2.0f scale:0.5f], nil]]];
[labelTTF setColor:ccc3(0,0,255)];
return self;
}
@end
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec13"/>How it works...</h2></div></div></div><p>Each label type has advantages and disadvantages.<a id="id348" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">CCLabelAtlas:</code><p>The simplest way to draw text onto the screen is to use the <code class="literal">CCLabelAtlas</code> class. This allows you to draw fixed-width bitmap fonts. It is a low-tech solution that essentially indexes a texture file sequentially using standard ASCII values. The only meta information provided is character size and what the first character in the map is.
<a id="id349" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">CCLabelBMFont:</code><p>The <code class="literal">CCLabelBMFont</code> class has the speed advantage of bitmap font drawing along with many other features. It uses the FNT file format to store non fixed-width bitmap fonts. These fonts can be created with a number of editors including <span class="strong"><strong>Hiero</strong></span>, which can be found at: <a class="ulink" href="http://www.n4te.com/hiero/hiero.jnlp">http://www.n4te.com/hiero/hiero.jnlp</a>. <code class="literal">CCLabelBMFont</code> treats each character as a CCSprite sub-node. This allows us to manipulate them individually.
<a id="id350" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">CCLabelTTF:</code><p>Finally, the <code class="literal">CCLabelTTF</code> class allows drawing of <span class="strong"><strong>TrueType</strong></span> fonts. This allows for the convenience of using built-in system fonts as well as other TrueType fonts that you can specify. It must be noted that TrueType fonts render slowly and should only be used for static text. Bitmap fonts should be used for text that will be updated frequently like a score display.
<a id="id351" class="indexterm"/>
</p></li></ul></div></div></div>
<div class="section" title="Using CCMenu"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec06"/>Using CCMenu</h1></div></div></div><p>Cocos2d provides menu tools that make the process of creating a simple menu very easy. In this example, we will see how to create a simple menu, adjust menu alignment, enable/disable menu items, and more.<a id="id352" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/4002_05_05.jpg" alt="Using CCMenu"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec14"/>Getting ready</h2></div></div></div><p>Please refer to the project<span class="emphasis"><em> RecipeCollection02</em></span> for full working code of this recipe.
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec15"/>How to do it...</h2></div></div></div><p>Execute the following code:</p><div class="informalexample"><pre class="programlisting">@implementation OptionsMenu
+(id) scene {
//Create a scene
CCScene *s = [CCScene node];
OptionsMenu *node = [OptionsMenu node];
[s addChild:node z:0 tag:0];
return s;
}
-(id) init {
if( (self=[super init] )) {
/* CODE OMITTED */
//Disabled title label for Sound option
CCMenuItemFont *title1 = [CCMenuItemFont itemFromString:@"Sound"];
[title1 setIsEnabled:NO];
title1.color = ccc3(0,0,0);
//Toggleable item for Sound option
CCMenuItemToggle *item1 = [CCMenuItemToggle itemWithTarget:self selector:@selector(soundToggle:) items:
[CCMenuItemFont itemFromString: @"On"], [CCMenuItemFont itemFromString: @"Off"], nil];
CCMenuusing//Disabled title label for Difficulty option
CCMenuItemFont *title2 = [CCMenuItemFont itemFromString:@"Difficulty"];
[title2 setIsEnabled:NO];
title2.color = ccc3(0,0,0);
//Toggleable item for Difficulty option
CCMenuItemToggle *item2 = [CCMenuItemToggle itemWithTarget:self selector:@selector(difficultyToggle:) items:
[CCMenuItemFont itemFromString: @"Easy"], [CCMenuItemFont itemFromString: @"Medium"],
[CCMenuItemFont itemFromString: @"Hard"], [CCMenuItemFont itemFromString: @"Insane"], nil];
//Back button
CCMenuItemFont *back = [CCMenuItemFont itemFromString:@"Back" target:self selector:@selector(back:)];
//Finally, create our menu
CCMenu *menu = [CCMenu menuWithItems:
title1, title2,
item1, item2,
back, nil]; // 5 items.
//Align items in columns
[menu alignItemsInColumns:
[NSNumber numberWithUnsignedInt:2],
[NSNumber numberWithUnsignedInt:2],
[NSNumber numberWithUnsignedInt:1],
nil
];
[self addChild:menu];
}
return self;
}
-(void) back:(id)sender {
[[CCDirector sharedDirector] popScene];
}
//Use the 'selectedIndex' variable to identify the touched item
-(void) soundToggle: (id) sender {
CCMenuItem *item = (CCMenuItem*)sender;
[message setString:[NSString stringWithFormat:@"Selected Sound Index:%d", [item selectedIndex]]];
}
-(void) difficultyToggle: (id) sender {
CCMenuItem *item = (CCMenuItem*)sender;
[message setString:[NSString stringWithFormat:@"Selected Difficulty Index:%d", [item selectedIndex]]];
}
@end
CCMenuusing@implementation Ch5_UsingCCMenu
-(CCLayer*) runRecipe {
[super runRecipe];
//Set font size/name
[CCMenuItemFont setFontSize:30];
[CCMenuItemFont setFontName:@"Marker Felt"];
//Image Button
CCMenuItemSprite *imageButton = [CCMenuItemSprite itemFromNormalSprite:[CCSprite spriteWithFile:@"button_unselected.png"]
selectedSprite:[CCSprite spriteWithFile:@"button_selected.png"] disabledSprite:[CCSprite spriteWithFile:@"button_disabled.png"]
target:self selector:@selector(buttonTouched:)];
//Enable Options Label
CCLabelBMFont *enableOptionsLabel = [CCLabelBMFont labelWithString:@"Enable Options" fntFile:@"eurostile_30.fnt"];
CCMenuItemLabel *enableOptions = [CCMenuItemLabel itemWithLabel:enableOptionsLabel target:self selector:@selector(enableOptions:)];
//Options Label
optionsItem = [CCMenuItemFont itemFromString:@"Options" target:self selector:@selector(options:)];
optionsItem.isEnabled = NO;
//Re-Align Label
CCMenuItemFont *reAlign = [CCMenuItemFont itemFromString:@"Re-Align" target:self selector:@selector(reAlign:)];
//Add menu items
menu = [CCMenu menuWithItems: imageButton, enableOptions, optionsItem, reAlign, nil];
[menu alignItemsVertically];
[self addChild:menu];
return self;
}
-(void) buttonTouched:(id)sender {
[message setString:@"Button touched!"];
}
-(void) options:(id)sender {
[[CCDirector sharedDirector] pushScene:[OptionsMenu scene]];
}
-(void) enableOptions:(id)sender {
optionsItem.isEnabled = !optionsItem.isEnabled;
}
//Randomly re-align our menu
-(void) reAlign:(id)sender {
int n = arc4random()%6;
if(n == 0){
[menu alignItemsVertically];
}else if(n == 1){
[menu alignItemsHorizontally];
}else if(n == 2){
[menu alignItemsHorizontallyWithPadding:arc4random()%30];
}else if(n == 3){
[menu alignItemsVerticallyWithPadding:arc4random()%30];
}else if(n == 4){
[menu alignItemsInColumns: [NSNumber numberWithUnsignedInt:2], [NSNumber numberWithUnsignedInt:2], nil];
}else if(n == 5){
[menu alignItemsInRows: [NSNumber numberWithUnsignedInt:2], [NSNumber numberWithUnsignedInt:2], nil];
}
}
@end
<a id="id355" class="indexterm"/>
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec16"/>How it works...</h2></div></div></div><p>The<code class="literal"> CCMenu</code> class acts as a container holding a configurable list of<code class="literal"> CCMenuItem</code> objects:<a id="id356" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">CCMenuItemFont:</code><p>The <code class="literal">CCMenuItemFont</code> class is a helper class designed to quickly create <code class="literal">CCMenuItemLabel</code> objects using TrueType fonts. It provides class methods which act as shortcuts to ease the process of creating a menu item label. Font name and size are set through class methods:
<a id="id357" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">[CCMenuItemFont setFontSize:30];
[CCMenuItemFont setFontName:@"Marker Felt"];
</pre></div><p>A <code class="literal">CCMenuItemFont</code> object is then created through a class method:
</p><div class="informalexample"><pre class="programlisting">CCMenuItemFont *reAlign = [CCMenuItemFont itemFromString:@"Re-Align" target:self selector:@selector(reAlign:)];
</pre></div><p>This class is used throughout the book to create menus item labels.
</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">CCMenuItemLabel:</code><a id="id358" class="indexterm"/><p>For more control over menu item labels, you can use <code class="literal">CCMenuItemLabel</code> directly:
</p><div class="informalexample"><pre class="programlisting">CCLabelBMFont *enableOptionsLabel = [CCLabelBMFont labelWithString:@"Enable Options" fntFile:@"eurostile_30.fnt"];
CCMenuItemLabel *enableOptions = [CCMenuItemLabel itemWithLabel:enableOptionsLabel target:self selector:@selector(enableOptions:)];
</pre></div><p>This allows you to add bitmap fonts using <code class="literal">CCLabelBMFont</code> and <code class="literal">CCLabelAtlas</code>.
</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">CCMenuItemSprite:</code><p>The <code class="literal">CCMenuItemSprite</code> class creates a tappable button as a menu item instead of a textual label:
<a id="id359" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">CCMenuItemSprite *imageButton = [CCMenuItemSprite itemFromNormalSprite:[CCSprite spriteWithFile:@"button_unselected.png"] selectedSprite:[CCSprite spriteWithFile:@"button_selected.png"] disabledSprite:[CCSprite spriteWithFile:@"button_disabled.png"] target:self selector:@selector(buttonTouched:)];
</pre></div><p>Two or three sprites are recommended to create a compelling button effect.
</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">CCMenuItemToggle:</code> A toggle-able menu item contains a list of menu items to iterate through:<a id="id360" class="indexterm"/><div class="informalexample"><pre class="programlisting">CCMenuItemToggle *item1 = [CCMenuItemToggle itemWithTarget:self selector:@selector(soundToggle:) items: [CCMenuItemFont itemFromString: @"On"], [CCMenuItemFont itemFromString: @"Off"], nil];
</pre></div><p>The current state can be identified by the <code class="literal">selectedIndex</code> property on the menu item. This is usually handled in the item's callback method.
</p></li><li class="listitem" style="list-style-type: disc">Automatically aligning menu items:<p>By using the following methods, a <code class="literal">CCMenu</code> object's items can be aligned horizontally or vertically:
</p><div class="informalexample"><pre class="programlisting">-(void) alignItemsVertically;
-(void) alignItemsVerticallyWithPadding:(float) padding;
-(void) alignItemsHorizontally;
-(void) alignItemsHorizontallyWithPadding: (float) padding;
</pre></div><p>Menus can also be aligned in columns or rows:
</p><div class="informalexample"><pre class="programlisting">[menu alignItemsInColumns: [NSNumber numberWithUnsignedInt:2], [NSNumber numberWithUnsignedInt:2], nil];
[menu alignItemsInRows: [NSNumber numberWithUnsignedInt:2], [NSNumber numberWithUnsignedInt:2], nil];
</pre></div><p>The list of <code class="literal">NSNumber</code> objects must total the number of menu items attached to the menu for the alignment to process correctly.
</p></li><li class="listitem" style="list-style-type: disc">Manually aligning menu items:<p>Menu items can also be manually positioned using the <code class="literal">position</code> property like on any other <code class="literal">CCNode</code> object.
<a id="id361" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc">Enabling/disabling menu items:<p>All menu items can be disabled so as to make them ignore touches. Labels can have their <code class="literal">disabledColor</code> property set to indicate this, while instances of <code class="literal">CCMenuItemSprite</code> have a specific sprite set to indicate this.
<a id="id362" class="indexterm"/>
</p></li></ul></div></div></div>
<div class="section" title="Creating shadowed menu labels"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec07"/>Creating shadowed menu labels</h1></div></div></div><p>With a dynamic swirl of colors often in the background, labels can sometimes be hard to identify onscreen. To remedy this, we can create labels with dark shadows behind them. In this recipe, we will create a few of these labels.<a id="id363" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/4002_05_06.jpg" alt="Creating shadowed menu labels"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec17"/>Getting ready</h2></div></div></div><p>Please refer to the project<span class="emphasis"><em> RecipeCollection02</em></span> for full working code of this recipe.
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec18"/>How to do it...</h2></div></div></div><p>Execute the following code:<a id="id364" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">#import "ShadowLabel.h"
@implementation Ch5_ShadowedLabels
-(CCLayer*) runRecipe {
[super runRecipe];
/* Draw four different shadowed labels using 4 different fonts */
[CCMenuItemFont setFontSize:47];
[CCMenuItemFont setFontName:@"Georgia"];
[self label:@"Label 1" at:ccp(-120,50) color:ccc3(0,50,255) activeColor:ccc3(0,200,255) selector:@selector(labelTouched:) tag:1];
[CCMenuItemFont setFontSize:40];
[CCMenuItemFont setFontName:@"Marker Felt"];
[self label:@"Label 2" at:ccp(120,50) color:ccc3(255,128,0) activeColor:ccc3(255,255,0) selector:@selector(labelTouched:) tag:2];
[CCMenuItemFont setFontSize:45];
[CCMenuItemFont setFontName:@"Arial"];
[self label:@"Label 3" at:ccp(-120,-50) color:ccc3(0,128,0) activeColor:ccc3(0,255,0) selector:@selector(labelTouched:) tag:3];
[CCMenuItemFont setFontSize:50];
[CCMenuItemFont setFontName:@"Courier New"];
[self label:@"Label 4" at:ccp(120,-50) color:ccc3(255,0,0) activeColor:ccc3(255,255,0) selector:@selector(labelTouched:) tag:4];
return self;
}
//Label creation helper method
-(void) label:(NSString*)s at:(CGPoint)p color:(ccColor3B)col activeColor:(ccColor3B)activeCol selector:(SEL)sel tag:(int)tag {
ShadowLabel *label = [ShadowLabel labelFromString:s target:self selector:sel];
label.position = p;
label.color = col;
label.activeColor = activeCol;
label.tag = tag;
CCMenu *menu = [CCMenu menuWithItems: label.shadow, label, nil];
[self addChild:menu];
}
//Label touch callback
-(void) labelTouched:(id)sender {
ShadowLabel *label = (ShadowLabel*)sender;
[self showMessage:[NSString stringWithFormat:@"Pressed label %d",label.tag]];
}
@end
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec19"/>How it works...</h2></div></div></div><p>The<code class="literal"> ShadowLabel</code> class creates a child<code class="literal"> CCMenuItemLabel</code> object that is positioned behind and slightly to the side of its parent. Methods are overriden, so the two labels are synchronized.<a id="id365" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Caveats:<p>The only caveat to this approach is that menus using this class cannot be auto-aligned, as the 'shadow' label must also be added as a menu item.
</p></li></ul></div></div><div class="section" title="There's More..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec20"/>There's More...</h2></div></div></div><p>In this example, we set the<code class="literal"> tag</code> property on each<code class="literal"> ShadowLabel</code> so it can be properly identified during a callback. This is the same<code class="literal"> tag</code> property that we've used in the past; only it has been re-purposed for this role.
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Adding shadows in a font editor:<p>As an alternative to technique used previously, shadows can be added to TrueType font using a font editor. The trade-off here is less code and a faster render time. But, you must first take time to add the shadows to the font in the editor.
</p></li></ul></div></div></div>
<div class="section" title="UIKit alert dialogs"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec08"/>UIKit alert dialogs</h1></div></div></div><p>In the next two recipes, we will experiment with the black art of integrating<span class="strong"><strong> UIKit</strong></span> elements into a Cocos2d game. In this example, we see a UIKit<span class="strong"><strong> alert</strong></span> dialog with choices and associated callback methods.<a id="id366" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/4002_05_07.jpg" alt="UIKit alert dialogs"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec21"/>Getting ready</h2></div></div></div><p>Please refer to the project<span class="emphasis"><em> RecipeCollection02</em></span> for full working code of this recipe.
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec22"/>How to do it...</h2></div></div></div><p>Execute the following code:</p><div class="informalexample"><pre class="programlisting">@interface Ch5_UIKitAlerts : Recipe &lt;UIAlertViewDelegate&gt;{}
-(CCLayer*) runRecipe;
-(void)showPieAlert;
-(void)alertView:(UIAlertView*)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex;
@end
@implementation Ch5_UIKitAlerts
-(CCLayer*) runRecipe {
[super runRecipe];
[self showPieAlert];
return self;
}
//Shows a UIAlertView
-(void)showPieAlert {
UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Do You Like Pie?" message:@"" delegate:self cancelButtonTitle:@"Cancel" otherButtonTitles:@"Yes",@"No",nil];
[alert show];
[alert release];
UIKit alert dialogsabout}
//AlertView callback
-(void)alertView:(UIAlertView *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex {
if(buttonIndex == 0) {
[self showMessage:@"You remain tight lipped on\nthe 'pie' question."];
}else if(buttonIndex == 1){
[self showMessage:@"Ah yes, another lover of pie."];
}else if(buttonIndex == 2){
[self showMessage:@"You don't like pie?\nWhat's wrong with you?"];
}
}
@end
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec23"/>How it works...</h2></div></div></div><p>Showing an alert is fairly straightforward. We instantiate a<code class="literal"> UIAlertView</code> object with some basic information and then call the<code class="literal"> show</code> method. This launches our alert.
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using<code class="literal"> UIAlertViewDelegate:</code><p>The <code class="literal">UIAlertViewDelegate</code> protocol dictates that we handle the following method:
<a id="id368" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">-(void)alertView:(UIAlertView *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex;
</pre></div><p>This allows us to handle alert responses by inspecting the returned buttonIndex variable.
<a id="id369" class="indexterm"/>
</p></li></ul></div></div></div>
<div class="section" title="Wrapping UIKit"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec09"/>Wrapping UIKit</h1></div></div></div><p>Other UIKit classes offer a wide range of time-tested UI functionality. Cocos2d requires the use of a UIKit wrapper to transform UIKit objects into<code class="literal"> CCNode</code> objects, so that they may be manipulated properly. In this example, we will wrap two different classes and manipulate them onscreen.<a id="id370" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/4002_05_08.jpg" alt="Wrapping UIKit"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec24"/>Getting ready</h2></div></div></div><p>Please refer to the project<span class="emphasis"><em> RecipeCollection02</em></span> for full working code of this recipe.
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec25"/>How to do it...</h2></div></div></div><p>Execute the following code:</p><div class="informalexample"><pre class="programlisting">#import "CCUIViewWrapper.h"
@implementation Ch5_WrappingUIKit
-(CCLayer*) runRecipe {
[super runRecipe];
[self addSpinningButton];
[self addScrollView];
return self;
}
-(void) addSpinningButton {
//Label
CCLabelBMFont *label = [CCLabelBMFont labelWithString:@"UIButton" fntFile:@"eurostile_30.fnt"];
label.position = ccp(350,220);
label.scale = 0.75f;
[label setColor:ccc3(255,255,255)];
[self addChild:label z:10];
//Our UIButton example
UIButton *button = [UIButton buttonWithType:UIButtonTypeRoundedRect];
[button addTarget:self action:@selector(buttonTapped:) forControlEvents:UIControlEventTouchDown];
[button setTitle:@"Touch Me!" forState:UIControlStateNormal];
button.frame = CGRectMake(0.0, 0.0, 120.0, 40.0);
//Wrap the UIButton using CCUIViewWrapper
CCUIViewWrapper *wrapper = [CCUIViewWrapper wrapperForUIView:button];
[self addChild:wrapper];
wrapper.position = ccp(90,140);
[wrapper runAction:[CCRepeatForever actionWithAction:[CCRotateBy actionWithDuration:5.0f angle:360]]];
}
-(void) addScrollView {
//Label
CCLabelBMFont *label = [CCLabelBMFont labelWithString:@"UIScrollView" fntFile:@"eurostile_30.fnt"];
label.position = ccp(100,220);
label.scale = 0.75f;
[label setColor:ccc3(255,255,255)];
[self addChild:label z:10];
//Create a simple UIScrollView with colored UIViews
CGPoint viewSize = ccp(200.0f,100.0f);
CGPoint nodeSize = ccp(200.0f,50.0f);
int nodeCount = 10;
//Init scrollview
UIScrollView *scrollview = [[UIScrollView alloc] initWithFrame: CGRectMake(0, 0, viewSize.x, viewSize.y)];
//Add nodes
for (int i = 0; i &lt;nodeCount; i++){
CGFloat y = i * nodeSize.y;
UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, y, nodeSize.x, nodeSize.y)];
view.backgroundColor = [UIColor colorWithRed:(CGFloat)random()/(CGFloat)RAND_MAX green:(CGFloat)random()/(CGFloat)RAND_MAX blue:(CGFloat)random()/(CGFloat)RAND_MAX alpha:1.0];
[scrollview addSubview:view];
[view release];
}
scrollview.contentSize = CGSizeMake(viewSize.x, viewSize.y * nodeCount/2);
//Wrap the UIScrollView object using CCUIViewWrapper
CCUIViewWrapper *wrapper = [CCUIViewWrapper wrapperForUIView:scrollview];
[self addChild:wrapper];
wrapper.rotation = -90;
wrapper.position = ccp(50,400);
}
-(void) buttonTapped:(id)sender {
[self showMessage:@"Button tapped"];
}
@end
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec26"/>How it works...</h2></div></div></div><p>The<code class="literal"> CCUIViewWrapper</code> takes any<code class="literal"> UIView</code> object in its main creation class method:<a id="id371" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">CCUIViewWrapper *wrapper = [CCUIViewWrapper wrapperForUIView:button];
</pre></div><p>This object can be manipulated like a normal<code class="literal"> CCSprite</code> object.
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">UIButton:</code><a id="id372" class="indexterm"/><p>The advantages of using UIKit classes are numerous. The <code class="literal">UIButton</code> class allows for the creation of a nifty button with text on it.
</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">UIScrollView:</code><a id="id373" class="indexterm"/><p>In our other example, we create a more complex <code class="literal">UIScrollView</code> object. Although the syntax is somewhat messier than using a built-in Cocos2d class, the slick functionality provided by this UIKit view is difficult to duplicate.
</p></li><li class="listitem" style="list-style-type: disc">Mixing actions:<p>If you scroll the <code class="literal">UIScrollView</code> object, you will see that the <code class="literal">UIButton</code> on the right stops spinning. Some UIKit actions take precedence over asynchronous Cocos2d actions.
</p></li><li class="listitem" style="list-style-type: disc">Autorotation and the UIKit wrapper:<p>One limitation of this wrapper is that it does not currently work with Cocos2d auto-rotation. If you rotate your device, while using this recipe, you'll see that the elements onscreen do not rotate along with the screen. It is recommended that you use the following line in your <code class="literal">GameConfig.h</code> file:
</p><div class="informalexample"><pre class="programlisting">#define GAME_AUTOROTATION kGameAutorotationNone
</pre></div><p>This will disable auto-rotation.
</p></li><li class="listitem" style="list-style-type: disc">The power of UIKit:<p>It is best to use this wrapper as a starting point for experimenting with UIKit classes. Cocos2d and UIKit don't always play nice together, but being able to leverage a robust UI library like UIKit can help create fancier menus without the headaches of writing and testing your own UI code.
</p></li></ul></div></div></div>
<div class="section" title="Creating draggable menu windows"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec10"/>Creating draggable menu windows</h1></div></div></div><p>Cocos2d is commonly thought of as a game development library and it has been treated as such in much of this book. However, Cocos2d is a robust solution for any 2D application. That said, draggable windows are a common element in many applications. In this example, we will create movable, collapsable menu windows.<a id="id374" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/4002_05_09.jpg" alt="Creating draggable menu windows"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec27"/>Getting ready</h2></div></div></div><p>Please refer to the project<span class="emphasis"><em> RecipeCollection02</em></span> for full working code of this recipe.<a id="id375" class="indexterm"/>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec28"/>How to do it...</h2></div></div></div><p>Execute the following code:</p><div class="informalexample"><pre class="programlisting">#import "GameMenuWindow.h"
@implementation Ch5_MenuWindows
-(CCLayer*) runRecipe {
[super runRecipe];
//Initialization
windows = [[[NSMutableArray alloc] init] autorelease];
CCNode *windowContainer = [[CCNode alloc] init];
/* Create three menu windows with randomized positions */
GameMenuWindow *window1 = [GameMenuWindow windowWithTitle:@"Window 1" size:CGSizeMake(arc4random()%200+120,arc4random()%100+50)];
window1.position = ccp(arc4random()%100+150,arc4random()%140+100);
[windowContainer addChild:window1 z:1];
[windows addObject:window1];
/* CODE OMITTED */
//Sort our window array by zOrder
//This allows ordered touching
NSSortDescriptor *sorter = [[NSSortDescriptor alloc] initWithKey:@"self.zOrder" ascending:NO];
[windows sortUsingDescriptors:[NSArray arrayWithObject:sorter]];
//Add window container node
[self addChild:windowContainer];
return self;
}
-(void) ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {
UITouch *touch = [touches anyObject];
CGPoint point = [touch locationInView: [touch view]];
point = [[CCDirector sharedDirector] convertToGL: point];
//Sort our window array before we process a touch
NSSortDescriptor *sorter = [[NSSortDescriptor alloc] initWithKey:@"self.zOrder" ascending:NO];
[windows sortUsingDescriptors:[NSArray arrayWithObject:sorter]];
//Grab the window by touching the top bar. Otherwise, merely bring the window to the front
for(GameMenuWindow* w in windows){
if(pointIsInRect(point, [w titleBarRect])){
[w ccTouchesBegan:touches withEvent:event];
return;
}else if(pointIsInRect(point, [w rect])){
[w bringToFront];
return;
}
}
}
-(void) ccTouchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {
/* CODE OMITTED */
//If we touched a window them we can drag it
for(GameMenuWindow* w in windows){
if(w.isTouched){
[w ccTouchesMoved:touches withEvent:event];
}
}
}
-(void) ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {
/* CODE OMITTED */
//End a touch if neccessary
for(GameMenuWindow* w in windows){
if(w.isTouched){
[w ccTouchesEnded:touches withEvent:event];
}
}
}
@end
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec29"/>How it works...</h2></div></div></div><p>The windows shown previously can be moved around by touching a title bar and then dragging. Pressing the plus/minus symbol expands or collapses the window content.<a id="id376" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating the title bar:<p>The title bar and other parts of each window are created using the colored <code class="literal">blank.png</code> sprite technique. The label used in the title bar is anchored to the left, to left-align the text.
<a id="id377" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc">Adding content to a window:<p>Nodes can be added to the <code class="literal">content</code> sprite to add window content. This can include text, images, dynamic content, and so on. Please note that, in this example, nodes added to the <code class="literal">content</code> sprite are not clipped and can appear outside the window depending on node position.
<a id="id378" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc">Sorting the windows:<p>Before we can properly interact with the windows, they must be sorted by their <code class="literal">zOrder</code> property:
<a id="id379" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">NSSortDescriptor *sorter = [[NSSortDescriptor alloc] initWithKey:@"self.zOrder" ascending:NO];
[windows sortUsingDescriptors:[NSArray arrayWithObject:sorter]];
</pre></div><p>The <code class="literal">NSSortDescriptor</code> class allows you to sort an <code class="literal">NSArray</code> container based on a common property of the objects being sorted. We specify the key <code class="literal">"self.zOrder"</code>. This re-orders the array according to the <code class="literal">Order</code>z property. Now, when we iterate through the array looking for a touched window, the first one we find will be the window that appears on top.
</p></li></ul></div></div></div>
<div class="section" title="Creating a horizontal scrollable menu"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec11"/>Creating a horizontal scrollable menu</h1></div></div></div><p>Cocos2d provides the rather mundane<code class="literal"> CCMenuItemToggle</code> class to iterate through multiple<code class="literal"> CCMenuItem</code> choices. In this example, we'll spice this up with the<code class="literal"> LoopingMenu</code> class that mimics the iPod Touch album art shuffling visual technique.<a id="id380" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/4002_05_10.jpg" alt="Creating a horizontal scrollable menu"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec30"/>Getting ready</h2></div></div></div><p>Please refer to the project<span class="emphasis"><em> RecipeCollection02</em></span> for full working code of this recipe.
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec31"/>How to do it...</h2></div></div></div><p>Execute the following code:<a id="id381" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">#import "LoopingMenu.h"
@implementation Ch5_HorizScrollMenu
-(CCLayer*) runRecipe {
[super runRecipe];
message.position = ccp(70,270);
/* Create 5 default sprites and 'selected' sprites */
CCSprite *book1 = [CCSprite spriteWithFile:@"book1.jpg"];
CCSprite *book2 = [CCSprite spriteWithFile:@"book2.jpg"];
/* CODE OMITTED */
CCSprite *book1_selected = [CCSprite spriteWithFile:@"book1.jpg"]; book1_selected.color = ccc3(128,128,180); [book1_selected setBlendFunc: (ccBlendFunc) { GL_ONE, GL_ONE }];
CCSprite *book2_selected = [CCSprite spriteWithFile:@"book2.jpg"]; book2_selected.color = ccc3(128,128,180); [book2_selected setBlendFunc: (ccBlendFunc) { GL_ONE, GL_ONE }];
/* CODE OMITTED */
/* Create CCMenuItemSprites */
CCMenuItemSprite* item1 = [CCMenuItemSprite itemFromNormalSprite:book1 selectedSprite:book1_selected target:self selector:@selector(bookClicked:)];
item1.tag = 1;
CCMenuItemSprite* item2 = [CCMenuItemSprite itemFromNormalSprite:book2 selectedSprite:book2_selected target:self selector:@selector(bookClicked:)];
item2.tag = 2;
/* CODE OMITTED */
//Initialize LoopingMenu and add menu items
LoopingMenu *menu = [LoopingMenu menuWithItems:item1, item2, item3, item4, item5, nil];
menu.position = ccp(240, 150);
[menu alignItemsHorizontallyWithPadding:0];
//Add LoopingMenu to scene
[self addChild:menu];
return self;
}
//Book clicked callback
-(void) bookClicked:(id)sender {
CCMenuItemSprite *sprite = (CCMenuItemSprite*)sender;
[self showMessage:[NSString stringWithFormat:@"Book clicked: %d", sprite.tag]];
}
@end
<a id="id382" class="indexterm"/>
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec32"/>How it works...</h2></div></div></div><p>The<code class="literal"> LoopingMenu</code> class inherits the<code class="literal"> CCMenu</code> class. It uses the same basic creation method:<a id="id383" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">LoopingMenu *menu = [LoopingMenu menuWithItems:item1, item2, item3, item4, item5, nil];
</pre></div><p>This creates an endlessly scrollable menu using the<code class="literal"> CCMenuItem</code> objects provided. In this case, we use<code class="literal"> CCMenuItemSprite</code> objects.<a id="id384" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Caveats:<p>The one caveat with this technique is that the <code class="literal">CCMenuItem</code> objects are constantly rescaled. So, menu items cannot be rescaled before adding them to the <code class="literal">LoopingMenu</code> instance. The full image or label sizes must be used.
</p></li></ul></div></div></div>
<div class="section" title="Creating a vertical sliding menu grid"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec12"/>Creating a vertical sliding menu grid</h1></div></div></div><p>Sometimes, you want a large number of menu choices onscreen at once. In this example, we see the<code class="literal"> SlidingMenuGrid</code> class in action.<a id="id385" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/4002_05_11.jpg" alt="Creating a vertical sliding menu grid"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec33"/>Getting ready</h2></div></div></div><p>Please refer to the project<span class="emphasis"><em> RecipeCollection02</em></span> for full working code of this recipe.<a id="id386" class="indexterm"/>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec34"/>How to do it...</h2></div></div></div><p>Execute the following code:</p><div class="informalexample"><pre class="programlisting">#import "SlidingMenuGrid.h"
@implementation Ch5_VertSlidingMenuGrid
-(CCLayer*) runRecipe {
[super runRecipe];
message.position = ccp(200,270);
[self showMessage:@"Tap a button or slide the menu grid up or down."];
//Init item array
NSMutableArray* allItems = [[[NSMutableArray alloc] init] autorelease];
/* Create 45 CCMenuItemSprite objects with tags, callback methods and randomized colors */
for (int i = 1; i &lt;= 45; ++i) {
CCSprite* normalSprite = [CCSprite spriteWithFile:@"sliding_menu_button_0.png"];
CCSprite* selectedSprite = [CCSprite spriteWithFile:@"sliding_menu_button_1.png"];
ccColor3B color = [self randomColor];
normalSprite.color = color;
selectedSprite.color = color;
CCMenuItemSprite* item = [CCMenuItemSprite itemFromNormalSprite:normalSprite selectedSprite:selectedSprite target:self selector:@selector(buttonClicked:)];
item.tag = i;
//Add each item to array
[allItems addObject:item];
}
//Init SlidingMenuGrid object with array and some other information
SlidingMenuGrid* menuGrid = [SlidingMenuGrid menuWithArray:allItems cols:5 rows:3 position:ccp(70.f,220.f) padding:ccp(90.f,80.f) verticalPages:true];
[self addChild:menuGrid z:1];
return self;
}
//Button clicked callback
-(void) buttonClicked:(id)sender {
CCMenuItemSprite *sprite = (CCMenuItemSprite*)sender;
[self showMessage:[NSString stringWithFormat:@"Button clicked: %d", sprite.tag]];
}
//Random base color method
-(ccColor3B) randomColor {
/* CODE OMITTED */
}
@end
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec35"/>How it works...</h2></div></div></div><p>Largely inspired by the über popular iOS game, Angry Birds, the<code class="literal"> SlidingMenuGrid</code> class takes an array of<code class="literal"> CCMenuItem</code> objects and arranges them in rows and columns as specified:<a id="id387" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">SlidingMenuGrid* menuGrid = [SlidingMenuGrid menuWithArray:allItems cols:5 rows:3 position:ccp(70.f,220.f) padding:ccp(90.f,80.f) verticalPages:true];
</pre></div><p>Menu items are divided up into pages depending on how many there are and how they fit onscreen.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Going from page to page:<p>Sliding vertically across the menu will switch from page to page.
</p></li><li class="listitem" style="list-style-type: disc">Tweaking<code class="literal"> SlidingMenuGrid:</code><p>If you inspect <code class="literal">SlidingMenuGrid.h</code> and <code class="literal">SlidingMenuGrid.mm</code>, you can see a number of variables that determine the behavior of the menu grid, including the distance required to 'page' the menu and paging animation speed.
</p></li></ul></div></div></div>
<div class="section" title="Creating a loading screen with an indicator"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec13"/>Creating a loading screen with an indicator</h1></div></div></div><p>Games with large levels often incur long load times. If level elements can be loaded in asynchronous steps, then we can give the user some reassuring feedback that the game is still loading and hasn't crashed.<a id="id388" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/4002_05_12.jpg" alt="Creating a loading screen with an indicator"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec36"/>Getting ready</h2></div></div></div><p>Please refer to the project<span class="emphasis"><em> RecipeCollection02</em></span> for full working code of this recipe.
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec37"/>How to do it...</h2></div></div></div><p>Execute the following code:<a id="id389" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">/* The actual 'game' class where we display the textures we loaded asynchronously */
@implementation GameScene
+(id) sceneWithLevel:(NSString*)str {
//Create our scene
CCScene *s = [CCScene node];
GameScene *node = [[GameScene alloc] initWithLevel:str];
[s addChild:node z:0 tag:0];
return s;
}
-(id) initWithLevel:(NSString*)str {
if( (self=[super init] )) {
//Load our level
[self loadLevel:str];
/* CODE OMITTED */
//Create a label to indicate that this is the loaded level
CCLabelBMFont *label = [CCLabelBMFont labelWithString:@"The Loaded Level:" fntFile:@"eurostile_30.fnt"];
/* CODE OMITTED */
//Quit button
CCMenuItemFont *quitItem = [CCMenuItemFont itemFromString:@"Quit" target:self selector:@selector(quit:)];
CCMenu *menu = [CCMenu menuWithItems: quitItem, nil];
menu.position = ccp(430,300);
[self addChild:menu z:10];
}
return self;
}
//Quit callback
-(void) quit:(id)sender {
[[CCDirector sharedDirector] popScene];
//Clear all loaded textures (including ones from other recipes)
[[CCTextureCache sharedTextureCache] removeAllTextures];
}
//Load level file and process sprites
-(void) loadLevel:(NSString*)str {
NSString *jsonString = [[NSString alloc] initWithContentsOfFile:getActualPath(str) encoding:NSUTF8StringEncoding error:nil];
NSData *jsonData = [jsonString dataUsingEncoding:NSUTF32BigEndianStringEncoding];
NSDictionary *dict = [[CJSONDeserializer deserializer] deserializeAsDictionary:jsonData error:nil];
NSArray *nodes = [dict objectForKey:@"nodes"];
for (id node in nodes) {
if([[node objectForKey:@"type"] isEqualToString:@"spriteFile"]){
[self processSpriteFile:node];
}
}
}
-(void) processSpriteFile:(NSDictionary*)node {
//Init the sprite
NSString *file = [node objectForKey:@"file"];
CCSprite *sprite = [CCSprite spriteWithFile:file];
//Set sprite position
sprite.position = ccp(arc4random()%480, arc4random()%200);
//Each numeric value is an NSString or NSNumber that must be cast into a float
sprite.scale = [[node objectForKey:@"scale"] floatValue];
//Set the anchor point so objects are positioned from the bottom-up
sprite.anchorPoint = ccp(0.5,0);
//Finally, add the sprite
[self addChild:sprite z:2];
}
@end
@implementation LoadingScene
+(id) sceneWithLevel:(NSString*)str {
//Create our scene
CCScene *s = [CCScene node];
LoadingScene *node = [[LoadingScene alloc] initWithLevel:str];
[s addChild:node z:0 tag:0];
return s;
}
-(id) initWithLevel:(NSString*)str {
if( (self=[super init] )) {
//Set levelStr
levelStr = str;
[levelStr retain];
/* CODE OMITTED */
//Set the initial loading message
loadingMessage = [CCLabelBMFont labelWithString:@"Loading, Please Wait...0%" fntFile:@"eurostile_30.fnt"];
/* CODE OMITTED */
//Create an initial '0%' loading bar
loadingBar = [CCSprite spriteWithFile:@"blank.png"];
loadingBar.color = ccc3(255,0,0);
[loadingBar setTextureRect:CGRectMake(0,0,10,25)];
loadingBar.position = ccp(50,50);
loadingBar.anchorPoint = ccp(0,0);
[self addChild:loadingBar z:10];
//Start level pre-load
[self preloadLevel];
}
return self;
}
//Asynchronously load all required textures
-(void) preloadLevel {
nodesLoaded = 0;
NSString *jsonString = [[NSString alloc] initWithContentsOfFile:getActualPath(levelStr) encoding:NSUTF8StringEncoding error:nil];
NSData *jsonData = [jsonString dataUsingEncoding:NSUTF32BigEndianStringEncoding];
NSDictionary *dict = [[CJSONDeserializer deserializer] deserializeAsDictionary:jsonData error:nil];
NSArray *nodes = [dict objectForKey:@"nodes"];
nodesToLoad = [nodes count];
for (id node in nodes) {
if([[node objectForKey:@"type"] isEqualToString:@"spriteFile"]){
[self preloadSpriteFile:node];
}
}
}
//Asynchronously load a texture and call the specified callback when finished
-(void) preloadSpriteFile:(NSDictionary*)node {
NSString *file = [node objectForKey:@"file"];
[[CCTextureCache sharedTextureCache] addImageAsync:file target:self selector:@selector(nodeLoaded:)];
}
//The loading callback
//This increments nodesLoaded and reloads the indicators accordingly
-(void) nodeLoaded:(id)sender {
nodesLoaded++;
float percentComplete = 100.0f * (nodesLoaded / nodesToLoad);
[loadingMessage setString:[NSString stringWithFormat:@"Loading, Please Wait...%d%@", (int)percentComplete, @"%"]];
//When we are 100% complete we run the game
if(percentComplete &gt;= 100.0f){
[self runAction:[CCSequence actions: [CCDelayTime actionWithDuration:0.25f], [CCCallFunc actionWithTarget:self selector:@selector(runGame:)], nil]];
}
//Grow the loading bar
[loadingBar setTextureRect:CGRectMake(0,0,percentComplete*4,25)];
}
//First pop this scene then load the game scene
-(void) runGame:(id)sender {
[[CCDirector sharedDirector] popScene];
[[CCDirector sharedDirector] pushScene:[GameScene sceneWithLevel:@"level1.json"]];
}
@end
@implementation Ch5_LoadingScreen
-(CCLayer*) runRecipe {
[super runRecipe];
//The load level button
CCMenuItemFont *loadLevelItem = [CCMenuItemFont itemFromString:@"Load Level" target:self selector:@selector(loadLevel:)];
CCMenu *menu = [CCMenu menuWithItems: loadLevelItem, nil];
menu.position = ccp(240,160);
[self addChild:menu];
return self;
}
//Callback to load the level
-(void) loadLevel:(id)sender {
[[CCDirector sharedDirector] pushScene:[LoadingScene sceneWithLevel:@"level1.json"]];
}
@end
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec38"/>How it works...</h2></div></div></div><p>This recipe reads through a JSON file and loads the images specified. For more information about loading data from a JSON file, please refer to the recipe entitled<span class="emphasis"><em> Reading JSON data files</em></span> located in<a class="link" href="ch03.html" title="Chapter 3. Files and Data"> Chapter 3</a>,<span class="emphasis"><em> Files and Data</em></span>. Here, in total, we load 10 images, totaling about 6 megabytes. Loading time depends on the device the application is running on (the simulator, the iPhone 4, the iPad, and so on).<a id="id390" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Asynchronous texture loading:<a id="id391" class="indexterm"/><p>We can create this loading screen because we have the capability to asynchronously load textures using the following method call:
</p><div class="informalexample"><pre class="programlisting">[[CCTextureCache sharedTextureCache] addImageAsync:file target:self selector:@selector(nodeLoaded:)];
</pre></div><p>Every time the nodeLoaded callback fires, we increment a counter to keep track of files loaded. Even though this ignores the variance of file sizes being loaded, this gives us a rough estimate of how far along we are in the loading process. Displaying this graphically in a bar, gives the user some basic visual feedback without going into too much detail.
</p></li><li class="listitem" style="list-style-type: disc">Switching to the game scene:<p>Once all the images are loaded asynchronously, we pop the loading scene and switch to the main game scene. The JSON file name is passed along so that a second pass can be made to actually display the images onscreen. Because these images have been pre-loaded, the scene displays immediately.
<a id="id392" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc">Unloading textures:<p>When we are finished with our game, we unload all loaded textures:
<a id="id393" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">[[CCTextureCache sharedTextureCache] removeAllTextures];
</pre></div><p>This unloads all loaded textures including ones loaded anywhere else in the application. Textures can also be removed manually by calling the <code class="literal">release</code> method on the ones to be removed, and then calling the <code class="literal">removeUnusedTextures</code> method on the <code class="literal">sharedTextureCache</code> singleton. Keep in mind that <code class="literal">removeUnusedTextures</code> also removes textures added to <code class="literal">CCTextureCache</code>. It might be safer to remove textures individually using one of the following methods:
<a id="id394" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">-(void) removeTexture: (CCTexture2D*) tex;
-(void) removeTextureForKey: (NSString*) textureKeyName;
</pre></div></li></ul></div></div><div class="section" title="Creating a minimap"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl1sec14"/>Creating a minimap</h2></div></div></div><p>An engaging and informative in-game HUD is a crucial piece of most games. Mobile games, in particular, often blend user input with heads-up information due to the small amount of screen real estate available. In this example, we will create a<span class="strong"><strong> Minimap</strong></span> to help the player navigate the terrain in the isometric game demo from the last chapter.<a id="id395" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/4002_05_13.jpg" alt="Creating a minimap"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec39"/>Getting ready</h3></div></div></div><p>Please refer to the project<span class="emphasis"><em> RecipeCollection02</em></span> for full working code of this recipe.
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec40"/>How to do it...</h3></div></div></div><p>Execute the following code:</p><div class="informalexample"><pre class="programlisting">#import "Minimap.h"
@implementation Ch5_Minimap
-(CCLayer*) runRecipe {
//Initialize the Minimap object
minimap = [[[Minimap alloc] init] autorelease];
minimap.position = ccp(300,140);
[self addChild:minimap z:10];
//Run our top-down isometric game recipe
[super runRecipe];
//Add trees as static objects
for(id t in trees){
GameObject *tree = (GameObject*)t;
[minimap addStaticObject:ccp(tree.body-&gt;GetPosition().x, tree.body-&gt;GetPosition().y)];
}
return self;
}
-(void) step:(ccTime)delta {
[super step:delta];
//Set the actor position
[minimap setActor: ccp(gunman.body-&gt;GetPosition().x, gunman.body-&gt;GetPosition().y)];
//Set individual projectile positions
for(id b in balls){
GameObject *ball = (GameObject*)b;
[minimap setProjectile:ccp(ball.body-&gt;GetPosition().x, ball.body-&gt;GetPosition().y) withKey:[NSString stringWithFormat:@"%d", ball.tag]];
}
}
//We override this method to automatically add walls to the minimap
-(void) addBrickWallFrom:(CGPoint)p1 to:(CGPoint)p2 height:(float)height {
//Convert wall vertex positions to the properly scaled Box2D coordinates
CGPoint vert1 = ccp(p1.x/PTM_RATIO,p1.y/PTM_RATIO/PERSPECTIVE_RATIO);
CGPoint vert2 = ccp(p2.x/PTM_RATIO,p2.y/PTM_RATIO/PERSPECTIVE_RATIO);
//Add both wall vertices
[minimap addWallWithVertex1:vert1 withVertex2:vert2];
[super addBrickWallFrom:p1 to:p2 height:height];
}
@end
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec41"/>How it works...</h3></div></div></div><p>The minimap shown in this example, is basically a simple graphical representation of the Box2D world similar to that of the Box2D debug drawing routines. In this instance, we have tailored the OpenGL drawing code to fit our needs.<a id="id396" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Generalizing the minimap:<a id="id397" class="indexterm"/><p>The <code class="literal">Minimap</code> class generalizes physical elements into a number of types and then draws these types using specific colors. These include walls, projectiles, static objects, and a central actor.
<a id="id398" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc">Walls:<p>Wall vertices are stored in two <code class="literal">NSMutableArray</code> objects. These are designed to be set initially and never updated.
<a id="id399" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc">Projectiles:<p>Projectile coordinates are stored in a single <code class="literal">NSMutableDictionary</code> object. This allows us to update all projectiles repeatedly by using their <code class="literal">tag</code> property as a key in the dictionary. The implication is that projectiles are in a constant state of movement.
<a id="id400" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc">Static objects:<p>Static objects in this example are trees. They represent static points on the map that do not move. They are drawn with the same color as the walls. Size information is not stored as it is assumed that static objects are not very large.
<a id="id401" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc">The central actor:<p>Finally, a central actor position is shown as a large blue point.
<a id="id402" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc">Customizing the<code class="literal"> Minimap</code> class:<p>The <code class="literal">Minimap</code> class represents a generic template that can be customized for any game type or situation. By changing the <code class="literal">scale</code> property, position information, and drawing routine, the <code class="literal">Minimap</code> can
<a id="id403" class="indexterm"/>
</p></li></ul></div></div></div></div></body></html>