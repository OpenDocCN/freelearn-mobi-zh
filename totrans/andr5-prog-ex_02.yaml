- en: Chapter 2. Building a UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Material Design** UI paradigm has brought a whole new look and feel to
    the Android platform. This new approach aims to give Android apps a clean and
    simple appearance with intuitive controls and animations. Google talks of virtual
    paper and virtual ink, and this concept can be seen most clearly in the new screen
    component (or widget), the Card (or `CardView`), which unlike previous Android
    widgets casts a shadow and has rounded corners.
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a UI](img/B04321_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Even before we have placed our first `CardView` widget into our layout, we can
    start to utilize Material Design by applying and customizing one of the material
    themes. These themes allow us to define a few base colors and properties which
    are then automatically applied throughout our app, giving it a brand identity
    that helps our app to be easily recognized by the user.
  prefs: []
  type: TYPE_NORMAL
- en: Having created our layout, we can then see how Java is used to provide functionality.
    Here, we will use a button to launch a simple Material Design animation, which
    we will then adapt to our layout to handle screen rotations and provide textual
    context to our images for users with visual impairments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Apply a material theme to our app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply your brand colors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand Material Design color guidelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add new widgets to a relative layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write some Java code to detect button clicks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write code to produce an animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observe the build process with the Gradle console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply accessibility options for images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create layouts for alternative screen orientations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will continue to develop the `Hello World` app that we started
    in the previous chapter and use it to demonstrate a simple animation. The code
    can be downloaded from the Packt Publishing website and is called `Hello World
    - Chapter 2`.
  prefs: []
  type: TYPE_NORMAL
- en: Applying a Material Design theme
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android themes govern the general appearance of our app, controlling things
    like default background colors and text colors and sizes. Prior to Android 5,
    the Holo theme was the most widely used built-in theme, and you can preview it
    by clicking on the **App Theme** button at the top of the `activity_main.xml`
    file, when viewed in the **Design** tab.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that previewing a theme will have no effect on the app when it is run on
    a handset or an emulator, as this has to be achieved within the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'All Android themes are highly configurable and none more so than the material
    theme, which allows us, with just a few lines of code, to set a color scheme that
    is applied across the app, and unlike its predecessors, to also change the color
    of the toolbar and the navigation bar. The following exercise details how such
    branding can be applied to the project we set up in the last chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Hello World` project from the last chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is not open already, open the **Project** tool window from the menu with
    **View** | **Tool Windows** | **Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the `res/values` folder and right-click on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **New** | **XML** | **Values XML File** from the menu and call the file
    `colors`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Fill out the `colors.xml` file as follows here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `res/values/styles/styles.xml (v21)` file and complete it as below:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can now run the app on a handset or an emulator, to see how our brand colors
    have been applied:![Applying a Material Design theme](img/B04321_02_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that not all the material theme colors will show up on the standard Android
    AVDs, in particular, the status and navigation bars. To view the changes, you
    will need a real device or one of the third-party emulators.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to apply our own color scheme to the previously un-editable UI elements,
    such as the status and navigation bars is a huge bonus. Not only does it give
    us control over how the entire screen looks, but it gives our apps an identifiable
    and individual feel.
  prefs: []
  type: TYPE_NORMAL
- en: Android provides fields such as `colorPrimaryDark` and `navigationBarColor`
    as convenient ways to apply our color schemes throughout the app. It is generally
    recommended that the navigation bar be left black, and was colored here simply
    by way of demonstration. We did not use all the color attributes that we could
    have; had we wanted to, we could have set the window background color with `windowBackground`
    and `statusBarColor`, which will override it being set by default as `colorPrimaryDark`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that `colorAccent` is not visible in this demonstration. It is used for
    switches, sliders and editable text views, among other things. It is included
    here as we will be using this theme (or one with colors of your choice) throughout
    the book and the inclusion of `colorAccent` will become evident as we progress.
  prefs: []
  type: TYPE_NORMAL
- en: 'Selecting colors for our theme is made remarkably easy with the help of an
    IDE, as you can see that the colors we have defined are displayed in the gutter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying a Material Design theme](img/B04321_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the `colors.xml` file, these colors can be clicked on to produce a dynamic
    color wheel for us to select from. Although we are free to use any colors we like
    for our theme, Google design guidelines suggest that colors should be picked from
    the recommended hues, a full list of which can be found at [http://www.google.com/design/spec/style/color.html](http://www.google.com/design/spec/style/color.html).
    Furthermore, Google also recommends that the primary color should have a value
    of 500 and the darker version should be 700.
  prefs: []
  type: TYPE_NORMAL
- en: In the `colors.xml` file, it can be seen that the text colors are defined with
    alpha channels.
  prefs: []
  type: TYPE_NORMAL
- en: Google recommends that we use transparency to produce various shades of text.
    In particular, they suggest around 87% opacity for our primary text and 54% for
    the secondary. When dealing with white text on a dark background, opacity values
    of 100% and 70% should be used. Edit text hints should be around 28% for either
    background.
  prefs: []
  type: TYPE_NORMAL
- en: You will have noticed that there are two `styles.xml` files, the `v21` version
    that we used and another with the same name. This other styles file is used for
    providing alternative themes for when we need to make our apps backward compatible.
    We will come to this in due course, but for now the other styles file can be safely
    ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Material Design guidelines do not have to be followed rigidly, especially if
    you are designing a full-screen app such as a game. They are there to help developers
    build apps that provide a consistent experience across the platform, and how strictly
    you adhere to the guidelines is entirely up to you.
  prefs: []
  type: TYPE_NORMAL
- en: Having seen how easy it is to apply a personalized theme to our app, we can
    now start to add more visual components to our layout and take a look at how they
    can then be controlled programmatically with Java. We will continue with our `Hello
    World` project and to make it a little more interesting, we will add in some simple
    Android 5 animations.
  prefs: []
  type: TYPE_NORMAL
- en: Adding animated widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with many programming languages, design and functionality are dealt with
    more or less separately. We use XML to design our layouts and Java to provide
    them with functionality. Here, we will see how both of these are done and will
    deal separately with each.
  prefs: []
  type: TYPE_NORMAL
- en: Designing an XML layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be using the graphical design view to construct this UI, but it is worth
    checking the text view from the tab at the bottom after each step, to see how
    the changes that we make are applied in XML.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Hello World` project and then the `activity_main.xml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Design** tab at the bottom to view the device preview.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a `TextView` control into the middle of the screen, like so:![Designing
    an XML layout](img/B04321_02_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Palette** on the left, drag and drop a **Button** widget to the bottom-center
    of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag an **ImageView** control from the **Palette** just under the **TextView**.
    The tip at the top should read:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the **ImageView** still selected, or by selecting it in the **Component
    Tree** pane, locate `src` in the **Properties** pane beneath this and click on
    the **....** button to bring up this dialog box:![Designing an XML layout](img/B04321_02_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Mip Map** | **ic_launcher** and click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Selecting the **ImageView** in the preview window and press *Ctrl* + *C* followed
    by *Ctrl* + *V*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the **ImageView** copy to the right of the one we just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat this process, placing a third **ImageView** to the left, so that the
    lower half of the layout looks like this:![Designing an XML layout](img/B04321_02_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, open the **Text** view of our layout with the tab at the bottom.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the **Button** node and click on the line that reads `android:text="New
    Button"`. An amber quick fix bulb will appear along with a warning about hardcoding
    strings.![Designing an XML layout](img/B04321_02_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **quick fix** drop-down and select **Extract string resource**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the resultant dialog, provide the **Resource name** as `button_text` and
    click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the file in **Text** view and add this line to the `RelativeLayout` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add this line to the **TextView**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That's it, as far as designing our layout is concerned!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use *Ctrl* + *Alt* + *L* to automatically format any code. *Ctrl* +
    *Alt* + *Shift* + *L* will bring up the reformatting dialog.
  prefs: []
  type: TYPE_NORMAL
- en: All Android layout designs have at their root a container object called a **ViewGroup**,
    in to which all other graphical objects are placed. This includes other ViewGroups,
    although complex layouts with lots of nested ViewGroups can have a negative effect
    on performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ViewGroup widget container we used here was the **RelativeLayout**. There
    are several other types of layout, each being suited to a particular purpose,
    and we will encounter these throughout the book. The RelativeLayout widget container
    we used here allows us to define widget positions relative to other widgets. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is very handy when it comes to designing layouts that will run on screens
    of varying sizes and ratios.
  prefs: []
  type: TYPE_NORMAL
- en: There are three tools at our disposal when it comes to generating layout files.
    We have the (almost) WYSIWYG device preview window, that allows us to position
    and size the widgets, the **Properties** pane which lets us set particular values
    and, perhaps most powerfully, the **Text** edit window which provides control
    over every aspect of our design.
  prefs: []
  type: TYPE_NORMAL
- en: We set the size of our text with `android:attr/textAppearanceMedium`. We could
    have set the size exactly with something like `android:textSize="42sp"`, but using
    `textAppearanceMedium` or `textAppearanceLarge` or `textAppearanceSmall` takes
    into consideration the text settings that the user has configured on their phone.
  prefs: []
  type: TYPE_NORMAL
- en: By far the most important aspect of what we have just done is the fact that
    each widget has an identifier in the form of `android:id="@+id/some_unique_identifier"`.
    These IDs are how we refer to and control widgets during runtime from our Java
    code.
  prefs: []
  type: TYPE_NORMAL
- en: We used the built-in application icon for our **ImageView** controls as a matter
    of convenience, but we could have supplied our own imagery, stored it in the `res(ources)/drawable`
    folder and used its filename (without the extension) as its ID. We will be doing
    a lot of this later, so it is not necessary to worry about it here. If you take
    a look inside the `mipmap` folder, you will see that there are four `ic_launcher`
    icons, for varying screen densities. To achieve high quality icons for all available
    screen densities, you will need to provide all four icons.
  prefs: []
  type: TYPE_NORMAL
- en: When we created the button on our screen, IDE provided the text **New Button**
    for us. Although a hardcoded string like this will work perfectly well, it is
    not recommended, for the reason that you will not be able to provide translations
    into other languages.
  prefs: []
  type: TYPE_NORMAL
- en: With our layout in place, we can now get on with the business of making it do
    something. Here, we will apply some of the new Android 5 animations which work
    when the button is clicked on.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the widget behavior with Java
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Android 5 introduces a new and simpler way of animating screen elements. These
    animations are of most use when transitioning between one screen to another, and
    can be used to intuitively display to the user what the app is doing. This app
    has only one screen (`Activity`), so we will just animate our widgets to fly off
    the screen and then return. Before we start though, we need to configure the IDE
    to automatically import the Java libraries our app will use. Follow these steps
    to see how both tasks are done:'
  prefs: []
  type: TYPE_NORMAL
- en: From the **File Menu** select **Settings** | **Editor** | **General** | **Auto
    Import** and check all boxes as below:![Controlling the widget behavior with Java](img/B04321_02_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `MainActivity.java` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the class, add these fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `onCreate()` method underneath the line `setContentView(R.layout.activity_main);`
    add this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Beneath this, add the code for the `Button` control as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new method called `toggle()` and complete it like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The app can now be tested on an emulator or a connected handset. Click on the
    run icon on the IDE toolbar:![Controlling the widget behavior with Java](img/B04321_02_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Although simple to follow, the code here covers some very important points.
    Firstly, there is the `onCreate()` method. This method is called as soon as the
    Activity is launched, usually with the application icon, and will form the start
    point of almost every Android app you will ever create. The first three lines,
    that were created for us, inflate our layout. We then used `findViewById()`, to
    associate our layout widgets with our Java instances.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that, for convenience, we used the names that the editor suggested here.
    In future, we will use the form `textView` to declare the Java instances and `text_view`
    for the XML counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: We also changed the text inside two of our widgets using the `setText()` method.
    We could have done this from within the XML, but it is very useful to know how
    to do this dynamically with Java.
  prefs: []
  type: TYPE_NORMAL
- en: The `OnClickListener()` interface we attached to our button provides us with
    the `onClick()` method, giving us control over what actions are performed when
    our widgets are clicked on. There was only one button in this Activity, so we
    created an `OnClickListener()` specifically for it. Often, our apps will have
    more than one button or clickable control and, as we will see in the next chapter,
    we can have the Activity itself implement a click listener and then have one `onClick()`
    method to handle all our buttons.
  prefs: []
  type: TYPE_NORMAL
- en: The animation itself is configured and triggered with the `TransitionManager`
    class and we will return to this later in the book. For now, it is worth changing
    the term `Explode()` to `Fade()` or `Slide()`. The effect these changes have will
    not surprise you, but it is useful to know that they are available. Most of the
    time, when we apply animations to our apps, they are for the purpose of demonstrating
    transitions from one Activity to another, rather than being merely for decoration,
    as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: Once you click on the run icon, the build process can be quite slow, particularly
    on older machines. There are, however, one or two handy tools that allow us to
    observe this process. Hover over the small icon in the lower left corner of the
    IDE and select **Gradle Console**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Controlling the widget behavior with Java](img/B04321_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is not necessary to understand the output of the Gradle console, but it is
    reassuring to see that the process has not ground to a halt on longer builds.
    Two other very useful windows that can be accessed in the same manner are the
    **Android** and **Run** windows. These can also be opened from the keyboard with
    *Alt* + *4* and *Alt* + *6* respectively.
  prefs: []
  type: TYPE_NORMAL
- en: If you have spent any time experimenting with the above app, you will have noticed
    that when the emulator or the device is rotated through 90 degrees, one or two
    things do not work as we might hope. Firstly, the animation resets whenever the
    device is rotated. This is because this, along with any other Activity, is reloaded
    whenever the the orientation changes and the `onCreate()` method is called afresh.
    There are, however, several other callback methods that allow us to intercept
    this process. We will be taking a closer look at the Activity life-cycle later
    on, but for now we will explore the second issue, which is the way the system
    positions our text and images in the landscape view.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An AVD can be rotated through 90 degrees by pressing *Ctrl* + *F12*. Pressing
    the home key returns the AVD to its home screen and *Esc* is the same as pressing
    the device's back button.
  prefs: []
  type: TYPE_NORMAL
- en: Creating alternative layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a device running one of our apps is rotated into landscape orientation,
    it refers to the same XML file as it does in portrait mode. Often this works perfectly
    well, but it is incredibly simple to set up an alternative layout that better
    suits the shape of a landscape screen. Follow these steps to create an alternative
    layout file for landscape viewing.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `activity_main.xml` file in **Design** view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the icon in the top-left and select **Create Landscape Variation**.![Creating
    alternative layouts](img/B04321_02_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and rearrange the onscreen widgets to form a more pleasing use of space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select one of the `ImageView` controls. Then click on the amber quick-fix icon.
    It will inform you that the image is missing a `contentDescription`. Click on
    this message and complete the resultant dialog as below:![Creating alternative
    layouts](img/B04321_02_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, run the app on a device or an emulator and check its behavior when
    rotated.![Creating alternative layouts](img/B04321_02_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Including a layout file for landscape orientation is as simple as placing a
    file with the same name and widget IDs in the `res/layout-land` directory instead
    of the `res/layout` directory. This file can then be edited in any way we like
    and will be automatically inflated whenever the screen is rotated to a landscape
    orientation.
  prefs: []
  type: TYPE_NORMAL
- en: As creating alternative layout files is such a quick and simple task, we also
    looked at how to provide alternative output for users with visual impairments
    in the form of content description for images. When a user with a visual impairment
    sets accessibility options and we have provided an appropriate text alternative,
    this description will be read out to the user. For the sake of brevity, we will
    not be adding this description for every exercise in this book, but it is recommended
    that such attributes are included in any apps intended for release.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This concludes our introduction to the relationship between XML layouts and
    Java code. We have seen how to produce layouts for a wide variety of screen sizes
    and orientations and how to connect these XML definitions to a dynamic Java code
    that controls our app's behavior at runtime. Significantly, we have seen how the
    `onCreate()` method is used to set up our app and how it is called whenever a
    device is rotated. We took advantage of this fact by creating an alternative layout,
    designed specifically for a rotated screen.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how to implement the two newest Android
    widgets, the `CardView`, which is a convenient and stylish container for whatever
    information we wish to display, and the `RecyclerView`, which manages the lists
    of `CardView` controls, or other views, in a memory efficient manner.
  prefs: []
  type: TYPE_NORMAL
