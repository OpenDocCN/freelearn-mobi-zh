- en: 'Chapter 5: Managing the State of Your Composable Functions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章：管理你的可组合函数的状态
- en: In [*Chapter 4*](B17505_04_ePub.xhtml#_idTextAnchor076), *Laying Out UI Elements*,
    I showed you how to set the red, green, and blue portions of a color by dragging
    sliders. We used **state** to share these values among composable functions. Quite
    a few other sample apps of the previous chapters dealt with state, too. In fact,
    reacting to state changes is critical to how modern mobile apps work.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 4 章*](B17505_04_ePub.xhtml#_idTextAnchor076)，*布局 UI 元素* 中，我向你展示了如何通过拖动滑块来设置颜色的红色、绿色和蓝色部分。我们使用
    **状态** 在可组合函数之间共享这些值。前几章的许多其他示例应用也处理了状态。事实上，对状态变化的反应是现代移动应用工作方式的关键。
- en: So far, I have described state as data that can change over time. You learned
    about a few important functions, for example, `remember { }` and `mutableStateOf()`.
    I also briefly touched on a concept called **state hoisting**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经描述了状态为随时间变化的数据。你了解了一些重要的函数，例如，`remember { }` 和 `mutableStateOf()`。我还简要提到了一个称为
    **状态提升** 的概念。
- en: This chapter builds on these foundations. For example, you will understand the
    difference between stateless and stateful composables, and when to choose which.
    Also, I will show you how events should flow in a well-behaving Compose app.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章建立在这些基础之上。例如，你将了解无状态和有状态的可组合组件之间的区别，以及何时选择哪一个。此外，我将向你展示在表现良好的 Compose 应用中事件应该如何流动。
- en: 'The main sections of this chapter are the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要部分如下：
- en: Understanding stateful and stateless composable functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解有状态和无状态的可组合函数
- en: Hoisting state and passing events
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提升状态和传递事件
- en: Surviving configuration changes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应对配置更改
- en: We will start by exploring the differences between stateful and stateless composable
    functions. You will learn their typical use cases and understand why you should
    try to keep your composables stateless. Hoisting state is a tool to achieve that;
    we will cover this important topic in the second main section. Also, I will show
    you that you can make your composable functions reusable by passing logic as parameters,
    rather than implementing it inside the composable.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先探讨有状态和无状态的可组合函数之间的区别。你将了解它们的典型用例，并理解为什么你应该尽量保持你的可组合函数无状态。提升状态是一个实现这一目标的工具；我们将在第二主要部分中介绍这个重要主题。此外，我将向你展示你可以通过传递逻辑作为参数来使你的可组合函数可重用，而不是在可组合函数内部实现它。
- en: Finally, the *Surviving configuration changes* section will explore the integration
    of a Compose UI hierarchy in activities, concerning how to retain user input.
    If the user changes from portrait to landscape mode (or vice versa), activities
    are destroyed and recreated. Of course, input should not be lost. We look at several
    ways that a Compose app can achieve this.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*应对配置更改* 部分将探讨在活动中集成 Compose UI 层次结构，关注如何保留用户输入。如果用户从纵向模式切换到横向模式（或反之），活动将被销毁并重新创建。当然，输入信息不应该丢失。我们将探讨
    Compose 应用实现这一点的几种方法。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter includes three sample apps. Please refer to the *Technical requirements*
    section in [*Chapter 1*](B17505_01_ePub.xhtml#_idTextAnchor014), *Building Your
    First Compose App*, for information about how to install and set up Android Studio,
    and how to get them. `StateDemo` contains all examples from the *Understanding
    stateful and stateless composable functions* section. The *Hoisting state and
    passing events* section discusses the `FlowOfEventsDemo` sample. Finally, `ViewModelDemo`
    belongs to the *Surviving configuration changes* section.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含三个示例应用。请参考 [*第 1 章*](B17505_01_ePub.xhtml#_idTextAnchor014)，*构建你的第一个 Compose
    应用*，了解如何安装和设置 Android Studio，以及如何获取它们。`StateDemo` 包含了 *理解有状态和无状态的可组合函数* 部分的所有示例。*提升状态和传递事件*
    部分讨论了 `FlowOfEventsDemo` 示例。最后，`ViewModelDemo` 属于 *应对配置更改* 部分。
- en: All the code files for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_05](https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_05).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码文件都可以在 GitHub 上找到，链接为 [https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_05](https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_05)。
- en: Understanding stateful and stateless composable functions
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解有状态和无状态的可组合函数
- en: 'In this section, I will show you the difference between stateful and stateless
    composable functions. To understand why this is important, let''s first focus
    on the **state** term. In previous chapters, I described state as *data that can
    change over time*. Where the data is held (an SQLite database, a file, or a value
    inside an object) does not matter. What is important is that the UI must always
    show the current data. Therefore, if a value changes, the UI must be notified.
    To achieve this, we use **observable** types. This is not specific to Jetpack
    Compose, but a common pattern in many frameworks, programming languages, and platforms.
    For example, Kotlin supports observables through property delegates:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向您展示有状态和无状态的可组合函数之间的区别。为了理解为什么这很重要，让我们首先关注一下 **状态** 这个词。在之前的章节中，我将状态描述为
    *随时间变化的数据*。数据存储的位置（一个SQLite数据库、一个文件或一个对象内的值）并不重要。重要的是UI必须始终显示当前数据。因此，如果值发生变化，UI必须得到通知。为了实现这一点，我们使用
    **可观察** 类型。这不仅仅局限于Jetpack Compose，而是许多框架、编程语言和平台中的常见模式。例如，Kotlin通过属性委托支持可观察性：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`observable()` returns a delegate for a property that can be read and written
    to. In the previous code snippet, the initial value is set to `-1`. The property
    calls a specified function when its value is changed (`counter = i`). My example
    prints the old and new values. In an imperative UI framework, state changes require
    modifying the component tree. Such code could be put in the callback function.
    Fortunately, Jetpack Compose doesn''t require this, because state changes automatically
    trigger a recomposition of the relevant UI elements. Let''s see how this works.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`observable()` 返回一个可以读取和写入的属性的委托。在上一个代码片段中，初始值被设置为 `-1`。当属性值改变时（`counter =
    i`），该属性会调用一个指定的函数。我的示例会打印出旧值和新值。在一个命令式UI框架中，状态变化需要修改组件树。这样的代码可以放在回调函数中。幸运的是，Jetpack
    Compose不需要这样做，因为状态变化会自动触发相关UI元素的重新组合。让我们看看这是如何工作的。'
- en: The `androidx.compose.runtime.State` base interface defines a value holder,
    an object that stores a value of a particular type in a property named `value`.
    If this property is read during the execution of a composable function, the composable
    will be recomposed whenever `value` changes, because internally the current `RecomposeScope`
    interface will be subscribed to changes of that value. Please note that to be
    able to change the value, state must be an implementation of `MutableState`; unlike
    its immediate predecessor (`State`), this interface defines `value` using `var`
    instead of `val`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`androidx.compose.runtime.State` 基础接口定义了一个值持有者，一个对象，它在名为 `value` 的属性中存储特定类型的值。如果在可组合函数的执行过程中读取该属性，当
    `value` 发生变化时，可组合函数将重新组合，因为内部当前的 `RecomposeScope` 接口将订阅该值的更改。请注意，为了能够更改值，状态必须是
    `MutableState` 的实现；与它的直接前身（`State`）不同，该接口使用 `var` 而不是 `val` 来定义 `value`。'
- en: The easiest way to create `State` instances is to invoke `mutableStateOf()`.
    This function returns a new `MutableState` instance, initialized with the value
    that was passed in. The next section explains how to use `mutableStateOf()` to
    create a stateful composable function.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `State` 实例的最简单方法是调用 `mutableStateOf()`。此函数返回一个新的 `MutableState` 实例，并使用传入的值进行初始化。下一节将解释如何使用
    `mutableStateOf()` 创建有状态的可组合函数。
- en: Using state in a composable function
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在可组合函数中使用状态
- en: 'A composable function is said to be `remember {}`. Let''s take a look:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为 `remember {}` 的可组合函数。让我们看一下：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`SimpleStateDemo1()` creates a mutable state holding a random integer. By invoking
    `remember {}`, we save the state, and in using `=`, we assign it to `num`. We
    get the random number through `num.value`. Please note that although we defined
    `num` with the `val` keyword, we could change the value with `num.value = …`,
    because `num` holds the reference to a mutable value holder (whose `value` property
    is writeable). Think of it as modifying an item in a list, not changing to another
    list. We can slightly alter the code, as shown in the following snippet. Can you
    spot the difference?'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleStateDemo1()` 创建了一个包含随机整数的可变状态。通过调用 `remember {}`，我们保存了状态，并在使用 `=` 时将其分配给
    `num`。我们通过 `num.value` 获取随机数。请注意，尽管我们使用 `val` 关键字定义了 `num`，但我们仍然可以通过 `num.value
    = …` 来更改其值，因为 `num` 持有可变值持有者的引用（其 `value` 属性是可写的）。把它想象成修改列表中的一个项目，而不是改变到另一个列表。我们可以稍微修改一下代码，如下面的代码片段所示。你能发现其中的区别吗？'
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`SimpleStateDemo2()` creates a mutable state holding a random integer number,
    too. Using `by`, we do not assign the state itself to `num` but the value it stores
    (the random number). This spares us from using `.value`, which makes the code
    a little shorter and hopefully more understandable. However, if we want to change
    `num`, we must change `val` to `var`. Otherwise, we see a `Val cannot be reassigned`
    error message.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleStateDemo2()` 创建了一个包含随机整数的可变状态。使用 `by`，我们不是将状态本身赋值给 `num`，而是它存储的值（随机数）。这样我们就可以避免使用
    `.value`，这使得代码更短，也许更容易理解。然而，如果我们想改变 `num`，我们必须将 `val` 改为 `var`。否则，我们会看到一个 `Val
    cannot be reassigned` 错误信息。'
- en: 'You may be wondering what `remember {}` does under the hood. Let''s peek into
    its code and find out:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道 `remember {}` 在底层做了什么。让我们看看它的代码，并找出答案：
- en: '![Figure 5.1 – The source code of remember {}'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.1 – remember {} 的源代码]'
- en: '](img/B17505_05_1.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17505_05_1.jpg]'
- en: Figure 5.1 – The source code of remember {}
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.1 – remember {} 的源代码]'
- en: The read-only, top-level `currentComposer` property belongs to the `androidx.compose.runtime`
    package. It references an instance of `Composer`. This interface is targeted by
    the Compose Kotlin compiler plugin and used by code generation helpers. You should
    not call it directly, because the runtime assumes that calls are generated by
    the compiler and therefore do not contain much validation logic. `Cache()` is
    an extension function of `Composer`. It stores a value in the composition data
    of a composition. So, `remember {}` creates internal state. Therefore, composable
    functions that contain `remember {}` are stateful.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 只读的顶级 `currentComposer` 属性属于 `androidx.compose.runtime` 包。它引用了一个 `Composer`
    实例。这个接口被 Compose Kotlin 编译器插件所针对，并由代码生成助手使用。你不应该直接调用它，因为运行时假设调用是由编译器生成的，因此不包含太多的验证逻辑。"Cache()"
    是 `Composer` 的一个扩展函数。它在组合的数据中存储一个值。因此，`remember {}` 创建了内部状态。因此，包含 `remember {}`
    的组合函数是有状态的。
- en: '`calculation` represents a lambda expression that creates the value to be remembered.
    It is evaluated only once, during the composition. Subsequent calls to `remember
    {}` (during recompositions) always return this value. The expression is not evaluated
    again. But what if we need to reevaluate the calculation, that is, remember a
    new value? After all, isn''t state data that can change over time? Here''s how
    you can do this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculation` 代表一个 lambda 表达式，它创建要记住的值。它只在组合期间评估一次。随后的 `remember {}` 调用（在重新组合期间）总是返回这个值。表达式不会被再次评估。但如果我们需要重新评估计算，即记住一个新的值呢？毕竟，状态数据是可以随时间变化的。下面是如何做到这一点的方法：'
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preview of `RememberWithKeyDemo()` is shown in *Figure 5.2*:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`RememberWithKeyDemo()` 的预览显示在 *图 5.2* 中：'
- en: '![Figure 5.2 – Preview of RememberWithKeyDemo()'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.2 – RememberWithKeyDemo() 的预览]'
- en: '](img/B17505_05_2.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17505_05_2.jpg]'
- en: Figure 5.2 – Preview of RememberWithKeyDemo()
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – RememberWithKeyDemo() 的预览
- en: '`RememberWithKeyDemo()` emits `Column()` with two horizontally centered children:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`RememberWithKeyDemo()` 发射带有两个水平居中子项的 `Column()`。'
- en: '`Text()` shows the string representation of a remembered `Date` instance.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Text()` 显示一个被记住的 `Date` 实例的字符串表示。'
- en: '`Button()` toggles a Boolean value (`key`).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Button()` 切换一个布尔值（`key`）。'
- en: Have you noticed that I pass `key` to `remember { mutableStateOf(Date()) }`?
    Here's what happens – when `remember {}` is invoked for the first time, the result
    of the calculation (`mutableStateOf(Date())`) is remembered and returned. During
    recompositions, the calculation is not reevaluated unless `key` is *not* equal
    to the previous composition. In this case, a new value is calculated, remembered,
    and returned.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到我把 `key` 传递给了 `remember { mutableStateOf(Date()) }`？下面是发生的事情——当 `remember
    {}` 首次被调用时，计算的结果（`mutableStateOf(Date())`）被记住并返回。在重新组合过程中，除非 `key` 与前一次组合不相等，否则不会重新评估计算。在这种情况下，会计算一个新的值，记住并返回。
- en: Tip
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You can pass any number of keys to `remember {}`. If one of them has changed
    since the previous composition, the calculation is reevaluated, and the new value
    is remembered and returned.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向 `remember {}` 传递任意数量的键。如果其中之一自上次组合以来已更改，则计算将被重新评估，新的值将被记住并返回。
- en: Passing keys to `remember {}` allows you to change remembered values. Please
    keep in mind, though, that this makes the composable function less predictable.
    Therefore, you should consider whether such logic needs to be composable or whether
    you could pass all state to it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将键传递给 `remember {}` 允许你更改记住的值。但请记住，这会使组合函数的可预测性降低。因此，你应该考虑是否需要将这种逻辑组合起来，或者是否可以将所有状态传递给它。
- en: In the next section, we turn to stateless composables.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将转向无状态组合。
- en: Writing stateless composable functions
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写无状态组合函数
- en: '`remember {}` makes a composable function stateful. A stateless composable,
    on the other hand, doesn''t hold any state. Here''s an example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`remember {}`使组合函数有状态。另一方面，无状态组合组件不持有任何状态。以下是一个例子：'
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`SimpleStatelessComposable1()` doesn''t receive parameters and it always calls
    `Text()`with the same parameters. Clearly, it doesn''t hold any state. But how
    about the following one?'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleStatelessComposable1()`不接收参数，并且总是以相同的参数调用`Text()`。显然，它不持有任何状态。但以下一个如何？'
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'While it receives state through the `text` parameter, it doesn''t store it,
    and it doesn''t remember other state. Consequently, `SimpleStatelessComposable2()`
    is stateless, too. It behaves the same way when called with the same argument
    multiple times. Such functions are said to be `SimpleStatelessComposable2()` a
    good blueprint for your own composable functions. They should be as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它通过`text`参数接收状态，但它不存储它，也不记住其他状态。因此，`SimpleStatelessComposable2()`也是无状态的。当多次用相同的参数调用时，它的行为也是一样的。这样的函数被称为`SimpleStatelessComposable2()`是你自己的组合函数的好蓝图。它们应该如下所示：
- en: '**Fast**: Your composable must not do heavy (that is, time-consuming) computations.
    Never invoke a web service or do any other I/O. Data that is used by a composable
    should be passed to it.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速**：你的组合组件不得进行重（即耗时）的计算。永远不要调用网络服务或执行任何其他I/O操作。组合组件使用的任何数据都应该传递给它。'
- en: '**Free of side-effects**: Do not modify global properties or produce unintended
    observable effects (modifying state that has been passed to a composable is certainly
    intentional).'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无副作用**：不要修改全局属性或产生意外的可观察效果（修改传递给组合组件的状态当然是故意的）。'
- en: '`remember {}`, do not access global properties, and do not call unpredictable
    code. For example, `SimpleStateDemo1()` and `SimpleStateDemo2()` use `Random.nextInt()`,
    which, by definition, is (practically) not predictable.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remember {}`，不要访问全局属性，也不要调用不可预测的代码。例如，`SimpleStateDemo1()`和`SimpleStateDemo2()`使用`Random.nextInt()`，根据定义，它是（实际上）不可预测的。'
- en: Such composable functions are both easy to reuse and test because they don't
    rely on anything that isn't passed in as parameters.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的组合函数既容易重用又容易测试，因为它们不依赖于作为参数传递之外的东西。
- en: 'When developing reusable composables, you may want to expose both a stateful
    and a stateless version. Let''s see how this looks:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发可重用的组合组件时，你可能希望公开有状态和无状态的版本。让我们看看这看起来是什么样子：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This version is stateless because it receives state and does not remember anything.
    Stateless versions are necessary for callers that need to control the state or
    hoist it themselves:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本是无状态的，因为它接收状态但不记住任何东西。无状态版本对于需要控制状态或自己提升状态的调用者来说是必要的：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This version is stateful because it remembers the state it creates. Stateful
    versions are convenient for callers that don't care about the state.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本是有状态的，因为它记得它创建的状态。有状态版本对于不关心状态的调用者来说很方便。
- en: To conclude, try to make your composables stateless by not relying on `remember
    {}` or other functions that remember state (for example, `rememberLazyListState()`
    or `rememberSaveable()`). Instead, pass state to the composable. You will see
    more use cases in the next section.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，尽量通过不依赖`remember {}`或其他记住状态的功能（例如，`rememberLazyListState()`或`rememberSaveable()`）来使你的组合组件无状态。相反，将状态传递给组合组件。你将在下一节中看到更多用例。
- en: Hoisting state and passing events
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升状态和传递事件
- en: So, state is any value that can change over time. As Jetpack Compose is a declarative
    UI framework, the only way to update a composable is to call it with new arguments.
    This happens automatically when state a composable is using changes. State hoisting
    is a pattern of moving state up to make a composable stateless.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，状态是任何随时间变化的价值。由于Jetpack Compose是一个声明式UI框架，更新组合组件的唯一方法是使用新的参数调用它。当组合组件使用的状态发生变化时，这会自动发生。状态提升是一种将状态向上移动以使组合组件无状态的模式。
- en: Besides making a composable more easily reusable and testable, moving state
    up is necessary to use it in more than one composable function. You have already
    seen this in quite a few of my sample apps. For example, in the *Composing and
    recomposing the UI* section of [*Chapter 3*](B17505_03_ePub.xhtml#_idTextAnchor054),
    *Exploring the Key Principles of Compose*, we used three sliders to create and
    display a color.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使组合组件更容易重用和测试外，将状态向上移动对于在多个组合函数中使用它是必要的。你已经在我的许多示例应用中看到了这一点。例如，在[*第3章*](B17505_03_ePub.xhtml#_idTextAnchor054)的“组合和重新组合UI”部分，我们使用三个滑块创建和显示一个颜色。
- en: 'While state controls the visual representation of a composable function (that
    is, how it looks on screen), `FlowOfEventsDemo` app is a simple temperature converter.
    The user enters a value, specifies whether it represents degrees Celsius or Fahrenheit,
    and then hits the **Convert** button:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当状态控制组合函数的视觉表示（即它在屏幕上的外观）时，`FlowOfEventsDemo` 应用是一个简单的温度转换器。用户输入一个值，指定它代表摄氏度还是华氏度，然后点击
    **转换** 按钮：
- en: '![Figure 5.3 – Sample FlowOfEventsDemo app'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.3 – 示例 FlowOfEventsDemo 应用'
- en: '](img/B17505_05_3.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17505_05_3.jpg)'
- en: Figure 5.3 – Sample FlowOfEventsDemo app
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 示例 FlowOfEventsDemo 应用
- en: 'The UI consists of `Column()` with four children: a text input field, a group
    of radio buttons with text, a button, and some result text. Let''s look at the
    text input field first:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: UI 由 `Column()` 组成，包含四个子元素：一个文本输入字段、一组带文本的单选按钮、一个按钮和一些结果文本。让我们首先看看文本输入字段：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It receives `MutableState<String>`, to which it pushes changes to the text in
    `onValueChange {}`. The virtual keyboard is configured to show a *Done* button.
    If it is invoked, code passed to the composable through `callback` is executed.
    As you will see a little later, that same code will run if the user clicks on
    the *Convert* button.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 它接收 `MutableState<String>`，在 `onValueChange {}` 中向其中推送文本更改。虚拟键盘配置为显示 *完成* 按钮。如果它被调用，通过
    `callback` 传递给组合函数的代码将被执行。您稍后将会看到，如果用户点击 *转换* 按钮，相同的代码也会运行。
- en: In the next section, I'll show you how to create radio buttons and put them
    in groups so that only one button is selected at a time. The section also covers
    the button and the result text, which you can see in *Fig. 5.3*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将向您展示如何创建单选按钮并将它们分组，以便每次只能选择一个按钮。本节还涵盖了按钮和结果文本，您可以在 *图 5.3* 中看到。
- en: Creating radio button groups
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建单选按钮组
- en: 'The app converts between degrees Celsius and Fahrenheit. Therefore, the user
    must choose the target scale. Such selections can be implemented easily in Jetpack
    Compose using `androidx.compose.material.RadioButton()`. This composable doesn''t
    show some descriptive text, but it is easy to add some. Here''s how:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用在摄氏度和华氏度之间进行转换。因此，用户必须选择目标刻度。此类选择可以很容易地在 Jetpack Compose 中使用 `androidx.compose.material.RadioButton()`
    实现。这个组合函数不显示一些描述性文本，但很容易添加。下面是如何做的：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`RadioButton()` and `Text()` are simply added to `Row()` and vertically centered.
    `TemperatureRadioButton()` receives a lambda expression with the `onClick` parameter.
    That code is executed when the radio button is clicked. My implementation passes
    the `resId` parameter to the lambda expression, which will be used to determine
    the button in a group. Here''s how:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`RadioButton()` 和 `Text()` 简单地添加到 `Row()` 中并垂直居中。`TemperatureRadioButton()`
    接收一个带有 `onClick` 参数的 lambda 表达式。当单选按钮被点击时，将执行该代码。我的实现将 `resId` 参数传递给 lambda 表达式，该表达式将用于确定组中的按钮。下面是如何做的：'
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Two `TemperatureRadioButton()` are put in a `Row()`. The first one is configured
    to represent degrees Celsius, the second one degrees Fahrenheit. Both receive
    the same `onClick` lambda. It sets the `resId` parameter it received from `TemperatureRadioButton()`
    as the new value of the `selected` parameter, a mutable state. So, what is happening
    here? Clicks on a radio button are not handled inside `TemperatureRadioButton()`
    but passed to the parent, `TemperatureScaleButtonGroup()`. The event, a button
    click, is said to **bubble up**. This way, the parent can orchestrate its children
    and notify its parent. In my example, this means changing some state.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 `TemperatureRadioButton()` 被放入一个 `Row()` 中。第一个配置为表示摄氏度，第二个表示华氏度。两者都接收相同的
    `onClick` lambda。它将 `TemperatureRadioButton()` 接收到的 `resId` 参数设置为 `selected` 参数的新值，这是一个可变状态。那么这里发生了什么？单选按钮的点击不是在
    `TemperatureRadioButton()` 内部处理，而是传递给父元素 `TemperatureScaleButtonGroup()`。事件，即按钮点击，被称为
    **冒泡**。这样，父元素可以协调其子元素并通知其父元素。在我的例子中，这意味着改变一些状态。
- en: 'Next, let''s see what happens when the user clicks the `FlowOfEventsDemo()`.
    Here''s the overall structure of this composable function:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看当用户点击 `FlowOfEventsDemo()` 时会发生什么。以下是这个组合函数的整体结构：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The conversion logic is assigned to a read-only variable called `calc`. It is
    passed to `TemperatureTextField()` and `Button()`. Passing the code that is going
    to be executed in response to an event to a composable function rather than hard
    coding it inside makes the composable more easily reusable and testable.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 转换逻辑被分配给一个名为 `calc` 的只读变量。它被传递给 `TemperatureTextField()` 和 `Button()`。将响应事件的代码传递给组合函数而不是在内部硬编码，使得组合函数更容易重用和测试。
- en: The text that is displayed after conversion is remembered and assigned to `result`.
    It is re-evaluated when `convertedTemperature` changes. This happens inside the
    `calc` lambda expression. Please note that I need to pass a key to `remember {}`;
    otherwise, the result would be changed also if the user picks another scale.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 转换后显示的文本会被记住并分配给 `result`。当 `convertedTemperature` 发生变化时，它会重新评估。这发生在 `calc`
    lambda 表达式内部。请注意，我需要向 `remember {}` 传递一个键；否则，如果用户选择了另一个刻度，结果也会改变。
- en: In the next section, we will look at how state can be persisted. To be more
    precise, we turn to configuration changes. If the user rotates a device, the UI
    should not be reset. Unfortunately, this is what happens with all sample apps
    I have shown you so far. It's time to fix this.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何持久化状态。更准确地说，我们将转向配置更改。如果用户旋转设备，UI 不应该被重置。不幸的是，到目前为止我所展示的所有示例应用都是这样做的。是时候解决这个问题了。
- en: Surviving configuration changes
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适应配置更改
- en: Please recall that our definition of state as data that may change over time
    is quite broad. For example, we do not specify where the data is stored. If it
    resides in a database, a file, or some backend in the cloud, the app should include
    a dedicated persistence layer. However, until Google introduced the Android Architecture
    Components back in 2017, there had been practically no guidance for developers
    on how to structure their apps. Consequently, persistence code, UI logic, and
    domain logic were often crammed into one activity. Such code was difficult to
    maintain and often prone to errors. To make matters a little more complicated,
    there are situations when an activity is destroyed and recreated shortly after.
    For example, this happens when a user rotates a device. Certainly, data should
    then be remembered.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们关于状态的定义——即可能随时间变化的数据——相当广泛。例如，我们没有指定数据存储的位置。如果它位于数据库、文件或云中的某个后端，则应用应包含一个专门的持久化层。然而，直到
    2017 年 Google 引入了 Android 架构组件，开发者实际上没有关于如何构建应用的指导。因此，持久化代码、UI 逻辑和领域逻辑通常被挤在一个活动中。这样的代码难以维护，并且往往容易出错。更复杂的是，当活动被销毁并在不久后重新创建时，会出现这种情况。例如，当用户旋转设备时就会发生这种情况。当然，数据应该被记住。
- en: The `Activity` class has a few methods to handle this. For example, `onSaveInstanceState()`
    is invoked when the activity is (temporarily) destroyed. Its counterpart `onRestoreInstanceState()`
    method is called only when such an instance state has been saved before. Both
    methods receive an instance of `Bundle`, which has getters and setters for various
    data types. However, the concept of instance state has been designed for the traditional
    view system. Most activities held references to UI elements and therefore could
    be accessed easily inside `onSaveInstanceState()` and `onRestoreInstanceState()`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Activity` 类有几个方法来处理这种情况。例如，当活动（暂时）被销毁时，会调用 `onSaveInstanceState()` 方法。它的对应方法
    `onRestoreInstanceState()` 只在之前已经保存了实例状态时被调用。这两个方法都接收一个 `Bundle` 实例，它为各种数据类型提供了获取器和设置器。然而，实例状态的概念是为传统的视图系统设计的。大多数活动持有
    UI 元素的引用，因此可以在 `onSaveInstanceState()` 和 `onRestoreInstanceState()` 中轻松访问。'
- en: 'Composables, on the other hand, are usually implemented as top-level functions.
    So, how can their state be set or queried from inside an activity? To temporarily
    save state in a Compose app, you can use `rememberSaveable {}`. This composable
    function remembers the value produced by a factory function. It behaves similarly
    to `remember {}`. The stored value will survive the activity or process recreation.
    Internally, the `savedInstanceState` mechanism is used. The sample `ViewModelDemo`
    app shows how to use `rememberSaveable {}`. Here''s what the main activity looks
    like:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，可组合项通常被实现为顶级函数。那么，如何在活动中设置或查询它们的状态呢？为了在 Compose 应用中临时保存状态，你可以使用 `rememberSaveable
    {}`。这个可组合函数会记住由工厂函数产生的值。它的行为类似于 `remember {}`。存储的值将存活于活动或进程的重创。内部，使用了 `savedInstanceState`
    机制。示例 `ViewModelDemo` 应用展示了如何使用 `rememberSaveable {}`。以下是主活动的外观：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We don''t need to override `onSaveInstanceState()` to temporarily save our
    state used with composables:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要重写 `onSaveInstanceState()` 来临时保存与可组合项一起使用的状态：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The app shows three text input fields that receive their values from states
    assigned to `state1`, `state2`, and `state3`. For now, we will focus on the first
    two. `state3` will be the subject of the *Using ViewModel* section. `state1` invokes
    `remember {}`, whereas `state2` uses `rememberSaveable {}`. If you ran `ViewModelDemo`,
    changed the content of the text input fields, and rotated the device, the first
    one would be reset to the original text, whereas the second one would keep your
    changes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序显示了三个文本输入字段，它们从分配给 `state1`、`state2` 和 `state3` 的状态接收值。现在，我们将专注于前两个。`state3`
    将是 *使用 ViewModel* 部分的主题。`state1` 调用 `remember {}`，而 `state2` 使用 `rememberSaveable
    {}`。如果您运行了 `ViewModelDemo`，更改了文本输入字段的内容，并旋转了设备，第一个将重置为原始文本，而第二个将保留您的更改。
- en: '`MyTextField` is a very simple composable. It looks like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyTextField` 是一个非常简单的可组合组件。它看起来像这样：'
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Have you noticed that `value` is of `State<String?>`? Why would I need a value
    holder whose value can be `null`, and therefore need to check with `value.value?.let
    {}` that it isn't? We will be reusing the composable in the following section,
    and you will find the answer to this question there. Please note, though, that
    for both `state1` and `state2`, this would not have been necessary.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您注意到 `value` 是 `State<String?>` 类型吗？为什么我需要一个其值可以是 `null` 的值持有者，因此需要使用 `value.value?.let
    {}` 来检查它不是 `null`？我们将在下一节中重用这个可组合组件，您将在那里找到这个问题的答案。请注意，尽管如此，对于 `state1` 和 `state2`，这并不是必要的。
- en: Using ViewModel
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ViewModel
- en: While temporarily storing state with `rememberSaveable {}` works great, an app
    still must get data that is persisted for a longer time (for example, in a database
    or file) and make it available as state that can be used in composables. The Android
    Architecture Components include `ViewModel` and `LiveData`. Both can be used seamlessly
    with Jetpack Compose.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `rememberSaveable {}` 在临时存储状态时效果很好，但应用程序仍然必须获取持久化时间较长的数据（例如，在数据库或文件中），并将其作为可以在可组合组件中使用的状态提供。Android
    架构组件包括 `ViewModel` 和 `LiveData`。两者都可以与 Jetpack Compose 无缝使用。
- en: 'First, you need to add a few implementation dependencies to the module-level
    `build.gradle` file:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要将一些实现依赖项添加到模块级别的 `build.gradle` 文件中：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The next step is to define a `ViewModel` class. It extends `androidx.lifecycle.ViewModel`.
    A `ViewModel` class stores and manages UI-related data in a lifecycle-conscious
    way. This means that data will survive configuration changes, such as screen rotations.
    `MyViewModel` exposes one property called `text` and a method named `setText()`
    to set it:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定义一个 `ViewModel` 类。它扩展了 `androidx.lifecycle.ViewModel`。`ViewModel` 类以生命周期感知的方式存储和管理与
    UI 相关的数据。这意味着数据将生存配置更改，例如屏幕旋转。`MyViewModel` 公开一个名为 `text` 的属性和一个名为 `setText()`
    的方法来设置它：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: My example shows a `ViewModel` class using `LiveData`. Depending on the architecture
    of an app, you can utilize other mechanisms for working with observable data.
    Going into more detail is, however, beyond the scope of this book. You can find
    additional information in *Guide to app architecture* at [https://developer.android.com/jetpack/guide](https://developer.android.com/jetpack/guide#fetching_data).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我的示例显示了一个使用 `LiveData` 的 `ViewModel` 类。根据应用程序的架构，您可以使用其他机制来处理可观察数据。然而，更详细的介绍超出了本书的范围。您可以在
    *应用程序架构指南* 中找到更多信息，网址为 [https://developer.android.com/jetpack/guide](https://developer.android.com/jetpack/guide#fetching_data)。
- en: 'To access the `ViewModel` class from inside a composable function, we invoke
    the composable `viewModel()`. It belongs to the `androidx.lifecycle.viewmodel.compose`
    package:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要从可组合函数内部访问 `ViewModel` 类，我们调用 `viewModel()` 可组合函数。它属于 `androidx.lifecycle.viewmodel.compose`
    包：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`LiveData` is made available as state like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`LiveData` 以如下状态提供：'
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s take a quick look at its source code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下它的源代码：
- en: '![Figure 5.4 – Source code of the observeAsState() extension function'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.4 – observeAsState() 扩展函数的源代码'
- en: '](img/B17505_05_4.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17505_05_4.jpg](img/B17505_05_4.jpg)'
- en: Figure 5.4 – Source code of the observeAsState() extension function
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – observeAsState() 扩展函数的源代码
- en: '`observeAsState()` is an extension function of `LiveData`. It passes the `value`
    property of its `LiveData` instance to a variant of `observeAsState()` that takes
    parameters. Have you noticed that the return type is `State<T?>`? That is why
    I defined `MyTextField()` in the previous section to receive `State<String?>`.
    To be able to use `State<String>` as with `remember {}` and `rememberSaveable
    {}`, we would need to define `state3` like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`observeAsState()` 是 `LiveData` 的一个扩展函数。它将 `LiveData` 实例的 `value` 属性传递给一个接受参数的
    `observeAsState()` 变体。你注意到返回类型是 `State<T?>` 吗？这就是为什么我在上一节中定义了 `MyTextField()`
    来接收 `State<String?>` 的原因。为了能够像使用 `remember {}` 和 `rememberSaveable {}` 一样使用 `State<String>`，我们需要像这样定义
    `state3`：'
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In my opinion, this is less favorable than using `State<String?>` because we
    use an unchecked cast.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，这不如使用 `State<String?>` 有利，因为我们使用了一个未经检查的类型转换。
- en: 'To reflect changes in state in the `ViewModel` class, we need code like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 `ViewModel` 类中反映状态的变化，我们需要像这样的代码：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Unlike using `MutableState`, we must explicitly invoke the `setText()` method
    of `MyViewModel` and pass the changed text.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用 `MutableState` 不同，我们必须显式调用 `MyViewModel` 的 `setText()` 方法并传递更改后的文本。
- en: To conclude, `rememberSaveable {}` is simple and easy to use. For more complex
    scenarios than presented in this chapter, you can provide `androidx.compose.runtime.saveable.Saver`
    implementations, which make your data objects simpler and convert them to something
    saveable. Bigger apps should use `ViewModel` classes, as recommended for quite
    a while now by Google. The combination of `ViewModel` and `LiveData` classes can
    be integrated nicely into composable apps using `observerAsState()`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`rememberSaveable {}` 简单易用。对于比本章所展示的更复杂的场景，你可以提供 `androidx.compose.runtime.saveable.Saver`
    实现，这将使你的数据对象更简单，并将它们转换为可保存的内容。较大的应用程序应使用 Google 建议已久的 `ViewModel` 类。`ViewModel`
    和 `LiveData` 类的组合可以很好地集成到使用 `observerAsState()` 的可组合应用程序中。
- en: Summary
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter aimed to give a more detailed look at state in Compose apps. We
    started by exploring the differences between stateful and stateless composable
    functions. You learned their typical use cases and why you should try to keep
    your composables stateless. Hoisting state is a tool to achieve that. We covered
    this important topic in the second main section. I also showed you that you can
    make your composable functions more reusable by passing logic as parameters, rather
    than implementing it inside the composable. The previous section explored the
    integration of a Compose UI hierarchy in activities concerning how to retain user
    input. We looked at the differences between `remember {}` and `rememberSaveable
    {}`, and I gave you a glimpse of how bigger Compose apps can benefit from `ViewModel`
    classes.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在更详细地探讨 Compose 应用程序中的状态。我们首先探讨了有状态和无状态的可组合函数之间的区别。你学习了它们的典型用例以及为什么你应该尽量保持你的可组合函数无状态。提升状态是一个实现这一目标的工具。我们在第二个主要部分中涵盖了这一重要主题。我还向你展示了你可以通过传递参数而不是在可组合函数内部实现逻辑来使你的可组合函数更具可重用性。上一节探讨了将
    Compose UI 层次集成到活动中的整合，关注了如何保留用户输入。我们研究了 `remember {}` 和 `rememberSaveable {}`
    之间的区别，并给你展示了较大的 Compose 应用程序如何从 `ViewModel` 类中受益。
- en: Chapters 1 to 5 introduced you to various aspects of Jetpack Compose, such as
    composable functions, state, and layout. [*Chapter 6*](B17505_06_ePub.xhtml#_idTextAnchor105),
    *Putting Pieces Together*, focuses on one app, providing you with a bigger picture
    of how these pieces work together to form a real-world app. We will implement
    a simple unit converter app, focusing on app architecture and UI, including theming
    and navigation.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第1章到第5章介绍了 Jetpack Compose 的各个方面，如可组合函数、状态和布局。[*第6章*](B17505_06_ePub.xhtml#_idTextAnchor105)，*整合组件*，专注于一个应用程序，为你提供了一个更全面的视角，了解这些组件如何协同工作以形成一个真实世界的应用程序。我们将实现一个简单的单位转换应用程序，重点关注应用程序架构和
    UI，包括主题和导航。
