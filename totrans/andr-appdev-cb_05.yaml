- en: Chapter 5. Exploring Fragments, AppWidgets, and the System UI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 探索Fragment、AppWidget和系统UI
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating and using a Fragment
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用Fragment
- en: Adding and removing Fragments during runtime
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时添加和删除Fragment
- en: Passing data between Fragments
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Fragment之间传递数据
- en: Creating a shortcut on the Home screen
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主屏幕上创建快捷方式
- en: Creating a Home screen widget
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建主屏幕小工具
- en: Adding Search to the Action Bar
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向ActionBar添加搜索功能
- en: Showing your app full screen
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全屏显示你的应用
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: With a firm understanding of layouts from [Chapter 2](ch02.html "Chapter 2. Layouts"),
    *Layouts*, we'll dig deeper into UI development with Fragments. Fragments are
    a way to separate your UI into smaller sections that can easily be reused. Think
    of Fragments as mini-activities, complete with their own classes, layouts, and
    lifecycle. Instead of designing your screen in one Activity Layout, possibly duplicating
    functionality across multiple layouts, you can break the screen into smaller,
    logical sections and turn them in to Fragments. Your Activity Layout can then
    reference one or multiple Fragments, as needed. The first three recipes will explore
    Fragments in-depth.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在对[第2章](ch02.html "第2章。布局")中的布局有牢固理解的基础上，*布局*，我们将深入探讨使用Fragment的UI开发。Fragment是一种将UI分割成更小部分的方法，这些部分可以轻松重用。将Fragment视为迷你活动，它们有自己的类、布局和生命周期。您不必在一个Activity
    Layout中设计整个屏幕，可能还会在多个布局中重复功能，而是可以将屏幕分割成更小、更逻辑的部分，并将它们转换为Fragment。根据需要，您的Activity
    Layout可以引用一个或多个Fragment。前三个菜谱将深入探讨Fragment。
- en: With an understanding of Fragments, we're ready to expand on our discussion
    of Widgets. In [Chapter 3](ch03.html "Chapter 3. Views, Widgets, and Styles"),
    *Views, Widgets, and Styles*, we discussed how to add widgets to your own app.
    Now, we'll look at how to create an App Widget so users can put their app on their
    Home screen.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解Fragment的基础上，我们准备扩展对Widgets的讨论。在[第3章](ch03.html "第3章。视图、小工具和样式")，*视图、小工具和样式*中，我们讨论了如何向您的应用添加小工具。现在，我们将探讨如何创建App
    Widget，以便用户可以将他们的应用放在主屏幕上。
- en: The last recipes of the chapter will explore System UI options. We have a recipe
    for adding a `Search` option to the Action Bar using the Android `SearchManager`
    API. The last recipe shows Full Screen mode and several additional variations
    of altering the System UI.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后几节将探索系统UI选项。我们有一个菜谱，使用Android的`SearchManager` API向ActionBar添加`搜索`选项。最后一个菜谱展示了全屏模式以及改变系统UI的几种额外变体。
- en: Creating and using a Fragment
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和使用Fragment
- en: Android didn't always support Fragments. The early versions of Android were
    designed for phones, when screens had relatively small displays. It wasn't until
    Android started being used on tablets that there was a need to split the screen
    into smaller sections. Android 3.0 introduced the `Fragments` class and the Fragment
    Manager.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Android并非始终支持Fragment。Android的早期版本是为手机设计的，当时屏幕相对较小。直到Android开始在平板电脑上使用时，才需要将屏幕分割成更小的部分。Android
    3.0引入了`Fragments`类和Fragment Manager。
- en: Along with a new class, also came the Fragment Lifecycle. The Fragment Lifecycle
    is similar to the Activity Lifecycle introduced in [Chapter 1](ch01.html "Chapter 1. Activities"),
    *Activities*, as most events parallel the Activity Lifecycle.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新类一起到来的还有Fragment生命周期。Fragment生命周期与在[第1章](ch01.html "第1章。活动")中引入的活动生命周期相似，*活动*，因为大多数事件都与活动生命周期并行。
- en: 'Here''s a brief overview of the main callbacks:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是主要回调的简要概述：
- en: '`onAttach()`: It''s called when the Fragment is associated with an Activity.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onAttach()`: 当Fragment与Activity关联时被调用。'
- en: '`onCreate()`: It''s called when the Fragment is first created.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCreate()`: 当Fragment首次创建时被调用。'
- en: '`onCreateView()`: It''s called when the Fragment is about to be displayed for
    the first time.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCreateView()`: 当Fragment即将首次显示时被调用。'
- en: '`onActivityCreated()`: It''s called when the associated Activity is created.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onActivityCreated()`: 当相关Activity被创建时被调用。'
- en: '`onStart()`: It''s called when the Fragment will become visible to the user.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onStart()`: 当Fragment将变为用户可见时被调用。'
- en: '`onResume()`: It''s called just before a Fragment is displayed.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onResume()`: 它在Fragment显示之前被调用。'
- en: '`onPause()`: It''s called when the Fragment is first suspended. The user may
    return to the Fragment, but this is where you should persist any user data.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPause()`: 当Fragment首次暂停时被调用。用户可能会返回到Fragment，但这是你应该持久化任何用户数据的地方。'
- en: '`onStop()`: It''s called when the Fragment is no longer visible to the user.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onStop()`: 当Fragment不再对用户可见时被调用。'
- en: '`onDestroyView()`: It''s called to allow final cleanup.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onDetach()`: It''s called when the Fragment is no longer associated with the
    Activity.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For our first exercise, we will create a new Fragment derived from the standard
    `Fragment` class. But there are several other `Fragment` classes we could derive
    from, including:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '`DialogFragment`: It''s used for creating a floating dialog'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListFragment`: It''s creates a `ListView` in a Fragment, similar to the `ListActivity`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PreferenceFragment`: It''s creates a list of Preference objects, commonly
    used for a Settings page'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we will walk through creating a basic Fragment derived from
    the `Fragment` class and include it in an Activity Layout.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new project in Android Studio and call it: `CreateFragment`. Use the
    default **Phone & Tablet** options and select the **Empty Activity** option when
    prompted for the Activity Type.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will create a new `Fragment` class with an accompanying
    layout file. We will then add the Fragment to the Activity Layout so it will be
    visible when the Activity starts. Here are the steps to create and display a new
    Fragment:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new layout called `fragment_one.xml` using the following XML:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a new Java file called `FragmentOne` with the following code:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Open the `main_activity.xml` file and replace the existing `<TextView>` element
    with the following `<fragment>` element:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run the program on a device or emulator.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start by creating a new class, the same as we do for an Activity. In this
    recipe, we only create an overwrite for the `onCreateView()` method to load our
    Fragment layout. But, just like with the Activity events, we can override the
    other events as we need them. Once the new Fragment is created, we then add it
    to the Activity Layout. Since the `Activity` class was created before `Fragments`
    existed, they do not support `Fragments`. If we were using pure framework classes,
    we would want to use `FragmentActivity` instead. If you used the Android Studio
    New Project Wizard, then by default the `MainActivity` extends `AppCompatActivity`,
    which already includes support for Fragments.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're only creating a single, simple Fragment in this recipe to teach the fundamentals
    of Fragments. But this is a good time to point out the power of Fragments. If
    we are creating multiple Fragments (and usually we are, as that's the point of
    using Fragments), when creating the Activity Layouts as we did in Step 4, we could
    create different layout configurations using the Android Resource Folders. The
    portrait layout may have only a single Fragment while the landscape may have two
    or more.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Adding and removing Fragments during runtime
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Defining a Fragment in the layout, as we did in the previous recipe, is known
    as a static Fragment and cannot be changed during runtime. Rather than using the
    `<fragment>` element, we will create a container to hold the Fragment, then create
    the Fragment dynamically in the Activity's `onCreate()` method.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在布局中定义片段，就像我们在前面的菜谱中所做的那样，被称为静态片段，在运行时无法更改。我们不会使用`<fragment>`元素，而是创建一个容器来容纳片段，然后在Activity的`onCreate()`方法中动态创建片段。
- en: 'The `FragmentManager` provides the APIs for adding, removing, and changing
    Fragments during runtime using a `FragmentTransaction`. A Fragment transaction
    consists of:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`FragmentManager`提供了在运行时使用`FragmentTransaction`添加、删除和更改片段的API。一个片段事务包括：'
- en: Starting a transaction
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始事务
- en: Performing one or multiple actions
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行一个或多个操作
- en: Committing the transaction
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交事务
- en: This recipe will demonstrate the `FragmentManager` by adding and removing Fragments
    during runtime.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将通过在运行时添加和删除片段来演示`FragmentManager`。
- en: Getting ready
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a new project in Android Studio and call it: `RuntimeFragments`. Use
    the default **Phone & Tablet** options and select the **Empty Activity** option
    when prompted for the **Activity Type**.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新的项目，命名为：`RuntimeFragments`。使用默认的**手机和平板**选项，并在提示**活动类型**时选择**空活动**选项。
- en: How to do it...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To demonstrate adding and removing Fragments, we first need to create the Fragments,
    which we will do be extending the `Fragment` class. After creating the new Fragments,
    we need to alter the layout for the Main Activity to include the `Fragment` container.
    From there, we just add the code to handle the Fragment transactions. Here are
    the steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示添加和删除片段，我们首先需要创建片段，我们将通过扩展`Fragment`类来实现。在创建了新的片段之后，我们需要修改主活动的布局以包含`Fragment`容器。从那里，我们只需添加处理片段事务的代码。以下是步骤：
- en: 'Create a new layout file called `fragment_one.xml` and include the following
    XML:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`fragment_one.xml`的新布局文件，并包含以下XML：
- en: '[PRE3]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The second layout file called `fragment_two.xml` is almost identical, with
    the only difference being the text:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个布局文件`fragment_two.xml`几乎与它完全相同，唯一的区别是文本：
- en: '[PRE4]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create a new Java file called `FragmentOne` with the following code:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`FragmentOne`的新Java文件，并包含以下代码：
- en: '[PRE5]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Import from the following library:'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从以下库导入：
- en: '[PRE6]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create the second Java file called `FragmentTwo` with the following code:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个Java文件，命名为`FragmentTwo`，并包含以下代码：
- en: '[PRE7]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Import from the following library:'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从以下库导入：
- en: '[PRE8]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we need to add a container and a button to the Main Activity layout. Change
    `main_activity.xml` as follows:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要在主活动布局中添加一个容器和一个按钮。按照以下方式更改`main_activity.xml`：
- en: '[PRE9]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With the Fragments created and the container added to the layout, we are now
    ready to write the code to manipulate the Fragments. Open `MainActivity.java`
    and add the following code below the class constructor:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建了片段并将容器添加到布局中之后，我们现在可以编写操作片段的代码。打开`MainActivity.java`文件，并在类构造函数下方添加以下代码：
- en: '[PRE10]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following code to the existing `onCreate()` method, below `setContentView()`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现有的`onCreate()`方法中，在`setContentView()`下方添加以下代码：
- en: '[PRE11]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Import from the following libraries:'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从以下库导入：
- en: '[PRE12]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The last code we need to add handles the Fragment switching, called by the
    button:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后需要添加的代码处理了片段切换，由按钮调用：
- en: '[PRE13]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Run the program on a device or emulator.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行程序。
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Most of the steps for this recipe involve setting up the Fragments. Once the
    Fragments are declared, we create them in the `onCreate()` method. Though the
    code can be condensed to a single line, it's shown in the long form as it makes
    it easier to read and understand.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的大部分步骤都涉及设置片段。一旦片段被声明，我们就在`onCreate()`方法中创建它们。尽管代码可以压缩成一行，但为了便于阅读和理解，这里以长形式展示。
- en: First, we get the `FragmentManager` so we can begin a `FragmentTransaction`.
    Once we have a `FragmentTransaction`, we start the transaction with `beginTransaction()`.
    Multiple actions can occur within the transaction, but all we need here is to
    `add()` our initial Fragment. We call the `commit()` method to finalize the transaction.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取`FragmentManager`以便开始一个`FragmentTransaction`。一旦我们有了`FragmentTransaction`，我们就通过调用`beginTransaction()`开始事务。事务中可以发生多个操作，但这里我们只需要`add()`我们的初始片段。我们调用`commit()`方法来最终确定事务。
- en: 'Now that you understand the Fragment transaction, here is the succinct version
    for `onCreate()`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了片段事务，以下是`onCreate()`方法的简洁版本：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`switchFragment` does basically the same type of Fragment transaction. Instead
    of calling the `add()` method, we call the `replace()` method with the existing
    Fragment. We keep track of the current Fragment with the `showingFragment` variable
    so we know which Fragment to show next. We are not limited to switching between
    two Fragments either. If we needed additional Fragments, we just need to create
    them.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`switchFragment`基本上执行相同的片段事务。我们不是调用`add()`方法，而是调用带有现有片段的`replace()`方法。我们通过`showingFragment`变量跟踪当前片段，以便我们知道要显示哪个片段。我们也不限于在两个片段之间切换。如果我们需要额外的片段，我们只需创建它们即可。'
- en: There's more...
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the *Switching between activities* recipe from [Chapter 1](ch01.html "Chapter 1. Activities"),
    *Activities*, we discussed the back stack. Most users would expect the back key
    to move backward through the "screens" and they don't know or care if those screens
    are activities or Fragments. Fortunately, Android makes it very easy to add Fragments
    to the back stack just by adding a call to `addToBackStack()` before calling `commit()`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章。活动")的*在活动之间切换*食谱中，我们讨论了返回栈。大多数用户都期望返回键可以向后移动通过“屏幕”，他们不知道或不在乎那些屏幕是活动还是片段。幸运的是，Android通过在调用`commit()`之前添加对`addToBackStack()`的调用，使得将片段添加到返回栈变得非常容易。
- en: Tip
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When a Fragment is removed or replaced without adding it to the back stack,
    it is immediately destroyed. If it is added to the back stack, it is stopped and,
    if the user returns to the Fragment, it is restarted, instead of recreated.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个片段在没有添加到返回栈的情况下被移除或替换时，它会被立即销毁。如果它被添加到返回栈中，它会被停止，并且如果用户返回到该片段，它会被重新启动，而不是重新创建。
- en: Passing data between Fragments
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在片段之间传递数据
- en: Often, the need arises to pass information between the Fragments. An email application
    serves as a classic example. It's common to have the list of emails in one Fragment,
    and show the email details in another Fragment (this is commonly referred to as
    a Master/Detail pattern). Fragments make creating this pattern easier because
    we only have to code each Fragment once, then we can include them in different
    layouts. We can easily have a single Fragment in a portrait layout with the ability
    to swap out the master Fragment with the detail Fragment when an email is selected.
    We can also create a two-panel layout where both the list and detail Fragments
    are side-by-side. Either way, when the user clicks the email in the list, the
    email opens up in the detail panel. This is when we need to communicate between
    two Fragments.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 经常会出现需要在片段之间传递信息的需求。电子邮件应用程序是一个经典的例子。通常，电子邮件列表在一个片段中，而在另一个片段中显示电子邮件详情（这通常被称为主/详细模式）。片段使得创建这种模式变得更容易，因为我们只需要为每个片段编写一次代码，然后我们就可以将它们包含在不同的布局中。我们可以轻松地在一个纵向布局中放置一个片段，当选择电子邮件时，可以用详细片段替换主片段。我们还可以创建一个双面板布局，其中列表和详细片段并排显示。无论哪种方式，当用户点击列表中的电子邮件时，电子邮件就会在详细面板中打开。这就是我们需要在两个片段之间进行通信的时候。
- en: Since one of the primary goals of Fragments is that they be completely self-contained,
    direct communication between Fragments is discouraged, and for good reason. If
    Fragments had to rely on other Fragments, your code would likely break when the
    layouts changed and only one Fragment was available. Fortunately, direct communication
    is not required for this scenario either. All Fragment communication should pass
    through the host Activity. The host activity is responsible for managing the Fragments
    and can properly route the messages.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于片段的主要目标之一是它们应该是完全自包含的，因此不建议片段之间进行直接通信，这有很好的理由。如果片段必须依赖于其他片段，那么当布局发生变化且只有一个片段可用时，你的代码很可能会出错。幸运的是，在这种情况下也不需要直接通信。所有片段通信都应该通过宿主活动进行。宿主活动负责管理片段，并且可以正确地路由消息。
- en: 'Now the question becomes: How do Fragments communicate with the activity? The
    answer is with an `interface`. You''re probably already familiar with an interface,
    as that''s how a view communicates an event back to an activity. A button click
    is a common example.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是：片段如何与活动通信？答案是使用一个`interface`。你可能已经熟悉接口，因为这是视图将事件回传给活动的方式。按钮点击是一个常见的例子。
- en: 'In this recipe, we will create two Fragments to demonstrate passing data from
    one Fragment to another via the host activity. We''ll also build on what we learned
    from the previous recipe by including two different Activity Layouts—one for portrait
    and one for landscape. When in portrait mode, the activity will swap the Fragments
    as needed. Here is a screenshot of when the application first runs in portrait
    mode:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将创建两个片段来演示通过宿主活动从一个片段向另一个片段传递数据。我们还将利用之前食谱中学到的知识，包括两个不同的活动布局——一个用于纵向，一个用于横向。在纵向模式下，活动将根据需要交换片段。以下是应用程序首次在纵向模式下运行的截图：
- en: '![Passing data between Fragments](img/B05057_05_01.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![片段间传递数据](img/B05057_05_01.jpg)'
- en: 'This is the screen showing the detail Fragment when you click on a country
    name:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是点击国家名称时显示详细片段的屏幕：
- en: '![Passing data between Fragments](img/B05057_05_02.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![片段间传递数据](img/B05057_05_02.jpg)'
- en: 'When in landscape, both Fragments will be side-by-side, as shown in the landscape
    screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在横向模式下，两个片段将并排显示，如横向截图所示：
- en: '![Passing data between Fragments](img/B05057_05_03.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![片段间传递数据](img/B05057_05_03.jpg)'
- en: Since the Master/Detail pattern generally involves a list for the master, we'll
    take advantage of the `ListFragment` (mentioned in the *Creating and using a Fragment*
    introduction.) When an item in the list is selected, the item text (country name
    in our example) will be sent to the detail Fragment via the host Activity.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于主/详细模式通常涉及一个主列表，我们将利用 `ListFragment`（在 *创建和使用片段* 介绍中提到）。当列表中的项目被选中时，项目文本（在我们的例子中是国家名称）将通过宿主活动发送到详细片段。
- en: Getting ready
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a new project in Android Studio and call it: `Fragmentcommunication`.
    Use the default **Phone & Tablet** options and select **Empty Activity** when
    prompted for the **Activity Type**.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目，并将其命名为：`Fragmentcommunication`。使用默认的 **手机和平板** 选项，并在提示
    **活动类型** 时选择 **空活动**。
- en: How to do it...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: To fully demonstrate working Fragments, we'll need to create two Fragments.
    The first Fragment will extend from the `ListFragment` so it will not need a layout.
    We're going to go one step further by creating both portrait and landscape layouts
    for our Activity. For portrait mode, we'll swap Fragments and for landscape mode,
    we'll show both Fragments side-by-side.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全演示工作的片段，我们需要创建两个片段。第一个片段将继承自 `ListFragment`，因此它不需要布局。我们将更进一步，为我们的活动创建纵向和横向布局。在纵向模式下，我们将交换片段，在横向模式下，我们将并排显示两个片段。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When typing this code, Android Studio will offer two different library import
    options. Since the New Project Wizard automatically references the `AppCompat`
    library, we need to use the support library APIs instead of the framework APIs.
    Though very similar, the following code uses the support Fragment APIs.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入此代码时，Android Studio 将提供两种不同的库导入选项。由于新项目向导自动引用了 `AppCompat` 库，我们需要使用支持库 API
    而不是框架 API。尽管非常相似，以下代码使用支持片段 API。
- en: 'Here are the steps, starting with the first Fragment:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是步骤，从第一个片段开始：
- en: 'Create a new Java class called `MasterFragment` and change it so it extends
    `ListFragment` as shown:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `MasterFragment` 的新 Java 类，并将其修改为继承 `ListFragment`，如下所示：
- en: '[PRE15]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Import from the following library:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从以下库导入：
- en: '[PRE16]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create the following `interface` inside the `MasterFragment` class:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MasterFragment` 类内部创建以下 `interface`：
- en: '[PRE17]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Set up the interface callback listener with the following code:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码设置接口回调监听器：
- en: '[PRE18]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The last step for the `MasterFragment` is to create a `ListAdapter` to populate
    the `ListView`, which we do in the `onViewCreated()` method. We''ll use the `setOnItemClickListener()`
    to call our `OnMasterSelectedListener` interface when a country name is selected
    with the following code:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MasterFragment` 的最后一步是创建一个 `ListAdapter` 来填充 `ListView`，我们在 `onViewCreated()`
    方法中这样做。我们将使用 `setOnItemClickListener()` 在选择国家名称时调用我们的 `OnMasterSelectedListener`
    接口，如下所示：'
- en: '[PRE19]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next we need to create the `DetailFragment`, starting with the Layout. Create
    a new layout file called: `fragment_detail.xml` with the following XML:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们需要创建 `DetailFragment`，从布局开始。创建一个名为：`fragment_detail.xml` 的新布局文件，其 XML 如下所示：
- en: '[PRE20]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a new Java class called `DetailFragment` extending from `Fragment` as
    follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `DetailFragment` 的新 Java 类，它继承自 `Fragment`，如下所示：
- en: '[PRE21]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Import from the following library:'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从以下库导入：
- en: '[PRE22]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the following constant to the class:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下常量添加到类中：
- en: '[PRE23]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Override `onCreateView()` as follows:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下重写 `onCreateView()`：
- en: '[PRE24]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Code the `onViewCreated()` as follows:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写 `onViewCreated()` 如下：
- en: '[PRE25]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The last step for this Fragment is to update the TextView when we receive the
    selected country name. Add the following method to the class:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个Fragment的最后一步是在我们接收到选定的国家名称时更新TextView。向类中添加以下方法：
- en: '[PRE26]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The existing `activity_main.xml` layout will handle the portrait mode layout.
    Remove the existing `<TextView>` and replace with the following `<FrameLayout>`:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现有的`activity_main.xml`布局将处理纵向模式布局。删除现有的`<TextView>`并将其替换为以下`<FrameLayout>`：
- en: '[PRE27]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create a new directory in the **res** folder for the landscape layout as: `res/layout-land`.'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**res**文件夹中为横向布局创建一个新的目录：`res/layout-land`。
- en: Tip
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you do not see the new res/layout-land directory, change from **Android**
    **view** to **Project** **view**.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您看不到新的`res/layout-land`目录，请从**Android** **view**更改为**Project** **view**。
- en: 'Create a new `activity_main.xml` layout in `res/layout-land` as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/layout-land`中创建一个新的`activity_main.xml`布局，如下所示：
- en: '[PRE28]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The final steps are to set up the `MainActivity` to handle the Fragments. Open
    the `MainActivity.java` file and add the following class variable to track single/dual
    pane:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后的步骤是将`MainActivity`设置为处理Fragment。打开`MainActivity.java`文件，并添加以下类变量以跟踪单/双面板：
- en: '[PRE29]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, change `onCreate()` as follows:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，按照以下方式更改`onCreate()`：
- en: '[PRE30]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The last code to add is the `sendCountryName()` method, which handles sending
    the country name to `DetailFragment`:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要添加的最后一段代码是`sendCountryName()`方法，它处理将国家名称发送到`DetailFragment`：
- en: '[PRE31]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Run the program on a device or emulator.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行程序。
- en: How it works...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We start by creating the `MasterFragment`. In the Master/Detail pattern we are
    using, this usually represents a list, so we create a list by extending the `ListFragment`.
    The `ListFragment` is the Fragment equivalent of the `ListActivity`. Other than
    extending from a Fragment, it's basically the same.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建`MasterFragment`。在我们使用的Master/Detail模式中，这通常代表一个列表，因此我们通过扩展`ListFragment`创建一个列表。`ListFragment`是`ListActivity`的Fragment等价物。除了扩展Fragment之外，它基本上是相同的。
- en: As stated in the recipe introduction, we shouldn't attempt to communicate directly
    with other Fragments.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如食谱介绍中所述，我们不应尝试直接与其他Fragment通信。
- en: 'To provide a means to communicate the list item selection, we expose the interface:
    `OnMasterSelectedListener`. We call `onItemSelected()` every time an item is selected
    in the list.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一个通信列表项选择的方法，我们暴露了接口：`OnMasterSelectedListener`。每次在列表中选择一个项目时，我们都调用`onItemSelected()`。
- en: 'Most of the work for passing data between Fragments is done in the host activity
    but, ultimately, the receiving Fragment needs a way to receive the data. `DetailFragment`
    supports this in two ways:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在Fragment之间传递数据的大部分工作是在宿主活动中完成的，但最终，接收数据的Fragment需要一种接收数据的方式。`DetailFragment`通过两种方式支持这一点：
- en: Passing the country name in the argument bundle, available at creation time.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建时通过参数包传递国家名称。
- en: A public method for the activity to call directly.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活动可以直接调用的公共方法。
- en: When the activity creates the Fragment, it also creates a `bundle` to hold the
    data we want to send. Here we add the country name using `KEY_COUNTRY_NAME` defined
    in Step 7\. We retrieve this bundle with `getArguments()` in `onViewCreated()`.
    If the key is found in the bundle, it is extracted and displayed using the `showSelectedCountry()`
    method. This is the same method the activity will call directly if the Fragment
    is already visible (in the two-panel layout).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当活动创建Fragment时，它也会创建一个`bundle`来保存我们想要发送的数据。在这里，我们使用在步骤7中定义的`KEY_COUNTRY_NAME`添加国家名称。我们在`onViewCreated()`中使用`getArguments()`检索这个bundle。如果键在bundle中找到，它将通过`showSelectedCountry()`方法提取并显示。这是活动如果Fragment已经可见（在两面板布局中）将直接调用的相同方法。
- en: 'Most of the work for this recipe is in the activity. We created two layouts:
    one for portrait and one for landscape. Android will choose the landscape layout
    using the `res/layout-land` directory created in *Step 12*. Both layouts use a
    `<FrameLayout>` placeholder, similar to the previous exercise. We manage the Fragments
    in both `onCreate()` and `sendCountryName()`.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的大部分工作都在活动中。我们创建了两个布局：一个用于纵向，一个用于横向。Android将使用在*步骤12*中创建的`res/layout-land`目录选择横向布局。这两个布局都使用一个`<FrameLayout>`占位符，类似于之前的练习。我们在`onCreate()`和`sendCountryName()`中管理Fragment。
- en: 'In `onCreate()`, we set the `dualPane` flag by checking whether the current
    layout includes the `frameLayout` view. If `frameLayout` is found (it won''t be
    null), then we have only a single panel because the `frameLayout` ID is only in
    the portrait layout. If frameLayout is not found, then we have two `<FrameLayout>`
    elements instead: one for the `MasterFragment` and another for the `DetailFragment`.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we do in the `onCreate()` is to set up the `MasterFragment` listener
    by creating an anonymous callback, which passes the country name to `sendCountryName()`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '`sendCountryName()` is where the data is actually passed to the `DetailFragment`.
    If we are in portrait (or single pane) mode, we need to create a `DetailFragment`
    and replace the existing `MasterFragment`. This is where we create the bundle
    with the country name and call `setArguments()`. Notice how we call `addToBackStack()`
    before committing the transaction? This allows the back key to bring the user
    back to the list (`MasterFragment`). If we are in landscape mode, the `DetailFragment`
    is already visible so we call the `showSelectedCountry()` public method directly.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `MasterFragment`, before sending the `onItemSelected()` event, we check
    to make sure the listener is not null with this code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Though it's the job of the activity to set up the callback to receive the events,
    we don't want this code to crash if there's no listener. An alternative approach
    would be to verify the activity extends our interface in the Fragment's `onAttach()`
    callback.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information on ListViews, see *Using ListView, GridView and Adapters*
    in [Chapter 2](ch02.html "Chapter 2. Layouts"), *Layouts*.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on resource directories, see *Selecting themes based on
    the Android version* in [Chapter 3](ch03.html "Chapter 3. Views, Widgets, and
    Styles"), *Views, Widgets, and Styles*.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a shortcut on the Home screen
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe explains how to create a link or create a shortcut for your app
    on the user's Home screen. So as not to be too obtrusive, it's generally best
    to make this an option for the user to initiate, such as in the settings.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a screenshot showing our shortcut on the Home screen:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a shortcut on the Home screen](img/B05057_05_04.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
- en: As you can see, this is just a shortcut, but we will explore creating a Home
    screen (AppWidget) in the next recipe.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new project in Android Studio and call it: `HomescreenShortcut`. Use
    the default **Phone & Tablet** options and select the **Empty Activity** option
    when prompted for the **Activity Type**.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step is to add the appropriate permission. Here are the steps:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `AndroidManifest` file and add the following permission:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, open `activity_main.xml` and replace the existing TextView with the following
    button:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add the following method to `ActivityMain.java`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Run the program on a device or emulator. Notice, each time you press the button,
    the app will make a shortcut on the Home screen.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行程序。注意，每次你按下按钮，应用都会在主屏幕上创建一个快捷方式。
- en: How it works...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Once you set up the proper permission, this is a rather straightforward task.
    When the button is clicked, the code creates a new intent called: `shortcutIntent`.
    This is the intent that will be called when the icon is pressed on the Home screen.
    The next intent created, `installIntent`, is responsible for actually creating
    the shortcut.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你设置了适当的权限，这便是一个相当直接的任务。当按钮被点击时，代码会创建一个新的意图，称为：`shortcutIntent`。这是当在主屏幕上按下图标时将被调用的意图。接下来创建的意图
    `installIntent` 负责实际创建快捷方式。
- en: There's more...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you also wanted to remove the shortcut, you would need the following permission:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还想删除快捷方式，你需要以下权限：
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Instead of using the INSTALL_SHORTCUT action, you would set the following action
    instead:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用 `INSTALL_SHORTCUT` 动作，你将设置以下动作：
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Creating a Home screen widget
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建主屏幕小部件
- en: 'Before we dig in to the code for creating an App Widget, let''s cover the basics.
    There are three required and one optional component:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究创建 App Widget 的代码之前，让我们先了解基础知识。有三个必需组件和一个可选组件：
- en: 'The `AppWidgetProviderInfo` file: It''s an XML resource described later on'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppWidgetProviderInfo` 文件：它是一个稍后描述的 XML 资源'
- en: 'The `AppWidgetProvider` class: This is a Java class'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppWidgetProvider` 类：这是一个 Java 类'
- en: 'The View layout file: It''s a standard layout XML file, with some restrictions
    listed later on'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图布局文件：它是一个带有一些限制的标准布局 XML 文件
- en: 'The App Widget configuration Activity (optional): This Activity launches when
    placing the widget to set configuration options'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: App Widget 配置 Activity（可选）：当放置小部件以设置配置选项时启动此 Activity
- en: 'The `AppWidgetProvider` must also be declared in the `AndroidManifest` file.
    Since the `AppWidgetProvider` is a helper class based on the Broadcast Receiver,
    it is declared in the manifest with the `<receiver>` element. Here is an example
    manifest entry:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppWidgetProvider` 也必须在 `AndroidManifest` 文件中声明。由于 `AppWidgetProvider` 是基于广播接收器的辅助类，它在
    Manifest 中使用 `<receiver>` 元素声明。以下是一个示例 Manifest 条目：'
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The meta-data points to the `AppWidgetProviderInfo` file, which is placed in
    the `res/xml` directory. Here is a sample `AppWidgetProviderInfo.xml` file:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据指向 `AppWidgetProviderInfo` 文件，该文件位于 `res/xml` 目录中。以下是一个示例 `AppWidgetProviderInfo.xml`
    文件：
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here''s a brief overview of the available attributes:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是可用属性的简要概述：
- en: '`minWidth`: The default width when placed on the Home screen'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minWidth`：放置在主屏幕上的默认宽度'
- en: '`minHeight`: The default height when placed on the Home screen'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minHeight`：放置在主屏幕上的默认高度'
- en: '`updatePeriodMillis`: It''s part of `onUpdate()` polling interval (in milliseconds)'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updatePeriodMillis`：它是 `onUpdate()` 轮询间隔的一部分（以毫秒为单位）'
- en: '`initialLayout`: The AppWidget layout'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialLayout`：AppWidget 布局'
- en: '`previewImage` (optional): The image shown when browsing App Widgets'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`previewImage`（可选）：浏览 App Widget 时显示的图像'
- en: '`configure` (optional): The activity to launch for configuration settings'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configure`（可选）：用于配置设置的 Activity'
- en: '`resizeMode` (optional): The flags indicate resizing options — `horizontal`,
    `vertical`, `none`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resizeMode`（可选）：标志指示调整大小选项 — `horizontal`、`vertical`、`none`'
- en: '`minResizeWidth` (optional): The minimum width allowed when resizing'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minResizeWidth`（可选）：调整大小时允许的最小宽度'
- en: '`minResizeHeight` (optional): The minimum height allowed when resizing'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minResizeHeight`（可选）：调整大小时允许的最小高度'
- en: '`widgetCategory` (optional): Android 5+ only supports Home screen widgets'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`widgetCategory`（可选）：Android 5+ 仅支持主屏幕小部件'
- en: 'The `AppWidgetProvider` extends the `BroadcastReceiver` class, which is why
    `<receiver>` is used when declaring the `AppWidget` in the Manifest. As it''s
    `BroadcastReceiver`, the class still receives the OS broadcast events, but the
    helper class filters those events down to those applicable for an App Widget.
    The `AppWidgetProvider` class exposes the following methods:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppWidgetProvider` 类扩展了 `BroadcastReceiver` 类，这就是为什么在 Manifest 中声明 `AppWidget`
    时使用 `<receiver>` 的原因。由于它是 `BroadcastReceiver`，该类仍然接收操作系统广播事件，但辅助类将这些事件过滤到适用于 App
    Widget 的事件。`AppWidgetProvider` 类公开了以下方法：'
- en: '`onUpdate()`: It''s called when initially created and at the interval specified.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onUpdate()`：它在首次创建时和指定的时间间隔被调用。'
- en: '`onAppWidgetOptionsChanged()`: It''s called when initially created and any
    time the size changes.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onAppWidgetOptionsChanged()`：它在首次创建和任何时间大小改变时被调用。'
- en: '`onDeleted()`: It''s called any time a widget is removed.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onDeleted()`：任何时间删除小部件时都会被调用。'
- en: '`onEnabled()`: It''s called the first time a widget is placed (is not called
    when adding a second and subsequent widgets).'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onDisabled()`: It''s called when the last widget is removed.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onReceive()`: It''s called on every event received, including the preceding
    event. Usually not overridden as the default implementation only sends the applicable
    events.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The last required component is the layout. Remote Views only support a subset
    of the available layouts. As an App Widget is a Remote View, only the following
    layouts are supported:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '`FrameLayout`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LinearLayout`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RelativeLayout`'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GridLayout`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And the following widgets:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '`AnalogClock`'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Button`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Chronometer`'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ImageButton`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ImageView`'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProgressBar`'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TextView`'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewFlipper`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListView`'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GridView`'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StackView`'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AdapterViewFlipper`'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the App Widget basics covered, it's now time to start coding. Our example
    will cover the basics so you can expand the functionality as needed. This recipe
    uses a View with a clock, which, when pressed, opens our activity.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'This screenshot shows the widget in the widget list when adding to the Home
    screen:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Home screen widget](img/B05057_05_05.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The widget list appearance varies by launcher.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a screenshot showing the widget after it is added to the Home screen:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Home screen widget](img/B05057_05_06.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new project in Android Studio and call it: `AppWidget`. Use the default
    **Phone & Tablet** options and select the **Empty Activity** option when prompted
    for the **Activity Type**.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll start by creating the widget layout, which resides in the standard layout
    resource directory. Then we'll create the xml resource directory to store the
    `AppWidgetProviderInfo` file. We'll add a new Java class and extend `AppWidgetProvider`,
    which handles the `onUpdate()` call for the widget. With the receiver created,
    we can then add it to the Android Manifest.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the detailed steps:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file in `res/layout` called `widget.xml` using the following XML:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create a new directory called `xml` in the resource directory. The final result
    will be: `res/xml`.'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new file in `res/xml` called `appwidget_info,xml` using the following
    xml:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Tip
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you cannot see the new xml directory, switch from **Android** view to **Project**
    view in the **Project** panel dropdown.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a new Java class called `HomescreenWidgetProvider` extending `AppWidgetProvider`.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `onUpdate()` method to the `HomescreenWidgetProvider` class:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Add `HomescreenWidgetProvider` to `AndroidManifest` using the following XML
    declaration within the `<application>` element:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Run the program on a device or emulator. After first running the application,
    the widget will then be available to add to the Home screen.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our first step is to create the layout file for the widget. This is a standard
    layout resource with the restrictions based on the App Widget being a Remote View,
    as discussed in the recipe introduction. Though our example uses an Analog Clock
    widget, this is where you'd want to expand the functionality based on your application
    needs.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是为小部件创建布局文件。这是一个标准的布局资源，其限制基于App Widget是一个远程视图，如配方介绍中所述。尽管我们的示例使用了一个模拟时钟小部件，但这是您根据应用程序需求扩展功能的地方。
- en: The xml resource directory serves to store the `AppWidgetProviderInfo`, which
    defines the default widget settings. The configuration settings determine how
    the widget is displayed when initially browsing the available widgets. We use
    very basic settings for this recipe, but they can easily be expanded to include
    additional features such as a preview image to show a functioning widget and sizing
    options. The `updatePeriodMillis` attribute sets the update frequency. Since the
    update will wake up the device, it's a trade-off between having up-to-date data
    and battery life. (This is where the optional Settings Activity is useful to let
    the user decide.)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: xml资源目录用于存储`AppWidgetProviderInfo`，它定义了默认的小部件设置。配置设置决定了小部件在最初浏览可用小部件时的显示方式。我们为这个配方使用了非常基本的设置，但它们可以很容易地扩展以包括其他功能，例如显示一个功能小部件的预览图像和尺寸选项。`updatePeriodMillis`属性设置了更新频率。由于更新会唤醒设备，这需要在最新的数据和电池寿命之间做出权衡。（这就是可选的设置活动有用的地方，可以让用户决定。）
- en: The `AppWidgetProvider` class is where we handle the `onUpdate()` event triggered
    by the `updatePeriodMillis` polling. Our example doesn't need any updating so
    we set the polling to zero. The update is still called when initially placing
    the widget. The `onUpdate()` is where we set the pending intent to open our app
    when the clock is pressed.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppWidgetProvider`类是我们处理由`updatePeriodMillis`轮询触发的`onUpdate()`事件的地方。我们的示例不需要任何更新，所以我们把轮询设置为零。当最初放置小部件时，更新仍然会被调用。`onUpdate()`是我们设置挂起意图以在时钟被按下时打开我们的应用的地方。'
- en: Since the `onUpdate()` method is probably the most complicated aspect of AppWidgets,
    we'll explain this is some detail. First, it's worth noting that `onUpdate()`
    will occur only once each polling interval for all the widgets is created by this
    provider. (Widgets created after the first will be on the cycle of the first widget.)
    This explains the `for` loop, as we need it to iterate through all the existing
    widgets. This is where we create a pending intent to call our app when the clock
    is pressed. As discussed earlier, an AppWidget is a Remote View. Therefore, to
    get the layout, we call `RemoteViews()` with our fully qualified package name
    and the layout ID. Once we have the layout, we can attach the pending intent to
    the clock view using `setOnClickPendingIntent()`. We call the `AppWidgetManager`
    named `updateAppWidget()` to initiate the changes we made.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`onUpdate()`方法可能是AppWidgets中最复杂的一部分，我们将对此进行详细解释。首先，值得注意的是，对于由该提供程序创建的所有小部件，`onUpdate()`方法在每个轮询间隔内只会发生一次。（在第一个之后创建的小部件将处于第一个小部件的周期中。）这解释了`for`循环，因为我们需要它来遍历所有现有的小部件。这就是我们创建一个挂起意图，在时钟被按下时调用我们的应用的地方。如前所述，AppWidget是一个远程视图。因此，为了获取布局，我们使用我们的完全限定包名和布局ID调用`RemoteViews()`。一旦我们有了布局，我们就可以使用`setOnClickPendingIntent()`将挂起意图附加到时钟视图。我们调用名为`updateAppWidget()`的`AppWidgetManager`来启动我们所做的更改。
- en: 'The last step to make all this work is to declare the widget in the Android
    Manifest. We identify the action we want to handle with the `<intent-filter>`.
    Most App Widgets will likely want to handle the Update event, as ours does. The
    other item to note in the declaration is this line:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使所有这些工作完成的最后一步是在AndroidManifest中声明小部件。我们使用`<intent-filter>`标识我们想要处理的操作。大多数App
    Widgets可能希望处理更新事件，就像我们的那样。声明中需要注意的另一项是这一行：
- en: '[PRE44]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This tells the system where to find our configuration file.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉系统在哪里可以找到我们的配置文件。
- en: There's more...
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Adding an App Widget configuration Activity allows greater flexibility with
    your widget. Not only can you offer polling options, but you could offer different
    layouts, click behaviors, and so on. Users tend to really appreciate flexible
    App Widgets.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 添加App Widget配置活动可以使您的部件更加灵活。您不仅可以选择轮询选项，还可以提供不同的布局、点击行为等。用户通常非常欣赏灵活的App Widgets。
- en: 'Adding a configuration Activity requires a few additional steps. The Activity
    needs to be declared in the Manifest as usual, but needs to include the `APPWIDGET_CONFIGURE`
    action, as shown in this example:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 添加配置活动需要几个额外的步骤。该活动需要像往常一样在 Manifest 中声明，但需要包含 `APPWIDGET_CONFIGURE` 动作，如下例所示：
- en: '[PRE45]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The Activity also needs to be specified in the `AppWidgetProviderInfo` file
    using the configure attribute, as shown in this example:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动还需要在 `AppWidgetProviderInfo` 文件中使用配置属性进行指定，如下例所示：
- en: '[PRE46]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `configure` attribute requires the fully qualified package name as this
    Activity will be called from outside of your application.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`configure` 属性需要完全限定的包名，因为此活动将从应用程序外部调用。'
- en: Tip
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember, the `onUpdate()` method will not be called when using a configuration
    Activity. The configuration Activity is responsible for handling any initial setup,
    if required.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当使用配置活动时，`onUpdate()` 方法不会被调用。配置活动负责处理任何所需的初始设置。
- en: See also
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For App Widget Design Guidelines, visit Google''s page at: [http://developer.android.com/design/patterns/widgets.html](http://developer.android.com/design/patterns/widgets.html)'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 App Widget 设计指南，请访问 Google 的页面：[http://developer.android.com/design/patterns/widgets.html](http://developer.android.com/design/patterns/widgets.html)
- en: Adding Search to the Action Bar
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将搜索添加到操作栏
- en: Along with the Action Bar, Android 3.0 introduced the `SearchView` widget, which
    can be included as a menu item when creating a menu. This is now the recommended
    UI pattern to provide a consistent user experience.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 除了操作栏外，Android 3.0 还引入了 `SearchView` 小部件，可以在创建菜单时将其作为菜单项包含。现在这是提供一致用户体验的推荐 UI
    模式。
- en: 'The following screenshot shows the initial appearance of the Search icon in
    the Action Bar:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了搜索图标在操作栏中的初始外观：
- en: '![Adding Search to the Action Bar](img/B05057_05_07.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![将搜索添加到操作栏](img/B05057_05_07.jpg)'
- en: 'This screenshot shows how the Search option expands when pressed:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 此截图显示了按下时搜索选项的展开方式：
- en: '![Adding Search to the Action Bar](img/B05057_05_08.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![将搜索添加到操作栏](img/B05057_05_08.jpg)'
- en: If you want to add a Search functionality to your application, this recipe will
    walk you through the steps to set up your User Interface and properly configure
    the Search Manager API.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想向您的应用程序添加搜索功能，本食谱将指导您设置用户界面并正确配置搜索管理器 API。
- en: Getting ready
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a new project in Android Studio and call it: `SearchView`. Use the default
    **Phone & Tablet** options and select **Empty Activity** when prompted for the
    Activity Type.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目，命名为：`SearchView`。使用默认的 **Phone & Tablet** 选项，并在提示活动类型时选择
    **Empty Activity**。
- en: How to do it...
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To set up the Search UI pattern, we need to create the Search menu item and
    a resource called `searchable`. We''ll create a second activity to receive the
    search query. Then we''ll hook it all up in the `AndroidManifest` file. To get
    started, open the `strings.xml` file in `res/values` and follow these steps:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置搜索 UI 模式，我们需要创建搜索菜单项和一个名为 `searchable` 的资源。然后我们将创建第二个活动来接收搜索查询。然后我们将在 `AndroidManifest`
    文件中将所有这些连接起来。要开始，请打开 `res/values` 中的 `strings.xml` 文件并按照以下步骤操作：
- en: 'Add the following string resources:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下字符串资源：
- en: '[PRE47]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Create the menu directory: `res/menu`.'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建菜单目录：`res/menu`。
- en: 'Create a new menu resource called `menu_options.xml` in `res/menu` using the
    following xml:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `res/menu` 中创建一个新的菜单资源 `menu_options.xml`，使用以下 xml：
- en: '[PRE48]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Override `onCreateOptionsMenu()` to inflate the menu and set up the Search
    Manager as follows:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写 `onCreateOptionsMenu()` 来填充菜单并设置搜索管理器如下：
- en: '[PRE49]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Create a new xml resource directory: `res/xml`.'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 xml 资源目录：`res/xml`。
- en: 'Create a new file in the `res/xml` called `searchable.xml` using the following
    xml:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `res/xml` 中创建一个新的文件 `searchable.xml`，使用以下 xml：
- en: '[PRE50]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Crate a new layout called `activity_search_result.xml` using this xml:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下 xml 创建一个新的布局 `activity_search_result.xml`：
- en: '[PRE51]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Create a new Activity called `SearchResultActivity`.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的活动，命名为 `SearchResultActivity`。
- en: 'Add the following variable to the class:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向类中添加以下变量：
- en: '[PRE52]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Change the `onCreate()` to load our layout, set the TextView and check for
    the `QUERY` action:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `onCreate()` 改为加载我们的布局，设置 TextView 并检查 `QUERY` 动作：
- en: '[PRE53]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Add the following method to handle the search:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法来处理搜索：
- en: '[PRE54]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'With the User Interface and code now complete, we just need to hook everything
    up correctly in the `AndroidManifest`. Here is the complete manifest including
    both activities:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 界面和代码现在已完成，我们只需在 `AndroidManifest` 中正确连接一切。以下是包含两个活动的完整 Manifest：
- en: '[PRE55]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Run the application on a device or emulator. Type in a search query and hit
    the **Search** button (or press enter). The `SearchResultActivity` will display
    showing the search query entered.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行应用程序。输入一个搜索查询并点击**搜索**按钮（或按回车键）。`SearchResultActivity`将显示并显示输入的搜索查询。
- en: How it works...
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Since the New Project Wizard uses the `AppCompat` library, our example uses
    the support library API. Using the support library provides the greatest device
    compatibility as it allows the use of modern features (such as the Action Bar)
    on older versions of the Android OS. This can sometimes provide an extra challenge
    as often the official documentation focuses on the framework API. Though usually
    the support library closely follows the framework API, they are not always interchangeable.
    The Search UI pattern is one of those situations, so it's worth paying extra attention
    to the steps outlined previously.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 由于新项目向导使用`AppCompat`库，我们的示例使用支持库API。使用支持库提供了最大的设备兼容性，因为它允许在较旧的Android OS版本上使用现代功能（如操作栏）。这有时会带来额外的挑战，因为官方文档通常关注框架API。尽管支持库通常紧跟框架API，但它们并不总是可以互换。搜索UI模式就是这样一种情况，因此值得特别注意之前概述的步骤。
- en: We start by creating string resources for the `searchable`, as declared in Step
    6.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先为`searchable`创建字符串资源，正如第6步所声明的。
- en: In Step 3, we create the menu resource, as we've done many times. One difference
    is that we use the `app` namespace for the `showAsAction` and `actionViewClass`
    attributes. The earlier versions of the Android OS don't include these attributes
    in their Android namespace. This serves as a way to bring new functionality to
    older versions of the Android OS
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3步中，我们创建菜单资源，就像我们多次做的那样。一个不同之处在于我们使用`app`命名空间来为`showAsAction`和`actionViewClass`属性。Android
    OS的早期版本不包括它们在Android命名空间中的这些属性。这可以作为将新功能引入较旧版本的Android OS的一种方式。
- en: In Step 4, we set up the `SearchManager`, again using the support library APIs.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，我们设置了`SearchManager`，再次使用支持库API。
- en: Step 6 is where we define the `searchable`, which is an xml resource used by
    the `SearchManager`. The only required attribute is the `label`, but the `hint`
    is recommended so the user will have an idea of what they should type in the field.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 第6步是我们定义`searchable`的地方，这是一个由`SearchManager`使用的xml资源。唯一必需的属性是`label`，但推荐使用`hint`，这样用户就会知道应该在字段中输入什么。
- en: Tip
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `android:label` must match the application name or the activity name and
    must use a string resource (as it does not work with a hard-coded string).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`android:label`必须与应用程序名称或活动名称匹配，并且必须使用字符串资源（因为它不适用于硬编码的字符串）。'
- en: Steps 7-11 are for the `SearchResultActivity`. Calling a second activity is
    not a requirement of the `SearchManager`, but is commonly done to provide a single
    activity for all searches initiated in your application.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 第7步至第11步是针对`SearchResultActivity`的。调用第二个活动不是`SearchManager`的要求，但通常这样做是为了提供一个活动来处理应用程序中启动的所有搜索。
- en: 'If you ran the application at this point, you would see the search icon, but
    nothing would work. Step 12 is where we put it all together in the `AndroidManifest`
    file. The first item to note is the following:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行应用程序，你会看到搜索图标，但什么都不会工作。第12步是我们将所有内容组合到`AndroidManifest`文件中的地方。首先要注意的是以下内容：
- en: '[PRE56]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Notice this is in the application element and not in either of the `<activity>`
    elements.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这位于`application`元素中，而不是任一`<activity>`元素中。
- en: 'We specify the searchable resource in the `SearchResultActivity <meta-data>`
    element:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`SearchResultActivity <meta-data>`元素中指定可搜索的资源：
- en: '[PRE57]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We also need to set the intent filter for `SearchResultActivity` as we do here:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要像这里一样设置`SearchResultActivity`的intent过滤器：
- en: '[PRE58]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `SearchManager` broadcasts the `SEARCH` intent when the user initiates
    the search. This declaration directs the intent to the `SearchResultActivity`
    activity. Once the search is triggered, the query text is sent to the `SearchResultActivity`
    using the `SEARCH` intent. We check for the `SEARCH` intent in the `onCreate()`
    and extract the query string using the following code:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户启动搜索时，`SearchManager`会广播`SEARCH`意图。这个声明将意图指向`SearchResultActivity`活动。一旦搜索被触发，查询文本将通过`SEARCH`意图发送到`SearchResultActivity`。我们在`onCreate()`中检查`SEARCH`意图，并使用以下代码提取查询字符串：
- en: '[PRE59]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: You now have the Search UI pattern fully implemented. With the UI pattern complete,
    how you handle the search is specific to your application needs. Depending on
    your application, you might search a local database or maybe a web service.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已完全实现了搜索 UI 模式。随着 UI 模式的完成，您如何处理搜索将具体取决于您的应用程序需求。根据您的应用程序，您可能需要搜索本地数据库或可能是一个网络服务。
- en: See also
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: To take your search to the Internet, see *Internet queries* in [Chapter 12](ch12.html
    "Chapter 12. Telephony, Networks, and the Web"), *Telephony, Networks, and the
    Web*.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 要将搜索扩展到互联网，请参阅第 12 章 [“Internet 查询”](ch12.html "第 12 章。电话、网络和互联网")，*电话、网络和互联网*。
- en: Showing your app full screen
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展示应用全屏
- en: 'Android 4.4 (API 19) introduced a UI feature called Immersive Mode. Unlike
    the previous full screen flag, your app receives all the touch events while in
    Immersive Mode. This mode is ideal for certain activities, such as reading books
    and news, full-screen drawing, gaming, or watching a video. There are several
    different approaches to full screen, and each have a best use case:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Android 4.4 (API 19) 引入了一个名为沉浸模式的 UI 功能。与之前的全屏标志不同，在沉浸模式下，您的应用会接收到所有触摸事件。这种模式非常适合某些活动，例如阅读书籍和新闻、全屏绘图、游戏或观看视频。全屏有几种不同的方法，每种方法都有最佳的使用场景：
- en: 'Reading books/articles, and so on: Immersive Mode with easy access to the system
    UI'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读书籍/文章等：带有轻松访问系统 UI 的沉浸模式
- en: 'Game/Drawing app: Immersive Mode for full screen use but minimal system UI'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏/绘图应用：全屏使用沉浸模式但最小化系统 UI
- en: 'Watching video: Full screen and normal system UI'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观看视频：全屏和正常系统 UI
- en: The key difference between the modes is how the System UI responds. In the first
    two scenarios, your app is expecting user interaction, so the System UI is hidden
    to make it easier for your user (such as not hitting the back button while playing
    a game). While using full screen with a normal system UI, such as watching a video,
    you wouldn't expect your user to use the screen at all, so when they do, the system
    UI should respond normally. In all modes, the user can bring back the System UI
    with a swipe inward across the hidden System Bar.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 两种模式之间的关键区别在于系统 UI 的响应方式。在前两种场景中，您的应用期望用户交互，因此系统 UI 被隐藏，以便更容易使用（例如，在玩游戏时不会误按返回按钮）。在使用带有正常系统
    UI 的全屏模式，如观看视频时，您不会期望用户使用屏幕，因此当用户这样做时，系统 UI 应该正常响应。在所有模式下，用户可以通过在隐藏的系统栏上向内滑动来恢复系统
    UI。
- en: 'Since watching a video doesn''t require the new **Immersive Mode**, full-screen
    mode can be achieved using the two flags: `SYSTEM_UI_FLAG_FULLSCREEN` and `SYSTEM_UI_FLAG_HIDE_NAVIGATION`,
    available since Android 4.0 (API 14).'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 由于观看视频不需要新的 **沉浸模式**，全屏模式可以使用两个标志：`SYSTEM_UI_FLAG_FULLSCREEN` 和 `SYSTEM_UI_FLAG_HIDE_NAVIGATION`
    实现，这两个标志自 Android 4.0 (API 14) 以来可用。
- en: Our recipe will demonstrate setting up Immersive Mode. We're also going to add
    the ability to toggle the System UI with a tap on the screen.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的配方将演示如何设置沉浸模式。我们还将添加通过屏幕点击切换系统 UI 的功能。
- en: Getting ready
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a new project in Android Studio and call it: `ImmersiveMode`. Use the
    default **Phone & Tablet** options and select **Empty Activity** when prompted
    for the **Activity Type**. When selecting the **Minimum API Level**, choose **API
    19** or higher.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目，并将其命名为：`ImmersiveMode`。使用默认的 **手机和平板** 选项，并在提示 **活动类型**
    时选择 **空活动**。在选择 **最小 API 级别** 时，选择 **API 19** 或更高版本。
- en: How to do it...
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We''ll create two functions for handling the system UI visibility, then we''ll
    create a gesture listener to detect the screen tap. All the steps for this recipe
    are adding code to `MainActivity.java`, so open the file and let''s begin:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个处理系统 UI 可见性的函数，然后创建一个手势监听器来检测屏幕点击。这个配方的所有步骤都是在 `MainActivity.java` 中添加代码，所以请打开文件，让我们开始：
- en: 'Add the following method to hide the System UI:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法以隐藏系统 UI：
- en: '[PRE60]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Add the following method to show the System UI:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法以显示系统 UI：
- en: '[PRE61]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Add the following class variable:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下类变量：
- en: '[PRE62]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Add the following `GestureListener` class at the class level, below the previous
    class variable:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类级别，在之前的类变量下方添加以下 `GestureListener` 类：
- en: '[PRE63]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Override the `onTouchEvent()` callback with the following:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码覆盖 `onTouchEvent()` 回调：
- en: '[PRE64]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Add the following code to the `onCreate()` method to set the `GestureListener`
    and hide the System UI:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `onCreate()` 方法中，以设置 `GestureListener` 并隐藏系统 UI：
- en: '[PRE65]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Run the application on a device or emulator. Swiping inward across a hidden
    System Bar will show the System UI. Tapping the screen will toggle the System
    UI.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行应用程序。向内滑动隐藏的系统栏将显示系统界面。轻触屏幕将切换系统界面。
- en: How it works...
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We create the `showSystemUI()` and `hideSystemUI()` methods by using `setSystemUiVisibility()`
    on the application window. The flags we set (and don't set) control what is visible
    and what is hidden. When we set the visibility without the `SYSTEM_UI_FLAG_IMMERSIVE`
    flag, we in effect, disable Immersive Mode.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在应用程序窗口上使用`setSystemUiVisibility()`来创建`showSystemUI()`和`hideSystemUI()`方法。我们设置的（和未设置的）标志控制着什么可见和什么隐藏。当我们设置可见性而不使用`SYSTEM_UI_FLAG_IMMERSIVE`标志时，实际上我们禁用了沉浸模式。
- en: If all we wanted to do was hide the System UI, we could just add `hideSystemUI()`
    to `onCreate()` and we'd be done. The problem is it wouldn't stay hidden. Once
    the user exited Immersive Mode, it would stay in the regular display mode. That's
    why we created the `GestureListener`. (We'll discuss gestures again in [Chapter
    8](ch08.html "Chapter 8. Using the Touchscreen and Sensors"), *Using the Touchscreen
    and Sensors*.) Since we only want to respond to the `onSingleTapUp()` gesture,
    we don't implement the full range of gestures. When `onSingleTapUp` is detected,
    we toggle the System UI.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想隐藏系统界面，我们只需在`onCreate()`中添加`hideSystemUI()`方法，任务就完成了。问题是它不会保持隐藏。一旦用户退出沉浸模式，它就会保持在常规显示模式。这就是我们创建`GestureListener`的原因。（我们将在[第8章](ch08.html
    "第8章。使用触摸屏和传感器")中再次讨论手势，*使用触摸屏和传感器*。）因为我们只想对`onSingleTapUp()`手势做出响应，所以我们没有实现所有手势范围。当检测到`onSingleTapUp`时，我们切换系统界面。
- en: There's more...
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Let''s look at some of the other important tasks that can be performed:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看可以执行的一些其他重要任务：
- en: Sticky Immersion
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 粘性沉浸
- en: There's another option we can use if we want the System UI to stay hidden automatically.
    Instead of using `SYSTEM_UI_FLAG_IMMERSIVE` to hide the UI, we can use `SYSTEM_UI_FLAG_IMMERSIVE_STICKY`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要系统界面自动隐藏，还有一个选项可以使用。我们不是使用`SYSTEM_UI_FLAG_IMMERSIVE`来隐藏UI，而是可以使用`SYSTEM_UI_FLAG_IMMERSIVE_STICKY`。
- en: Dimming the System UI
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调暗系统界面
- en: If all you need is to reduce the visibility of the Navigation bar, there's also
    `SYSTEM_UI_FLAG_LOW_PROFILE` to dim the UI.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要减少导航栏的可见性，还有`SYSTEM_UI_FLAG_LOW_PROFILE`来调暗UI。
- en: 'Use this flag with the same `setSystemUiVisibility()` call as the Immersive
    Mode flag:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与沉浸模式标志相同的`setSystemUiVisibility()`调用此标志：
- en: '[PRE66]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Call `setSystemUiVisibility()` with 0 to clear all flags:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 使用0调用`setSystemUiVisibility()`以清除所有标志：
- en: '[PRE67]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Setting the Action Bar as an Overlay
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将操作栏设置为叠加层
- en: 'If you just need to hide or show the Action Bar, use these methods:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要隐藏或显示操作栏，请使用以下方法：
- en: '[PRE68]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'One problem with this approach is that the system resizes the layout each time
    either method is called. Instead, you might want to consider using a theme option
    to make the System UI behave as an overlay. To enable overlay mode, add the following
    to the theme:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个问题是，每次调用任一方法时，系统都会重新调整布局的大小。相反，你可能想考虑使用主题选项来使系统界面表现得像一个叠加层。要启用叠加模式，请将以下内容添加到主题中：
- en: '[PRE69]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Translucent system bars
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 透明系统栏
- en: 'These two themes enable the translucent settings:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个主题启用了透明设置：
- en: '[PRE70]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'If you are creating your own theme, use the following theme settings:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在创建自己的主题，请使用以下主题设置：
- en: '[PRE71]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: See also
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Recognizing a gesture* recipe in [Chapter 8](ch08.html "Chapter 8. Using
    the Touchscreen and Sensors"), *Using the Touchscreen and Sensors*.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '[第8章](ch08.html "第8章。使用触摸屏和传感器")中关于*识别手势*的配方，*使用触摸屏和传感器*。'
