# 第三章。Android 很奇怪

确实如此。尽管它是建立在熟悉的 Linux 内核之上，但 Android 拥有一个完全定制的用户空间，并且虽然其中许多功能是 GNU 亲缘功能的重写，但也有一些是全新的，或者与桌面版本有显著不同的功能。由于这些差异，这些系统必须进行修改以支持 SELinux。在本章中，我们将：

+   介绍 Android 安全模型

+   调查 binder、zygote 和属性服务

+   涵盖为补充这些系统而添加的 SELinux 元素及其原因

这些系统的覆盖范围将适中，但当我们进行 Android SE 的探索性研究时，我们将适当地详细介绍每个系统的更复杂细节。

# Android 的安全模型

Android 的核心安全模型基于 Linux DAC，包括能力。然而，Android 却以非常非传统的方式使用 Linux 的 UID/GID 概念。系统上的每个进程都有自己的 UID，而不是启动它的那个人的 UID。这些 UID（通常是唯一的）提供了沙箱和进程隔离。尽管如此，也有一些情况下进程可以共享 UID 和 GID。通常，当一个进程与另一个进程共享 UID 时，是因为它们都需要系统上的相同权限集并共享数据。对于 GID 来说，这也可能是可能的。然而，Android 中的一些 GID 实际上用于获取访问底层系统（如 SD 卡文件系统）的权限。简而言之，UID 用于隔离进程，而不是系统的人类用户。事实上，Android 直到其 Jelly Bean 4.3 版本才支持多个人类用户。它始终是为单个人类用户设计的设备……至少在操作上。

在这个安全模型中，有两种进程类别。第一种被称为系统组件服务。这些是在系统 init 脚本中声明的服务。它们通常具有高度特权，因此几乎从不与其他进程共享 UID。一个系统组件服务的例子是**无线电接口层守护进程**（**RILD**）。RILD 负责处理 Android 用户空间与设备上的调制解调器之间的消息。由于其执行的性质，它通常以 UID root 运行。没有要求进程必须是纯原生代码。系统服务器有非原生组件，以系统 UID 运行，并且具有高度特权。几乎所有这些系统都有一个共同的主题；它们有一个 UID，要么是 root，要么被设置为许多敏感内核对象的所有者，如套接字、管道和文件。

第二类是应用程序。应用程序通常用 Java 编写，尽管这并非强制要求；这类似于系统组件服务通常用本地代码编写，尽管也不是强制要求。这些应用程序在安装时自动分配 UID，并且系统为这个目的保留了这些 UID。包管理器负责向应用程序分配 UID。这些 UID 与系统上的任何敏感或危险内容都没有关联，并且应用程序运行时没有能力。为了访问系统资源，应用程序必须将其补充组附加到或由一个单独的过程仲裁。

当一个应用程序需要使用 SD 卡时，我们可以看到一个利用补充组的简单例子。为了访问 SD 卡，应用程序必须在其补充 GID 中具有`SDCARD_RW`。这些权限由内核通过标准的 Linux DAC 权限强制执行。补充组由包管理器在应用程序安装期间根据声明的权限分配。Android 中的应用程序必须在应用程序的清单中声明一个名为`uses-permission`的内容。这个权限作为一个字符串出现，它映射到一个补充 GID。这种映射在系统中的一个文件中维护，具体是`/system/etc/permissions/platform.xml`文件。你将在后面的章节中看到这些权限字符串的应用实例。

应用程序获取系统资源的第二种方式是通过另一个进程。希望使用系统资源的应用程序必须让另一个进程代表它执行此操作。大多数请求由一个称为**系统服务器**的进程处理。系统服务器检查发起仲裁请求的应用程序是否在其清单文件中声明了匹配的权限字符串。如果是，则允许其继续，否则会抛出安全异常。即使在 Android 中，仲裁访问也使用 DAC 模型，本质上如此。虽然对象所有者通过权限字符串控制对象上的访问规则，但任何受保护对象的消费者都可以请求权限字符串以获取访问权限。本质上，任何人都可以编写请求任何权限字符串的应用程序。在安装应用程序时，用户会看到应用程序请求的权限列表，他们可以选择全部接受或拒绝。如果用户的意图是安装应用程序，则必须授予所有请求的权限。如果用户不够小心，他们可能会无意中允许该应用程序以可能威胁设备、应用程序或用户数据安全的方式访问受保护的对象。设备的所有者应始终确保他们对应用程序使用声明的权限感到满意。

### 注意

有关示例或进一步讨论，请参阅[`developer.android.com/guide/topics/security/permissions.html`](http://developer.android.com/guide/topics/security/permissions.html)。

# Binder

之前讨论的仲裁访问方法需要某种形式的**进程间通信**（**IPC**），虽然 Android 使用 Unix 域套接字，但它也带来了自己的 IPC 机制，该机制在整个系统中被更广泛地使用。这种 IPC 机制称为 binder，是 Android 操作系统的核心 IPC 机制。它具有从 BeOS 和 Palm OS 的 OpenBinder 实现的历史相关性，并且由于最初的 Android 开发团队由许多 OpenBinder 工程师组成，binder 随着他们一起进入了 Android。然而，Android 对 binder 代码库进行了完全从头开始的重新编写，该代码库针对 Linux。

### 注意

Binder 目前尚未完全融入 Linux 内核，Android 的许多内核更改仍在进行中。

在 binder 及其主线采用方面存在一些争议。有些人反对它在驱动程序中承担的大量工作，与`dbus`等竞争实现相比。然而，我们可能还需要很长时间才能看到这场辩论的解决。无论 binder 是否继续作为 Android 特定的技术，是否在 Linux 内核中主流化，或者最终被 Android 中的另一种技术所取代，binder 在可预见的未来都将存在。

## Binder 的架构

Binder IPC 遵循客户端/服务器架构。服务发布一个接口，客户端从该接口消费。客户端可以通过两种方法之一绑定到服务：已知地址或服务名称。

系统中的每个 binder 接口都称为 binder 节点。每个 binder 节点都有一个地址。当客户端想要使用一个接口时，他们必须通过这个地址绑定到 binder 节点。这类似于通过 IP 地址浏览网页。然而，与通常在长时间内固定的 IP 地址不同，binder 地址可能会根据发布服务的重启或设备启动时的服务启动顺序而改变。进程的顺序并不完全保证，因此进程服务的发布可能会导致分配不同的 binder 令牌（一个在进程间共享的简单 binder 对象）。此外，这种间接性允许运行时仅使用发布的服务名称重新设置服务实现，而无需利用令牌。

这种重定向的方式类似于 DNS 为网络设备访问提供从名称到 IP 地址的解析。binder 有一个称为上下文管理器（也称为服务管理器）的东西。上下文管理器位于固定的节点地址 `0`。发布服务的会将名称和 binder 令牌发送给上下文管理器，然后，当客户端需要通过名称查找服务时，他们会检查 binder 节点 0 并将名称解析为 binder 令牌。binder 令牌是这个地址或 ID 的正确名称，它唯一地指向一个 binder 接口。在客户端绑定到 binder 对象（这是一个实现 binder 接口的进程）之后，进程然后使用一个经过良好建立的 binder 协议执行 binder 事务。此协议允许类似于方法调用的同步事务。

由于 binder 是一个内核驱动程序，它具有一些很好的特性，这些特性决定了跨接口可以做什么。首先，它允许传输文件描述符。它还管理一个线程池来调度服务方法。此外，它采用了一种称为零拷贝的方法，其中 binder 不会在进程之间复制任何事务数据...而是共享它们。binder 还提供了对象的引用计数，并允许服务查询客户端应用的 Linux 凭证，如 UID、GID 和 **进程 ID**（**PID**）。binder 还允许服务和客户端通过其与死亡功能的链接知道对方何时终止。

通常在 Android 中，你不会直接与 binder 一起工作。相反，你通过服务及其 **Android 接口描述语言**（**AIDL**）接口来工作。最后一章将提供关于 AIDL 在我们自定义 Android 系统中的实践详细示例，但在此期间，以下是一个简单的 AIDL 接口示例，它提供了远程进程执行 `getAccountName()` 和 `putAccountName()` 函数的手段：

```kt
package com.example.sample;

interface IRemoteInterface {
  String getAccountName();
  boolean putAccountName(in String name);
}
```

与 AIDL 接口一起工作的美妙之处在于，它可以生成大量代码来管理数据和处理过程，这些原本可能需要手动完成。例如，以下只是从前面的 AIDL 示例生成的代码的一小部分：

```kt
@Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException
{
switch (code)
{
case INTERFACE_TRANSACTION:
{
reply.writeString(DESCRIPTOR);
return true;
}
case TRANSACTION_getAccountName:
{
data.enforceInterface(DESCRIPTOR);
java.lang.String _result = this.getAccountName();
reply.writeNoException();
reply.writeString(_result);
return true;
}
case TRANSACTION_putAccountName:
{
data.enforceInterface(DESCRIPTOR);
java.lang.String _arg0;
_arg0 = data.readString();
...
```

## Binder 和安全性

绑定器的安全影响相当大。你应该能够控制谁成为上下文管理者，因为一个恶意上下文管理者可能会通过将客户端发送到恶意服务而不是正确服务来破坏整个系统。除此之外，你可能还想控制哪些客户端可以绑定到哪些绑定器对象。最后，你可能希望控制是否可以通过绑定器发送文件描述符。绑定器还具有允许某人通过接口伪造凭据的能力，该接口设计用于良好的用途。例如，一些特权系统进程，如**活动管理器服务**（**AMS**），代表其他进程执行操作。在这种伪装中暴露的凭据是你正在为其工作的进程的，而不是特权实体的。这类似于代理权，当某人代表你行事时使用。

Android 的绑定器 IPC 机制传统上使用 DAC 权限进行控制。然而，正如我们在第一章中看到的，*Linux 访问控制*，这些权限存在一些缺陷。因此，绑定器需要修改以支持 SELinux，因为绑定器驱动程序没有实现任何额外的安全模块的钩子。为此，斯蒂芬·斯莫利向谷歌发送了一个补丁，实现了这些功能。该补丁为所谓的**Linux 安全模块**（**LSM**）框架的消费者实现了新的钩子。该框架允许 LSMs（如 SELinux）被调用并做出访问决策。这个补丁的细节超出了本书的范围。只需知道绑定器已被修补，SELinux 现在可以使用 MAC 来控制其功能。

### 注意

斯蒂芬·斯莫利是美国国家安全局（**NSA**）可信系统研究组织的计算机安全研究员，并领导 SE Android 项目。他发送给谷歌以修改绑定器以实现 SELinux 钩子的补丁可以在[`android-review.googlesource.com/45984`](https://android-review.googlesource.com/45984)查看。

由于 SELinux 和绑定器的集成，Android 的 SE 有一个额外的具有访问向量的类（这是一种说法，“它能做什么的事情。”）。在第二章中的先前示例中，*强制访问控制和 SELinux*，目标类是`food`。同样，绑定器的 SELinux 类是`binder`。它定义了以下列表中列出的访问向量。如果你还记得，第二章中`food`的访问向量是`eat`。以下访问向量可用于绑定器：

+   `impersonate`: 这在绑定器接口上创建伪造的凭据

+   `call`: 这将客户端绑定到绑定器接口并使用它

+   `set_context_mgr`: 这设置上下文管理者

+   `transfer`: 这将传输一个文件描述符

# Zygote – 应用生成

在 Android 中，非本地应用历史上使用 Dalvik **虚拟机**（**VM**）并运行一种名为 DEX 的专有字节码。应用也是通过名为 zygote 的通用进程通过 fork 和 specialize 机制产生的。Zygote 本身是一个进程，它将 Dalvik VM 和一些通用类，如`java.util.*`，加载到 VM 中。fork 和 specialize 是从 zygote 到执行某些应用代码的 zygote 子进程的机制。

### 注意

自 Android 4.4 以来的 Android 版本正在用**Android RunTime**（**ART**）替换它。据推测，Android L 将根本不使用 Dalvik VM。

这个过程的第一个部分涉及套接字连接。Zygote 通过这个套接字监听应用的生成请求。一些参数包括要加载的应用的包名和一个标志，表示应用是否是系统服务器。一旦收到生成命令，fork 就可以继续了。

### 注意

追踪这个初始套接字连接的一个好方法是使用`app_process`工具。这个命令会启动一个带有 Dalvik 的进程。更多信息，请导航到`frameworks/base/cmds/app_process/app_main.cpp`。

在 fork 之后，现在的父 zygote 返回到套接字上监听更多请求。子进程正在执行，需要发生几件事情。首先需要发生的事情是 UID 和 GID 切换。Zygote 以 root UID 运行，因此为了满足 Android 安全模型，它必须将子进程的 UID 和 GID 设置为非 root。子进程将设置 UID 和 GID 为包管理器定义的，以及补充 GIDs。它还设置了进程的资源限制和调度策略。然后它将应用程序的能力集清零（无能力）。在系统服务的情况下，能力集不会被清除，而是作为通过套接字发送的参数之一设置。在此之后，子进程开始运行。zygote 中更后面的代码加载类，以及其他系统交互，如 intent 传递，用于启动活动。这些 zygote 的部分超出了本书的范围。

# 属性服务

Android 中的属性服务在所有进程之间提供了一个共享的键值对映射。Android 系统上的所有进程共享一些专门用于此系统的内存页面。然而，除了 init 进程具有`READ/WRITE`映射外，所有进程中的映射都是`只读`的。属性服务系统位于 init 中，它的任务是更新或添加到这个键值映射中的值。为了更改一个值，你必须通过属性服务进行，但任何人都可以读取一个值。如果你使用属性服务，请不要存储敏感信息。它主要被设计用于存储小值，而不是一个通用的存储大量值的存储库。以下是对属性服务的一个非常基础的介绍。稍后将会进行更深入的研究。

要设置一个属性，你必须使用 Unix 域套接字向属性服务发送一个请求。如果权限允许，属性服务将解析请求并设置值。属性有以句点分隔的段，类似于包名，它们在构建时静态地分配了权限。权限和属性服务代码可以在`system/core/property_service.c`中一起找到。通过这个接口期望的参数包括一个命令、属性名和属性值。对于那些好奇的人来说，这些都在结构`prop_msg`中定义，该结构在`bionic/libc/include/sys/_system_properties.h`中定义。在接收到消息后，属性服务将检查对等套接字的凭据与权限的静态映射进行比较。如果 UID 是 root，它可以写入任何东西，否则它必须与 UID 或 GID 匹配。在非常新的 Android 版本中，或者那些应用了从[`android-review.googlesource.com/#/c/98428/`](https://android-review.googlesource.com/#/c/98428/)补丁的版本中，权限检查和硬编码的 DAC 都被 SELinux 控制所取代。

由于设置值的权限是由用户空间使用 DAC 控制的，因此可以推断出属性设置机制共享固有的 root 漏洞缺陷。考虑到这一点，属性服务代码在 SELinux 中得到了增强。由于这是一个用户空间进程，它通过内核使用 SELinux API 来编程一个称为用户空间对象管理器的程序。这仅仅意味着用户空间应用程序会通过内核中的 SELinux 来检查，以确保它可以执行活动……在这种情况下，设置属性。

# 摘要

Android 有一些非常独特的属性。从它使用常见的 UID 和 GID 模型来促进其安全目标，到其定制的 binder IPC 机制，这些系统对设备的安全性和功能都有影响。在下一章中，当我们将 UDOO 启动并运行，并在其上启用 Android 的 SE 时，这些系统将再次发挥作用。
