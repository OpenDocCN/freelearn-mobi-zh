# 2

# 软件架构原则

在本章中，我们将介绍软件架构的基本原则。它们对软件架构的每个部分都至关重要。我们应该不断提醒自己这些原则，就像专业钢琴家每天练习音阶一样。

我们将首先介绍描述和查看软件架构的不同方法。然后，我们将介绍一些在后续章节中会引用的重要原则。目的是你可能随时回到这一章，再次思考这些关键概念。

+   视角、维度和品质

+   关注点分离、内聚性和耦合性

+   SOLID 原则

+   YAGNI 和未来证明的架构

+   Demeter 法则

# 技术需求

你可以在 GitHub 上找到本章使用的所有代码文件：[`github.com/Packt Publishing/Software-Architecture-with-Kotlin/tree/main/chapter-2`](https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-2%0D)

# 视角、维度和品质

软件系统不是我们可以轻易看到或触摸的物理对象。在它们的根源上，它们是由机器解释的指令。因此，我们需要以其他方式可视化软件系统。

可视化软件系统的主要目的是展示如何解决利益相关者的关注点。通常有一个长长的关注点列表。每个利益相关者通常在多个抽象级别上有多个关注点。不可能在一个视觉表示中从所有角度解决所有关注点。

**视图**的概念在 20 世纪 70 年代被引入，用于描述软件架构。从那时起，已经有许多努力来规范和标准化描述软件架构的方法。**ISO/IEC/IEEE 42010:2022** 是目前指定软件架构的标准，通过该标准定义了架构概念、结构和语言。

在一个视图中，只描绘了软件架构的选定视角。选择旨在解决某些利益相关者的关注点。此外，存在多个视图，因此每个视图可以针对特定的关注点和特定的利益相关者。

**视图模型**是一组视图的集合，其中每个视图都有专门的焦点、目的和可视化语言。

**4+1 架构视图模型**由 Philippe Kruchten 在 1995 年创建。它包括软件系统的四个视图，以及帮助不同利益相关者从其他利益相关者视角理解软件系统的选定场景。

![图 2.1 – 4+1 架构视图模型](img/B21737_02_1.jpg)

图 2.1 – 4+1 架构视图模型

在接下来的章节中，我们将从 4+1 架构视图模型的角度逐一查看每个视图。

## 逻辑视图

**逻辑视图**关注系统的业务功能及其实现方式。它对技术问题无关紧要。它是一个抽象视图，描述了业务功能如何工作，而不涉及技术术语，使用的是技术和非技术利益相关者都能理解的语言。它适合与非技术利益相关者进行沟通。

在家庭之间服务交换合同状态转换的例子中，逻辑视图如下所示的表达在 UML 状态图中：

![图 2.2 – 4+1 架构视图模型 – 逻辑视图](img/B21737_02_2.jpg)

图 2.2 – 4+1 架构视图模型 – 逻辑视图

两个家庭之间的服务合同首先由一个家庭起草。合同处于**草稿**状态。一旦草案完成，家庭将合同提交给另一个家庭进行审查。

在双方家庭达成协议之前，合同可以由双方家庭进行修改。在继续之前，双方家庭必须同意条款。然而，在某些情况下，合同可能被一个家庭拒绝，从而进入**拒绝**的终端状态。

假设双方家庭都同意了条款，合同仍有可能因其他情况而被撤回。假设合同继续进行，双方家庭随后行使并履行合同的条款。这标志着合同的结束，并结束了其生命周期。

## 物理视图

**物理视图**关注可部署的软件组件及其之间的互连。它也被称为**部署视图**。它适合与系统工程师、平台工程师和基础设施工程师进行沟通。

想象一下，我们在上一章中展示的 ADR 示例被批准了。有一个中心服务来保存服务交换合同的原始记录。物理视图可能看起来如下所示：

![图 2.3 – 4+1 架构视图模型 – 物理视图](img/B21737_02_3.jpg)

图 2.3 – 4+1 架构视图模型 – 物理视图

该软件已被移至基于浏览器的网络应用程序。用户通过网页浏览器作为客户端访问系统，并提交服务请求。负载均衡器是第一个接收这些请求并将它们根据每个实例的负载分配到适当的**交换服务**实例的组件。任何静态内容，如图像，都是从网络服务器获取的。**交换服务**处理请求并将结果持久化到**关系数据库**。

## 过程视图

**过程视图**关注系统的实时行为。它通常接近系统的操作，涉及内部员工或其他系统。它在展示涉及并发、性能和可扩展性的问题时很有用。这种视图促进了技术利益相关者之间的沟通。

UML 图，如序列图、交互图、活动图、通信图和时序图，有助于表示过程视图。**业务流程建模与符号**（**BPMN**）图在描述系统在业务流程上下文中的行为时也非常有用。

如果服务合同交换系统具有电子邮件通知功能，它可能看起来像下面的图：

![图 2.4 – 4+1 架构视图模型 – 流程视图](img/B21737_02_4.jpg)

图 2.4 – 4+1 架构视图模型 – 流程视图

当**家庭 A**提交一份草稿合同时，**交易所服务**验证请求并更新**关系数据库**中相应的记录。之后，**交易所服务**调用**电子邮件服务**向**家庭 B**发送关于由**家庭 A**提交的服务合同的电子邮件通知。

在这种情况下，**家庭 B**通过电子邮件通知服务合同。然后**家庭 B**向**交易所服务**提交请求，同意合同条款。随后，**交易所服务**更新**关系数据库**中的记录。

## 开发视图

**开发视图**专注于软件管理。目标受众是实际在系统中编码的程序员。

该视图侧重于开发环境中软件的静态组织。这包括多个组件如何在不同级别上协作形成一个软件系统，例如源代码包、从高级业务功能到低级实用功能的调用层次结构、类的继承层次结构和软件工件之间的依赖树。该视图的详细信息可以在源代码库中找到。

UML 包和组件图可以用来表示这个视图。一个有组织的源代码库可能会发现这些图是多余的。然而，这些图擅长突出显示包和模块之间的任何依赖问题。

服务合同交换系统中的**交易所服务**可能用 UML 包图表示，如下面的图所示：

![图 2.5 – 4+1 架构视图模型 – 开发视图](img/B21737_02_5.jpg)

图 2.5 – 4+1 架构视图模型 – 开发视图

**交易所服务**有一个包含以下内容的业务包：

1.  一个控制服务合同工作流程的模块

1.  一个掌握家庭记录的模块

1.  一个搜索服务合同历史的模块

**业务**包使用**持久化**包来执行服务合同和家庭的实际关系数据库操作。

**业务**包依赖于**验证**包，该包包含一些用于地址、电子邮件、日期和服务合同的独立验证器。

**集成**模块负责与其他服务（如**电子邮件服务**）进行通信。该模块由**业务**模块用于通知家庭。

## 场景

在 4+1 架构视图模型中，场景由*+1*表示，因为只有重要的场景会被选择进行文档记录。它侧重于用户与系统的交互以及系统如何帮助用户在他们的工作流程中。它通常用于与内部和外部用户的沟通。

UML 用例图用于场景。在服务合同交换系统的例子中，选择了服务合同的起草和执行作为用例。

![图 2.6 – 4+1 架构视图模型 – 场景](img/B21737_02_6.jpg)

图 2.6 – 4+1 架构视图模型 – 场景

**家庭 A**提交一份待**家庭 B**审查的合同。在达成一致之前，合同可以进行修改。一旦家庭就合同条款达成一致，他们就会执行服务合同直至完成。

我们已经讨论了 4+1 架构视图模型，该模型从至少五个角度可视化系统的架构。每个角度都使用不同的维度来突出显示一次的某些方面。每个视图都有其自身的受众，在沟通时非常有用。

接下来，我们将探讨系统质量属性，这些属性可以用来描述、衡量和预测系统性能的好坏。

### 系统质量属性

如果有两个功能上完全相同的系统，我们如何比较和评估哪个系统表现更好？我们可以使用系统质量属性来衡量和比较这两个系统。

系统质量属性独立于系统提供的业务功能存在。它们是纯粹的技术属性，决定了系统是否能够平稳运行。要求具有某些系统质量属性被称为**非功能性需求**（NFRs）或**跨功能需求**（CFRs）。

区分功能需求和 NFRs（非功能性需求）很重要。功能需求定义了系统做什么，而 NFRs 定义了如何满足这些需求。功能需求指定了系统的功能，而 NFRs 定义了其质量、行为和性能特征。

系统质量属性有许多维度。在这里，我们将突出一些将在后续章节中涵盖的系统质量属性：

+   **正确性**：这衡量系统是否按规格描述的行为。这可以被称为**应用程序编程接口**（API）文档、操作手册，或者简单地称为功能合同。

+   **可用性**：这衡量的是系统的正常运行时间或它能够运行并执行其目的的时间。

+   **鲁棒性**：这指的是系统在存在故障部分和/或面临重压时可以提供的服务水平。

+   **弹性**：这指的是系统从故障中恢复、继续运行并从意外中断中恢复到完全功能状态的速度。

+   **性能**：这衡量了系统响应请求的速度以及系统一次可以处理多少请求。

+   **可伸缩性**：这衡量了系统如何灵活地扩展以应对变化的数据量和延迟要求。这是系统扩展或缩小的能力。

+   **可观察性**：这指的是系统的外部视图如何帮助我们确定其内部状态。外部视图可以由日志消息、图表、警报、文件或系统远程调用的有效载荷表示。

+   **可管理性**：这衡量了在操作、监控、配置和管理方面管理和控制系统的容易程度。

+   **可维护性**：这衡量了维护一个运行系统有多容易。这可能包括源代码、更新基础设施、修改构建管道和调整环境。

+   **可扩展性**：这衡量了随着业务的增长，扩展当前系统功能以包括新功能的容易程度。它包括修改和增强当前系统所需的时间、复杂性和努力。

+   **可测试性**：这衡量了测试可以覆盖系统功能程度的范围。它不仅限于要测试的业务功能，还包括对其他系统质量属性的评估。

+   **可重用性**：这指的是系统的各个组件可以用于其他目的的程度。这不仅包括软件模块和源代码，还包括业务功能和流程。

+   **可用性**：这转化为与系统一起工作时用户体验有多好。它不仅限于将系统视为黑盒的最终用户，还包括其他利益相关者，如内部用户、系统操作员、管理员和程序员。

我们已经介绍了一些重要的系统质量属性，这些属性将在后面的章节中提到。我们将讨论推动现代软件架构和帮助我们改进现有系统的基本架构原则。

# **关注点分离**、**内聚性**和**耦合**

一个系统由许多组件及其相互之间的连接组成。在系统中分组和分离元素的能力已成为确保其可维护性、可重用性和可扩展性的关键因素。我们将介绍三个基本概念，这些概念将帮助我们适当地分组和分离元素，即**关注点分离**、**内聚性**和**耦合**。

## **关注点分离**

关注点分离是一个我们应该在系统每个角落应用的基本原则。这是一个主张将系统分割成独立的组件，并让每个组件处理特定关注点的原则。关注点分离旨在创建一个更容易维护、推理和更新，并且能够适应随时间变化的需求的系统。

让我们以以下场景为例：从家庭的浏览器提交草拟服务交换合同到**交换服务**，通过**表示状态转移**（**REST**）进行，有效载荷以**JavaScript 对象表示法**（**JSON**）格式。

首要关注点可能是确保**交换服务**只获取正确信息以在**关系数据库**中创建草拟服务。

在正确性类别中，存在多个级别：

1.  请求有效载荷需要符合约定的结构；否则，应返回 HTTP `400`（错误请求）状态。

1.  要交换的服务不能为空；否则，应返回 HTTP `400`（错误请求）状态。

1.  合同中的家庭必须在系统记录中已存在；否则，应返回 HTTP `404`（未找到）状态。

1.  提交草拟合同的该家庭必须已经登录；否则，应返回 HTTP `401`（未授权）状态。

1.  提交草拟合同的该家庭必须已经经过验证；否则，应返回 HTTP `403`（禁止）状态。

1.  如果请求通过所有验证检查并且合同持续存在，则应返回带有持久化记录的有效载荷的 HTTP `200`（OK）状态。

1.  如果请求通过所有验证并且合同持续存在，则合同应处于**草拟**状态。

列表还在继续。然而，我们可以看到，例如，有效载荷在句法层面。另一方面，返回的 HTTP 状态在合同通信层面，而处于正确状态是在语义层面。

如果对系统某一部分的一个关注点的更改没有影响到其他关注点，那么这个更改与关注点分离原则是一致的。

要在修改系统时分离关注点，系统的一些部分需要分组在一起，而其他部分则需要分离。

一个组件内软件元素之间紧密相关的程度可以通过内聚性来衡量。每个组件的独立程度可以通过耦合度来衡量。

## 内聚性

与彼此紧密相关的软件组件具有一些属性。首先，它们承担相似的责任，并且很可能有一个共同的目标。其次，如果你更改一个组件，其余的组件可能也需要更改。最后，它们至少以一种方式协调和合作。链式函数调用是内聚组件的例子。

软件组件可以通过以下方式实现内聚。

### 水平内聚

水平内聚组件被分组在一起，以提供与特定实现相关的功能。例如，与特定外部系统集成相关的组件被分组在一起，以将特定供应商的实现关注点与系统提供的功能行为分开。在审查供应商选择的情况下，工程师可以用针对不同供应商系统的另一组组件替换这个组件组。这种内聚方法支持易于维护和理解的即插即用结构。

### 垂直内聚

垂直内聚组件根据它们共同提供的功能行为进行分组。垂直内聚通常涉及对组内组件共享的数据和行为进行**封装**。例如，负责为管理家庭提供**创建、读取、更新、删除**（**CRUD**）操作的组件可以分组在一起。这种分组清晰地说明了系统的行为。当必须修改行为时，工程师可以专注于一个小区域，从而降低更改的风险。

### 线性内聚

线性内聚组件由于执行顺序或控制流的顺序而被分组在一起。这可以通过函数调用的链或事件通信的连锁反应来体现。这种分组为较小的任务或过程如何融入更大的工作流程提供了清晰性和可见性。

### 交互内聚

交互内聚组件根据它们之间通信和交互模式的频率进行分组。例如，某个函数的 HTTP 服务和客户端库被分组在具有不同模块的项目下。当通信协议发生变化时，工程师可以在一个项目中找到大部分必要的更改。这减少了更改的成本和努力。同时，它也确保更改被限制在一个区域内。

以下是一个家庭验证的示例：

```kt
data class Household(
    val name: String,
    val members: List<Person>,
)
data class Person(
    val firstName: String,
    val lastName: String,
    val age: Int,
    val skills: List<String>,
)
fun Household.validate(): List<String> =
    listOfNotNull(
        if (name.isBlank()) "name must not be empty" else null,
    ) + members.flatMap { it.validate() }
fun Person.validate(): List<String> = listOfNotNull(
    if (firstName.isBlank()) "first name must be non-empty" else null,
    if (lastName.isBlank()) "last name must be non-empty" else null,
    if (age < 0) "age must be non-negative" else null,
)
```

一个家庭有一个名称和成员列表。每个成员都有一些基本字段，如名和姓。基本的家庭验证将涉及确保家庭名称不为空；此外，还需要确保家庭中的每个人都能通过验证。例如，年龄不能是负数。

在这个例子中，一个家庭的验证依赖于该家庭中一个人的验证。验证家庭和个人的功能是垂直内聚的，因为它们以高阶函数的形式作为验证功能。它们也是线性内聚的，因为家庭的验证函数调用了个人的验证函数。

高内聚性将相关组件集中在一个地方。这说明了组件的整体行为，使得行为更容易理解。它还促进了更好的可测试性，因为工程师可以在一个地方测试组件的整体行为。将相关组件保持在同一个地方也意味着在做出更改时移动部件更少，这降低了风险。整体行为可以被视为一个单元，系统的其他部分可以重用它。

另一方面，低内聚性导致相关组件散布在各个地方，使得它们难以理解、修改和维护。它会在组件之间创建不适当的耦合，使得在不影响系统其他无关部分的情况下进行更改变得更加危险。试图修改一个系统的质量属性可能会意外地改变其他属性。在做出更改时，也更有可能创建错误。由于它带来了不太可能适合用例的依赖，因此修改组件变得难以重用。

## 耦合

在内聚性的背景下，耦合是一个坏主意，但耦合的测量却一点也不坏。它提供了系统中的软件组件之间相互依赖性的视图。

耦合是不可避免的，但可以通过一种促进更好的可维护性、可重用性和理解性的方式来最小化。尽可能限制组件之间的交互是更好的选择。

### 功能耦合

为了限制组件之间的交互，我们必须区分需要做什么和如何做。在先前的例子中，“需要做什么”是验证包括其成员的家庭；“如何做”是验证函数通过每个字段运行，并将违反的条件添加到要返回的列表中。如果返回的列表为空，则家庭是有效的。

软件组件执行的工作的定义是提供者和调用者之间的合同。它通常包括一个输入、可选状态和一个输出。调用者关心提供输入和接收输出，但不关心软件组件内部发生的事情。另一方面，提供者关心如何根据给定的输入计算输出，并可选地更新状态。

这份合同通常被称为提供者和调用者之间的接口。它为松散耦合的软件组件提供了一个良好的基础。当双方的交互都围绕接口进行时，调用者现在可以灵活地切换到另一个能够履行合同的提供者。提供者无需为想要重用此功能的另一个调用者做任何额外的工作。

这种耦合类型被称为**功能耦合**。它基于软件组件之间的合同或接口。

### 数据耦合

软件组件可能需要与另一个组件共享的数据才能正常工作。数据所有权是一个独立的话题。然而，从简单意义上讲，如果只有一个组件创建、更新或删除一类数据，那么该组件就拥有这些数据。

几乎可以肯定，如果多个组件拥有相同的数据，那么在保持数据可靠性和一致性方面将出现重大问题。在这种情况下，两个组件真正拥有自己的数据会更好。

有几个选项可以考虑：

1.  是否应该将共享相同数据的组件合并为一个组件？

1.  数据的所有权是否可以分散到各个组件中，使它们不再共享相同的数据？

1.  是否可以提取一个新的组件来拥有数据，而其他组件成为数据变化的监听者？

1.  是否应该由一个组件承担创建、更新和删除数据的全部责任，从而成为数据的所有者？这将意味着其他组件成为数据变化的监听者。

1.  是否每个组件都应该拥有数据的副本，并让每个副本在每个组件中都是多样化的？

1.  在有差异处理流程的情况下，每个组件是否可以保留另一个组件拥有的数据的独立副本？

由于软件组件可以拥有数据，因此对于组件来说，决定应该对外暴露多少数据非常重要。组件应该封装数据以隐藏任何内部数据，并且只向其他组件暴露与接口相关的字段。

此外，通常很有必要将数据的内部和外部表示分开。例如，一个包含内部错误枚举值的列表可能包含无意中暴露组件内部状态的信息。

例如，假设有一个登录操作有多个内部错误枚举值，那么 Kotlin 枚举类将如下所示：

```kt
enum class InternalError {
    WRONG_PASSWORD,
    USERNAME_NOT_FOUND,
    FAILED_CAPTCHA,
    TIMED_OUT,
    INVALID_REQUEST
}
```

如果我们公开所有这些值，组件的调用者将能够理解即使登录操作失败，用户名是否存在，或者两者都有效但验证码挑战失败。这些对于组件的外部来说是不必要的细节，应该被隐藏。这还不包括显然的安全问题。因此，我们可以创建一个外部错误枚举值列表，只显示对调用者感兴趣的内容：

```kt
enum class ExternalError {
    FAILED_AUTHENTICATION,
    TIMED_OUT,
    INVALID_REQUEST
}
```

### 时间耦合

如果两个软件组件都需要在整个操作过程中都可用，它们就可以在时间上耦合。例如，组件 A 可能需要调用组件 B 的同步远程调用来继续处理其传入的请求。更糟糕的情况是多个组件之间的多个远程级联调用链。以下 UML 时序图中描述了时间耦合组件的例子：

![图 2.7 – 同步拉取交互](img/B21737_02_7.jpg)

图 2.7 – 同步拉取交互

每次进行同步调用时，它都会阻塞线程，直到返回答案或超时。这也被称为**基于拉取**的方法。如果我们有多个这样的调用，很容易导致原始请求超时错误。

同步远程调用具有阻塞线程、拉取数据和依赖于组件可用性的特性。在某些情况下，由于时间敏感性，同步远程调用可能是必要的，例如当服务必须在给定秒数或超时时间内验证用户时。

如果所有的同步远程调用只是为了提供数据，那么我们可以考虑异步和**基于推送**的方法。使用这种方法，组件 A 订阅了一个主题，当数据发生变化时，组件 B 会发布一个事件。然后组件 A 在本地保留数据的副本。这样，组件 A 就不再需要组件 B 可用来处理请求；组件 A 使用最后已知的值。组件之间异步推送交互的例子如图 *图 2.8* 所示：

![图 2.8 – 异步推送交互](img/B21737_02_8.jpg)

图 2.8 – 异步推送交互

如果组件 A 和 B 之间的交互更程序化和顺序化，那么通过使用事件进行反应性和异步操作，组件仍然可以松散耦合。在这种情况下，组件 A 已经处理到需要组件 B 的点，因此组件 A 发送一个事件，组件 B 接收它。然后组件 B 执行工作。当组件 B 完成其部分时，它发送一个事件，组件 A 接收。然后组件 A 继续剩余的工作。组件之间异步反应事件驱动的交互可以通过以下 UML 时序图表示：

![图 2.9 – 异步反应式事件驱动交互](img/B21737_02_9.jpg)

图 2.9 – 异步反应式事件驱动交互

我们已经讨论了关注点分离、内聚性和耦合性的原则。我们探讨了它们为什么重要以及这些概念的应用如何影响系统质量属性。我们还通过实时世界的实例介绍了内聚性和耦合性的子类别。它们是三个不同的概念，但常常相互关联。

接下来，我们将介绍**SOLID 原则**。这些原则鼓励具有分离关注点、高度内聚组件和组件之间低耦合的软件架构。

# SOLID 原则

SOLID 原则是一组五个软件架构原则，主张创建可维护、可理解、灵活和模块化的软件。尽管它们最初是针对面向对象软件的，但它们背后的概念是有用的，并且可以应用于除面向对象以外的系统。

这些概念最初由 Robert J. Martin 在 2000 年的论文《设计原则和设计模式》中提出。然而，SOLID 缩写是由 Michael Feathers 后来引入的。

缩写 SOLID 代表以下内容：

+   **单一职责** **原则** （**SRP**）

+   **开闭** **原则** （**OCP**）

+   **里氏替换** **原则** （**LSP**）

+   **接口隔离** **原则** （**ISP**）

+   **依赖倒置** **原则** （**DIP**）

我们将逐一介绍它们，并使用我们已讨论的概念进行讨论。

## SRP

SRP 指出，一个类应该有一个责任或关注点，只有一个。只有一个变化的原因。如果一个符合这个原则的类有一个清晰和明确的目的，那么它更容易理解、测试和维护，这可以被视为一个例外。

让我们看看一个违反 SRP 的类：

```kt
interface HouseholdService {
    fun create(household: Household): Household
    fun draftContract(contract: Contract)
    fun notifyHouseholds(contract: Contract)
}
```

`HouseholdService`接口负责创建家庭、起草合同以及通知参与合同的家庭。这个类可能会因为这些操作中的任何一个发生变化而改变。

我们可以将示例重构以符合 SRP：

```kt
interface HouseholdService {
    fun create(household: Household): Household
}
interface ContractService {
    fun draftContract(contract: Contract)
}
interface NotificationService {
    fun notifyHouseholds(contract: Contract)
}
```

现在`HouseholdService`只负责管理家庭。`ContractService`接口仅负责起草合同。`NotificationService`仅旨在通知参与合同的家庭。现在每个类只有一个责任和一个变化的原因。

这种变化带来了一些额外的益处。现在每个类都更容易测试、更容易理解和维护。每个类可以独立地发展和扩展其功能。单个类中的一个关注点可以解决，而不会影响其他类。其他类也可以轻松地重用这些类中的一个，而不会引入一些永远不会使用的功能。

## OCP

OCP 声明，软件组件如类、模块和函数应该是可扩展的，但对修改是封闭的。

一个组件是*开放的*，如果其行为可以在不修改现有代码的情况下进行扩展。一个高度内聚的组件已经包含了所有紧密相关的元素，因此行为的扩展只需要使用已经提供的内容，而不需要修改内部的代码。

一个组件是*封闭的*，如果它可以被其他组件使用。我们应该能够修改实现而不改变行为。一个松耦合的组件提供了一个简单直接的方式，使其可以被其他组件使用，而不会引入其他可能不希望包含的依赖项。

在以下示例中，存在一个`NotificationService`，它会通知涉及合同的住户合同的状态：

```kt
interface NotificationService {
    fun notifyHouseholds(contract: Contract)
}
class SmsNotificationService : NotificationService {
    override fun notifyHouseholds(contract: Contract) {
        // send SMS messages to household's phone numbers
    }
}
class EmailNotificationService : NotificationService {
    override fun notifyHouseholds(contract: Contract) {
        // send messages to household's email addresses
    }
}
```

我们有一个定义了`notifyHouseholds(contract: Contract)`函数的接口。`SmsNotificationService`和`EmailNotificationService`是这个接口的具体实现。

如果我们想要通过添加新的通信方式来扩展行为，例如电话应用通知，我们可以创建一个新的具体实现，而不需要修改任何现有代码。此接口对扩展是*开放的*。

我们可以在其他需要通知住户关于其合同的情况中重用此接口。我们可以更新`EmailNotificationService`与**简单邮件传输协议**（**SMTP**）服务器的认证方式，而不改变接口。此接口对修改是*封闭的*。

## LSP

LSP 声明，超类中的对象可以被其子类的对象替换，而不会改变系统的修正。

换句话说，所有子类都应该在功能上与其超类行为相同。

从前面的示例中，`NotificationService`指定了`notifyHouseholds`函数将通知给定合同中的住户。从行为函数的角度来看，它可以通过电子邮件、短信或任何其他通信方式来完成。然而，所有这些子类都应该通知给定合同中的住户。

相反，如果存在一个`PhoneNotificationService`，它不仅通知参与合同的住户，还将合同状态更新为`UNDER_REVIEW`，这将违反 LSP。这是因为如果用`PhoneNotificationService`替换`EmailNotificationService`，合同状态将被更新，而这种情况在替换之前是不会发生的：

```kt
class PhoneNotificationService : NotificationService {
    override fun notifyHouseholds(contract: Contract) {
         // ring an automated message to household's phone
   // also update contract status to UNDER_REVIEW
    }
}
```

如果我们遵守 LSP，那么我们将拥有高度内聚的类，因为它只关注类在行为上与其超类等效，而不关注其他方面。

## ISP

ISP 声明，客户端不应该被迫依赖于他们不使用的接口。

这个原则提倡接口应该针对使用它们的客户端的需求进行设计。这可能导致以下几种结果：

+   **小而多的接口**：接口很小，因此客户端不需要依赖于他们未使用的接口中的功能。由于每个接口都较小，因此可能存在更多的接口来覆盖相同的功能范围。

+   **相关性**：接口是相关且针对客户端需求的。不同的客户端可能有独特的需求。因此，可能存在几个特定于不同客户端的特定接口。可能存在功能重叠，并且一些客户端可能希望有独特的行为，这些行为只与他们相关。

+   **更高的内聚性**：每个接口应只包含相关的功能，并且理想情况下专注于一个职责。

+   **松耦合**：由于接口较小，与其他组件的耦合也更松。

这是一个违反 ISP 的例子：

```kt
interface Human {
    fun logOn()
    fun exerciseContract()
}
data class User(val username: String) : Human {
    override fun logOn() {
        // user log on
    }
    override fun exerciseContract() {
        throw UnsupportedOperationException("user cannot exercise contract")
    }
}
data class HouseholdMember(val name: String) : Human {
    override fun logOn() {
        throw UnsupportedOperationException("household members do not log on")
    }
    override fun exerciseContract() {
        // exercise contract
    }
}
```

`Human`接口有两个功能：`logOn`和`exerciseContract`。有两个具体的实现：`User`和`HouseholdMember`。虽然用户和家庭成员都是人类，但在功能上他们没有任何共同点。这两个子类被迫实现了他们不需要的功能。接口应该被分离，以便它们专门针对用户和家庭成员的功能。

## DIP

DIP 包含两个部分：

1.  高级组件不应该直接依赖于低级组件。两者都应依赖于抽象。

1.  抽象不应当依赖于细节；细节应当依赖于抽象。

抽象可以指代接口，而细节可以指代具体的实现。这个原则背后的逻辑是，组件的使用者应该只关心组件的行为，而不是其实现。

例如，如果我们想在工作流中重用通知参与合同的家庭的组件，那么这个原则建议我们将该组件引用为`NotificationService`类型，即使我们知道`EmailNotificationService`是具体的实现。

这种方法带来了一些好处：

+   `NotificationService`接口可以被模拟或替换为`EmailNotificationService`。我们的单元测试关注的是如何与`NotificationService`交互，处理`notifyHouseholds`函数的几种类型的输出。

+   对`NotificationService`的依赖可以在运行时注入或查找。这给了我们灵活性，可以将其与不同的具体实现交换，并且功能仍然可以正确运行。一个**控制反转**（**IoC**）容器框架可以支持注入的实现。

+   与`NotificationService`的耦合被放松，只关注行为。

+   由于交换`NotificationService`的具体实现不需要代码更改，代码更容易维护。

+   通过提供不同的具体实现，更容易扩展`NotificationService`。

让我们看看接下来的例子，看看它是否遵循 DIP：

```kt
class ContractWorkflowService(
    val emailNotificationService: EmailNotificationService,
) {
    fun agree(contract: Contract): Contract {
        return contract.copy(agreedAt = Instant.now()).also {
 emailNotificationService.notifyHouseholds(contract)
        }
    }
}
interface NotificationService {
    fun notifyHouseholds(contract: Contract)
}
class EmailNotificationService : NotificationService {
    override fun notifyHouseholds(contract: Contract) {
        // send messages to household's email addresses
    }
}
```

`ContractWorkflowService`有一个标记合同为`agreed`的函数。合同达成一致后，它调用`EmailNotificationService`通知家庭关于协议。然而，`ContractWorkflowService`使用接口`NotificationService`的函数，而不是子类。

没有必要让`ContractWorkflowService`引用具体实现，因为该服务不关心通知是通过电子邮件还是其他渠道发送。这是违反 DIP 的。

# **迪米特法则**

**迪米特法则**，或最小知识原则，指出软件组件应该对其他组件的内部细节了解有限。更具体地说，一个组件不应该了解另一个组件的内部细节。

假设有一个函数返回人的地址中的城市：

```kt
class Person(val name: String, val address: Address) {
    fun getAddressCity(): String {
        return address.city
    }
}
class Address(val city: String)
```

`Person`类直接访问`Address`类内部的`city`属性。`Person`类不应该拥有这种知识，因为这违反了**迪米特法则**。

这在`Person`和`Address`之间创建了一种耦合。耦合规定，如果`city`属性的数据类型发生变化，那么两个类都需要更改。这也意味着代码更改比必要的更大，因此使其更难以维护和测试。

为了符合迪米特法则，`getAddressCity`函数应由`Address`类提供。这减少了`Person`类获取地址城市的责任，从而降低了代码库的复杂性。

# YAGNI 和未来证明架构

**YAGNI（你不会需要它）**是一个原则，它指出功能不应该在需要之前实现。这个原则来源于**极限编程（XP**）作为提高软件质量和应对不断变化业务需求的方法。

这个原则也与软件开发中的极简主义思想相关，它指出我们应该避免不必要的代码和复杂性，以换取干净、易于理解且可扩展的软件。

另一种描述 YAGNI 的方式是作为执行最简单可行事情的命令。这绝对不是不完整的设计或未满足的用户需求。它仍然促进完整且功能齐全的软件，以最简单的可用设计满足用户需求。

YAGNI 旨在以下实践：

+   **简单且精简的代码库**：通过只实现当前必要的功能，可以避免很多复杂性。因此，代码库简单、干净且易于维护。

+   **过度工程预防**：过度工程发生在工程师预测未来需求并在系统中包含未使用的功能时。这不仅导致在非必要工作上浪费了时间，而且成为代码库中的累赘，使得维护变得更加困难。过度设计的代码还意味着在做出选择之前，没有足够的信息来做出那个选择，过早地锁定了一种方法。

+   **自适应和灵活的实施**：通过推迟功能的实施直到需要时，工程师在功能最终需要时有了更多的选择来适应变化。这也鼓励系统进行更有机的进化，工程师能够更有效地响应不断变化的需求。

+   **生产力**：通过关注绝对必需的需求，工程师可以更快、更有效地交付变更。任何不必要的功能都可以推迟，节省时间和资源。

虽然也有相反的观点：**未来证明的架构**。它旨在创建不太可能在未来过时或失败的系统。这听起来非常吸引人。如果我们能够构建一个能够满足未来需求系统，我们将节省那些本可以用来不断进化系统的宝贵时间和精力。

然而，这背后有一个假设。你需要预测新的需求，并且你需要预测正确。这相当于知道未来。这种情况很少发生。

如果你确信将来需要某个功能，那么这既不是预测也不是未来的需求。这只是一个现在的需求。

这并不意味着我们应该基于短期目标或走捷径来构建系统。相反，我们应该构建能够适应新需求的系统，但不要立即实现这些需求。

**容量规划**不应被误解为未来证明的架构。容量规划是与部署和物理资源相关的运营问题。例如，建造一条可以处理当前交通量两倍的道路与建造一条没有去处的道路分支不同。为扩展、额外容量和额外交通留出空间是进化准备的一部分。容量规划是一个非功能性需求（NFR），而不是未来的需求。我们不希望系统在可能因请求量波动而崩溃的边缘运行。

这种心态导致了一些结果。软件架构旨在实现模块化、可扩展和灵活的组件，这些组件在必要时可以做出改变。

这意味着每个组件具有高度的内聚性但耦合性较弱。这意味着接口小且具体。这也意味着组件之间的交互基于抽象接口而不是具体实现。进一步来说，这意味着子类符合其超类的行为，并准备好进行扩展。此外，这意味着每个组件只有一个改变的理由。这也意味着修改组件不需要重新编译整个系统。这也意味着关注点被分离，这样当我们想要调整系统质量属性时，我们可以单独处理特定的关注点。

# 摘要

我们介绍了 4+1 架构视图模型，以及系统质量属性、关注点分离、内聚性、耦合性、SOLID 原则和迪米特法则。我们通过代码示例演示了这些原则。这些示例表明，遵循这些原则可以使代码变得模块化、灵活、易于维护、可扩展且易于理解。

我们还讨论了 YAGNI 原则和未来兼容架构的冲突概念。我们阐明了什么是未来兼容性以及它与容量规划的差异。

在下一章中，我们将探讨多态及其替代方法。
