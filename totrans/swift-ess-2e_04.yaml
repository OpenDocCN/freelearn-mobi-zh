- en: Chapter 4. Storyboard Applications with Swift and iOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Storyboards were originally introduced in Xcode 4.2 with iOS 5.0\. Storyboards
    solved the problem of being able to graphically present the flow of screens in
    an iOS application, and they also provided a way to edit the content of these
    screens in one place instead of many separate `xib` files. Storyboards work in
    the same way with Swift as with Objective-C, and the *Swift and storyboards* section
    shows how to integrate Swift code with storyboard transitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will present the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create a storyboard project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating multiple scenes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using segues to navigate between scenes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing custom view controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting views to outlets in Swift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Laying out views with Auto Layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using constraints to build resizable views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storyboards, scenes, and segues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Xcode 7 creates a `Main.storyboard` file instead of a `MainWindow.xib`
    file for newly-created iOS projects. The `UIMainStoryboardFile` key in the `Info.plist`
    file points to the application's main storyboard name (without the extension).
    When the application starts up, the `Main.storyboard` file is loaded instead of
    the `NSMainNib` entry. Prior versions of Xcode allowed developers to opt in or
    out of storyboards, but with Xcode 7, storyboards are the default and developers
    cannot easily opt out. It is still possible to use the `xib` files for individual
    sections of an application or to use them to load custom classes for prototype
    table cells. In addition, Xcode 7 creates a `LaunchScreen.storyboard` to display
    as a splash screen (on iOS 8 and higher) while the application is loading, in
    preference to prerendered screens at fixed resolutions. This allows devices with
    many different resolutions (including future unannounced ones) to render pixel-perfect
    splash screens without having to be rendered at different resolutions for each
    new device size.
  prefs: []
  type: TYPE_NORMAL
- en: A *storyboard* is a collection of *scenes* (separate screens) that are connected
    with *segues* (pronounced *seg-ways*). Each scene is represented by a *view controller*,
    which has an associated *view*. Segues transition between different scenes with
    a customizable user-interface transition, such as a slide or fade, and they can
    be triggered from a UI control or programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a storyboard project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the default templates with Xcode 7 use storyboards by default, any of the
    templates will work. In fact, each of the application templates set up a specific
    type of view controller and template code. The simplest template to work with
    and customize is the **Single View Application**, which can be selected by navigating
    to **File** | **New** | **Project…**. Create a project called `Storyboards`, which
    uses a single-view application, for experimentation with this chapter. (Refer
    to the *Creating a single view iOS application* section in [Chapter 3](part0029_split_000.html#RL0A1-d7e55eb5242648e89c396442afe4f84b
    "Chapter 3. Creating an iOS Swift App"), *Creating an iOS Swift App*, for more
    details on how to create a new application.)
  prefs: []
  type: TYPE_NORMAL
- en: Scenes and view controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Standard view controllers can be used to build up an application, which includes
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Split views using a `UISplitViewController` class, which can contain any of
    the following but may not be embedded in any other view controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tabbed views using a `UITabBarController` class, which can contain any of the
    following but may only be embedded in a split view or used as the root controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigational controls can be added to existing controllers with a `UINavigationController`
    class, which can contain any of the following and may be embedded in any of the
    preceding or used as a root view controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paginated views using a `UIPageViewController` class, which provide both sliding
    and page curling display options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tabular views using a `UITableViewController` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grid views using a `UICollectionViewController` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Audio-visual content using a `AVPlayerViewController` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenGL ES content using a `GLKViewController` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom controller content using a `UIViewController` class or a custom subclass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These classes can be mixed, but there is an explicit ordering that must be
    followed to satisfy the Apple **Human Interface Guidelines** (also known as the
    **HIG**). These are all optional, but if combined, they need to obey this ordering:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scenes and view controllers](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In addition to the standard view controller classes, custom subclasses can be
    used as well. This is covered in more detail in the *Custom view controllers*
    section later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Adding views to the scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Main.storyboard` file can be opened by clicking on the file in the project
    navigator. An editor will open, which shows the storyboard as a set of scenes
    along with the document outline on the left. In a single-page application, only
    one view controller will exist.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding views to the scene](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The arrow to the left of the view controller indicates that this scene is the
    *initial view controller*. This can also be set with the **Is Initial View Controller**
    checkbox, which can be seen by selecting the **View Controller** from the scene
    and navigating to the *attributes inspector* (go to **View** | **Utilities** |
    **Show Attributes Inspector**, or press *Command* + *Option* + *4*). The initial
    view controller can also be changed to a different scene by dragging and dropping
    the arrow to point to a different scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'Views are added by dragging and dropping them from the *object library* at
    the bottom-right of Xcode. The object library can be shown by navigating to **View**
    | **Utilities** | **Show Object Library**, or by pressing *Command* + *Option*
    + *Control* + *3*. Click on a view, such as the **Label**, and drag it into the
    view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding views to the scene](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The label''s text content can be modified by double-clicking on the label in
    the view and typing or by selecting the object and editing the text attribute
    in the attributes inspector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding views to the scene](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When the element is dragged, blue guide lines may be shown. They suggest locations
    for the views; the standard is to have a 20pt gap between the views and the edge
    of the screen and an 8pt gap between adjacent views.
  prefs: []
  type: TYPE_NORMAL
- en: Drag the **Welcome to Swift** label to the top-left of the scene and then drag
    a **Button** from the object library into the scene. Rename the button's title
    to **Press Me**. This button should be a standard space (8pt) away from the label
    and aligned at the baseline (the level at which the text naturally sits).
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding views to the scene](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, the text in the views is hardcoded in the user interface file
    and the alignment is manual, which means that the views will not resize if the
    parent view is modified. These problems will be addressed in the *Connecting views
    to outlets in Swift* and *Using Auto Layout* sections later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To view the storyboard in the simulator, click on the **Play** button at the
    top or press *Command* + *R* to run the application. A window should be shown
    with **Welcome to Swift** and **Press Me**. At this stage, pressing the button
    will have no effect, which will be fixed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Segues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *segue* is a transition to a different scene in a storyboard. Segues can be
    hooked up to views on the screen or can be triggered via code. The most common
    transitions are when the user has selected a view in the user interface, such
    as a button, a table row, or a details icon, and a new scene is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate a segue, a new scene is required. Drag a **View Controller**
    from the object library and drop it onto the storyboard. The exact location of
    the view controller doesn''t matter, but conventionally, scenes are organized
    from left to right in the order in which they will be viewed, so dropping it on
    the right-hand side of the existing view controller is recommended, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Segues](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once the **View Controller** has been added, drop a label onto the top-left
    and change the text to **Please do not press this button again**. This will present
    a visual clue that the screen has changed when the segue is followed.
  prefs: []
  type: TYPE_NORMAL
- en: Now, select the **Press Me** button and press the *Control* key while dragging
    the mouse to the newly created view controller. When the mouse button is released,
    a pop-up menu will be shown with a number of options that are grouped into **Action
    Segue** and **Non-Adaptive Action Segue**. The former is preferred; the latter
    is only there for backward compatibility and might be removed in the future.
  prefs: []
  type: TYPE_NORMAL
- en: '![Segues](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Alternatively, the object can be selected from the *document outline* on the
    left, and dragged to the object below in the document outline. It is possible
    to drag from the view in the editor area to an object in the document outline
    and vice versa. Dragging to the document outline is sometimes faster and more
    accurate, especially when there are multiple scenes in a storyboard. The document
    outline can be displayed by navigating to **Editor** | **Show Document Outline**,
    if it is not visible, or by clicking on the icon at the bottom-left of the editor.
  prefs: []
  type: TYPE_NORMAL
- en: Choose the **Show** option and a segue will be created between the two views.
    This is represented as an arrow connecting them and another object in the document
    outline. The icon inside the circular-segue line shows what kind of transition
    will occur; a **push** will have an arrow pointing to the left, while **present
    modally** will be represented as a square box. The **popover** type will show
    a small popover icon in the segue.
  prefs: []
  type: TYPE_NORMAL
- en: '![Segues](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Run the application in the simulator and click the **Press Me** button. A window
    should slide up and display the second message.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There will be no way to dismiss or exit the second screen. This is intentional
    and will be fixed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a navigation controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When there are multiple screens to be displayed, a parent controller is required
    to keep track of which screen is currently being shown and what the next step
    (or previous step) is. This is the purpose of a *navigation controller*; although
    it has no direct visual representation, it is represented as a scene in a storyboard
    and can affect the layout of the individual elements in the storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'To embed the initial scene into a navigation controller, select the initial
    view and navigate to **Editor** | **Embed In** | **Navigation Controller**. This
    will create a new navigation controller view and place it to the left-hand side
    of the first scene. It will also change the initial view controller to the navigation
    controller and set up a *relationship segue* with the name **root view controller**
    between the navigation controller and the first scene that is represented by an
    icon that is similar to a percent symbol but with the line rotated the other way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a navigation controller](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It will be necessary to move the label and button below the newly added navigation
    bar so that they are still visible. This can either be done before the navigation
    controller is introduced or by selecting through overlapping objects.
  prefs: []
  type: TYPE_NORMAL
- en: To temporarily hide the navigation bar, delete the relationship segue between
    the navigation controller and the welcome scene, and the navigation bar will disappear.
    This will allow the objects to be selected and moved elsewhere temporarily in
    order to be repositioned. To add it back again, press the *Control* key and drag
    the mouse cursor from the navigation controller to the welcome scene and choose
    **root view controller** under **Relationship Segue**; or alternatively, set the
    **Top Bar** attribute to **None** in the attribute inspector.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, to select through overlapping objects, first select the object
    in the document outline so that the location is shown with the drag boxes. Then,
    press the *Shift* key and right-click it for a pop-up menu of the objects under
    the mouse position at any depth. From here, the object can be selected and then
    moved with the arrow keys to reposition them elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a navigation controller](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now when the application is run and the **Press Me** button is tapped, the
    message will be shown again but with a **< Back** navigation menu item as well,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a navigation controller](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Naming scenes and views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with many scenes, calling all of them **View Controller Scene**
    is not helpful. To distinguish between them, the controllers can be renamed in
    the storyboard editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the name of a scene, select its view controller in the document outline
    and go to **View** | **Utilities** | **Show Attributes Inspector** or press *Command*
    + *Option* + *3*, and then drill down to the **Document** section where the label
    hint will read **Document Label**. Typing in another value, such as `Press` `Me`,
    `Message`, or `Initial` will rename both the view controller and the scene in
    the document outline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Naming scenes and views](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, the name of the element in the document outline is taken from the
    text value of the element or the type if no text value is present. This means
    that updates to the label or button text will be automatically reflected in the
    outline. However, it is possible to add document labels to any view in the document
    outline.
  prefs: []
  type: TYPE_NORMAL
- en: Swift and storyboards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, the storyboard content does not involve any Swift or
    other programming content—it used the drag and drop capabilities of the storyboard
    editor. Fortunately, it is easy to integrate Storyboard and Swift using a *custom
    view controller*.
  prefs: []
  type: TYPE_NORMAL
- en: Custom view controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each standard view controller has a corresponding superclass (listed in the
    *Scenes and view controllers* section previously in this chapter). This can be
    replaced with a custom subclass, which then has the ability to influence and change
    what happens in the user interface. To replace the message in the **Message Scene**,
    create a new file named `MessageViewCotroller.swift` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Having created this class, it can be associated with the view controller by
    selecting it in the storyboard and then switching to the identity inspector by
    navigating to **View** | **Utilities** | **Show Identity Inspector** or pressing
    *Command* + *Option* + *3*. In the **Custom Class** section, the **Class** will
    show `UIViewController` as a hint. Entering `MessageViewController` here will
    associate the custom controller with the view controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom view controllers](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This will have no visible impact to the message scene; running the application
    will be the same as before. To show a difference, create a `viewDidLoad` method
    with an `override` keyword and then create a random color for the background as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Running the application and pressing the **Press Me** button results in a differently
    colored view being created each time.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This does not demonstrate good user experience, but is used here to demonstrate
    the fact that `viewDidLoad` is called each time the segue occurs. It is typically
    used to set up view state just before showing the view to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting views to outlets in Swift
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each view controller has an implicit relationship with its view, and each view
    has its own `backgroundColor` property. This example will work regardless of what
    the view happens to be. What if the view controller needs to interact with the
    view's content in some way? The view controller could walk the view programmatically,
    looking for a certain type of view or for a view with a particular identifier,
    but there is a better way to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Both the interface builder and storyboard have the concept of *outlets*, which
    are a predefined point in a class that can be exposed and can have connections
    between the UI and the code. In Objective-C, this was done with an `IBOutlet`
    qualifier. In Swift, this is done with a `@IBOutlet` attribute. In effect, they
    are variables that can be bound to the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When defining a class with a `@IBOutlet` attribute, the `@objc` attribute is
    also implicitly added marking this Swift class as using the Objective-C runtime.
    As all the `UIKit` classes are already Objective-C types, this doesn't matter;
    but for types where the Objective-C runtime should not be used, care should be
    taken when adding attributes, such as `@IBOutlet`. The `@objc` attribute can also
    be used for non-UI classes that need to use the Objective-C runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps are required to create an outlet in a Swift view controller:'
  prefs: []
  type: TYPE_NORMAL
- en: Define an outlet in the view controller code with `@IBOutlet` `weak` `var` of
    an optional type of the connected view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the outlet in the view controller to the view by pressing *Control*
    and dragging the mouse cursorfrom the view to the outlet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To do this, open the **assistant editor** by pressing *Command* + *Option* +
    *Enter* or by going to **View** | **Assistant Editor** | **Show Assistant Editor**.
    This will show a side-by-side view of the associated source file. This is useful
    to display the associated custom view controller for a selected view in the storyboard
    (or the interface file).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the assistant editor is displayed, open the **Message Scene** from the
    storyboard and press *Control* while dragging the mouse cursorfrom the message
    label to the assistant editor and dropping it just after the class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting views to outlets in Swift](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A pop-up dialog will ask what to call the field and present some other information;
    ensure **Outlet** is selected, name it `message`, and ensure that it has a **Weak**
    storage type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting views to outlets in Swift](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This will result in the following line being added to the `MessageViewController`
    class, and it will wire up the label to the property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `@IBOutlet` attribute (defined in `UIKit`) allows interface builder to bind
    to the property. The **Weak** storage type—which can be changed in the pop-up
    dialog—indicates that this class will not hold a strong reference to the object
    so that when the view is dismissed, the controller will not own it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Generally, all `@IBOutlet` connections should be marked as `weak`, because the
    storyboard or the `xib` file is the owner of the object, not the controller. Ownership
    does not pass when assigning properties from interface builder. Changing it to
    something other than `weak` may lead to circular references. As Swift uses a reference
    counting approach to determine when an object is no longer referenced, a circular
    reference between strong references can cause memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: The exclamation mark on the end of the type `UILabel!` indicates that it is
    an *implicitly unwrapped optional*. This property is stored as an optional type,
    but the accessor code will automatically unwrap it at the point of use. As the
    view controller will not have a reference to the `message` at the point of initialization,
    it will be `nil`, so it must be stored as an optional. However, as the value is
    known to not be `nil` after the view has been loaded, the implicitly unwrapped
    optional saves the `?.` calls that would otherwise be used each time it is used.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An implicitly unwrapped optional is still an optional value under the covers;
    it is syntactic sugar to unwrap it at the point of use each time the value is
    accessed. When the view is loaded, but before the `viewDidLoad` method is called,
    the outlet's value will be wired to the instantiated view on screen.
  prefs: []
  type: TYPE_NORMAL
- en: The connections can be seen in the connections inspector, which can be displayed
    by selecting the message label and pressing *Command* + *Option* + *6* or by navigating
    to **View** | **Utilities** | **Show Connections Inspector**. The inspector can
    also be used to remove existing connections or add new ones.
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting views to outlets in Swift](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that the connection has been made between the message view and the custom
    controller, instead of changing the background color of the view, change the background
    color of the `message` instead, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application and the message will have the background color changed
    each time the scene is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting views to outlets in Swift](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Calling actions from interface builder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the same way that outlets are variables for interface builder to assign to
    (or read from), *actions* are methods/functions that can be triggered from a view
    in interface builder. The `@IBAction` attribute is used to annotate a method or
    function that can be wired up.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with `@IBOutlet`, using `@IBAction` on a function causes the compiler to
    implicitly add a `@objc` attribute to the class in order to force it to use the
    Objective-C runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the message when a button is invoked, a suitable `changeMessage`
    is required. Historically, the signature for an action method was one that returned
    `void`, marked with `IBAction`, and took a `sender` argument, which could be any
    object. In Swift, this signature translates to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'However, with Swift, the `sender` is no longer a required argument. It is,
    therefore, possible to bind an action with the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If the signature is changed, any existing bindings must be deleted and recreated,
    as an error will be reported otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is difficult to convert from a `func` that doesn't take an argument to one
    that takes an argument. It is easier to have a `func` that takes an argument that
    isn't required. If not sure, choose the function signature that takes a sender
    object and then just ignore it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `changeMessage` function can randomly select a message and set the text
    on the label, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When the function is invoked, the message text will change to a value that
    is defined in the array. To call the function, it needs to be wired up in the
    storyboard editor. Add a new **Button** from the object library to the message
    scene, with a `Change Message` label. To connect it to the action, press *Control*
    and drag the mouse cursor from the **Change Message** button in **Message Scene**
    and drop it on the **Message** view controller at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calling actions from interface builder](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A pop-up menu will then display the outlets and actions that this can be connected
    to. Select the **changeMessage** from the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calling actions from interface builder](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If **changeMessage** isn't listed, check that the view controller is defined
    to be `MessageViewController` and verify that the `@IBAction` attribute is added
    to the `changeMessage` function.
  prefs: []
  type: TYPE_NORMAL
- en: Now when the application is run and the **Change Message** button is pressed,
    the label will change to one of the hardcoded values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The message label will not change in size because the view has no automatic
    layout associated with it. The *Using Auto Layout* section in this chapter explains
    how to fix this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Triggering a segue with code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A segue can be triggered programmatically from code if additional setup is required
    or if there are data parameters that need to be passed from one view controller
    to another (such as the currently-selected object).
  prefs: []
  type: TYPE_NORMAL
- en: 'Segues have named *segue identifiers*, which are used in code to trigger specific
    segues. To test this out, drag a new **View Controller** from the library (by
    pressing *Command* + *Option* + *Control* + *3* or by navigating to **View** |
    **Utilities** | **Show Object Library**) onto the main storyboard and name it
    `About`. Drag a **Label** and give it the text: `About` `this` `App`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a segue by pressing *Control* and dragging the mouse cursor between
    the **Message** scene to the new scene. The named identifier can be set as `about`
    through the attributes inspector (shown by pressing *Command* + *Option* + *4*
    or by navigating to **View** | **Utilities** | **Show Attributes Inspector**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Triggering a segue with code](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, drag a new **Button** to the **Change Message** scene and call it
    `About`. Instead of directly calling the segue, create a new `@IBAction` called
    `about`. When this button is pressed, the following code will be run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When the **About** button is pressed, the **About** screen will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Passing data with segues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Typically, in a master-detail application, data needs to be passed from one
    scene to the next. This may be the currently selected object, or it may require
    additional information to be processed. When the segue is called, the view controller's
    `prepareForSegue` method is called, with the destination segue and the sending
    object. This allows any internal state of the view controller to be passed to
    the new segue.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `UIStoryboardSegue` contains an identifier, which was set in the previous
    section. As the `prepareForSegue` method may be called on the `MessageViewController`
    for any number of segues, it is common for a `switch` statement to be used on
    the identifier so that the right action can be taken. For a single segue, an `if`
    statement can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `prepareForSegue` method is called with `segue`, which contains the
    destination (the scene) and the identifier. The `if` statement ensures that the
    correct identifier is matched. In this case, the background color of the message
    label (which is chosen randomly when the view is loaded) is passed to the destination
    view's background color; however, any property on either the view controller or
    the view can be set here.
  prefs: []
  type: TYPE_NORMAL
- en: Using Auto Layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Auto Layout** has been part of Xcode for the last few releases, and it was
    added to support an evolution from the previous springs-and-struts approach that
    predated Mac OS X. First released on iOS 6.0, it has evolved to the point where
    size-independent displays can now be created as the default.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Xcode 5, interface builder enabled Auto Layout by default for the first time.
    When a label was dragged to the top or bottom of the parent view, a dotted blue
    line would indicate that the label was correctly spaced, and a *constraint* would
    be generated.
  prefs: []
  type: TYPE_NORMAL
- en: However, in many cases, the constraints weren't created correctly or had undesired
    effects. For example, positioning a button in the center at the top may not maintain
    the location depending on whether the constraint being added was absolute (200px
    from the right) or relative (in the center of the screen). In both cases, the
    button may look like it was positioned correctly, only to fail when the device's
    screen orientation rotates or it is run on a screen of different size.
  prefs: []
  type: TYPE_NORMAL
- en: In Xcode 6, although the guidelines are still displayed as views are moved around,
    relative constraints are not created. Instead, each view is given an exact hardcoded
    position that does not change with screen rotation or with a change of display
    size.
  prefs: []
  type: TYPE_NORMAL
- en: In Xcode 7, Auto Layout is the preferred way of creating applications, and views
    are implicitly selected for Auto Layout. In addition, separate user interfaces
    can be created for different *size classes*, which allows applications such as
    Calculator and Mail to provide different user interfaces that are based on the
    device's rotation. On larger screen devices that have the ability to dock applications
    next to each other, the size classes are used to determine how each application
    looks and behaves.
  prefs: []
  type: TYPE_NORMAL
- en: Constraints must be added manually to the views in order to restore the right
    behavior, and as manual constraints are added, absolute constraints are removed.
  prefs: []
  type: TYPE_NORMAL
- en: Adding constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the example application, the **Welcome to Swift** label and the **Press Me**
    button are next to each other, a small distance from the top. However, when the
    screen is rotated in the simulator, by pressing *Command* and the left or right
    arrow keys, the spacing between the labels and the top doesn't change, so the
    labels look further away.
  prefs: []
  type: TYPE_NORMAL
- en: The desired outcome is that the label remains a standard distance away from
    the top-left edge and the button remains aligned to the label's baseline.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two separate constraints that need to be applied to the label:'
  prefs: []
  type: TYPE_NORMAL
- en: Be a standard vertical distance away from the top of the parent view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be a standard horizontal distance away from the left of the parent view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also two constraints that need to be applied to the button:'
  prefs: []
  type: TYPE_NORMAL
- en: Be aligned with the label's baseline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be a standard vertical distance away from the label
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are different ways of adding a constraint, which are covered in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a constraint with drag and drop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A quick way to add a constraint is to press *Control* and drag the mouse cursor
    from the view to the top of the container. Depending on the direction of the drag,
    different options will be displayed. Dragging vertically upwards presents the
    vertical alignment options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a constraint with drag and drop](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The **Vertical Spacing to Top Layout Guide** option will insert a recommended
    break between the navigation bar and the label. There is a **Center Horizontally
    in Container** option, which is also a vertical separation but not appropriate
    in this case.
  prefs: []
  type: TYPE_NORMAL
- en: The other types that are active—**Equal Widths**, **Equal Heights**, and **Aspect
    Ratio**—allow multiple views to be sized relative to each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dragging horizontally will show a different set of options at the top, including
    **Leading Space to Container Margin** and **Center Vertically in Container**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a constraint with drag and drop](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If the mouse is dragged at an angle, both sets of options will be displayed,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a constraint with drag and drop](img/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Adding constraints to the Press Me scene
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To set the constraints for the welcome label, press *Control* and drag the
    mouse cursor from the label to the left, and select **Leading Space to Container
    Margin**. An orange line will appear, and an orange outline will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding constraints to the Press Me scene](img/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The orange line indicates an *ambiguous constraint*, which means that some constraints
    have been added to the view but are not enough to uniquely position the label.
    In this case, the label is positioned from the left of the container, but it could
    be anywhere with respect to the top or bottom of the screen. The red dotted lines
    show where the Auto Layout algorithm will place the view with the constraints
    that are currently specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'To resolve this problem, press *Control* and drag the mouse pointer from the
    label to the top and select **Vertical Spacing to Top Layout Guide**. Once this
    is done, two constraints will be displayed in blue, which represent the constraints
    about the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding constraints to the Press Me scene](img/00061.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If there is an orange box surrounding the label along with a warning that says
    **Frame for label will be different at run-time**, this can be fixed with the
    **Update Frames** option that is discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constraints can also be seen in the document outline on the left-hand side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding constraints to the Press Me scene](img/00062.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If the application is run now and rotated, the label is correctly repositioned,
    but the button is not:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding constraints to the Press Me scene](img/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Adding missing constraints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To find out which views have no constraints, click through the views one by
    one in the document outline and check the size inspector (which can be seen by
    pressing *Command* + *Option* + *5* or by navigating to **View** | **Utilities**
    | **Show Size Inspector**). For views that have constraints set, there will be
    content shown under the **Constraints** section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding missing constraints](img/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If a view has no constraints associated with it, then this section will be empty.
    Interface builder has an option to create missing constraints for selected views,
    which can be accessed by navigating to **Editor** | **Resolve Auto Layout Issues**
    | **Add Missing Constraints** or from the **Resolve Auto Layout Issues** menu
    at the bottom-right, which looks like a triangle between two vertical lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'When selected, the options in the top-half apply to selected views only, while
    the options in the bottom-half work on all the views in the selected view controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding missing constraints](img/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The options include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Update Frames**: This is based on the current constraints; it automatically
    repositions and resizes the views to correspond to what will happen at runtime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Update Constraints**: This is based on the current positions of the objects
    and attempts to recalculate the existing constraints (but not create new ones)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Add Missing Constraints**: This is based on the approximate positioning of
    the components and adds constraints that creates the same result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reset to Suggested Constraints**: This is equivalent to clearing all the
    constraints associated with the views and then reading missing constraints'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clear Constraints**: This removes all the constraints associated with the
    views'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To add constraints to the **Press Me** button, click on the view and then navigate
    to **Editor** | **Resolve Auto Layout Issues** | **Selected Views** | **Add Missing
    Constraints**. There should be two constraints added: a baseline alignment with
    the label, and a horizontal space to the label.'
  prefs: []
  type: TYPE_NORMAL
- en: To see the effect of the **Update Frames** operation, move the label and the
    button to different places in the view controller. Orange lines and dotted outlines
    will be shown, indicating that there is an ambiguous constraint. Navigate to **Choose
    Editor** | **Resolve Auto Layout Issues** | **All Views in View Controller** |
    **Update Frames**, and the views will automatically move to the right places and
    resize.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The views are sized to their *intrinsic size*, which is the size that just fits
    the content. For example, a label's intrinsic size is the size in which the text
    can fit into the space in the current font. This can be used to fix the size of
    the label in the **Message Scene**; by adding constraints, the changing text will
    result in the intrinsic size being recalculated, and the background color will
    be correctly sized.
  prefs: []
  type: TYPE_NORMAL
- en: Now, run the application and rotate the device, by pressing *Command* and the
    left and right arrow keys to see the view resize itself correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced the concept of storyboards as a sequence of scenes that
    are connected with segues, which can either be wired with the GUI or driven programmatically.
    Finally, Auto Layout can be used to build applications that respond to differences
    in screen orientation or size, as well as respond to changes in view size or other
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will present how to create custom views in Swift.
  prefs: []
  type: TYPE_NORMAL
