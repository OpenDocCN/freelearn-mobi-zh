<html><head></head><body>
        <section>

            <header>
                <h1 class="header-title">Enabling the ARM Translator and Introducing Native Bridge</h1>
            </header>

            <article>
                
<p>We created a new x86emu device in the last chapter. This is the foundation of further customization and extension. As we know, if the application includes native libraries, it cannot run on a different processor architecture. Most Android applications are built for the ARM platform. We usually have problems with running these applications with ARM native libraries on Intel x86 platform. However, Google provides a solution for this situation from Android 5 and above called <strong>Native Bridge</strong>. We will delve into the Native Bridge and Intel Houdini implementation to extend x86emu to support the ARM native application in this chapter. In this chapter, we will cover the following topics:</p>
<ul>
<li>Introducing Native Bridge</li>
<li>Integrating the Houdini library to the x86emu device</li>
<li>Building and testing the image with Houdini integration</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Introducing Native Bridge</h1>
            </header>

            <article>
                
<p>Native Bridge is implemented as a part of <strong>Android Runtime</strong> (<strong>ART</strong>) in the Android architecture. It is used to support running native libraries in a different processor architecture so that an application with native libraries can run on a broader range of devices. The Intel ARM translator called Houdini is one of the use cases of Native Bridge. In ART, there are two stages for the Native Bridge to be initialized:</p>
<ol>
<li>In the first stage, the Native Bridge is loaded in the system as part of the ART initialization process. This is common for all applications.</li>
</ol>
<ol start="2">
<li>In the second stage, when an application with native libraries is started, it will be forked from Zygote. At this time, the Native Bridge will be initialized and ready to be used for the application. This is a process that is specific for individual applications. For example, if there are no native libraries being used, Native Bridge won't be initialized for this application.</li>
</ol>
<div class="packt_infobox"><strong>Zygote<br/></strong>Android at its core has a process they call the Zygote, which starts up at init. This process is a "warmed-up" process, which means it's a process that's been initialized and has all the core libraries linked in. When you start an application, the Zygote is forked to create the new process. The real speedup is achieved by <em>not</em> copying the shared libraries. This memory will only be copied if the new process tries to modify it. This means that all of the core libraries can exist in a single place because they are read-only.</div>
<p>When the application starts to load a native library from a different processor architecture, the Native Bridge will help to resolve the loading of this library. For example, when we load an ARM library on Intel the x86 architecture, the Native Bridge will use Houdini to load and execute this ARM library in the Intel x86 environment.</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="260" width="262" class=" image-border" src="assets/image_05_001.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Native Bridge in Android architecture</div>
<p>Native Bridge is built as a <kbd>libnativebridge.so</kbd> shared library as part of the Android system libraries, as shown in the preceding diagram. The implementation can be found at <kbd>$AOSP/system/core/libnativebridge</kbd>. Within the Native Bridge implementation, it has five states defined in <kbd>native_bridge.cc</kbd>, as follows:</p>
<pre>
enum class NativeBridgeState { <br/>  kNotSetup,               // Initial state. <br/>  kOpened,                 // After successful dlopen. <br/>  kPreInitialized,         // After successful pre-initialization. <br/>  kInitialized,            // After successful initialization. <br/>  kClosed                  // Closed or errors. <br/>}; 
</pre>
<p>When the Android system has just started, Native Bridge is in a <kbd>kNotSetup</kbd> state. During the initialization of ART, it will be loaded into the system and the stage changes to <kbd>kOpened</kbd>.</p>
<p>These two states are in the first stage of the Native Bridge initialization. When the user starts an application with native libraries, the system will fork a new process from Zygote. At this time, the system will do some pre-initialization work for Native Bridge, and we will see this later in this chapter. The state changes to <kbd>kPreInitialized</kbd> at this time. After the process is forked from Zygote, Native Bridge is initialized as part of the process creation and its state becomes <kbd>kInitialized</kbd>. The <kbd>kClosed</kbd> state is usually not used unless there is an error and Native Bridge is closed. These three states fall into the second stage of the Native Bridge initialization.</p>
<p>With the overview about Native Bridge in Android system architecture, we will have to delve into the details of each stage about Native Bridge used at runtime.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Setting up Native Bridge as part of the ART initialization</h1>
            </header>

            <article>
                
<p>First of all, let's take a look at how Native Bridge is loaded in the system. Native Bridge is loaded as part of the initialization of ART. As shown in the following diagram, it includes function calls from <strong>ART</strong> to the <strong>Native Bridge</strong> implementation. At the end of this stage, the state of <strong>Native Bridge</strong> will be set to <kbd>kOpened</kbd>.</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="241" width="302" class=" image-border" src="assets/image_05_002.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Loading Native Bridge</div>
<p>When the system is initializing ART, the <kbd>Runtime::Init</kbd> function is called. Inside <kbd>Runtime::Init</kbd>, a <kbd>LoadNativeBridge</kbd> function is invoked to load the Native Bridge shared library. We can see this in the following code snippet:</p>
<pre>
bool Runtime::Init(const RuntimeOptions&amp; raw_options, bool ignore_unrecognized) { <br/>  ATRACE_BEGIN("Runtime::Init"); <br/>  CHECK_EQ(sysconf(_SC_PAGE_SIZE), kPageSize); <br/>  ... <br/>    std::string native_bridge_file_name = <br/>    runtime_options.ReleaseOrDefault(Opt::NativeBridge); <br/>    is_native_bridge_loaded_ = <br/>    LoadNativeBridge(native_bridge_file_name);  <br/>   ... <br/>} 
</pre>
<p>This <kbd>LoadNativeBridge</kbd> function is part of ART and it is implemented in the <kbd>native_bridge_art_interface.cc</kbd> file, as shown in the following snippet. This function simply calls to another function, <kbd>android::LoadNativeBridge</kbd>, in the namespace <kbd>android</kbd>, while it itself is in the namespace of <kbd>art</kbd>. The functions in the namespace of <kbd>android</kbd> are part of the Native Bridge implementation, as shown in the preceding diagram, and we will see more of this later in this chapter. We can see the implementation of <kbd>LoadNativeBridge</kbd> in the following code snippet:</p>
<pre>
static android::NativeBridgeRuntimeCallbacks native_bridge_art_callbacks_ { <br/>  GetMethodShorty, GetNativeMethodCount, GetNativeMethods <br/>}; <br/><br/>bool LoadNativeBridge(std::string&amp; native_bridge_library_filename) { <br/>  VLOG(startup) &lt;&lt; "Runtime::Setup native bridge library: " <br/>      &lt;&lt; (native_bridge_library_filename.empty() ? "(empty)" : <br/>      native_bridge_library_filename); <br/>  return android::LoadNativeBridge(native_bridge_library_filename.c_str(), <br/>                                   &amp;native_bridge_art_callbacks_); <br/>} 
</pre>
<p>The <kbd>android::LoadNativeBridge</kbd> function in the <kbd>android</kbd> namespace has an extra <kbd>native_bridge_art_callbacks</kbd> parameter compared to the <kbd>art:LoadNativeBridge</kbd> function in the <kbd>art</kbd> namespace. The type of this parameter is a pointer of <kbd>struct NativeBridgeRuntimeCallbacks</kbd>, which is defined in <kbd>native_bridge.h</kbd>. In <kbd>struct NativeBridgeRuntimeCallbacks</kbd>, it defines three callback methods as follows:</p>
<pre>
// Runtime interfaces to native bridge. <br/>struct NativeBridgeRuntimeCallbacks { <br/>  // Get shorty of a Java method. The shorty is supposed to be   <br/>  persistent in <br/>  // memory. <br/>  // <br/>  // Parameters: <br/>  //   env [IN] pointer to JNIenv. <br/>  //   mid [IN] Java methodID. <br/>  // Returns: <br/>  //   short descriptor for method. <br/>  const char* (*getMethodShorty)(JNIEnv* env, jmethodID mid); <br/><br/>  // Get number of native methods for specified class. <br/>  // <br/>  // Parameters: <br/>  //   env [IN] pointer to JNIenv. <br/>  //   clazz [IN] Java class object. <br/>  // Returns: <br/>  //   number of native methods. <br/>  uint32_t (*getNativeMethodCount)(JNIEnv* env, jclass clazz); <br/><br/>  // Get at most 'method_count' native methods for specified class <br/>  'clazz'. <br/>  // Results are outputed <br/>  // via 'methods' [OUT]. The signature pointer in JNINativeMethod is <br/>  reused <br/>  // as the method shorty. <br/>  // <br/>  // Parameters: <br/>  //   env [IN] pointer to JNIenv. <br/>  //   clazz [IN] Java class object. <br/>  //   methods [OUT] array of method with the name, shorty, and fnPtr. <br/>  //   method_count [IN] max number of elements in methods. <br/>  // Returns: <br/>  //   number of method it actually wrote to methods. <br/>  uint32_t (*getNativeMethods)(JNIEnv* env, jclass clazz, <br/>  JNINativeMethod* methods, uint32_t method_count); <br/>}; 
</pre>
<p>These three callback functions that are part of ART are implemented in the <kbd>native_bridge_art_interface.cc</kbd> file. These callback functions provide a way for native methods to call JNI native functions. We will see how this callback data structure is passed to the actual Native Bridge implementation later. In our case, the actual implementation is the Houdini library.</p>
<p>The <kbd>native_bridge.h</kbd> file defines another callback function data structure, <kbd>NativeBridgeCallbacks</kbd>, which is used as the Native Bridge interface of its actual implementation. In our case, this implementation is the Houdini library. The Houdini library needs to implement these callback functions and pass the pointers to Native Bridge so that ART can use them. The following figure depicts the relationship between these two groups of callback functions:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="220" width="424" class=" image-border" src="assets/image_05_003.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">ART, Native Bridge, and Houdini</div>
<p>In the preceding figure, we can see that <strong>ART</strong> calls <strong>Native Bridge</strong> functions to load and initialize the <strong>Native Bridge</strong> module. The <strong>Native Bridge</strong> module invokes the callback functions registered by <strong>Houdini</strong> to handle all ARM native binary translations. During the initialization of <strong>Native Bridge</strong>, <strong>NativeBridgeRuntimeCallbacks</strong> are passed to the <strong>Houdini</strong> library so that the methods in the <strong>Houdini</strong> library can call JNI native functions.</p>
<p>Now let's take a look at the implementation of <kbd>android::LoadNativeBridge</kbd>:</p>
<pre>
bool LoadNativeBridge(const char* nb_library_filename, <br/>          const NativeBridgeRuntimeCallbacks* runtime_cbs) { <br/><br/>  if (state != NativeBridgeState::kNotSetup) { <br/>    // Setup has been called before. Ignore this call. <br/>    if (nb_library_filename != nullptr) { <br/>         ALOGW("Called LoadNativeBridge for an already set up native  <br/>           bridge. State is %s.", GetNativeBridgeStateString(state)); <br/>    } <br/>    had_error = true; <br/>    return false; <br/>  } <br/><br/>  if (nb_library_filename == nullptr || *nb_library_filename == 0) <br/>  { <br/>    CloseNativeBridge(false); <br/>    return false; <br/>  } else { <br/>    if (!NativeBridgeNameAcceptable(nb_library_filename)) { <br/>      CloseNativeBridge(true); <br/>    } else { <br/>      // Try to open the library. <br/>      void* handle = dlopen(nb_library_filename, RTLD_LAZY); <br/>      if (handle != nullptr) { <br/>        callbacks = <br/>            reinterpret_cast&lt;NativeBridgeCallbacks*&gt;(dlsym(handle, <br/>            kNativeBridgeInterfaceSymbol)); <br/>        if (callbacks != nullptr) { <br/>          if (VersionCheck(callbacks)) { <br/>            // Store the handle for later. <br/>            native_bridge_handle = handle; <br/>          } else { <br/>            callbacks = nullptr; <br/>            dlclose(handle); <br/>            ALOGW("Unsupported native bridge interface."); <br/>          } <br/>        } else { <br/>          dlclose(handle); <br/>        } <br/>      } <br/><br/>      if (callbacks == nullptr) { <br/>        CloseNativeBridge(true); <br/>      } else { <br/>        runtime_callbacks = runtime_cbs; <br/>        state = NativeBridgeState::kOpened; <br/>      } <br/>    } <br/>    return state == NativeBridgeState::kOpened; <br/>  } <br/>} 
</pre>
<p>As we can see from the preceding code snippet, <kbd>android::LoadNativeBridge</kbd> checks the state first. It should be in a <kbd>kNotSetup</kbd> state. Otherwise, it will report an error and return.</p>
<div class="packt_infobox">To be convenient, we will refer to the function in the Android namespace as <kbd>LoadNativeBridge</kbd> instead of <kbd>android::LoadNativeBridge</kbd> in the next few paragraphs. The files that will be discussed can be found at:<br/>
<kbd>$AOSP/art/runtime/runtime.c</kbd><br/>
<kbd>$AOSP/art/runtime/native_bridge_art_interface.c</kbd><br/>
<kbd>$AOSP/system/core/libnativebridge/native_bridge.cc</kbd></div>
<p>After that, it will check whether the first parameter is <kbd>NULL</kbd> and the filename is good to use or not. If everything is good, it will open the library through <kbd>dlopen</kbd> using the filename <kbd>nb_library_filename</kbd>.</p>
<p>So what is the content of the <kbd>nb_library_filename</kbd> filename? As we can see from the <kbd>Runtime::Init</kbd> function, the first parameter of <kbd>LoadNativeBridge</kbd> is initialized using a <kbd>Opt::NativeBridge</kbd> property:</p>
<pre>
std::string native_bridge_file_name = runtime_options.ReleaseOrDefault(Opt::NativeBridge); 
</pre>
<p>This property is initialized from the default property <kbd>ro.dalvik.vm.native.bridge</kbd>, which is defined in the <kbd>default.prop</kbd> file of the Android system. This is done in the <kbd>AndroidRuntime::startVm</kbd> function, as you can see in the following snippet. This function is defined in the <kbd>$AOSP/frameworks/base/core/jni/AndroidRuntime.cpp</kbd> file:</p>
<pre>
int AndroidRuntime::startVm(JavaVM** pJavaVM, JNIEnv** pEnv, bool zygote) <br/>{ <br/>... <br/>    // Native bridge library. "0" means that native bridge is disabled. <br/>    property_get("<strong>ro.dalvik.vm.native.bridge</strong>", propBuf, ""); <br/>    if (propBuf[0] == '\0') { <br/>        ALOGW("ro.dalvik.vm.native.bridge is not expected to be <br/>          empty"); <br/>    } else if (strcmp(propBuf, "0") != 0) { <br/>        snprintf(nativeBridgeLibrary, sizeof("-XX:NativeBridge=") + <br/>        PROPERTY_VALUE_MAX, "-XX:NativeBridge=%s", propBuf); <br/>        addOption(nativeBridgeLibrary); <br/>    } <br/>... <br/>} 
</pre>
<p>When Native Bridge is enabled, the <kbd>ro.dalvik.vm.native.bridge</kbd> property usually includes a shared library filename. In our case, it is <kbd>libhoudini.so</kbd> for Intel devices or <kbd>libnb.so</kbd> for Android-x86. If Native Bridge is disabled, its value is 0. Once the library is loaded successfully, it will use the <kbd>kNativeBridgeInterfaceSymbol</kbd> symbol to get the memory location and cast the location to a pointer of <kbd>NativeBridgeCallbacks</kbd>. This means that the Houdini library provides an implementation of <kbd>NativeBridgeCallbacks</kbd>. Let's look at what it is inside <kbd>NativeBridgeCallbacks</kbd>:</p>
<pre>
struct NativeBridgeCallbacks { <br/>  uint32_t version; <br/>  bool (*initialize)(const NativeBridgeRuntimeCallbacks*   <br/>       runtime_cbs, const char* private_dir, const char*  <br/>       instruction_set); <br/>  void* (*loadLibrary)(const char* libpath, int flag); <br/>  void* (*getTrampoline)(void* handle, const char* name, const  <br/>        char* shorty, uint32_t len); <br/>  bool (*isSupported)(const char* libpath); <br/>  const struct NativeBridgeRuntimeValues* (*getAppEnv)(const char*  <br/>       instruction_set); <br/>  bool (*isCompatibleWith)(uint32_t bridge_version); <br/>  NativeBridgeSignalHandlerFn (*getSignalHandler)(int signal); <br/>}; 
</pre>
<p>From the preceding code snippet, we can see that <kbd>NativeBridgeCallbacks</kbd> includes a variable and seven callback functions:</p>
<ul>
<li><kbd>version</kbd>: This is the version number of the interface. So far, there are two versions. Version 1 defines the first five callback functions and version 2 adds another two new functions, which we will see very shortly.</li>
<li><kbd>initialize</kbd>: This function initializes an instance of Native Bridge. Native Bridge's internal implementation must ensure multithread safety and Native Bridge is initialized only once.</li>
<li><kbd>loadLibrary</kbd> : This function loads a shared library that is supported by the Native Bridge.</li>
<li><kbd>getTrampoline</kbd> : This function gets a Native Bridge trampoline for the specified native method.</li>
<li><kbd>isSupported</kbd> : This function checks whether the instance of Native Bridge is valid and whether it is for an ABI that is supported by Native Bridge.</li>
</ul>
<p>In version 2, the following two functions are added:</p>
<ul>
<li><kbd>isCompatibleWith</kbd>: This function checks whether the bridge is compatible with the given version of library. A bridge may decide not to be forward- or backward-compatible, and <kbd>libnativebridge</kbd> will then stop using it.</li>
<li><kbd>getSignalHandler</kbd>: A callback function to retrieve a Native Bridge's signal handler for the specified signal. The runtime will ensure that the signal handler is being called after the runtime's own handler, but before all chained handlers. The native bridge should not try to install the handler by itself, as that will potentially lead to cycles.</li>
</ul>
<p>Now we have concluded the first stage of the Native Bridge initialization. As we can see from the preceding lists, Native Bridge is loaded at the startup of ART. At this stage, the initialization is not process-specific. The library name is defined in the <kbd>ro.dalvik.vm.native.bridge</kbd> property. In our case, ART loads the <kbd>libhoudini.so</kbd> library through the <kbd>LoadNativeBridge</kbd> function defined in <kbd>libnativebridge.so</kbd>. After Native Bridge is loaded successfully, the state is set to <kbd>kOpened</kbd>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Pre-initializing Native Bridge</h1>
            </header>

            <article>
                
<p>In the second stage of Native Bridge initialization, it becomes process-specific. Native Bridge can be used by an Android application to load a native library in a different processor architecture than the current device. The other two states, <kbd>kPreInitialized</kbd> and <kbd>kInitialized</kbd>, are related to the creation of Android applications, as we know that all applications are forked from Zygote in Android. Let's look at the pre-initialization of Native Bridge first, as shown in the following diagram:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="143" width="304" class=" image-border" src="assets/image_05_004.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Pre-initialization of  Native Bridge</div>
<p>During the creation of an application, the <kbd>ForkAndSpecializeCommon</kbd> function is called. The pre-initialization of Native Bridge is done in this function. This function is defined in the <kbd>$AOSP/frameworks/base/core/jni/com_android_internal_os_Zygote.cpp</kbd> file:</p>
<pre>
static pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t <br/>    gid, jintArray javaGids, jint debug_flags, jobjectArray <br/>    javaRlimits, jlong permittedCapabilities, jlong <br/>    effectiveCapabilities, jint mount_external, jstring <br/>    java_se_info, jstring java_se_name, bool is_system_server,  <br/>    jintArray fdsToClose, jstring instructionSet, jstring dataDir) { <br/>      SetSigChldHandler(); <br/><br/>#ifdef ENABLE_SCHED_BOOST <br/>  SetForkLoad(true); <br/>#endif <br/>... <br/>  pid_t pid = fork(); <br/><br/>  if (pid == 0) { <br/>    // The child process. <br/>... <br/>    bool use_native_bridge = !is_system_server &amp;&amp; (instructionSet != <br/>    NULL) &amp;&amp; android::NativeBridgeAvailable(); <br/>    if (use_native_bridge) { <br/>      ScopedUtfChars isa_string(env, instructionSet); <br/>      use_native_bridge = <br/>      android::NeedsNativeBridge(isa_string.c_str()); <br/>    } <br/>    if (use_native_bridge &amp;&amp; dataDir == NULL) { <br/>      use_native_bridge = false; <br/>      ALOGW("Native bridge will not be used because dataDir == NULL."); <br/>    } <br/><br/>    if (!MountEmulatedStorage(uid, mount_external, use_native_bridge)) { <br/>      ALOGW("Failed to mount emulated storage: %s", strerror(errno)); <br/>      if (errno == ENOTCONN || errno == EROFS) { <br/>      } else { <br/>        RuntimeAbort(env, __LINE__, "Cannot continue without emulated <br/>        storage"); <br/>      } <br/>    } <br/><br/>    if (!is_system_server) { <br/>        int rc = createProcessGroup(uid, getpid()); <br/>        if (rc != 0) { <br/>            if (rc == -EROFS) { <br/>                ALOGW("createProcessGroup failed, kernel missing <br/>                CONFIG_CGROUP_CPUACCT?"); <br/>            } else { <br/>                ALOGE("createProcessGroup(%d, %d) failed: %s", uid, <br/>                pid, strerror(-rc)); <br/>            } <br/>        } <br/>    } <br/><br/>    SetGids(env, javaGids); <br/><br/>    SetRLimits(env, javaRlimits); <br/><br/>    if (use_native_bridge) { <br/>      ScopedUtfChars isa_string(env, instructionSet); <br/>      ScopedUtfChars data_dir(env, dataDir); <br/>      android::PreInitializeNativeBridge(data_dir.c_str(), <br/>      isa_string.c_str()); <br/>    } <br/>... <br/>    env-&gt;CallStaticVoidMethod(gZygoteClass, <br/>           gCallPostForkChildHooks,  <br/>           debug_flags, is_system_server ? NULL : instructionSet);  <br/>... <br/>  } else if (pid &gt; 0) { <br/>    // the parent process <br/><br/>#ifdef ENABLE_SCHED_BOOST <br/>    // unset scheduler knob <br/>    SetForkLoad(false); <br/>#endif <br/><br/>  } <br/>  return pid; <br/>} 
</pre>
<p>In this <kbd>ForkAndSpecializeCommon</kbd> function, it checks whether the current process is not a SystemServer process and if the Native Bridge is ready to use. After that, it calls the <kbd>NeedsNativeBridge</kbd> function to check whether the current process needs to use Native Bridge or not:</p>
<pre>
bool NeedsNativeBridge(const char* instruction_set) { <br/>  if (instruction_set == nullptr) { <br/>    ALOGE("Null instruction set in NeedsNativeBridge."); <br/>    return false; <br/>  } <br/>  return strncmp(instruction_set, kRuntimeISA,  <br/>               strlen(kRuntimeISA) + 1) != 0; <br/>} 
</pre>
<p>The <kbd>NeedsNativeBridge</kbd> function compares <kbd>instruction_set</kbd> with the current Android platform instruction set. If these two instruction sets are different, then we need to use Native Bridge; otherwise, we don't. The <kbd>NeedsNativeBridge</kbd> function is implemented in <kbd>native_bridge.cc</kbd>.</p>
<p>If Native Bridge is needed by the application, then <kbd>PreInitializeNativeBridge</kbd>, which is also implemented in <kbd>native_bridge.cc</kbd>, is going to be called with two parameters, <kbd>app_data_dir_in</kbd> and <kbd>instruction_set</kbd>:</p>
<pre>
bool PreInitializeNativeBridge(const char* app_data_dir_in,  <br/>     const char* instruction_set) { <br/>  if (state != NativeBridgeState::kOpened) { <br/>    ALOGE("Invalid state: native bridge is expected to be opened."); <br/>    CloseNativeBridge(true); <br/>    return false; <br/>  } <br/><br/>  if (app_data_dir_in == nullptr) { <br/>    ALOGE("Application private directory cannot be null."); <br/>    CloseNativeBridge(true); <br/>    return false; <br/>  } <br/><br/>  const size_t len = strlen(app_data_dir_in) +  <br/>                    strlen(kCodeCacheDir) + 2; // '\0' + '/' <br/>  app_code_cache_dir = new char[len]; <br/>  snprintf(app_code_cache_dir, len, "%s/%s", app_data_dir_in,  <br/>  kCodeCacheDir); <br/><br/><strong>  state = NativeBridgeState::kPreInitialized;</strong> <br/><br/>#ifndef __APPLE__ <br/>  if (instruction_set == nullptr) { <br/>    return true; <br/>  } <br/>  size_t isa_len = strlen(instruction_set); <br/>  if (isa_len &gt; 10) { <br/>    ALOGW("Instruction set %s is malformed, must be less than or equal <br/>    to 10 characters.", instruction_set); <br/>    return true; <br/>  } <br/><br/>  char cpuinfo_path[1024]; <br/><br/>#if defined(__ANDROID__) <br/>  snprintf(cpuinfo_path, sizeof(cpuinfo_path), "/system/lib" <br/>#ifdef __LP64__ <br/>      "64" <br/>#endif  // __LP64__ <br/>      "/%s/cpuinfo", instruction_set); <br/>#else   // !__ANDROID__ <br/>  snprintf(cpuinfo_path, sizeof(cpuinfo_path), "./cpuinfo"); <br/>#endif <br/><br/>  // Bind-mount. <br/>  if (TEMP_FAILURE_RETRY(mount(cpuinfo_path, <br/>                               "/proc/cpuinfo", <br/>                               nullptr, <br/>                               MS_BIND, <br/>                               nullptr)) == -1) { <br/>    ALOGW("Failed to bind-mount %s as /proc/cpuinfo: %s", cpuinfo_path, <br/>    strerror(errno)); <br/>  } <br/>#else  // __APPLE__ <br/>  UNUSED(instruction_set); <br/>  ALOGW("Mac OS does not support bind-mounting. Host simulation of <br/>  native bridge impossible."); <br/>#endif <br/><br/>  return true; <br/>} 
</pre>
<p>From the preceding code snippet, we can see that it will check whether the state is <kbd>kOpened</kbd> or not. Then <kbd>PreInitializeNativeBridge</kbd> will do two things. Firstly, it creates a code cache directory using the first parameter, <kbd>app_data_dir_in</kbd>, for Native Bridge in the <kbd>data</kbd> folder of the application. Next, it uses the second parameter, <kbd>instruction_set</kbd>, to find the <kbd>/system/lib/&lt;isa&gt;/cpuinfo</kbd> path and it does a bind-mount of it to <kbd>/proc/cpuinfo</kbd>. If Houdini is available in the device, you can find the <kbd>/system/lib/arm/cpuinfo</kbd> file in the <kbd>system</kbd> folder. Once the preceding two tasks are completed, the state of Native Bridge will be set to <kbd>kPreInitialized</kbd>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Initializing Native Bridge</h1>
            </header>

            <article>
                
<p>After the state is changed to <kbd>kPreInitialized</kbd>, the creation of the new Android application will continue in the <kbd>ForkAndSpecializeCommon</kbd> function. At the end of this function, it calls a <kbd>callPostForkChildHooks</kbd> registered function through a global variable, <kbd>gCallPostForkChildHooks</kbd>. The call stack will eventually go to a <kbd>ZygoteHooks_nativePostForkChild</kbd> function, which is the JNI implementation of the <kbd>postForkChild</kbd> Java method. The <kbd>postForkChild</kbd> function is called by Zygote in the child process after every fork. The following table is a summary of the call stack:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Function</strong></p>
</td>
<td>
<p><strong>Class</strong></p>
</td>
<td>
<p><strong>Language</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>ForkAndSpecializeCommon</kbd></p>
</td>
<td/>
<td>
<p>C++</p>
</td>
</tr>
<tr>
<td>
<p><kbd>gCallPostForkChildHooks</kbd></p>
</td>
<td/>
<td>
<p>C++</p>
</td>
</tr>
<tr>
<td>
<p><kbd>callPostForkChildHooks</kbd></p>
</td>
<td>
<p>Zygote</p>
</td>
<td>
<p>Java</p>
</td>
</tr>
<tr>
<td>
<p><kbd>postForkChild</kbd></p>
</td>
<td>
<p>ZygoteHooks</p>
</td>
<td>
<p>Java</p>
</td>
</tr>
<tr>
<td>
<p><kbd>ZygoteHooks_nativePostForkChild</kbd></p>
</td>
<td>
<p>JNI (postForkChild)</p>
</td>
<td>
<p>C++</p>
</td>
</tr>
</tbody>
</table>
<p>The <kbd>ZygoteHooks_nativePostForkChild</kbd> function is implemented in the <kbd>$AOSP/ art/runtime/native/dalvik_system_ZygotHooks.cc</kbd> file. The <kbd>DidForkFromZygote</kbd> function is implemented in the <kbd>$AOSP/art/runtime/runtime.cc</kbd> file.</p>
<p>The following diagram is a summary of functions involved in the second stage of the initialization of Native Bridge. Be aware that we are in the child process now. We can see that the <strong>Runtime::DidForkFromZygote</strong> function in <strong>ART</strong> will call the following Native Bridge interface functions: <strong>InitializeNativeBridge</strong> and <strong>SetupEnvironment</strong>. The Native Bridge interface functions will eventually call the registered callback functions in the Houdini library.</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="282" width="421" class=" image-border" src="assets/image_05_005.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Initialization of Native Bridge</div>
<p>Let's look at the JNI implementation of <kbd>postForkChild</kbd>:</p>
<pre>
static void ZygoteHooks_nativePostForkChild(JNIEnv* env,  <br/>    jclass, jlong token, jint debug_flags,  <br/>    jstring instruction_set) { <br/>... <br/>  if (instruction_set != nullptr) { <br/>    ScopedUtfChars isa_string(env, instruction_set); <br/>    InstructionSet isa = <br/>    GetInstructionSetFromString(isa_string.c_str()); <br/>    Runtime::NativeBridgeAction action = <br/>    Runtime::NativeBridgeAction::kUnload; <br/>    if (isa != kNone &amp;&amp; isa != kRuntimeISA) { <br/>      action = Runtime::NativeBridgeAction::kInitialize; <br/>    } <br/>    Runtime::Current()-&gt;<strong>DidForkFromZygote</strong>(env, action, <br/>    isa_string.c_str()); <br/>  } else { <br/>    Runtime::Current()-&gt;<strong>DidForkFromZygote</strong>(env, <br/>    Runtime::NativeBridgeAction::kUnload, nullptr); <br/>  } <br/>} 
</pre>
<p>Here, it checks the instruction set again to decide whether we need Native Bridge for the application. Then it calls the <kbd>Runtime::DidForkFromZygote</kbd> function to initialize Native Bridge in the new process:</p>
<pre>
void Runtime::DidForkFromZygote(JNIEnv* env,  <br/>    NativeBridgeAction action, const char* isa) { <br/>  is_zygote_ = false; <br/><br/>  if (is_native_bridge_loaded_) { <br/>    switch (action) { <br/>      case NativeBridgeAction::kUnload: <br/>        UnloadNativeBridge(); <br/>        is_native_bridge_loaded_ = false; <br/>        break; <br/><br/>      case NativeBridgeAction::kInitialize: <br/><strong>        InitializeNativeBridge</strong>(env, isa); <br/>        break; <br/>    } <br/>  } <br/>... <br/>} 
</pre>
<p>As we can see, <kbd>Runtime::DidForkFromZygote</kbd> calls the <kbd>InitializeNativeBridge</kbd> based on the action. Now let's dive into the <kbd>InitializeNativeBridge</kbd> function, which is implemented in <kbd>native_bridge.cc</kbd>:</p>
<pre>
bool InitializeNativeBridge(JNIEnv* env,  <br/>    const char* instruction_set) { <br/><br/>  if (state == NativeBridgeState::kPreInitialized) { <br/>    // Check for code cache: if it doesn't exist try to create it. <br/>    struct stat st; <br/>    if (stat(app_code_cache_dir, &amp;st) == -1) { <br/>      if (errno == ENOENT) { <br/>        if (mkdir(app_code_cache_dir, S_IRWXU | S_IRWXG | S_IXOTH) <br/>        == -1) { <br/>          ALOGW("Cannot create code cache directory %s: %s.", <br/>          app_code_cache_dir, strerror(errno)); <br/>          ReleaseAppCodeCacheDir(); <br/>        } <br/>      } else { <br/>        ALOGW("Cannot stat code cache directory %s: %s.", <br/>        app_code_cache_dir, strerror(errno)); <br/>        ReleaseAppCodeCacheDir(); <br/>      } <br/>    } else if (!S_ISDIR(st.st_mode)) { <br/>      ALOGW("Code cache is not a directory %s.", app_code_cache_dir); <br/>      ReleaseAppCodeCacheDir(); <br/>    } <br/><br/>    if (state == NativeBridgeState::kPreInitialized) { <br/>      if (callbacks-&gt;initialize(runtime_callbacks, app_code_cache_dir, <br/>      instruction_set)) { <br/>        SetupEnvironment(callbacks, env, instruction_set); <br/>        state = NativeBridgeState::kInitialized; <br/>        ReleaseAppCodeCacheDir(); <br/>      } else { <br/>        // Unload the library. <br/>        dlclose(native_bridge_handle); <br/>        CloseNativeBridge(true); <br/>      } <br/>    } <br/>  } else { <br/>    CloseNativeBridge(true); <br/>  } <br/><br/>  return state == NativeBridgeState::kInitialized; <br/>} 
</pre>
<p>In the <kbd>InitializeNativeBridge</kbd> function, it creates the folder for the code cache first. Then, it invokes the <kbd>initialize</kbd> function, implemented by the Houdini library in our case.</p>
<div class="packt_infobox">The shared library is <kbd>libhoudini.so</kbd> in Intel devices. If you run Android-x86 on an Intel device, the shared library is <kbd>libnb.so</kbd>. We will discuss <kbd>libnb.so</kbd> later in this chapter.</div>
<p>After that, it calls another <kbd>SetupEnvironment</kbd> function in <kbd>native_bridge.cc</kbd> to set up the environment for the Native Bridge in the current application. Finally, it sets the state to <kbd>kInitialized</kbd>. Now Native Bridge is ready for the current application to use.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Loading a native library</h1>
            </header>

            <article>
                
<p>Once Native Bridge is ready to use, we can have a look at what happens when an application loads a native library in a different processor architecture.</p>
<p>We know that, if we implement a native method in a shared library, we need to implement a <kbd>JNI_OnLoad</kbd> entry point, which is used to register native methods. The Java code needs to make a call to either <kbd>System.load</kbd> or <kbd>System.loadLibrary</kbd> to load this shared library. In the following table, it is the call stack from <kbd>System.loadLibrary</kbd> to <kbd>JNI_OnLoad</kbd>:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Function</strong></p>
</td>
<td>
<p><strong>Class</strong></p>
</td>
<td>
<p><strong>Language</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>System.loadLibrary</kbd></p>
</td>
<td>
<p>Runtime</p>
</td>
<td>
<p>Java</p>
</td>
</tr>
<tr>
<td>
<p><kbd>doLoad</kbd></p>
</td>
<td>
<p>Runtime</p>
</td>
<td>
<p>Java</p>
</td>
</tr>
<tr>
<td>
<p><kbd>nativeLoad</kbd></p>
</td>
<td>
<p>Runtime</p>
</td>
<td>
<p>JNI</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Runtime_nativeLoad</kbd></p>
</td>
<td>
<p>Runtime</p>
</td>
<td>
<p>C++</p>
</td>
</tr>
<tr>
<td>
<p><kbd>LoadNativeLibrary</kbd></p>
</td>
<td>
<p>JavaVMExt</p>
</td>
<td>
<p>C++</p>
</td>
</tr>
<tr>
<td>
<p><kbd>JNI_OnLoad</kbd></p>
</td>
<td/>
<td>
<p>C++</p>
</td>
</tr>
</tbody>
</table>
<p>Let's look into the details of <kbd>JavaVMExt::LoadNativeLibrary</kbd>. This function is defined in <kbd>$AOSP/art/runtime/jni_internal.cc</kbd>. The following diagram is the part of <kbd>JavaVMExt::LoadNativeLibrary</kbd> related to Native Bridge:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="318" width="425" class=" image-border" src="assets/image_05_006.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Loading native library</div>
<p>Android applications call to this function when they load native libraries. Usually, we refer to the native library in the same processor architecture here. With Native Bridge, we can load supported native libraries in a different processor architecture with this function as well:</p>
<pre>
bool JavaVMExt::LoadNativeLibrary(JNIEnv* env,  <br/>    const std::string&amp; path, jobject class_loader,  <br/>    std::string* error_msg) { <br/>... <br/>  const char* path_str = path.empty() ? nullptr : path.c_str(); <br/>  void* handle = <strong>dlopen</strong>(path_str, RTLD_NOW); <br/>  bool needs_native_bridge = false; <br/>  if (handle == nullptr) { <br/>    if (<strong>android::NativeBridgeIsSupported</strong>(path_str)) { <br/>      handle = <strong>android::NativeBridgeLoadLibrary</strong>(path_str, RTLD_NOW); <br/>      needs_native_bridge = true; <br/>    } <br/>  } <br/>... <br/>  bool was_successful = false; <br/>  void* sym; <br/>  if (needs_native_bridge) { <br/>    library-&gt;SetNeedsNativeBridge(); <br/><strong>    sym = library-&gt;FindSymbolWithNativeBridge("JNI_OnLoad", nullptr);</strong> <br/>  } else { <br/>    sym = dlsym(handle, "JNI_OnLoad"); <br/>  } <br/>... <br/>    typedef int (*JNI_OnLoadFn)(JavaVM*, void*); <br/>    JNI_OnLoadFn jni_on_load = reinterpret_cast&lt;JNI_OnLoadFn&gt;(sym); <br/><strong>    int version = (*jni_on_load)(this, nullptr);</strong>  <br/>... <br/>} 
</pre>
<p>The <kbd>LoadNativeLibrary</kbd> function will call to <kbd>dlopen</kbd> to load the shared library first. If it is a shared library in a different processor architecture, such as an open ARM library on an Intel x86 platform, the <kbd>dlopen</kbd> call should fail. In this case, it will try to load the library again using Native Bridge instead of returning an error.</p>
<p>To use Native Bridge, it calls to the <kbd>NativeBridgeIsSupported</kbd> function first to check whether Native Bridge is supported or not. The <kbd>NativeBridgeIsSupported</kbd> function calls to the Houdini callback function, <kbd>isSupported</kbd>, to check whether the given shared library can be supported by Native Bridge or not:</p>
<pre>
bool NativeBridgeIsSupported(const char* libpath) { <br/>  if (NativeBridgeInitialized()) { <br/>    return callbacks-&gt;<strong>isSupported</strong>(libpath); <br/>  } <br/>  return false; <br/>} 
</pre>
<p>If the library can be supported by Native Bridge, <kbd>LoadNativeLibrary</kbd> will call another Native Bridge function, <kbd>android::NativeBridgeLoadLibrary</kbd>, to load the library:</p>
<pre>
void* NativeBridgeLoadLibrary(const char* libpath, int flag) { <br/>  if (NativeBridgeInitialized()) { <br/>    return callbacks-&gt;<strong>loadLibrary</strong>(libpath, flag); <br/>  } <br/>  return nullptr; <br/>} 
</pre>
<p>The Native Bridge <kbd>NativeBridgeLoadLibrary</kbd> function will make a call to the Houdini callback function <kbd>loadLibrary</kbd> to load the library. After the native library is loaded successfully, the <kbd>JNI_OnLoad</kbd> entry point will be found in the library and the system will call it to register the native methods registered by the native library. For a normal native library, the system function <kbd>dlsym</kbd> is used to get the <kbd>JNI_OnLoad</kbd> method, but the <kbd>FindSymbolWithNativeBridge</kbd> function is used to get <kbd>JNI_OnLoad</kbd> from the Houdini library:</p>
<pre>
void* FindSymbolWithNativeBridge(const std::string&amp; symbol_name, <br/>const char* shorty) { <br/>    CHECK(NeedsNativeBridge()); <br/><br/>    uint32_t len = 0; <br/>    return android::NativeBridgeGetTrampoline(handle_,  <br/>    symbol_name.c_str(), shorty, len); <br/>} 
</pre>
<p><kbd>FindSymbolWithNativeBridge</kbd> calls to the <kbd>NativeBridgeGetTrampoline</kbd> Native Bridge function, while <kbd>NativeBridgeGetTrampoline</kbd> calls to the <kbd>getTrampoline</kbd> Houdini callback function to do the actual work:</p>
<pre>
void* NativeBridgeGetTrampoline(void* handle, const char* name, <br/>const char* shorty, uint32_t len) { <br/>  if (NativeBridgeInitialized()) { <br/>    return callbacks-&gt;getTrampoline(handle, name, shorty, len); <br/>  } <br/>  return nullptr; <br/>} 
</pre>
<p>From the preceding analysis, we can see that the ARM translator library Houdini uses the Native Bridge in Android to support ARM binary translation. The interfaces between the Houdini library and the system are two sets of callback functions. The callback functions defined in <kbd>NativeBridgeCallbacks</kbd> are used by the system to perform the function calls to the ARM native library, while the callback functions defined in <kbd>NativeBridgeRuntimeCallbacks</kbd> can be used by the functions in the Houdini library to call JNI functions in the system.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Integrating Houdini to the x86emu device</h1>
            </header>

            <article>
                
<p>The goal of this chapter is to support Houdini ARM binary translation in Android emulator. After we have an overview of the internals of Native Bridge, which is the foundation of the Houdini library, we can work on Houdini support for our x86emu device.</p>
<p>Since the Houdini library is an Intel proprietary library, it is not available publicly. For those people who want to add Houdini to a new device, such as an Android emulator that is not supported by Intel, the only possible way is to copy the Houdini library from a supported device and add it to the unsupported device.</p>
<p>Fortunately, the open source project Android-x86 provides basic support for Houdini to any Intel devices, which we can use as a reference in this book. In this chapter, we will add Houdini to an Android emulator based on the Android-x86 project.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Changing the configuration of the x86emu build</h1>
            </header>

            <article>
                
<p>The basic steps to support Houdini on a new device are:</p>
<ul>
<li>Change the device configurations according to what we have discussed in <a href="f69f330a-932c-4a32-bb78-e427c860b65e.xhtml">Chapter 4</a>, <em>Customizing the Android Emulator</em>, in the <em>Why</em> c<em><span class="ChapterrefPACKT">ustomize the Android emulator? </span></em>section</li>
<li>Copy a suitable version of the Houdini library to the <kbd>system</kbd> folder</li>
</ul>
<p>To work on the preceding two steps, let's start with the changes to the x86emu device configurations first. What we will do for this is that we will use the source code in <a href="f69f330a-932c-4a32-bb78-e427c860b65e.xhtml">Chapter 4</a>, <em>Customizing the Android Emulator</em> as the baseline and make changes on top of it. This is also the approach that we will use in most of the chapters in this book. We will make independent changes based on the simplest code base for each topic. What I mean is that the source code for x86emu in <a href="f69f330a-932c-4a32-bb78-e427c860b65e.xhtml">Chapter 4</a>, <em>Customizing the Android Emulator</em> is the simplest code base for the x86emu device.</p>
<p>Given that we already have a working copy of the AOSP source code for x86emu, we can make changes for this chapter in a new branch:</p>
<pre>
<strong>$ cd device/generic/x86emu</strong><br/><strong>$ git checkout android-7.1.1_r4_x86emu_ch04_r1</strong><br/><strong>$ git branch android-7.1.1_r4_ch05</strong><br/><strong>$ git checkout android-7.1.1_r4_ch05</strong>  
</pre>
<p>I created a tag for each chapter and we can use that as the start for the new development. The <kbd>android-7.1.1_r4_x86emu_ch04_r1</kbd> tag is the baseline for <a href="f69f330a-932c-4a32-bb78-e427c860b65e.xhtml">Chapter 4</a><span>,</span> <em>Customizing the Android Emulator</em>. From the preceding commands, we create a new branch, <kbd>android-7.1.1_r4_ch05</kbd>, for the development work in this chapter. I didn't push the development branches to GitHub, but I pushed all the tags to GitHub. After we complete all the changes in this chapter, we will create a new tag, <kbd>android-7.1.1_r4_x86emu_ch05_r1</kbd>, for this chapter.</p>
<p>After we make all the changes, we also need to update the manifest file so that we can have a manifest to download the code for this chapter. Instead of using tags, I use branches to manage manifests. The branch for this chapter's manifests is <kbd>android-7.1.1_r4_ch05_aosp</kbd>. We can use the following command to download the source code of:</p>
<pre>
<strong>$ repo init -u https://github.com/shugaoye/manifests -b android-7.1.1_r4_ch05_aosp</strong><br/><strong>$ repo sync</strong>
</pre>
<p>If you set up the local mirror as we discussed in <a href="984e0cef-7bf6-4454-bede-bb34c553be12.xhtml">Chapter 2</a>, <em>Setting Up the Development Environment</em>, you can check out the source code as follows:</p>
<pre>
<strong>$ repo init -u {your local mirror}/github/manifests.git -b android-7.1.1_r4_ch05</strong><br/><strong>$ repo sync</strong>  
</pre>
<p>You need to create an <kbd>android-7.1.1_r4_ch05</kbd> branch for your own local mirror referring to the <kbd>android-7.1.1_r4_ch05_aosp</kbd> branch.</p>
<p>After we create a working copy of the source code using the preceding manifest, we can look at the <kbd>.repo/manifest.xml</kbd> file:</p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt; <br/>&lt;manifest&gt; <br/><br/>  &lt;remote  name="github" <br/>           fetch="." /&gt; <br/><br/>  &lt;remote  name="aosp" <br/>           fetch="https://android.googlesource.com/" /&gt; <br/>  &lt;default revision="refs/tags/android-7.1.1_r4" <br/>           remote="aosp" <br/>           sync-c="true" <br/>           sync-j="1" /&gt; <br/><br/>  &lt;!-- github/shugaoye --&gt; <br/>  &lt;project path="kernel" name="goldfish" remote="github"   <br/>  revision="refs/tags/android-7.1.1_r4_x86emu_ch05_r1" /&gt; <br/>  &lt;project path="device/generic/common" name="device_generic_common" <br/>   groups="pdk" <br/>  remote="github" revision="refs/tags/android-7.1.1_r4_x86emu_ch05_r1" /&gt; <br/>  &lt;project path="device/generic/goldfish" <br/>  name="device_generic_goldfish" <br/>  remote="github" groups="pdk" revision="refs/tags/android- <br/>  7.1.1_r4_x86emu_ch05_r1" /&gt; <br/>  &lt;project path="device/generic/x86emu" name="x86emu" remote="github" <br/>  revision="refs/tags/android-7.1.1_r4_x86emu_ch05_r1" /&gt; <br/><br/>  &lt;!-- aosp --&gt; <br/>  &lt;project path="build" name="platform/build" groups="pdk,tradefed" &gt; <br/>    &lt;copyfile src="core/root.mk" dest="Makefile" /&gt; <br/>... <br/>&lt;/manifest&gt; 
</pre>
<p>In the preceding manifest file, we use the <kbd>android-7.1.1_r4_x86emu_ch05_r1</kbd> tag to tag all projects that are not in AOSP projects. The <kbd>device/generic/common</kbd> project is duplicated from Android-x86 and the <kbd>device/generic/goldfish</kbd> project is duplicated from AOSP. Besides <kbd>kernel</kbd> and <kbd>device/generic/x86emu</kbd>, these are the two projects that we need to change in this chapter.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Extending the x86emu device</h1>
            </header>

            <article>
                
<p>Once we have done all the changes for the source code configuration, we can start to extend the x86emu device to support Houdini now. What are the changes that we have to make? Since I have done all the changes before I explained them here, let's use a tool to compare the difference between the source code in <a href="f69f330a-932c-4a32-bb78-e427c860b65e.xhtml">Chapter 4</a>, <em>Customizing the Android Emulator</em> and this chapter's code.</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="packt_screen"><img height="150" width="399" class=" image-border" src="assets/image_05_007.png"/></span></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Changes to support Houdini</div>
<p>As we can see in the preceding screenshot, we added a <kbd>system</kbd> folder and we modified four Makefiles. We can ignore the <kbd>x86emu_x86_64.mk</kbd> Makefile, since we won't discuss 64-bit builds in this book. The changes to <kbd>x86emu_x86_64.mk</kbd> are similar to those for <kbd>x86emu_x86.mk</kbd>, so we save ourselves the effort of discussing similar things twice. It won't be a significant effort for you to enable a 64-bit build for x86emu by yourself. The other two files, <kbd>.cproject</kbd> and <kbd>.project</kbd>, are generated due to Eclipse integration and we can ignore them too. Let's look at <kbd>BoardConfig.mk</kbd>, <kbd>x86emu_x86.mk</kbd>, and <kbd>device.mk</kbd> one by one.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Changes to BoardConfig.mk</h1>
            </header>

            <article>
                
<p>In the board configuration file, we need to add an ARM instruction set to the CPU ABI list so that the program can detect support for the ARM instruction set as follows:</p>
<pre>
... <br/># houdini <br/># Native Bridge ABI List <br/>NATIVE_BRIDGE_ABI_LIST_32_BIT := armeabi-v7a armeabi <br/>NATIVE_BRIDGE_ABI_LIST_64_BIT := arm64-v8a <br/>TARGET_CPU_ABI_LIST_32_BIT := $(TARGET_CPU_ABI) $(TARGET_CPU_ABI2) $(NATIVE_BRIDGE_ABI_LIST_32_BIT) <br/>TARGET_CPU_ABI_LIST := $(TARGET_CPU_ABI_LIST_32_BIT) <br/><br/>BUILD_ARM_FOR_X86 := $(WITH_NATIVE_BRIDGE) <br/>... 
</pre>
<p>You may have noticed the <kbd>BUILD_ARM_FOR_X86</kbd> macro. This macro is used by Android-x86 Houdini support and we will discuss it later.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Changes to x86emu_x86.mk</h1>
            </header>

            <article>
                
<p>In the product definition Makefile, <kbd>x86emu_x86.mk</kbd>, we set the <kbd>persist.sys.nativebridge</kbd> property to <kbd>1</kbd>. Then we copy all files under the <kbd>$AOSP/device/generic/x86emu/system</kbd> folder to the <kbd>$OUT/system</kbd> image. All the files under the <kbd>$AOSP/device/generic/x86emu/system/lib/arm</kbd> folder are a copy of the Houdini libraries:</p>
<pre>
... <br/>PRODUCT_PROPERTY_OVERRIDES := \ <br/>    persist.sys.nativebridge=1 \ <br/><br/>NB_PATH := $(LOCAL_PATH) <br/>NB_LIB_PATH := system/lib <br/>NB_ARM_PATH := $(NB_LIB_PATH)/arm <br/>NB_NBLIB_PATH := $(NB_ARM_PATH)/nb <br/>NB_BIN_PATH := system/bin <br/><br/>PRODUCT_COPY_FILES += $(foreach LIB, $(filter-out nb liblog_legacy.so libbinder_legacy.so,\  <br/>      $(notdir $(wildcard $(NB_PATH)/$(NB_ARM_PATH)/*))), $(NB_PATH)/$(NB_ARM_PATH)/$(LIB):$(NB_ARM_PATH)/$(LIB):intel) <br/>PRODUCT_COPY_FILES += $(foreach NB, $(filter-out libbinder_legacy.so, $(notdir $(wildcard $(NB_PATH)/$(NB_NBLIB_PATH)/*))),\  <br/>      $(NB_PATH)/$(NB_NBLIB_PATH)/$(NB):$(NB_NBLIB_PATH)/$(NB):intel) <br/>... 
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Changes to device.mk</h1>
            </header>

            <article>
                
<p>In the device Makefile <kbd>device.mk</kbd>, we only added one line to include another Makefile, <kbd>nativebridge.mk</kbd>, in the <kbd>device/generic/common/nativebridge</kbd> directory. As we discussed in the section on source configuration, we use the one from Android-x86 to support Houdini integration. We will analyze the <kbd>nativebridge.mk</kbd> Makefile in the next section:</p>
<pre>
... <br/># Get native bridge settings <br/>$(call inherit-product-if-exists,device/generic/common/nativebridge/nativebridge.mk) <br/>... 
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Using the Android-x86 implementation</h1>
            </header>

            <article>
                
<p>Since we use Houdini support from the Android-x86 project, we can see that we only need to make very minor changes to the x86emu Makefiles.</p>
<p>Now let's look at <kbd>nativebridge.mk</kbd> in Android-x86:</p>
<pre>
# Enable native bridge <br/>WITH_NATIVE_BRIDGE := true <br/><br/># Native Bridge ABI List <br/>NATIVE_BRIDGE_ABI_LIST_32_BIT := armeabi-v7a armeabi <br/>NATIVE_BRIDGE_ABI_LIST_64_BIT := arm64-v8a <br/><br/>LOCAL_SRC_FILES := bin/enable_nativebridge <br/><br/>PRODUCT_COPY_FILES := $(foreach f,$(LOCAL_SRC_FILES),$(LOCAL_PATH)/$(f):system/$(f)) <br/><br/>PRODUCT_PROPERTY_OVERRIDES := \ <br/>    ro.dalvik.vm.isa.arm=x86 \ <br/>    ro.enable.native.bridge.exec=1 \  <br/><br/>ifeq ($(TARGET_SUPPORTS_64_BIT_APPS),true) <br/>PRODUCT_PROPERTY_OVERRIDES += \ <br/>    ro.dalvik.vm.isa.arm64=x86_64 \ <br/>    ro.enable.native.bridge.exec64=1 <br/>endif <br/><br/>PRODUCT_DEFAULT_PROPERTY_OVERRIDES := ro.dalvik.vm.native.bridge=libnb.so <br/><br/>PRODUCT_PACKAGES := libnb <br/><br/>$(call inherit-product-if-exists,vendor/intel/houdini/houdini.mk) 
</pre>
<p><kbd>nativebridge.mk</kbd> copies an <kbd>enable_nativebridge</kbd> script to the <kbd>system</kbd> folder first. After that, it sets the <kbd>ro.dalvik.vm.isa.arm</kbd> and <kbd>ro.enable.native.bridge.exec</kbd> properties. These two properties will be added to <kbd>system/build.prop</kbd> in the system image. It also sets the default property <kbd>ro.dalvik.vm.native.bridge</kbd> to <kbd>libnb.so</kbd>. This property is used by ART to find the Houdini library. Android-x86 uses the <kbd>libnb.so</kbd> library instead of <kbd>libhoudini.so</kbd>, which all supported Intel devices use. The <kbd>libnb.so</kbd> library is a wrapper of <kbd>libhoudini.so</kbd>. Since we use <kbd>libnb.so</kbd> as the ARM binary translation library, we need to add this package to the build.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Analyzing libnb.so</h1>
            </header>

            <article>
                
<p>Since the <kbd>libnb.so</kbd> library is the key starting point for Native Bridge support in Android-x86, we will dive into the details of it now. The Makefile to build <kbd>libnb.so</kbd> can be found at <kbd>device/generic/common/nativebridge/Android.mk</kbd>. The source code for <kbd>libnb.so</kbd> includes only one file, <kbd>libnb.cpp</kbd>, as follows:</p>
<pre>
#define LOG_TAG "libnb" <br/><br/>#include &lt;dlfcn.h&gt; <br/>#include &lt;cutils/log.h&gt; <br/>#include &lt;cutils/properties.h&gt; <br/>#include "nativebridge/native_bridge.h" <br/><br/>namespace android { <br/><br/>static void *native_handle = nullptr; <br/><br/>static NativeBridgeCallbacks *get_callbacks() <br/>{ <br/>    static NativeBridgeCallbacks *callbacks = nullptr; <br/><br/>    if (!callbacks) { <br/>        const char *libnb = "/system/" <br/>        #ifdef __LP64__ <br/>                "lib64/arm64/" <br/>        #else <br/>                "lib/arm/" <br/>        #endif <br/>                "libhoudini.so"; <br/>        if (!native_handle) { <br/>            native_handle = dlopen(libnb, RTLD_LAZY); <br/>            if (!native_handle) { <br/>                ALOGE("Unable to open %s", libnb); <br/>                return nullptr; <br/>            } <br/>        } <br/>        callbacks = reinterpret_cast&lt;NativeBridgeCallbacks *&gt; <br/>        (dlsym(native_handle, "NativeBridgeItf")); <br/>    } <br/>    return callbacks; <br/>} <br/><br/>// NativeBridgeCallbacks implementations <br/>static bool native_bridge2_initialize(const    <br/>  NativeBridgeRuntimeCallbacks *art_cbs, const char  <br/>  *app_code_cache_dir, const char *isa) <br/>{ <br/>    ALOGV("enter native_bridge2_initialize %s %s", <br/>    app_code_cache_dir, isa); <br/>    if (property_get_bool("persist.sys.nativebridge", 0)) { <br/>        if (NativeBridgeCallbacks *cb = get_callbacks()) { <br/><strong>return cb-&gt;initialize(art_cbs, app_code_cache_dir, isa)</strong>; <br/>        } <br/>    } else { <br/>        ALOGW("Native bridge is disabled"); <br/>    } <br/>    return false; <br/>} <br/><br/>static void *native_bridge2_loadLibrary(const char *libpath, int flag) <br/>{ <br/>    ALOGV("enter native_bridge2_loadLibrary %s", libpath); <br/>    NativeBridgeCallbacks *cb = get_callbacks(); <br/><strong>    return cb ? cb-&gt;loadLibrary(libpath, flag) : nullptr;</strong> <br/>} <br/><br/>static void *native_bridge2_getTrampoline(void *handle,  <br/>  const char *name, const char* shorty, uint32_t len) <br/>{ <br/>    ALOGV("enter native_bridge2_getTrampoline %s", name); <br/>    NativeBridgeCallbacks *cb = get_callbacks(); <br/>    return cb ? <strong>cb-&gt;getTrampoline(handle, name, shorty, len) <br/></strong>    : nullptr; <br/>} <br/><br/>static bool native_bridge2_isSupported(const char *libpath) <br/>{ <br/>    ALOGV("enter native_bridge2_isSupported %s", libpath); <br/>    NativeBridgeCallbacks *cb = get_callbacks(); <br/>    return cb ? <strong>cb-&gt;isSupported(libpath)</strong> : false; <br/>} <br/><br/>static const struct NativeBridgeRuntimeValues *native_bridge2_getAppEnv(const char *abi) <br/>{ <br/>    ALOGV("enter native_bridge2_getAppEnv %s", abi); <br/>    NativeBridgeCallbacks *cb = get_callbacks(); <br/>    return cb ? <strong>cb-&gt;getAppEnv(abi)</strong> : nullptr; <br/>} <br/><br/>static bool native_bridge2_is_compatible_compatible_with(uint32_t version) <br/>{ <br/>    // For testing, allow 1 and 2, but disallow 3+. <br/>    return version &lt;= 2; <br/>} <br/><br/>static NativeBridgeSignalHandlerFn native_bridge2_get_signal_handler(int signal) <br/>{ <br/>    ALOGV("enter native_bridge2_getAppEnv %d", signal); <br/>    NativeBridgeCallbacks *cb = get_callbacks(); <br/>    return cb ? <strong>cb-&gt;getSignalHandler(signal)</strong> : nullptr; <br/>} <br/><br/>static void __attribute__ ((destructor)) on_dlclose() <br/>{ <br/>    if (native_handle) { <br/>        dlclose(native_handle); <br/>        native_handle = nullptr; <br/>    } <br/>} <br/><br/>extern "C" { <br/><br/>NativeBridgeCallbacks NativeBridgeItf = { <br/>    version: 2, <br/>    initialize: &amp;native_bridge2_initialize, <br/>    loadLibrary: &amp;native_bridge2_loadLibrary, <br/>    getTrampoline: &amp;native_bridge2_getTrampoline, <br/>    isSupported: &amp;native_bridge2_isSupported, <br/>    getAppEnv: &amp;native_bridge2_getAppEnv, <br/>    isCompatibleWith: &amp;native_bridge2_is_compatible_compatible_with, <br/>    getSignalHandler: &amp;native_bridge2_get_signal_handler, <br/>}; <br/><br/>} // extern "C" <br/>} // namespace android 
</pre>
<p>In <kbd>libnb.cpp</kbd>, we can see that it loads the <kbd>libhoudini.so</kbd> library, which is the original Houdini library from Intel, and it makes only two changes. It checks the <kbd>persist.sys.nativebridge</kbd> property before it does the initialization. The rest of the code provides a wrapper of <kbd>NativeBridgeCallbacks</kbd> and the wrapper functions call the one in the Houdini library directly.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Using binfmt_misc</h1>
            </header>

            <article>
                
<p>Up to now, what we have discussed is how to load an ARM shared library in the Intel x86 architecture. Houdini can also support running standalone ARM applications on Intel devices as well. To do this, it uses a mechanism called <kbd>binfmt_misc</kbd>. <kbd>binfmt_misc</kbd>, which is a capability of the Linux kernel that allows arbitrary executable file formats to be recognized and passed to certain user space applications, such as emulators and virtual machines.</p>
<p>According to the Linux kernel documentation, this kernel feature allows you to invoke almost every program by simply typing its name in the shell. This includes, for example, compiled Java (TM), Python, or Emacs. To achieve this, you must tell <kbd>binfmt_misc</kbd> which interpreter should be invoked with which binary. <kbd>binfmt_misc</kbd> recognizes the binary-type by matching some bytes at the beginning of the file with a magic byte sequence (masking out specified bits) that you have supplied. <kbd>binfmt_misc</kbd> can also recognize a filename extension such as <kbd>.com</kbd> or <kbd>.exe</kbd>.</p>
<p>To use this method, first we must mount <kbd>binfmt_misc</kbd>:</p>
<pre>
<strong>$ mount binfmt_misc -t binfmt_misc /proc/sys/fs/binfmt_misc </strong> 
</pre>
<p>To register a new binary type, we must set up a string that looks as follows:</p>
<pre>
:name:type:offset:magic:mask:interpreter:flags  
</pre>
<p>Then we need to add it to <kbd>/proc/sys/fs/binfmt_misc/register</kbd>.</p>
<p>Here is what the fields mean:</p>
<ul>
<li><kbd>name</kbd> is an identifier string. A new <kbd>/proc</kbd> file will be created with this name below the <kbd>/proc/sys/fs/binfmt_misc</kbd> directory.</li>
<li><kbd>type</kbd> is the type of recognition. It gives <kbd>M</kbd> for magic and <kbd>E</kbd> for extension.</li>
<li><kbd>offset</kbd> is the offset of the magic/mask in the file, counted in bytes. This defaults to 0 if you omit it (that is, you write <kbd>:name:type::magic...</kbd>).</li>
<li><kbd>magic</kbd> is the byte sequence that <kbd>binfmt_misc</kbd> is matching for. The magic string may contain hex-encoded characters such as <kbd>\x0a</kbd> or <kbd>\xA4</kbd>. In a shell environment, you should write <kbd>\\x0a</kbd> to prevent the shell from eating your <kbd>\</kbd>. If you chose the matching filename extension, this is the extension to be recognized (without the <kbd>.</kbd>, the <kbd>\x0a</kbd> specials are not allowed). Extension matching is case-sensitive.</li>
<li><kbd>mask</kbd> is a (optional, defaults to all <kbd>0xff</kbd>) mask. You can mask out some bits from matching by supplying a string like magic.</li>
<li><kbd>interpreter</kbd> is the program that should be invoked with the binary as the first argument (specify the full path).</li>
<li><kbd>flags</kbd> is an optional field that controls several aspects of the invocation of the interpreter. It is a string of capital letters and each controls a certain aspect.</li>
</ul>
<p>In <kbd>nativebridge.mk</kbd>, it copies an <kbd>enable_nativebridge</kbd> script to the <kbd>system</kbd> folder. This file is used to enable Houdini in Android-x86. In Android-x86, Houdini is not enabled by default. This can be turned on at any time using an option in <span class="packt_screen">Settings app</span> of Android-x86. Of course, this is not supported in the AOSP source code. When you turn on Houdini in Android-x86, it calls the <kbd>enable_nativebridge</kbd> script. This script does two things:</p>
<ol>
<li>It downloads Houdini from the third-party project repository to the local repository and installs it in the <kbd>/system/lib/arm</kbd> system directory. It also sets the <kbd>persist.sys.nativebridge</kbd> property to <kbd>1</kbd>.</li>
<li>In the second part of this script, it creates the <kbd>binfmt_misc</kbd> files in the <kbd>/proc</kbd> directory.</li>
</ol>
<p>We won't use the <kbd>enable_nativebridge</kbd> script directly, but we want to run the second part of <kbd>enable_nativebridge</kbd> at the system start. With the second part, Houdini is enabled in the Android emulator by default. This can be done by adding the second part of <kbd>enable_nativebridge</kbd> to <kbd>device/generic/goldfish/init.goldfish.sh</kbd>. The following is the code snippet that we added to the end of <kbd>init.goldfish.sh</kbd>. This is the script that is used to set up the environment for the Android emulator during system startup:</p>
<pre>
... <br/># <br/># Houdini integration (Native Bridge) <br/># <br/>houdini_bin=0 <br/>dest_dir=/system/lib$1/arm$1 <br/>binfmt_misc_dir=/proc/sys/fs/binfmt_misc <br/><br/># if you don't see the files 'register' and 'status' in /proc/sys/fs/binfmt_misc <br/># then run the following command: <br/># mount -t binfmt_misc none /proc/sys/fs/binfmt_misc <br/><br/># this is to add the supported binary formats via binfmt_misc <br/><br/>if [ ! -e $binfmt_misc_dir/register ]; then <br/>   mount -t binfmt_misc none $binfmt_misc_dir <br/>fi <br/><br/>cd $binfmt_misc_dir <br/>if [ -e register ]; then <br/>   # register Houdini for arm binaries <br/>   if [ -z "$1" ]; then <br/>         echo ':arm_exe:M::\\x7f\\x45\\x4c\\x46\\x01\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x28::'"$dest_dir/houdini:P" &gt; register <br/>         echo ':arm_dyn:M::\\x7f\\x45\\x4c\\x46\\x01\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x28::'"$dest_dir/houdini:P" &gt; register <br/>   else <br/>         echo ':arm64_exe:M::\\x7f\\x45\\x4c\\x46\\x02\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\xb7::'"$dest_dir/houdini64:P" &gt; register <br/>         echo ':arm64_dyn:M::\\x7f\\x45\\x4c\\x46\\x02\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\xb7::'"$dest_dir/houdini64:P" &gt; register <br/>   fi <br/>   if [ -e arm${1}_exe ]; then <br/>         houdini_bin=1 <br/>   fi <br/>else <br/>   log -pe -thoudini "No binfmt_misc support" <br/>fi <br/><br/>if [ $houdini_bin -eq 0 ]; then <br/>   log -pe -thoudini "houdini$1 enabling failed!" <br/>else <br/>   log -pi -thoudini "houdini$1 enabled" <br/>fi <br/><br/>[ "$(getprop ro.zygote)" = "zygote64_32" -a -z "$1" ] &amp;&amp; exec $0 64 
</pre>
<p>After we rebuild the image and start the emulator, we can verify the changes using the following command:</p>
<pre>
<strong>$ adb shell</strong><br/><strong>root@x86emu:/ # ls /proc/sys/fs/binfmt_misc/                      </strong><br/><strong>arm_dyn</strong><br/><strong>arm_exe</strong><br/><strong>register</strong><br/><strong>status</strong>  
</pre>
<p>We can see that we registered two <kbd>binfmt_misc</kbd> types: <kbd>arm_dyn</kbd> and <kbd>arm_exe</kbd>. The <kbd>/proc</kbd> file <kbd>arm_dyn</kbd> is used to load the shared library and <kbd>arm_exe</kbd> is used to load the ARM executable:</p>
<pre>
<strong>root@x86emu:/ # cat /proc/sys/fs/binfmt_misc/arm_exe              </strong><br/><strong>enabled</strong><br/><strong>interpreter /system/lib/arm/houdini</strong><br/><strong>flags: P</strong><br/><strong>offset 0</strong><br/><strong>magic 7f454c46010101000000000000000000020028</strong>  
</pre>
<p>If we look at the content of <kbd>arm_exe</kbd>, from the preceding output we can see that the <kbd>/system/lib/arm/houdini</kbd> interpreter is used to interpret ARM binaries.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Building and testing</h1>
            </header>

            <article>
                
<p>We have made all the code changes to enable Houdini now. We can build the system image using the following commands:</p>
<pre>
<strong>$ source build/envsetup.sh</strong><br/><strong>$ lunch x86emu_x86-eng</strong><br/><strong>$ m -j4</strong>  
</pre>
<p>After we build the system image, we can test it. Of course, we can test the images using any Android application that can run on the ARM architecture. However, in order to get details about the test targets, we will use two unit test applications to verify our work in this chapter. The first one is a standalone ARM application that can be run from the command line. The second one is an Android application with a JNI shared library for ARM only. The Android emulator images and test binaries in this chapter can be downloaded from<span class="URLPACKT"> <a href="https://sourceforge.net/projects/android-system-programming/files/android-7/ch05/ch05.zip/download">https://sourceforge.net/projects/android-system-programming/files/android-7/ch05/ch05.zip/download</a>.</span></p>
<p><span class="URLPACKT">The source code for these two test applications is hosted on GitHub. You can get the source code at </span><span class="URLPACKT"><a href="https://github.com/shugaoye/asp-sample/tree/master/ch05">https://github.com/shugaoye/asp-sample/tree/master/ch05</a>.</span></p>
<p>To build the test applications, you need to have both Android SDK and NDK so that you can build both Android applications and native applications.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Testing the command-line application</h1>
            </header>

            <article>
                
<p>After you clone the preceding Git repository for test applications, you can build and test them. Let's test the command-line application first. It is a very simple "hello world" application to print just one line message to standard output as follows:</p>
<pre>
#include &lt;stdio.h&gt; <br/><br/>void main() <br/>{ <br/>    printf("This is built using NDK r12.n"); <br/>} 
</pre>
<p>You can build it and test it in the emulator as follows:</p>
<pre>
<strong>$ cd ch05/test1</strong><br/><strong>$ ./build.sh </strong><br/><strong>[armeabi-v7a] Install : ch05_test =&gt; libs/armeabi-v7a/ch05_test</strong><br/><strong>$ file libs/armeabi-v7a/ch05_test</strong><br/><strong>libs/armeabi-v7a/ch05_test: ELF 32-bit LSB  shared object, ARM, EABI5 version 1 (SYSV), dynamically linked (uses shared libs), BuildID[sha1]=b3cf0ae12c0d5b192053dc40c31f665196145039, stripped</strong><br/><strong>$ adb push libs/armeabi-v7a/ch05_test /data/local/tmp</strong><br/><strong>[100%] /data/local/tmp/ch05_test</strong><br/><strong>$ adb shell</strong><br/><strong>root@x86emu:/ # cd /data/local/tmp</strong><br/><strong>127|root@x86emu:/data/local/tmp # ./ch05_test</strong><br/><strong>This is built using NDK r12.</strong>  
</pre>
<p>After you build it, you can check the file format using the <kbd>file</kbd> command. You can see that the output is a 32-bit ARM ELF file. You can push this binary to the emulator using <kbd>adb</kbd> and run it. You will see that it can print the output message to standard output correctly.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Testing the Android JNI application</h1>
            </header>

            <article>
                
<p>Next, let's test the Android application with the ARM JNI library.</p>
<p>The JNI library can be found at <kbd>ch05/test2/jni</kbd>. The processor architecture that can be supported is defined in <kbd>Application.mk</kbd> as follows:</p>
<pre>
# Build both ARMv5TE and ARMv7-A and x86 machine code. <br/># armeabi armeabi-v7a  <br/>APP_ABI := armeabi armeabi-v7a <br/>APP_PLATFORM := android-23 
</pre>
<p>We can see that we build the JNI library for <kbd>armeabi</kbd> and <kbd>armeabi-v7a</kbd>. Let's build the JNI library using NDK first:</p>
<pre>
<strong>$ cd ch05/test2/jni</strong><br/><strong>$ ./build.sh</strong><br/><strong>[armeabi] Install : libHelloJNI.so =&gt; libs/armeabi/libHelloJNI.so</strong><br/><strong>[armeabi-v7a] Install: libHelloJNI.so =&gt; libs/armeabi-v7a/libHelloJNI.so</strong>  
</pre>
<p>After we build the JNI library, we can import the Android source code to Eclipse or Android Studio to build the application itself. We won't explain the details of importing and building Android applications. You can read books on how to develop an Android application and how to develop a JNI library to find out more. What we want to investigate here is the test result. After we have the APK file, we can install it in the emulator and run it. At the same time, we can catch the debug log using logcat. Here is the log from my environment:</p>
<pre>
... <br/>10-02 00:44:57.871: I/ActivityManager(1527): START u0 {act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=fr.myrddin.hellojni/.HelloJNIActivity (has extras)} from uid 10008 on display 0 <br/>10-02 00:44:57.900: I/ActivityManager(1527): Start proc 2652:fr.myrddin.hellojni/u0a53 for activity fr.myrddin.hellojni/.HelloJNIActivity <br/>10-02 00:44:57.902: I/art(2652): Late-enabling JIT <br/>10-02 00:44:57.903: D/houdini(2652): [2652] Initialize library(version: 6.1.1a_x.48413 RELEASE)... successfully. <br/>10-02 00:44:57.907: W/art(2652): Unexpected CPU variant for X86 using defaults: x86 <br/>10-02 00:44:57.907: I/art(2652): JIT created with code_cache_capacity=2MB compile_threshold=1000 <br/>10-02 00:44:58.546: W/art(1527): Long monitor contention event with owner method=int com.android.server.wm.WindowManagerService.relayoutWindow(com.android.server.wm.Session, android.view.IWindow, int, android.view.WindowManager$LayoutParams, int, int, int, int, android.graphics.Rect, android.graphics.Rect, android.graphics.Rect, android.graphics.Rect, android.graphics.Rect, android.graphics.Rect, android.content.res.Configuration, android.view.Surface) from WindowManagerService.java:3104 waiters=0 for 632ms <br/>10-02 00:44:58.580: W/dex2oat(2667): Unexpected CPU variant for X86 using defaults: x86 <br/>10-02 00:44:58.581: W/dex2oat(2667): Mismatch between dex2oat instruction set features (ISA: X86 Feature string: smp,-ssse3,-sse4.1,-sse4.2,-avx,-avx2) and those of dex2oat executable (ISA: X86 Feature string: smp,ssse3,-sse4.1,-sse4.2,-avx,-avx2) for the command line: <br/>10-02 00:44:58.581: W/dex2oat(2667): /system/bin/dex2oat --runtime-arg -classpath --runtime-arg  --compiler-filter=interpret-only --instruction-set=x86 --instruction-set-features=smp,ssse3,-sse4.1,-sse4.2,-avx,-avx2 --runtime-arg -Xrelocate --boot-image=/system/framework/boot.art --runtime-arg -Xms64m --runtime-arg -Xmx512m --compiler-filter=verify-at-runtime --instruction-set-variant=x86 --instruction-set-features=default --dex-file=/data/app/fr.myrddin.hellojni-1/base.apk --oat-file=/data/dalvik-cache/x86/data@app@fr.myrddin.hellojni-1@base.apk@classes.dex <br/>10-02 00:44:58.581: E/dex2oat(2667): Failed to create oat file: /data/dalvik-cache/x86/data@app@fr.myrddin.hellojni-1@base.apk@classes.dex: Permission denied <br/>10-02 00:44:58.581: I/dex2oat(2667): dex2oat took 774.330us (threads: 2)  <br/>10-02 00:44:58.582: W/art(2652): Failed execv(/system/bin/dex2oat --runtime-arg -classpath --runtime-arg  --compiler-filter=interpret-only --instruction-set=x86 --instruction-set-features=smp,ssse3,-sse4.1,-sse4.2,-avx,-avx2 --runtime-arg -Xrelocate --boot-image=/system/framework/boot.art --runtime-arg -Xms64m --runtime-arg -Xmx512m --compiler-filter=verify-at-runtime --instruction-set-variant=x86 --instruction-set-features=default --dex-file=/data/app/fr.myrddin.hellojni-1/base.apk --oat-file=/data/dalvik-cache/x86/data@app@fr.myrddin.hellojni-1@base.apk@classes.dex) because non-0 exit status <br/>10-02 00:44:58.603: D/houdini(2652): [2652] Added shared library /data/app/fr.myrddin.hellojni-1/lib/arm/libHelloJNI.so for ClassLoader by Native Bridge. <br/>10-02 00:44:58.603: E/JNI(2652): Number : 4  <br/>... <br/>10-02 00:44:59.906: I/ActivityManager(1527): Displayed fr.myrddin.hellojni/.HelloJNIActivity: +2s9ms  <br/>... 
</pre>
<p>We can see from the preceding log message that Houdini is initialized successfully and that the <kbd>libHelloJNI.so</kbd> JNI library is loaded by Native Bridge.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Summary</h1>
            </header>

            <article>
                
<p>In this chapter, we introduced Native Bridge in Android architecture first so that we can understand how it works. Based on our understanding of Native Bridge, we extended the x86emu device with Houdini support. We changed the Makefiles of the x86emu device and we also utilized the open source project Android-x86 to save the effort of integration. After we integrated Houdini in x86emu, we tested two scenarios of Houdini use:</p>
<ul>
<li>A standalone command-line application</li>
<li>An Android application with a native shared library built with JNI</li>
</ul>
<p>In the next chapter, we will explore more about the x86emu start up process and we will learn how to debug the start up process using a customized ramdisk image.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </body></html>