<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Getting Started with Flutter</h1>
                </header>
            
            <article>
                
<p><span>Before developing any applications, it is ideal to understand the installation process for that system. In this chapter, we will first look at how to install Flutter on your system and choose the right IDE. We will then move on to exploring a sample app that displays the basic <kbd>Hello World</kbd> on our screen. Before we look at how to debug and test our application, we will take a quick look at what <strong>Hot Reload</strong> is.</span></p>
<p><span>To Develop iOS applications, I would recommend using a Mac. We can always use and test applications only on Android and use macOS when deploying those applications. However, problems are always around the corner, so testing the application on the respective platform during building will be highly recommended.</span></p>
<p>In this chapter, we will will cover the following topics:</p>
<ul>
<li>Installing Flutter </li>
<li>Choosing a suitable IDE</li>
<li>Exploring a sample application</li>
<li>Hot Reload</li>
<li>Looking at the Flutter tools and how to use them</li>
<li>Writing and executing tests in Flutter</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing Flutter</h1>
                </header>
            
            <article>
                
<p>Let's get started with our main application and get Flutter installed onto your system. Depending on the operating system you are using, you can follow the given steps to install Flutter on your system. We will take a look at installing Flutter on Windows, Mac, and Linux.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing Flutter on Windows</h1>
                </header>
            
            <article>
                
<p>To install Flutter on Windows, follow these steps:</p>
<ol>
<li>Download Flutter from <a href="https://storage.googleapis.com/flutter_infra/releases/stable/windows/flutter_windows_v1.2.1-stable.zip" target="_blank">https://storage.googleapis.com/flutter_infra/releases/stable/windows/flutter_windows_v1.2.1-stable.zip</a>.</li>
<li>Extract the downloaded file and place it in your desired folder on your system.</li>
<li>Locate and run <kbd>flutter_console.bat</kbd> to start the installation.</li>
<li>We will then need to download and set up Node.js; you can download it from <a href="https://nodejs.org/en/download/" target="_blank">https://nodejs.org/en/download/</a>.</li>
<li>Finally, we will need to download and install Git For Windows 2.x: <a href="https://gitforwindows.org/" target="_blank">https://gitforwindows.org/</a>. </li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing Flutter on Mac</h1>
                </header>
            
            <article>
                
<p>To install Flutter on Mac, follow these steps:</p>
<ol>
<li>Download Flutter for Mac from<span> </span><a href="https://storage.googleapis.com/flutter_infra/releases/stable/macos/flutter_macos_v1.2.1-stable.zip" target="_blank">https://storage.googleapis.com/flutter_infra/releases/stable/macos/flutter_macos_v1.2.1-stable.zip</a>.</li>
<li>Extract the downloaded file and place it in your desired folder on your system using the <kbd>$ export PATH=`pwd`/flutter/bin:$PATH</kbd> command.</li>
<li>Run <kbd>$ flutter doctor</kbd> to verify that everything is set up in the right way.</li>
<li><span>We then need to download and set up Node.js; you can download it from </span><a href="https://www.npmjs.com/get-npm" target="_blank">https://www.npmjs.com/get-npm</a>.</li>
</ol>
<div class="packt_infobox">We will use the following commands: <kbd>bash</kbd>, <kbd>curl</kbd>, <kbd>git 2.x</kbd>, <kbd><span>mkdir</span></kbd>, <kbd>rm</kbd>, <kbd>unzip</kbd>, and <kbd>which</kbd>.</div>
<ol start="5">
<li><span>Finally, we will need to download and install Git</span>:<span> </span><a href="https://git-scm.com/download/mac" target="_blank">https://git-scm.com/download/mac</a><a href="https://git-scm.com/download/mac" target="_blank"/></li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing Flutter on Linux</h1>
                </header>
            
            <article>
                
<p>To install Flutter on Linux, follow these steps:</p>
<ol>
<li>Download Flutter from<span> </span><a href="https://storage.googleapis.com/flutter_infra/releases/stable/linux/flutter_linux_v1.2.1-stable.tar.xz" target="_blank">https://storage.googleapis.com/flutter_infra/releases/stable/linux/flutter_linux_v1.2.1-stable.tar.xz</a>.</li>
<li><span>Extract the downloaded file and place it in your chosen folder on your system using <kbd>$ tar xf ~/Downloads/flutter_linux_v1.2.1-stable.tar.xz</kbd>. </span></li>
<li>Then, add Flutter to your path using <kbd>$ export PATH="$PATH:`pwd`/flutter/bin"</kbd>.</li>
<li><span>We will then need to download and set up Node.js; you can download it from <a href="https://git-scm.com/download/linux">https://git-scm.com/download/linux</a>.<a href="https://git-scm.com/download/linux"/></span></li>
</ol>
<div class="packt_infobox">Here are the commands we will use: <kbd>bash</kbd>, <kbd>curl</kbd>, <kbd>git 2.x</kbd>, <kbd>mkdir</kbd>, <kbd>rm</kbd>, <kbd>unzip</kbd>, <kbd>which</kbd>, and <kbd>xz-utils</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting familiar with IDEs</h1>
                </header>
            
            <article>
                
<div>
<p>For Flutter, it's best to use Android Studio/IntelliJ or <strong>Visual Studio </strong>(<strong>VS</strong>) code with Mac/Windows as your operating systems. These IDEs are the best you can find for developing mobile applications. But to use these with Flutter, we will need to use a few plugins.</p>
<p>We will need a plugin for the Dart compiler, another for code analysis, and another for the Flutter developer workflow (building, running, and debugging).</p>
<p>These plugins can be installed on both Android studio and VS code. All you need to do is search for them in the corresponding plugin sections. The IDEs not only provide the option of these fantastic plugins to support your development. Let's take a look at some quick tips you can use when developing your application.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Some quick tips for using your desired IDE</h1>
                </header>
            
            <article>
                
<div>
<p>When using the Flutter plugin, there is a very good option that can be used while developing your application; it is called the <span class="packt_screen"><strong>quickfix</strong></span> option. To use this, press <em>Alt</em> + <em>Enter</em> (<em>Ctrl</em> + <em>.</em> on VS code) and a popup will be displayed with some quickfixes. Lets take a look at how it looks on screen. The following screenshot shows what it looks like: </p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/faebb8f0-67da-495c-8081-fa951e16178c.png" style="width:22.25em;height:13.83em;"/></p>
<p>In the preceding screenshot, the quickfix gives an option to add a padding: a center widget, wrapping it using a column or a row, and wrapping it with a new widget.</p>
<p>This is a very useful option as it will help you save a lot of time during the development of the application, considering you will be nesting several widgets. While you do this, keeping the code clean is not an easy task.</p>
<p>Another great thing that can be done using the quickfix option is that you can order the children in a column to swap a widget with their parents or remove a widget completely but quickly. The following screenshot shows these options:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/eff7439d-ad80-4b57-bf80-85e06a4bdae6.png" style="width:26.75em;height:14.33em;"/></p>
<p><span>Speaking of nesting, a very useful option from the plugin is the presence of some fake comments at the end of each widget. This helps you understand the tree of the widgets you are composing at a single glance. The following screenshot shows what those fake comments look like:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6f6467a1-1365-4773-bc82-aa7360c24ef6.png" style="width:16.25em;height:8.33em;"/></p>
<p>These few tips may not seem very useful at first, but once you start developing applications with Flutter, they will be essential and will help you work more quickly.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploring a sample app</h1>
                </header>
            
            <article>
                
<div>
<p>Let's take a look at how the code in Flutter looks and explore its elements. F<span>irst, l</span>et's create a new project; this way, Flutter-cli will create a sample app for us to explore. Before we start looking at the code, here is t<span>he GitHub repository dedicated to this book: </span><a href="https://github.com/PacktPublishing/Flutter-Quick-Start-Guide/tree/master/sample_app">https://github.com/PacktPublishing/Flutter-Quick-Start-Guide/tree/master/sample_app</a>.<a href="https://github.com/PacktPublishing/Flutter-Quick-Start-Guide/tree/master/sample_app"/></p>
<p>The following screenshot shows how the Flutter code looks; let's explore its elements:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2da0d6fe-249e-4e23-8ddb-ae6bd2fabfc3.png" style="width:21.08em;height:10.83em;"/></p>
<p><span>As you can see, the entry point of the application is the </span><kbd>main</kbd><span> function in which you can see the call to the </span><kbd>runApp</kbd><q><em>.</em> </q>This is the first line that is executed; its task is to set up the Flutter framework and run the selected application. When we set up the application, initially, it is a normal stateless widget.</p>
<p>Next, we come to the <kbd>Build</kbd> method. It is displayed in the previous screenshot as <kbd>Widget build(BuildContext context)</kbd> . The <kbd>Build</kbd> method is the one that returns the <kbd>MaterialAPP</kbd>, sets the title, and sets a general theme. In addition to this, the <kbd>Build</kbd> method also sets the routing of an application and the home screen.</p>
<p>Moving on, let's take a look at the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ee7935ce-6154-4175-9f0c-5ce394710346.png" style="width:28.17em;height:14.17em;"/></p>
<p>The sample application that we are working on is composed of a Scaffold with a counter that is incremented with the pressure of a <span><strong>Floating Action Button</strong> (</span><strong>FAB</strong>). As we can see in the preceding screenshot, there is no <kbd>setText</kbd> here. <span>The counter is described by just one variable that is updated by the handler of the </span><kbd>onPressed</kbd><span> action of the FAB.</span><q> </q></p>
<p>Let's move on and look at the most important line in the code: line 49 in the previous screenshot. <span>In Flutter, you use the </span><kbd>setState()</kbd><q> </q><span>method to update the UI and sync it with the underlying variables. In this case, we are incrementing the <kbd>_counter</kbd><q> </q></span>variable, and, at the same time, we also want the application to render the text showing the number. These are a few of the elements you will be able to use when you create a sample project in Flutter. We'll take a look at one of the best features of Flutter in the next section: Hot Reload.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hot Reload</h1>
                </header>
            
            <article>
                
<p>Before you begin the actual development of your application in Flutter, it is good to know what features of Flutter you can use to make life easier. Hot Reload is one such feature; it will make development much easier. How is it going to do that? Let's take a look.</p>
<p>To understand how Hot Reload is a blessing, let's consider a normal development flow, where you are building a tab for setting up a page of your application. When you navigate to your tab, you find out that a certain text is too small. Usually, you would have to go back and change the font size in the code and then navigate back to the point and check whether the size is now correct. If not, you do the same thing again: you go back to change the font size in the code, come back to the point, and check whether it is now correct. You will have to do this again and again until you figure out the right font size. </p>
<p>This is very time-consuming and frustrating, right? But in Flutter, we won't have to do this, because we have the Hot Reload feature. In this particular situation, all you will have to do is edit the font size and press <span>⌘+S. Once you do this, your app will show the updated version of the code! We will not have to recompile or navigate to that specific screen again and again.</span></p>
<p>How is that even possible? H<span>ot Reload uses the </span><span>JIT compiling </span><span>feature of Dart. The edited code is injected into the application running in debug mode in a matter of milliseconds, keeping the state in its memory.</span></p>
<p>This is an amazing feature for developers, as it changes the way the development workflow works. You will have the opportunity here to write the code in a different way, and this helps you make more modifications in your UI code, without being afraid of rigorous work.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Debugging an application</h1>
                </header>
            
            <article>
                
<p>Debugging an application is one of the most important things to learn about when learning to develop any application. Debugging will help you identify and work on errors in your code. <span>Errors are always around the corner, and knowing how to deal with them is essential. To understand debugging in Flutter, we will have to understand these three concepts: </span></p>
<ul>
<li><strong><span>Dart analyzer</span></strong></li>
<li><strong><span>Dart observatory </span></strong></li>
<li><span><strong>Visual debugging</strong></span></li>
</ul>
<p>We will see in detail what they are and how they help with debugging <strong> </strong>in detail in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dart analyzer</h1>
                </header>
            
            <article>
                
<p>Dart analyzer checks your Dart code for errors. It is essentially a linter of Dart, a simple wrapper around the <kbd>dartanalyzer</kbd> tool. Dart analyzer is also included in the Flutter plugin for Android Studio and VS code, so you won't have to worry about including it separately in your IDE.</p>
<p>We<span> can also create a file named </span><kbd>analysis_options.yaml</kbd><q> </q>and<q> </q><span>specify some additional options that will raise errors/warnings and will help you write better Flutter code.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dart observatory</h1>
                </header>
            
            <article>
                
<p><span>The dart observatory is a tool dedicated to debugging and analyzing Flutter apps. To put a breakpoint and run the app step by step, you can use the help of an IDE. An alternative is the <kbd>debugger()</kbd></span> statement<span>. This line will break the execution in the point where you put it. It's also possible to specify a condition, and the app will stop only if the condition is true:</span></p>
<pre>void function(int aNumber) {<br/> debugger(when: aNumber &lt; 10);<br/> // ...<br/> }</pre>
<p>When you are running a Flutter application, you will see a line in the console, specifying the observatory URL. The line will look as follows:</p>
<pre>Observatory listening on http://127.0.0.1:8100/</pre>
<p>You can perform a number of things by navigating to this URL. You can open the obeservatory, use it to profile the app, examine the heap, allocate memory, and so on. This is a really powerful tool; you can find more information on this at <a href="https://dart-lang.github.io/observatory/">https://dart-lang.github.io/observatory/</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Visual debugging</h1>
                </header>
            
            <article>
                
<p>There are going to be cases where we will need to debug the layout of our application. We might need to align some widgets in a particular way, or sometimes we might not know whether the space between widgets is a margin or padding. In such instances, we will need to visually debug our application. To debug in such instances, enable the <span><kbd>debugPaintSize</kbd> option.</span></p>
<p><span>To do so, set the</span> <kbd>debugPaintSizeEnabled</kbd> variable <span>to <kbd>true</kbd> as follows:</span></p>
<pre class="mce-root">void main() {<br/> debugPaintSizeEnabled=true;<br/> runApp(MyApp());<br/> }</pre>
<p>The following output will be displayed:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c45c133c-ea8c-4b9d-b007-88f9d8346558.png" style="width:22.67em;height:35.92em;"/></p>
<p>As you can see in the previous screenshot, every widget gets colored in and can be easily distinguished now. </p>
<p>This is a very powerful <span>feature and can help you with visual debugging, especially if you are not that "pixel perfect"</span> <span>frontend developer.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Material grid variable</h1>
                </header>
            
            <article>
                
<p>Let's take a look at another visual debugging variable: it's called the <strong>material grid</strong>. Here, you will declare your <span>MaterialApp by setting <kbd>debugShowMaterialGrid</kbd> to <kbd>true</kbd>! Your application will be overlayed by the material pixel grid—which is perfect to study the app layout. The following is how your application would then look:</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The showPerformanceOverlay variable</h1>
                </header>
            
            <article>
                
<p>The next useful option is <span><kbd>showPerformanceOverlay</kbd>. By setting it to <kbd>true</kbd>, you will see the performance of your application displayed in the form of a graph on the upper part of the graph. There will be two graphs displayed on your screen, as shown in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><span> <img src="assets/95645447-fbcd-4374-bb66-b7ea40b16ceb.png" style="width:21.83em;height:34.50em;"/></span></p>
<p>The upper graph shows the time spent by the GPU thread, and the bottom one shows the time spent by the CPU thread. They will also display whether the app is running at less than 60Hz; in this case, you might have some performance issues. This feature will help you understand the performance of your application and to verify whether it is running as expected. </p>
<div class="packt_infobox">B<span>e sure to use this feature only in </span><strong>release </strong><span>mode. In debug mode, the performance is intentionally reduced to have Hot Reload available and raise more warnings. <br/>
<br/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Flutter widget inspector</h1>
                </header>
            
            <article>
                
<p><span>If you are a web developer, you could easily miss the </span><strong><span class="packt_screen">inspect</span></strong><q> </q><span>option in many browsers. Flutter brings it back to you in the form of a Flutter widget inspector. It</span> is yet another feature that will help you visually debug your application. Let's take a look at a screenshot that displays it:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e2cbf93d-5e9c-42af-b6dc-2404bbf493bb.png" style="width:34.42em;height:12.58em;"/></p>
<p>This is the Flutter widget inspector that we can find in our Android studio. There are many options that this feature presents to us; some of them are shortcuts to the features we mentioned in the visual debugging section. To trigger the inspector, perform the following steps:</p>
<ol>
<li><span>Click on the <span class="packt_screen">S</span></span><q><span class="packt_screen">elect widget</span> </q>option.</li>
</ol>
<ol start="2">
<li>Then, click on a widget on your device. The widget you click on will be selected and highlighted on the widget tree, as follows:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b0a5bbc2-0c19-4367-b69a-62b1c822787c.png" style="border: 1em solid black;text-align: center;width:58.58em;height:38.67em;"/></p>
<p>Once it is triggered and you can see the widget tree, you can take a look at the widget composition and understand whether there is anything wrong in the layout. </p>
<p>We took a look at debugging and also visually debugging our application. Debugging is a good way to find out whether there are any errors in your application. Another good way to find any anomalies or issues in the working of your application is by testing your application. We'll take a look at testing your Flutter application in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing a Flutter application</h1>
                </header>
            
            <article>
                
<p><span>As your app gets bigger and bigger, a good set of tests may help you save time, as tests can find new bugs that could appear with normal modifications. Even performing <strong>Test Driven Development</strong> (<strong>TDD</strong>) is a good idea, as it can help you define a structure of your project and write less but more efficient code.</span></p>
<p><span>In Flutter, there are mainly three kinds of automated testing:</span></p>
<ul>
<li><strong>Unit testing</strong></li>
<li><strong>Widget testing</strong></li>
<li><strong>Integration testing</strong></li>
</ul>
<p>Let's take a look at them in detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unit testing</h1>
                </header>
            
            <article>
                
<p>As the name suggests, a unit test is a type of testing that is used to test a single unit of code. This small unit could be a function, a method, or a class. Generally, in unit testing, we won't need to write on a disk, render to a screen, or receive external input. Unit tests must be as small as possible, so remove any possible external dependencies.</p>
<p>These tests are low maintenance and low in cost, and are very quick in terms of the time they take to execute. The only drawback of unit testing is that you can never completely reply on it, as it does not test the system as a whole. For this reason, there are other kinds of testing that should be used. Let's take a look at how to perform this type of testing:</p>
<ol>
<li>Import <kbd>pubspec.yaml</kbd><span> into your testing framework, as follows:</span></li>
</ol>
<pre>      dev_dependencies:<br/>           flutter_test:<br/>             sdk: flutter</pre>
<ol start="2">
<li>Write the test code in <kbd>test/unit_test.dart</kbd>:</li>
</ol>
<pre>      import 'package:test/test.dart';<br/>      void main() {<br/>         test('the answer to the question', () {<br/>           var answer = 42;<br/>           expect(answer, 42);<br/>         });<br/>       }</pre>
<ol start="3">
<li>Run the test by running <kbd><span>flutter test test/unit_test.dart</span></kbd> in the project folder. Alternatively, you can run <kbd><span>flutter test</span></kbd> to run all the tests.</li>
</ol>
<p>Unit tests are run in a local Dart VM with <span>a headless version of the Flutter engine.This makes the process faster because it doesn't need to boot a real Flutter engine or compile a real application.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Widget testing</h1>
                </header>
            
            <article>
                
<p>Widget testing is also known as <strong>component testing</strong>. As its name suggests, it is used for testing a single widget, and the goal of this test is to verify whether the widget works and looks as expected. </p>
<p><span>In addition to this, you can use the </span><kbd>WidgetTester</kbd><span> utility for multiple things while testing, such as </span><span>sending input to a widget, finding a component in the widget tree, verifying values, and so on.</span></p>
<p>Let's take a look at how a widget test looks in code:</p>
<pre class="mce-root">import 'package:flutter/material.dart';<br/> import 'package:flutter_test/flutter_test.dart';<br/>void main() {<br/>   testWidgets('my first widget test', (WidgetTester tester) async {<br/>     // You can use keys to locate the widget you need to test<br/>     var sliderKey = UniqueKey();<br/>     var value = 0.0;<br/>    // Tells the tester to build a UI based on the widget tree passed to it<br/>     await tester.pumpWidget(<br/>     StatefulBuilder(<br/>       builder: (BuildContext context, StateSetter setState) {<br/>         return MaterialApp(<br/>           home: Material(<br/>             child: Center(<br/>               child: Slider(<br/>                 key: sliderKey,<br/>                 value: value,<br/>                 onChanged: (double newValue) {<br/>                   setState(() {<br/>                     value = newValue;<br/>                       });<br/>                     },<br/>                   ),<br/>                 ),<br/>               ),<br/>             );<br/>           },<br/>         ),<br/>       );<br/>     expect(value, equals(0.0));<br/>    // Taps on the widget found by key<br/>     await tester.tap(find.byKey(sliderKey));<br/>    // Verifies that the widget updated the value correctly<br/>     expect(value, equals(0.5));<br/>   });<br/> }</pre>
<p>While testing, if you need to see<span> the UI, you can always use the </span><kbd>debugDumpApp()</kbd><span> function or run the test using <kbd>flutter tun test/widget_test.dart</kbd>. In this way, you will also be able to interact with the widgets during testing.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"> Integration testing</h1>
                </header>
            
            <article>
                
<p>Now, let's take a look at integration testing. This type of testing is used for testing the whole application or a big part of the application. Integration testing can be used to verify that the app does everything as expected or to test the performance of the code. Integration tests are run on a real device or an emulator, but they can't be run with a headless version of Dart VM like as it can in widget testing.</p>
<p>Now, let's get started with writing and running the tests:</p>
<ol>
<li>Add the <kbd>flutter_driver</kbd><q> </q>package to <kbd>pubspec</kbd>:</li>
</ol>
<pre>      dev_dependencies:<br/>           flutter_driver: <br/>             sdk: flutter</pre>
<ol start="2">
<li>E<span>nable the Flutter driver extension and add a call to the </span><kbd>enableFlutterDriverExtension()</kbd><q> </q>function <span>in </span><kbd>main.dart</kbd><span>.</span></li>
<li><span>Run the integration test by using the </span><kbd>flutter drive</kbd><span> command:</span></li>
</ol>
<pre><strong>      flutter drive --target=my_app/test_driver/my_test.dart<br/></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have installed the tools to use Flutter; we then became familiar with IDE for our use and looked at Hot Reload, one of the best features in Flutter. We then learned about two essential concepts that are required in every application development workflow, that is, debugging and testing. </p>
<p>These concepts are going to help us get started with Flutter and start building our applications with it.</p>
<p>In the next chapter we'll dive into the widget world and learn the different kinds of widgets that the widget catalog holds for us.</p>


            </article>

            
        </section>
    </body></html>