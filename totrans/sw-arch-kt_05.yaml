- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring MVC, MVP, and MVVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter aims to provide a comprehensive comparison of **Model-View-Controller**
    (**MVC**), **Model-View-Presenter** (**MVP**), and **Model-View-ViewModel** (**MVVM**),
    demonstrating their similarities, differences, and the contexts in which they
    shine. By understanding the strengths and weaknesses of each pattern, developers
    can make informed decisions when architecting their applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter begins by exploring the principles of MVC, a pattern that has
    been widely adopted across various platforms, including web and mobile app development.
    We will delve into its three core components: the *Model*, responsible for business
    data; the *View*, responsible for the visual presentation of information to users;
    and the *Controller*, the intermediary between the Model and the View.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will shift our focus to MVP, a pattern that emerged as an evolution
    of MVC. We will examine how MVP addresses some of the limitations of MVC by introducing
    the Presenter, which orchestrates the exchange of data and user interactions between
    the Model and the View. We will analyze the **separation of concerns** (**SoC**)
    achieved in MVP and how it enables improved testability and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will explore MVVM, a pattern that became popular with data-binding
    frameworks. We will investigate how MVVM separates the concerns of the *Model*,
    *View*, and *ViewModel* and how data bindings facilitate the automatic synchronization
    of data between the View and the ViewModel. We will discuss the benefits of declarative
    programming and the increased SoC that MVVM offers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will thus cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: MVC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MVP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MVVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing MVC, MVP, and MVVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beyond MVC, MVP, and MVVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find all the code files used in this chapter on GitHub: [https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-5](https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-5)'
  prefs: []
  type: TYPE_NORMAL
- en: MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MVC pattern originated in the 1970s when the concepts of MVC were developed
    to structure code and separate concerns in the **graphical user interface** (**GUI**)
    of desktop applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the late 1990s and early 2000s, web development became popular. MVC was adopted
    as part of web development frameworks; for example, **JavaServer Pages** (**JSP**),
    Ruby on Rails, ASP.NET, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The MVC pattern divides an application into three interconnected components:
    the Model, the View, and the Controller. Each component has distinct responsibilities
    and interacts with the others in a coordinated manner. This pattern promotes SoC
    and a clear division of responsibilities.'
  prefs: []
  type: TYPE_NORMAL
- en: You may find various versions of interactions among the three components in
    different frameworks and languages. MVC represents the need to separate the Model,
    the View, and the Controller, and not as a prescription of how they work together.
  prefs: []
  type: TYPE_NORMAL
- en: The Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Model is the application’s internal data, independent of the **user interface**
    (**UI**). Data is validated, manipulated, and transformed to other formats within
    the Model. It encapsulates the core behavior and business logic and can be shared
    across different Views.
  prefs: []
  type: TYPE_NORMAL
- en: The View
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The View is responsible for presenting the UI to the end user. It displays the
    data from the Model and provides a mechanism to interact with users. The View
    is passive and reactive to users’ actions. It only contains simple logic that
    is related to rendering data and responding to user input.
  prefs: []
  type: TYPE_NORMAL
- en: The Controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Controller is the intermediary coordinator between the Model, the View,
    and the user. It receives a request from the user and requests an update of the
    data in the Model. Once the Model accepts the request, the Controller updates
    the presentation in the View.
  prefs: []
  type: TYPE_NORMAL
- en: The Controller orchestrates the flow of data and the sequence of changes between
    the Model and the View. In other words, the Controller determines the application’s
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The collaboration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One version of the collaboration among the Model, the View, and the Controller
    is illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – The MVC pattern](img/B21737_05_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – The MVC pattern
  prefs: []
  type: TYPE_NORMAL
- en: The user sees the View and makes requests to the Controller. The Controller
    updates the data in the Model and then the presentation in the View, and finally,
    the user sees a visual response to its previous request to the Controller. The
    View can also be updated when the Model changes, with the use of callback functions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is worth pointing out that the Model does not depend on the View or the Controller.
    On the contrary, the View depends on the Model. The Controller depends on both
    the View and the Model.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of MVC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The MVC pattern separates the concerns of data management (the Model), UI (the
    View), and user interaction (the Controller). As a result, it promotes modularity,
    code reusability, and testability.
  prefs: []
  type: TYPE_NORMAL
- en: The Model captures the application data and business logic, which can be reused
    among multiple UIs and user interactions. Multiple platforms, such as web browser
    interfaces and mobile app interfaces, can both depend on the Model as a module.
    A single update operation and a bulk update operation can reuse the same data
    structure and validation logic within the Model. The business logic in the Model
    can be tested in isolation without dependency on the View and the Controller.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, modularizing the Model, the View, and the Controller enables each
    of them to be replaced without breaking or affecting other modules. If we were
    to rewrite the current UI, it would now be possible to write the next-generation
    UI as an independent module in parallel with the current UI, without the fear
    of breaking any existing functionality or degrading user experience. We could
    still maintain the current UI for one team while the new UI was being built by
    another team.
  prefs: []
  type: TYPE_NORMAL
- en: When the next-generation UI is launched, we can safely decommission the old
    UI module. This reduces a lot of dependencies and risks of releasing software.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, it is not as usual to reuse the View and the Controller.
    As described in the previous diagram, the View depends on the Model, and the Controller
    depends on both the View and the Model. Reusing either of them brings the Model
    as the transitive dependency, locking down the Model to be used. Additionally,
    the Controller is usually tightly coupled with the View, making very little room
    for reuse.
  prefs: []
  type: TYPE_NORMAL
- en: A real-life example of MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to apply MVC in building a frontend application for households
    to draft a contract for the exchange of service (the “contract”) with their neighbors.
    We will use Android Studio and the Android **Software Development** **Kit** (**SDK**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The draft contract should contain basic information, such as each household’s
    name and the services to be exchanged. The household uses a mobile application
    to create a draft contract record. The application as the View has only two screens,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Sample mobile application for drafting a contract](img/B21737_05_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Sample mobile application for drafting a contract
  prefs: []
  type: TYPE_NORMAL
- en: The first screen allows the household to enter its name and the service it provides.
    In this case, it is the Smith household that provides a cleaning service. On the
    other hand, the household enters the neighbor’s name and service in exchange.
    Specifically, here, it is the Lee household that provides a plumbing service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The layout of the screen is defined by XML files as resources under the `/app/src/main/res/layout`
    project folder. For instance, the text field of **Your household** is declared
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The XML block defines the View as an `EditText` component with an assigned ID,
    alignments, and dimensions. Copies (that is, display text) shown in the UI can
    be defined in a separate file and bound here using identifiers. This separates
    the concerns of copywriting and visual layouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'View components in XML layouts can be bound to data sources in a declarative
    manner, using the Android Jetpack library. When the data changes in the Model,
    the View updates automatically without requiring manual updates in the code. This
    mechanism creates a more dynamic and responsive UI. The data binding can be expressed
    in the following XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With the data defined, the View can be bound to the Model. In the following
    example, `TextView` displays the name of `Household`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When the **SUBMIT** button is clicked, the application navigates to the confirmation
    screen. On the screen, it acknowledges that the draft contract has been submitted,
    and the contract of exchanged service is shown to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Model should have two data classes. `HouseholdInput` captures the name
    and service provided by a household, and `DraftContractInput` has two `HouseholdInput`
    objects to form a contract. The two data classes are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a sample repository class, `ContractRepository`, for handling
    the submission of draft contracts. The repository class is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The current implementation of the repository does not do anything but can be
    enhanced to validate and persist draft contracts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Controller` interface in the MVC pattern is the one that coordinates between
    the View and the Model. In this example, an interface is defined for what the
    Controller can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MainActivity` class implements the `Controller` interface and is a subclass
    of `AppCompatActivity` from the Android SDK. It sets up the content of the View,
    controls the screen navigation, and connects with the Model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Up to this part of the `MainActivity` class, it creates a `ContractRepository`
    object from the Model. It also creates a `ContractDraftFragment` screen as the
    first application screen, as shown on the left in *Figure 5**.2*. The `submitContract`
    function from the `Controller` interface invokes the function in the Model to
    submit the draft contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Before the Controller navigates the View to the confirmation screen, it creates
    a `Bundle` object that contains the data submitted. The data is passed to `ConfirmationFragment`,
    which is the screen shown on the right in *Figure 5**.2*. The `ContractDraftFragment`
    sends user actions to the Controller for draft contract submission. This is implemented
    in the `onCreateView` function of the `ContractDraftFragment` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After the View is inflated, a click listener can be set to the `EditText` components
    are then extracted:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic elements in the Android SDK
  prefs: []
  type: TYPE_NORMAL
- en: The Android SDK provides a comprehensive set of tools and components for building
    Android applications. There are a few key elements that are used throughout this
    chapter. An Activity is a single screen with a UI, acting as an entry point for
    user interaction with the application. Fragments are modular sections of an Activity,
    and they can be reused across multiple Activities. Views are the basic building
    blocks for UIs, such as buttons, text fields, and images. Layouts are the declarative
    definition of the UI in XML format, which specifies how Views are arranged on
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A `DraftContractInput` object from the Model is created from the extracted values
    in the `EditText` components. The `DraftContractInput` object is then submitted
    to the `ContractRepository` class for further processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, `ContractDraftFragment` retrieves the `Bundle` object passed from
    the previous screen. The View components are then set with the data from the `Bundle`
    object to display a confirmation screen with details of the draft contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, users first see the UI and fill in the text fields. Then, the
    users click the **SUBMIT** button. This user action invokes the Controller to
    update the View by navigating to a confirmation screen. The Controller also updates
    the Model by submitting a draft contract object to the repository. At the end,
    users see the confirmation screen.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth pointing out that the code in the Model focuses merely on the business
    data and logic, and the View is solely responsible for rendering the UI. The Controller
    does all the coordination between the View and the Model, and this is how SoC
    is achieved in the MVC pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Coming next, we are moving on to MVP, an architecture pattern that can be seen
    as evolving from MVC.
  prefs: []
  type: TYPE_NORMAL
- en: MVP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MVP can be considered a pattern evolving from the MVC pattern. MVP originated
    in the 1990s as a response to the limitations and challenges faced when applying
    MVC to desktop and web application development.
  prefs: []
  type: TYPE_NORMAL
- en: MVP is built upon the concepts of MVC. The View and the Model concepts are shared
    between the two patterns, but interactions between the View and the Model have
    significantly changed.
  prefs: []
  type: TYPE_NORMAL
- en: The major limitation of MVC is the tight coupling between the View and the Controller.
    It results in a limited ability to test the View and the Controller independently.
    Also, when the View is complex and has a lot of presentation logic, it becomes
    difficult to test and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, any variation or extension to the current View inevitably requires
    a proportional change in the Controller as the Controller needs to understand
    all the variations and extensions that exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'MVP promotes an even more decoupled relationship between the View and the Model
    by introducing the Presenter. The following diagram demonstrates the new relationships
    among the View, the Model, and the Presenter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – The MVP pattern](img/B21737_05_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – The MVP pattern
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the user sees the View and interacts with the UI. The View then
    sends the user action to the Presenter. The Presenter updates the data in the
    Model. The Model calls back the Presenter when the data is updated. The Presenter
    then updates the View according to the data changed in the Model. Eventually,
    the user sees an updated UI based on the previous interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Differences from MVC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first noticeable difference between MVP and MVC is that the Model and the
    View do not interact. All messages come through the Presenter, and the Presenter
    depends on both the View and the Model. The View is self-contained and does not
    depend on either the Model or the Presenter.
  prefs: []
  type: TYPE_NORMAL
- en: The second difference is that the View can be completely passive in the sense
    that it is only responsible for rendering the UI as a response to the Presenter’s
    request to update the View. However, the *Passive View* is considered an option
    for MVP. Passive View is a variant of MVP in which the View makes no decisions
    and contains no business logic.
  prefs: []
  type: TYPE_NORMAL
- en: If not passive, the View can contain certain presentation logic that does not
    affect the Model or the Presenter. Simple field validation such as data type and
    length is a typical example.
  prefs: []
  type: TYPE_NORMAL
- en: The third difference is that MVP typically enforces explicit communication with
    the View and the Model. The View informs the Presenter of user actions, and the
    Presenter then interprets and acts upon them. Defining explicit communication
    helps engineers understand and reason about the application’s behaviors, as a
    result making the application easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of MVP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The further SoC among the View, the Model, and the Presenter brings about a
    few benefits on top of the MVC pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The View under MVP can be independently tested, without the involvement of the
    Presenter. The explicit incoming messages to the View can be used as the input
    of test cases, and the UI is used for verification. On the other hand, user interactions
    can be the input of test cases, and the explicit outgoing message from the View
    is used for verification.
  prefs: []
  type: TYPE_NORMAL
- en: With MVP, it is now possible to have variants of View without any change in
    the Presenter. The variant of the View interprets messages from the Presenter
    differently. The variant might produce the same message to the Presenter from
    a slightly different user interaction. In this way, there is no need to change
    the Presenter to support a variant of the View. Nowadays, there are so many variations
    of UIs on different platforms, such as iOS applications, Android applications,
    web applications, and custom devices such as televisions. It is possible for these
    different Views to share the same Model and same Presenter while still giving
    users a unique experience that is tailored to the platform.
  prefs: []
  type: TYPE_NORMAL
- en: MVP standardizes messages explicitly sent to and received by the Presenter.
    It ensures there is no confusion and no room for deviation by different frameworks
    or implementations. It brings clarity to engineers and makes the application easy
    to understand.
  prefs: []
  type: TYPE_NORMAL
- en: A real-life example of MVP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We continue to use the same example we used for the MVC pattern. We are using
    the same real-life example used in MVP, where a household can draft a contract
    of exchanged services (the “contract”) with another household.
  prefs: []
  type: TYPE_NORMAL
- en: Evolving from the MVC pattern, the View and the Model can be kept the same in
    MVP, but the ways of communication will change.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Controller` interface is renamed as `Presenter`, even though the declared
    function has not changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The Presenter has two-way communication with both the View and the Model. So,
    the first change would be to support a callback when the Model has changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DraftContractSubmittedListener` type alias acts as a callback interface
    when the draft contract is submitted to the Model. The `ContractRepository` class
    is enhanced to keep a `DraftContractSubmittedListener` object and will invoke
    the callback when a draft contract is submitted. The implementation of the repository
    class is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The callback function, when the model is updated, can be used to navigate to
    the confirmation screen with the submitted draft contract. This is the updated
    `submitContract` function in the `MainActivity` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, the `ConfirmationFragment` class is updated. The screen
    takes the values directly from the submitted draft contract that was just set
    from `DraftContractSubmittedListener` to `MainActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The major difference between this MVP example and the MVC example is that the
    loading of the confirmation screen is triggered by the change in the Model, with
    the use of a callback function. In this way, all communications between the View
    and the Model are through the Presenter. It is now possible to test the View logic
    in the `ConfirmationFragment` class, the Model logic in the `ContractRepository`
    class, and the Presenter logic in the `MainActivity` class independently.
  prefs: []
  type: TYPE_NORMAL
- en: After MVP, we are going to delve into the MVVM pattern, which also aims to solve
    the same problem as MVC and MVP.
  prefs: []
  type: TYPE_NORMAL
- en: MVVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MVVM was first introduced by John Gossman at Microsoft in 2005\. It was created
    for UI development using the **Windows Presentation Foundation** (**WPF**) framework.
    Later it was adopted by other frameworks, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Xamarin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AngularJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MVVM fundamentally retains the concepts of the Model and the View from the older
    models, MVC and MVP. However, it uses the View Model as an intermediary between
    the View and the Model. There is also a substantial preference for using declarative
    data binding to coding. The data-binding feature of MVVM supports the automatic
    synchronization between the View and the View Model.
  prefs: []
  type: TYPE_NORMAL
- en: The View Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The View Model exposes data and commands that the view can bind to. The data
    binding allows an automatic two-way synchronization between the View and the View
    Model. In other words, updates from the View Model are reflected in the View automatically,
    and the View Model can react to user actions in the View. This reduces boilerplate
    code to manually synchronize the data between the View and the View Model and
    the code to update the View. The following diagram will throw more light on interactions
    among the View, the Model, and the View Model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – The MVVM pattern](img/B21737_05_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – The MVVM pattern
  prefs: []
  type: TYPE_NORMAL
- en: As you can see here, the View Model reads data from the Model, transforms it
    for presentation, and provides properties and functions for the View. The View
    receives the properties and function callback to render the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'A use case in which a user interacts with the View and ends up seeing changes
    in the View is demonstrated in *Figure 5**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – User interacting and seeing changes in the View](img/B21737_05_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – User interacting and seeing changes in the View
  prefs: []
  type: TYPE_NORMAL
- en: When a user interacts with the View, the user actions are propagated to the
    View Model. The View Model executes commands to respond to the user actions, which
    typically involve updating the data in the Model. Once the data is updated in
    the Model, the View Model receives the data update and transforms it for presentation.
    Finally, the View receives the View Model changes and renders the UI as a response
    to the user actions.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of MVVM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MVVM separates the concerns of business logic even further from the presentation
    in the View. The View Model encapsulates presentation logic without needing to
    be concerned about how it is rendered visually. This implies the View Model can
    be tested in isolation, independent of specific details of the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Properties and commands in the View Model can be shared while keeping the user
    experience consistent among multiple Views, such as web browsers, desktop applications,
    and mobile applications. Moreover, View changes can be made without updating the
    View Model. This promotes flexibility and extensibility to evolve the code base.
  prefs: []
  type: TYPE_NORMAL
- en: UI designers can better collaborate with frontend engineers. UI designers can
    focus on styling, layout, and visual components without the need to interfere
    with the business logic. This promotes working in parallel and improves productivity.
  prefs: []
  type: TYPE_NORMAL
- en: The automatic synchronization between the View and the View Model reduces boilerplate
    code to manually update the View when the View Model changes and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: A real-life example of MVVM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Continuing from the same example we used for the MVP pattern, the code base
    is going to evolve to the MVVM pattern. We are using the same real-life example
    from MVC and MVP, and the code base evolves from them using the Android SDK.
  prefs: []
  type: TYPE_NORMAL
- en: 'The View Model is introduced and named `DraftContractViewModel` to store transitional
    data before it is ready to become a draft contact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DraftContractViewModel` object is going to be shared among `Fragments`
    to keep building the data required for a draft contract. This is reflected in
    the mutable fields (known as `var` in Kotlin). Moreover, the View Model acts as
    a bridge between the View and the Model. The `toModel` function converts a View
    Model `DraftContractViewModel` object to the Model `DraftContractInput` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that data integrity logic has been applied to the function to ensure that
    the Model object can only be created when all fields are present. This conversion
    logic can also be tested independently, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This unit test is run by the `null`. The second test creates a View Model object
    with all fields not `null`, and therefore it can be converted to a Model object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data between the View and the View Model is bound and synchronized automatically,
    using the following custom function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Initially, when the `EditText` View component is created, the default value
    is set to the View Model `DraftContractViewModel` object. Subsequently, any text
    change will trigger a callback to update the View Model. The data-binding process
    is kicked off in the `onCreate` function of the first screen, represented by the
    `ContractDraftFragment` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The View Model is looked up here, and the owner is set to be the activity so
    that it can be shared with the next screen. Then, a callback is registered upon
    clicking the `toModel` function is used to convert the View Model to the Model
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code then binds the `EditText` View components with the View
    Model, field by field, using the `bind` function just mentioned previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The confirmation screen gets the submitted data from the View Model directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The View Model is looked up here with the activity as the owner shared with
    the first screen. Then, the View gets the data from the same View Model object.
    There are now two screens sharing the same View Model object, but the Views are
    rendered differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: There are a few more potential features that can be added to this example. As
    the user types in the text fields, the callback function to synchronize the View
    Model keeps on being invoked. This makes it possible to provide real-time validation
    feedback to the user.
  prefs: []
  type: TYPE_NORMAL
- en: As the View Model is shared among multiple screens in the same activity, the
    View can be evolved into a series of screens as a wizard-style multi-step activity.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if the Model is shared between two households in two copies of the application,
    the data of the draft contract can be synchronized in real time using a certain
    protocol such as a **peer-to-peer** (**P2P**) network. When the Model is updated
    externally from the network, the callback function for changes in the Model can
    populate the View Model and then update the View in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing MVC, MVP, and MVVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MVC, MVP, and MVVM patterns share the same concepts of the View and the
    Model. However, their relationships and ways of communication are different.
  prefs: []
  type: TYPE_NORMAL
- en: In MVC, one Controller has access to multiple Views and usually calls the functions
    of View directly. The View and the Model are tightly coupled. User inputs are
    handled by the Controller. Unit testing is limited to the Model on business logic
    only. Modifying the View or the Model would require changing the Controller as
    well. It is suitable for small projects only because the code footprint is the
    smallest.
  prefs: []
  type: TYPE_NORMAL
- en: In MVP, one Presenter manages at least one View. The View and the Model have
    no knowledge about the Presenter, but they communicate with the Presenter using
    callback functions. Also, the View and the Model are decoupled. User inputs are
    handled by the View, and then the View invokes the callback function provided
    by the Presenter. Unit testing can be done in the Model on business logic. The
    behaviors of callback functions from the Model and the View can also be tested.
    Modifying the View or the Model may not need to modify the Presenter if the callback
    function stays the same. It is suitable for small to more complex projects that
    require better testability of the Model and the View.
  prefs: []
  type: TYPE_NORMAL
- en: In MVVM, one View Model maps to one or many Views. The View and the Model are
    also decoupled, but even more separation of business logic from the View and communications
    are more event-driven and supported by the underlying frameworks. User inputs
    are handled by the View, and then the View invokes the callback function provided
    by the View Model. Unit testing can be done in the Model on business logic. The
    behaviors of callback functions from the Model, the View, and the View Model can
    also be tested.
  prefs: []
  type: TYPE_NORMAL
- en: The concerns are easier to separate, and the functions can be small enough to
    conform to the **single-responsibility principle** (**SRP**). Modifying the View
    or the Model may not need to modify the View Model if the data binding has not
    changed. It is suitable for large and complex projects that may be deployed to
    multiple platforms and, therefore, multiple variants of the View and requires
    better isolation between the View and the Model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The comparison is summarized in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **MVC** | **MVP** | **MVVM** |'
  prefs: []
  type: TYPE_TB
- en: '| View and Model tightly coupled. | View and Model are decoupled. | View and
    Model are decoupled. |'
  prefs: []
  type: TYPE_TB
- en: '| Controller depends on View and Model. | One Presenter manages at least one
    View via callback functions. | One VIewmodel manages at least one View via callback
    functions. |'
  prefs: []
  type: TYPE_TB
- en: '| Controller handles user input. | View handles user input. | View handles
    user input. |'
  prefs: []
  type: TYPE_TB
- en: '| Unit testing on Model only. | Unit testing on Model and View. | Unit testing
    on Model, View and Viewmodel. |'
  prefs: []
  type: TYPE_TB
- en: Table 5.1 – Comparison of MVC, MVP, and MVVM
  prefs: []
  type: TYPE_NORMAL
- en: Beyond MVC, MVP, and MVVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'More architectural patterns have evolved from the three patterns we discussed
    previously. The in-depth comparison of these patterns is beyond this chapter,
    but they are worth mentioning:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model-View-Intent (MVI)**: MVI emerged as a pattern influenced by MVC, MVP,
    and MVVM around the 2010s in the Android community. MVI has a unique focus on
    a unidirectional data flow to streamline state management. It also adopts reactive
    programming paradigms to asynchronously manage the unidirectional data flow, using
    libraries such as RxJava and RxJS. The interactions among them are shown in *Figure
    5**.6*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.6 – MVI interaction](img/B21737_05_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – MVI interaction
  prefs: []
  type: TYPE_NORMAL
- en: '**Atomic design**: Introduced by Brad Frost in his book *Atomic Design* in
    2013, atomic design breaks down the UI into five levels:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Atoms**: Elemental building blocks such as text fields'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Molecules**: Functional organization of atoms such as search bars'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Organisms**: Sectional organization of molecules such as navigation panels'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Templates**: Visual layout and organization of organisms that form a page'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pages**: Business-aware and specific instances of pages with real content'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Component-based**: Focus on separating functionalities into self-contained
    and reusable components. Each component encapsulates the behaviors, hides its
    lower-level details, and only exposes higher-level functions via interfaces. It
    goes together with design systems that contain a library of reusable components
    with well-defined behaviors. It aims at providing a consistent user experience
    and optimizing productivity during development. Each component is developed, tested,
    and deployed independently, which makes it easier to update applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server-side rendering (SSR)**: SSR is primarily used in web development but
    can be extended to mobile and desktop applications. The content of a page is generated
    on the server instead of in the browser or on clients’ devices. It aims at improving
    performance and response time by reducing loads in the browser or on clients’
    devices, which come in various computation powers. Optimization of data fetching
    can be done on the server side, and it reduces unnecessary traffic between client
    and server. It does, however, increase the server load for processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We began the chapter with the MVC pattern. We explored the Model, the View,
    and how the Controller interacts with them. We also illustrated the concepts with
    a real-life example of the drafting of a contract for the exchange of services
    among households. The UI of the drafting and confirmation screens was used in
    the example, with the Controller driving the navigation and submitting the draft
    contract.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we bought in the MVP pattern by evolving from MVC. The Presenter was introduced
    to replace the Controller, and callback functions from the Model were added to
    the pattern to further isolate the View and the Model. Then, we came back to the
    same real-life example, and the original code base of MVC was modified to become
    MVP.
  prefs: []
  type: TYPE_NORMAL
- en: Afterward, we introduced the MVVM pattern by evolving from MVP. The View Model
    was added as an intermediary between the View and the Model. Data binding was
    supported to automatically synchronize data between the View and the View Model.
    We reused the same real-life example and refactored it to be an MVVM pattern.
    A custom bind function was introduced to bind values in View components to fields
    in the View Model. The View Model could be converted to the Model object upon
    submission. We discussed the potential enhancement provided by the MVVM pattern,
    such as real-time validation, distributed processing of the View, and multiple
    variants of the View.
  prefs: []
  type: TYPE_NORMAL
- en: We compared the three patterns from multiple perspectives. We discussed the
    relationship between the View and the Model and how coupled they were in each
    pattern. The ways of communication among the three patterns were then compared,
    as well as the ease of unit testing. We looked at the chain of modifications needed
    in each pattern. In the end, we covered which pattern was suitable according to
    the scale of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we introduced a few architectural patterns in the frontend landscape
    that evolved from MVC, MVP, and MVVM.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will look into another set of architectural patterns
    and compare them: monoliths, micro-frontend, microservices, nanoservices, and
    serverless. They are applied in either frontend or backend systems, but they do
    share similar fundamental concepts that are worth a discussion.'
  prefs: []
  type: TYPE_NORMAL
