- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Exploring MVC, MVP, and MVVM
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 MVC、MVP 和 MVVM
- en: This chapter aims to provide a comprehensive comparison of **Model-View-Controller**
    (**MVC**), **Model-View-Presenter** (**MVP**), and **Model-View-ViewModel** (**MVVM**),
    demonstrating their similarities, differences, and the contexts in which they
    shine. By understanding the strengths and weaknesses of each pattern, developers
    can make informed decisions when architecting their applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在全面比较 **模型-视图-控制器**（**MVC**）、**模型-视图-表示者**（**MVP**）和 **模型-视图-视图模型**（**MVVM**），展示它们的相似之处、不同之处以及它们各自的优势领域。通过了解每种模式的优缺点，开发者在架构应用程序时可以做出明智的决策。
- en: 'This chapter begins by exploring the principles of MVC, a pattern that has
    been widely adopted across various platforms, including web and mobile app development.
    We will delve into its three core components: the *Model*, responsible for business
    data; the *View*, responsible for the visual presentation of information to users;
    and the *Controller*, the intermediary between the Model and the View.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先探讨 MVC 的原则，这是一种在包括 Web 和移动应用开发在内的各种平台上广泛采用的模式。我们将深入研究其三个核心组件：*模型*，负责业务数据；*视图*，负责向用户展示信息的视觉呈现；以及*控制器*，模型和视图之间的中介。
- en: Next, we will shift our focus to MVP, a pattern that emerged as an evolution
    of MVC. We will examine how MVP addresses some of the limitations of MVC by introducing
    the Presenter, which orchestrates the exchange of data and user interactions between
    the Model and the View. We will analyze the **separation of concerns** (**SoC**)
    achieved in MVP and how it enables improved testability and maintainability.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把重点转向 MVP，这是一种作为 MVC 进化而出现的模式。我们将研究 MVP 如何通过引入表示者（Presenter）来解决 MVC 的一些局限性，表示者负责在模型和视图之间协调数据交换和用户交互。我们将分析
    MVP 中实现的 **关注点分离**（**SoC**）以及它如何提高可测试性和可维护性。
- en: Finally, we will explore MVVM, a pattern that became popular with data-binding
    frameworks. We will investigate how MVVM separates the concerns of the *Model*,
    *View*, and *ViewModel* and how data bindings facilitate the automatic synchronization
    of data between the View and the ViewModel. We will discuss the benefits of declarative
    programming and the increased SoC that MVVM offers.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探索 MVVM，这是一种随着数据绑定框架的流行而变得流行的模式。我们将研究 MVVM 如何通过分离 *模型*、*视图* 和 *视图模型* 的关注点，以及数据绑定如何促进视图和视图模型之间数据的自动同步。我们将讨论声明性编程的好处以及
    MVVM 提供的更高的 SoC（关注点分离）。
- en: 'We will thus cover the following topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本章将涵盖以下主题：
- en: MVC
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVC
- en: MVP
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVP
- en: MVVM
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVVM
- en: Comparing MVC, MVP, and MVVM
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较 MVC、MVP 和 MVVM
- en: Beyond MVC, MVP, and MVVM
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不仅仅是 MVC、MVP 和 MVVM
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find all the code files used in this chapter on GitHub: [https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-5](https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-5)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到本章使用的所有代码文件：[https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-5](https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-5)
- en: MVC
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVC
- en: The MVC pattern originated in the 1970s when the concepts of MVC were developed
    to structure code and separate concerns in the **graphical user interface** (**GUI**)
    of desktop applications.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 模式起源于 1970 年代，当时 MVC 的概念被开发出来，用于结构化代码并在桌面应用程序的 **图形用户界面**（**GUI**）中分离关注点。
- en: In the late 1990s and early 2000s, web development became popular. MVC was adopted
    as part of web development frameworks; for example, **JavaServer Pages** (**JSP**),
    Ruby on Rails, ASP.NET, and so on.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1990 年代末和 2000 年代初，Web 开发变得流行。MVC 被作为 Web 开发框架的一部分采用；例如，**JavaServer Pages**（**JSP**）、Ruby
    on Rails、ASP.NET 等等。
- en: 'The MVC pattern divides an application into three interconnected components:
    the Model, the View, and the Controller. Each component has distinct responsibilities
    and interacts with the others in a coordinated manner. This pattern promotes SoC
    and a clear division of responsibilities.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 模式将应用程序划分为三个相互关联的组件：模型（Model）、视图（View）和控制器（Controller）。每个组件都有其独特的职责，并以协调的方式与其他组件交互。此模式促进了
    SoC（关注点分离）和职责的清晰划分。
- en: You may find various versions of interactions among the three components in
    different frameworks and languages. MVC represents the need to separate the Model,
    the View, and the Controller, and not as a prescription of how they work together.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在不同的框架和语言中找到三个组件之间不同版本的交互。MVC 代表了分离模型、视图和控制器的需求，而不是它们如何一起工作的规定。
- en: The Model
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型
- en: The Model is the application’s internal data, independent of the **user interface**
    (**UI**). Data is validated, manipulated, and transformed to other formats within
    the Model. It encapsulates the core behavior and business logic and can be shared
    across different Views.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是应用程序的内部数据，独立于**用户界面**（**UI**）。数据在模型内进行验证、操作和转换成其他格式。它封装了核心行为和业务逻辑，并且可以在不同的视图中共享。
- en: The View
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图
- en: The View is responsible for presenting the UI to the end user. It displays the
    data from the Model and provides a mechanism to interact with users. The View
    is passive and reactive to users’ actions. It only contains simple logic that
    is related to rendering data and responding to user input.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 视图负责向最终用户展示用户界面。它显示模型中的数据，并提供与用户交互的机制。视图是被动且对用户动作做出反应的。它只包含与渲染数据和响应用户输入相关的简单逻辑。
- en: The Controller
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器
- en: The Controller is the intermediary coordinator between the Model, the View,
    and the user. It receives a request from the user and requests an update of the
    data in the Model. Once the Model accepts the request, the Controller updates
    the presentation in the View.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器是模型、视图和用户之间的中间协调者。它接收来自用户的请求，并请求更新模型中的数据。一旦模型接受请求，控制器就会更新视图中的展示。
- en: The Controller orchestrates the flow of data and the sequence of changes between
    the Model and the View. In other words, the Controller determines the application’s
    behavior.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器负责协调模型和视图之间数据流和变更序列。换句话说，控制器决定了应用程序的行为。
- en: The collaboration
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协作
- en: 'One version of the collaboration among the Model, the View, and the Controller
    is illustrated in the following diagram:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 模型、视图和控制器之间的一种协作方式如下所示：
- en: '![Figure 5.1 – The MVC pattern](img/B21737_05_1.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – MVC 模式](img/B21737_05_1.jpg)'
- en: Figure 5.1 – The MVC pattern
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – MVC 模式
- en: The user sees the View and makes requests to the Controller. The Controller
    updates the data in the Model and then the presentation in the View, and finally,
    the user sees a visual response to its previous request to the Controller. The
    View can also be updated when the Model changes, with the use of callback functions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 用户看到视图并向控制器发出请求。控制器更新模型中的数据，然后更新视图中的展示，最后，用户看到对之前向控制器发出的请求的视觉响应。当模型发生变化时，视图也可以通过使用回调函数进行更新。
- en: Note
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is worth pointing out that the Model does not depend on the View or the Controller.
    On the contrary, the View depends on the Model. The Controller depends on both
    the View and the Model.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，模型不依赖于视图或控制器。相反，视图依赖于模型。控制器依赖于视图和模型。
- en: The benefits of MVC
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVC的好处
- en: The MVC pattern separates the concerns of data management (the Model), UI (the
    View), and user interaction (the Controller). As a result, it promotes modularity,
    code reusability, and testability.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: MVC模式将数据管理（模型）、用户界面（视图）和用户交互（控制器）的关注点分开。因此，它促进了模块化、代码重用性和可测试性。
- en: The Model captures the application data and business logic, which can be reused
    among multiple UIs and user interactions. Multiple platforms, such as web browser
    interfaces and mobile app interfaces, can both depend on the Model as a module.
    A single update operation and a bulk update operation can reuse the same data
    structure and validation logic within the Model. The business logic in the Model
    can be tested in isolation without dependency on the View and the Controller.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 模型捕获应用程序数据和业务逻辑，这些可以在多个UI和用户交互中重用。多个平台，如网络浏览器界面和移动应用界面，都可以将模型作为模块依赖。单个更新操作和批量更新操作可以在模型内重用相同的数据结构和验证逻辑。模型中的业务逻辑可以在不依赖视图和控制器的情况下独立测试。
- en: In addition, modularizing the Model, the View, and the Controller enables each
    of them to be replaced without breaking or affecting other modules. If we were
    to rewrite the current UI, it would now be possible to write the next-generation
    UI as an independent module in parallel with the current UI, without the fear
    of breaking any existing functionality or degrading user experience. We could
    still maintain the current UI for one team while the new UI was being built by
    another team.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，将模型、视图和控制器模块化使得它们中的任何一个都可以在不破坏或影响其他模块的情况下被替换。如果我们现在要重写当前的UI，就可以将下一代UI作为独立模块与当前UI并行编写，而不用担心破坏任何现有功能或降低用户体验。我们可以在另一个团队构建新UI的同时，仍然维护当前UI。
- en: When the next-generation UI is launched, we can safely decommission the old
    UI module. This reduces a lot of dependencies and risks of releasing software.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当下一代 UI 启动时，我们可以安全地退役旧 UI 模块。这减少了大量的依赖关系和软件发布的风险。
- en: On the other hand, it is not as usual to reuse the View and the Controller.
    As described in the previous diagram, the View depends on the Model, and the Controller
    depends on both the View and the Model. Reusing either of them brings the Model
    as the transitive dependency, locking down the Model to be used. Additionally,
    the Controller is usually tightly coupled with the View, making very little room
    for reuse.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，重用视图和控制器并不常见。如前一个图所示，视图依赖于模型，控制器依赖于视图和模型。重用任何一个都会将模型作为传递依赖项，锁定要使用的模型。此外，控制器通常与视图紧密耦合，几乎没有重用的空间。
- en: A real-life example of MVC
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVC 的实际示例
- en: We are going to apply MVC in building a frontend application for households
    to draft a contract for the exchange of service (the “contract”) with their neighbors.
    We will use Android Studio and the Android **Software Development** **Kit** (**SDK**).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用 MVC 架构来构建一个面向家庭的、用于与服务邻居交换服务（即“合同”）的前端应用程序。我们将使用 Android Studio 和 Android
    **软件开发** **工具包**（**SDK**）。
- en: 'The draft contract should contain basic information, such as each household’s
    name and the services to be exchanged. The household uses a mobile application
    to create a draft contract record. The application as the View has only two screens,
    as shown here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 草稿合同应包含基本信息，例如每个家庭的名称和要交换的服务。家庭使用移动应用程序创建草稿合同记录。作为视图的应用程序只有两个屏幕，如下所示：
- en: '![Figure 5.2 – Sample mobile application for drafting a contract](img/B21737_05_2.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 草拟合同的示例移动应用程序](img/B21737_05_2.jpg)'
- en: Figure 5.2 – Sample mobile application for drafting a contract
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 草拟合同的示例移动应用程序
- en: The first screen allows the household to enter its name and the service it provides.
    In this case, it is the Smith household that provides a cleaning service. On the
    other hand, the household enters the neighbor’s name and service in exchange.
    Specifically, here, it is the Lee household that provides a plumbing service.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个屏幕允许家庭输入其名称和提供的服务。在这种情况下，是史密斯家庭提供清洁服务。另一方面，家庭输入邻居的名称和交换的服务。具体来说，这里是由李家庭提供管道服务。
- en: 'The layout of the screen is defined by XML files as resources under the `/app/src/main/res/layout`
    project folder. For instance, the text field of **Your household** is declared
    as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕布局由位于 `/app/src/main/res/layout` 项目文件夹下的 XML 文件作为资源定义。例如，**您的家庭** 文本字段声明如下：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The XML block defines the View as an `EditText` component with an assigned ID,
    alignments, and dimensions. Copies (that is, display text) shown in the UI can
    be defined in a separate file and bound here using identifiers. This separates
    the concerns of copywriting and visual layouts.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: XML 块定义了视图为一个具有分配 ID、对齐方式和尺寸的 `EditText` 组件。在 UI 中显示的副本（即显示文本）可以在单独的文件中定义，并使用标识符绑定到这里。这分离了文案编写和视觉布局的关注点。
- en: 'View components in XML layouts can be bound to data sources in a declarative
    manner, using the Android Jetpack library. When the data changes in the Model,
    the View updates automatically without requiring manual updates in the code. This
    mechanism creates a more dynamic and responsive UI. The data binding can be expressed
    in the following XML:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 XML 布局中的视图组件可以声明性地绑定到数据源，使用 Android Jetpack 库。当模型中的数据发生变化时，视图会自动更新，无需在代码中进行手动更新。这种机制创建了一个更动态和响应式的用户界面。数据绑定可以表示如下
    XML：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With the data defined, the View can be bound to the Model. In the following
    example, `TextView` displays the name of `Household`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 数据定义后，视图可以绑定到模型。在以下示例中，`TextView` 显示 `Household` 的名称：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When the **SUBMIT** button is clicked, the application navigates to the confirmation
    screen. On the screen, it acknowledges that the draft contract has been submitted,
    and the contract of exchanged service is shown to the user.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击 **提交** 按钮时，应用程序导航到确认屏幕。在屏幕上，它确认草稿合同已提交，并显示交换服务的合同给用户。
- en: 'The Model should have two data classes. `HouseholdInput` captures the name
    and service provided by a household, and `DraftContractInput` has two `HouseholdInput`
    objects to form a contract. The two data classes are shown here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 模型应该有两个数据类。`HouseholdInput` 捕获家庭的名字和提供的服务，而 `DraftContractInput` 包含两个 `HouseholdInput`
    对象以形成一个合同。这两个数据类如下所示：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There is also a sample repository class, `ContractRepository`, for handling
    the submission of draft contracts. The repository class is shown here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个用于处理草稿合同提交的示例仓库类，`ContractRepository`。仓库类如下所示：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The current implementation of the repository does not do anything but can be
    enhanced to validate and persist draft contracts.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当前仓库的实现并没有做任何事情，但可以增强以验证和持久化草稿合同。
- en: 'The `Controller` interface in the MVC pattern is the one that coordinates between
    the View and the Model. In this example, an interface is defined for what the
    Controller can do:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: MVC模式中的`Controller`接口是协调View和模型之间的接口。在这个例子中，定义了一个接口来描述Controller可以做什么：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `MainActivity` class implements the `Controller` interface and is a subclass
    of `AppCompatActivity` from the Android SDK. It sets up the content of the View,
    controls the screen navigation, and connects with the Model:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainActivity`类实现了`Controller`接口，并且是Android SDK中的`AppCompatActivity`的子类。它设置View的内容，控制屏幕导航，并与模型连接：'
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Up to this part of the `MainActivity` class, it creates a `ContractRepository`
    object from the Model. It also creates a `ContractDraftFragment` screen as the
    first application screen, as shown on the left in *Figure 5**.2*. The `submitContract`
    function from the `Controller` interface invokes the function in the Model to
    submit the draft contract:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 到`MainActivity`类的这部分，它从模型中创建了一个`ContractRepository`对象。它还创建了一个`ContractDraftFragment`屏幕作为第一个应用程序屏幕，如*图5.2*中左侧所示。`Controller`接口中的`submitContract`函数调用模型中的函数以提交草稿合同：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Before the Controller navigates the View to the confirmation screen, it creates
    a `Bundle` object that contains the data submitted. The data is passed to `ConfirmationFragment`,
    which is the screen shown on the right in *Figure 5**.2*. The `ContractDraftFragment`
    sends user actions to the Controller for draft contract submission. This is implemented
    in the `onCreateView` function of the `ContractDraftFragment` class:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在Controller将View导航到确认屏幕之前，它创建一个包含提交数据的`Bundle`对象。数据传递给`ConfirmationFragment`，这是*图5.2*中右侧显示的屏幕。`ContractDraftFragment`将用户操作发送到Controller以提交草稿合同。这是在`ContractDraftFragment`类的`onCreateView`函数中实现的：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After the View is inflated, a click listener can be set to the `EditText` components
    are then extracted:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在View被填充之后，可以设置一个点击监听器到`EditText`组件，然后提取这些组件：
- en: Basic elements in the Android SDK
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Android SDK中的基本元素
- en: The Android SDK provides a comprehensive set of tools and components for building
    Android applications. There are a few key elements that are used throughout this
    chapter. An Activity is a single screen with a UI, acting as an entry point for
    user interaction with the application. Fragments are modular sections of an Activity,
    and they can be reused across multiple Activities. Views are the basic building
    blocks for UIs, such as buttons, text fields, and images. Layouts are the declarative
    definition of the UI in XML format, which specifies how Views are arranged on
    the screen.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Android SDK提供了一套全面的工具和组件，用于构建Android应用程序。本章中使用了几个关键元素。Activity是一个带有UI的单个屏幕，作为用户与应用程序交互的入口点。Fragment是Activity的模块化部分，它们可以在多个Activity之间重用。View是UI的基本构建块，例如按钮、文本字段和图像。Layout是以XML格式声明的UI定义，它指定了View在屏幕上的排列方式。
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A `DraftContractInput` object from the Model is created from the extracted values
    in the `EditText` components. The `DraftContractInput` object is then submitted
    to the `ContractRepository` class for further processing.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从`EditText`组件中提取的值创建了一个来自模型的`DraftContractInput`对象。然后，将`DraftContractInput`对象提交给`ContractRepository`类以进行进一步处理。
- en: 'Finally, `ContractDraftFragment` retrieves the `Bundle` object passed from
    the previous screen. The View components are then set with the data from the `Bundle`
    object to display a confirmation screen with details of the draft contract:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`ContractDraftFragment`检索从上一屏幕传递过来的`Bundle`对象。然后，使用`Bundle`对象中的数据设置View组件，以显示包含草稿合同详细信息的确认屏幕：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, users first see the UI and fill in the text fields. Then, the
    users click the **SUBMIT** button. This user action invokes the Controller to
    update the View by navigating to a confirmation screen. The Controller also updates
    the Model by submitting a draft contract object to the repository. At the end,
    users see the confirmation screen.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，用户首先看到UI并填写文本字段。然后，用户点击**提交**按钮。这个用户操作调用Controller通过导航到确认屏幕来更新View。Controller还通过将草稿合同对象提交到仓库来更新模型。最后，用户看到确认屏幕。
- en: It is worth pointing out that the code in the Model focuses merely on the business
    data and logic, and the View is solely responsible for rendering the UI. The Controller
    does all the coordination between the View and the Model, and this is how SoC
    is achieved in the MVC pattern.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，模型（Model）中的代码仅关注业务数据和逻辑，而视图（View）则完全负责渲染用户界面。控制器（Controller）负责视图和模型之间的所有协调，这就是
    MVC 模式中如何实现 SoC（分离关注点）。
- en: Coming next, we are moving on to MVP, an architecture pattern that can be seen
    as evolving from MVC.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将转向 MVP，这是一种可以看作是从 MVC 演变而来的架构模式。
- en: MVP
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVP
- en: MVP can be considered a pattern evolving from the MVC pattern. MVP originated
    in the 1990s as a response to the limitations and challenges faced when applying
    MVC to desktop and web application development.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: MVP 可以被视为从 MVC 模式演变而来的一个模式。MVP 诞生于 20 世纪 90 年代，作为对将 MVC 应用于桌面和 Web 应用程序开发时遇到的局限性和挑战的回应。
- en: MVP is built upon the concepts of MVC. The View and the Model concepts are shared
    between the two patterns, but interactions between the View and the Model have
    significantly changed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: MVP 建立在 MVC 的概念之上。视图和模型的概念在这两种模式之间是共享的，但视图和模型之间的交互方式发生了显著变化。
- en: The major limitation of MVC is the tight coupling between the View and the Controller.
    It results in a limited ability to test the View and the Controller independently.
    Also, when the View is complex and has a lot of presentation logic, it becomes
    difficult to test and maintain.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 的主要局限性在于视图（View）和控制器（Controller）之间的紧密耦合。这导致独立测试视图和控制器的能力有限。此外，当视图复杂且包含大量展示逻辑时，测试和维护变得困难。
- en: In addition, any variation or extension to the current View inevitably requires
    a proportional change in the Controller as the Controller needs to understand
    all the variations and extensions that exist.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对当前视图的任何变化或扩展都不可避免地需要控制器成比例的变化，因为控制器需要理解所有存在的变体和扩展。
- en: 'MVP promotes an even more decoupled relationship between the View and the Model
    by introducing the Presenter. The following diagram demonstrates the new relationships
    among the View, the Model, and the Presenter:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: MVP 通过引入演示者（Presenter）来促进视图和模型之间更加解耦的关系。以下图表展示了视图、模型和演示者之间新的关系：
- en: '![Figure 5.3 – The MVP pattern](img/B21737_05_3.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – MVP 模式](img/B21737_05_3.jpg)'
- en: Figure 5.3 – The MVP pattern
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – MVP 模式
- en: As you can see, the user sees the View and interacts with the UI. The View then
    sends the user action to the Presenter. The Presenter updates the data in the
    Model. The Model calls back the Presenter when the data is updated. The Presenter
    then updates the View according to the data changed in the Model. Eventually,
    the user sees an updated UI based on the previous interaction.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，用户看到视图并与用户界面交互。然后视图将用户操作发送给演示者。演示者更新模型中的数据。当数据更新时，模型会回调演示者。然后演示者根据模型中变化的数据更新视图。最终，用户根据之前的交互看到更新后的用户界面。
- en: Differences from MVC
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 MVC 的区别
- en: The first noticeable difference between MVP and MVC is that the Model and the
    View do not interact. All messages come through the Presenter, and the Presenter
    depends on both the View and the Model. The View is self-contained and does not
    depend on either the Model or the Presenter.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: MVP 与 MVC 之间的第一个明显区别是模型和视图不直接交互。所有消息都通过演示者（Presenter）传递，演示者依赖于视图和模型。视图是自包含的，不依赖于模型或演示者。
- en: The second difference is that the View can be completely passive in the sense
    that it is only responsible for rendering the UI as a response to the Presenter’s
    request to update the View. However, the *Passive View* is considered an option
    for MVP. Passive View is a variant of MVP in which the View makes no decisions
    and contains no business logic.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个区别是视图可以完全被动，即它只负责根据演示者请求更新视图来渲染用户界面。然而，*被动视图*被认为是 MVP 的一个选项。被动视图是 MVP 的一个变体，其中视图不做出任何决策，也不包含任何业务逻辑。
- en: If not passive, the View can contain certain presentation logic that does not
    affect the Model or the Presenter. Simple field validation such as data type and
    length is a typical example.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是被动视图，视图可以包含某些不影响模型或演示者的展示逻辑。例如，简单的字段验证，如数据类型和长度。
- en: The third difference is that MVP typically enforces explicit communication with
    the View and the Model. The View informs the Presenter of user actions, and the
    Presenter then interprets and acts upon them. Defining explicit communication
    helps engineers understand and reason about the application’s behaviors, as a
    result making the application easier to maintain.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个区别是 MVP 通常强制执行与视图和模型的显式通信。视图通知 Presenter 用户操作，然后 Presenter 解释并采取行动。定义显式通信有助于工程师理解和推理应用程序的行为，从而使得应用程序更容易维护。
- en: The benefits of MVP
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVP 的好处
- en: The further SoC among the View, the Model, and the Presenter brings about a
    few benefits on top of the MVC pattern.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图、模型和 Presenter 之间进一步实现 SoC 带来了 MVC 模式之上的几个好处。
- en: The View under MVP can be independently tested, without the involvement of the
    Presenter. The explicit incoming messages to the View can be used as the input
    of test cases, and the UI is used for verification. On the other hand, user interactions
    can be the input of test cases, and the explicit outgoing message from the View
    is used for verification.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MVP 中，视图可以独立测试，无需 Presenter 的参与。显式传入视图的消息可以用作测试用例的输入，UI 用于验证。另一方面，用户交互可以是测试用例的输入，视图显式传出的消息用于验证。
- en: With MVP, it is now possible to have variants of View without any change in
    the Presenter. The variant of the View interprets messages from the Presenter
    differently. The variant might produce the same message to the Presenter from
    a slightly different user interaction. In this way, there is no need to change
    the Presenter to support a variant of the View. Nowadays, there are so many variations
    of UIs on different platforms, such as iOS applications, Android applications,
    web applications, and custom devices such as televisions. It is possible for these
    different Views to share the same Model and same Presenter while still giving
    users a unique experience that is tailored to the platform.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 MVP，现在可以拥有没有改变 Presenter 的视图变体。视图变体以不同的方式解释来自 Presenter 的消息。变体可能从稍微不同的用户交互中产生相同的消息给
    Presenter。这样，就无需更改 Presenter 以支持视图的变体。如今，在 iOS 应用程序、Android 应用程序、Web 应用程序以及电视等定制设备等不同平台上，有如此多的
    UI 变体。这些不同的视图可以共享相同的模型和相同的 Presenter，同时仍然为用户提供针对平台的独特体验。
- en: MVP standardizes messages explicitly sent to and received by the Presenter.
    It ensures there is no confusion and no room for deviation by different frameworks
    or implementations. It brings clarity to engineers and makes the application easy
    to understand.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: MVP 明确标准化了发送给和接收由 Presenter 的消息。它确保没有混淆，也没有不同框架或实现偏差的空间。它为工程师带来清晰，使应用程序易于理解。
- en: A real-life example of MVP
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVP 的真实生活示例
- en: We continue to use the same example we used for the MVC pattern. We are using
    the same real-life example used in MVP, where a household can draft a contract
    of exchanged services (the “contract”) with another household.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续使用之前用于 MVC 模式的相同示例。我们使用 MVP 中使用的相同真实生活示例，其中一家家庭可以与另一家家庭起草一项交换服务的合同（即“合同”）。
- en: Evolving from the MVC pattern, the View and the Model can be kept the same in
    MVP, but the ways of communication will change.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 从 MVC 模式演变而来，在 MVP 中，视图和模型可以保持不变，但通信方式将改变。
- en: 'The `Controller` interface is renamed as `Presenter`, even though the declared
    function has not changed:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管声明的函数没有改变，但 `Controller` 接口被重命名为 `Presenter`：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The Presenter has two-way communication with both the View and the Model. So,
    the first change would be to support a callback when the Model has changed:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Presenter 与视图和模型都有双向通信。因此，第一个变化是支持当模型发生变化时的回调：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `DraftContractSubmittedListener` type alias acts as a callback interface
    when the draft contract is submitted to the Model. The `ContractRepository` class
    is enhanced to keep a `DraftContractSubmittedListener` object and will invoke
    the callback when a draft contract is submitted. The implementation of the repository
    class is shown here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`DraftContractSubmittedListener` 类型别名在草案合同提交给模型时充当回调接口。`ContractRepository`
    类被增强以保持一个 `DraftContractSubmittedListener` 对象，并在提交草案合同时调用回调。仓库类的实现如下所示：'
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The callback function, when the model is updated, can be used to navigate to
    the confirmation screen with the submitted draft contract. This is the updated
    `submitContract` function in the `MainActivity` class:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当模型更新时，回调函数可用于导航到带有提交的草案合同的确认屏幕。这是 `MainActivity` 类中更新的 `submitContract` 函数：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'On the other hand, the `ConfirmationFragment` class is updated. The screen
    takes the values directly from the submitted draft contract that was just set
    from `DraftContractSubmittedListener` to `MainActivity`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`ConfirmationFragment` 类被更新。屏幕直接从刚刚从 `DraftContractSubmittedListener` 设置到
    `MainActivity` 的提交草稿合同中获取值：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The major difference between this MVP example and the MVC example is that the
    loading of the confirmation screen is triggered by the change in the Model, with
    the use of a callback function. In this way, all communications between the View
    and the Model are through the Presenter. It is now possible to test the View logic
    in the `ConfirmationFragment` class, the Model logic in the `ContractRepository`
    class, and the Presenter logic in the `MainActivity` class independently.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与 MVC 示例相比，这个 MVP 示例的主要区别在于确认屏幕的加载是由模型的变化触发的，使用了回调函数。这样，视图和模型之间的所有通信都通过演示者（Presenter）进行。现在可以独立测试
    `ConfirmationFragment` 类中的视图逻辑、`ContractRepository` 类中的模型逻辑和 `MainActivity` 类中的演示者逻辑。
- en: After MVP, we are going to delve into the MVVM pattern, which also aims to solve
    the same problem as MVC and MVP.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MVP 之后，我们将深入探讨 MVVM 模式，该模式也旨在解决 MVC 和 MVP 相同的问题。
- en: MVVM
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVVM
- en: 'MVVM was first introduced by John Gossman at Microsoft in 2005\. It was created
    for UI development using the **Windows Presentation Foundation** (**WPF**) framework.
    Later it was adopted by other frameworks, such as the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM 首次由微软的 John Gossman 在 2005 年引入。它是为了使用 **Windows Presentation Foundation**
    （**WPF**） 框架进行 UI 开发而创建的。后来它被其他框架采用，如下所示：
- en: React
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React
- en: Xamarin
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xamarin
- en: AngularJS
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AngularJS
- en: MVVM fundamentally retains the concepts of the Model and the View from the older
    models, MVC and MVP. However, it uses the View Model as an intermediary between
    the View and the Model. There is also a substantial preference for using declarative
    data binding to coding. The data-binding feature of MVVM supports the automatic
    synchronization between the View and the View Model.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM 基本上保留了从较老的模型 MVC 和 MVP 中继承的模型和视图的概念。然而，它使用视图模型作为视图和模型之间的中介。还有大量偏好使用声明性数据绑定而不是编码。MVVM
    的数据绑定功能支持视图和视图模型之间的自动同步。
- en: The View Model
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图模型
- en: 'The View Model exposes data and commands that the view can bind to. The data
    binding allows an automatic two-way synchronization between the View and the View
    Model. In other words, updates from the View Model are reflected in the View automatically,
    and the View Model can react to user actions in the View. This reduces boilerplate
    code to manually synchronize the data between the View and the View Model and
    the code to update the View. The following diagram will throw more light on interactions
    among the View, the Model, and the View Model:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 视图模型公开视图可以绑定到其上的数据和命令。数据绑定允许视图和视图模型之间自动双向同步。换句话说，视图模型中的更新会自动反映在视图中，视图模型也可以对视图中的用户操作做出反应。这减少了手动在视图和视图模型之间同步数据以及更新视图的样板代码。以下图表将更详细地说明视图、模型和视图模型之间的交互：
- en: '![Figure 5.4 – The MVVM pattern](img/B21737_05_4.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – MVVM 模式](img/B21737_05_4.jpg)'
- en: Figure 5.4 – The MVVM pattern
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – MVVM 模式
- en: As you can see here, the View Model reads data from the Model, transforms it
    for presentation, and provides properties and functions for the View. The View
    receives the properties and function callback to render the UI.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，视图模型从模型读取数据，将其转换为展示格式，并为视图提供属性和函数。视图接收属性和函数回调以渲染用户界面。
- en: 'A use case in which a user interacts with the View and ends up seeing changes
    in the View is demonstrated in *Figure 5**.5*:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 5.5* 中演示了一个用户与视图交互并最终在视图中看到变化的用例：
- en: '![Figure 5.5 – User interacting and seeing changes in the View](img/B21737_05_5.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 用户与视图交互并看到视图中的变化](img/B21737_05_5.jpg)'
- en: Figure 5.5 – User interacting and seeing changes in the View
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 用户与视图交互并看到视图中的变化
- en: When a user interacts with the View, the user actions are propagated to the
    View Model. The View Model executes commands to respond to the user actions, which
    typically involve updating the data in the Model. Once the data is updated in
    the Model, the View Model receives the data update and transforms it for presentation.
    Finally, the View receives the View Model changes and renders the UI as a response
    to the user actions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户与视图交互时，用户操作会被传播到视图模型。视图模型执行命令以响应用户操作，这通常涉及更新模型中的数据。一旦模型中的数据被更新，视图模型就会接收到数据更新并将其转换为用于展示的形式。最后，视图接收到视图模型的变化并渲染
    UI 作为对用户操作的响应。
- en: The benefits of MVVM
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVVM 的好处
- en: MVVM separates the concerns of business logic even further from the presentation
    in the View. The View Model encapsulates presentation logic without needing to
    be concerned about how it is rendered visually. This implies the View Model can
    be tested in isolation, independent of specific details of the UI.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM 将业务逻辑的关注点进一步从视图的展示中分离出来。视图模型封装了展示逻辑，无需关心其视觉呈现方式。这意味着视图模型可以在隔离状态下进行测试，独立于
    UI 的具体细节。
- en: Properties and commands in the View Model can be shared while keeping the user
    experience consistent among multiple Views, such as web browsers, desktop applications,
    and mobile applications. Moreover, View changes can be made without updating the
    View Model. This promotes flexibility and extensibility to evolve the code base.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 视图模型中的属性和命令可以在保持多个视图（如网页浏览器、桌面应用程序和移动应用程序）之间用户体验一致性的同时共享。此外，可以在不更新视图模型的情况下对视图进行更改。这促进了代码库的灵活性和可扩展性。
- en: UI designers can better collaborate with frontend engineers. UI designers can
    focus on styling, layout, and visual components without the need to interfere
    with the business logic. This promotes working in parallel and improves productivity.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: UI 设计师可以更好地与前端工程师协作。UI 设计师可以专注于样式、布局和视觉组件，无需干扰业务逻辑。这促进了并行工作并提高了生产力。
- en: The automatic synchronization between the View and the View Model reduces boilerplate
    code to manually update the View when the View Model changes and vice versa.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 视图和视图模型之间的自动同步减少了手动更新视图的样板代码，反之亦然。
- en: A real-life example of MVVM
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVVM 的真实生活示例
- en: Continuing from the same example we used for the MVP pattern, the code base
    is going to evolve to the MVVM pattern. We are using the same real-life example
    from MVC and MVP, and the code base evolves from them using the Android SDK.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们之前用于 MVP 模式的示例继续，代码库将演变为 MVVM 模式。我们使用与 MVC 和 MVP 相同的真实生活示例，并使用 Android SDK
    从它们中演变代码库。
- en: 'The View Model is introduced and named `DraftContractViewModel` to store transitional
    data before it is ready to become a draft contact:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 视图模型被引入并命名为 `DraftContractViewModel`，用于在它准备好成为草稿联系人之前存储过渡数据：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `DraftContractViewModel` object is going to be shared among `Fragments`
    to keep building the data required for a draft contract. This is reflected in
    the mutable fields (known as `var` in Kotlin). Moreover, the View Model acts as
    a bridge between the View and the Model. The `toModel` function converts a View
    Model `DraftContractViewModel` object to the Model `DraftContractInput` object:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`DraftContractViewModel` 对象将在 `Fragments` 之间共享，以继续构建草稿合同所需的数据。这反映在可变字段（在 Kotlin
    中称为 `var`）。此外，视图模型充当视图和模型之间的桥梁。`toModel` 函数将视图模型 `DraftContractViewModel` 对象转换为模型
    `DraftContractInput` 对象：'
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note that data integrity logic has been applied to the function to ensure that
    the Model object can only be created when all fields are present. This conversion
    logic can also be tested independently, as shown here:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，已经应用了数据完整性逻辑到该函数中，以确保模型对象只能在所有字段都存在的情况下创建。这种转换逻辑也可以独立测试，如下所示：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This unit test is run by the `null`. The second test creates a View Model object
    with all fields not `null`, and therefore it can be converted to a Model object.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单元测试由 `null` 运行。第二个测试创建了一个所有字段均非 `null` 的视图模型对象，因此它可以被转换为模型对象。
- en: 'The data between the View and the View Model is bound and synchronized automatically,
    using the following custom function:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 视图和视图模型之间的数据绑定和同步是自动进行的，使用以下自定义函数：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Initially, when the `EditText` View component is created, the default value
    is set to the View Model `DraftContractViewModel` object. Subsequently, any text
    change will trigger a callback to update the View Model. The data-binding process
    is kicked off in the `onCreate` function of the first screen, represented by the
    `ContractDraftFragment` class:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，当创建`EditText`视图组件时，默认值设置为视图模型`DraftContractViewModel`对象。随后，任何文本更改都会触发一个回调来更新视图模型。数据绑定过程在第一个屏幕的`onCreate`函数中启动，由`ContractDraftFragment`类表示：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The View Model is looked up here, and the owner is set to be the activity so
    that it can be shared with the next screen. Then, a callback is registered upon
    clicking the `toModel` function is used to convert the View Model to the Model
    object:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 视图模型在这里查找，并将所有者设置为活动，以便它可以与下一个屏幕共享。然后，在点击`toModel`函数时注册一个回调，用于将视图模型转换为模型对象：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following code then binds the `EditText` View components with the View
    Model, field by field, using the `bind` function just mentioned previously:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用前面提到的`bind`函数，逐字段将`EditText`视图组件与视图模型绑定：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The confirmation screen gets the submitted data from the View Model directly:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 确认屏幕直接从视图模型获取提交的数据：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The View Model is looked up here with the activity as the owner shared with
    the first screen. Then, the View gets the data from the same View Model object.
    There are now two screens sharing the same View Model object, but the Views are
    rendered differently:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 视图模型在这里通过活动作为所有者与第一个屏幕共享来查找。然后，视图从相同的视图模型对象获取数据。现在有两个屏幕共享相同的视图模型对象，但视图的渲染方式不同：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There are a few more potential features that can be added to this example. As
    the user types in the text fields, the callback function to synchronize the View
    Model keeps on being invoked. This makes it possible to provide real-time validation
    feedback to the user.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例中还可以添加一些其他潜在功能。当用户在文本字段中输入文本时，同步视图模型的回调函数会不断被调用。这使得向用户提供实时验证反馈成为可能。
- en: As the View Model is shared among multiple screens in the same activity, the
    View can be evolved into a series of screens as a wizard-style multi-step activity.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于视图模型在同一个活动中的多个屏幕之间共享，视图可以演变为一组屏幕，作为向导式多步骤活动。
- en: Also, if the Model is shared between two households in two copies of the application,
    the data of the draft contract can be synchronized in real time using a certain
    protocol such as a **peer-to-peer** (**P2P**) network. When the Model is updated
    externally from the network, the callback function for changes in the Model can
    populate the View Model and then update the View in real time.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果模型在两个应用程序的两个副本之间共享，可以使用某种协议（如**对等网络**（**P2P**））实时同步草拟合同的实时数据。当模型从网络外部更新时，模型更改的回调函数可以填充视图模型，然后实时更新视图。
- en: Comparing MVC, MVP, and MVVM
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较MVC、MVP和MVVM
- en: The MVC, MVP, and MVVM patterns share the same concepts of the View and the
    Model. However, their relationships and ways of communication are different.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: MVC、MVP和MVVM模式共享视图和模型的概念。然而，它们的关系和通信方式不同。
- en: In MVC, one Controller has access to multiple Views and usually calls the functions
    of View directly. The View and the Model are tightly coupled. User inputs are
    handled by the Controller. Unit testing is limited to the Model on business logic
    only. Modifying the View or the Model would require changing the Controller as
    well. It is suitable for small projects only because the code footprint is the
    smallest.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在MVC中，一个控制器可以访问多个视图，并且通常直接调用视图的功能。视图和模型紧密耦合。用户输入由控制器处理。单元测试仅限于业务逻辑的模型。修改视图或模型需要更改控制器。它仅适用于小型项目，因为代码占用空间最小。
- en: In MVP, one Presenter manages at least one View. The View and the Model have
    no knowledge about the Presenter, but they communicate with the Presenter using
    callback functions. Also, the View and the Model are decoupled. User inputs are
    handled by the View, and then the View invokes the callback function provided
    by the Presenter. Unit testing can be done in the Model on business logic. The
    behaviors of callback functions from the Model and the View can also be tested.
    Modifying the View or the Model may not need to modify the Presenter if the callback
    function stays the same. It is suitable for small to more complex projects that
    require better testability of the Model and the View.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MVP 中，一个演示者管理至少一个视图。视图和模型不知道演示者，但它们通过回调函数与演示者通信。此外，视图和模型是解耦的。用户输入由视图处理，然后视图调用演示者提供的回调函数。单元测试可以在模型上的业务逻辑中进行。模型和视图的回调函数的行为也可以进行测试。如果回调函数保持不变，修改视图或模型可能不需要修改演示者。它适用于从小型到更复杂的项目，这些项目需要更好的模型和视图的可测试性。
- en: In MVVM, one View Model maps to one or many Views. The View and the Model are
    also decoupled, but even more separation of business logic from the View and communications
    are more event-driven and supported by the underlying frameworks. User inputs
    are handled by the View, and then the View invokes the callback function provided
    by the View Model. Unit testing can be done in the Model on business logic. The
    behaviors of callback functions from the Model, the View, and the View Model can
    also be tested.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MVVM 中，一个 ViewModel 映射到一个或多个视图。视图和模型也是解耦的，但业务逻辑与视图的分离更加彻底，通信更加事件驱动，并得到底层框架的支持。用户输入由视图处理，然后视图调用
    ViewModel 提供的回调函数。单元测试可以在模型上的业务逻辑中进行。模型、视图和 ViewModel 的回调函数的行为也可以进行测试。
- en: The concerns are easier to separate, and the functions can be small enough to
    conform to the **single-responsibility principle** (**SRP**). Modifying the View
    or the Model may not need to modify the View Model if the data binding has not
    changed. It is suitable for large and complex projects that may be deployed to
    multiple platforms and, therefore, multiple variants of the View and requires
    better isolation between the View and the Model.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 关注点更容易分离，功能可以足够小，以符合 **单一职责原则** (**SRP**)。如果数据绑定没有改变，修改视图或模型可能不需要修改 ViewModel。它适用于可能部署到多个平台和因此需要更好的视图和模型之间隔离的大型和复杂项目。
- en: 'The comparison is summarized in the following table:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 比较总结在下表中：
- en: '| **MVC** | **MVP** | **MVVM** |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| **MVC** | **MVP** | **MVVM** |'
- en: '| View and Model tightly coupled. | View and Model are decoupled. | View and
    Model are decoupled. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 视图和模型紧密耦合。 | 视图和模型解耦。 | 视图和模型解耦。 |'
- en: '| Controller depends on View and Model. | One Presenter manages at least one
    View via callback functions. | One VIewmodel manages at least one View via callback
    functions. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 控制器依赖于视图和模型。 | 一个演示者通过回调函数管理至少一个视图。 | 一个 ViewModel 通过回调函数管理至少一个视图。 |'
- en: '| Controller handles user input. | View handles user input. | View handles
    user input. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 控制器处理用户输入。 | 视图处理用户输入。 | 视图处理用户输入。 |'
- en: '| Unit testing on Model only. | Unit testing on Model and View. | Unit testing
    on Model, View and Viewmodel. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 仅在模型上进行单元测试。 | 在模型和视图上进行单元测试。 | 在模型、视图和 ViewModel 上进行单元测试。 |'
- en: Table 5.1 – Comparison of MVC, MVP, and MVVM
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.1 – MVC、MVP 和 MVVM 的比较
- en: Beyond MVC, MVP, and MVVM
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 除此之外 MVC、MVP 和 MVVM
- en: 'More architectural patterns have evolved from the three patterns we discussed
    previously. The in-depth comparison of these patterns is beyond this chapter,
    but they are worth mentioning:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 更多的架构模式已经从我们之前讨论的三个模式中演变而来。这些模式的深入比较超出了本章的范围，但它们值得提及：
- en: '**Model-View-Intent (MVI)**: MVI emerged as a pattern influenced by MVC, MVP,
    and MVVM around the 2010s in the Android community. MVI has a unique focus on
    a unidirectional data flow to streamline state management. It also adopts reactive
    programming paradigms to asynchronously manage the unidirectional data flow, using
    libraries such as RxJava and RxJS. The interactions among them are shown in *Figure
    5**.6*:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型-视图-意图 (MVI)**: MVI 在 2010 年左右作为受 MVC、MVP 和 MVVM 影响的模式在 Android 社区中兴起。MVI
    对单向数据流有独特的关注，以简化状态管理。它还采用响应式编程范式，通过 RxJava 和 RxJS 等库异步管理单向数据流。它们之间的交互在 *图 5.6*
    中展示：'
- en: '![Figure 5.6 – MVI interaction](img/B21737_05_6.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – MVI 交互](img/B21737_05_6.jpg)'
- en: Figure 5.6 – MVI interaction
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – MVI 交互
- en: '**Atomic design**: Introduced by Brad Frost in his book *Atomic Design* in
    2013, atomic design breaks down the UI into five levels:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子设计**：由布拉德·弗罗斯特在2013年他的书《原子设计》中提出，原子设计将 UI 分解为五个级别：'
- en: '**Atoms**: Elemental building blocks such as text fields'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子**：如文本字段等基本构建块'
- en: '**Molecules**: Functional organization of atoms such as search bars'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分子**：如搜索栏等原子的功能组织'
- en: '**Organisms**: Sectional organization of molecules such as navigation panels'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有机体**：如导航面板等分子的部分组织'
- en: '**Templates**: Visual layout and organization of organisms that form a page'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板**：构成页面的有机体的视觉布局和组织'
- en: '**Pages**: Business-aware and specific instances of pages with real content'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**页面**：具有真实内容的业务感知和特定页面实例'
- en: '**Component-based**: Focus on separating functionalities into self-contained
    and reusable components. Each component encapsulates the behaviors, hides its
    lower-level details, and only exposes higher-level functions via interfaces. It
    goes together with design systems that contain a library of reusable components
    with well-defined behaviors. It aims at providing a consistent user experience
    and optimizing productivity during development. Each component is developed, tested,
    and deployed independently, which makes it easier to update applications.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于组件**：专注于将功能分离成自包含和可重用的组件。每个组件封装了行为，隐藏了其底层细节，并通过接口仅暴露高级功能。它与包含具有良好定义行为的可重用组件库的设计系统相结合。它的目的是在开发过程中提供一致的用户体验并优化生产力。每个组件都是独立开发、测试和部署的，这使得更新应用程序变得更容易。'
- en: '**Server-side rendering (SSR)**: SSR is primarily used in web development but
    can be extended to mobile and desktop applications. The content of a page is generated
    on the server instead of in the browser or on clients’ devices. It aims at improving
    performance and response time by reducing loads in the browser or on clients’
    devices, which come in various computation powers. Optimization of data fetching
    can be done on the server side, and it reduces unnecessary traffic between client
    and server. It does, however, increase the server load for processing.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器端渲染（SSR）**：SSR 主要用于网页开发，但可以扩展到移动和桌面应用程序。页面的内容是在服务器上生成的，而不是在浏览器或客户端设备上。它的目的是通过减少浏览器或客户端设备上的负载来提高性能和响应时间，这些设备具有不同的计算能力。数据获取的优化可以在服务器端进行，从而减少客户端和服务器之间的不必要流量。然而，这确实增加了服务器处理负载。'
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We began the chapter with the MVC pattern. We explored the Model, the View,
    and how the Controller interacts with them. We also illustrated the concepts with
    a real-life example of the drafting of a contract for the exchange of services
    among households. The UI of the drafting and confirmation screens was used in
    the example, with the Controller driving the navigation and submitting the draft
    contract.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以 MVC 模式开始本章。我们探讨了模型、视图以及控制器如何与它们交互。我们还用一个现实生活中的例子来说明这些概念，即家庭之间服务交换合同的起草。示例中使用了起草和确认屏幕的
    UI，控制器驱动导航并提交草案合同。
- en: Then, we bought in the MVP pattern by evolving from MVC. The Presenter was introduced
    to replace the Controller, and callback functions from the Model were added to
    the pattern to further isolate the View and the Model. Then, we came back to the
    same real-life example, and the original code base of MVC was modified to become
    MVP.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过从 MVC 演化引入了 MVP 模式。引入了演示者来替代控制器，并将从模型中添加的回调函数添加到模式中，以进一步隔离视图和模型。然后，我们回到了同一个现实生活中的例子，并将
    MVC 的原始代码库修改为 MVP。
- en: Afterward, we introduced the MVVM pattern by evolving from MVP. The View Model
    was added as an intermediary between the View and the Model. Data binding was
    supported to automatically synchronize data between the View and the View Model.
    We reused the same real-life example and refactored it to be an MVVM pattern.
    A custom bind function was introduced to bind values in View components to fields
    in the View Model. The View Model could be converted to the Model object upon
    submission. We discussed the potential enhancement provided by the MVVM pattern,
    such as real-time validation, distributed processing of the View, and multiple
    variants of the View.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们通过从MVP演变而来介绍了MVVM模式。在视图和模型之间添加了视图模型作为中介。支持数据绑定以自动同步视图和视图模型之间的数据。我们重用了相同的真实生活示例并将其重构为MVVM模式。引入了一个自定义的绑定函数，用于将视图组件中的值绑定到视图模型中的字段。提交时，视图模型可以转换为模型对象。我们讨论了MVVM模式提供的潜在增强，例如实时验证、视图的分布式处理和视图的多种变体。
- en: We compared the three patterns from multiple perspectives. We discussed the
    relationship between the View and the Model and how coupled they were in each
    pattern. The ways of communication among the three patterns were then compared,
    as well as the ease of unit testing. We looked at the chain of modifications needed
    in each pattern. In the end, we covered which pattern was suitable according to
    the scale of the project.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从多个角度比较了这三种模式。我们讨论了视图和模型之间的关系以及在每个模式中它们是如何耦合的。然后比较了三种模式之间的通信方式以及单元测试的简便性。我们考察了在每个模式中需要的修改链。最后，我们讨论了根据项目规模选择哪种模式更合适。
- en: Finally, we introduced a few architectural patterns in the frontend landscape
    that evolved from MVC, MVP, and MVVM.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了前端领域中从MVC、MVP和MVVM演变而来的几种架构模式。
- en: 'In the next chapter, we will look into another set of architectural patterns
    and compare them: monoliths, micro-frontend, microservices, nanoservices, and
    serverless. They are applied in either frontend or backend systems, but they do
    share similar fundamental concepts that are worth a discussion.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨另一组架构模式，并进行比较：单体架构、微前端、微服务、纳米服务和无服务器架构。它们应用于前端或后端系统，但它们确实共享一些值得讨论的相似的基本概念。
