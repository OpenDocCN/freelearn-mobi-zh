- en: Chapter 5. TV Set Constant Volume Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I don't watch TV much, but when I do, I usually completely relax and fall asleep.
    I know that TV is not meant for putting you to sleep, but it does this to me.
    Unfortunately, commercials are transmitted at a very high volume and they wake
    me up. How can I relax if commercials wake me up every five minutes?
  prefs: []
  type: TYPE_NORMAL
- en: Can you believe it? During one of my naps between two commercials, I came up
    with a solution based on iOS and Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: It's nothing complex. An iOS device listens to the TV set's audio, and when
    the audio level becomes higher than a preset threshold, the iOS device sends a
    message (via Bluetooth) to Arduino, which controls the TV set volume, emulating
    the traditional IR remote control. Exactly the same happens when the volume drops
    below another threshold. The final result is that the TV set volume is almost
    constant, independent of what is on the air. This helps me sleep longer!
  prefs: []
  type: TYPE_NORMAL
- en: The techniques that you are going to learn in this chapter are useful in many
    different ways. You can use an IR remote control for any purpose, or you can control
    many different devices, such as a CD/DVD player, a stereo set, Apple TV, a projector,
    and so on, directly from an Arduino and iOS device. As always, it is up to your
    imagination.
  prefs: []
  type: TYPE_NORMAL
- en: Constant Volume Controller requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our aim is to design an Arduino-based device, which can make the TV set's volume
    almost constant by emulating the traditional remote controller, and an iOS application,
    which monitors the TV and decides when to decrease or increase the TV set's volume.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most TV sets can be controlled by an IR remote controller, which sends signals
    to control the volume, change the channel, and control all the other TV set functions.
  prefs: []
  type: TYPE_NORMAL
- en: IR remote controllers use a carrier signal (usually at 38 KHz) that is easy
    to isolate from noise and disturbances.
  prefs: []
  type: TYPE_NORMAL
- en: The carrier signal is turned on and off by following different rules (encoding)
    in order to transmit the 0 and 1 digital values.
  prefs: []
  type: TYPE_NORMAL
- en: The IR receiver removes the carrier signal (with a low pass filter) and decodes
    the remaining signal by returning a clear sequence of 0 and 1.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The IR remote control theory**'
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about the IR remote control at [http://bit.ly/1UjhsIY](http://bit.ly/1UjhsIY).
  prefs: []
  type: TYPE_NORMAL
- en: Our circuit will emulate the IR remote controller by using an IR LED, which
    will send specific signals that can be interpreted by our TV set.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, we can receive an IR signal with a phototransistor and decode
    it into an understandable sequence of numbers, by designing a demodulator and
    a decoder.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, electronics is very simple; an IR receiver module (Vishay 4938) will
    manage the complexity of signal demodulation, noise cancellation, triggering,
    and decoding. It can be directly connected to Arduino, making everything very
    easy.
  prefs: []
  type: TYPE_NORMAL
- en: In the project in this chapter, we need an IR receiver to discover the coding
    rules that are used by our own IR remote controller (and the TV set).
  prefs: []
  type: TYPE_NORMAL
- en: Additional electronic components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this project, we need the following additional components:'
  prefs: []
  type: TYPE_NORMAL
- en: IR LED Vishay TSAL6100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IR Receiver module Vishay TSOP 4838
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resistor 100Ω
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resistor 680Ω
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Electrolytic capacitor 0.1μF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Electronic circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following picture shows the electrical diagram of the circuit that we need
    for the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Electronic circuit](img/image00207.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The IR receiver will be used only to capture the TV set's remote controller
    signals so that our circuit can emulate them.
  prefs: []
  type: TYPE_NORMAL
- en: However, an IR LED is constantly used to send commands to the TV set. The other
    two LEDs will show when Arduino increases or decreases the volume. They are optional
    and can be omitted.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, the Bluetooth device is used to receive commands from the iOS device.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Powering the IR LED in the current limits of Arduino**'
  prefs: []
  type: TYPE_NORMAL
- en: From the datasheet of the TSAL6100, we know that the forward voltage is 1.35V.
    The voltage drop along R1 is then *5-1.35 = 3.65V*, and the current provided by
    Arduino to power the LED is about *3.65/680=5.3 mA*. The maximum current that
    is allowed for each PIN is 40 mA (the recommended value is 20 mA). So, we are
    within the limits. In case your TV set is far from the LED, you may need to reduce
    the R1 resistor in order to get more current (and the IR light). Use a new value
    of R1 in the previous calculations to check whether you are within the Arduino
    limits. For more information about the Arduino PIN current, check out [http://bit.ly/1JosGac](http://bit.ly/1JosGac).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how to mount the circuit on a breadboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Electronic circuit](img/image00208.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Arduino code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The entire code of this project can be downloaded from [https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support).
  prefs: []
  type: TYPE_NORMAL
- en: To understand better the explanations in the following paragraphs, open the
    downloaded code while reading them.
  prefs: []
  type: TYPE_NORMAL
- en: In this project, we are going to use the IR remote library, which helps us code
    and decode IR signals.
  prefs: []
  type: TYPE_NORMAL
- en: 'The library can be downloaded from [http://bit.ly/1Isd8Ay](http://bit.ly/1Isd8Ay),
    and installed by using the following procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the release page of [http://bit.ly/1Isd8Ay](http://bit.ly/1Isd8Ay)
    in order to get the latest release and download the `IRremote.zip` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unzip the file whatever you like.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Finder** and then the `Applications` folder (*Shift* + *Control*
    + *A*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the Arduino application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on it and select **Show Package Contents**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the `Java` folder and then `libraries`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `IRremote` folder (unzipped in step 2) into the `libraries` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart Arduino if you have it running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this project, we need the following two Arduino programs:'
  prefs: []
  type: TYPE_NORMAL
- en: One is used to acquire the codes that your IR remote controller sends to increase
    and decrease the volume
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other is the main program that Arduino has to run to automatically control
    the TV set volume
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with the code that is used to acquire the IR remote controller codes.
  prefs: []
  type: TYPE_NORMAL
- en: Decoder setup code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will be referring to the downloaded `Decode.ino` program
    that is used to discover the codes that are used by your remote controller.
  prefs: []
  type: TYPE_NORMAL
- en: Since the setup code is quite simple, it doesn't require a detailed explanation;
    it just initializes the library to receive and decode messages.
  prefs: []
  type: TYPE_NORMAL
- en: Decoder main program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will be referring to the downloaded `Decode.ino` program;
    the main code receives signals from the TV remote controller and dumps the appropriate
    code, which will be included in the main program to emulate the remote controller
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the program is run, if you press any button on the remote controller,
    the console will show the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The second row is what we need. Please refer to the *Testing and tuning* section
    for a detailed description of how to use this data.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will take a look at the main code that will be running on Arduino all
    the time.
  prefs: []
  type: TYPE_NORMAL
- en: Setup code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will be referring to the `Arduino_VolumeController.ino`
    program. The setup function initializes the nRF8001 board and configures the pins
    for the optional monitoring LEDs.
  prefs: []
  type: TYPE_NORMAL
- en: Main program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `loop` function just calls the `polACI` function to allow the correct management
    of incoming messages from the nRF8001 board.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program accepts the following two messages from the iOS device (refer to
    the `rxCallback` function):'
  prefs: []
  type: TYPE_NORMAL
- en: '`D` to decrease the volume'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`I` to increase the volume'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following two functions perform the actual increasing and decreasing of
    volume by sending the two `up` and `down` buffers through the IR LED:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `up` and `down` buffers, `VOLUME_UP_BUFFER_LEN` and `VOLUME_DOWN_BUFFER_LEN`,
    are prepared with the help of the Decode.ino program (see the *Testing and tuning*
    section).
  prefs: []
  type: TYPE_NORMAL
- en: iOS code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to look at the iOS application that monitors the
    TV set volume and sends the volume down or volume up commands to the Arduino board
    in order to maintain the volume at the desired value.
  prefs: []
  type: TYPE_NORMAL
- en: The full code of this project can be downloaded from [https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support).
  prefs: []
  type: TYPE_NORMAL
- en: To understand better the explanations in the following paragraphs, open the
    downloaded code while reading them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Xcode project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a new project as we already did in the previous chapters. The
    following are the steps that you need to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the parameters for the new project:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Project Type**: Tabbed application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Product Name**: VolumeController'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Language**: Objective-C'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Devices**: Universal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To set a capability for this project, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the project in the left pane of Xcode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Capabilities** in the right pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn on the **Background Modes** option and select **Audio and AirPlay** (refer
    to the following picture). This allows an iOS device to listen to audio signals
    too when the iOS device screen goes off, or the app goes in the background:![Creating
    the Xcode project](img/image00209.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since the structure of this project is very close to the Pet Door Locker, we
    can reuse a part of the user interface and the code by performing the following
    steps (for more details, go back to the iOS guider rover project in [Chapter 4](part0033.xhtml#aid-VF2I1
    "Chapter 4. iOS Guided Rover"), *iOS Guided Rover*, where we did almost the same
    thing):'
  prefs: []
  type: TYPE_NORMAL
- en: Select **FirstViewController.h** and **FirstViewController.m**, right-click
    on them, click on **Delete**, and select **Move to Trash**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the same procedure, delete**SecondViewController**and **Main.storyboard**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **PetDoorLocker** project in Xcode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the following files and drag and drop them to this project (refer to
    the following picture).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**BLEConnectionViewController.h**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BLEConnectionViewController.m**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Main.storyboard**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that **Copy items if needed** is selected and then click on **Finish**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Copy the icon that was used for the BLEConnectionViewController view controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new View Controller class and name it `VolumeControllerViewController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Main.storyboard** and locate the main View Controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete all the graphical components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Identity Inspector and change the **Class** to **VolumeControllerViewController**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we are ready to create what we need for the new application.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the user interface for VolumeControllerViewController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This view controller is the main view controller of the application, and contains
    just the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: The switch that turns on and off the volume control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The slider that sets the desired volume of the TV set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you have added the components and their layout constraints, you will end
    up with something that looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the user interface for VolumeControllerViewController](img/image00210.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the GUI components are linked with the code of the view controller, we
    end with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Writing code for BLEConnectionViewController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we copied this View Controller from the Pet Door Locker project, we don't
    need to change it apart from replacing the key, which was used to store the peripheral
    UUID, from `PetDoorLockerDevice` to `VolumeControllerDevice`.
  prefs: []
  type: TYPE_NORMAL
- en: We saved some work!
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to work on the VolumeControllerViewController, which is much
    more interesting.
  prefs: []
  type: TYPE_NORMAL
- en: Writing code for VolumeControllerViewController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the main part of the application; almost everything happens here.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need some properties, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Some are used to manage the Bluetooth communication and don't need much explanation.
    The `audioEngine` is the instance of `AVAudioEngine`, which allows us to transform
    the audio signal captured by the iOS device microphone in numeric samples. By
    analyzing these samples, we can obtain the power of the signal that is directly
    related to the TV set's volume (the higher the volume, the greater the signal
    power).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Analog-to-digital conversion**'
  prefs: []
  type: TYPE_NORMAL
- en: The operation of transforming an analog signal into a digital sequence of numbers,
    which represent the amplitude of the signal itself at different times, is called
    analog-to-digital conversion. Arduino analog inputs perform exactly the same operation.
    Together with the digital-to-analog conversion, it is a basic operation of digital
    signal processing and storing music in our devices and playing it with a reasonable
    quality. For more details, visit [http://bit.ly/1N1QyXp](http://bit.ly/1N1QyXp).
  prefs: []
  type: TYPE_NORMAL
- en: The `actualVolumeDb` property stores the actual volume of the signal measured
    in dB (short for decibel).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Decibel (dB)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The decibel (dB) is a logarithmic unit that expresses the ratio between two
    values of a physical quantity. Referring to the power of a signal, its value in
    decibel is calculated with the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing code for VolumeControllerViewController](img/image00211.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, P is the power of the signal and P[0] is a reference power. You can find
    out more about decibel at [http://bit.ly/1LZQM0m](http://bit.ly/1LZQM0m). We have
    to point out that if P < P[0], the value of P[dB] if lower of zero. So, decibel
    values are usually negative values, and 0dB indicates the maximum power of the
    signal.
  prefs: []
  type: TYPE_NORMAL
- en: The `desiredVolumeDb` property stores the desired volume measured in dB, and
    the user controls this value through the volume slider in the main tab of the
    app; `desiredVolumeMinDb` and `desiredVolumeMaxDb` are derived from the `desiredVolumeDb`.
  prefs: []
  type: TYPE_NORMAL
- en: The most significant part of the code is in the `viewDidLoad` method (refer
    to the downloaded code).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we instantiate the `AudioEngine` and get the default input node, which
    is the microphone, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `AVAudioEngine` is a very powerful class, which allows digital audio signal
    processing. We are just going to scratch its capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**AVAudioEngine**'
  prefs: []
  type: TYPE_NORMAL
- en: You can find out more about AVAudioEngine by visiting [http://apple.co/1kExe35](http://apple.co/1kExe35)
    (AVAudioEngine in practice) and [http://apple.co/1WYG6Tp](http://apple.co/1WYG6Tp).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AVAudioEngine` and other functions that we are going to use require that
    we add the following imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'By installing an audio tap on the bus for our input node, we can get the numeric
    representation of the signal that the iOS device is listening to, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as a new buffer of data is available, the code block is called and
    the data can be processed. Now, we can take a look at the code that transforms
    the audio data samples into actual commands to control the TV set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In our case, the `for` cycle is executed just once, because we have just one
    buffer and we are using only one channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'The power of a signal, represented by *N* samples, can be calculated by using
    the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing code for VolumeControllerViewController](img/image00212.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, *v* is the value of the nth signal sample.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the power calculation has to performed in real time, we are going to
    use the following functions, which are provided by the Accelerated Framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '`vDSP_vsq`: This function calculates the square of each input vector element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vDSP_meanv`: This function calculates the mean value of the input vector elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The Accelerated Framework**'
  prefs: []
  type: TYPE_NORMAL
- en: The Accelerated Framework is an essential tool that is used for digital signal
    processing. It saves you time in implementing the most used algorithms and mostly
    providing implementation of algorithms that are optimized in terms of memory footprint
    and performance. More information on the Accelerated Framework can be found at
    [http://apple.co/1PYIKE8](http://apple.co/1PYIKE8) and [http://apple.co/1JCJWYh](http://apple.co/1JCJWYh).
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, the signal power is stored in `_actualVolumeDb`. When the modulus
    of `_actualVolumeDb` is lower than the `_desiredVolumeMinDb`, the TV set's volume
    is too high, and we need to send a message to Arduino to reduce it. Don't forget
    that `_actualVolumeDb` is a negative number; the modulus decreases this number
    when the TV set's volume increases. Conversely, when the TV set's volume decreases,
    the `_actualVolumeDb` modulus increases, and when it gets higher than `_desiredVolumeMaxDb`,
    we need to send a message to Arduino to increase the TV set's volume.
  prefs: []
  type: TYPE_NORMAL
- en: During pauses in dialogues, the power of the signal tends to decrease even if
    the volume of the speech is not changed. Without any adjustment, the increasing
    and decreasing messages are continuously sent to the TV set during dialogues.
    To avoid this misbehavior, we send the volume increase message only when the signal
    power stays over the threshold for some time (when `_increaseVolumeDelay` is greater
    than 10).
  prefs: []
  type: TYPE_NORMAL
- en: We can take a look at the other view controller methods that are not complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the view belonging at the view controller appears, the following method
    is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this function, we connect to the Arduino board and start the audio engine
    in order to start listening to the TV set.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the view disappears from the screen, the `viewDidDisappear` method is
    called, and we disconnect from the Arduino and stop the audio engine, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The method that is called when the switch is operated (`switchChanged`) is
    pretty simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The method that is called when the volume slider changes is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We just set the desired volume and the lower and upper thresholds.
  prefs: []
  type: TYPE_NORMAL
- en: The other methods that are used to manage the Bluetooth connection and data
    transfer don't require any explanation, because they are exactly like in the previous
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: Testing and tuning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are now ready to test our new amazing system and spend more and more time
    watching TV (or taking more and more naps!) Let''s perform the following procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the `Decoder.ino` sketch and open the Arduino IDE console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Point your TV remote controller to the TSOP4838 receiver and press the button
    that increases the volume. You should see something like the following appearing
    on the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Copy all the values between the curly braces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `Arduino_VolumeController.ino` and paste the values for the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Check whether the length of the two vectors (68 in the example) is the same
    and modify it, if needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Point your TV remote controller to the TSOP4838 receiver, and press the button
    that decreases the volume. Copy the values and paste them for:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Check whether the length of the two vectors (68 in the example) is the same
    and modify it, if needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upload the `Arduino_VolumeController.ino` to Arduino and point the IR LED towards
    the TV set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the iOS application, scan for the nRF8001, and then go to the main tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap on connect and then set the desired volume by touching the slider.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you should see the blue LED and the green LED flashing. The TV set's volume
    should stabilize to the desired value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To check whether everything is properly working, increase the volume of the
    TV set by using the remote control; you should immediately see the blue LED flashing
    and the volume getting lower to the preset value. Similarly, by decreasing the
    volume with the remote control, you should see the green LED flashing and the
    TV set's volume increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Take a nap, and the commercials will not wake you up!
  prefs: []
  type: TYPE_NORMAL
- en: How to go further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are some improvements that can be implemented in this project:'
  prefs: []
  type: TYPE_NORMAL
- en: Changing channels and controlling other TV set functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Catching handclaps to turn on or off the TV set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding a button to mute the TV set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Muting the TV set on receiving a phone call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Anyway, you can use the IR techniques that you have learned for many other purposes.
    For example, you can modify the rover project in [Chapter 4](part0033.xhtml#aid-VF2I1
    "Chapter 4. iOS Guided Rover"), *iOS Guided Rover*, to control the robot via an
    IR remote controller. Take a look at the other functions provided by the IRremote
    library to learn the other provided options. You can find all the available functions
    in the `IRremote.h` that is stored in the `IRremote` library folder.
  prefs: []
  type: TYPE_NORMAL
- en: On the iOS side, try to experiment with the AV Audio Engine and the Accelerate
    Framework that is used to process signals.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focused on an easy but useful project and taught you how to use
    IR to transmit and receive data to and from Arduino. There are many different
    applications of the basic circuits and programs that you learned here.
  prefs: []
  type: TYPE_NORMAL
- en: On the iOS platform, you learned the very basics of capturing sounds from the
    device microphone and the DSP (digital signal processing). This allows you to
    leverage the processing capabilities of the iOS platform to expand your Arduino
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will be amazing. You are going to open your garage door magically;
    you don't even need to touch your iOS device to do this. You will also learn a
    lot about the iBeacon technology. Your imagination will be your only limit!
  prefs: []
  type: TYPE_NORMAL
