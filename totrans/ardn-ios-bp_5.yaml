- en: Chapter 5. TV Set Constant Volume Controller
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I don't watch TV much, but when I do, I usually completely relax and fall asleep.
    I know that TV is not meant for putting you to sleep, but it does this to me.
    Unfortunately, commercials are transmitted at a very high volume and they wake
    me up. How can I relax if commercials wake me up every five minutes?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Can you believe it? During one of my naps between two commercials, I came up
    with a solution based on iOS and Arduino.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: It's nothing complex. An iOS device listens to the TV set's audio, and when
    the audio level becomes higher than a preset threshold, the iOS device sends a
    message (via Bluetooth) to Arduino, which controls the TV set volume, emulating
    the traditional IR remote control. Exactly the same happens when the volume drops
    below another threshold. The final result is that the TV set volume is almost
    constant, independent of what is on the air. This helps me sleep longer!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: The techniques that you are going to learn in this chapter are useful in many
    different ways. You can use an IR remote control for any purpose, or you can control
    many different devices, such as a CD/DVD player, a stereo set, Apple TV, a projector,
    and so on, directly from an Arduino and iOS device. As always, it is up to your
    imagination.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Constant Volume Controller requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our aim is to design an Arduino-based device, which can make the TV set's volume
    almost constant by emulating the traditional remote controller, and an iOS application,
    which monitors the TV and decides when to decrease or increase the TV set's volume.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Hardware
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most TV sets can be controlled by an IR remote controller, which sends signals
    to control the volume, change the channel, and control all the other TV set functions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: IR remote controllers use a carrier signal (usually at 38 KHz) that is easy
    to isolate from noise and disturbances.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: The carrier signal is turned on and off by following different rules (encoding)
    in order to transmit the 0 and 1 digital values.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The IR receiver removes the carrier signal (with a low pass filter) and decodes
    the remaining signal by returning a clear sequence of 0 and 1.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The IR remote control theory**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about the IR remote control at [http://bit.ly/1UjhsIY](http://bit.ly/1UjhsIY).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Our circuit will emulate the IR remote controller by using an IR LED, which
    will send specific signals that can be interpreted by our TV set.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, we can receive an IR signal with a phototransistor and decode
    it into an understandable sequence of numbers, by designing a demodulator and
    a decoder.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, electronics is very simple; an IR receiver module (Vishay 4938) will
    manage the complexity of signal demodulation, noise cancellation, triggering,
    and decoding. It can be directly connected to Arduino, making everything very
    easy.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: In the project in this chapter, we need an IR receiver to discover the coding
    rules that are used by our own IR remote controller (and the TV set).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Additional electronic components
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this project, we need the following additional components:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: IR LED Vishay TSAL6100
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IR Receiver module Vishay TSOP 4838
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resistor 100Ω
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resistor 680Ω
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Electrolytic capacitor 0.1μF
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Electronic circuit
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following picture shows the electrical diagram of the circuit that we need
    for the project:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![Electronic circuit](img/image00207.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: The IR receiver will be used only to capture the TV set's remote controller
    signals so that our circuit can emulate them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: However, an IR LED is constantly used to send commands to the TV set. The other
    two LEDs will show when Arduino increases or decreases the volume. They are optional
    and can be omitted.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: As usual, the Bluetooth device is used to receive commands from the iOS device.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Powering the IR LED in the current limits of Arduino**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: From the datasheet of the TSAL6100, we know that the forward voltage is 1.35V.
    The voltage drop along R1 is then *5-1.35 = 3.65V*, and the current provided by
    Arduino to power the LED is about *3.65/680=5.3 mA*. The maximum current that
    is allowed for each PIN is 40 mA (the recommended value is 20 mA). So, we are
    within the limits. In case your TV set is far from the LED, you may need to reduce
    the R1 resistor in order to get more current (and the IR light). Use a new value
    of R1 in the previous calculations to check whether you are within the Arduino
    limits. For more information about the Arduino PIN current, check out [http://bit.ly/1JosGac](http://bit.ly/1JosGac).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how to mount the circuit on a breadboard:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![Electronic circuit](img/image00208.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: Arduino code
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The entire code of this project can be downloaded from [https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: To understand better the explanations in the following paragraphs, open the
    downloaded code while reading them.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: In this project, we are going to use the IR remote library, which helps us code
    and decode IR signals.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'The library can be downloaded from [http://bit.ly/1Isd8Ay](http://bit.ly/1Isd8Ay),
    and installed by using the following procedure:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the release page of [http://bit.ly/1Isd8Ay](http://bit.ly/1Isd8Ay)
    in order to get the latest release and download the `IRremote.zip` file.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unzip the file whatever you like.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Finder** and then the `Applications` folder (*Shift* + *Control*
    + *A*).
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the Arduino application.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on it and select **Show Package Contents**.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the `Java` folder and then `libraries`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `IRremote` folder (unzipped in step 2) into the `libraries` folder.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart Arduino if you have it running.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this project, we need the following two Arduino programs:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: One is used to acquire the codes that your IR remote controller sends to increase
    and decrease the volume
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other is the main program that Arduino has to run to automatically control
    the TV set volume
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with the code that is used to acquire the IR remote controller codes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Decoder setup code
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will be referring to the downloaded `Decode.ino` program
    that is used to discover the codes that are used by your remote controller.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Since the setup code is quite simple, it doesn't require a detailed explanation;
    it just initializes the library to receive and decode messages.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Decoder main program
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will be referring to the downloaded `Decode.ino` program;
    the main code receives signals from the TV remote controller and dumps the appropriate
    code, which will be included in the main program to emulate the remote controller
    itself.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the program is run, if you press any button on the remote controller,
    the console will show the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The second row is what we need. Please refer to the *Testing and tuning* section
    for a detailed description of how to use this data.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will take a look at the main code that will be running on Arduino all
    the time.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Setup code
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will be referring to the `Arduino_VolumeController.ino`
    program. The setup function initializes the nRF8001 board and configures the pins
    for the optional monitoring LEDs.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Main program
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `loop` function just calls the `polACI` function to allow the correct management
    of incoming messages from the nRF8001 board.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'The program accepts the following two messages from the iOS device (refer to
    the `rxCallback` function):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '`D` to decrease the volume'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`I` to increase the volume'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following two functions perform the actual increasing and decreasing of
    volume by sending the two `up` and `down` buffers through the IR LED:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `up` and `down` buffers, `VOLUME_UP_BUFFER_LEN` and `VOLUME_DOWN_BUFFER_LEN`,
    are prepared with the help of the Decode.ino program (see the *Testing and tuning*
    section).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: iOS code
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to look at the iOS application that monitors the
    TV set volume and sends the volume down or volume up commands to the Arduino board
    in order to maintain the volume at the desired value.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: The full code of this project can be downloaded from [https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: To understand better the explanations in the following paragraphs, open the
    downloaded code while reading them.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Xcode project
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a new project as we already did in the previous chapters. The
    following are the steps that you need to follow:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the parameters for the new project:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '**Project Type**: Tabbed application'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Product Name**: VolumeController'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Language**: Objective-C'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Devices**: Universal'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To set a capability for this project, perform the following steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Select the project in the left pane of Xcode.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Capabilities** in the right pane.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn on the **Background Modes** option and select **Audio and AirPlay** (refer
    to the following picture). This allows an iOS device to listen to audio signals
    too when the iOS device screen goes off, or the app goes in the background:![Creating
    the Xcode project](img/image00209.jpeg)
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since the structure of this project is very close to the Pet Door Locker, we
    can reuse a part of the user interface and the code by performing the following
    steps (for more details, go back to the iOS guider rover project in [Chapter 4](part0033.xhtml#aid-VF2I1
    "Chapter 4. iOS Guided Rover"), *iOS Guided Rover*, where we did almost the same
    thing):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Select **FirstViewController.h** and **FirstViewController.m**, right-click
    on them, click on **Delete**, and select **Move to Trash**.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the same procedure, delete**SecondViewController**and **Main.storyboard**.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **PetDoorLocker** project in Xcode.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the following files and drag and drop them to this project (refer to
    the following picture).
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**BLEConnectionViewController.h**'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BLEConnectionViewController.m**'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Main.storyboard**'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that **Copy items if needed** is selected and then click on **Finish**.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Copy the icon that was used for the BLEConnectionViewController view controller.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new View Controller class and name it `VolumeControllerViewController`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Main.storyboard** and locate the main View Controller.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete all the graphical components.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Identity Inspector and change the **Class** to **VolumeControllerViewController**.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we are ready to create what we need for the new application.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Designing the user interface for VolumeControllerViewController
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This view controller is the main view controller of the application, and contains
    just the following components:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The switch that turns on and off the volume control
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The slider that sets the desired volume of the TV set
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you have added the components and their layout constraints, you will end
    up with something that looks like the following screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the user interface for VolumeControllerViewController](img/image00210.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: 'Once the GUI components are linked with the code of the view controller, we
    end with the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Writing code for BLEConnectionViewController
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we copied this View Controller from the Pet Door Locker project, we don't
    need to change it apart from replacing the key, which was used to store the peripheral
    UUID, from `PetDoorLockerDevice` to `VolumeControllerDevice`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: We saved some work!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to work on the VolumeControllerViewController, which is much
    more interesting.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Writing code for VolumeControllerViewController
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the main part of the application; almost everything happens here.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'We need some properties, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Some are used to manage the Bluetooth communication and don't need much explanation.
    The `audioEngine` is the instance of `AVAudioEngine`, which allows us to transform
    the audio signal captured by the iOS device microphone in numeric samples. By
    analyzing these samples, we can obtain the power of the signal that is directly
    related to the TV set's volume (the higher the volume, the greater the signal
    power).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Analog-to-digital conversion**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The operation of transforming an analog signal into a digital sequence of numbers,
    which represent the amplitude of the signal itself at different times, is called
    analog-to-digital conversion. Arduino analog inputs perform exactly the same operation.
    Together with the digital-to-analog conversion, it is a basic operation of digital
    signal processing and storing music in our devices and playing it with a reasonable
    quality. For more details, visit [http://bit.ly/1N1QyXp](http://bit.ly/1N1QyXp).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The `actualVolumeDb` property stores the actual volume of the signal measured
    in dB (short for decibel).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Decibel (dB)**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'The decibel (dB) is a logarithmic unit that expresses the ratio between two
    values of a physical quantity. Referring to the power of a signal, its value in
    decibel is calculated with the following formula:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing code for VolumeControllerViewController](img/image00211.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: Here, P is the power of the signal and P[0] is a reference power. You can find
    out more about decibel at [http://bit.ly/1LZQM0m](http://bit.ly/1LZQM0m). We have
    to point out that if P < P[0], the value of P[dB] if lower of zero. So, decibel
    values are usually negative values, and 0dB indicates the maximum power of the
    signal.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The `desiredVolumeDb` property stores the desired volume measured in dB, and
    the user controls this value through the volume slider in the main tab of the
    app; `desiredVolumeMinDb` and `desiredVolumeMaxDb` are derived from the `desiredVolumeDb`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: The most significant part of the code is in the `viewDidLoad` method (refer
    to the downloaded code).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we instantiate the `AudioEngine` and get the default input node, which
    is the microphone, as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `AVAudioEngine` is a very powerful class, which allows digital audio signal
    processing. We are just going to scratch its capabilities.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**AVAudioEngine**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: You can find out more about AVAudioEngine by visiting [http://apple.co/1kExe35](http://apple.co/1kExe35)
    (AVAudioEngine in practice) and [http://apple.co/1WYG6Tp](http://apple.co/1WYG6Tp).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AVAudioEngine` and other functions that we are going to use require that
    we add the following imports:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'By installing an audio tap on the bus for our input node, we can get the numeric
    representation of the signal that the iOS device is listening to, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As soon as a new buffer of data is available, the code block is called and
    the data can be processed. Now, we can take a look at the code that transforms
    the audio data samples into actual commands to control the TV set:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In our case, the `for` cycle is executed just once, because we have just one
    buffer and we are using only one channel.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'The power of a signal, represented by *N* samples, can be calculated by using
    the following formula:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing code for VolumeControllerViewController](img/image00212.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: Here, *v* is the value of the nth signal sample.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the power calculation has to performed in real time, we are going to
    use the following functions, which are provided by the Accelerated Framework:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '`vDSP_vsq`: This function calculates the square of each input vector element'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vDSP_meanv`: This function calculates the mean value of the input vector elements'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The Accelerated Framework**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: The Accelerated Framework is an essential tool that is used for digital signal
    processing. It saves you time in implementing the most used algorithms and mostly
    providing implementation of algorithms that are optimized in terms of memory footprint
    and performance. More information on the Accelerated Framework can be found at
    [http://apple.co/1PYIKE8](http://apple.co/1PYIKE8) and [http://apple.co/1JCJWYh](http://apple.co/1JCJWYh).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, the signal power is stored in `_actualVolumeDb`. When the modulus
    of `_actualVolumeDb` is lower than the `_desiredVolumeMinDb`, the TV set's volume
    is too high, and we need to send a message to Arduino to reduce it. Don't forget
    that `_actualVolumeDb` is a negative number; the modulus decreases this number
    when the TV set's volume increases. Conversely, when the TV set's volume decreases,
    the `_actualVolumeDb` modulus increases, and when it gets higher than `_desiredVolumeMaxDb`,
    we need to send a message to Arduino to increase the TV set's volume.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: During pauses in dialogues, the power of the signal tends to decrease even if
    the volume of the speech is not changed. Without any adjustment, the increasing
    and decreasing messages are continuously sent to the TV set during dialogues.
    To avoid this misbehavior, we send the volume increase message only when the signal
    power stays over the threshold for some time (when `_increaseVolumeDelay` is greater
    than 10).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: We can take a look at the other view controller methods that are not complex.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'When the view belonging at the view controller appears, the following method
    is called:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this function, we connect to the Arduino board and start the audio engine
    in order to start listening to the TV set.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'When the view disappears from the screen, the `viewDidDisappear` method is
    called, and we disconnect from the Arduino and stop the audio engine, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The method that is called when the switch is operated (`switchChanged`) is
    pretty simple:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The method that is called when the volume slider changes is as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We just set the desired volume and the lower and upper thresholds.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The other methods that are used to manage the Bluetooth connection and data
    transfer don't require any explanation, because they are exactly like in the previous
    projects.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Testing and tuning
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are now ready to test our new amazing system and spend more and more time
    watching TV (or taking more and more naps!) Let''s perform the following procedure:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Load the `Decoder.ino` sketch and open the Arduino IDE console.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Point your TV remote controller to the TSOP4838 receiver and press the button
    that increases the volume. You should see something like the following appearing
    on the console:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Copy all the values between the curly braces.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `Arduino_VolumeController.ino` and paste the values for the following:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Check whether the length of the two vectors (68 in the example) is the same
    and modify it, if needed.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Point your TV remote controller to the TSOP4838 receiver, and press the button
    that decreases the volume. Copy the values and paste them for:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Check whether the length of the two vectors (68 in the example) is the same
    and modify it, if needed.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upload the `Arduino_VolumeController.ino` to Arduino and point the IR LED towards
    the TV set.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the iOS application, scan for the nRF8001, and then go to the main tab.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap on connect and then set the desired volume by touching the slider.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you should see the blue LED and the green LED flashing. The TV set's volume
    should stabilize to the desired value.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To check whether everything is properly working, increase the volume of the
    TV set by using the remote control; you should immediately see the blue LED flashing
    and the volume getting lower to the preset value. Similarly, by decreasing the
    volume with the remote control, you should see the green LED flashing and the
    TV set's volume increasing.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Take a nap, and the commercials will not wake you up!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: How to go further
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are some improvements that can be implemented in this project:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Changing channels and controlling other TV set functions.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Catching handclaps to turn on or off the TV set.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding a button to mute the TV set.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Muting the TV set on receiving a phone call.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Anyway, you can use the IR techniques that you have learned for many other purposes.
    For example, you can modify the rover project in [Chapter 4](part0033.xhtml#aid-VF2I1
    "Chapter 4. iOS Guided Rover"), *iOS Guided Rover*, to control the robot via an
    IR remote controller. Take a look at the other functions provided by the IRremote
    library to learn the other provided options. You can find all the available functions
    in the `IRremote.h` that is stored in the `IRremote` library folder.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: On the iOS side, try to experiment with the AV Audio Engine and the Accelerate
    Framework that is used to process signals.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focused on an easy but useful project and taught you how to use
    IR to transmit and receive data to and from Arduino. There are many different
    applications of the basic circuits and programs that you learned here.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: On the iOS platform, you learned the very basics of capturing sounds from the
    device microphone and the DSP (digital signal processing). This allows you to
    leverage the processing capabilities of the iOS platform to expand your Arduino
    projects.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS平台上，你学习了从设备麦克风和DSP（数字信号处理）捕获声音的非常基础的知识。这让你可以利用iOS平台的处理能力来扩展你的Arduino项目。
- en: The next chapter will be amazing. You are going to open your garage door magically;
    you don't even need to touch your iOS device to do this. You will also learn a
    lot about the iBeacon technology. Your imagination will be your only limit!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将会非常精彩。你将神奇地打开你的车库门；你甚至不需要触摸你的iOS设备就能做到这一点。你还将了解到很多关于iBeacon技术的知识。你的想象力将是你的唯一限制！
