- en: Chapter 4. Plugin Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 插件管理
- en: In the last chapter, we discussed Gradle task, which is the atomic unit of execution
    in Gradle. In most cases, a task provides only a single unit of work in modules.
    We can choose to bundle tasks together and execute them in a certain order to
    provide the complete functionality. This grouping of tasks along with properties
    and configuration is called a plugin. A plugin is the logical grouping of tasks,
    which may have a life cycle. You can configure plugins to alter the behavior based
    on the requirements. You can extend it to provide additional features. At a broader
    level, Gradle provides two types of plugins; script plugin and binary plugin.
    Gradle treats a build script as a script plugin and you can use other build scripts
    in a project by importing build scripts into the current project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了Gradle任务，它是Gradle中的执行原子单位。在大多数情况下，任务在模块中只提供单一的工作单元。我们可以选择将任务捆绑在一起，并按特定顺序执行它们，以提供完整的功能。这种任务、属性和配置的组合称为插件。插件是任务的逻辑组合，可能具有生命周期。你可以根据需求配置插件以改变行为。你可以扩展它以提供额外的功能。在更广泛的意义上，Gradle提供了两种类型的插件；脚本插件和二进制插件。Gradle将构建脚本视为脚本插件，并且你可以通过将构建脚本导入到当前项目中，在项目中使用其他构建脚本。
- en: Binary plugins are plugins, that we create using programming languages such
    as Java or Groovy. Gradle provides in-built binary plugins for different build
    functionalities. There are different approaches to creating a binary plugin in
    Gradle, which we will discuss in the Custom Plugin section. First, we will explore
    the script plugin.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制插件是我们使用诸如Java或Groovy之类的编程语言创建的插件。Gradle为不同的构建功能提供了内置的二进制插件。在Gradle中创建二进制插件有不同的方法，我们将在自定义插件部分进行讨论。首先，我们将探索脚本插件。
- en: The script plugin
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本插件
- en: A script plugin is nothing but a Gradle file, which we import into other build
    files. It is the same as modularizing your code across different classes. When
    a build file size exceeds to a certain limit or diverse functionalities are clubbed
    to a single file, it might be a better option to divide the cohesive tasks into
    different build files. Then, you can import these files to the main build file
    to use the new functionalities.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本插件实际上就是一个Gradle文件，我们将其导入到其他构建文件中。这就像在不同的类之间模块化你的代码一样。当一个构建文件的大小超过一定限制，或者将不同的功能组合到一个文件中时，将连贯的任务分割到不同的构建文件中可能是一个更好的选择。然后，你可以将这些文件导入到主构建文件中以使用新的功能。
- en: 'To import the build file you can use the following code:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入构建文件，你可以使用以下代码：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, the path could be a local file or a location relative to the project directory
    or a valid URL. However, if you mention the URL, the downside is that the file
    will be downloaded each time. Once the build file is imported, you can use the
    tasks defined in the build file without any additional configuration.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，路径可以是本地文件，也可以是项目目录的相对位置或有效的URL。然而，如果你提到URL，缺点是文件将每次都下载。一旦构建文件被导入，你就可以使用构建文件中定义的任务，而无需任何额外的配置。
- en: 'If you are adding multiple build files in the main build file, make sure you
    do not have tasks with the same name in the imported build files. During import,
    if Gradle finds two tasks with the same name, it will throw the following exception:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在主构建文件中添加多个构建文件，确保导入的构建文件中没有具有相同名称的任务。在导入过程中，如果Gradle发现两个具有相同名称的任务，它将抛出以下异常：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Consider the following directory structure:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下目录结构：
- en: '`/Chapter4/scriptplugin.gradle`'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`/Chapter4/scriptplugin.gradle`'
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`/Chapter4/build.gradle`'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`/Chapter4/build.gradle`'
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Execute the following command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we have defined the `scriptPluginTask1` in the `scriptplugin.gradle` file
    and have imported this build file in the main script `build.gradle`. Thus, importing
    the `scriptplugin.gradle` file into `build.gradle` will make `scriptPluginTask1`
    available in the main build file and you can call it directly without mentioning
    any build filename.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`scriptplugin.gradle`文件中定义了`scriptPluginTask1`，并将此构建文件导入到主脚本`build.gradle`中。因此，将`scriptplugin.gradle`文件导入到`build.gradle`中会使`scriptPluginTask1`在主构建文件中可用，并且你可以直接调用它而无需提及任何构建文件名。
- en: The binary plugin
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二进制插件
- en: 'Binary plugins are classes that implement the **Plugin** interface, which you
    can embed into the build script. Alternatively, you can create a separate project,
    package it into a jar file and add that jar file as a classpath entry to a project.
    The second approach makes it more reusable. Each binary plugin has one ID to uniquely
    identify it. To use a binary plugin, you need to include it using the `apply plugin`
    statement:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制插件是实现 **Plugin** 接口的类，你可以将其嵌入到构建脚本中。或者，你可以创建一个单独的项目，将其打包成一个 jar 文件，并将该 jar
    文件作为类路径条目添加到项目中。第二种方法使其更具可重用性。每个二进制插件都有一个 ID 来唯一标识它。要使用二进制插件，你需要使用 `apply plugin`
    语句来包含它：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For example, to use the Java plugin, you can write the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要使用 Java 插件，你可以编写以下代码：
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can also use the class type to add plugins. For example, if you are creating
    a custom class, `DisplayPlugin`, as a plugin, you can apply the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用类类型来添加插件。例如，如果你正在创建一个自定义类，`DisplayPlugin`，作为一个插件，你可以应用以下代码：
- en: '[PRE7]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Before using this approach make sure you import this class in the build file
    using the import statement. All the Gradle core plugins are available to you by
    default. You do not need any additional configuration to use them. For third-party
    or community plugins, you need to make sure they are available in the classpath
    before you use them. You can do this by adding the plugin in the classpath using
    the `buildscript{}` closure. When you apply any plugin to a build file, all the
    tasks that are part of the plugin are automatically added. You can directly use
    the task with the default configurations or you can customize the task configuration,
    if needed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这种方法之前，请确保你在构建文件中使用导入语句导入此类。所有 Gradle 核心插件默认都可用。你不需要任何额外的配置就可以使用它们。对于第三方或社区插件，在使用之前，你需要确保它们在类路径中可用。你可以通过在
    `buildscript{}` 闭包中添加插件到类路径来实现。当你将任何插件应用到构建文件时，该插件的所有任务都会自动添加。你可以直接使用默认配置的任务，或者如果需要，你可以自定义任务配置。
- en: Gradle's in-built plugins
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gradle 的内置插件
- en: Gradle provides different in-built plugins to automate the build process. Gradle
    not only provides different plugins to build a project, but also provides plugins
    to test the project, for code analysis, for IDE support, for web container support,
    and so on.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 提供了不同的内置插件来自动化构建过程。Gradle 不仅提供了不同的插件来构建项目，还提供了用于测试项目、代码分析、IDE 支持、Web
    容器支持等的插件。
- en: The following are some of the frequently used plugins in different categories.
    You will find more details on core plugins in the Gradle documentation at [https://docs.gradle.org/current/userguide/userguide](https://docs.gradle.org/current/userguide/userguide).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些不同类别中常用的插件。你可以在 Gradle 文档的[https://docs.gradle.org/current/userguide/userguide](https://docs.gradle.org/current/userguide/userguide)中找到关于核心插件的更多详细信息。
- en: Build and Test plugins
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建和测试插件
- en: 'These plugins also support the testing features to execute Junit and TestNG
    tests:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些插件也支持测试功能，可以执行 Junit 和 TestNG 测试：
- en: The Java plugin
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 插件
- en: The Groovy plugin
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Groovy 插件
- en: The Scala plugin
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala 插件
- en: The War plugin
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: War 插件
- en: Code analysis plugins
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码分析插件
- en: 'The following are the code analysis plugins:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些代码分析插件：
- en: The Checkstyle plugin
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Checkstyle 插件
- en: The FindBugs plugin
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FindBugs 插件
- en: The Sonar plugin
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sonar 插件
- en: The Sonar Runner plugin
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sonar Runner 插件
- en: The PMD plugin
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PMD 插件
- en: IDE plugins
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDE 插件
- en: 'The following are IDE plugins:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 IDE 插件：
- en: The Eclipse plugin
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eclipse 插件
- en: The IDEA plugin
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IDEA 插件
- en: These are some of the frequently used plugins. Apart from the core plugins,
    you can also find third-party plugins at [https://plugins.gradle.org/](https://plugins.gradle.org/).
    It allows the publication of binary plugins with the support of the Gradle `Plugin
    Publishing` plugin. Consider spending some time learning how to publish a plugin
    and how to use the `Plugin Publishing` plugin. In the following chapters, we will
    learn a few core plugins. In the next section, we will explore the Java plugin.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些常用的插件。除了核心插件之外，你还可以在[https://plugins.gradle.org/](https://plugins.gradle.org/)找到第三方插件。它允许使用
    Gradle `Plugin Publishing` 插件发布二进制插件。考虑花一些时间学习如何发布插件以及如何使用 `Plugin Publishing`
    插件。在接下来的章节中，我们将学习一些核心插件。在下一节中，我们将探索 Java 插件。
- en: The Java plugin
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 插件
- en: In [Chapter 1](ch01.html "Chapter 1. Getting Started with Gradle"), *Getting
    Started with Gradle*, we already created a Java project called `FirstGradleProject`.
    However, the discussion was only limited to the Eclipse plugin tasks. We did not
    discuss anything about the Java plugin. The Java plugin is part of the Gradle
    core API, which enables us to build a Java project with supporting tasks such
    as compiling the Java code, testing the code, assembling binaries to create libraries,
    and more. It supports conventions over configuration. This means, if we use this
    plugin, some default configuration is already available to the developer, such
    as the location of the source code, the location of the compiled class file, and
    the jar naming convention. Unless we want to override these configurations, we
    do not need to write a lot of code to work with the default tasks and properties.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 1 章](ch01.html "第 1 章. 使用 Gradle 入门")，*使用 Gradle 入门* 中，我们已创建了一个名为 `FirstGradleProject`
    的 Java 项目。然而，讨论仅限于 Eclipse 插件任务。我们没有讨论关于 Java 插件的内容。Java 插件是 Gradle 核心API的一部分，它使我们能够使用支持编译
    Java 代码、测试代码、组装二进制文件以创建库等任务来构建 Java 项目。它支持约定而非配置。这意味着，如果我们使用此插件，一些默认配置已经对开发者可用，例如源代码的位置、编译后的类文件的位置以及
    jar 命名约定。除非我们想要覆盖这些配置，否则我们不需要编写大量代码来与默认任务和属性一起工作。
- en: 'To apply the Java plugin, we add a single statement to the build file:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用 Java 插件，我们只需在构建文件中添加一个语句：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Internally, the apply method of the Java plugin is invoked with the **project**
    object as the argument and the build script is enabled in order to use all the
    tasks and properties provided by the Java plugin. To understand the Java plugin,
    we will create a new Java application (project name `Ch04-Java1`) similar to the
    Java project `FirstGradleProject`, which we developed in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with Gradle"), *Getting Started with Gradle*. We will
    add two new classes, Customer and Order; we will also add a new JUnit or TestNG
    library dependency to support unit testing functionality for the project.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，Java 插件的 apply 方法使用 **project** 对象作为参数调用，并且启用构建脚本以便使用 Java 插件提供的所有任务和属性。为了理解
    Java 插件，我们将创建一个新的 Java 应用程序（项目名称 `Ch04-Java1`），类似于我们在 [第 1 章](ch01.html "第 1 章.
    使用 Gradle 入门") 中开发的 Java 项目 `FirstGradleProject`，*使用 Gradle 入门*。我们将添加两个新的类，Customer
    和 Order；我们还将添加一个新的 JUnit 或 TestNG 库依赖项，以支持项目的单元测试功能。
- en: With the help of this example, we will explore different Java plugin conventions.
    To be precise, we will try to understand how different tasks work and which default
    conventions are supported by the Java plugin. Then, in the next section, we will
    learn how to customize different properties, so that we can create our own configuration
    in the build file.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个示例的帮助，我们将探索不同的 Java 插件约定。更准确地说，我们将尝试理解不同的任务是如何工作的，以及 Java 插件支持哪些默认约定。然后，在下一节中，我们将学习如何自定义不同的属性，以便我们可以在构建文件中创建自己的配置。
- en: Conventions
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 约定
- en: 'To understand conventions, let us start with the Java plugin tasks. Once we
    have applied the Java plugin to display all the available tasks in the project
    (project name `Ch04-Java1`), we can use the tasks command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解约定，让我们从 Java 插件任务开始。一旦我们将 Java 插件应用到项目中以显示所有可用的任务（项目名称 `Ch04-Java1`），我们就可以使用任务命令：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding output displays different build tasks, test tasks, documentation
    tasks, and other available tasks in the Java plugin. The output also shows the
    task dependencies between different tasks. For example, task classes internally
    depend on the `compileJava` and `processResources` tasks, which compile and process
    the source code and resources from `src/main/java` and `src/main/resources`, respectively.
    Similarly, the `compileTestJava` task and `processTestResources` task compile
    and process resources from `src/test/java` and `src/test/resources`, respectively.
    The output of all these tasks is compiled classes and resources, which will be
    created under the `build` directory by convention and will be added to the `classspath`
    during the execution of the program. Now, let us explore, with an example, what
    these tasks mean and which conventions are available by default.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出显示了Java插件中的不同构建任务、测试任务、文档任务和其他可用任务。输出还显示了不同任务之间的任务依赖关系。例如，任务类内部依赖于`compileJava`和`processResources`任务，分别编译和处理`src/main/java`和`src/main/resources`中的源代码和资源。同样，`compileTestJava`任务和`processTestResources`任务分别编译和处理`src/test/java`和`src/test/resources`中的资源。所有这些任务的输出是编译后的类和资源，按照惯例将在`build`目录下创建，并在程序执行期间添加到`classpath`中。现在，让我们通过一个示例来探索这些任务的意义以及默认可用的约定。
- en: To compile classes only under `src/main`, we should use the task classes. The
    compiled classes will be created under `build/classes/` directory.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要仅在`src/main`下编译类，我们应该使用`classes`任务。编译后的类将创建在`build/classes/`目录下。
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `testClasses` task compiles and processes test classes and resources, and
    additionally, executes the classes task. In the following output, you can see
    that the `compileJava`, `processResources`, and `classes` tasks were executed
    again but the tasks were marked as `UP-TO-DATE`. This is because there was no
    change in the input and output of those tasks, as we have already executed the
    `classes` task in the last command. After successful execution, you will find
    a test directory created under the `build/classes` folder:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`testClasses`任务编译并处理测试类和资源，并且还会执行类任务。在以下输出中，你可以看到`compileJava`、`processResources`和`classes`任务再次执行，但任务被标记为`UP-TO-DATE`。这是因为这些任务的输入和输出没有变化，因为我们已经在上一条命令中执行了`classes`任务。执行成功后，你将在`build/classes`文件夹下找到一个测试目录：'
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The other important task is the `test` task. This task helps to execute unit
    test code written under the `src/test` directory. After successful execution,
    you will find the test results created under the `build/test-results` directory:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的任务是`test`任务。这个任务可以帮助执行在`src/test`目录下编写的单元测试代码。执行成功后，你将在`build/test-results`目录下找到测试结果：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You have the `assemble` task or the `jar` task to package classes and resources
    into a jar file. The `jar` task will only create jar files, whereas, the assemble
    task helps you to produce other artifacts, including jar. For example, when you
    apply the war plugin, the `jar` task is disabled and is replaced with the war
    task. By default, the JAR file is named `<project-name>.jar` and is created under
    `build/libs`. If you have not set the `<project-name>` in the build file, you
    will get the jar name `<project-folder-name>.jar`. This is not good practice if
    the jar file does not contain any version. You can add the version to the jar
    file by adding the version property to your project in the build file, which will
    generate `<name>-<version>.jar`. In our example, the project name is `Ch04-Java1`
    and the version property is set to `1.0` in the build file. Therefore, the jar
    file will be named `Ch04-Java1-1.0.jar`. Execute the following command and you
    will find the jar file under `build/libs`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`assemble`任务或`jar`任务将类和资源打包到JAR文件中。`jar`任务只会创建JAR文件，而`assemble`任务可以帮助你生成其他工件，包括JAR文件。例如，当你应用war插件时，`jar`任务被禁用，并替换为war任务。默认情况下，JAR文件命名为`<project-name>.jar`，并创建在`build/libs`下。如果你在构建文件中没有设置`<project-name>`，你将得到名为`<project-folder-name>.jar`的JAR文件名。如果JAR文件不包含任何版本，这并不是一个好的做法。你可以在构建文件中为你的项目添加版本属性，这将生成`<name>-<version>.jar`。在我们的示例中，项目名称是`Ch04-Java1`，版本属性在构建文件中设置为`1.0`。因此，JAR文件将被命名为`Ch04-Java1-1.0.jar`。执行以下命令，你将在`build/libs`下找到JAR文件：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: No test classes will be packaged in the JAR file.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: JAR文件中不会打包任何测试类。
- en: Another task is the `build` task, which executes the `check` and `assemble`
    tasks together. The `clean` task deletes all the artifacts created by another
    task. It actually deletes the complete `build/` folder. This means, the `clean`
    task deletes the output generated by all the tasks, that is, `check` and `assemble`.
    To delete a task-specific output, we can apply the `clean<TaskName>` rule. For
    example, to delete only the jar file created by the `build` task, we can execute
    the `gradle cleanJar` command.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个任务是`build`任务，它一起执行`check`和`assemble`任务。`clean`任务删除另一个任务创建的所有工件。它实际上删除了完整的`build/`文件夹。这意味着，`clean`任务删除了所有任务生成的输出，即`check`和`assemble`。要删除特定任务的输出，我们可以应用`clean<TaskName>`规则。例如，要删除由`build`任务创建的jar文件，我们可以执行`gradle
    cleanJar`命令。
- en: 'All the tasks in the Java plugin execute based on conventions such as source
    directory location, build folder name, test result folder, and so on. To understand
    this in a better way, the following example shows some of the conventions supported
    by Gradle:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Java插件中的所有任务都是基于诸如源目录位置、构建文件夹名称、测试结果文件夹等约定来执行的。为了更好地理解这一点，以下示例展示了Gradle支持的一些约定：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The output displays various conventions supported by the Java plugin. You can
    find the complete list in the official Gradle documentation at [https://docs.gradle.org/current/userguide/java_plugin.html](https://docs.gradle.org/current/userguide/java_plugin.html).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了Java插件支持的各个约定。您可以在官方Gradle文档中找到完整的列表，网址为[https://docs.gradle.org/current/userguide/java_plugin.html](https://docs.gradle.org/current/userguide/java_plugin.html)。
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Sometimes, these default configurations might not suffice. We might need to
    configure some default properties to support our requirements. In the next section,
    we will explore how to configure some of the default configurations.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，这些默认配置可能不够用。我们可能需要配置一些默认属性以支持我们的需求。在下一节中，我们将探讨如何配置一些默认配置。
- en: Configuration
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: In the previous example, we learned about the default properties or conventions
    available in the Java plugin. Now, we will configure some of these properties.
    This is important when we want to change the build directory name, the libs folder
    name, or the source file location of the project.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们了解了Java插件中可用的默认属性或约定。现在，我们将配置一些这些属性。当我们想要更改构建目录名称、库文件夹名称或项目的源文件位置时，这很重要。
- en: The source- related configuration changes can be set in the `sourceSets` closure.
    The upcoming code snippet (project name `Ch04-Java2`) shows that the source code
    location has been modified from `src/main/java` to `src/productioncode` for the
    source code location and `src/test/java` to `src/testcode` for the test code location,
    respectively. As a result, compiled classes will now be stored in `classes/productioncode`
    and `classes/testcode` locations for the source and test code, respectively. This
    will not replace the source directory from `main` to `productioncode`, but Gradle
    will now look for source code in both `main` and `productioncode` directories
    and for test code in both `test` and `testcode` directories. If you want Gradle
    to look for the source code only in the `productioncode` directory, you can set
    the `java.srcDirs` property.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与源相关的配置更改可以在`sourceSets`闭包中设置。即将到来的代码片段（项目名称`Ch04-Java2`）显示，源代码位置已从`src/main/java`更改为`src/productioncode`，分别用于源代码位置和`src/test/java`到`src/testcode`用于测试代码位置。因此，编译后的类现在将分别存储在`classes/productioncode`和`classes/testcode`位置，分别对应源代码和测试代码。这不会替换`main`到`productioncode`的源目录，但Gradle现在将在`main`和`productioncode`目录中查找源代码，在`test`和`testcode`目录中查找测试代码。如果您希望Gradle仅在`productioncode`目录中查找源代码，您可以设置`java.srcDirs`属性。
- en: 'These Java plugin conventions are written in the `JavaPluginConvention` and`BasePluginConvention`
    classes. One such property, `testResultsDirName`, can also be set in the `build`
    file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这些Java插件约定是在`JavaPluginConvention`和`BasePluginConvention`类中编写的。其中一个这样的属性，`testResultsDirName`，也可以在`build`文件中设置：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These changes will make sure that `buildfolder`, `libfolder`, and `test-result`
    folders have been replaced with `buildfolder`, `libfolder`, and `new-test-result`
    folders.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改将确保`buildfolder`、`libfolder`和`test-result`文件夹已被替换为`buildfolder`、`libfolder`和`new-test-result`文件夹。
- en: 'Figure 4.1 shows the directory structure of the `src` folder and new the `buildfolder`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1显示了`src`文件夹和新的`buildfolder`的目录结构：
- en: '![Configuration](img/B02000_04_01.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![配置](img/B02000_04_01.jpg)'
- en: Figure 4.1
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1
- en: 'All these new changes can be verified by executing the previously created `displayJavaPluginConvention`
    task. After executing the task, you will find the output updated with new configurations:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些新更改都可以通过执行之前创建的`displayJavaPluginConvention`任务来验证。执行任务后，你会发现输出已更新为新的配置：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The custom plugin
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义插件
- en: In this section, we will discuss how to create a custom plugin. A plugin can
    be created by implementing the `org.gradle.api.Plugin<T>` interface. This interface
    has one method named `apply(T target)`, which must be implemented in the plugin
    class. Typically, we write a plugin for the Gradle projects. In that situation,
    T becomes the Project. However, T can be any type of object.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何创建自定义插件。可以通过实现`org.gradle.api.Plugin<T>`接口来创建插件。此接口有一个名为`apply(T
    target)`的方法，必须在插件类中实现。通常，我们为Gradle项目编写插件。在这种情况下，T变为Project。然而，T可以是任何类型的对象。
- en: 'The class that implements the plugin interface can be placed in various locations,
    such as:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 实现插件接口的类可以放置在多个位置，例如：
- en: The same build file
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的构建文件
- en: The `buildSrc` directory
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buildSrc`目录'
- en: A standalone project
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立项目
- en: This is similar to creating a custom task that we discussed in the last chapter.
    When we define a plugin in the same build file, the scope is limited to the defining
    project only. This means, this plugin cannot be reused in any other projects.
    This is not a good idea, if we want to distribute our plugin for other projects.
    For a multiproject Gradle build, the plugin code can be placed in the `buildSrc`
    folder of the root project or build file of the root project. All the subprojects
    will have access to this custom plugin. The most elegant way to create a plugin
    is to create a standalone Groovy project, create a jar file from it and share
    the plugin across projects and teams. Now, we will explore how to create a custom
    plugin with examples.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在上一章中讨论的创建自定义任务类似。当我们在一个构建文件中定义一个插件时，其作用域仅限于定义的项目。这意味着，此插件不能在其他任何项目中重用。如果我们想将我们的插件分发给其他项目，这并不是一个好主意。对于多项目Gradle构建，插件代码可以放置在根项目的`buildSrc`文件夹或根项目的构建文件中。所有子项目都将能够访问此自定义插件。创建插件最优雅的方式是创建一个独立的Groovy项目，从它创建一个jar文件，并在项目之间和团队之间共享插件。现在，我们将通过示例探索如何创建一个自定义插件。
- en: The build file
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建文件
- en: 'In the following example, we have added a `FilePlugin` class, which implements
    a Plugin interface in the build file. In the apply method, we have added two tasks,
    `copy` and `move`. These tasks are simple tasks, which print a line in the console.
    Now, we need to add this plugin to the build file if we want to execute the `copy`
    or `move` tasks. In this example, the plugin name is `FilePlugin`. We add this
    plugin using the `apply plugin` statement. Without adding the plugin, you will
    find `Could not find property ''copy'' on root project ''PROJECT_NAME''.` if you
    try to execute the copy task:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们添加了一个`FilePlugin`类，该类在构建文件中实现了Plugin接口。在apply方法中，我们添加了两个任务，`copy`和`move`。这些任务是简单的任务，它们在控制台打印一行。现在，如果我们想执行`copy`或`move`任务，我们需要将此插件添加到构建文件中。在这个例子中，插件名称是`FilePlugin`。我们使用`apply
    plugin`语句添加此插件。如果没有添加插件，当你尝试执行复制任务时，你会找到`Could not find property 'copy' on root
    project 'PROJECT_NAME'.`的错误信息：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'On executing the copy task (for the `Ch04_CustomPlugin1` project) from the
    command-line, we find the following two lines printed in the console as expected:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中执行复制任务（针对`Ch04_CustomPlugin1`项目）时，我们发现在控制台按预期打印出以下两行：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The buildSrc directory
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`buildSrc`目录'
- en: 'Similar to Task, to keep the plugin code separate from the build file, we can
    create a `buildSrc` folder inside the project root directory and any common code,
    task or plugin can be placed in this folder. In the following example, the Plugin
    is created in the `buildSrc` folder, which can be reused in the root build file
    and in all the subprojects. We have created a `FilePlugin.groovy` class under
    `buildSrc/src/main/groovy`. This class implements the plugin interface and adds
    two tasks: the `copy` task and the `move` task in the apply method. This `FilePlugin.groovy`
    class is similar to what we have done in the previous example. For this example,
    we will create a project `Ch04_CustomPlugin2`. Additionally, in the `FilePlugin.groovy`
    class, we need to add the package declaration and import statements (`import org.gradle.api.*`).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与任务类似，为了将插件代码与构建文件分开，我们可以在项目根目录内创建一个 `buildSrc` 文件夹，并将任何通用代码、任务或插件放置在这个文件夹中。在以下示例中，插件是在
    `buildSrc` 文件夹中创建的，它可以在根构建文件和所有子项目中重用。我们在 `buildSrc/src/main/groovy` 下创建了一个 `FilePlugin.groovy`
    类。这个类实现了插件接口，并在 `apply` 方法中添加了两个任务：`copy` 任务和 `move` 任务。这个 `FilePlugin.groovy`
    类与上一个示例中所做的工作类似。对于这个示例，我们将创建一个项目 `Ch04_CustomPlugin2`。此外，在 `FilePlugin.groovy`
    类中，我们需要添加包声明和导入语句（`import org.gradle.api.*`）。
- en: 'During build execution, this plugin class will be compiled automatically by
    Gradle and added to the classpath of the project. As the plugin definition is
    not in the build file, we need a mechanism to declare plugin information in the
    build file. This is done by importing the `Plugin` class and adding the plugin
    with the `apply plugin` statement. The following snippet shows the content of
    the main build file. In the file, additionally, we have added a `doLast` method
    in the `copy` task just for logging purposes:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建执行期间，此插件类将由 Gradle 自动编译并添加到项目的类路径中。由于插件定义不在构建文件中，我们需要一种机制在构建文件中声明插件信息。这是通过导入
    `Plugin` 类并使用 `apply plugin` 语句添加插件来实现的。以下代码片段显示了主构建文件的内容。此外，我们在 `copy` 任务中添加了一个
    `doLast` 方法，仅用于日志记录目的：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we create two subprojects: `project1` and `project2`. Each project has
    a simple build file. This build file is similar to the main build file. The build
    file imports and applies the `FilePlugin` and adds a `doLast` method to the `copy`
    task for logging. The content of `build.gradle` of `project1` is shown in the
    following code. The build file of `project2` is also similar to this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了两个子项目：`project1` 和 `project2`。每个项目都有一个简单的构建文件。这个构建文件与主构建文件类似。构建文件导入了并应用了
    `FilePlugin`，并将 `doLast` 方法添加到 `copy` 任务中用于日志记录。以下代码显示了 `project1` 的 `build.gradle`
    文件内容。`project2` 的构建文件也与此类似：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We need another `settings.gradle` file, which includes the subprojects in the
    main project:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要另一个 `settings.gradle` 文件，它包括主项目中的子项目：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Do not get confused with the `settings.gradle` file. We will discuss multiproject
    builds in detail in [Chapter 6](ch06.html "Chapter 6. Working with Gradle"), *Working
    with Gradle*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 不要与 `settings.gradle` 文件混淆。我们将在第 6 章“与 Gradle 一起工作”中详细讨论多项目构建。*与 Gradle 一起工作*。
- en: 'For convenience, the directory structure of the `Ch04_CustomPlugin2` project
    is displayed in Figure 4.2:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，`Ch04_CustomPlugin2` 项目的目录结构如图 4.2 所示：
- en: '![The buildSrc directory](img/B02000_04_02.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![构建Src目录](img/B02000_04_02.jpg)'
- en: Figure 4.2
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2
- en: 'When we execute the `copy` task, we find three copy tasks being executed: one
    from the main project and two other copy tasks from subprojects `project 1` and
    `project 2`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行 `copy` 任务时，我们发现有三个 `copy` 任务正在执行：一个来自主项目，另外两个来自子项目 `project 1` 和 `project
    2`。
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The Standalone project
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 独立项目
- en: In the last section, we placed the plugin code in the `buildSrc` directory and
    we used the plugin in the root build file and all the subprojects build files.
    It was just one step towards modularizing the plugin code from the build logic.
    However, this plugin is not reusable in other projects. Ideally, a plugin should
    be created in a standalone Groovy project. Then we create a JAR file and include
    that JAR file in the classpath of other build files. In this section, we will
    explore how to create a standalone plugin project.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们将插件代码放在了 `buildSrc` 目录中，并在根构建文件和所有子项目的构建文件中使用了该插件。这只是将插件代码模块化从构建逻辑中分离出来的一步。然而，此插件在其他项目中不可重用。理想情况下，插件应该在一个独立的
    Groovy 项目中创建。然后我们创建一个 JAR 文件，并将该 JAR 文件包含在其他构建文件的类路径中。在本节中，我们将探讨如何创建一个独立的插件项目。
- en: 'We will start by creating a simple Groovy project. We will add a plugin class
    `FilePlugin.groovy` and two tasks `CopyTask` and `MoveTask` in the `src/main/groovy`.
    We will also add a properties file in the resource folder. The snapshot of the
    project (`Ch04_CustomPlugin3`) is displayed in Figure 4.3:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个简单的Groovy项目开始。我们将在`src/main/groovy`中添加一个插件类`FilePlugin.groovy`和两个任务`CopyTask`和`MoveTask`。我们还会在资源文件夹中添加一个属性文件。项目的快照（`Ch04_CustomPlugin3`）显示在图4.3中：
- en: '![The Standalone project](img/B02000_04_03.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![独立项目](img/B02000_04_03.jpg)'
- en: Figure 4.3
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3
- en: The `FilePlugin.groovy` class creates two tasks named `copy` and `move` by referring
    to the `CopyTask` and `MoveTask` classes. These tasks are created by calling the
    `create(...)` method on the `TaskContainer` object with the `taskname` and `task`
    classes as method parameters. Both tasks extend `DefaultTask` and define their
    own implementation. This is just an example of creating a custom task that we
    learned about in the last chapter. We have created one more additional task `customTask`,
    which will print the `sourceFile` property value. The `sourceFile` property is
    defined using the extension object. Plugin extensions are plain old Groovy objects
    used to add properties to plugins. You can provide properties/configuration information
    to `Plugins` using `extension` objects. You can create more than one extension
    object in the plugin to group the related properties together. Gradle adds a configuration
    closure block for each extension object.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`FilePlugin.groovy`类通过引用`CopyTask`和`MoveTask`类创建了两个名为`copy`和`move`的任务。这些任务是通过在`TaskContainer`对象上调用`create(...)`方法，并将`taskname`和`task`类作为方法参数来创建的。这两个任务都扩展了`DefaultTask`并定义了自己的实现。这只是一个例子，展示了我们在上一章中学到的创建自定义任务的方法。我们创建了一个额外的任务`customTask`，它将打印`sourceFile`属性的值。`sourceFile`属性是通过扩展对象定义的。插件扩展是普通的Groovy对象，用于向插件添加属性。你可以使用`extension`对象向`Plugins`提供属性/配置信息。你可以在插件中创建多个扩展对象来将相关的属性分组在一起。Gradle为每个扩展对象添加一个配置闭包块。'
- en: 'The code snippet of the `FilePlugin.groovy` class is as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`FilePlugin.groovy`类的代码片段如下：'
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The following is the source code for the `AbstractTask`, `CopyTask`, `MoveTask`,
    and `extension` classes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码是`AbstractTask`、`CopyTask`、`MoveTask`和`extension`类的源代码。
- en: 'File: `AbstractTask.groovy`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：`AbstractTask.groovy`
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'File: `CopyTask.groovy`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：`CopyTask.groovy`
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'File: `MoveTask.groovy`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：`MoveTask.groovy`
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'File: `FilePluginRootExtension.groovy`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：`FilePluginRootExtension.groovy`
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we need a plugin ID so that Gradle can find this plugin information. This
    is done by creating a properties file under `src/main/resources/META-INF/gradle-plugins`.
    The name of the file becomes the plugin ID. In our example, we have named the
    file `fileplugin.properties`. So, the plugin ID is `fileplugin`. In any other
    build file, we can now apply the plugin as:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个插件ID，这样Gradle才能找到这个插件信息。这是通过在`src/main/resources/META-INF/gradle-plugins`下创建一个属性文件来完成的。文件名成为插件ID。在我们的例子中，我们给文件命名为`fileplugin.properties`。因此，插件ID是`fileplugin`。在任何其他构建文件中，我们现在可以应用这个插件，如下所示：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the `fileplugin.properties` file, we need to add the `implementation-class`
    property, which maps to the main plug in the implementing class:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在`fileplugin.properties`文件中，我们需要添加`implementation-class`属性，它映射到实现类中的主插件：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: That's all you need. Now, we can build this project to create a jar file and
    then we can use this jar in any other project. In our example, the jar file is
    named `Ch04_CustomPlugin3-1.0.jar`. If you wish to publish a plugin in [https://plugins.gradle.org/](https://plugins.gradle.org/),
    you need to make sure the plugin ID is unique. In such cases, you might want to
    rename `fileplugin.properties` to something like `mastering.gradle.ch4.properties`
    to ensure uniqueness of the plugin ID.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要的一切。现在，我们可以构建这个项目来创建一个jar文件，然后我们可以在任何其他项目中使用这个jar。在我们的例子中，jar文件被命名为`Ch04_CustomPlugin3-1.0.jar`。如果你希望将插件发布到[https://plugins.gradle.org/](https://plugins.gradle.org/)，你需要确保插件ID是唯一的。在这种情况下，你可能想要将`fileplugin.properties`重命名为类似`mastering.gradle.ch4.properties`的东西，以确保插件ID的唯一性。
- en: 'Once the jar file is created, the plugin can be used in any other build file.
    The code snippet shows how the `buildscript` closure can define a local directory
    as the repository. The plugin jar file can be included in the classpath by the
    dependencies closure. In the example, we are using the plugin from the local directory.
    Ideally, we should publish the plugin jar to a private or public repository and
    reference it via the Maven or Ivy URL:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了 jar 文件，该插件就可以在任何其他构建文件中使用。代码片段显示了如何通过 `buildscript` 闭包将本地目录定义为仓库。插件 jar
    文件可以通过依赖闭包包含在类路径中。在示例中，我们正在使用本地目录中的插件。理想情况下，我们应该将插件 jar 发布到私有或公共仓库，并通过 Maven 或
    Ivy URL 引用它：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We have added a `dolast` in the copy task, which prints the project name. Try
    to execute the following command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在复制任务中添加了一个 `dolast`，它打印项目名称。尝试执行以下命令：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'From the output, you can understand that the copy task has two statements.
    One we mentioned in plugin definition and the other we added in the `build.gradle`
    file. The output of the `customTask` prints the default value of the source file,
    which is `/home/tmp`. This value was set in the `FilePluginRootExtension.groovy`
    class. If you want to update the property to some other value, add the following
    configuration closure in the build file:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，你可以理解复制任务有两个语句。一个我们在插件定义中提到，另一个我们在 `build.gradle` 文件中添加。`customTask` 的输出打印了源文件的默认值，即
    `/home/tmp`。这个值是在 `FilePluginRootExtension.groovy` 类中设置的。如果你想将属性更新为其他值，请在构建文件中添加以下配置闭包：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After adding the preceding closure, try to execute the following command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加前面的闭包之后，尝试执行以下命令：
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, the output is changed to the new value mentioned in the `filePluginExtension`
    closure.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输出已更改为 `filePluginExtension` 闭包中提到的新的值。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we have mainly discussed two topics: the Java plugin and the
    custom plugin. In the Java plugin, we learned about the default convention and
    properties supported by Gradle. Then we discussed how to customize and configure
    these properties. In the custom plugin, we showed different ways to create a plugin.
    However, there are so many plugins to discuss in Gradle. We will be discussing
    a few important plugins in [Chapter 6](ch06.html "Chapter 6. Working with Gradle"),
    *Working with Gradle* and [Chapter 7](ch07.html "Chapter 7. Continuous Integration"),
    *Continuous Integration*. However, we will not be able to cover all the plugins
    in this book. We request readers to refer to the Gradle documentation for more
    details.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们主要讨论了两个主题：Java 插件和自定义插件。在 Java 插件中，我们学习了 Gradle 支持的默认约定和属性。然后我们讨论了如何自定义和配置这些属性。在自定义插件中，我们展示了创建插件的不同方法。然而，Gradle
    中有如此多的插件需要讨论。我们将在第 6 章 [Working with Gradle](ch06.html "第 6 章。使用 Gradle") 和第 7
    章 [Continuous Integration](ch07.html "第 7 章。持续集成") 中讨论一些重要的插件。然而，我们无法在本书中涵盖所有插件。我们请求读者查阅
    Gradle 文档以获取更多详细信息。
- en: In the next chapter, we will cover another important topic in Gradle, which
    is dependency management. We will learn about various repository configurations
    in the build file, different dependency resolution strategies, publishing artifacts
    in the repositories, and more.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍 Gradle 中的另一个重要主题，即依赖管理。我们将学习在构建文件中各种仓库配置、不同的依赖解析策略、在仓库中发布工件等内容。
