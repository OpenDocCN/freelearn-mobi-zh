- en: Chapter 4. Plugin Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we discussed Gradle task, which is the atomic unit of execution
    in Gradle. In most cases, a task provides only a single unit of work in modules.
    We can choose to bundle tasks together and execute them in a certain order to
    provide the complete functionality. This grouping of tasks along with properties
    and configuration is called a plugin. A plugin is the logical grouping of tasks,
    which may have a life cycle. You can configure plugins to alter the behavior based
    on the requirements. You can extend it to provide additional features. At a broader
    level, Gradle provides two types of plugins; script plugin and binary plugin.
    Gradle treats a build script as a script plugin and you can use other build scripts
    in a project by importing build scripts into the current project.
  prefs: []
  type: TYPE_NORMAL
- en: Binary plugins are plugins, that we create using programming languages such
    as Java or Groovy. Gradle provides in-built binary plugins for different build
    functionalities. There are different approaches to creating a binary plugin in
    Gradle, which we will discuss in the Custom Plugin section. First, we will explore
    the script plugin.
  prefs: []
  type: TYPE_NORMAL
- en: The script plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A script plugin is nothing but a Gradle file, which we import into other build
    files. It is the same as modularizing your code across different classes. When
    a build file size exceeds to a certain limit or diverse functionalities are clubbed
    to a single file, it might be a better option to divide the cohesive tasks into
    different build files. Then, you can import these files to the main build file
    to use the new functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: 'To import the build file you can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, the path could be a local file or a location relative to the project directory
    or a valid URL. However, if you mention the URL, the downside is that the file
    will be downloaded each time. Once the build file is imported, you can use the
    tasks defined in the build file without any additional configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are adding multiple build files in the main build file, make sure you
    do not have tasks with the same name in the imported build files. During import,
    if Gradle finds two tasks with the same name, it will throw the following exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following directory structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/Chapter4/scriptplugin.gradle`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`/Chapter4/build.gradle`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have defined the `scriptPluginTask1` in the `scriptplugin.gradle` file
    and have imported this build file in the main script `build.gradle`. Thus, importing
    the `scriptplugin.gradle` file into `build.gradle` will make `scriptPluginTask1`
    available in the main build file and you can call it directly without mentioning
    any build filename.
  prefs: []
  type: TYPE_NORMAL
- en: The binary plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Binary plugins are classes that implement the **Plugin** interface, which you
    can embed into the build script. Alternatively, you can create a separate project,
    package it into a jar file and add that jar file as a classpath entry to a project.
    The second approach makes it more reusable. Each binary plugin has one ID to uniquely
    identify it. To use a binary plugin, you need to include it using the `apply plugin`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to use the Java plugin, you can write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the class type to add plugins. For example, if you are creating
    a custom class, `DisplayPlugin`, as a plugin, you can apply the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Before using this approach make sure you import this class in the build file
    using the import statement. All the Gradle core plugins are available to you by
    default. You do not need any additional configuration to use them. For third-party
    or community plugins, you need to make sure they are available in the classpath
    before you use them. You can do this by adding the plugin in the classpath using
    the `buildscript{}` closure. When you apply any plugin to a build file, all the
    tasks that are part of the plugin are automatically added. You can directly use
    the task with the default configurations or you can customize the task configuration,
    if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Gradle's in-built plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gradle provides different in-built plugins to automate the build process. Gradle
    not only provides different plugins to build a project, but also provides plugins
    to test the project, for code analysis, for IDE support, for web container support,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The following are some of the frequently used plugins in different categories.
    You will find more details on core plugins in the Gradle documentation at [https://docs.gradle.org/current/userguide/userguide](https://docs.gradle.org/current/userguide/userguide).
  prefs: []
  type: TYPE_NORMAL
- en: Build and Test plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These plugins also support the testing features to execute Junit and TestNG
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: The Java plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Groovy plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Scala plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The War plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code analysis plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the code analysis plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: The Checkstyle plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The FindBugs plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Sonar plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Sonar Runner plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The PMD plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IDE plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are IDE plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: The Eclipse plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The IDEA plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are some of the frequently used plugins. Apart from the core plugins,
    you can also find third-party plugins at [https://plugins.gradle.org/](https://plugins.gradle.org/).
    It allows the publication of binary plugins with the support of the Gradle `Plugin
    Publishing` plugin. Consider spending some time learning how to publish a plugin
    and how to use the `Plugin Publishing` plugin. In the following chapters, we will
    learn a few core plugins. In the next section, we will explore the Java plugin.
  prefs: []
  type: TYPE_NORMAL
- en: The Java plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. Getting Started with Gradle"), *Getting
    Started with Gradle*, we already created a Java project called `FirstGradleProject`.
    However, the discussion was only limited to the Eclipse plugin tasks. We did not
    discuss anything about the Java plugin. The Java plugin is part of the Gradle
    core API, which enables us to build a Java project with supporting tasks such
    as compiling the Java code, testing the code, assembling binaries to create libraries,
    and more. It supports conventions over configuration. This means, if we use this
    plugin, some default configuration is already available to the developer, such
    as the location of the source code, the location of the compiled class file, and
    the jar naming convention. Unless we want to override these configurations, we
    do not need to write a lot of code to work with the default tasks and properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply the Java plugin, we add a single statement to the build file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Internally, the apply method of the Java plugin is invoked with the **project**
    object as the argument and the build script is enabled in order to use all the
    tasks and properties provided by the Java plugin. To understand the Java plugin,
    we will create a new Java application (project name `Ch04-Java1`) similar to the
    Java project `FirstGradleProject`, which we developed in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with Gradle"), *Getting Started with Gradle*. We will
    add two new classes, Customer and Order; we will also add a new JUnit or TestNG
    library dependency to support unit testing functionality for the project.
  prefs: []
  type: TYPE_NORMAL
- en: With the help of this example, we will explore different Java plugin conventions.
    To be precise, we will try to understand how different tasks work and which default
    conventions are supported by the Java plugin. Then, in the next section, we will
    learn how to customize different properties, so that we can create our own configuration
    in the build file.
  prefs: []
  type: TYPE_NORMAL
- en: Conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand conventions, let us start with the Java plugin tasks. Once we
    have applied the Java plugin to display all the available tasks in the project
    (project name `Ch04-Java1`), we can use the tasks command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output displays different build tasks, test tasks, documentation
    tasks, and other available tasks in the Java plugin. The output also shows the
    task dependencies between different tasks. For example, task classes internally
    depend on the `compileJava` and `processResources` tasks, which compile and process
    the source code and resources from `src/main/java` and `src/main/resources`, respectively.
    Similarly, the `compileTestJava` task and `processTestResources` task compile
    and process resources from `src/test/java` and `src/test/resources`, respectively.
    The output of all these tasks is compiled classes and resources, which will be
    created under the `build` directory by convention and will be added to the `classspath`
    during the execution of the program. Now, let us explore, with an example, what
    these tasks mean and which conventions are available by default.
  prefs: []
  type: TYPE_NORMAL
- en: To compile classes only under `src/main`, we should use the task classes. The
    compiled classes will be created under `build/classes/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `testClasses` task compiles and processes test classes and resources, and
    additionally, executes the classes task. In the following output, you can see
    that the `compileJava`, `processResources`, and `classes` tasks were executed
    again but the tasks were marked as `UP-TO-DATE`. This is because there was no
    change in the input and output of those tasks, as we have already executed the
    `classes` task in the last command. After successful execution, you will find
    a test directory created under the `build/classes` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The other important task is the `test` task. This task helps to execute unit
    test code written under the `src/test` directory. After successful execution,
    you will find the test results created under the `build/test-results` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You have the `assemble` task or the `jar` task to package classes and resources
    into a jar file. The `jar` task will only create jar files, whereas, the assemble
    task helps you to produce other artifacts, including jar. For example, when you
    apply the war plugin, the `jar` task is disabled and is replaced with the war
    task. By default, the JAR file is named `<project-name>.jar` and is created under
    `build/libs`. If you have not set the `<project-name>` in the build file, you
    will get the jar name `<project-folder-name>.jar`. This is not good practice if
    the jar file does not contain any version. You can add the version to the jar
    file by adding the version property to your project in the build file, which will
    generate `<name>-<version>.jar`. In our example, the project name is `Ch04-Java1`
    and the version property is set to `1.0` in the build file. Therefore, the jar
    file will be named `Ch04-Java1-1.0.jar`. Execute the following command and you
    will find the jar file under `build/libs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No test classes will be packaged in the JAR file.
  prefs: []
  type: TYPE_NORMAL
- en: Another task is the `build` task, which executes the `check` and `assemble`
    tasks together. The `clean` task deletes all the artifacts created by another
    task. It actually deletes the complete `build/` folder. This means, the `clean`
    task deletes the output generated by all the tasks, that is, `check` and `assemble`.
    To delete a task-specific output, we can apply the `clean<TaskName>` rule. For
    example, to delete only the jar file created by the `build` task, we can execute
    the `gradle cleanJar` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the tasks in the Java plugin execute based on conventions such as source
    directory location, build folder name, test result folder, and so on. To understand
    this in a better way, the following example shows some of the conventions supported
    by Gradle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The output displays various conventions supported by the Java plugin. You can
    find the complete list in the official Gradle documentation at [https://docs.gradle.org/current/userguide/java_plugin.html](https://docs.gradle.org/current/userguide/java_plugin.html).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, these default configurations might not suffice. We might need to
    configure some default properties to support our requirements. In the next section,
    we will explore how to configure some of the default configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous example, we learned about the default properties or conventions
    available in the Java plugin. Now, we will configure some of these properties.
    This is important when we want to change the build directory name, the libs folder
    name, or the source file location of the project.
  prefs: []
  type: TYPE_NORMAL
- en: The source- related configuration changes can be set in the `sourceSets` closure.
    The upcoming code snippet (project name `Ch04-Java2`) shows that the source code
    location has been modified from `src/main/java` to `src/productioncode` for the
    source code location and `src/test/java` to `src/testcode` for the test code location,
    respectively. As a result, compiled classes will now be stored in `classes/productioncode`
    and `classes/testcode` locations for the source and test code, respectively. This
    will not replace the source directory from `main` to `productioncode`, but Gradle
    will now look for source code in both `main` and `productioncode` directories
    and for test code in both `test` and `testcode` directories. If you want Gradle
    to look for the source code only in the `productioncode` directory, you can set
    the `java.srcDirs` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'These Java plugin conventions are written in the `JavaPluginConvention` and`BasePluginConvention`
    classes. One such property, `testResultsDirName`, can also be set in the `build`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: These changes will make sure that `buildfolder`, `libfolder`, and `test-result`
    folders have been replaced with `buildfolder`, `libfolder`, and `new-test-result`
    folders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.1 shows the directory structure of the `src` folder and new the `buildfolder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuration](img/B02000_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1
  prefs: []
  type: TYPE_NORMAL
- en: 'All these new changes can be verified by executing the previously created `displayJavaPluginConvention`
    task. After executing the task, you will find the output updated with new configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The custom plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss how to create a custom plugin. A plugin can
    be created by implementing the `org.gradle.api.Plugin<T>` interface. This interface
    has one method named `apply(T target)`, which must be implemented in the plugin
    class. Typically, we write a plugin for the Gradle projects. In that situation,
    T becomes the Project. However, T can be any type of object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class that implements the plugin interface can be placed in various locations,
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: The same build file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `buildSrc` directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A standalone project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is similar to creating a custom task that we discussed in the last chapter.
    When we define a plugin in the same build file, the scope is limited to the defining
    project only. This means, this plugin cannot be reused in any other projects.
    This is not a good idea, if we want to distribute our plugin for other projects.
    For a multiproject Gradle build, the plugin code can be placed in the `buildSrc`
    folder of the root project or build file of the root project. All the subprojects
    will have access to this custom plugin. The most elegant way to create a plugin
    is to create a standalone Groovy project, create a jar file from it and share
    the plugin across projects and teams. Now, we will explore how to create a custom
    plugin with examples.
  prefs: []
  type: TYPE_NORMAL
- en: The build file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following example, we have added a `FilePlugin` class, which implements
    a Plugin interface in the build file. In the apply method, we have added two tasks,
    `copy` and `move`. These tasks are simple tasks, which print a line in the console.
    Now, we need to add this plugin to the build file if we want to execute the `copy`
    or `move` tasks. In this example, the plugin name is `FilePlugin`. We add this
    plugin using the `apply plugin` statement. Without adding the plugin, you will
    find `Could not find property ''copy'' on root project ''PROJECT_NAME''.` if you
    try to execute the copy task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'On executing the copy task (for the `Ch04_CustomPlugin1` project) from the
    command-line, we find the following two lines printed in the console as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The buildSrc directory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to Task, to keep the plugin code separate from the build file, we can
    create a `buildSrc` folder inside the project root directory and any common code,
    task or plugin can be placed in this folder. In the following example, the Plugin
    is created in the `buildSrc` folder, which can be reused in the root build file
    and in all the subprojects. We have created a `FilePlugin.groovy` class under
    `buildSrc/src/main/groovy`. This class implements the plugin interface and adds
    two tasks: the `copy` task and the `move` task in the apply method. This `FilePlugin.groovy`
    class is similar to what we have done in the previous example. For this example,
    we will create a project `Ch04_CustomPlugin2`. Additionally, in the `FilePlugin.groovy`
    class, we need to add the package declaration and import statements (`import org.gradle.api.*`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'During build execution, this plugin class will be compiled automatically by
    Gradle and added to the classpath of the project. As the plugin definition is
    not in the build file, we need a mechanism to declare plugin information in the
    build file. This is done by importing the `Plugin` class and adding the plugin
    with the `apply plugin` statement. The following snippet shows the content of
    the main build file. In the file, additionally, we have added a `doLast` method
    in the `copy` task just for logging purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create two subprojects: `project1` and `project2`. Each project has
    a simple build file. This build file is similar to the main build file. The build
    file imports and applies the `FilePlugin` and adds a `doLast` method to the `copy`
    task for logging. The content of `build.gradle` of `project1` is shown in the
    following code. The build file of `project2` is also similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We need another `settings.gradle` file, which includes the subprojects in the
    main project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Do not get confused with the `settings.gradle` file. We will discuss multiproject
    builds in detail in [Chapter 6](ch06.html "Chapter 6. Working with Gradle"), *Working
    with Gradle*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For convenience, the directory structure of the `Ch04_CustomPlugin2` project
    is displayed in Figure 4.2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The buildSrc directory](img/B02000_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2
  prefs: []
  type: TYPE_NORMAL
- en: 'When we execute the `copy` task, we find three copy tasks being executed: one
    from the main project and two other copy tasks from subprojects `project 1` and
    `project 2`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The Standalone project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the last section, we placed the plugin code in the `buildSrc` directory and
    we used the plugin in the root build file and all the subprojects build files.
    It was just one step towards modularizing the plugin code from the build logic.
    However, this plugin is not reusable in other projects. Ideally, a plugin should
    be created in a standalone Groovy project. Then we create a JAR file and include
    that JAR file in the classpath of other build files. In this section, we will
    explore how to create a standalone plugin project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by creating a simple Groovy project. We will add a plugin class
    `FilePlugin.groovy` and two tasks `CopyTask` and `MoveTask` in the `src/main/groovy`.
    We will also add a properties file in the resource folder. The snapshot of the
    project (`Ch04_CustomPlugin3`) is displayed in Figure 4.3:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Standalone project](img/B02000_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3
  prefs: []
  type: TYPE_NORMAL
- en: The `FilePlugin.groovy` class creates two tasks named `copy` and `move` by referring
    to the `CopyTask` and `MoveTask` classes. These tasks are created by calling the
    `create(...)` method on the `TaskContainer` object with the `taskname` and `task`
    classes as method parameters. Both tasks extend `DefaultTask` and define their
    own implementation. This is just an example of creating a custom task that we
    learned about in the last chapter. We have created one more additional task `customTask`,
    which will print the `sourceFile` property value. The `sourceFile` property is
    defined using the extension object. Plugin extensions are plain old Groovy objects
    used to add properties to plugins. You can provide properties/configuration information
    to `Plugins` using `extension` objects. You can create more than one extension
    object in the plugin to group the related properties together. Gradle adds a configuration
    closure block for each extension object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code snippet of the `FilePlugin.groovy` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The following is the source code for the `AbstractTask`, `CopyTask`, `MoveTask`,
    and `extension` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'File: `AbstractTask.groovy`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'File: `CopyTask.groovy`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'File: `MoveTask.groovy`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'File: `FilePluginRootExtension.groovy`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need a plugin ID so that Gradle can find this plugin information. This
    is done by creating a properties file under `src/main/resources/META-INF/gradle-plugins`.
    The name of the file becomes the plugin ID. In our example, we have named the
    file `fileplugin.properties`. So, the plugin ID is `fileplugin`. In any other
    build file, we can now apply the plugin as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `fileplugin.properties` file, we need to add the `implementation-class`
    property, which maps to the main plug in the implementing class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: That's all you need. Now, we can build this project to create a jar file and
    then we can use this jar in any other project. In our example, the jar file is
    named `Ch04_CustomPlugin3-1.0.jar`. If you wish to publish a plugin in [https://plugins.gradle.org/](https://plugins.gradle.org/),
    you need to make sure the plugin ID is unique. In such cases, you might want to
    rename `fileplugin.properties` to something like `mastering.gradle.ch4.properties`
    to ensure uniqueness of the plugin ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the jar file is created, the plugin can be used in any other build file.
    The code snippet shows how the `buildscript` closure can define a local directory
    as the repository. The plugin jar file can be included in the classpath by the
    dependencies closure. In the example, we are using the plugin from the local directory.
    Ideally, we should publish the plugin jar to a private or public repository and
    reference it via the Maven or Ivy URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added a `dolast` in the copy task, which prints the project name. Try
    to execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'From the output, you can understand that the copy task has two statements.
    One we mentioned in plugin definition and the other we added in the `build.gradle`
    file. The output of the `customTask` prints the default value of the source file,
    which is `/home/tmp`. This value was set in the `FilePluginRootExtension.groovy`
    class. If you want to update the property to some other value, add the following
    configuration closure in the build file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding the preceding closure, try to execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, the output is changed to the new value mentioned in the `filePluginExtension`
    closure.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have mainly discussed two topics: the Java plugin and the
    custom plugin. In the Java plugin, we learned about the default convention and
    properties supported by Gradle. Then we discussed how to customize and configure
    these properties. In the custom plugin, we showed different ways to create a plugin.
    However, there are so many plugins to discuss in Gradle. We will be discussing
    a few important plugins in [Chapter 6](ch06.html "Chapter 6. Working with Gradle"),
    *Working with Gradle* and [Chapter 7](ch07.html "Chapter 7. Continuous Integration"),
    *Continuous Integration*. However, we will not be able to cover all the plugins
    in this book. We request readers to refer to the Gradle documentation for more
    details.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover another important topic in Gradle, which
    is dependency management. We will learn about various repository configurations
    in the build file, different dependency resolution strategies, publishing artifacts
    in the repositories, and more.
  prefs: []
  type: TYPE_NORMAL
