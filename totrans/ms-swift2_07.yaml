- en: Chapter 7. Writing Safer Code with Availability and Error Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I first started writing iOS and OS X applications with Objective-C, one
    of the most noticeable *deficiencies* was the lack of exception handling when
    working with the Cocoa and Cocoa Touch frameworks. Most modern programming languages
    such as Java and C# use `try-catch` blocks or something similar to handle exceptions.
    While Objective-C did have the `try-catch` block, it wasn't used within the Cocoa
    frameworks themselves and it never felt like a true part of the language. I do
    have significant experience with C, so I was able to understand how the Cocoa
    and Cocoa Touch frameworks received and responded to errors, and to be honest,
    I actually preferred this method, even though I had grown accustom to exception
    handling with Java and C#. When Swift was first introduced, I was hoping that
    Apple would put true error handling into the language, so we would have the option
    of using it; however, it was not in the initial release of Swift. Now with Swift
    2, Apple has added error handling to Swift. While this error handling may look
    similar to exception handling in Java and C#, there are some very significant
    differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use the `do-catch` block in Swift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to represent errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the availability attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error handling prior to Swift 2.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Error handling is the process of responding to and recovering from error conditions
    within our applications. Prior to Swift 2.0, error reporting followed the same
    pattern as Objective-C; however, with Swift, we did have the added benefit of
    using optional return values, where returning a nil would indicate an error within
    the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the simplest form of error handling, the return value from the function
    would indicate whether it was successful or not. This return value could be something
    as simple as a Boolean true/false value or something more complex such as an enum,
    whose values indicated what actually went wrong if the function was unsuccessful.
    If we needed to report additional information about the error that occurred, we
    could add an `NSError` out parameter of the `NSErrorPointer` type, but this wasn''t
    the easiest of approaches and these errors tended to be ignored by developers.
    The following example illustrates how errors were generally handled prior to Swift
    2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: While handling errors in this manner works well and can be modified to suit
    most needs, it definitely is not the perfect solution. There are a couple of issues
    with this solution, with the biggest being that it is easy for developers to ignore
    both the value that is returned and the error itself. While most experienced developers
    will be very careful to check all the errors, sometimes, it is hard for novice
    developers to understand what and when to check, especially if the function does
    not contain an `NSError` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to using `NSError`, we could also raise and catch exceptions using
    the `NSException` class; however, very few developers actually use this method.
    Even within the Cocoa and Cocoa Touch frameworks, this method of exception handling
    was rarely ever used.
  prefs: []
  type: TYPE_NORMAL
- en: While using the `NSError` class and return values to handle errors does work
    well, there were many people, including me, who were disappointed that Apple did
    not include additional error handling when Swift was originally released. Well,
    now with Swift 2.0, we do have native error handling.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling in Swift 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Languages such as Java and C# generally refer to the error handling process
    as *exception handling*; within the Swift documentation, Apple refers to this
    process as *error handling*. While on the outside, the Java and C# exception handling
    may look very similar to Swift's error handling, there are some significant differences
    that those familiar with exception handling in the other language will notice
    throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Representing errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can really understand how error handling works in Swift, we must first
    see how we would represent an error. In Swift, errors are represented by values
    of types that conform to the `ErrorType` protocol. Swift's enums are very well-suited
    to modeling the error conditions because generally, we have a finite number of
    error conditions to represent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how we would use an enum to represent an error. For this, we
    will define a fictitious error named `MyError` with three error conditions: `Minor`,
    `Bad`, and `Terrible`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we define that the `MyError` enum conforms to the `ErrorType`
    protocol. We then define the three error conditions: `Minor`, `Bad`, and `Terrible`.
    We can also use the associated values with our error conditions. Let''s say that
    we wanted to add a description to one of the error conditions; we would do it
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Those who are familiar with exception handling in Java and C# can see that representing
    errors in Swift is a lot cleaner and easier. Another advantage that we have is
    it is very easy to define multiple error conditions and group them together, so
    all the related error conditions are of one type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see how we would model errors in Swift. For this example, let''s
    look at how we would assign numbers to players in a baseball team. In a baseball
    team, every new player who is called up is assigned a unique number for that team.
    This number also must be within a certain range of numbers. In this case, we would
    have three error conditions: number is too large, number is too small, or number
    is not unique. The following example shows how we might represent these error
    conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With the `PlayerNumberError` type, we define three very specific error conditions
    that tell us exactly what was wrong. These error conditions are also grouped together
    in one type since they are all related to assigning player's numbers.
  prefs: []
  type: TYPE_NORMAL
- en: This method of defining errors allows us to define very specific errors that
    let our code know exactly what went wrong if an error condition occurs and, as
    we see in our example, it also lets us group our errors, so all of the related
    errors can be defined in the same type.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to represent errors, let's look at how we would throw errors.
  prefs: []
  type: TYPE_NORMAL
- en: Throwing errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an error occurs in a function, the code that called the function must be
    made aware of it; this is called **throwing the error**. When a function throws
    an error, it assumes that the code that called the function, or some code further
    up the chain, will catch and recover appropriately from the error.
  prefs: []
  type: TYPE_NORMAL
- en: To throw an error from a function we use the `throws` keyword. This keyword
    lets the code that called it know that an error may be thrown from the function.
    Unlike exception handling in other languages, we do not list the specific errors
    types that may be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since we do not list the specific error types that may be thrown from a function
    within the function's definition, it would be good practice to list them in the
    documentation and comment for the function so that other developers who use our
    function know what error types to catch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how we would throw errors, but first, let''s add a fourth error
    to our `PlayerNumberError` type that we defined earlier. This error condition
    is thrown if we are trying to retrieve a player by his or her number but no player
    is assigned that number. The new `PlayerNumberError` type will now look similar
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To demonstrate how to throw errors, we will begin by creating a `BaseballTeam`
    struct that will contain a list of player for a given team. These players will
    be stored in a dictionary object named `players` and will use the player''s number
    as the key. The `BaseballPlayer` type, which will be used to represent a single
    player, will be a `typealias` for a tuple type and is defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this `BaseballTeam` struct, we will have two methods. The first one will
    be named `addPlayer()`. This will have one parameter of the `BaseballPlayer` type
    and will attempt to add the player to the team. This method could throw one of
    the three error conditions: `NumberTooHigh`, `NumberTooLow`, or `NumberAlreadyExists`.
    Here is how we would write this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the method's definition, we see that the `throws` keyword is added. The `throws`
    keyword lets any code that calls this method know that it may throw an error and
    the errors must be handled. We then use the three `guard` statements. These `guard`
    statements are used to verify that the number is not too large, not too small,
    and is unique in the `players` dictionary. If any of the conditions are not met,
    we throw the appropriate error using the `throw` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: If we make it through all the three checks, the player is added to the `players`
    dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second method that we will be adding to the `BaseballTeam` struct is the
    `getPlayerByNumber()` method. This method will attempt to retrieve the baseball
    player that is assigned a given number. If no player is assigned that number,
    this method will throw a `PlayerNumberError.NumberDoesNotExist` error. The `getPlayerByNumber()`
    method will look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this method definition, we see that it can throw an error because we use
    the `throws` keyword within the definition. The `throws` keyword must be placed
    before the `return` type in the method definition.
  prefs: []
  type: TYPE_NORMAL
- en: Within the method, we attempt to retrieve the baseball player with the number
    that is passed into the method. If we are able to retrieve the player, we return
    it; otherwise, we throw the `PlayerNumberError.NumberDoesNotExist` error. Notice
    that if we throw an error from a method that has a `return` type, we do not need
    to return a value.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's see how we would catch an error with Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Catching errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When an error is thrown from a function, we need to catch it in the code that
    called the function; this is done using the `do-catch` block. The `do-catch` block
    takes the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If an error is thrown, it is propagated out until it is handled by a `catch`
    clause. The `catch` clause consists of the `catch` keyword, followed by a pattern
    to match the error against. If the error matches the pattern, the code within
    the `catch` block is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how we would use the `do-catch` block by calling both the `getPlayerByNumber()`
    and `addPlayer()` methods of the `BaseballTeam` struct. Let''s look at the `getPlayerByNumber()`
    method first since it only throws one error condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Within this example, the `do-catch` block calls the `getPlayerByNumber()` method
    of the `BaseballTeam` struct. This method will throw the `PlayerNumberError.NumberDoesNotExist`
    error condition if no player on the team has been assigned this number; therefore,
    we attempt to match that error in our `catch` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Anytime an error is thrown within a `do-catch` block, the remainder of the code
    within the block is skipped and the code within the `catch` block, which matches
    the error, is executed. Therefore, in our example, if the `PlayerNumberError.NumberDoesNotExist`
    error is thrown by the `getPlayerByNumber()` method, then the `print()` function
    is never reached.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do not have to include a pattern after the `catch` statement. If a pattern
    is not included after the `catch` statement or we put an underscore, the `catch`
    statement will match all error conditions. For example, either one of the following
    two `catch` statements will catch all errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to capture the error, we can use the `let` keyword, as shown in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s look at how we could use the `catch` statement, similar to a `switch`
    statement, to catch different error conditions. For this, we will call the `addPlayer()`
    method of our `BaseballTeam` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have three `catch` statements. Each `catch` statement has
    a different pattern to match; therefore, they will each match a different error
    condition. If we recall, the `PlayerNumberError.NumberToHigh` and `PlayerNumberError.NumberToLow`
    error conditions have associated values. To retrieve the associated value, we
    use the `let` statement within the parentheses, as shown in the example.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is always good practice to make your last `catch` statement an empty `catch`
    so that it will `catch` any error that did not match any of the patterns in the
    previous `catch` statements. Therefore, the previous example should be rewritten
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also let the errors propagate out rather than immediately catch them.
    To do this, we just need to add the `throws` keyword to the function definition.
    For instance, in the following example, rather than catching the error, we let
    it propagate out to the code that calls the function rather than handling the
    error within the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If we are certain that an error will not be thrown, we can call the function
    using a forced-try expression, which is written as `try`!. The forced-try expression
    disables error propagation and wraps the function call in a runtime assertion
    that no error will be thrown from this call. If an error is thrown, we will get
    a runtime error, so be very careful when using this expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'When I am working with exceptions in languages such as Java and C#, I see a
    lot of empty `catch` blocks. This is where we need to catch the exception because
    one might be thrown; however, we do not want to do anything with it. In Swift,
    the code would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Seeing code like this is one of the things that I dislike about exception handling.
    Well, the Swift developers have an answer for this: the `try?` keyword. The `try?`
    keyword attempts to perform an operation that may throw an error. If the operation
    succeeds, the results are returned in the form of an optional; however, if the
    operation fails with an error being thrown, the operation returns a nil and the
    error is discarded.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the results of the `try?` keyword are returned in the form of an optional,
    we would normally want to use this keyword with optional binding. We could rewrite
    the previous example like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the `try?` keyword makes our code much cleaner and easier to
    read.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need to perform some clean up action, regardless of if we had any errors
    or not, we can use the `defer` statement. We use the `defer` statement to execute
    a block of code just before code execution leaves the current scope. The following
    example shows how we would use the `defer` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If we called this function, the first line that is printed to the console is—`Function
    started`. The execution of the code would skip over the `defer` block and `Function
    finished` would be printed to the console next. Finally, the `defer` block of
    code would be executed just before we leave the function''s scope, and we would
    see the message, `In defer block`. The following is the output from this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `defer` block will always be called before execution leaves the current
    scope, even if an error is thrown. The `defer` block is very useful when we need
    to perform some clean up functions prior to leaving a function.
  prefs: []
  type: TYPE_NORMAL
- en: The `defer` statement is very useful when we want to make sure we perform all
    the necessary clean up, even if an error is thrown. For example, if we successfully
    open up a file to write to, we will always want to make sure we close that file,
    even if we have an error during the write operation. We could then put the file
    closed functionality in a `defer` block to make sure that the file is always closed
    prior to leaving the current scope.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at how we would use the new availability attribute with Swift.
  prefs: []
  type: TYPE_NORMAL
- en: The availability attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the latest SDK gives us access to all of the latest features for the platform
    that we are developing for; however, there are times when we want to also target
    older platforms. Swift allows us to use the availability attribute to safely wrap
    code to run only when the correct version of the operating system is available.
    The availability was first introduced in Swift 2.
  prefs: []
  type: TYPE_NORMAL
- en: The availability blocks essentially lets us say, "If we are running the specified
    version of the operating system or higher, run this code. Otherwise, run some
    other code." There are two ways in which we can use the `availability` attribute.
    The first way allows us to execute a specific block of code and can be used with
    an `if` or `guard` statement. The second way allows us to mark a method or type
    as available only on certain platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `availability` attribute accepts up to five comma-separated arguments that
    allow us to define the minimum version of the operating system or application
    extension needed to execute our code. These arguments are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`iOS`: This is the minimum iOS version that is compatible with our code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OSX`: This is the minimum OS X version that is compatible with our code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`watchOS`: This is the minimum watchOS version that is compatible with our
    code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iOSApplicationExtension`: This is the minimum iOS application extension that
    is compatible with our code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OSXApplicationExtension`: This is the minimum OS X application extension that
    is compatible with our code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After the argument, we specify the minimum version that is required. We only
    need to include the arguments that are compatible with our code. As an example,
    if we are writing an iOS application, we only need to include the `iOS` argument
    in the `available` attribute. We end the argument list with an `*` (asterisk).
    Let''s look at how we would execute a specific block of code only if we meet the
    minimum requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `if #available(iOS 9.0, OSX 10.10, watchOS 2, *)` line
    of code prevents the block of code form executing when the application is run
    on a system that does not meet the specified minimum operating system version.
    In this example, we also use the `else` statement to execute a separate block
    of code if the operating system did not meet the minimum requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also restrict access to a function or a type. In the previous code,
    the `available` attribute was prefixed with the `#` (pound) character. To restrict
    access to a function or type, we prefix the available attribute with an `@` (at)
    character. The following example shows how we would restrict access to a type
    and function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we specify that the `testAvailability()` function
    and the `testStruct()` type can only be accessed if the code is run on a device
    that has iOS version 9 or above. In order to use the `@available` attribute to
    block access to a function or type, we must wrap the code that calls that function
    or type with the `#available` attribute. The following example shows how we would
    call the `testAvailability()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `testAvailability()` function is only called if the application
    is running on a device that has iOS version 9 or above.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the new error-handling features and `availability`
    attribute that were added in Swift 2\. These two features can help us write safer
    code and make our applications more stable.
  prefs: []
  type: TYPE_NORMAL
- en: The error-handling feature of Swift 2 significantly changes the way Swift programmers
    handle errors. While we are not required to use this new feature in our custom
    types, it does give us a uniform manner to handle and respond to error. Apple
    has also started to use this error handling in the Cocoa and Cocoa Touch frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: The new `availability` attribute allows us to develop applications that take
    advantage of the latest features of our target operating systems while still allowing
    our applications to run on older versions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how to create and parse XML and JSON documents.
  prefs: []
  type: TYPE_NORMAL
