<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Using Optional Types</h1></div></div></div><p>When I first started using Swift, the concept that I had the most trouble with was optional types. Coming from an Objective-C, C, Java, and Python background, I was able to relate to most of Swift's features to how things worked in one of the other languages that I knew, but optionals were different. There really was nothing like optionals in the other languages that I used, so it took a lot of reading to fully understand them. While I briefly covered optionals in <a class="link" href="ch02.html" title="Chapter 2. Learning about Variables, Constants, Strings, and Operators">Chapter 2</a>, <em>Learning about Variables, Constants, Strings, and Operators</em>, which gave enough of an overview to get started with, we need to cover a lot more information to really understand what optionals are, how to properly use them, and why they are so important in the Swift language.</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An introduction to optional types</li><li class="listitem" style="list-style-type: disc">The need for optional types in Swift</li><li class="listitem" style="list-style-type: disc">Unwrapping an optional</li><li class="listitem" style="list-style-type: disc">Optional binding</li><li class="listitem" style="list-style-type: disc">Optional chaining</li></ul></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec67"/>Introducing optionals</h1></div></div></div><p>When we <a class="indexterm" id="id446"/>declare variables in Swift, they are, by default, non-optional, which means that they must contain a valid, non-nil value. If we try to set a non-optional variable to nil, it will result in a <code class="literal">Type '{type}' does not conform to protocol 'NilLiteralConvertible'</code> error, where <code class="literal">{type}</code> is the type of the variable. </p><p>For example, the following code will throw an error when we attempt to set the <code class="literal">message</code> variable to <code class="literal">nil</code> because <code class="literal">message</code> is a non-optional type:</p><div><pre class="programlisting">var message: String = "My String"
message = nil</pre></div><p>It is very important to understand that nil in Swift is very different from nil in Objective-C. In Objective-C, nil is a pointer to non-existent object; however, in Swift, nil is the absence of a value. This concept is very important to fully understand optionals in Swift.</p><p>A variable defined as an optional can contain a valid value or it can indicate an absence of a value. We indicate an absence of a value by assigning it a special nil value. Optionals of any type can be set to nil, whereas in Objective-C, only objects can be set to nil.</p><p>To really understand the concept behind optionals, let's look at a line of code that defines an optional:</p><div><pre class="programlisting">var myString: String?</pre></div><p>The question mark at the end indicates that the <code class="literal">myString</code> variable is an optional. When we look at this code, it would be wrong to read this line of code as "the <code class="literal">myString</code> variable is a string type that is optional". We should actually read this line of code as "the <code class="literal">myString</code> variable is an optional type, which may contain a string type or may contain no value". The subtle difference between the two lines actually makes a big difference in understanding how optionals work.</p><p>Optionals <a class="indexterm" id="id447"/>are a special type in Swift. When we defined the <code class="literal">myString</code> variable, we actually defined it as an optional type. To understand this, let's look at some more code:</p><div><pre class="programlisting">var myString1: String?
var myString2: Optional&lt;String&gt;</pre></div><p>These two declarations are equivalent. Both lines declare an optional type that may contain a string type or may be absent of a value. In Swift, we can think of the absence of a value as being set to nil, but always remember that this is different than setting something to nil in Objective-C. In this book, when we refer to nil, we are referring to how Swift uses nil and not how Objective-C uses nil.</p><p>The optional type is an enumeration with two possible values, <code class="literal">None</code> and <code class="literal">Some(T)</code>, where <code class="literal">T</code> is the associated value of the appropriate type. If we set the optional to <code class="literal">nil</code>, then it will have a value of <code class="literal">None</code>, and if we set a value, then the optional will have a value of <code class="literal">Some</code> with an associated value of the appropriate type. In <a class="link" href="ch02.html" title="Chapter 2. Learning about Variables, Constants, Strings, and Operators">Chapter 2</a>, <em>Learning about Variables, Constants, Strings, and Operators</em>, we explained that an enum in Swift may have associated values. Associated values allow us to store additional information along with the enum's member value.</p><p>Internally, an optional is defined as follows:</p><div><pre class="programlisting">enum Optional&lt;T&gt; {
  case None
  case Some(T)
}</pre></div><p>Here, <code class="literal">T</code> is the type to associate with the optional. The <code class="literal">T</code> symbol is used to define a generic. We can read more about generics in <a class="link" href="ch11.html" title="Chapter 11. Working with Generics">Chapter 11</a>, <em>Working with Generics</em>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec68"/>The need for optional types in Swift</h1></div></div></div><p>Now, the <a class="indexterm" id="id448"/>burning question is why does Swift need optionals? To understand why Swift has optionals, we should examine what problems optionals are designed to solve.</p><p>In most languages, it is possible to create a variable without giving it an initialized value. For example, in Objective-C, both lines of code are valid:</p><div><pre class="programlisting">int i;
MyObject *m;</pre></div><p>Now, let's say that the <code class="literal">MyObject</code> class has the following method:</p><div><pre class="programlisting">-(int)myMethodWithValue:(int)i {
    return i*2;
}</pre></div><p>This method takes the value passed in from the <code class="literal">i</code> parameter, multiplies it by 2, and returns the results. Let's try to call this method using the following code:</p><div><pre class="programlisting">MyObject *m;
NSLog(@"Value: %d",[m myMethodWithValue:5]);</pre></div><p>Our first thought might be that this code would display <code class="literal">Value: 10</code>; however, this would be wrong. In reality, this code would display <code class="literal">Value: 0</code> because we did not initialize the <code class="literal">m</code> object prior to using it.</p><p>When we forget to initialize an object or set a value for a variable, we can get unexpected results at runtime, as we just demonstrated. The unexpected results can be, at times, very difficult to track down.</p><p>With optionals, Swift is able to detect problems like this at compile time and alert us at runtime. If we expect a variable or object to always contain a value prior to using it, we will declare the variable as a non-optional (this is the default declaration). Then, at compile time, we would receive an error if we try to use it prior to initializing it. Let's look at an example of this. The following code would display an error at compile time because we are attempting to use a non-optional variable prior to initialize it:</p><div><pre class="programlisting">var myString: String
print(myString)</pre></div><p>If a variable is declared as an optional, it is good programming practice to verify that it contains a valid value before attempting to use it. We should only declare a variable as an optional if there is a valid reason for the variable to contain no value. This is the reason Swift declares variables a non-optional by default.</p><p>Now that we (hopefully) have a good understanding of what optionals are and what types of problems they are designed to solve, let's look at how to use them.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec115"/>Defining an optional</h2></div></div></div><p>Typically, to <a class="indexterm" id="id449"/>define an optional type, we put a question mark after the type in the variable declaration. Keep in mind that the type we define in the variable's declaration is actually the associated value in the optional enum. The following code shows us how we would typically declare an optional:</p><div><pre class="programlisting">var myOptional: String?</pre></div><p>This code declares an optional variable that might contain a string or no value (nil). When a variable is declared like this, by default, it is set to no value.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec116"/>Using optionals</h2></div></div></div><p>There are a <a class="indexterm" id="id450"/>number of ways that we can use optionals within our code. The key to using optionals is to always verify that they contain a valid value prior to accessing it. We use the unwrapping term to refer to retrieve the value of an optional.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec1116"/>Forced unwrapping an optional</h3></div></div></div><p>To<a class="indexterm" id="id451"/> unwrap or retrieve the value of an optional, we place an exclamation mark (<code class="literal">!</code>) after the variable name. Forced unwrapping, in this manner, can be very dangerous and should be used only if we are certain that the value is not nil.</p><p>When we use the exclamation mark to unwrap an optional, we are telling the compiler that we know the optional does not contain a nil value, so go ahead and give us the value. Let's look at how to do this:</p><div><pre class="programlisting">var myString1: String?
myString1 = "test"
var test: String = myString1!</pre></div><p>This code will work as we expect it to, where the <code class="literal">test</code> variable will contain the <code class="literal">test</code> string; however, if the line that set the <code class="literal">myString1</code> optional to <code class="literal">test</code> was removed, we would receive a runtime error when we run the application. Note that the compiler will not alert us of an issue because we are using the exclamation point to unwrap the optional; therefore, the compiler assumes that we know what we are doing and will happily compile the code for us. We should verify that the <code class="literal">myString1</code> optional contains a valid value prior to unwrapping it. The following example is one way to do this:</p><div><pre class="programlisting">var myString1: String?
myString1 = "test"
if myString1 != nil {
    var test:String = myString1!
}</pre></div><p>Now, if the line that sets the <code class="literal">myString1</code> optional to <code class="literal">test</code> was removed, we would not receive a runtime error because we are only unwrapping the <code class="literal">myString</code> optional, if it contains a valid (non-nil) value.</p><p>Unwrapping<a class="indexterm" id="id452"/> optionals, as we just described, is not the most optimal way, and it is not recommended that we unwrap optionals in this manner. We can combine the verification and unwrapping into one step called <strong>optional binding</strong>.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec1117"/>Optional binding</h3></div></div></div><p>Optional binding is<a class="indexterm" id="id453"/> the recommended way to unwrap an optional. With optional binding, we perform a check to see whether the optional contains a valid value and, if so, unwrap it into a temporary variable or constant. This is all performed in one step.</p><p>Optional binding is performed with the <code class="literal">if</code> or <code class="literal">while</code> conditional statements. It takes the following format if we want to put the value of the optional in a constant:</p><div><pre class="programlisting">if let constantName = optional {
   statements
}</pre></div><p>If we need to put the value in a variable, instead of a constant, we can use the <code class="literal">var</code> keyword instead of the <code class="literal">let</code> keyword, as shown in the following example:</p><div><pre class="programlisting">if var variableName = optional {
   statements
}</pre></div><p>The following example shows how to perform optional binding:</p><div><pre class="programlisting">var myString3: String?
myString3 = "Space"
if let tempVar = myString3 {
    print(tempVar)
} else {
    print("No value")
}</pre></div><p>In the example, we define the <code class="literal">myString3</code> variable as an optional type. If the <code class="literal">myString3</code> optional contains a valid value, then we set the new variable named <code class="literal">tempvar</code> to the value of the <code class="literal">myString3</code> optional and print the value to the console. If the <code class="literal">myString3</code> optional does not contain a value, then we print <code class="literal">No</code> value to the console.</p><p>Starting with Swift 1.2, we are able to use optional binding to unwrap multiple optionals within the same optional binding line. For example, if we had three optionals named <code class="literal">optional1</code>, <code class="literal">optional2</code> and <code class="literal">optional3</code>, we could use the following code to attempt to unwrap all the three at once:</p><div><pre class="programlisting">If let tmp1 = optional1, tmp2 = optional2, tmp3 = optional3 {
}</pre></div><p>If any of the <a class="indexterm" id="id454"/>three optionals failed to unwrap, the whole optional binding statement fails.</p><p>It is perfectly acceptable with optional binding to assign the value to a variable of the same name. The following code illustrates this:</p><div><pre class="programlisting">if let myOptional = myOptional {
  print(myOptional)
} else {
  print("myOptional was nil")
}</pre></div><p>One thing to note is that the <code class="literal">temp</code> variable is scoped only for the conditional block and cannot be used outside the conditional block. To illustrate the scope of the temporary variable, let's take a look at the following code:</p><div><pre class="programlisting">var myOptional: String?
myOptional = "test"
if var tmp = myOptional {
    print("Inside:  \(tmp)")
}
// This next line will cause a compile time error
print("Outside: \(tmp)")</pre></div><p>This code would not compile because the <code class="literal">tmp</code> variable is only valid within the conditional block and we are attempting to use it outside of the conditional block.</p><p>Using optional binding is a lot cleaner and easier than manually verifying that the optional has a value and then forcing the unwrapping of the optional.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec1118"/>Returning optionals from functions, methods, and subscripts</h3></div></div></div><p>We can set <a class="indexterm" id="id455"/>the return type of a function or a method to the optional type. This allows us to return a nil (no value) from the function or method. To set the return type to an optional type, we will insert a question mark after the name of the type<a class="indexterm" id="id456"/> in the function or method declaration.</p><p>The following <a class="indexterm" id="id457"/>example shows us how we will return an optional from a function or method:</p><div><pre class="programlisting">func getName(index: Int) -&gt; String? {
    let names = ["Jon", "Kim", "Kailey", "Kara"]
    if index &gt;= names.count || index &lt; 0 {
        return nil
    } else {
        return names[index]
    }
}</pre></div><p>In the <a class="indexterm" id="id458"/>example, we defined the return type as an optional that can be either a string value or no value. Inside the function, we will return the name if the index is within the bounds of the array, or <code class="literal">nil</code> if it is outside the bounds of the array.</p><p>The following <a class="indexterm" id="id459"/>code shows how to call this function where the return value is an optional:</p><div><pre class="programlisting">var name = getName(2)
var name2 = getName(5)</pre></div><p>In the <a class="indexterm" id="id460"/>previous code, the <code class="literal">name</code> variable will contain <code class="literal">Kailey</code>, while the <code class="literal">name2</code> variable will contain <code class="literal">nil</code> (no value). Note that we do not have to define the variable as an optional (with a question mark) since Swift knows it is an optional type because that is the return type defined by the function.</p><p>We can also define a subscript that returns an optional type. We define a subscript as an optional exactly like we defined functions. Here is an example template of a subscript that returns an optional:</p><div><pre class="programlisting">subscript(index: Int) -&gt; String? {
   //some statements
}</pre></div><p>With this definition, we are able to return a <code class="literal">nil</code> (no value) from our subscript.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec1119"/>Using optionals as a parameter in a function or method</h3></div></div></div><p>We can<a class="indexterm" id="id461"/> also accept an optional as a parameter to a function or a method. This allows us to have the option of passing a nil (no value) into a function or method if required. The following example shows how to define an optional parameter for a function:</p><div><pre class="programlisting">func optionalParam(myString: String?) {
  if let temp = myString {
    print("Contains value \(temp)")
  }
  else {
    print("Does not contain value")
  }
}</pre></div><p>To define a parameter as an optional type, we use the question mark within the parameter definition. Within <a class="indexterm" id="id462"/>this example, we use optional binding to check whether the optional contains a value or not. If it contains a value, we print <code class="literal">Contains value to the console;</code> otherwise, we print <code class="literal">Does not contain value</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec11119"/>Optional types with tuples</h3></div></div></div><p>We <a class="indexterm" id="id463"/>can define a whole tuple as an optional or any of the elements within a tuple as an optional. It is especially useful to use optionals with tuples when we return a tuple from a function or method. This allows us to return part (or all) of the tuples as nil. The following example shows how to define a tuple as an optional, and also how to define individual elements of a tuple as an optional type:</p><div><pre class="programlisting">var tuple1: (one: String, two: Int)?
var tuple2: (one: String, two: Int?)</pre></div><p>The first line defines the whole tuple as an optional type. The second line defines the second value within the tuple as an optional, while the first value is a non-optional.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec69"/>Optional chaining</h1></div></div></div><p>Optional binding<a class="indexterm" id="id464"/> allows us to unwrap one optional at a time, but what would happen if we had optional types embedded within other optional types? This would force us to have optional binding statements embedded within other optional binding statements. There is a better way to handle this by using optional chaining. Before we look at optional chaining, let's see how this would work with optional binding:</p><div><pre class="programlisting">class Collar {
    var color: String
    init(color: String) {
        self.color = color
    }
}

class Pet {
    var name: String
    var collar: Collar?
    init(name: String) {
        self.name = name
    }
}

class Person {
    var name: String
    var pet: Pet?
    init(name: String) {
        self.name = name
    }
}</pre></div><p>In this <a class="indexterm" id="id465"/>example, we begin by defining a <code class="literal">Collar</code> class, which has one property defined. This property is named <code class="literal">color</code>, which is of the type string. We can see that the <code class="literal">color</code> property is not an optional; therefore, we can safely assume that it will always have a valid value.</p><p>Next, we define a <code class="literal">Pet</code> class that has two properties defined. These properties are named <code class="literal">name</code> and <code class="literal">collar</code>. The <code class="literal">name</code> property is of the string type and the <code class="literal">collar</code> property is an optional that may contain a <code class="literal">Collar</code> type object.</p><p>Finally, we define the <code class="literal">Person</code> class that also has two properties. These properties are named <code class="literal">name</code> and <code class="literal">pet</code>. The <code class="literal">name</code> property is of the string type and the <code class="literal">pet</code> property is an optional that may contain a <code class="literal">Pet</code> type object.</p><p>For the examples that follow, let's use the following code to initialize the classes:</p><div><pre class="programlisting">var jon = Person(name: "Jon")
var buddy = Pet(name: "Buddy")
jon.pet = buddy
var collar = Collar(color: "red")
buddy.collar = collar</pre></div><p>Now, let's say that we want to get the color of the collar for a person's pet; however, the person may not have a pet (the <code class="literal">pet</code> property is <code class="literal">nil</code>) or the pet may not have a collar (the <code class="literal">collar</code> property is <code class="literal">nil</code>). We could use optional binding to drill down through each layer, as shown in the following example:</p><div><pre class="programlisting">if let tmpPet = jon.pet, tmpCollar = tmpPet.collar {
   print("The color of the collar is \(tmpCollar.color)")
  }
else {
    print("Cannot retrieve color")
}</pre></div><p>While this example is perfectly valid and would print out the message, <code class="literal">The color of the collar is red</code>, the code is rather messy and hard to follow because we have optional binding statements embedded within other optional binding statements.</p><p>Optional chaining allows us to drill down through multiple optional type layers of properties, methods, and subscripts in one line of code. These layers can be chained together and if any layer returns a <code class="literal">nil</code>, the entire chain gracefully fails and returns nil. If none of the values return <code class="literal">nil</code>, the last value of the chain is returned. Since the results of optional chaining may be a <code class="literal">nil</code> value, the results are always returned as an optional type, even if the final value we are retrieving is a non-optional type.</p><p>To specify <a class="indexterm" id="id466"/>optional chaining, we will place a question mark (<code class="literal">?</code>) after each of the optional values within the chain. The following example shows how to use optional chaining to make the preceding example much cleaner and easier to read:</p><div><pre class="programlisting">if let color = jon.pet?.collar?.color {
    print("The color of the collar is \(color)")
} else {
    print("Cannot retrieve color")
}</pre></div><p>In this example, we put a question mark after the <code class="literal">pet</code> and <code class="literal">collar</code> properties to signify that they are of the optional type and if either value is <code class="literal">nil</code>, the whole chain will return <code class="literal">nil</code>. This code would also print out the message, <code class="literal">The color of the collar is red</code>; however, it is much easier to read than the preceding example that used optional binding.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec117"/>The nil coalescing operator</h2></div></div></div><p>The<a class="indexterm" id="id467"/> nil coalescing operator is similar to the ternary operator that we discussed in <a class="link" href="ch02.html" title="Chapter 2. Learning about Variables, Constants, Strings, and Operators">Chapter 2</a>, <em>Learning about Variables, Constants, Strings, and Operators</em>, of this book. The ternary operator assigns a value to a variable, based<a class="indexterm" id="id468"/> on the evaluation of a comparison operator or a Boolean value. The nil coalescing operator unwraps an optional, and if it contains a value, it will return that value, or a default value if the optional is <code class="literal">nil</code>.</p><p>Let's look at a prototype for the nil coalescing operator:</p><div><pre class="programlisting">optionalA ?? defaultValue</pre></div><p>In this example, we demonstrate the nil coalescing operator when the optional contains a nil and also when it contains a value:</p><div><pre class="programlisting">var defaultName = "Jon"

var optionalA: String?
var optionalB: String?

optionalB = "Buddy"

var nameA = optionalA ?? defaultName
var nameB = optionalB ?? defaultName</pre></div><p>In this example, we begin by initializing our <code class="literal">defaultName</code> variable to <code class="literal">Jon</code>. We then define two optionals that are named <code class="literal">optionalA</code> and <code class="literal">optionalB</code>. The <code class="literal">optionalA</code> variable will be set to <code class="literal">nil</code> while the <code class="literal">optionalB</code> variable is set to <code class="literal">Buddy</code>.</p><p>The nil coalescing operator is used in the final two lines. Since the <code class="literal">optionalA</code> variable contains a <code class="literal">nil</code>, the <code class="literal">nameA</code> variable<a class="indexterm" id="id469"/> will be set to the <a class="indexterm" id="id470"/>value of the <code class="literal">defaultName</code> variable, which is <code class="literal">Jon</code>. The <code class="literal">nameB</code> variable will be set to the value of the <code class="literal">optionalB</code> variable as it contains a value.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec70"/>Summary</h1></div></div></div><p>While the concept of optional types, as used in the Swift language, might seem a little foreign at first, the more you use them, the more they will make sense. One of the biggest advantages with optional types is we get additional compile time checks that alert us if we forget to initialize non-optionals prior to using them.</p><p>The one thing to take away from this chapter is the concept of what optionals are. To reinforce this concept, let's review a couple of paragraphs from this chapter.</p><p>It is very important to understand that nil in Swift is very different than nil in Objective-C. In Objective-C, nil is a pointer to a non-existent object; however, in Swift nil is an absence of a value. This concept is very important to fully understand optionals in Swift.</p><p>A variable defined as an optional can contain a valid value or it can be absent of a value. We set a variable to a valueless state by assigning it Swift's special nil value. Optionals of any type can be set to nil, whereas in Objective-C, only objects could be set to nil.</p><p>The optional type is an enumeration with two possible values, <code class="literal">None</code> and <code class="literal">Some (T)</code>, where <code class="literal">T</code> is the associated value of the appropriate type. If we set the optional to <code class="literal">nil</code>, it will have a value of <code class="literal">None</code>, and if we set a value, the optional will have a value of <code class="literal">Some</code> with an associated value of the appropriate type. In <a class="link" href="ch02.html" title="Chapter 2. Learning about Variables, Constants, Strings, and Operators">Chapter 2</a>, <em>Learning about Variables, Constants, Strings, and Operators</em>, we explained that an enum in Swift may have associated values. Associated values allow us to store additional information along with the enum's member value.</p></div></body></html>