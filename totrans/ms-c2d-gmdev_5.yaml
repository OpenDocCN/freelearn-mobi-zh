- en: Chapter 5. Creating Cool Content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you'll be learning how to implement the really complex, subtle
    game mechanics that not many developers do. This is what separates the good games
    from the great games. There will be many examples, tutorials, and code snippets
    in this chapter intended for adaption in your own projects, so feel free to come
    back at any time to look at something you may have either missed the first time,
    or are just curious to know about in general.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a table for scores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding subtle sliding to the units
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating movements on a Bézier curve instead of straight paths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depth perception via device tilting (and parallax scrolling)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three ways to create unit streamers or ghosts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Touchscreen controls versus D-pad adaptation (and why it matters so much to
    know this distinction)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A common theme for this chapter will be to show you how to take what seem like
    complex things and turn them into easy-to-code and easy-to-modify segments that
    you can implement in your own project (or projects).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, this chapter features things that won't go well with the book's project,
    and only the first two points in the preceding list are related to the game project,
    which has been slowly worked all this while. The rest are standalone sample projects
    with code designed in a modular fashion so that you can extract it for your own
    projects faster.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's strongly recommended to open the Chapter 5 code before working on the first
    two sections. A decent amount of code has been added and/or modified since the
    last chapter, and it was not talked about in this book. Therefore, you may get
    compilation errors should you try to follow along with the book without using
    the Chapter 5 project code. Thanks for understanding!
  prefs: []
  type: TYPE_NORMAL
- en: Adding a table for scores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because we want a way to show the user their past high scores, in the `GameOver`
    scene, we're going to add a table that displays the most recent high scores that
    are saved. For this, we're going to use `CCTableView`. It's still relatively new,
    but it works for what we're going to use it.
  prefs: []
  type: TYPE_NORMAL
- en: CCTableView versus UITableView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although `UITableView` might be known to some of you who've made non-Cocos2d
    apps before, you should be aware of its downfalls when it comes to using it within
    Cocos2d. For example, if you want a BMFont in your table, you can't add `LabelBMFont`
    (you could try to convert the BMFont into a TTF font and use that within the table,
    but that's outside the scope of this book).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you still wish to use a `UITableView` object (or any `UIKit` element for
    that matter), you can create the object like normal, and add it to the scene,
    like this (`tblScores` is the name of the `UITableView` object):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Saving high scores (NSUserDefaults)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we display any high scores, we have to make sure we save them. The easiest
    way to do this is by making use of Apple's built-in data preservation tool—NSUserDefaults.
    If you've never used it before, let me tell you that it's basically a dictionary
    with "save" mechanics that stores the values in the device so that the next time
    the user loads the device, the values are available for the app.
  prefs: []
  type: TYPE_NORMAL
- en: Also, because there are three different values we're tracking for each gameplay,
    let's only say a given game is better than another game when the total score is
    greater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, let''s create a `saveHighScore` method that will go through all
    the total scores in our saved list and see whether the current total score is
    greater than any of the saved scores. If so, it will insert itself and bump the
    rest down. In `MainScene.m`, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, call this method in the `endGame` method right before you transition
    to the next scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our high scores being saved, let's create the table to display
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's really simple to set up a `CCTableView` object. All we need to do is modify
    the `contentSize` object, and then put in a few methods that handle the size and
    content of each cell.
  prefs: []
  type: TYPE_NORMAL
- en: 'So first, open the `GameOverScene.h` file and set the scene as a data source
    for the `CCTableView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `initWithScoreData` method, create the header labels as well as
    initialize the `CCTableView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With the `CCTableView` object's data source being set to `self` we can add the
    three methods that will determine exactly how our table looks and what data goes
    in each cell (that is, row).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that if we don't set the data source, the table view's method will not
    be called; and if we set it to anything other than `self`, the methods will be
    called on that object/class instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'That being said, add these three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first method, `tableView:nodeForRowAtIndex:`, will format each cell based
    on which index it is. For now, we're going to color each cell in one of two different
    colors.
  prefs: []
  type: TYPE_NORMAL
- en: The second method, `tableViewNumberOfRows:`, returns the number of rows, or
    cells, that will be in the table view. Since we know there are going to be 20,
    we can technically type 20, but what if we decide to change that number later?
    So, let's stick with using the count of the array.
  prefs: []
  type: TYPE_NORMAL
- en: The third method, `tableView:heightForRowAtIndex:`, is meant to return the height
    of the row, or cell, at the given index. Since we aren't doing anything different
    with any cell in particular, we can hardcode this value to a fairly reasonable
    height of 40.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should be able to run the game, and when you lose, you'll
    be taken to the game over screen with the labels across the top as well as a table
    that scrolls on the right side of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's good practice when learning Cocos2d to just mess around with stuff to see
    what sort of effects you can make. For example, you could try using some ScaleTo
    actions to scale the text up from 0, or use a `MoveTo` action to slide it from
    the bottom or the side.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to see whether you can create a cool way to display the text right
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the table in place, let's get the data displayed, shall we?
  prefs: []
  type: TYPE_NORMAL
- en: Showing the scores
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have our table created, it's a simple addition to our code to get
    the proper numbers to display correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `nodeForRowAtIndex` method, add the following block of code right after
    adding the background color to the cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: And that's it! When you play the game and end up at the game over screen, you'll
    see the high scores being displayed (even the scores from earlier attempts, because
    they were saved, remember?). Notice the high score that is yellow. It's an indication
    that the score you got in the game you just played is on the scoreboard, and shows
    you where it is.
  prefs: []
  type: TYPE_NORMAL
- en: Although the `CCTableView` might feel a bit weird with things disappearing and
    reappearing as you scroll, we'll cover how to make that better in the next chapter
    on polishing our game. For now, let's get some *Threes!*—like sliding into our
    game.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're considering adding a `CCTableView` to your own project, the key takeaway
    here is to make sure you modify the `contentSize` and position properly. By default,
    the `contentSize` is a normalized `CGSize`, so from 0 to 1, and the anchor point
    is (0,0).
  prefs: []
  type: TYPE_NORMAL
- en: 'Plus, make sure you perform these two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the data source of the table view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the three table view methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With all that in mind, it should be relatively easy to implement a `CCTableView`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding subtle sliding to the units
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've ever played *Threes!* (or if you haven't, check out the trailer at
    [http://asherv.com/threes/](http://asherv.com/threes/), and maybe even download
    the game on your phone), you would be aware of the sliding feature when a user
    begins to make their move but hasn't yet completed the move. At the speed of the
    dragging finger, the units slide in the direction they're going to move, showing
    the user where each unit will go and how each unit will combine with another.
  prefs: []
  type: TYPE_NORMAL
- en: This is useful as it not only adds that extra layer of "cool factor" but also
    provides a preview of the future for the user if they want to revert their decision
    ahead of time and make a different, more calculated move.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s a side note: if you want your game to go really viral, you have to
    make the user believe it was their fault that they lost, and not your "stupid
    game mechanics" (as some players might say).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Think *Angry Birds*, *Smash Hit*, *Crossy Road*, *Threes!*, *Tiny Wings*… the
    list goes on and on with more games that became popular, and all had one underlying
    theme: when the user loses, it was entirely in their control to win or lose, and
    they made the wrong move.'
  prefs: []
  type: TYPE_NORMAL
- en: This unseen mechanic pushes players to play again with a better strategy in
    mind. And this is exactly why we want our users to see their move before it gets
    made. It's a win-win situation for both the developers and the players.
  prefs: []
  type: TYPE_NORMAL
- en: Sliding one unit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we can get one unit to slide, we can surely get the rest of the units to
    slide by simply looping through them, modularizing the code, or some other form
    of generalization.
  prefs: []
  type: TYPE_NORMAL
- en: 'That being said, we need to set up the `Unit` class so that it can detect how
    far the finger has dragged. Thus, we can determine how far to move the unit. So,
    open `Unit.h` and add the following variable. It will track the distance from
    the previous touch position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `touchMoved` method of `Unit.m`, add the following assignment
    to `previousTouchPos`. It sets the previous touch position to the touch-down position,
    but only after the distance is greater than 20 units:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once that''s in place, we can begin calculating the distance while the finger
    is being dragged. To do that, we''ll do a simple check. Add the following block
    of code at the end of `touchMoved`, after the end of the initial `if` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The assignment of `previousTouchPos` at the end will ensure that while the unit
    is being dragged, we continue to update the touch position so that we can determine
    the distance. Plus, the distance is calculated in only the direction in which
    the unit is being dragged (up and down are denoted by Y, and left and right are
    denoted by X).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the distance between finger drags being calculated, let''s
    push this into a function that will move our unit based on which direction it''s
    being dragged in. So, right after you''ve calculated `dist` in the previous code
    block, call the following method to move our unit based on the amount dragged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dividing the distance by `2` is optional. You may think the squares are too
    small, and want the user to be able to see their square. So note that dividing
    by `2`, or a larger number, will mean that for every 1 point the finger moves,
    the unit will move by 1/2 (or less) points.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that method call being ready, we need to implement it, so add the following
    method body for now. Since this method is rather complicated, it''s going to be
    added in parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we need to do is set up a variable to calculate the new *x*
    and *y* positions of the unit. We''ll call these `newX` and `newY`, and set them
    to the unit''s current position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to grab the position that the unit starts at, that is, the position
    the unit would be at if it was positioned at its current grid coordinate. To do
    that, we''re going to call the `getPositionForGridCoordinate` method from `MainScene`,
    (since that''s where the positions are being calculated anyway, we might as well
    use that function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''re going to move the `newX` or `newY` based on the direction in which
    the unit is being dragged. For now, let''s just add the up direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this if block, we're first going to add the distance to the `newY` variable
    (because we're going up, we're adding to Y instead of X). Then, we want to make
    sure the position is at most 1 square up. We're going to use the `gridWidth` (which
    is essentially the width of the square, assigned in the `initCommon` method).
    Also, we need to make sure that if they're bringing the square back to its original
    position, it doesn't go into the square beneath it.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s add the rest of the directions as else if statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will set the position of the unit based on the newly calculated
    *x* and *y* positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Running the game at this point should cause the unit you drag to slide along
    with your finger. Nice, huh? Since we have a function that moves one unit, we
    can very easily alter it so that every unit can be moved like this.
  prefs: []
  type: TYPE_NORMAL
- en: But first, there's something you've probably noticed a while ago (or maybe just
    recently), and that's the unit movement being canceled only when you bring your
    finger back to the original touch down position. Because we're dragging the unit
    itself, we can "cancel" the move by dragging the unit back to where it started.
    However, the finger might be in a completely different position, so we need to
    modify how the cancelling gets determined.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, in your `touchEnded` method of `Unit.m`, locate this if statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to the following, which will determine the unit''s distance, and
    not the finger''s distance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Yes, this means you no longer need the `touchPos` variable in `touchEnded` if
    you're getting that warning and wish to get rid of it. But that's it for sliding
    1 unit. Now we're ready to slide all the units, so let's do it!
  prefs: []
  type: TYPE_NORMAL
- en: Sliding all units
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have the dragging unit being slid, let's continue and make all the
    units slide (even the enemy units so that we can better predict our troops' movement).
  prefs: []
  type: TYPE_NORMAL
- en: First, we need a way to move all the units on the screen. However, since the
    Unit class only contains information about the individual unit (which is a good
    thing), we need to call a method in `MainScene`, since that's where the arrays
    of units are.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, we cannot simply call `[MainScene method]`, since the arrays are instance
    variables, and instance variables must be accessed through an instance of the
    object itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'That being said, because we know that our unit will be added to the scene as
    a child, we can use Cocos2d to our advantage, and call an instance method on the
    `MainScene` class via the parent parameter. So, in `touchMoved` of `Unit.m`, make
    the following change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Basically we've commented out (or deleted) the old method call here, and instead
    called it on our parent object (which we cast as a `MainScene` so that we know
    which functions it has).
  prefs: []
  type: TYPE_NORMAL
- en: 'But we don''t have that method created yet, so in `MainScene.h`, add the following
    method declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just in case you haven't noticed, the enum UnitDirection is declared in `Unit.h`,
    which is why `MainScene.h` imports `Unit.h`—so that we can make use of that enum
    in this class, and the function to be more specific.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then in `MainScene.m`, we''re going to loop through both the friendly and enemy
    arrays, and call the `slideUnitWithDistance` function on each individual unit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'However, that still isn''t functional, as we haven''t declared that function
    in the header file for the `Unit` class. So go ahead and do that now. Declare
    the function header in `Unit.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We're almost done.
  prefs: []
  type: TYPE_NORMAL
- en: We initially set up our `slideUnitWithDistance` method with a drag direction
    in mind. However, only the unit that's currently being dragged will have a drag
    direction. Every other unit will need to use the direction it's currently facing
    (that is, the direction in which it's already going).
  prefs: []
  type: TYPE_NORMAL
- en: To do that, we just need to modify how the `slideUnitWithDistance` method does
    its checking to determine which direction to modify the distance by.
  prefs: []
  type: TYPE_NORMAL
- en: But first, we need to handle the negatives. What does that mean? Well, if you're
    dragging a unit to the left and a unit being moved is supposed to be moving to
    the left, it will work properly, as x-10 (for example) will still be less than
    the grid's width. However, if you're dragging left and a unit being moved is supposed
    to be moving right, it won't be moving at all, as it tries to add a negative value
    x `-10`, but because it needs to be moving to the right, it'll encounter the left-bound
    right away (of less than the original position), and stay still.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram should help explain what is meant by "handling negatives."
    As you can see, in the top section, when the non-dragged unit is supposed to be
    going left by `10` (in other words, negative 10 in the *x* direction), it works.
    But when the non-dragged unit is going the opposite sign (in other words, positive
    `10` in the *x* direction), it doesn't.
  prefs: []
  type: TYPE_NORMAL
- en: '![Sliding all units](img/image00248.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To handle this, we set up a pretty complicated if statement. It checks when
    the drag direction and the unit's own direction are opposite (positive versus
    negative), and multiplies the distance by `-1` (flips it).
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this to the top of the `slideUnitWithDistance` method, right after you
    grab the `newX` and the original position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The logic of this if statement works is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose the unit is not being dragged. Also suppose that either the direction
    is positive and the drag direction is negative, or the direction is negative and
    the drag direction is positive. Then multiply by `-1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, as mentioned earlier, we just need to handle the non-dragged units.
    So, in every `if` statement, add an "or" portion that will check for the same
    direction, but only if the unit is not currently being dragged. In other words,
    in the `slideUnitWithDistance` method, modify your if statements to look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can run the game. Bam! All the units go gliding across the screen
    with our drag. Isn't it lovely? Now the player can better choose their move.
  prefs: []
  type: TYPE_NORMAL
- en: That's it for the sliding portion (as well as this project's portion of the
    chapter). The rest of this chapter is filled with some really amazing things,
    and you're encouraged to check them out, as they may be helpful to you in your
    current projects outside this book, or in a future project of your own.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The key to unit sliding is to loop through the arrays to ensure that all the
    units get moved by an equal amount, hence passing the distance to the `move` function.
  prefs: []
  type: TYPE_NORMAL
- en: Creating movements on a Bézier curve
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you don't know what a Bézier curve is, it's basically a line that goes from
    point A to point B over a curve. Instead of being a straight line with two points,
    it uses a second set of points called control points that bend the line in a smooth
    way. When you want to apply movement with animations in Cocos2d, it's very tempting
    to queue up a bunch of `MoveTo` actions in a sequence. However, it's going to
    look a lot nicer ( in both the game and the code) if you use a smoother Bézier
    curve animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a good example of what a Bézier curve looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating movements on a Bézier curve](img/image00249.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the red line goes from point P0 to P3\. However, the line is
    influenced in the direction of the control points, P1 and P2.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of using a Bézier curve
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s list a few examples where it would be a good choice to use a Bézier
    curve instead of just the regular `MoveTo` or `MoveBy` actions:'
  prefs: []
  type: TYPE_NORMAL
- en: A character that will perform a jumping animation, for example, in *Super Mario
    Bros*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A boomerang as a weapon that the player throws
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching a missile or rocket and giving it a parabolic curve
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tutorial hand that indicates a curved path the user must make with their finger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A skateboarder on a half-pipe ramp (if not done with Chipmunk)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are obviously a lot of other examples that could use a Bézier curve for
    their movement. But let's actually code one, shall we?
  prefs: []
  type: TYPE_NORMAL
- en: Sample project – Bézier map route
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, to make things go a lot faster—as this isn't going to be part of the
    book's project—simply download the project from the code repository or the website.
  prefs: []
  type: TYPE_NORMAL
- en: If you open the project and run it on your device or a simulator, you will notice
    a blue screen and a square in the bottom-left corner. If you tap anywhere on the
    screen, you'll see the blue square make an **M** shape ending in the bottom-right
    corner. If you hold your finger, it will repeat. Tap again and the animation will
    reset.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine the path this square takes is over a map, and indicates what route a
    player will travel with their character. This is a very choppy, very sharp path.
    Generally, paths are curved, so let's make one that is!
  prefs: []
  type: TYPE_NORMAL
- en: Here's the end result (tracked using the `CCMotionStreak` method described in
    the *Three ways to make unit streamers or "ghosts"* section of this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a screenshot that shows a very straight path of the blue square:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sample project – Bézier map route](img/image00250.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the Bézier path of the yellow square:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sample project – Bézier map route](img/image00251.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Curved M-shape
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open `MainScene.h` and add another `CCNodeColor` variable, named `unitBezier`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then open `MainScene.m` and add the following code to the init method so that
    your yellow block shows up on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `sendFirstUnit` method, add the lines of code that will reset
    the yellow block''s position as well as queue up the method to move the yellow
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, you''ll need to actually create the `sendSecondUnit` method, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The preceding method creates three Bézier configurations and attaches them to
    a `MoveTo` command that takes a Bézier configuration. The reason for this is that
    each Bézier configuration can take only two control points. As you can see in
    this marked-up screenshot, where each white and red square represents a control
    point, you can make only a U-shaped parabola with a single Bézier configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, to make three U-shapes, you need three Bézier configurations.
  prefs: []
  type: TYPE_NORMAL
- en: '![Curved M-shape](img/image00252.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, make sure that in the `touchBegan` method, you make the `unitBezier`
    stop all its actions (that is, stop on reset):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: And that's it! When you run the project and tap on the screen (or tap and hold),
    you'll see the blue square M-shape its way across, followed by the yellow square
    in its squiggly M-shape.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to adapt the Bézier `MoveTo` or `MoveBy` actions for your own project,
    you should know that you can create only one U-shape with each Bézier configuration.
    They're fairly easy to implement and can quickly be copied and pasted, as shown
    in the `sendSecondUnit` function.
  prefs: []
  type: TYPE_NORMAL
- en: Plus, as the control points and end position are just `CGPoint` values, they
    can be relative (that is, relative to the unit's current position, the world's
    position, or an enemy's position), and as a regular `CCAction`, they can be run
    with any `CCNode` object quite easily.
  prefs: []
  type: TYPE_NORMAL
- en: Depth perception via device tilting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Something that can increase the cool factor of your game without really changing
    the game is a depth-perception-like feel when the user tilts the device. This
    can be seen in games such as *Shadowmatic* and *Jump! Chump!*, the checklist *Wunderlist*,
    or a lock screen background image with **Perspective Zoom** set to **On**. Although
    it's subtle, it can make your game feel a lot more polished and increase user
    engagement, as it's just one more thing they'll find cool or interesting about
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a reminder, you cannot make use of device tilting/accelerometer in the simulator.
    It must be done on a physical device.
  prefs: []
  type: TYPE_NORMAL
- en: Here is *Shadowmatic* game's tilt effect seen on the menu. As you can see, it's
    a three-dimensional object, and the camera rotates around the object, as well
    as the shadows.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Depth perception via device tilting](img/image00253.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The second one is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Depth perception via device tilting](img/image00254.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The following is *Jump! Chump!* game's tilt effect seen in the game, where you
    can see the shadows of the main characters and enemies being shifted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Depth perception via device tilting](img/image00255.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The second one is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Depth perception via device tilting](img/image00256.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Isn't this parallax scrolling?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is similar, but slightly different from parallax scrolling. Parallax scrolling—if
    you're unfamiliar—is when there are multiple background layers and each moves
    across the screen at a different rate to create the feeling of a more realistic
    movement. Cocos2d even has something called `CCParallaxNode`, which basically
    allows different relative movement speeds among the node's children. As an example,
    suppose you add a background image, a middle-ground image, and a foreground image
    with different ratios. When you move the `CCParallaxNode` object, it will automatically
    move the children as per the ratio set by each individual child.
  prefs: []
  type: TYPE_NORMAL
- en: Parallax scrolling is similar because there will still be multiple layers moving
    around, and they will be moving slightly in one direction or another based on
    the tilt of the device. Thus, the user feels as if there are objects (buttons,
    for example) that are literally in front of others (the grass in the background,
    for example).
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin implementing some simple depth perception effects.
  prefs: []
  type: TYPE_NORMAL
- en: Sample project – depth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Download the `Depth` sample project from the code repository and run the project.
    You'll notice there are some background mountains, grass, and a few buttons that
    don't go anywhere. We're going to change this so that the buttons move around
    the screen to give a bit of depth.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the parallax node and adding the objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `MainScene.h`, add the the variables listed here, as well as import the
    CoreMotion framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `CCParallaxNode` is obvious. The `motionManager` is meant for tracking the
    accelerometer data, and `xFiltered` and `yFiltered` are going to be used as filters
    for the accelerometer so that it doesn't become too jittery.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the init method of `MainScene.m`, comment out the line that adds the
    `layoutbox` to the scene. Add the code that initializes the parallax node, adds
    the `layoutbox` to it, and adds the parallax node to the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re wondering what the ratio parameter is, it''s like what the comment
    says: for every one pixel that the parallax object is moved, it will move the
    child by that amount. For example, if the parallax node was moved 100 pixels to
    the left, and if the child has a ratio of 0.5, the child will move to the left
    by 50 pixels. Does this make sense? So, for our buttons, we want the ratio to
    be 1:1\. This means that, for every pixel the parallax node moves, the buttons
    will move by the same amount.'
  prefs: []
  type: TYPE_NORMAL
- en: Running the project now won't do anything, however, so let's get the accelerometer
    data going so that we can shift the menu buttons by tilting the device.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing the depth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the init method of `MainScene.m`, add the following block of code, which
    will set up the motion manager so that it can start collecting accelerometer data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'For the accelerometer to affect the parallax node''s position, we must create
    the `getAccelerometerData` method, and modify the position there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This method basically reads the accelerometer's data 60 times per second, sends
    it through a filter (if you want steadier movement, increase the K value, which
    we called `filterValue` in the preceding code, up to a maximum of 1), and assigns
    the parallax's position based on the filtered *x* and *y* values.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If this is the entirety of the effect you want in your own project, feel free
    to stop here. The key thing to note if you're using this in your own project is
    the fact that the parallax node affects every child's position based on the ratio
    it was given. Plus, if you're using the tilt mechanic, make sure you put a filter
    on the accelerometer data, or else it will be very jittery and actually hurt your
    game instead of helping it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we're going to equalize the parallax node so that the buttons aren't always
    being pushed up or off to the side.
  prefs: []
  type: TYPE_NORMAL
- en: Restoring equilibrium (calibrating to the new rotation)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After the user adjusts their phone to a new position, you would want to slowly
    bring their equilibrium to the way they're holding the device. For example, if
    they start with the device flat on a table, and then tilt it towards themselves
    by about 45 degrees, you will shift the items as necessary. You'll then need to
    slowly make the 45-degree position look the same as it did when it was flat.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is easy to do, as long as we have a variable to hold what the equilibrium
    is. To do so, open `MainScene.h` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: These two values will store the average of the last 100 `xFiltered` and `yFiltered`
    values recorded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then in `MainScene.m`, modify the three relevant lines in your `getAccelerometerData`
    method to look like what you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: At first, the math probably makes no sense, so let's go over it.
  prefs: []
  type: TYPE_NORMAL
- en: First, `avgXValue` and `avgYValue` calculate the average by slowly adding one
    point at a time to the average in an estimation sort of way. This is not 100 percent
    accurate in the true "average" sense, but it comes close enough. It's also slightly
    better to do it this way as it means less code, less memory, and faster execution.
    Since we're doing this 60 times per second, it's not entirely important to get
    an accurate average. Within a few seconds, you'll have hundreds of points that
    will get you close enough.
  prefs: []
  type: TYPE_NORMAL
- en: Second, the subtraction of `xFiltered`/`xFiltered` and `avgYValue`/`avgXValue`
    is done to slowly bring it back to the center. For example, if your `yFiltered`
    value is `-1`, and `avgYValue` is `0`, it will quickly jump down to its new position.
    But if the device is held at `-1` for long enough, `avgYValue` will come so close
    to `-1` that subtracting the two variables will yield a zeroed-out position, which
    is exactly what we want.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The key thing to note here if you are implementing the calibration effect into
    your own project is to subtract the two values. Whether you use a single-value
    calibration or a pseudo-average value (like what was used here), if you don't
    subtract the filtered *x* and *y* values, you won't see any change.
  prefs: []
  type: TYPE_NORMAL
- en: For slow calibration, the preceding method is the way to go. If you want instant
    calibration (for example, with a button that realigns when the user says so),
    simply store the single accelerometer value when the button is pressed rather
    than store the average value.
  prefs: []
  type: TYPE_NORMAL
- en: A quick scrolling example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we''re covering the topic of parallax scrolling, let''s quickly go over
    a simple example of parallax scrolling as it was intended. In `MainScene.m` (or
    the header; it doesn''t really matter), import the `GameScene.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `buttonPressed` method, add the following line of code. It will
    go to the game scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s add the `CCParallaxNode` to `GameScene.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `GameScene.m` file''s `init` method, set up the parallax node
    and add a few sprites to the node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Just in case you're wondering what `positionOffset` does, it moves the node
    to the position given as a parameter before any parallax ratios get applied. This
    is useful when first setting up your scene (just as we're doing here).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we want to enable touching, so we add this line to the `init` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'But first, we need to create a variable to hold the previous position the finger
    was at so that we know how far to move the parallax node. Therefore, in `GameScene.h`,
    add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the `touchBegan` and `touchMoved` methods so that the parallax
    node moves according to the `touchMoved` distance, while also making sure that
    the scrolling never goes beyond the bounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: From here onwards, you can run the project, and when you click on **Play**,
    you'll be taken to the game scene, which now has a (rather crude) set of background,
    middle-ground, and foreground elements. When you drag your finger across the screen,
    you'll notice the grass scrolling at the same speed while the mountains, trees,
    and sun all scroll at different speeds.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're implementing a parallax scrolling background in your own project,
    the key thing to note is the difference in ratios between the added objects. Once
    you have that squared away, all you have to do is move the parallax node with
    respect to a finger dragging, a character moving, or whatever.
  prefs: []
  type: TYPE_NORMAL
- en: Three ways to make unit streamers or "ghosts"
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've ever played games such as *Fruit Ninja*, *Blek*, *Jetpack Joyride*,
    or *Tiny Wings*, you've surely seen this effect. There's a position on the screen
    that generates something similar to stars, a slashing effect, smoke clouds, or
    a line following the finger.
  prefs: []
  type: TYPE_NORMAL
- en: Sample project – ghosts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go to the code repository and open the `Ghosts` project under the `Sample Projects`
    folder. If you run it, you will see just three labels as buttons that lead to
    mostly blank screens that don't really do anything. That's where you come in.
  prefs: []
  type: TYPE_NORMAL
- en: Here, you're going to learn how to make the effects that you just read. There
    are three general ways to go about making something like this. Let's go over each
    method, starting with the easiest and ending with the hardest.
  prefs: []
  type: TYPE_NORMAL
- en: Method 1 – particle systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Particle systems are basically sprites that are created en masse, such as a
    firework effect, a gushing water fountain, or a flickering candle. The difference
    between using a particle system and creating the sprites yourself is that particle
    systems generally allow only moving, scaling, rotation, and color changes. But
    for simple effects such as a smoke cloud, a particle system works just fine.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you wish to create your own particles for this sample project or any project
    of your own, as mentioned in [Chapter 1](part0014.xhtml "Chapter 1. Refreshing
    Your Cocos2d Knowledge"), *Refreshing Your Cocos2d Knowledge*, Particle Designer
    is a great tool for this purpose. You can manually create them in the code, but
    it's a lot easier and more efficient to create them visually using an editor such
    as Particle Designer.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `Ghosts` project opened in Xcode, open the `ParticleExampleScene.h`
    file and add a `CCParticleSystem` variable to the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then open `ParticleExampleScene.m` and add the particle system to the screen
    in the init method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The particle system used in the preceding code was created using Particle Designer,
    as mentioned at the beginning of this book. It uses a simple cloud-shaped image
    and has certain properties set to create the effect of fading out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in the `updateParticleSource` method, set the particle system''s source
    position so that as you drag your finger around the screen, the smoke starts in
    a different position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If you run the project at this point, you'll see that the smoke is constantly
    being generated, even after you take your finger off the screen. Although this
    doesn't mean much for this sample project, imagine you want a particle being displayed
    only if a user is in midair, or while a combo move is being performed. That being
    said, we need a way to stop and start the particle streaming on demand (in this
    case, when the user places or removes their finger).
  prefs: []
  type: TYPE_NORMAL
- en: 'Although Cocos2d does not have a method to begin a particle system, it''s very
    easy to add such a method. So, look up the project for `stopSystem`. In the `CCParticleSystemBase.h`
    file (which should be the first result in the search), add the following code
    above the `stopSystem` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `CCParticleSystemBase.m` file (the next result in the search),
    add this method so that you can start the particle system on demand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now go back to `ParticleExampleScene.m`, and in the `init` method, right after
    you''ve added the smoke particle to the scene, call the `stopSystem` method so
    that it''s not on the screen when the scene first starts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `stopSystem` method to the `touchEnded` method so that the particle
    system stops spawning new particles and lets the old particles die out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add a method call to the newly created `startSystem` method in the
    `touchBegan` method so that the particles begin streaming when a finger is on
    the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Running the project at this point will allow you to see the starting and stopping
    of a particle system that has already been created.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may be wondering how to adapt this for your own project. Once you have the
    particle system added to the screen, it's basically just a matter of updating
    the particle system's source position with the "start position." For example,
    you could have a rocket flying across the screen, and the rocket's position could
    be the start position.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's move on to a very similar-looking style that takes a little more code,
    but allows greater manipulation with the overall look of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Method 2 – sprites or nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although a particle system requires less code to get a similar effect, there
    are more things you can do when you create the sprite yourself and handle everything
    that happens to it. For example, you can make the sprite change color several
    times, set up crazy movement patterns, change images altogether, or apply other
    `CCAction` actions that the particle system can't do.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One example of something that a particle system can't do is shake mechanics.
    A simple way you can do this is by queuing up a sequence of `CCMove` actions to
    go in the various directions you want (generally, no more than a few points in
    any direction), and using a variable for the duration so that you can increase
    or decrease the speed based on the situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `Ghosts` project opened in Xcode, open the `SpriteExampleScene.m`
    file and add the following block of code to the `spawnStreamer` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This code will spawn a red heart (the image is white, but we've colored it red),
    shrink it down to a scale of `0` in half a second, and then remove it from the
    scene so that it doesn't create lag after running for a while.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the project and drag you finger around the screen, you'll see some
    beautiful hearts being created in a fluid manner. And that's it! The only reason
    it was mentioned that you'd probably have to use more code is that, the more you
    want to do with your streamer (ghost, phantom, or whatever), the more code it
    will take to get the effect you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'So say, for example, you want to make the sprites move along a Bézier curve,
    spin 360 degrees, and finally shrink down and disappear, while at the same time
    changing to a green heart. The code will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you wish to implement something like this within your own project, the key
    requirement is the `isStreaming` Boolean and the check within the update method.
    Everything else is straightforward and very similar to the particle method of
    changing the `startPosition`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's tackle the most unique method of all—the constant line that both
    *Fruit Ninja* and *Blek* have implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Method 3 – constant line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Constant line is the most advanced version of streamers. It's not really a particle,
    and therefore, it can't be made as a sprite creation either. Instead, we're going
    to use `CCMotionStreak` to create a slashing effect. `CCMotionStreak` is fairy
    simple to implement, as it only needs a position, an image, and a color.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `Ghosts` project opened in Xcode, open `ConstantLineExampleScene.h`
    and add a `CCMotionStreak` object to the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in `ConstantLineExampleScene.m`, create the streak and add it to the
    scene in the `init` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Here we're using the yellow color and the file named `blade.png`. You can use
    whichever image you want, but since we want a blade slashing effect, we're going
    to use the image that is shaped like a diamond to give the beginning and end a
    pointed edge.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in the `touchBegan` method, set the `CCMotionStreak` object''s position,
    and reset it so that when the users touch down again, it doesn''t connect the
    two lines (unless that''s what you want; in that case, you should not reset it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the `touchMoved` method, set the position so that every time the
    finger is dragged, the motion streak glides to the next position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: And that's it! If you run the project, go to the line example, and drag a finger
    around, you'll see the nice slashing effect. If you want to make the line bigger
    (or smaller), simply adjust the width in the initialization of `CCMotionStreak`.
    The same applies to the color, image, or even duration. However, it's not recommended
    to set the duration too high, as the motion streak might be a bit delayed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The key point to remember if you want to implement this style of streamer/ghost
    in your project is that `CCMotionStreak` relies on a position of something. So,
    if you want a streak on a spaceship, you have to update the motion streak''s position
    in the update function, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Touchscreen controls versus D-pad adaptation (and why it matters so much to
    know this distinction)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because we're coding for iOS, it's important to note the uniqueness of the device
    we're creating games for, that is, the touchscreen itself versus a plastic controller
    with joysticks and triggers that the user has in their hands. When creating games
    for iOS (or any smartphone device with a touchscreen), you must create the controls
    such that they feel natural and fluid on the device, as if the game never existed
    on another console.
  prefs: []
  type: TYPE_NORMAL
- en: Granted, it's understandable that some games are better suited for D-pad-style
    movement. However, there's always the accelerometer, swipe controls, or the way
    that Infinity Blade does it (using small buttons on the screen to block or dodge,
    and also using swipes across the center of the screen to attack with your sword).
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, there's no "how to program" section for the best controls, as
    it's all based on your individual game. For example, in this book's game, we don't
    tap a unit and then use a D-pad to tell the game which direction to send the unit
    in. Instead, we make use of the touch-and-drag feature of iOS and integrate that
    as part of our controls.
  prefs: []
  type: TYPE_NORMAL
- en: There are more good examples of touch-integrated controls later in this chapter,
    but first, let's go over what not to do.
  prefs: []
  type: TYPE_NORMAL
- en: Bad examples of iOS game controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following are some examples of some games that just basically took the controls
    they had on their console or PC version of the game and dumped them into the touchscreen,
    hoping it would work out for them.
  prefs: []
  type: TYPE_NORMAL
- en: '*Game Dev Story*: Although this is not a bad game on its own, the controls
    are completely menu driven and don''t feel as if they were created with a mobile
    in mind.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bad examples of iOS game controls](img/image00257.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '*Tomb Raider I*: Just based on the screenshots, it''s easy to see how complex
    the controls are and how little time the developers put into innovating their
    control scheme for the mobile platform.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bad examples of iOS game controls](img/image00258.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '*Duke Nukem 3D*: Again, just based on the following screenshot, you can understand
    what bad controls are being pointed out here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bad examples of iOS game controls](img/image00259.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '*Midway Arcade*: They could''ve done so much better when it comes to cycling
    through the mini-games and even the mini-games themselves. Some of the games feel
    mobile friendly, but the rest are just not pulling their weight.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bad examples of iOS game controls](img/image00260.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Great examples of touchscreen controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you'll find some games that, whether they started on console
    before or not, have some great controls on mobile. They exhibit everything beautiful
    about being able to code games for a handheld device with a touchscreen and an
    accelerometer.
  prefs: []
  type: TYPE_NORMAL
- en: First up is *Shadowmatic*; you drag the screen to rotate the objects, and tilting
    the device moves the camera so slightly that you really get a three-dimension-like
    feeling in this game.
  prefs: []
  type: TYPE_NORMAL
- en: '![Great examples of touchscreen controls](img/image00261.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Next is *Smash Hit*; not only does it spawn the metal balls where your finger
    touches but also the easy-to-press buttons cause no disruptions to the gameplay
    either.
  prefs: []
  type: TYPE_NORMAL
- en: '![Great examples of touchscreen controls](img/image00262.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: I can't forget *Angry Birds*, with its pinch-zoom, pullback mechanics, and easy-to-understand
    gameplay, all of which stem from great touchscreen controls.
  prefs: []
  type: TYPE_NORMAL
- en: '![Great examples of touchscreen controls](img/image00263.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's also *Temple Run*, integrating the swiping mechanics in every direction,
    making the user feel as if they're actually pushing their character in the particular
    direction.
  prefs: []
  type: TYPE_NORMAL
- en: '![Great examples of touchscreen controls](img/image00264.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Last but not least (as there are surely a lot more that also have great touchscreen
    controls) is *Blek*. I'm not even sure whether this game could exist outside a
    touchscreen environment because it's just so fluid!
  prefs: []
  type: TYPE_NORMAL
- en: '![Great examples of touchscreen controls](img/image00265.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to do a variety of things, from making a score
    table and previewing the next move, to making use of Bézier curves and creating
    unit streamers.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, if you ever need to come back to this chapter (or any other for that
    matter), don't hesitate to do so. The code was built with a copy-paste mindset,
    so it can be adapted for any project without much reworking (if it is required
    at all).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will enhance this game, which used only programmer art
    until now, so that it looks like something a team of 20 people spent months developing.
  prefs: []
  type: TYPE_NORMAL
