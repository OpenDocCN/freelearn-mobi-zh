- en: '*Chapter 19*: Ensuring App Quality with Tests'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In all of the chapters so far, the main focus has been code that ran as part
    of an app. The apps you have worked on are small and can easily be tested manually.
    However, this approach doesn't scale well if your apps become larger. This approach
    also doesn't scale if you want to verify lots of different user input, lots of
    screens, convoluted logic, or even if you're going to run tests on many different
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode comes with built-in testing tools. These tools allow you to write tests
    so you can make sure that all of the business logic for your app works as expected.
    More importantly, you can test that your user interface functions and behaves
    as intended in many different automated scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Many developers tend to shy away from testing and postpone it until the end
    of the project, or don't do it at all. The reason for this is that it's often
    pretty hard to figure out how to write proper tests. This is especially true if
    you're just starting out with testing. Lots of developers feel like large parts
    of the logic their tests validate are so obvious that writing tests for that logic
    just feels silly. When testing is not approached correctly, it can be more of
    a burden than a relief by being high-maintenance and not testing the essential
    areas of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter serves as an introduction to writing both logic and user interface
    tests using Xcode and its built-in tools. By the end of this chapter, you should
    be able to set up a robust suite of tests and understand how you can make use
    of the tools provided by Xcode to write better code that is testable and reliable.
    This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing logic with XCTest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing code for testability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the user interface with XCUITest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing logic with XCTest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is going to help you to discover the testing capabilities on iOS
    with `XCTest`. Even if you haven't written any tests before, you might have thoughts
    or ideas about it. To start testing code, you don't need to have a computer science
    degree or spend days studying the absolute best way to test your code. In fact,
    the chances are that you're already testing your code and you don't even know
    it.
  prefs: []
  type: TYPE_NORMAL
- en: So, what does it mean to test your code? That's what this section aims to make
    clear. First, you will read about the different types of tests you can write.
    Then, you'll learn what `XCTest` is and how you can set up a test suite for an
    app. Finally, you'll learn how to optimally test some actual code and how code
    can be refactored to make it more testable.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what it means to test code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you test your code, you're essentially making sure that certain input produces
    the desired output. A very basic example of a test would be to make sure that
    calling a method that increments its input by a given value produces the output
    you expect.
  prefs: []
  type: TYPE_NORMAL
- en: Any time you launch your application and perform any action within your app,
    you are testing some part of your code. Any time you print something to the console
    to verify that the expected value is printed, you are also testing your code.
    Once you think about testing this way, a concept that might have sounded hard
    before actually does not seem as complicated as you may have thought. So, if just
    by using your app, you are indeed testing it already, then, what should you write
    tests for? Let's see how to determine when to write a test for your code.
  prefs: []
  type: TYPE_NORMAL
- en: Determining which tests to write
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you start testing, it's often hard to decide what logic you want to test
    and what logic you don't want to test. Reasons for this could include certain
    logic being too trivial, too hard, or just not important enough to test. This
    statement implies that you do not have to test absolutely every line of code in
    your app, and that is intentional. Sometimes it's simply not reasonable to write
    tests for a certain part of your code. For instance, you don't have to test that
    `UIKit` behaves as it should; it's Apple's job to make sure that the frameworks
    they ship are bug-free.
  prefs: []
  type: TYPE_NORMAL
- en: Determining what to test is important, and the longer you defer deciding whether
    you will add tests for a particular piece of logic, the harder it will be to write
    tests for it. A simple rule of thumb is that you don't need to test Apple's frameworks.
    It's safe to assume that Apple makes sure that any code they ship is tested and
    if it contains bugs, there's not much you can do to fix it anyway. Moreover, you
    don't want your tests to fail where Apple's tests should have failed.
  prefs: []
  type: TYPE_NORMAL
- en: What you should at least test is the *call site* of your methods, structs, and
    classes. You can think of the call site as the methods that other objects use
    to perform tasks. It's a good practice to make anything that's not used by the
    call site of your objects private, meaning that outside code can't access that
    part of the code. We'll cover more on this later when you learn more about refactoring
    code to make it more testable.
  prefs: []
  type: TYPE_NORMAL
- en: You should also test code that you might consider too trivial to write tests
    for. These parts of your code are likely to receive the *too trivial* treatment
    in other parts of the development process too. This usually causes you and your
    coworkers to pay less and less attention to this trivial piece of code, and before
    you know it, a bug gets introduced that might not be spotted until the app is
    in the App Store. Writing trivial tests for trivial code takes very little time
    and saves you from minor oversights that could lead to massive complications.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few simple guidelines that you should follow when you write tests are the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Test trivial code**: This usually requires minimal effort.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test the call site of your objects**: These tests will ensure that your public
    APIs are consistent and work as expected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Don''t test Apple''s frameworks or any other dependencies**: Doing this is
    the responsibility of the framework vendor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you've determined what you should test, it's time to start writing the
    actual tests. However, if you've heard about testing before, you might have heard
    of terms such as integration tests, unit tests, sanity tests, and a couple of
    others. The next segment explains a couple of the most important and well-known
    types of testing.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the correct test type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you write tests, it''s often a good idea to ask yourself what kind of
    test you''re writing. The kind of test you want to write will typically guide
    you toward the way your test should be structured and scoped. Having tests that
    are well-scoped, structured, and focused will ensure that you''re building a stable
    test suite that properly tests your code without unintended side-effects that
    influence the quality of your test. Now let''s dive into the following types of
    tests: unit tests and integration tests.'
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Probably the most well-known type of test is the unit test. A lot of people
    call any other test they write a **unit test**, which is probably why this is
    such a well-known term for testing. Another reason for unit tests being so popular
    is that it's a very sensible test type.
  prefs: []
  type: TYPE_NORMAL
- en: A unit test is intended to make sure that an isolated object works as expected.
    This isolated object will usually be a class or struct, but it could just as well
    be a standalone method. It's important that unit tests do not rely on any other
    test or object. It's perfectly fine to set up an environment that has all the
    preconditions you need for your unit test, but none of this setup should be accidental.
    For instance, you shouldn't accidentally test other objects or depend on the order
    in which your tests are executed.
  prefs: []
  type: TYPE_NORMAL
- en: When you write a unit test, it's not uncommon to create instances of models
    that are stored in an array to represent a dummy database or fake REST APIs. Creating
    such a list of dummy data is done to ensure that a unit test does not fail due
    to external factors such as a network error. If your test should depend on certain
    external factors, you are probably writing an **integration test**.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An integration test ensures that a certain part of your code can integrate with
    other components of the system. Similar to unit tests, an integration test should
    never rely on other tests. This is important for any test you write. Whenever
    a test depends on certain preconditions, they must be set up within the test itself.
    If your test does depend on other tests, this dependency might not be obvious
    at first, but it can make your tests fail in weird and unexpected ways.
  prefs: []
  type: TYPE_NORMAL
- en: Because no test can depend on another test, integration tests require a little
    more setup than unit tests. For example, you might want to set up an API helper,
    fetch some data from the API, and feed it into a database. A test such as this
    verifies that the API helper can cooperate with the database layer. Both layers
    should have their separate unit tests to ensure they work in isolation while the
    integration test ensures that the database and API can work together. There are
    many other types of tests that you can write or learn about, but for now, integration
    tests and unit tests provide an excellent starting point.
  prefs: []
  type: TYPE_NORMAL
- en: Isolating tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Assumptions are a considerable risk when you're testing. Any time you assume
    anything about the environment you're testing in, your test is not reliable. If
    you're just getting into writing tests, it's tempting to make assumptions such
    as *I'm testing on the simulator and my test user is always logged in so my tests
    can be written under the assumption that a logged-in user exists*. This assumption
    makes a lot of sense to a lot of people, but what if one of your tests logs the
    current user out?
  prefs: []
  type: TYPE_NORMAL
- en: When this happens, a lot of your tests will fail due to assumptions that you
    made about the test environment. More importantly, these tests might fail even
    if the code they're testing works flawlessly.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned before, tests should test a single thing in your app. They should
    rely on as little outside code as possible, and they should be properly focused.
    A typical pattern that people use to structure their tests and improve reliability
    is the 3-As or AAA approach. The name of this pattern is short for Arrange, Act,
    and Assert. The following is an explanation of each *A*.
  prefs: []
  type: TYPE_NORMAL
- en: Arrange
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The arrange step is all about preparation. Make sure a logged-in user exists,
    populate the (in-memory) database, and create instances of your fake API or other
    helpers. You essentially arrange everything to be in place for your testing environment.
    Note that this step should not involve too much setup. If you find yourself writing
    a lot of code in the arrange step, your test might be too broad. Or the code you're
    testing relies on too many other pieces of code. You can't always avoid this,
    but if it happens, make sure you consider refactoring your code and test to keep
    the quality on par with what you're trying to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: Act
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the act step, you set everything for your test in motion. You call methods
    on the object you're testing, you feed it data, and you manipulate it. This is
    where you take your code for a proverbial spin. Don't perform too many actions
    in succession though; too many actions will lead to problems during the next step,
    assert.
  prefs: []
  type: TYPE_NORMAL
- en: Assert
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The final A in the 3-As approach is assert. During the assert step, you make
    sure that the state of the object you're testing is as you'd expect. Act and assert
    can be used multiple times in a single test. For instance, you might want to assert
    that doing something once places the object in a particular state and that doing
    it again places the object in another state. Or possibly that the state stays
    the same. Just as with the other two steps, if you're asserting a lot of things,
    or if you're acting and asserting over and over again in a test, the chances are
    that your test is too broad. This can't always be avoided, but long tests with
    a lot of acting and asserting are often an indication of testing too much at once.
  prefs: []
  type: TYPE_NORMAL
- en: Reading about testing can be quite dull, and it tends to get abstract quickly,
    so let's leave the theory for now. You will set up a test suite for an existing
    project in Xcode and start writing some tests, so all of the information you've
    taken in so far becomes a bit more tangible.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a test suite with XCTest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, you''ll work on a test suite for a new app: `Info.plist` file,
    and all the other files you would normally expect to find in a project. There''s
    also a JSON file in the project named `TriviaQuestions.json`. This file contains
    a couple of dummy questions that you can load by uncommenting a bit of code in
    `LoadTriviaViewController.swift`.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, `LoadTriviaViewController.swift` attempts to load questions from
    a non-existing web server. This is intentional, to demonstrate how one would normally
    set up a project like this. Since you don't have a web server at your disposal
    right now, you can swap out the dummy networking code for the JSON file to test
    this app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you write tests or perform any optimization, you must add a test target
    to the project. You add a test target in the same way you added extensions before.
    The only difference is that you select a different type of target. When adding
    a test target, you should pick the **iOS Unit Testing Bundle** template. The following
    screenshot shows the correct template you should select:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 19.1 – Adding a unit testing target'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_19.01_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 19.1 – Adding a unit testing target
  prefs: []
  type: TYPE_NORMAL
- en: After adding the target, Xcode adds a new folder to your project. If you choose
    the default name for the test target, it's called `MovieTriviaTests`. You should
    add all the tests you write for this project to the test target.
  prefs: []
  type: TYPE_NORMAL
- en: If you think about when you used files in multiple targets with extensions,
    you might expect that you would need to add all of the files you want to write
    tests for to both of the targets. Fortunately, this isn't the case. When you write
    tests, you can import the entire app as a testable target, enabling you to write
    tests for all of the code in the app target.
  prefs: []
  type: TYPE_NORMAL
- en: If you look inside the `MovieTriviaTests` folder that Xcode created when you
    added the unit test target, you'll find a single file called `MovieTriviaTests.swift`.
    This file contains a couple of hints about what tests should look like for your
    test suite. First of all, note that the test class inherits from `XCTestCase`.
    All of your test classes should inherit from this `XCTestCase` so they can be
    identified as a test.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the methods you''ll find in the test template is the `setUp()` method.
    This method is executed before every test in the file and helps you to fulfill
    the first stage of the AAA pattern in testing: Arrange. You use this method to
    ensure that all of the preconditions for your test are met. You could make sure
    that your user is logged in or that your database is populated with test data.
    Of course, the depth of your setup in this method depends on the unit of code
    for which you''re writing a test.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that there are two methods prefixed with `test` in the `test` class.
    These methods are executed as tests, and they are expected to perform the act
    and assert steps. The majority of the work should be performed in these test methods.
    Do note that it's often better to have multiple short test methods rather than
    a single test method that tests everything. The larger the methods, the harder
    it will be to maintain and debug your tests.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you'll find a `tearDown()` method. This method is intended to give
    you an opportunity to clean up after yourself. When you have inserted dummy data
    into your database, it's often desirable to remove this data when your tests have
    been completed. This will ensure a clean slate for the next test that runs, and
    it minimizes the chances of your first test accidentally influencing the second
    test that runs. As mentioned before, tests should never depend on other tests.
    This means that you also don't want to pollute other tests by leaving traces of
    previous tests.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `setUp()` and `tearDown()` should be specific to the unit you're testing.
    This means that you can't put all of your tests in a single class. Separating
    tests into several classes is a good thing. You should create a test class for
    every unit of code that you're testing. One test class should typically not test
    more than a single class or struct in your app. If you're writing an integration
    test, there might be more than one class involved in the test, but you should
    still make sure that you're only testing a single thing, which is the integration
    between the classes involved in the integration you're testing.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a test suite in place, let's see how you can write tests for
    the existing code in the **MovieTrivia** app and how the app can be refactored
    to be tested appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing code for testability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the project has a test target, it's time to start adding some tests
    to it. Before you add tests, you should determine what to test. Take some time
    to look at the app and the code and try to think of things to test. Assume that
    the app is finished and that the trivia questions are loaded from a server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the things you might have thought of to test are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Making sure that we can display the data we load from the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing that selecting the correct answer triggers the expected code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing that choosing a wrong answer triggers the expected code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring that the first question is displayed after we show the last one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing that the question index increments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you came up with most of the tests on this list, good job. You've successfully
    identified a lot of good test cases. But how do you test these cases? The project
    has been made hard to test intentionally, but let's see what tests can be written
    without refactoring the app right away.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the test class that Xcode has generated for you and create a new one
    called `LoadQuestionsTest`. Use the following bit of boilerplate code in this
    file''s implementation as a starting point for the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note the `@testable` import `MovieTrivia` line at the top of the file. This
    line imports the entire app target so you can access it in your tests. Before
    you implement the test body for `testLoadQuestions`, it's wise to think about
    what this method should test. If you look at the code in the app target, the trivia
    questions are loaded in the `viewDidAppear(_:)` method of `LoadTriviaViewController`.
    Once the questions are loaded, the app moves on to the next screen. An important
    detail is that the `triviaJSON` property on `LoadTriviaViewController` is set
    once the questions are loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Based on this information, you could write a test that creates an instance of
    `LoadTriviaViewController`, makes it appear, so the questions will load, and then
    waits until `triviaJSON` has a value to verify that the questions were successfully
    loaded. Writing a test that fits this description would involve many moving parts,
    way more than you should be comfortable with. `MovieTrivia` uses storyboards,
    so to obtain an instance of `LoadTriviaViewController`, the storyboard would have
    to be involved. This means that any changes or mistakes in the user interface
    would cause the logic test that checks whether data is loaded to fail. This is
    not desirable because this test should only verify whether it's possible to load
    data, not whether the user interface updates once the load completes.
  prefs: []
  type: TYPE_NORMAL
- en: This is a great moment to start refactoring some code and make it more testable.
    The first piece of code that should be revamped for testability is the question-loading
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the question loader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make `MovieTrivia` more testable, you should create a special helper that
    can load questions. The helper will go to the network and fetch the questions.
    Once the data is loaded, a callback is called to notify the object that initiated
    the request about the loaded questions. Because you already know that you're going
    to write tests for the new helper, you should think of a way to make sure that
    the helper works with both an offline and an online implementation, so the tests
    don't have to depend on an internet connection to work.
  prefs: []
  type: TYPE_NORMAL
- en: Because tests should rely on as few outside factors as possible, removing the
    networking layer from this test would be great. This means that the helper needs
    to be split into two parts. One part is the helper itself. The other part would
    be a data fetcher. The data fetcher should conform to a protocol that defines
    the interface that a data fetcher must have, so you can choose to inject either
    an online or offline fetcher into the helper.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the preceding explanation seems a little bit abstract and confusing to you,
    that''s OK. The following code samples will show you the process of separating
    the different helpers step by step. Add a new Swift file to the application target
    and call it `QuestionsLoader.swift`. Then add the following implementation to
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This struct defines a method to load questions with a callback. This is already
    nice and a lot more testable than before. You can now isolate the question loader
    and test it separated from the rest of the app. A test for the helper in its current
    state would look like the test shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding test creates an instance of `QuestionLoader` and sets up an expectation.
    An expectation is used when you expect something to happen in your test eventually.
    Since `QuestionLoader` loads its questions asynchronously, you can't expect the
    questions to be loaded by the time this test method is done executing. The callback
    that's called when the questions are loaded is used to fulfill the expectation
    in this test. To make sure that the test waits for the expectation to be fulfilled,
    `waitForExpectations(timeout:handler:)` is called after `loadQuestions(callback:)`.
    If the expectation isn't fulfilled within the 5-second timeout that is specified,
    the test fails.
  prefs: []
  type: TYPE_NORMAL
- en: Examine this test closely; you should be able to see all of the As (Arrange,
    Act, Assert) that you read about earlier. The first A, arrange, is where the loader
    and expectation are created. The second A, act, is when `loadQuestions(callback:)`
    is called. The final A, assert, is inside the callback. This test doesn't validate
    whether the data passed to the callback is valid, but you'll get to that later.
  prefs: []
  type: TYPE_NORMAL
- en: Separating the loader into its own object is great but it still has one problem.
    There is no way to configure whether it loads data from a local file or the network.
    In a production environment, the question loader would load data from the network,
    which would make the test for the question loader depend on the network as well.
  prefs: []
  type: TYPE_NORMAL
- en: This isn't ideal because a test that depends on the network might fail for reasons
    you can't control.
  prefs: []
  type: TYPE_NORMAL
- en: This can be improved by utilizing some protocol-oriented programming and the
    dependency-injection pattern. This means that you should define a protocol that
    defines the public API for a networking layer. Then you should implement a networking
    object in the app target that conforms to the protocol. `QuestionsLoader` should
    have a property that holds anything that conforms to the networking protocol.
    The test target should have its own object that conforms to the networking protocol
    so you can use that object to provide `QuestionsLoader` with mock data.
  prefs: []
  type: TYPE_NORMAL
- en: By setting the test up like this, you can take the entire networking logic out
    of the equation and arrange tests in such a way that the networking doesn't matter.
    The mock networking layer will respond with valid, reliable responses that can
    be used as test input.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking API responses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s common practice to mock API responses when you''re testing. In this segment,
    you will implement the mock API that was described before to improve the quality
    and reliability of the `MovieTrivia` test suite. Follow these steps to create
    a mock response to test your API:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s define the networking protocol. Create a new file in the app
    target and name it `TriviaAPIProviding`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The protocol only requires a single method. If you want to expand this app later,
    everything related to the Trivia API must be added to the protocol to make sure
    that you can create both an online version of your app and an offline version
    for your tests.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, create a file named `TriviaAPI` and add the following implementation
    to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, update the `QuestionsLoader` struct with the following implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The question loader now has an `apiProvider` that it uses to load questions.
    Currently, it delegates any load call over to its API provider, but you'll update
    this code soon to make sure that it converts the raw JSON data that the API returns
    to question models.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `viewDidAppear(_:)` method of `LoadTriviaViewController` as shown
    in the following code snippet. This implementation uses the loader struct instead
    of directly loading the data inside the view controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code is not only more testable but also a lot cleaner. The next
    step is to create the mock API in the test target so you can use it to provide
    the question loader with data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The JSON file in the app target should be removed from the app target and added
    to the test target. You can leave it in the app folder but make sure to update
    the `Target Membership` so the JSON file is only available in the test target.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now add a new Swift file named `MockTriviaAPI` to the test target and add the
    following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code fetches the locally stored JSON file from the test bundle. To determine
    the location of the JSON file, one of the test classes is used to retrieve the
    current bundle. This is not the absolute best way to retrieve a bundle because
    it relies on an external factor to exist in the test target. However, structs
    can't be used to look up the current bundle. Luckily, the compiler will throw
    an error if the class that is used to determine the bundle is removed so the compiler
    would quickly error and the mistake can be fixed. After loading the file, the
    callback is called, and the request has been successfully handled.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now update the test in `LoadQuestionsTest` so it uses the mock API as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s summarize what we have done here: We have defined our API as a protocol.
    By doing that and with dependency injection, we are now capable of creating a
    mock class to test the API. As long as our mock class conforms to that protocol,
    we can inject it anywhere we need the API.'
  prefs: []
  type: TYPE_NORMAL
- en: A lot of apps have way more complex interactions than the one you're testing
    now. When you get to implementing more complex scenarios, the main ideas about
    how to architect your app and tests remain the same, regardless of application
    complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Protocols can be used to define a common interface for certain objects. Combining
    this with dependency-injection as you did for `QuestionsLoader` helps to isolate
    the pieces of your code that you're testing, and it enables you to swap out pieces
    of code to make sure that you don't rely on external factors if you don't have
    to.
  prefs: []
  type: TYPE_NORMAL
- en: So far, the test suite is not particularly useful. The only thing that's tested
    at this point is whether `QuestionsLoader` passes requests on to the `TriviaAPIProviding`
    object and whether the callbacks are called as expected. Even though this technically
    qualifies as a test, it's much better also to test whether the loader object can
    convert the loaded data into question objects that the app can display.
  prefs: []
  type: TYPE_NORMAL
- en: Testing whether `QuestionsLoader` can convert JSON into a `Question` model is
    a test that's a lot more interesting than just testing whether the callback is
    called. A refactor such as this might make you wonder whether you should add a
    new test or modify the existing test.
  prefs: []
  type: TYPE_NORMAL
- en: If you choose to add a new test, your test suite will cover a simple case where
    you only test that the callback is called and a more complex case that ensures
    the loader can convert JSON data to models. When you update the existing test,
    you end up with a test that validates two things. It will make sure that the callback
    is called but also that the data is converted to models.
  prefs: []
  type: TYPE_NORMAL
- en: While the implications for both choices are similar, the second-choice sort
    of assumes that the callback will be called. You always want to limit your assumptions
    when writing tests and there's no harm in adding more tests when you add more
    features. However, if the callback does not get called, none of the tests will
    work. So, in this case, you can work with a single test that makes sure the callback
    is called and that the loader returns the expected models.
  prefs: []
  type: TYPE_NORMAL
- en: The test you should end up with will have a single expectation and multiple
    assertions. Writing the test like this makes sure that the expectation of the
    callback is fulfilled when the callback is called, and at the same time you can
    use assertions to ensure that the data that's passed to the callback is valid
    and correct.
  prefs: []
  type: TYPE_NORMAL
- en: By making `QuestionsLoader` create instances of a `Question` model rather than
    using it to return a dictionary of JSON data, it not only makes the test more
    interesting but also improves the app code by making it a lot cleaner. Right now,
    the app uses a dictionary of JSON data to display questions. If the JSON changes,
    you would have to update the view controller's code. If the app grows, you might
    be using the JSON data in multiple places, making the process of updating quite
    painful and error-prone. This is why it's a much better idea to use the `Codable`
    protocol to convert raw API responses to `Question` models. Using `Codable` objects
    means you can get rid of the JSON dictionaries in the view controllers, which
    is a vast improvement.
  prefs: []
  type: TYPE_NORMAL
- en: Using models for consistency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adding a question model to `MovieTrivia` involves quite a bit of refactoring.
    First, you must define the `Question` model. Let''s create and make use of our
    models instead of using JSON structs around the code. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Swift file named `Question` and add the following implementation
    to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Question` struct conforms to the `Codable` protocol.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Since the dummy JSON data contains a list of questions, you''ll want to define
    a `Codable` object that contains the response as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that the `Question` model and the response container are in place, a couple
    of changes must be made to the existing code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify the `typealias` in the `TriviaAPIProviding` protocol as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, update the implementation of the `TriviaAPI` for the `URLSession` callback
    in `loadTriviaQuestions(callback:)` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, update `MockTriviaApi` so it executes its callback with data instead
    of a JSON dictionary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `QuestionsLoadedCallback`  `typealias` in `QuestionsLoader` to the
    following definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And lastly, update the implementation for `loadQuestions(callback:)` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This wraps up the changes for the API. However, there still is some refactoring
    to be done in the view controllers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Rename the `triviaJSON` property on `LoadTriviaViewController` to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make sure you replace all occurrences of `triviaJSON` with the new `questions`
    array. Also, make sure you change the following line in `prepare(for:sender:)`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the preceding line to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `QuestionViewController`, change the type of `questions` to `[Question]`
    and remove the `triviaJSON` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, you can clear all of the JSON-related code from the guards in
    this class. You should be able to do this on your own since the compiler should
    guide you with errors. If you get stuck, look at the finished project in the code
    bundle.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you should be able to run the tests, and they should pass. To run your
    tests, click the `Question` models. To make sure this conversion worked, you can
    load the JSON file in the test, count the number of questions in the JSON file,
    and assert that it matches the number of questions in the callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `testLoadQuestions()` method as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This test loads the dummy JSON file and uses `XCTAssert` to make sure that more
    than zero questions were passed to the callback and that the number of questions
    in the JSON file matches the number of questions that were loaded.
  prefs: []
  type: TYPE_NORMAL
- en: '`XCTAssert` takes a Boolean expression and a description. If the assertion
    fails, the description is shown. Adding good descriptions will help you to quickly
    figure out which assertion in your test has made your test fail.'
  prefs: []
  type: TYPE_NORMAL
- en: This new version of the load-questions test is a small addition to the test
    suite but has vast consequences. By improving the test suite, you have improved
    the quality of the app because you can now prove that the question loader correctly
    transforms JSON into model objects. By adding model objects, you have improved
    the code in the view controllers as well. Instead of reading raw JSON, you are
    now reading properties from a model. And lastly, these changes have made your
    view controllers a lot cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you have learned how to create and use your own data models
    through your code. By doing so, your code is more consistent and easier to test
    (and maintain).
  prefs: []
  type: TYPE_NORMAL
- en: One more metric that has improved by refactoring your code is the amount of
    code that is covered by the test suite. You can measure the percentage of code
    your test suite covers with Xcode's built-in code coverage tracking. You'll learn
    how to use this tool next.
  prefs: []
  type: TYPE_NORMAL
- en: Gaining insights through code coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code coverage is a tool in Xcode that is used to gain insights into how much
    of your code you are testing with your test suite. It tells you exactly which
    parts of your code were executed during a test and which parts of your code were
    not. This is extremely useful because you can take focused action based on the
    information provided by code coverage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to enable the code coverage functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: To enable **Code Coverage**, open the scheme editor through the (**Product**
    | **Scheme**) menu:![Figure 19.2 – Editing scheme
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_19.02_B14717.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 19.2 – Editing scheme
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select **Test action** and make sure the **Gather coverage** checkbox on the
    **Options** tab is checked:![Figure 19.3 – Gather coverage option
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_19.03_B14717.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 19.3 – Gather coverage option
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can also press *Command + <* to open the scheme editor quickly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After doing this, close the scheme editor and run your tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This time, Xcode will monitor which parts of your code were executed during
    this test, and which parts weren't. This information can give you some good insights
    into which parts of your code could use some more testing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To see the coverage data, open the **Report navigator** in the left sidebar
    in Xcode. The rightmost icon in this sidebar represents the report navigator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 19.4 – Coverage option'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_19.04_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 19.4 – Coverage option
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several reports listed under your app name. If you select the **Coverage**
    report, the coverage report will open in the editor area in Xcode. You can see
    all the files in your app and the percentage of code in the file that''s covered
    by your tests. The following screenshot shows coverage for the **MovieTrivia**
    app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 19.5 – Coverage details'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_19.05_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 19.5 – Coverage details
  prefs: []
  type: TYPE_NORMAL
- en: The more a bar is filled, the more lines of code in that file or method were
    executed during your test. You'll notice that the `AppDelegate.swift` file is
    covered under the tests even though you haven't written any tests for it. The
    reason this happens is that the app must launch during the test to act as a host
    for the test suite. This means that parts of the code in `AppDelegate.swift` are
    actually executed during the test, and therefore Xcode considers it covered in
    the tests.
  prefs: []
  type: TYPE_NORMAL
- en: You can see which methods for a specific file were executed by clicking on the
    triangle next to the class name. This enables you to see exactly which parts of
    a file are tested and which parts aren't.
  prefs: []
  type: TYPE_NORMAL
- en: One last feature of code coverage that's worth mentioning is inline code coverage.
    Inline code coverage will show you how often a specific block of code has been
    executed during testing. This will give you code coverage insights right next
    to your code, without having to navigate to the report navigator. To enable this
    feature, open up your Xcode preferences and navigate to the **Text Editing** tab.
    Check the **Show iteration counts** checkbox at the bottom of the tab. If you
    open a file now, you'll see the iteration count for your code on the right side
    of the editor window.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the iteration count for the `loadQuestions(callback:)`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 19.6 – Show iteration counts'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_19.06_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 19.6 – Show iteration counts
  prefs: []
  type: TYPE_NORMAL
- en: Even though code coverage is a great tool for gaining insights into your tests,
    you shouldn't let it influence you too much. Regularly check the code coverage
    for your app and look for methods that are untested and are either easy to write
    tests for or should be tested because they contain important logic. Code coverage
    is also great for discovering parts of your code that should be tested but are
    hard to test because they're nested deep inside a view controller or are otherwise
    hard to reach.
  prefs: []
  type: TYPE_NORMAL
- en: You should always aim for as much code coverage as possible, but don't push
    yourself to reach 100%. Doing this will make you jump through all kinds of hoops,
    and you'll invest way more time in testing than you should. Not all paths in your
    code have to be tested. However, don't shy away from doing some refactoring. Proper
    testing helps you to avoid bugs and to structure your code better. Code coverage
    is just one extra tool in your tool belt to help identify which parts of your
    code could benefit from some tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the current state of the coverage in the `XCTest` can be quite
    hard and tedious. Luckily, there is one last testing tool that we''ll discuss
    in this chapter: `XCUITest`.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing the user interface with XCUITest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned how to test your code and the logic behind it. In this section,
    we are going to learn how to test the UI of your app with **XCUITest**.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing that most of your app logic is covered with tests is great. What's not
    so great, however, is adding your view controllers to your logic test. Luckily,
    you can use `XCUITest` to easily record and write tests that focus on the user
    interface of an app. `XCUITest` uses the accessibility features in iOS to gain
    access to the user interface of your app. This means that implementing user interface
    tests forces you to put at least a little bit of effort into accessibility for
    your applications. The better your app's accessibility is, the easier it will
    be to write UI Tests for.
  prefs: []
  type: TYPE_NORMAL
- en: '`XCUITest` has two great features that we''ll look at in greater detail. First
    of all, UI tests help you to enhance the accessibility of your apps. Secondly,
    it''s easy to get started with UI testing because Xcode can record your tests
    while you navigate through your app. This can significantly benefit the amount
    of code that is covered by your test suite since code coverage also takes UI tests
    into account.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we start recording our first UI test, let's have a quick look at accessibility.
  prefs: []
  type: TYPE_NORMAL
- en: Making your app accessible to your tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the lesser thoughts about features in iOS is accessibility. The design
    teams at Apple work hard to ensure that iOS is accessible for everybody. This
    includes blind people and people with other disabilities that could somehow affect
    the user's ability to operate their iOS device.
  prefs: []
  type: TYPE_NORMAL
- en: Just looking at the accessibility settings in the iOS Settings app makes it
    evident that this is a subject that Apple invests a lot of time in. If you're
    working on an app, Apple expects you to put in the same kind of effort. Doing
    this will be rewarded by more app downloads and if you're lucky, even a couple
    of great reviews. In their talk on iOS accessibility from WWDC 2015, Apple even
    mentioned that implementing accessibility features can be helpful if you ever
    want to be featured in the *App Store*. Only the best apps get featured by Apple,
    and if your app is accessible to all people, that significantly boosts your app's
    quality.
  prefs: []
  type: TYPE_NORMAL
- en: A common myth surrounding accessibility is that it's hard to implement or that
    it takes a lot of time. Some people even go so far as to say that it looks ugly
    or gets in the way of beautiful design. None of this is entirely correct. Sure,
    making your app accessible requires some effort, but the UIKit framework is very
    helpful when it comes to accessibility. Using standard components and keeping
    your users in mind while you design your app will make sure that your app is both
    accessible and looks good.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how does accessibility work on iOS? And how can we make sure our app is
    accessible? A fun way to experiment with this is to turn on **VoiceOver** on your
    device. Follow these steps to enable it:'
  prefs: []
  type: TYPE_NORMAL
- en: To enable **VoiceOver**, go to the **Accessibility** menu. You'll find several
    vision-related accessibility settings. **VoiceOver** should be the topmost one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To quickly enable and disable **VoiceOver**, scroll all the way to the bottom
    of the settings page and select **VoiceOver** as your accessibility shortcut:![Figure
    19.7 – Device Accessibility options
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_19.07_B14717.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 19.7 – Device Accessibility options
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This will allow you to toggle **VoiceOver** off and on by triple-clicking the
    home button or side button, depending on your device.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After enabling this, run the **MovieTrivia** app on your device and triple-click
    your home button or the side button to enable **VoiceOver**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Swipe around and try to use the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is how a person with a visual handicap would use your app. You won't get
    past the loading screen because the dummy questions aren't loaded, but you should
    find the splash screen to be pretty accessible, especially considering no special
    work had to be done to achieve this. UIKit uses great default settings to make
    sure your app will be accessible by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can set your own accessibility information through the **Identity Inspector**
    in Interface Builder. You can add custom labels, hints, identifiers, and traits
    to your interface to aid accessibility and, coincidentally, your UI tests. The
    following screenshot shows the **Accessibility** panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 19.8 – Accessibility options'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_19.08_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 19.8 – Accessibility options
  prefs: []
  type: TYPE_NORMAL
- en: For most UIKit interface elements, you won't have to touch these settings yourself.
    UIKit will make sure that your objects have sensible defaults that automatically
    make your app accessible. Now that you have a little bit of background information
    about accessibility, let's have a look at testing the app's (accessible) UI.
  prefs: []
  type: TYPE_NORMAL
- en: Recording UI tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you can record UI tests, you must add a UI testing target to the project.
    Follow the same steps as before to add a new testing target but pick the iOS UI
    Testing Bundle this time around. If you look inside the newly created group in
    your project, the structure of your UI tests looks very similar to the structure
    of unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: One significant difference between UI test targets and unit test targets is
    that your UI tests do not have access to any code that's inside your app. A UI
    test can only test the interface of your app and make assertions based on that.
  prefs: []
  type: TYPE_NORMAL
- en: If you open the `MovieTriviaUITest.swift` file, you'll notice the `setUpWithError
    ()` and `tearDown()` methods. Also, all of the tests that must be executed are
    methods with the `test` prefix. This is all similar to what you've already seen
    for `XCUITest`.
  prefs: []
  type: TYPE_NORMAL
- en: One big difference is that the app is launched explicitly in the setup stage.
    This is because the UI test target is essentially just a different app that can
    interact with your main app's interface. This limitation is very interesting,
    and it's also the reason why it's important to make your app accessible.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start recording a UI test in Xcode, you must start a recording session.
    If you''re editing code in a UI test target, a new interface element is visible
    in the bottom-left corner of your code editor area:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 19.9 – Recording interface'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_19.09_B14717.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 19.9 – Recording interface
  prefs: []
  type: TYPE_NORMAL
- en: 'Place your typing cursor inside the `testExample()` method and click the red
    dot. Your app is launched and anything you do is recorded as a UI test and played
    back when you run your tests. If you tap on the label and the activity indicator
    on the loading screen, Xcode produces the following Swift code in the testing
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The UI test you recorded is a set of instructions that are sent to the app.
    In this sample, the test looks for a certain element in the app's UI and calls
    `tap()` on it. This test doesn't do a lot, so it's not particularly useful. To
    make the test more useful, we should let the app know that it should run in a
    special test mode so it can load questions from the JSON file instead of trying
    to load it from the network. To do this, you can send launch arguments to the
    app. Launch arguments can be used by the app to enable or disable certain functionalities.
    You can think of them as variables that are sent to the app when it launches.
  prefs: []
  type: TYPE_NORMAL
- en: Passing launch arguments to your app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To switch the loading of questions from the network to a local file for testing,
    you can pass your app a launch argument. This launch argument is then read by
    the app to make sure it loads questions from the JSON file, as you did before
    in the unit tests, rather than attempting to load trivia questions from the server.
  prefs: []
  type: TYPE_NORMAL
- en: To prepare for the launch argument and loading the JSON file, make sure you
    add it to the test target, the app target, and the UI test target. You won't need
    it in the UI test target just yet, but you will later, so you might as well add
    it to the UI test target while you're at it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to pass launch arguments to the app, the `setUpWithError()` method
    in the UI test class should be modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `XCUIApplication` instance that represents the app has a `launchArguments`
    property, which is an array of strings. You can add strings to this array before
    launching the app. These strings can then be extracting inside of the app. Modify
    the `loadTriviaQuestions(callback:)` method in `TriviaAPI.swift` as shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code should be inserted above the existing implementation of this
    method. The snippet checks whether we're UI testing by reading the app's launch
    arguments. If the UI testing argument is present, we call the `loadQuestionsFromFile(callback:)`
    method to load the questions from the JSON file instead of loading it from the
    network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that it''s not ideal to perform checks such as the preceding one in your
    production code. It''s often better to wrap a configuration such as this in a
    struct that can be modified easily. You can then use this struct throughout your
    app instead of directly accessing process info throughout your app. An example
    of such a configuration could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We won't use this configuration class in this app since it's not needed for
    an app this small. But for your own apps, you might want to implement a configuration
    object regardless of app size since it leads to more maintainable code in the
    long run.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you build the app right now, you should get a compiler error because `loadQuestionsFromFile(callback:)`
    is not implemented in the API class yet. Add the following implementation for
    this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It's very similar to the question-loading method in the unit tests; the only
    difference is that it uses a different way to obtain the bundle from which the
    questions are loaded.
  prefs: []
  type: TYPE_NORMAL
- en: If you run your UI tests now, they will fail. The reason for this is that when
    the test framework starts looking for the elements it tapped before, they don't
    exist. This results in a test failure because the test can't tap elements that
    don't exist.
  prefs: []
  type: TYPE_NORMAL
- en: The test should be adjusted a bit because tapping a loader isn't very useful
    anyway. It's a lot more useful to make sure that buttons can be tapped and whether
    the UI updates accordingly. To do this, you can write a UI test that waits for
    the question and buttons to appear, taps them, and checks whether the UI has updated
    accordingly. The dummy data will be loaded in this test as well to verify that
    the correct question is shown and the buttons behave as they should.
  prefs: []
  type: TYPE_NORMAL
- en: Making sure the UI updates as expected
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You're going to write two tests to make sure that the trivia game works as expected.
    The first test will test that the question and the answer buttons appear and that
    they have the correct labels. The second test will make sure that the answers
    can be tapped and that the UI updates accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of recording the tests, you''ll write them manually. Writing tests
    manually gives you a bit more control and allows you to do much more than just
    tapping on elements. Before you do this, you should open the `Main.storyboard`
    file and give accessibility identifiers to the UI elements. Follow these steps
    to create a UI test manually:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the question title and give `UILabel` an identifier of `QuestionTitle`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select each of the answers and give them the `AnswerA`, `AnswerB`, and `AnswerC`
    identifiers, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, give the next button an accessibility identifier of `NextQuestion`. The
    following screenshot shows what the question title should look like:![Figure 19.10
    – Accessibility identifiers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_19.10_B14717.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 19.10 – Accessibility identifiers
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Remove the existing UI test, called `testExample()`, from the `MovieTriviaUITests`
    class and add the one shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Each element is selected through its accessibility identifier. You can do this
    because the `XCUIApplication` instance we create provides easy access to the UI
    elements.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, a predicate is created that is used to check whether each element exists,
    and an expectation is created. This expectation will continuously evaluate whether
    the predicate is true and once it is, the predicate will be fulfilled automatically.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, the UI test will wait for all expectations to be fulfilled.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To make sure the questions are loaded correctly, you should load the JSON file
    as you did before.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following property to the test so you have a place to store the trivia
    questions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the following code to the top of the `setUp()` method before launching
    the app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This code should look familiar to you because it''s similar to the code you
    already used to load JSON. To make sure that the correct question is displayed,
    update the test method as shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code calls `validateQuestionIsDisplayed(_:)`, but this method
    is not implemented yet.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code is run after checking that the UI elements exist because it's run
    after waiting for the expectations we created. The first question is extracted
    from the JSON data, and all of the relevant labels are then compared to the question
    data using a reusable method that validates whether a specific question is currently
    shown.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The second test you should add is intended to check whether the game UI responds
    as expected. After loading a question, the test will tap on the wrong answers
    and then makes sure the UI doesn''t show the button to go to the next question.
    Then, the correct answer will be selected, and the test will attempt to navigate
    to the next question. And of course, the test will then validate that the next
    question is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows the entire test that validates that the UI responds
    appropriately to correct and incorrect answers. Tests such as these are quite
    verbose, but they save you a lot of manual testing.
  prefs: []
  type: TYPE_NORMAL
- en: When you test your UI like this, you can rest assured that your app will at
    least be somewhat accessible. The beauty in this is that both UI testing and accessibility
    can significantly improve your app quality and each actively aids the other.
  prefs: []
  type: TYPE_NORMAL
- en: Testing your UI is mostly a matter of looking for elements in the UI, checking
    their state or availability, and making assertions based on that. In the two tests
    you have written for **MovieTrivia**, we've combined expectations and assertions
    to test both existing UI elements and elements that might not be on screen yet.
    Note that your UI tests will always attempt to wait for any animations to complete
    before the next command is executed. This will make sure that you don't have to
    write asynchronous expectations for any new UI that is added to the screen with
    an animation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations! You've made it to the end of this lengthy, information-packed
    chapter. You should know enough about testing and accessibility right now to begin
    exploring testing in greater depth than we have in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: No matter how small or big your app, writing automated tests will ensure that
    your app is of a high quality. More importantly, instead of assuming that something
    works because it worked before, your automated tests will guarantee that it works
    because your tests won't pass if you've broken your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you have learned the fundamentals about `XCTest`: when to
    write tests, which type of tests to write (unit and integration), and how to isolate
    tests following the Arrange-Act-Assert pattern. You also learned about code coverage
    and how to m easure how much of your code is being tested. Finally, you learned
    about `XCUITest` and how it can help you to test parts of your UI.'
  prefs: []
  type: TYPE_NORMAL
- en: You also learned that writing testable code sometimes requires you to refactor
    large portions of code. More often than not, these refactoring sessions leave
    your code in a much better state than before. Code that is easy to test is often
    cleaner and more robust than code that is hard to test.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to cover your app with tests, in the next chapter, we'll
    look at how you can submit your app to the App Store.
  prefs: []
  type: TYPE_NORMAL
