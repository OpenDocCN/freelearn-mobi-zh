- en: Chapter 2. Payment Request Workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When your customer decides to purchase an item that is offered in your app,
    it is your responsibility to give the user a smooth, fast, and pain-free payment
    experience. Thankfully, Apple has taken the brunt of this effort by implementing
    Apple Pay. Users do not have to dig up their credit cards and enter shipping addresses
    to complete an order, even if it is the first time that they use your app. By
    asking only for the information that is strictly necessary to perform a transaction,
    you provide your customers with a compelling purchasing experience, which will
    encourage subsequent purchases from your app.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter describes the things that your app needs to do to give its users
    a pleasant shopping experience, one in which the barrier between desiring something
    and having this product shipped to your doorstep is reduced to the gentle touch
    of a smooth, round button. At the same time, you reduce or eliminate the need
    to ask for and store your customers' payment information, which is a sensible
    approach in light of the notable increase in breaches of computer systems to obtain
    information on active payment cards. You will probably also welcome the marked
    increase in purchases from the same customers who, in addition to having a better
    purchasing experience than the ones offered by other apps, have confidence that
    their payment information will not be compromised (because their card information
    is not stored in their phones). Having a seamless payment experience will place
    your app high in its users' list of *loved* and *highly liked* apps, and apps
    that they would readily recommend to their family and friends.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Providing an overview of a simple inventory web service that provides inventory
    information to its clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing the implementation of a product card that displays essential product
    information and either an **Apple** **Pay** button or a regular **Buy** button
    depending on the availability of Apple Pay on the user's device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Walking through the process of creating a payment request and displaying a payment
    sheet with order information for the user to authorize payment (when Apple Pay
    is available)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting information from an inventory service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If users of your app can purchase tangible goods through it, then the app must
    get information about the availability of such products. One way to accomplish
    this is through a *web service*. A web service is an app (web app or web process)
    that runs on a web server and to which clients (desktop or mobile apps) can connect
    to access resources such as an inventory, product images, orders, and payments.
    The most web-centric way to access such resources is through the use of *RESTful
    API*. **Representational State Transfer** (**REST**) provides a way for a computer
    to communicate with other computers, akin to the way people browse the web.
  prefs: []
  type: TYPE_NORMAL
- en: When you visit a web page, the page will likely offer options (links) that you
    can use to access content that is related to this page or the workflow (transaction)
    in which you are engaged. You then analyze each link to decide which related page
    to go to next. The RESTful API provides clients with an organic way to interact
    with resources that are hosted by web servers. Instead of having to follow a rigid
    API that is dictated by the web service, clients can ask for specific representations
    of a resource (a browser may ask for its XHTML version, while an iOS app may ask
    for JavaScript Object Notation or JSON). Embedded in the resource are links to
    related resources or to operations that modify the state of the resource. For
    example, after creating an order, the web server may provide links to operations
    that return the state of this order, modify it, or cancel it. This type of interaction
    is known as *hypermedia*. Hypermedia refers to the way distributed systems operate,
    accessing resources by their unique identifiers through a small set of HTTP verbs,
    such as `POST`, `PUT`, `GET`, and `DELETE`. This simple communication style provides
    great flexibility to distributed systems in establishing specialized-communication
    protocols.
  prefs: []
  type: TYPE_NORMAL
- en: The example solution (iOS app and web service) described in this book (and available
    for download) makes use of RESTful API to provide access to inventory, orders,
    and payments. By basing the app's interaction with its web service on a simple
    RESTful API, we can focus our attention on the main aspects of incorporating Apple
    Pay in your app and processing payments on your web server.
  prefs: []
  type: TYPE_NORMAL
- en: Before your app can present product information to your customers, it must get
    this information from your web servers. Shipping information is also important
    because the shipping methods that you offer may change from time to time, and
    the app should also get this information regularly. The app would present the
    shipping methods that are available on the payment sheet to let the user accept
    the default shipping method or change it. The following sections describe how
    the example solution gets inventory and shipping information from a web server
    to the user's device.
  prefs: []
  type: TYPE_NORMAL
- en: Getting inventory information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The example app is very simple. On launch, it requests two things from the
    web server: the inventory, and the shipping methods that are available. Then,
    it displays the inventory in a list, as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting inventory information](img/B05093_02_01.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To get the inventory information, the app requests a representation of the resource
    from the server using a REST API. The resource is found by accessing the `http://red:12345/inventory`
    **Uniform Resource Identifier** (**URI**). After receiving the data, the app uses
    the `NSJSONSerialization` class to convert the data that is received (encoded
    in JSON) into an `NSDictionary` instance, which is the data source for the table
    (a `UITableView` instance) whose rows display the name of each product in inventory.
  prefs: []
  type: TYPE_NORMAL
- en: 'This listing shows the model that is used by the web service (implemented in
    Node.js), the Objective-C class that defines the corresponding iOS model, and
    the code that converts the JSON into the products dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: An important thing to note is that a product's price is stored as a string,
    not a number. This is because performing financial computations with numeric types
    does not produce accurate results. When performing financial computations, especially
    those having to do with Apple Pay transactions, you must use instances of the
    `NSDecimalNumber` class, which facilitate the accurate computation of arithmetic
    operations on base-10 numbers. The `NSDecimalNumber` class also has methods that
    convert numeric strings to decimal numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting shipping information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To provide available shipping methods to customers on the payment sheet, the
    app needs to get the list from the server. In the sample code, the app's `AppDelegate`
    object gets this list in its `application:didFinishLaunchingWithOptions:` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'This listing shows the Node.js and Objective-C model classes of instances of
    the `ShippingService` class, and the code that gets the shipping services from
    the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the `Product` class that was introduced earlier, the `ShippingMethod`
    class uses a string to store the price of each shipping method. This is because
    shipping-method prices are added to the price of other items in the payment request,
    and all these additions must be done using decimal numbers (the `NSDecimalNumber`
    instances).
  prefs: []
  type: TYPE_NORMAL
- en: Now that the app has the inventory of available products and the shipping methods
    available to its users, it can show a *product information card* when the user
    selects a product from the product list and a payment sheet when the user taps
    the **Apple** **Pay** button.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the product card
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Apple Pay user experience starts with the appearance of the **Apple** **Pay**
    button. When your customer sees this button, they know that the product pictured
    on their device's screen can be at their doorstep with as few as two taps. There
    really is no *step 3*.
  prefs: []
  type: TYPE_NORMAL
- en: The *product card* is a screen that displays product information, such as the
    product's name, description, and price, and the **Apple** **Pay** button when
    Apple Pay is available on the user's device. When Apple Pay is not available (either
    because the customer's device does not support it or because the customer has
    not set up Apple Pay on that device), your app should not display the **Apple**
    **Pay** button. Instead, it should display either an **Add to Cart** button or
    a regular **Buy** button, and process the payment using traditional means.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections describe how to design a product-card screen and how
    to lay out an **Apple** **Pay** button at runtime when Apple Pay is available.
  prefs: []
  type: TYPE_NORMAL
- en: Presenting product information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The product-card definition starts in the app''s main storyboard file, as in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Presenting product information](img/B05093_02_02.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The product scene lays out the elements that make up the product card. This
    is mainly an image view that displays the product''s image and three labels that
    display the product description, the **Price**: legend, and the product price
    using a currency formatter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This listing shows the `viewDidLoad` method of the `ProductCard` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `viewDidLoad` method instantiates the currency formatter that is used by
    the *buy* table cell, which displays the product's price and the **Apple** **Pay**
    button. However, the **Apple** **Pay** button is not laid out at design time;
    it is laid out at run time when the product table displays the buy cell. This
    setup is explained in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The `viewDidLoad` method also gets the product's image by getting the resources
    identified by the product's `image_uri` property. This method uses the REST API
    to download the image data from the server. When the image is downloaded, the
    method creates a `UIImage` object, which it assigns to the `view` property of
    the product table.
  prefs: []
  type: TYPE_NORMAL
- en: Presenting the Apple Pay button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As stated earlier, it is very important that your app does not display the
    **Apple** **Pay** button if the user is unable to use Apple Pay on their device.
    Your app determines whether Apple Pay is available using two methods of the `PKPaymentAuthorizationViewController`
    class: `canMakePayments`, and `canMakePaymentsUsingNetworks`:.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This listing shows how an example iOS app uses these methods to determine which
    purchase button to add to the buy cell: the **Apple** **Pay** button, an instance
    of the `PKPaymentButton` class, or a **Buy** button implemented as a `UIButton`
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The result of this process is a product card that displays the **Apple** **Pay**
    button (if Apple Pay is available on the device), allowing the user to quickly
    satisfy their impulse to purchase a beautiful product. It is your job to facilitate
    the satisfaction of this impulse with as few barriers as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '![Presenting the Apple Pay button](img/B05093_02_03.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When the user taps the **Apple** **Pay** button, your app starts the Apple Pay
    transaction by creating a payment request.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the payment request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the user has decided to purchase your product, we are on a mission
    to help them authorize the payment request with as few distractions and interruptions
    as possible. A user's attention, especially on a device such as an iPhone, can
    be fleeting; in the extra second that it takes for them to confirm a billing address
    (even though they always use the same address), a phone call can come in and,
    pouf, the sale goes away. Anything you can not show the user helps speed up the
    authorization. Apple Pay makes this very convenient.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the payment request](img/B05093_02_04.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Specifying payment details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The essential components of a payment request (an instance of `PKPaymentRequest`)
    are: country and currency code, your merchant identifier and capabilities, and
    the payment networks that you support. You must specify all these properties on
    each payment request you create.'
  prefs: []
  type: TYPE_NORMAL
- en: Country and currency code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You specify these items with the `countryCode` and `currencyCode` properties
    of the payment request. Specifying these items is important because they identify
    where and how the payment is processed. The country code is the two-letter code
    for the country where the payment will be processed (refer to ISO 3166 at [http://www.iso.org/iso/country_codes](http://www.iso.org/iso/country_codes)).
    The currency code is the three-letter code that identifies the currency that is
    used to fund the transaction (refer to ISO 4217 at [http://www.iso.org/iso/home/standards/currency_codes](http://www.iso.org/iso/home/standards/currency_codes)).
  prefs: []
  type: TYPE_NORMAL
- en: Merchant identifier and capabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Apple merchant identifier is the identifier that you obtained (or will get
    right now!) from the *Certificates, Identifiers & Profiles* section of the Apple
    Member Center website. They are reverse-DNS identifiers that start with `merchant.com`.
    The merchant capabilities identify the payment protocols, 3-D Secure, and EMV
    (Europay, MasterCard, and Visa). 3-D Secure support is required; EMV support is
    optional. You specify these components with the `merchantIdentifier` and `merchantCapabilities`
    properties of the payment request.
  prefs: []
  type: TYPE_NORMAL
- en: 'This listing shows the code that specifies the payment details of a payment
    request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Requiring shipping and billing information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apple Pay provides all the information that you need to complete a transaction.
    However, there may be situations in which you need information stored in Apple
    Pay that is not available to you before the user authorizes the payment request.
    For example, even though Apple Pay provides shipping and billing information,
    you may still require that the user enter or confirm the shipping destination
    before they authorize the payment request to calculate the shipping costs to present
    in the payment sheet. Keep in mind though that as your customer's billing and
    shipping details are most likely up to date in Apple Pay, relying on Apple Pay
    for this information is generally the best approach. Not to mention that by not
    requiring users to confirm such details, you would be putting them on the fast
    lane to that magical *authorization touch*.
  prefs: []
  type: TYPE_NORMAL
- en: Requiring shipping or billing addresses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need the user to enter shipping or billing information (because your
    systems interface with other systems that need this information readily), you
    can specify these requirements with the `requiredBillingAddressFields` and `requiredShippingAddressFields`
    properties of the payment request. For example, to make the billing address a
    required field, set this property to `PKAddressFieldPostalAddress`. If you need
    an e-mail, set it to `PKAddressFieldEmail`. Finally, to request a name, set the
    property to `PKAddressFieldName`. As the values that these properties accept are
    bitfield constants, you can aggregate them to require multiple items. This listing
    shows how to require a shipping address and email, and a billing email:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Specifying shipping or billing addresses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your customer has purchased items from your business before, and you have
    their billing and shipping address, you can prepopulate this information on the
    payment sheet using the `billingAddress` and `shippingAddress` properties of the
    payment request.
  prefs: []
  type: TYPE_NORMAL
- en: 'This listing shows how to make shipping and billing information required fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Specifying shipping methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you ship products to your customers, you may offer one or more shipping
    methods. The example iOS app and web service described earlier shows a basic implementation
    of such a system. Depending on the size of your enterprise, you may offer shipping
    methods for particular products or destinations. Regardless of the complexity
    of the setup, in the payment sheet that you present should be a simple list of
    shipping methods from which users choose the one that is most convenient to them.
    The next chapter discusses how to react when the user changes the shipping method
    in the payment sheet. For now, your focus is on creating an array of shipping
    methods (the `PKShippingMethod` instances) to assign to the `shippingMethods`
    payment-request property. This listing shows how to create such an array and how
    to incorporate it on the payment request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If, in addition to shipping goods using shipping services, you support in-store
    pickup of items or special delivery methods, such as for pizza or furniture, then
    you can specify a list of alternative delivery methods. To specify these shipping
    types, use the `shippingType` property of the payment request.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying summary items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The summary items are the elements of the payment sheet that specify the price
    of the item the user is purchasing, the shipping cost, taxes, discounts, and the
    total price. Each summary item has a label, such as `SHIPPING` or `TAX`. The last
    item represents the total price with a label, such as `PAY ACME`. The label of
    this item must identify your company so that the customer can match the purchase
    to their payment-card statement. You specify the summary items of a payment request
    by assigning an array of `PKPaymentSummaryItem` instances to the `paymentSummaryItems`
    property of the payment request. Each summary item has an `amount` property that
    represents the cost of the item.
  prefs: []
  type: TYPE_NORMAL
- en: 'This listing shows how to define the summary items of a payment request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To specify a summary item representing a discount from the product price, use
    a negative value for the summary item's amount. When you do not know the value
    for the amount because the value is generated as part of processing the order,
    you can indicate this fact to the user by setting the `type` property of the summary
    item to `PKPaymentSummaryItemTypePending`. This adds an appropriate legend to
    the item's label.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying custom information tied to the order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your ordering system needs additional information after the payment has been
    approved by the issuing bank, you can specify it in the `applicationData` property
    of the payment request. However, Apple Pay does not deliver this information to
    you. Your app has to send this information to your system separately.
  prefs: []
  type: TYPE_NORMAL
- en: As part of processing payment, your payment processor gets a hash of the value
    that you set in the `applicationData` property of the payment request. You can
    use this hash to verify that the value the app sent separately is the same as
    the initial value.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has shown how your app may obtain data to perform its functions
    using the REST API, which provides flexible functionality using the standard HTTP
    idioms (with HTTP verbs such as `PUT`, `GET`, `UPDATE`, and `DELETE`). It also
    showed you how to convert this data into information the user can act on, such
    as product names, descriptions, and images. In particular, this chapter discussed
    when to present the **Apple** **Pay** button to the user (only when Apple Pay
    is available on the user's device). Finally, this chapter walked you through the
    process of creating a payment request, which includes specifying payment information,
    such as the Apple merchant identifier and merchant capabilities, shipping and
    billing information, and the summary items that include the total price of the
    order labeled with your company name for easy verification with payment-card statements.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the user is looking at the payment sheet, your app needs to respond
    effectively to changes in the shipping methods or billing and shipping addresses.
    The ultimate user action though is authorizing the payment request. This is the
    topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
