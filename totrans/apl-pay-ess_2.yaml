- en: Chapter 2. Payment Request Workflow
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 支付请求工作流程
- en: When your customer decides to purchase an item that is offered in your app,
    it is your responsibility to give the user a smooth, fast, and pain-free payment
    experience. Thankfully, Apple has taken the brunt of this effort by implementing
    Apple Pay. Users do not have to dig up their credit cards and enter shipping addresses
    to complete an order, even if it is the first time that they use your app. By
    asking only for the information that is strictly necessary to perform a transaction,
    you provide your customers with a compelling purchasing experience, which will
    encourage subsequent purchases from your app.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的客户决定购买您应用中提供的产品时，您的责任是给用户提供一个顺畅、快速且无痛苦的支付体验。幸运的是，苹果公司通过实施Apple Pay承担了这项工作的主要部分。用户无需翻找信用卡和输入送货地址即可完成订单，即使这是他们第一次使用您的应用。通过仅请求执行交易所必需的信息，您为您的客户提供了一种引人入胜的购物体验，这将鼓励他们从您的应用中进行后续购买。
- en: This chapter describes the things that your app needs to do to give its users
    a pleasant shopping experience, one in which the barrier between desiring something
    and having this product shipped to your doorstep is reduced to the gentle touch
    of a smooth, round button. At the same time, you reduce or eliminate the need
    to ask for and store your customers' payment information, which is a sensible
    approach in light of the notable increase in breaches of computer systems to obtain
    information on active payment cards. You will probably also welcome the marked
    increase in purchases from the same customers who, in addition to having a better
    purchasing experience than the ones offered by other apps, have confidence that
    their payment information will not be compromised (because their card information
    is not stored in their phones). Having a seamless payment experience will place
    your app high in its users' list of *loved* and *highly liked* apps, and apps
    that they would readily recommend to their family and friends.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了您的应用需要执行的操作，以给用户带来愉快的购物体验，在这个体验中，从渴望某物到将此产品送到您家门口的障碍被简化为轻轻触摸一个光滑、圆润的按钮。同时，您减少了或消除了请求和存储客户支付信息的需求，这在计算机系统信息泄露事件显著增加的背景下是一种明智的做法。您可能还会欢迎来自同一客户的显著增加的购买量，这些客户除了在其他应用中拥有更好的购物体验外，还对其支付信息的安全性有信心（因为他们的卡信息没有存储在他们的手机中）。无缝的支付体验将使您的应用在用户“喜爱”和“高度喜爱”的应用列表中名列前茅，并且他们愿意向家人和朋友推荐这些应用。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Providing an overview of a simple inventory web service that provides inventory
    information to its clients
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个简单库存网络服务的概述，该服务向其客户端提供库存信息
- en: Describing the implementation of a product card that displays essential product
    information and either an **Apple** **Pay** button or a regular **Buy** button
    depending on the availability of Apple Pay on the user's device
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述了一个产品卡片实现，该卡片显示必要的产品信息，并根据用户设备上Apple Pay的可用性显示**Apple Pay**按钮或常规**购买**按钮。
- en: Walking through the process of creating a payment request and displaying a payment
    sheet with order information for the user to authorize payment (when Apple Pay
    is available)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演示创建支付请求的过程，并显示带有订单信息的支付单，以便用户授权支付（当Apple Pay可用时）
- en: Getting information from an inventory service
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从库存服务获取信息
- en: If users of your app can purchase tangible goods through it, then the app must
    get information about the availability of such products. One way to accomplish
    this is through a *web service*. A web service is an app (web app or web process)
    that runs on a web server and to which clients (desktop or mobile apps) can connect
    to access resources such as an inventory, product images, orders, and payments.
    The most web-centric way to access such resources is through the use of *RESTful
    API*. **Representational State Transfer** (**REST**) provides a way for a computer
    to communicate with other computers, akin to the way people browse the web.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用用户可以通过它购买有形商品，那么应用必须获取有关此类产品可用性的信息。实现这一目标的一种方法是通过*网络服务*。网络服务是在网络服务器上运行的程序（网络应用或网络进程），客户端（桌面或移动应用）可以连接到它以访问资源，例如库存、产品图片、订单和支付。访问此类资源最网络化的方式是通过使用*RESTful
    API*。**表示状态转移**（**REST**）为计算机与其他计算机之间的通信提供了一种方式，类似于人们浏览网页的方式。
- en: When you visit a web page, the page will likely offer options (links) that you
    can use to access content that is related to this page or the workflow (transaction)
    in which you are engaged. You then analyze each link to decide which related page
    to go to next. The RESTful API provides clients with an organic way to interact
    with resources that are hosted by web servers. Instead of having to follow a rigid
    API that is dictated by the web service, clients can ask for specific representations
    of a resource (a browser may ask for its XHTML version, while an iOS app may ask
    for JavaScript Object Notation or JSON). Embedded in the resource are links to
    related resources or to operations that modify the state of the resource. For
    example, after creating an order, the web server may provide links to operations
    that return the state of this order, modify it, or cancel it. This type of interaction
    is known as *hypermedia*. Hypermedia refers to the way distributed systems operate,
    accessing resources by their unique identifiers through a small set of HTTP verbs,
    such as `POST`, `PUT`, `GET`, and `DELETE`. This simple communication style provides
    great flexibility to distributed systems in establishing specialized-communication
    protocols.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当您访问一个网页时，该网页可能会提供一些选项（链接），您可以使用这些选项访问与此页面或您参与的流程（交易）相关的页面。然后，您分析每个链接以决定下一步访问哪个相关页面。RESTful
    API为客户端提供了与由Web服务器托管资源进行有机交互的方式。客户端无需遵循由Web服务指定的严格API，而是可以请求资源的特定表示（浏览器可能请求其XHTML版本，而iOS应用可能请求JavaScript对象表示法或JSON）。资源中嵌入了对相关资源或修改资源状态的操作的链接。例如，在创建订单后，Web服务器可能会提供返回此订单状态、修改它或取消它的操作的链接。这种交互方式被称为*超媒体*。超媒体指的是分布式系统操作的方式，通过一组小的HTTP动词（如`POST`、`PUT`、`GET`和`DELETE`）通过其唯一标识符访问资源。这种简单的通信风格为分布式系统在建立专门的通信协议时提供了极大的灵活性。
- en: The example solution (iOS app and web service) described in this book (and available
    for download) makes use of RESTful API to provide access to inventory, orders,
    and payments. By basing the app's interaction with its web service on a simple
    RESTful API, we can focus our attention on the main aspects of incorporating Apple
    Pay in your app and processing payments on your web server.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本书（并可下载）中描述的示例解决方案（iOS应用和Web服务）使用RESTful API来提供对库存、订单和支付的访问。通过将应用与其Web服务的交互基于简单的RESTful
    API，我们可以将注意力集中在将Apple Pay集成到您的应用中以及处理Web服务器上的支付的主要方面。
- en: Before your app can present product information to your customers, it must get
    this information from your web servers. Shipping information is also important
    because the shipping methods that you offer may change from time to time, and
    the app should also get this information regularly. The app would present the
    shipping methods that are available on the payment sheet to let the user accept
    the default shipping method or change it. The following sections describe how
    the example solution gets inventory and shipping information from a web server
    to the user's device.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用向客户展示产品信息之前，它必须从您的Web服务器获取这些信息。运输信息同样重要，因为您提供的运输方式可能会不时发生变化，应用也应该定期获取这些信息。应用将展示支付单上的可用运输方式，以便用户接受默认的运输方式或更改它。以下部分描述了示例解决方案如何从Web服务器获取库存和运输信息到用户的设备。
- en: Getting inventory information
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取库存信息
- en: 'The example app is very simple. On launch, it requests two things from the
    web server: the inventory, and the shipping methods that are available. Then,
    it displays the inventory in a list, as in the following screenshot:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 示例应用非常简单。在启动时，它从Web服务器请求两件事：库存和可用的运输方式。然后，它以列表的形式显示库存，如下面的截图所示：
- en: '![Getting inventory information](img/B05093_02_01.png.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![获取库存信息](img/B05093_02_01.png.jpg)'
- en: To get the inventory information, the app requests a representation of the resource
    from the server using a REST API. The resource is found by accessing the `http://red:12345/inventory`
    **Uniform Resource Identifier** (**URI**). After receiving the data, the app uses
    the `NSJSONSerialization` class to convert the data that is received (encoded
    in JSON) into an `NSDictionary` instance, which is the data source for the table
    (a `UITableView` instance) whose rows display the name of each product in inventory.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取库存信息，应用程序使用REST API从服务器请求资源的表示。通过访问`http://red:12345/inventory`**统一资源标识符**（**URI**）找到资源。在接收到数据后，应用程序使用`NSJSONSerialization`类将接收到的数据（以JSON编码）转换为`NSDictionary`实例，这是表格（`UITableView`实例）的数据源，其行显示库存中每个产品的名称。
- en: 'This listing shows the model that is used by the web service (implemented in
    Node.js), the Objective-C class that defines the corresponding iOS model, and
    the code that converts the JSON into the products dictionary:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表显示了由网络服务（用Node.js实现）使用的模型，定义相应iOS模型的Objective-C类，以及将JSON转换为产品字典的代码：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: An important thing to note is that a product's price is stored as a string,
    not a number. This is because performing financial computations with numeric types
    does not produce accurate results. When performing financial computations, especially
    those having to do with Apple Pay transactions, you must use instances of the
    `NSDecimalNumber` class, which facilitate the accurate computation of arithmetic
    operations on base-10 numbers. The `NSDecimalNumber` class also has methods that
    convert numeric strings to decimal numbers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一个重要事项是，产品的价格以字符串形式存储，而不是数字。这是因为使用数字类型进行财务计算不会产生准确的结果。在进行财务计算时，尤其是涉及苹果支付交易的计算，必须使用`NSDecimalNumber`类的实例，这有助于在十进制数上进行准确的算术运算。`NSDecimalNumber`类还包含将数字字符串转换为十进制数的方法。
- en: Getting shipping information
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取运输信息
- en: To provide available shipping methods to customers on the payment sheet, the
    app needs to get the list from the server. In the sample code, the app's `AppDelegate`
    object gets this list in its `application:didFinishLaunchingWithOptions:` method.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在支付页面上向客户提供可用的运输方式，应用程序需要从服务器获取列表。在示例代码中，应用程序的`AppDelegate`对象在其`application:didFinishLaunchingWithOptions:`方法中获取此列表。
- en: 'This listing shows the Node.js and Objective-C model classes of instances of
    the `ShippingService` class, and the code that gets the shipping services from
    the server:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表显示了`ShippingService`类实例的Node.js和Objective-C模型类，以及从服务器获取运输服务的代码：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Similar to the `Product` class that was introduced earlier, the `ShippingMethod`
    class uses a string to store the price of each shipping method. This is because
    shipping-method prices are added to the price of other items in the payment request,
    and all these additions must be done using decimal numbers (the `NSDecimalNumber`
    instances).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前引入的`Product`类类似，`ShippingMethod`类使用字符串来存储每种运输方式的价格。这是因为运输方式的价格会被添加到支付请求中其他项目的价格中，并且所有这些添加都必须使用十进制数（`NSDecimalNumber`实例）来完成。
- en: Now that the app has the inventory of available products and the shipping methods
    available to its users, it can show a *product information card* when the user
    selects a product from the product list and a payment sheet when the user taps
    the **Apple** **Pay** button.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序已经拥有了可用产品的库存和用户可用的运输方式，当用户从产品列表中选择产品时，它可以显示**产品信息卡片**；当用户点击**苹果支付**按钮时，它可以显示支付页面。
- en: Displaying the product card
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示产品卡片
- en: The Apple Pay user experience starts with the appearance of the **Apple** **Pay**
    button. When your customer sees this button, they know that the product pictured
    on their device's screen can be at their doorstep with as few as two taps. There
    really is no *step 3*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果支付的用户体验从**苹果支付**按钮的出现开始。当您的客户看到这个按钮时，他们会知道他们设备屏幕上显示的产品只需轻触两次即可送到家门口。实际上，根本不需要**第三步**。
- en: The *product card* is a screen that displays product information, such as the
    product's name, description, and price, and the **Apple** **Pay** button when
    Apple Pay is available on the user's device. When Apple Pay is not available (either
    because the customer's device does not support it or because the customer has
    not set up Apple Pay on that device), your app should not display the **Apple**
    **Pay** button. Instead, it should display either an **Add to Cart** button or
    a regular **Buy** button, and process the payment using traditional means.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*产品卡片*是一个显示产品信息的屏幕，例如产品的名称、描述和价格，以及当用户的设备上可用**Apple Pay**按钮时显示的**Apple Pay**按钮。当**Apple
    Pay**不可用（无论是由于客户的设备不支持它，还是因为客户未在该设备上设置Apple Pay），您的应用不应显示**Apple Pay**按钮。相反，它应显示**添加到购物车**按钮或常规**购买**按钮，并使用传统方式处理支付。'
- en: The following sections describe how to design a product-card screen and how
    to lay out an **Apple** **Pay** button at runtime when Apple Pay is available.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分描述了如何设计产品卡片屏幕以及如何在可用时运行时布局**Apple Pay**按钮。
- en: Presenting product information
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展示产品信息
- en: 'The product-card definition starts in the app''s main storyboard file, as in
    the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 产品卡片定义从应用的主要故事板文件开始，如下面的截图所示：
- en: '![Presenting product information](img/B05093_02_02.png.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![展示产品信息](img/B05093_02_02.png.jpg)'
- en: 'The product scene lays out the elements that make up the product card. This
    is mainly an image view that displays the product''s image and three labels that
    display the product description, the **Price**: legend, and the product price
    using a currency formatter.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 产品场景布局构成产品卡片的元素。这主要是用于显示产品图像的一个图像视图，以及三个标签，用于显示产品描述、**价格**图例和产品价格（使用货币格式化器）。
- en: 'This listing shows the `viewDidLoad` method of the `ProductCard` object:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表显示了`ProductCard`对象的`viewDidLoad`方法：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `viewDidLoad` method instantiates the currency formatter that is used by
    the *buy* table cell, which displays the product's price and the **Apple** **Pay**
    button. However, the **Apple** **Pay** button is not laid out at design time;
    it is laid out at run time when the product table displays the buy cell. This
    setup is explained in the next section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewDidLoad`方法实例化了用于*购买*表格单元格的货币格式化器，该单元格显示产品的价格和**Apple Pay**按钮。然而，**Apple
    Pay**按钮不是在设计时布局的；它是在产品表格显示购买单元格时运行时布局的。此设置将在下一节中解释。'
- en: The `viewDidLoad` method also gets the product's image by getting the resources
    identified by the product's `image_uri` property. This method uses the REST API
    to download the image data from the server. When the image is downloaded, the
    method creates a `UIImage` object, which it assigns to the `view` property of
    the product table.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewDidLoad`方法通过获取产品的`image_uri`属性标识的资源来获取产品的图像。此方法使用REST API从服务器下载图像数据。当图像下载完成后，该方法创建一个`UIImage`对象，并将其分配给产品表格的`view`属性。'
- en: Presenting the Apple Pay button
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展示Apple Pay按钮
- en: 'As stated earlier, it is very important that your app does not display the
    **Apple** **Pay** button if the user is unable to use Apple Pay on their device.
    Your app determines whether Apple Pay is available using two methods of the `PKPaymentAuthorizationViewController`
    class: `canMakePayments`, and `canMakePaymentsUsingNetworks`:.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果用户无法在他们的设备上使用Apple Pay，则您的应用不显示**Apple Pay**按钮非常重要。您的应用使用`PKPaymentAuthorizationViewController`类的两个方法来确定Apple
    Pay是否可用：`canMakePayments`和`canMakePaymentsUsingNetworks`。
- en: 'This listing shows how an example iOS app uses these methods to determine which
    purchase button to add to the buy cell: the **Apple** **Pay** button, an instance
    of the `PKPaymentButton` class, or a **Buy** button implemented as a `UIButton`
    instance:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表显示了示例iOS应用如何使用这些方法确定要添加到购买单元格中的购买按钮：**Apple Pay**按钮，`PKPaymentButton`类的一个实例，或作为`UIButton`实例实现的**购买**按钮：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The result of this process is a product card that displays the **Apple** **Pay**
    button (if Apple Pay is available on the device), allowing the user to quickly
    satisfy their impulse to purchase a beautiful product. It is your job to facilitate
    the satisfaction of this impulse with as few barriers as possible.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '此过程的结果是一个显示**Apple Pay**按钮的产品卡片（如果设备上可用Apple Pay），使用户能够快速满足购买美丽产品的冲动。您的任务是尽可能减少障碍，以促进这种冲动的满足。 '
- en: '![Presenting the Apple Pay button](img/B05093_02_03.png.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![展示Apple Pay按钮](img/B05093_02_03.png.jpg)'
- en: When the user taps the **Apple** **Pay** button, your app starts the Apple Pay
    transaction by creating a payment request.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击**Apple** **Pay**按钮时，您的应用通过创建支付请求来启动Apple Pay交易。
- en: Creating the payment request
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建支付请求
- en: Now that the user has decided to purchase your product, we are on a mission
    to help them authorize the payment request with as few distractions and interruptions
    as possible. A user's attention, especially on a device such as an iPhone, can
    be fleeting; in the extra second that it takes for them to confirm a billing address
    (even though they always use the same address), a phone call can come in and,
    pouf, the sale goes away. Anything you can not show the user helps speed up the
    authorization. Apple Pay makes this very convenient.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户已经决定购买您的产品，我们的任务是帮助他们以尽可能少的干扰和中断来授权支付请求。用户的注意力，尤其是在iPhone这样的设备上，可能是短暂的；在他们确认账单地址的额外一秒钟（即使他们总是使用相同的地址），电话可能会打进来，然后，砰，交易就消失了。您能提供给用户的任何信息都能帮助加快授权过程。Apple
    Pay使这一点变得非常方便。
- en: '![Creating the payment request](img/B05093_02_04.png.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![创建支付请求](img/B05093_02_04.png.jpg)'
- en: Specifying payment details
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定支付详情
- en: 'The essential components of a payment request (an instance of `PKPaymentRequest`)
    are: country and currency code, your merchant identifier and capabilities, and
    the payment networks that you support. You must specify all these properties on
    each payment request you create.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 支付请求（`PKPaymentRequest`的一个实例）的基本组件包括：国家代码和货币代码、您的商户标识符和能力，以及您支持的支付网络。您必须在创建的每个支付请求中指定所有这些属性。
- en: Country and currency code
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 国家和货币代码
- en: You specify these items with the `countryCode` and `currencyCode` properties
    of the payment request. Specifying these items is important because they identify
    where and how the payment is processed. The country code is the two-letter code
    for the country where the payment will be processed (refer to ISO 3166 at [http://www.iso.org/iso/country_codes](http://www.iso.org/iso/country_codes)).
    The currency code is the three-letter code that identifies the currency that is
    used to fund the transaction (refer to ISO 4217 at [http://www.iso.org/iso/home/standards/currency_codes](http://www.iso.org/iso/home/standards/currency_codes)).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您通过支付请求的`countryCode`和`currencyCode`属性来指定这些项。指定这些项非常重要，因为它们确定了支付的处理地点和处理方式。国家代码是支付处理所在国家的两位字母代码（参考ISO
    3166，见[http://www.iso.org/iso/country_codes](http://www.iso.org/iso/country_codes)）。货币代码是用于资助交易的货币的三位字母代码（参考ISO
    4217，见[http://www.iso.org/iso/home/standards/currency_codes](http://www.iso.org/iso/home/standards/currency_codes)）。
- en: Merchant identifier and capabilities
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 商户标识符和能力
- en: The Apple merchant identifier is the identifier that you obtained (or will get
    right now!) from the *Certificates, Identifiers & Profiles* section of the Apple
    Member Center website. They are reverse-DNS identifiers that start with `merchant.com`.
    The merchant capabilities identify the payment protocols, 3-D Secure, and EMV
    (Europay, MasterCard, and Visa). 3-D Secure support is required; EMV support is
    optional. You specify these components with the `merchantIdentifier` and `merchantCapabilities`
    properties of the payment request.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果商户标识符是您从苹果会员中心网站上的“证书、标识符和配置文件”部分获得的标识符（或者您现在就可以获得！）它们是反向DNS标识符，以`merchant.com`开头。商户能力标识了支付协议、3-D
    Secure和EMV（欧付宝、万事达卡和维萨）。3-D Secure支持是必需的；EMV支持是可选的。您通过支付请求的`merchantIdentifier`和`merchantCapabilities`属性来指定这些组件。
- en: 'This listing shows the code that specifies the payment details of a payment
    request:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表显示了指定支付请求支付详情的代码：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Requiring shipping and billing information
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求提供运输和账单信息
- en: Apple Pay provides all the information that you need to complete a transaction.
    However, there may be situations in which you need information stored in Apple
    Pay that is not available to you before the user authorizes the payment request.
    For example, even though Apple Pay provides shipping and billing information,
    you may still require that the user enter or confirm the shipping destination
    before they authorize the payment request to calculate the shipping costs to present
    in the payment sheet. Keep in mind though that as your customer's billing and
    shipping details are most likely up to date in Apple Pay, relying on Apple Pay
    for this information is generally the best approach. Not to mention that by not
    requiring users to confirm such details, you would be putting them on the fast
    lane to that magical *authorization touch*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Apple Pay 提供了你完成交易所需的所有信息。然而，可能存在需要用户在授权支付请求之前存储在 Apple Pay 中但之前无法获取的信息的情况。例如，尽管
    Apple Pay 提供了运输和账单信息，但你可能仍然需要在用户授权支付请求之前要求他们输入或确认运输目的地，以便在支付单中计算运输成本。但请记住，由于客户的账单和运输细节很可能在
    Apple Pay 中是最新的，因此依赖 Apple Pay 获取这些信息通常是最佳方法。更不用说，如果不要求用户确认此类详细信息，你将使他们快速进入那神奇的*授权触摸*。
- en: Requiring shipping or billing addresses
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 要求运输或账单地址
- en: 'If you need the user to enter shipping or billing information (because your
    systems interface with other systems that need this information readily), you
    can specify these requirements with the `requiredBillingAddressFields` and `requiredShippingAddressFields`
    properties of the payment request. For example, to make the billing address a
    required field, set this property to `PKAddressFieldPostalAddress`. If you need
    an e-mail, set it to `PKAddressFieldEmail`. Finally, to request a name, set the
    property to `PKAddressFieldName`. As the values that these properties accept are
    bitfield constants, you can aggregate them to require multiple items. This listing
    shows how to require a shipping address and email, and a billing email:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要用户输入运输或账单信息（因为你的系统与其他需要这些信息的系统接口），你可以使用支付请求的 `requiredBillingAddressFields`
    和 `requiredShippingAddressFields` 属性来指定这些要求。例如，为了使账单地址成为必填字段，将此属性设置为 `PKAddressFieldPostalAddress`。如果你需要一个电子邮件地址，将其设置为
    `PKAddressFieldEmail`。最后，为了请求姓名，将属性设置为 `PKAddressFieldName`。由于这些属性接受的值是位字段常量，你可以将它们聚合起来以要求多个项目。以下列表展示了如何要求运输地址和电子邮件，以及账单电子邮件：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Specifying shipping or billing addresses
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定运输或账单地址
- en: If your customer has purchased items from your business before, and you have
    their billing and shipping address, you can prepopulate this information on the
    payment sheet using the `billingAddress` and `shippingAddress` properties of the
    payment request.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客户之前已经从你的业务中购买了商品，并且你有他们的账单和运输地址，你可以使用支付请求的 `billingAddress` 和 `shippingAddress`
    属性在支付单上预先填充这些信息。
- en: 'This listing shows how to make shipping and billing information required fields:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了如何使运输和账单信息成为必填字段：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Specifying shipping methods
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定运输方式
- en: 'If you ship products to your customers, you may offer one or more shipping
    methods. The example iOS app and web service described earlier shows a basic implementation
    of such a system. Depending on the size of your enterprise, you may offer shipping
    methods for particular products or destinations. Regardless of the complexity
    of the setup, in the payment sheet that you present should be a simple list of
    shipping methods from which users choose the one that is most convenient to them.
    The next chapter discusses how to react when the user changes the shipping method
    in the payment sheet. For now, your focus is on creating an array of shipping
    methods (the `PKShippingMethod` instances) to assign to the `shippingMethods`
    payment-request property. This listing shows how to create such an array and how
    to incorporate it on the payment request:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向客户发货产品，你可以提供一种或多种运输方式。前面提到的示例 iOS 应用和 Web 服务展示了这样一个系统的基本实现。根据你企业的规模，你可能需要为特定产品或目的地提供运输方式。无论设置有多复杂，你提供的支付单上都应该有一个简单的运输方式列表，用户可以选择对他们最方便的一种。下一章将讨论当用户在支付单中更改运输方式时如何做出反应。目前，你的重点是创建一个运输方式数组（`PKShippingMethod`
    实例），并将其分配给 `shippingMethods` 支付请求属性。以下列表展示了如何创建这样一个数组以及如何在支付请求中包含它：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If, in addition to shipping goods using shipping services, you support in-store
    pickup of items or special delivery methods, such as for pizza or furniture, then
    you can specify a list of alternative delivery methods. To specify these shipping
    types, use the `shippingType` property of the payment request.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果除了使用运输服务运输商品外，您还支持店内取货或特殊递送方式，例如披萨或家具，那么您可以指定一个替代递送方式的列表。要指定这些运输类型，请使用支付请求的`shippingType`属性。
- en: Specifying summary items
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定摘要项
- en: The summary items are the elements of the payment sheet that specify the price
    of the item the user is purchasing, the shipping cost, taxes, discounts, and the
    total price. Each summary item has a label, such as `SHIPPING` or `TAX`. The last
    item represents the total price with a label, such as `PAY ACME`. The label of
    this item must identify your company so that the customer can match the purchase
    to their payment-card statement. You specify the summary items of a payment request
    by assigning an array of `PKPaymentSummaryItem` instances to the `paymentSummaryItems`
    property of the payment request. Each summary item has an `amount` property that
    represents the cost of the item.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要项是支付单中的元素，用于指定用户购买的商品的价格、运费、税费、折扣和总价。每个摘要项都有一个标签，例如`SHIPPING`或`TAX`。最后一个项目代表总价，并带有标签，例如`PAY
    ACME`。此项目的标签必须能识别您的公司，以便客户可以将购买与他们的支付卡账单相匹配。您通过将`PKPaymentSummaryItem`实例数组分配给支付请求的`paymentSummaryItems`属性来指定支付请求的摘要项。每个摘要项都有一个`amount`属性，表示项目的成本。
- en: 'This listing shows how to define the summary items of a payment request:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表显示了如何定义支付请求的摘要项：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To specify a summary item representing a discount from the product price, use
    a negative value for the summary item's amount. When you do not know the value
    for the amount because the value is generated as part of processing the order,
    you can indicate this fact to the user by setting the `type` property of the summary
    item to `PKPaymentSummaryItemTypePending`. This adds an appropriate legend to
    the item's label.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定表示从产品价格中折扣的摘要项，请为摘要项的金额使用负值。当您不知道金额的值，因为该值是作为订单处理的一部分生成时，您可以通过将摘要项的`type`属性设置为`PKPaymentSummaryItemTypePending`来向用户表明这一事实。这会在项目的标签中添加适当的说明。
- en: Specifying custom information tied to the order
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定与订单相关的自定义信息
- en: If your ordering system needs additional information after the payment has been
    approved by the issuing bank, you can specify it in the `applicationData` property
    of the payment request. However, Apple Pay does not deliver this information to
    you. Your app has to send this information to your system separately.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的订单系统在发行银行批准支付后需要额外的信息，您可以在支付请求的`applicationData`属性中指定它。然而，Apple Pay不会将此信息发送给您。您的应用必须单独将此信息发送到您的系统。
- en: As part of processing payment, your payment processor gets a hash of the value
    that you set in the `applicationData` property of the payment request. You can
    use this hash to verify that the value the app sent separately is the same as
    the initial value.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 作为处理支付的一部分，您的支付处理器会获取支付请求中`applicationData`属性设置的值的哈希。您可以使用这个哈希来验证应用单独发送的值与初始值是否相同。
- en: Summary
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has shown how your app may obtain data to perform its functions
    using the REST API, which provides flexible functionality using the standard HTTP
    idioms (with HTTP verbs such as `PUT`, `GET`, `UPDATE`, and `DELETE`). It also
    showed you how to convert this data into information the user can act on, such
    as product names, descriptions, and images. In particular, this chapter discussed
    when to present the **Apple** **Pay** button to the user (only when Apple Pay
    is available on the user's device). Finally, this chapter walked you through the
    process of creating a payment request, which includes specifying payment information,
    such as the Apple merchant identifier and merchant capabilities, shipping and
    billing information, and the summary items that include the total price of the
    order labeled with your company name for easy verification with payment-card statements.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了您的应用如何使用REST API获取数据以执行其功能，该API使用标准的HTTP惯用语（如`PUT`、`GET`、`UPDATE`和`DELETE`等HTTP动词）提供灵活的功能。它还向您展示了如何将此数据转换为用户可以采取行动的信息，例如产品名称、描述和图片。特别是，本章讨论了何时向用户展示**Apple
    Pay**按钮（只有当用户的设备上可用Apple Pay时）。最后，本章向您介绍了创建支付请求的过程，这包括指定支付信息，例如Apple商户标识和商户能力、运输和账单信息，以及包含订单总价格并标注您公司名称的摘要项，以便于与支付卡对账单进行轻松验证。
- en: Now that the user is looking at the payment sheet, your app needs to respond
    effectively to changes in the shipping methods or billing and shipping addresses.
    The ultimate user action though is authorizing the payment request. This is the
    topic of the next chapter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户正在查看付款单，您的应用需要有效地响应用户在运输方式或账单和运输地址上的变化。然而，最终的用户操作是授权支付请求。这是下一章的主题。
