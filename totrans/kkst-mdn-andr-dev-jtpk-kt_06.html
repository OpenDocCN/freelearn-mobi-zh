<html><head></head><body>
		<div id="_idContainer072">
			<h1 id="_idParaDest-79"><em class="italic"><a id="_idTextAnchor147"/>Chapter 5</em>: Adding Navigation in Compose With Jetpack Navigation</h1>
			<p>In this chapter, we'll focus on a core Jetpack library, the Navigation component. This library is essential to us since it allows us to easily navigate between application screens.</p>
			<p>So far, we have only created a screen in our Restaurants application, where we displayed a list of diners. It's time to step up the game and add another screen to our application!</p>
			<p>In the first section, <em class="italic">Introducing the Jetpack Navigation component</em>, we will explore the basic concepts and elements of the Navigation component. In the second section, <em class="italic">Creating a new Compose-based screen</em>, we will create a new screen to display the details of a specific restaurant and realize that we don't know how to navigate to it. </p>
			<p>In the third section, <em class="italic">Implementing navigation with Jetpack Navigation</em>, we will add the Navigation component to the Restaurants application and use it to navigate to the second screen. Finally, in the <em class="italic">Adding support for deep links</em> section, we will create a deep link to our newly created screen and make sure that our application knows how to handle it.</p>
			<p>To summarize, in this chapter we're going to cover the following main topics:</p>
			<ul>
				<li>Introducing the Jetpack Navigation component</li>
				<li>Creating a new Compose-based screen</li>
				<li>Implementing navigation with Jetpack Navigation</li>
				<li>Adding support for deep links</li>
			</ul>
			<p>Before jumping in, let's set up the technical requirements for this chapter.</p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor148"/>Technical requirements</h1>
			<p>Building Compose-based Android projects with Jetpack Navigation usually requires your day-to-day tools. However, to follow along smoothly, make sure you have the following:</p>
			<ul>
				<li>The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer Android Studio version or even Canary builds, but note that the IDE interface and other generated code files might differ from the ones used throughout this book.</li>
				<li>Kotlin 1.6.10 or newer plugin installed in Android Studio</li>
				<li>The Restaurants app code from the previous chapter</li>
			</ul>
			<p>The starting point for this chapter is represented by the Restaurants application developed in <a href="B17788_04_ePub.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">Handling Async Operations with Coroutines</em>. If you haven't followed the implementation from the previous chapter, access the starting point for this chapter by navigating to the <strong class="source-inline">Chapter_04</strong> directory of the repository and importing the Android project named <strong class="source-inline">chapter_4_restaurants_app</strong>.</p>
			<p>To access the solution code for this chapter, navigate to the <strong class="source-inline">Chapter_05</strong> directory: <a href="https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_05/chapter_5_restaurants_app">https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_05/chapter_5_restaurants_app</a>.</p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor149"/>Introducing the Jetpack Navigation component</h1>
			<p>The <strong class="bold">Navigation</strong> component<a id="_idIndexMarker341"/> is Jetpack's solution to navigation within Android apps. This library allows you to easily implement navigation between the screens of your application.</p>
			<p>To promote a predictable user experience and consistent manner of handling app flows, the Navigation component adheres <a id="_idIndexMarker342"/>to a set of principles. The two most important principles are as follows:</p>
			<ul>
				<li>The application has a fixed <a id="_idIndexMarker343"/>start <strong class="bold">destination</strong> (screen) – this allows the application behavior to be predictable because the app will always present this destination first, no matter where it is being launched from.</li>
			</ul>
			<p>In our Restaurants application, we plan to set the start destination as our existing screen with the list of restaurants (represented by the <strong class="source-inline">RestaurantsScreen()</strong> composable function). In other words, this is the first screen that the user will always see when launching the app from the Android launcher screen.</p>
			<ul>
				<li>The navigation state <a id="_idIndexMarker344"/>is defined as a stack of destinations, often called <a id="_idIndexMarker345"/>the <strong class="bold">back stack</strong>. When the app is initially started, the stack will contain the app's start destination – let's call this <em class="italic">Screen A</em>. If you navigate from <em class="italic">Screen A</em> to <em class="italic">Screen B</em>, <em class="italic">B</em> will be added on top of the stack. This applies when navigating to <em class="italic">Screen C</em> too. To better understand how the back stack works, let's try to illustrate it in such a scenario:</li>
			</ul>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/B17788_05_1.jpg" alt="Figure 5.1 – Back stack evolution of screens while the user navigates within the app&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – Back stack evolution of screens while the user navigates within the app</p>
			<p>At the top of the back stack, you will always have the current screen the user is at right now. When navigating back to the previous screen, the top of the back stack is popped, just as we did in <em class="italic">Figure 5.1</em>, where navigating from <em class="italic">Screen C</em> to <em class="italic">Screen B</em> resulted in the pop of <em class="italic">Screen C</em> from the back stack.</p>
			<p>All these operations are always done at the top of the stack, while the back of the stack will always contain the fixed start destination – in our case, <em class="italic">Screen A</em>.</p>
			<p>The Navigation component<a id="_idIndexMarker346"/> takes care of handling the back stack operations behind the scenes for us.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Initially, the Navigation component specialized in offering navigation mainly between <strong class="source-inline">Fragment</strong> components. Today, the library also supports Compose and the navigation between composable functions.</p>
			<p>Apart from following clear principles when it comes to UI navigation, the Navigation component has three main<a id="_idIndexMarker347"/> constituent elements:</p>
			<ul>
				<li><strong class="bold">Navigation graph</strong>: The<a id="_idIndexMarker348"/> core source <a id="_idIndexMarker349"/>of information related to navigation within your app. In the navigation graph, you define all the destinations as well as the possible paths that the user can take throughout the app to achieve different tasks.</li>
				<li><strong class="bold">NavHost</strong>: A <a id="_idIndexMarker350"/>container composable function that<a id="_idIndexMarker351"/> will display the composable destinations. As the user navigates between different destinations, the content of the navigation host is swapped and recomposed.</li>
				<li><strong class="bold">NavController</strong>: A <a id="_idIndexMarker352"/>stateful object that handles the <a id="_idIndexMarker353"/>navigation between composable screens and is, therefore, in charge of propagating updates inside the destinations back stack. The navigation controller sets the correct destinations to <strong class="source-inline">NavHost</strong> as the user starts navigating between screens.</li>
			</ul>
			<p>Now, when you implement the Navigation component in your Compose-based Android app, you will gain a lot of <a id="_idIndexMarker354"/>benefits. The following lists<a id="_idIndexMarker355"/> some examples:</p>
			<ul>
				<li>You don't need to handle the complexity of navigation between composable functions. The library does that out of the box for you.</li>
				<li>You don't need to handle <em class="italic">Up</em> or <em class="italic">Back</em> actions on your own. If you press the system's <strong class="bold">Back</strong> button, the library will automatically pop the current destination from the back stack and send the user to the previous destination.</li>
				<li>You benefit from scoped <strong class="source-inline">ViewModel</strong> components to a specific Navigation graph or destination. This means that the <strong class="source-inline">ViewModel</strong> instance used by a composable destination will live for as long as the composable screen does.</li>
				<li>You<a id="_idIndexMarker356"/> don't need to implement deep links from scratch. Deep links allow you to directly navigate to a specific destination within the app without having to traverse the entire path of screens that get you there. We will see how they work in the <em class="italic">Adding support for deep links</em> section of this chapter.</li>
			</ul>
			<p>Now that we have a basic overview of the elements and advantages of using Jetpack Navigation, it's time to create a new screen so we can implement navigation in our Restaurants application.</p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor150"/>Creating a new Compose-based screen</h1>
			<p>Real-world applications<a id="_idIndexMarker357"/> are required to display a lot of content, so one screen probably won't suffice. So far, our Restaurants application features a simple screen where all the restaurants that we receive from our remote database are displayed.</p>
			<p>Let's practice all the skills we've learned so far by creating a new screen that will display the details of a particular restaurant. The plan is that when users press on a particular restaurant from the list inside our <strong class="source-inline">RestaurantsScreen()</strong> composable screen, we should take them to a new details screen for that particular restaurant.</p>
			<p>Yet to perform navigation between two screens, we need first to build the second screen. Unlike with the first composable screen, it's time to change our tactic and build it from top to<a id="_idIndexMarker358"/> bottom. Let's build this second feature first by defining the network request, then executing it inside its own <strong class="source-inline">ViewModel</strong>, and finally creating the composable UI that will consume the data, as follows:</p>
			<ul>
				<li>Defining the HTTP request for the contents of a restaurant</li>
				<li>Getting the contents of a specific restaurant</li>
				<li>Building the restaurant details screen</li>
			</ul>
			<p>Let's start!</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor151"/>Defining the HTTP request for the contents of a restaurant</h2>
			<p>We need to<a id="_idIndexMarker359"/> know how to obtain the data for our new restaurant details screen. Instead of relying on the previously retrieved data (the list of restaurants), we want to make every <a id="_idIndexMarker360"/>screen in our application as independent as possible. This way, we design our application to easily support deep links and we better defend ourselves from events such as a system-initiated process death.</p>
			<p>That's why we will build this new screen so that it gets its own content. In other words, in the new screen, we will get the details for a particular restaurant from the same database where we've obtained the list of restaurants. But how will we do that?</p>
			<p>Remember that the restaurants within our Firebase database have a unique <strong class="source-inline">Integer</strong> identifier field called <strong class="source-inline">r_id</strong>, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/B17788_05_2.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – Identifying the unique identifier field for restaurants in Firebase</p>
			<p>We can<a id="_idIndexMarker361"/> use this field to get the details of one specific restaurant. And since <strong class="source-inline">r_id</strong> is mapped to the <strong class="source-inline">id: Int</strong> field of the <strong class="source-inline">Restaurant</strong> object, this means that when the user presses on a restaurant in our <strong class="source-inline">RestaurantsScreen</strong> composable, we can forward the <strong class="source-inline">id</strong> value to the second screen.</p>
			<p>In the second <a id="_idIndexMarker362"/>screen, we will execute an API request to our Firebase REST API and pass the value of the unique ID of the restaurant within our app that corresponds to the <strong class="source-inline">r_id</strong> identifier of the restaurant inside the remote database.</p>
			<p>The Firebase REST API <a id="_idIndexMarker363"/>has us covered for such cases. If we want to get the details of one element from the restaurants JSON content, we must append two query parameters to the same URL used to retrieve the entire restaurants list:</p>
			<ul>
				<li><strong class="source-inline">orderBy=r_id</strong> to instruct Firebase to filter the elements by their <strong class="source-inline">r_id</strong> field.</li>
				<li><strong class="source-inline">equalTo=2</strong> to let Firebase know the value of the <strong class="source-inline">r_id</strong> field of the restaurant element that we're looking for – in this case <strong class="source-inline">2</strong>.</li>
			</ul>
			<p>To practice, place in your browser address bar the Firebase URL that you've used to get the restaurants until now and append the previous two query parameters as follows:</p>
			<p class="source-code">https://restaurants-db-default-rtdb.firebaseio.com/restaurants.json?<strong class="bold">orderBy="r_id"&amp;equalTo=2</strong></p>
			<p>If you access your link, the response will, unfortunately, look like this:</p>
			<p class="source-code">{ "error" : "Index not defined, add \".indexOn\": \"r_id\", for path \"/restaurants\", to the rules" }</p>
			<p>Firebase needs some additional configuration so that we can get the details of only one element<a id="_idIndexMarker364"/> within the list, so let's do that now:</p>
			<ol>
				<li>Navigate to your<a id="_idIndexMarker365"/> Firebase console and log into your Google account by accessing this link: <a href="https://console.firebase.google.com/">https://console.firebase.google.com/</a>.</li>
				<li>From <a id="_idIndexMarker366"/>the list of Firebase projects, select the one you've previously created to store the restaurants.</li>
				<li>In the left menu, expand the <strong class="bold">Build</strong> tab, search for <strong class="bold">Realtime Database</strong>, and then select it.</li>
				<li>Move away from the preselected <strong class="bold">Data</strong> tab and select the <strong class="bold">Rules</strong> tab.</li>
				<li>We need to allow Firebase to index the restaurants based on their <strong class="source-inline">r_id</strong> field, so update the write <strong class="source-inline">rules</strong> as follows:<p class="source-code">{</p><p class="source-code">    "rules": {</p><p class="source-code">        ".read": "true",</p><p class="source-code"><strong class="bold">        ".write": "true",</strong></p><p class="source-code"><strong class="bold">        "restaurants": {</strong></p><p class="source-code"><strong class="bold">          ".indexOn": ["r_id"]</strong></p><p class="source-code"><strong class="bold">         }</strong></p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>By doing so, we've instructed Firebase that the JSON array content located at the <strong class="source-inline">restaurants</strong> node can be indexed and accessed individually.</p>
			<ol>
				<li value="6">Now, try to access the URL with the details for the restaurant with the <strong class="source-inline">id</strong> field value of <strong class="source-inline">2</strong> again:</li>
			</ol>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/B17788_05_3.jpg" alt="Figure 5.3 – Obtaining the response from Firebase for one restaurant JSON object&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – Obtaining the response from Firebase for one restaurant JSON object</p>
			<p class="callout-heading">Note:</p>
			<p class="callout">To see the structure of the JSON response in a more readable manner in your browser, you can add the <strong class="source-inline">&amp;print=pretty</strong> query parameter at the end of the request URL.</p>
			<p>Success! We've<a id="_idIndexMarker367"/> obtained the details of the restaurant with the <strong class="source-inline">r_id</strong> field's value of <strong class="source-inline">2</strong>.</p>
			<p>Now, let's <a id="_idIndexMarker368"/>implement this request in our app:</p>
			<ol>
				<li value="1">First, inside the <strong class="source-inline">RestaurantsApiService</strong> interface, define a <strong class="source-inline">suspend</strong> function called <strong class="source-inline">getRestaurant()</strong>, which will serve as another <strong class="source-inline">@GET</strong> HTTP method that will get the details of one restaurant:<p class="source-code">interface RestaurantsApiService {</p><p class="source-code"><strong class="bold">    […]</strong></p><p class="source-code"><strong class="bold">    @GET("restaurants.jso<a id="_idTextAnchor152"/>n?orderBy=\"r_id\"")</strong></p><p class="source-code"><strong class="bold">    suspend fun getRestaurant(</strong></p><p class="source-code"><strong class="bold">      @Query("equalTo") id: Int): Unit</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>Let's break down the code we've just added to our second HTTP method:</p>
			<ul>
				<li>The HTTP call defined by this method is an async job that takes some time to finish, so we've marked the method as a suspending function by adding the <strong class="source-inline">suspend</strong> keyword.</li>
				<li>Inside the <strong class="source-inline">@GET</strong> annotation, we specified not only that we want to access the <strong class="source-inline">restaurants.json</strong> JSON content, but this time we also hardcoded the <strong class="source-inline">orderBy</strong> query parameter and specified the <strong class="source-inline">r_id</strong> value so that we filter the elements by the value of their <strong class="source-inline">r_id</strong> key.</li>
				<li>This<a id="_idIndexMarker369"/> method receives one essential parameter – <strong class="source-inline">id: Int</strong> that represents the unique ID of <a id="_idIndexMarker370"/>the restaurant corresponding to the <strong class="source-inline">r_id</strong> field in the database. To tell Retrofit that this method parameter is a query parameter in the required HTTP call, we've annotated it with the <strong class="source-inline">@Query</strong> annotation and passed the <strong class="source-inline">"equalTo"</strong> value.</li>
			</ul>
			<p>Yet our HTTP call defined by our <strong class="source-inline">getRestaurant()</strong> method is missing something crucial: the response type. We've set <strong class="source-inline">Unit</strong> as the response type, but we need to receive a proper response object. To see what to expect, let's have a closer look at the response we received earlier on inside our browser:</p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/B17788_05_4.jpg" alt="Figure 5.4 – The JSON response structure of the restaurant object&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4 – The JSON response structure of the restaurant object</p>
			<p>If we look at these fields, <strong class="source-inline">is_shutdown</strong>, <strong class="source-inline">r_description</strong>, <strong class="source-inline">r_id</strong>, and <strong class="source-inline">r_title</strong>, we can easily identify the response JSON object as the same JSON object that we receive in the existing HTTP request that gets all the restaurants.</p>
			<p>And since we've mapped such a JSON object in the past to our <strong class="source-inline">Restaurant</strong> data class using the <strong class="source-inline">@Serialized</strong> annotations, we could very well say our new <strong class="source-inline">getRestaurant()</strong> HTTP call will receive a simple <strong class="source-inline">Restaurant</strong> object as a response.</p>
			<p>We wouldn't be far from the truth, yet this response wouldn't be fully correct.</p>
			<p>If we look closer at the previous JSON response, we notice that the restaurant JSON object is a value object that corresponds to a <strong class="source-inline">String</strong> key with the value of <strong class="source-inline">2</strong>:</p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/B17788_05_5.jpg" alt="Figure 5.5 –Identifying the key field for the restaurant object&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5 –Identifying the key field for the restaurant object</p>
			<p>This <a id="_idIndexMarker371"/>key <a id="_idIndexMarker372"/>corresponds to an internal index generated by Firebase that represents the order number in which the corresponding restaurant was added to the database. This response structure isn't typical for most REST API responses, yet Firebase has this quirk of wrapping your JSON object in a key that is unknown at compile time.</p>
			<ol>
				<li value="2">To g<a id="_idTextAnchor153"/>et around this, inside the <strong class="source-inline">RestaurantsApiService</strong> interface, update the <strong class="source-inline">getRestaurant()</strong> method to return a <strong class="source-inline">Map</strong> object with an unknown <strong class="source-inline">String</strong> key and a <strong class="source-inline">Restaurant</strong> data type as the value:<p class="source-code">interface RestaurantsApiService {</p><p class="source-code">    …</p><p class="source-code">    @GET("restaurants.json?orderBy=\"r_id\"")</p><p class="source-code">    suspend fun getRestaurant(@Query("eq<a id="_idTextAnchor154"/>ualTo") id: Int)</p><p class="source-code">      : <strong class="bold">Map&lt;String, Restaurant&gt;</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>Great work! We have our app ready to execute a second network request that obtains the details about a specific restaurant, so it's time to call this request.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor155"/>Getting the contents of a specific restaurant</h2>
			<p>Now that we<a id="_idIndexMarker373"/> know how to obtain the details about a specific restaurant, it's time to execute our newly defined ne<a id="_idTextAnchor156"/>twork request.</p>
			<p>Our <a id="_idIndexMarker374"/>existing <strong class="source-inline">RestaurantsScreen</strong> composable delegates the responsibility of requesting the list of restaurants that must be displayed to a <strong class="source-inline">ViewModel</strong> class, so let's create another <strong class="source-inline">ViewModel</strong> so that our second screen can do the same:</p>
			<ol>
				<li value="1">Create a new file by left-clicking the application package, selecting <strong class="bold">New</strong>, and t<a id="_idTextAnchor157"/>hen <strong class="bold">Kotlin Class/File</strong>. Enter <strong class="source-inline">RestaurantDetailsViewModel</strong> as the name and select <strong class="bold">File</strong> as the type. Inside the newly created file, add the following code:<p class="source-code">class RestaurantDetailsViewModel(): ViewModel() {</p><p class="source-code">    private var restInterface: RestaurantsApiService</p><p class="source-code">    init {</p><p class="source-code">        val retrofit: Retrofit = Retrofit.Builder()</p><p class="source-code">            .addConverterFactory(GsonConverterFactory</p><p class="source-code">                .create())</p><p class="source-code">            .baseUrl("your-firebase-base-url")</p><p class="source-code">            .build()</p><p class="source-code">        restInterface = retrofit.create(</p><p class="source-code">            RestaurantsApiService::class.java)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>In the preceding snippet, we've created a <strong class="source-inline">ViewModel</strong> class where we instantiated a Retrofit client of type <strong class="source-inline">RestaurantsApiService</strong>, just like we did in the <strong class="source-inline">RestaurantsViewModel</strong> class.</p>
			<p>The <a id="_idIndexMarker375"/>block of code that<a id="_idIndexMarker376"/> initializes a Retrofit client is indeed duplicated in both our <strong class="source-inline">ViewModel</strong> classes, but don't worry because you will be able to fix this during <a href="B17788_09_ePub.xhtml#_idTextAnchor293"><em class="italic">Chapter 9</em></a>, <em class="italic">Implementing Dependency Injection with Jetpack Hilt</em>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Remember to pass your Firebase database URL to the <strong class="source-inline">baseUrl()</strong> method. This URL should be identical to the one used in the <strong class="source-inline">RestaurantsViewModel</strong> class and should correspond to your Firebase Realtime Database project.</p>
			<ol>
				<li value="2">Inside the newly created <strong class="source-inline">ViewModel</strong>, create a <strong class="source-inline">getRemoteRestaurant()</strong> method that receives an <strong class="source-inline">id</strong> parameter and takes care of executing the network request to get the details of a specific restaurant:<p class="source-code">class RestaurantDetailsViewModel() : ViewModel() {</p><p class="source-code">    private var restInterface: RestaurantsApiService</p><p class="source-code">     init { […] }</p><p class="source-code">    <strong class="bold">private suspend fun getRemoteRestaurant(id: Int):</strong></p><p class="source-code"><strong class="bold">            Restaurant {</strong></p><p class="source-code"><strong class="bold">        return withContext(Dispatchers.IO) {</strong></p><p class="source-code"><strong class="bold">            val responseMap = restInterface</strong></p><p class="source-code"><strong class="bold">                .getRestaurant(id)</strong></p><p class="source-code"><strong class="bold">            return@withContext responseMap.values.first()</strong></p><p class="source-code"><strong class="bold">        }</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>Let's break down what happens inside the <strong class="source-inline">getRemoteRestaurant()</strong> method:</p>
			<ul>
				<li>It<a id="_idIndexMarker377"/> receives an <strong class="source-inline">id</strong> parameter corresponding to the restaurant whose details we need and returns the specific <strong class="source-inline">Restaurant</strong> object.</li>
				<li>It is <a id="_idIndexMarker378"/>marked by the <strong class="source-inline">suspend</strong> keyword since the job of executing a network request is a suspending work that shouldn't block the main thread.</li>
				<li>It is wrapped in a <strong class="source-inline">withContext()</strong> block that specifies the <strong class="source-inline">Dispatchers.IO</strong> dispatcher since the suspending work should be run on the specialized IO thread.</li>
				<li>It executes the network request to obtain the details of a restaurant by calling the <strong class="source-inline">getRestaurant()</strong> suspending function on <strong class="source-inline">restInterface</strong> while passing <strong class="source-inline">id</strong> of the specific restaurant.</li>
				<li>Finally, it obtains <strong class="source-inline">Map&lt;String, Restaurant&gt;</strong> from the REST API. To unwrap this and obtain the restaurant, we call the <strong class="source-inline">values()</strong> function of <strong class="source-inline">Map</strong> and get the first <strong class="source-inline">Restaurant</strong> object with the <strong class="source-inline">.first()</strong> extension function.</li>
			</ul>
			<p class="callout-heading">Note:</p>
			<p class="callout">The <strong class="source-inline">first()</strong> extension function is called on the <strong class="source-inline">Collection&lt;Restaurant&gt;</strong> object returned by the <strong class="source-inline">values()</strong> function of <strong class="source-inline">Map</strong>. With this extension function, we are obtaining the first element, that is, the <strong class="source-inline">Restaurant</strong> object we're interested in. However, the <strong class="source-inline">first()</strong> extension function can throw a <strong class="source-inline">NoSuchElementException</strong> if for some reason we query for a non-existent restaurant. In production, you should cover this case as well by catching such an exception.</p>
			<ol>
				<li value="3">Since <strong class="source-inline">RestaurantDetailsViewModel</strong> will hold the state of the restaurant details screen, add a <strong class="source-inline">MutableState</strong> object that will hold a <strong class="source-inline">Restaurant</strong> object<a id="_idIndexMarker379"/> and initialize it with a <strong class="source-inline">null</strong> value until we finish executing the network request that retrieves it:<p class="source-code">class RestaurantDetailsViewModel(): ViewModel() {</p><p class="source-code">    private var restIn<a id="_idTextAnchor158"/>terface: RestaurantsApiService</p><p class="source-code">    <strong class="bold">val state = mutableStateOf&lt;Restaurant?&gt;(null)</strong></p><p class="source-code">     […]</p><p class="source-code">}</p></li>
				<li>Inside <a id="_idIndexMarker380"/>the <strong class="source-inline">init</strong> block of <strong class="source-inline">RestaurantDetailsViewModel</strong>, below the instantiation of the Retrofit client, launch a coroutine with the help of the <strong class="source-inline">viewModelScope</strong> builder:<p class="source-code">init {</p><p class="source-code">    […]</p><p class="source-code"><strong class="bold">    </strong>restInterface = retrofit.create(…)</p><p class="source-code"><strong class="bold">    viewModelScope.launch {</strong></p><p class="source-code"><strong class="bold">        val restaurant = getRemoteRestaurant(2)</strong></p><p class="source-code"><strong class="bold">  <a id="_idTextAnchor159"/>      state.value = restaurant</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>We needed to launch a coroutine because the job of getting a <strong class="source-inline">Restaurant</strong> object from our remote Firebase API would have blocked the main thread. We've used the built-in <strong class="source-inline">viewModelScope</strong> coroutine builder to make sure that the launched coroutine will live as long as the <strong class="source-inline">RestaurantDetailsViewModel</strong> instance does. Inside the coroutine, we did the following:</p>
			<ol>
				<li value="1">We first called the suspending <strong class="source-inline">getRemoteRestaurants()</strong> function and passed a hardcoded value of <strong class="source-inline">2</strong> as the <strong class="source-inline">id</strong> of the restaurant. At this time, <strong class="source-inline">RestaurantsViewModel</strong> has no idea what's the <strong class="source-inline">id</strong> of the restaurant that it's looking for – we will fix this soon when we perform the navigation.</li>
				<li>We<a id="_idIndexMarker381"/> stored the obtained <strong class="source-inline">Restaurant</strong> inside the <strong class="source-inline">restaurant</strong> variable and passed it to the <strong class="source-inline">state</strong> variable of the <strong class="source-inline">RestaurantDetailsViewModel</strong> class so that the UI will be recomposed with the freshly received restaurant content.</li>
			</ol>
			<p>We've <a id="_idIndexMarker382"/>executed the network request to obtain the details about a restaurant and prepared the state so that a Compose-based screen can display its contents. Let's build the new screen up next.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor160"/>Building the restaurant details screen</h2>
			<p>We <a id="_idIndexMarker383"/>need to create a new composable <a id="_idIndexMarker384"/>screen that will display the details about a specific restaurant:</p>
			<ol>
				<li value="1">Create a new file<a id="_idTextAnchor161"/> inside the application package called <strong class="source-inline">RestaurantDetailsScreen</strong> and create the <strong class="source-inline">RestaurantDetailsScreen</strong> composable:<p class="source-code">@Composable</p><p class="source-code">fun RestaurantDetailsScreen() {</p><p class="source-code">    val viewModel: RestaurantDetailsViewModel =         viewModel()</p><p class="source-code">    val item = viewModel.state.value</p><p class="source-code">    if (item !<a id="_idTextAnchor162"/>= null) {</p><p class="source-code">        // composables</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Inside of it, we've instantiated its corresponding <strong class="source-inline">ViewModel</strong> and accessed the <strong class="source-inline">State</strong> object, just like we previously did in the <strong class="source-inline">RestaurantsScreen</strong> composable. The <strong class="source-inline">State</strong> object holds the <strong class="source-inline">Restaurant</strong> object, which we're storing inside the <strong class="source-inline">item</strong> variable. If <strong class="source-inline">item</strong> is not <strong class="source-inline">null</strong>, we will display the details about the restaurant by passing a composable hierarchy.</p>
			<ol>
				<li value="2">Since<a id="_idIndexMarker385"/> we plan to reuse <a id="_idIndexMarker386"/>some composable functions fro<a id="_idTextAnchor163"/>m the first screen, head back inside the <strong class="source-inline">RestaurantsScreen.kt</strong> file and mark the <strong class="source-inline">RestaurantIcon</strong> and <strong class="source-inline">RestaurantDetails</strong> composables as public for use by removing their <strong class="source-inline">private</strong> keywords.</li>
				<li>Add a new parameter to the <strong class="source-inline">RestaurantDetails</strong> composable called <strong class="source-inline">horizontalAlignment</strong> and pass it to the column's <strong class="source-inline">horizontalAlignment</strong> parameter:<p class="source-code">@Composable</p><p class="source-code">fun RestaurantDeta<a id="_idTextAnchor164"/>ils(</p><p class="source-code">    … ,</p><p class="source-code">    modifier: Modifier,</p><p class="source-code">    <strong class="bold">horizontalAlignment: Alignment.Horizontal</strong></p><p class="source-code">                                    <strong class="bold">= Alignment.Start</strong></p><p class="source-code">) {</p><p class="source-code">    Colu<a id="_idTextAnchor165"/>mn(</p><p class="source-code">        modifier = modifier,</p><p class="source-code">        <strong class="bold">horizontalAlignment = horizontalAlignment</strong></p><p class="source-code">    ) { ... }</p><p class="source-code">}</p></li>
			</ol>
			<p>By doing so, we can control how the <strong class="source-inline">Column</strong> children are horizontally aligned so we can change this behavior in the new screen. Since we want <strong class="source-inline">Column</strong> to position its children horizontally to the left by default (so that its effect in the <strong class="source-inline">RestaurantsScreen</strong> composable won't differ), we passed <strong class="source-inline">Alignmen<a id="_idTextAnchor166"/>t.Start</strong> as the default value.</p>
			<ol>
				<li value="4">Inside<a id="_idIndexMarker387"/> the <strong class="source-inline">RestaurantDetailsScreen</strong> composable, add a <strong class="source-inline">Column</strong> instance that contains <strong class="source-inline">RestaurantIcon</strong>, <strong class="source-inline">RestaurantDetails</strong>, and <strong class="source-inline">Text</strong> composables, all <a id="_idIndexMarker388"/>positioned vertically and centered horizontally:<p class="source-code">@Composable</p><p class="source-code">fun RestaurantDetailsScreen() {</p><p class="source-code">    val viewModel: RestaurantDetailsViewModel = </p><p class="source-code">        viewModel()</p><p class="source-code">    val item = viewModel.state.value</p><p class="source-code">    if (item != null) {</p><p class="source-code">        <strong class="bold">Column(</strong></p><p class="source-code"><strong class="bold">            horizontalAlignment = </strong></p><p class="source-code"><strong class="bold">                Alignment.CenterHorizontally,</strong></p><p class="source-code"><strong class="bold">            modifier = </strong></p><p class="source-code"><strong class="bold">                Modifier.fillMaxSize().padding(16.dp)</strong></p><p class="source-code"><strong class="bold">        ) {</strong></p><p class="source-code"><strong class="bold">            RestaurantIcon(</strong></p><p class="source-code"><strong class="bold">                Icons.Filled.Place,</strong></p><p class="source-code"><strong class="bold">                Modifier.padding(</strong></p><p class="source-code"><strong class="bold">                    top = 32.dp, </strong></p><p class="source-code"><strong class="bold">                    bottom = 32.dp</strong></p><p class="source-code"><strong class="bold">                )</strong></p><p class="source-code"><strong class="bold">            )</strong></p><p class="source-code"><strong class="bold">            RestaurantDetails(</strong></p><p class="source-code"><strong class="bold">                item.title,</strong></p><p class="source-code"><strong class="bold">                item.description,</strong></p><p class="source-code"><strong class="bold">                Modifier.padding(bottom = 32.dp),</strong></p><p class="source-code"><strong class="bold">                Alignment.CenterHorizontally)</strong></p><p class="source-code"><strong class="bold">            Text("More info coming soon!")</strong></p><p class="source-code"><strong class="bold">        }</strong></p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>To prove how simple it is to reuse composables, we've passed the same <strong class="source-inline">RestaurantIcon</strong> and <strong class="source-inline">RestaurantDetails</strong> composables used in the first screen to our <strong class="source-inline">Column</strong>. We've configured them with different <strong class="source-inline">Modifier</strong> objects and additionally passed <strong class="source-inline">Alignment.centerHorizontally</strong> to the <strong class="source-inline">RestaurantDetails</strong> composable's new alignment parameter added previously.</p>
			<ol>
				<li value="5">To<a id="_idIndexMarker389"/> test that everything <a id="_idIndexMarker390"/>works fine, and our new screen renders the details of the hardcoded restaurant with an <strong class="source-inline">id</strong> value of <strong class="source-inline">2</strong>, navigate back to <strong class="source-inline">MainActivity</strong> and inside the <strong class="source-inline">setContent</strong> method, replace the <strong class="source-inline">RestaurantsScreen</strong> composable with <strong class="source-inline">RestaurantDetailsScreen</strong>:<p class="source-code">setContent {</p><p class="source-code"><strong class="bold">    </strong>RestaurantsAppT<a id="_idTextAnchor167"/>heme {</p><p class="source-code"><strong class="bold">        //RestaurantsScreen()</strong></p><p class="source-code"><strong class="bold">        RestaurantDetailsScreen()</strong></p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Run the application and we get the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/B17788_05_6.jpg" alt="Figure 5.6 – Displaying the RestaurantDetailsScreen() composable&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.6 – Displaying the RestaurantDetailsScreen() composable</p>
			<p>Awesome! We<a id="_idIndexMarker391"/> have now created <a id="_idIndexMarker392"/>our second screen, the restaurant details screen. We can now start thinking about the navigation between our two screens.</p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor168"/>Implementing navigation with Jetpack Navigation</h1>
			<p>Navigation <a id="_idIndexMarker393"/>within apps represents those interactions that allow the user to navigate back and forth between several screens.</p>
			<p>In our <a id="_idIndexMarker394"/>Restaurants application, we now have two screens, and we want to navigate from the first one to the second one. In the first screen, we display a list of restaurants and when the users press on one restaurant item from the list, we want to take them to the second screen, the details screen:</p>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/B17788_05_7.jpg" alt="Figure 5.7 – Navigation from list screen to details screen&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.7 – Navigation from list screen to details screen</p>
			<p>Basically, we<a id="_idIndexMarker395"/> want to perform a simple navigation action from the <strong class="source-inline">RestaurantsScreen</strong> composable to the <strong class="source-inline">RestaurantDetailsScreen</strong> composable. To achieve a simple navigation action, we need to implement a navigation<a id="_idIndexMarker396"/> library that will not only allow us to transition from the first screen to the second screen but should also allow us to return to the previous screen with the press of the <strong class="bold">Back</strong> button.</p>
			<p>As we already know, the Jetpack Navigation component comes to our rescue as it will help us implement such a behavior! Let's start with the following steps:</p>
			<ol>
				<li value="1">Inside the <strong class="source-inline">build.gradle</strong> file in the app module, add the dependency for the Navigation component with Compose inside the dependencies block:<p class="source-code">implementation "androidx.navigation:navigation-compose:2.4.2"</p></li>
			</ol>
			<p>After updating the <strong class="source-inline">build.gradle</strong> file, make sure to sync your project with its Gradle files. You can do that by pressing on the <strong class="bold">File</strong> menu option and then by selecting <strong class="bold">Sync Project with Gradle Files</strong>.</p>
			<ol>
				<li value="2">Inside the <strong class="source-inline">MainActivity</strong> class, create a new empty composable function called <strong class="source-inline">RestaurantsA<a id="_idTextAnchor169"/>pp()</strong>:<p class="source-code">@Composable</p><p class="source-code">private fun RestaurantsApp() {</p><p class="source-code">}</p></li>
			</ol>
			<p>This <a id="_idIndexMarker397"/>composable <a id="_idIndexMarker398"/>function will act as the parent composable function of our Restaurants application. Here, all the screens of the app will be defined.</p>
			<ol>
				<li value="3">Inside the <strong class="source-inline">onCreate()</strong> method, replace the <strong class="source-inline">RestaurantsDetailsScreen()</strong> composable that is passed to the <strong class="source-inline">setContent</strong> method with the <strong class="source-inline">RestaurantsApp()</strong> composable:<p class="source-code">setContent {</p><p class="source-code">    RestaurantsAppTheme {</p><p class="source-code">        <strong class="bold">RestaurantsApp()</strong></p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Inside the <strong class="source-inline">RestaurantsApp()</strong> composable function, instantiate <strong class="source-inline">NavController</strong> via the <strong class="source-inline">remem<a id="_idTextAnchor170"/>berNavController()</strong> meth<a id="_idTextAnchor171"/>od:<p class="source-code">@Composable</p><p class="source-code">private fun RestaurantsApp() {</p><p class="source-code">    <strong class="bold">val navController = rememberNavController()</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">NavController</strong> object handles the navigation between composable screens – it operates on the back stack of composable destinations. This means that across recompositions, it must keep the current state of the navigation stack. For that to happen, it must be a stateful object – that's why we used the <strong class="source-inline">rememberNavController</strong> syntax, which is similar to the <strong class="source-inline">remember</strong> block we've been using when defining <strong class="source-inline">State</strong> objects.</p>
			<ol>
				<li value="5">Next up, we<a id="_idIndexMarker399"/> need to create a <strong class="source-inline">NavHost</strong> container composable that will display the composable <a id="_idIndexMarker400"/>destinations. Every time a navigation action between composables is done, the content within <strong class="source-inline">NavHost</strong> is recomposed automatically.</li>
			</ol>
			<p>Add a <strong class="source-inline">NavHost</strong> composable and pass both, the <strong class="source-inline">NavController</strong> instance created previously and an empty <strong class="source-inline">String</strong> to the <strong class="source-inline">startDestination</strong> parameter:</p>
			<p class="source-code"><strong class="bold">import androidx.navigation.compose.NavHost</strong></p>
			<p class="source-code">[…]</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">private fun RestaurantsApp() {</p>
			<p class="source-code">    val navController = rememberNavController()</p>
			<p class="source-code">    <strong class="bold">NavHost(navController, startDestination = "") {</strong></p>
			<p class="source-code">    <strong class="bold">}</strong></p>
			<p class="source-code">}</p>
			<p>Among other parameters, <strong class="source-inline">NavHost</strong> specifies three mandatory parameters:</p>
			<ul>
				<li>A <strong class="source-inline">navController: NavHostController</strong> object that is associated with a single <strong class="source-inline">NavHost</strong> composable. <strong class="source-inline">NavHost</strong> links <strong class="source-inline">NavController</strong> with a navigation graph that defines the possible destinations of the application. In our case, we've passed the <strong class="source-inline">navController</strong> variable to this parameter.</li>
				<li>A <strong class="source-inline">startDestination: String</strong> object that defines the<a id="_idIndexMarker401"/> entry-point <strong class="bold">route</strong> of the navigation graph. The route is <strong class="source-inline">String</strong>, which defines the path to a specific destination (composable screen). Every destination should have a unique route. In our case, since we haven't defined any routes, we've passed an empty <strong class="source-inline">String</strong> to <strong class="source-inline">startDestination</strong>.</li>
				<li>The <strong class="source-inline">builder: NavGraphBuilder.() -&gt; Unit</strong> trailing lambda parameter, which uses the lambda syntax from the Navigation Kotlin DSL (just like <strong class="source-inline">LazyColumn</strong> or <strong class="source-inline">LazyRow</strong> did with their own DSL) to construct a navigation graph. In here, we should define routes and set corresponding composables, yet so far we've set an empty body <strong class="source-inline">{ }</strong> function to the trailing lambda parameter.</li>
			</ul>
			<ol>
				<li value="6">To build <a id="_idIndexMarker402"/>the navigation graph, we must make use of the <strong class="source-inline">builder</strong> parameter and instead of passing only an empty function, inside of it, we need to start adding routes that specify composable destinations.</li>
			</ol>
			<p>To do <a id="_idIndexMarker403"/>that, make use of the DSL function called <strong class="source-inline">composable()</strong> where you can provide a route string to the <strong class="source-inline">route</strong> parameter and a composable function corresponding to the desired destination to the trailing lambda <strong class="source-inline">conte<a id="_idTextAnchor172"/>nt</strong> parameter:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">private fun RestaurantsApp() {</p>
			<p class="source-code">    val navController = rememberNavController()</p>
			<p class="source-code">    NavHost(</p>
			<p class="source-code">        navController,</p>
			<p class="source-code">        startDestination = <strong class="bold">"restaurants"</strong></p>
			<p class="source-code"><strong class="bold">   </strong> ) {</p>
			<p class="source-code"><strong class="bold">        composable(route = "restaurants") {</strong></p>
			<p class="source-code"><strong class="bold">            RestaurantsScreen()</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Through the <strong class="source-inline">composable()</strong> DSL function, we've created a route with the value of <strong class="source-inline">"restaurants"</strong> that navigates to the <strong class="source-inline">RestaurantsScreen()</strong> composable.</p>
			<p>Additionally, we've passed the same route to the <strong class="source-inline">startDestination</strong> parameter of <strong class="source-inline">NavHost</strong>, thereby making our <strong class="source-inline">RestaurantsScreen()</strong> composable the unique entry point of our application.</p>
			<ol>
				<li value="7">By calling the <strong class="source-inline">composable()</strong> DSL function again inside the navigation graph builder, add another route that points to the <strong class="source-inline">RestaurantDetailsScreen()</strong> destination and that derives from the <strong class="source-inline">"restaurants"</strong> route by appending the <strong class="source-inline">{restaurant_id}</strong> argument placeholder:<p class="source-code">NavHost(navController, startDestination = "...") {</p><p class="source-code"><strong class="bold">    </strong>composable(route = "restaurants") { … }</p><p class="source-code"><strong class="bold">    composable(route = "restaurants/{re<a id="_idTextAnchor173"/>staurant_id}") { </strong></p><p class="source-code"><strong class="bold">        RestaurantDetailsScreen()</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>We <a id="_idIndexMarker404"/>want to<a id="_idIndexMarker405"/> navigate from the <strong class="source-inline">"restaurants"</strong> route to this new route that points to the <strong class="source-inline">RestaurantDetailsSreen()</strong> composable, so the <strong class="source-inline">{restaurant_id}</strong> placeholder will take the <strong class="source-inline">id</strong> value of the restaurant to which we are trying to navigate.</p>
			<p>In practice, this route branches off the <strong class="source-inline">"restaurants"</strong> route, and while being structured similarly to a URL (because of the <strong class="source-inline">"/"</strong> element that delimitates a new path), we can say that this route can have multiple values, depending on <strong class="source-inline">id</strong> of the restaurant we're looking to navigate to. For example, this route can have values at runtime such as <strong class="source-inline">"restaurants/0"</strong> or <strong class="source-inline">"restaurants/2"</strong>.</p>
			<ol>
				<li value="8">Inside the navigation graph, we've defined the routes and their corresponding destinations, but we haven't really performed the actual navigation between the two screens. To do that, we first need to have a trigger or callback that notifies us when the user pressed on a restaurant item within the restaurant list, so we <a id="_idTextAnchor174"/>can navigate to the restaurant details screen.</li>
			</ol>
			<p>Inside the <strong class="source-inline">RestaurantsScreen.kt</strong> file, modify the <strong class="source-inline">RestaurantItem</strong> composable to expose an <strong class="source-inline">onItemClick</strong> callback function that provides us with <strong class="source-inline">id</strong> of the<a id="_idIndexMarker406"/> restaurant that is clicked, and also call it when the entire restaurant's <strong class="source-inline">Card</strong> is pressed on:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun RestaurantItem(item: Restaurant,</p>
			<p class="source-code">        <a id="_idTextAnchor175"/>           onClick: (id: Int) -&gt; Unit, </p>
			<p class="source-code">                   <strong class="bold">onItemClick: (id: Int) -&gt; Unit</strong>) {</p>
			<p class="source-code">    val icon = …</p>
			<p class="source-code">    Card(elevation = 4.dp,</p>
			<p class="source-code">        <a id="_idTextAnchor176"/> <a id="_idTextAnchor177"/>modifier = Modifier</p>
			<p class="source-code">            .padding(8.dp)</p>
			<p class="source-code">            <strong class="bold">.clickable { onItemClick(item.id) }</strong>) { … }</p>
			<p class="source-code">}</p>
			<ol>
				<li value="9">To <a id="_idIndexMarker407"/>prevent confusion, refactor the <strong class="source-inline">RestaurantItem</strong> composable by renaming the old <strong class="source-inline">onClick</strong> parameter to a more suggestive name, such as <strong class="source-inline">onFavoriteClick</strong>:<p class="source-code">@Composa<a id="_idTextAnchor178"/>ble</p><p class="source-code">fun RestaurantItem(item: Restaurant,</p><p class="source-code">                   <strong class="bold">onFavoriteClick</strong>: (id: Int) -&gt; Unit, </p><p class="source-code">                   onItemClick: (id: Int) -&gt; Unit) {</p><p class="source-code">    val icon = …</p><p class="source-code">    Card(…) {</p><p class="source-code">        Row(…) {</p><p class="source-code">            …</p><p class="source-code">            RestaurantIcon(icon, Modifier.weight(0.15f)) </p><p class="source-code">            {</p><p class="source-code">                <strong class="bold">onFavoriteClick</strong>(item.id)</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Inside the <strong class="source-inline">RestaurantsScreen()</strong> composable, add a similar <strong class="source-inline">onItemClick</strong> callback <a id="_idIndexMarker408"/>function<a id="_idIndexMarker409"/> as a parameter, and call it when the <strong class="source-inline">onItemClick</strong> callback comes from the<a id="_idTextAnchor179"/> <strong class="source-inline">RestaurantItem</strong> composable:<p class="source-code">@Composable</p><p class="source-code">fun RestaurantsScreen(<strong class="bold">onItemClick: (id: Int) -&gt; Unit = { }</strong>) {</p><p class="source-code">    val viewModel: RestaurantsViewModel = viewModel()</p><p class="source-code">    LazyColumn(...) {</p><p class="source-code">        items(viewModel.state.value) { restaurant -&gt;</p><p class="source-code">            RestaurantItem(</p><p class="source-code">                restaurant,</p><p class="source-code">                <strong class="bold">onFavoriteClick =</strong></p><p class="source-code">                  { id -&gt; viewModel.toggleFavorite(id) },</p><p class="source-code">                <strong class="bold">onItemClick = { id -&gt; onItemClick(id) })</strong></p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Additionally, we've changed the <strong class="source-inline">onClick</strong> parameter name of the <strong class="source-inline">RestaurantItem</strong> composable call to match its signature of <strong class="source-inline">onFavoriteClick</strong>.</p>
			<p>What we <a id="_idIndexMarker410"/>are <a id="_idIndexMarker411"/>essentially doing is propagating events through callbacks from child composables to parent composables.</p>
			<ol>
				<li value="11">Inside <strong class="source-inline">NavHost</strong>, update the <strong class="source-inline">RestaurantsScreen()</strong> composable destination to listen for navigation callbacks and then, inside the callback, trigger the navigation between composables by calling the <strong class="source-inline">navigate()</strong> method, which expects <strong class="source-inline">route</strong> as a parameter:<p class="source-code">@Composable</p><p class="source-code">private fun RestaurantsApp() {</p><p class="source-code">    val navController = rememberNavController()</p><p class="source-code">    NavHost(navController, startDestination = "...") {</p><p class="source-code">        composable(route = "restaurants") {</p><p class="source-code">            <strong class="bold">RestaurantsScreen { id -&gt;</strong></p><p class="source-code"><strong class="bold">                navController.navigate("restaurants/$id")</strong></p><p class="source-code"><strong class="bold">            }</strong></p><p class="source-code">        }</p><p class="source-code">        composable(</p><p class="source-code">            route = "restaurants/{restaurant_id}"</p><p class="source-code">        ) {</p><p class="source-code">            RestaurantDetailsScreen()</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Inside <a id="_idIndexMarker412"/>the new trailing lambda function of <strong class="source-inline">RestaurantsScreen</strong>, we now receive the <strong class="source-inline">id</strong> value of the restaurant we need to navigate to. To trigger the navigation, we called the <strong class="source-inline">navigate()</strong> method, and to its <strong class="source-inline">route</strong> parameter, we passed the <strong class="source-inline">"restaurants/$id"</strong> string to match the route of our other composable destination, <strong class="source-inline">RestaurantDetailsScreen()</strong>.</p>
			<ol>
				<li value="12">Try running<a id="_idIndexMarker413"/> the application and verify the following.</li>
			</ol>
			<p>When the app is launched, the <strong class="source-inline">RestaurantsScreen()</strong> composable is composed and displayed. In other words, you are at the <strong class="source-inline">"restaurants"</strong> route because we've set this route as <strong class="source-inline">startDestination</strong> for our navigation graph. On the navigation back stack, this destination will be added:</p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/B17788_05_8.jpg" alt="Figure 5.8 – Back stack with the start destination&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.8 – Back stack with the start destination</p>
			<p>When pressing on one of the restaurants on the list, navigation is triggered and you arrive at the <strong class="source-inline">RestaurantDetailsScreen()</strong> composable destination. On top of the navigation back stack this destination will be added:</p>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="image/B17788_05_9.jpg" alt="Figure 5.9 – Back stack after navigating to another destination&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.9 – Back stack after navigating to another destination</p>
			<p>When pressing the system's <strong class="bold">Back</strong> button while being at the <strong class="source-inline">RestaurantDetailsScreen()</strong> destination, you are sent back to the existing destination in the back stack, <strong class="source-inline">RestaurantsScreen()</strong>. This means that on the back stack, the top destination is popped, and only the root destination remains:</p>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/B17788_05_10.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.10 – Back stack after returning to start destination</p>
			<p>The<a id="_idIndexMarker414"/> navigation <a id="_idIndexMarker415"/>works, but if you noticed, it always points to the same restaurant. This happens because of two reasons:</p>
			<ul>
				<li>While we defined the <strong class="source-inline">{restaurant_id}</strong> placeholder argument in the route that points to <strong class="source-inline">RestaurantDetailsScreen()</strong>, we didn't define this argument inside the DSL <strong class="source-inline">composable()</strong> function as a navigation argument, so the Navigation component has no idea how to send it to the route's composable destination.</li>
				<li>Inside <strong class="source-inline">RestaurantDetailsViewModel</strong>, we've hardcoded the id of the restaurant to the value of <strong class="source-inline">2</strong>. </li>
			</ul>
			<p>We want the user to see details about the restaurant that is pressed on, so let's fix these issues and pass the ID of the restaurant dynamically.</p>
			<ol>
				<li value="13">For the <strong class="source-inline">RestaurantDetailsScreen()</strong> destination, apart from <strong class="source-inline">route</strong>, add the <strong class="source-inline">arguments</strong> parameter that expects a list of <strong class="source-inline">NamedNavArgument</strong> objects, and pass such an argument using the <strong class="source-inline">navArgument</strong> function:<p class="source-code">NavHost(navController, startDestination = "..."){</p><p class="source-code">    composable(route = "restaurants") { … }</p><p class="source-code">    composable(</p><p class="source-code">        route = "restaurants/{restaurant_id}",</p><p class="source-code"><strong class="bold">        arguments =</strong></p><p class="source-code"><strong class="bold">            listOf(navArgument("restaurant_id") {</strong></p><p class="source-code"><strong class="bold">                type = NavType.IntType</strong></p><p class="source-code"><strong class="bold">            })</strong></p><p class="source-code">    ) { RestaurantDetailsScreen() }</p><p class="source-code">}</p></li>
			</ol>
			<p>This<a id="_idIndexMarker416"/> argument <a id="_idIndexMarker417"/>specifies the same <strong class="source-inline">"restaurant_id"</strong> key that we've added as a place holder within <strong class="source-inline">route</strong> and allows the Navigation library to expose this argument to the destination composable. Additionally, the <strong class="source-inline">navArgument</strong> function exposes <strong class="source-inline">NavArgumentBuilder</strong>, where we specified the type of the argument to be <strong class="source-inline">IntType</strong>.</p>
			<p>To obtain the argument's value inside the <strong class="source-inline">RestaurantDetailsScreen()</strong> destination, the <strong class="source-inline">composable()</strong> DSL function exposes a <strong class="source-inline">NavBackStackEntr<a id="_idTextAnchor180"/>y</strong> object that allows us to get the value as follows:</p>
			<p class="source-code">composable(…) { navStackEntry -&gt;</p>
			<p class="source-code">    val id =</p>
			<p class="source-code">        navStackEntry.arguments?.getInt("restaurant_id")</p>
			<p class="source-code">    RestaurantDetailsScreen() </p>
			<p class="source-code">}</p>
			<p>Yet our <strong class="source-inline">RestaurantDetailsScreen()</strong> destination doesn't expect the <strong class="source-inline">id</strong> of a restaurant, but <strong class="source-inline">RestaurantDetailsViewModel</strong> does, so we will not perform the previous changes where we access <strong class="source-inline">navStackEntry</strong>; instead, we will do something similar in the <strong class="source-inline">ViewModel</strong> soon enough.</p>
			<ol>
				<li value="14">Behind <a id="_idIndexMarker418"/>the scenes, the Navigation component saves the navigation arguments stored in <strong class="source-inline">NavStackEntry</strong> into <strong class="source-inline">SavedStateHandle</strong>, which our VM exposes. This means that we can take advantage of that, and instead of obtaining the ID of the restaurant inside the <strong class="source-inline">RestaurantDetailsScreen()</strong> composable, we can directly obtain it in <strong class="source-inline">RestaurantDetailsViewModel</strong>.</li>
			</ol>
			<p>First, add<a id="_idIndexMarker419"/> the <strong class="source-inline">SavedStateHandle</strong> parameter to the <strong class="source-inline">RestaurantDetailsViewModel</strong> constructor, just like <a id="_idTextAnchor181"/>we did within <strong class="source-inline">RestaurantsViewModel</strong>:</p>
			<p class="source-code">class RestaurantDetailsViewModel(</p>
			<p class="source-code"><strong class="bold">    private val stateHandle: SavedStateHandle</strong></p>
			<p class="source-code">) : ViewModel() {</p>
			<p class="source-code">    […]</p>
			<p class="source-code">    init { […]  }</p>
			<p class="source-code">    private suspend fun getRemoteRestaurant(id: Int) {</p>
			<p class="source-code">        […]</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<ol>
				<li value="15">Inside of the <strong class="source-inline">init { }</strong> block of <strong class="source-inline">ViewModel</strong>, below the instantiation of the Retrofit client, store the ID of the restaurant inside a new <strong class="source-inline">id</strong> variable while obtaining it dynamically from the <strong class="source-inline">SavedStateHandle</strong> object, and then pass it to the <strong class="source-inline">getRemoteRestaurant()</strong> method call:<p class="source-code">class RestaurantDetailsViewModel(private val stateHandle: SavedStateHandle): ViewModel() {</p><p class="source-code">    …</p><p class="source-code">    init {</p><p class="source-code">        val retrofit: Retrofit = Retrofit[…].build()</p><p class="source-code">        restInterface = […]</p><p class="source-code">        <strong class="bold">val id = stateHandle.get&lt;Int&gt;("restaurant_id") </strong></p><p class="source-code"><strong class="bold">            ?: 0</strong></p><p class="source-code">        viewModelScope.launch {</p><p class="source-code">            val restaurant = getRemoteRestaurant(<strong class="bold">id</strong>)</p><p class="source-code">            state.value = restaurant</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    …</p><p class="source-code">}</p></li>
			</ol>
			<p>We've<a id="_idIndexMarker420"/> instructed <strong class="source-inline">navArgument</strong> that the argument is of type <strong class="source-inline">Int</strong>, so we've obtained it as an <strong class="source-inline">Int</strong> value from <strong class="source-inline">stateHandle</strong> and passed the same <strong class="source-inline">"restaurant_id"</strong> key that we've used to define <strong class="source-inline">navArgument</strong>.</p>
			<p>This <a id="_idIndexMarker421"/>approach will protect us from system-initiated process death scenarios as well. The user could navigate to the <strong class="source-inline">RestaurantDetailsScreen()</strong> destination of a restaurant with an <strong class="source-inline">id</strong> value of <strong class="source-inline">2</strong>, and then minimize the app for a while. In the meantime, the system could decide to kill the process of the app to free up memory, so when the user resumes the app, the system would restore it and provide us with a <strong class="source-inline">SavedStateHandle</strong> object that contains the ID of the restaurant with the value of <strong class="source-inline">2</strong>.</p>
			<p>In conclusion, the app would know to obtain the details of the restaurant the user initially navigated to, so the application behaves correctly for this edge case.</p>
			<ol>
				<li value="16">Run the app again and verify that this time when pressing on one restaurant item in the <strong class="source-inline">RestaurantsScreen()</strong>start destination, the details about this restaurant are displayed in the second destination, <strong class="source-inline">RestaurantDetailsScreen()</strong>.<p class="callout-heading">Note</p><p class="callout">We used the Navigation component with destinations that are composable functions. Inside these composables, we instantiate <strong class="source-inline">ViewModel</strong> objects. Since these composables are in a back stack of destinations, their <strong class="source-inline">ViewModel</strong> objects become scoped to the lifetime of the composables. In other words, with the addition of the Navigation component, the <strong class="source-inline">ViewModel</strong> objects have the same lifetime as the composable screen that they are attached to.</p></li>
			</ol>
			<p>Perfect! Now<a id="_idIndexMarker422"/> our Restaurants app <a id="_idIndexMarker423"/>has two screens that you can navigate between whenever the user presses on a restaurant from within our list. It's time to explore another type of navigation event.</p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor182"/>Adding support for deep links</h1>
			<p><strong class="bold">Deep links</strong> allow<a id="_idIndexMarker424"/> you to redirect users to specific parts of your application without having them go through all the intermediary screens. This technique is especially useful for<a id="_idIndexMarker425"/> marketing campaigns because it can boost user engagement while also providing a good user experience.</p>
			<p>Deep links are usually incorporated within URI schemes or custom schemes. This allows you to configure anything from an image advertisement, text advertisement, or even a QR code that when clicked or scanned redirects you to a specific page of the app. If your app is configured to know how to handle such schemes, the user will be able to open that particular link with your application.</p>
			<p>For example, say<a id="_idIndexMarker426"/> that for our Restaurants application, we start a marketing campaign where we include some advertisements on the internet that showcase some special restaurants. We configure the advertisements to be clickable and to redirect to the following link, which contains the ID of the advertised restaurant, such as <strong class="source-inline">2</strong>: <strong class="source-inline">https://www.restaurantsapp.details.com/2</strong>.</p>
			<p>This URI will not work when loaded into a browser application (because there is no such website), yet we can configure our app to know how to interpret it as a deep link.</p>
			<p>When a user is browsing a search engine and presses on a campaign advertisement for one of our restaurants, the app should know how to handle these actions and should allow the user to be redirected to our application:</p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/B17788_05_11.jpg" alt="Figure 5.11 – Inefficient redirect to our Restaurants app&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.11 – Inefficient redirect to our Restaurants app</p>
			<p>Our application has as the start destination the <strong class="source-inline">RestaurantsScreen()</strong> composable, so the user should manually find the restaurant that was initially presented on the advertisement, and press on it to navigate to the <strong class="source-inline">RestaurantDetailsScreen()</strong> destination.</p>
			<p>This is obviously a bad practice because we don't want the user to perform manual navigations within our app to get to the advertised restaurant. Imagine if other apps required the user to navigate not through one or two screens as per our application, but more screens – this would result in a bad user experience and the campaign would be ineffective.</p>
			<p>Deep links, however, allow<a id="_idIndexMarker427"/> you to automatically redirect the user to your desired destination:</p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/B17788_05_12.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.12 – Direct deep link to the screen of interest</p>
			<p>By redirecting the user directly to the screen of interest, we improve the user experience and expect our advertising campaign to perform better.</p>
			<p>Let's implement <a id="_idIndexMarker428"/>such a deep link in our Restaurants application with the help of the Navigation component library:</p>
			<ol>
				<li value="1">Inside the <strong class="source-inline">RestaurantDetailsScreen()</strong> DSL <strong class="source-inline">composable()</strong> function, apart from <strong class="source-inline">route</strong> and <strong class="source-inline">arguments</strong>, add another parameter called <strong class="source-inline">deepLinks</strong> that expects a list of <strong class="source-inline">NavDeepLink</strong> objects, and pass such an argument using the <strong class="source-inline">navDeepLink</strong> function:<p class="source-code">NavHost(navController, startDestination = "restaurants")</p><p class="source-code">{</p><p class="source-code">  composable(route = "restaurants") {…}</p><p class="source-code">  composable(</p><p class="source-code">    route = "restaurants/{restaurant_id}",</p><p class="source-code">    arguments = listOf(</p><p class="source-code">      navArgument("restaurant_id") {…}</p><p class="source-code">    ),</p><p class="source-code">    <strong class="bold">deepLinks = listOf(navDeepLink {</strong></p><p class="source-code"><strong class="bold">      uriPattern =</strong></p><p class="source-code"><strong class="bold">    "www.restaurantsapp.details.com/{restaurant_id}"</strong></p><p class="source-code"><strong class="bold">      })</strong></p><p class="source-code">     ) { RestaurantDetailsScreen() }</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">navDeepLink</strong> function expects in turn a <strong class="source-inline">NavDeepLinkDslBuilder</strong> extension function that exposes its own DSL. We've set the <strong class="source-inline">uriPattern</strong> DSL variable to expect our custom URI of <strong class="source-inline">www.restaurantsapp.details.com</strong> but also added our placeholder <strong class="source-inline">"restaurant_id"</strong> argument that will allow the Navigation component to parse and provide us with the ID of the restaurant from the deep link.</p>
			<p>Right now, our application knows how to handle a deep link, but only internally.</p>
			<ol>
				<li value="2">To <a id="_idIndexMarker429"/>make our deep link available externally, inside the <strong class="source-inline">AndroidManifest.xml</strong> file, add the following <strong class="source-inline">&lt;intent-filter&gt;</strong> element within our <strong class="source-inline">MainActivity</strong>'s <strong class="source-inline">&lt;activity&gt;</strong> element:<p class="source-code">&lt;application … &gt;</p><p class="source-code">    &lt;activity</p><p class="source-code">        android:name=".MainActivity"</p><p class="source-code">        […] &gt;</p><p class="source-code">        &lt;intent-filter&gt;</p><p class="source-code">            &lt;action android:name="[…].action.MAIN" /&gt;</p><p class="source-code">            &lt;category android:name="[…].LAUNCHER" /&gt;</p><p class="source-code">        &lt;/intent-filter&gt;</p><p class="source-code"><strong class="bold">        &lt;intent-filter&gt;</strong></p><p class="source-code"><strong class="bold">          &lt;data</strong></p><p class="source-code"><strong class="bold">                android:host="www.restaurantsapp.</strong></p><p class="source-code"><strong class="bold">                    details.com"</strong></p><p class="source-code"><strong class="bold">                android:scheme="https" /&gt;</strong></p><p class="source-code"><strong class="bold">          &lt;action android:name="android.intent.</strong></p><p class="source-code"><strong class="bold">              action.VIEW" /&gt;</strong></p><p class="source-code"><strong class="bold">          &lt;category android:name="android.intent.</strong></p><p class="source-code"><strong class="bold">              category.DEFAULT" /&gt;</strong></p><p class="source-code"><strong class="bold">          &lt;categor<a id="_idTextAnchor183"/>y android:name="android.intent.</strong></p><p class="source-code"><strong class="bold">              category.BROWSABLE" /&gt;</strong></p><p class="source-code"><strong class="bold">        &lt;/intent-filter&gt;</strong></p><p class="source-code">    &lt;/activity&gt;</p><p class="source-code">&lt;/application&gt;</p></li>
			</ol>
			<p>Let's break up what we've just added inside the new <strong class="source-inline">&lt;intent-filter&gt;</strong> element:</p>
			<ul>
				<li>A <strong class="source-inline">&lt;data&gt;</strong> element <a id="_idIndexMarker430"/>that specifies the following:</li>
				<li>The <strong class="source-inline">host</strong> parameter as the deep link URI that we've set previously in our navigation graph. This is the URI that our ads should link to.</li>
				<li>The <strong class="source-inline">scheme</strong>  parameter of the deep link as <strong class="source-inline">https</strong>. Every <strong class="source-inline">&lt;data&gt;</strong> element should define a scheme so that the URI is recognized.</li>
				<li>A <strong class="source-inline">&lt;category&gt;</strong> element of <strong class="source-inline">BROWSABLE</strong> that is required for the intent filter to be accessed from web browser apps.</li>
				<li>A <strong class="source-inline">&lt;category&gt;</strong> element of <strong class="source-inline">DEFAULT</strong> that makes the app intercept the deep link's intents implicitly. Without it, the app could be started only if the deep link intent specified the application component name.</li>
			</ul>
			<p>To test<a id="_idIndexMarker431"/> the deep link, we need to simulate a deep link action. Let's imagine that we want to test a deep link that points to a restaurant that has the ID with the value of <strong class="source-inline">2</strong>. The deep link would look like this: <strong class="source-inline">https://www.restaurantsapp.details.com/2</strong>.</p>
			<p>Since we don't have any advertisements that refer to our deep link, we have two options:</p>
			<ul>
				<li>Create a QR code with this URL and then scan it with our device.</li>
				<li>Launch an intent from the command line that simulates the deep link.</li>
			</ul>
			<p>Let's go with the second option.</p>
			<ol>
				<li value="3">Build the project and run the application on an emulator or physical device. This step is needed so that the installed application knows how to respond to our deep link.</li>
				<li>Close the app or minimize it, but make sure you leave your emulator or device connected to Android Studio.</li>
				<li>Open the terminal inside Android Studio, paste the following command and enter it:<p class="source-code"><strong class="bold">$ adb shell am start -W -a android.intent.action.VIEW -d "https://www.restaurantsapp.details.com/2"</strong></p></li>
				<li>The emulator/device that you have connected to Android Studio should now prompt a disambiguation dialog asking you what app you'd like to open the deep link with:</li>
			</ol>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/B17788_05_13.jpg" alt="Figure 5.13 – Disambiguation dialog displayed when launching a deep link&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.13 – Disambiguation dialog displayed when launching a deep link</p>
			<p>Our <a id="_idIndexMarker432"/>application is one of those apps and this means that it has been correctly configured to intercept our deep links.</p>
			<ol>
				<li value="7">Select <strong class="bold">Restaurants app</strong> (or whatever you called your app) and press <strong class="bold">JUST ONCE</strong>. The application should open our <strong class="source-inline">RestaurantDetailsScreen()</strong> destination and show the details of the desired restaurant.</li>
			</ol>
			<p>Optionally, you can try pressing the system's <strong class="bold">Back</strong> button. The Navigation component application knows automatically how to send the user back to the <strong class="source-inline">RestaurantsScreen</strong> composable.</p>
			<p>Now that we've also successfully added deep link functionality to our Restaurant application, it's time to wrap this chapter up.</p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor184"/>Summary</h1>
			<p>In this chapter, we learned how to navigate between screens within our Restaurants application. We did that easily with the help of the Jetpack Navigation component library.</p>
			<p>We started off by learning the basics of the Jetpack Navigation library and understood how easy our life becomes when having to handle navigation back stacks. Afterward, we created a new screen, implemented the Navigation library, and explored how seamless it is to add navigation between composables. Finally, we added support for deep links and made sure to test such a deep link within our app.</p>
			<p>Next up, it's time to focus on improving the quality and architecture of our Restaurants application.</p>
		</div>
	</body></html>