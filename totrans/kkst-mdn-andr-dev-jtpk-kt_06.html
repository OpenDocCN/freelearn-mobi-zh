<html><head></head><body>
		<div><h1 id="_idParaDest-79"><em class="italic"><a id="_idTextAnchor147"/>Chapter 5</em>: Adding Navigation in Compose With Jetpack Navigation</h1>
			<p>In this chapter, we'll focus on a core Jetpack library, the Navigation component. This library is essential to us since it allows us to easily navigate between application screens.</p>
			<p>So far, we have only created a screen in our Restaurants application, where we displayed a list of diners. It's time to step up the game and add another screen to our application!</p>
			<p>In the first section, <em class="italic">Introducing the Jetpack Navigation component</em>, we will explore the basic concepts and elements of the Navigation component. In the second section, <em class="italic">Creating a new Compose-based screen</em>, we will create a new screen to display the details of a specific restaurant and realize that we don't know how to navigate to it. </p>
			<p>In the third section, <em class="italic">Implementing navigation with Jetpack Navigation</em>, we will add the Navigation component to the Restaurants application and use it to navigate to the second screen. Finally, in the <em class="italic">Adding support for deep links</em> section, we will create a deep link to our newly created screen and make sure that our application knows how to handle it.</p>
			<p>To summarize, in this chapter we're going to cover the following main topics:</p>
			<ul>
				<li>Introducing the Jetpack Navigation component</li>
				<li>Creating a new Compose-based screen</li>
				<li>Implementing navigation with Jetpack Navigation</li>
				<li>Adding support for deep links</li>
			</ul>
			<p>Before jumping in, let's set up the technical requirements for this chapter.</p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor148"/>Technical requirements</h1>
			<p>Building Compose-based Android projects with Jetpack Navigation usually requires your day-to-day tools. However, to follow along smoothly, make sure you have the following:</p>
			<ul>
				<li>The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer Android Studio version or even Canary builds, but note that the IDE interface and other generated code files might differ from the ones used throughout this book.</li>
				<li>Kotlin 1.6.10 or newer plugin installed in Android Studio</li>
				<li>The Restaurants app code from the previous chapter</li>
			</ul>
			<p>The starting point for this chapter is represented by the Restaurants application developed in <a href="B17788_04_ePub.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">Handling Async Operations with Coroutines</em>. If you haven't followed the implementation from the previous chapter, access the starting point for this chapter by navigating to the <code>Chapter_04</code> directory of the repository and importing the Android project named <code>chapter_4_restaurants_app</code>.</p>
			<p>To access the solution code for this chapter, navigate to the <code>Chapter_05</code> directory: <a href="https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_05/chapter_5_restaurants_app">https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_05/chapter_5_restaurants_app</a>.</p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor149"/>Introducing the Jetpack Navigation component</h1>
			<p>The <strong class="bold">Navigation</strong> component<a id="_idIndexMarker341"/> is Jetpack's solution to navigation within Android apps. This library allows you to easily implement navigation between the screens of your application.</p>
			<p>To promote a predictable user experience and consistent manner of handling app flows, the Navigation component adheres <a id="_idIndexMarker342"/>to a set of principles. The two most important principles are as follows:</p>
			<ul>
				<li>The application has a fixed <a id="_idIndexMarker343"/>start <strong class="bold">destination</strong> (screen) – this allows the application behavior to be predictable because the app will always present this destination first, no matter where it is being launched from.</li>
			</ul>
			<p>In our Restaurants application, we plan to set the start destination as our existing screen with the list of restaurants (represented by the <code>RestaurantsScreen()</code> composable function). In other words, this is the first screen that the user will always see when launching the app from the Android launcher screen.</p>
			<ul>
				<li>The navigation state <a id="_idIndexMarker344"/>is defined as a stack of destinations, often called <a id="_idIndexMarker345"/>the <strong class="bold">back stack</strong>. When the app is initially started, the stack will contain the app's start destination – let's call this <em class="italic">Screen A</em>. If you navigate from <em class="italic">Screen A</em> to <em class="italic">Screen B</em>, <em class="italic">B</em> will be added on top of the stack. This applies when navigating to <em class="italic">Screen C</em> too. To better understand how the back stack works, let's try to illustrate it in such a scenario:</li>
			</ul>
			<div><div><img src="img/B17788_05_1.jpg" alt="Figure 5.1 – Back stack evolution of screens while the user navigates within the app&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – Back stack evolution of screens while the user navigates within the app</p>
			<p>At the top of the back stack, you will always have the current screen the user is at right now. When navigating back to the previous screen, the top of the back stack is popped, just as we did in <em class="italic">Figure 5.1</em>, where navigating from <em class="italic">Screen C</em> to <em class="italic">Screen B</em> resulted in the pop of <em class="italic">Screen C</em> from the back stack.</p>
			<p>All these operations are always done at the top of the stack, while the back of the stack will always contain the fixed start destination – in our case, <em class="italic">Screen A</em>.</p>
			<p>The Navigation component<a id="_idIndexMarker346"/> takes care of handling the back stack operations behind the scenes for us.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Initially, the Navigation component specialized in offering navigation mainly between <code>Fragment</code> components. Today, the library also supports Compose and the navigation between composable functions.</p>
			<p>Apart from following clear principles when it comes to UI navigation, the Navigation component has three main<a id="_idIndexMarker347"/> constituent elements:</p>
			<ul>
				<li><strong class="bold">Navigation graph</strong>: The<a id="_idIndexMarker348"/> core source <a id="_idIndexMarker349"/>of information related to navigation within your app. In the navigation graph, you define all the destinations as well as the possible paths that the user can take throughout the app to achieve different tasks.</li>
				<li><strong class="bold">NavHost</strong>: A <a id="_idIndexMarker350"/>container composable function that<a id="_idIndexMarker351"/> will display the composable destinations. As the user navigates between different destinations, the content of the navigation host is swapped and recomposed.</li>
				<li><code>NavHost</code> as the user starts navigating between screens.</li>
			</ul>
			<p>Now, when you implement the Navigation component in your Compose-based Android app, you will gain a lot of <a id="_idIndexMarker354"/>benefits. The following lists<a id="_idIndexMarker355"/> some examples:</p>
			<ul>
				<li>You don't need to handle the complexity of navigation between composable functions. The library does that out of the box for you.</li>
				<li>You don't need to handle <em class="italic">Up</em> or <em class="italic">Back</em> actions on your own. If you press the system's <strong class="bold">Back</strong> button, the library will automatically pop the current destination from the back stack and send the user to the previous destination.</li>
				<li>You benefit from scoped <code>ViewModel</code> components to a specific Navigation graph or destination. This means that the <code>ViewModel</code> instance used by a composable destination will live for as long as the composable screen does.</li>
				<li>You<a id="_idIndexMarker356"/> don't need to implement deep links from scratch. Deep links allow you to directly navigate to a specific destination within the app without having to traverse the entire path of screens that get you there. We will see how they work in the <em class="italic">Adding support for deep links</em> section of this chapter.</li>
			</ul>
			<p>Now that we have a basic overview of the elements and advantages of using Jetpack Navigation, it's time to create a new screen so we can implement navigation in our Restaurants application.</p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor150"/>Creating a new Compose-based screen</h1>
			<p>Real-world applications<a id="_idIndexMarker357"/> are required to display a lot of content, so one screen probably won't suffice. So far, our Restaurants application features a simple screen where all the restaurants that we receive from our remote database are displayed.</p>
			<p>Let's practice all the skills we've learned so far by creating a new screen that will display the details of a particular restaurant. The plan is that when users press on a particular restaurant from the list inside our <code>RestaurantsScreen()</code> composable screen, we should take them to a new details screen for that particular restaurant.</p>
			<p>Yet to perform navigation between two screens, we need first to build the second screen. Unlike with the first composable screen, it's time to change our tactic and build it from top to<a id="_idIndexMarker358"/> bottom. Let's build this second feature first by defining the network request, then executing it inside its own <code>ViewModel</code>, and finally creating the composable UI that will consume the data, as follows:</p>
			<ul>
				<li>Defining the HTTP request for the contents of a restaurant</li>
				<li>Getting the contents of a specific restaurant</li>
				<li>Building the restaurant details screen</li>
			</ul>
			<p>Let's start!</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor151"/>Defining the HTTP request for the contents of a restaurant</h2>
			<p>We need to<a id="_idIndexMarker359"/> know how to obtain the data for our new restaurant details screen. Instead of relying on the previously retrieved data (the list of restaurants), we want to make every <a id="_idIndexMarker360"/>screen in our application as independent as possible. This way, we design our application to easily support deep links and we better defend ourselves from events such as a system-initiated process death.</p>
			<p>That's why we will build this new screen so that it gets its own content. In other words, in the new screen, we will get the details for a particular restaurant from the same database where we've obtained the list of restaurants. But how will we do that?</p>
			<p>Remember that the restaurants within our Firebase database have a unique <code>Integer</code> identifier field called <code>r_id</code>, as shown in the following screenshot:</p>
			<div><div><img src="img/B17788_05_2.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – Identifying the unique identifier field for restaurants in Firebase</p>
			<p>We can<a id="_idIndexMarker361"/> use this field to get the details of one specific restaurant. And since <code>r_id</code> is mapped to the <code>id: Int</code> field of the <code>Restaurant</code> object, this means that when the user presses on a restaurant in our <code>RestaurantsScreen</code> composable, we can forward the <code>id</code> value to the second screen.</p>
			<p>In the second <a id="_idIndexMarker362"/>screen, we will execute an API request to our Firebase REST API and pass the value of the unique ID of the restaurant within our app that corresponds to the <code>r_id</code> identifier of the restaurant inside the remote database.</p>
			<p>The Firebase REST API <a id="_idIndexMarker363"/>has us covered for such cases. If we want to get the details of one element from the restaurants JSON content, we must append two query parameters to the same URL used to retrieve the entire restaurants list:</p>
			<ul>
				<li><code>orderBy=r_id</code> to instruct Firebase to filter the elements by their <code>r_id</code> field.</li>
				<li><code>equalTo=2</code> to let Firebase know the value of the <code>r_id</code> field of the restaurant element that we're looking for – in this case <code>2</code>.</li>
			</ul>
			<p>To practice, place in your browser address bar the Firebase URL that you've used to get the restaurants until now and append the previous two query parameters as follows:</p>
			<pre>https://restaurants-db-default-rtdb.firebaseio.com/restaurants.json?<strong class="bold">orderBy="r_id"&amp;equalTo=2</strong></pre>
			<p>If you access your link, the response will, unfortunately, look like this:</p>
			<pre>{ "error" : "Index not defined, add \".indexOn\": \"r_id\", for path \"/restaurants\", to the rules" }</pre>
			<p>Firebase needs some additional configuration so that we can get the details of only one element<a id="_idIndexMarker364"/> within the list, so let's do that now:</p>
			<ol>
				<li>Navigate to your<a id="_idIndexMarker365"/> Firebase console and log into your Google account by accessing this link: <a href="https://console.firebase.google.com/">https://console.firebase.google.com/</a>.</li>
				<li>From <a id="_idIndexMarker366"/>the list of Firebase projects, select the one you've previously created to store the restaurants.</li>
				<li>In the left menu, expand the <strong class="bold">Build</strong> tab, search for <strong class="bold">Realtime Database</strong>, and then select it.</li>
				<li>Move away from the preselected <strong class="bold">Data</strong> tab and select the <strong class="bold">Rules</strong> tab.</li>
				<li>We need to allow Firebase to index the restaurants based on their <code>r_id</code> field, so update the write <code>rules</code> as follows:<pre>{
    "rules": {
        ".read": "true",
<strong class="bold">        ".write": "true",</strong>
<strong class="bold">        "restaurants": {</strong>
<strong class="bold">          ".indexOn": ["r_id"]</strong>
<strong class="bold">         }</strong>
    }
}</pre></li>
			</ol>
			<p>By doing so, we've instructed Firebase that the JSON array content located at the <code>restaurants</code> node can be indexed and accessed individually.</p>
			<ol>
				<li value="6">Now, try to access the URL with the details for the restaurant with the <code>id</code> field value of <code>2</code> again:</li>
			</ol>
			<div><div><img src="img/B17788_05_3.jpg" alt="Figure 5.3 – Obtaining the response from Firebase for one restaurant JSON object&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – Obtaining the response from Firebase for one restaurant JSON object</p>
			<p class="callout-heading">Note:</p>
			<p class="callout">To see the structure of the JSON response in a more readable manner in your browser, you can add the <code>&amp;print=pretty</code> query parameter at the end of the request URL.</p>
			<p>Success! We've<a id="_idIndexMarker367"/> obtained the details of the restaurant with the <code>r_id</code> field's value of <code>2</code>.</p>
			<p>Now, let's <a id="_idIndexMarker368"/>implement this request in our app:</p>
			<ol>
				<li value="1">First, inside the <code>RestaurantsApiService</code> interface, define a <code>suspend</code> function called <code>getRestaurant()</code>, which will serve as another <code>@GET</code> HTTP method that will get the details of one restaurant:<pre>interface RestaurantsApiService {
<strong class="bold">    […]</strong>
<strong class="bold">    @GET("restaurants.jso<a id="_idTextAnchor152"/>n?orderBy=\"r_id\"")</strong>
<strong class="bold">    suspend fun getRestaurant(</strong>
<strong class="bold">      @Query("equalTo") id: Int): Unit</strong>
}</pre></li>
			</ol>
			<p>Let's break down the code we've just added to our second HTTP method:</p>
			<ul>
				<li>The HTTP call defined by this method is an async job that takes some time to finish, so we've marked the method as a suspending function by adding the <code>suspend</code> keyword.</li>
				<li>Inside the <code>@GET</code> annotation, we specified not only that we want to access the <code>restaurants.json</code> JSON content, but this time we also hardcoded the <code>orderBy</code> query parameter and specified the <code>r_id</code> value so that we filter the elements by the value of their <code>r_id</code> key.</li>
				<li>This<a id="_idIndexMarker369"/> method receives one essential parameter – <code>id: Int</code> that represents the unique ID of <a id="_idIndexMarker370"/>the restaurant corresponding to the <code>r_id</code> field in the database. To tell Retrofit that this method parameter is a query parameter in the required HTTP call, we've annotated it with the <code>@Query</code> annotation and passed the <code>"equalTo"</code> value.</li>
			</ul>
			<p>Yet our HTTP call defined by our <code>getRestaurant()</code> method is missing something crucial: the response type. We've set <code>Unit</code> as the response type, but we need to receive a proper response object. To see what to expect, let's have a closer look at the response we received earlier on inside our browser:</p>
			<div><div><img src="img/B17788_05_4.jpg" alt="Figure 5.4 – The JSON response structure of the restaurant object&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4 – The JSON response structure of the restaurant object</p>
			<p>If we look at these fields, <code>is_shutdown</code>, <code>r_description</code>, <code>r_id</code>, and <code>r_title</code>, we can easily identify the response JSON object as the same JSON object that we receive in the existing HTTP request that gets all the restaurants.</p>
			<p>And since we've mapped such a JSON object in the past to our <code>Restaurant</code> data class using the <code>@Serialized</code> annotations, we could very well say our new <code>getRestaurant()</code> HTTP call will receive a simple <code>Restaurant</code> object as a response.</p>
			<p>We wouldn't be far from the truth, yet this response wouldn't be fully correct.</p>
			<p>If we look closer at the previous JSON response, we notice that the restaurant JSON object is a value object that corresponds to a <code>String</code> key with the value of <code>2</code>:</p>
			<div><div><img src="img/B17788_05_5.jpg" alt="Figure 5.5 –Identifying the key field for the restaurant object&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5 –Identifying the key field for the restaurant object</p>
			<p>This <a id="_idIndexMarker371"/>key <a id="_idIndexMarker372"/>corresponds to an internal index generated by Firebase that represents the order number in which the corresponding restaurant was added to the database. This response structure isn't typical for most REST API responses, yet Firebase has this quirk of wrapping your JSON object in a key that is unknown at compile time.</p>
			<ol>
				<li value="2">To g<a id="_idTextAnchor153"/>et around this, inside the <code>RestaurantsApiService</code> interface, update the <code>getRestaurant()</code> method to return a <code>Map</code> object with an unknown <code>String</code> key and a <code>Restaurant</code> data type as the value:<pre>interface RestaurantsApiService {
    …
    @GET("restaurants.json?orderBy=\"r_id\"")
    suspend fun getRestaurant(@Query("eq<a id="_idTextAnchor154"/>ualTo") id: Int)
      : <strong class="bold">Map&lt;String, Restaurant&gt;</strong>
}</pre></li>
			</ol>
			<p>Great work! We have our app ready to execute a second network request that obtains the details about a specific restaurant, so it's time to call this request.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor155"/>Getting the contents of a specific restaurant</h2>
			<p>Now that we<a id="_idIndexMarker373"/> know how to obtain the details about a specific restaurant, it's time to execute our newly defined ne<a id="_idTextAnchor156"/>twork request.</p>
			<p>Our <a id="_idIndexMarker374"/>existing <code>RestaurantsScreen</code> composable delegates the responsibility of requesting the list of restaurants that must be displayed to a <code>ViewModel</code> class, so let's create another <code>ViewModel</code> so that our second screen can do the same:</p>
			<ol>
				<li value="1">Create a new file by left-clicking the application package, selecting <code>RestaurantDetailsViewModel</code> as the name and select <strong class="bold">File</strong> as the type. Inside the newly created file, add the following code:<pre>class RestaurantDetailsViewModel(): ViewModel() {
    private var restInterface: RestaurantsApiService
    init {
        val retrofit: Retrofit = Retrofit.Builder()
            .addConverterFactory(GsonConverterFactory
                .create())
            .baseUrl("your-firebase-base-url")
            .build()
        restInterface = retrofit.create(
            RestaurantsApiService::class.java)
    }
}</pre></li>
			</ol>
			<p>In the preceding snippet, we've created a <code>ViewModel</code> class where we instantiated a Retrofit client of type <code>RestaurantsApiService</code>, just like we did in the <code>RestaurantsViewModel</code> class.</p>
			<p>The <a id="_idIndexMarker375"/>block of code that<a id="_idIndexMarker376"/> initializes a Retrofit client is indeed duplicated in both our <code>ViewModel</code> classes, but don't worry because you will be able to fix this during <a href="B17788_09_ePub.xhtml#_idTextAnchor293"><em class="italic">Chapter 9</em></a>, <em class="italic">Implementing Dependency Injection with Jetpack Hilt</em>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Remember to pass your Firebase database URL to the <code>baseUrl()</code> method. This URL should be identical to the one used in the <code>RestaurantsViewModel</code> class and should correspond to your Firebase Realtime Database project.</p>
			<ol>
				<li value="2">Inside the newly created <code>ViewModel</code>, create a <code>getRemoteRestaurant()</code> method that receives an <code>id</code> parameter and takes care of executing the network request to get the details of a specific restaurant:<pre>class RestaurantDetailsViewModel() : ViewModel() {
    private var restInterface: RestaurantsApiService
     init { […] }
    <strong class="bold">private suspend fun getRemoteRestaurant(id: Int):</strong>
<strong class="bold">            Restaurant {</strong>
<strong class="bold">        return withContext(Dispatchers.IO) {</strong>
<strong class="bold">            val responseMap = restInterface</strong>
<strong class="bold">                .getRestaurant(id)</strong>
<strong class="bold">            return@withContext responseMap.values.first()</strong>
<strong class="bold">        }</strong>
<strong class="bold">    }</strong>
}</pre></li>
			</ol>
			<p>Let's break down what happens inside the <code>getRemoteRestaurant()</code> method:</p>
			<ul>
				<li>It<a id="_idIndexMarker377"/> receives an <code>id</code> parameter corresponding to the restaurant whose details we need and returns the specific <code>Restaurant</code> object.</li>
				<li>It is <a id="_idIndexMarker378"/>marked by the <code>suspend</code> keyword since the job of executing a network request is a suspending work that shouldn't block the main thread.</li>
				<li>It is wrapped in a <code>withContext()</code> block that specifies the <code>Dispatchers.IO</code> dispatcher since the suspending work should be run on the specialized IO thread.</li>
				<li>It executes the network request to obtain the details of a restaurant by calling the <code>getRestaurant()</code> suspending function on <code>restInterface</code> while passing <code>id</code> of the specific restaurant.</li>
				<li>Finally, it obtains <code>Map&lt;String, Restaurant&gt;</code> from the REST API. To unwrap this and obtain the restaurant, we call the <code>values()</code> function of <code>Map</code> and get the first <code>Restaurant</code> object with the <code>.first()</code> extension function.</li>
			</ul>
			<p class="callout-heading">Note:</p>
			<p class="callout">The <code>first()</code> extension function is called on the <code>Collection&lt;Restaurant&gt;</code> object returned by the <code>values()</code> function of <code>Map</code>. With this extension function, we are obtaining the first element, that is, the <code>Restaurant</code> object we're interested in. However, the <code>first()</code> extension function can throw a <code>NoSuchElementException</code> if for some reason we query for a non-existent restaurant. In production, you should cover this case as well by catching such an exception.</p>
			<ol>
				<li value="3">Since <code>RestaurantDetailsViewModel</code> will hold the state of the restaurant details screen, add a <code>MutableState</code> object that will hold a <code>Restaurant</code> object<a id="_idIndexMarker379"/> and initialize it with a <code>null</code> value until we finish executing the network request that retrieves it:<pre>class RestaurantDetailsViewModel(): ViewModel() {
    private var restIn<a id="_idTextAnchor158"/>terface: RestaurantsApiService
    <strong class="bold">val state = mutableStateOf&lt;Restaurant?&gt;(null)</strong>
     […]
}</pre></li>
				<li>Inside <a id="_idIndexMarker380"/>the <code>init</code> block of <code>RestaurantDetailsViewModel</code>, below the instantiation of the Retrofit client, launch a coroutine with the help of the <code>viewModelScope</code> builder:<pre>init {
    […]
<strong class="bold">    </strong>restInterface = retrofit.create(…)
<strong class="bold">    viewModelScope.launch {</strong>
<strong class="bold">        val restaurant = getRemoteRestaurant(2)</strong>
<strong class="bold">  <a id="_idTextAnchor159"/>      state.value = restaurant</strong>
<strong class="bold">    }</strong>
}</pre></li>
			</ol>
			<p>We needed to launch a coroutine because the job of getting a <code>Restaurant</code> object from our remote Firebase API would have blocked the main thread. We've used the built-in <code>viewModelScope</code> coroutine builder to make sure that the launched coroutine will live as long as the <code>RestaurantDetailsViewModel</code> instance does. Inside the coroutine, we did the following:</p>
			<ol>
				<li value="1">We first called the suspending <code>getRemoteRestaurants()</code> function and passed a hardcoded value of <code>2</code> as the <code>id</code> of the restaurant. At this time, <code>RestaurantsViewModel</code> has no idea what's the <code>id</code> of the restaurant that it's looking for – we will fix this soon when we perform the navigation.</li>
				<li>We<a id="_idIndexMarker381"/> stored the obtained <code>Restaurant</code> inside the <code>restaurant</code> variable and passed it to the <code>state</code> variable of the <code>RestaurantDetailsViewModel</code> class so that the UI will be recomposed with the freshly received restaurant content.</li>
			</ol>
			<p>We've <a id="_idIndexMarker382"/>executed the network request to obtain the details about a restaurant and prepared the state so that a Compose-based screen can display its contents. Let's build the new screen up next.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor160"/>Building the restaurant details screen</h2>
			<p>We <a id="_idIndexMarker383"/>need to create a new composable <a id="_idIndexMarker384"/>screen that will display the details about a specific restaurant:</p>
			<ol>
				<li value="1">Create a new file<a id="_idTextAnchor161"/> inside the application package called <code>RestaurantDetailsScreen</code> and create the <code>RestaurantDetailsScreen</code> composable:<pre>@Composable
fun RestaurantDetailsScreen() {
    val viewModel: RestaurantDetailsViewModel =         viewModel()
    val item = viewModel.state.value
    if (item !<a id="_idTextAnchor162"/>= null) {
        // composables
    }
}</pre></li>
			</ol>
			<p>Inside of it, we've instantiated its corresponding <code>ViewModel</code> and accessed the <code>State</code> object, just like we previously did in the <code>RestaurantsScreen</code> composable. The <code>State</code> object holds the <code>Restaurant</code> object, which we're storing inside the <code>item</code> variable. If <code>item</code> is not <code>null</code>, we will display the details about the restaurant by passing a composable hierarchy.</p>
			<ol>
				<li value="2">Since<a id="_idIndexMarker385"/> we plan to reuse <a id="_idIndexMarker386"/>some composable functions fro<a id="_idTextAnchor163"/>m the first screen, head back inside the <code>RestaurantsScreen.kt</code> file and mark the <code>RestaurantIcon</code> and <code>RestaurantDetails</code> composables as public for use by removing their <code>private</code> keywords.</li>
				<li>Add a new parameter to the <code>RestaurantDetails</code> composable called <code>horizontalAlignment</code> and pass it to the column's <code>horizontalAlignment</code> parameter:<pre>@Composable
fun RestaurantDeta<a id="_idTextAnchor164"/>ils(
    … ,
    modifier: Modifier,
    <strong class="bold">horizontalAlignment: Alignment.Horizontal</strong>
                                    <strong class="bold">= Alignment.Start</strong>
) {
    Colu<a id="_idTextAnchor165"/>mn(
        modifier = modifier,
        <strong class="bold">horizontalAlignment = horizontalAlignment</strong>
    ) { ... }
}</pre></li>
			</ol>
			<p>By doing so, we can control how the <code>Column</code> children are horizontally aligned so we can change this behavior in the new screen. Since we want <code>Column</code> to position its children horizontally to the left by default (so that its effect in the <code>RestaurantsScreen</code> composable won't differ), we passed <code>Alignmen<a id="_idTextAnchor166"/>t.Start</code> as the default value.</p>
			<ol>
				<li value="4">Inside<a id="_idIndexMarker387"/> the <code>RestaurantDetailsScreen</code> composable, add a <code>Column</code> instance that contains <code>RestaurantIcon</code>, <code>RestaurantDetails</code>, and <code>Text</code> composables, all <a id="_idIndexMarker388"/>positioned vertically and centered horizontally:<pre>@Composable
fun RestaurantDetailsScreen() {
    val viewModel: RestaurantDetailsViewModel = 
        viewModel()
    val item = viewModel.state.value
    if (item != null) {
        <strong class="bold">Column(</strong>
<strong class="bold">            horizontalAlignment = </strong>
<strong class="bold">                Alignment.CenterHorizontally,</strong>
<strong class="bold">            modifier = </strong>
<strong class="bold">                Modifier.fillMaxSize().padding(16.dp)</strong>
<strong class="bold">        ) {</strong>
<strong class="bold">            RestaurantIcon(</strong>
<strong class="bold">                Icons.Filled.Place,</strong>
<strong class="bold">                Modifier.padding(</strong>
<strong class="bold">                    top = 32.dp, </strong>
<strong class="bold">                    bottom = 32.dp</strong>
<strong class="bold">                )</strong>
<strong class="bold">            )</strong>
<strong class="bold">            RestaurantDetails(</strong>
<strong class="bold">                item.title,</strong>
<strong class="bold">                item.description,</strong>
<strong class="bold">                Modifier.padding(bottom = 32.dp),</strong>
<strong class="bold">                Alignment.CenterHorizontally)</strong>
<strong class="bold">            Text("More info coming soon!")</strong>
<strong class="bold">        }</strong>
    }
}</pre></li>
			</ol>
			<p>To prove how simple it is to reuse composables, we've passed the same <code>RestaurantIcon</code> and <code>RestaurantDetails</code> composables used in the first screen to our <code>Column</code>. We've configured them with different <code>Modifier</code> objects and additionally passed <code>Alignment.centerHorizontally</code> to the <code>RestaurantDetails</code> composable's new alignment parameter added previously.</p>
			<ol>
				<li value="5">To<a id="_idIndexMarker389"/> test that everything <a id="_idIndexMarker390"/>works fine, and our new screen renders the details of the hardcoded restaurant with an <code>id</code> value of <code>2</code>, navigate back to <code>MainActivity</code> and inside the <code>setContent</code> method, replace the <code>RestaurantsScreen</code> composable with <code>RestaurantDetailsScreen</code>:<pre>setContent {
<strong class="bold">    </strong>RestaurantsAppT<a id="_idTextAnchor167"/>heme {
<strong class="bold">        //RestaurantsScreen()</strong>
<strong class="bold">        RestaurantDetailsScreen()</strong>
    }
}</pre></li>
				<li>Run the application and we get the following screenshot:</li>
			</ol>
			<div><div><img src="img/B17788_05_6.jpg" alt="Figure 5.6 – Displaying the RestaurantDetailsScreen() composable&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.6 – Displaying the RestaurantDetailsScreen() composable</p>
			<p>Awesome! We<a id="_idIndexMarker391"/> have now created <a id="_idIndexMarker392"/>our second screen, the restaurant details screen. We can now start thinking about the navigation between our two screens.</p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor168"/>Implementing navigation with Jetpack Navigation</h1>
			<p>Navigation <a id="_idIndexMarker393"/>within apps represents those interactions that allow the user to navigate back and forth between several screens.</p>
			<p>In our <a id="_idIndexMarker394"/>Restaurants application, we now have two screens, and we want to navigate from the first one to the second one. In the first screen, we display a list of restaurants and when the users press on one restaurant item from the list, we want to take them to the second screen, the details screen:</p>
			<div><div><img src="img/B17788_05_7.jpg" alt="Figure 5.7 – Navigation from list screen to details screen&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.7 – Navigation from list screen to details screen</p>
			<p>Basically, we<a id="_idIndexMarker395"/> want to perform a simple navigation action from the <code>RestaurantsScreen</code> composable to the <code>RestaurantDetailsScreen</code> composable. To achieve a simple navigation action, we need to implement a navigation<a id="_idIndexMarker396"/> library that will not only allow us to transition from the first screen to the second screen but should also allow us to return to the previous screen with the press of the <strong class="bold">Back</strong> button.</p>
			<p>As we already know, the Jetpack Navigation component comes to our rescue as it will help us implement such a behavior! Let's start with the following steps:</p>
			<ol>
				<li value="1">Inside the <code>build.gradle</code> file in the app module, add the dependency for the Navigation component with Compose inside the dependencies block:<pre>implementation "androidx.navigation:navigation-compose:2.4.2"</pre></li>
			</ol>
			<p>After updating the <code>build.gradle</code> file, make sure to sync your project with its Gradle files. You can do that by pressing on the <strong class="bold">File</strong> menu option and then by selecting <strong class="bold">Sync Project with Gradle Files</strong>.</p>
			<ol>
				<li value="2">Inside the <code>MainActivity</code> class, create a new empty composable function called <code>RestaurantsA<a id="_idTextAnchor169"/>pp()</code>:<pre>@Composable
private fun RestaurantsApp() {
}</pre></li>
			</ol>
			<p>This <a id="_idIndexMarker397"/>composable <a id="_idIndexMarker398"/>function will act as the parent composable function of our Restaurants application. Here, all the screens of the app will be defined.</p>
			<ol>
				<li value="3">Inside the <code>onCreate()</code> method, replace the <code>RestaurantsDetailsScreen()</code> composable that is passed to the <code>setContent</code> method with the <code>RestaurantsApp()</code> composable:<pre>setContent {
    RestaurantsAppTheme {
        <strong class="bold">RestaurantsApp()</strong>
    }
}</pre></li>
				<li>Inside the <code>RestaurantsApp()</code> composable function, instantiate <code>NavController</code> via the <code>remem<a id="_idTextAnchor170"/>berNavController()</code> meth<a id="_idTextAnchor171"/>od:<pre>@Composable
private fun RestaurantsApp() {
    <strong class="bold">val navController = rememberNavController()</strong>
}</pre></li>
			</ol>
			<p>The <code>NavController</code> object handles the navigation between composable screens – it operates on the back stack of composable destinations. This means that across recompositions, it must keep the current state of the navigation stack. For that to happen, it must be a stateful object – that's why we used the <code>rememberNavController</code> syntax, which is similar to the <code>remember</code> block we've been using when defining <code>State</code> objects.</p>
			<ol>
				<li value="5">Next up, we<a id="_idIndexMarker399"/> need to create a <code>NavHost</code> container composable that will display the composable <a id="_idIndexMarker400"/>destinations. Every time a navigation action between composables is done, the content within <code>NavHost</code> is recomposed automatically.</li>
			</ol>
			<p>Add a <code>NavHost</code> composable and pass both, the <code>NavController</code> instance created previously and an empty <code>String</code> to the <code>startDestination</code> parameter:</p>
			<pre><strong class="bold">import androidx.navigation.compose.NavHost</strong>
[…]
@Composable
private fun RestaurantsApp() {
    val navController = rememberNavController()
    <strong class="bold">NavHost(navController, startDestination = "") {</strong>
    <strong class="bold">}</strong>
}</pre>
			<p>Among other parameters, <code>NavHost</code> specifies three mandatory parameters:</p>
			<ul>
				<li>A <code>navController: NavHostController</code> object that is associated with a single <code>NavHost</code> composable. <code>NavHost</code> links <code>NavController</code> with a navigation graph that defines the possible destinations of the application. In our case, we've passed the <code>navController</code> variable to this parameter.</li>
				<li>A <code>startDestination: String</code> object that defines the<a id="_idIndexMarker401"/> entry-point <code>String</code>, which defines the path to a specific destination (composable screen). Every destination should have a unique route. In our case, since we haven't defined any routes, we've passed an empty <code>String</code> to <code>startDestination</code>.</li>
				<li>The <code>builder: NavGraphBuilder.() -&gt; Unit</code> trailing lambda parameter, which uses the lambda syntax from the Navigation Kotlin DSL (just like <code>LazyColumn</code> or <code>LazyRow</code> did with their own DSL) to construct a navigation graph. In here, we should define routes and set corresponding composables, yet so far we've set an empty body <code>{ }</code> function to the trailing lambda parameter.</li>
			</ul>
			<ol>
				<li value="6">To build <a id="_idIndexMarker402"/>the navigation graph, we must make use of the <code>builder</code> parameter and instead of passing only an empty function, inside of it, we need to start adding routes that specify composable destinations.</li>
			</ol>
			<p>To do <a id="_idIndexMarker403"/>that, make use of the DSL function called <code>composable()</code> where you can provide a route string to the <code>route</code> parameter and a composable function corresponding to the desired destination to the trailing lambda <code>conte<a id="_idTextAnchor172"/>nt</code> parameter:</p>
			<pre>@Composable
private fun RestaurantsApp() {
    val navController = rememberNavController()
    NavHost(
        navController,
        startDestination = <strong class="bold">"restaurants"</strong>
<strong class="bold">   </strong> ) {
<strong class="bold">        composable(route = "restaurants") {</strong>
<strong class="bold">            RestaurantsScreen()</strong>
<strong class="bold">        }</strong>
    }
}</pre>
			<p>Through the <code>composable()</code> DSL function, we've created a route with the value of <code>"restaurants"</code> that navigates to the <code>RestaurantsScreen()</code> composable.</p>
			<p>Additionally, we've passed the same route to the <code>startDestination</code> parameter of <code>NavHost</code>, thereby making our <code>RestaurantsScreen()</code> composable the unique entry point of our application.</p>
			<ol>
				<li value="7">By calling the <code>composable()</code> DSL function again inside the navigation graph builder, add another route that points to the <code>RestaurantDetailsScreen()</code> destination and that derives from the <code>"restaurants"</code> route by appending the <code>{restaurant_id}</code> argument placeholder:<pre>NavHost(navController, startDestination = "...") {
<strong class="bold">    </strong>composable(route = "restaurants") { … }
<strong class="bold">    composable(route = "restaurants/{re<a id="_idTextAnchor173"/>staurant_id}") { </strong>
<strong class="bold">        RestaurantDetailsScreen()</strong>
<strong class="bold">    }</strong>
}</pre></li>
			</ol>
			<p>We <a id="_idIndexMarker404"/>want to<a id="_idIndexMarker405"/> navigate from the <code>"restaurants"</code> route to this new route that points to the <code>RestaurantDetailsSreen()</code> composable, so the <code>{restaurant_id}</code> placeholder will take the <code>id</code> value of the restaurant to which we are trying to navigate.</p>
			<p>In practice, this route branches off the <code>"restaurants"</code> route, and while being structured similarly to a URL (because of the <code>"/"</code> element that delimitates a new path), we can say that this route can have multiple values, depending on <code>id</code> of the restaurant we're looking to navigate to. For example, this route can have values at runtime such as <code>"restaurants/0"</code> or <code>"restaurants/2"</code>.</p>
			<ol>
				<li value="8">Inside the navigation graph, we've defined the routes and their corresponding destinations, but we haven't really performed the actual navigation between the two screens. To do that, we first need to have a trigger or callback that notifies us when the user pressed on a restaurant item within the restaurant list, so we <a id="_idTextAnchor174"/>can navigate to the restaurant details screen.</li>
			</ol>
			<p>Inside the <code>RestaurantsScreen.kt</code> file, modify the <code>RestaurantItem</code> composable to expose an <code>onItemClick</code> callback function that provides us with <code>id</code> of the<a id="_idIndexMarker406"/> restaurant that is clicked, and also call it when the entire restaurant's <code>Card</code> is pressed on:</p>
			<pre>@Composable
fun RestaurantItem(item: Restaurant,
        <a id="_idTextAnchor175"/>           onClick: (id: Int) -&gt; Unit, 
                   <strong class="bold">onItemClick: (id: Int) -&gt; Unit</strong>) {
    val icon = …
    Card(elevation = 4.dp,
        <a id="_idTextAnchor176"/> <a id="_idTextAnchor177"/>modifier = Modifier
            .padding(8.dp)
            <strong class="bold">.clickable { onItemClick(item.id) }</strong>) { … }
}</pre>
			<ol>
				<li value="9">To <a id="_idIndexMarker407"/>prevent confusion, refactor the <code>RestaurantItem</code> composable by renaming the old <code>onClick</code> parameter to a more suggestive name, such as <code>onFavoriteClick</code>:<pre>@Composa<a id="_idTextAnchor178"/>ble
fun RestaurantItem(item: Restaurant,
                   <strong class="bold">onFavoriteClick</strong>: (id: Int) -&gt; Unit, 
                   onItemClick: (id: Int) -&gt; Unit) {
    val icon = …
    Card(…) {
        Row(…) {
            …
            RestaurantIcon(icon, Modifier.weight(0.15f)) 
            {
                <strong class="bold">onFavoriteClick</strong>(item.id)
            }
        }
    }
}</pre></li>
				<li>Inside the <code>RestaurantsScreen()</code> composable, add a similar <code>onItemClick</code> callback <a id="_idIndexMarker408"/>function<a id="_idIndexMarker409"/> as a parameter, and call it when the <code>onItemClick</code> callback comes from the<a id="_idTextAnchor179"/> <code>RestaurantItem</code> composable:<pre>@Composable
fun RestaurantsScreen(<strong class="bold">onItemClick: (id: Int) -&gt; Unit = { }</strong>) {
    val viewModel: RestaurantsViewModel = viewModel()
    LazyColumn(...) {
        items(viewModel.state.value) { restaurant -&gt;
            RestaurantItem(
                restaurant,
                <strong class="bold">onFavoriteClick =</strong>
                  { id -&gt; viewModel.toggleFavorite(id) },
                <strong class="bold">onItemClick = { id -&gt; onItemClick(id) })</strong>
        }
    }
}</pre></li>
			</ol>
			<p>Additionally, we've changed the <code>onClick</code> parameter name of the <code>RestaurantItem</code> composable call to match its signature of <code>onFavoriteClick</code>.</p>
			<p>What we <a id="_idIndexMarker410"/>are <a id="_idIndexMarker411"/>essentially doing is propagating events through callbacks from child composables to parent composables.</p>
			<ol>
				<li value="11">Inside <code>NavHost</code>, update the <code>RestaurantsScreen()</code> composable destination to listen for navigation callbacks and then, inside the callback, trigger the navigation between composables by calling the <code>navigate()</code> method, which expects <code>route</code> as a parameter:<pre>@Composable
private fun RestaurantsApp() {
    val navController = rememberNavController()
    NavHost(navController, startDestination = "...") {
        composable(route = "restaurants") {
            <strong class="bold">RestaurantsScreen { id -&gt;</strong>
<strong class="bold">                navController.navigate("restaurants/$id")</strong>
<strong class="bold">            }</strong>
        }
        composable(
            route = "restaurants/{restaurant_id}"
        ) {
            RestaurantDetailsScreen()
        }
    }
}</pre></li>
			</ol>
			<p>Inside <a id="_idIndexMarker412"/>the new trailing lambda function of <code>RestaurantsScreen</code>, we now receive the <code>id</code> value of the restaurant we need to navigate to. To trigger the navigation, we called the <code>navigate()</code> method, and to its <code>route</code> parameter, we passed the <code>"restaurants/$id"</code> string to match the route of our other composable destination, <code>RestaurantDetailsScreen()</code>.</p>
			<ol>
				<li value="12">Try running<a id="_idIndexMarker413"/> the application and verify the following.</li>
			</ol>
			<p>When the app is launched, the <code>RestaurantsScreen()</code> composable is composed and displayed. In other words, you are at the <code>"restaurants"</code> route because we've set this route as <code>startDestination</code> for our navigation graph. On the navigation back stack, this destination will be added:</p>
			<div><div><img src="img/B17788_05_8.jpg" alt="Figure 5.8 – Back stack with the start destination&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.8 – Back stack with the start destination</p>
			<p>When pressing on one of the restaurants on the list, navigation is triggered and you arrive at the <code>RestaurantDetailsScreen()</code> composable destination. On top of the navigation back stack this destination will be added:</p>
			<div><div><img src="img/B17788_05_9.jpg" alt="Figure 5.9 – Back stack after navigating to another destination&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.9 – Back stack after navigating to another destination</p>
			<p>When pressing the system's <code>RestaurantDetailsScreen()</code> destination, you are sent back to the existing destination in the back stack, <code>RestaurantsScreen()</code>. This means that on the back stack, the top destination is popped, and only the root destination remains:</p>
			<div><div><img src="img/B17788_05_10.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.10 – Back stack after returning to start destination</p>
			<p>The<a id="_idIndexMarker414"/> navigation <a id="_idIndexMarker415"/>works, but if you noticed, it always points to the same restaurant. This happens because of two reasons:</p>
			<ul>
				<li>While we defined the <code>{restaurant_id}</code> placeholder argument in the route that points to <code>RestaurantDetailsScreen()</code>, we didn't define this argument inside the DSL <code>composable()</code> function as a navigation argument, so the Navigation component has no idea how to send it to the route's composable destination.</li>
				<li>Inside <code>RestaurantDetailsViewModel</code>, we've hardcoded the id of the restaurant to the value of <code>2</code>. </li>
			</ul>
			<p>We want the user to see details about the restaurant that is pressed on, so let's fix these issues and pass the ID of the restaurant dynamically.</p>
			<ol>
				<li value="13">For the <code>RestaurantDetailsScreen()</code> destination, apart from <code>route</code>, add the <code>arguments</code> parameter that expects a list of <code>NamedNavArgument</code> objects, and pass such an argument using the <code>navArgument</code> function:<pre>NavHost(navController, startDestination = "..."){
    composable(route = "restaurants") { … }
    composable(
        route = "restaurants/{restaurant_id}",
<strong class="bold">        arguments =</strong>
<strong class="bold">            listOf(navArgument("restaurant_id") {</strong>
<strong class="bold">                type = NavType.IntType</strong>
<strong class="bold">            })</strong>
    ) { RestaurantDetailsScreen() }
}</pre></li>
			</ol>
			<p>This<a id="_idIndexMarker416"/> argument <a id="_idIndexMarker417"/>specifies the same <code>"restaurant_id"</code> key that we've added as a place holder within <code>route</code> and allows the Navigation library to expose this argument to the destination composable. Additionally, the <code>navArgument</code> function exposes <code>NavArgumentBuilder</code>, where we specified the type of the argument to be <code>IntType</code>.</p>
			<p>To obtain the argument's value inside the <code>RestaurantDetailsScreen()</code> destination, the <code>composable()</code> DSL function exposes a <code>NavBackStackEntr<a id="_idTextAnchor180"/>y</code> object that allows us to get the value as follows:</p>
			<pre>composable(…) { navStackEntry -&gt;
    val id =
        navStackEntry.arguments?.getInt("restaurant_id")
    RestaurantDetailsScreen() 
}</pre>
			<p>Yet our <code>RestaurantDetailsScreen()</code> destination doesn't expect the <code>id</code> of a restaurant, but <code>RestaurantDetailsViewModel</code> does, so we will not perform the previous changes where we access <code>navStackEntry</code>; instead, we will do something similar in the <code>ViewModel</code> soon enough.</p>
			<ol>
				<li value="14">Behind <a id="_idIndexMarker418"/>the scenes, the Navigation component saves the navigation arguments stored in <code>NavStackEntry</code> into <code>SavedStateHandle</code>, which our VM exposes. This means that we can take advantage of that, and instead of obtaining the ID of the restaurant inside the <code>RestaurantDetailsScreen()</code> composable, we can directly obtain it in <code>RestaurantDetailsViewModel</code>.</li>
			</ol>
			<p>First, add<a id="_idIndexMarker419"/> the <code>SavedStateHandle</code> parameter to the <code>RestaurantDetailsViewModel</code> constructor, just like <a id="_idTextAnchor181"/>we did within <code>RestaurantsViewModel</code>:</p>
			<pre>class RestaurantDetailsViewModel(
<strong class="bold">    private val stateHandle: SavedStateHandle</strong>
) : ViewModel() {
    […]
    init { […]  }
    private suspend fun getRemoteRestaurant(id: Int) {
        […]
    }
}</pre>
			<ol>
				<li value="15">Inside of the <code>init { }</code> block of <code>ViewModel</code>, below the instantiation of the Retrofit client, store the ID of the restaurant inside a new <code>id</code> variable while obtaining it dynamically from the <code>SavedStateHandle</code> object, and then pass it to the <code>getRemoteRestaurant()</code> method call:<pre>class RestaurantDetailsViewModel(private val stateHandle: SavedStateHandle): ViewModel() {
    …
    init {
        val retrofit: Retrofit = Retrofit[…].build()
        restInterface = […]
        <strong class="bold">val id = stateHandle.get&lt;Int&gt;("restaurant_id") </strong>
<strong class="bold">            ?: 0</strong>
        viewModelScope.launch {
            val restaurant = getRemoteRestaurant(<strong class="bold">id</strong>)
            state.value = restaurant
        }
    }
    …
}</pre></li>
			</ol>
			<p>We've<a id="_idIndexMarker420"/> instructed <code>navArgument</code> that the argument is of type <code>Int</code>, so we've obtained it as an <code>Int</code> value from <code>stateHandle</code> and passed the same <code>"restaurant_id"</code> key that we've used to define <code>navArgument</code>.</p>
			<p>This <a id="_idIndexMarker421"/>approach will protect us from system-initiated process death scenarios as well. The user could navigate to the <code>RestaurantDetailsScreen()</code> destination of a restaurant with an <code>id</code> value of <code>2</code>, and then minimize the app for a while. In the meantime, the system could decide to kill the process of the app to free up memory, so when the user resumes the app, the system would restore it and provide us with a <code>SavedStateHandle</code> object that contains the ID of the restaurant with the value of <code>2</code>.</p>
			<p>In conclusion, the app would know to obtain the details of the restaurant the user initially navigated to, so the application behaves correctly for this edge case.</p>
			<ol>
				<li value="16">Run the app again and verify that this time when pressing on one restaurant item in the <code>RestaurantsScreen()</code>start destination, the details about this restaurant are displayed in the second destination, <code>RestaurantDetailsScreen()</code>.<p class="callout-heading">Note</p><p class="callout">We used the Navigation component with destinations that are composable functions. Inside these composables, we instantiate <code>ViewModel</code> objects. Since these composables are in a back stack of destinations, their <code>ViewModel</code> objects become scoped to the lifetime of the composables. In other words, with the addition of the Navigation component, the <code>ViewModel</code> objects have the same lifetime as the composable screen that they are attached to.</p></li>
			</ol>
			<p>Perfect! Now<a id="_idIndexMarker422"/> our Restaurants app <a id="_idIndexMarker423"/>has two screens that you can navigate between whenever the user presses on a restaurant from within our list. It's time to explore another type of navigation event.</p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor182"/>Adding support for deep links</h1>
			<p><strong class="bold">Deep links</strong> allow<a id="_idIndexMarker424"/> you to redirect users to specific parts of your application without having them go through all the intermediary screens. This technique is especially useful for<a id="_idIndexMarker425"/> marketing campaigns because it can boost user engagement while also providing a good user experience.</p>
			<p>Deep links are usually incorporated within URI schemes or custom schemes. This allows you to configure anything from an image advertisement, text advertisement, or even a QR code that when clicked or scanned redirects you to a specific page of the app. If your app is configured to know how to handle such schemes, the user will be able to open that particular link with your application.</p>
			<p>For example, say<a id="_idIndexMarker426"/> that for our Restaurants application, we start a marketing campaign where we include some advertisements on the internet that showcase some special restaurants. We configure the advertisements to be clickable and to redirect to the following link, which contains the ID of the advertised restaurant, such as <code>2</code>: <code>https://www.restaurantsapp.details.com/2</code>.</p>
			<p>This URI will not work when loaded into a browser application (because there is no such website), yet we can configure our app to know how to interpret it as a deep link.</p>
			<p>When a user is browsing a search engine and presses on a campaign advertisement for one of our restaurants, the app should know how to handle these actions and should allow the user to be redirected to our application:</p>
			<div><div><img src="img/B17788_05_11.jpg" alt="Figure 5.11 – Inefficient redirect to our Restaurants app&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.11 – Inefficient redirect to our Restaurants app</p>
			<p>Our application has as the start destination the <code>RestaurantsScreen()</code> composable, so the user should manually find the restaurant that was initially presented on the advertisement, and press on it to navigate to the <code>RestaurantDetailsScreen()</code> destination.</p>
			<p>This is obviously a bad practice because we don't want the user to perform manual navigations within our app to get to the advertised restaurant. Imagine if other apps required the user to navigate not through one or two screens as per our application, but more screens – this would result in a bad user experience and the campaign would be ineffective.</p>
			<p>Deep links, however, allow<a id="_idIndexMarker427"/> you to automatically redirect the user to your desired destination:</p>
			<div><div><img src="img/B17788_05_12.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.12 – Direct deep link to the screen of interest</p>
			<p>By redirecting the user directly to the screen of interest, we improve the user experience and expect our advertising campaign to perform better.</p>
			<p>Let's implement <a id="_idIndexMarker428"/>such a deep link in our Restaurants application with the help of the Navigation component library:</p>
			<ol>
				<li value="1">Inside the <code>RestaurantDetailsScreen()</code> DSL <code>composable()</code> function, apart from <code>route</code> and <code>arguments</code>, add another parameter called <code>deepLinks</code> that expects a list of <code>NavDeepLink</code> objects, and pass such an argument using the <code>navDeepLink</code> function:<pre>NavHost(navController, startDestination = "restaurants")
{
  composable(route = "restaurants") {…}
  composable(
    route = "restaurants/{restaurant_id}",
    arguments = listOf(
      navArgument("restaurant_id") {…}
    ),
    <strong class="bold">deepLinks = listOf(navDeepLink {</strong>
<strong class="bold">      uriPattern =</strong>
<strong class="bold">    "www.restaurantsapp.details.com/{restaurant_id}"</strong>
<strong class="bold">      })</strong>
     ) { RestaurantDetailsScreen() }
}</pre></li>
			</ol>
			<p>The <code>navDeepLink</code> function expects in turn a <code>NavDeepLinkDslBuilder</code> extension function that exposes its own DSL. We've set the <code>uriPattern</code> DSL variable to expect our custom URI of <code>www.restaurantsapp.details.com</code> but also added our placeholder <code>"restaurant_id"</code> argument that will allow the Navigation component to parse and provide us with the ID of the restaurant from the deep link.</p>
			<p>Right now, our application knows how to handle a deep link, but only internally.</p>
			<ol>
				<li value="2">To <a id="_idIndexMarker429"/>make our deep link available externally, inside the <code>AndroidManifest.xml</code> file, add the following <code>&lt;intent-filter&gt;</code> element within our <code>MainActivity</code>'s <code>&lt;activity&gt;</code> element:<pre>&lt;application … &gt;
    &lt;activity
        android:name=".MainActivity"
        […] &gt;
        &lt;intent-filter&gt;
            &lt;action android:name="[…].action.MAIN" /&gt;
            &lt;category android:name="[…].LAUNCHER" /&gt;
        &lt;/intent-filter&gt;
<strong class="bold">        &lt;intent-filter&gt;</strong>
<strong class="bold">          &lt;data</strong>
<strong class="bold">                android:host="www.restaurantsapp.</strong>
<strong class="bold">                    details.com"</strong>
<strong class="bold">                android:scheme="https" /&gt;</strong>
<strong class="bold">          &lt;action android:name="android.intent.</strong>
<strong class="bold">              action.VIEW" /&gt;</strong>
<strong class="bold">          &lt;category android:name="android.intent.</strong>
<strong class="bold">              category.DEFAULT" /&gt;</strong>
<strong class="bold">          &lt;categor<a id="_idTextAnchor183"/>y android:name="android.intent.</strong>
<strong class="bold">              category.BROWSABLE" /&gt;</strong>
<strong class="bold">        &lt;/intent-filter&gt;</strong>
    &lt;/activity&gt;
&lt;/application&gt;</pre></li>
			</ol>
			<p>Let's break up what we've just added inside the new <code>&lt;intent-filter&gt;</code> element:</p>
			<ul>
				<li>A <code>&lt;data&gt;</code> element <a id="_idIndexMarker430"/>that specifies the following:</li>
				<li>The <code>host</code> parameter as the deep link URI that we've set previously in our navigation graph. This is the URI that our ads should link to.</li>
				<li>The <code>scheme</code>  parameter of the deep link as <code>https</code>. Every <code>&lt;data&gt;</code> element should define a scheme so that the URI is recognized.</li>
				<li>A <code>&lt;category&gt;</code> element of <code>BROWSABLE</code> that is required for the intent filter to be accessed from web browser apps.</li>
				<li>A <code>&lt;category&gt;</code> element of <code>DEFAULT</code> that makes the app intercept the deep link's intents implicitly. Without it, the app could be started only if the deep link intent specified the application component name.</li>
			</ul>
			<p>To test<a id="_idIndexMarker431"/> the deep link, we need to simulate a deep link action. Let's imagine that we want to test a deep link that points to a restaurant that has the ID with the value of <code>2</code>. The deep link would look like this: <code>https://www.restaurantsapp.details.com/2</code>.</p>
			<p>Since we don't have any advertisements that refer to our deep link, we have two options:</p>
			<ul>
				<li>Create a QR code with this URL and then scan it with our device.</li>
				<li>Launch an intent from the command line that simulates the deep link.</li>
			</ul>
			<p>Let's go with the second option.</p>
			<ol>
				<li value="3">Build the project and run the application on an emulator or physical device. This step is needed so that the installed application knows how to respond to our deep link.</li>
				<li>Close the app or minimize it, but make sure you leave your emulator or device connected to Android Studio.</li>
				<li>Open the terminal inside Android Studio, paste the following command and enter it:<pre><strong class="bold">$ adb shell am start -W -a android.intent.action.VIEW -d "https://www.restaurantsapp.details.com/2"</strong></pre></li>
				<li>The emulator/device that you have connected to Android Studio should now prompt a disambiguation dialog asking you what app you'd like to open the deep link with:</li>
			</ol>
			<div><div><img src="img/B17788_05_13.jpg" alt="Figure 5.13 – Disambiguation dialog displayed when launching a deep link&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.13 – Disambiguation dialog displayed when launching a deep link</p>
			<p>Our <a id="_idIndexMarker432"/>application is one of those apps and this means that it has been correctly configured to intercept our deep links.</p>
			<ol>
				<li value="7">Select <code>RestaurantDetailsScreen()</code> destination and show the details of the desired restaurant.</li>
			</ol>
			<p>Optionally, you can try pressing the system's <code>RestaurantsScreen</code> composable.</p>
			<p>Now that we've also successfully added deep link functionality to our Restaurant application, it's time to wrap this chapter up.</p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor184"/>Summary</h1>
			<p>In this chapter, we learned how to navigate between screens within our Restaurants application. We did that easily with the help of the Jetpack Navigation component library.</p>
			<p>We started off by learning the basics of the Jetpack Navigation library and understood how easy our life becomes when having to handle navigation back stacks. Afterward, we created a new screen, implemented the Navigation library, and explored how seamless it is to add navigation between composables. Finally, we added support for deep links and made sure to test such a deep link within our app.</p>
			<p>Next up, it's time to focus on improving the quality and architecture of our Restaurants application.</p>
		</div>
	</body></html>