["```swift\n//get device\nlet device: MTLDevice = MTLCreateSystemDefaultDevice()\n```", "```swift\n//Create Command Queue\nvar commandQueue: MTLCommandQueue = device.newCommandQueue()\n```", "```swift\nlet vertexArray:[Float] = [\n\n    0.0, 0.75, \n\n    -0.75, -0.75, \n\n    0.75, -0.75] \n```", "```swift\nvar vertexBuffer: MTLBuffer! = device.newBufferWithBytes(vertexArray,\nlength: vertexArray.count * sizeofValue(vertexArray[0]),\n                       options: nil)\n```", "```swift\n#include <metal_stdlib>\nusing namespace metal;\n\nvertex float4 myVertexShader(const device float2 * vertex_array [[ buffer(0) ]],\n                             uint vid [[ vertex_id ]]) {\n\n    return float4(vertex_array[vid],0,1);\n}\n\nfragment float4 myFragmentShader() {\n\n    return float4(1.0, 0.0, 1.0, 1.0);\n}\n```", "```swift\nreturn float4(0.56);\n```", "```swift\n//library - collection of functions that can be retrieved by name\nlet defaultLibrary = device.newDefaultLibrary()\nlet newVertexFunction = defaultLibrary!.newFunctionWithName(\"myVertexShader\")\nlet newFragmentFunction = defaultLibrary!.newFunctionWithName(\"myFragmentShader\")\n```", "```swift\n//Render Pipeline\nlet pipelineStateDescriptor = MTLRenderPipelineDescriptor()\n```", "```swift\npipelineStateDescriptor.vertexFunction = newVertexFunction\npipelineStateDescriptor.fragmentFunction = newFragmentFunction\npipelineStateDescriptor.colorAttachments[0].pixelFormat = .BGRA8Unorm\n```", "```swift\n//Render pipeline state from descriptor\nvar pipelineState: MTLRenderPipelineState!\npipelineState = device.newRenderPipelineStateWithDescriptor(\npipelineStateDescriptor,\nerror: nil)\n```", "```swift\n//prepare view with layer\nlet  metalLayer = CAMetalLayer()\nmetalLayer.device = device //set the device\nmetalLayer.pixelFormat = .BGRA8Unorm \nmetalLayer.frame = view.layer.frame \nview.layer.addSublayer(metalLayer) \n```", "```swift\n//get next drawable texture\nvar drawable = metalLayer.nextDrawable() \n```", "```swift\n//create a render descriptor\nlet renderPassDescriptor = MTLRenderPassDescriptor()\n\nrenderPassDescriptor.colorAttachments[0].texture = drawable.texture //assign drawable texture\n\nrenderPassDescriptor.colorAttachments[0].loadAction = .Clear //clear with color on load\n\nrenderPassDescriptor.colorAttachments[0].clearColor = MTLClearColor(red: 1.0,\n            green: 1.0,\n            blue: 0.0,\n            alpha: 1.0) // specify color to clear it with\n```", "```swift\n//Command Buffer - get next available command buffer\nlet commandBuffer = commandQueue.commandBuffer()\n```", "```swift\n//create Encoder - converts code to machine language\nlet renderEncoder:MTLRenderCommandEncoder = commandBuffer.renderCommandEncoderWithDescriptor(renderPassDescriptor)!\n```", "```swift\n//provide pipelineState and vertexBuffer\nrenderEncoder.setRenderPipelineState(pipelineState)\nrenderEncoder.setVertexBuffer(vertexBuffer, offset: 0, atIndex: 0)\n```", "```swift\n//drawing begin\nrenderEncoder.drawPrimitives(.Triangle, vertexStart: 0, vertexCount: 3, instanceCount: 1) //drawin\n```", "```swift\n//End drawing\nrenderEncoder.endEncoding() \n```", "```swift\n//commit to view\ncommandBuffer.presentDrawable(drawable)\ncommandBuffer.commit()\n```", "```swift\nlet vertexArray:[Float] = [\n\n    -1.0, 1.0, 0, 1,  //a\n    -1.0, -1.0, 0, 1, //b\n    1.0, -1.0, 0, 1,  //c    \n    -1.0, 1.0, 0, 1,  //a\n    1.0, -1.0, 0, 1,  //c\n    1.0, 1.0, 0, 1,   //d\n]\n```", "```swift\nlet colorArray:[Float] = [\n\n    1, 0, 0, 1, //a\n    0, 1, 0, 1, //b\n    0, 0, 1, 1, //c\n\n    1, 0, 0, 1, //a\n    0, 0, 1, 1, //c\n    1, 0, 1, 1, //d\n]\n```", "```swift\nlet colorBuffer = device.newBufferWithBytes(colorArray,\n                length: colorArray.count * sizeofValue(colorArray[0]), //sizeof(colorArray)\n                options: nil)\n```", "```swift\nstruct VertexInOut{\n    float4  position [[position]];\n    float4  color;\n};\n```", "```swift\nvertex VertexInOut vertexShader(uint vid [[ vertex_id ]],\n                constant packed_float4* position  [[ buffer(0) ]],\n                constant packed_float4* color    [[ buffer(1) ]]){\n\n    VertexInOut outVertex;\n\n    outVertex.position = position[vid];\n    outVertex.color    = color[vid];\n\n    return outVertex;\n};\n```", "```swift\nfragment half4 fragmentShader(VertexInOut inFrag [[stage_in]]){\n\n    return half4(inFrag.color);\n}; \n```", "```swift\n//draw - prep drawing\n\nrenderEncoder.setRenderPipelineState(pipelineState)\n\nrenderEncoder.setVertexBuffer(vertexBuffer, offset: 0, atIndex: 0)\n\nrenderEncoder.setVertexBuffer(colorBuffer, offset: 0, atIndex: 1)\n\nrenderEncoder.drawPrimitives(.Triangle, vertexStart: 0, vertexCount: 6, instanceCount: 1)\n\nrenderEncoder.endEncoding()\n```", "```swift\npipelineStateDescriptor.vertexFunction = defaultLibrary!.newFunctionWithName(\"vertexShader\")\n\npipelineStateDescriptor.fragmentFunction = defaultLibrary!.newFunctionWithName(\"fragmentShader\")\n\npipelineStateDescriptor.colorAttachments[0].pixelFormat = .BGRA8Unorm\n```", "```swift\nlet vertexArray:[Float] = [\n\n    -0.75, 0.75, 0, 1,  //a\n\n    -0.75, -0.75, 0, 1, //b\n\n    0.75, -0.75, 0, 1,  //c\n\n    -0.75, 0.75, 0, 1,  //a\n\n    0.75, -0.75, 0, 1,  //c\n\n    0.75, 0.75, 0, 1,   //d\n]\n```", "```swift\nlet textureCoordsArray:[Float] = [\n\n    0.0, 0.0, //a\n\n    0.0, 1.0, //b\n\n    1.0, 1.0, //c\n\n    0.0, 0.0, //a\n\n    1.0, 1.0, //c\n\n    1.0, 0.0  //d\n]\n```", "```swift\n//initialize textureCoordBuffer\nlet textureCoordBuffer: MTLBuffer = device.newBufferWithBytes(textureCoordsArray,\nlength: textureCoordsArray.count * sizeofValue(textureCoordsArray[0]),\noptions: nil)\n```", "```swift\n        //get texture\n        let path =  NSBundle.mainBundle().URLForResource(\"Bg2\", withExtension: \"png\")\n        let data = NSData(contentsOfURL: path!)\n```", "```swift\n        let image = UIImage(data: data!)\n```", "```swift\n        let width = CGImageGetWidth(image?.CGImage)\n        let height = CGImageGetHeight(image?.CGImage)\n        let colorSpace = CGColorSpaceCreateDeviceRGB();\n```", "```swift\n        let bitmapData = calloc(height * width * 4, UInt(sizeof(UInt8)))\n```", "```swift\n        let bytesPerPixel: UInt = 4\n        let bytesPerRow: UInt = bytesPerPixel * width\n```", "```swift\n        let bitsPerComponent: UInt = 8\n```", "```swift\n        let context = CGBitmapContextCreate(bitmapData,\n            width,\n            height,\n            bitsPerComponent,\n            bytesPerRow,\n            colorSpace,\n            CGBitmapInfo(CGImageAlphaInfo.PremultipliedLast.rawValue))\n```", "```swift\n        let rect = CGRectMake(0.0,\n    0.0,\n                                CGFloat(width),\n                                CGFloat(height));\n```", "```swift\n        CGContextClearRect(context, rect);\n        CGContextDrawImage(context, rect, image?.CGImage);\n```", "```swift\n        let textureDescriptor  = MTLTextureDescriptor.texture2DDescriptorWithPixelFormat(.RGBA8Unorm,\n            width: Int(width),\n            height: Int(height),\n            mipmapped: false)\n```", "```swift\n        let texture: MTLTexture = device.newTextureWithDescriptor(textureDescriptor)\n```", "```swift\n        let region = MTLRegionMake2D(0, 0, Int(width), Int(height))\n\n        texture.replaceRegion(region,\n            mipmapLevel: 0,\n            slice: 0,\n            withBytes: bitmapData,\n            bytesPerRow: Int(bytesPerRow),\n            bytesPerImage: Int(bytesPerRow * height))\n```", "```swift\nstruct VertexInOut\n{\n    float4  position [[position]];\n    float4  color;\n    float2 m_TexCoord [[user(texturecoord)]];\n};\n```", "```swift\nvertex VertexInOut vertexShader(uint vid [[ vertex_id ]],\n                       constant float4* position  [[ buffer(0) ]],\n                 constant packed_float4* color    [[ buffer(1) ]], \n         constant packed_float2* pTexCoords  [[ buffer(2) ]])\n\n{\n    VertexInOut outVertex;\n\n    outVertex.position =  position[vid];\n    outVertex.color    =  color[vid];\n    outVertex.m_TexCoord = pTexCoords[vid];\n\n    return outVertex;\n};\n```", "```swift\nfragment half4 texturedQuadFragmentShader(\n  VertexInOut inFrag [[ stage_in ]],\n                      texture2d<half>  tex2D     [[ texture(0) ]])\n{\n    constexpr sampler quad_sampler;\n\n    half4 color = tex2D.sample(quad_sampler, inFrag.m_TexCoord);\n\n    return color;\n} \n```", "```swift\nrenderEncoder.setVertexBuffer(colorBuffer, offset: 0, atIndex: 1) \n\nrenderEncoder.setVertexBuffer(textureCoordBuffer, offset: 0, atIndex: 2)\nrenderEncoder.setFragmentTexture(texture, atIndex: 0)\n        â€©renderEncoder.drawPrimitives(.Triangle, vertexStart: 0, vertexCount: 6, instanceCount: 1)\n```", "```swift\npipelineStateDescriptor.vertexFunction = defaultLibrary!.newFunctionWithName(\"vertexShader\")\n\npipelineStateDescriptor.fragmentFunction = defaultLibrary!.newFunctionWithName(\"texturedQuadFragmentShader\")\n\npipelineStateDescriptor.colorAttachments[0].pixelFormat = .BGRA8Unorm\n```"]