- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Using the Room Database and Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Room 数据库和测试
- en: Android applications can benefit significantly from storing data locally. The
    Room persistence library harnesses the power of SQLite. In particular, Room offers
    excellent benefits for Android developers. Furthermore, Room offers offline support,
    and the data is stored locally. In this chapter, we will learn how to implement
    Room, a Jetpack Library.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Android 应用程序可以从本地存储数据中显著受益。Room 持久化库利用了 SQLite 的力量。特别是，Room 为 Android 开发者提供了卓越的好处。此外，Room
    提供了离线支持，数据是本地存储的。在本章中，我们将学习如何实现 Room，一个 Jetpack 库。
- en: 'In this chapter, we’ll be covering the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Implementing Room in your applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的应用程序中实现 Room
- en: Implementing Dependency Injection in Room
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Room 中实现依赖注入
- en: Supporting multiple entities
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持多个实体
- en: Migrating existing SQL database to Room
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将现有的 SQL 数据库迁移到 Room
- en: Testing your local database
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试你的本地数据库
- en: It is also important to mention there are a couple more libraries are used with
    Room – for example, RxJava and Paging integration. In this chapter, we will not
    focus on them but instead on how you can utilize Room to build modern Android
    apps.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要提到的是，还有一些库与 Room 一起使用——例如，RxJava 和分页集成。在本章中，我们不会关注它们，而是专注于如何利用 Room 来构建现代
    Android 应用。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The complete source code for this chapter can be found at [https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_six](https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_six).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节的完整源代码可以在[https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_six](https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_six)找到。
- en: Implementing Room in your applications
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的应用程序中实现 Room
- en: Room is an object-relational mapping library used in Android data persistence
    and is the recommended data persistence in Modern Android Development. In addition,
    it is effortless to use, understand and maintain, and harnesses the powers of
    `SQLiteDatabase`, it also helps reduce boilerplate code, an issue many developers
    experience when using SQLite. Writing tests is also very straightforward and easy
    to understand.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Room 是一个用于 Android 数据持久化的对象关系映射库，是现代 Android 开发中推荐的数据持久化方案。此外，它易于使用、理解和维护，并利用了
    `SQLiteDatabase` 的功能，同时也有助于减少许多开发者在使用 SQLite 时遇到的样板代码问题。编写测试也非常直接且易于理解。
- en: The most notable advantage of Room is that it is easy to integrate with other
    architecture components and gives developers runtime compile checks – that is,
    Room will complain if you make an error or change your schema without migrating,
    which is practical and helps reduce crashes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Room 最显著的优势是它易于与其他架构组件集成，并为开发者提供运行时编译检查——也就是说，如果你在未迁移的情况下犯错或更改了模式，Room 会提出警告，这既实用又有助于减少崩溃。
- en: How to do it…
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Let’s go ahead and create a new empty compose project and call it `RoomExample`.
    In our example project, we will create a form intake from users; this is where
    users can save their first and last names, date of birth, gender, the city they
    live in, and their profession.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的空 Compose 项目，并将其命名为 `RoomExample`。在我们的示例项目中，我们将创建一个用户表单输入；这是用户可以保存他们的名字、姓氏、出生日期、性别、居住的城市以及他们的职业的地方。
- en: 'We will save our user data in our Room database, and then later inspect whether
    the elements we inserted were saved in our database and display the data on the
    screen:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Room 数据库中保存我们的用户数据，然后稍后检查我们插入的元素是否已保存在我们的数据库中，并在屏幕上显示数据：
- en: 'In our newly created project, let’s go ahead and delete the unnecessary wanted
    code – that is, `Greeting(name: String)`, which comes with all empty Compose projects.
    Keep the preview function, since we will use it to view the screen we create.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在我们新创建的项目中，让我们先删除不必要的 wanted 代码——即，所有空 Compose 项目都包含的 `Greeting(name: String)`，保留预览功能，因为我们将会用它来查看我们创建的屏幕。'
- en: 'Now, let’s go on and add the needed dependencies for Room and sync the project.
    We will touch on dependency management using `buildSrc` in [*Chapter 12*](B18827_12.xhtml#_idTextAnchor672),
    *Android Studio Tips and Tricks to Help You during Development*. You can find
    the latest version of Room at [https://developer.android.com/jetpack/androidx/releases/room](https://developer.android.com/jetpack/androidx/releases/room);
    we will add `kapt`, which stands for **Kotlin Annotation Processing Tool**, to
    enable us to use the Java annotation processor with the Kotlin code:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续添加Room所需的依赖并同步项目。我们将在[*第12章*](B18827_12.xhtml#_idTextAnchor672)中介绍如何使用`buildSrc`进行依赖管理，*Android
    Studio技巧和窍门，帮助你开发过程中*。你可以在[https://developer.android.com/jetpack/androidx/releases/room](https://developer.android.com/jetpack/androidx/releases/room)找到Room的最新版本；我们将添加`kapt`，代表**Kotlin
    Annotation Processing Tool**，以使我们能够使用Java注解处理器与Kotlin代码一起使用：
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Create a new package and call it `data`. Inside `data`, create a new Kotlin
    class and call it `UserInformationModel()`. A data class is used to hold data
    only – in our case, the type of data that we will collect from users will be the
    first name, last name, date of birth, and so on.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的包并命名为`data`。在`data`内部创建一个新的Kotlin类并命名为`UserInformationModel()`。数据类用于仅保存数据——在我们的案例中，我们将从用户那里收集的数据类型将是名字、姓氏、出生日期等等。
- en: 'By using Room, we use the `@Entity` annotation to give our model a table name;
    hence, in our newly created `UserInformation` class, let’s go ahead and add the
    `@Entity` annotation and call our table user information:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用Room，我们使用`@Entity`注解给我们的模型一个表名；因此，在我们的新创建的`UserInformation`类中，让我们继续添加`@Entity`注解并称我们的表为用户信息：
- en: '[PRE8]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, as in all databases, we need to define a primary key for our database.
    Hence, in our ID, we will add the `@PrimaryKey` annotation to tell Room that this
    is our primary key, and it should be autogenerated. If you don’t wish to autogenerate,
    you can set the Boolean to `false`, but this might not be a good idea, due to
    conflicts that might arise later in your database:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，就像所有数据库一样，我们需要为我们的数据库定义一个主键。因此，在我们的ID中，我们将添加`@PrimaryKey`注解来告诉Room这是我们主键，并且应该自动生成。如果你不希望自动生成，你可以将布尔值设置为`false`，但这可能不是一个好主意，因为可能会在数据库中引起冲突：
- en: '[PRE18]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, you should have an entity with a table name, a primary key, and your data
    types:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你应该有一个具有表名、主键和你的数据类型的实体：
- en: '[PRE19]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Inside our data package, let us go ahead and create a new package and call it
    `DAO`, which means `UserInformationDao`; this interface will hold the **create**,
    **read**, **update**, and **delete** (**CRUD**) functionality – that is, **update**,
    **insert**, **delete**, and **query**.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的数据包内部，让我们继续创建一个新的包并命名为`DAO`，代表`UserInformationDao`；这个接口将包含**创建**、**读取**、**更新**和**删除**（**CRUD**）功能——即**更新**、**插入**、**删除**和**查询**。
- en: 'We must also annotate our interface with `@Dao` to tell Room that this is our
    DAO. We use `OnConflictStrategy.REPLACE` on the update and `Insert` functions
    to help us with a case where we might encounter conflicts in our database. `OnConflictStrategy`,
    in this case, means that if `Insert` has the same ID, it will replace that data
    with a particular ID:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须在我们的接口上使用`@Dao`注解来告诉Room这是我们自己的DAO。我们在更新和插入函数上使用`OnConflictStrategy.REPLACE`来帮助我们处理可能在我们数据库中遇到的冲突情况。在这种情况下，`OnConflictStrategy`意味着如果`Insert`有相同的ID，它将用特定的ID替换该数据：
- en: '[PRE27]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now that we have our entity and DAO, we will finally create the `Database`
    class, which extends `RoomDatabase()`. In this class, we will use the `@Database`
    annotation, pass in the entity that we created, which is the `UserInformation`
    entity, and give our database a version name, which currently is `one`. We will
    also specify whether our database schema should be exported or not. So, let’s
    go ahead and create the `Database` abstract class:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了实体和DAO，我们最终将创建一个`Database`类，它扩展了`RoomDatabase()`。在这个类中，我们将使用`@Database`注解，传入我们创建的实体，即`UserInformation`实体，并给我们的数据库一个版本名称，目前是`one`。我们还将指定是否应该导出我们的数据库模式。所以，让我们继续创建`Database`抽象类：
- en: '[PRE28]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Finally, we have `Room` set up and ready. Now, we need to add Dependency Injection
    and our user interface; you can find the code in the *Technical requirements*
    section. Also, the UI is quite basic at this stage; you can make it a challenge
    to improve it, as this sample project is just for demonstration purposes.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们已经设置了`Room`并准备好了。现在，我们需要添加依赖注入和用户界面；你可以在*技术要求*部分找到代码。此外，UI在这个阶段相当基础；你可以将其作为一个挑战来改进，因为这个示例项目只是为了演示目的。
- en: "![Figure 6.1 – The\uFEFF app's UI](img/Figure_6.1.jpg)"
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 应用程序的UI](img/Figure_6.1.jpg)'
- en: Figure 6.1 – The app's UI
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 应用程序的 UI
- en: How it works…
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The Modern Android Development Room library has three significant components
    of the Room database:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现代安卓开发 Room 库有三个重要的 Room 数据库组件：
- en: The entity
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体
- en: The DAO
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DAO
- en: The database
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库
- en: '`Entity` is a table within the database. Room generates a table for each class
    that has the `@Entity` annotation; if you have used Java before, you can think
    of the entity as a **plain old Java object** (**POJO**). The entity classes tend
    to be minor, don’t contain any logic, and only hold the data type for the object.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Entity` 是数据库中的一个表。Room 为每个带有 `@Entity` 注解的类生成一个表；如果你之前使用过 Java，你可以把实体想象成 **普通的
    Java 对象**（**POJO**）。实体类通常很小，不包含任何逻辑，只持有对象的数据类型。'
- en: Some significant annotations that map the tables in the database are the foreign
    keys, indices, primary keys, and table names. There are other essential annotations,
    such as `ColumnInfo`, which gives column information, and `Ignore`, which, if
    used, whichever data you wish to ignore will not be persisted by Room.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据库中的表映射的一些重要注解是外键、索引、主键和表名。还有其他重要的注解，例如 `ColumnInfo`，它提供了列信息，以及 `Ignore`，如果使用它，你希望忽略的任何数据将不会被
    Room 持久化。
- en: '![Figure 6.2 – Room DAO](img/Figure_6.2.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – Room DAO](img/Figure_6.2.jpg)'
- en: Figure 6.2 – Room DAO
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – Room DAO
- en: '`@DAO` defines the functions that access the database. Think of it like CRUD;
    if you used SQLite before Room, this is similar to using the cursor objects. Finally,
    `@Database` contains the database functions and serves as the main entry point
    for any underlying connection to our application’s relational data.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`@DAO` 定义了访问数据库的函数。把它想象成 CRUD；如果你在 Room 之前使用过 SQLite，这类似于使用游标对象。最后，`@Database`
    包含数据库函数，并作为任何底层连接到我们应用程序关系数据的入口点。'
- en: If you need to use this, you annotate with `@Database`, as we did in our database
    class. In addition, this class extends `RoomDatabase` and includes the list of
    entities we create. It also contains the abstract method that we create, has no
    arguments, and returns the class that we annotated with `@Dao`. We run the database
    by calling `Room.databaseBuilder()`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要使用这个功能，你可以用 `@Database` 进行注释，就像我们在数据库类中做的那样。此外，这个类扩展了 `RoomDatabase` 并包含了我们创建的实体列表。它还包含了一个我们创建的抽象方法，没有参数，并返回我们用
    `@Dao` 注释的类。我们通过调用 `Room.databaseBuilder()` 来运行数据库。
- en: Implementing Dependency Injection in Room
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Room 中实现依赖注入
- en: As with other recipes, Dependency Injection is vital, and in this recipe, we
    will walk through how we can inject our `DatabaseModule` and provide the Room
    database where it is needed.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他食谱一样，依赖注入至关重要，在这个食谱中，我们将介绍我们如何注入 `DatabaseModule` 并提供所需的 Room 数据库。
- en: Getting ready
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to have prior knowledge of how Hilt works to be able to follow
    this recipe step by step.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够一步一步地跟随这个食谱，你需要先了解 Hilt 的工作原理。
- en: How to do it…
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Open the `RoomExample` project and add Hilt, which is what we will use for
    Dependency Injection. In [*Chapter 3*](B18827_03.xhtml#_idTextAnchor137), *Handling
    the UI State in Jetpack Compose and Using Hilt*, we covered Hilt, so we will not
    discuss it here but just show you how you can use it with Room:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `RoomExample` 项目并添加 Hilt，这是我们用于依赖注入的库。在 [*第 3 章*](B18827_03.xhtml#_idTextAnchor137)，*在
    Jetpack Compose 中处理 UI 状态和使用 Hilt*，我们介绍了 Hilt，所以这里我们不会讨论它，但会展示你如何与 Room 一起使用它：
- en: Open your project and add the necessary Hilt dependency. See [*Chapter 3*](B18827_03.xhtml#_idTextAnchor137),
    *Handling the UI State in Jetpack Compose and Using Hilt*, if you need help setting
    up Hilt or visit [https://dagger.dev/hilt/](https://dagger.dev/hilt/).
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的项目并添加必要的 Hilt 依赖。参见 [*第 3 章*](B18827_03.xhtml#_idTextAnchor137)，*在 Jetpack
    Compose 中处理 UI 状态和使用 Hilt*，如果你需要帮助设置 Hilt 或访问 [https://dagger.dev/hilt/](https://dagger.dev/hilt/)。
- en: 'Next, let’s go ahead and add our `@HiltAndroidApp` class, and in the `Manifest`
    folder, add the name of our `HiltAndroidApp`, in our case, `UserInformation`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们添加我们的 `@HiltAndroidApp` 类，并在 `Manifest` 文件夹中添加我们的 `HiltAndroidApp` 的名称，在我们的例子中，是
    `UserInformation`：
- en: '[PRE33]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now that we have Dependency Injection, let’s go ahead and add `@AndroidEntryPoint`
    in the `MainActivity` class, and in our project, let’s create a new package and
    call it `di`. Inside, we will create a new class, `DatabaseModule`, and add our
    functionalities.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了依赖注入，让我们在 `MainActivity` 类中添加 `@AndroidEntryPoint`，并在我们的项目中创建一个新的包，命名为
    `di`。在里面，我们将创建一个新的类，`DatabaseModule`，并添加我们的功能。
- en: 'In `DatabaseModule`, let’s go ahead and create a `provideDatabase()` function,
    where we will return the `Room` object, add the database name, and ensure we build
    our database:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DatabaseModule`中，让我们继续创建一个`provideDatabase()`函数，我们将返回`Room`对象，添加数据库名称，并确保我们构建了数据库：
- en: '[PRE40]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now that we have our Dependency Injection database module set up, we can now
    start adding the service, which are functions that will help us add user information
    to the database and get user information from the database. So, let us go ahead
    and create a new package called `service`. Inside the package, create a new interface,
    `UserInfoService`, and add the two aforementioned functions:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经设置了依赖注入数据库模块，我们现在可以开始添加服务，这些服务是帮助我们向数据库添加用户信息并从数据库获取用户信息的函数。因此，让我们继续创建一个新的包，名为`service`。在包内部，创建一个新的接口，`UserInfoService`，并添加上述两个函数：
- en: '[PRE62]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Since `UserInfoService` is an interface, we will need to implement the functionalities
    in our `Impl` class, so let us now go ahead and create a new class called `UserInfoServiceImpl`
    and a singleton class, and then implement the interface:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`UserInfoService`是一个接口，我们需要在我们的`Impl`类中实现这些功能，因此现在让我们继续创建一个新的类，名为`UserInfoServiceImpl`，以及一个单例类，然后实现接口：
- en: '[PRE68]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We will need to inject our constructor and pass `UserInformationDao()`, since
    we will use the insert function to insert the user data:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要注入构造函数并传递`UserInformationDao()`，因为我们将会使用插入函数来插入用户数据：
- en: '[PRE79]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now, we need to add code in our functions that have the TODO in them. Let’s
    go ahead and see the user information first. Using `userInformationDao`, we will
    call the insert function to tell Room that we want to insert this user information:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要在我们的函数中添加代码，这些函数中有TODO。让我们先看看用户信息。使用`userInformationDao`，我们将调用插入函数来告诉Room我们想要插入这条用户信息：
- en: '[PRE82]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Then, we need to get the user information from the database; this will visualize
    a user’s data on the screen:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要从数据库中获取用户信息；这将可视化用户数据在屏幕上：
- en: '[PRE95]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Finally, we need to ensure that we provide the implementation through Dependency
    Injection, so let’s now go ahead and add the preceding code, then clean the project,
    run it, and ensure that everything works as expected:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要确保通过依赖注入提供实现，因此现在让我们继续添加前面的代码，然后清理项目，运行它，并确保一切按预期工作：
- en: '[PRE113]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Once you run the project, you should be able to see it launch without issue.
    We will go ahead and add a function in our `ViewModel` to insert the data in our
    database; the `ViewModel` will be used in the views that we created:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦运行项目，你应该能够看到它无问题地启动。我们将继续在我们的`ViewModel`中添加一个函数来将数据插入我们的数据库；`ViewModel`将在我们创建的视图中使用：
- en: '[PRE122]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: We can now inspect the database and see whether it was created correctly. Run
    the app, and once it’s ready in the IDE, click **App Inspection**, as shown in
    *Figure 6**.3*. You should be able to open the Database Inspector.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以检查数据库，看它是否正确创建。运行应用，一旦在IDE中准备就绪，点击**应用检查**，如图**图6.3**所示。你应该能够打开数据库检查器。
- en: '![Figure 6.3 – App Inspection](img/Figure_6.3.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – 应用检查](img/Figure_6.3.jpg)'
- en: Figure 6.3 – App Inspection
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 应用检查
- en: 'Once the Database Inspector is loaded, you should be able to select the currently
    running Android Emulator, as shown in *Figure 6**.4*:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦数据库检查器加载完毕，你应该能够选择当前运行的Android模拟器，如图**图6.4**所示：
- en: '![Figure 6.4 – The selected app for app inspection](img/Figure_6.4.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4 – 用于应用检查的选定应用](img/Figure_6.4.jpg)'
- en: Figure 6.4 – The selected app for app inspection
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 用于应用检查的选定应用
- en: In *Figure 6**.5*, you can see the Database Inspector open and our database.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**图6.5**中，你可以看到数据库检查器已打开，以及我们的数据库。
- en: '![Figure 6.5 – Our user_information database](img/Figure_6.5.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5 – 我们的user_information数据库](img/Figure_6.5.jpg)'
- en: Figure 6.5 – Our user_information database
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – 我们的user_information数据库
- en: In *Figure 6**.6*, you can see that the data we inserted is displayed, which
    means our insert function works as expected.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**图6.6**中，你可以看到我们插入的数据被显示出来，这意味着我们的插入函数按预期工作。
- en: "![Fi\uFEFFgure 6.6 – Our database](img/Figure_6.6.jpg)"
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图6.6 – 我们的数据库](img/Figure_6.6.jpg)'
- en: Figure 6.6 – Our database
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 – 我们的数据库
- en: How it works…
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we opted to use Dependency Injection to supply the needed dependencies
    to specific classes. We covered in depth what Dependency Injection is in previous
    chapters, so we will not explain it again in this recipe but, instead, talk about
    the modules we created.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们选择使用依赖注入来提供所需依赖给特定类。我们在前面的章节中深入介绍了依赖注入是什么，所以在这个菜谱中我们不再解释它，而是讨论我们创建的模块。
- en: We used the `@Singleton` annotation in Hilt to indicate that `provideDatabase`,
    which provides an instance of Room, should be created only once during the lifetime
    of our application, and that this instance should be shared across all the components
    that depend on it. In addition, when you annotate a class or a binding method
    with `@Singleton`, Hilt ensures that only one instance of that class or object
    is created and all the components that need that object will receive the same
    instance.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Hilt 中使用了 `@Singleton` 注解来指示 `provideDatabase`，它提供 Room 的实例，应在应用程序的生命周期内只创建一次，并且这个实例应该被所有依赖它的组件共享。此外，当您使用
    `@Singleton` 注解一个类或绑定方法时，Hilt 确保只创建该类或对象的单个实例，并且所有需要该对象的组件都将接收到相同的实例。
- en: It’s important to also know that when we use `@Singleton` in Hilt, it is not
    the same as the Singleton pattern in software design, which can easily be a source
    of confusion. Hilt’s `@Singleton` only guarantees that one instance of a class
    will be created within the context of a particular component hierarchy.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，当我们使用 Hilt 中的 `@Singleton` 时，它与软件设计中的 Singleton 模式并不相同，这可能会引起混淆。Hilt
    的 `@Singleton` 只保证在特定组件层次结构上下文中创建一个类的单个实例。
- en: 'In our project, we created `DatabaseModule()` and `UserInfoServiceModule()`.
    In the `DatabaseModule()` class, we have two functions, `provideDatabase` and
    `provideUserInformationDao`. The first function, `provideDatabase`, returns the
    `UserInformationDatabase` Room instance, where we get to create the database and
    build it:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，我们创建了 `DatabaseModule()` 和 `UserInfoServiceModule()`。在 `DatabaseModule()`
    类中，我们有两个函数，`provideDatabase` 和 `provideUserInformationDao`。第一个函数 `provideDatabase`
    返回 `UserInformationDatabase` Room 实例，在那里我们可以创建数据库并构建它：
- en: '[PRE133]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'In `provideUserInformationDao`, we pass `UserInformationDatabase` in the constructor
    and return the `UserInformationDao` abstract class:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `provideUserInformationDao` 中，我们在构造函数中传递 `UserInformationDatabase` 并返回 `UserInformationDao`
    抽象类：
- en: '[PRE134]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Important note
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you want to lose existing data when you are migrating or if your migration
    path is missing, you can use the `.fallbackToDestructiveMigration()` function
    when creating the database.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在迁移时想要丢失现有数据，或者您的迁移路径缺失，您可以在创建数据库时使用 `.fallbackToDestructiveMigration()`
    函数。
- en: See also
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: There is more to learn in Room, and this recipe has only given you a brief overview
    of what you can do with it. You can learn more by following the link at [https://developer.android.com/reference/androidx/room/package-summary](https://developer.android.com/reference/androidx/room/package-summary).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Room 中还有更多东西要学习，这个配方只为您提供了一个关于您可以做什么的简要概述。您可以通过点击[https://developer.android.com/reference/androidx/room/package-summary](https://developer.android.com/reference/androidx/room/package-summary)中的链接来了解更多信息。
- en: Supporting multiple entities in Room
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Room 中支持多个实体
- en: In this recipe, you will learn how to handle multiple entities in Room. This
    is useful whenever you have a big project that needs a different data input. An
    excellent example that we can work with is a budgeting app.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将学习如何在 Room 中处理多个实体。这在您有一个需要不同数据输入的大项目时非常有用。我们可以一起工作的一个很好的例子是一个预算应用程序。
- en: 'To support multiple entities in Room, you need to define multiple classes that
    represent your database tables. Each class should have its own annotations and
    fields that correspond to columns in a table. For instance, a budgeting app might
    need different types of models, such as the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Room 中支持多个实体，您需要定义多个类来表示您的数据库表。每个类都应该有自己的注解和字段，这些字段对应于表中的列。例如，一个预算应用程序可能需要不同类型的模型，如下所示：
- en: '`BudgetData`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BudgetData`'
- en: '`ExpenseData`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExpenseData`'
- en: '`ExpenseItem`'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExpenseItem`'
- en: Hence, having multiple entities is sometimes necessary, and knowing how to handle
    that comes in handy.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有时拥有多个实体是必要的，了解如何处理这一点会很有帮助。
- en: Getting ready
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To follow along with this recipe, you must have completed the previous recipe.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随这个配方，您必须完成之前的配方。
- en: How to do it …
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作 …
- en: You can use any project of your choosing to implement the topics discussed in
    this recipe. In addition, you can use this example in your pre-existing project
    to implement the topic.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用您选择的任何项目来实现本配方中讨论的主题。此外，您还可以将此示例用于您现有的项目来实现该主题。
- en: In `RoomExample`, you can add more functionality to the app and try to add more
    entities, but for this project, let’s go ahead and show how you can handle multiple
    entities in Room.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RoomExample` 中，您可以向应用程序添加更多功能并尝试添加更多实体，但在这个项目中，让我们继续展示如何在 Room 中处理多个实体。
- en: 'For this example, we will use the sample budgeting App we introduced in an
    earlier chapter, and since we are working with entities, this will be easier to
    follow. Let’s create a new entity and call it `BudgetData`; the budget data class
    might have several fields, such as `budgetName`, `budgetAmount`, `expenses`, `startDate`,
    `endDate`, `notify`, `currency`, and `totalExpenses`; hence, our `BudgetData`
    data class will look like this:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本例中，我们将使用我们在前一章中介绍的示例预算应用程序，并且由于我们正在处理实体，这将更容易理解。让我们创建一个新的实体，并将其命名为`BudgetData`；预算数据类可能包含多个字段，例如`budgetName`、`budgetAmount`、`expenses`、`startDate`、`endDate`、`notify`、`currency`和`totalExpenses`；因此，我们的`BudgetData`数据类将看起来像这样：
- en: '[PRE135]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Let’s go ahead and add two more entities. First, we will add `ExpenseData`,
    which might have the following fields and types:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续添加两个更多实体。首先，我们将添加`ExpenseData`，它可能包含以下字段和类型：
- en: '[PRE148]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Then, let’s add `ExpenseItem`, which might consist of the following fields:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们添加`ExpenseItem`，它可能包含以下字段：
- en: '[PRE160]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'As you can see, we have three entities; based on these entities, you should
    create different DAOs for each one:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，我们有三个实体；基于这些实体，你应该为每个实体创建不同的DAO：
- en: '[PRE168]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'At the top of the `AppDatabase` abstract class, we will annotate it with `@Database`
    and then pass it to all our entities:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AppDatabase`抽象类的顶部，我们将使用`@Database`注解并传递给所有我们的实体：
- en: '[PRE173]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'You can also use embedded objects; the `@Embedded` annotation includes nested
    or related entities within an entity. It allows you to represent the relationship
    between entities by embedding one or more related entities in the parent entity:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以使用嵌套对象；`@Embedded`注解包括实体内的嵌套或相关实体。它允许你通过在父实体中嵌入一个或多个相关实体来表示实体之间的关系：
- en: '[PRE184]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: In our preceding example, we have annotated the tasks property in the `ExpenseItem`
    entity with the `@Embedded` annotation. This tells Room to include the fields
    of the `Tasks` data class within the `ExpenseItem` table, rather than creating
    a separate table for our `ExpenseItem` entity.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们前面的例子中，我们在`ExpenseItem`实体的任务属性上使用了`@Embedded`注解。这告诉Room将`Tasks`数据类的字段包含在`ExpenseItem`表中，而不是为我们的`ExpenseItem`实体创建一个单独的表。
- en: 'Then, the Tasks data class can have the `description`, `priority`, `updatedAt`,
    and ID:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，`Tasks`数据类可以包含`description`、`priority`、`updatedAt`和ID：
- en: '[PRE189]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: Hence, the table representing the `ExpenseItem` object will contain additional
    columns with the newly added fields.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，表示`ExpenseItem`对象的表将包含具有新添加字段的附加列。
- en: That’s it; once you declare the entities in the database and pass them as required,
    you will have supported multiples entities in your `Database`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样；一旦你在数据库中声明了实体并将它们作为所需内容传递，你将在你的`Database`中支持多个实体。
- en: Important note
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If your entity has multiple embedded fields of the same type, you can keep each
    column unique by setting the `Prefix` property; then, Room will add the provided
    values to the beginning of each column name in the embedded object. Find out more
    at [https://developer.android.com/](https://developer.android.com/).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的实体有多个相同类型的嵌套字段，你可以通过设置`Prefix`属性来保持每个列的唯一性；然后，Room将在嵌套对象中的每个列名前添加提供的值。更多信息请参阅[https://developer.android.com/](https://developer.android.com/).
- en: How it works…
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: According to the rules in Room, you can define an entity relationship in three
    different ways.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Room的规则，你可以以三种不同的方式定义实体关系。
- en: One-to-many relationships or many-to-one relationships
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对多关系或多对一关系
- en: One-to-one relationships
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对一关系
- en: Many-to-many relationships
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多对多关系
- en: As you have already seen, using entities in one class makes it manageable and
    easily trackable; hence, this is an excellent solution for Android engineers.
    A notable annotation is `@Relation`, which specifies where you create an object
    that shows the relationship between your entities.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，在一个类中使用实体使其易于管理和跟踪；因此，这对于Android工程师来说是一个极好的解决方案。一个值得注意的注解是`@Relation`，它指定了创建显示实体之间关系的对象的位置。
- en: There’s more...
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There is more to learn in Room – for instance, defining relationships between
    objects, writing asynchronous data accessible object queries, and referencing
    complex data. It is fair to say we cannot cover everything in just one chapter
    but offer some guidance to help you navigate building Modern Android applications.
    For more on Room, visit [https://developer.android.com/training/data-storage/room](https://developer.android.com/training/data-storage/room).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Room 中还有更多东西要学习——例如，定义对象之间的关系、编写异步数据可访问对象查询以及引用复杂数据。可以说，我们不可能在一章中涵盖所有内容，但我们可以提供一些指导，帮助您导航构建现代
    Android 应用程序。有关 Room 的更多信息，请访问 [https://developer.android.com/training/data-storage/room](https://developer.android.com/training/data-storage/room)。
- en: Migrating an existing SQL database to room
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将现有的 SQL 数据库迁移到 room
- en: As we mentioned earlier, Room does harness the power of SQLite, and because
    many applications still use legacy, you might find applications still using SQL
    and be wondering how you can migrate to Room and utilize the latest Room features.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，Room 确实利用了 SQLite 的力量，并且由于许多应用程序仍在使用遗留版本，您可能会发现一些应用程序仍在使用 SQL，并想知道如何迁移到
    Room 并利用最新的 Room 功能。
- en: In this recipe, we will cover the migration of an existing SQL database to Room
    with step-by-step examples. Furthermore, Room offers an abstraction layer to help
    with SQLite migrations – that is, by offering the `Migration` class to developers.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将通过逐步示例来介绍将现有的 SQL 数据库迁移到 Room。此外，Room 提供了一个抽象层来帮助处理 SQLite 迁移——也就是说，通过向开发者提供
    `Migration` 类。
- en: How to do it…
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Because we did not create a new SQLite database example, since that is not
    necessary, we will try to emulate a scenario with a dummy sample SQLite database
    and showcase how you can migrate your existing SQLite database to Room:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有创建一个新的 SQLite 数据库示例，因为那不是必要的，我们将尝试使用一个虚拟的样本 SQLite 数据库来模拟场景，展示如何将现有的 SQLite
    数据库迁移到 Room：
- en: Since we will be adding Room in an existing SQLite project, you will need to
    ensure you add the required dependencies. To set this up, refer to the *Implementing
    Room in your* *applications* recipe.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将在现有的 SQLite 项目中添加 Room，您需要确保添加所需的依赖项。要设置此环境，请参考 *在您的应用程序中实现 Room* 菜谱。
- en: Next, you will need to go ahead and create a new DAO and entity, since Room
    requires it. Hence, in this set following the first Room recipe, you can update
    the model classes to entities. This is pretty straightforward, since mostly what
    you will do is annotate the classes with `@Entity` and use the table `Names` property
    to set the name of the table.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您需要继续创建一个新的 DAO 和实体，因为 Room 要求这样做。因此，在第一个 Room 菜谱的后续步骤中，您可以更新模型类为实体。这相当简单，因为您主要需要做的是用
    `@Entity` 注解类，并使用 `@Database` 注解中的 `table` 属性来设置表名。
- en: 'You must also add `@PrimaryKey` and `@ColumnInfo` annotations for your entity
    classes. Here is a sample SQLite database:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还必须为实体类添加 `@PrimaryKey` 和 `@ColumnInfo` 注解。以下是一个样本 SQLite 数据库：
- en: '[PRE196]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE224]'
- en: However, Room has simplified the process, and we no longer need to create `Contracts`.
    `Contracts` in Android are a way for developers to define and enforce a set of
    rules for accessing data within an application. These contracts typically define
    the structure and schema of the database tables and the expected data types and
    formats for the data within them. In the case of SQLite on Android, contracts
    are often used to define the tables and columns of the database, as well as any
    constraints or relationships between them.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Room 简化了这个过程，我们不再需要创建 `Contracts`。在 Android 中，`Contracts` 是开发者定义并强制执行一组规则以访问应用程序中数据的方式。这些合约通常定义数据库表的结构和模式，以及其中数据的预期数据类型和格式。在
    Android 的 SQLite 情况下，合约通常用于定义数据库的表和列，以及它们之间任何约束或关系。
- en: 'Once we have created all our needed entities and DAOs, we can go ahead and
    create the database. As we saw in the *Implementing Room in your Applications*
    recipe, we can add all our entities in the `@Database` annotation, and since we
    are in the first `(1)` version, we can increment the version to (`2)`:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们创建了所有需要的实体和 DAO，我们就可以继续创建数据库。正如我们在 *在您的应用程序中实现 Room* 菜谱中看到的，我们可以在 `@Database`
    注解中添加所有我们的实体，并且由于我们处于第一个 `(1)` 版本，我们可以将版本增加到 (`2`)：
- en: '[PRE225]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'Then, the important part is ensuring we call `build()` to the Room database:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，重要的是确保我们调用 `build()` 方法到 Room 数据库：
- en: '[PRE243]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE254]'
- en: 'Once your data layer starts using Room, you can officially replace all the
    `Cursor` and `ContentValue` code with the DAO calls. In our `AppDatabase` class,
    we have our entities, and our class extends `RoomDatabase()`:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你的数据层开始使用Room，你可以正式用DAO调用替换所有的`Cursor`和`ContentValue`代码。在我们的`AppDatabase`类中，我们有我们的实体，并且我们的类扩展了`RoomDatabase()`：
- en: '[PRE255]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE261]'
- en: Because Room offers runtime errors, if any error occurs, you will be notified
    in Logcat.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Room提供了运行时错误，如果发生任何错误，你将在Logcat中收到通知。
- en: It is fair to say that not everything can be covered in one recipe because SQLite
    does require a lot of code to set up – for instance, to create queries and handle
    the cursors – but Room helps to speed these processes up, which is why it is highly
    recommended.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 公平地说，并不是所有内容都可以在一个菜谱中涵盖，因为SQLite确实需要很多代码来设置——例如，创建查询和处理游标——但Room有助于加快这些过程，这就是为什么它被强烈推荐。
- en: How it works…
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As recommended earlier, migrating a complex database might be hectic and require
    caution, since it can affect users if pushed to production without thorough testing.
    It is also highly recommended to use `OpenHelper`, exposed by `RoomDatabase`,
    for more straightforward or minimal changes to your database. Furthermore, it
    is worth mentioning that if you have any legacy code using SQLite, it will be
    written at a high level in Java, so working with a team to find a better solution
    for the migration is needed.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，迁移复杂的数据库可能会很繁琐，需要谨慎，因为它如果没有经过彻底测试就推送到生产环境，可能会影响用户。还强烈建议使用`RoomDatabase`暴露的`OpenHelper`，以实现数据库的更直接或最小更改。此外，值得一提的是，如果你有任何使用SQLite的遗留代码，它将用Java在高级别编写，因此需要与团队合作，找到更好的迁移解决方案。
- en: In your project, you must update the class that extends `SQLiteOpenHelper`.
    We use `SupportSQLiteDatabase` because we need to update the calls to get the
    writable and readable database. This is a cleaner database abstraction class to
    insert and query the database.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目中，你必须更新扩展`SQLiteOpenHelper`的类。我们使用`SupportSQLiteDatabase`是因为我们需要更新获取可写和可读数据库的调用。这是一个更干净的数据库抽象类，用于插入和查询数据库。
- en: Important note
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'It is important to note that it might be complicated to migrate to a complex
    database that has many tables and complex queries. However, if your database has
    minimal tables and no complex queries, migration can be done quickly with relatively
    small incremental changes in a feature branch. It might be helpful to download
    the app’s database, and you can do so by visiting the following link: [https://developer.android.com/training/data-storage/room/testing-db#command-line](https://developer.android.com/training/data-storage/room/testing-db#command-line).'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，迁移到一个具有许多表和复杂查询的复杂数据库可能会很复杂。然而，如果你的数据库具有少量表且没有复杂查询，迁移可以通过在功能分支中进行相对较小的增量更改快速完成。下载应用程序的数据库可能会有所帮助，你可以通过访问以下链接来完成：[https://developer.android.com/training/data-storage/room/testing-db#command-line](https://developer.android.com/training/data-storage/room/testing-db#command-line)。
- en: Testing your local database
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的本地数据库
- en: So far, we have ensured that we write tests whenever necessary for our projects.
    We will now need to go ahead and write tests for our `RoomExample` project, since
    this is crucial, and you might be required to do so in a real-world scenario.
    Hence, in this recipe, we will look at a step-by-step guide on writing CRUD tests
    for our database.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经确保在必要时为我们的项目编写测试。现在，我们需要继续编写`RoomExample`项目的测试，因为这是至关重要的，你可能在现实世界的场景中需要这样做。因此，在这个菜谱中，我们将查看编写数据库CRUD测试的逐步指南。
- en: Getting ready
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to open the `RoomExample` project to get started with this recipe.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要打开`RoomExample`项目来开始这个菜谱。
- en: How to do it…
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let’s go ahead and first add all the needed Room testing dependencies, and
    then start writing our tests. For the Hilt test setup, refer to the *Technical
    requirements* section, where you can find all the required code:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先添加所有需要的Room测试依赖项，然后开始编写测试。对于Hilt测试设置，请参阅*技术要求*部分，在那里你可以找到所有所需的代码：
- en: 'You will need to add the following to your `build.gradle`:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要将以下内容添加到你的`build.gradle`中：
- en: '[PRE262]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE263]'
- en: 'After you have added the required dependencies inside the Android test, go
    ahead and create a new class, calling it `UserInformationDBTest`:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你已经在Android测试中添加了所需的依赖项之后，继续创建一个新的类，命名为`UserInformationDBTest`：
- en: '[PRE264]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE264]'
- en: 'Before we can set up our `@Before` function, we will need to create two `lateinit
    var` instances, which we will initialize in our `@``Before` function:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们能够设置`@Before`函数之前，我们需要创建两个`lateinit var`实例，我们将在`@Before`函数中初始化它们：
- en: '[PRE265]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE266]'
- en: 'Now, let us go ahead and set up our `@Before` function and create our database,
    using the in-memory database for testing purposes:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续设置我们的 `@Before` 函数并创建我们的数据库，使用内存数据库进行测试目的：
- en: '[PRE267]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE276]'
- en: 'Since we are running and creating the database in memory, we will need to close
    it after it is done; hence, in our `@After` call, we will need to call `close()`
    on our database:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们是在内存中运行和创建数据库，所以在完成后我们需要关闭它；因此，在我们的 `@After` 调用中，我们需要在我们的数据库上调用 `close()`：
- en: '[PRE277]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE280]'
- en: 'Now that our setup is complete, we will go ahead and start testing our CRUD
    – that is, inserting, deleting, and updating. Let’s go ahead and create an insert
    test first:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们设置完成，我们将继续开始测试我们的 CRUD 操作——即插入、删除和更新。让我们先创建一个插入测试：
- en: '[PRE281]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE303]'
- en: 'Finally, let us add the `delete` function, and that will wrap up our testing
    Room for now:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们添加 `delete` 函数，这样就可以暂时完成我们的 Room 测试：
- en: '[PRE304]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '[PRE335]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE337]'
- en: 'When you run the test, they should all pass with a green check mark:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行测试时，它们都应该通过，显示绿色的勾号：
- en: '![Figure 6.7 – Our tests passing](img/Figure_6.7.jpg)'
  id: totrans-483
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.7 – 我们的测试通过](img/Figure_6.7.jpg)'
- en: Figure 6.7 – Our tests passing
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 – 我们的测试通过
- en: How it works…
  id: totrans-485
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: You might have noticed we have used `Truth`, which is a testing framework that
    provides a fluent and expressive API to write assertions in tests. It is developed
    by Google, and some of the advantages of using `Truth` include readability, flexibility,
    and clear error messages. We can easily use a more like natural language constructs
    – for example, `isEqualTo` and `shouldBe` – which makes the test assertions more
    intuitive and readable for us developers.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们使用了 `Truth`，这是一个提供流畅和表达性 API 以在测试中编写断言的测试框架。它由 Google 开发，使用 `Truth`
    的优点包括可读性、灵活性和清晰的错误消息。我们可以轻松地使用更接近自然语言的结构——例如，`isEqualTo` 和 `shouldBe`——这使得测试断言对我们开发者来说更加直观和易于阅读。
- en: When using the framework, you get a wide range of assertion methods that allow
    you to test a variety of conditions, including equality, order, and containment.
    It also allows you to define custom assertion methods, giving you more control
    over the behavior of your tests.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用框架时，你将获得一系列断言方法，允许你测试各种条件，包括相等性、顺序和包含。它还允许你定义自定义断言方法，这让你对测试行为有更多的控制。
- en: 'The `@Before` annotation ensures our `databaseCreated()` function is executed
    before each class. Our function then creates a database using `Room.inMemoryDatabaseBuilder`,
    which creates a database in `@After` call, we close the database:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Before` 注解确保我们的 `databaseCreated()` 函数在每个类之前执行。然后我们的函数使用 `Room.inMemoryDatabaseBuilder`
    创建一个数据库，在 `@After` 调用中，我们将关闭数据库：'
- en: '[PRE338]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: As you might have seen, our tests are in `AndroidTest`, since we launch Room
    in the main thread and close it after we finish it. The test classes just test
    the DAO functions – that is, `Update`, `Insert`, `Delete`, and `Query`.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能看到的，我们的测试在 `AndroidTest` 中，因为我们是在主线程中启动 Room 并在完成后关闭它。测试类仅测试 DAO 函数——即
    `Update`、`Insert`、`Delete` 和 `Query`。
