- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the Room Database and Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android applications can benefit significantly from storing data locally. The
    Room persistence library harnesses the power of SQLite. In particular, Room offers
    excellent benefits for Android developers. Furthermore, Room offers offline support,
    and the data is stored locally. In this chapter, we will learn how to implement
    Room, a Jetpack Library.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be covering the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Room in your applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing Dependency Injection in Room
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting multiple entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Migrating existing SQL database to Room
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing your local database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also important to mention there are a couple more libraries are used with
    Room – for example, RxJava and Paging integration. In this chapter, we will not
    focus on them but instead on how you can utilize Room to build modern Android
    apps.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The complete source code for this chapter can be found at [https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_six](https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_six).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Room in your applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Room is an object-relational mapping library used in Android data persistence
    and is the recommended data persistence in Modern Android Development. In addition,
    it is effortless to use, understand and maintain, and harnesses the powers of
    `SQLiteDatabase`, it also helps reduce boilerplate code, an issue many developers
    experience when using SQLite. Writing tests is also very straightforward and easy
    to understand.
  prefs: []
  type: TYPE_NORMAL
- en: The most notable advantage of Room is that it is easy to integrate with other
    architecture components and gives developers runtime compile checks – that is,
    Room will complain if you make an error or change your schema without migrating,
    which is practical and helps reduce crashes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s go ahead and create a new empty compose project and call it `RoomExample`.
    In our example project, we will create a form intake from users; this is where
    users can save their first and last names, date of birth, gender, the city they
    live in, and their profession.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will save our user data in our Room database, and then later inspect whether
    the elements we inserted were saved in our database and display the data on the
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our newly created project, let’s go ahead and delete the unnecessary wanted
    code – that is, `Greeting(name: String)`, which comes with all empty Compose projects.
    Keep the preview function, since we will use it to view the screen we create.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s go on and add the needed dependencies for Room and sync the project.
    We will touch on dependency management using `buildSrc` in [*Chapter 12*](B18827_12.xhtml#_idTextAnchor672),
    *Android Studio Tips and Tricks to Help You during Development*. You can find
    the latest version of Room at [https://developer.android.com/jetpack/androidx/releases/room](https://developer.android.com/jetpack/androidx/releases/room);
    we will add `kapt`, which stands for **Kotlin Annotation Processing Tool**, to
    enable us to use the Java annotation processor with the Kotlin code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a new package and call it `data`. Inside `data`, create a new Kotlin
    class and call it `UserInformationModel()`. A data class is used to hold data
    only – in our case, the type of data that we will collect from users will be the
    first name, last name, date of birth, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By using Room, we use the `@Entity` annotation to give our model a table name;
    hence, in our newly created `UserInformation` class, let’s go ahead and add the
    `@Entity` annotation and call our table user information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, as in all databases, we need to define a primary key for our database.
    Hence, in our ID, we will add the `@PrimaryKey` annotation to tell Room that this
    is our primary key, and it should be autogenerated. If you don’t wish to autogenerate,
    you can set the Boolean to `false`, but this might not be a good idea, due to
    conflicts that might arise later in your database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you should have an entity with a table name, a primary key, and your data
    types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside our data package, let us go ahead and create a new package and call it
    `DAO`, which means `UserInformationDao`; this interface will hold the **create**,
    **read**, **update**, and **delete** (**CRUD**) functionality – that is, **update**,
    **insert**, **delete**, and **query**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must also annotate our interface with `@Dao` to tell Room that this is our
    DAO. We use `OnConflictStrategy.REPLACE` on the update and `Insert` functions
    to help us with a case where we might encounter conflicts in our database. `OnConflictStrategy`,
    in this case, means that if `Insert` has the same ID, it will replace that data
    with a particular ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our entity and DAO, we will finally create the `Database`
    class, which extends `RoomDatabase()`. In this class, we will use the `@Database`
    annotation, pass in the entity that we created, which is the `UserInformation`
    entity, and give our database a version name, which currently is `one`. We will
    also specify whether our database schema should be exported or not. So, let’s
    go ahead and create the `Database` abstract class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we have `Room` set up and ready. Now, we need to add Dependency Injection
    and our user interface; you can find the code in the *Technical requirements*
    section. Also, the UI is quite basic at this stage; you can make it a challenge
    to improve it, as this sample project is just for demonstration purposes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 6.1 – The\uFEFF app's UI](img/Figure_6.1.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – The app's UI
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Modern Android Development Room library has three significant components
    of the Room database:'
  prefs: []
  type: TYPE_NORMAL
- en: The entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DAO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Entity` is a table within the database. Room generates a table for each class
    that has the `@Entity` annotation; if you have used Java before, you can think
    of the entity as a **plain old Java object** (**POJO**). The entity classes tend
    to be minor, don’t contain any logic, and only hold the data type for the object.'
  prefs: []
  type: TYPE_NORMAL
- en: Some significant annotations that map the tables in the database are the foreign
    keys, indices, primary keys, and table names. There are other essential annotations,
    such as `ColumnInfo`, which gives column information, and `Ignore`, which, if
    used, whichever data you wish to ignore will not be persisted by Room.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Room DAO](img/Figure_6.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Room DAO
  prefs: []
  type: TYPE_NORMAL
- en: '`@DAO` defines the functions that access the database. Think of it like CRUD;
    if you used SQLite before Room, this is similar to using the cursor objects. Finally,
    `@Database` contains the database functions and serves as the main entry point
    for any underlying connection to our application’s relational data.'
  prefs: []
  type: TYPE_NORMAL
- en: If you need to use this, you annotate with `@Database`, as we did in our database
    class. In addition, this class extends `RoomDatabase` and includes the list of
    entities we create. It also contains the abstract method that we create, has no
    arguments, and returns the class that we annotated with `@Dao`. We run the database
    by calling `Room.databaseBuilder()`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Dependency Injection in Room
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with other recipes, Dependency Injection is vital, and in this recipe, we
    will walk through how we can inject our `DatabaseModule` and provide the Room
    database where it is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to have prior knowledge of how Hilt works to be able to follow
    this recipe step by step.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `RoomExample` project and add Hilt, which is what we will use for
    Dependency Injection. In [*Chapter 3*](B18827_03.xhtml#_idTextAnchor137), *Handling
    the UI State in Jetpack Compose and Using Hilt*, we covered Hilt, so we will not
    discuss it here but just show you how you can use it with Room:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your project and add the necessary Hilt dependency. See [*Chapter 3*](B18827_03.xhtml#_idTextAnchor137),
    *Handling the UI State in Jetpack Compose and Using Hilt*, if you need help setting
    up Hilt or visit [https://dagger.dev/hilt/](https://dagger.dev/hilt/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, let’s go ahead and add our `@HiltAndroidApp` class, and in the `Manifest`
    folder, add the name of our `HiltAndroidApp`, in our case, `UserInformation`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have Dependency Injection, let’s go ahead and add `@AndroidEntryPoint`
    in the `MainActivity` class, and in our project, let’s create a new package and
    call it `di`. Inside, we will create a new class, `DatabaseModule`, and add our
    functionalities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `DatabaseModule`, let’s go ahead and create a `provideDatabase()` function,
    where we will return the `Room` object, add the database name, and ensure we build
    our database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have our Dependency Injection database module set up, we can now
    start adding the service, which are functions that will help us add user information
    to the database and get user information from the database. So, let us go ahead
    and create a new package called `service`. Inside the package, create a new interface,
    `UserInfoService`, and add the two aforementioned functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since `UserInfoService` is an interface, we will need to implement the functionalities
    in our `Impl` class, so let us now go ahead and create a new class called `UserInfoServiceImpl`
    and a singleton class, and then implement the interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will need to inject our constructor and pass `UserInformationDao()`, since
    we will use the insert function to insert the user data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to add code in our functions that have the TODO in them. Let’s
    go ahead and see the user information first. Using `userInformationDao`, we will
    call the insert function to tell Room that we want to insert this user information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need to get the user information from the database; this will visualize
    a user’s data on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need to ensure that we provide the implementation through Dependency
    Injection, so let’s now go ahead and add the preceding code, then clean the project,
    run it, and ensure that everything works as expected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you run the project, you should be able to see it launch without issue.
    We will go ahead and add a function in our `ViewModel` to insert the data in our
    database; the `ViewModel` will be used in the views that we created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can now inspect the database and see whether it was created correctly. Run
    the app, and once it’s ready in the IDE, click **App Inspection**, as shown in
    *Figure 6**.3*. You should be able to open the Database Inspector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.3 – App Inspection](img/Figure_6.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – App Inspection
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the Database Inspector is loaded, you should be able to select the currently
    running Android Emulator, as shown in *Figure 6**.4*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.4 – The selected app for app inspection](img/Figure_6.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – The selected app for app inspection
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 6**.5*, you can see the Database Inspector open and our database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Our user_information database](img/Figure_6.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – Our user_information database
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 6**.6*, you can see that the data we inserted is displayed, which
    means our insert function works as expected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Fi\uFEFFgure 6.6 – Our database](img/Figure_6.6.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – Our database
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we opted to use Dependency Injection to supply the needed dependencies
    to specific classes. We covered in depth what Dependency Injection is in previous
    chapters, so we will not explain it again in this recipe but, instead, talk about
    the modules we created.
  prefs: []
  type: TYPE_NORMAL
- en: We used the `@Singleton` annotation in Hilt to indicate that `provideDatabase`,
    which provides an instance of Room, should be created only once during the lifetime
    of our application, and that this instance should be shared across all the components
    that depend on it. In addition, when you annotate a class or a binding method
    with `@Singleton`, Hilt ensures that only one instance of that class or object
    is created and all the components that need that object will receive the same
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to also know that when we use `@Singleton` in Hilt, it is not
    the same as the Singleton pattern in software design, which can easily be a source
    of confusion. Hilt’s `@Singleton` only guarantees that one instance of a class
    will be created within the context of a particular component hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our project, we created `DatabaseModule()` and `UserInfoServiceModule()`.
    In the `DatabaseModule()` class, we have two functions, `provideDatabase` and
    `provideUserInformationDao`. The first function, `provideDatabase`, returns the
    `UserInformationDatabase` Room instance, where we get to create the database and
    build it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'In `provideUserInformationDao`, we pass `UserInformationDatabase` in the constructor
    and return the `UserInformationDao` abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you want to lose existing data when you are migrating or if your migration
    path is missing, you can use the `.fallbackToDestructiveMigration()` function
    when creating the database.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is more to learn in Room, and this recipe has only given you a brief overview
    of what you can do with it. You can learn more by following the link at [https://developer.android.com/reference/androidx/room/package-summary](https://developer.android.com/reference/androidx/room/package-summary).
  prefs: []
  type: TYPE_NORMAL
- en: Supporting multiple entities in Room
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to handle multiple entities in Room. This
    is useful whenever you have a big project that needs a different data input. An
    excellent example that we can work with is a budgeting app.
  prefs: []
  type: TYPE_NORMAL
- en: 'To support multiple entities in Room, you need to define multiple classes that
    represent your database tables. Each class should have its own annotations and
    fields that correspond to columns in a table. For instance, a budgeting app might
    need different types of models, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BudgetData`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExpenseData`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExpenseItem`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hence, having multiple entities is sometimes necessary, and knowing how to handle
    that comes in handy.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To follow along with this recipe, you must have completed the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it …
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use any project of your choosing to implement the topics discussed in
    this recipe. In addition, you can use this example in your pre-existing project
    to implement the topic.
  prefs: []
  type: TYPE_NORMAL
- en: In `RoomExample`, you can add more functionality to the app and try to add more
    entities, but for this project, let’s go ahead and show how you can handle multiple
    entities in Room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For this example, we will use the sample budgeting App we introduced in an
    earlier chapter, and since we are working with entities, this will be easier to
    follow. Let’s create a new entity and call it `BudgetData`; the budget data class
    might have several fields, such as `budgetName`, `budgetAmount`, `expenses`, `startDate`,
    `endDate`, `notify`, `currency`, and `totalExpenses`; hence, our `BudgetData`
    data class will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s go ahead and add two more entities. First, we will add `ExpenseData`,
    which might have the following fields and types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, let’s add `ExpenseItem`, which might consist of the following fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, we have three entities; based on these entities, you should
    create different DAOs for each one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE171]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the top of the `AppDatabase` abstract class, we will annotate it with `@Database`
    and then pass it to all our entities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE174]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE175]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE176]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE177]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE178]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE179]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE180]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE181]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE182]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE183]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also use embedded objects; the `@Embedded` annotation includes nested
    or related entities within an entity. It allows you to represent the relationship
    between entities by embedding one or more related entities in the parent entity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE185]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE186]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE187]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE188]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In our preceding example, we have annotated the tasks property in the `ExpenseItem`
    entity with the `@Embedded` annotation. This tells Room to include the fields
    of the `Tasks` data class within the `ExpenseItem` table, rather than creating
    a separate table for our `ExpenseItem` entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the Tasks data class can have the `description`, `priority`, `updatedAt`,
    and ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE190]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE191]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE192]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE193]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE194]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE195]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Hence, the table representing the `ExpenseItem` object will contain additional
    columns with the newly added fields.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it; once you declare the entities in the database and pass them as required,
    you will have supported multiples entities in your `Database`.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If your entity has multiple embedded fields of the same type, you can keep each
    column unique by setting the `Prefix` property; then, Room will add the provided
    values to the beginning of each column name in the embedded object. Find out more
    at [https://developer.android.com/](https://developer.android.com/).
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: According to the rules in Room, you can define an entity relationship in three
    different ways.
  prefs: []
  type: TYPE_NORMAL
- en: One-to-many relationships or many-to-one relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One-to-one relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many-to-many relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you have already seen, using entities in one class makes it manageable and
    easily trackable; hence, this is an excellent solution for Android engineers.
    A notable annotation is `@Relation`, which specifies where you create an object
    that shows the relationship between your entities.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is more to learn in Room – for instance, defining relationships between
    objects, writing asynchronous data accessible object queries, and referencing
    complex data. It is fair to say we cannot cover everything in just one chapter
    but offer some guidance to help you navigate building Modern Android applications.
    For more on Room, visit [https://developer.android.com/training/data-storage/room](https://developer.android.com/training/data-storage/room).
  prefs: []
  type: TYPE_NORMAL
- en: Migrating an existing SQL database to room
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned earlier, Room does harness the power of SQLite, and because
    many applications still use legacy, you might find applications still using SQL
    and be wondering how you can migrate to Room and utilize the latest Room features.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will cover the migration of an existing SQL database to Room
    with step-by-step examples. Furthermore, Room offers an abstraction layer to help
    with SQLite migrations – that is, by offering the `Migration` class to developers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because we did not create a new SQLite database example, since that is not
    necessary, we will try to emulate a scenario with a dummy sample SQLite database
    and showcase how you can migrate your existing SQLite database to Room:'
  prefs: []
  type: TYPE_NORMAL
- en: Since we will be adding Room in an existing SQLite project, you will need to
    ensure you add the required dependencies. To set this up, refer to the *Implementing
    Room in your* *applications* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will need to go ahead and create a new DAO and entity, since Room
    requires it. Hence, in this set following the first Room recipe, you can update
    the model classes to entities. This is pretty straightforward, since mostly what
    you will do is annotate the classes with `@Entity` and use the table `Names` property
    to set the name of the table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You must also add `@PrimaryKey` and `@ColumnInfo` annotations for your entity
    classes. Here is a sample SQLite database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE197]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE198]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE199]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE200]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE201]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE202]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE203]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE204]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE205]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE206]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE207]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE208]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE209]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE210]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE211]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE212]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE213]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE214]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE215]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE216]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE217]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE218]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE219]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE220]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE221]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE222]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE223]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE224]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: However, Room has simplified the process, and we no longer need to create `Contracts`.
    `Contracts` in Android are a way for developers to define and enforce a set of
    rules for accessing data within an application. These contracts typically define
    the structure and schema of the database tables and the expected data types and
    formats for the data within them. In the case of SQLite on Android, contracts
    are often used to define the tables and columns of the database, as well as any
    constraints or relationships between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have created all our needed entities and DAOs, we can go ahead and
    create the database. As we saw in the *Implementing Room in your Applications*
    recipe, we can add all our entities in the `@Database` annotation, and since we
    are in the first `(1)` version, we can increment the version to (`2)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE226]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE227]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE228]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE229]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE230]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE231]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE232]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE233]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE234]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE235]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE236]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE237]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE238]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE239]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE240]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE241]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE242]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, the important part is ensuring we call `build()` to the Room database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE244]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE245]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE246]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE247]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE248]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE249]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE250]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE251]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE252]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE253]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE254]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once your data layer starts using Room, you can officially replace all the
    `Cursor` and `ContentValue` code with the DAO calls. In our `AppDatabase` class,
    we have our entities, and our class extends `RoomDatabase()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE256]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE257]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE258]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE259]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE260]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE261]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because Room offers runtime errors, if any error occurs, you will be notified
    in Logcat.
  prefs: []
  type: TYPE_NORMAL
- en: It is fair to say that not everything can be covered in one recipe because SQLite
    does require a lot of code to set up – for instance, to create queries and handle
    the cursors – but Room helps to speed these processes up, which is why it is highly
    recommended.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As recommended earlier, migrating a complex database might be hectic and require
    caution, since it can affect users if pushed to production without thorough testing.
    It is also highly recommended to use `OpenHelper`, exposed by `RoomDatabase`,
    for more straightforward or minimal changes to your database. Furthermore, it
    is worth mentioning that if you have any legacy code using SQLite, it will be
    written at a high level in Java, so working with a team to find a better solution
    for the migration is needed.
  prefs: []
  type: TYPE_NORMAL
- en: In your project, you must update the class that extends `SQLiteOpenHelper`.
    We use `SupportSQLiteDatabase` because we need to update the calls to get the
    writable and readable database. This is a cleaner database abstraction class to
    insert and query the database.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that it might be complicated to migrate to a complex
    database that has many tables and complex queries. However, if your database has
    minimal tables and no complex queries, migration can be done quickly with relatively
    small incremental changes in a feature branch. It might be helpful to download
    the app’s database, and you can do so by visiting the following link: [https://developer.android.com/training/data-storage/room/testing-db#command-line](https://developer.android.com/training/data-storage/room/testing-db#command-line).'
  prefs: []
  type: TYPE_NORMAL
- en: Testing your local database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have ensured that we write tests whenever necessary for our projects.
    We will now need to go ahead and write tests for our `RoomExample` project, since
    this is crucial, and you might be required to do so in a real-world scenario.
    Hence, in this recipe, we will look at a step-by-step guide on writing CRUD tests
    for our database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to open the `RoomExample` project to get started with this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s go ahead and first add all the needed Room testing dependencies, and
    then start writing our tests. For the Hilt test setup, refer to the *Technical
    requirements* section, where you can find all the required code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to add the following to your `build.gradle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE263]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After you have added the required dependencies inside the Android test, go
    ahead and create a new class, calling it `UserInformationDBTest`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we can set up our `@Before` function, we will need to create two `lateinit
    var` instances, which we will initialize in our `@``Before` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE266]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let us go ahead and set up our `@Before` function and create our database,
    using the in-memory database for testing purposes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE268]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE269]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE270]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE271]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE272]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE273]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE274]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE275]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE276]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we are running and creating the database in memory, we will need to close
    it after it is done; hence, in our `@After` call, we will need to call `close()`
    on our database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE278]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE279]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE280]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that our setup is complete, we will go ahead and start testing our CRUD
    – that is, inserting, deleting, and updating. Let’s go ahead and create an insert
    test first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE282]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE283]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE284]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE285]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE286]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE287]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE288]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE289]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE290]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE291]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE292]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE293]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE294]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE295]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE296]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE297]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE298]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE299]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE300]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE301]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE302]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE303]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let us add the `delete` function, and that will wrap up our testing
    Room for now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE305]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE306]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE307]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE308]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE309]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE310]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE311]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE312]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE313]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE314]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE315]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE316]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE317]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE318]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE319]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE320]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE321]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE322]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE323]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE324]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE325]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE326]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE327]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE328]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE329]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE330]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE331]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE332]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE333]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE334]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE335]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE336]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE337]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you run the test, they should all pass with a green check mark:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Our tests passing](img/Figure_6.7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – Our tests passing
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might have noticed we have used `Truth`, which is a testing framework that
    provides a fluent and expressive API to write assertions in tests. It is developed
    by Google, and some of the advantages of using `Truth` include readability, flexibility,
    and clear error messages. We can easily use a more like natural language constructs
    – for example, `isEqualTo` and `shouldBe` – which makes the test assertions more
    intuitive and readable for us developers.
  prefs: []
  type: TYPE_NORMAL
- en: When using the framework, you get a wide range of assertion methods that allow
    you to test a variety of conditions, including equality, order, and containment.
    It also allows you to define custom assertion methods, giving you more control
    over the behavior of your tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@Before` annotation ensures our `databaseCreated()` function is executed
    before each class. Our function then creates a database using `Room.inMemoryDatabaseBuilder`,
    which creates a database in `@After` call, we close the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: As you might have seen, our tests are in `AndroidTest`, since we launch Room
    in the main thread and close it after we finish it. The test classes just test
    the DAO functions – that is, `Update`, `Insert`, `Delete`, and `Query`.
  prefs: []
  type: TYPE_NORMAL
