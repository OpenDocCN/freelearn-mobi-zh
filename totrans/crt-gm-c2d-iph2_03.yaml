- en: Chapter 3. Thumping Moles for Fun
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 欢乐地敲打地鼠
- en: We will be continuing our journey through classic gameplay styles in this chapter.
    We will talk a little about different approaches to solve the design challenges
    in this chapter. In game programming, there are always many ways to solve the
    same problem, there is no single right answer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续探索经典的游戏玩法风格。我们将简要讨论本章中解决设计挑战的不同方法。在游戏编程中，总是有解决同一问题的多种方法，没有唯一的正确答案。
- en: 'In this chapter, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Tricking the eye with Z-ordering
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Z排序欺骗眼睛
- en: Reusing objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复使用对象
- en: Detecting touch on the part of a sprite
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测精灵部分的触摸
- en: Animations and movement actions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画和动作
- en: Randomized objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机对象
- en: The project is…
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 该项目是……
- en: In this chapter, we will be building a mole thumping game. Inspired by mechanical
    games of the past, we will build molehills on the screen and randomly cause animated
    moles to pop their heads out. The player taps them to score. Simple in concept,
    but there are a few challenging design considerations in this deceptively easy
    game. To make this game a little unusual, we will be using a penguin instead of
    a mole for the graphics, but we will continue to use the mole terminology throughout,
    since a molehill is easier to consider than a penguin-hill.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个敲打地鼠游戏。受过去机械游戏的启发，我们将在屏幕上构建地鼠丘，并随机让动画地鼠伸出头来。玩家点击它们来得分。概念简单，但在这个看似简单的游戏中有一些具有挑战性的设计考虑。为了让这个游戏有点不同，我们将使用企鹅而不是地鼠作为图形，但我们将继续在整个过程中使用地鼠术语，因为地鼠丘比企鹅丘更容易考虑。
- en: Design approach
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计方法
- en: Before diving into the code, let's start with a discussion of the design of
    the game. First, we will need to have molehills on the screen. To be aesthetically
    pleasing, the molehills will be in a 3 x 4 grid. Another approach would be to
    use random molehill positions, but that doesn't really work well on the limited
    screen space of the iPhone. Moles will randomly spawn from the molehills. Each
    mole will rise up, pause, and drop down. We will need touch handling to detect
    when a mole has been touched, and that mole will need to increase the player's
    score and then go away.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入代码之前，让我们先讨论一下游戏的设计。首先，我们需要在屏幕上有地鼠丘。为了美观，地鼠丘将排列成3 x 4的网格。另一种方法可能是使用随机的地鼠丘位置，但在iPhone有限的屏幕空间上这并不真正有效。地鼠将从地鼠丘中随机出现。每个地鼠都会升起，暂停，然后落下。我们需要触摸处理来检测何时触摸到地鼠，并且那个地鼠需要增加玩家的分数然后消失。
- en: How do we make the mole come up from underground? If we assume the ground is
    a big sprite with the molehills drawn on it, we would need to determine where
    to make the "slot" from which the mole emerges, and somehow make the mole disappear
    when it is below that slot. One approach is to adjust the size of the mole's displayed
    frame by clipping the bottom of the image so that the part below the ground is
    not visible. This needs to be done as a part of every update cycle for every mole
    for the entire game. From a programming standpoint this will work, but you may
    experience performance issues. Another consideration is that this usually means
    the hole in the molehill will always appear to be a straight-edged hole, if we
    trim the sprite with a straight line. This lacks the organic feel we want for
    this game.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何让地鼠从地下升起？如果我们假设地面是一个大精灵，地鼠丘画在上面，我们就需要确定从哪个“槽”让地鼠出现，并且以某种方式在地鼠低于那个槽时使其消失。一种方法是调整地鼠显示帧的大小，通过裁剪图像的底部，使地面以下的部分不可见。这需要作为每个更新周期中每个地鼠在整个游戏中的部分来完成。从编程的角度来看，这将有效，但你可能会遇到性能问题。另一个考虑因素是，如果我们用直线裁剪精灵，这通常意味着地鼠丘的洞将始终看起来是一个直边洞，这缺乏我们希望在这款游戏中拥有的有机感。
- en: The approach we will take is to use Z-ordering to trick the eye into seeing
    a flat playfield when everything is really on staggered Z-orders. We will create
    a "stair step" board, with multiple "sandwiches" of graphics for every row of
    molehills on the board.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采取的方法是使用Z排序来欺骗眼睛，使其看到当所有内容实际上都在交错Z排序时，我们看到的是一个平坦的游乐场。我们将创建一个“阶梯”板，每行地鼠丘上都有多个“三明治”式的图形。
- en: '![Design approach](img/9007_03_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![设计方法](img/9007_03_01.jpg)'
- en: 'For each "step" of the "stair step", we have a sandwich of Z-ordered elements
    in this order, from back to front: molehill top, mole, ground, and molehill bottom.
    We need to have everything aligned so that the molehill top graphic overlaps the
    ground of the next "step" further towards the top of the screen. This will visually
    contain the mole, so it appears to be emerging from inside the molehill.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于“阶梯”的每一个“步骤”，我们按照Z排序的元素顺序，从后往前有一个三明治，包括：土丘顶部、鼹鼠、地面和土丘底部。我们需要确保一切对齐，以便土丘顶部的图形与下一个“步骤”的地面在屏幕顶部进一步重叠。这样在视觉上就能包含鼹鼠，使其看起来是从土丘内部出现的。
- en: We intentionally skipped the Z value of 1, to provide an extra expansion space
    if we later decide that we need another element in the "sandwich". It is easier
    to leave little holes like this than to worry about changing everything later,
    if we enhance our design. So throughout our layout, we will consider it as a sandwich
    of five Z values, even though we only use four elements in the sandwich.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意跳过了Z值为1，以提供额外的扩展空间，以防我们以后决定需要“三明治”中的另一个元素。如果我们在增强设计时担心改变一切，留下这样的小洞更容易。因此，在我们的布局中，我们将它视为五个Z值的“三明治”，尽管我们只使用了四个元素。
- en: As we said, we need this to be a "stair step" board. So for each row of molehills,
    from the top of the screen to the bottom, we will need to increase the Z-ordering
    between layers to complete the illusion. This is needed so that each mole will
    actually pass in front of the ground layer that is closer to the top of the screen,
    yet will hide completely behind the ground layer in its own sandwich of layers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说的，我们需要这是一个“阶梯”板。因此，对于每一排土丘，从屏幕顶部到底部，我们需要增加层之间的Z排序以完成这种错觉。这是必要的，以便每个鼹鼠实际上会穿过屏幕顶部更靠近的地面层，但在它自己的层“三明治”中会完全隐藏在地面层后面。
- en: Designing the spawn
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计生成
- en: 'That covers the physical design of the game, but there is one additional design
    aspect we need to discuss: spawning moles. We need to spawn the moles whenever
    we need one to be put into the play. Just as we reviewed two approaches to the
    hiding mole problem earlier, we will touch on two approaches to mole spawning.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了游戏的物理设计，但还有一个额外的设计方面我们需要讨论：鼹鼠的生成。我们需要在需要将鼹鼠放入游戏时生成鼹鼠。正如我们之前回顾了两种解决隐藏鼹鼠问题的方法，我们也会涉及到两种鼹鼠生成的方法。
- en: The first approach (and most common) is to create a new mole from scratch each
    time you need one. When you are done with it, you destroy it. This works fine
    for games with a small number of objects or games of more limited complexity,
    but there is a performance penalty to create and destroy a lot of objects in a
    short amount of time. Strictly speaking, our mole thumping game would likely work
    fine with this approach. Even though we will be creating and destroying quite
    a few moles all the time, we only have a dozen possible moles, not hundreds.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法（也是最常见的方法）是在每次需要鼹鼠时从头开始创建一个新的鼹鼠。当你用完它后，你销毁它。这对于对象数量较少或更有限复杂性的游戏来说效果很好，但在短时间内创建和销毁大量对象会有性能损失。严格来说，我们的鼹鼠敲击游戏可能会用这种方法工作得很好。尽管我们将会不断地创建和销毁很多鼹鼠，但我们只有十二个可能的鼹鼠，而不是数百个。
- en: The other approach is to create a spawning pool. This is basically a set number
    of the objects that are created when you start up. When you need a mole, in our
    case, you ask the pool for an unused "blank mole", set any parameters that are
    needed, and use it. When you are done with it, you reset it back to the "blank
    mole" state, and it goes back into the pool.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是创建一个生成池。这基本上是在启动时创建的一定数量的对象。当你需要鼹鼠时，在我们的例子中，你向池请求一个未使用的“空白鼹鼠”，设置所需的任何参数，并使用它。当你用完它后，你将其重置回“空白鼹鼠”状态，然后它回到池中。
- en: For our game the spawning pool might be a little more heavily coded than needed,
    as it is doubtful that we would run into any performance issues with this relatively
    simple game. Still, if you are willing to build the additional code as we are
    doing here, it does provide a strong foundation to add more performance-heavy
    effects later on.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的游戏，生成池可能比所需的编码更复杂，因为我们怀疑我们不会在这个相对简单的游戏中遇到任何性能问题。尽管如此，如果你愿意像我们这样构建额外的代码，它确实为以后添加更多性能密集型效果提供了一个坚实的基础。
- en: To clarify our design approach, we will actually implement a variation of the
    traditional spawning pool. Instead of a general pool of moles, we will build our
    "blank mole" objects attached to their molehills. A more traditional spawning
    pool might have six "blank moles" in the pool, and they are assigned to a molehill
    when they are needed. Both approaches are perfectly valid.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了阐明我们的设计方法，我们将实际实现传统孵化池的一种变体。而不是一个普通的地鼠池，我们将构建“空白地鼠”对象，并将它们附加到它们的小山丘上。一个更传统的孵化池可能有六个“空白地鼠”在池中，当需要时分配给小山丘。这两种方法都是完全有效的。
- en: Portrait mode
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 竖屏模式
- en: The default orientation supported by cocos2d is landscape mode, which is more
    commonly used in games. However, we want our game to be in portrait mode. The
    changes are very simple to make this work. If you click once on the project name
    (and blue icon) in the **Project Navigator** pane (where all your files are listed),
    and then click on the name of your game under **TARGETS**, you will see the **Summary**
    pane. Under the **Supported Interface Orientations**, select **Portrait**, and
    deselect **Landscape Left** and **Landscape Right**. That will change your project
    to portrait. The one adjustment to the cocos2d template code we need is in the
    `IntroLayer.m`. After it sets the background to `Default.png`, there is a command
    to rotate the background. Remove, or comment out this line, and everything will
    work correctly.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: cocos2d 支持的默认方向是横屏模式，这在游戏中更常用。然而，我们希望我们的游戏在竖屏模式下。要实现这一点，更改非常简单。如果你在 **项目导航器**
    窗格（所有文件都列在这里）中单击一次项目名称（蓝色图标），然后单击 **TARGETS** 下的你的游戏名称，你会看到 **摘要** 窗格。在 **支持的界面方向**
    下，选择 **竖屏**，并取消选择 **横屏左** 和 **横屏右**。这将使你的项目变为竖屏。我们需要对 cocos2d 模板代码进行的一个调整是在 `IntroLayer.m`
    中。在它将背景设置为 `Default.png` 之后，有一个旋转背景的命令。删除或注释掉这一行，一切都会正常工作。
- en: Custom TTF fonts
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义 TTF 字体
- en: 'In this project we will be using a custom TTF font. In cocos2d 1.x, you could
    simply add the font to your project and use it. Under cocos2d 2.0, which we are
    using, we have to approach this a little differently. We add the font to our project
    (we are using `anudrg.ttf`). Then we edit the `Info.plist` for our project, and
    add a new key to the list, like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将使用自定义的 TTF 字体。在 cocos2d 1.x 中，你可以简单地添加字体到你的项目中并使用它。在使用的 cocos2d 2.0
    中，我们必须采取稍微不同的方法。我们将字体添加到我们的项目中（我们使用 `anudrg.ttf`）。然后我们编辑项目的 `Info.plist`，并向列表中添加一个新的键，如下所示：
- en: '![Custom TTF fonts](img/9007_03_02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![自定义 TTF 字体](img/9007_03_02.jpg)'
- en: This tells the project that we need to know about this font. To actually use
    the font, we need to call it by the proper name for the font, not the filename.
    To find out this name, in **Finder**, select the file and choose **File Info**.
    In the info box, there is an entry for **Full Name**. In our case, the file name
    is `AnuDaw`. Any time we create a label with `CCLabelTTF`, we simply need to use
    this as the font name, and everything works perfectly.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉项目我们需要了解这个字体。要实际使用这个字体，我们需要用字体的正确名称来调用它，而不是文件名。要找出这个名称，在 **Finder** 中选择文件并选择
    **文件信息**。在信息框中，有一个 **全名** 的条目。在我们的例子中，文件名是 `AnuDaw`。每次我们用 `CCLabelTTF` 创建标签时，我们只需将这个名称用作字体名称，一切就会完美工作。
- en: Defining a molehill
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义小山丘
- en: We have created a new subclass of `CCNode` to represent the `MXMoleHill` object.
    Yes, we will be using a subclass of `CCNode`, not a subclass of `CCSprite`. Even
    though we initially would consider the molehill to be a sprite, referring back
    to our design, it is actually made up of *two* sprites, one for the top of the
    hill and one for the bottom. We will use `CCNode` as a container that will then
    contain two `CCSprite` objects as variables inside the `MXMoleHill` class.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个 `CCNode` 的新子类来表示 `MXMoleHill` 对象。是的，我们将使用 `CCNode` 的子类，而不是 `CCSprite`
    的子类。尽管我们最初会考虑地鼠丘是一个精灵，但回顾我们的设计，它实际上由 *两个* 精灵组成，一个用于山丘的顶部，一个用于底部。我们将使用 `CCNode`
    作为容器，然后在这个 `MXMoleHill` 类中作为变量包含两个 `CCSprite` 对象。
- en: '**Filename:** `MXMoleHill.h`'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `MXMoleHill.h`'
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If this seems rather sparse to you, it is. As we will be using this as a container
    for everything that defines the hill, we don't need to override any methods from
    the standard `CCNode` class. Likewise, the `@implementation` file contains nothing
    but the `@synthesize` statements for these variables.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这对你来说似乎相当稀疏，它确实是。因为我们将使用它作为定义小山丘的所有内容的容器，所以我们不需要覆盖标准 `CCNode` 类的任何方法。同样，`@implementation`
    文件只包含这些变量的 `@synthesize` 语句。
- en: It is worth pointing out that we could have used a `CCSprite` object for the
    `hillTop` sprite, with the `hillBottom` object as a child of that sprite, and
    achieved the same effect. However, we prefer consistency in our object structure,
    so we have opted to use the structure noted previously. This allows us to refer
    to the two sprites in exactly the same fashion, as they are both children of the
    same parent.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，我们本可以使用 `CCSprite` 对象作为 `hillTop` 精灵，将 `hillBottom` 对象作为该精灵的子对象，达到相同的效果。然而，我们更喜欢保持对象结构的统一性，因此我们选择了之前提到的结构。这允许我们以完全相同的方式引用这两个精灵，因为它们都是同一个父对象的子对象。
- en: Building the mole
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建地鼠
- en: When we start building the playfield, we will be creating "blank mole" objects
    for each hill, so we need to look at the `MXMole` class before we build the playfield.
    Following the same design decision as we did with the `MXMoleHill` class, the
    `MXMole` class is also a subclass of `CCNode`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始构建游戏场时，我们将为每个山创建“空白地鼠”对象，因此在我们构建游戏场之前需要查看 `MXMole` 类。遵循与 `MXMoleHill` 类相同的决策，`MXMole`
    类也是一个 `CCNode` 的子类。
- en: '**Filename:** `MXMole.h`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `MXMole.h`'
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We see a forward declaration here (the `@class` statement). Use of forward declaration
    avoids creating a circular loop, because the `MXMoleHill.h` file needs to import
    `MXMole.h`. In our case, `MXMole` needs to know there is a valid class called
    `MXMoleHill`, so we can store a reference to an `MXMoleHill` object in the `parentHill`
    instance variable, but we don't actually need to import the class. The `@class`
    declaration is an instruction to the compiler that there is a valid class called
    `MXMoleHill`, but doesn't actually import the header while compiling the `MXMole`
    class. If we needed to call the methods of `MXMoleHill` from the `MXMole` class,
    we could then put the actual `#import "MXMoleHill.h"` line in the `MXMole.m` file.
    For our current project, we only need to know the class exists, so we don't need
    that additional line in the `MXMole.m` file.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到了一个前置声明（`@class` 语句）。使用前置声明可以避免创建循环，因为 `MXMoleHill.h` 文件需要导入 `MXMole.h`。在我们的情况下，`MXMole`
    需要知道存在一个名为 `MXMoleHill` 的有效类，因此我们可以在 `parentHill` 实例变量中存储一个 `MXMoleHill` 对象的引用，但实际上我们不需要导入该类。`@class`
    声明是给编译器的一个指令，表明存在一个名为 `MXMoleHill` 的有效类，但在编译 `MXMole` 类时并不实际导入头文件。如果我们需要在 `MXMole`
    类中调用 `MXMoleHill` 的方法，我们可以在 `MXMole.m` 文件中放置实际的 `#import "MXMoleHill.h"` 行。对于我们的当前项目，我们只需要知道类的存在，因此我们不需要在
    `MXMole.m` 文件中添加那额外的行。
- en: We have built a simple state machine for `MoleState`. Now that we have reviewed
    the `MXMole.h` file, we have a basic idea of what makes up a mole. It tracks the
    state of the mole (dead, alive, and so on), it keeps a reference to its parent
    hill, and it has `CCSprite` as a child where the actual mole sprite variable will
    be held. There are a couple of other variables (`moleGroundY` and `isSpecial`),
    but we will deal with these later.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为 `MoleState` 构建了一个简单的状态机。现在我们已经审查了 `MXMole.h` 文件，我们对地鼠的构成有一个基本的了解。它跟踪地鼠的状态（死亡、活着等），它保留对其父山的引用，并且它有一个
    `CCSprite` 作为子对象，实际的地鼠精灵变量将保存在那里。还有一些其他变量（`moleGroundY` 和 `isSpecial`），但我们稍后再处理这些。
- en: '**Filename:** `MXDefinitions.h`'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `MXDefinitions.h`'
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Unlike in the previous chapter, we do not have `typedef enum` that defines the
    `MoleState` type inside this header file. We have moved our definitions to the
    `MXDefinitions.h` file, which helps to maintain slightly cleaner code. You can
    store these "universal" definitions in a single header file, and include the header
    in any `.h` or `.m` files where they are needed, without needing to import classes
    just to gain access to these definitions. The `MXDefinitions.h` file only includes
    the definitions; there are no `@interface` or `@implementation` sections, nor
    a related `.m` file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章不同，我们在这个头文件中没有使用 `typedef enum` 来定义 `MoleState` 类型。我们已经将定义移动到了 `MXDefinitions.h`
    文件中，这有助于保持代码的略微整洁。您可以将这些“通用”定义存储在一个单独的头文件中，并在需要它们的任何 `.h` 或 `.m` 文件中包含该头文件，而无需仅为了访问这些定义而导入类。`MXDefinitions.h`
    文件只包含定义；没有 `@interface` 或 `@implementation` 部分，也没有相关的 `.m` 文件。
- en: Making a molehill
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作地鼠山
- en: 'We have our molehill class and we''ve seen the mole class, so now we can look
    at how we actually build the molehills in the `MXPlayfieldLayer` class:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了地鼠山类，我们也看到了地鼠类，现在我们可以看看在 `MXPlayfieldLayer` 类中我们是如何实际构建地鼠山的：
- en: '**Filename:** `MXPlayfieldLayer.m`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `MXPlayfieldLayer.m`'
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is a pretty dense method, so we'll walk through it one section at a time.
    We start by creating two nested `for` loops so we can iterate over every possible
    row and column position. For clarity, we named our loop variables as `row` and
    `column`, so we know what each represents. If you recall from the design, we decided
    to use a 3 x 4 grid, so we will have three columns and four rows of molehills.
    We create a new hill using an `alloc`/`init`, and then we begin filling in the
    variables. We set an ID number (1 through 12), and we build `CCSprite` objects
    to fill in the `moleHillTop` and `moleHillBottom` variables.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当密集的方法，所以我们将分部分进行讲解。我们首先创建两个嵌套的`for`循环，以便我们可以遍历每个可能的行和列位置。为了清晰起见，我们给循环变量命名为`row`和`column`，这样我们就可以知道每个代表什么。如果您还记得设计，我们决定使用一个3x4的网格，因此我们将有三个列和四个行的土丘。我们使用`alloc`/`init`创建一个新的土丘，然后开始填充变量。我们设置一个ID号码（1到12），并构建`CCSprite`对象来填充`moleHillTop`和`moleHillBottom`变量。
- en: '**Filename:** `MXPlayfieldLayer.m`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `MXPlayfieldLayer.m`'
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We also set the position using the helper method, `hillPositionForRow:andColumn:`,
    that returns a `CGPoint` for each molehill. (It is important to remember that
    `ccp` is a cocos2d shorthand term for a `CGPoint`. They are interchangeable in
    your code.) These calculations are based on experimentation with the layout, to
    create a grid that is both easy to draw as well as being visually appealing.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用辅助方法`hillPositionForRow:andColumn:`设置位置，该方法为每个土丘返回一个`CGPoint`。重要的是要记住，`ccp`是cocos2d对`CGPoint`的简写术语，它们在您的代码中可以互换使用。这些计算是基于对布局的实验，以创建既易于绘制又具有视觉吸引力的网格。
- en: 'The one variable that needs a little extra explaining is `moleHillBaseZ`. This
    represents which "step" of the Z-order stair-step design this hill belongs to.
    We use this to aid in the calculations to determine the proper Z-ordering across
    the entire playfield. If you recall, we used Z-orders from 2 to 5 in the illustration
    of the stack of elements. When we add the `moleHillTop` and `moleHillBottom` as
    children of the `moleSheet` (our `CCSpriteBatchNode`), we add the Z-order of the
    piece of the sandwich to the "base Z" times 5\. We will use a "base Z" of 5 for
    the stack at the bottom of the screen, and a "base Z" of 2 at the top of the screen.
    This will be easier to understand the reason if we look at the following chart,
    which shows the calculations we use for each row of molehills:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 需要额外解释的一个变量是`moleHillBaseZ`。这表示这个土丘属于Z顺序阶梯设计的哪个“步骤”。我们使用这个变量来帮助计算整个游戏场上的正确Z顺序。如果您还记得，我们在元素堆叠的插图中使用从2到5的Z顺序。当我们把`moleHillTop`和`moleHillBottom`作为`moleSheet`（我们的`CCSpriteBatchNode`）的子节点添加时，我们将三明治部分的Z顺序加到“基础Z”乘以5。我们将使用5作为屏幕底部的堆叠的基础Z，并在屏幕顶部使用2作为基础Z。如果我们查看以下图表，这将更容易理解原因，该图表显示了我们对每行土丘使用的计算：
- en: '![Making a molehill](img/9007_03_03.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![制作土丘](img/9007_03_03.jpg)'
- en: As we start building our molehills at the bottom of the screen, we start with
    a higher Z-order first. In the preceding chart, you will see that the mole in
    hole 4 (second row of molehills from the bottom) will have a Z-order of 23\. This
    will put it behind its own ground layer, which is at a Z-order of 24, but in front
    of the ground higher on the screen, which would be at a Z-order of 19.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在屏幕底部开始构建我们的土丘时，我们首先从较高的Z顺序开始。在先前的图表中，您将看到第4个洞中的土丘（从底部数起的第二行土丘）将有一个Z顺序为23。这将使其位于自己的地面层之后，该地面层的Z顺序为24，但位于屏幕上更高的地面之前，其Z顺序为19。
- en: It is worth calling out that since we have a grid of molehills in our design,
    all Z-ordering will be identical for all molehills in the same row. This is why
    the decrement of the `baseHillZ` variable occurs only when we are iterating through
    a new row.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，由于我们的设计中有一个土丘网格，因此同一行中的所有土丘的Z顺序都将相同。这就是为什么`baseHillZ`变量的递减只在我们遍历新行时发生。
- en: If we refer back to the `drawHills` method itself, we also see a big calculation
    for the actual position of the `moleHillTop` and `moleHillBottom` sprites. We
    want the "seam" between these two sprites to be at the top edge of the ground
    image of their stack, so we set the `y` position based on the position of the
    `MXMoleHill` object. At first it may look like an error, because both `setPosition`
    statements use `contentSize` of the `moleHillTop` sprite as a part of the calculation.
    This is intentional, because we have a little jagged overlap between those two
    sprites to give it a more organic feel.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: To wrap up the `drawHills` method, we allocate a new `MXMole`, assign it to
    the molehill that was just created, and set the cross-referencing `hillMole` and
    `parentHill` variables in the objects themselves. We add the molehill to our `moleHillsInPlay`
    array, and we clean everything up by releasing both the `newHill` and the `newMole`
    objects. Because the array retains a reference to the molehill, and the molehill
    retains a reference to the mole, we can safely release both the `newHill` and
    `newMole` objects in this method.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the ground
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have gone over the Z-ordering "trickery", we should look at the
    `drawGround` method to see how we accomplish the Z-ordering in a similar fashion:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `MXPlayfieldLayer.m`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This format should look familiar to you. We create five `CCSprite` objects for
    the five stripes of ground, tile them from the bottom of the screen to the top,
    and assign the Z-order as `z:4+((5-i) * 5)`. We do include a randomizer with two
    different background images, and we also include a skybox image at the top of
    the screen, because we want some sense of a horizon line above the mole-thumping
    area.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: We saw `anchorPoints` briefly in [Chapter 1](ch01.html "Chapter 1. Thanks for
    the Memory Game"), *Thanks for the Memory Game* but we should revisit them here,
    as they will become more important in later projects. `anchorPoint` is the point
    that is basically "center" for the sprite. The acceptable values are floats between
    0 and 1\. For the x axis, an `anchorPoint` of 0 is the left edge, and 1 is the
    right edge (0.5 is centered). For the y axis, an `anchorPoint` of 0 is the bottom
    edge, and 1 is the top edge. This `anchorPoint` is important here because that
    `anchorPoint` is the point on the object to which the `setPosition` method will
    refer. So in our code, the first `groundStrip1` created will be anchored at the
    bottom center. When we call `setPosition`, the coordinate passed to `setPosition`
    needs to relate to that `anchorPoint`; the position set will be the bottom center
    of the sprite. If this is still fuzzy for you, it is a great exercise to change
    `anchorPoint` of your own `CCSprite` objects and see what happens on the screen.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Mole spawning
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The only piece of the "sandwich" of elements we haven''t seen in detail is
    the mole itself, so let''s visit the mole spawning method to see how the mole
    fits in with our design:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `MXPlayfieldLayer.m`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `MXPlayfieldLayer.m`'
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first thing we check is to make sure we don't have active moles in every
    molehill, and that we haven't reached the maximum number of simultaneous moles
    we want on screen at the same time (the `maxMoles` variable). If we have enough
    moles, we skip the rest of the loop. If we need a new mole, we enter a `do…while`
    loop that will randomly pick a molehill and check if it has the `isOccupied` variable
    set to `NO` (that is, no active mole in this molehill). If the randomizer picks
    a molehill that is already occupied, the `do…while` loop will pick another molehill
    and try again. When we find an unoccupied molehill, the code breaks out of the
    loop and starts to set up the mole.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查确保每个地鼠坑中都没有活跃的地鼠，并且我们没有达到我们希望在屏幕上同时显示的最大地鼠数量（`maxMoles`变量）。如果我们有足够的地鼠，我们就跳过循环的其余部分。如果我们需要一个新地鼠，我们进入一个`do…while`循环，该循环将随机选择一个地鼠坑并检查它是否将`isOccupied`变量设置为`NO`（即，这个地鼠坑中没有活跃的地鼠）。如果随机数生成器选择了一个已经被占据的地鼠坑，`do…while`循环将选择另一个地鼠坑并再次尝试。当我们找到一个未被占据的地鼠坑时，代码将跳出循环并开始设置地鼠。
- en: As we saw earlier, there is already a "blank mole" attached to every molehill.
    At this point we build a new sprite to attach to the `moleSprite` variable of
    `MXMole`, change the `moleState` to `kMoleAlive`, and set up the coordinates for
    the mole to start. We want the mole to start from underground (hidden by the ground
    image), so we set the mole's `y` position as the position of the molehill minus
    the height of the mole.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，每个地鼠坑已经附有一个“空白地鼠”。在这个阶段，我们构建一个新的精灵并将其附加到`MXMole`的`moleSprite`变量上，将`moleState`更改为`kMoleAlive`，并设置地鼠开始的位置坐标。我们希望地鼠从地下（被地面图像隐藏）开始，因此我们将地鼠的`y`位置设置为地鼠坑的位置减去地鼠的高度。
- en: Once we have set up the mole, we assign our calculated Z-order for this mole
    (based on the `moleHillBaseZ` variable we stored earlier for each molehill), and
    call the `raiseMole` method, which controls the animation and movement of the
    mole.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了地鼠，我们就为这个地鼠分配我们计算出的Z顺序（基于我们之前为每个地鼠坑存储的`moleHillBaseZ`变量），并调用`raiseMole`方法，该方法控制地鼠的动画和移动。
- en: Special moles
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊地鼠
- en: 'We have seen two references to the `isSpecial` variable from the `MXMole` class,
    so now is a good time to explain how it is used. In order to break the repetitive
    nature of the game, we have added a "special mole" feature. When a new mole is
    requested to spawn in the `spawnMole` method, we generate a random number between
    1 and 100\. If the resulting number is less than five, then we set the `isSpecial`
    flag for that mole. This means that roughly 5 percent of the time the player will
    get a special mole. Our special moles use the same graphics as the standard mole,
    but we will make them flash a rainbow of colors when they are in the play. It
    is a small difference, but enough to set up the scoring to give extra points for
    the "special mole". To implement this special mole, we only need to adjust coding
    in three logic areas:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了两次对`MXMole`类中的`isSpecial`变量的引用，因此现在是解释其使用方法的好时机。为了打破游戏的重复性，我们增加了一个“特殊地鼠”功能。当请求在`spawnMole`方法中生成新的地鼠时，我们生成一个介于1到100之间的随机数。如果得到的数字小于五，则将该地鼠的`isSpecial`标志设置为true。这意味着大约5%的时间玩家将获得一个特殊地鼠。我们的特殊地鼠使用与标准地鼠相同的图形，但当我们玩游戏时，我们会让它们闪烁彩虹般的多彩颜色。这是一个小小的不同，但足以设置计分系统，为“特殊地鼠”提供额外积分。为了实现这个特殊地鼠，我们只需要调整三个逻辑区域的编码：
- en: When `raiseMole` is setting the mole's actions (to make it flashy)
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`raiseMole`设置地鼠的动作（使其变得闪亮）
- en: When we hit the mole (to play a different sound effect)
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们击中地鼠（播放不同的音效）
- en: When we score the mole (to score more points)
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们得分（获得更多积分）
- en: 'This is a very small task, but it is the small variations in the gameplay that
    will draw the players in further. Let''s see the game with a special mole in the
    play:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常小的任务，但正是游戏中的这些小变化会吸引玩家进一步参与。让我们看看游戏中带有特殊地鼠的场景：
- en: '![Special moles](img/9007_03_04.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![特殊地鼠](img/9007_03_04.jpg)'
- en: Moving moles
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动地鼠
- en: When we call the `raiseMole` method, we build all of the mole's behavior. The
    absolute minimum we need is to raise the mole from the hill and lower it again.
    For our game, we want to add a little randomness to the behavior, so that we don't
    see exactly the same motions for every mole. We use a combination of pre-built
    animations with actions to achieve our result. As we haven't used any `CCAnimate`
    calls before, we should talk about them first.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`raiseMole`方法时，我们构建了所有鼹鼠的行为。我们需要的绝对最小行为是将鼹鼠从山上抬起来，然后再放下来。对于我们的游戏，我们希望给行为添加一点随机性，这样我们就不至于每次看到鼹鼠都做完全相同的动作。我们通过结合预制的动画和动作来实现我们的结果。因为我们之前没有使用过任何`CCAnimate`调用，所以我们首先来谈谈它们。
- en: The animation cache
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画缓存
- en: Cocos2d has many useful caches to store frequently used data. When we use a
    `CCSpriteBatchNode` , we are using the `CCSpriteFrameCache` to store all of the
    sprites we need by name. There is an equally useful `CCAnimationCache` as well.
    It is simple to use. You build your animation as a `CCAnimation`, and then load
    it to the `CCAnimationCache` by whatever name you would like.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d有许多有用的缓存来存储频繁使用的数据。当我们使用`CCSpriteBatchNode`时，我们通过名称使用`CCSpriteFrameCache`来存储我们需要的所有精灵。同样有用的是`CCAnimationCache`。它使用起来很简单。你将动画构建为一个`CCAnimation`，然后以你喜欢的任何名称将其加载到`CCAnimationCache`中。
- en: When you want to use your named animation, you can create a `CCAnimate` action
    that loads directly from `CCAnimationCache`. The only caution is that if you load
    two animations with the same name to the cache, they will collide in the cache,
    and the second one will replace the first.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想使用你的命名动画时，你可以创建一个直接从`CCAnimationCache`加载的`CCAnimate`动作。唯一的注意事项是，如果你将两个具有相同名称的动画加载到缓存中，它们将在缓存中发生冲突，第二个将替换第一个。
- en: For our project, we preload the animation during the `init` method by calling
    the `buildAnimations` method. We only use one animation here, but you could preload
    as many as you need to the cache ahead of time.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目，我们在`init`方法中通过调用`buildAnimations`方法预加载动画。这里我们只使用一个动画，但你可以在缓存中提前预加载你需要的任意多个。
- en: '**Filename:** `MXPlayfieldLayer.m`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `MXPlayfieldLayer.m`'
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We only have three unique frames of animation, but we load them multiple times
    into the `frameArray` to fit our desired animation. We create a `CCAnimation`
    object from the `frameArray`, and then commit it to `CCAnimationCache` under the
    name `penguinAnim`. Now that we have loaded it to the cache, we can reference
    it anywhere we want it, just by requesting it from `CCAnimationCache`, like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只有三帧独特的动画，但我们将它们多次加载到`frameArray`中，以适应我们想要的动画。我们从`frameArray`创建一个`CCAnimation`对象，然后将其以名称`penguinAnim`提交到`CCAnimationCache`中。现在我们已经将其加载到缓存中，我们可以在任何需要的地方通过请求`CCAnimationCache`来引用它，就像这样：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Combining actions and animation
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合动作和动画
- en: For the behavior of the moles, we will be combining actions and animation at
    the same time to give more of a feeling of life to the game. In all, we define
    six behaviors for a normal mole, and one specific behavior for a special mole.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于鼹鼠的行为，我们将同时结合动作和动画，以给游戏增添更多的生命力。总的来说，我们为普通鼹鼠定义了六种行为，以及一种特殊鼹鼠的特定行为。
- en: '**Filename:** `MXPlayfieldLayer.m`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `MXPlayfieldLayer.m`'
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This method takes one big shortcut to keep from repeating code. We define nine
    separate actions for a standard mole, even though we will not use them all on
    the same mole. We do this because there is a lot of overlap between the different
    behaviors, and we don't want to repeat the same line of code again and again.
    If we look at just two of the actions, `moveUp` and `moveUpHalf`, half of the
    mole behaviors use the first, and half use the second. Instead of the path we
    have taken here, the alternative would be to include seven individual `CCMoveBy`
    definitions in this method to accommodate the six normal mole move up behaviors
    plus the special mole behavior. On the surface this isn't a big concern, but it
    does matter if we wanted to alter the behavior of how far a mole is raised up
    from the `moveUp` action, we would have to change that in four places. If we only
    defined the necessary actions after the behavior was determined, this would mean
    31 lines to maintain instead of our current 9 lines. If performance is not negatively
    affected, it is a good idea to always take the maintainable approach.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通过一个大的捷径来避免重复代码。我们为标准鼹鼠定义了九个独立的行为，尽管我们不会在同一个鼹鼠上使用它们全部。我们这样做是因为不同的行为之间有很多重叠，我们不希望重复相同的代码行。如果我们只看其中的两个动作，`moveUp`和`moveUpHalf`，一半的鼹鼠行为使用第一个，另一半使用第二个。而不是我们这里采取的路径，另一种选择是在这个方法中包含七个单独的`CCMoveBy`定义来适应六个正常的鼹鼠向上移动行为加上特殊鼹鼠行为。表面上这并不是一个大问题，但如果我们要改变鼹鼠从`moveUp`动作中抬升的距离的行为，我们就必须在这四个地方进行更改。如果我们只在行为确定后定义必要的动作，这意味着我们需要维护31行代码，而不是我们当前的9行。如果性能没有负面影响，始终采取可维护的方法是一个好主意。
- en: We also define the special mole behavior in this method. If the `isSpecial`
    flag is set, we use one set behavior, in two distinct actions. The `CCRepeatForever`
    action loops over our tinting, which tints the mole to red, then blue, and then
    green. At the same time, we are also running `CCSequence` of `moveUp`, rotating
    side to side a couple of times, and then moving it down again.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也在这种方法中定义了特殊的鼹鼠行为。如果设置了`isSpecial`标志，我们将使用一组行为，分为两个不同的动作。`CCRepeatForever`动作会循环我们的着色，将鼹鼠染成红色，然后蓝色，接着绿色。同时，我们也在运行`CCSequence`的`moveUp`动作，左右旋转几次，然后再将其向下移动。
- en: For a standard mole, we use a similar parallel action in the default section
    of the `switch` statement. We play the animation (named `anim`), which does not
    impact the moving up and down run by the second `runAction`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于标准鼹鼠，我们在`switch`语句的默认部分使用类似的并行动作。我们播放动画（命名为`anim`），这不会影响由第二个`runAction`执行的上下移动。
- en: Simultaneous actions
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同时动作
- en: This running of multiple simultaneous actions is a source of confusion for new
    developers. Some actions cannot be run in parallel in this fashion. For example,
    trying to run `CCMoveTo` and `CCMoveBy` at the same time will result in only the
    second run action being run. Why? Both are affecting the position of the sprite,
    and are therefore incompatible. The last one that is run "wins" and the former
    is discarded. Earlier we were able to run `CCTintTo` at the same time as a full
    `CCSequence` of movement and rotation actions. None of these other commands affected
    the color of the sprite, so they were able to be run in parallel.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这种同时运行多个动作的做法会让新开发者感到困惑。有些动作不能以这种方式并行运行。例如，同时尝试运行`CCMoveTo`和`CCMoveBy`只会运行第二个运行的动作。为什么？它们都在影响精灵的位置，因此是不兼容的。最后一个运行的动作“获胜”，前面的动作被丢弃。之前我们能够在运行`CCTintTo`的同时运行一个完整的`CCSequence`动作和旋转动作。这些其他命令都没有影响精灵的颜色，因此它们可以并行运行。
- en: When developing more complex sets of actions, it is important to evaluate what
    the desired outcome is, and which actions could conflict. A good rule of thumb
    is that you cannot run two of the "same" action on the "same" sprite at the "same"
    time. If you need to use two `CCMoveBy` statements, for example, you either need
    to chain them with `CCSequence` so they will run in order, or you need to revise
    your logic to combine the parameters so you can make a single `CCMoveBy` action
    that integrates both.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发更复杂的动作集时，重要的是评估期望的结果以及哪些动作可能会冲突。一个很好的经验法则是，你不能在同一时间在同一精灵上运行两个“相同”的动作。例如，如果你需要使用两个`CCMoveBy`语句，你可能需要用`CCSequence`将它们链接起来，以便它们按顺序运行，或者你需要修改你的逻辑以合并参数，这样你就可以创建一个整合了两个参数的单个`CCMoveBy`动作。
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The final level of complexity would be to abandon actions for that behavior
    and instead manually change the positioning in your `update` method. This is powerful,
    but nothing we need to delve into at this time.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最复杂的最终级别将是放弃动作以实现该行为，而是手动在您的 `update` 方法中更改位置。这很强大，但我们目前不需要深入研究。
- en: Deleting moles
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除地鼠
- en: At the end of all of the mole actions, there was a `CCCallFuncND` action named
    `delMole` called. `CCCallFuncND` is a very powerful action, yet it is extremely
    simple at the same time. This action is used to call any selector and pass any
    data object to it. In our case, we call the `deleteMole:data:` method, and pass
    it a pointer to the current `MXMoleHill`. Using `CCCallFuncND` (and its similar
    brethren `CCCallFunc` and `CCCallFuncN`), you can integrate other methods into
    an action sequence.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有地鼠动作结束时，调用了名为 `delMole` 的 `CCCallFuncND` 动作。`CCCallFuncND` 是一个非常强大的动作，同时它也非常简单。此动作用于调用任何选择器并向其传递任何数据对象。在我们的情况下，我们调用
    `deleteMole:data:` 方法，并传递一个指向当前 `MXMoleHill` 的指针。使用 `CCCallFuncND`（及其类似兄弟 `CCCallFunc`
    和 `CCCallFuncN`），您可以将其他方法集成到动作序列中。
- en: '**Filename:** `MXPlayfieldLayer.m`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `MXPlayfieldLayer.m`'
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Because we implemented the "blank mole" model into our design, we aren't actually
    deleting the moles. We reduce the counter `molesInPlay` and call the method to
    reset the mole to become a "blank mole". This is the same `resetMole` we called
    when we first created the "blank moles" in the beginning.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将“空白地鼠”模型实施到设计中，我们实际上并没有删除地鼠。我们减少计数器 `molesInPlay` 并调用方法将地鼠重置为“空白地鼠”。这就是我们在最初创建“空白地鼠”时调用的相同
    `resetMole` 方法。
- en: '**Filename:** `MXPlayfieldLayer.m`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `MXPlayfieldLayer.m`'
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: That's all it takes to completely clean a mole when we're ready to make a "blank
    mole" out of it. We reset everything to default values, and we remove the sprite
    attached to it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们准备好将地鼠变成“空白地鼠”时，完全清理地鼠只需这样做。我们将所有内容重置为默认值，并移除附加到其上的精灵。
- en: Touching moles
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触摸地鼠
- en: 'By this point, we have moles that can be spawned, animated, and reset. What
    about the real fun, the mole thumping? For that, we look at the `MXMole.m` file,
    where all of the mole touch handling is coded:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有了可以生成、动画化和重置的地鼠。那么真正的乐趣，地鼠的敲击呢？为此，我们查看 `MXMole.m` 文件，其中包含了所有地鼠触摸处理代码：
- en: '**Filename:** `MXMole.m`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `MXMole.m`'
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have registered the `MXMole` class with the `CCTouchDispatcher` as a Targeted
    Delegate. This means that the mole will be notified of every touch individually.
    As we are looking for a single touch per mole, this is perfect for our needs.
    We registered with the dispatcher in the `init` method, and we built the matching
    `destroyTouchDelgate` method, which is called in the `dealloc` method of `MXPlayfieldLayer`.
    If we don't remove the delegate, the mole will be a leaked object and will cause
    memory issues.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将 `MXMole` 类注册为 `CCTouchDispatcher` 的目标代理。这意味着地鼠将单独通知每个触摸。由于我们正在寻找每个地鼠的单个触摸，这对我们的需求来说非常完美。我们在
    `init` 方法中注册了它，并构建了匹配的 `destroyTouchDelgate` 方法，该方法在 `MXPlayfieldLayer` 的 `dealloc`
    方法中被调用。如果我们不移除代理，地鼠将成为泄漏对象，并导致内存问题。
- en: When the game design was reviewed at the beginning of the chapter, we discussed
    the approach we would take with the Z-order "trick" to make the mole disappear
    when it went behind the ground image. If we left it at that, there would be a
    serious gameplay flaw. The normal touch handling would also accept the touch when
    the mole was touched below the ground level. How do we fix this?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开头对游戏设计进行审查时，我们讨论了使用 Z-顺序“技巧”使地鼠在进入地面图像后面消失的方法。如果我们就这样留下，将会有一个严重的游戏玩法缺陷。正常的触摸处理也会在地鼠被触摸在地面以下时接受触摸。我们如何解决这个问题？
- en: Correcting this issue is the reason we created the `moleGroundY` variable. When
    we spawn a new mole, we set this variable to match the molehill's `y` position.
    Since we also use the molehill's `y` value in the placement of the molehill graphics,
    this represents the exact `y` position where the mole emerges from the ground.
    In our `ccTouchBegan` method inside the `MXMole` class, we only accept the touch
    if the mole is being touched and the touch has a `y` value greater than or equal
    to the `moleGroundY` position. This will effectively limit the touched mole parts
    to those above ground level. (It's not pixel-perfect, because the `moleHillBottom`
    sprite has a few pixels above this "horizon" line, but it is so small a coordinate
    variation that it does not affect the playability of the game).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 修复这个问题是我们创建`moleGroundY`变量的原因。当我们生成一个新的鼹鼠时，我们将这个变量设置为与鼹鼠丘的`y`位置相匹配。由于我们还在放置鼹鼠丘图形时使用鼹鼠丘的`y`值，这代表了鼹鼠从地面出现的确切`y`位置。在我们的`MXMole`类中的`ccTouchBegan`方法内，我们只接受当鼹鼠被触摸且触摸的`y`值大于或等于`moleGroundY`位置时的触摸。这将有效地限制被触摸的鼹鼠部分仅限于地面以上的部分。（这不是像素级的完美，因为`moleHillBottom`精灵在“地平线”线以上有少量像素，但这种坐标变化非常小，不会影响游戏的可玩性）。
- en: When the mole is touched, it changes the `moleState` variable to a value of
    `kMoleHit` and plays a sound.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当触摸鼹鼠时，它将`moleState`变量更改为`kMoleHit`的值并播放声音。
- en: Tying it together
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 综合起来
- en: 'There are only two important methods left to review to tie this all together.
    First is the `update` method. Let''s look at the applicable portions of the `update`
    method (we have left placeholders for the other portions of the `update` method,
    but those will not be addressed here. Please refer the code bundle for this book
    to see those details):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下只有两个重要的方法需要审查以将这些内容综合起来。首先是`update`方法。让我们看看`update`方法的相关部分（我们留下了`update`方法其他部分的占位符，但那些内容在这里不会讨论。请参考本书的代码包以查看这些细节）：
- en: '**Filename:** `MXPlayfieldLayer.m`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `MXPlayfieldLayer.m`'
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: On every loop of the `update` method, we iterate through the `moleHillsInPlay`
    array. We check each mole to see if we have one in the `kMoleHit` state. If a
    hit mole is found, we change the state of that mole to `kMoleMoving`, and call
    the `scoreMole` method. As we only set the `moleState` to `kMoleHit` within the
    touch handler, and then immediately change it to `kMoleMoving` when we first trap
    it in this loop, we can be assured that this is the first (and only) time we have
    seen this particular scoring event. If we did not change the `moleState` here,
    we would trigger `scoreMole` every time the `update` method ran, and the game
    would grind to a halt.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在`update`方法的每次循环中，我们遍历`moleHillsInPlay`数组。我们检查每个鼹鼠，看是否有处于`kMoleHit`状态的鼹鼠。如果找到一个被击中的鼹鼠，我们将该鼹鼠的状态更改为`kMoleMoving`，并调用`scoreMole`方法。由于我们只在触摸处理程序中将`moleState`设置为`kMoleHit`，然后立即在我们第一次在这个循环中捕获它时将其更改为`kMoleMoving`，我们可以确保这是我们第一次（也是唯一一次）看到这个特定的计分事件。如果我们没有在这里更改`moleState`，那么每次`update`方法运行时都会触发`scoreMole`，游戏将陷入停滞。
- en: The second section of the `update` method controls the spawning of new moles.
    As we want to have a little delay between new moles being created, we use the
    `spawnRest` variable to act as a timer to leave at least 10 update loops between
    calls to `spawnMole`. We also make sure we don't have the maximum number of desired
    moles in the play already. Combined, these two simple checks provide a very natural
    spawn feeling. The player is never bored waiting for moles to spawn, and the moles
    themselves don't appear in any synchronized pattern.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`方法的第二部分控制新鼹鼠的生成。由于我们希望在创建新鼹鼠之间有一定的延迟，我们使用`spawnRest`变量作为计时器，在调用`spawnMole`之间至少留下10个更新循环。我们还确保在游戏中没有达到期望的最大鼹鼠数量。这两个简单的检查结合起来，提供了非常自然的生成感觉。玩家在等待鼹鼠生成时永远不会感到无聊，而且鼹鼠本身不会以任何同步的模式出现。'
- en: Scoring the mole
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计分鼹鼠
- en: We haven't addressed the details of the scoring system because it is trivially
    simple. There is a variable called `playerScore`, and a label that displays that
    score. (For details on the scoring, please see the code bundle for this book.)
    In this game, the more interesting aspect of "scoring the mole" is the visual
    way we show that it was scored.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有讨论计分系统的细节，因为它非常简单。有一个名为`playerScore`的变量和一个显示该得分的标签。（有关计分的详细信息，请参阅本书的代码包。）在这个游戏中，“计分鼹鼠”更有趣的方面是我们展示计分的视觉方式。
- en: '**Filename:** `MXPlayfieldLayer.m`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `MXPlayfieldLayer.m`'
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Most of this code should look familiar by now. After a "safety net" check to
    prevent scoring a dead mole, we increment the score itself. After we update the
    score, we build some new actions to move the mole to the score location, scale
    it down, and then delete it when we're done.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，大部分代码应该看起来都很熟悉了。在进行“安全网”检查以防止获得无效的分数后，我们增加分数本身。在更新分数之后，我们构建一些新的动作来将鼹鼠移动到得分位置，将其缩小，并在完成后删除它。
- en: 'Here we see one type of action we haven''t touched on before: `CCSpawn`. Despite
    the name, it is completely unrelated to the mole spawning we built in this game.
    Instead, a `CCSpawn` action allows two actions to be performed on the same target
    at the same time. This is an alternate behavior compared to `CCSequence`, which
    will run the actions one at a time. For our use, we want the sprite to move and
    scale down by 50 percent at the same time. There are a couple of limitations of
    `CCSpawn`. The first is that it must be a finite interval action. No `CCRepeatForever`
    actions can be used inside a `CCSpawn`, for example. The other limitation is that
    both actions inside the `CCSpawn` action should have the same duration. If their
    duration is different, it will run until the longer of the two actions is complete.
    With that in mind, we set the duration for both the `CCMoveTo` and `CCScaleTo`
    actions to `0.2f` so the move and scale is quick and pleasant.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到一种之前未曾涉及的动作类型：`CCSpawn`。尽管名字如此，它与我们在游戏中构建的鼹鼠繁殖完全无关。相反，`CCSpawn`动作允许同时对同一目标执行两个动作。这与`CCSequence`的行为不同，后者会逐个运行动作。对于我们的用途，我们希望精灵同时移动并缩小50%。`CCSpawn`有几个限制。第一个是它必须是一个有限间隔的动作。例如，不能在`CCSpawn`中使用`CCRepeatForever`动作。另一个限制是`CCSpawn`动作中的两个动作应该具有相同的持续时间。如果它们的持续时间不同，它将运行直到两个动作中较长的那个完成。考虑到这一点，我们将`CCMoveTo`和`CCScaleTo`动作的持续时间都设置为`0.2f`，以便移动和缩放既快又愉快。
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have navigated the challenges of a mole thumping game, and survived intact.
    In this chapter we have covered a few interesting concepts. We learned how to
    use Z-ordering to trick the eye. We created persistent objects that can be reused
    (the moles). We have also worked with using instances of `CCNode` as containers
    for other objects for both the molehills and the moles. We have spent considerable
    time discussing actions and animations, both of which are core to a successful
    cocos2d game design.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经克服了鼹鼠敲击游戏的挑战，并且完好无损地生存下来。在这一章中，我们介绍了一些有趣的概念。我们学习了如何使用Z排序来欺骗眼睛。我们创建了可重复使用的持久对象（鼹鼠）。我们还处理了使用`CCNode`实例作为其他对象的容器，无论是鼹鼠丘还是鼹鼠。我们花了相当多的时间讨论动作和动画，这两者都是成功cocos2d游戏设计的关键。
- en: In the next chapter, we will explore a snake game. From snakes eating mice to
    scaling difficulty levels, the chapter will cover some familiar ground and some
    new terrain.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索一个蛇形游戏。从蛇吃老鼠到调整难度级别，这一章将涵盖一些熟悉的领域和一些新的领域。
