- en: Chapter 8. Interacting with Native Phone Applications and APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Android Options menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing the contacts address book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing and retrieving data via the clipboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a background service on the iPhone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying local notifications on the iPhone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying Android notifications using intents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing your Android app on the device's SD-card
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Titanium allows you to create native apps that are almost totally cross-platform,
    it is inevitable that some devices will inherently have operating system and hardware
    differences that are specific to them (particularly between Android and iOS).
    For example, anyone who has used both Android and iPhone devices would immediately
    recognize the very different way the notification systems are set up. However,
    there are other platform-specific limitations that are very specific to the Titanium
    API.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll show you how to create and use some of these device-specific
    components and APIs in your applications. Unlike most chapters in this book, this
    one does not follow a singular, coherent application. So feel free to read each
    recipe in whichever order you wish.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Android Options menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Option menus are an important part of the Android user interface. They are the
    primary collection of menu items for a screen and appear when the user presses
    the **MENU** button on their device. In this recipe we are going to create an
    Android Options Menu and add it to our screen, giving each option its own click
    event with an action.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To prepare for this recipe, and all recipes in this chapter, open up Titanium
    Studio and log in if you have not already done so. You can either use the same
    application for each of the recipes in this chapter or create a new one, the choice
    is up to you.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The icons and code for this application is available in the `Chapter 8/Recipe
    1` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 8/Recipe
    1` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open up the `app.js` file in your IDE and enter in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run your application in the Android emulator for the first time.
    When you press the "menu" button on your device/emulator you should end up seeing
    a screen that looks just like the following example. Tapping on the first menu
    item should execute its click event and show you an alert dialog. An example of
    this can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/3968EXP_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, it is important to note that the code in this recipe is applicable to
    Android only. The iOS platform doesn't have a physical menu button like an Android
    device, and therefore doesn't have an Option menu. On Android, these menus help
    to facilitate user actions. We can see this occurring in the `click` event of
    the first menu item, where we are using an event handler to capture this event
    and show a simple alert dialog.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth option in the menu is altered by utilizing the "**onPrepareOptionsMenu**"
    event, which is executed prior to the menu being added to the screen. You can
    enable, disable, add, or remove items within this event handler. In this recipe,
    we are hiding the fourth menu option by setting its `visible` state to *false*,
    which we can change again to *true* within the event handler of the second menu
    option.
  prefs: []
  type: TYPE_NORMAL
- en: Menu icon sizes for Android devices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your menu icons should be flat, pictured "face on", and greyscale. According
    to the Android guidelines, all menu icons should use the same color palette and
    effects in order to maintain consistency. Icon sizes for each of the Android screen
    density sizes are listed below.
  prefs: []
  type: TYPE_NORMAL
- en: 'Menu icon dimensions for high-density (hdpi) screens:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Full Asset: 72 x 72 px'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Icon: 48 x 48 px'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Square Icon: 44 x 44 px'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Menu icon dimensions for medium-density (mdpi) screens:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Full Asset: 48 x 48 px'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Icon: 32 x 32 px'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Square Icon: 30 x 30 px'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Menu icon dimensions for low-density (ldpi) screens:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Full Asset: 36 x 36 px'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Icon: 24 x 24 px'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Square Icon: 22 x 22'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing the contacts address book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There will be times when you want the user to access existing data from their
    device in order to populate some fields or a database within your own application.
    Possibly, the best example of this is the utilization of the address book and
    contact details. For example, if you built an application that primarily was meant
    for sharing data over e-mail, using the contact address book on the device would
    allow the user to select contacts they already have from a selection list (as
    opposed to having to remember or re-enter the data separately).
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll create a basic interface that accesses our address book
    and pulls back a contact's details, filling in our interface components including
    some text fields and an image view as we do so. Before you start, make sure your
    device or emulator has some contacts available in it by choosing the *Contacts*
    icon on iPhone or the *People* icon on Android and adding at least one entry.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 8/Recipe
    2` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open up the `app.js` file in your IDE and enter in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Access to the address book differs depending on the platform. On the Android
    operating system you will have read-only access to the contacts list, whereas
    on the iPhone you will have full read/write privileges. Therefore, it pays to
    keep in mind that methods such as `createPerson` will not be available for use
    on Android devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'All access to the device''s contacts are available through the `Titanium.Contacts`
    namespace. In this recipe, we built a basic screen with some text fields and an
    image view, which we''re populating by loading up the contacts API and choosing
    an entry from the device''s contact list. To do this, we are executing the `showContacts()`
    method, which has two distinct callback functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SelectedProperty:` This callback is executed when the user chooses a person''s
    property, rather than a singular contact entry'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SelectedPerson:` This call-back is executed when the user chooses a person''s
    entry'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our example recipe, we are utilizing the `SelectedPerson` function and assigning
    the callback property `(e)` to a new object named `person`. From here we can access
    the `field` properties of the contact that were chosen from the device''s contact
    list, such as phone, e-mail, name, and contact photograph, and then assign these
    variables to the relevant fields in our own application. The following screenshots
    show the contact''s screen both empty and filled out after choosing a contact
    from the device''s list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/3968EXP_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Storing and retrieving data via the clipboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The clipboard is used to store textual and object data so it can be utilized
    between different screens and applications on your device. While both iOS and
    Android have built-in clipboard capability, Titanium extends this by letting you
    programmatically access and write data to the clipboard. In this recipe, we will
    create a screen with two text fields and a series of buttons that allow us to
    programmatically copy data from one text field and paste it into another.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 8/Recipe
    3` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open your project's `app.js` file in your IDE and enter in the following code
    (deleting any existing code). When finished, run your application in the emulator
    to test it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe we are copying simple strings to and from the clipboard. However,
    it is important to note that you can also copy objects using the `Ti.UI.Clipboard.setObject()`
    method. There are two methods we are utilizing in order to copy data to and from
    the clipboard, `setText()` and `getText()`, which do exactly the function they
    both describe. We are setting the text in the clipboard from our first text field
    using the **Copy** button, and then pasting that same text programmatically into
    the second text field using the **Paste** button. Using the clipboard has many
    uses, but the most important one is its ability to let users share data provided
    by your application with other applications on their device (as seen in the following
    screenshots). As an example, you may provide a "copy" button for an e-mail address
    that can then be copied and pasted by the user into their local e-mail client,
    such as Mobile Mail or Google Gmail.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/3968EXP_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a background service on the iPhone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apple now supports background services in iOS 4 and above, meaning your apps
    can now run code in the background much like Android apps are able to. In this
    recipe we are going to create a background service, which will execute a set piece
    of code from a separate file called `bg.js`. We will also log each stage of the
    background service cycle to the console so you can understand each process.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 8/Recipe
    4` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your project''s `app.js` file in your IDE and enter in the following code
    (deleting any existing code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new file called `bg.js` and save it to your project''s `Resources`
    folder, then type in the following code. This is the code we are going to execute
    via our background service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When finished, run your application in the emulator to test it.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two major steps being undertaken with this recipe. The first is ensuring
    that the device we're currently running is indeed an iPhone (iOS) device, and
    second, that it is running the required iOS 4+ operating system. The `validiOSPlatform()`
    function performs this task and returns a simple Boolean true/false response which
    indicates whether to proceed with registering our background service or not.
  prefs: []
  type: TYPE_NORMAL
- en: The second part is registering our background service using the file `bg.js`
    as the code we wish to execute when the application becomes "backgrounded". In
    this situation, the code in our background service file will fire and log an information
    message to the console. All of the application pause and resume event listeners
    are also handled in this example. Therefore, you can run the application in the
    emulator, open it, exit it, and re-open it again to see each of the event handler
    fire, and log the matching message to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/3968EXP_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Displaying local notifications on the iPhone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another post iOS 4+ feature was the introduction of local notifications which
    allowed the developer to create basic notification alerts that looked and acted
    similar to **Push** notifications, but without the hassle of creating all of the
    certificates and server-side code necessary for Push to work. In this recipe,
    we are going to extend the previous code that we wrote for our background service,
    and create a local notification when the app is pushed to the background of the
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 8/Recipe
    5` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your project''s `bg.js` file from the previous recipe, and extend it by
    adding in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in your `app.js` file, create the following event listener and handler.
    It will execute whenever your **Answer It** confirmation button is pushed during
    the background process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When you are finished, run your application in the emulator to test it. You
    should be able to "background", or pause, the application after it starts running
    (by pressing the "home" button on your iPhone) and receive a local notification.
    Tapping on **Answer It** will reload your app and cause our "notification' event
    listener to fire (as seen in the following screenshots)!
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/3968EXP_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A local notification consists of a number of parameters, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '`alertBody:` The message that appears in your alert dialog'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alertAction:` The right-hand button that executes your application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`userInfo:` The data you wish to pass back to your app'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`date:` When to execute the notification'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our example is using the current date and time, meaning the notification will
    appear momentarily after the application has become "backgrounded". When the notification
    appears, the user can then either cancel it, or use our custom "action" button
    to re-launch the app and execute our "notification" event handler.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying Android notifications using intents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Intents are the Android terminology for an operation that is to be performed
    on the system. Most significantly, it is used for launching activities. The primary
    parameters of an intent are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The "action": A general action to be performed, such as `ACTION_VIEW`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The "data": The data to operate the action on, such as database record or contact
    person data'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this recipe we are going to use intents in conjunction with Android's Notification
    Manager in order to create a local notification which will appear in our user's
    Android notification bar.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 8/Recipe
    6` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need the package identifier (in the format of *com.yourcompany.yourapp—you*
    can find it on the **Edit** tab in Titanium Studio) and the class name of your
    Android app. You can find the class name by opening the `Build/Android` folder
    in your project, and then opening the `Android.manifest.xml` file contained within.
    Under the `application` node you will find a section that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Your `className` property is a combination of your application identifier and
    the `android:name` attribute in the previous XML. In our case, this `className`
    property is `com.boydlee.nativeapis.NativeapisActvitity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these two values written down, open your project''s `app.js` file in your
    IDE and enter in the following code (deleting any existing):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When finished, run your application in the Android emulator to test it. Once
    your application has launched you should be able to then exit and pull down the
    Android notification bar to see the results.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe we are using intents and activities in conjunction with a notification
    message. The `notification` object itself is relatively simple. It takes in a
    number of parameters including the title and message of the notification, along
    with a badge `number` and `when` parameter (the `datetime` that the notification
    will show, which we have set to the default value 'now'). The `ledARGB` parameter
    is the color to flash on the device LED, which we have set to the device default.
  prefs: []
  type: TYPE_NORMAL
- en: You'll notice that we also added a category to our intent, using the `addCategory`
    method, such as `intent.addCategory(Titanium.Android.CATEGORY_LAUNCHER)`;. In
    our example, we used `CATEGORY_LAUNCHER`, which means that our intent should appear
    in the Launcher as a top-level application.
  prefs: []
  type: TYPE_NORMAL
- en: Coupled with our notification is an object called `pending`. This is our *intent*,
    and that intent has been written in order to launch an *activity*. In our case,
    the activity is to launch our application again. You can also add URL properties
    to intents so that your application can launch specific code on re-entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows an example of our notification message in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/3968EXP_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Storing your Android app on the device's SD card
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the downsides to Titanium is that, due to its compilation process, applications
    built on the Titanium platform tend to be rather large in file size in comparison
    to a native app. Most simple apps in Titanium will range from between 4-5 megabytes
    in size. This is not really a problem for an iPhone, but unfortunately many Android
    devices utilize SD card memory and do not have much in the way of local phone
    storage space.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will show you how to configure your Android application in
    order for it to run on the SD card, via Android's **Move to SD card** button in
    the application settings screen.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 8/Recipe
    7` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `tiapp.xml` file under your project''s root directory and find the`<android>`
    node in the XML which will be located near the bottom of the file. Alter the`<android>`
    node so it looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now build and run your application on your Android device. Note that this may
    not work in the emulator.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few important parts to understand in relation to this XML configuration.
    The first is that the`<tool-api-level>` node value is actually referring to the
    minimum version of the Android tools required. Version 8 is the minimum needed
    to enable the external storage functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The`<android:installLocation>` attribute refers to the initial storage of the
    application upon installation. Here we are telling the Android OS that we prefer
    it to be stored externally to an SD card. However, if one is unavailable, the
    app will be stored directly to the phone memory. You can also use a value of `internalOnly`,
    which would disallow the app from being installed on external memory.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the`<uses-sdk>` node refers to the version of Android required. Version
    7 in this case refers to Android 2.1 and up, which is required in order to perform
    the **Copy To SD-Card** action.
  prefs: []
  type: TYPE_NORMAL
