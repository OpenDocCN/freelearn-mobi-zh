- en: Chapter 8. Interacting with Native Phone Applications and APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章.与原生手机应用程序和API交互
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍：
- en: Creating an Android Options menu
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Android选项菜单
- en: Accessing the contacts address book
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问联系人地址簿
- en: Storing and retrieving data via the clipboard
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过剪贴板存储和检索数据
- en: Creating a background service on the iPhone
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在iPhone上创建后台服务
- en: Displaying local notifications on the iPhone
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在iPhone上显示本地通知
- en: Displaying Android notifications using intents
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用意图显示Android通知
- en: Storing your Android app on the device's SD-card
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的Android应用程序存储在设备的SD卡上
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: While Titanium allows you to create native apps that are almost totally cross-platform,
    it is inevitable that some devices will inherently have operating system and hardware
    differences that are specific to them (particularly between Android and iOS).
    For example, anyone who has used both Android and iPhone devices would immediately
    recognize the very different way the notification systems are set up. However,
    there are other platform-specific limitations that are very specific to the Titanium
    API.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Titanium允许您创建几乎完全跨平台的本地应用程序，但不可避免的是，某些设备将固有地具有特定于它们的操作系统和硬件差异（尤其是在Android和iOS之间）。例如，任何使用过Android和iPhone设备的用户都会立即认识到通知系统设置方式非常不同。然而，还有其他特定于平台的限制，这些限制非常具体于Titanium
    API。
- en: In this chapter, we'll show you how to create and use some of these device-specific
    components and APIs in your applications. Unlike most chapters in this book, this
    one does not follow a singular, coherent application. So feel free to read each
    recipe in whichever order you wish.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您展示如何在您的应用程序中创建和使用一些这些特定于设备的组件和API。与本书中的大多数章节不同，这一章不遵循一个单一、连贯的应用程序。因此，请随意按您希望的顺序阅读每个菜谱。
- en: Creating an Android Options menu
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Android选项菜单
- en: Option menus are an important part of the Android user interface. They are the
    primary collection of menu items for a screen and appear when the user presses
    the **MENU** button on their device. In this recipe we are going to create an
    Android Options Menu and add it to our screen, giving each option its own click
    event with an action.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 选项菜单是Android用户界面的重要组成部分。它们是屏幕上菜单项的主要集合，当用户在其设备上按下**MENU**按钮时出现。在本菜谱中，我们将创建一个Android选项菜单并将其添加到我们的屏幕上，为每个选项分配一个具有动作的点击事件。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To prepare for this recipe, and all recipes in this chapter, open up Titanium
    Studio and log in if you have not already done so. You can either use the same
    application for each of the recipes in this chapter or create a new one, the choice
    is up to you.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备这个菜谱以及本章中的所有菜谱，打开Titanium Studio并登录，如果您还没有这样做的话。您可以使用本章中每个菜谱相同的程序，或者创建一个新的程序，选择权在您手中。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The icons and code for this application is available in the `Chapter 8/Recipe
    1` folder.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本应用程序的图标和代码可在`Chapter 8/Recipe 1`文件夹中找到。
- en: Complete source code for this recipe can be found in the `/Chapter 8/Recipe
    1` folder.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的完整源代码可以在`/Chapter 8/Recipe 1`文件夹中找到。
- en: How to do it…
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Open up the `app.js` file in your IDE and enter in the following code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的IDE中打开`app.js`文件，并输入以下代码：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Build and run your application in the Android emulator for the first time.
    When you press the "menu" button on your device/emulator you should end up seeing
    a screen that looks just like the following example. Tapping on the first menu
    item should execute its click event and show you an alert dialog. An example of
    this can be seen in the following screenshot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首次在Android模拟器中构建和运行您的应用程序。当您在设备/模拟器上按下“菜单”按钮时，您应该看到一个看起来就像以下示例的屏幕。点击第一个菜单项应该执行其点击事件并显示一个警告对话框。以下截图是一个示例：
- en: '![How to do it…](img/3968EXP_08_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/3968EXP_08_01.jpg)'
- en: How it works…
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: First, it is important to note that the code in this recipe is applicable to
    Android only. The iOS platform doesn't have a physical menu button like an Android
    device, and therefore doesn't have an Option menu. On Android, these menus help
    to facilitate user actions. We can see this occurring in the `click` event of
    the first menu item, where we are using an event handler to capture this event
    and show a simple alert dialog.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，需要注意的是，这个菜谱中的代码仅适用于Android。iOS平台没有像Android设备那样的物理菜单按钮，因此也没有选项菜单。在Android上，这些菜单有助于方便用户操作。我们可以在第一个菜单项的`click`事件中看到这一点，在那里我们使用事件处理器来捕获这个事件并显示一个简单的警告对话框。
- en: The fourth option in the menu is altered by utilizing the "**onPrepareOptionsMenu**"
    event, which is executed prior to the menu being added to the screen. You can
    enable, disable, add, or remove items within this event handler. In this recipe,
    we are hiding the fourth menu option by setting its `visible` state to *false*,
    which we can change again to *true* within the event handler of the second menu
    option.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单中的第四个选项通过使用"**onPrepareOptionsMenu**"事件进行修改，该事件在菜单被添加到屏幕之前执行。您可以在此事件处理器中启用、禁用、添加或删除项目。在本教程中，我们通过将第四个菜单选项的`visible`状态设置为*false*来隐藏它，我们可以在第二个菜单选项的事件处理器中再次将其更改为*true*。
- en: Menu icon sizes for Android devices
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android设备的菜单图标大小
- en: Your menu icons should be flat, pictured "face on", and greyscale. According
    to the Android guidelines, all menu icons should use the same color palette and
    effects in order to maintain consistency. Icon sizes for each of the Android screen
    density sizes are listed below.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您的菜单图标应该是平面的，以“正面”呈现，并且是灰度的。根据Android指南，所有菜单图标应使用相同的调色板和效果，以保持一致性。以下是Android屏幕密度大小的图标大小列表。
- en: 'Menu icon dimensions for high-density (hdpi) screens:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高密度（hdpi）屏幕的菜单图标尺寸：
- en: 'Full Asset: 72 x 72 px'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整资产：72 x 72 像素
- en: 'Icon: 48 x 48 px'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图标：48 x 48 像素
- en: 'Square Icon: 44 x 44 px'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方形图标：44 x 44 像素
- en: 'Menu icon dimensions for medium-density (mdpi) screens:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中密度（mdpi）屏幕的菜单图标尺寸：
- en: 'Full Asset: 48 x 48 px'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整资产：48 x 48 像素
- en: 'Icon: 32 x 32 px'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图标：32 x 32 像素
- en: 'Square Icon: 30 x 30 px'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方形图标：30 x 30 像素
- en: 'Menu icon dimensions for low-density (ldpi) screens:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低密度（ldpi）屏幕的菜单图标尺寸：
- en: 'Full Asset: 36 x 36 px'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整资产：36 x 36 像素
- en: 'Icon: 24 x 24 px'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图标：24 x 24 像素
- en: 'Square Icon: 22 x 22'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方形图标：22 x 22
- en: Accessing the contacts address book
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问联系人地址簿
- en: There will be times when you want the user to access existing data from their
    device in order to populate some fields or a database within your own application.
    Possibly, the best example of this is the utilization of the address book and
    contact details. For example, if you built an application that primarily was meant
    for sharing data over e-mail, using the contact address book on the device would
    allow the user to select contacts they already have from a selection list (as
    opposed to having to remember or re-enter the data separately).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，您可能希望用户访问他们设备中的现有数据，以便在您的应用程序中填充某些字段或数据库。可能最好的例子是使用地址簿和联系人详细信息。例如，如果您构建了一个主要用于通过电子邮件共享数据的应用程序，使用设备上的联系人地址簿将允许用户从选择列表中选择他们已经拥有的联系人（而不是需要单独记住或重新输入数据）。
- en: In this recipe, we'll create a basic interface that accesses our address book
    and pulls back a contact's details, filling in our interface components including
    some text fields and an image view as we do so. Before you start, make sure your
    device or emulator has some contacts available in it by choosing the *Contacts*
    icon on iPhone or the *People* icon on Android and adding at least one entry.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将创建一个基本界面，该界面访问我们的通讯录并检索联系人详细信息，在执行此操作的同时填充我们的界面组件，包括一些文本字段和图像视图。在开始之前，请确保您的设备或模拟器中已通过在iPhone上选择*通讯录*图标或在Android上选择*联系人*图标添加了一些联系人。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this recipe can be found in the `/Chapter 8/Recipe
    2` folder.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程的完整源代码可在`/Chapter 8/Recipe 2`文件夹中找到。
- en: How to do it…
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Open up the `app.js` file in your IDE and enter in the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的IDE中打开`app.js`文件，并输入以下代码：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works…
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Access to the address book differs depending on the platform. On the Android
    operating system you will have read-only access to the contacts list, whereas
    on the iPhone you will have full read/write privileges. Therefore, it pays to
    keep in mind that methods such as `createPerson` will not be available for use
    on Android devices.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对地址簿的访问取决于平台。在Android操作系统上，您将只能对联系人列表进行只读访问，而在iPhone上，您将拥有完整的读写权限。因此，请注意，`createPerson`等方法在Android设备上不可用。
- en: 'All access to the device''s contacts are available through the `Titanium.Contacts`
    namespace. In this recipe, we built a basic screen with some text fields and an
    image view, which we''re populating by loading up the contacts API and choosing
    an entry from the device''s contact list. To do this, we are executing the `showContacts()`
    method, which has two distinct callback functions:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所有对设备通讯录的访问都通过`Titanium.Contacts`命名空间提供。在本教程中，我们创建了一个包含一些文本字段和图像视图的基本屏幕，我们通过加载联系人API并从设备联系人列表中选择一个条目来填充它。为此，我们执行了`showContacts()`方法，该方法有两个不同的回调函数：
- en: '`SelectedProperty:` This callback is executed when the user chooses a person''s
    property, rather than a singular contact entry'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SelectedProperty:` 当用户选择一个人的属性而不是单个联系人条目时执行此回调'
- en: '`SelectedPerson:` This call-back is executed when the user chooses a person''s
    entry'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SelectedPerson:` 当用户选择一个人的条目时执行此回调'
- en: 'In our example recipe, we are utilizing the `SelectedPerson` function and assigning
    the callback property `(e)` to a new object named `person`. From here we can access
    the `field` properties of the contact that were chosen from the device''s contact
    list, such as phone, e-mail, name, and contact photograph, and then assign these
    variables to the relevant fields in our own application. The following screenshots
    show the contact''s screen both empty and filled out after choosing a contact
    from the device''s list:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例菜谱中，我们正在使用`SelectedPerson`函数，并将回调属性`(e)`分配给一个名为`person`的新对象。从这里我们可以访问从设备联系人列表中选择的联系人的`field`属性，例如电话、电子邮件、姓名和联系照片，然后将这些变量分配给我们自己的应用程序中的相关字段。以下截图显示了从设备列表中选择联系人后，联系人的屏幕在空和填写后的样子：
- en: '![How it works…](img/3968EXP_08_02.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/3968EXP_08_02.jpg)'
- en: Storing and retrieving data via the clipboard
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过剪贴板存储和检索数据
- en: The clipboard is used to store textual and object data so it can be utilized
    between different screens and applications on your device. While both iOS and
    Android have built-in clipboard capability, Titanium extends this by letting you
    programmatically access and write data to the clipboard. In this recipe, we will
    create a screen with two text fields and a series of buttons that allow us to
    programmatically copy data from one text field and paste it into another.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 剪贴板用于存储文本和对象数据，以便在设备上的不同屏幕和应用程序之间使用。虽然iOS和Android都内置了剪贴板功能，但Titanium通过允许您以编程方式访问和写入剪贴板数据来扩展了这一功能。在这个菜谱中，我们将创建一个带有两个文本字段和一系列按钮的屏幕，这些按钮允许我们以编程方式从一个文本字段复制数据并将其粘贴到另一个文本字段中。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this recipe can be found in the `/Chapter 8/Recipe
    3` folder.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的完整源代码可以在`/Chapter 8/Recipe 3`文件夹中找到。
- en: How to do it…
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: Open your project's `app.js` file in your IDE and enter in the following code
    (deleting any existing code). When finished, run your application in the emulator
    to test it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的IDE中打开项目中的`app.js`文件，并输入以下代码（删除任何现有代码）。完成后，在模拟器中运行您的应用程序以进行测试。
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works…
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe we are copying simple strings to and from the clipboard. However,
    it is important to note that you can also copy objects using the `Ti.UI.Clipboard.setObject()`
    method. There are two methods we are utilizing in order to copy data to and from
    the clipboard, `setText()` and `getText()`, which do exactly the function they
    both describe. We are setting the text in the clipboard from our first text field
    using the **Copy** button, and then pasting that same text programmatically into
    the second text field using the **Paste** button. Using the clipboard has many
    uses, but the most important one is its ability to let users share data provided
    by your application with other applications on their device (as seen in the following
    screenshots). As an example, you may provide a "copy" button for an e-mail address
    that can then be copied and pasted by the user into their local e-mail client,
    such as Mobile Mail or Google Gmail.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们正在将简单的字符串复制到剪贴板和从剪贴板中。然而，重要的是要注意，您还可以使用`Ti.UI.Clipboard.setObject()`方法复制对象。我们正在使用两种方法来复制剪贴板中的数据，`setText()`和`getText()`，它们确实执行了它们所描述的功能。我们使用**复制**按钮将文本从第一个文本字段设置到剪贴板中，然后使用**粘贴**按钮以编程方式将相同的文本粘贴到第二个文本字段中。使用剪贴板有许多用途，但其中最重要的用途是它允许用户将应用程序提供的数据与设备上的其他应用程序共享（如下面的截图所示）。例如，您可以为电子邮件地址提供一个“复制”按钮，然后用户可以将该按钮复制并粘贴到他们的本地电子邮件客户端中，例如Mobile
    Mail或Google Gmail。
- en: '![How it works…](img/3968EXP_08_03.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/3968EXP_08_03.jpg)'
- en: Creating a background service on the iPhone
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在iPhone上创建后台服务
- en: Apple now supports background services in iOS 4 and above, meaning your apps
    can now run code in the background much like Android apps are able to. In this
    recipe we are going to create a background service, which will execute a set piece
    of code from a separate file called `bg.js`. We will also log each stage of the
    background service cycle to the console so you can understand each process.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果现在支持iOS 4及更高版本的背景服务，这意味着您的应用程序现在可以在后台运行代码，就像Android应用程序能够做到的那样。在这个菜谱中，我们将创建一个后台服务，它将执行一个名为`bg.js`的单独文件中的固定代码片段。我们还将记录后台服务周期的每个阶段到控制台，以便您理解每个过程。
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this recipe can be found in the `/Chapter 8/Recipe
    4` folder.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的完整源代码可以在`/Chapter 8/Recipe 4`文件夹中找到。
- en: How to do it…
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Open your project''s `app.js` file in your IDE and enter in the following code
    (deleting any existing code):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的IDE中打开项目`app.js`文件，并输入以下代码（删除任何现有代码）：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now create a new file called `bg.js` and save it to your project''s `Resources`
    folder, then type in the following code. This is the code we are going to execute
    via our background service:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个名为`bg.js`的新文件，并将其保存到项目的`Resources`文件夹中，然后输入以下代码。这是我们通过后台服务将要执行的代码：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When finished, run your application in the emulator to test it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，在模拟器中运行你的应用程序以进行测试。
- en: How it works…
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: There are two major steps being undertaken with this recipe. The first is ensuring
    that the device we're currently running is indeed an iPhone (iOS) device, and
    second, that it is running the required iOS 4+ operating system. The `validiOSPlatform()`
    function performs this task and returns a simple Boolean true/false response which
    indicates whether to proceed with registering our background service or not.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱涉及两个主要步骤。第一步是确保我们正在运行的设备确实是一部iPhone（iOS）设备，第二步是确保它正在运行所需的iOS 4+操作系统。`validiOSPlatform()`函数执行此任务，并返回一个简单的布尔值true/false响应，指示是否继续注册我们的后台服务。
- en: The second part is registering our background service using the file `bg.js`
    as the code we wish to execute when the application becomes "backgrounded". In
    this situation, the code in our background service file will fire and log an information
    message to the console. All of the application pause and resume event listeners
    are also handled in this example. Therefore, you can run the application in the
    emulator, open it, exit it, and re-open it again to see each of the event handler
    fire, and log the matching message to the console.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是使用`bg.js`文件作为代码注册我们的后台服务，当应用程序进入“后台”状态时执行此代码。在这种情况下，后台服务文件中的代码将触发并记录一条信息消息到控制台。本例中还处理了所有应用程序暂停和恢复事件监听器。因此，你可以在模拟器中运行应用程序，打开它，退出它，然后再次打开它，以查看每个事件处理程序触发，并将相应的消息记录到控制台。
- en: '![How it works…](img/3968EXP_08_04.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/3968EXP_08_04.jpg)'
- en: Displaying local notifications on the iPhone
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在iPhone上显示本地通知
- en: Another post iOS 4+ feature was the introduction of local notifications which
    allowed the developer to create basic notification alerts that looked and acted
    similar to **Push** notifications, but without the hassle of creating all of the
    certificates and server-side code necessary for Push to work. In this recipe,
    we are going to extend the previous code that we wrote for our background service,
    and create a local notification when the app is pushed to the background of the
    system.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个iOS 4+后的特性是本地通知的引入，它允许开发者创建看起来和操作类似**推送**通知的基本通知警报，但无需创建所有必要的证书和服务器端代码，以便推送工作。在本食谱中，我们将扩展为我们的后台服务编写的先前代码，并在应用程序被推送到系统后台时创建一个本地通知。
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this recipe can be found in the `/Chapter 8/Recipe
    5` folder.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的完整源代码可以在`/Chapter 8/Recipe 5`文件夹中找到。
- en: How to do it…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Open your project''s `bg.js` file from the previous recipe, and extend it by
    adding in the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 打开上一个食谱中的项目`bg.js`文件，并添加以下代码来扩展它：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now in your `app.js` file, create the following event listener and handler.
    It will execute whenever your **Answer It** confirmation button is pushed during
    the background process:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你的`app.js`文件中，创建以下事件监听器和处理程序。它将在后台过程中按下**Answer It**确认按钮时执行：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When you are finished, run your application in the emulator to test it. You
    should be able to "background", or pause, the application after it starts running
    (by pressing the "home" button on your iPhone) and receive a local notification.
    Tapping on **Answer It** will reload your app and cause our "notification' event
    listener to fire (as seen in the following screenshots)!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，在模拟器中运行你的应用程序以进行测试。你应该能够在应用程序启动后“后台”或暂停应用程序（通过按下iPhone上的“主页”按钮）并接收本地通知。点击**Answer
    It**将重新加载你的应用程序，并触发我们的“通知”事件监听器（如以下截图所示）！
- en: '![How to do it…](img/3968EXP_08_05.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到这一点…](img/3968EXP_08_05.jpg)'
- en: How it works…
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: 'A local notification consists of a number of parameters, including:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 本地通知由多个参数组成，包括：
- en: '`alertBody:` The message that appears in your alert dialog'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alertBody:` 出现在你的警报对话框中的消息'
- en: '`alertAction:` The right-hand button that executes your application'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alertAction:` 执行您应用的右侧按钮'
- en: '`userInfo:` The data you wish to pass back to your app'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`userInfo:` 您希望传递回应用的资料'
- en: '`date:` When to execute the notification'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`date:` 何时执行通知'
- en: Our example is using the current date and time, meaning the notification will
    appear momentarily after the application has become "backgrounded". When the notification
    appears, the user can then either cancel it, or use our custom "action" button
    to re-launch the app and execute our "notification" event handler.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例使用当前日期和时间，这意味着通知将在应用变为“后台”后立即出现。当通知出现时，用户可以取消它，或者使用我们的自定义“操作”按钮重新启动应用并执行我们的“通知”事件处理器。
- en: Displaying Android notifications using intents
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用意图显示 Android 通知
- en: 'Intents are the Android terminology for an operation that is to be performed
    on the system. Most significantly, it is used for launching activities. The primary
    parameters of an intent are:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 意图是 Android 术语，用于在系统上执行的操作。最重要的是，它用于启动活动。意图的主要参数包括：
- en: 'The "action": A general action to be performed, such as `ACTION_VIEW`'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “操作”：要执行的一般操作，例如 `ACTION_VIEW`
- en: 'The "data": The data to operate the action on, such as database record or contact
    person data'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “数据”：操作要操作的数据，例如数据库记录或联系人数据
- en: In this recipe we are going to use intents in conjunction with Android's Notification
    Manager in order to create a local notification which will appear in our user's
    Android notification bar.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将结合使用意图和 Android 的通知管理器来创建一个本地通知，该通知将出现在我们用户的 Android 通知栏中。
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this recipe can be found in the `/Chapter 8/Recipe
    6` folder.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的完整源代码可以在 `/Chapter 8/Recipe 6` 文件夹中找到。
- en: How to do it…
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'You will need the package identifier (in the format of *com.yourcompany.yourapp—you*
    can find it on the **Edit** tab in Titanium Studio) and the class name of your
    Android app. You can find the class name by opening the `Build/Android` folder
    in your project, and then opening the `Android.manifest.xml` file contained within.
    Under the `application` node you will find a section that looks like the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要包标识符（格式为 *com.yourcompany.yourapp—you*，您可以在 Titanium Studio 的 **编辑** 选项卡中找到它）以及您
    Android 应用的类名。您可以通过在项目中打开 `Build/Android` 文件夹，然后打开包含在内的 `Android.manifest.xml`
    文件来找到类名。在 `application` 节点下，您将找到一个类似以下内容的部分：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Your `className` property is a combination of your application identifier and
    the `android:name` attribute in the previous XML. In our case, this `className`
    property is `com.boydlee.nativeapis.NativeapisActvitity`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `className` 属性是您的应用标识符和之前 XML 中的 `android:name` 属性的组合。在我们的例子中，这个 `className`
    属性是 `com.boydlee.nativeapis.NativeapisActvitity`。
- en: 'With these two values written down, open your project''s `app.js` file in your
    IDE and enter in the following code (deleting any existing):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两个值记录下来后，在您的 IDE 中打开项目中的 `app.js` 文件，并输入以下代码（删除任何现有代码）：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When finished, run your application in the Android emulator to test it. Once
    your application has launched you should be able to then exit and pull down the
    Android notification bar to see the results.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，在 Android 模拟器中运行您的应用以进行测试。一旦您的应用启动，您应该可以退出并下拉 Android 通知栏以查看结果。
- en: How it works…
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe we are using intents and activities in conjunction with a notification
    message. The `notification` object itself is relatively simple. It takes in a
    number of parameters including the title and message of the notification, along
    with a badge `number` and `when` parameter (the `datetime` that the notification
    will show, which we have set to the default value 'now'). The `ledARGB` parameter
    is the color to flash on the device LED, which we have set to the device default.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们结合使用意图、活动和通知消息。`notification` 对象本身相对简单。它接受包括通知的标题和消息、徽章 `number` 和
    `when` 参数（通知将显示的 `datetime`，我们将其设置为默认值 'now'）在内的多个参数。`ledARGB` 参数是设备 LED 闪烁的颜色，我们将其设置为设备默认值。
- en: You'll notice that we also added a category to our intent, using the `addCategory`
    method, such as `intent.addCategory(Titanium.Android.CATEGORY_LAUNCHER)`;. In
    our example, we used `CATEGORY_LAUNCHER`, which means that our intent should appear
    in the Launcher as a top-level application.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们还使用 `addCategory` 方法为我们的意图添加了一个类别，例如 `intent.addCategory(Titanium.Android.CATEGORY_LAUNCHER)`；在我们的例子中，我们使用了
    `CATEGORY_LAUNCHER`，这意味着我们的意图应作为顶级应用出现在启动器中。
- en: Coupled with our notification is an object called `pending`. This is our *intent*,
    and that intent has been written in order to launch an *activity*. In our case,
    the activity is to launch our application again. You can also add URL properties
    to intents so that your application can launch specific code on re-entry.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的通知一起的是一个名为`pending`的对象。这是我们**意图**，这个意图已经被编写来启动一个**活动**。在我们的案例中，活动是重新启动我们的应用程序。您还可以向意图添加URL属性，以便您的应用程序可以在重新进入时启动特定的代码。
- en: 'The following screenshot shows an example of our notification message in action:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的通知消息在实际操作中的示例：
- en: '![How it works…](img/3968EXP_08_06.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/3968EXP_08_06.jpg)'
- en: Storing your Android app on the device's SD card
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将您的Android应用程序存储在设备的SD卡上
- en: One of the downsides to Titanium is that, due to its compilation process, applications
    built on the Titanium platform tend to be rather large in file size in comparison
    to a native app. Most simple apps in Titanium will range from between 4-5 megabytes
    in size. This is not really a problem for an iPhone, but unfortunately many Android
    devices utilize SD card memory and do not have much in the way of local phone
    storage space.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Titanium的一个缺点是，由于其编译过程，基于Titanium平台构建的应用程序与原生应用程序相比，文件大小往往较大。在Titanium上大多数简单应用程序的大小在4-5兆字节之间。这对iPhone来说并不是真正的问题，但不幸的是，许多Android设备使用SD卡内存，并且没有太多的本地手机存储空间。
- en: In this recipe, we will show you how to configure your Android application in
    order for it to run on the SD card, via Android's **Move to SD card** button in
    the application settings screen.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将向您展示如何配置您的Android应用程序，以便它可以在SD卡上运行，通过在应用程序设置屏幕中的Android的**移动到SD卡**按钮。
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this recipe can be found in the `/Chapter 8/Recipe
    7` folder.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的完整源代码可以在`/第8章/食谱7`文件夹中找到。
- en: How to do it…
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Open the `tiapp.xml` file under your project''s root directory and find the`<android>`
    node in the XML which will be located near the bottom of the file. Alter the`<android>`
    node so it looks like the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 打开项目根目录下的`tiapp.xml`文件，并找到XML中的`<android>`节点，该节点位于文件底部附近。修改`<android>`节点，使其看起来像以下代码：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now build and run your application on your Android device. Note that this may
    not work in the emulator.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建并运行您的应用程序在您的Android设备上。请注意，这可能在模拟器中不起作用。
- en: How it works…
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: There are a few important parts to understand in relation to this XML configuration.
    The first is that the`<tool-api-level>` node value is actually referring to the
    minimum version of the Android tools required. Version 8 is the minimum needed
    to enable the external storage functionality.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解与这个XML配置相关的几个重要部分时，首先要注意的是`<tool-api-level>`节点值实际上是指所需的Android工具的最小版本。版本8是启用外部存储功能所需的最小版本。
- en: The`<android:installLocation>` attribute refers to the initial storage of the
    application upon installation. Here we are telling the Android OS that we prefer
    it to be stored externally to an SD card. However, if one is unavailable, the
    app will be stored directly to the phone memory. You can also use a value of `internalOnly`,
    which would disallow the app from being installed on external memory.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`<android:installLocation>`属性指的是应用程序安装时的初始存储位置。在这里，我们告诉Android操作系统我们希望它存储在外部SD卡上。然而，如果SD卡不可用，应用程序将直接存储在手机内存中。您还可以使用`internalOnly`值，这将不允许应用程序安装在外部存储上。'
- en: Finally, the`<uses-sdk>` node refers to the version of Android required. Version
    7 in this case refers to Android 2.1 and up, which is required in order to perform
    the **Copy To SD-Card** action.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`<uses-sdk>`节点指的是所需的Android版本。在本例中，版本7指的是Android 2.1及以上版本，这是执行**复制到SD卡**操作所必需的。
