- en: Chapter 8. Introduction to Swift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apple held their **Worldwide Developers Conference** (**WWDC**) for 2014 on
    June 2 at Moscone West in San Francisco, which was the same venue as previous
    years. They announced a slew of new APIs, technologies for games such as Metal,
    new operating systems for iOS (iOS 8) and Mac (Yosemite), and the most important
    announcement for iOS developers in 2014, that is, the announcement of Swift, a
    new programming language, which some say is meant to replace Objective-C, as Objective-C
    was introduced in 1983 and is showing its age due to its long history. Swift is
    meant to be an easy and simple to learn programming language that will lower the
    barrier to entry for developers who are intimidated by Objective-C. However, what
    is Swift and what is good about it? How far does it differ from Objective-C, and
    finally, how easy is it to learn Swift? These are the questions that we will cover
    in this chapter, and to start things off, here is a list of topics we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Welcome to Swift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swift basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Welcome to Swift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swift is actually not a new language, as Apple started the development of Swift
    back in 2010\. Since programming languages such as Ruby, Python, Haskell, Rust,
    and so on have surged in popularity, Swift was developed using language ideas
    from these popular languages. As Apple describes Swift as *Objective-C without
    the C*, you can consider Swift as a language that is a reimagining of Objective-C
    using modern concepts and syntax borrowed from languages such as JavaScript, but
    still keeping the essence and spirit of Objective-C.
  prefs: []
  type: TYPE_NORMAL
- en: Swift does away with pointers and makes memory management opaque to the developer
    through the use of ARC so that they can focus on their iOS application creation
    and not worry about memory management most of the time. Swift uses ARC and not
    the GC method found in Java. This means that Swift can still leak memory if you
    are not careful by using cyclic strong references. Smalltalk is a programming
    language released in 1972 that has heavily influenced Objective-C in terms of
    architecture, such as message passing. And the Smalltalk aspect of Objective-C,
    such as method calls, has been replaced with dot notation and a namespace system
    that is reminiscent of Java and C#. However, Swift is not a totally radical departure
    from Objective-C. Key Objective-C concepts such as protocols, closures, and categories
    are still present in Swift, except that the syntax is much cleaner and crisper.
  prefs: []
  type: TYPE_NORMAL
- en: Swift's approach to memory management is that it uses ARC, and one problem with
    ARC is that a developer can unintentionally create a strong reference cycle where
    instances of two different classes include a reference to the other. So, Swift
    provides the weak and unowned keyboards to prevent strong reference cycles from
    occurring.
  prefs: []
  type: TYPE_NORMAL
- en: For a seasoned Objective-C programmer who comes from a C or C++ background,
    Swift may seem like a totally new language as it does away with some aspects of
    Objective-C such as verbosity. I am sure that a lot of Objective-C developers
    have experienced "square brackets hell", where simple functionalities need to
    be wrapped with a lot of square brackets, thus rendering the code hard to read,
    and which also runs the risk of introducing bugs into your application. The goal
    of Swift is to let developers harness the power of Objective-C without C. So,
    there are some aspects of Swift that indeed make it easier for a developer, but
    conversely, there are some parts of Swift that do not seem to be fully fleshed
    out yet. However, bear in mind that at the time of writing this, Swift is still
    in beta and Apple may still introduce a lot of changes in the following weeks
    and months. However, with Apple putting its full weight behind Swift, now is a
    good time to start learning some Swift basics. As with all new technology that
    Apple introduces, you will require Xcode 6 beta and higher to run and build your
    Swift code as Xcode 5 does not support Swift. Your Swift code can also run on
    iOS 7 and Mac OS 10.9.3\. So, if you are an Apple developer, you can download
    Xcode 6 beta and install it on your Mac as it will be installed side by side with
    your Xcode 5 and will not override anything or break your current Xcode projects.
    So, let's get cracking.
  prefs: []
  type: TYPE_NORMAL
- en: Basics of Swift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swift syntax is very different to Objective-C, while Objective-C has a lot of
    reliance on C and C++ components such as pointers, strong typing, and so on. Swift
    is very similar to popular scripting languages such as Python and Ruby with regards
    to terseness and variable declaration. So, let's look at some basics of Swift
    to get acquainted with it.
  prefs: []
  type: TYPE_NORMAL
- en: Variable declaration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Swift does away with the need to remember ints, floats, NSStrings, and so on
    and consolidates all of these type of variables under one type, and that is of
    the type `var`. If you are familiar with JavaScript, then the `var` keyword should
    not be unfamiliar to you. Swift supports the type inference, where depending on
    the value that you assign to a variable, it will infer its type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the variable, `welcome`, is inferred to have a string type
    as I assigned the text `Hello world` to it. However, if you want to be specific,
    you can annotate a variable like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then to append two strings together in Swift, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were using Objective-C, you will need to type out the longer syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Swift also supports constants with the keyword `let`. So, to declare a constant,
    you can just type the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that Swift now infers that `LIFE_MEANING` is an integer as you have assigned
    the value `42` to it. To print out a line of text for logging, which is analogous
    to NSLog from Apple's Cocoa framework, you can use the `println` keyword, whereas
    with NSLog, you need to specify the format specifier such as `%d` for integers,
    `%@` for NSStrings, or `%f` for float/double.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no need to do this for Swift; you can just use the following syntactical
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: One thing that has not changed from Objective-C is that comments in Swift are
    denoted by the `//` for single line comments and `/*` and `*/` for multiline comments.
  prefs: []
  type: TYPE_NORMAL
- en: Semicolons are also optional. Some of you may want to be pedantic and put a
    semicolon, but personally, I don't like any additional typing than is necessary,
    so I tend to omit the semicolon (;) for my Swift code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Variable declaration](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As with all programming languages, Swift supports an array of operators for
    arithmetic comparison and assignment.
  prefs: []
  type: TYPE_NORMAL
- en: All the operators such as `/`, `*`, `+`, and so on perform the same function
    as in Objective-C except that the `+` operator serves a dual function as a string
    concatenation operator if you need to concatenate multiple strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift introduces the concept of closed range operators, which defines a range
    that runs from *x* to *y* and includes the values *x* and *y* if you use it like
    this (*x...y*). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print out the values **1**, **2**, **3**, **4**, and **5**. As you
    may have noticed by now, this can be used to replace the more verbose tradition
    for loop in Objective-C, which is represented by these lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'However, what if you want to do some common `for` loop code to loop through
    an array? Then, you will need a half-closed range operator, which is similar to
    a closed range operator except that there is one dot less (*x..y*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you have seen earlier, Swift also has support for collection types such
    as arrays as shown earlier and dictionaries, which we will cover in the next few
    pages. To start off declaring an array, you just use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, there are some properties that can come in handy, among others, such
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`count`: This returns the number of items in the array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isEmpty`: This is a Boolean variable that returns true if the count property
    is `0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`append`: This property will allow you to add an item to the end of an array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Swift provides some helper code to iterating over an array instead of using
    a `for` loop, `while` loop, or `do-while` loop. Array iteration is easier in Swift
    as you just need to do this to do the iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: No longer do you need to write any verbose and unnecessary code for a `for`,
    `while`, or `do-while` loop as you can use the item variable to access the array.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will cover dictionary. The dictionary in Swift is similar to `NSDictionary`
    in Cocoa, in terms of functionality and usage. However, there is a major difference
    in that, whereas in `NSDictionary` and `NSMutableDictionary`, you are allowed
    to use any object as the key and value, which does not provide any information
    about the object nature. In Swift, the type of keys and values in a dictionary
    are always made explicitly clear using explicit type annotation or via type inference.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for a dictionary in Swift is quite straightforward, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code uses explicit type notation as you can see that the key
    and value are explicitly defined as `String` and `String` respectively. This is
    very similar to how you declare dictionaries in Javascript or Maps in Java, by
    running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses type inference where once we assign `Breed1` to the
    key and `Bull Dog` to the value, Swift automatically infers that our dictionary
    will hold two strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modifying a dictionary in Swift is similar to how you access an array except
    that instead of using an index, you use the key, which in our case is a String.
    So, if you want to modify the value that maps to the `Breed1` key, you can do
    it as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, Swift allows us to update a value another way, which is the
    `updateValue` method as demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Both ways will allow you to update a value using the key, but I prefer the first
    way as it is less verbose, yet equally easy to read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Iteration over a dictionary is similar to the iteration of an array in Swift
    where we can forgo the old Objective-C `for`, `while`, or `do-while` loop methods.
    To do a dictionary iteration in Swift, we just use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In any general purpose programming language, control flow statements are a necessity
    in order to control the flow of your code and your app. So, although Swift is
    a big departure from Objective-C, it still allows for control flow constructs
    of C-like languages such as C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of control flow constructs available for you to use in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: The `for` loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `for-in` loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `while` loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `do-while` loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `if` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `switch` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These control flow statements serve the same purpose as they will in Objective-C,
    but there are a few improvements to them, which I will explain briefly.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For statements that iterate over and over again, such as `for` loops, Swift
    emphasizes the `for-in` loop for iteration. This is also known as an enhanced
    for loop in other programming languages such as Java. This improves readability
    and adds terseness to your code. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you have the need for a Objective-C traditional style `for` loop,
    you can do it with Swift, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Conditional statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If statements behave the same way as they do in Objective-C, except for a minor
    change of syntax as shown here. Do note that the brackets are optional, so we
    did not put it around the conditional expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in the preceding example, we have a very simple condition, so we
    have opted to eliminate our brackets. However, what if you have multiple conditions?
    Then, Swift will use the normal rules of precedence that you are familiar with,
    but the lack of brackets can make the operations hard to understand. So, in this
    case, I would prefer to use brackets for multiple conditions and operations like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in Swift, Switch statements have now been made easier for debugging
    by not having to fall through the next case. So now the entire switch statement
    finishes its execution as soon as the first matching switch case is completed.
    So, the following statement will show the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The output will be `"Number is 2"` in Swift instead of `"Number is 1"` and `"Number
    is 3"`, which you will see in Objective-C.
  prefs: []
  type: TYPE_NORMAL
- en: Control flows in Swift have been made better where the syntax has been improved
    to add readability and to prevent developers from creating non-obvious bugs such
    as a Switch case fallthrough due to a missing `break` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functions are the fundamental building blocks of every programming language,
    and it is also the same in Swift, but there are some improvements made, which
    we will go through now. The syntax for a function has changed quite a bit, so
    a function in Swift now has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'So, you can call it using `println(animalType("Dog"))`. If the function does
    not have a return value, you can avoid adding the arrow (`->`) like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Functions in Swift can now have multiple return values as part of a compound
    return value where you can use a tuple return type.
  prefs: []
  type: TYPE_NORMAL
- en: 'A tuple type is just a fancy term for a comma separated list of zero or types,
    which are enclosed in a parenthesis. So, to let a function have multiple return
    values, a tuple is what you need as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then to use the return value, you need to assign it to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Swift allows the default values in a function where a default value is used
    if a function parameter is not used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'So, in the preceding example, `num2` will have a default value of 0 if you
    do not pass in a parameter for the second parameter in the add function, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Swift functions also allow the function to accept a variable number of arguments,
    which is useful when you need to pass in a varying number of parameters to a function.
    To enable a function to accept a varying number of parameters, you just need to
    add three full stops (`...`) in your function, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'So, you can call the `getAverage` function using a varying number of parameters
    such as `getAverage(1, 2, 3)` or `getAverage(1, 2, 3, 4, 5)`. By default, Swift
    makes all function parameters as constant to promote good programming practice.
    This is one of the more unique features of Swift, which you do not find in other
    procedural programming languages such as C++, Objective-C, and so on. So trying
    to modify a function parameter will result in an error. However, if you need to
    modify a function parameter in your code, you just need to add the `var` keyword
    to tell Swift to treat that function parameter as a variable, not as a constant,
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the important changes that functions in Swift, different from Objective-C,
    is that you can have nested functions where a function is created inside another
    function. But do note that the inner function is only available to the enclosing
    function. To declare a nested function, you can just use a normal function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Classes and structures in Swift
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you know, classes and structures are general purpose data structures that
    form the building block of the code of your application. You can define properties
    and methods to add functionality to these classes and structures using the same
    syntax as you will for the variables, functions, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Classes and structures in Swift have many common points such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining properties to store values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining methods to provide added functionalities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to be extended to expand their functionalities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The possibility to conform to protocols to provide standard functionalities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, classes have other differences that structures do not possess; they
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance to allow a subclass to inherit the characteristic of another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type casting, which allows you to check and interpret the type of a class instance
    during runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference counting, which allows more than one reference to a class instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deinitializers, which allow a class to do resource freeing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structures are copied when they are passed around in your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To declare a class or structure, use the `class` and `struct` keyword respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As in Objective-C, to use a `struct` or `class`, you need to create an instance
    of it before you can use it. So, for `struct` and `class`, you need to use the
    `()` to create an instance of a `class` or `struct`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To access a property in a `class` or `struct`, you can use the "`.`" operator
    to access it, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'For classes, you can define your own custom initializer and deinitializer in
    your class file. Initializers for your struct members are automatically created
    for you, which you can use, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Generally, you do not need to do any manual cleanup of your allocated instances
    as Swift will do it for you using ARC. However, if you are using some custom resources,
    then you may need to do the additional cleanup yourself. One use case will be
    when you have a class that opens a text file and writes or appends some data to
    it. So, in this situation, you may need to close the file before your instance
    is deallocated. An example syntax of deinitialization is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: One of the most important differences between a Swift class and Swift struct
    is that Swift classes are passed by reference, which means that a reference to
    the existing class instance is created when you assign it to another instance,
    and any change to the new instance will affect the original instance. This is
    in contrast with pass by value where a copy of the value is passed to the variable
    so that what happens in the new variable will not affect the original variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, depending on this difference, sometimes using a class is more useful in
    some situations while in other situations using a struct would be better. It all
    depends on the context of your program or application. So, let''s use some code
    to help us understand this better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If you use the following code, you will notice that the `classA` member `x`
    will also be set to the value of `100` as a reference to `classA` is passed when
    you run the code `classB = classA`. So, whatever affects `classB` will also affect
    `classA`.
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Closures in Swift are known as blocks in Objective-C. Both have the same concept
    of creating self-contained blocks of code that can be passed around and used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Closures use `{` and `}` to denote the beginning and end respectively. So,
    a very simple example of creating a closure and calling it would be something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You can see the output **Hello Gibson** appearing in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you will need to pass in arguments and get return values from your
    closures. You also need to use `(` and `)` to enclose your arguments and `->`
    to denote your return values as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the code, you will get the output **Howdy Gibby** because I passed
    in two string variables of the names `s1` and `name` respectively as you can see
    from the line `(s1: String, name: String)`, while I ask a return value of the
    type string using `-> String`.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's move on to memory management in Swift, which you still need to take
    note of as ARC frees you from a lot of memory management techniques, but you still
    need to take note of some memory management techniques in Swift as Swift can still
    leak memory if you are not careful.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management in Swift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swift was created to avoid some of the downsides of C, one of which being memory
    management. Notice that nowhere in this chapter did I mention anything about pointers,
    memory allocation, deallocation, and so on. This is because in Swift, memory management
    is made to be as painless as possible so that you, the developer, can focus more
    on your application development than on debugging memory leaks. Every time a new
    instance of a class is created, ARC will allocate a chunk of the memory to be
    used to store information about that instance. This chunk of memory holds information
    such as the instance type (string, integer, and so on) along with the values of
    the properties that are associated with that instance. ARC will free up the memory
    used by that instance when it is no longer needed or referenced. This is to avoid
    a situation where instances still occupy precious memory space when they are no
    longer being used or needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you try to access an instance''s properties or methods after ARC
    has deallocated it, then a crash will be the likely result that you will see.
    So, to make sure that this does not happen to you, ARC will track how many properties,
    variables, and constants are currently referencing a class instance, and ARC will
    not allow deallocation as long as there is at least one active reference to that
    instance from another object in your code somewhere. A strong reference is created
    when you assign a class instance to a property, constant, or variable, and this
    strong reference keeps a strong hold on that class instance, and ARC will not
    make a deallocation call as long as that strong reference remains. Let''s illustrate
    this with some code to understand this further:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s declare a class called `Dog`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will create two references to the `Dog` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that there is a `?` keyword, which means that `dog1` is of an optional
    type, which means that it could be nil. In Swift, any variable with a `?` keyword
    means that there is a possibility that it can hold a nil value. Since we declared
    `dog1` and `dog2` as an optional type, it means that `dog1` and `dog2` are initialized
    with a value of nil and do not have a reference to the `Dog` class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we will create an instance and assign two variables, `dog1` and `dog2`
    respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So, now there are two strong references to the `Dog` instance. One is through
    `dog1` and the other is from `dog2` to `dog1`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'One thing to note about Swift is that the type inference only works for the
    initial assignment; assigning another type to the same variable will throw an
    error. This is quite different from other languages such as JavaScript, where
    no error will be thrown. Let me illustrate what I mean with an example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So, you can try assigning `dog1` to nil, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'ARC will see that `dog2` still holds a strong reference and will not deallocate
    the `Dog` instance. The only time that the `Dog` instance will be deallocated
    will be when `dog2` is set to nil as shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Conversely, Swift also supports weak references where the reference does not
    have a strong reference onto the instance that it references. So, ARC will dispose
    of an instance even if it has a weak reference. To create a weak reference, you
    need to use the `weak` keyword as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `?` keyword is added at the end of the `String` keyword as a
    weak reference can be allowed to have a value of nil, so all weak references must
    be declared as optional using the `?` keyword. Notice that it is also declared
    as a variable as weak references will have their values changed in the code during
    runtime. So, a weak reference cannot be declared as a constant as a weak reference
    does not have a strong hold on the instance it refers to. So, when this instance
    is going to be deallocated while the weak reference is still referring to it,
    ARC will set the weak reference to nil when that situation arises and you can
    check the value of a weak reference to see if that object has been deallocated.
    This way you can avoid a situation where you end up with a reference to an invalid
    instance that has already been deallocated by ARC.
  prefs: []
  type: TYPE_NORMAL
- en: 'In between strong and weak references, there is another type of reference that
    keeps a weak hold on an instance it refers to, but it cannot be set to nil, so
    it is always assumed to have a value. This is known as an unowned reference. It
    can be used as a replacement for a weak reference and for some use cases as we
    will see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we initialize `City` within the initializer method for `Country`,
    but we also need to initialize `Country` within the initializer method of `City`,
    and this presents itself as a conundrum since `Country` depends on the initializer
    of `City` and `City` depends on the initializer of `Country`. To get a solution
    to this, you can declare the `capital` variable of `Country` as an implicit unwrapped
    optional property, which you denote by using `!`. This means that the `capital`
    property will have a default value as nil.
  prefs: []
  type: TYPE_NORMAL
- en: The `!` keyword also serves as a unwrapping function where you can get the value
    of the property without assigning that property to a local variable. As mentioned
    earlier, a variable that is denoted with the optional symbol, which is a `?` keyword,
    can either contain a value or nothing. So, when you are testing against this variable
    of the type denoted as optional, you need to know whether there is a value without
    directly accessing the underlying value. The `!` keyword means that you can unwrap
    the variable to get access to the value.
  prefs: []
  type: TYPE_NORMAL
- en: However, this does not absolve you from checking whether that property is nil
    as you still need to check for nil in your code.
  prefs: []
  type: TYPE_NORMAL
- en: So, now what happens is that `capital` has a default nil value and the `Country`
    instanced is considered as fully initialized as soon as the `Country` instance
    sets its `name` property within its own initializer method. This means that the
    `Country` initializer method can start to reference and pass around its `self`
    property as soon as the `name` property is set. So now the `Country` initializer
    can therefore pass the `self` property as one of the parameters for the `City`
    initializer when the `Country` initializer is setting its own `city` property.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, Swift is a big departure in terms of syntax, style, and paradigm
    from Objective-C. Swift was developed to move away from the C paradigm of programming
    where we need to wrap our heads around memory management, allocation, and deallocation.
    We went through some of the basic features of Swift and noted that Swift features
    more terse code, has made memory management, and is also fuss free, since ARC
    takes care of memory management for us in Swift. However, Swift is still in the
    beta stage at the time of this writing, so it can still be subject to changes
    in its journey to alpha and release status. Therefore, you can expect that some
    features will be added or removed during this period. However, the fundamentals
    of Swift will not be changed significantly, and I hope that this chapter has given
    you a better understanding of Swift and has prepared you for programming in Swift
    in the near future.
  prefs: []
  type: TYPE_NORMAL
- en: To find out more information about Swift, the best resource to refer to is Apple's
    website on Swift programming at [https://developer.apple.com/swift/blog/](https://developer.apple.com/swift/blog/)
    as it has been updated constantly since Swift was announced.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at memory management techniques using some
    of the excellent tools in Xcode, such as Static Analyzer, and we will also cover
    more details on the various techniques so that you will know which debugging tool
    is the best tool to use in different situations.
  prefs: []
  type: TYPE_NORMAL
