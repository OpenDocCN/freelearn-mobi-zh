- en: Chapter 3. Structural Patterns – Composite and Flyweight
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already seen three structural patterns: the decorator, proxy, and bridge
    patterns that provide us with ways of adding state and behavior dynamically, controlling
    the creation and access of objects, and keeping specifications and implementations
    separate. This chapter will now focus on the composite and flyweight patterns
    that are designed to facilitate the manipulation of a group of objects or large
    number of small objects. The composite is often used and we can also make use
    of the flyweight pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: The flyweight pattern efficiently shares the common information present in small
    objects by helping you reduce the memory consumption or storage requirements when
    many values are duplicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The composite pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The flyweight pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The objectives of these two new structural patterns are described in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pattern | Objective |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| The composite pattern | This pattern allows you to compose objects into tree
    structures and treat the group of objects as an instance of an object. |'
  prefs: []
  type: TYPE_TB
- en: '| The flyweight pattern | This pattern allows you to manage huge number of
    objects by instantiating them on the fly to improve the performance efficiently.
    |'
  prefs: []
  type: TYPE_TB
- en: The composite pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This pattern is very often used to manipulate a group of objects. Swift, like
    many other languages already makes use of the composite pattern in its internal
    structure. For example, in the case of the `UIView` class available in the `cocoa`
    framework, which defines a common behavior of an app layout. Then, individuals
    view objects in the view hierarchy can be leaf nodes (such as labels) or composites
    that have collections of other views (such as table view controllers).
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This pattern permits you to treat single components and a group of components
    in the same way by providing a structured hierarchy of objects. It allows you
    to build structures of objects in the form of trees that contain both compositions
    of objects and individual objects as nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Using this pattern, we can create complex trees and treat them as a whole or
    as parts. Operations can be applied to the whole or the parts too.
  prefs: []
  type: TYPE_NORMAL
- en: We generally find the `add`, `remove`, `display`, `find`, and `group` operations
    in the `Composite` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern can be used when:'
  prefs: []
  type: TYPE_NORMAL
- en: It is necessary to have a composition hierarchy in a system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clients need to be ignored if they are working with composites objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The generic UML class diagram is represented in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Design](img/4852_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The participants of this pattern are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Component`: This is an abstract class that introduces an object''s interface
    of the composition, implements common methods, and defines the method signature
    that manages the addition or deletion of components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Leaf`: This is a concrete class that defines the behavior of the elements
    in the composition. It implements the operations that the `Composite` class supports.
    A `Leaf` class does not have its own components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Composite`: This is a concrete class that defines the behavior of the components
    that have children and store the child components. It implements the `Leaf` class-related
    operations. This class has an aggregation of the `Component` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Client`: This class uses the component''s interface to manipulate the objects
    in the composition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Composite` contains components. Components can be `Leaf` or `Composite`. It
    is indeed recursive. A composite holds a set of children; these children may be
    other composites or leaf elements.'
  prefs: []
  type: TYPE_NORMAL
- en: Collaboration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A client sends a request to the leaf throughout the `Component` interface.
  prefs: []
  type: TYPE_NORMAL
- en: When a component receives a request, it reacts depending on its class. If the
    component is a leaf, then it will treat the request itself.
  prefs: []
  type: TYPE_NORMAL
- en: If the component is a composite, it will first treat on itself, then it will
    send a message to each of its child, which in turn will execute a treatment too.
    Then, when every child completes their treatment, the composite will execute the
    last treatment.
  prefs: []
  type: TYPE_NORMAL
- en: Illustration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our company has an online catalog of **Video on demand** (**VOD**). All our
    movies are categorized by genre. As this is a pay-per-view system, each of our
    videos will have a price, name, and small description.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we want to easily manipulate the display of our full catalog using this
    new pattern. The following schema represents the organization of our catalog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Illustration](img/4852_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, it''s time for us to apply the generic design of the composite pattern
    to our case. First, we will redesign our pattern according to our scenario in
    order to understand what we need to do, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](img/4852_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `VODManager` class will use the `VODComponent` interface to access the VOD
    categories and VOD items. The `VODComponent` class is our abstract class that
    will provide the default implementation of the defined methods. The `VODItem`
    class will only override the methods that make sense. The `VODCategory` class
    will also override methods that make sense, including a way to add the new `VODItem`
    and `VODCategory` objects. After reorganizing our pattern, we are now ready to
    implement our solution.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of the VODComponent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we create our abstract class, which both `VODItem` and `VODCategory`
    will inherit form. This class will provide the interface for the leaf nodes and
    composite nodes. Swift doesn''t support an abstract class; nevertheless, nothing
    should prevent us from implementing the default behavior onto our methods, such
    as informing that a method is not supported using an **assert**. An assert will
    just inform us that if it is used in an inappropriate class, then the method will
    not be supported. We could write our "fake" abstract class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Implementation of the VODItem leaf
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our component class is ready; a default behavior is available for each method.
    We can now implement our `VODItem` class. It is a leaf class in the composite
    diagram and implements the behavior of the elements of the composite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: See how I have defined the private variables with `!`. This means that the values
    of these variables cannot be nil after initialization. This is true because we
    added a constructor (the `init` method) where all our arguments must be passed
    to initialize our private fields.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we override only methods that interest us. The `Add`/`Remove` and `GetChild`
    methods don't need to be overridden here; this will be done in the composite class.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure that each name, description, and price has a value, we added an exclamation
    mark to unwrap it.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is now time to implement our composite category class. We will call this
    composite class: `VODCategory`. It will hold `VODItems` or `VODCategory`. You''ll
    see that again we will override only methods that interest us in this class. The
    `getPrice()` method will not interest us as it doesn''t make sense.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of the VODCategory composite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first shot of the `VodCategory` class could be written as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Well, as with `VODComponent`, we override the methods that interest us. As we
    can have any number of `VODComponent`, we add an array of type `VODComponent`
    to hold them.
  prefs: []
  type: TYPE_NORMAL
- en: We added the `Add`, `Remove`, and `GetChild` methods. The `Add` method will
    allow us to add an item, category, or subcategory. We can also remove it and return
    a `VODComponent` class based on its index.
  prefs: []
  type: TYPE_NORMAL
- en: Again, we can add a name and description to our composite that will be displayed
    when the `display()` method will be invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you write it like the preceding code, you'll get an error because Swift doesn't
    provide a `remove` method for the `Array` type.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to make some modifications in our implementation and introduce you
    to the use of extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Our problem is that we want to be able to remove an object of the type `VODComponent`
    to our `vodComponents` array using a method called `remove` (or anything else),
    where we pass an object that represents the object we want to remove from the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we check the available method when the auto-completion is displayed, we
    do not see any method that can help us in this purpose, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation of the VODCategory composite](img/4852_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 2](ch02.html "Chapter 2. Structural Patterns – Decorator, Proxy,
    and Bridge"), *Structural Patterns – Decorator, Proxy, and Bridge,* you could
    have used the decorator pattern to add such methods to the `Array` type; you can
    also propose to simply add a method to the class that will test all the elements
    in the array by comparing them one by one, and if they are identical, remove them
    from the list.
  prefs: []
  type: TYPE_NORMAL
- en: What we want is something that can be reused and generic. For this, Swift has
    `extension`. This permits you to add a behavior to a class very easily. Let's
    do it by adding a `remove` method to the type `Array`.
  prefs: []
  type: TYPE_NORMAL
- en: The extension must not be added to a class. Indeed, extensions are global. If
    you add extensions to an OS X or iOS project, you'll generally add them to a dedicated
    Swift file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As this function modifies the instance of the `Array` type and its properties,
    we mark this function as mutating. Then, we start from the end of the list and
    compare the elements that we want to find in the current elements of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, here there are some tricky things to do to make this code without any
    error. This function tells that we want that `Array` of type `T` must implement
    `Equatable` (is said with `remove <T: Equatable>` ) to be able to make the comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, we need to modify our abstract class, telling that our class implements
    the `Equatable` protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Of course, adding this protocol modifies our class diagram a little, but no
    matter. By implementing this protocol we are telling that elements of type `VODComponent`
    can be compared using `==` and `!=`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this is not completed, then we need to implement this protocol, so the best
    way to do this is by making a global function outside any class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `===` operator tells us whether the instances of the two components are
    identical or not.
  prefs: []
  type: TYPE_NORMAL
- en: So, now, all the code required for this class is written; the `remove` method
    is available and works perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: Some improvements need to be added to our class to fully complete the implementation
    of the composite.
  prefs: []
  type: TYPE_NORMAL
- en: Have you seen how we implemented the `display` method in our composite (`VODCategory`)
    ? Indeed, the `display()` method of the composite only displays the information
    about itself, but it must invoke the `display()` method of each element that is
    contained in the composite. To do this, we will simply add a small part of the
    code that will iterate all elements that the composite contains in its array by
    adding a call to their respective `display()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change the `display()` method of the `VODCategory` class to add an iteration
    to all our elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So, we iterate over each element of the array using `for … in` and call the
    `display()` method of each element.
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All our classes are now ready and it's time to see how we can use this pattern
    in our client to test all of this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first prepare our `VODManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we write our test code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We need to prepare all our components. So, first, we prepare our tree category
    and then we add items to the good category.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the script, we call the `vodManager.displayCatalog()` method that
    will invoke the `display` method of all the components.
  prefs: []
  type: TYPE_NORMAL
- en: So, why don't we see something interesting in Playground? In fact, we have some
    clues that tell us that the code has been properly executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the right-hand side of the screen, we can see the number of times a method
    has been called, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Usage](img/4852_03_05.jpg)![Usage](img/4852_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'However, we will modify this a little bit to get something more accurate for
    our test. We will modify each `display()` method by adding the string `return`
    type and replace the `print` statement with a `return` statement that contains
    the string to be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You need to change the `display()` method of the `VODComponent`, `VODItem`,
    and `VODCategory` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `VODCategory`, you need to modify it like the following code so that it
    is easily readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'For `VODManager`, you need to simply add the return type and replace `print`
    with `return`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, move the `tvSeriesCategory.add(voSTTvSeries)` line in the *Usage*
    section (marked with a comment : // USAGE) of the Playground file ( just before
    the `vodManager.display()`line; this will make our result easier to read.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you will see something on the right-hand side just after the `vodManager.display()`
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Usage](img/4852_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the Eye icon on the right-hand side of the screen. You''ll see the
    result of our `vodManager.display()` invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Usage](img/4852_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the `display()` method of the composite or leaf is called recursively.
    The items are organized depending on the categories that we have added them to.
    In the preceding screenshot, we can see that after `Horror VODCategory` is called,
    all horror movies (`VODItem`) that we defined are displayed, then it continues
    with the TV series that also contain a `VOST TV Series` subcategory, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discovery of the composite pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The flyweight pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This pattern can be used when the system needs to deal with a large number of
    similar objects. Instead of creating each element one by one, this pattern permits
    you to reuse an object that shares the same data.
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The flyweight pattern is used to reduce the memory and resource usage of complex
    models that contain many hundreds and thousands of similar objects by reducing
    the number of objects created. It tries to reuse similar existing objects or creates
    a new one when no match is found.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern can be used when:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to manipulate a lot of small similar objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cost (the memory/execution time) of this manipulation is high
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following class diagram represents the generic structure of the pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Design](img/4852_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three participants to the flyweight pattern, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Flyweight`: This declares an interface that contains an intrinsic state and
    implements methods. These methods can receive and act on the extrinsic state of
    the flyweights.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FlyweightFactory`: This factory creates and manages a flyweight''s objects.
    It assures that the flyweight is shared, thanks to the method that it returns
    a reference to the flyweight.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Client`: This contains references to the used flyweight. It also contains
    the extrinsic state of these flyweights.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The extrinsic state**: This is the state that belongs to the context of the
    object (external) or unique to that instance.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The intrinsic state**: This is the state that belongs to the flyweight object
    and should be permanent or immutable (internal).'
  prefs: []
  type: TYPE_NORMAL
- en: Collaboration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clients do not create the flyweight by themselves, but they use the `FlyweightFactory`
    method that guarantees the sharing of flyweights.
  prefs: []
  type: TYPE_NORMAL
- en: When a client invokes a method of a flyweight, it needs to send its extrinsic
    state.
  prefs: []
  type: TYPE_NORMAL
- en: Illustration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose that we want to display 200000 rectangles on a 1024 x 768 screen. These
    rectangles are generated randomly; they can have a random color from a list of
    10 different colors.
  prefs: []
  type: TYPE_NORMAL
- en: We need to reduce the time taken to execute the function and use as less memory
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we will use an `XCTest` project with the `XCTest` framework
    and instrument tool to illustrate how this pattern will help us reduce the memory
    consumption.
  prefs: []
  type: TYPE_NORMAL
- en: First, open the project called `Flyweight Pattern_Demo1` that you will find
    in the source code folder of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the Xcode project named `FlyweightPattern_Demo1Tests` and click on the
    `FlyweightPattern_Demo1Tests.swift` file, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](img/4852_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this file, you'll see the different test methods that are already implemented.
    Before starting with the implementation of our flyweight pattern, let's see what
    we currently have.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already have an abstract class called `AbstractPerfTest` that contains some
    already defined properties, fields, and methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'There is another class called `NoPattern` that inherits from this abstract
    class and overrides the run method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `SimpleRect` class is defined in the `SimpleRect.swift` file of the `NoPattern`
    group folder. It is an object defined by a color, *x* and *y* position, width,
    and height.
  prefs: []
  type: TYPE_NORMAL
- en: I will not comment too much on the `NoPattern` class, but what we see here is
    that the `run` method of the `NoPattern` class generates `NUMBER_TO_GENERATE`
    (set to `100000` by default in the `FlyweightPattern_Demo1Tests.swift` file) rectangles
    with a random color taken from the list of the colors array (defined in the abstract
    class). It then generates a position and dimension for each of these rectangles.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's check the performance of the `run` method.
  prefs: []
  type: TYPE_NORMAL
- en: Come back to the `FlyweightPattern_Demo1Tests.swift` file and check the method
    named `testSimpleScreenFilling_noFlyWeight()`. Here, the method will execute the
    code implemented in the `NoPattern` class that, like the name of the method tells
    us, does not implement the flyweight pattern. The execution time of this method
    will be used as a baseline to compare the same method but with the implementation
    of the flyweight pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s execute the test by clicking on the small icon on the left-hand
    side of the `func testSimpleScreenFilling_noFlyWeight()` function, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](img/4852_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to ensure that the console is visible in Xcode. While executing, you''ll
    see that the console log with **200000 rects generated** has been repeated 10
    times. This proves that our code has generated 2,00,000 rectangles 10 times. By
    default, the `self.measureBlock` closure is executed 10 times, and it calculates
    the standard deviation of these 10 executions to obtain an average execution time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](img/4852_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'On my MacBook Pro 15 Retina Late 2013, the average time is **0.804** seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](img/4852_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, the best part is to refactor our code to reduce the time taken to generate
    these 2,00,000 rectangles. As you have already seen in the generic structure of
    the pattern, we will need a few classes to manage our flyweights.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with our `flyweightRect` class. Note that the `flyweightRect` and
    `SimpleRect` classes are used in the `NoPattern` class to generate rectangles
    that are identical.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, in the following code, you'll find our `FlyweightRect` class with
    the definition of our rectangle. So, we have a color, *x* and *y* position, height,
    and width of the rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that because I really want to see the gain in performance, I added two
    fields: `image` and `sprite`. Because the value of these fields have a cost in
    terms of performance on the instantiation of the class, I added them to show you
    clearly that the flyweight pattern permits you to reduce the calculation costs
    (and memory usage) when applied.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add a constructor to the intrinsic state as an argument: this will
    be the color. We will add another `display()`method that will receive extrinsic
    states as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once our flyweight is defined, we can now prepare our `FlyweightFactory` object.
    Remember that this factory will first check if we already have a rectangle that
    is similar to the new one that we want to position on the screen; if it is not
    similar, then it will create a new one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We declare a static `rectsMap` variable of the type `Dictionary` that will contain
    our shared objects and manage their existence. The dictionary `Key` will contain
    a `Color` object.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we define a static method called `getFlyweightRect` that will return a
    `FlyweightRect` class.
  prefs: []
  type: TYPE_NORMAL
- en: As `rectMaps[color]` returns `nil`, we unwrap the optional with a `if let` statement.
    If it is not `nil`, we return the result; otherwise, we create a new flyweight
    with the appropriate color, add it to our dictionary, and return the result.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the `FlyweightPattern_Demo1.swift` file, you'll find several test methods
    that test the response time of the factory depending on the type of the object
    that manages our flyweights. In the project, I tested the performance of the object
    that manages our flyweights using the `Dictionary<SKColor, FlyweightRect>`, `NSMutableDictionary`,
    and `NSCache` types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete code of the `FlyweightRectFactory.swift` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using our pattern is extremely easy. You need to check the `run()` method of
    the `WithPattern.swift` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We will simply make a loop to create 200000 `FlyweightRect` objects (`NUMBER_TO_GENERATE`
    is a constant defined at the top of the `FlyweightPattern_Demo1Tests.swift` file).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `WithPattern` class written in the preceding does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We first generate a random number that returns a value that will correspond
    to the index of a color available in the colors array (defined in the `AbstractPerfTest.swift`
    file).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we tell the factory to return a flyweight with the appropriate color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we generate the extrinsic state (*x* position, *y* position, width, and
    height).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the loop is complete, we display the number of generated rectangles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Performance results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To check the performance, there is an `XCTest` class available in the project
    with the `self.measureblock` closure that allows us to measure the performance
    of our block.
  prefs: []
  type: TYPE_NORMAL
- en: 'To launch all the tests available in the project, click on the **Show the Test
    navigator** button on the left-hand side, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Performance results](img/4852_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, click on the play button that is visible on the right-hand side of the
    highlighted line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Performance results](img/4852_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After a few seconds, all the tests would have been run and you can now check
    your performance results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Come back to the `FlyweightPattern_Demo1Tests.swift` file and check the end
    of each `measureblock()` method. This is the result with the flyweight pattern
    using a dictionary. You can see that it took an average of 0.247 seconds to generate
    200000 rectangles, as shown in the following screenshot. You''ll see a text with
    `Time xxxx` written; this is the average time taken to execute this block:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Performance results](img/4852_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As compared to an average of **0.877** seconds without using the pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Performance results](img/4852_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After reviewing the results, you''ll see that generating rectangles are better
    when (best performance first):'
  prefs: []
  type: TYPE_NORMAL
- en: The flyweight pattern with a `Dictionary` object is used to manage our shared
    objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The flyweight pattern with a `NSDictionary` object is used to manage our shared
    objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The flyweight pattern with a `NSCache` object is used to manage our shared objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No pattern is applied
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, we can say that generating 200000 `FlyweightRect` objects is
    3,55 times faster than without using the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The test project proves that Swift is faster than Objective-C and `NSCache,`
    which are encapsulated.
  prefs: []
  type: TYPE_NORMAL
- en: The `NSDictionary` object will have its own logic while handling the cache.
    It can create more objects inside its own hidden code structure, so it's slower
    than the `NSDictionary` object.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to deal with structures of multiple objects.
    The composite pattern allows you to access and alter data structures in a uniform
    way, whereas the flyweight pattern is a more accurate way to save the memory space
    or time spent in calculation when they are multiple similar objects.
  prefs: []
  type: TYPE_NORMAL
- en: A flyweight pattern is useful with other patterns to keep data as small as possible.
    The composite pattern is useful in combination with other patterns to manage the
    data structure. The composite pattern can use a flyweight pattern, but the inverse
    will not.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I tried to present you with something different; using the
    `XCTest` framework, to test the performance of our pattern. If you want to dive
    deeper, you can try to see the difference in the memory allocation using the instrument
    tools provided in Xcode.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue with the discovery of our structural patterns
    by learning what the adapter and facade patterns are.
  prefs: []
  type: TYPE_NORMAL
