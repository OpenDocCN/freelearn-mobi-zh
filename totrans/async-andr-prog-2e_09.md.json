["```java\npublic class MyNativeActivity extends Activity {\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    ...\n    cTv.setText(isPrime(2) ? \"true\" : \"false\");\n  }\n  …\n  private native boolean isPrime(int number );\n}\n```", "```java\njavah  -d jni -classpath <sdk_direcory>/android.jar:../../build/intermediates/classes/debug/  com.packpublishing.asynchronousandroid.chapter9.MyNativeActivity\n```", "```java\nJNIEXPORT jboolean JNICALL Java_com_packpublishing_asynchronousandroid_chapter9_MyNativeActivity_isPrime\n  (JNIEnv *, jobject, jint);\n```", "```java\n#include \"com_packpublishing_asynchronousandroid_chapter9_MyNativeActivity.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\njboolean  Java_com_packpublishing_asynchronousandroid_chapter9_MyNativeActivity_isPrime( JNIEnv *env, jobject obj, jint number) {\n    int c;\n    for (c = 2; c < number ; c++) {\n        if (number % c == 0)\n            return JNI_FALSE;\n    }\n    return JNI_TRUE;\n}\n#ifdef __cplusplus\n}\n#endif\n```", "```java\nndk.dir=<Path to downloaded NDK package>/android-ndk-r10e\n```", "```java\napply plugin: 'com.android.library'\n\nandroid {\n    defaultConfig {\n        minSdkVersion 9\n     ...\n        ndk { moduleName \"mylib\" } \n    } \n}\n```", "```java\n├── lib\n│   ├── arm64-v8a\n│   │   └── libmylib.so\n│   ├── armeabi\n│   │   └── libmylib.so\n│   ├── armeabi-v7a\n│   │   └── libmylib.so\n│   ├── mips\n│   │   └── libmylib.so\n│   ├── mips64\n│   │   └── libmylib.so\n│   ├── x86\n│   │   └── libmylib.so\n│   └── x86_64\n│       └── libmylib.so\n```", "```java\npublic class MyNativeActivity extends Activity {\n   …\n   static {\n      System.loadLibrary(\"mylib\");\n   }\n}\n```", "```java\npublic class MyNativeActivity extends Activity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n      ...\n      TextView cPlusTv = (TextView)  \n          findViewById(R.id.helloFromCPlusPlus);\n      cPlusTv.setText(isPrimeCPlusPlus(4));\n    }\n\n    public native String isPrimeCPlusPlus(int number);\n}\n```", "```java\nJNIEXPORT jstring JNICALL Java_com_packpublishing_asynchronousandroid_chapter9_MyNativeActivity_isPrimeCPlusPlus(JNIEnv *, jobject, jint);\n```", "```java\n#include \"com_packpublishing_asynchronousandroid_chapter9_MyNativeActivity.h\"\n\nclass Math {\n  public:\n  static int isPrime(int number) { ...// Elided for brevity}\n};\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\njstring  Java_com_packpublishing_asynchronousandroid_chapter9_MyNativeActivity_isPrimeCPlusPlus\n(JNIEnv * env, jobject obj, jint number) {\n\n  return (env)->NewStringUTF(\n     Math::isPrime(number) ? \"Is Prime\" : \"Is not Prime\");\n}\n\n#ifdef __cplusplus\n}\n#endif\n```", "```java\n  ndk {\n    moduleName \"mylib\"\n    stl \"c++_shared\"\n  }\n```", "```java\npublic class MyNativeActivity extends Activity {\n  static {\n    System.loadLibrary(\"c++_shared\");\n    System.loadLibrary(\"mylib\");\n  }\n}\n```", "```java\npublic class MyNativeActivity extends Activity {\n\n  protected EditText inputTextEt = null;\n  protected TextView charCountTv = null;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n\n     // Reference stored as member fields for native access\t\n    inputTextEt = (EditText) findViewById(R.id.inputText);\n    charCountTv = (TextView) findViewById(R.id.charCount);\n\n    // Called every time the code changes\n    inputTextEt.addTextChangedListener(new TextWatcher() {\n      @Override\n      public void onTextChanged(CharSequence s, int start, \n                                int before, int count) {\n        updateWordCounter(s.toString());\n      }\n      ...\n    });\n  }\n  // Native function that calculates the number of words \n  // in a string\n  private native void updateWordCounter(String s);\n}\n```", "```java\nclass Util {\n  public:\n  static int countWords(const std::string &strString) { \n    ... \n  };\n}\n\nVoid Java_com_packpublishing_asynchronousandroid_chapter9_MyNativeActivity_updateWordCounter(JNIEnv *env, jobject obj, jstring text) {\n\n    std::string content(env->GetStringUTFChars(text, 0));\n\n    size_t word_cnt= Util::countWords(content);\n\n    // Update the TexView with word_cnt integer\n\n}\n```", "```java\njmethodID   GetMethodID(JNIEnv* env, jclass clazz, \n                        const char*name, \n                        const char* methodSignature);\n\njfieldID    GetFieldID(JNIEnv*, jclass clazz, \n                       const char*name, \n                       const char* fieldTypeCode);\n```", "```java\n (<Argument 1 TC ><Argument N TC>) <Return TC>\n```", "```java\n// 1\\. Obtain a reference to the MyNativeActivity class definiton\njclass activityClass = env->GetObjectClass(obj);\n\n// 2\\. Get the fieldId for the charCountTv TextView \n   jfieldID charCountFId = env->GetFieldID(activityClass, \"charCountTv\", \"Landroid/widget/TextView;\");\n\n// 3\\. Retrieve the object using the object and the jfieldID\njobject tvObj = env->GetObjectField(obj,charCountFId); \n```", "```java\nvoid CallVoidMethod(JNIEnv *env, jclass clazz,\n                    jmethodID methodID, ...);\n```", "```java\n// 1\\. Get the TextView class definition \njclass textViewClass = env->GetObjectClass(tvObj);\n\n// 2\\. Get the methodId for the TextView.setText function\njmethodID setTextMId = env->GetMethodID(\n       textViewClass, \"setText\", \"(Ljava/lang/CharSequence;)V\");\n\n// 3\\. Invoke the SetText instance function\n   env->CallVoidMethod(\n     tvObj,setTextMId,env->NewStringUTF(wordCountStr);\n```", "```java\n// To invoke a Class static method that returns a Java Type\n<NativeType> CallStatic<Type>Method(\n   JNIEnv *env, jobject obj, jmethodID methodID, ...);\n\n// To invoke a method that returns a Java <Type>  \n<NativeType> Call<Type>Method(\n   JNIEnv *env, jobject obj, jmethodID methodID, ...);\n\n// To invoke a method that returns a Java <Type[]>  \n<NativeArrayType> Call<Type>MethodA(\n  JNIEnv *env, jobject obj, jmethodID methodID, ...);\n```", "```java\npublic class GrayImageLoader extends AsyncTaskLoader<Result<Bitmap>> {\n\n  final String fileName;\n  Bitmap grayImage;\n\n  public ToGrayImageLoader(Context ctx, String fileName) {\n    super(ctx);\n    this.fileName =  fileName;\n  }\n\n  @Override\n  public Result<Bitmap> loadInBackground() {\n    Result<Bitmap> result = new Result<Bitmap>();\n    try {\n      BitmapFactory.Options options = new BitmapFactory.Options();\n      options.inPreferredConfig = Bitmap.Config.ARGB_8888;\n\n      // Build a RGBA 8888 Bitmap to represent the image \n      Bitmap b = BitmapFactory.decodeFile(this.fileName, options);\n\n      // Convert the Image to Gray scale on Native code\n      Bitmap originalImage = BitmapFactory.decodeStream(\n        getContext().getAssets().open(fileName));\n\n \t  // Fill the result with the Gray Image\n      result.obj = convertImageToGray(originalImage);\n    } catch (Exception e) {\n      result.error = e;\n    }\n    return result;\n  }\n\n  private native Bitmap convertImageToGray(Bitmap original);\n  …\n}\n```", "```java\nJNIEXPORT jobject JNICALL Java_com_packpublishing_asynchronousandroid_chapter9_ToGrayImageLoader_convertImageToGray(JNIEnv * env, jobject loader, jobject bitmap);\n```", "```java\nndk {\n    moduleName \"mylib\"\n    stl \"stlport_shared\"\n    ldLibs \"jnigraphics\", \"log\"\n}\n```", "```java\n#include \"com_packpublishing_asynchronousandroid_chapter9_ToGrayImageLoader.h\"\n#include <android/bitmap.h>\n```", "```java\njobject Java_com_packpublishing_asynchronousandroid_chapter9_ToGrayImageLoader_convertImageToGray(JNIEnv * env, jobject obj, jobject bitmap) {\n\n  AndroidBitmapInfo info; // Image Information\n  void * pixels; // Pixel Matrix\n  int ret; // Jni Graphics operation result code\n\n   // Reads the Image width, height, format,...\n  if ( (ret = AndroidBitmap_getInfo(env, bitmap, & info)) < 0) {\n    jclass clazz = env->FindClass(\"java/lang/RuntimeException\");\n    env->ThrowNew(clazz, \"Failed to get bitmap info\");\n    return 0;\n  }\n  // Loads the bitmap pixel matrix on pixels pointer\n  if ((ret = AndroidBitmap_lockPixels(env,bitmap,(void **)& pixels)) < 0) {\n    // Exception Generation Elided for brevity\n  }\n  // Convert each pixel to gray\n  ...\n  AndroidBitmap_unlockPixels(env, bitmap);\n  return bitmap;\n}\n```", "```java\n@Override\npublic void onLoadFinished(Loader<Result<Bitmap>> loader, Result<Bitmap> data) {\n  if ( data.obj != null ) {\n    ImageView iv = (ImageView)findViewById(R.id.grayImage);\n    iv.setImageBitmap(data.obj);\n  } else {\n    Log.e(\"<TAG>\", data.error.getMessage(), data.error);\n  }\n}\n```", "```java\nndk {\n  moduleName \"mylib\"\n  stl \"c++_shared\"\n  cppFlags.add(\"-frtti\")\n  cppFlags.add(\"-exceptions)\n}\n```", "```java\njint AttachCurrentThread(JavaVM *vm, void **p_env, void *thr_args) \n```", "```java\n// Java VM Global Pointer\nstatic JavaVM* gVm = NULL;\njint JNI_OnLoad (JavaVM* vm, void* reserved) {\n    gVm = vm;\n    return JNI_VERSION_1_4;\n}\n```", "```java\n#include <thread> // including the C++11 Thread Header\n#include <jni.h>  // JNI Header\nclass JavaThread: public std::thread {\npublic:\t \n  JavaThread();\n  Void join(); // Wait for the thread to finish\n  void entryPoint();\n  void start(); \n  void stop();\nprotected:\n   // Method that subclass should implement to define\n   // the unit of work \n   virtual void run() = 0;    \t \n   virtual void onDetach() {};JNIEnv* threadEnv = NULL; // Thread specific JNI Environment\n   std::thread thread_; // C++11 Thread \n   // is Thread attached to JVM\nbool isStarted = false;\n   std::condition_variable startCond;\n   std::mutex startMutex;\n   volatile bool shouldStop = false;\n   std::condition_variable stopCond;\n   std::mutex stopMutex;\n};\n```", "```java\n // Thread waits for his turn\n mutex.lock();\n ...// Only one thread enters on this section\n mutex.unlock();\n```", "```java\nvoid JavaThread::start() {\n    thread_ = std::thread(&JavaThread::entryPoint, this);\n    std::unique_lock<std::mutex> lck(startMutex);\n    // wait until the Thread is attached to JVM\n    while (!isStarted) startCond.wait(lck);\n}\n```", "```java\nvoid JavaThread::entryPoint() {\n\n  // Attach current thread to Java virtual machine\n  // and obrain JNIEnv interface pointer\n  { \n    // Acquires the start Mutex to access the conditional variable\n    std::unique_lock<std::mutex> lck(startMutex);\n    // Ataches the current thread to the JVM \n    // and caches the JNIEnv \n    if ( gVm->AttachCurrentThread(&threadEnv, NULL) != 0) {\n      ..// Handle the error \n    }\n    isStarted = true;  // Changes the shared variable\n    startCond.notify_all(); // Notify the thread constructor\n  }\n  onAttach();\n  try {\n    // Run the subclass method\n    run();\n  } catch (...) {\n    // Detach current thread when an exception happens\n    onDetach();\n    gVm->DetachCurrentThread();\n    throw;\n  }\n  // Detach current thread from Java virtual machine\n  onDetach(); \n  gVm->DetachCurrentThread();\n}\n```", "```java\nvoid JavaThread::stop() {\n    // Acquire the stop mutex \n    std::unique_lock<std::mutex> lck(stopMutex);    \n    // Change the should stop condition \nthis->shouldStop =true;    \n    // Notify any thread waiting for this signal that shouldstop\n    // condition has changed.\n    stopCond.notify_all();\n}\n```", "```java\npublic class NativeThreadsActivity extends Activity {  \n  public static final int HEALTHCHECK = 0; // Handler Message Code\n  ...\n  // Process the Message sent by the native threads\n  Handler myHandler = new Handler() {\n    public void handleMessage(Message msg) {\n      switch (msg.what) {\n      case HEALTHCHECK:\n        TextView tv = (TextView)findViewById(R.id.console);\n        tv.setText((String) msg.obj + tv.getText());\n        break;\n      }\n    }\n  };\n  // Start the Native Threads when the start button is clicked\n  public native void startNativeThreads(Handler handler);\n  // Stop The Native Threads when the stop button is clicked\n  public native void stopNativeThreads();\n}\nOnce our handler receives a message with the code HEALTHCHECK it will prepend the String received on the msg.obg to a TextView on the Activity UI screen. \n```", "```java\nclass HealthCheckThread: public JavaThread {\n\n     jobject handlerObj; // Cache the Global Reference  \npublic:\n    HealthCheckThread(JNIEnv *env_,jobject handlerObj_):\n      JavaThread(), \n      // Use the main threadJNIEnv to create a global ref\n      handlerObj(env_->NewGlobalRef(handlerObj_)) {} \n     }\n```", "```java\n    Jobject NewLocalRef(jobject);\n    void DeleteLocalRef (jobject);\n    ```", "```java\n        jint EnsureLocalCapacity(jint);\n        ```", "```java\n    jobject NewGlobalRef (jobject);\n    void DeleteGlobalRef(jobject);\n    ```", "```java\n    jweak NewWeakGlobalRef(JNIEnv *env, jobject obj);\n    void DeleteWeakGlobalRef(JNIEnv *env, jweak obj);\n    ```", "```java\nclass HealthCheckThread: public JavaThread {\n    ...\n    virtual void onDetach(){\n        jniEnv()->DeleteGlobalRef(handlerObj);\n    }\n}\n```", "```java\nvirtual void run(){\n\n  while (!shouldStop) {\n    std::unique_lock<std::mutex> lck(stopMutex);\n    // Do Work\n    // ...\n    sendHealthMessage();\n    // Wait until a stop signal is sent\n    stopCond.wait_for(lck, std::chrono::seconds(1));\n  }\n    }\n```", "```java\nvoid sendHealthMessage() {\n\n  // Get the Handler class from the JVM\n  jclass handlerClass = jniEnv()->FindClass(\"android/os/Handler\");\n\n  // Get the Handler.obtainMessage methodId \n  jmethodID obtainMId = jniEnv()->GetMethodID(handlerClass,  \n \"obtainMessage\",\"(ILjava/lang/Object;)Landroid/os/Message;\");\n  ...\n  // Build up the alive message\n  std::ostringstream oss;\n  oss << \"Thread[\" << std::this_thread::get_id() \n      << \"] is alive at \" << ctime( & tt) << std::endl;;\n\n  // Obtain a message object \n  jobject messagObj = jniEnv()->CallObjectMethod(handlerObj, \n                      obtainMId,\n                      HEALTHCHECK_MESSAGE,\n                      jniEnv()->NewStringUTF(oss.str().c_str()));\n\n  // Get the Handler.senMessage methodId\n  jmethodID sendMsgMId = jniEnv()->GetMethodID(handlerClass, \n                         \"sendMessage\",\"(Landroid/os/Message;)Z\");\n\n  // Enqueues a new message on the main thread looper\n  jniEnv()->CallBooleanMethod(handlerObj,sendMsgMId, messagObj);\n  // Deletes the local references\n  jniEnv()->DeleteLocalRef(handlerClass);\n  jniEnv()->DeleteLocalRef(messagObj);\n}\n```", "```java\nstatic const int num_threads = 10;\nstatic JavaThread* threads[num_threads];\n\nvoid  Java_com_packpublishing_asynchronousandroid_chapter9_NativeThreadsActivity_startNativeThreads\n        (JNIEnv *jEnv, jobject activity, jobject handler){\n\n    LOGI(\"Starting  %d Native Threads\",num_threads);\n    // Launch a group of threads\n    for (int i = 0; i < num_threads; ++i) {\n        threads[i] = new HealthCheckThread(jEnv,handler);\n        threads[i]->start();\n     }\n}\n```", "```java\nvoid Java_com_packpublishing_asynchronousandroid_chapter9_NativeThreadsActivity_stopNativeThreads(JNIEnv *env, jobject activity){\n\n    LOGI(\"Stopping %d Native Threads\", num_threads);\n\n    for (int i = 0; i < num_threads; ++i) {\n        // Notify the thread to stop\n     threads[i]->stop();        \n        // This blocks the execution of the current thread until\n        // HealthCheckThread native thread finishes\n        threads[i]->join();        \n  // De-allocates memory previously allocated \n        delete threads[i];\n    }\n}\n```", "```java\npublic class ExceptionActivity extends Activity {\n\n ...\n OnClickListener onClickListener = new OnClickListener() {\n    @Override\n    public void onClick(View v) {\n      try {\n        // Allocate a ByteBuffer with a size of 8 bytes\n        ByteBuffer byteBuffer = ByteBuffer.allocate(8);\n\n        // Call a native function that will try to access \n        // an out of bounds buffer position\n        genException(byteBuffer);\n\t    // Catches a Runtime Exception\n      } catch (RuntimeException e) {\n        // Prints the Exception Stack Trace to the TextView\n        TextView console = (TextView)findViewById(R.id.console);\n        StringWriter sw = new StringWriter();\n        e.printStackTrace(new PrintWriter(sw));\n        console.setText(sw.toString());\n      }\n    }\n  };\n  ...\n  // Native Function that will generate and Exception\n  private native void genException(ByteBuffer buffer);\n}\n```", "```java\nvoid Java_com_packpublishing_asynchronousandroid_chapter9_ExceptionActivity_genException(JNIEnv * jniEnv, jobject activityObj, jobject byteBuffer){\n\n  // Get the ByteBuffer class \n  jclass byteBufC= jniEnv->GetObjectClass(byteBuffer);\n\n  jmethodID getMid = jniEnv>GetMethodID(byteBufC,\"get\",\"(I)B\");\n\n// Trying to access a buffer position out of the buffer capacity\n  jbyte byte = jniEnv->CallByteMethod(byteBuffer,getMid,32);\n\n  if (jniEnv->ExceptionCheck()) {\n    // Prints the exception  on the standard Error\n    jniEnv->ExceptionDescribe();    \n    // Clears the exception on the JVM\n    jniEnv->ExceptionClear();\n    jclass excC = jniEnv>FindClass(\"java/lang/RuntimeException\");\n    jniEnv->ThrowNew(excC,\"Failed to get byte from buffer\");\n    // Release the Allocated Resources \n    jniEnv->DeleteLocalRef(excC);\n    jniEnv->DeleteLocalRef(byteBufC);        \n    // Return with Pending RuntimeException\n    return;\n  }\n  ...\n}\n```", "```java\nsynchronized (obj) { ... // synchronized block }\nsynchronized void incrementCount() { ... // synchronized methods }\n```", "```java\njint MonitorEnter(JNIEnv *env, jobject obj);\njint MonitorExit(JNIEnv *env, jobject obj);\n```", "```java\npublic class StatsActivity extends Activity {\n     // Memory RSS(Resident Set Size) SIZE Retrieve size Request\n  public static final int MEM_RSS_REQUEST = 0;\n\n  // Shared Resource between Java and Native\n  Queue<Integer> requests = new LinkedList<Integer>();\n  Object queueLock = new Object();\n\n  OnClickListener onRSSReqListener = new OnClickListener() {\n    @Override\n    public void onClick(View v) {\n      synchronized (queueLock) {\n        requests.add(MEM_RSS_REQUEST);\n      }\n    }\n  };\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    ...\n    RSSButton.setOnClickListener(onRSSReqListener);\n  }\n}\n```", "```java\n#include \"thread.h\" // Header where JavaThread is defined\n\nstatic const int RSS_REQUEST= 0;\n\nclass CPUStatThread: public JavaThread {\n\n  // Reference to the Activity and received on the constructor\n  jobject activityObj; \n  ...\n  virtual void run() {\n    while ( !shouldStop ) {\n      std::unique_lock<std::mutex> lck(stopMutex);\n      processMessage();\n      // Wait until a stop signal is sent\n         stopCond.wait_for(lck,std::chrono::milliseconds(200));\n    }\n  }\n  void processMessage(){\n\n    jclass activityClass = jniEnv()->GetObjectClass(activityObj);\n\n    // Retrieve the QueueLock(lockObj) and the Handler \n    // Fields(handlerObj) objects from Activity and \n    // getNextRequest methodId\n\t ... \n    // Acquire the queue monitor\t \n    jniEnv()->MonitorEnter(lockObj);\n\n    // Retrieve the next command request to be processed\n    int requestCode = jniEnv()->CallIntMethod(activityObj, \n                                              getNextRequestMid);\n    switch (requestCode){\n      case RSS_REQUEST:\n        LOGI(\"Received a RSS Request\");\n        sendRSSMessage(handlerObj);\n        break;\n    }\n    // Release the queue monitor\t\n      jniEnv()->MonitorExit(lockObj);\n\t// Release local References to avoid leaks\n   ...\n  }\n};\n```", "```java\npublic class StatsActivity extends Activity {\n\n  int getNextRequest(){\n    return requests.size()> 0 ? requests.remove():-1;\n  }\n}\n```", "```java\npublic class MyObject {\n  // Transports a pointer to original \n  // native object or structure\n  long nativePtr; \n}\n```", "```java\npublic interface Disposable {\n  // Releases the native objects wrapped on the object\n  void dispose();\n}\n```", "```java\nstruct CPUStat{\n    double vm; // Virtual Memory Size\n    double rss; // Process Resident Memory    \n    // constructor \n    CPUStat( double &vm_,\n             double &rss_):vm(vm_),rss(rss_){}\n};\n\nAnd its Java counterpart:\n\npublic class JCPUStat implements Disposable {    \n    // Reference to the native struct stored on a long\n    long nativePtr;\n\n    public JCPUStat(long nativePtr){\n        this.nativePtr = nativePtr;\n    }\n    native long getRSSMemory();\n\n    @Override\n    public native void dispose();\n}\n```", "```java\n   // Generic function to convert a nativePtr member to a T pointer \ntemplate <typename T>\nT * getNativePtr(JNIEnv * env, jobject obj) {\n  jclass c = env->GetObjectClass(obj);\n  jfieldID nativePtrFID =  env->GetFieldID(c, \"nativePtr\", \"J\");\n  jlong nativePtr = env->GetLongField(obj, nativePtrFID);\n  return reinterpret_cast<T * >(nativePtr);\n}\n\nvoid unsetNativePtr(JNIEnv * env, jobject obj) {\n  jclass c = env->GetObjectClass(obj);\n  jfieldID nativePtrFID =  env->GetFieldID(c, \"nativePtr\", \"J\");\n  env->SetLongField(obj, nativePtrFID, 0);\n}\n\nvoid Java_com_packpublishing_asynchronousandroid_chapter9_JCPUStat_dispose(JNIEnv *env, jobject obj){\n\n   // Retrieves the pointer to the original structure\n   CPUStat *stat = getNativePtr<CPUStat>(env,obj);\n   if ( stat != 0 ) {\n     delete stat;  // Releases the memory allocated to stat\n     unsetNativePtr(ev,obj); \n   }\n   }\n```", "```java\n// Function to retrieve the Memory Usage \nvoid CPUStatThread::processMemUsage(\n  double& vm_usage, double& resident_set){...}\n\nvoid CPUStatThread::sendRSSMessage(jobject & handlerObj) {\n\n  double vm, rss;\n  // Read the mempory usage\n  processMemUsage(vm, rss);\n  jclass jCpuStatClass = jniEnv()->FindClass(\n    \"com.packpublishing.asynchronousandroid.chapter9.JCPUStat\");\n\n  // Find the JCPUStat Constructor\n  jmethodID  jCpuConstructorMid = jniEnv()->GetMethodID(\n    jCpuStatClass, \"<init>\", \"(J)V\");\n  // Create a native CPUStat object \n  CPUStat * cpuStat = new CPUStat(vm, rss);\n\n  // Wrap the native object on a JCPUStat object  \n  jlong nativePtr = reinterpret_cast<jlong>(cpuStat);\n  jobject jCpuStat = jniEnv()->NewObject(\n    jCpuStatClass, jCpuConstructorMid, nativePtr);\n\n  // Get the Handler Reference and send Message\n  ...    \n  // Build up the Response Message with the \n  jobject messagObj = jniEnv()->CallObjectMethod(\n     handlerObj, obtainMId, RSS_RESPONSE, jCpuStat);\n\n  // Push the message to the main Thread Handler                   \n  jniEnv()->CallBooleanMethod(handlerObj, sendMsgMId, messagObj);\n  // Clean up the local references\n  ...\n  }\n```", "```java\npublic class StatsActivity extends Activity {\n  public static final int MEM_RSS_REQUEST = 0;\n  public static final int MEM_RSS_RESPONSE = 1;\n  public Handler myHandler = new Handler() {\n    public void handleMessage(Message msg) {\n      switch (msg.what){\n        case MEM_RSS_RESPONSE:\n          TextView tv = (TextView) findViewById(R.id.console);\n          JCPUStat stat = (JCPUStat) msg.obj;\n          tv.setText(\"Memory Consumed is \"+stat.getRSSMemory());\n          // Releases the native object and frees the memory\n          stat.dispose();\n          break;\n      }\n    }\n  };\n  ...\n  public native void startCPUStatThread();\n  public native void stopCPUStatThread()\n}\n```", "```java\njlong Java_com_packpublishing_asynchronousandroid_chapter9_JCPUStat_getRSSMemory(JNIEnv *env, jobject obj) {\n    CPUStat *stat = getNativePtr<CPUStat>(env,obj);\n    return (jlong)stat->rss;\n}\n```"]