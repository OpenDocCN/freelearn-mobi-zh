<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Structural Patterns &#x2013; Decorator, Proxy, and Bridge"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Structural Patterns – Decorator, Proxy, and Bridge</h1></div></div></div><p>After reviewing the five creational patterns in the previous chapter, we will now talk about another category of patterns: the <a class="indexterm" id="id75"/>structural patterns. There are seven patterns to talk about; these patterns ease the design by identifying a simple way to realize relationships between entities.</p><p>We will see how these patterns help you to encapsulate the composition of objects through the use of an interface, allowing you to conveniently abstract your system as the creational pattern does to encapsulate the creation of objects. Structural patterns highlight the use of interfaces.</p><p>You will see how the composition is designed; we will not interfere with the object itself but with the one that will transfer the structuration. This second object is strongly related to the first one. Indeed, the first object presents the interface to the client and manages its relationship with the second object, which, manages the composition and doesn't have any interfaces with clients.</p><p>One important thing to make a note of is that this structuration allows a great flexibility to your system by allowing dynamic modification of the composition. Indeed, we can substitute an object with another if both inherit the same class and use the same interface.</p><div class="section" title="Static and dynamic composition"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Static and dynamic composition</h1></div></div></div><p>We can have several possible implementations. The classic way to design this is to differentiate these implementations in subclasses. In this case, we will provide an interface from where our classes will implement this interface.</p><p>This<a class="indexterm" id="id76"/> solution consists of a <a class="indexterm" id="id77"/>static composition. Indeed, once the implementation class of an object is chosen, we can no longer change it. The following diagram is the implementation of an object by heritage:</p><div class="mediaobject"><img alt="Static and dynamic composition" src="graphics/4852_02_01.jpg"/></div><p>Another <a class="indexterm" id="id78"/>way is to separate the implementation in another object. The implementation parts are <a class="indexterm" id="id79"/>managed by an instance of the <code class="literal">ConcreteImplementationA</code> class or by the <code class="literal">ConcreteImplementationB</code> class. This reference is referred by the <code class="literal">implementation</code> attribute. This instance can then be easily substituted by another instance at runtime. This composition is dynamic.</p><p>The following UML class diagram shows us clearly how to structure your objects using a dynamic composition. The <code class="literal">ConcreteImplementation</code> class can be switched at runtime, without having to modify the <code class="literal">Realization</code> object. </p><p>We can eventually modify the realization object, without having to modify our original object, as shown in the following diagram:</p><div class="mediaobject"><img alt="Static and dynamic composition" src="graphics/4852_02_02.jpg"/></div><p>In this chapter, you'll see how to use this solution with the bridge pattern.</p><p>The discovery of the structural patterns will span three chapters. In this chapter, we will introduce you to three of them:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The decorator pattern</li><li class="listitem" style="list-style-type: disc">The proxy pattern</li><li class="listitem" style="list-style-type: disc">The bridge pattern</li></ul></div><p>These three patterns provide a mechanism of adding states and behaviors dynamically, controlling the creation and access of objects, and keeping the specification and implementation separate.</p><p>The objectives of the three structural patterns that we will see in this chapter are described in the following table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Pattern</p>
</th><th style="text-align: left" valign="bottom">
<p>Objective</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>The decorator pattern</p>
</td><td style="text-align: left" valign="top">
<p>This<a class="indexterm" id="id80"/> pattern <a class="indexterm" id="id81"/>allows you to dynamically add new behaviors and functionalities to the object.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>The proxy pattern</p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id82"/>pattern <a class="indexterm" id="id83"/>is a substitute of another object. It provides a behavior that can adapt to the optimization or security needs. </p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>The bridge pattern</p>
</td><td style="text-align: left" valign="top">
<p>This <a class="indexterm" id="id84"/>pattern <a class="indexterm" id="id85"/>decouples an abstraction from its implementation, enabling them to vary independently.</p>
</td></tr></tbody></table></div></div></div>
<div class="section" title="The decorator pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>The decorator pattern</h1></div></div></div><p>The <a class="indexterm" id="id86"/>first structural pattern that we will discuss is the <a class="indexterm" id="id87"/>decorator pattern. It introduces you to the object substitution by adding new functionalities or behaviors.</p><div class="section" title="Roles"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec44"/>Roles</h2></div></div></div><p>The <a class="indexterm" id="id88"/>main objective of this pattern is to dynamically add new functionalities to an object. The interface of the object will not be modified, so from the client's perspective, this is fully transparent.</p><p>This pattern is an alternative to the addition of a subclass that adds functionalities to its parent class. A key implementation point in the decorator pattern is that decorators both inherit the original class and contain an instantiation of it.</p><p>This pattern can be <a class="indexterm" id="id89"/>used when:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A system adds dynamically new functionalities to an object, without having to modify its interface, which means without having to modify the client of this object</li><li class="listitem" style="list-style-type: disc">A system manages the behavior that can be dynamically removed</li><li class="listitem" style="list-style-type: disc">The use of inheritance is not a good option because of an already complex class hierarchy</li></ul></div></div><div class="section" title="Design"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec45"/>Design</h2></div></div></div><p>The generic UML <a class="indexterm" id="id90"/>class diagram of the decorator pattern is quiet simple: The <code class="literal">ConcreteComponent</code> and <code class="literal">AbstractDecorator</code> classes share the same interface that have the same method name. Our <code class="literal">AbstractDecorator</code> class defines a constructor where we pass our <code class="literal">Abstractcomponent</code> class as an argument. Then, in our <code class="literal">ConcreteDecorator</code> class, we reroute the operation call to the <code class="literal">additionalOperation</code> methods to add<a class="indexterm" id="id91"/> new functionalities or behaviors to the original component, as shown in the following diagram:</p><div class="mediaobject"><img alt="Design" src="graphics/4852_02_03.jpg"/></div></div><div class="section" title="Participants"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec46"/>Participants</h2></div></div></div><p>In the <a class="indexterm" id="id92"/>preceding diagram, there are four participants in this pattern:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">AbstractComponent</code>: This<a class="indexterm" id="id93"/> is the common interface to components and decorators.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ConcreteComponent</code>: This<a class="indexterm" id="id94"/> is the main object to which we want to add behaviors and/or functionalities.</li><li class="listitem" style="list-style-type: disc"><code class="literal">AbstractDecorator</code>: This<a class="indexterm" id="id95"/> abstract class contains a reference to a component.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ConcreteDecoratorA</code> and <code class="literal">ConcreteDecoratorB</code>: These <a class="indexterm" id="id96"/>are the<a class="indexterm" id="id97"/> concrete subclasses of <code class="literal">AbstractDecorator</code>. These classes implement the functionalities added to the component.</li></ul></div></div><div class="section" title="Collaboration"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec47"/>Collaboration</h2></div></div></div><p>When a <a class="indexterm" id="id98"/>decorator receives a message that must reach the component, it redirects the message by making a prior or posterior operation to that redirection.</p></div><div class="section" title="Sample"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec48"/>Sample</h2></div></div></div><p>To illustrate<a class="indexterm" id="id99"/> this pattern, we will take a simple example. Let's suppose that you have a drawing software that enables you to draw some shapes on the screen: a rectangle and square.</p><p>You already know how to draw these shapes. Now, you need to add a new functionality that will add a rounded angle to your shapes. To do this, you need to decide which decorator pattern you need to use that will allow you to not to interfere with the existing class method signature.</p></div><div class="section" title="Implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec49"/>Implementation</h2></div></div></div><p>First, we will<a class="indexterm" id="id100"/> create our interface that defines the shape. We will simulate a <code class="literal">Draw()</code> operation. In fact, the method will return a string that tells us what is drawn:</p><div class="informalexample"><pre class="programlisting">protocol IShape {
  func draw() -&gt; String
}</pre></div><p>Now, we will create our two concrete classes that implement the <code class="literal">IShape</code> interface. We will have the <code class="literal">Square</code> and <code class="literal">Rectangle</code> classes. They both implement the <code class="literal">draw</code> function. This function returns the shape that is currently drawn:</p><div class="informalexample"><pre class="programlisting">class Square: IShape {
  func draw() -&gt; String{
    return "drawing Shape: Square"
  }
}

class Rectangle: IShape {
  func draw() -&gt; String {
    return "drawing Shape: Rectangle"
  }
}</pre></div><p>Our classes are ready; now, we prepare our abstract <code class="literal">ShapeDecorator</code> class that defines the structure<a class="indexterm" id="id101"/> of our future concrete decorators. This class implements the <code class="literal">IShape</code> interface too, so the <code class="literal">Draw()</code> function must be present. Nevertheless, Swift doesn't have an abstract class, so we implement the draw method, but we force an exception to tell us that this method must be implemented. The <code class="literal">ShapeDecorator</code> class will not be used by the client itself. The client will call the <code class="literal">ConcreteDecorator</code> object to add a new functionality to its shape:</p><div class="informalexample"><pre class="programlisting">class ShapeDecorator: IShape {
  private let decoratedShape: IShape
  
  required init(decoratedShape: IShape){
    self.decoratedShape = decoratedShape
  }
  
   func draw() -&gt; String {
    fatalError("Not Implemented")
  }
}</pre></div><p>Now, we add our concrete decorator class that inherits from the <code class="literal">ShapeDecorator </code>abstract class. We add our new <code class="literal">setRoundedCornerShape</code> functionality to this class and override the <code class="literal">draw</code> function to return the shape that is drawn, but with rounded corners:</p><div class="informalexample"><pre class="programlisting">class RoundedCornerShapeDecorator: ShapeDecorator{
  required init(decoratedShape: IShape) {
       super.init(decoratedShape: decoratedShape)
  }
  
  override func draw() -&gt;String{
    //we concatenate our shape properties
     return  decoratedShape.draw() + "," + setRoundedCornerShape(decoratedShape)
  }
  
  func setRoundedCornerShape(decoratedShape: IShape) -&gt; String{
    return "Corners are rounded"
  }
}</pre></div></div><div class="section" title="Usage"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec50"/>Usage</h2></div></div></div><p>Now, here<a class="indexterm" id="id102"/> is the easy part that shows us how to use all of the code, we already have written, from the client perspective.</p><p>We first create our two concrete shapes:</p><div class="informalexample"><pre class="programlisting">let rectangle = Rectangle()
let square = Square()</pre></div><p>Now, we want to <a class="indexterm" id="id103"/>have some shapes with rounded corners. To do this, we simply call the <code class="literal">ConcreteDecorator</code> class that interests us, the <code class="literal">RoundedCornerShapeDecorator</code> class, and pass a new shape (<code class="literal">Rectangle</code> or <code class="literal">Square</code>) as an argument of the constructor:</p><div class="informalexample"><pre class="programlisting">let roundedRectangle = RoundedCornerShapeDecorator(decoratedShape: Rectangle())

let roundedSquare = RoundedCornerShapeDecorator(decoratedShape: Square())</pre></div><p>Now, we simulate the <code class="literal">Draw()</code> method on the screen of our shapes by calling the <code class="literal">draw</code> operation:</p><div class="informalexample"><pre class="programlisting">print("rectangle with Normal Angles")
rectangle.draw()

print("square with Normal Angles")
square.draw()

//rounded corners shapes
roundedRectangle.draw()
roundedSquare.draw()</pre></div><p>The Playground will return the following result:</p><div class="mediaobject"><img alt="Usage" src="graphics/4852_02_04.jpg"/></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>Swift allows you to implement the decorator pattern using the concept of extensions. This allows you to add additional methods to concrete classes or constructs, without having to subclass or alter the original one. With extensions, you can add new methods but no new properties, as opposed to a subclass.</p></div></div></div></div>
<div class="section" title="The proxy pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>The proxy pattern</h1></div></div></div><p>The <a class="indexterm" id="id104"/>second pattern<a class="indexterm" id="id105"/> that we will talk about in this chapter is the proxy pattern. It is often used for security or optimization purposes.</p><div class="section" title="Roles"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec51"/>Roles</h2></div></div></div><p>The objective of the <a class="indexterm" id="id106"/>proxy pattern is to substitute an object (the subject) with another one that will control its access. The object that substitutes the subject shares the same interface, so it is transparent from the consumer's perspective. The proxy is often a small (public) object that stands in for a more complex (private) object that is activated once certain circumstances are clear. The proxy adds a level of indirection by accepting requests from a client object and passing them to the real subject as necessary.</p><p>The proxy pattern is used in object-oriented programming. There are several types of proxies, which are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>A virtual proxy</strong></span>: This allows <a class="indexterm" id="id107"/>you to create a "big" object at the appropriate time (used when the creation process is slow)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>A remote proxy</strong></span>: This <a class="indexterm" id="id108"/>allows you to access an object that is available on another environment (such as on a multiplayer game server)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>An authentication proxy</strong></span>: This <a class="indexterm" id="id109"/>check whether the access permission for a request is correct or not</li></ul></div></div><div class="section" title="Design"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec52"/>Design</h2></div></div></div><p>The following <a class="indexterm" id="id110"/>class diagram is quite simple; we have an interface that defines our subject, both the proxy and <code class="literal">RealSubject</code> implement this interface.</p><p>The client will call the proxy, not the <code class="literal">RealSubject</code> object himself. The proxy contains a reference to the <code class="literal">RealSubject</code> object. When the proxy receives a request, it can analyze it, and if the request is considered to be valid, it can be rerouted to the <code class="literal">RealSubject.request()</code> method. The proxy can decide when to create, or not, the <code class="literal">RealSubject</code> object avoiding to have to manage too <a class="indexterm" id="id111"/>big object in memory if useless. The following figure represent the generic class diagram of the proxy pattern:</p><div class="mediaobject"><img alt="Design" src="graphics/4852_02_05.jpg"/></div></div><div class="section" title="Participants"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec53"/>Participants</h2></div></div></div><p>There are <a class="indexterm" id="id112"/>only three participants in this pattern:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ISubject</code>: This <a class="indexterm" id="id113"/>is the common interface of the <code class="literal">Proxy</code> and <code class="literal">RealSubject</code> object</li><li class="listitem" style="list-style-type: disc"><code class="literal">RealSubject</code>: This <a class="indexterm" id="id114"/>is the object that is controlled and manipulated by the proxy.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Proxy</code>: This is the <a class="indexterm" id="id115"/>object that substitutes <code class="literal">RealSubject</code>. It has the same interface of the <code class="literal">RealSubject</code> object (the <code class="literal">ISubject</code> interface). It creates, controls, enhances, and authenticates access to a <code class="literal">RealSubject</code> object.</li></ul></div></div><div class="section" title="Collaboration"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec54"/>Collaboration</h2></div></div></div><p>The <a class="indexterm" id="id116"/>proxy receives the incoming request from a client instead of the <code class="literal">RealSubject</code>. If necessary, the message is then delegated to the <code class="literal">RealSubject</code> object. In this case, prior to the delegation, the proxy creates the <code class="literal">RealSubject</code> object if it has not already been done.</p></div><div class="section" title="Illustration"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec55"/>Illustration</h2></div></div></div><p>We are <a class="indexterm" id="id117"/>developing a new software; this software presents a video catalog in a list. For each video in the list, we have a placeholder for the video and a description. The placeholder of the video first displays a screenshot of the video. If we click on this image, the video will be launched.</p><p>The video catalog contains videos, so it will be too heavy to have all of these videos in memory and transferring them through the network will take too long. The proxy pattern will help us organize all of this. We will create the subject only when we will need it, once the screenshot is clicked.</p><p>The two advantages are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The list is loaded quickly, mainly if it is downloaded from the network</li><li class="listitem" style="list-style-type: disc">Only videos that we want to watch are created, loaded, and played</li></ul></div><p>The <code class="literal">Screenshot</code> class that represents the video is called the proxy of the <code class="literal">Video</code> subject. The proxy substitutes the <code class="literal">Video</code> subject for the display. The <code class="literal">Screenshot</code> class implements the same interface as the <code class="literal">Video</code> subject (the <code class="literal">RealSubject</code> object).</p><p>In our example, the proxy pattern design is as follows:</p><div class="mediaobject"><img alt="Illustration" src="graphics/4852_02_06.jpg"/></div><p>When the proxy receives the <code class="literal">display()</code> message, it will display the video if this one already exists. If <a class="indexterm" id="id118"/>it receives the <code class="literal">click()</code> message, it will first create the <code class="literal">Video</code> subject and then load the video.</p></div><div class="section" title="Implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec56"/>Implementation</h2></div></div></div><p>We will <a class="indexterm" id="id119"/>first define the interface that will be used by our proxy and real subject.</p><p>When we simulate the real behavior of these methods with Playground, these methods return a string, telling us what the code is expected to do. We can ensure what we are coding is correct by checking the message returned by Playground.</p><p>The interface will have only two methods: <code class="literal">click()</code> and <code class="literal">display()</code>:</p><div class="informalexample"><pre class="programlisting">protocol IAnimation{
  func display() -&gt; String
  func click() -&gt; String
}</pre></div><p>The <code class="literal">RealSubject</code> object is represented here with the video class. We implement the interface and display the message according to the action:</p><div class="informalexample"><pre class="programlisting">class Video:IAnimation{
  func click() -&gt; String{
    return ""
  }
  
  func display()-&gt;String{
    return "Display the video"
  }
  
  func load()-&gt;String{
    return "Loading the video"
  }
  
  func play()-&gt;String{
    return "Playing the video"
  }
}</pre></div><p>The proxy now implements the same interface as the <code class="literal">RealSubject</code> object: the <code class="literal">IAnimation</code> interface but has the intelligence to create the <code class="literal">RealSubject</code> object, here the <code class="literal">video</code> object, when needed in the <code class="literal">click</code> method:</p><div class="informalexample"><pre class="programlisting">class ScreenShot:IAnimation{
  var video:Video?
  
  func click() -&gt; String {
    if let video = video {
      return video.play()
    } else {
      video = Video()
      return video!.load()
    }
  }
  
  func display() -&gt; String {
    if let video = video {
      return video.display()
    } else {
      return "Display the screenshot of the video"
    }
  }
}</pre></div></div><div class="section" title="Usage"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec57"/>Usage</h2></div></div></div><p>The <a class="indexterm" id="id120"/>cool part is to simulate the client.</p><p>We first create a new proxy, <code class="literal">Screenshot</code>, and then we simulate the operation. We call <code class="literal">display</code> from the proxy. As the video is not created or loaded, it is the screenshot that will be displayed.</p><p>Then, we simulate a click. We can see that when we call the <code class="literal">click</code> method, the video gets loaded. As the video is created and loaded, we call the <code class="literal">display</code> method, which informs us that the video is now playing (instead of the screenshot of the video):</p><div class="informalexample"><pre class="programlisting">var animation = ScreenShot()
animation.display()
animation.click()
animation.display()</pre></div><p>The result in Playground is as follows:</p><div class="mediaobject"><img alt="Usage" src="graphics/4852_02_07.jpg"/></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>Use the proxy pattern when you have objects, which are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Expensive to create</li><li class="listitem" style="list-style-type: disc">Need access control</li><li class="listitem" style="list-style-type: disc">Access remote sites</li><li class="listitem" style="list-style-type: disc">Need to perform some actions whenever they are accessed</li></ul></div><p>Also, use the proxy pattern when you want to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Create objects only when their operations are requested</li><li class="listitem" style="list-style-type: disc">Perform checks or housekeeping on objects whenever accessed</li><li class="listitem" style="list-style-type: disc">Have a local object that will refer to a remote object</li><li class="listitem" style="list-style-type: disc">Implement access rights on objects when their operations are requested</li></ul></div></div></div></div></div>
<div class="section" title="The bridge pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>The bridge pattern</h1></div></div></div><p>Remember <a class="indexterm" id="id121"/>that, at the beginning of the chapter, we discussed <a class="indexterm" id="id122"/>dynamic composition that allows you to change the implementation of an object at runtime. The bridge pattern is another structural pattern that allows this.</p><div class="section" title="Roles"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec58"/>Roles</h2></div></div></div><p>The <a class="indexterm" id="id123"/>bridge pattern decouples an abstraction from its implementation. This means that this pattern separates the implementation of an object from its representation and interface.</p><p>Thus, firstly, the implementation can fully be encapsulated, and secondly, the implementation and representation can independently change, without having any constraints between them.</p><p>This pattern <a class="indexterm" id="id124"/>can be used:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To avoid a strong link between the object representation and its implementations</li><li class="listitem" style="list-style-type: disc">To avoid any impact between the interaction of the objects and their clients when the implementations of objects are modified</li><li class="listitem" style="list-style-type: disc">To allow the representation of objects and their implementations to keep their extension capability by creating new subclasses</li><li class="listitem" style="list-style-type: disc">To avoid to obtain very complex classes hierarchies</li></ul></div></div><div class="section" title="Design"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec59"/>Design</h2></div></div></div><p>In the <a class="indexterm" id="id125"/>class diagram of the bridge pattern, the separation between the abstraction and the implementation is very well represented—notice the left-hand side and right-hand side of the following diagram:</p><div class="mediaobject"><img alt="Design" src="graphics/4852_02_08.jpg"/></div></div><div class="section" title="Participants"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec60"/>Participants</h2></div></div></div><p>The bridge <a class="indexterm" id="id126"/>pattern uses a minimum of four participants:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">AbstractClass</code><a class="indexterm" id="id127"/> represents the domain objects. This class contains the interface used by clients and contains a reference to an object that implements the <code class="literal">Implementation</code> interface.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">ConcreteClass</code><a class="indexterm" id="id128"/> is the class that implements the methods defined in the <code class="literal">AbstractClass</code>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">ImplementationBase</code> class <a class="indexterm" id="id129"/>defines the method signature of the concrete implementation classes. The methods defined here differ from the methods of the <code class="literal">Abstract</code> class. These two sets of methods are different. Generally, methods of the <code class="literal">AbstractClass</code> are high-level methods, while the methods of the <code class="literal">implementation</code> class are low-level methods.</li><li class="listitem" style="list-style-type: disc">The <a class="indexterm" id="id130"/><code class="literal">ConcreteImplementationA</code> (<code class="literal">B </code>…) classes are concrete classes that realize methods introduced in the <code class="literal">ImplementationBase</code> interface.</li></ul></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>The <code class="literal">ImplementationBase</code> interface represents the bridge.</p></div></div></div><div class="section" title="Collaboration"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec61"/>Collaboration</h2></div></div></div><p>The <a class="indexterm" id="id131"/>operation of <code class="literal">AbstractClass</code> and its subclasses invokes the methods defined in the <code class="literal">ImplementationBase</code> interface, which represent the bridge.</p></div><div class="section" title="Illustration"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec62"/>Illustration</h2></div></div></div><p>We<a class="indexterm" id="id132"/> should be able to turn on the light or TV using the same object. Once my code to turn on the light or TV will be implemented in my client, I don't need to modify it if the <code class="literal">ConcreteImplementation</code> structure changes. Using the bridge pattern, I will use an object that inherits from <code class="literal">AbstractClass</code>. This object contains a method that the client will consume. This method doesn't turn on the TV, but it calls the method defined in the <code class="literal">ImplementationBase</code> class; thus, depending on the object that our abstract object uses, it will run the actions that are defined in the <code class="literal">ConcreteImplementation</code> class, which are represented by the TV or the light.</p></div><div class="section" title="Implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec63"/>Implementation</h2></div></div></div><p>Given the <a class="indexterm" id="id133"/>preceding problem, we will first define the method and a property that contains the object we want to manipulate. This object will implement the <code class="literal">ImplementationBase</code> interface, which represents the bridge.</p><p>The object that will be manipulated by clients will have a <code class="literal">turnOn()</code> method. This is the only method known by the client:</p><div class="informalexample"><pre class="programlisting">// IAbstractBridge
protocol IAbstractBridge {
  var concreteImpl: ImplementationBase {get set}
  func turnOn()
}</pre></div><p>Now, we will define the <code class="literal">ImplementationBase</code> interface. It contains the <code class="literal">run()</code>method that each <code class="literal">ConcreteImplementation</code> class will implement:</p><div class="informalexample"><pre class="programlisting">//Bridge
protocol ImplementationBase {
  func run()
}</pre></div><p>Our interfaces are now ready; we can create the <code class="literal">RemoteControl</code> class that our clients will use. Depending on the object referred in the <code class="literal">concreteImpl</code> property, the <code class="literal">turnOn()</code> method will call the run method of the <code class="literal">concreteImpl</code> object. To obtain a reference to the <code class="literal">concreteImpl</code> object, we will add an argument to the constructor (<code class="literal">init</code>) of the <code class="literal">RemoteControl</code> class:</p><div class="informalexample"><pre class="programlisting">/* Concrete Abstraction */
class RemoteControl: IAbstractBridge {
  var concreteImpl: ImplementationBase
  
  func turnOn() {
    self.concreteImpl.run()
  }
  
  init(impl: ImplementationBase) {
    self.concreteImpl = impl
  }
}</pre></div><p>Finally, we<a class="indexterm" id="id134"/> implement our <code class="literal">ImplementationBase</code> class for the <code class="literal">TV</code> and <code class="literal">Light</code> classes. A <code class="literal">run()</code> method is needed in each of them. The <code class="literal">run()</code> method contains all the needed logic that will permit you to turn on the light or TV. In our example, we only display a text that indicates the action has been completed:</p><div class="informalexample"><pre class="programlisting">/* Implementation Classes 1 */
class TV: ImplementationBase {
  func run() {
    println("tv turned on");
  }
}

/* Implementation Classes 2 */
class Light: ImplementationBase {
  func run() {
    println("light turned on")
  }
}</pre></div></div><div class="section" title="Usage"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec64"/>Usage</h2></div></div></div><p>From <a class="indexterm" id="id135"/>the client's perspective, we will use our <code class="literal">RemoteControl</code> abstraction class, pass the final object to the constructor when we want to manipulate (the <code class="literal">Light</code> or <code class="literal">TV</code> class), and call the <code class="literal">turnOn()</code> method of the <code class="literal">RemoteControl</code> object to execute the action:</p><div class="informalexample"><pre class="programlisting">let tvRemoteControl = RemoteControl(impl: TV())
tvRemoteControl.turnOn()

let lightRemoteControl = RemoteControl(impl: Light())
lightRemoteControl.turnOn()</pre></div><p>Thanks to Playground, we can now see the live result, which is as follows:</p><div class="mediaobject"><img alt="Usage" src="graphics/4852_02_09.jpg"/></div><p>We can see <a class="indexterm" id="id136"/>two messages on the right-hand side of our Playground file: <span class="strong"><strong>tv turned on</strong></span> and <span class="strong"><strong>light turned on</strong></span>, which means that the <code class="literal">run()</code> method of each final object has been correctly executed.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Summary</h1></div></div></div><p>We discussed the three structural patterns in this chapter: the decorator pattern, the proxy pattern, and the bridge pattern. From a high-level perspective, all of them help you extend classes without using inheritance, but using a dynamic composition of its class hierarchy.</p><p>Extending our original class has some impact on our original object except for the proxy pattern where it remains completely unchanged. The decorator pattern that needs to be designed needs to have the original class already developed because every concrete decorator needs to implement an interface based on the original object structure. The bridge pattern is more closely coupled, and there is an understanding that the original object must incorporate considerable references to the rest of the system.</p><p>We also discussed all the patterns that rely on rerouting operations. We learned that the rerouting is always done from the new code back to the original.</p><p>It is important to note that in real-time applications, where performance is required, the overhead of the time for rerouting the operations might not be acceptable.</p><p>In the next chapter, we will continue our discovery of structural patterns with the composite and flyweight patterns, which can be applied to systems that have huge data objects.</p></div></body></html>