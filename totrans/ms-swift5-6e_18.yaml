- en: '18'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '18'
- en: Memory Management
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理
- en: For many years, the primary languages that I used were C and C-based object-oriented
    languages. These languages required a good handle on managing memory and knowing
    when to release memory. Luckily, modern languages like Swift take care of managing
    memory for us. However, it is a good idea to understand how this memory management
    works so we can avoid the pitfalls that cause this memory management to fail.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，我主要使用的编程语言是C和基于C的面向对象语言。这些语言要求对内存管理有很好的掌握，并知道何时释放内存。幸运的是，现代语言如Swift为我们处理内存管理。然而，了解这种内存管理的工作原理是个好主意，这样我们可以避免导致内存管理失败的陷阱。
- en: 'In this chapter, we will learn:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习：
- en: How ARC works
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARC 的工作原理
- en: What a strong reference cycle is
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强引用循环是什么
- en: How to use weak and unowned references to prevent strong reference cycles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用弱引用和无主引用来防止强引用循环
- en: As we saw in *Chapter 17*, *Custom Value Types*, structures are value types
    and classes are reference types. What this means is that when we pass an instance
    of a structure within our application, such as a parameter of a method, we create
    a new instance of the structure in the memory. This new instance of the structure
    is only valid while the application is in the scope where the structure was created.
    Once the structure goes out of scope, the new instance of the structure is automatically
    destroyed, and the memory is released. This makes the memory management of structures
    very easy and painless.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在*第17章*中看到的，*自定义值类型*，结构体是值类型，类是引用类型。这意味着当我们在我们应用程序中传递一个结构体的实例时，例如一个方法的参数，我们在内存中创建了一个新的结构体实例。这个结构体的新实例仅在结构体被创建的作用域内有效。一旦结构体超出作用域，结构体的新实例将被自动销毁，内存将被释放。这使得结构体的内存管理非常简单且无痛苦。
- en: Classes, on the other hand, are reference types. This means that we allocate
    memory for the instance of the class only once, which is when it is initially
    created. When we pass an instance of the class within our application, either
    as a function argument or by assigning it to a variable, we are really passing
    a reference to where the instance is stored in memory. Since the instance of a
    class may be referenced in multiple scopes (unlike a structure), it cannot be
    automatically destroyed, and memory is not released when it goes out of scope
    because it may be referenced in another scope. Therefore, Swift needs some form
    of memory management to track and release the memory used by instances of classes
    when the class is no longer needed. Swift uses **Automatic Reference Counting**
    (**ARC**) to track and manage memory usage.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，类是引用类型。这意味着我们只为类的实例分配一次内存，即它最初被创建时。当我们在我们应用程序中传递类的实例时，无论是作为函数参数还是通过将其分配给变量，我们实际上是在传递一个指向内存中实例存储位置的引用。由于类的实例可能在多个作用域中被引用（与结构体不同），它不能被自动销毁，当它超出作用域时不会释放内存，因为它可能在另一个作用域中被引用。因此，Swift需要某种形式的内存管理来跟踪和释放当类不再需要时由类的实例使用的内存。Swift使用**自动引用计数**（**ARC**）来跟踪和管理内存使用。
- en: With ARC, for the most part, memory management in Swift simply works. ARC will
    automatically track the references to instances of classes, and when an instance
    is no longer needed (when there are no references pointing to it), ARC will automatically
    destroy the instance and release the memory. There are a few instances where ARC
    requires additional information about relationships to properly manage memory.
    Before we look at the instances where ARC needs help, let's look at how ARC itself
    works.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在ARC中，对于Swift来说，大部分的内存管理工作很简单。ARC会自动跟踪类的实例引用，当一个实例不再需要时（当没有引用指向它时），ARC会自动销毁该实例并释放内存。有一些情况下，ARC需要关于关系的额外信息来正确管理内存。在我们查看ARC需要帮助的情况之前，让我们看看ARC本身是如何工作的。
- en: How ARC works
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ARC 的工作原理
- en: Whenever we create a new instance of a class, **ARC** allocates the memory needed
    to store that instance. This ensures that there is enough memory to store the
    information associated with that instance of the class, and also locks the memory
    so that nothing overwrites it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们创建一个新类的实例时，**ARC**会分配存储该实例所需的内存。这确保了有足够的内存来存储与该类实例相关的信息，并且锁定内存，防止任何内容覆盖它。
- en: When the instance of the class is no longer needed, ARC will release the memory
    allocated for the instance so that it can be used for other purposes. This ensures
    that we are not tying up memory that is no longer needed. It is known as a **memory
    leak** when memory is reserved for instances that are no longer needed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当类的实例不再需要时，ARC将释放为实例分配的内存，以便它可以用于其他目的。这确保了我们不会占用不再需要的内存。当内存被保留给不再需要的实例时，这被称为**内存泄漏**。
- en: If ARC were to release the memory for an instance of a class that is still needed,
    it would not be possible to retrieve the class information from memory. If we
    did try to access the instance of the class after the memory was released, there
    is a possibility that the application would crash or the data would be corrupted.
    To ensure memory is not released for an instance of a class that is still needed,
    ARC counts how many times the instance is referenced; that is, how many active
    properties, variables, or constants are pointing to the instance of the class.
    Once the reference count for an instance of a class equals zero (that is, nothing
    is referencing the instance), the memory is marked for release.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果ARC释放了一个仍然需要的类的实例的内存，那么将无法从内存中检索到类信息。如果我们尝试在内存释放后访问类的实例，应用程序可能会崩溃或数据可能会损坏。为了确保不会释放仍然需要的类的实例的内存，ARC会计算实例被引用的次数；也就是说，有多少活跃的属性、变量或常量指向类的实例。一旦类的实例的引用计数等于零（即没有任何东西引用该实例），内存就会被标记为释放。
- en: 'All the previous examples run properly in a playground; however, the following
    examples will not. When we run sample code in a playground, ARC does not release
    objects that we create; this is by design so that we can see how the application
    runs and also the state of the objects at each step. Therefore, we will need to
    run these samples as an iOS or macOS project. Let''s look at an example of how
    ARC works. We begin by creating a `MyClass` class with the following code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前一个示例都在playground中运行正常；然而，以下示例将不会运行。当我们在一个playground中运行示例代码时，ARC不会释放我们创建的对象；这是设计上的，这样我们就可以看到应用程序的运行情况以及每个步骤中对象的状态。因此，我们需要将这些样本作为一个iOS或macOS项目来运行。让我们看看ARC是如何工作的一个例子。我们首先使用以下代码创建一个`MyClass`类：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this class, we have a `name` property that will be set by an initiator accepting
    a string value. This class also has a deinitializer that is called just before
    an instance of the class is destroyed and removed from memory. This deinitializer
    prints out a message to the console that lets us know that the instance of the
    class is about to be removed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们有一个`name`属性，它将通过接受一个字符串值的初始化器来设置。这个类还有一个在类的实例被销毁并从内存中移除之前被调用的析构器。这个析构器会在控制台打印一条消息，让我们知道类的实例即将被移除。
- en: 'Now, let''s look at the code that shows how ARC creates and destroys instances
    of a class:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看展示ARC如何创建和销毁类实例的代码：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the example, we begin by creating two instances of the `MyClass` class named
    `class1ref1` (which stands for class 1 reference 1) and `class2ref1` (which stands
    for class 2 reference 1). We then create a second reference to `class2ref1` named
    `class2ref2`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先创建了两个名为`class1ref1`（代表类1引用1）和`class2ref1`（代表类2引用1）的`MyClass`类的实例。然后我们为`class2ref1`创建了一个第二个引用，名为`class2ref2`。
- en: Now, in order to see how ARC works, we need to begin setting the references
    to `nil`. We start out by setting `class1ref1` to `nil`. Since there is only one
    reference to `class1ref1`, the deinitializer will be called. Once the deinitializer
    completes its task, in our case it prints a message to the console letting us
    know that the instance of the class has been destroyed and the memory has been
    released.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了看到ARC是如何工作的，我们需要开始将引用设置为`nil`。我们首先将`class1ref1`设置为`nil`。由于只有一个引用指向`class1ref1`，析构器将被调用。一旦析构器完成其任务，在我们的例子中，它会在控制台打印一条消息，让我们知道类的实例已经被销毁，内存已经被释放。
- en: We then set `class2ref1` to `nil`, but there is a second reference to this class
    (`class2ref2`) that prevents ARC from destroying the instance so that the deinitializer
    is not called.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`class2ref1`设置为`nil`，但是这个类有一个第二个引用（`class2ref2`），这阻止了ARC销毁实例，因此不会调用析构器。
- en: Finally, we set `class2ref2` to `nil`, which allows ARC to destroy this instance
    of the `MyClass` class.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`class2ref2`设置为`nil`，这允许ARC销毁这个`MyClass`类的实例。
- en: 'If we run this code, we will see the following output, which illustrates how
    ARC works:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，我们将看到以下输出，它说明了ARC是如何工作的：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: From the example, it seems that ARC handles memory management very well. However,
    it is possible to write code that will prevent ARC from working properly.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从例子中看起来，ARC处理内存管理得很好。然而，有可能编写代码来阻止ARC正常工作。
- en: Strong reference cycles
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强引用循环
- en: 'A **strong reference cycle**, or **strong retain cycle**, is where the instances
    of two classes hold a strong reference to each other, preventing ARC from releasing
    either instance. Once again, we are not able to use a playground for this example,
    so we need to create an Xcode project. In this project, we start off by creating
    two classes named `MyClass1_Strong` and `MyClass2_Strong` with the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**强引用循环**，或称为**强保留循环**，是指两个类的实例相互持有强引用，阻止ARC释放任何一个实例。再次强调，我们无法在这个例子中使用playground，因此我们需要创建一个Xcode项目。在这个项目中，我们首先创建两个名为`MyClass1_Strong`和`MyClass2_Strong`的类，代码如下：'
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we can see from the code, `MyClass1_Strong` contains an instance of `MyClass2_Strong`,
    therefore the instance of `MyClass2_Strong` cannot be released until `MyClass1_Strong`
    is destroyed. We can also see from the code that `MyClass2_Strong` contains an
    instance of `MyClass1_Strong`, therefore, the instance of `MyClass1_Strong` cannot
    be released until `MyClass2_Strong` is destroyed. This creates a cycle of dependency
    in which neither instance can be destroyed until the other one is destroyed.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码中我们可以看出，`MyClass1_Strong`包含了一个`MyClass2_Strong`的实例，因此`MyClass2_Strong`的实例不能被释放，直到`MyClass1_Strong`被销毁。我们还可以从代码中看到，`MyClass2_Strong`包含了一个`MyClass1_Strong`的实例，因此，`MyClass1_Strong`的实例不能被释放，直到`MyClass2_Strong`被销毁。这创建了一个依赖循环，其中两个实例都不能被销毁，直到另一个被销毁。
- en: 'Let''s see how this works by running the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过运行以下代码来看看它是如何工作的：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this example, we create instances of both the `MyClass1_Strong` and `MyClass2_Strong`
    classes. We then set the `class2` property of the `class1` instance to the `MyClass2_Strong`
    instance. We also set the `class1` property of the `class2` instance to the `MyClass1_Strong`
    instance. This means that the `MyClass1_Strong` instance cannot be destroyed until
    the `MyClass2_Strong` instance is destroyed. This means that the reference counters
    for each instance will never reach zero, therefore, ARC cannot destroy the instances,
    producing the following output in this case:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了`MyClass1_Strong`和`MyClass2_Strong`两个类的实例。然后我们将`class1`实例的`class2`属性设置为`MyClass2_Strong`实例。我们还设置了`class2`实例的`class1`属性为`MyClass1_Strong`实例。这意味着`MyClass1_Strong`实例不能被销毁，直到`MyClass2_Strong`实例被销毁。这也意味着每个实例的引用计数器永远不会达到零，因此ARC不能销毁这些实例，在这种情况下会产生以下输出：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This inability to destroy instances creates a memory leak, where an application
    continues to use memory and does not properly release it. This can cause an application
    to eventually crash.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这种无法销毁实例的能力会导致内存泄漏，应用程序继续使用内存而不正确地释放它。这可能导致应用程序最终崩溃。
- en: To resolve a strong reference cycle, we need to prevent one of the classes from
    keeping a strong hold on the instance of the other class, thereby allowing ARC
    to destroy them both. Swift provides two ways of doing this by letting us define
    the properties as either a weak or an unowned reference.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决强引用循环，我们需要防止其中一个类保持对另一个类实例的强引用，从而允许ARC销毁它们。Swift提供了两种方法，允许我们定义属性为弱引用或无所有者引用。
- en: The difference between a weak reference and an unowned reference is that the
    instance that a weak reference refers to can be `nil`, whereas the instance that
    an unowned reference is referring to cannot be `nil`. This means that when we
    use a weak reference, the property must be an optional property. Let's see how
    we would use unowned and weak references to resolve a strong reference cycle.
    Let's start by looking at the unowned reference.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 弱引用和无所有者引用之间的区别是，弱引用所引用的实例可以是`nil`，而无所有者引用所引用的实例不能是`nil`。这意味着当我们使用弱引用时，属性必须是可选属性。让我们看看我们如何使用无所有者和弱引用来解决强引用循环。让我们首先看看无所有者引用。
- en: Unowned references
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无所有者引用
- en: 'We begin by creating two more classes, `MyClass1_Unowned` and `MyClass2_Unowned`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建另外两个类，`MyClass1_Unowned`和`MyClass2_Unowned`：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `MyClass1_Unowned` class looks pretty similar to the `MyClass1_Strong` and
    `MyClass2_Strong` classes in the preceding example. The difference here is the
    `MyClass1_Unowned` class—we set the `class2` property to `unowned`, which means
    it cannot be `nil` and it does not keep a strong reference to the instance that
    it is referring to. Since the `class2` property cannot be nil, we also need to
    set it when the class is initialized.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyClass1_Unowned` 类在先前的示例中看起来与 `MyClass1_Strong` 和 `MyClass2_Strong` 类非常相似。这里的区别在于
    `MyClass1_Unowned` 类——我们将 `class2` 属性设置为 `unowned`，这意味着它不能为 `nil`，并且它不会保持对它所引用的实例的强引用。由于
    `class2` 属性不能为 `nil`，因此我们还需要在类初始化时将其设置。'
- en: 'Let''s see how we can initialize and deinitialize the instances of these classes
    with the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用以下代码初始化和销毁这些类的实例：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we create an instance of the `MyClass_Unowned` class
    and then use that instance to create an instance of the `MyClass1_Unowned` class.
    We then set the `class1` property of the `MyClass2` instance to the `MyClass1_Unowned`
    instance we just created.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个 `MyClass_Unowned` 类的实例，然后使用该实例创建了一个 `MyClass1_Unowned` 类的实例。然后我们将
    `MyClass2` 实例的 `class1` 属性设置为刚刚创建的 `MyClass1_Unowned` 实例。
- en: This creates a reference cycle of dependency between the two classes again,
    but this time, the `MyClass1_Unowned` instance is not keeping a strong hold on
    the `MyClass2_Unowned` instance, allowing ARC to release both instances when they
    are no longer needed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这再次在两个类之间创建了依赖关系的引用循环，但这次 `MyClass1_Unowned` 实例并没有对 `MyClass2_Unowned` 实例保持强引用，允许
    ARC 在不再需要时释放这两个实例。
- en: 'If we run this code, we see the following output, showing that both the `class1`
    and `class2` instances are released, and the memory is freed:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行此代码，我们将看到以下输出，显示 `class1` 和 `class2` 实例都已释放，并且内存已释放：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we can see, both instances are properly released. Now let's look at how we
    would use a weak reference to prevent a strong reference cycle.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，两个实例都得到了适当的释放。现在让我们看看如何使用弱引用来防止强引用循环。
- en: Weak references
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弱引用
- en: 'Once again, we begin by creating two new classes:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次从创建两个新类开始：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `MyClass1_Weak` and `MyClass2_Weak` classes look very similar to the previous
    classes we created that showed how a strong reference cycle works. The difference
    is that we define the `class1` property in the `MyClass2_Weak` class as a weak
    reference.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyClass1_Weak` 和 `MyClass2_Weak` 类与我们在先前的示例中创建的、展示了强引用循环如何工作的类非常相似。区别在于我们在
    `MyClass2_Weak` 类中定义了 `class1` 属性为一个弱引用。'
- en: 'Now, let''s see how we can initialize and deinitialize instances of these classes
    with the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用以下代码初始化和销毁这些类的实例：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code, we create instances of the `MyClass1_Weak` and `MyClass2_Weak`
    classes and then set the properties of those classes to point to the instance
    of the other class. Once again, this creates a cycle of dependency, but since
    we set the `class1` property of the `MyClass2_Weak` class to weak, it does not
    create a strong reference, allowing both instances to be released.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了 `MyClass1_Weak` 和 `MyClass2_Weak` 类的实例，并将这些类的属性设置为指向另一个类的实例。再次，这创建了一个依赖关系的循环，但由于我们将
    `MyClass2_Weak` 类的 `class1` 属性设置为弱引用，它不会创建强引用，允许释放这两个实例。
- en: 'If we run the code, we will see the following output, showing that both the
    `class1_Weak` and `class2_Weak` instances are released and the memory is freed:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行代码，我们将看到以下输出，显示 `class1_Weak` 和 `class2_Weak` 实例都已释放，并且内存已释放：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: On an additional note, a retain cycle for a closure is exactly the same as a
    strong reference cycle; a closure actually is a strong reference by default. We
    would use weak and unowned references to prevent this exactly as explained in
    this chapter, simply by changing the variable that holds an instance of a class
    to hold an instance of a closure.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另外值得一提的是，闭包的保留循环与强引用循环完全相同；闭包默认情况下实际上是一个强引用。我们会使用弱引用和非拥有引用来防止这种情况，正如本章所解释的那样，只需将持有类实例的变量更改为持有闭包实例即可。
- en: It is recommended that you avoid creating circular dependencies, as shown in
    this section, but there are times when you may need them. For those times, remember
    that ARC needs some help to release them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您避免创建循环依赖，正如本节所示，但有时您可能需要它们。在这些情况下，请记住，ARC需要一些帮助来释放它们。
- en: Summary
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explained how ARC works to give you an understanding of
    how memory is managed in your application. We showed what a strong reference cycle
    is and explained how it can cause ARC to fail. We concluded the chapter by showing
    how we can use weak and unowned references to prevent strong reference cycles.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们解释了自动引用计数（ARC）的工作原理，以便您了解应用程序中内存是如何管理的。我们展示了强引用循环是什么，并解释了它如何导致 ARC 失败。我们通过展示如何使用弱引用和非拥有引用来防止强引用循环来结束本章。
- en: In the next chapter, we will look at how to properly format our Swift code for
    consistency and readability.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何正确格式化我们的 Swift 代码以保持一致性和可读性。
