- en: '18'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory Management
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For many years, the primary languages that I used were C and C-based object-oriented
    languages. These languages required a good handle on managing memory and knowing
    when to release memory. Luckily, modern languages like Swift take care of managing
    memory for us. However, it is a good idea to understand how this memory management
    works so we can avoid the pitfalls that cause this memory management to fail.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: How ARC works
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What a strong reference cycle is
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use weak and unowned references to prevent strong reference cycles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we saw in *Chapter 17*, *Custom Value Types*, structures are value types
    and classes are reference types. What this means is that when we pass an instance
    of a structure within our application, such as a parameter of a method, we create
    a new instance of the structure in the memory. This new instance of the structure
    is only valid while the application is in the scope where the structure was created.
    Once the structure goes out of scope, the new instance of the structure is automatically
    destroyed, and the memory is released. This makes the memory management of structures
    very easy and painless.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Classes, on the other hand, are reference types. This means that we allocate
    memory for the instance of the class only once, which is when it is initially
    created. When we pass an instance of the class within our application, either
    as a function argument or by assigning it to a variable, we are really passing
    a reference to where the instance is stored in memory. Since the instance of a
    class may be referenced in multiple scopes (unlike a structure), it cannot be
    automatically destroyed, and memory is not released when it goes out of scope
    because it may be referenced in another scope. Therefore, Swift needs some form
    of memory management to track and release the memory used by instances of classes
    when the class is no longer needed. Swift uses **Automatic Reference Counting**
    (**ARC**) to track and manage memory usage.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: With ARC, for the most part, memory management in Swift simply works. ARC will
    automatically track the references to instances of classes, and when an instance
    is no longer needed (when there are no references pointing to it), ARC will automatically
    destroy the instance and release the memory. There are a few instances where ARC
    requires additional information about relationships to properly manage memory.
    Before we look at the instances where ARC needs help, let's look at how ARC itself
    works.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: How ARC works
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever we create a new instance of a class, **ARC** allocates the memory needed
    to store that instance. This ensures that there is enough memory to store the
    information associated with that instance of the class, and also locks the memory
    so that nothing overwrites it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: When the instance of the class is no longer needed, ARC will release the memory
    allocated for the instance so that it can be used for other purposes. This ensures
    that we are not tying up memory that is no longer needed. It is known as a **memory
    leak** when memory is reserved for instances that are no longer needed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: If ARC were to release the memory for an instance of a class that is still needed,
    it would not be possible to retrieve the class information from memory. If we
    did try to access the instance of the class after the memory was released, there
    is a possibility that the application would crash or the data would be corrupted.
    To ensure memory is not released for an instance of a class that is still needed,
    ARC counts how many times the instance is referenced; that is, how many active
    properties, variables, or constants are pointing to the instance of the class.
    Once the reference count for an instance of a class equals zero (that is, nothing
    is referencing the instance), the memory is marked for release.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'All the previous examples run properly in a playground; however, the following
    examples will not. When we run sample code in a playground, ARC does not release
    objects that we create; this is by design so that we can see how the application
    runs and also the state of the objects at each step. Therefore, we will need to
    run these samples as an iOS or macOS project. Let''s look at an example of how
    ARC works. We begin by creating a `MyClass` class with the following code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this class, we have a `name` property that will be set by an initiator accepting
    a string value. This class also has a deinitializer that is called just before
    an instance of the class is destroyed and removed from memory. This deinitializer
    prints out a message to the console that lets us know that the instance of the
    class is about to be removed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the code that shows how ARC creates and destroys instances
    of a class:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the example, we begin by creating two instances of the `MyClass` class named
    `class1ref1` (which stands for class 1 reference 1) and `class2ref1` (which stands
    for class 2 reference 1). We then create a second reference to `class2ref1` named
    `class2ref2`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Now, in order to see how ARC works, we need to begin setting the references
    to `nil`. We start out by setting `class1ref1` to `nil`. Since there is only one
    reference to `class1ref1`, the deinitializer will be called. Once the deinitializer
    completes its task, in our case it prints a message to the console letting us
    know that the instance of the class has been destroyed and the memory has been
    released.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: We then set `class2ref1` to `nil`, but there is a second reference to this class
    (`class2ref2`) that prevents ARC from destroying the instance so that the deinitializer
    is not called.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set `class2ref2` to `nil`, which allows ARC to destroy this instance
    of the `MyClass` class.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run this code, we will see the following output, which illustrates how
    ARC works:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: From the example, it seems that ARC handles memory management very well. However,
    it is possible to write code that will prevent ARC from working properly.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Strong reference cycles
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **strong reference cycle**, or **strong retain cycle**, is where the instances
    of two classes hold a strong reference to each other, preventing ARC from releasing
    either instance. Once again, we are not able to use a playground for this example,
    so we need to create an Xcode project. In this project, we start off by creating
    two classes named `MyClass1_Strong` and `MyClass2_Strong` with the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we can see from the code, `MyClass1_Strong` contains an instance of `MyClass2_Strong`,
    therefore the instance of `MyClass2_Strong` cannot be released until `MyClass1_Strong`
    is destroyed. We can also see from the code that `MyClass2_Strong` contains an
    instance of `MyClass1_Strong`, therefore, the instance of `MyClass1_Strong` cannot
    be released until `MyClass2_Strong` is destroyed. This creates a cycle of dependency
    in which neither instance can be destroyed until the other one is destroyed.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how this works by running the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this example, we create instances of both the `MyClass1_Strong` and `MyClass2_Strong`
    classes. We then set the `class2` property of the `class1` instance to the `MyClass2_Strong`
    instance. We also set the `class1` property of the `class2` instance to the `MyClass1_Strong`
    instance. This means that the `MyClass1_Strong` instance cannot be destroyed until
    the `MyClass2_Strong` instance is destroyed. This means that the reference counters
    for each instance will never reach zero, therefore, ARC cannot destroy the instances,
    producing the following output in this case:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This inability to destroy instances creates a memory leak, where an application
    continues to use memory and does not properly release it. This can cause an application
    to eventually crash.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: To resolve a strong reference cycle, we need to prevent one of the classes from
    keeping a strong hold on the instance of the other class, thereby allowing ARC
    to destroy them both. Swift provides two ways of doing this by letting us define
    the properties as either a weak or an unowned reference.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: The difference between a weak reference and an unowned reference is that the
    instance that a weak reference refers to can be `nil`, whereas the instance that
    an unowned reference is referring to cannot be `nil`. This means that when we
    use a weak reference, the property must be an optional property. Let's see how
    we would use unowned and weak references to resolve a strong reference cycle.
    Let's start by looking at the unowned reference.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Unowned references
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We begin by creating two more classes, `MyClass1_Unowned` and `MyClass2_Unowned`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `MyClass1_Unowned` class looks pretty similar to the `MyClass1_Strong` and
    `MyClass2_Strong` classes in the preceding example. The difference here is the
    `MyClass1_Unowned` class—we set the `class2` property to `unowned`, which means
    it cannot be `nil` and it does not keep a strong reference to the instance that
    it is referring to. Since the `class2` property cannot be nil, we also need to
    set it when the class is initialized.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can initialize and deinitialize the instances of these classes
    with the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we create an instance of the `MyClass_Unowned` class
    and then use that instance to create an instance of the `MyClass1_Unowned` class.
    We then set the `class1` property of the `MyClass2` instance to the `MyClass1_Unowned`
    instance we just created.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: This creates a reference cycle of dependency between the two classes again,
    but this time, the `MyClass1_Unowned` instance is not keeping a strong hold on
    the `MyClass2_Unowned` instance, allowing ARC to release both instances when they
    are no longer needed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run this code, we see the following output, showing that both the `class1`
    and `class2` instances are released, and the memory is freed:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we can see, both instances are properly released. Now let's look at how we
    would use a weak reference to prevent a strong reference cycle.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Weak references
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once again, we begin by creating two new classes:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `MyClass1_Weak` and `MyClass2_Weak` classes look very similar to the previous
    classes we created that showed how a strong reference cycle works. The difference
    is that we define the `class1` property in the `MyClass2_Weak` class as a weak
    reference.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how we can initialize and deinitialize instances of these classes
    with the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code, we create instances of the `MyClass1_Weak` and `MyClass2_Weak`
    classes and then set the properties of those classes to point to the instance
    of the other class. Once again, this creates a cycle of dependency, but since
    we set the `class1` property of the `MyClass2_Weak` class to weak, it does not
    create a strong reference, allowing both instances to be released.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the code, we will see the following output, showing that both the
    `class1_Weak` and `class2_Weak` instances are released and the memory is freed:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: On an additional note, a retain cycle for a closure is exactly the same as a
    strong reference cycle; a closure actually is a strong reference by default. We
    would use weak and unowned references to prevent this exactly as explained in
    this chapter, simply by changing the variable that holds an instance of a class
    to hold an instance of a closure.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended that you avoid creating circular dependencies, as shown in
    this section, but there are times when you may need them. For those times, remember
    that ARC needs some help to release them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explained how ARC works to give you an understanding of
    how memory is managed in your application. We showed what a strong reference cycle
    is and explained how it can cause ARC to fail. We concluded the chapter by showing
    how we can use weak and unowned references to prevent strong reference cycles.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们解释了自动引用计数（ARC）的工作原理，以便您了解应用程序中内存是如何管理的。我们展示了强引用循环是什么，并解释了它如何导致 ARC 失败。我们通过展示如何使用弱引用和非拥有引用来防止强引用循环来结束本章。
- en: In the next chapter, we will look at how to properly format our Swift code for
    consistency and readability.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何正确格式化我们的 Swift 代码以保持一致性和可读性。
