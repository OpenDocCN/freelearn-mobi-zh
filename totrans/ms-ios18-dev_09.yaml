- en: <st c="0">9</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">9</st>
- en: <st c="1">Creating Dynamic Graphs with Swift Charts</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1">使用Swift Charts创建动态图表</st>
- en: '**<st c="42">Swift Charts</st>** <st c="55">is a framework by Apple that allows</st>
    <st c="91">us to present data in beautiful and expressive charts.</st> <st c="147">Working
    with charts is not a minor topic – data is an essential topic in mobile apps,
    and the ability to show glance information of insights and trends is crucial to
    our app’s</st> <st c="323">user experience.</st>'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="42">Swift Charts</st>** <st c="55">是苹果的一个框架，允许</st> <st c="91">我们以美丽和富有表现力的图表展示数据。</st>
    <st c="147">与图表一起工作不是一个次要的话题——数据是移动应用中的一个基本主题，展示洞察力和趋势的快速信息对于我们的应用</st> <st c="323">用户体验至关重要。</st>'
- en: <st c="339">In this chapter, we will cover the</st> <st c="375">following topics:</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="339">在本章中，我们将涵盖以下主题：</st> <st c="375">以下内容：</st>
- en: <st c="392">Understanding why we need charts in</st> <st c="429">our apps</st>
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="392">了解为什么我们需要在应用中使用图表</st> <st c="429">我们的应用中</st>
- en: <st c="437">Meeting the Swift</st> <st c="456">Charts framework</st>
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="437">了解Swift</st> <st c="456">Charts框架</st>
- en: <st c="472">Creating charts such as bar, line, pie, area, and</st> <st c="523">point
    charts</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="472">创建条形图、折线图、饼图、面积图和</st> <st c="523">点图</st>
- en: <st c="535">Visualizing functions</st> <st c="558">with Charts</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="535">使用图表可视化函数</st> <st c="558">图表</st>
- en: <st c="569">Implementing user interaction to our charts</st> <st c="614">using
    ChartProxy</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="569">使用ChartProxy实现图表的</st> <st c="614">用户交互</st>
- en: <st c="630">Allowing different data types to work with charts by conforming
    to the</st> <st c="702">Plottable protocol</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="630">通过遵循</st> <st c="702">可绘制协议</st>允许不同数据类型与图表一起工作
- en: <st c="720">Before we create our first chart, let’s understand why charts are
    important and what value</st> <st c="812">they bring.</st>
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="720">在我们创建第一个图表之前，让我们了解图表为什么很重要以及它们带来了什么价值。</st>
- en: <st c="823">Technical requirements</st>
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="823">技术要求</st>
- en: <st c="846">For this chapter, you must download Xcode version 15.0 or above
    from Apple’s</st> <st c="924">App Store.</st>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="846">对于本章，您必须从苹果的</st> <st c="924">App Store</st>下载Xcode版本15.0或更高版本。</st>
- en: <st c="934">You’ll also need to run the latest version of macOS (Ventura or
    above).</st> <st c="1007">Simply search for Xcode in the App Store and select
    and download the latest version.</st> <st c="1092">Launch Xcode and follow any
    additional installation instructions that your system may prompt you with.</st>
    <st c="1195">Once Xcode has fully launched, you’re ready</st> <st c="1239">to
    go.</st>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="934">您还需要运行最新的macOS版本（Ventura或更高版本）。</st> <st c="1007">只需在App Store中搜索Xcode，选择并下载最新版本。</st>
    <st c="1092">启动Xcode，并遵循系统可能提示的任何其他安装说明。</st> <st c="1195">一旦Xcode完全启动，您就准备好</st>
    <st c="1239">开始了。</st>
- en: <st c="1245">Download the sample code from the following GitHub</st> <st c="1297">link:</st>
    [<st c="1303">https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter9/Chapter9.swiftpm</st>](https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter9/Chapter9.swiftpm)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1245">从以下GitHub</st> <st c="1297">链接</st>下载示例代码：[<st c="1303">https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter9/Chapter9.swiftpm</st>](https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter9/Chapter9.swiftpm)
- en: <st c="1402">Why charts?</st>
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1402">为什么需要图表？</st>
- en: <st c="1414">The following is not necessarily</st> <st c="1448">a mobile-specific
    section but an important one nevertheless.</st> <st c="1509">Many apps display
    helpful information in a textual way, such as tables, lists, or grids.</st> <st
    c="1598">While displaying information in a list or a grid can be beneficial, it’s
    much harder to tell the story</st> <st c="1701">that way.</st>
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1414">以下内容可能不是</st> <st c="1448">特定于移动端的章节，但仍然非常重要。</st> <st c="1509">许多应用以文本方式显示有用的信息，例如表格、列表或网格。</st>
    <st c="1598">虽然以列表或网格的形式显示信息可能有益，但用这种方式讲述故事要困难得多。</st>
- en: <st c="1710">Users sometimes struggle to process a textual representation of
    information, and visualizing it may help them gain interesting insights and make
    decisions.</st> <st c="1867">There might be different types of insights, which
    can be relationships between data points, trends, and</st> <st c="1971">repeated
    patterns.</st>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1710">用户有时难以处理信息的文本表示，而将其可视化可能有助于他们获得有趣的见解并做出决策。</st> <st c="1867">可能会有不同类型的见解，这些见解可以是数据点之间的关系、趋势和</st>
    <st c="1971">重复的模式。</st>
- en: <st c="1989">Data can be even more difficult to digest on a mobile phone due
    to the screen size and the challenge of presenting information in grids.</st>
    <st c="2127">However, screen size is not the only challenge with mobile phones
    – users often expect to glimpse data insights rather than analyze spreadsheets.</st>
    <st c="2273">A mobile user experience differs from a desktop one because of different
    use cases and behavior.</st> <st c="2370">Due to that difference, charts have
    even greater value on mobile than on desktop apps, as they provide a way to present</st>
    <st c="2490">information visually.</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1989">由于屏幕尺寸和信息在网格中展示的挑战，数据在手机上可能更难消化。</st> <st c="2127">然而，屏幕尺寸并不是手机唯一的挑战——用户通常期望快速了解数据洞察，而不是分析电子表格。</st>
    <st c="2273">移动用户体验与桌面体验不同，因为它们有不同的用例和行为。</st> <st c="2370">由于这种差异，图表在移动应用中的价值甚至比在桌面应用中更大，因为它们提供了一种以视觉方式展示信息的方法。</st>
    <st c="2490">信息。</st>
- en: <st c="2511">Having said that, it is essential not to overuse charts or to use
    charts where a table or a list makes more sense.</st> <st c="2627">For example,
    a banking app that shows the user’s latest transactions would use a list rather
    than a chart.</st> <st c="2734">A list is a great way to present raw data in a
    scannable format that is also interactive and allows users to perform actions
    or view</st> <st c="2867">more details.</st>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2511">尽管如此，避免过度使用图表或在图表比表格或列表更有意义的地方使用图表是至关重要的。</st> <st c="2627">例如，一个显示用户最新交易的银行应用会使用列表而不是图表。</st>
    <st c="2734">列表是一种以可扫描的格式展示原始数据的好方法，它既交互性强，又允许用户执行操作或查看更多细节。</st> <st c="2867">更多信息。</st>
- en: <st c="2880">Just as we have Lists, Tables, and Collection Views, we now have
    Swift Charts, a framework dedicated to presenting data in an informative,</st>
    <st c="3020">visualized way.</st>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2880">正如我们已经有列表、表格和集合视图一样，我们现在有了 Swift Charts，这是一个专门用于以信息丰富、可视化方式展示数据的框架。</st>
    <st c="3020">方式。</st>
- en: <st c="3035">Introducing the Swift Charts framework</st>
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="3035">介绍 Swift Charts 框架</st>
- en: <st c="3074">Creating charts that are simple and easy</st> <st c="3115">to use
    was always a challenge.</st> <st c="3147">Unlike Tables, Collection views, or
    Lists, most third-party chart frameworks</st> <st c="3223">never felt natural</st>
    <st c="3243">in</st> **<st c="3246">UIKit/SwiftUI</st>**<st c="3259">.</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3074">创建简单易用的图表一直是一个挑战。</st> <st c="3115">与表格、集合视图或列表不同，大多数第三方图表框架</st>
    <st c="3223">从未在</st> **<st c="3246">UIKit/SwiftUI</st>**<st c="3259">中感觉自然。</st>
- en: <st c="3260">In iOS 16, Apple announced Swift Charts, a SwiftUI framework that
    presents structured data in a chart and fits</st> <st c="3371">nicely in a</st>
    <st c="3384">SwiftUI view.</st>
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3260">在 iOS 16 中，苹果公司宣布了 Swift Charts，这是一个 SwiftUI 框架，它以图表的形式展示结构化数据，并且非常适合在
    SwiftUI 视图中使用。</st> <st c="3371">很好地</st> <st c="3384">适应了 SwiftUI 视图。</st>
- en: <st c="3397">Let’s see an example of a</st> <st c="3424">bar chart:</st>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3397">让我们看看一个</st> <st c="3424">条形图</st> <st c="3429">的例子：</st>
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="3821">Even though the code example seems long, it is simple to read and
    understand.</st> <st c="3900">This example displays a</st> `<st c="3924">BarMark</st>`
    <st c="3931">chart showing different sales figures for fruits.</st> <st c="3982">It
    has a</st> `<st c="3991">Sales</st>` <st c="3996">structure that contains a single
    sales information for a specific fruit type and a</st> `<st c="4080">data</st>`
    <st c="4084">array that contains sales information about several</st> <st c="4137">fruit
    types.</st>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3821">尽管代码示例看起来很长，但它简单易读易懂。</st> <st c="3900">此示例显示了一个</st> `<st c="3924">BarMark</st>`
    <st c="3931">图表，展示了不同水果的销售数据。</st> <st c="3982">它有一个</st> `<st c="3991">Sales</st>`
    <st c="3996">结构，包含特定水果类型的单一销售信息，以及一个</st> `<st c="4080">data</st>` <st c="4084">数组，包含关于几种</st>
    <st c="4137">水果类型的销售信息。</st>
- en: <st c="4149">In the SwiftUI body part, we add a new view</st> <st c="4193">called</st>
    `<st c="4201">Chart</st>` <st c="4206">with the</st> `<st c="4216">data</st>`
    <st c="4220">array as a parameter.</st> <st c="4243">Inside that</st> `<st c="4255">Chart</st>`
    <st c="4260">view, we add a</st> `<st c="4276">BarMark</st>` <st c="4283">view
    – a way to present data information in bars – passing the</st> `<st c="4347">x</st>`
    <st c="4348">and</st> `<st c="4353">y</st>` <st c="4354">values from our</st>
    `<st c="4371">Sales</st>` <st c="4376">struct.</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4149">在 SwiftUI 的主体部分，我们添加了一个名为</st> <st c="4193">`<st c="4201">Chart</st>`
    <st c="4206">`的新视图，并将</st> `<st c="4216">data</st>` <st c="4220">数组作为参数。</st>
    <st c="4243">在那个</st> `<st c="4255">Chart</st>` <st c="4260">视图中，我们添加了一个</st>
    `<st c="4276">BarMark</st>` <st c="4283">视图——一种以条形展示数据信息的方式——传递来自我们</st> `<st
    c="4371">Sales</st>` <st c="4376">结构体的</st> `<st c="4347">x</st>` <st c="4348">和</st>
    `<st c="4353">y</st>` <st c="4354">值。</st>
- en: '*<st c="4384">Figure 9</st>**<st c="4393">.1</st>* <st c="4395">shows</st>
    <st c="4402">the result:</st>'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="4384">图9</st>**<st c="4393">.1</st>* <st c="4395">显示了结果：</st>'
- en: '![Figure 9.1: A BarMark chart](img/B21795_09_1.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1：条形标记图表](img/B21795_09_1.jpg)'
- en: '<st c="4422">Figure 9.1: A BarMark chart</st>'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4422">图9.1：条形标记图表</st>
- en: '*<st c="4449">Figure 9</st>**<st c="4458">.1</st>* <st c="4460">shows our code
    result—a view with three red bars, including a legend and titles.</st> <st c="4542">We
    can see how much easier it is to create a chart, similar to how we would make
    a</st> `<st c="4625">List</st>` <st c="4629">or a</st> `<st c="4635">VStack</st>`
    <st c="4641">view.</st>'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="4449">图9</st>**<st c="4458">.1</st>* 显示了我们的代码结果——一个包含图例和标题的三个红色条形图视图。<st
    c="4542">我们可以看到创建图表有多容易，就像我们创建</st> `<st c="4625">列表</st>` <st c="4629">或</st>
    `<st c="4635">垂直堆叠</st>` <st c="4641">视图</st>一样。'
- en: <st c="4647">Let’s explore and learn how to create the different chart types
    and understand</st> <st c="4727">their usage.</st>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4647">让我们探索和学习如何创建不同的图表类型，并了解</st> <st c="4727">它们的用法。</st>
- en: <st c="4739">Creating charts</st>
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="4739">创建图表</st>
- en: <st c="4755">Before we continue, let’s understand</st> <st c="4792">the view
    structure of a chart in the Swift Charts framework.</st> <st c="4854">As we can
    see from the last code example, the chart view is</st> <st c="4914">called</st>
    `<st c="4921">Chart</st>`<st c="4926">:</st>
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4755">在我们继续之前，让我们了解</st> <st c="4792">Swift Charts框架中图表的视图结构。</st> <st
    c="4854">正如我们从最后一个代码示例中可以看到的，图表视图被称为</st> `<st c="4921">Chart</st>`<st c="4926">：</st>
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="5014">Each data point</st> <st c="5030">in the chart is called a</st>
    `<st c="5138">BarMark</st>` <st c="5145">type.</st> <st c="5152">If the Chart
    receives an array as a parameter, it performs a</st> `<st c="5213">ForEach</st>`
    <st c="5220">loop under the hood and creates</st> <st c="5253">several marks.</st>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5014">图表中的每个数据点</st> <st c="5030">被称为</st> `<st c="5138">条形标记</st>` <st
    c="5145">类型。</st> <st c="5152">如果图表接收一个数组作为参数，它会在幕后执行一个</st> `<st c="5213">ForEach</st>`
    <st c="5220">循环并创建</st> <st c="5253">几个标记。</st>
- en: <st c="5267">In fact, we could write the same code as</st> <st c="5309">the
    following:</st>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5267">实际上，我们可以编写与以下相同的代码：</st> <st c="5309">：</st>
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="5441">In this code example, we take the same data array as before, iterate
    it using a</st> `<st c="5522">ForEach</st>` <st c="5529">loop, and create a</st>
    `<st c="5549">BarMark</st>` <st c="5556">view for each array item.</st> <st c="5583">This
    example is crucial to understanding how charts are built so we can customize and
    configure</st> <st c="5678">them in</st> <st c="5687">the future.</st>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5441">在这个代码示例中，我们使用之前相同的数据数组，使用一个</st> `<st c="5522">ForEach</st>` <st
    c="5529">循环迭代它，并为每个数组项创建一个</st> `<st c="5549">条形标记</st>` <st c="5556">视图。</st>
    <st c="5583">这个例子对于理解图表是如何构建的至关重要，这样我们就可以在未来自定义和配置</st> <st c="5678">它们。</st>
- en: <st c="5698">Now, let’s explore the</st> `<st c="5722">BarMark</st>` <st c="5729">chart</st>
    <st c="5736">even further.</st>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5698">现在，让我们进一步探索</st> `<st c="5722">条形标记</st>` <st c="5729">图表</st>
    <st c="5736">。</st>
- en: <st c="5749">Creating BarMark chart</st>
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="5749">创建条形标记图表</st>
- en: <st c="5772">We can use a</st> `<st c="5786">BarMark</st>`<st c="5793">-based
    chart</st> <st c="5806">to compare different data points, such as sales figures
    and country population sizes.</st> <st c="5893">We saw how simple creating a chart
    with multiple bar</st> <st c="5946">marks is.</st>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5772">我们可以使用基于</st> `<st c="5786">条形标记</st>`<st c="5793">的图表</st> <st
    c="5806">来比较不同的数据点，例如销售额和各国人口规模。</st> <st c="5893">我们看到了创建具有多个条形标记的图表是多么简单。</st>
- en: <st c="5955">However, implementing a chart with BarMark views doesn’t end here.</st>
    <st c="6023">We have more options to expand that mark to provide even</st> <st
    c="6080">more information.</st>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5955">然而，使用条形标记视图创建图表的工作还没有结束。</st> <st c="6023">我们还有更多选项来扩展这个标记，以提供更多信息。</st>
- en: <st c="6097">We’ll start with a stacked</st> <st c="6125">bar chart.</st>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6097">我们将从一个堆叠的条形图开始。</st>
- en: <st c="6135">Adding Stacked Marks</st>
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="6135">添加堆叠标记</st>
- en: <st c="6156">Standard marks represent two-dimensional data</st> <st c="6202">points,
    comparing one value to another.</st> <st c="6243">Sometimes, datasets may have
    a deeper story, as each bar may be constructed from</st> <st c="6324">several
    values.</st>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6156">标准标记代表二维数据点，比较一个值与另一个值。</st> <st c="6202">有时，数据集可能有一个更深层的故事，因为每个条形可能由几个值组成。</st>
- en: <st c="6339">For example, let’s take the sales chart we have just created and
    discuss the sales of apples.</st> <st c="6434">The current value of apple sales
    is 50 items.</st> <st c="6480">Perhaps we want to display how this value is divided
    between green and red apples.</st> <st c="6563">In this case, we can use a</st>
    <st c="6590">stacked mark.</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们拿我们刚刚创建的销售图表来讨论苹果的销售情况。</st> <st c="6434">苹果销售当前值为50件。</st> <st c="6480">也许我们想展示这个值是如何在绿色和红色苹果之间分配的。</st>
    <st c="6563">在这种情况下，我们可以使用</st> <st c="6590">堆叠标记。</st>
- en: <st c="6603">We will now add a stacked bar to our</st> <st c="6641">existing
    chart.</st>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6603">现在，我们将向我们的</st> <st c="6641">现有图表</st> 添加一个堆叠条形图。
- en: <st c="6656">First, we need to adjust</st> <st c="6681">our</st> `<st c="6686">Sales</st>`
    <st c="6691">structure to contain our</st> <st c="6717">fr</st><st c="6719">uit
    color:</st>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6656">首先，我们需要调整</st> <st c="6681">我们的</st> `<st c="6686">Sales</st>`
    <st c="6691">结构以包含我们的</st> <st c="6717">fruit color：</st>
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="6845">Now that we have added a</st> `<st c="6870">fruitColor</st>` <st
    c="6880">property to the</st> `<st c="6897">Sales</st>` <st c="6902">structure,
    we can update</st> <st c="6928">our dataset:</st>
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6845">现在，我们已经向</st> `<st c="6870">fruitColor</st>` <st c="6880">属性添加到</st>
    `<st c="6897">Sales</st>` <st c="6902">结构中，我们可以更新</st> <st c="6928">我们的数据集：</st>
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="7153">Currently, our updated dataset</st> <st c="7184">has two records
    related to apple sales, each containing the</st> <st c="7245">color sold.</st>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7153">目前，我们的更新后的数据集</st> <st c="7184">有两个与苹果销售相关的记录，每个记录都包含</st> <st
    c="7245">销售的颜色。</st>
- en: <st c="7256">Now that we have all the data that we need, let’s create a chart
    and assign each of the properties to the right role in</st> <st c="7377">the chart:</st>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7256">现在我们已经有了所有需要的数据，让我们创建一个图表并将每个属性分配给图表中的正确角色：</st>
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="7523">In this code example, the only difference we have is the</st> `<st
    c="7580">foregroundStyle</st>` <st c="7595">view modifier, which helps distinguish
    between the different fruit colors.</st> <st c="7671">Let’s see the result in</st>
    *<st c="7695">Figure 9</st>**<st c="7703">.2</st>*<st c="7705">:</st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7523">在这个代码示例中，我们唯一的不同之处在于</st> `<st c="7580">foregroundStyle</st>` <st
    c="7595">视图修改器，它有助于区分不同的水果颜色。</st> <st c="7671">让我们看看</st> *<st c="7695">图9</st>**<st
    c="7703">.2</st>*<st c="7705">的结果。</st>
- en: '![Figure 9.2: Stacked bar view](img/B21795_09_2.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2：堆叠条形图视图](img/B21795_09_2.jpg)'
- en: '<st c="7712">Figure 9.2: Stacked bar view</st>'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7712">图9.2：堆叠条形图视图</st>
- en: <st c="7740">In</st> *<st c="7744">Figure 9</st>**<st c="7752">.2</st>*<st c="7754">,
    we can see that the apples bar is built from two types of values.</st> <st c="7822">The
    blue represents green apples, and the green represents</st> <st c="7881">red apples.</st>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7740">在</st> *<st c="7744">图9</st>**<st c="7752">.2</st>*<st c="7754">中，我们可以看到苹果条形图是由两种类型的值构建的。</st>
    <st c="7822">蓝色代表绿色苹果，绿色代表</st> <st c="7881">红色苹果。</st>
- en: <st c="7892">We saw that when we add several marks</st> <st c="7930">with the
    same</st> *<st c="7945">x</st>* <st c="7946">values, the Charts framework knows
    how to stack</st> <st c="7995">them together.</st>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7892">我们看到了当我们添加具有相同</st> <st c="7930">x</st> <st c="7945">值的几个标记时，图表框架知道如何将它们堆叠在一起。</st>
- en: <st c="8009">Next, let’s see what happens when we don’t add</st> *<st c="8057">y</st>*
    <st c="8058">values to our</st> <st c="8073">data set.</st>
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8009">接下来，让我们看看当我们没有向我们的</st> *<st c="8057">y</st>* <st c="8058">值添加数据时会发生什么。</st>
- en: <st c="8082">Adding 1D bar marks</st>
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="8082">添加一维条形标记</st>
- en: <st c="8102">Most charts are two-dimensional, meaning</st> <st c="8143">they
    have an</st> *<st c="8157">x</st>* <st c="8158">and</st> *<st c="8163">y</st>*
    <st c="8164">axis that</st> <st c="8174">compares different data categories.</st>
    <st c="8211">However, we can focus on one category (meaning the chart will have
    only one</st> *<st c="8287">y</st>* <st c="8288">axis value) and create a</st>
    <st c="8314">one-dimensional chart.</st>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8102">大多数图表都是二维的，这意味着</st> <st c="8143">它们有一个</st> *<st c="8157">x</st>*
    <st c="8158">和</st> *<st c="8163">y</st>* <st c="8164">轴，用于比较不同的数据类别。</st> <st
    c="8211">然而，我们可以专注于一个类别（这意味着图表将只有一个</st> *<st c="8287">y</st>* <st c="8288">轴值）并创建一个</st>
    <st c="8314">一维图表。</st>
- en: <st c="8336">For instance, let’s take the apple category from the previous example
    and try to create a 1D bar based</st> <st c="8440">on it.</st>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8336">例如，让我们从上一个例子中的苹果类别开始，并尝试基于它创建一个一维条形图。</st> <st c="8440">。</st>
- en: <st c="8446">First, let’s enrich our data and add</st> `<st c="8484">Yellow</st>`
    <st c="8490">as an additional</st> <st c="8508">fruit color:</st>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8446">首先，让我们丰富我们的数据，并添加</st> `<st c="8484">黄色</st>` <st c="8490">作为额外的</st>
    <st c="8508">水果颜色：</st>
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="8714">Our dataset now includes</st> <st c="8738">the</st> `<st c="8743">Green</st>`<st
    c="8748">,</st> `<st c="8750">Red</st>`<st c="8753">, and</st> `<st c="8759">Yellow</st>`
    <st c="8765">fruit</st> <st c="8771">colors.</st>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8714">我们的数据集现在包括</st> <st c="8738">的</st> `<st c="8743">绿色</st>`<st c="8748">、</st>
    `<st c="8750">红色</st>`<st c="8753">，和</st> `<st c="8759">黄色</st>` <st c="8765">水果</st>
    <st c="8771">颜色。</st>
- en: <st c="8779">Next, let’s create our chart, but this time, we won’t define</st>
    <st c="8841">the</st> *<st c="8845">y</st>*<st c="8846">-axis:</st>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8779">接下来，让我们创建我们的图表，但这次，我们不会定义</st> <st c="8841">的</st> *<st c="8845">y</st>*<st
    c="8846">-轴：</st>
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="8957">In this code example, we passed only the</st> `<st c="8999">x</st>`
    `<st c="9000">BarMark</st>` <st c="9007">parameter.</st> <st c="9019">However,
    if we examine the</st> `<st c="9046">BarMark</st>` <st c="9053">header, we can
    see that there’s a method that requires only the</st> `<st c="9118">x</st>` <st
    c="9119">parameter:</st>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8957">在这个代码示例中，我们只传递了</st> `<st c="8999">x</st>` `<st c="9000">BarMark</st>`
    <st c="9007">参数。</st> <st c="9019">然而，如果我们检查</st> `<st c="9046">BarMark</st>`
    <st c="9053">标题，我们可以看到有一个只需要</st> `<st c="9118">x</st>` <st c="9119">参数的方法：</st>
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Chart(data) {
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Chart(data) {
- en: BarMark(
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: BarMark(
- en: 'x: .value("Qty", $0.qty)'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'x: .value("Qty", $0.qty)'
- en: )
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: )
- en: '.foregroundStyle(by: .value("Color",'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '.foregroundStyle(by: .value("Color",'
- en: $0.fruitColor))
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: $0.fruitColor))
- en: '} <st c="10118">.chartForegroundStyleScale(["Green" :</st>'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '} <st c="10118">.chartForegroundStyleScale(["Green" :</st>'
- en: '<st c="10155">Color.green, "Red" : Color.red,</st>'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="10155">Color.green, "Red" : Color.red,</st>'
- en: <st c="10218">chartForegroundStyleScale</st> function is a view modifier we
    can apply to the Chart and different <st c="10312">ShapeStyle</st> protocol to
    different values. In this case, we use colors that reflect the fruit colors and
    improve clarity.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10218">chartForegroundStyleScale</st>函数是一个我们可以应用于Chart和不同<st c="10312">ShapeStyle</st>协议的视图修改器。在这种情况下，我们使用反映水果颜色的颜色并提高清晰度。
- en: '*<st c="10431">Figure 9</st>**<st c="10440">.4</st>* <st c="10442">shows how
    the chart looks now that we matched the colors to</st> <st c="10503">the names:</st>'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*<st c="10431">图9</st>**<st c="10440">.4</st>* <st c="10442">显示了如何将颜色匹配到</st>
    <st c="10503">名称后图表的外观：</st>'
- en: '![Figure 9.4: A 1D chart with custom colors](img/B21795_09_4.jpg)'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图9.4：具有自定义颜色的1D图表](img/B21795_09_4.jpg)'
- en: '<st c="10547">Figure 9.4: A 1D chart with custom colors</st>'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="10547">图9.4：具有自定义颜色的1D图表</st>
- en: <st c="10588">We can use</st> `<st c="10600">chartForegroundStyleScale</st>`
    <st c="10625">not only for 1D charts but also for all other types</st> <st c="10678">of
    charts.</st>
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="10588">我们可以使用</st> `<st c="10600">chartForegroundStyleScale</st>` <st
    c="10625">不仅适用于1D图表，也适用于所有其他类型的</st> <st c="10678">图表。</st>
- en: <st c="10688">We saw how</st> <st c="10699">to use BarMarks</st> <st c="10715">for
    stacked and one-dimensional marks.</st> <st c="10755">Yet another way we can use
    BarMarks is for interval</st> <st c="10807">bar charts.</st>
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="10688">我们看到了如何</st> <st c="10699">使用BarMarks</st> <st c="10715">进行堆叠和一维标记。</st>
    <st c="10755">另一种我们可以使用BarMarks的方法是用于区间</st> <st c="10807">条形图。</st>
- en: <st c="10818">Adding interval bar charts</st>
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="10818">添加区间条形图</st>
- en: <st c="10845">We use</st> **<st c="10853">interval bar charts</st>** <st c="10872">to
    represent data grouped</st> <st c="10898">into intervals, such</st> <st c="10920">as
    periods, age groups, o</st><st c="10945">r</st> <st c="10948">numerical ranges.</st>
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="10845">我们使用</st> **<st c="10853">区间条形图</st>** <st c="10872">来表示按区间分组的数据，例如</st>
    <st c="10898">时期、年龄组、或</st> <st c="10920">数值范围。</st>
- en: <st c="10965">For example, let’s say we want to display a list of workers and
    the time intervals they worked throughout</st> <st c="11072">the day.</st>
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="10965">例如，假设我们想显示一份工人及其在一天中工作的时间间隔的列表。</st>
- en: <st c="11080">First, let’s create a data set that represents a list of</st>
    <st c="11138">working periods:</st>
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="11080">首先，让我们创建一个表示一系列</st> <st c="11138">工作时段的数据集：</st>
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <st c="11610">Each item in the</st> `<st c="11628">data</st>` <st c="11632">array
    represents one employee’s working period.</st> <st c="11681">Notice that we don’t
    care about the item’s order—the Charts framework is responsible for ordering them
    correctly.</st> <st c="11795">However, we care about consistency with the employee’s
    name, so the Charts framework can also properly group</st> <st c="11904">the items.</st>
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="11610">数据</st> `<st c="11628">数组中的每个项目</st>` <st c="11632">代表一名员工的工时。</st>
    <st c="11681">请注意，我们并不关心项目的顺序——Charts框架负责正确地排序它们。</st> <st c="11795">然而，我们关心与员工姓名的一致性，因此Charts框架也可以正确地</st>
    <st c="11904">分组</st> <st c="11905">这些项目。</st>
- en: <st c="11914">Let’s see how we can build</st> <st c="11941">an interval chart
    based</st> <st c="11965">on</st> <st c="11969">that dataset:</st>
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="11914">让我们看看我们如何基于</st> <st c="11941">那个数据集</st> <st c="11965">构建</st>
    <st c="11969">一个区间图表：</st>
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <st c="12114">In this code example, we create a BarMark initializer that includes
    new parameters—</st>`<st c="12198">xStart</st>`<st c="12205">, which represents
    the value where the interval begins,</st> `<st c="12261">xEnd</st>`<st c="12265">,
    detailing where it ends, and</st> `<st c="12296">y</st>`<st c="12297">, the</st>
    <st c="12303">employee’s name.</st>
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="12114">在这个代码示例中，我们创建了一个包含新参数的BarMark初始化器——</st>`<st c="12198">xStart</st>`<st
    c="12205">，它表示区间开始的价值，</st> `<st c="12261">xEnd</st>`<st c="12265">，详细说明它结束的位置，以及</st>
    `<st c="12296">y</st>`<st c="12297">，员工的姓名。</st>
- en: <st c="12319">Now, let’s see how an interval chart looks when we run it (</st>*<st
    c="12379">Figure 9</st>**<st c="12388">.5</st>*<st c="12390">):</st>
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="12319">现在，让我们看看当我们运行它时区间图表看起来像什么（</st>*<st c="12379">图9</st>**<st c="12388">.5</st>*<st
    c="12390">）：</st>
- en: '![Figure 9.5: An interval chart](img/B21795_09_5.jpg)'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图9.5：一个区间图表](img/B21795_09_5.jpg)'
- en: '<st c="12444">Figure 9.5: An interval chart</st>'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="12444">图9.5：一个区间图表</st>
- en: <st c="12473">In</st> *<st c="12477">Figure 9</st>**<st c="12485">.5</st>*<st
    c="12487">, we can see a timeline when each of the employees is represented in
    a row, and their working periods are interva</st><st c="12600">ls in this timeline.</st>
    <st c="12622">The interval bar chart is an excellent example of a component that
    can be complex to build from the ground up, and the Charts framework can simplify</st>
    <st c="12771">the process.</st>
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="12473">在</st> *<st c="12477">图9</st>**<st c="12485">.5</st>*<st c="12487">中，我们可以看到一个时间线，其中每个员工都代表一行，他们的工作周期是这个时间线中的</st><st
    c="12600">区间。</st> <st c="12622">区间条形图是一个复杂的组件的例子，从头开始构建可能很复杂，而Charts框架可以简化</st>
    <st c="12771">这个过程。</st>
- en: <st c="12783">BarMark seems like a very flexible chart type, and that’s part
    of the reason it is so common.</st> <st c="12878">It allows us to present different
    information types, whether comparing values or different trends over time, in
    stacked, one-dimensional, or</st> <st c="13019">interval layouts.</st>
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="12783">BarMark看起来是一个非常灵活的图表类型，这也是它如此常见的原因之一。</st> <st c="12878">它允许我们展示不同类型的信息，无论是比较值还是随时间变化的不同趋势，在堆叠、一维或</st>
    <st c="13019">区间布局中。</st>
- en: <st c="13036">However, sometimes, it’s a better choice</st> <st c="13077">to
    pick a more specific chart</st> <st c="13107">that expresses data</st> <st c="13128">more
    precisely.</st>
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="13036">然而，有时，选择一个更具体的图表</st> <st c="13077">来更精确地表达数据</st> <st c="13107">可能是一个更好的选择。</st>
- en: <st c="13143">So, let’s me</st><st c="13156">et the</st> <st c="13164">LineMark
    chart.</st>
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="13143">所以，让我</st><st c="13156">们设置</st> <st c="13164">LineMark图表。</st>
- en: <st c="13179">Creating LineMark charts</st>
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="13179">创建LineMark图表</st>
- en: <st c="13204">One of the challenges of presenting data</st> <st c="13245">in
    a table is showing trends and patterns.</st> <st c="13289">Even though the BarMark
    chart type can do that better than a table, there are better ways to show trends,
    especially when dealing with a large amount</st> <st c="13439">of information.</st>
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="13204">在表格中展示数据的一个挑战是展示趋势和模式。</st> <st c="13245">尽管BarMark图表类型比表格做得更好，但还有更好的方法来展示趋势，尤其是在处理大量</st>
    <st c="13439">信息时。</st>
- en: <st c="13454">To show trends and patterns more efficiently, we can use the LineMark
    chart, which represents data using a line representing a list of</st> <st c="13590">data
    points.</st>
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="13454">为了更有效地展示趋势和模式，我们可以使用LineMark图表，它使用表示一系列</st> <st c="13590">数据点的线来表示数据。</st>
- en: <st c="13602">Let’s take, for example, a chart that shows phone sales over time.</st>
    <st c="13670">We create a structure named</st> `<st c="13698">SalesFigure</st>`
    <st c="13709">that contains information about the product type, the day of the
    sales, and the</st> <st c="13790">total amount:</st>
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="13602">让我们以一个显示随时间变化的手机销售图表为例。</st> <st c="13670">我们创建了一个名为</st> `<st
    c="13698">SalesFigure</st>` <st c="13709">的结构</st>，其中包含有关产品类型、销售日期和</st> <st c="13790">总金额的信息：</st>
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <st c="13915">Now that we have a structure, let’s create</st> <st c="13958">our
    dataset like we did in all</st> <st c="13990">previous examples:</st>
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="13915">现在我们有了结构，让我们创建</st> <st c="13958">我们的数据集，就像我们在所有</st> <st c="13990">之前的示例中所做的那样：</st>
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <st c="14450">The</st> `<st c="14455">salesFigures</st>` <st c="14467">variable
    contains information</st> <st c="14497">about four days of sales.</st> <st c="14524">The
    LineMark chart is suitable for working with many entries, but we use only four
    for</st> <st c="14611">demonstration purposes.</st>
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="14450">`salesFigures`</st> <st c="14455">变量包含有关四天销售的信息。</st> <st c="14467">LineMark图表适合处理多个条目，但我们只使用四个进行</st>
    <st c="14611">演示目的。</st>
- en: <st c="14634">Now, let’s connect the</st> `<st c="14658">salesFigures</st>`
    <st c="14670">variable to a chart using the</st> `<st c="14701">LinkMark</st>`
    <st c="14709">view:</st>
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="14634">现在，让我们使用</st> `<st c="14658">salesFigures</st>` <st c="14670">变量通过</st>
    `<st c="14701">LinkMark</st>` <st c="14709">视图连接到一个图表：</st>
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <st c="14809">We created a LineMark inside the chart, setting the day as the</st>
    *<st c="14872">x</st>* <st c="14873">axis and the amount as the</st> *<st c="14901">y</st>*
    <st c="14902">axis.</st> <st c="14909">Running that code should show us a chart
    that looks like</st> *<st c="14966">Figure 9</st>**<st c="14974">.6</st>*<st c="14976">:</st>
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="14809">我们在图表内创建了一个LineMark，将日期设置为</st> *<st c="14872">x</st>* <st c="14873">轴，数量设置为</st>
    *<st c="14901">y</st>* <st c="14902">轴。</st> <st c="14909">运行此代码应显示一个类似于</st>
    *<st c="14966">图9</st>**<st c="14974">.6</st>*<st c="14976">:</st>
- en: '![Figure 9.6: A LineMark chart](img/B21795_09_6.jpg)'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图9.6：一个LineMark图表](img/B21795_09_6.jpg)'
- en: '<st c="15010">Figure 9.6: A LineMark chart</st>'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="15010">图9.6：一个LineMark图表</st>
- en: <st c="15038">The chart in</st> *<st c="15052">Figure 9</st>**<st c="15060">.6</st>*
    <st c="15062">shows the declining trend of phone sales over the dataset period.</st>
    <st c="15129">What’s nice about line charts is that it’s easy to compare one LineMark
    to another.</st> <st c="15213">All we need to do is to update our dataset.</st>
    <st c="15257">So, let’s also add tablet sales to compare it with</st> <st c="15308">phone
    sales:</st>
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="15038">图</st> *<st c="15052">9</st>**<st c="15060">.6</st>* <st c="15062">显示了数据集期间手机销售的下降趋势。</st>
    <st c="15129">关于折线图的好处是，它很容易比较一个LineMark与另一个。</st> <st c="15213">我们只需要更新我们的数据集。</st>
    <st c="15257">因此，让我们也添加平板电脑销售以与</st> <st c="15308">手机销售进行比较：</st>
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: <st c="15771">In this code example, we updated</st> <st c="15804">our dataset
    by adding tablet sales figures items to</st> <st c="15856">the array.</st>
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="15771">在这个代码示例中，我们通过向数组中添加平板电脑销售数据项来更新</st> <st c="15804">我们的数据集。</st>
- en: <st c="15866">To make the chart distinct between the two product types, we use
    the</st> `<st c="15936">foregroundStyle</st>` <st c="15951">view modifier:</st>
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="15866">为了使图表在两种产品类型之间区分开来，我们使用</st> `<st c="15936">foregroundStyle</st>`
    <st c="15951">视图修饰符：</st>
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'let data: [FavoriteFruit] = ['
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 'let data: [最喜欢的水果] = ['
- en: 'FavoriteFruit(name: "Apple", value: 30),'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最喜欢的水果（名称："Apple"，价值：30）,
- en: 'FavoriteFruit(name: "Banana", value: 25),'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最喜欢的水果（名称："Banana"，价值：25）,
- en: 'FavoriteFruit(name: "Orange", value: 20),'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最喜欢的水果（名称："Orange"，价值：20）,
- en: 'FavoriteFruit(name: "Strawberries", value: 15),'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最喜欢的水果（名称："Strawberries"，价值：15）,
- en: 'FavoriteFruit(name: "Grapes", value: 10)'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最喜欢的水果（名称："Grapes"，价值：10）
- en: ']'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ']'
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Chart(data) {item in <st c="18384">SectorMark(angle: .value("Value", item.value))</st>
    .foregroundStyle(by: .value("Fruit",'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '图表（数据）{item in <st c="18384">扇形标记（角度：.value("Value", item.value))</st> .foregroundStyle(by:
    .value("Fruit",'
- en: item.name))
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: item.name))
- en: '}'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Chart(data) {item in
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图表（数据）{item in
- en: 'SectorMark(angle: .value("Value", item.value), <st c="19020">innerRadius: 50</st>)'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 扇形标记（角度：.value("Value", item.value)，<st c="19020">内半径：50</st>）
- en: '.foregroundStyle(by: .value("Fruit", item.name))'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '.foregroundStyle(by: .value("Fruit", item.name))'
- en: '}'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Chart(salesFigures) { data in <st c="20522">AreaMark</st>(
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图表（销售数据）{ data in <st c="20522">AreaMark</st>(
- en: 'x: .value("Date", data.day),'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'x: .value("Date", data.day),'
- en: 'y: .value("Sales", data.amount)'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'y: .value("Sales", data.amount)'
- en: )
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: )
- en: '.foregroundStyle(by: .value("Product",'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '.foregroundStyle(by: .value("Product",'
- en: data.product))
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: data.product))
- en: '}'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'struct StudentData: Identifiable {'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 'struct StudentData: Identifiable {'
- en: 'var id: UUID = UUID()'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var id: UUID = UUID()'
- en: 'var hoursStudied: Double'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var hoursStudied: Double'
- en: 'var examScore: Double'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var examScore: Double'
- en: '}'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'let studentDataSet: [StudentData] = ['
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 'let studentDataSet: [StudentData] = ['
- en: 'StudentData(hoursStudied: 1.7, examScore: 61.8),'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 学生数据（学习时长：1.7小时，考试成绩：61.8分）,
- en: 'StudentData(hoursStudied: 7.9, examScore: 78.6),'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 学生数据（学习时长：7.9小时，考试成绩：78.6分）,
- en: 'StudentData(hoursStudied: 4.1, examScore: 44.3),'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 学生数据（学习时长：4.1小时，考试成绩：44.3分）,
- en: 'StudentData(hoursStudied: 4.7, examScore: 63.4),'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 学生数据（学习时长：4.7小时，考试成绩：63.4分）,
- en: 'StudentData(hoursStudied: 7.8, examScore: 90.4),'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 学生数据（学习时长：7.8小时，考试成绩：90.4分）,
- en: 'StudentData(hoursStudied: 8.6, examScore: 83.2),'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 学生数据（学习时长：8.6小时，考试成绩：83.2分）,
- en: 'StudentData(hoursStudied: 2.8, examScore: 29.7),'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 学生数据（学习时长：2.8小时，考试成绩：29.7分）,
- en: 'StudentData(hoursStudied: 6.3, examScore: 72.9),'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 学生数据（学习时长：6.3小时，考试成绩：72.9分）,
- en: 'StudentData(hoursStudied: 6.4, examScore: 73.8),'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 学生数据（学习时长：6.4小时，考试成绩：73.8分）,
- en: 'StudentData(hoursStudied: 6.1, examScore: 77.6)'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`)`'
- en: ']'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="28753">chartOverlay</st> view modifier in this code example.` '
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Chart(studentDataSet) { <st c="22979">PointMark(x: .value("hours", $0.hoursStudied),</st>'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="29988">图 9.14：图表和 chartOverlay 结构</st>`'
- en: '<st c="23025">y: .value("score", $0.examScore))</st> }'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="23025">y: .value("score", $0.examScore))</st>` }'
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Chart { <st c="24633">LinePlot</st>(x:"x", y:"y") { x in
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: return sin(x)
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`return sin(x)`'
- en: '}'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Chart { <st c="25162">AreaPlot</st>(x:"x", y:"y") { x in`'
- en: '}'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chart(studentDataSet) { <st c="22979">PointMark(x: .value("hours", $0.hoursStudied),`'
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Chart { <st c="25162">AreaPlot</st>(x:"x", y:"y") { x in
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`y: .value("amount", $0.amount)`'
- en: return sin(x)
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`return sin(x)`'
- en: '}'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`.foregroundStyle(by: .value("Product",`'
- en: '}'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Chart(salesFigures){
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chart(salesFigures){}`'
- en: LineMark(
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="29629">我们将根据用户的</st>` `<st c="29680">点击位置</st>` '
- en: 'x: .value("time", $0.day),'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`x: .value("time", $0.day),`'
- en: 'y: .value("amount", $0.amount)'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`]`'
- en: )
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`}`'
- en: '.foregroundStyle(by: .value("Product",'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="28801">我们可以看到</st>` `<st c="28818">chartOverlay</st>` `<st c="28830">附带了一个</st>`
    `<st c="28844">代理</st>` `<st c="28849">变量，它就是之前讨论过的</st>` `<st c="28873">ChartProxy</st>`
    `<st c="28883">组件。</st>`'
- en: $0.product))
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$0.product))`'
- en: '} <st c="28644">.chartOverlay { proxy in</st>'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="28644">.chartOverlay { proxy in`'
- en: <st c="28753">chartOverlay</st> view modifier in this code example.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`StudentData(hoursStudied: 6.1, examScore: 77.6)`'
- en: <st c="28801">We can see that</st> `<st c="28818">chartOverlay</st>` <st c="28830">comes
    with a</st> `<st c="28844">proxy</st>` <st c="28849">variable, which is the</st>
    `<st c="28873">ChartProxy</st>` <st c="28883">component we</st> <st c="28897">discussed
    earlier.</st>
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`LineMark(`'
- en: '`<st c="28915">ChartOverlay</st>` <st c="28928">is not a view but a view modifier
    that lets us add new views to the chart.</st> <st c="29004">So, to recognize gestures
    and add a ruler, we can add a transparent view with a drag gesture and add a</st>
    <st c="29107">ruler view:</st>'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="28915">ChartOverlay</st>` `<st c="28928">不是一个视图，而是一个视图修饰符，它允许我们在图表中添加新的视图。</st>`
    `<st c="29004">因此，为了识别手势并添加一个仪表，我们可以添加一个带有拖动手势的透明视图，并添加一个</st>` `<st c="29107">仪表视图：</st>`'
- en: '[PRE24]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: <st c="29420">In this code example, we added a</st> `<st c="29454">ZStack</st>`
    <st c="29460">view with a clear rectangle that covers the whole chart and, on
    top of it, a red ruler view.</st> <st c="29554">The ruler view</st> *<st c="29569">x</st>*
    <st c="29570">axis is a</st> <st c="29581">state variable:</st>
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Chart { <st c="24633">LinePlot</st>(x:"x", y:"y") { x in`'
- en: '[PRE25]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: <st c="29629">We are going to change it according to the user’s</st> <st c="29680">tap
    locations.</st>
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`![图 9.14：图表和 chartOverlay 结构](img/B21795_09_14.jpg)`'
- en: <st c="29694">Notice that we used our</st> `<st c="29719">proxy</st>` <st c="29724">object
    to determine</st> <st c="29744">the chart size for the ruler view.</st> <st c="29780">This
    is crucial proxy</st> <st c="29801">usage, as we will need it on other occasions,
    such as calculations for displaying different views in</st> <st c="29903">particular
    locations.</st>
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="29420">在这个代码示例中，我们添加了一个</st>` `<st c="29454">ZStack</st>` `<st c="29460">视图，它有一个清晰的矩形覆盖整个图表，在其上方是一个红色的仪表视图。</st>`
    `<st c="29554">仪表视图</st>` `<st c="29569">x</st>` `<st c="29570">轴是一个</st>` `<st
    c="29581">状态变量：</st>`'
- en: <st c="29924">To see our view structure, look at</st> *<st c="29960">Figure
    9</st>**<st c="29968">.14</st>*<st c="29971">:</st>
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="29924">要查看我们的视图结构，请看</st>` `<st c="29960">图</st>**<st c="29968">9</st>**<st
    c="29971">.14</st>` `<st c="29971">：</st>`'
- en: '![Figure 9.14: Chart and chartOverlay structures](img/B21795_09_14.jpg)'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '`<st c="30310">响应用户的手势</st>`'
- en: '<st c="29988">Figure 9.14: Chart and chartOverlay structures</st>'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`}`'
- en: '*<st c="30034">Figure 9</st>**<st c="30043">.14</st>* <st c="30046">shows our
    chart view and the rectangle we added using the</st> `<st c="30105">chartOverlay</st>`
    <st c="30117">view modifier.</st> <st c="30133">We can also see that they are
    connected using the</st> <st c="30183">proxy object.</st>'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="30034">图</st>**<st c="30043">9</st>**<st c="30046">.14</st>` `<st c="30046">显示了我们的图表视图和通过</st>`
    `<st c="30105">chartOverlay</st>` `<st c="30117">视图修饰符添加的矩形。</st>` `<st c="30133">我们还可以看到它们是通过</st>`
    `<st c="30183">代理对象连接的。</st>`'
- en: <st c="30196">Also, we added</st> <st c="30211">a drag gesture</st> <st c="30226">to
    the rectangle.</st> <st c="30245">Let’s see how to use it to change our ruler</st>
    <st c="30289">position accordingly.</st>
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="30196">此外，我们还添加了</st>` `<st c="30211">一个拖动手势</st>` `<st c="30226">到矩形上。</st>`
    `<st c="30245">让我们看看如何使用它来相应地改变我们的仪表</st>` `<st c="30289">位置。</st>`'
- en: <st c="30310">Responding to the user’s gesture</st>
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="29694">注意，我们使用了我们的</st>` `<st c="29719">代理</st>` `<st c="29724">对象来确定</st>`
    `<st c="29744">仪表视图的图表大小。</st>` `<st c="29780">这是一个关键的代理</st>` `<st c="29801">使用，因为我们还需要在其他场合使用它，例如在特定位置显示不同视图的计算。</st>`'
- en: <st c="30343">To respond to the user’s gesture</st> <st c="30376">and move the
    horizontal ruler to the closest data point, we need to implement the</st> `<st
    c="30459">onChanged</st>` <st c="30468">closure:</st>
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="30343">为了响应用户的手势</st>` `<st c="30376">并将水平仪表移动到最接近的数据点，我们需要实现</st>`
    `<st c="30459">onChanged</st>` `<st c="30468">闭包：</st>`'
- en: '[PRE26]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: <st c="30689">The</st> `<st c="30694">onChanged</st>` <st c="30703">closure
    implementation does</st> <st c="30732">three things:</st>
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="30689">The</st> `<st c="30694">onChanged</st>` <st c="30703">closure
    implementation does</st> <st c="30732">three things:</st>
- en: <st c="30745">First, it</st> *<st c="30756">finds the closest sales data point</st>*
    <st c="30790">according to the tap location and the proxy.</st> <st c="30836">We
    will go over the</st> `<st c="30856">getClosestDateForLocation</st>` <st c="30881">function
    in</st> <st c="30894">a minute.</st>
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="30745">首先，它</st> *<st c="30756">根据点击位置和代理找到最近的销售额数据点</st>* <st c="30790">。
    <st c="30836">我们将在一分钟内介绍</st> `<st c="30856">getClosestDateForLocation</st>` <st
    c="30881">函数。</st>
- en: <st c="30903">After we found the closest sales data point according to the tap
    location, we used the proxy object to</st> *<st c="31007">retrieve its position</st>*
    <st c="31028">on the chart.</st> <st c="31043">One of the proxy’s capabilities
    is to convert data points to position and</st> <st c="31117">vice versa.</st>
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="30903">在我们根据点击位置找到最近的销售数据点后，我们使用代理对象来</st> *<st c="31007">检索它在图表上的位置</st>*
    <st c="31028">。 <st c="31043">代理的一个功能是将数据点转换为位置，反之亦然。</st>
- en: <st c="31128">When we have the position of the closest data point, we adjust
    the ruler location by setting the</st> `<st c="31226">markerX</st>` <st c="31233">state
    variable.</st>
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="31128">当我们获得最近的数据点位置时，我们通过设置</st> `<st c="31226">markerX</st>` <st c="31233">状态变量</st>来调整尺子位置。
- en: <st c="31249">This piece of code is a good</st> <st c="31278">demonstration
    of what we can do with the</st> <st c="31320">proxy object.</st>
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="31249">这段代码是使用代理对象可以做什么的一个很好的</st> <st c="31278">示例。</st>
- en: <st c="31333">For more proxy object usage, let’s see the</st> `<st c="31377">getClosestDateForLocation</st>`
    <st c="31402">function.</st>
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="31333">有关代理对象的使用，让我们看看</st> `<st c="31377">getClosestDateForLocation</st>`
    <st c="31402">函数。</st>
- en: <st c="31412">Finding the closest data point to the user’s touch</st>
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="31412">找到用户触摸点最近的数据点</st>
- en: <st c="31463">The</st> `<st c="31468">getClosestDateForLocation</st>` <st c="31493">function
    goal</st> <st c="31507">is to find the closest date with a data point according
    to a</st> <st c="31569">specific position.</st>
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="31463">`<st c="31468">getClosestDateForLocation</st>` <st c="31493">`函数的目标是</st>
    <st c="31507">根据一个特定的位置找到最近的数据点。</st> <st c="31569">`根据一个特定的位置找到最近的数据点。</st>
- en: <st c="31587">The function receives two parameters – the position (</st>`<st
    c="31641">CGFloat</st>`<st c="31649">) and the</st> <st c="31660">proxy object:</st>
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="31587">该函数接收两个参数 - 位置（</st>`<st c="31641">CGFloat</st>`<st c="31649">）和</st>
    <st c="31660">代理对象：</st>
- en: '[PRE27]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: <st c="32079">Remember what our chart looks like – the</st> *<st c="32121">y</st>*
    <st c="32122">axis represents the timeline, and the</st> *<st c="32161">x</st>*
    <st c="32162">axis represents the total sales on a</st> <st c="32200">specific
    date.</st>
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="32079">记住我们的图表看起来像什么 -</st> *<st c="32121">y</st>* <st c="32122">轴代表时间线，而</st>
    *<st c="32161">x</st>* <st c="32162">轴代表特定日期的总销售额。</st>
- en: <st c="32214">So, we can use the proxy object to find the date for a specific</st>
    `<st c="32279">x</st>` <st c="32280">value, and that’s our</st> <st c="32303">first
    step:</st>
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="32214">因此，我们可以使用代理对象来找到特定</st> `<st c="32279">x</st>` <st c="32280">值的日期，这是我们</st>
    <st c="32303">的第一步：</st>
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: <st c="32359">The proxy’s</st> `<st c="32371">value(atX:)</st>` <st c="32382">function
    calculates the date value for a specific</st> `<st c="32433">x</st>` <st c="32434">value.</st>
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="32359">代理的</st> `<st c="32371">value(atX:)</st>` <st c="32382">函数计算特定</st>
    `<st c="32433">x</st>` <st c="32434">值的日期值。</st>
- en: <st c="32441">However, the returned value is arbitrary; to locate the closest
    data point, we must iterate through our dataset and search for the nearest</st>
    `<st c="32581">SalesFigure</st>` <st c="32592">object.</st> <st c="32601">Once
    identified, the function can then</st> <st c="32640">return it.</st>
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="32441">然而，返回的值是任意的；为了定位最近的数据点，我们必须遍历我们的数据集并搜索最近的</st> `<st c="32581">SalesFigure</st>`
    <st c="32592">对象。</st> <st c="32601">一旦确定，函数就可以返回它。</st>
- en: <st c="32650">Even though allowing user interaction</st> <st c="32688">with
    charts is not complex, it includes interesting view modifiers and objects that
    enable us to access the chart data, perform calculations, and display overlay
    UI components.</st> <st c="32866">We don’t have to use the</st> `<st c="32891">proxy</st>`
    <st c="32896">object and the</st> `<st c="32912">chartOverlay</st>` <st c="32924">view
    modifier just for interaction—we can show additional information, improve the
    chart design, and, in rare cases, even create</st> <st c="33054">our chart.</st>
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="32650">尽管允许用户与图表交互并不复杂，但它包括一些有趣的视图修改器和对象，使我们能够访问图表数据，执行计算，并显示叠加 UI 组件。</st>
    <st c="32866">我们不必仅仅为了交互而使用</st> `<st c="32891">代理</st>` <st c="32896">对象和</st>
    `<st c="32912">chartOverlay</st>` <st c="32924">视图修改器——我们可以显示更多信息，改进图表设计，在罕见的情况下，甚至可以</st>
    <st c="33054">创建自己的图表。</st>
- en: <st c="33064">Until now, we used data sets with foundation types –</st> `<st
    c="33118">String</st>`<st c="33124">,</st> `<st c="33126">Double</st>`<st c="33132">,
    and</st> `<st c="33138">Date</st>`<st c="33142">. However, when we look at the
    Swift Charts framework headers, we see</st> <st c="33212">something interesting:</st>
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="33064">到目前为止，我们使用的是具有基础类型的数据集 –</st> `<st c="33118">String</st>`<st c="33124">,</st>
    `<st c="33126">Double</st>`<st c="33132">, 和</st> `<st c="33138">Date</st>`<st
    c="33142">。然而，当我们查看 Swift Charts 框架的头文件时，我们发现</st> <st c="33212">一些有趣的东西：</st>
- en: '[PRE29]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: <st c="33415">It seems that the different chart functions</st> <st c="33458">only
    work with types that conform to the</st> `<st c="33500">Plottable</st>` <st c="33509">protocol.</st>
    <st c="33520">Let’s find out what</st> <st c="33540">that is.</st>
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="33415">似乎不同的图表函数</st> <st c="33458">只与符合</st> `<st c="33500">Plottable</st>`
    <st c="33509">协议的类型一起工作。</st> <st c="33520">让我们来看看</st> <st c="33540">那是什么。</st>
- en: <st c="33548">Conforming to the Plottable protocol</st>
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="33548">符合 Plottable 协议</st>
- en: <st c="33585">Until now, we have been under the assumption</st> <st c="33630">that
    any data set we threw on our charts would work.</st> <st c="33684">However, we
    saw that the proxy object can perform interesting calculations that are not possible
    with any data, and that’s only one reason why our data types need to support the
    ability to be drawn in</st> <st c="33885">a chart.</st>
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="33585">到目前为止，我们一直假设</st> <st c="33630">我们抛到图表上的任何数据集都会工作。</st> <st c="33684">然而，我们发现代理对象可以执行一些有趣的计算，而这些计算用任何数据都是不可能完成的，这也是我们数据类型需要支持在</st>
    <st c="33885">图表中绘制能力的原因之一。</st>
- en: <st c="33893">Therefore, the Swift Charts framework only works with data types
    that conform to the</st> `<st c="33979">Plottable</st>` <st c="33988">protocol,
    which allows data to be drawn in</st> <st c="34032">a chart.</st>
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="33893">因此，Swift Charts 框架只与符合</st> `<st c="33979">Plottable</st>` <st
    c="33988">协议的数据类型一起工作，这允许数据在</st> <st c="34032">图表中绘制。</st>
- en: <st c="34040">First, every primitive data type already conforms to the</st>
    `<st c="34098">Plottable</st>` <st c="34107">protocol.</st> <st c="34118">Also,
    the</st> `<st c="34128">Date</st>` <st c="34132">class that we used in our last
    example conforms to the</st> `<st c="34188">Plottable</st>` <st c="34197">protocol.</st>
    <st c="34208">We can even see that in the apple</st> <st c="34242">header files:</st>
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="34040">首先，每个原始数据类型已经符合</st> `<st c="34098">Plottable</st>` <st c="34107">协议。</st>
    <st c="34118">此外，我们在上一个示例中使用的</st> `<st c="34128">Date</st>` <st c="34132">类也符合</st>
    `<st c="34188">Plottable</st>` <st c="34197">协议。</st> <st c="34208">我们甚至可以在苹果</st>
    <st c="34242">头文件中看到这一点：</st>
- en: '[PRE30]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: <st c="34367">However, working only with primitive or Foundation types is not</st>
    <st c="34432">always practical.</st>
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="34367">然而，仅与原始类型或 Foundation 类型一起工作并不</st> <st c="34432">总是实用。</st>
- en: <st c="34449">Let’s take, for example, our</st> `<st c="34479">Sales</st>` <st
    c="34484">structure from the</st> *<st c="34504">Adding Stacked</st>* *<st c="34519">Marks</st>*
    <st c="34524">section:</st>
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="34449">以，例如，我们的</st> `<st c="34479">Sales</st>` <st c="34484">结构体</st>
    从 *<st c="34504">Adding Stacked</st>* *<st c="34519">Marks</st>* <st c="34524">部分：</st>
- en: '[PRE31]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: <st c="34648">Declaring the</st> `<st c="34662">itemType</st>` <st c="34670">property
    as a string</st> <st c="34691">is not always a best practice.</st> <st c="34723">Typically,
    types are part of a closed list, and using strings may lead to typos and duplicates.</st>
    <st c="34819">We probably would like to use an enum for that, as it</st> <st c="34872">is
    more suitable for handling a list</st> <st c="34910">of types:</st>
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="34648">将</st> `<st c="34662">itemType</st>` <st c="34670">属性声明为字符串</st>
    <st c="34691">并不总是最佳实践。</st> <st c="34723">通常，类型是封闭列表的一部分，使用字符串可能会导致拼写错误和重复。</st>
    <st c="34819">我们可能更愿意使用枚举，因为它</st> <st c="34872">更适合处理类型列表：</st>
- en: '[PRE32]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: <st c="35098">In this example, we created a</st> `<st c="35129">FruitType</st>`
    <st c="35138">enum to replace the</st> `<st c="35159">itemType</st>` <st c="35167">type</st>
    <st c="35173">from</st> `<st c="35178">String</st>`<st c="35184">.</st>
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="35098">在这个例子中，我们创建了一个</st> `<st c="35129">FruitType</st>` <st c="35138">枚举来替换来自
    `<st c="35178">String</st>` 的</st> `<st c="35159">itemType</st>` <st c="35167">类型。</st>
- en: <st c="35185">Our next step is to make the</st> `<st c="35215">FruitType</st>`
    <st c="35224">enum conform</st> <st c="35238">to</st> `<st c="35241">Plottable</st>`<st
    c="35250">:</st>
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="35185">我们的下一步是使</st> `<st c="35215">FruitType</st>` <st c="35224">枚举符合</st>
    `<st c="35241">Plottable</st>`<st c="35250">:</st>
- en: '[PRE33]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: <st c="35332">In this example, we used the</st> `<st c="35362">primitivePlottable</st>`
    <st c="35380">variable getter to return the type’s primitive value.</st> <st c="35435">That
    would make the</st> `<st c="35455">FruitType</st>` <st c="35464">type eligible
    to be used</st> <st c="35490">inside Charts.</st>
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="35332">在这个例子中，我们使用了</st> `<st c="35362">primitivePlottable</st>` <st
    c="35380">变量获取器来返回类型的原始值。</st> <st c="35435">这将使</st> `<st c="35455">FruitType</st>`
    <st c="35464">类型有资格在 Charts 中使用。</st>
- en: <st c="35504">Even though not every type can be used</st> <st c="35543">inside
    a chart, we can easily make them eligible for that.</st> <st c="35603">Conforming
    to the</st> `<st c="35621">Plottable</st>` <st c="35630">protocol is simple and
    straightforward and allows us to use our custom-made types</st> <st c="35713">within
    charts.</st>
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="35504">尽管不是每种类型都可以在图表中使用，但我们可以轻松地使它们有资格。</st> <st c="35543">遵守</st> `<st
    c="35621">Plottable</st>` <st c="35630">协议既简单又直接，并允许我们在图表中使用自定义类型。</st> <st c="35713">这样，我们就可以在我们的图表中使用几乎任何我们想要的数据类型。</st>
- en: <st c="35727">Summary</st>
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="35727">总结</st>
- en: <st c="35735">The Swift Charts framework is exciting.</st> <st c="35776">It
    allows us to create amazing-looking charts using a simple data set, making it
    much easier to display data insights, trends,</st> <st c="35903">and comparisons.</st>
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="35735">Swift Charts 框架非常令人兴奋。</st> <st c="35776">它允许我们使用简单的数据集创建令人惊叹的图表，这使得展示数据洞察、趋势和比较变得容易得多。</st>
- en: <st c="35919">This chapter reviewed the different chart types of the Swift Charts
    framework, including BarMark, LineMark, SectorMark, AreaMark,</st> <st c="36050">and
    PointMark.</st>
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="35919">本章回顾了 Swift Charts 框架的不同图表类型，包括 BarMark、LineMark、SectorMark、AreaMark
    和 PointMark。</st>
- en: <st c="36064">We also discussed each chart’s different usage and goals, learned
    how to customize them, and added user interaction to add more capabilities.</st>
    <st c="36207">At last, we went over the</st> `<st c="36233">Plottable</st>` <st
    c="36242">protocol, which allows our charts to use almost any data type we want.</st>
    <st c="36314">By now, we should be able to implement charts in our</st> <st c="36367">apps
    quickly.</st>
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="36064">我们还讨论了每个图表的不同用途和目标，学习了如何自定义它们，并添加了用户交互以增加更多功能。</st> <st c="36207">最后，我们回顾了</st>
    `<st c="36233">Plottable</st>` <st c="36242">协议，它允许我们的图表使用几乎任何我们想要的数据类型。</st>
    <st c="36314">到目前为止，我们应该能够快速在我们的</st> <st c="36367">应用中实现图表。</st>
- en: <st c="36380">Our next chapter includes an advanced yet very powerful topic
    –</st> <st c="36445">Swift macros.</st>
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="36380">我们的下一章包括一个高级但非常强大的主题——</st> <st c="36445">Swift 宏。</st>
- en: '[PRE34]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '<st c="0">Part 2: Refine your iOS Development with Advanced Techniques</st>'
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">第二部分：使用高级技术完善你的 iOS 开发</st>
- en: <st c="61">In this part, you will step up your iOS development and explore advanced
    topics, such as Swift macros, testing, Combine, architectures,</st> **<st c="198">machine
    learning</st>** <st c="214">(</st>**<st c="216">ML</st>**<st c="218">), and AI.</st>
    <st c="230">This part is a must-read if you want to get the most from</st> <st
    c="288">iOS 18.</st>
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="61">在本部分，你将提升你的 iOS 开发技能，并探索高级主题，如 Swift 宏、测试、Combine、架构、**<st c="198">机器学习</st>**（**<st
    c="216">ML</st>**<st c="218">）和 AI。</st> <st c="230">如果你想要充分利用 iOS 18，这部分内容是必读的。</st>
- en: <st c="295">This section contains the</st> <st c="322">following chapters:</st>
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="295">本节包含以下章节：</st>
- en: '[*<st c="341">Chapter 10</st>*](B21795_10.xhtml#_idTextAnchor329)<st c="352">,</st>
    *<st c="354">Swift Macros</st>*'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*<st c="341">第 10 章</st>*](B21795_10.xhtml#_idTextAnchor329)<st c="352">，*<st
    c="354">Swift 宏</st>* '
- en: '[*<st c="367">Chapter 11</st>*](B21795_11.xhtml#_idTextAnchor346)<st c="377">,</st>
    *<st c="379">Creating Pipelines with Combine</st>*'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*<st c="367">第 11 章</st>*](B21795_11.xhtml#_idTextAnchor346)<st c="377">，*<st
    c="379">使用 Combine 创建管道</st>* '
- en: '[*<st c="411">Chapter 12</st>*](B21795_12.xhtml#_idTextAnchor369)<st c="421">,</st>
    *<st c="423">Being Smart with Apple Intelligence and ML</st>*'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*<st c="411">第 12 章</st>*](B21795_12.xhtml#_idTextAnchor369)<st c="421">，*<st
    c="423">利用 Apple 智能和 ML 变得聪明</st>* '
- en: '[*<st c="466">Chapter 13</st>*](B21795_13.xhtml#_idTextAnchor401)<st c="476">,</st>
    *<st c="478">Exposing Your App to Siri with App Intents</st>*'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*<st c="466">第13章</st>*](B21795_13.xhtml#_idTextAnchor401)<st c="476">,</st>
    *<st c="478">通过应用意图将您的应用暴露给Siri</st>*'
- en: '[*<st c="521">Chapter 14</st>*](B21795_14.xhtml#_idTextAnchor430)<st c="531">,</st>
    *<st c="533">Improving the App Quality with Swift Testing</st>*'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*<st c="521">第14章</st>*](B21795_14.xhtml#_idTextAnchor430)<st c="531">,</st>
    *<st c="533">使用Swift测试提高应用质量</st>*'
- en: '[*<st c="577">Chapter 15</st>*](B21795_15.xhtml#_idTextAnchor463)<st c="588">,</st>
    *<st c="590">Exploring Architectures for iOS</st>*'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*<st c="577">第15章</st>*](B21795_15.xhtml#_idTextAnchor463)<st c="588">,</st>
    *<st c="590">探索iOS架构</st>*'
