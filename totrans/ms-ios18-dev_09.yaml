- en: <st c="0">9</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1">Creating Dynamic Graphs with Swift Charts</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**<st c="42">Swift Charts</st>** <st c="55">is a framework by Apple that allows</st>
    <st c="91">us to present data in beautiful and expressive charts.</st> <st c="147">Working
    with charts is not a minor topic – data is an essential topic in mobile apps,
    and the ability to show glance information of insights and trends is crucial to
    our app’s</st> <st c="323">user experience.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="339">In this chapter, we will cover the</st> <st c="375">following topics:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="392">Understanding why we need charts in</st> <st c="429">our apps</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="437">Meeting the Swift</st> <st c="456">Charts framework</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="472">Creating charts such as bar, line, pie, area, and</st> <st c="523">point
    charts</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="535">Visualizing functions</st> <st c="558">with Charts</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="569">Implementing user interaction to our charts</st> <st c="614">using
    ChartProxy</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="630">Allowing different data types to work with charts by conforming
    to the</st> <st c="702">Plottable protocol</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="720">Before we create our first chart, let’s understand why charts are
    important and what value</st> <st c="812">they bring.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="823">Technical requirements</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="846">For this chapter, you must download Xcode version 15.0 or above
    from Apple’s</st> <st c="924">App Store.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="934">You’ll also need to run the latest version of macOS (Ventura or
    above).</st> <st c="1007">Simply search for Xcode in the App Store and select
    and download the latest version.</st> <st c="1092">Launch Xcode and follow any
    additional installation instructions that your system may prompt you with.</st>
    <st c="1195">Once Xcode has fully launched, you’re ready</st> <st c="1239">to
    go.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1245">Download the sample code from the following GitHub</st> <st c="1297">link:</st>
    [<st c="1303">https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter9/Chapter9.swiftpm</st>](https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter9/Chapter9.swiftpm)
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1402">Why charts?</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1414">The following is not necessarily</st> <st c="1448">a mobile-specific
    section but an important one nevertheless.</st> <st c="1509">Many apps display
    helpful information in a textual way, such as tables, lists, or grids.</st> <st
    c="1598">While displaying information in a list or a grid can be beneficial, it’s
    much harder to tell the story</st> <st c="1701">that way.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1710">Users sometimes struggle to process a textual representation of
    information, and visualizing it may help them gain interesting insights and make
    decisions.</st> <st c="1867">There might be different types of insights, which
    can be relationships between data points, trends, and</st> <st c="1971">repeated
    patterns.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1989">Data can be even more difficult to digest on a mobile phone due
    to the screen size and the challenge of presenting information in grids.</st>
    <st c="2127">However, screen size is not the only challenge with mobile phones
    – users often expect to glimpse data insights rather than analyze spreadsheets.</st>
    <st c="2273">A mobile user experience differs from a desktop one because of different
    use cases and behavior.</st> <st c="2370">Due to that difference, charts have
    even greater value on mobile than on desktop apps, as they provide a way to present</st>
    <st c="2490">information visually.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2511">Having said that, it is essential not to overuse charts or to use
    charts where a table or a list makes more sense.</st> <st c="2627">For example,
    a banking app that shows the user’s latest transactions would use a list rather
    than a chart.</st> <st c="2734">A list is a great way to present raw data in a
    scannable format that is also interactive and allows users to perform actions
    or view</st> <st c="2867">more details.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2880">Just as we have Lists, Tables, and Collection Views, we now have
    Swift Charts, a framework dedicated to presenting data in an informative,</st>
    <st c="3020">visualized way.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3035">Introducing the Swift Charts framework</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="3074">Creating charts that are simple and easy</st> <st c="3115">to use
    was always a challenge.</st> <st c="3147">Unlike Tables, Collection views, or
    Lists, most third-party chart frameworks</st> <st c="3223">never felt natural</st>
    <st c="3243">in</st> **<st c="3246">UIKit/SwiftUI</st>**<st c="3259">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3260">In iOS 16, Apple announced Swift Charts, a SwiftUI framework that
    presents structured data in a chart and fits</st> <st c="3371">nicely in a</st>
    <st c="3384">SwiftUI view.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3397">Let’s see an example of a</st> <st c="3424">bar chart:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: <st c="3821">Even though the code example seems long, it is simple to read and
    understand.</st> <st c="3900">This example displays a</st> `<st c="3924">BarMark</st>`
    <st c="3931">chart showing different sales figures for fruits.</st> <st c="3982">It
    has a</st> `<st c="3991">Sales</st>` <st c="3996">structure that contains a single
    sales information for a specific fruit type and a</st> `<st c="4080">data</st>`
    <st c="4084">array that contains sales information about several</st> <st c="4137">fruit
    types.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4149">In the SwiftUI body part, we add a new view</st> <st c="4193">called</st>
    `<st c="4201">Chart</st>` <st c="4206">with the</st> `<st c="4216">data</st>`
    <st c="4220">array as a parameter.</st> <st c="4243">Inside that</st> `<st c="4255">Chart</st>`
    <st c="4260">view, we add a</st> `<st c="4276">BarMark</st>` <st c="4283">view
    – a way to present data information in bars – passing the</st> `<st c="4347">x</st>`
    <st c="4348">and</st> `<st c="4353">y</st>` <st c="4354">values from our</st>
    `<st c="4371">Sales</st>` <st c="4376">struct.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="4384">Figure 9</st>**<st c="4393">.1</st>* <st c="4395">shows</st>
    <st c="4402">the result:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: A BarMark chart](img/B21795_09_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="4422">Figure 9.1: A BarMark chart</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="4449">Figure 9</st>**<st c="4458">.1</st>* <st c="4460">shows our code
    result—a view with three red bars, including a legend and titles.</st> <st c="4542">We
    can see how much easier it is to create a chart, similar to how we would make
    a</st> `<st c="4625">List</st>` <st c="4629">or a</st> `<st c="4635">VStack</st>`
    <st c="4641">view.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4647">Let’s explore and learn how to create the different chart types
    and understand</st> <st c="4727">their usage.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4739">Creating charts</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="4755">Before we continue, let’s understand</st> <st c="4792">the view
    structure of a chart in the Swift Charts framework.</st> <st c="4854">As we can
    see from the last code example, the chart view is</st> <st c="4914">called</st>
    `<st c="4921">Chart</st>`<st c="4926">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: <st c="5014">Each data point</st> <st c="5030">in the chart is called a</st>
    `<st c="5138">BarMark</st>` <st c="5145">type.</st> <st c="5152">If the Chart
    receives an array as a parameter, it performs a</st> `<st c="5213">ForEach</st>`
    <st c="5220">loop under the hood and creates</st> <st c="5253">several marks.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5267">In fact, we could write the same code as</st> <st c="5309">the
    following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: <st c="5441">In this code example, we take the same data array as before, iterate
    it using a</st> `<st c="5522">ForEach</st>` <st c="5529">loop, and create a</st>
    `<st c="5549">BarMark</st>` <st c="5556">view for each array item.</st> <st c="5583">This
    example is crucial to understanding how charts are built so we can customize and
    configure</st> <st c="5678">them in</st> <st c="5687">the future.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5698">Now, let’s explore the</st> `<st c="5722">BarMark</st>` <st c="5729">chart</st>
    <st c="5736">even further.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5749">Creating BarMark chart</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="5772">We can use a</st> `<st c="5786">BarMark</st>`<st c="5793">-based
    chart</st> <st c="5806">to compare different data points, such as sales figures
    and country population sizes.</st> <st c="5893">We saw how simple creating a chart
    with multiple bar</st> <st c="5946">marks is.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5955">However, implementing a chart with BarMark views doesn’t end here.</st>
    <st c="6023">We have more options to expand that mark to provide even</st> <st
    c="6080">more information.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6097">We’ll start with a stacked</st> <st c="6125">bar chart.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6135">Adding Stacked Marks</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="6156">Standard marks represent two-dimensional data</st> <st c="6202">points,
    comparing one value to another.</st> <st c="6243">Sometimes, datasets may have
    a deeper story, as each bar may be constructed from</st> <st c="6324">several
    values.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6339">For example, let’s take the sales chart we have just created and
    discuss the sales of apples.</st> <st c="6434">The current value of apple sales
    is 50 items.</st> <st c="6480">Perhaps we want to display how this value is divided
    between green and red apples.</st> <st c="6563">In this case, we can use a</st>
    <st c="6590">stacked mark.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6603">We will now add a stacked bar to our</st> <st c="6641">existing
    chart.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6656">First, we need to adjust</st> <st c="6681">our</st> `<st c="6686">Sales</st>`
    <st c="6691">structure to contain our</st> <st c="6717">fr</st><st c="6719">uit
    color:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: <st c="6845">Now that we have added a</st> `<st c="6870">fruitColor</st>` <st
    c="6880">property to the</st> `<st c="6897">Sales</st>` <st c="6902">structure,
    we can update</st> <st c="6928">our dataset:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: <st c="7153">Currently, our updated dataset</st> <st c="7184">has two records
    related to apple sales, each containing the</st> <st c="7245">color sold.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7256">Now that we have all the data that we need, let’s create a chart
    and assign each of the properties to the right role in</st> <st c="7377">the chart:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: <st c="7523">In this code example, the only difference we have is the</st> `<st
    c="7580">foregroundStyle</st>` <st c="7595">view modifier, which helps distinguish
    between the different fruit colors.</st> <st c="7671">Let’s see the result in</st>
    *<st c="7695">Figure 9</st>**<st c="7703">.2</st>*<st c="7705">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2: Stacked bar view](img/B21795_09_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="7712">Figure 9.2: Stacked bar view</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7740">In</st> *<st c="7744">Figure 9</st>**<st c="7752">.2</st>*<st c="7754">,
    we can see that the apples bar is built from two types of values.</st> <st c="7822">The
    blue represents green apples, and the green represents</st> <st c="7881">red apples.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7892">We saw that when we add several marks</st> <st c="7930">with the
    same</st> *<st c="7945">x</st>* <st c="7946">values, the Charts framework knows
    how to stack</st> <st c="7995">them together.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8009">Next, let’s see what happens when we don’t add</st> *<st c="8057">y</st>*
    <st c="8058">values to our</st> <st c="8073">data set.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8082">Adding 1D bar marks</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="8102">Most charts are two-dimensional, meaning</st> <st c="8143">they
    have an</st> *<st c="8157">x</st>* <st c="8158">and</st> *<st c="8163">y</st>*
    <st c="8164">axis that</st> <st c="8174">compares different data categories.</st>
    <st c="8211">However, we can focus on one category (meaning the chart will have
    only one</st> *<st c="8287">y</st>* <st c="8288">axis value) and create a</st>
    <st c="8314">one-dimensional chart.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8336">For instance, let’s take the apple category from the previous example
    and try to create a 1D bar based</st> <st c="8440">on it.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8446">First, let’s enrich our data and add</st> `<st c="8484">Yellow</st>`
    <st c="8490">as an additional</st> <st c="8508">fruit color:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: <st c="8714">Our dataset now includes</st> <st c="8738">the</st> `<st c="8743">Green</st>`<st
    c="8748">,</st> `<st c="8750">Red</st>`<st c="8753">, and</st> `<st c="8759">Yellow</st>`
    <st c="8765">fruit</st> <st c="8771">colors.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8779">Next, let’s create our chart, but this time, we won’t define</st>
    <st c="8841">the</st> *<st c="8845">y</st>*<st c="8846">-axis:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: <st c="8957">In this code example, we passed only the</st> `<st c="8999">x</st>`
    `<st c="9000">BarMark</st>` <st c="9007">parameter.</st> <st c="9019">However,
    if we examine the</st> `<st c="9046">BarMark</st>` <st c="9053">header, we can
    see that there’s a method that requires only the</st> `<st c="9118">x</st>` <st
    c="9119">parameter:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Chart(data) {
  prefs: []
  type: TYPE_NORMAL
- en: BarMark(
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'x: .value("Qty", $0.qty)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '.foregroundStyle(by: .value("Color",'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: $0.fruitColor))
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '} <st c="10118">.chartForegroundStyleScale(["Green" :</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '<st c="10155">Color.green, "Red" : Color.red,</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10218">chartForegroundStyleScale</st> function is a view modifier we
    can apply to the Chart and different <st c="10312">ShapeStyle</st> protocol to
    different values. In this case, we use colors that reflect the fruit colors and
    improve clarity.
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="10431">Figure 9</st>**<st c="10440">.4</st>* <st c="10442">shows how
    the chart looks now that we matched the colors to</st> <st c="10503">the names:</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.4: A 1D chart with custom colors](img/B21795_09_4.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: '<st c="10547">Figure 9.4: A 1D chart with custom colors</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="10588">We can use</st> `<st c="10600">chartForegroundStyleScale</st>`
    <st c="10625">not only for 1D charts but also for all other types</st> <st c="10678">of
    charts.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="10688">We saw how</st> <st c="10699">to use BarMarks</st> <st c="10715">for
    stacked and one-dimensional marks.</st> <st c="10755">Yet another way we can use
    BarMarks is for interval</st> <st c="10807">bar charts.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="10818">Adding interval bar charts</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="10845">We use</st> **<st c="10853">interval bar charts</st>** <st c="10872">to
    represent data grouped</st> <st c="10898">into intervals, such</st> <st c="10920">as
    periods, age groups, o</st><st c="10945">r</st> <st c="10948">numerical ranges.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="10965">For example, let’s say we want to display a list of workers and
    the time intervals they worked throughout</st> <st c="11072">the day.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="11080">First, let’s create a data set that represents a list of</st>
    <st c="11138">working periods:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: <st c="11610">Each item in the</st> `<st c="11628">data</st>` <st c="11632">array
    represents one employee’s working period.</st> <st c="11681">Notice that we don’t
    care about the item’s order—the Charts framework is responsible for ordering them
    correctly.</st> <st c="11795">However, we care about consistency with the employee’s
    name, so the Charts framework can also properly group</st> <st c="11904">the items.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="11914">Let’s see how we can build</st> <st c="11941">an interval chart
    based</st> <st c="11965">on</st> <st c="11969">that dataset:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: <st c="12114">In this code example, we create a BarMark initializer that includes
    new parameters—</st>`<st c="12198">xStart</st>`<st c="12205">, which represents
    the value where the interval begins,</st> `<st c="12261">xEnd</st>`<st c="12265">,
    detailing where it ends, and</st> `<st c="12296">y</st>`<st c="12297">, the</st>
    <st c="12303">employee’s name.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="12319">Now, let’s see how an interval chart looks when we run it (</st>*<st
    c="12379">Figure 9</st>**<st c="12388">.5</st>*<st c="12390">):</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.5: An interval chart](img/B21795_09_5.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: '<st c="12444">Figure 9.5: An interval chart</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="12473">In</st> *<st c="12477">Figure 9</st>**<st c="12485">.5</st>*<st
    c="12487">, we can see a timeline when each of the employees is represented in
    a row, and their working periods are interva</st><st c="12600">ls in this timeline.</st>
    <st c="12622">The interval bar chart is an excellent example of a component that
    can be complex to build from the ground up, and the Charts framework can simplify</st>
    <st c="12771">the process.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="12783">BarMark seems like a very flexible chart type, and that’s part
    of the reason it is so common.</st> <st c="12878">It allows us to present different
    information types, whether comparing values or different trends over time, in
    stacked, one-dimensional, or</st> <st c="13019">interval layouts.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="13036">However, sometimes, it’s a better choice</st> <st c="13077">to
    pick a more specific chart</st> <st c="13107">that expresses data</st> <st c="13128">more
    precisely.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="13143">So, let’s me</st><st c="13156">et the</st> <st c="13164">LineMark
    chart.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="13179">Creating LineMark charts</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="13204">One of the challenges of presenting data</st> <st c="13245">in
    a table is showing trends and patterns.</st> <st c="13289">Even though the BarMark
    chart type can do that better than a table, there are better ways to show trends,
    especially when dealing with a large amount</st> <st c="13439">of information.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="13454">To show trends and patterns more efficiently, we can use the LineMark
    chart, which represents data using a line representing a list of</st> <st c="13590">data
    points.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="13602">Let’s take, for example, a chart that shows phone sales over time.</st>
    <st c="13670">We create a structure named</st> `<st c="13698">SalesFigure</st>`
    <st c="13709">that contains information about the product type, the day of the
    sales, and the</st> <st c="13790">total amount:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: <st c="13915">Now that we have a structure, let’s create</st> <st c="13958">our
    dataset like we did in all</st> <st c="13990">previous examples:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: <st c="14450">The</st> `<st c="14455">salesFigures</st>` <st c="14467">variable
    contains information</st> <st c="14497">about four days of sales.</st> <st c="14524">The
    LineMark chart is suitable for working with many entries, but we use only four
    for</st> <st c="14611">demonstration purposes.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="14634">Now, let’s connect the</st> `<st c="14658">salesFigures</st>`
    <st c="14670">variable to a chart using the</st> `<st c="14701">LinkMark</st>`
    <st c="14709">view:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: <st c="14809">We created a LineMark inside the chart, setting the day as the</st>
    *<st c="14872">x</st>* <st c="14873">axis and the amount as the</st> *<st c="14901">y</st>*
    <st c="14902">axis.</st> <st c="14909">Running that code should show us a chart
    that looks like</st> *<st c="14966">Figure 9</st>**<st c="14974">.6</st>*<st c="14976">:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.6: A LineMark chart](img/B21795_09_6.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: '<st c="15010">Figure 9.6: A LineMark chart</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="15038">The chart in</st> *<st c="15052">Figure 9</st>**<st c="15060">.6</st>*
    <st c="15062">shows the declining trend of phone sales over the dataset period.</st>
    <st c="15129">What’s nice about line charts is that it’s easy to compare one LineMark
    to another.</st> <st c="15213">All we need to do is to update our dataset.</st>
    <st c="15257">So, let’s also add tablet sales to compare it with</st> <st c="15308">phone
    sales:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: <st c="15771">In this code example, we updated</st> <st c="15804">our dataset
    by adding tablet sales figures items to</st> <st c="15856">the array.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="15866">To make the chart distinct between the two product types, we use
    the</st> `<st c="15936">foregroundStyle</st>` <st c="15951">view modifier:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'let data: [FavoriteFruit] = ['
  prefs: []
  type: TYPE_NORMAL
- en: 'FavoriteFruit(name: "Apple", value: 30),'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'FavoriteFruit(name: "Banana", value: 25),'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'FavoriteFruit(name: "Orange", value: 20),'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'FavoriteFruit(name: "Strawberries", value: 15),'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'FavoriteFruit(name: "Grapes", value: 10)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ']'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Chart(data) {item in <st c="18384">SectorMark(angle: .value("Value", item.value))</st>
    .foregroundStyle(by: .value("Fruit",'
  prefs: []
  type: TYPE_NORMAL
- en: item.name))
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Chart(data) {item in
  prefs: []
  type: TYPE_NORMAL
- en: 'SectorMark(angle: .value("Value", item.value), <st c="19020">innerRadius: 50</st>)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '.foregroundStyle(by: .value("Fruit", item.name))'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Chart(salesFigures) { data in <st c="20522">AreaMark</st>(
  prefs: []
  type: TYPE_NORMAL
- en: 'x: .value("Date", data.day),'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'y: .value("Sales", data.amount)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '.foregroundStyle(by: .value("Product",'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: data.product))
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'struct StudentData: Identifiable {'
  prefs: []
  type: TYPE_NORMAL
- en: 'var id: UUID = UUID()'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'var hoursStudied: Double'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'var examScore: Double'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'let studentDataSet: [StudentData] = ['
  prefs: []
  type: TYPE_NORMAL
- en: 'StudentData(hoursStudied: 1.7, examScore: 61.8),'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'StudentData(hoursStudied: 7.9, examScore: 78.6),'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'StudentData(hoursStudied: 4.1, examScore: 44.3),'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'StudentData(hoursStudied: 4.7, examScore: 63.4),'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'StudentData(hoursStudied: 7.8, examScore: 90.4),'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'StudentData(hoursStudied: 8.6, examScore: 83.2),'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'StudentData(hoursStudied: 2.8, examScore: 29.7),'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'StudentData(hoursStudied: 6.3, examScore: 72.9),'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'StudentData(hoursStudied: 6.4, examScore: 73.8),'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'StudentData(hoursStudied: 6.1, examScore: 77.6)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Chart(studentDataSet) { <st c="22979">PointMark(x: .value("hours", $0.hoursStudied),</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="23025">y: .value("score", $0.examScore))</st> }'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Chart { <st c="24633">LinePlot</st>(x:"x", y:"y") { x in
  prefs: []
  type: TYPE_NORMAL
- en: return sin(x)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Chart { <st c="25162">AreaPlot</st>(x:"x", y:"y") { x in
  prefs: []
  type: TYPE_NORMAL
- en: return sin(x)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Chart(salesFigures){
  prefs: []
  type: TYPE_NORMAL
- en: LineMark(
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'x: .value("time", $0.day),'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'y: .value("amount", $0.amount)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '.foregroundStyle(by: .value("Product",'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: $0.product))
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '} <st c="28644">.chartOverlay { proxy in</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="28753">chartOverlay</st> view modifier in this code example.
  prefs: []
  type: TYPE_NORMAL
- en: <st c="28801">We can see that</st> `<st c="28818">chartOverlay</st>` <st c="28830">comes
    with a</st> `<st c="28844">proxy</st>` <st c="28849">variable, which is the</st>
    `<st c="28873">ChartProxy</st>` <st c="28883">component we</st> <st c="28897">discussed
    earlier.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<st c="28915">ChartOverlay</st>` <st c="28928">is not a view but a view modifier
    that lets us add new views to the chart.</st> <st c="29004">So, to recognize gestures
    and add a ruler, we can add a transparent view with a drag gesture and add a</st>
    <st c="29107">ruler view:</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: <st c="29420">In this code example, we added a</st> `<st c="29454">ZStack</st>`
    <st c="29460">view with a clear rectangle that covers the whole chart and, on
    top of it, a red ruler view.</st> <st c="29554">The ruler view</st> *<st c="29569">x</st>*
    <st c="29570">axis is a</st> <st c="29581">state variable:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: <st c="29629">We are going to change it according to the user’s</st> <st c="29680">tap
    locations.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="29694">Notice that we used our</st> `<st c="29719">proxy</st>` <st c="29724">object
    to determine</st> <st c="29744">the chart size for the ruler view.</st> <st c="29780">This
    is crucial proxy</st> <st c="29801">usage, as we will need it on other occasions,
    such as calculations for displaying different views in</st> <st c="29903">particular
    locations.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="29924">To see our view structure, look at</st> *<st c="29960">Figure
    9</st>**<st c="29968">.14</st>*<st c="29971">:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.14: Chart and chartOverlay structures](img/B21795_09_14.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: '<st c="29988">Figure 9.14: Chart and chartOverlay structures</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '*<st c="30034">Figure 9</st>**<st c="30043">.14</st>* <st c="30046">shows our
    chart view and the rectangle we added using the</st> `<st c="30105">chartOverlay</st>`
    <st c="30117">view modifier.</st> <st c="30133">We can also see that they are
    connected using the</st> <st c="30183">proxy object.</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="30196">Also, we added</st> <st c="30211">a drag gesture</st> <st c="30226">to
    the rectangle.</st> <st c="30245">Let’s see how to use it to change our ruler</st>
    <st c="30289">position accordingly.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="30310">Responding to the user’s gesture</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="30343">To respond to the user’s gesture</st> <st c="30376">and move the
    horizontal ruler to the closest data point, we need to implement the</st> `<st
    c="30459">onChanged</st>` <st c="30468">closure:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: <st c="30689">The</st> `<st c="30694">onChanged</st>` <st c="30703">closure
    implementation does</st> <st c="30732">three things:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="30745">First, it</st> *<st c="30756">finds the closest sales data point</st>*
    <st c="30790">according to the tap location and the proxy.</st> <st c="30836">We
    will go over the</st> `<st c="30856">getClosestDateForLocation</st>` <st c="30881">function
    in</st> <st c="30894">a minute.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="30903">After we found the closest sales data point according to the tap
    location, we used the proxy object to</st> *<st c="31007">retrieve its position</st>*
    <st c="31028">on the chart.</st> <st c="31043">One of the proxy’s capabilities
    is to convert data points to position and</st> <st c="31117">vice versa.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="31128">When we have the position of the closest data point, we adjust
    the ruler location by setting the</st> `<st c="31226">markerX</st>` <st c="31233">state
    variable.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="31249">This piece of code is a good</st> <st c="31278">demonstration
    of what we can do with the</st> <st c="31320">proxy object.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="31333">For more proxy object usage, let’s see the</st> `<st c="31377">getClosestDateForLocation</st>`
    <st c="31402">function.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="31412">Finding the closest data point to the user’s touch</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="31463">The</st> `<st c="31468">getClosestDateForLocation</st>` <st c="31493">function
    goal</st> <st c="31507">is to find the closest date with a data point according
    to a</st> <st c="31569">specific position.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="31587">The function receives two parameters – the position (</st>`<st
    c="31641">CGFloat</st>`<st c="31649">) and the</st> <st c="31660">proxy object:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: <st c="32079">Remember what our chart looks like – the</st> *<st c="32121">y</st>*
    <st c="32122">axis represents the timeline, and the</st> *<st c="32161">x</st>*
    <st c="32162">axis represents the total sales on a</st> <st c="32200">specific
    date.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="32214">So, we can use the proxy object to find the date for a specific</st>
    `<st c="32279">x</st>` <st c="32280">value, and that’s our</st> <st c="32303">first
    step:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: <st c="32359">The proxy’s</st> `<st c="32371">value(atX:)</st>` <st c="32382">function
    calculates the date value for a specific</st> `<st c="32433">x</st>` <st c="32434">value.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="32441">However, the returned value is arbitrary; to locate the closest
    data point, we must iterate through our dataset and search for the nearest</st>
    `<st c="32581">SalesFigure</st>` <st c="32592">object.</st> <st c="32601">Once
    identified, the function can then</st> <st c="32640">return it.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="32650">Even though allowing user interaction</st> <st c="32688">with
    charts is not complex, it includes interesting view modifiers and objects that
    enable us to access the chart data, perform calculations, and display overlay
    UI components.</st> <st c="32866">We don’t have to use the</st> `<st c="32891">proxy</st>`
    <st c="32896">object and the</st> `<st c="32912">chartOverlay</st>` <st c="32924">view
    modifier just for interaction—we can show additional information, improve the
    chart design, and, in rare cases, even create</st> <st c="33054">our chart.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="33064">Until now, we used data sets with foundation types –</st> `<st
    c="33118">String</st>`<st c="33124">,</st> `<st c="33126">Double</st>`<st c="33132">,
    and</st> `<st c="33138">Date</st>`<st c="33142">. However, when we look at the
    Swift Charts framework headers, we see</st> <st c="33212">something interesting:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: <st c="33415">It seems that the different chart functions</st> <st c="33458">only
    work with types that conform to the</st> `<st c="33500">Plottable</st>` <st c="33509">protocol.</st>
    <st c="33520">Let’s find out what</st> <st c="33540">that is.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="33548">Conforming to the Plottable protocol</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="33585">Until now, we have been under the assumption</st> <st c="33630">that
    any data set we threw on our charts would work.</st> <st c="33684">However, we
    saw that the proxy object can perform interesting calculations that are not possible
    with any data, and that’s only one reason why our data types need to support the
    ability to be drawn in</st> <st c="33885">a chart.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="33893">Therefore, the Swift Charts framework only works with data types
    that conform to the</st> `<st c="33979">Plottable</st>` <st c="33988">protocol,
    which allows data to be drawn in</st> <st c="34032">a chart.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="34040">First, every primitive data type already conforms to the</st>
    `<st c="34098">Plottable</st>` <st c="34107">protocol.</st> <st c="34118">Also,
    the</st> `<st c="34128">Date</st>` <st c="34132">class that we used in our last
    example conforms to the</st> `<st c="34188">Plottable</st>` <st c="34197">protocol.</st>
    <st c="34208">We can even see that in the apple</st> <st c="34242">header files:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: <st c="34367">However, working only with primitive or Foundation types is not</st>
    <st c="34432">always practical.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="34449">Let’s take, for example, our</st> `<st c="34479">Sales</st>` <st
    c="34484">structure from the</st> *<st c="34504">Adding Stacked</st>* *<st c="34519">Marks</st>*
    <st c="34524">section:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: <st c="34648">Declaring the</st> `<st c="34662">itemType</st>` <st c="34670">property
    as a string</st> <st c="34691">is not always a best practice.</st> <st c="34723">Typically,
    types are part of a closed list, and using strings may lead to typos and duplicates.</st>
    <st c="34819">We probably would like to use an enum for that, as it</st> <st c="34872">is
    more suitable for handling a list</st> <st c="34910">of types:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: <st c="35098">In this example, we created a</st> `<st c="35129">FruitType</st>`
    <st c="35138">enum to replace the</st> `<st c="35159">itemType</st>` <st c="35167">type</st>
    <st c="35173">from</st> `<st c="35178">String</st>`<st c="35184">.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="35185">Our next step is to make the</st> `<st c="35215">FruitType</st>`
    <st c="35224">enum conform</st> <st c="35238">to</st> `<st c="35241">Plottable</st>`<st
    c="35250">:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: <st c="35332">In this example, we used the</st> `<st c="35362">primitivePlottable</st>`
    <st c="35380">variable getter to return the type’s primitive value.</st> <st c="35435">That
    would make the</st> `<st c="35455">FruitType</st>` <st c="35464">type eligible
    to be used</st> <st c="35490">inside Charts.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="35504">Even though not every type can be used</st> <st c="35543">inside
    a chart, we can easily make them eligible for that.</st> <st c="35603">Conforming
    to the</st> `<st c="35621">Plottable</st>` <st c="35630">protocol is simple and
    straightforward and allows us to use our custom-made types</st> <st c="35713">within
    charts.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="35727">Summary</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="35735">The Swift Charts framework is exciting.</st> <st c="35776">It
    allows us to create amazing-looking charts using a simple data set, making it
    much easier to display data insights, trends,</st> <st c="35903">and comparisons.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="35919">This chapter reviewed the different chart types of the Swift Charts
    framework, including BarMark, LineMark, SectorMark, AreaMark,</st> <st c="36050">and
    PointMark.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="36064">We also discussed each chart’s different usage and goals, learned
    how to customize them, and added user interaction to add more capabilities.</st>
    <st c="36207">At last, we went over the</st> `<st c="36233">Plottable</st>` <st
    c="36242">protocol, which allows our charts to use almost any data type we want.</st>
    <st c="36314">By now, we should be able to implement charts in our</st> <st c="36367">apps
    quickly.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="36380">Our next chapter includes an advanced yet very powerful topic
    –</st> <st c="36445">Swift macros.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="0">Part 2: Refine your iOS Development with Advanced Techniques</st>'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="61">In this part, you will step up your iOS development and explore advanced
    topics, such as Swift macros, testing, Combine, architectures,</st> **<st c="198">machine
    learning</st>** <st c="214">(</st>**<st c="216">ML</st>**<st c="218">), and AI.</st>
    <st c="230">This part is a must-read if you want to get the most from</st> <st
    c="288">iOS 18.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="295">This section contains the</st> <st c="322">following chapters:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[*<st c="341">Chapter 10</st>*](B21795_10.xhtml#_idTextAnchor329)<st c="352">,</st>
    *<st c="354">Swift Macros</st>*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*<st c="367">Chapter 11</st>*](B21795_11.xhtml#_idTextAnchor346)<st c="377">,</st>
    *<st c="379">Creating Pipelines with Combine</st>*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*<st c="411">Chapter 12</st>*](B21795_12.xhtml#_idTextAnchor369)<st c="421">,</st>
    *<st c="423">Being Smart with Apple Intelligence and ML</st>*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*<st c="466">Chapter 13</st>*](B21795_13.xhtml#_idTextAnchor401)<st c="476">,</st>
    *<st c="478">Exposing Your App to Siri with App Intents</st>*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*<st c="521">Chapter 14</st>*](B21795_14.xhtml#_idTextAnchor430)<st c="531">,</st>
    *<st c="533">Improving the App Quality with Swift Testing</st>*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*<st c="577">Chapter 15</st>*](B21795_15.xhtml#_idTextAnchor463)<st c="588">,</st>
    *<st c="590">Exploring Architectures for iOS</st>*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
