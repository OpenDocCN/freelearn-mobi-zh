["```swift\nimport GameplayKit\nclass GameEntity : GKEntity\n```", "```swift\nWWDC15 conference, in both Objective-C and Swift, showing how we'd create entities, components, and component systems in our projects:\n```", "```swift\n//Objective-C\n/* Make our archer */\nGKEntity *archer = [GKEntity entity];\n/* Archers can move, shoot, be targeted */\n[archer addComponent: [MoveComponent component]];\n[archer addComponent: [ShootComponent component]];\n[archer addComponent: [TargetComponent component]];\n/* Create MoveComponentSystem */\nGKComponentSystem *moveSystem =\n          [GKComponentSystem systemWithComponentClass:MoveComponent.class];\n/* Add archer's MoveComponent to the system */\n[moveSystem addComponent: [archer componentForClass:MoveComponent.class]];\n\n//Swift\n/* Make our archer */\nlet archer = GKEntity()\n/* Archers can move, shoot, be targeted */\nlet moveComponent = MoveComponent()\nlet shootComponent = ShootComponent()\nlet targetComponent = TargetComponent()\n\narcher.addComponent(moveComponent)\narcher.addComponent(shootComponent)\narcher.addComponent(targetComponent)\n\n/* Create MoveComponentSystem */\nlet moveComponentSystem = GKComponentSystem(componentClass: MoveComponent.self)\n\n/* Add archer's MoveComponent to the system */   moveComponentSystem.addComponent(archer.componentForClass(MoveComponent.self)!)\n```", "```swift\noverride func isValidNextState(stateClass: AnyClass) -> Bool {\n        switch stateClass {\n            case is FlyingBotPreAttackState.Type, is GroundBotRotateToAttackState.Type, is TaskBotZappedState.Type:\n                return true\n            default:\n                return false\n        }\n    }\n```", "```swift\nGKState objects to them:\n```", "```swift\n/* Make some states - Chase, Flee, Defeated, Respawn */\nlet chase = ChaseState()\nlet flee  = FleeState()\nlet defeated = DefeatedState()\nlet respawn  = RespawnState()\n/* Create a state machine */\nlet stateMachine = GKStateMachine(states: [chase,flee,defeated,respawn])\n/* Enter our initial state - Chase */\nstateMachine.enterState(chase.classForCoder)\n```", "```swift\nfunc agentWillUpdate(agent:GKAgent)\n{\n   /* Position the agent to match our sprite */\n    agent.position = self.position\n    agent.rotation = self.zRotation\n}\nfunc agentDidUpdate(agent:GKAgent)\n{\n   /* Position the sprite to match our agent */\n    self.position = agent.position\n    self.zRotation = agent.zRotation\n}\n```", "```swift\nTaskBotBehavior.swift class, which is a child of GKBehavior:\n```", "```swift\n//(1)\nlet separationGoal = GKGoal(toSeparateFromAgents: agentsToFlockWith, maxDistance: \nGameplayConfiguration.Flocking.separationRadius, maxAngle: GameplayConfiguration.Flocking.separationAngle)\n//(2)\nbehavior.setWeight(GameplayConfiguration.Flocking.separationWeight, forGoal: separationGoal)\n```", "```swift\n//Objective-C\n/* Make some goals, we want to seek the enemy, avoid obstacles, target speed */\nGKGoal *seek = [GKGoal goalToSeekAgent:enemyAgent];\nGKGoal *avoid = [GKGoal goalToAvoidObstacles:obstacles];\nGKGoal *targetSpeed = [GKGoal goalToReachTargetSpeed:50.0f];\n/* Combine goals into behavior */\nGKBehavior *behavior = [GKBehavior behaviorWithGoals:@[seek,avoid,targetSpeed]\n  andWeights:@[@1.0,@5.0,@0.5]];\n/* Make an agent - add the behavior to it */\nGKAgent2D *agent = [[GKAgent2D* alloc] init];\nagent.behavior = behavior;\n\n//Swift\n/* Make some goals, we want to seek the enemy, avoid obstacles, target speed */\nlet seek  = GKGoal(toSeekAgent: enemyAgent)\nlet avoid = GKGoal(toAvoidObstacles: obstacles, maxPredictionTime: 0.5)\nlet targetSpeed = GKGoal(toReachTargetSpeed: 50.0)\n/* Combine goals into behavior */\nlet behavior = GKBehavior(goals: [seek, avoid, targetSpeed], andWeights: [1.0, 5.0, 0.5])\n/* Make an agent - add the behavior to it */\nlet agent = GKAgent2D()\nagent.behavior = behavior\n```", "```swift\n/* Make an obstacle - a simple square */\nvector_float2 points[] = {{400,400}, {500,400}, {500,500}, {400,500}};\nGKPolygonObstacle *obstacle = [[GKPolygonObstacle alloc] initWithPoints:points count:4];\n/* Make an obstacle graph */\nGKObstacleGraph *graph = [GKObstacleGraph graphWithObstacles:@[obstacle] bufferRadius:10.0f];\n/* Make nodes for hero position and destination */\nGKGraphNode2D *startNode = [GKGraphNode2D nodeWithPoint:hero.position];\nGKGraphNode2D *endNode = [GKGraphNode2D nodeWithPoint:goalPosition];\n/* Connect start and end node to graph */\n[graph connectNodeUsingObstacles:startNode];\n[graph connectNodeUsingObstacles:endNode];\n/* Find path from start to end */\nNSArray *path = [graph findPathFromNode:startNode toNode:endNode];\n```", "```swift\nGKObstacleGraph by first manually creating 2D vector points in the points array and initializing the GKObstacleGraph object and graph with those points. Next, the two GKGraphNode2D objects are created to represent the start and end nodes for a hero character in the game. Then, finally, the optimal path for that hero character is created and stored into the array automatically; that is, a path using the graph's findpathFromNode: and toNode: parameters using the startNode and endNode objects, respectively. This path object can then be used in our hero's movement component or may be a map visual component to move to or indicate to the player the correct path needed to traverse the game stage's obstacles.\n```", "```swift\nlazy var graph: GKObstacleGraph = GKObstacleGraph(obstacles: self.polygonObstacles, bufferRadius: GameplayConfiguration.TaskBot.pathfindingGraphBufferRadius)\n\nlazy var obstacleSpriteNodes: [SKSpriteNode] = self[\"world/obstacles/*\"] as! [SKSpriteNode]\n/*the above line casts the obstacles in our project's \"world/obstacles/\" folder path as an implicitly unwrapped array of SKSpriteNodes\n*/\n\nlazy var polygonObstacles: [GKPolygonObstacle] = SKNode.obstaclesFromNodePhysicsBodies(self.obstacleSpriteNodes)\n```", "```swift\n/* ChessGameModel implements GKGameModel */\nChessGameModel *chessGameModel = [ChessGameModel new];\nGKMinmaxStrategist *minmax = [GKMinmaxStrategist new];\nminmax.gameModel = chessGameModel;\nminmax.maxLookAheadDepth = 6;\n/* Find the best move for the active player */\nChessGameUpdate *chessGameUpdate =\n            [minmax bestMoveForPlayer:chessGameModel.activePlayer];\n/* Apply update to the game model */\n[chessGameModel applyGameModelUpdate:chessGameUpdate];\n```", "```swift\n/* Create a six-sided die with its own random source */\nlet d6 = GKRandomDistribution.d6()\n/* Get die value between 1 and 6 */\nlet choice = d6.nextInt()\n/* Create a custom 256-sided die with its own random source */\nlet d256 = GKRandomDistribution.die(lowest:1, highest:256)\n/* Get die value between 1 and 256 */\nlet choice = d256.nextInt()\n/* Create a twenty-sided die with a bell curve bias */\nlet d20 = GKGaussianDistribution.d20()\n/* Get die value between 1 and 20 that is most likely to be around 11 */\nlet choice = d20.nextInt()\n/* Create a twenty-sided die with no clustered values â€” fair random */\nlet d20 = GKShuffledDistribution.d20()\n/* Get die value between 1 and 20 */\nlet choice = d20.nextInt()\n/* Get another die value that is not the same as 'choice' */\nlet secondChoice = d20.nextInt()\n\n/* Make a deck of cards */\nvar deck = [Ace, King, Queen, Jack, Ten]\n/* Shuffle them */\ndeck = GKRandomSource.sharedRandom().shuffle(deck)\n/* possible result - [Jack, King, Ten, Queen, Ace] */\n/* Get a random card from the deck */\nlet card = deck[0]\n```", "```swift\nif (car.distance < 5) {\n  car.slowDown()\n}\nelse if (car.distance >= 5) {\n  car.speedUp()\n}\n```", "```swift\n/* Make a rule system */\nGKRuleSystem* sys = [[GKRuleSystem alloc] init];\n/* Getting distance and asserting facts */\nfloat distance = sys.state[@\"distance\"];\n[sys assertFact:@\"close\" grade:1.0f - distance / kBrakingDistance];\n[sys assertFact:@\"far\" grade:distance / kBrakingDistance];\n/* Grade our facts - farness and closeness */\nfloat farness = [sys gradeForFact@\"far\"];\nfloat closeness = [sys gradeForFact@\"close\"];\n/* Derive Fuzzy acceleration */\nfloat fuzzyAcceleration = farness - closeness;\n[car applyAcceleration:fuzzyAcceleration withDeltaTime:seconds];\n```"]